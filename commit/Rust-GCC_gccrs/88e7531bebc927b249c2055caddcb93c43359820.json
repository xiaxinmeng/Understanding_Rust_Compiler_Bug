{"sha": "88e7531bebc927b249c2055caddcb93c43359820", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhlNzUzMWJlYmM5MjdiMjQ5YzIwNTVjYWRkY2I5M2M0MzM1OTgyMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T09:29:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-05-15T09:29:46Z"}, "message": "[multiple changes]\n\n2012-05-15  Robert Dewar  <dewar@adacore.com>\n\n\t* g-comlin.adb, g-comlin.ads: Minor reformatting.\n\n2012-05-15  Vincent Pucci  <pucci@adacore.com>\n\n\t* aspects.adb, aspects.adb: Reordering of the Aspect_Idi list. New\n\taspect Aspect_Lock_Free.\n\t* einfo.adb, einfo.ads: New flag Uses_Lock_Free (flag 188).\n\t(Set_Uses_Lock_Free): New routine.\n\t(Uses_Lock_Free): New routine.\n\t* exp_ch7.adb (Is_Simple_Protected_Type): Return False for\n\tlock-free implementation.\n\t* exp_ch9.adb (Allows_Lock_Free_Implementation): Moved to Sem_Ch9.\n\t(Build_Lock_Free_Unprotected_Subprogram_Body): Protected\n\tprocedure uses __sync_synchronise. Check both Object_Size\n\tand Value_Size.\n\t(Expand_N_Protected_Body): Lock_Free_Active\n\trenames Lock_Free_On.\n\t(Expand_N_Protected_Type_Declaration):\n\t_Object field removed for lock-free implementation.\n\t(Install_Private_Data_Declarations): Protection object removed\n\tfor lock-free implementation.\n\t(Make_Initialize_Protection):\n\tProtection object initialization removed for lock-free implementation.\n\t* rtsfind.ads: RE_Atomic_Synchronize and RE_Relaxed added.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Aspect_Lock_Free\n\tanalysis added.\n\t* sem_ch9.adb (Allows_Lock_Free_Implementation): New routine.\n\t(Analyze_Protected_Body): Allows_Lock_Free_Implementation call added.\n\t(Analyze_Protected_Type_Declaration):\n\tAllows_Lock_Free_Implementation call added.\n\t(Analyze_Single_Protected_Declaration): Second analysis of\n\taspects removed.\n\t* s-atopri.ads: Header added.\n\t(Atomic_Synchronize): New routine.\n\n2012-05-15  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch7.ads: Add comment.\n\nFrom-SVN: r187505", "tree": {"sha": "4a1bddd2f4929ab05a86932cff22860124f1fb69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a1bddd2f4929ab05a86932cff22860124f1fb69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88e7531bebc927b249c2055caddcb93c43359820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e7531bebc927b249c2055caddcb93c43359820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88e7531bebc927b249c2055caddcb93c43359820", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88e7531bebc927b249c2055caddcb93c43359820/comments", "author": null, "committer": null, "parents": [{"sha": "db664118be5bc2ea3e04784d45da659b13af1ef8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db664118be5bc2ea3e04784d45da659b13af1ef8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db664118be5bc2ea3e04784d45da659b13af1ef8"}], "stats": {"total": 1570, "additions": 942, "deletions": 628}, "files": [{"sha": "9f31c7543f9a6f9eb9974a9e6775d3ce4eb3ff90", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -1,3 +1,44 @@\n+2012-05-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* g-comlin.adb, g-comlin.ads: Minor reformatting.\n+\n+2012-05-15  Vincent Pucci  <pucci@adacore.com>\n+\n+\t* aspects.adb, aspects.adb: Reordering of the Aspect_Idi list. New\n+\taspect Aspect_Lock_Free.\n+\t* einfo.adb, einfo.ads: New flag Uses_Lock_Free (flag 188).\n+\t(Set_Uses_Lock_Free): New routine.\n+\t(Uses_Lock_Free): New routine.\n+\t* exp_ch7.adb (Is_Simple_Protected_Type): Return False for\n+\tlock-free implementation.\n+\t* exp_ch9.adb (Allows_Lock_Free_Implementation): Moved to Sem_Ch9.\n+\t(Build_Lock_Free_Unprotected_Subprogram_Body): Protected\n+\tprocedure uses __sync_synchronise. Check both Object_Size\n+\tand Value_Size.\n+\t(Expand_N_Protected_Body): Lock_Free_Active\n+\trenames Lock_Free_On.\n+\t(Expand_N_Protected_Type_Declaration):\n+\t_Object field removed for lock-free implementation.\n+\t(Install_Private_Data_Declarations): Protection object removed\n+\tfor lock-free implementation.\n+\t(Make_Initialize_Protection):\n+\tProtection object initialization removed for lock-free implementation.\n+\t* rtsfind.ads: RE_Atomic_Synchronize and RE_Relaxed added.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Aspect_Lock_Free\n+\tanalysis added.\n+\t* sem_ch9.adb (Allows_Lock_Free_Implementation): New routine.\n+\t(Analyze_Protected_Body): Allows_Lock_Free_Implementation call added.\n+\t(Analyze_Protected_Type_Declaration):\n+\tAllows_Lock_Free_Implementation call added.\n+\t(Analyze_Single_Protected_Declaration): Second analysis of\n+\taspects removed.\n+\t* s-atopri.ads: Header added.\n+\t(Atomic_Synchronize): New routine.\n+\n+2012-05-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch7.ads: Add comment.\n+\n 2012-05-15  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* a-calend.adb (Day_Of_Week): The routine once again treats"}, {"sha": "86e70917d1671f0f0cc2edc1debf20a2d641416f", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -242,11 +242,13 @@ package body Aspects is\n     Aspect_Ada_2012                     => Aspect_Ada_2005,\n     Aspect_Address                      => Aspect_Address,\n     Aspect_Alignment                    => Aspect_Alignment,\n+    Aspect_All_Calls_Remote             => Aspect_All_Calls_Remote,\n     Aspect_Asynchronous                 => Aspect_Asynchronous,\n     Aspect_Atomic                       => Aspect_Atomic,\n     Aspect_Atomic_Components            => Aspect_Atomic_Components,\n     Aspect_Attach_Handler               => Aspect_Attach_Handler,\n     Aspect_Bit_Order                    => Aspect_Bit_Order,\n+    Aspect_Compiler_Unit                => Aspect_Compiler_Unit,\n     Aspect_Component_Size               => Aspect_Component_Size,\n     Aspect_Constant_Indexing            => Aspect_Constant_Indexing,\n     Aspect_Contract_Case                => Aspect_Contract_Case,\n@@ -259,31 +261,20 @@ package body Aspects is\n     Aspect_Discard_Names                => Aspect_Discard_Names,\n     Aspect_Dispatching_Domain           => Aspect_Dispatching_Domain,\n     Aspect_Dynamic_Predicate            => Aspect_Predicate,\n+    Aspect_Elaborate_Body               => Aspect_Elaborate_Body,\n     Aspect_External_Tag                 => Aspect_External_Tag,\n     Aspect_Favor_Top_Level              => Aspect_Favor_Top_Level,\n     Aspect_Implicit_Dereference         => Aspect_Implicit_Dereference,\n     Aspect_Independent                  => Aspect_Independent,\n     Aspect_Independent_Components       => Aspect_Independent_Components,\n     Aspect_Inline                       => Aspect_Inline,\n     Aspect_Inline_Always                => Aspect_Inline,\n+    Aspect_Input                        => Aspect_Input,\n     Aspect_Interrupt_Handler            => Aspect_Interrupt_Handler,\n     Aspect_Interrupt_Priority           => Aspect_Interrupt_Priority,\n-    Aspect_Iterator_Element             => Aspect_Iterator_Element,\n-    Aspect_All_Calls_Remote             => Aspect_All_Calls_Remote,\n-    Aspect_Compiler_Unit                => Aspect_Compiler_Unit,\n-    Aspect_Elaborate_Body               => Aspect_Elaborate_Body,\n-    Aspect_Preelaborate                 => Aspect_Preelaborate,\n-    Aspect_Preelaborate_05              => Aspect_Preelaborate_05,\n-    Aspect_Pure                         => Aspect_Pure,\n-    Aspect_Pure_05                      => Aspect_Pure_05,\n-    Aspect_Pure_12                      => Aspect_Pure_12,\n-    Aspect_Remote_Call_Interface        => Aspect_Remote_Call_Interface,\n-    Aspect_Remote_Types                 => Aspect_Remote_Types,\n-    Aspect_Scalar_Storage_Order         => Aspect_Scalar_Storage_Order,\n-    Aspect_Shared_Passive               => Aspect_Shared_Passive,\n-    Aspect_Universal_Data               => Aspect_Universal_Data,\n-    Aspect_Input                        => Aspect_Input,\n     Aspect_Invariant                    => Aspect_Invariant,\n+    Aspect_Iterator_Element             => Aspect_Iterator_Element,\n+    Aspect_Lock_Free                    => Aspect_Lock_Free,\n     Aspect_Machine_Radix                => Aspect_Machine_Radix,\n     Aspect_No_Return                    => Aspect_No_Return,\n     Aspect_Object_Size                  => Aspect_Object_Size,\n@@ -295,12 +286,21 @@ package body Aspects is\n     Aspect_Pre                          => Aspect_Pre,\n     Aspect_Precondition                 => Aspect_Pre,\n     Aspect_Predicate                    => Aspect_Predicate,\n+    Aspect_Preelaborate                 => Aspect_Preelaborate,\n+    Aspect_Preelaborate_05              => Aspect_Preelaborate_05,\n     Aspect_Preelaborable_Initialization => Aspect_Preelaborable_Initialization,\n     Aspect_Priority                     => Aspect_Priority,\n+    Aspect_Pure                         => Aspect_Pure,\n+    Aspect_Pure_05                      => Aspect_Pure_05,\n+    Aspect_Pure_12                      => Aspect_Pure_12,\n     Aspect_Pure_Function                => Aspect_Pure_Function,\n     Aspect_Remote_Access_Type           => Aspect_Remote_Access_Type,\n+    Aspect_Remote_Call_Interface        => Aspect_Remote_Call_Interface,\n+    Aspect_Remote_Types                 => Aspect_Remote_Types,\n     Aspect_Read                         => Aspect_Read,\n+    Aspect_Scalar_Storage_Order         => Aspect_Scalar_Storage_Order,\n     Aspect_Shared                       => Aspect_Atomic,\n+    Aspect_Shared_Passive               => Aspect_Shared_Passive,\n     Aspect_Simple_Storage_Pool          => Aspect_Simple_Storage_Pool,\n     Aspect_Simple_Storage_Pool_Type     => Aspect_Simple_Storage_Pool_Type,\n     Aspect_Size                         => Aspect_Size,\n@@ -316,6 +316,7 @@ package body Aspects is\n     Aspect_Type_Invariant               => Aspect_Invariant,\n     Aspect_Unchecked_Union              => Aspect_Unchecked_Union,\n     Aspect_Universal_Aliasing           => Aspect_Universal_Aliasing,\n+    Aspect_Universal_Data               => Aspect_Universal_Data,\n     Aspect_Unmodified                   => Aspect_Unmodified,\n     Aspect_Unreferenced                 => Aspect_Unreferenced,\n     Aspect_Unreferenced_Objects         => Aspect_Unreferenced_Objects,"}, {"sha": "523412bd0e836e8a6318f17754d3d6b26db2a369", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -142,7 +142,12 @@ package Aspects is\n       Aspect_Unreferenced,                  -- GNAT\n       Aspect_Unreferenced_Objects,          -- GNAT\n       Aspect_Volatile,\n-      Aspect_Volatile_Components);\n+      Aspect_Volatile_Components,\n+\n+      --  Aspects that have a static boolean value but don't correspond to\n+      --  pragmas\n+\n+      Aspect_Lock_Free);\n \n    --  The following array indicates aspects that accept 'Class\n \n@@ -182,6 +187,7 @@ package Aspects is\n                              Aspect_Dimension_System         => True,\n                              Aspect_Favor_Top_Level          => True,\n                              Aspect_Inline_Always            => True,\n+                             Aspect_Lock_Free                => True,\n                              Aspect_Object_Size              => True,\n                              Aspect_Persistent_BSS           => True,\n                              Aspect_Predicate                => True,\n@@ -352,6 +358,7 @@ package Aspects is\n      Aspect_Interrupt_Priority           => Name_Interrupt_Priority,\n      Aspect_Invariant                    => Name_Invariant,\n      Aspect_Iterator_Element             => Name_Iterator_Element,\n+     Aspect_Lock_Free                    => Name_Lock_Free,\n      Aspect_Machine_Radix                => Name_Machine_Radix,\n      Aspect_No_Return                    => Name_No_Return,\n      Aspect_Object_Size                  => Name_Object_Size,"}, {"sha": "b7ffe58fd59f4b6abc16187ac0b413328c99f220", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -452,6 +452,7 @@ package body Einfo is\n    --    Is_Ada_2005_Only                Flag185\n    --    Is_Interface                    Flag186\n    --    Has_Constrained_Partial_View    Flag187\n+   --    Uses_Lock_Free                  Flag188\n    --    Is_Pure_Unit_Access_Type        Flag189\n    --    Has_Specified_Stream_Input      Flag190\n \n@@ -525,7 +526,6 @@ package body Einfo is\n    --    Has_Anonymous_Master            Flag253\n    --    Is_Implementation_Defined       Flag254\n \n-   --    (unused)                        Flag188\n    --    (unused)                        Flag201\n \n    -----------------------\n@@ -2794,6 +2794,12 @@ package body Einfo is\n       return Flag222 (Id);\n    end Used_As_Generic_Actual;\n \n+   function Uses_Lock_Free (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Protected_Type (Id));\n+      return Flag188 (Id);\n+   end Uses_Lock_Free;\n+\n    function Uses_Sec_Stack (Id : E) return B is\n    begin\n       return Flag95 (Id);\n@@ -5358,16 +5364,22 @@ package body Einfo is\n       Set_Node16 (Id, V);\n    end Set_Unset_Reference;\n \n-   procedure Set_Uses_Sec_Stack (Id : E; V : B := True) is\n-   begin\n-      Set_Flag95 (Id, V);\n-   end Set_Uses_Sec_Stack;\n-\n    procedure Set_Used_As_Generic_Actual (Id : E; V : B := True) is\n    begin\n       Set_Flag222 (Id, V);\n    end Set_Used_As_Generic_Actual;\n \n+   procedure Set_Uses_Lock_Free (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Protected_Type);\n+      Set_Flag188 (Id, V);\n+   end Set_Uses_Lock_Free;\n+\n+   procedure Set_Uses_Sec_Stack (Id : E; V : B := True) is\n+   begin\n+      Set_Flag95 (Id, V);\n+   end Set_Uses_Sec_Stack;\n+\n    procedure Set_Warnings_Off (Id : E; V : B := True) is\n    begin\n       Set_Flag96 (Id, V);"}, {"sha": "01037a5c0052e64329a6cc6fd0e30a7cd9aacfb6", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -3878,6 +3878,12 @@ package Einfo is\n --       Present in all entities, set if the entity is used as an argument to\n --       a generic instantiation. Used to tune certain warning messages.\n \n+--    Uses_Lock_Free (Flag188)\n+--       Present in protected type entities. Set to True when the Lock Free\n+--       implementation is used for the protected type. This implemenatation is\n+--       based on atomic transactions and doesn't require anymore the use of\n+--       Protection object (see System.Tasking.Protected_Objects).\n+\n --    Uses_Sec_Stack (Flag95)\n --       Present in scope entities (blocks,functions, procedures, tasks,\n --       entries). Set to True when secondary stack is used in this scope and\n@@ -5601,6 +5607,7 @@ package Einfo is\n    --    Stored_Constraint                   (Elist23)\n    --    Has_Interrupt_Handler               (synth)\n    --    Sec_Stack_Needed_For_Return         (Flag167)  ???\n+   --    Uses_Lock_Free                      (Flag188)\n    --    Uses_Sec_Stack                      (Flag95)   ???\n    --    Has_Entries                         (synth)\n    --    Number_Entries                      (synth)\n@@ -6405,6 +6412,7 @@ package Einfo is\n    function Universal_Aliasing                  (Id : E) return B;\n    function Unset_Reference                     (Id : E) return N;\n    function Used_As_Generic_Actual              (Id : E) return B;\n+   function Uses_Lock_Free                      (Id : E) return B;\n    function Uses_Sec_Stack                      (Id : E) return B;\n    function Vax_Float                           (Id : E) return B;\n    function Warnings_Off                        (Id : E) return B;\n@@ -7001,6 +7009,7 @@ package Einfo is\n    procedure Set_Universal_Aliasing              (Id : E; V : B := True);\n    procedure Set_Unset_Reference                 (Id : E; V : N);\n    procedure Set_Used_As_Generic_Actual          (Id : E; V : B := True);\n+   procedure Set_Uses_Lock_Free                  (Id : E; V : B := True);\n    procedure Set_Uses_Sec_Stack                  (Id : E; V : B := True);\n    procedure Set_Warnings_Off                    (Id : E; V : B := True);\n    procedure Set_Warnings_Off_Used               (Id : E; V : B := True);\n@@ -7746,6 +7755,7 @@ package Einfo is\n    pragma Inline (Universal_Aliasing);\n    pragma Inline (Unset_Reference);\n    pragma Inline (Used_As_Generic_Actual);\n+   pragma Inline (Uses_Lock_Free);\n    pragma Inline (Uses_Sec_Stack);\n    pragma Inline (Warnings_Off);\n    pragma Inline (Warnings_Off_Used);\n@@ -8148,6 +8158,7 @@ package Einfo is\n    pragma Inline (Set_Universal_Aliasing);\n    pragma Inline (Set_Unset_Reference);\n    pragma Inline (Set_Used_As_Generic_Actual);\n+   pragma Inline (Set_Uses_Lock_Free);\n    pragma Inline (Set_Uses_Sec_Stack);\n    pragma Inline (Set_Warnings_Off);\n    pragma Inline (Set_Warnings_Off_Used);"}, {"sha": "238469ce79cb80dbef7e9e619b17b2df164e60f0", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -4602,6 +4602,7 @@ package body Exp_Ch7 is\n    begin\n       return\n         Is_Protected_Type (T)\n+          and then not Uses_Lock_Free (T)\n           and then not Has_Entries (T)\n           and then Is_RTE (Find_Protection_Type (T), RE_Protection);\n    end Is_Simple_Protected_Type;"}, {"sha": "244936c7e16bfb5bb3b85c33fbab4bdb4d3e0cb2", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -272,6 +272,8 @@ package Exp_Ch7 is\n    function Is_Simple_Protected_Type (T : Entity_Id) return Boolean;\n    --  Determine whether T denotes a protected type without entires whose\n    --  _object field is of type System.Tasking.Protected_Objects.Protection.\n+   --  Something wrong here, implementation was changed to test Lock_Free\n+   --  but this spec does not mention that ???\n \n    --------------------------------\n    -- Transient Scope Management --"}, {"sha": "1f9f45890f20cd58ee46afcdea8086e79c7dc0d3", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 344, "deletions": 546, "changes": 890, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -25,7 +25,6 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -52,6 +51,7 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch9;  use Sem_Ch9;\n with Sem_Ch11; use Sem_Ch11;\n with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n@@ -61,7 +61,6 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n-with Table;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n@@ -77,37 +76,6 @@ package body Exp_Ch9 is\n \n    Entry_Family_Bound : constant Int := 2**16;\n \n-   ------------------------------\n-   -- Lock Free Data Structure --\n-   ------------------------------\n-\n-   --  A lock-free subprogram is a protected routine which references a unique\n-   --  protected scalar component and does not contain statements that cause\n-   --  side effects. Due to this restricted behavior, all references to shared\n-   --  data from within the subprogram can be synchronized through the use of\n-   --  atomic operations rather than relying on locks.\n-\n-   type Lock_Free_Subprogram is record\n-      Sub_Body : Node_Id;\n-      --  Reference to the body of a protected subprogram which meets the lock-\n-      --  free requirements.\n-\n-      Comp_Id : Entity_Id;\n-      --  Reference to the scalar component referenced from within Sub_Body\n-   end record;\n-\n-   --  This table establishes a relation between a protected subprogram body\n-   --  and a unique component it references. The table is used when building\n-   --  the lock-free versions of a protected subprogram body.\n-\n-   package Lock_Free_Subprogram_Table is new Table.Table (\n-     Table_Component_Type => Lock_Free_Subprogram,\n-     Table_Index_Type     => Nat,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 5,\n-     Table_Increment      => 5,\n-     Table_Name           => \"Lock_Free_Subprogram_Table\");\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -142,20 +110,6 @@ package body Exp_Ch9 is\n    --    Decls is the list of declarations to be enhanced.\n    --    Ent is the entity for the original entry body.\n \n-   function Allows_Lock_Free_Implementation (N : Node_Id) return Boolean;\n-   --  Given a protected body N, return True if N satisfies the following list\n-   --  of lock-free restrictions:\n-   --\n-   --    1) Protected type\n-   --         May not contain entries\n-   --         May contain only scalar components\n-   --         Component types must support atomic compare and exchange\n-   --\n-   --    2) Protected subprograms\n-   --         May not have side effects\n-   --         May not contain loop statements or procedure calls\n-   --         Function calls and attribute references must be static\n-\n    function Build_Accept_Body (Astat : Node_Id) return Node_Id;\n    --  Transform accept statement into a block with added exception handler.\n    --  Used both for simple accept statements and for accept alternatives in\n@@ -828,220 +782,6 @@ package body Exp_Ch9 is\n       Prepend_To (Decls, Decl);\n    end Add_Object_Pointer;\n \n-   -------------------------------------\n-   -- Allows_Lock_Free_Implementation --\n-   -------------------------------------\n-\n-   function Allows_Lock_Free_Implementation (N : Node_Id) return Boolean is\n-      Spec       : constant Entity_Id := Corresponding_Spec (N);\n-      Prot_Def   : constant Node_Id   := Protected_Definition (Parent (Spec));\n-      Priv_Decls : constant List_Id   := Private_Declarations (Prot_Def);\n-\n-      function Satisfies_Lock_Free_Requirements\n-        (Sub_Body : Node_Id) return Boolean;\n-      --  Return True if protected subprogram body Sub_Body satisfies all\n-      --  requirements of a lock-free implementation.\n-\n-      --------------------------------------\n-      -- Satisfies_Lock_Free_Requirements --\n-      --------------------------------------\n-\n-      function Satisfies_Lock_Free_Requirements\n-        (Sub_Body : Node_Id) return Boolean\n-      is\n-         Comp : Entity_Id := Empty;\n-         --  Track the current component which the body references\n-\n-         function Check_Node (N : Node_Id) return Traverse_Result;\n-         --  Check that node N meets the lock free restrictions\n-\n-         ----------------\n-         -- Check_Node --\n-         ----------------\n-\n-         function Check_Node (N : Node_Id) return Traverse_Result is\n-         begin\n-            --  Function calls and attribute references must be static\n-            --  ??? what about side-effects\n-\n-            if Nkind_In (N, N_Attribute_Reference, N_Function_Call)\n-              and then not Is_Static_Expression (N)\n-            then\n-               return Abandon;\n-\n-            --  Loop statements and procedure calls are prohibited\n-\n-            elsif Nkind_In (N, N_Loop_Statement,\n-                               N_Procedure_Call_Statement)\n-            then\n-               return Abandon;\n-\n-            --  References\n-\n-            elsif Nkind (N) = N_Identifier\n-              and then Present (Entity (N))\n-            then\n-               declare\n-                  Id     : constant Entity_Id := Entity (N);\n-                  Sub_Id : constant Entity_Id := Corresponding_Spec (Sub_Body);\n-\n-               begin\n-                  --  Prohibit references to non-constant entities outside the\n-                  --  protected subprogram scope.\n-\n-                  if Ekind (Id) in Assignable_Kind\n-                    and then not Scope_Within_Or_Same (Scope (Id), Sub_Id)\n-                    and then not Scope_Within_Or_Same (Scope (Id),\n-                                   Protected_Body_Subprogram (Sub_Id))\n-                  then\n-                     return Abandon;\n-\n-                  --  A protected subprogram may reference only one component\n-                  --  of the protected type.\n-\n-                  elsif Ekind_In (Id, E_Constant, E_Variable)\n-                    and then Present (Prival_Link (Id))\n-                  then\n-                     declare\n-                        Comp_Decl : constant Node_Id :=\n-                                      Parent (Prival_Link (Id));\n-                     begin\n-                        if Nkind (Comp_Decl) = N_Component_Declaration\n-                          and then Is_List_Member (Comp_Decl)\n-                          and then List_Containing (Comp_Decl) = Priv_Decls\n-                        then\n-                           if No (Comp) then\n-                              Comp := Prival_Link (Id);\n-\n-                           --  Check if another protected component has already\n-                           --  been accessed by the subprogram body.\n-\n-                           elsif Comp /= Prival_Link (Id) then\n-                              return Abandon;\n-                           end if;\n-                        end if;\n-                     end;\n-                  end if;\n-               end;\n-            end if;\n-\n-            return OK;\n-         end Check_Node;\n-\n-         function Check_All_Nodes is new Traverse_Func (Check_Node);\n-\n-      --  Start of processing for Satisfies_Lock_Free_Requirements\n-\n-      begin\n-         if Check_All_Nodes (Sub_Body) = OK then\n-\n-            --  Establish a relation between the subprogram body and the unique\n-            --  protected component it references.\n-\n-            if Present (Comp) then\n-               Lock_Free_Subprogram_Table.Append\n-                 (Lock_Free_Subprogram'(Sub_Body, Comp));\n-            end if;\n-\n-            return True;\n-         else\n-            return False;\n-         end if;\n-      end Satisfies_Lock_Free_Requirements;\n-\n-      --  Local variables\n-\n-      Decls     : constant List_Id   := Declarations (N);\n-      Vis_Decls : constant List_Id   := Visible_Declarations (Prot_Def);\n-\n-      Comp_Id       : Entity_Id;\n-      Comp_Size     : Int;\n-      Comp_Type     : Entity_Id;\n-      Decl          : Node_Id;\n-      Has_Component : Boolean := False;\n-\n-   --  Start of processing for Allows_Lock_Free_Implementation\n-\n-   begin\n-      --  The lock-free implementation is currently enabled through a debug\n-      --  flag.\n-\n-      if not Debug_Flag_9 then\n-         return False;\n-      end if;\n-\n-      --  Examine the visible declarations. Entries and entry families are not\n-      --  allowed by the lock-free restrictions.\n-\n-      Decl := First (Vis_Decls);\n-      while Present (Decl) loop\n-         if Nkind (Decl) = N_Entry_Declaration then\n-            return False;\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-\n-      --  Examine the private declarations\n-\n-      Decl := First (Priv_Decls);\n-      while Present (Decl) loop\n-\n-         --  The protected type must define at least one scalar component\n-\n-         if Nkind (Decl) = N_Component_Declaration then\n-            Has_Component := True;\n-\n-            Comp_Id   := Defining_Identifier (Decl);\n-            Comp_Type := Etype (Comp_Id);\n-\n-            if not Is_Scalar_Type (Comp_Type) then\n-               return False;\n-            end if;\n-\n-            Comp_Size := UI_To_Int (Esize (Base_Type (Comp_Type)));\n-\n-            --  Check that the size of the component is 8, 16, 32 or 64 bits\n-\n-            case Comp_Size is\n-               when 8 | 16 | 32 | 64 =>\n-                  null;\n-               when others           =>\n-                  return False;\n-            end case;\n-\n-         --  Entries and entry families are not allowed\n-\n-         elsif Nkind (Decl) = N_Entry_Declaration then\n-            return False;\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-\n-      --  At least one scalar component must be present\n-\n-      if not Has_Component then\n-         return False;\n-      end if;\n-\n-      --  Ensure that all protected subprograms meet the restrictions of the\n-      --  lock-free implementation.\n-\n-      Decl := First (Decls);\n-      while Present (Decl) loop\n-         if Nkind (Decl) = N_Subprogram_Body\n-           and then not Satisfies_Lock_Free_Requirements (Decl)\n-         then\n-            return False;\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-\n-      return True;\n-   end Allows_Lock_Free_Implementation;\n-\n    -----------------------\n    -- Build_Accept_Body --\n    -----------------------\n@@ -3228,7 +2968,8 @@ package body Exp_Ch9 is\n    --    begin\n    --       loop\n    --          declare\n-   --             Saved_Comp   : constant ... := Atomic_Load (Comp'Address);\n+   --             Saved_Comp   : constant ... :=\n+   --                              Atomic_Load (Comp'Address, Relaxed);\n    --             Current_Comp : ... := Saved_Comp;\n    --          begin\n    --             <original statements>\n@@ -3496,19 +3237,33 @@ package body Exp_Ch9 is\n \n       if Present (Comp) then\n          declare\n-            Comp_Typ     : constant Entity_Id := Etype (Comp);\n-            Typ_Size     : constant Int       := UI_To_Int (Esize (Comp_Typ));\n+            Comp_Type    : constant Entity_Id := Etype (Comp);\n             Block_Decls  : List_Id;\n             Compare      : Entity_Id;\n             Current_Comp : Entity_Id;\n             Decl         : Node_Id;\n             Label        : Node_Id;\n             Load         : Entity_Id;\n+            Load_Params  : List_Id;\n             Saved_Comp   : Entity_Id;\n             Stmt         : Node_Id;\n+            Typ_Size     : Int;\n             Unsigned     : Entity_Id;\n \n          begin\n+            --  Get the type size\n+\n+            if Known_Esize (Comp_Type) then\n+               Typ_Size := UI_To_Int (Esize (Comp_Type));\n+\n+            --  If the Esize (Object_Size) is unknown at compile-time, look at\n+            --  the RM_Size (Value_Size) since it may have been set by an\n+            --  explicit representation clause.\n+\n+            else\n+               Typ_Size := UI_To_Int (RM_Size (Comp_Type));\n+            end if;\n+\n             --  Retrieve all relevant atomic routines and types\n \n             case Typ_Size is\n@@ -3537,34 +3292,51 @@ package body Exp_Ch9 is\n             end case;\n \n             --  Generate:\n-            --    Saved_Comp : constant Comp_Typ :=\n-            --                   Comp_Typ (Atomic_Load (Comp'Address));\n+            --    For functions:\n+\n+            --       Saved_Comp : constant Comp_Type :=\n+            --                      Comp_Type (Atomic_Load (Comp'Address));\n+\n+            --    For procedures:\n+\n+            --       Saved_Comp : constant Comp_Type :=\n+            --                      Comp_Type (Atomic_Load (Comp'Address),\n+            --                                             Relaxed);\n \n             Saved_Comp :=\n               Make_Defining_Identifier (Loc,\n                 New_External_Name (Chars (Comp), Suffix => \"_saved\"));\n \n+            Load_Params := New_List (\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Reference_To (Comp, Loc),\n+                Attribute_Name => Name_Address));\n+\n+            --  For protected procedures, set the memory model to be relaxed\n+\n+            if Is_Procedure then\n+               Append_To (Load_Params,\n+                 New_Reference_To (RTE (RE_Relaxed), Loc));\n+            end if;\n+\n             Decl :=\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Saved_Comp,\n                 Constant_Present    => True,\n-                Object_Definition   => New_Reference_To (Comp_Typ, Loc),\n+                Object_Definition   => New_Reference_To (Comp_Type, Loc),\n                 Expression          =>\n-                  Unchecked_Convert_To (Comp_Typ,\n+                  Unchecked_Convert_To (Comp_Type,\n                     Make_Function_Call (Loc,\n                       Name                   => New_Reference_To (Load, Loc),\n-                      Parameter_Associations => New_List (\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix         => New_Reference_To (Comp, Loc),\n-                          Attribute_Name => Name_Address)))));\n+                      Parameter_Associations => Load_Params)));\n \n             --  Protected procedures\n \n             if Is_Procedure then\n                Block_Decls := New_List (Decl);\n \n                --  Generate:\n-               --    Current_Comp : Comp_Typ := Saved_Comp;\n+               --    Current_Comp : Comp_Type := Saved_Comp;\n \n                Current_Comp :=\n                  Make_Defining_Identifier (Loc,\n@@ -3573,7 +3345,7 @@ package body Exp_Ch9 is\n                Append_To (Block_Decls,\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Current_Comp,\n-                   Object_Definition   => New_Reference_To (Comp_Typ, Loc),\n+                   Object_Definition   => New_Reference_To (Comp_Type, Loc),\n                    Expression          => New_Reference_To (Saved_Comp, Loc)));\n \n             --  Protected function\n@@ -3645,6 +3417,9 @@ package body Exp_Ch9 is\n \n             if Is_Procedure then\n                Stmts := New_List (\n+                Make_Procedure_Call_Statement (Loc,\n+                    Name =>\n+                      New_Reference_To (RTE (RE_Atomic_Synchronize), Loc)),\n                  Make_Loop_Statement (Loc,\n                    Statements => New_List (\n                      Make_Block_Statement (Loc,\n@@ -8423,7 +8198,7 @@ package body Exp_Ch9 is\n       Loc          : constant Source_Ptr := Sloc (N);\n       Pid          : constant Entity_Id  := Corresponding_Spec (N);\n \n-      Lock_Free_On : constant Boolean := Allows_Lock_Free_Implementation (N);\n+      Lock_Free_Active : constant Boolean := Uses_Lock_Free (Pid);\n       --  This flag indicates whether the lock free implementation is active\n \n       Current_Node : Node_Id;\n@@ -8554,7 +8329,7 @@ package body Exp_Ch9 is\n                if not Is_Eliminated (Defining_Entity (Op_Body))\n                  and then not Is_Eliminated (Corresponding_Spec (Op_Body))\n                then\n-                  if Lock_Free_On then\n+                  if Lock_Free_Active then\n                      New_Op_Body :=\n                        Build_Lock_Free_Unprotected_Subprogram_Body\n                          (Op_Body, Pid);\n@@ -8581,7 +8356,7 @@ package body Exp_Ch9 is\n                   --  declaration in the protected body itself.\n \n                   if Present (Corresponding_Spec (Op_Body)) then\n-                     if Lock_Free_On then\n+                     if Lock_Free_Active then\n                         New_Op_Body :=\n                           Build_Lock_Free_Protected_Subprogram_Body\n                             (Op_Body, Pid, Specification (New_Op_Body));\n@@ -8765,10 +8540,13 @@ package body Exp_Ch9 is\n    --  the specs refer to this type.\n \n    procedure Expand_N_Protected_Type_Declaration (N : Node_Id) is\n-      Loc      : constant Source_Ptr := Sloc (N);\n-      Prot_Typ : constant Entity_Id  := Defining_Identifier (N);\n+      Loc              : constant Source_Ptr := Sloc (N);\n+      Prot_Typ         : constant Entity_Id  := Defining_Identifier (N);\n+\n+      Lock_Free_Active : constant Boolean := Uses_Lock_Free (Prot_Typ);\n+      --  This flag indicates whether the lock free implementation is active\n \n-      Pdef : constant Node_Id := Protected_Definition (N);\n+      Pdef             : constant Node_Id := Protected_Definition (N);\n       --  This contains two lists; one for visible and one for private decls\n \n       Rec_Decl     : Node_Id;\n@@ -8926,108 +8704,6 @@ package body Exp_Ch9 is\n \n       Collect_Entry_Families (Loc, Cdecls, Current_Node, Prot_Typ);\n \n-      --  Prepend the _Object field with the right type to the component list.\n-      --  We need to compute the number of entries, and in some cases the\n-      --  number of Attach_Handler pragmas.\n-\n-      declare\n-         Ritem              : Node_Id;\n-         Num_Attach_Handler : Int := 0;\n-         Protection_Subtype : Node_Id;\n-         Entry_Count_Expr   : constant Node_Id :=\n-                                Build_Entry_Count_Expression\n-                                  (Prot_Typ, Cdecls, Loc);\n-\n-      begin\n-         --  Could this be simplified using Corresponding_Runtime_Package???\n-\n-         if Has_Attach_Handler (Prot_Typ) then\n-            Ritem := First_Rep_Item (Prot_Typ);\n-            while Present (Ritem) loop\n-               if Nkind (Ritem) = N_Pragma\n-                 and then Pragma_Name (Ritem) = Name_Attach_Handler\n-               then\n-                  Num_Attach_Handler := Num_Attach_Handler + 1;\n-               end if;\n-\n-               Next_Rep_Item (Ritem);\n-            end loop;\n-\n-            if Restricted_Profile then\n-               if Has_Entries (Prot_Typ) then\n-                  Protection_Subtype :=\n-                    New_Reference_To (RTE (RE_Protection_Entry), Loc);\n-               else\n-                  Protection_Subtype :=\n-                    New_Reference_To (RTE (RE_Protection), Loc);\n-               end if;\n-            else\n-               Protection_Subtype :=\n-                 Make_Subtype_Indication\n-                   (Sloc => Loc,\n-                    Subtype_Mark =>\n-                      New_Reference_To\n-                        (RTE (RE_Static_Interrupt_Protection), Loc),\n-                    Constraint =>\n-                      Make_Index_Or_Discriminant_Constraint (\n-                        Sloc => Loc,\n-                        Constraints => New_List (\n-                          Entry_Count_Expr,\n-                          Make_Integer_Literal (Loc, Num_Attach_Handler))));\n-            end if;\n-\n-         elsif Has_Interrupt_Handler (Prot_Typ)\n-           and then not Restriction_Active (No_Dynamic_Attachment)\n-         then\n-            Protection_Subtype :=\n-               Make_Subtype_Indication (\n-                 Sloc => Loc,\n-                 Subtype_Mark => New_Reference_To\n-                   (RTE (RE_Dynamic_Interrupt_Protection), Loc),\n-                 Constraint =>\n-                   Make_Index_Or_Discriminant_Constraint (\n-                     Sloc => Loc,\n-                     Constraints => New_List (Entry_Count_Expr)));\n-\n-         --  Type has explicit entries or generated primitive entry wrappers\n-\n-         elsif Has_Entries (Prot_Typ)\n-           or else (Ada_Version >= Ada_2005\n-                      and then Present (Interface_List (N)))\n-         then\n-            case Corresponding_Runtime_Package (Prot_Typ) is\n-               when System_Tasking_Protected_Objects_Entries =>\n-                  Protection_Subtype :=\n-                     Make_Subtype_Indication (Loc,\n-                       Subtype_Mark =>\n-                         New_Reference_To (RTE (RE_Protection_Entries), Loc),\n-                       Constraint =>\n-                         Make_Index_Or_Discriminant_Constraint (\n-                           Sloc => Loc,\n-                           Constraints => New_List (Entry_Count_Expr)));\n-\n-               when System_Tasking_Protected_Objects_Single_Entry =>\n-                  Protection_Subtype :=\n-                    New_Reference_To (RTE (RE_Protection_Entry), Loc);\n-\n-               when others =>\n-                  raise Program_Error;\n-            end case;\n-\n-         else\n-            Protection_Subtype := New_Reference_To (RTE (RE_Protection), Loc);\n-         end if;\n-\n-         Object_Comp :=\n-           Make_Component_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc, Name_uObject),\n-             Component_Definition =>\n-               Make_Component_Definition (Loc,\n-                 Aliased_Present    => True,\n-                 Subtype_Indication => Protection_Subtype));\n-      end;\n-\n       pragma Assert (Present (Pdef));\n \n       --  Add private field components\n@@ -9144,10 +8820,117 @@ package body Exp_Ch9 is\n          end loop;\n       end if;\n \n-      --  Put the _Object component after the private component so that it\n-      --  be finalized early as required by 9.4 (20)\n+      --  Except for the lock-free implementation, prepend the _Object field\n+      --  with the right type to the component list. We need to compute the\n+      --  number of entries, and in some cases the number of Attach_Handler\n+      --  pragmas.\n+\n+      if not Lock_Free_Active then\n+         declare\n+            Ritem              : Node_Id;\n+            Num_Attach_Handler : Int := 0;\n+            Protection_Subtype : Node_Id;\n+            Entry_Count_Expr   : constant Node_Id :=\n+                                   Build_Entry_Count_Expression\n+                                     (Prot_Typ, Cdecls, Loc);\n+\n+         begin\n+            --  Could this be simplified using Corresponding_Runtime_Package???\n+\n+            if Has_Attach_Handler (Prot_Typ) then\n+               Ritem := First_Rep_Item (Prot_Typ);\n+               while Present (Ritem) loop\n+                  if Nkind (Ritem) = N_Pragma\n+                    and then Pragma_Name (Ritem) = Name_Attach_Handler\n+                  then\n+                     Num_Attach_Handler := Num_Attach_Handler + 1;\n+                  end if;\n+\n+                  Next_Rep_Item (Ritem);\n+               end loop;\n+\n+               if Restricted_Profile then\n+                  if Has_Entries (Prot_Typ) then\n+                     Protection_Subtype :=\n+                       New_Reference_To (RTE (RE_Protection_Entry), Loc);\n+                  else\n+                     Protection_Subtype :=\n+                       New_Reference_To (RTE (RE_Protection), Loc);\n+                  end if;\n+               else\n+                  Protection_Subtype :=\n+                    Make_Subtype_Indication\n+                      (Sloc => Loc,\n+                       Subtype_Mark =>\n+                         New_Reference_To\n+                           (RTE (RE_Static_Interrupt_Protection), Loc),\n+                       Constraint =>\n+                         Make_Index_Or_Discriminant_Constraint (\n+                           Sloc => Loc,\n+                           Constraints => New_List (\n+                             Entry_Count_Expr,\n+                             Make_Integer_Literal (Loc, Num_Attach_Handler))));\n+               end if;\n+\n+            elsif Has_Interrupt_Handler (Prot_Typ)\n+              and then not Restriction_Active (No_Dynamic_Attachment)\n+            then\n+               Protection_Subtype :=\n+                  Make_Subtype_Indication (\n+                    Sloc => Loc,\n+                    Subtype_Mark => New_Reference_To\n+                      (RTE (RE_Dynamic_Interrupt_Protection), Loc),\n+                    Constraint =>\n+                      Make_Index_Or_Discriminant_Constraint (\n+                        Sloc => Loc,\n+                        Constraints => New_List (Entry_Count_Expr)));\n+\n+            --  Type has explicit entries or generated primitive entry wrappers\n \n-      Append_To (Cdecls, Object_Comp);\n+            elsif Has_Entries (Prot_Typ)\n+              or else (Ada_Version >= Ada_2005\n+                         and then Present (Interface_List (N)))\n+            then\n+               case Corresponding_Runtime_Package (Prot_Typ) is\n+                  when System_Tasking_Protected_Objects_Entries =>\n+                     Protection_Subtype :=\n+                        Make_Subtype_Indication (Loc,\n+                          Subtype_Mark =>\n+                            New_Reference_To (RTE (RE_Protection_Entries),\n+                              Loc),\n+                          Constraint =>\n+                            Make_Index_Or_Discriminant_Constraint (\n+                              Sloc => Loc,\n+                              Constraints => New_List (Entry_Count_Expr)));\n+\n+                  when System_Tasking_Protected_Objects_Single_Entry =>\n+                     Protection_Subtype :=\n+                       New_Reference_To (RTE (RE_Protection_Entry), Loc);\n+\n+                  when others =>\n+                     raise Program_Error;\n+               end case;\n+\n+            else\n+               Protection_Subtype :=\n+                 New_Reference_To (RTE (RE_Protection), Loc);\n+            end if;\n+\n+            Object_Comp :=\n+              Make_Component_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uObject),\n+                Component_Definition =>\n+                  Make_Component_Definition (Loc,\n+                    Aliased_Present    => True,\n+                    Subtype_Indication => Protection_Subtype));\n+         end;\n+\n+         --  Put the _Object component after the private component so that it\n+         --  be finalized early as required by 9.4 (20)\n+\n+         Append_To (Cdecls, Object_Comp);\n+      end if;\n \n       Insert_After (Current_Node, Rec_Decl);\n       Current_Node := Rec_Decl;\n@@ -13149,9 +12932,12 @@ package body Exp_Ch9 is\n       end if;\n \n       --  Step 2: Create the Protection object and build its declaration for\n-      --  any protected entry (family) of subprogram.\n+      --  any protected entry (family) of subprogram. Note for the lock-free\n+      --  implementation, the Protection object is not needed anymore.\n \n-      if Is_Protected then\n+      if Is_Protected\n+        and then not Uses_Lock_Free (Conc_Typ)\n+      then\n          declare\n             Prot_Ent : constant Entity_Id := Make_Temporary (Loc, 'R');\n             Prot_Typ : RE_Id;\n@@ -13612,191 +13398,200 @@ package body Exp_Ch9 is\n \n       Args := New_List;\n \n-      --  Object parameter. This is a pointer to the object of type\n-      --  Protection used by the GNARL to control the protected object.\n-\n-      Append_To (Args,\n-        Make_Attribute_Reference (Loc,\n-          Prefix =>\n-            Make_Selected_Component (Loc,\n-              Prefix        => Make_Identifier (Loc, Name_uInit),\n-              Selector_Name => Make_Identifier (Loc, Name_uObject)),\n-          Attribute_Name => Name_Unchecked_Access));\n-\n-      --  Priority parameter. Set to Unspecified_Priority unless there is a\n-      --  priority pragma, in which case we take the value from the pragma,\n-      --  or there is an interrupt pragma and no priority pragma, and we\n-      --  set the ceiling to Interrupt_Priority'Last, an implementation-\n-      --  defined value, see D.3(10).\n-\n-      if Present (Pdef)\n-        and then Has_Pragma_Priority (Pdef)\n-      then\n-         declare\n-            Prio : constant Node_Id :=\n-                     Expression\n-                       (First\n-                          (Pragma_Argument_Associations\n-                             (Find_Task_Or_Protected_Pragma\n-                                (Pdef, Name_Priority))));\n-            Temp : Entity_Id;\n-\n-         begin\n-            --  If priority is a static expression, then we can duplicate it\n-            --  with no problem and simply append it to the argument list.\n-\n-            if Is_Static_Expression (Prio) then\n-               Append_To (Args,\n-                          Duplicate_Subexpr_No_Checks (Prio));\n-\n-            --  Otherwise, the priority may be a per-object expression, if it\n-            --  depends on a discriminant of the type. In this case, create\n-            --  local variable to capture the expression. Note that it is\n-            --  really necessary to create this variable explicitly. It might\n-            --  be thought that removing side effects would the appropriate\n-            --  approach, but that could generate declarations improperly\n-            --  placed in the enclosing scope.\n-\n-            --  Note: Use System.Any_Priority as the expected type for the\n-            --  non-static priority expression, in case the expression has not\n-            --  been analyzed yet (as occurs for example with pragma\n-            --  Interrupt_Priority).\n-\n-            else\n-               Temp := Make_Temporary (Loc, 'R', Prio);\n-               Append_To (L,\n-                  Make_Object_Declaration (Loc,\n-                     Defining_Identifier => Temp,\n-                     Object_Definition   =>\n-                       New_Occurrence_Of (RTE (RE_Any_Priority), Loc),\n-                     Expression          => Relocate_Node (Prio)));\n-\n-               Append_To (Args, New_Occurrence_Of (Temp, Loc));\n-            end if;\n-         end;\n+      --  For lock-free implementation, skip initializations of the Protection\n+      --  object.\n \n-      --  When no priority is specified but an xx_Handler pragma is, we default\n-      --  to System.Interrupts.Default_Interrupt_Priority, see D.3(10).\n+      if not Uses_Lock_Free (Defining_Identifier (Pdec)) then\n+         --  Object parameter. This is a pointer to the object of type\n+         --  Protection used by the GNARL to control the protected object.\n \n-      elsif Has_Attach_Handler (Ptyp)\n-        or else Has_Interrupt_Handler (Ptyp)\n-      then\n          Append_To (Args,\n-           New_Reference_To (RTE (RE_Default_Interrupt_Priority), Loc));\n+           Make_Attribute_Reference (Loc,\n+             Prefix =>\n+               Make_Selected_Component (Loc,\n+                 Prefix        => Make_Identifier (Loc, Name_uInit),\n+                 Selector_Name => Make_Identifier (Loc, Name_uObject)),\n+             Attribute_Name => Name_Unchecked_Access));\n+\n+         --  Priority parameter. Set to Unspecified_Priority unless there is a\n+         --  priority pragma, in which case we take the value from the pragma,\n+         --  or there is an interrupt pragma and no priority pragma, and we\n+         --  set the ceiling to Interrupt_Priority'Last, an implementation-\n+         --  defined value, see D.3(10).\n+\n+         if Present (Pdef)\n+           and then Has_Pragma_Priority (Pdef)\n+         then\n+            declare\n+               Prio : constant Node_Id :=\n+                        Expression\n+                          (First\n+                             (Pragma_Argument_Associations\n+                                (Find_Task_Or_Protected_Pragma\n+                                   (Pdef, Name_Priority))));\n+               Temp : Entity_Id;\n \n-      --  Normal case, no priority or xx_Handler specified, default priority\n+            begin\n+               --  If priority is a static expression, then we can duplicate it\n+               --  with no problem and simply append it to the argument list.\n \n-      else\n-         Append_To (Args,\n-           New_Reference_To (RTE (RE_Unspecified_Priority), Loc));\n-      end if;\n+               if Is_Static_Expression (Prio) then\n+                  Append_To (Args,\n+                    Duplicate_Subexpr_No_Checks (Prio));\n \n-      --  Test for Compiler_Info parameter. This parameter allows entry body\n-      --  procedures and barrier functions to be called from the runtime. It\n-      --  is a pointer to the record generated by the compiler to represent\n-      --  the protected object.\n+               --  Otherwise, the priority may be a per-object expression, if\n+               --  it depends on a discriminant of the type. In this case,\n+               --  create local variable to capture the expression. Note that\n+               --  it is really necessary to create this variable explicitly.\n+               --  It might be thought that removing side effects would the\n+               --  appropriate approach, but that could generate declarations\n+               --  improperly placed in the enclosing scope.\n \n-      --  A protected type without entries that covers an interface and\n-      --  overrides the abstract routines with protected procedures is\n-      --  considered equivalent to a protected type with entries in the\n-      --  context of dispatching select statements.\n+               --  Note: Use System.Any_Priority as the expected type for the\n+               --  non-static priority expression, in case the expression has\n+               --  not been analyzed yet (as occurs for example with pragma\n+               --  Interrupt_Priority).\n \n-      if Has_Entry\n-        or else Has_Interfaces (Protect_Rec)\n-        or else\n-          ((Has_Attach_Handler (Ptyp) or else Has_Interrupt_Handler (Ptyp))\n-             and then not Restriction_Active (No_Dynamic_Attachment))\n-      then\n-         declare\n-            Pkg_Id : constant RTU_Id  := Corresponding_Runtime_Package (Ptyp);\n+               else\n+                  Temp := Make_Temporary (Loc, 'R', Prio);\n+                  Append_To (L,\n+                     Make_Object_Declaration (Loc,\n+                        Defining_Identifier => Temp,\n+                        Object_Definition   =>\n+                          New_Occurrence_Of (RTE (RE_Any_Priority), Loc),\n+                        Expression          => Relocate_Node (Prio)));\n+\n+                  Append_To (Args, New_Occurrence_Of (Temp, Loc));\n+               end if;\n+            end;\n \n-            Called_Subp : RE_Id;\n+         --  When no priority is specified but an xx_Handler pragma is, we\n+         --  default to System.Interrupts.Default_Interrupt_Priority, see\n+         --  D.3(10).\n \n-         begin\n-            case Pkg_Id is\n-               when System_Tasking_Protected_Objects_Entries =>\n-                  Called_Subp := RE_Initialize_Protection_Entries;\n+         elsif Has_Attach_Handler (Ptyp)\n+           or else Has_Interrupt_Handler (Ptyp)\n+         then\n+            Append_To (Args,\n+              New_Reference_To (RTE (RE_Default_Interrupt_Priority), Loc));\n \n-               when System_Tasking_Protected_Objects =>\n-                  Called_Subp := RE_Initialize_Protection;\n+         --  Normal case, no priority or xx_Handler specified, default priority\n \n-               when System_Tasking_Protected_Objects_Single_Entry =>\n-                  Called_Subp := RE_Initialize_Protection_Entry;\n+         else\n+            Append_To (Args,\n+              New_Reference_To (RTE (RE_Unspecified_Priority), Loc));\n+         end if;\n \n-               when others =>\n-                  raise Program_Error;\n-            end case;\n+         --  Test for Compiler_Info parameter. This parameter allows entry body\n+         --  procedures and barrier functions to be called from the runtime. It\n+         --  is a pointer to the record generated by the compiler to represent\n+         --  the protected object.\n+\n+         --  A protected type without entries that covers an interface and\n+         --  overrides the abstract routines with protected procedures is\n+         --  considered equivalent to a protected type with entries in the\n+         --  context of dispatching select statements.\n+\n+         if Has_Entry\n+           or else Has_Interfaces (Protect_Rec)\n+           or else\n+             ((Has_Attach_Handler (Ptyp) or else Has_Interrupt_Handler (Ptyp))\n+                and then not Restriction_Active (No_Dynamic_Attachment))\n+         then\n+            declare\n+               Pkg_Id : constant RTU_Id  :=\n+                          Corresponding_Runtime_Package (Ptyp);\n \n-            if Has_Entry\n-              or else not Restricted\n-              or else Has_Interfaces (Protect_Rec)\n-            then\n-               Append_To (Args,\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix         => Make_Identifier (Loc, Name_uInit),\n-                   Attribute_Name => Name_Address));\n-            end if;\n+               Called_Subp : RE_Id;\n \n-            --  Entry_Bodies parameter. This is a pointer to an array of\n-            --  pointers to the entry body procedures and barrier functions of\n-            --  the object. If the protected type has no entries this object\n-            --  will not exist, in this case, pass a null.\n+            begin\n+               case Pkg_Id is\n+                  when System_Tasking_Protected_Objects_Entries =>\n+                     Called_Subp := RE_Initialize_Protection_Entries;\n \n-            if Has_Entry then\n-               P_Arr := Entry_Bodies_Array (Ptyp);\n+                  when System_Tasking_Protected_Objects =>\n+                     Called_Subp := RE_Initialize_Protection;\n \n-               Append_To (Args,\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix => New_Reference_To (P_Arr, Loc),\n-                   Attribute_Name => Name_Unrestricted_Access));\n+                  when System_Tasking_Protected_Objects_Single_Entry =>\n+                     Called_Subp := RE_Initialize_Protection_Entry;\n+\n+                  when others =>\n+                     raise Program_Error;\n+               end case;\n \n-               if Pkg_Id = System_Tasking_Protected_Objects_Entries then\n+               if Has_Entry\n+                 or else not Restricted\n+                 or else Has_Interfaces (Protect_Rec)\n+               then\n+                  Append_To (Args,\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => Make_Identifier (Loc, Name_uInit),\n+                      Attribute_Name => Name_Address));\n+               end if;\n \n-                  --  Find index mapping function (clumsy but ok for now)\n+               --  Entry_Bodies parameter. This is a pointer to an array of\n+               --  pointers to the entry body procedures and barrier functions\n+               --  of the object. If the protected type has no entries this\n+               --  object will not exist, in this case, pass a null.\n \n-                  while Ekind (P_Arr) /= E_Function loop\n-                     Next_Entity (P_Arr);\n-                  end loop;\n+               if Has_Entry then\n+                  P_Arr := Entry_Bodies_Array (Ptyp);\n \n                   Append_To (Args,\n                     Make_Attribute_Reference (Loc,\n-                      Prefix         => New_Reference_To (P_Arr, Loc),\n+                      Prefix => New_Reference_To (P_Arr, Loc),\n                       Attribute_Name => Name_Unrestricted_Access));\n \n-                  --  Build_Entry_Names generation flag. When set to true, the\n-                  --  runtime will allocate an array to hold the string names\n-                  --  of protected entries.\n+                  if Pkg_Id = System_Tasking_Protected_Objects_Entries then\n \n-                  if not Restricted_Profile then\n-                     if Entry_Names_OK then\n-                        Append_To (Args,\n-                          New_Reference_To (Standard_True, Loc));\n-                     else\n-                        Append_To (Args,\n-                          New_Reference_To (Standard_False, Loc));\n+                     --  Find index mapping function (clumsy but ok for now)\n+\n+                     while Ekind (P_Arr) /= E_Function loop\n+                        Next_Entity (P_Arr);\n+                     end loop;\n+\n+                     Append_To (Args,\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix         => New_Reference_To (P_Arr, Loc),\n+                         Attribute_Name => Name_Unrestricted_Access));\n+\n+                     --  Build_Entry_Names generation flag. When set to true,\n+                     --  the runtime will allocate an array to hold the string\n+                     --  names of protected entries.\n+\n+                     if not Restricted_Profile then\n+                        if Entry_Names_OK then\n+                           Append_To (Args,\n+                             New_Reference_To (Standard_True, Loc));\n+                        else\n+                           Append_To (Args,\n+                             New_Reference_To (Standard_False, Loc));\n+                        end if;\n                      end if;\n                   end if;\n-               end if;\n \n-            elsif Pkg_Id = System_Tasking_Protected_Objects_Single_Entry then\n-               Append_To (Args, Make_Null (Loc));\n+               elsif Pkg_Id =\n+                       System_Tasking_Protected_Objects_Single_Entry\n+               then\n+                  Append_To (Args, Make_Null (Loc));\n \n-            elsif Pkg_Id = System_Tasking_Protected_Objects_Entries then\n-               Append_To (Args, Make_Null (Loc));\n-               Append_To (Args, Make_Null (Loc));\n-               Append_To (Args, New_Reference_To (Standard_False, Loc));\n-            end if;\n+               elsif Pkg_Id = System_Tasking_Protected_Objects_Entries then\n+                  Append_To (Args, Make_Null (Loc));\n+                  Append_To (Args, Make_Null (Loc));\n+                  Append_To (Args, New_Reference_To (Standard_False, Loc));\n+               end if;\n \n+               Append_To (L,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To (RTE (Called_Subp), Loc),\n+                   Parameter_Associations => Args));\n+            end;\n+         else\n             Append_To (L,\n               Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (RTE (Called_Subp), Loc),\n+                Name => New_Reference_To (RTE (RE_Initialize_Protection), Loc),\n                 Parameter_Associations => Args));\n-         end;\n-      else\n-         Append_To (L,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Reference_To (RTE (RE_Initialize_Protection), Loc),\n-             Parameter_Associations => Args));\n+         end if;\n       end if;\n \n       if Has_Attach_Handler (Ptyp) then\n@@ -13868,15 +13663,18 @@ package body Exp_Ch9 is\n                    Parameter_Associations => Args));\n \n             else\n-               --  First, prepends the _object argument\n+               if not Uses_Lock_Free (Defining_Identifier (Pdec)) then\n+                  --  First, prepends the _object argument\n \n-               Prepend_To (Args,\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix        => Make_Identifier (Loc, Name_uInit),\n-                       Selector_Name => Make_Identifier (Loc, Name_uObject)),\n-                   Attribute_Name => Name_Unchecked_Access));\n+                  Prepend_To (Args,\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix        => Make_Identifier (Loc, Name_uInit),\n+                          Selector_Name =>\n+                            Make_Identifier (Loc, Name_uObject)),\n+                      Attribute_Name => Name_Unchecked_Access));\n+               end if;\n \n                --  Then, insert call to Install_Handlers\n "}, {"sha": "723ff120ff6ee6d7911590e4ee6e96250a02a7ec", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -1343,7 +1343,7 @@ package body GNAT.Command_Line is\n    begin\n       if Switch /= \"\" or else Long_Switch /= \"\" then\n          Initialize_Switch_Def\n-            (Def, Switch, Long_Switch, Help, Section, Argument);\n+           (Def, Switch, Long_Switch, Help, Section, Argument);\n          Add (Config, Def);\n       end if;\n    end Define_Switch;\n@@ -1390,7 +1390,7 @@ package body GNAT.Command_Line is\n    begin\n       if Switch /= \"\" or else Long_Switch /= \"\" then\n          Initialize_Switch_Def\n-            (Def, Switch, Long_Switch, Help, Section, Argument);\n+           (Def, Switch, Long_Switch, Help, Section, Argument);\n          Def.Integer_Output  := Output.all'Unchecked_Access;\n          Def.Integer_Default := Default;\n          Def.Integer_Initial := Initial;\n@@ -1415,7 +1415,7 @@ package body GNAT.Command_Line is\n    begin\n       if Switch /= \"\" or else Long_Switch /= \"\" then\n          Initialize_Switch_Def\n-            (Def, Switch, Long_Switch, Help, Section, Argument);\n+           (Def, Switch, Long_Switch, Help, Section, Argument);\n          Def.String_Output  := Output.all'Unchecked_Access;\n          Add (Config, Def);\n       end if;\n@@ -3233,7 +3233,9 @@ package body GNAT.Command_Line is\n                   end if;\n                end if;\n \n-            else  --  Long_Switch necessarily not null\n+            --  Def.Switch is null (Long_Switch must be non-null)\n+\n+            else\n                Decompose_Switch (Def.Long_Switch.all, P2, Last2);\n                Append (Result,\n                        Def.Long_Switch (Def.Long_Switch'First .. Last2));"}, {"sha": "c4b290e55677ba76b451eb18b9a42b895a3e0e66", "filename": "gcc/ada/g-comlin.ads", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -181,16 +181,20 @@\n --     ...\n \n --  Specifying the help message is optional, but makes it easy to then call\n---  the function\n+--  the function:\n+\n --     Display_Help (Config);\n+\n --  that will display a properly formatted help message for your application,\n --  listing all possible switches. That way you have a single place in which\n --  to maintain the list of switches and their meaning, rather than maintaining\n --  both the string to pass to Getopt and a subprogram to display the help.\n --  Both will properly stay synchronized.\n \n---  Once you have this Config, you just have to call\n+--  Once you have this Config, you just have to call:\n+\n --     Getopt (Config, Callback'Access);\n+\n --  to parse the command line. The Callback will be called for each switch\n --  found on the command line (in the case of our example, that is \"-gnatwu\"\n --  and then \"-gnatwv\", not \"-gnatwa\" itself). This simplifies command line\n@@ -203,13 +207,13 @@\n \n --     Optimization : aliased Integer;\n --     Verbose      : aliased Boolean;\n---\n+\n --     Define_Switch (Config, Verbose'Access,\n --                    \"-v\", Long_Switch => \"--verbose\",\n --                    Help => \"Output extra verbose information\");\n --     Define_Switch (Config, Optimization'Access,\n --                    \"-O?\", Help => \"Optimization level\");\n---\n+\n --     Getopt (Config);  --  No callback\n \n --  Since all switches are handled automatically, we don't even need to pass\n@@ -263,8 +267,8 @@\n --  Some command line arguments can have parameters, which on a command line\n --  appear as a separate argument that must immediately follow the switch.\n --  Since the subprograms in this package will reorganize the switches to group\n---  them, you need to indicate what is a command line\n---  parameter, and what is a switch argument.\n+--  them, you need to indicate what is a command line parameter, and what is a\n+--  switch argument.\n \n --  This is done by passing an extra argument to Add_Switch, as in:\n \n@@ -308,18 +312,18 @@ package GNAT.Command_Line is\n       Stop_At_First_Non_Switch : Boolean := False;\n       Section_Delimiters       : String := \"\");\n    --  The first procedure resets the internal state of the package to prepare\n-   --  to rescan the parameters. It does not need to be called before the first\n-   --  use of Getopt (but it could be), but it must be called if you want to\n-   --  start rescanning the command line parameters from the start. The\n-   --  optional parameter Switch_Char can be used to reset the switch\n+   --  to rescan the parameters. It does not need to be called before the\n+   --  first use of Getopt (but it could be), but it must be called if you\n+   --  want to start rescanning the command line parameters from the start.\n+   --  The optional parameter Switch_Char can be used to reset the switch\n    --  character, e.g. to '/' for use in DOS-like systems.\n    --\n-   --  The second subprogram initializes a parser that takes its arguments from\n-   --  an array of strings rather than directly from the command line. In this\n-   --  case, the parser is responsible for freeing the strings stored in\n+   --  The second subprogram initializes a parser that takes its arguments\n+   --  from an array of strings rather than directly from the command line. In\n+   --  this case, the parser is responsible for freeing the strings stored in\n    --  Command_Line. If you pass null to Command_Line, this will in fact create\n    --  a second parser for Ada.Command_Line, which doesn't share any data with\n-   --  the default parser. This parser must be free-ed.\n+   --  the default parser. This parser must be free'ed.\n    --\n    --  The optional parameter Stop_At_First_Non_Switch indicates if Getopt is\n    --  to look for switches on the whole command line, or if it has to stop as\n@@ -451,9 +455,9 @@ package GNAT.Command_Line is\n    --  spaces.\n    --\n    --    Example\n-   --       Getopt (\"a b\", Concatenate => False)\n-   --       If the command line is '-ab', exception Invalid_Switch will be\n-   --       raised and Full_Switch will return \"ab\".\n+   --      Getopt (\"a b\", Concatenate => False)\n+   --      If the command line is '-ab', exception Invalid_Switch will be\n+   --      raised and Full_Switch will return \"ab\".\n \n    function Get_Argument\n      (Do_Expansion : Boolean := False;\n@@ -559,8 +563,8 @@ package GNAT.Command_Line is\n    --  The section name should not include the leading '-'. So for instance in\n    --  the case of gnatmake we would use:\n    --\n-   --      Define_Section (Config, \"cargs\");\n-   --      Define_Section (Config, \"bargs\");\n+   --    Define_Section (Config, \"cargs\");\n+   --    Define_Section (Config, \"bargs\");\n \n    procedure Define_Alias\n      (Config   : in out Command_Line_Configuration;\n@@ -609,9 +613,9 @@ package GNAT.Command_Line is\n    --\n    --  Switch and Long_Switch (when specified) are aliases and can be used\n    --  interchangeably. There is no check that they both take an argument or\n-   --  both take no argument.\n-   --  Switch can be set to \"*\" to indicate that any switch is supported (in\n-   --  which case Getopt will return '*', see its documentation).\n+   --  both take no argument. Switch can be set to \"*\" to indicate that any\n+   --  switch is supported (in which case Getopt will return '*', see its\n+   --  documentation).\n    --\n    --  Help is used by the Display_Help procedure to describe the supported\n    --  switches.\n@@ -633,11 +637,13 @@ package GNAT.Command_Line is\n    --  See Define_Switch for a description of the parameters.\n    --  When the switch is found on the command line, Getopt will set\n    --  Output.all to Value.\n+   --\n    --  Output is always initially set to \"not Value\", so that if the switch is\n    --  not found on the command line, Output still has a valid value.\n    --  The switch must not take any parameter.\n-   --  Output must exist at least as long as Config, otherwise erroneous memory\n-   --  access may happen.\n+   --\n+   --  Output must exist at least as long as Config, otherwise an erroneous\n+   --  memory access may occur.\n \n    procedure Define_Switch\n      (Config      : in out Command_Line_Configuration;\n@@ -649,14 +655,14 @@ package GNAT.Command_Line is\n       Initial     : Integer := 0;\n       Default     : Integer := 1;\n       Argument    : String := \"ARG\");\n-   --  See Define_Switch for a description of the parameters.\n-   --  When the switch is found on the command line, Getopt will set\n-   --  Output.all to the value of the switch's parameter. If the parameter is\n-   --  not an integer, Invalid_Parameter is raised.\n+   --  See Define_Switch for a description of the parameters. When the\n+   --  switch is found on the command line, Getopt will set Output.all to the\n+   --  value of the switch's parameter. If the parameter is not an integer,\n+   --  Invalid_Parameter is raised.\n+\n    --  Output is always initialized to Initial. If the switch has an optional\n    --  argument which isn't specified by the user, then Output will be set to\n-   --  Default.\n-   --  The switch must accept an argument.\n+   --  Default. The switch must accept an argument.\n \n    procedure Define_Switch\n      (Config      : in out Command_Line_Configuration;\n@@ -667,11 +673,10 @@ package GNAT.Command_Line is\n       Section     : String := \"\";\n       Argument    : String := \"ARG\");\n    --  Set Output to the value of the switch's parameter when the switch is\n-   --  found on the command line.\n-   --  Output is always initialized to the empty string if it does not have\n-   --  a value already (otherwise it is left as is so that you can specify the\n-   --  default value directly in the declaration of the variable).\n-   --  The switch must accept an argument.\n+   --  found on the command line. Output is always initialized to the empty\n+   --  string if it does not have a value already (otherwise it is left as is\n+   --  so that you can specify the default value directly in the declaration\n+   --  of the variable). The switch must accept an argument.\n \n    procedure Set_Usage\n      (Config   : in out Command_Line_Configuration;\n@@ -705,15 +710,14 @@ package GNAT.Command_Line is\n      (Switch    : String;\n       Parameter : String;\n       Section   : String);\n-   --  Called when a switch is found on the command line.\n-   --  [Switch] includes any leading '-' that was specified in Define_Switch.\n-   --  This is slightly different from the functional version of Getopt above,\n-   --  for which Full_Switch omits the first leading '-'.\n+   --  Called when a switch is found on the command line. Switch includes\n+   --  any leading '-' that was specified in Define_Switch. This is slightly\n+   --  different from the functional version of Getopt above, for which\n+   --  Full_Switch omits the first leading '-'.\n \n    Exit_From_Command_Line : exception;\n-   --  Emitted when the program should exit.\n-   --  This is called when Getopt below has seen -h, --help or an invalid\n-   --  switch.\n+   --  Emitted when the program should exit. This is called when Getopt below\n+   --  has seen -h, --help or an invalid switch.\n \n    procedure Getopt\n      (Config      : Command_Line_Configuration;\n@@ -823,7 +827,7 @@ package GNAT.Command_Line is\n    --  If the command line has sections (such as -bargs -cargs), then they\n    --  should be listed in the Sections parameter (as \"-bargs -cargs\").\n    --\n-   --  This function can be used to reset Cmd by passing an empty string.\n+   --  This function can be used to reset Cmd by passing an empty string\n    --\n    --  If an invalid switch is found on the command line (ie wasn't defined in\n    --  the configuration via Define_Switch), and the configuration wasn't set\n@@ -947,6 +951,7 @@ package GNAT.Command_Line is\n    ---------------\n    -- Iteration --\n    ---------------\n+\n    --  When a command line was created with the above, you can then iterate\n    --  over its contents using the following iterator.\n \n@@ -992,6 +997,7 @@ package GNAT.Command_Line is\n    --  create an Opt_Parser.\n    --\n    --  Args must be freed by the caller.\n+   --\n    --  Expanded has the same meaning as in Start.\n \n private"}, {"sha": "a01505c709c2219afe4484cdddaf7d104c98d049", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -739,6 +739,8 @@ package Rtsfind is\n      RE_Atomic_Load_16,                  -- System.Atomic_Primitives\n      RE_Atomic_Load_32,                  -- System.Atomic_Primitives\n      RE_Atomic_Load_64,                  -- System.Atomic_Primitives\n+     RE_Atomic_Synchronize,              -- System.Atomic_Primitives\n+     RE_Relaxed,                         -- System.Atomic_Primitives\n      RE_Uint8,                           -- System.Atomic_Primitives\n      RE_Uint16,                          -- System.Atomic_Primitives\n      RE_Uint32,                          -- System.Atomic_Primitives\n@@ -1960,6 +1962,8 @@ package Rtsfind is\n      RE_Atomic_Load_16                   => System_Atomic_Primitives,\n      RE_Atomic_Load_32                   => System_Atomic_Primitives,\n      RE_Atomic_Load_64                   => System_Atomic_Primitives,\n+     RE_Atomic_Synchronize               => System_Atomic_Primitives,\n+     RE_Relaxed                          => System_Atomic_Primitives,\n      RE_Uint8                            => System_Atomic_Primitives,\n      RE_Uint16                           => System_Atomic_Primitives,\n      RE_Uint32                           => System_Atomic_Primitives,"}, {"sha": "3b87eb2812517ee8d5eaca5a382d75833d30c9e4", "filename": "gcc/ada/s-atopri.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fs-atopri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fs-atopri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-atopri.ads?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -29,7 +29,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  ??? Need header saying what this unit is!!!\n+--  This package contains atomic primitives defined from gcc built-in functions\n+\n+--  For now, these operations are only used by the compiler to generate the\n+--  lock-free implementation of protected objects.\n \n package System.Atomic_Primitives is\n    pragma Preelaborate;\n@@ -119,4 +122,6 @@ package System.Atomic_Primitives is\n       Model : Mem_Model := Seq_Cst) return uint64;\n    pragma Import (Intrinsic, Atomic_Load_64, \"__atomic_load_8\");\n \n+   procedure Atomic_Synchronize;\n+   pragma Import (Intrinsic, Atomic_Synchronize, \"__sync_synchronize\");\n end System.Atomic_Primitives;"}, {"sha": "c8b987e93cdd87dbc6136d3dcd1713da99c85ce3", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -926,16 +926,40 @@ package body Sem_Ch13 is\n                when No_Aspect =>\n                   raise Program_Error;\n \n-               --  Aspects taking an optional boolean argument. For all of\n-               --  these we just create a matching pragma and insert it, if\n-               --  the expression is missing or set to True. If the expression\n-               --  is False, we can ignore the aspect with the exception that\n-               --  in the case of a derived type, we must check for an illegal\n-               --  attempt to cancel an inherited aspect.\n+               --  Aspects taking an optional boolean argument\n \n                when Boolean_Aspects =>\n                   Set_Is_Boolean_Aspect (Aspect);\n \n+                  --  Special treatment for Aspect_Lock_Free since it is the\n+                  --  only Boolean_Aspect that doesn't correspond to a pragma.\n+\n+                  if A_Id = Aspect_Lock_Free then\n+                     if Ekind (E) /= E_Protected_Type then\n+                        Error_Msg_N\n+                          (\"aspect % only applies to protected objects\",\n+                           Aspect);\n+                     end if;\n+\n+                     --  Set the Uses_Lock_Free flag to True if there is no\n+                     --  expression or if the expression is True.\n+\n+                     if No (Expr)\n+                       or else Is_True (Static_Boolean (Expr))\n+                     then\n+                        Set_Uses_Lock_Free (E);\n+                     end if;\n+\n+                     goto Continue;\n+                  end if;\n+\n+                  --  For all of these aspects we just create a matching pragma\n+                  --  and insert it, if the expression is missing or set to\n+                  --  True. If the expression is False, we can ignore the\n+                  --  aspect with the exception that in the case of a derived\n+                  --  type, we must check for an illegal attempt to cancel an\n+                  --  inherited aspect.\n+\n                   if Present (Expr)\n                     and then Is_False (Static_Boolean (Expr))\n                   then"}, {"sha": "a91f494152f0ccd8120d2da04cb6f078ada56468", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 371, "deletions": 4, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -23,13 +23,16 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Ch9;  use Exp_Ch9;\n with Elists;   use Elists;\n with Freeze;   use Freeze;\n+with Layout;   use Layout;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -64,6 +67,29 @@ package body Sem_Ch9 is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Allows_Lock_Free_Implementation\n+     (N        : Node_Id;\n+      Complain : Boolean := False) return Boolean;\n+   --  This dispatch routine return True if N satisfies the following list of\n+   --  lock-free restrictions for protected type declaration and protected\n+   --  body:\n+   --\n+   --    1) Protected type declaration\n+   --         May not contain entries\n+   --         Component types must support atomic compare and exchange\n+   --\n+   --    2) Protected Body\n+   --         Each protected subprogram body within N must satisfy:\n+   --            May reference only one protected component\n+   --            May not reference non-constant entities outside the protected\n+   --              subprogram scope.\n+   --            May not reference non-scalar out parameters\n+   --            May not contain loop statements or procedure calls\n+   --            Function calls and attribute references must be static\n+   --\n+   --  If Complain is set to True, an error message is issued when return\n+   --  False.\n+\n    procedure Check_Max_Entries (D : Node_Id; R : All_Parameter_Restrictions);\n    --  Given either a protected definition or a task definition in D, check\n    --  the corresponding restriction parameter identifier R, and if it is set,\n@@ -91,6 +117,304 @@ package body Sem_Ch9 is\n    --  Utility to make visible in corresponding body the entities defined in\n    --  task, protected type declaration, or entry declaration.\n \n+   -------------------------------------\n+   -- Allows_Lock_Free_Implementation --\n+   -------------------------------------\n+\n+   function Allows_Lock_Free_Implementation\n+     (N        : Node_Id;\n+      Complain : Boolean := False) return Boolean\n+   is\n+   begin\n+      pragma Assert (Nkind_In (N,\n+                               N_Protected_Type_Declaration,\n+                               N_Protected_Body));\n+\n+      --  The lock-free implementation is currently enabled through a debug\n+      --  flag. When Complain is True, an aspect Lock_Free forces the lock-free\n+      --  implementation. In that case, the debug flag is not needed.\n+\n+      if not Complain\n+        and then not Debug_Flag_9\n+      then\n+         return False;\n+      end if;\n+\n+      --  Protected type declaration case\n+\n+      if Nkind (N) = N_Protected_Type_Declaration then\n+         declare\n+            Pdef       : constant Node_Id := Protected_Definition (N);\n+            Priv_Decls : constant List_Id := Private_Declarations (Pdef);\n+            Vis_Decls  : constant List_Id := Visible_Declarations (Pdef);\n+\n+            Comp_Id    : Entity_Id;\n+            Comp_Size  : Int;\n+            Comp_Type  : Entity_Id;\n+            Decl       : Node_Id;\n+\n+         begin\n+            --  Examine the visible declarations. Entries and entry families\n+            --  are not allowed by the lock-free restrictions.\n+\n+            Decl := First (Vis_Decls);\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Entry_Declaration then\n+                  if Complain then\n+                     Error_Msg_N (\"entry not allowed for lock-free \" &\n+                                  \"implementation\",\n+                                  Decl);\n+                  end if;\n+\n+                  return False;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+\n+            --  Examine the private declarations\n+\n+            Decl := First (Priv_Decls);\n+            while Present (Decl) loop\n+\n+               --  The protected type must define at least one scalar component\n+\n+               if Nkind (Decl) = N_Component_Declaration then\n+                  Comp_Id       := Defining_Identifier (Decl);\n+                  Comp_Type     := Etype (Comp_Id);\n+\n+                  --  Make sure the protected component type has size and\n+                  --  alignment fields set at this point whenever this is\n+                  --  possible.\n+\n+                  Layout_Type (Comp_Type);\n+\n+                  if Known_Esize (Comp_Type) then\n+                     Comp_Size := UI_To_Int (Esize (Comp_Type));\n+\n+                  --  If the Esize (Object_Size) is unknown at compile-time,\n+                  --  look at the RM_Size (Value_Size) since it may have been\n+                  --  set by an explicit representation clause.\n+\n+                  else\n+                     Comp_Size := UI_To_Int (RM_Size (Comp_Type));\n+                  end if;\n+\n+                  --  Check that the size of the component is 8, 16, 32 or 64\n+                  --  bits.\n+\n+                  case Comp_Size is\n+                     when 8 | 16 | 32 | 64 =>\n+                        null;\n+                     when others           =>\n+                        if Complain then\n+                           Error_Msg_N (\"must support atomic operations for \" &\n+                                        \"lock-free implementation\",\n+                                         Decl);\n+                        end if;\n+\n+                        return False;\n+                  end case;\n+\n+               --  Entries and entry families are not allowed\n+\n+               elsif Nkind (Decl) = N_Entry_Declaration then\n+                  if Complain then\n+                     Error_Msg_N (\"entry not allowed for lock-free \" &\n+                                  \"implementation\",\n+                                  Decl);\n+                  end if;\n+\n+                  return False;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end;\n+\n+      --  Protected body case\n+\n+      else\n+         declare\n+            Decls         : constant List_Id   := Declarations (N);\n+            Pid           : constant Entity_Id := Corresponding_Spec (N);\n+            Prot_Typ_Decl : constant Node_Id   := Parent (Pid);\n+            Prot_Def      : constant Node_Id   :=\n+                              Protected_Definition (Prot_Typ_Decl);\n+            Priv_Decls    : constant List_Id   :=\n+                              Private_Declarations (Prot_Def);\n+            Decl          : Node_Id;\n+\n+            function Satisfies_Lock_Free_Requirements\n+              (Sub_Body : Node_Id) return Boolean;\n+            --  Return True if protected subprogram body Sub_Body satisfies all\n+            --  requirements of a lock-free implementation.\n+\n+            --------------------------------------\n+            -- Satisfies_Lock_Free_Requirements --\n+            --------------------------------------\n+\n+            function Satisfies_Lock_Free_Requirements\n+              (Sub_Body : Node_Id) return Boolean\n+            is\n+               Comp : Entity_Id := Empty;\n+               --  Track the current component which the body references\n+\n+               function Check_Node (N : Node_Id) return Traverse_Result;\n+               --  Check that node N meets the lock free restrictions\n+\n+               ----------------\n+               -- Check_Node --\n+               ----------------\n+\n+               function Check_Node (N : Node_Id) return Traverse_Result is\n+               begin\n+                  --  Function calls and attribute references must be static\n+\n+                  if Nkind_In (N, N_Attribute_Reference, N_Function_Call)\n+                    and then not Is_Static_Expression (N)\n+                  then\n+                     return Abandon;\n+\n+                  --  Loop statements and procedure calls are prohibited\n+\n+                  elsif Nkind_In (N, N_Loop_Statement,\n+                                     N_Procedure_Call_Statement)\n+                  then\n+                     return Abandon;\n+\n+                  --  References\n+\n+                  elsif Nkind (N) = N_Identifier\n+                    and then Present (Entity (N))\n+                  then\n+                     declare\n+                        Id     : constant Entity_Id := Entity (N);\n+                        Sub_Id : constant Entity_Id :=\n+                                   Corresponding_Spec (Sub_Body);\n+\n+                     begin\n+                        --  Prohibit references to non-constant entities\n+                        --  outside the protected subprogram scope.\n+\n+                        if Ekind (Id) in Assignable_Kind\n+                          and then not Scope_Within_Or_Same (Scope (Id),\n+                                         Sub_Id)\n+                          and then not Scope_Within_Or_Same (Scope (Id),\n+                                         Protected_Body_Subprogram (Sub_Id))\n+                        then\n+                           return Abandon;\n+\n+                        --  Prohibit non-scalar out parameters (scalar\n+                        --  parameters are passed by copy).\n+\n+                        elsif Ekind_In (Id, E_Out_Parameter,\n+                                            E_In_Out_Parameter)\n+                          and then not Is_Scalar_Type (Etype (Id))\n+                          and then Scope_Within_Or_Same (Scope (Id), Sub_Id)\n+                        then\n+                           return Abandon;\n+\n+                        --  A protected subprogram may reference only one\n+                        --  component of the protected type.\n+\n+                        elsif Ekind (Id) = E_Component then\n+                           declare\n+                              Comp_Decl : constant Node_Id := Parent (Id);\n+                           begin\n+                              if Nkind (Comp_Decl) = N_Component_Declaration\n+                                and then Is_List_Member (Comp_Decl)\n+                                and then List_Containing (Comp_Decl) =\n+                                           Priv_Decls\n+                              then\n+                                 if No (Comp) then\n+                                    Comp := Id;\n+\n+                                 --  Check if another protected component has\n+                                 --  already been accessed by the subprogram\n+                                 --  body.\n+\n+                                 elsif Comp /= Id then\n+                                    return Abandon;\n+                                 end if;\n+                              end if;\n+                           end;\n+\n+                        elsif Ekind_In (Id, E_Constant, E_Variable)\n+                          and then Present (Prival_Link (Id))\n+                        then\n+                           declare\n+                              Comp_Decl : constant Node_Id :=\n+                                            Parent (Prival_Link (Id));\n+                           begin\n+                              if Nkind (Comp_Decl) = N_Component_Declaration\n+                                and then Is_List_Member (Comp_Decl)\n+                                and then List_Containing (Comp_Decl) =\n+                                           Priv_Decls\n+                              then\n+                                 if No (Comp) then\n+                                    Comp := Prival_Link (Id);\n+\n+                                 --  Check if another protected component has\n+                                 --  already been accessed by the subprogram\n+                                 --  body.\n+\n+                                 elsif Comp /= Prival_Link (Id) then\n+                                    return Abandon;\n+                                 end if;\n+                              end if;\n+                           end;\n+                        end if;\n+                     end;\n+                  end if;\n+\n+                  return OK;\n+               end Check_Node;\n+\n+               function Check_All_Nodes is new Traverse_Func (Check_Node);\n+\n+            --  Start of processing for Satisfies_Lock_Free_Requirements\n+\n+            begin\n+               if Check_All_Nodes (Sub_Body) = OK then\n+\n+                  --  Establish a relation between the subprogram body and the\n+                  --  unique protected component it references.\n+\n+                  if Present (Comp) then\n+                     Lock_Free_Subprogram_Table.Append\n+                       (Lock_Free_Subprogram'(Sub_Body, Comp));\n+                  end if;\n+\n+                  return True;\n+               else\n+                  return False;\n+               end if;\n+            end Satisfies_Lock_Free_Requirements;\n+\n+         begin\n+            Decl := First (Decls);\n+\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Subprogram_Body\n+                 and then not Satisfies_Lock_Free_Requirements (Decl)\n+               then\n+                  if Complain then\n+                     Error_Msg_N (\"body prevents lock-free implementation\",\n+                                  Decl);\n+                  end if;\n+\n+                  return False;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end;\n+      end if;\n+\n+      return True;\n+   end Allows_Lock_Free_Implementation;\n+\n    -----------------------------\n    -- Analyze_Abort_Statement --\n    -----------------------------\n@@ -1057,6 +1381,7 @@ package body Sem_Ch9 is\n \n    procedure Analyze_Protected_Body (N : Node_Id) is\n       Body_Id : constant Entity_Id := Defining_Identifier (N);\n+      Aspect  : Node_Id;\n       Last_E  : Entity_Id;\n \n       Spec_Id : Entity_Id;\n@@ -1130,6 +1455,42 @@ package body Sem_Ch9 is\n       Check_References (Spec_Id);\n       Process_End_Label (N, 't', Ref_Id);\n       End_Scope;\n+\n+      --  Turn on/off the lock-free implementation for the protected object\n+\n+      --  Look for a Lock_Free aspect with a False expression that disables the\n+      --  lock-free implementation.\n+\n+      Aspect := First (Aspect_Specifications (Parent (Spec_Id)));\n+\n+      while Present (Aspect) loop\n+         if Get_Aspect_Id (Chars (Identifier (Aspect))) = Aspect_Lock_Free\n+           and then Present (Expression (Aspect))\n+           and then Entity (Expression (Aspect)) = Standard_False\n+         then\n+            return;\n+         end if;\n+\n+         Next (Aspect);\n+      end loop;\n+\n+      --  When a Lock_Free aspect forces the lock-free implementation, verify\n+      --  the protected body meets all the restrictions, otherwise\n+      --  Allows_Lock_Free_Implementation issues an error message.\n+\n+      if Uses_Lock_Free (Spec_Id) then\n+         if not Allows_Lock_Free_Implementation (N, Complain => True) then\n+            return;\n+         end if;\n+\n+      --  In other cases, check both the protected declaration and body satisfy\n+      --  the lock-free restrictions.\n+\n+      elsif Allows_Lock_Free_Implementation (Parent (Spec_Id))\n+        and then Allows_Lock_Free_Implementation (N)\n+      then\n+         Set_Uses_Lock_Free (Spec_Id);\n+      end if;\n    end Analyze_Protected_Body;\n \n    ----------------------------------\n@@ -1347,6 +1708,16 @@ package body Sem_Ch9 is\n \n       End_Scope;\n \n+      --  When a Lock_Free aspect forces the lock-free implementation, check N\n+      --  meets all the lock-free restrictions. Otherwise,\n+      --  Allows_Lock_Free_Implementation issue an error message.\n+\n+      if Uses_Lock_Free (Defining_Identifier (N)) then\n+         if not Allows_Lock_Free_Implementation (N, Complain => True) then\n+            return;\n+         end if;\n+      end if;\n+\n       --  Case of a completion of a private declaration\n \n       if T /= Def_Id\n@@ -1840,10 +2211,6 @@ package body Sem_Ch9 is\n       --  disastrous result.\n \n       Analyze_Protected_Type_Declaration (N);\n-\n-      if Has_Aspects (N) then\n-         Analyze_Aspect_Specifications (N, Id);\n-      end if;\n    end Analyze_Single_Protected_Declaration;\n \n    -------------------------------------"}, {"sha": "5cb7916974a9dec5ba999612c28bcb032b9cfba2", "filename": "gcc/ada/sem_ch9.ads", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fsem_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fsem_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.ads?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Table;\n with Types; use Types;\n \n package Sem_Ch9  is\n@@ -52,4 +53,35 @@ package Sem_Ch9  is\n    procedure Analyze_Terminate_Alternative              (N : Node_Id);\n    procedure Analyze_Timed_Entry_Call                   (N : Node_Id);\n    procedure Analyze_Triggering_Alternative             (N : Node_Id);\n+\n+   ------------------------------\n+   -- Lock Free Data Structure --\n+   ------------------------------\n+\n+   --  A lock-free subprogram is a protected routine which references a unique\n+   --  protected scalar component and does not contain statements that cause\n+   --  side effects. Due to this restricted behavior, all references to shared\n+   --  data from within the subprogram can be synchronized through the use of\n+   --  atomic operations rather than relying on locks.\n+\n+   type Lock_Free_Subprogram is record\n+      Sub_Body : Node_Id;\n+      --  Reference to the body of a protected subprogram which meets the lock-\n+      --  free requirements.\n+\n+      Comp_Id : Entity_Id;\n+      --  Reference to the scalar component referenced from within Sub_Body\n+   end record;\n+\n+   --  This table establishes a relation between a protected subprogram body\n+   --  and a unique component it references. The table is used when building\n+   --  the lock-free versions of a protected subprogram body.\n+\n+   package Lock_Free_Subprogram_Table is new Table.Table (\n+     Table_Component_Type => Lock_Free_Subprogram,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 5,\n+     Table_Increment      => 5,\n+     Table_Name           => \"Lock_Free_Subprogram_Table\");\n end Sem_Ch9;"}, {"sha": "c402967e7330e8adf67fa1b0cac1c51c7f03ecef", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88e7531bebc927b249c2055caddcb93c43359820/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=88e7531bebc927b249c2055caddcb93c43359820", "patch": "@@ -142,6 +142,7 @@ package Snames is\n    Name_Dimension                      : constant Name_Id := N + $;\n    Name_Dimension_System               : constant Name_Id := N + $;\n    Name_Dynamic_Predicate              : constant Name_Id := N + $;\n+   Name_Lock_Free                      : constant Name_Id := N + $;\n    Name_Post                           : constant Name_Id := N + $;\n    Name_Pre                            : constant Name_Id := N + $;\n    Name_Static_Predicate               : constant Name_Id := N + $;"}]}