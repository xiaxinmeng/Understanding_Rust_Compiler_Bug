{"sha": "5ae74944af1de032d4a27fad4a2287bd3a2163fd", "node_id": "C_kwDOANBUbNoAKDVhZTc0OTQ0YWYxZGUwMzJkNGEyN2ZhZDRhMjI4N2JkM2EyMTYzZmQ", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-07-12T10:18:47Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-07-12T22:35:28Z"}, "message": "libstdc++: Check for EOF if extraction avoids buffer overflow [PR106248]\n\nIn r11-2581-g17abcc77341584 (for LWG 2499) I added overflow checks to\nthe pre-C++20 operator>>(istream&, char*) overload.  Those checks can\ncause extraction to stop after filling the buffer, where previously it\nwould have tried to extract another character and stopped at EOF. When\nthat happens we no longer set eofbit in the stream state, which is\nconsistent with the behaviour of the new C++20 overload, but is an\nobservable and unexpected change in the C++17 behaviour. What makes it\nworse is that the behaviour change is dependent on optimization, because\n__builtin_object_size is used to detect the buffer size and that only\nworks when optimizing.\n\nTo avoid the unexpected and optimization-dependent change in behaviour,\nset eofbit manually if we stopped extracting because of the buffer size\ncheck, but had reached EOF anyway. If the stream's rdstate() != goodbit\nor width() is non-zero and smaller than the buffer, there's nothing to\ndo. Otherwise, we filled the buffer and need to check for EOF, and maybe\nset eofbit.\n\nThe new check is guarded by #ifdef __OPTIMIZE__ because otherwise\n__builtin_object_size is useless. There's no point compiling and\nemitting dead code that can't be eliminated because we're not\noptimizing.\n\nWe could add extra checks that the next character in the buffer is not\nwhitespace, to detect the case where we stopped early and prevented a\nbuffer overflow that would have happened otherwise. That would allow us\nto assert or set badbit in the stream state when undefined behaviour was\nprevented. However, those extra checks would increase the size of the\nfunction, potentially reducing the likelihood of it being inlined, and\nso making the buffer size detection less reliable. It seems preferable\nto prevent UB and silently truncate, rather than miss the UB and allow\nthe overflow to happen.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/106248\n\t* include/std/istream [C++17] (operator>>(istream&, char*)):\n\tSet eofbit if we stopped extracting at EOF.\n\t* testsuite/27_io/basic_istream/extractors_character/char/pr106248.cc:\n\tNew test.\n\t* testsuite/27_io/basic_istream/extractors_character/wchar_t/pr106248.cc:\n\tNew test.", "tree": {"sha": "787bb0eaf58c10b752a0f54a96ea53b1cc9de8b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/787bb0eaf58c10b752a0f54a96ea53b1cc9de8b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ae74944af1de032d4a27fad4a2287bd3a2163fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ae74944af1de032d4a27fad4a2287bd3a2163fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ae74944af1de032d4a27fad4a2287bd3a2163fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ae74944af1de032d4a27fad4a2287bd3a2163fd/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e9d5dfc2911e3acc6039ebfe3837e7ba4be197f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e9d5dfc2911e3acc6039ebfe3837e7ba4be197f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e9d5dfc2911e3acc6039ebfe3837e7ba4be197f"}], "stats": {"total": 111, "additions": 106, "deletions": 5}, "files": [{"sha": "416ef556fa1703a27103302249ddae79f0b30ed6", "filename": "libstdc++-v3/include/std/istream", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ae74944af1de032d4a27fad4a2287bd3a2163fd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ae74944af1de032d4a27fad4a2287bd3a2163fd/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream?ref=5ae74944af1de032d4a27fad4a2287bd3a2163fd", "patch": "@@ -784,7 +784,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  - if `width()` is greater than zero, `n` is `min(width(), n)`\n    *  - otherwise `n` is the number of elements of the array\n    *  - (before C++20 the pointer is assumed to point to an array of\n-   *  - the largest possible size for an array of `char_type`).\n+   *    the largest possible size for an array of `char_type`).\n    *\n    *  Characters are extracted and stored until one of the following happens:\n    *  - `n - 1` characters are stored\n@@ -802,19 +802,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline basic_istream<_CharT, _Traits>&\n     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)\n     {\n+#ifdef __OPTIMIZE__\n+      // Function inlining might make the buffer size known, allowing us to\n+      // prevent overflow.\n       size_t __n = __builtin_object_size(__s, 0);\n-      if (__builtin_expect(__n < sizeof(_CharT), false))\n+      if (__n < sizeof(_CharT))\n \t{\n \t  // There is not even space for the required null terminator.\n \t  __glibcxx_assert(__n >= sizeof(_CharT));\n+\t  // No point calling __istream_extract, but still need to reset width.\n \t  __in.width(0);\n \t  __in.setstate(ios_base::failbit);\n \t}\n+      else if (__n != (size_t)-1)\n+\t{\n+\t  __n /= sizeof(_CharT);\n+\t  streamsize __w = __in.width();\n+\t  std::__istream_extract(__in, __s, __n);\n+\t  if (__in.good() && (__w <= 0 || __n < __w))\n+\t    {\n+\t      // Stopped extracting early to avoid overflowing the buffer,\n+\t      // but might have stopped anyway (and set eofbit) if at EOF.\n+\t      const typename _Traits::int_type __c = __in.rdbuf()->sgetc();\n+\t      const bool __eof = _Traits::eq_int_type(__c, _Traits::eof());\n+\t      if (__builtin_expect(__eof, true)) // Assume EOF, not overflow.\n+\t\t__in.setstate(ios_base::eofbit);\n+\t    }\n+\t}\n       else\n+#endif // __OPTIMIZE\n \t{\n-\t  if (__n == (size_t)-1)\n-\t    __n = __gnu_cxx::__numeric_traits<streamsize>::__max;\n-\t  std::__istream_extract(__in, __s, __n / sizeof(_CharT));\n+\t  // Buffer size is unknown, have to assume it's huge.\n+\t  streamsize __n = __gnu_cxx::__numeric_traits<streamsize>::__max;\n+\t  __n /= sizeof(_CharT);\n+\t  std::__istream_extract(__in, __s, __n);\n \t}\n       return __in;\n     }"}, {"sha": "6d89a0e5fefc1cf5f52f302b019d2f4dfcc7f704", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/char/pr106248.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ae74944af1de032d4a27fad4a2287bd3a2163fd/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fchar%2Fpr106248.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ae74944af1de032d4a27fad4a2287bd3a2163fd/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fchar%2Fpr106248.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fchar%2Fpr106248.cc?ref=5ae74944af1de032d4a27fad4a2287bd3a2163fd", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do run }\n+\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_pr106248()\n+{\n+  char buf[5] = {'x', 'x', 'x', 'x', 'x'};\n+  std::string s(\"  four\");\n+  std::istringstream in(s);\n+  in >> buf;\n+#if __cplusplus >= 202002L\n+  // Extraction stops because buffer is full.\n+  VERIFY( in.good() );\n+#else\n+  // PR libstdc++/106248\n+  // Extraction stops because all input has been consumed and eofbit is set.\n+  VERIFY( in.eof() );\n+#endif\n+  // Extracted string must be null-terminated.\n+  VERIFY( buf[4] == '\\0' );\n+  VERIFY( std::string(buf) == \"four\" );\n+\n+  in.clear();\n+  in.str(s);\n+  for (int i = 0; i < 5; ++i)\n+    s[i] = 'x';\n+\n+  in.width(5);\n+  in >> buf;\n+  // Extraction stops due to field width, eofbit not set.\n+  VERIFY( in.good() );\n+  VERIFY( std::string(buf) == \"four\" );\n+}\n+\n+int main()\n+{\n+  test_pr106248();\n+}"}, {"sha": "7c226600b9e20b644bd139be07b29336a94988fd", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/extractors_character/wchar_t/pr106248.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ae74944af1de032d4a27fad4a2287bd3a2163fd/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fwchar_t%2Fpr106248.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ae74944af1de032d4a27fad4a2287bd3a2163fd/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fwchar_t%2Fpr106248.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fextractors_character%2Fwchar_t%2Fpr106248.cc?ref=5ae74944af1de032d4a27fad4a2287bd3a2163fd", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do run }\n+\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_pr106248()\n+{\n+  wchar_t buf[5] = {L'x', L'x', L'x', L'x', L'x'};\n+  std::wstring s(L\"  four\");\n+  std::wistringstream in(s);\n+  in >> buf;\n+#if __cplusplus >= 202002L\n+  // Extraction stops because buffer is full.\n+  VERIFY( in.good() );\n+#else\n+  // PR libstdc++/106248\n+  // Extraction stops because all input has been consumed and eofbit is set.\n+  VERIFY( in.eof() );\n+#endif\n+  // Extracted string must be null-terminated.\n+  VERIFY( buf[4] == L'\\0' );\n+  VERIFY( std::wstring(buf) == L\"four\" );\n+\n+  in.clear();\n+  in.str(s);\n+  for (int i = 0; i < 5; ++i)\n+    s[i] = L'x';\n+\n+  in.width(5);\n+  in >> buf;\n+  // Extraction stops due to field width, eofbit not set.\n+  VERIFY( in.good() );\n+  VERIFY( std::wstring(buf) == L\"four\" );\n+}\n+\n+int main()\n+{\n+  test_pr106248();\n+}"}]}