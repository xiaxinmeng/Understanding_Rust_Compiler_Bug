{"sha": "f20459f1b2211a6a48cfdf21151e81818dde5904", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjIwNDU5ZjFiMjIxMWE2YTQ4Y2ZkZjIxMTUxZTgxODE4ZGRlNTkwNA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2004-10-27T15:10:22Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2004-10-27T15:10:22Z"}, "message": "ffi.c (ffi_prep_cif_machdep): Handle functions that return long long values.\n\n* src/arm/ffi.c (ffi_prep_cif_machdep): Handle functions that return\nlong long values.  Round stack allocation to a multiple of 8 bytes\nfor ATPCS compatibility.\n* src/arm/sysv.S (ffi_call_SYSV): Rework to avoid use of APCS register\nnames.  Handle returning long long types.  Add Thumb and interworking\nsupport.  Improve soft-float code.\n\nFrom-SVN: r89681", "tree": {"sha": "a62193690e2806ff106cd3e9c9cf8928481f3800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a62193690e2806ff106cd3e9c9cf8928481f3800"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f20459f1b2211a6a48cfdf21151e81818dde5904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20459f1b2211a6a48cfdf21151e81818dde5904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f20459f1b2211a6a48cfdf21151e81818dde5904", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20459f1b2211a6a48cfdf21151e81818dde5904/comments", "author": null, "committer": null, "parents": [{"sha": "5ae4c565619048723021f9780baf259497804acc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ae4c565619048723021f9780baf259497804acc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ae4c565619048723021f9780baf259497804acc"}], "stats": {"total": 249, "additions": 175, "deletions": 74}, "files": [{"sha": "46d41da08131cc8609c1bb1988220bfb5c1dead7", "filename": "libffi/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20459f1b2211a6a48cfdf21151e81818dde5904/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20459f1b2211a6a48cfdf21151e81818dde5904/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=f20459f1b2211a6a48cfdf21151e81818dde5904", "patch": "@@ -1,3 +1,12 @@\n+2004-10-27  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* src/arm/ffi.c (ffi_prep_cif_machdep): Handle functions that return\n+\tlong long values.  Round stack allocation to a multiple of 8 bytes\n+\tfor ATPCS compatibility.\n+\t* src/arm/sysv.S (ffi_call_SYSV): Rework to avoid use of APCS register\n+\tnames.  Handle returning long long types.  Add Thumb and interworking\n+\tsupport.  Improve soft-float code.\n+\n 2004-10-27  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* testsuite/lib/libffi-db.exp (load_gcc_lib): New function."}, {"sha": "1f58d93ef19ae64baefbe1b78025e3fb59fec2b8", "filename": "libffi/src/arm/ffi.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20459f1b2211a6a48cfdf21151e81818dde5904/libffi%2Fsrc%2Farm%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20459f1b2211a6a48cfdf21151e81818dde5904/libffi%2Fsrc%2Farm%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffi.c?ref=f20459f1b2211a6a48cfdf21151e81818dde5904", "patch": "@@ -108,6 +108,11 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n /* Perform machine dependent cif processing */\n ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n {\n+  /* Round the stack up to a multiple of 8 bytes.  This isn't needed \n+     everywhere, but it is on some platforms, and it doesn't harm anything\n+     when it isn't needed.  */\n+  cif->bytes = (cif->bytes + 7) & ~7;\n+\n   /* Set the return type flag */\n   switch (cif->rtype->type)\n     {\n@@ -118,6 +123,11 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       cif->flags = (unsigned) cif->rtype->type;\n       break;\n \n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+      cif->flags = (unsigned) FFI_TYPE_SINT64;\n+      break;\n+\n     default:\n       cif->flags = FFI_TYPE_INT;\n       break;"}, {"sha": "c3471a8a2ff1d8f1aeecd2b81d22cc5693931212", "filename": "libffi/src/arm/sysv.S", "status": "modified", "additions": 156, "deletions": 74, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f20459f1b2211a6a48cfdf21151e81818dde5904/libffi%2Fsrc%2Farm%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f20459f1b2211a6a48cfdf21151e81818dde5904/libffi%2Fsrc%2Farm%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fsysv.S?ref=f20459f1b2211a6a48cfdf21151e81818dde5904", "patch": "@@ -40,87 +40,169 @@\n #endif\n #define ENTRY(x) .globl CNAME(x); .type CNAME(x),%function; CNAME(x):\n #endif\n+\n+#ifdef __ELF__\n+#define LSYM(x) .x\n+#else\n+#define LSYM(x) x\n+#endif\n+\n+/* We need a better way of testing for this, but for now, this is all \n+   we can do.  */\n+@ This selects the minimum architecture level required.\n+#define __ARM_ARCH__ 3\n+\n+#if defined(__ARM_ARCH_4__) || defined(__ARM_ARCH_4T__)\n+# undef __ARM_ARCH__\n+# define __ARM_ARCH__ 4\n+#endif\n+        \n+#if defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) \\\n+\t|| defined(__ARM_ARCH_5E__) || defined(__ARM_ARCH_5TE__) \\\n+\t|| defined(__ARM_ARCH_5TEJ__)\n+# undef __ARM_ARCH__\n+# define __ARM_ARCH__ 5\n+#endif\n+\n+#if defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \\\n+        || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) \\\n+        || defined(__ARM_ARCH_6ZK__)\n+# undef __ARM_ARCH__\n+# define __ARM_ARCH__ 6\n+#endif\n+\n+#if __ARM_ARCH__ >= 5\n+# define call_reg(x)\tblx\tx\n+#elif defined (__ARM_ARCH_4T__)\n+# define call_reg(x)\tmov\tlr, pc ; bx\tx\n+# if defined(__thumb__) || defined(__THUMB_INTERWORK__)\n+#  define __INTERWORKING__\n+# endif\n+#else\n+# define call_reg(x)\tmov\tlr, pc ; mov\tpc, x\n+#endif\n+\n+#if defined(__thumb__) && !defined(__THUMB_INTERWORK__)\n+.macro\tARM_FUNC_START name\n+\t.text\n+\t.align 0\n+\t.thumb\n+\t.thumb_func\n+\tENTRY(\\name)\n+\tbx\tpc\n+\tnop\n+\t.arm\n+/* A hook to tell gdb that we've switched to ARM mode.  Also used to call\n+   directly from other local arm routines.  */\n+_L__\\name:\t\t\n+.endm\n+#else\n+.macro\tARM_FUNC_START name\n+\t.text\n+\t.align 0\n+\t.arm\n+\tENTRY(\\name)\n+.endm\n+#endif\n+\n+.macro\tRETLDM\tregs=, cond=, dirn=ia\n+#if defined (__INTERWORKING__)\n+\t.ifc \"\\regs\",\"\"\n+\tldr\\cond\tlr, [sp], #4\n+\t.else\n+\tldm\\cond\\dirn\tsp!, {\\regs, lr}\n+\t.endif\n+\tbx\\cond\tlr\n+#else\n+\t.ifc \"\\regs\",\"\"\n+\tldr\\cond\tpc, [sp], #4\n+\t.else\n+\tldm\\cond\\dirn\tsp!, {\\regs, pc}\n+\t.endif\n+#endif\n+.endm\n+\n+\n+\t@ r0:   ffi_prep_args\n+\t@ r1:   &ecif\n+\t@ r2:   cif->bytes\n+\t@ r3:   fig->flags\n+\t@ sp+0: ecif.rvalue\n+\t@ sp+4: fn\n+\n+\t@ This assumes we are using gas.\n+ARM_FUNC_START ffi_call_SYSV\n+\t@ Save registers\n+        stmfd\tsp!, {r0-r3, fp, lr}\n+\tmov\tfp, sp\n+\n+\t@ Make room for all of the new args.\n+\tsub\tsp, fp, r2\n+\n+\t@ Place all of the ffi_prep_args in position\n+\tmov\tip, r0\n+\tmov\tr0, sp\n+\t@     r1 already set\n+\n+\t@ Call ffi_prep_args(stack, &ecif)\n+\tcall_reg(ip)\n+\n+\t@ move first 4 parameters in registers\n+\tldmia\tsp, {r0-r3}\n+\n+\t@ and adjust stack\n+\tldr\tip, [fp, #8]\n+        cmp\tip, #16\n+\tmovhs\tip, #16\n+        add\tsp, sp, ip\n+\n+\t@ call (fn) (...)\n+\tldr\tip, [fp, #28]\n+\tcall_reg(ip)\n \t\n-.text\n-\n-\t# a1:   ffi_prep_args\n-\t# a2:   &ecif\n-\t# a3:   cif->bytes\n-\t# a4:   fig->flags\n-\t# sp+0: ecif.rvalue\n-\t# sp+4: fn\n-\n-\t# This assumes we are using gas.\n-ENTRY(ffi_call_SYSV)\n-\t# Save registers\n-        stmfd sp!, {a1-a4, fp, lr}\n-\tmov   fp, sp\n-\n-\t# Make room for all of the new args.\n-\tsub   sp, fp, a3\n-\n-\t# Place all of the ffi_prep_args in position\n-\tmov   ip, a1\n-\tmov   a1, sp\n-\t#     a2 already set\n-\n-\t# And call\n-\tmov   lr, pc\n-\tmov   pc, ip\n-\n-\t# move first 4 parameters in registers\n-\tldr   a1, [sp, #0]\n-\tldr   a2, [sp, #4]\n-\tldr   a3, [sp, #8]\n-        ldr   a4, [sp, #12]\n-\n-\t# and adjust stack\n-\tldr   ip, [fp, #8]\n-        cmp   ip, #16\n-\tmovge ip, #16\n-        add   sp, sp, ip\n-\n-\t# call function\n-\tmov   lr, pc\n-\tldr   pc, [fp, #28]\n-\n-\t# Remove the space we pushed for the args\n-\tmov   sp, fp\n-\n-\t# Load a3 with the pointer to storage for the return value\n-\tldr   a3, [sp, #24]\n-\n-\t# Load a4 with the return type code \n-\tldr   a4, [sp, #12]\n-\n-\t# If the return value pointer is NULL, assume no return value.\n-\tcmp   a3, #0\n-\tbeq   epilogue\n-\n-# return INT\n-\tcmp   a4, #FFI_TYPE_INT\n-\tstreq a1, [a3]\n-\tbeq   epilogue\n-\n-# return FLOAT\n-\tcmp     a4, #FFI_TYPE_FLOAT\n+\t@ Remove the space we pushed for the args\n+\tmov\tsp, fp\n+\n+\t@ Load r2 with the pointer to storage for the return value\n+\tldr\tr2, [sp, #24]\n+\n+\t@ Load r3 with the return type code \n+\tldr\tr3, [sp, #12]\n+\n+\t@ If the return value pointer is NULL, assume no return value.\n+\tcmp\tr2, #0\n+\tbeq\tLSYM(Lepilogue)\n+\n+@ return INT\n+\tcmp\tr3, #FFI_TYPE_INT\n #ifdef __SOFTFP__\n-\tstreq\ta1, [a3]\n-#else\n-\tstfeqs  f0, [a3]\n+\tcmpne\tr3, #FFI_TYPE_FLOAT\n #endif\n-\tbeq     epilogue\n+\tstreq\tr0, [r2]\n+\tbeq\tLSYM(Lepilogue)\n \n-# return DOUBLE or LONGDOUBLE\n-\tcmp     a4, #FFI_TYPE_DOUBLE\n+\t@ return INT64\n+\tcmp\tr3, #FFI_TYPE_SINT64\n #ifdef __SOFTFP__\n-\tstmeqia\ta3, {a1, a2}\n-#else\n-\tstfeqd  f0, [a3]\n+\tcmpne\tr3, #FFI_TYPE_DOUBLE\n+#endif\n+\tstmeqia\tr2, {r0, r1}\n+\n+#ifndef __SOFTFP__\n+\tbeq\tLSYM(Lepilogue)\n+\n+@ return FLOAT\n+\tcmp\tr3, #FFI_TYPE_FLOAT\n+\tstfeqs\tf0, [r2]\n+\tbeq\tLSYM(Lepilogue)\n+\n+@ return DOUBLE or LONGDOUBLE\n+\tcmp\tr3, #FFI_TYPE_DOUBLE\n+\tstfeqd\tf0, [r2]\n #endif\n \n-epilogue:\n-        ldmfd sp!, {a1-a4, fp, pc}\n+LSYM(Lepilogue):\n+\tRETLDM\t\"r0-r3,fp\"\n \n .ffi_call_SYSV_end:\n         .size    CNAME(ffi_call_SYSV),.ffi_call_SYSV_end-CNAME(ffi_call_SYSV)"}]}