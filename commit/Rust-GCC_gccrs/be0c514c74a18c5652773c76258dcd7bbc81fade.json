{"sha": "be0c514c74a18c5652773c76258dcd7bbc81fade", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUwYzUxNGM3NGExOGM1NjUyNzczYzc2MjU4ZGNkN2JiYzgxZmFkZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-08-31T16:26:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-08-31T16:26:51Z"}, "message": "re PR rtl-optimization/23601 (reload may drop non-call exception information)\n\n        PR rtl-opt/23601\n        * reload1.c (reload): Set MEM_NOTRAP_P in spill slots.\n        (fixup_eh_region_note): New.\n        (reload_as_needed): Call it.\n        (fixup_abnormal_edges): Allow all throwing insns to be deleted;\n        don't call find_many_sub_basic_blocks; call verify_flow_info.\n        * function.c (assign_stack_local_1): Set MEM_NOTRAP_P.\n        (keep_stack_depressed): Likewise.\n        (assign_stack_temp_for_type): Likewise; use adjust_address_nv.\n\nFrom-SVN: r103680", "tree": {"sha": "f7a2dee22307156d52f9729484b53473c1ff7f74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7a2dee22307156d52f9729484b53473c1ff7f74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be0c514c74a18c5652773c76258dcd7bbc81fade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be0c514c74a18c5652773c76258dcd7bbc81fade", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be0c514c74a18c5652773c76258dcd7bbc81fade", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be0c514c74a18c5652773c76258dcd7bbc81fade/comments", "author": null, "committer": null, "parents": [{"sha": "5d3018cee7e9cea99b2b6c823ef3d8ee3c756474", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d3018cee7e9cea99b2b6c823ef3d8ee3c756474", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d3018cee7e9cea99b2b6c823ef3d8ee3c756474"}], "stats": {"total": 162, "additions": 122, "deletions": 40}, "files": [{"sha": "49812f2a8676ff7b86a37dc4c6a6c19118e5b6da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0c514c74a18c5652773c76258dcd7bbc81fade/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0c514c74a18c5652773c76258dcd7bbc81fade/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be0c514c74a18c5652773c76258dcd7bbc81fade", "patch": "@@ -1,3 +1,15 @@\n+2005-08-31  Richard Henderson  <rth@redhat.com>\n+\n+\tPR rtl-opt/23601\n+\t* reload1.c (reload): Set MEM_NOTRAP_P in spill slots.\n+\t(fixup_eh_region_note): New.\n+\t(reload_as_needed): Call it.\n+\t(fixup_abnormal_edges): Allow all throwing insns to be deleted;\n+\tdon't call find_many_sub_basic_blocks; call verify_flow_info.\n+\t* function.c (assign_stack_local_1): Set MEM_NOTRAP_P.\n+\t(keep_stack_depressed): Likewise.\n+\t(assign_stack_temp_for_type): Likewise; use adjust_address_nv.\n+\n 2005-08-31  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (ix86_function_ok_for_sibcall): Fix test for"}, {"sha": "3ee5e8b8892a89fe6be26e7dbe5c6a4e930f6813", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0c514c74a18c5652773c76258dcd7bbc81fade/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0c514c74a18c5652773c76258dcd7bbc81fade/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=be0c514c74a18c5652773c76258dcd7bbc81fade", "patch": "@@ -474,6 +474,7 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size, int align,\n     function->x_frame_offset += size;\n \n   x = gen_rtx_MEM (mode, addr);\n+  MEM_NOTRAP_P (x) = 1;\n \n   function->x_stack_slot_list\n     = gen_rtx_EXPR_LIST (VOIDmode, x, function->x_stack_slot_list);\n@@ -649,9 +650,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n \t      p->size = best_p->size - rounded_size;\n \t      p->base_offset = best_p->base_offset + rounded_size;\n \t      p->full_size = best_p->full_size - rounded_size;\n-\t      p->slot = gen_rtx_MEM (BLKmode,\n-\t\t\t\t     plus_constant (XEXP (best_p->slot, 0),\n-\t\t\t\t\t\t    rounded_size));\n+\t      p->slot = adjust_address_nv (best_p->slot, BLKmode, rounded_size);\n \t      p->align = best_p->align;\n \t      p->address = 0;\n \t      p->type = best_p->type;\n@@ -743,6 +742,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n       MEM_VOLATILE_P (slot) = TYPE_VOLATILE (type);\n       MEM_SET_IN_STRUCT_P (slot, AGGREGATE_TYPE_P (type));\n     }\n+  MEM_NOTRAP_P (slot) = 1;\n \n   return slot;\n }\n@@ -4822,6 +4822,7 @@ keep_stack_depressed (rtx insns)\n \t\t\t\t\t\t\t   info.sp_offset));\n \n \t  retaddr = gen_rtx_MEM (Pmode, retaddr);\n+\t  MEM_NOTRAP_P (retaddr) = 1;\n \n \t  /* If there is a pending load to the equivalent register for SP\n \t     and we reference that register, we must load our address into"}, {"sha": "eb2ce0f3d747a53745e8b5a52ddb747890aa3881", "filename": "gcc/reload1.c", "status": "modified", "additions": 106, "deletions": 37, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be0c514c74a18c5652773c76258dcd7bbc81fade/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be0c514c74a18c5652773c76258dcd7bbc81fade/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=be0c514c74a18c5652773c76258dcd7bbc81fade", "patch": "@@ -1125,6 +1125,7 @@ reload (rtx first, int global)\n \t\t  MEM_IN_STRUCT_P (reg) = MEM_SCALAR_P (reg) = 0;\n \t\t  MEM_ATTRS (reg) = 0;\n \t\t}\n+\t      MEM_NOTRAP_P (reg) = 1;\n \t    }\n \t  else if (reg_equiv_mem[i])\n \t    XEXP (reg_equiv_mem[i], 0) = addr;\n@@ -3758,6 +3759,55 @@ scan_paradoxical_subregs (rtx x)\n     }\n }\n \f\n+/* A subroutine of reload_as_needed.  If INSN has a REG_EH_REGION note,\n+   examine all of the reload insns between PREV and NEXT exclusive, and\n+   annotate all that may trap.  */\n+\n+static void\n+fixup_eh_region_note (rtx insn, rtx prev, rtx next)\n+{\n+  rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n+  unsigned int trap_count;\n+  rtx i;\n+\n+  if (note == NULL)\n+    return;\n+\n+  if (may_trap_p (PATTERN (insn)))\n+    trap_count = 1;\n+  else\n+    {\n+      remove_note (insn, note);\n+      trap_count = 0;\n+    }\n+\n+  for (i = NEXT_INSN (prev); i != next; i = NEXT_INSN (i))\n+    if (INSN_P (i) && i != insn && may_trap_p (PATTERN (i)))\n+      {\n+\ttrap_count++;\n+\tREG_NOTES (i)\n+\t  = gen_rtx_EXPR_LIST (REG_EH_REGION, XEXP (note, 0), REG_NOTES (i));\n+      }\n+\n+  /* ??? Since we entered with one eh insn, we should exit with one eh insn;\n+     otherwise we're unsure that we're not losing an exception.  Except that\n+     the instruction stream incoming to reload doesn't pass the \"if \n+     reg_eh_region is present, may_trap_p is true\" smoke test.\n+\n+     Worse, even if it did, rtx_addr_can_trap_p returns false for some forms\n+     of address that include constants regardless of the actual value of the\n+     constant.  If we decide that \"int a[3]; a[100000]\" should be considered\n+     non-trapping, we should get that story straight across more of the\n+     compiler.  If we decide that it should trap, then we cannot decide\n+     may_trap_p on the basis of rtx_addr_can_trap_p at all.  Which may not\n+     be such a big thing -- it doesn't seem hard to get MEM_NOTRAP_P set\n+     correctly in the first place.\n+\n+     Fixing all that is not in the cards for gcc 4.2, so for the nonce we\n+     allow all eh insns to evaporate.  */\n+  gcc_assert (trap_count <= 1);\n+}\n+\n /* Reload pseudo-registers into hard regs around each insn as needed.\n    Additional register load insns are output before the insn that needs it\n    and perhaps store insns after insns that modify the reloaded pseudo reg.\n@@ -3875,10 +3925,13 @@ reload_as_needed (int live_known)\n \t\t and that we moved the structure into).  */\n \t      subst_reloads (insn);\n \n+\t      /* Adjust the exception region notes for loads and stores.  */\n+\t      if (flag_non_call_exceptions)\n+\t\tfixup_eh_region_note (insn, prev, next);\n+\n \t      /* If this was an ASM, make sure that all the reload insns\n \t\t we have generated are valid.  If not, give an error\n \t\t and delete them.  */\n-\n \t      if (asm_noperands (PATTERN (insn)) >= 0)\n \t\tfor (p = NEXT_INSN (prev); p != next; p = NEXT_INSN (p))\n \t\t  if (p != insn && INSN_P (p)\n@@ -8080,55 +8133,71 @@ fixup_abnormal_edges (void)\n       if (e && !CALL_P (BB_END (bb))\n \t  && !can_throw_internal (BB_END (bb)))\n \t{\n-\t  rtx insn = BB_END (bb), stop = NEXT_INSN (BB_END (bb));\n-\t  rtx next;\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if (e->flags & EDGE_FALLTHRU)\n-\t      break;\n-\t  /* Get past the new insns generated. Allow notes, as the insns may\n-\t     be already deleted.  */\n+\t  rtx insn;\n+\n+\t  /* Get past the new insns generated.  Allow notes, as the insns\n+\t     may be already deleted.  */\n+\t  insn = BB_END (bb);\n \t  while ((NONJUMP_INSN_P (insn) || NOTE_P (insn))\n \t\t && !can_throw_internal (insn)\n \t\t && insn != BB_HEAD (bb))\n \t    insn = PREV_INSN (insn);\n-\t  gcc_assert (CALL_P (insn) || can_throw_internal (insn));\n-\t  BB_END (bb) = insn;\n-\t  inserted = true;\n-\t  insn = NEXT_INSN (insn);\n-\t  while (insn && insn != stop)\n+\n+\t  if (CALL_P (insn) || can_throw_internal (insn))\n \t    {\n-\t      next = NEXT_INSN (insn);\n-\t      if (INSN_P (insn))\n+\t      rtx stop, next;\n+\n+\t      stop = NEXT_INSN (BB_END (bb));\n+\t      BB_END (bb) = insn;\n+\t      insn = NEXT_INSN (insn);\n+\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\tif (e->flags & EDGE_FALLTHRU)\n+\t\t  break;\n+\n+\t      while (insn && insn != stop)\n \t\t{\n-\t          delete_insn (insn);\n-\n-\t\t  /* Sometimes there's still the return value USE.\n-\t\t     If it's placed after a trapping call (i.e. that\n-\t\t     call is the last insn anyway), we have no fallthru\n-\t\t     edge.  Simply delete this use and don't try to insert\n-\t\t     on the non-existent edge.  */\n-\t\t  if (GET_CODE (PATTERN (insn)) != USE)\n+\t\t  next = NEXT_INSN (insn);\n+\t\t  if (INSN_P (insn))\n \t\t    {\n-\t\t      /* We're not deleting it, we're moving it.  */\n-\t\t      INSN_DELETED_P (insn) = 0;\n-\t\t      PREV_INSN (insn) = NULL_RTX;\n-\t\t      NEXT_INSN (insn) = NULL_RTX;\n+\t              delete_insn (insn);\n+\n+\t\t      /* Sometimes there's still the return value USE.\n+\t\t\t If it's placed after a trapping call (i.e. that\n+\t\t\t call is the last insn anyway), we have no fallthru\n+\t\t\t edge.  Simply delete this use and don't try to insert\n+\t\t\t on the non-existent edge.  */\n+\t\t      if (GET_CODE (PATTERN (insn)) != USE)\n+\t\t\t{\n+\t\t\t  /* We're not deleting it, we're moving it.  */\n+\t\t\t  INSN_DELETED_P (insn) = 0;\n+\t\t\t  PREV_INSN (insn) = NULL_RTX;\n+\t\t\t  NEXT_INSN (insn) = NULL_RTX;\n \n-\t\t      insert_insn_on_edge (insn, e);\n+\t\t\t  insert_insn_on_edge (insn, e);\n+\t\t\t  inserted = true;\n+\t\t\t}\n \t\t    }\n+\t\t  insn = next;\n \t\t}\n-\t      insn = next;\n \t    }\n+\n+\t  /* It may be that we don't find any such trapping insn.  In this\n+\t     case we discovered quite late that the insn that had been \n+\t     marked as can_throw_internal in fact couldn't trap at all.\n+\t     So we should in fact delete the EH edges out of the block.  */\n+\t  else\n+\t    purge_dead_edges (bb);\n \t}\n     }\n-  /* We've possibly turned single trapping insn into multiple ones.  */\n-  if (flag_non_call_exceptions)\n-    {\n-      sbitmap blocks;\n-      blocks = sbitmap_alloc (last_basic_block);\n-      sbitmap_ones (blocks);\n-      find_many_sub_basic_blocks (blocks);\n-    }\n+\n   if (inserted)\n     commit_edge_insertions ();\n+\n+#ifdef ENABLE_CHECKING\n+  /* Verify that we didn't turn one trapping insn into many, and that\n+     we found and corrected all of the problems wrt fixups on the\n+     fallthru edge.  */\n+  verify_flow_info ();\n+#endif\n }"}]}