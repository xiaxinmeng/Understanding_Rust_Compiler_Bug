{"sha": "c838119946c9f75f1e42f4320275355822cc86fc", "node_id": "C_kwDOANBUbNoAKGM4MzgxMTk5NDZjOWY3NWYxZTQyZjQzMjAyNzUzNTU4MjJjYzg2ZmM", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-11-07T20:07:35Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-11-08T00:22:19Z"}, "message": "Add transitive inferred range processing.\n\nRewalk statements at the end of a block to see if any inferred ranges\naffect earlier calculations and register those as inferred ranges.\n\n\tgcc/\n\tPR tree-optimization/104530\n\t* gimple-range-cache.cc (ranger_cache::register_inferred_value):\n\tNew.  Split from:\n\t(ranger_cache::apply_inferred_ranges): Move setting cache to\n\tseparate function.\n\t* gimple-range-cache.h (register_inferred_value): New prototype.\n\t* gimple-range-infer.cc (infer_range_manager::has_range_p): New.\n\t* gimple-range-infer.h (has_range_p): New prototype.\n\t* gimple-range.cc (register_transitive_inferred_ranges): New.\n\t* gimple-range.h (register_transitive_inferred_ranges): New proto.\n\t* tree-vrp.cc (rvrp_folder::fold_stmt): Check for transitive inferred\n\tranges at the end of the block before folding final stmt.\n\n\tgcc/testsuite/\n\t* gcc.dg/pr104530.c: New.", "tree": {"sha": "2ca1a424406083b17d55461bfc69fc2a093c9d47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ca1a424406083b17d55461bfc69fc2a093c9d47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c838119946c9f75f1e42f4320275355822cc86fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c838119946c9f75f1e42f4320275355822cc86fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c838119946c9f75f1e42f4320275355822cc86fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c838119946c9f75f1e42f4320275355822cc86fc/comments", "author": null, "committer": null, "parents": [{"sha": "f8d901d00e94e5a03c3321b37303eddd7c321ecb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8d901d00e94e5a03c3321b37303eddd7c321ecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8d901d00e94e5a03c3321b37303eddd7c321ecb"}], "stats": {"total": 126, "additions": 112, "deletions": 14}, "files": [{"sha": "ce5a0c8155e6716f1eda0b38d7e5405e6f10667a", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=c838119946c9f75f1e42f4320275355822cc86fc", "patch": "@@ -1544,8 +1544,27 @@ ranger_cache::range_from_dom (vrange &r, tree name, basic_block start_bb,\n   return true;\n }\n \n-// This routine is used during a block walk to move the state of non-null for\n-// any operands on stmt S to nonnull.\n+// This routine will register an inferred value in block BB, and possibly\n+// update the on-entry cache if appropriate.\n+\n+void\n+ranger_cache::register_inferred_value (const vrange &ir, tree name,\n+\t\t\t\t       basic_block bb)\n+{\n+  Value_Range r (TREE_TYPE (name));\n+  if (!m_on_entry.get_bb_range (r, name, bb))\n+    exit_range (r, name, bb, RFD_READ_ONLY);\n+  if (r.intersect (ir))\n+    {\n+      m_on_entry.set_bb_range (name, bb, r);\n+      // If this range was invariant before, remove invariance.\n+      if (!m_gori.has_edge_range_p (name))\n+\tm_gori.set_range_invariant (name, false);\n+    }\n+}\n+\n+// This routine is used during a block walk to adjust any inferred ranges\n+// of operands on stmt S.\n \n void\n ranger_cache::apply_inferred_ranges (gimple *s)\n@@ -1574,17 +1593,6 @@ ranger_cache::apply_inferred_ranges (gimple *s)\n       tree name = infer.name (x);\n       m_exit.add_range (name, bb, infer.range (x));\n       if (update)\n-\t{\n-\t  Value_Range r (TREE_TYPE (name));\n-\t  if (!m_on_entry.get_bb_range (r, name, bb))\n-\t    exit_range (r, name, bb, RFD_READ_ONLY);\n-\t  if (r.intersect (infer.range (x)))\n-\t    {\n-\t      m_on_entry.set_bb_range (name, bb, r);\n-\t      // If this range was invariant before, remove invariance.\n-\t      if (!m_gori.has_edge_range_p (name))\n-\t\tm_gori.set_range_invariant (name, false);\n-\t    }\n-\t}\n+\tregister_inferred_value (infer.range (x), name, bb);\n     }\n }"}, {"sha": "8e3ae8f58c618c39d6311269395a447bed92929e", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=c838119946c9f75f1e42f4320275355822cc86fc", "patch": "@@ -87,6 +87,7 @@ class ranger_cache : public range_query\n \n   void propagate_updated_value (tree name, basic_block bb);\n \n+  void register_inferred_value (const vrange &r, tree name, basic_block bb);\n   void apply_inferred_ranges (gimple *s);\n   gori_compute m_gori;\n   infer_range_manager m_exit;"}, {"sha": "8714ef2ed419f47a7e69b8d2bb7a751c56da73ae", "filename": "gcc/gimple-range-infer.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range-infer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range-infer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.cc?ref=c838119946c9f75f1e42f4320275355822cc86fc", "patch": "@@ -252,6 +252,17 @@ infer_range_manager::get_nonzero (tree name)\n   return *(m_nonzero[v]);\n }\n \n+// Return TRUE if there are any range inferences in block BB.\n+\n+bool\n+infer_range_manager::has_range_p (basic_block bb)\n+{\n+  if (bb->index >= (int)m_on_exit.length ())\n+    return false;\n+  bitmap b = m_on_exit[bb->index].m_names;\n+  return b && !bitmap_empty_p (b);\n+}\n+\n // Return TRUE if NAME has a range inference in block BB.\n \n bool"}, {"sha": "10705e046d3a3bc7d9086eb7fa4b07addcda0b0f", "filename": "gcc/gimple-range-infer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range-infer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range-infer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-infer.h?ref=c838119946c9f75f1e42f4320275355822cc86fc", "patch": "@@ -62,6 +62,7 @@ class infer_range_manager\n   void add_range (tree name, basic_block bb, const vrange &r);\n   void add_nonzero (tree name, basic_block bb);\n   bool has_range_p (tree name, basic_block bb);\n+  bool has_range_p (basic_block bb);\n   bool maybe_adjust_range (vrange &r, tree name, basic_block bb);\n private:\n   class exit_range_head"}, {"sha": "2885d0fa21ef52e1576b52e3877e7137cd584ca3", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=c838119946c9f75f1e42f4320275355822cc86fc", "patch": "@@ -482,6 +482,54 @@ gimple_ranger::register_inferred_ranges (gimple *s)\n   m_cache.apply_inferred_ranges (s);\n }\n \n+// This function will walk the statements in BB to determine if any\n+// discovered inferred ranges in the block have any transitive effects,\n+// and if so, register those effects in BB.\n+\n+void\n+gimple_ranger::register_transitive_inferred_ranges (basic_block bb)\n+{\n+  // Return if there are no inferred ranges in BB.\n+  infer_range_manager &infer = m_cache.m_exit;\n+  if (!infer.has_range_p (bb))\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Checking for transitive inferred ranges in BB %d\\n\",\n+\t     bb->index);\n+\n+  for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n+       gsi_next (&si))\n+    {\n+      gimple *s = gsi_stmt (si);\n+      tree lhs = gimple_get_lhs (s);\n+      // If the LHS alreayd has an inferred effect, leave it be.\n+      if (!gimple_range_ssa_p (lhs) || infer.has_range_p (lhs, bb))\n+\tcontinue;\n+      // Pick up global value.\n+      Value_Range g (TREE_TYPE (lhs));\n+      range_of_expr (g, lhs);\n+\n+      // If either dependency has an inferred range, check if recalculating\n+      // the LHS is different than the global value. If so, register it as\n+      // an inferred range as well.\n+      Value_Range r (TREE_TYPE (lhs));\n+      r.set_undefined ();\n+      tree name1 = gori ().depend1 (lhs);\n+      tree name2 = gori ().depend2 (lhs);\n+      if ((name1 && infer.has_range_p (name1, bb))\n+\t  || (name2 && infer.has_range_p (name2, bb)))\n+\t{\n+\t  // Check if folding S produces a different result.\n+\t  if (fold_range (r, s, this) && g != r)\n+\t    {\n+\t      infer.add_range (lhs, bb, r);\n+\t      m_cache.register_inferred_value (r, lhs, bb);\n+\t    }\n+\t}\n+    }\n+}\n+\n // When a statement S has changed since the result was cached, re-evaluate\n // and update the global cache.\n "}, {"sha": "dfe8199b8b0d1a75dcc61893df848364e0598dc4", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=c838119946c9f75f1e42f4320275355822cc86fc", "patch": "@@ -62,6 +62,7 @@ class gimple_ranger : public range_query\n   auto_edge_flag non_executable_edge_flag;\n   bool fold_stmt (gimple_stmt_iterator *gsi, tree (*) (tree));\n   void register_inferred_ranges (gimple *s);\n+  void register_transitive_inferred_ranges (basic_block bb);\n protected:\n   bool fold_range_internal (vrange &r, gimple *s, tree name);\n   void prefill_name (vrange &r, tree name);"}, {"sha": "1ec10154e1b65064bc323803a380d74a04e91906", "filename": "gcc/testsuite/gcc.dg/pr104530.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104530.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104530.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104530.c?ref=c838119946c9f75f1e42f4320275355822cc86fc", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+void foo(void);\n+\n+static int a, *b = &a, c, d = 1;\n+\n+int main() {\n+    c = 0 == b;\n+    a = *b;\n+    if (c % d)\n+        for (; d; --d)\n+            foo();\n+    b = 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-not \"foo\" \"evrp\" } }  */\n+"}, {"sha": "3393c73a7db729e6e51de8a2fde4873f03ebc2ae", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c838119946c9f75f1e42f4320275355822cc86fc/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=c838119946c9f75f1e42f4320275355822cc86fc", "patch": "@@ -4501,6 +4501,15 @@ class rvrp_folder : public substitute_and_fold_engine\n \n   bool fold_stmt (gimple_stmt_iterator *gsi) override\n   {\n+    gimple *s = gsi_stmt (*gsi);\n+    // If this is a block ending condition, and there are inferred ranges,\n+    // reparse the block to see if there are any transitive inferred ranges.\n+    if (is_a<gcond *> (s))\n+      {\n+\tbasic_block bb = gimple_bb (s);\n+\tif (bb && s == gimple_outgoing_range_stmt_p (bb))\n+\t  m_ranger->register_transitive_inferred_ranges (bb);\n+      }\n     bool ret = m_simplifier.simplify (gsi);\n     if (!ret)\n       ret = m_ranger->fold_stmt (gsi, follow_single_use_edges);"}]}