{"sha": "ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY5MGE4OWU0ODBkMzE4YmJiMWEwOWZjYTFlYTc2YzFhODZlM2ViYg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2013-11-15T15:34:14Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2013-11-15T15:34:14Z"}, "message": "stl_map.h (map): Implement C++11 allocator-aware container requirements.\n\n\t* include/bits/stl_map.h (map): Implement C++11 allocator-aware\n\tcontainer requirements.\n\t* include/bits/stl_multimap.h (multimap): Likewise.\n\t* include/bits/stl_multiset.h (multiset): Likewise.\n\t* include/bits/stl_set.h (set): Likewise.\n\t* include/bits/stl_tree.h (_Rb_tree_node): Use __aligned_buffer and\n\tadd accessors for value.\n\t(_Rb_tree_iterator, _Rb_tree_const_iterator): Use _Rb_tree_node\n\taccessors.\n\t(_Rb_tree): Use allocator_traits and implement support for sets and\n\tmaps the be allocator-aware.\n\t* include/bits/forward_list.h (_Fwd_list_base::_M_create_node): Do\n\tnot zero-initialize storage buffer.\n\t* include/bits/hashtable_policy.h (_Hashtable_alloc::_M_allocate_node):\n\tLikewise.\n\t* include/bits/stl_vector.h (vector(vector&&, const allocator_type&)):\n\tAdd conditional noexcept specification.\n\t* doc/xml/manual/status_cxx2011.xml: Update status of containers.\n\t* testsuite/util/testsuite_allocator.h: Re-indent.\n\t* testsuite/23_containers/forward_list/allocator/copy.cc: Test\n\tallocator-extended copy constructor.\n\t* testsuite/23_containers/unordered_map/allocator/copy.cc: Likewise.\n\t* testsuite/23_containers/unordered_multimap/allocator/copy.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_multiset/allocator/copy.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_set/allocator/copy.cc: Likewise.\n\t* testsuite/23_containers/vector/allocator/copy.cc: Likewise.\n\t* testsuite/23_containers/forward_list/allocator/move.cc: New.\n\t* testsuite/23_containers/unordered_map/allocator/move.cc: New.\n\t* testsuite/23_containers/unordered_multimap/allocator/move.cc: New.\n\t* testsuite/23_containers/unordered_multiset/allocator/move.cc: New.\n\t* testsuite/23_containers/unordered_set/allocator/move.cc: New.\n\t* testsuite/23_containers/vector/allocator/move.cc: New.\n\t* testsuite/23_containers/map/allocator/copy.cc: New.\n\t* testsuite/23_containers/map/allocator/copy_assign.cc: New.\n\t* testsuite/23_containers/map/allocator/minimal.cc: New.\n\t* testsuite/23_containers/map/allocator/move.cc: New.\n\t* testsuite/23_containers/map/allocator/move_assign.cc: New.\n\t* testsuite/23_containers/map/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/map/allocator/swap.cc: New.\n\t* testsuite/23_containers/multimap/allocator/copy.cc: New.\n\t* testsuite/23_containers/multimap/allocator/copy_assign.cc: New.\n\t* testsuite/23_containers/multimap/allocator/minimal.cc: New.\n\t* testsuite/23_containers/multimap/allocator/move.cc: New.\n\t* testsuite/23_containers/multimap/allocator/move_assign.cc: New.\n\t* testsuite/23_containers/multimap/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/multimap/allocator/swap.cc: New.\n\t* testsuite/23_containers/multiset/allocator/copy.cc: New.\n\t* testsuite/23_containers/multiset/allocator/copy_assign.cc: New.\n\t* testsuite/23_containers/multiset/allocator/minimal.cc: New.\n\t* testsuite/23_containers/multiset/allocator/move.cc: New.\n\t* testsuite/23_containers/multiset/allocator/move_assign.cc: New.\n\t* testsuite/23_containers/multiset/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/multiset/allocator/swap.cc: New.\n\t* testsuite/23_containers/set/allocator/copy.cc: New.\n\t* testsuite/23_containers/set/allocator/copy_assign.cc: New.\n\t* testsuite/23_containers/set/allocator/minimal.cc: New.\n\t* testsuite/23_containers/set/allocator/move.cc: New.\n\t* testsuite/23_containers/set/allocator/move_assign.cc: New.\n\t* testsuite/23_containers/set/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/set/allocator/swap.cc: New.\n\t* testsuite/23_containers/vector/requirements/dr438/assign_neg.cc:\n\tAdjust dg-error line number.\n\t* testsuite/23_containers/vector/requirements/dr438/\n\tconstructor_1_neg.cc: Likewise.\n\t* testsuite/23_containers/vector/requirements/dr438/\n\tconstructor_2_neg.cc: Likewise.\n\t* testsuite/23_containers/vector/requirements/dr438/insert_neg.cc:\n\tLikewise.\n\nFrom-SVN: r204848", "tree": {"sha": "8d74c7399d7ca47a8c91d1e7e04159421d2f077b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d74c7399d7ca47a8c91d1e7e04159421d2f077b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cc65f15c42dd3a8f88764ce893cd2c9004801dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cc65f15c42dd3a8f88764ce893cd2c9004801dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cc65f15c42dd3a8f88764ce893cd2c9004801dd"}], "stats": {"total": 2984, "additions": 2866, "deletions": 118}, "files": [{"sha": "44d89b400554c27f087887cb3986532c3e94a57e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -1,3 +1,76 @@\n+2013-11-15  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/bits/stl_map.h (map): Implement C++11 allocator-aware\n+\tcontainer requirements.\n+\t* include/bits/stl_multimap.h (multimap): Likewise.\n+\t* include/bits/stl_multiset.h (multiset): Likewise.\n+\t* include/bits/stl_set.h (set): Likewise.\n+\t* include/bits/stl_tree.h (_Rb_tree_node): Use __aligned_buffer and\n+\tadd accessors for value.\n+\t(_Rb_tree_iterator, _Rb_tree_const_iterator): Use _Rb_tree_node\n+\taccessors.\n+\t(_Rb_tree): Use allocator_traits and implement support for sets and\n+\tmaps the be allocator-aware.\n+\t* include/bits/forward_list.h (_Fwd_list_base::_M_create_node): Do\n+\tnot zero-initialize storage buffer.\n+\t* include/bits/hashtable_policy.h (_Hashtable_alloc::_M_allocate_node):\n+\tLikewise.\n+\t* include/bits/stl_vector.h (vector(vector&&, const allocator_type&)):\n+\tAdd conditional noexcept specification.\n+\t* doc/xml/manual/status_cxx2011.xml: Update status of containers.\n+\t* testsuite/util/testsuite_allocator.h: Re-indent.\n+\t* testsuite/23_containers/forward_list/allocator/copy.cc: Test\n+\tallocator-extended copy constructor.\n+\t* testsuite/23_containers/unordered_map/allocator/copy.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multimap/allocator/copy.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_multiset/allocator/copy.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_set/allocator/copy.cc: Likewise.\n+\t* testsuite/23_containers/vector/allocator/copy.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/allocator/move.cc: New.\n+\t* testsuite/23_containers/unordered_map/allocator/move.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/allocator/move.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/allocator/move.cc: New.\n+\t* testsuite/23_containers/unordered_set/allocator/move.cc: New.\n+\t* testsuite/23_containers/vector/allocator/move.cc: New.\n+\t* testsuite/23_containers/map/allocator/copy.cc: New.\n+\t* testsuite/23_containers/map/allocator/copy_assign.cc: New.\n+\t* testsuite/23_containers/map/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/map/allocator/move.cc: New.\n+\t* testsuite/23_containers/map/allocator/move_assign.cc: New.\n+\t* testsuite/23_containers/map/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/map/allocator/swap.cc: New.\n+\t* testsuite/23_containers/multimap/allocator/copy.cc: New.\n+\t* testsuite/23_containers/multimap/allocator/copy_assign.cc: New.\n+\t* testsuite/23_containers/multimap/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/multimap/allocator/move.cc: New.\n+\t* testsuite/23_containers/multimap/allocator/move_assign.cc: New.\n+\t* testsuite/23_containers/multimap/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/multimap/allocator/swap.cc: New.\n+\t* testsuite/23_containers/multiset/allocator/copy.cc: New.\n+\t* testsuite/23_containers/multiset/allocator/copy_assign.cc: New.\n+\t* testsuite/23_containers/multiset/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/multiset/allocator/move.cc: New.\n+\t* testsuite/23_containers/multiset/allocator/move_assign.cc: New.\n+\t* testsuite/23_containers/multiset/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/multiset/allocator/swap.cc: New.\n+\t* testsuite/23_containers/set/allocator/copy.cc: New.\n+\t* testsuite/23_containers/set/allocator/copy_assign.cc: New.\n+\t* testsuite/23_containers/set/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/set/allocator/move.cc: New.\n+\t* testsuite/23_containers/set/allocator/move_assign.cc: New.\n+\t* testsuite/23_containers/set/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/set/allocator/swap.cc: New.\n+\t* testsuite/23_containers/vector/requirements/dr438/assign_neg.cc:\n+\tAdjust dg-error line number.\n+\t* testsuite/23_containers/vector/requirements/dr438/\n+\tconstructor_1_neg.cc: Likewise.\n+\t* testsuite/23_containers/vector/requirements/dr438/\n+\tconstructor_2_neg.cc: Likewise.\n+\t* testsuite/23_containers/vector/requirements/dr438/insert_neg.cc:\n+\tLikewise.\n+\n 2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* scripts/extract_symvers.in: Ignore <localentry: > fields"}, {"sha": "3c4ec69dcad74290e34c01eabfc43f3d1ab57e7b", "filename": "libstdc++-v3/doc/xml/manual/status_cxx2011.xml", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2011.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2011.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2011.xml?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -1371,7 +1371,7 @@ particular release.\n       <entry>23.2.1</entry>\n       <entry>General container requirements</entry>\n       <entry>Partial</entry>\n-      <entry>Only <code>vector</code> and <code>forward_list</code>\n+      <entry><code>deque</code> and <code>list</code> do not\n              meet the requirements\n              relating to allocator use and propagation.</entry>\n     </row>\n@@ -1416,8 +1416,7 @@ particular release.\n       <entry>23.3.3</entry>\n       <entry>Class template <code>deque</code></entry>\n       <entry>Partial</entry>\n-      <entry><code>insert</code> and <code>erase</code> members do not\n-             take <code>const_iterator</code> arguments (N2350).</entry>\n+      <entry>Incomplete allocator support.</entry>\n     </row>\n     <row>\n       <entry>23.3.4</entry>\n@@ -1430,24 +1429,19 @@ particular release.\n       <entry>23.3.5</entry>\n       <entry>Class template <code>list</code></entry>\n       <entry>Partial</entry>\n-      <entry><code>insert</code> and <code>erase</code> members do not\n-             take <code>const_iterator</code> arguments (N2350).</entry>\n+      <entry>Incomplete allocator support.</entry>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#B0B0B0\" ?>\n       <entry>23.3.6</entry>\n       <entry>Class template <code>vector</code></entry>\n-      <entry>Partial</entry>\n-      <entry><code>insert</code> and <code>erase</code> members do not\n-             take <code>const_iterator</code> arguments (N2350).</entry>\n+      <entry>Y</entry>\n+      <entry/>\n     </row>\n     <row>\n-      <?dbhtml bgcolor=\"#B0B0B0\" ?>\n       <entry>23.3.7</entry>\n       <entry>Class <code>vector&lt;bool&gt;</code></entry>\n-      <entry>Partial</entry>\n-      <entry><code>insert</code> and <code>erase</code> members do not\n-             take <code>const_iterator</code> arguments (N2350).</entry>\n+      <entry>Y</entry>\n+      <entry/>\n     </row>\n     <row>\n       <entry>23.4</entry>"}, {"sha": "e469dbfd803734e7741ae889ac8bbee80f760713", "filename": "libstdc++-v3/include/bits/forward_list.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -352,7 +352,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n             {\n \t      _Tp_alloc_type __a(_M_get_Node_allocator());\n \t      typedef allocator_traits<_Tp_alloc_type> _Alloc_traits;\n-\t      ::new ((void*)__node) _Node();\n+\t      ::new ((void*)__node) _Node;\n \t      _Alloc_traits::construct(__a, __node->_M_valptr(),\n \t\t\t\t       std::forward<_Args>(__args)...);\n             }"}, {"sha": "930a785d0a5dc1fdefece25f1a0c331e265071e7", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -1862,7 +1862,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__try\n \t  {\n \t    __value_alloc_type __a(_M_node_allocator());\n-\t    ::new ((void*)__n) __node_type();\n+\t    ::new ((void*)__n) __node_type;\n \t    __value_alloc_traits::construct(__a, __n->_M_valptr(),\n \t\t\t\t\t    std::forward<_Args>(__args)...);\n \t    return __n;"}, {"sha": "5b73f19084e298090f1f73302ee9b025090f5a85", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -128,22 +128,24 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n     private:\n       /// This turns a red-black tree into a [multi]map. \n-      typedef typename _Alloc::template rebind<value_type>::other \n-        _Pair_alloc_type;\n+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n+\trebind<value_type>::other _Pair_alloc_type;\n \n       typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,\n \t\t       key_compare, _Pair_alloc_type> _Rep_type;\n \n       /// The actual tree structure.\n       _Rep_type _M_t;\n \n+      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;\n+\n     public:\n       // many of these are specified differently in ISO, but the following are\n       // \"functionally equivalent\"\n-      typedef typename _Pair_alloc_type::pointer         pointer;\n-      typedef typename _Pair_alloc_type::const_pointer   const_pointer;\n-      typedef typename _Pair_alloc_type::reference       reference;\n-      typedef typename _Pair_alloc_type::const_reference const_reference;\n+      typedef typename _Alloc_traits::pointer            pointer;\n+      typedef typename _Alloc_traits::const_pointer      const_pointer;\n+      typedef typename _Alloc_traits::reference          reference;\n+      typedef typename _Alloc_traits::const_reference    const_reference;\n       typedef typename _Rep_type::iterator               iterator;\n       typedef typename _Rep_type::const_iterator         const_iterator;\n       typedef typename _Rep_type::size_type              size_type;\n@@ -208,6 +210,33 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  const allocator_type& __a = allocator_type())\n       : _M_t(__comp, _Pair_alloc_type(__a))\n       { _M_t._M_insert_unique(__l.begin(), __l.end()); }\n+\n+      /// Allocator-extended default constructor.\n+      explicit\n+      map(const allocator_type& __a)\n+      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }\n+\n+      /// Allocator-extended copy constructor.\n+      map(const map& __m, const allocator_type& __a)\n+      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }\n+\n+      /// Allocator-extended move constructor.\n+      map(map&& __m, const allocator_type& __a)\n+      noexcept(is_nothrow_copy_constructible<_Compare>::value\n+\t       && _Alloc_traits::_S_always_equal())\n+      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }\n+\n+      /// Allocator-extended initialier-list constructor.\n+      map(initializer_list<value_type> __l, const allocator_type& __a)\n+      : _M_t(_Compare(), _Pair_alloc_type(__a))\n+      { _M_t._M_insert_unique(__l.begin(), __l.end()); }\n+\n+      /// Allocator-extended range constructor.\n+      template<typename _InputIterator>\n+        map(_InputIterator __first, _InputIterator __last,\n+\t    const allocator_type& __a)\n+\t: _M_t(_Compare(), _Pair_alloc_type(__a))\n+        { _M_t._M_insert_unique(__first, __last); }\n #endif\n \n       /**\n@@ -276,12 +305,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @a __x is a valid, but unspecified %map.\n        */\n       map&\n-      operator=(map&& __x)\n+      operator=(map&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n+\tif (!_M_t._M_move_assign(__x._M_t))\n+\t  {\n+\t    // The rvalue's allocator cannot be moved and is not equal,\n+\t    // so we need to individually move each element.\n+\t    clear();\n+\t    insert(std::__make_move_if_noexcept_iterator(__x.begin()),\n+\t\t   std::__make_move_if_noexcept_iterator(__x.end()));\n+\t    __x.clear();\n+\t  }\n \treturn *this;\n       }\n \n@@ -776,6 +810,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       swap(map& __x)\n+#if __cplusplus >= 201103L\n+      noexcept(_Alloc_traits::_S_nothrow_swap())\n+#endif\n       { _M_t.swap(__x._M_t); }\n \n       /**"}, {"sha": "3f9690fb3e1149b2f95f7c5f513568171fbe9ebc", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -127,21 +127,23 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n     private:\n       /// This turns a red-black tree into a [multi]map.\n-      typedef typename _Alloc::template rebind<value_type>::other \n-        _Pair_alloc_type;\n+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n+\trebind<value_type>::other _Pair_alloc_type;\n \n       typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,\n \t\t       key_compare, _Pair_alloc_type> _Rep_type;\n       /// The actual tree structure.\n       _Rep_type _M_t;\n \n+      typedef __gnu_cxx::__alloc_traits<_Pair_alloc_type> _Alloc_traits;\n+\n     public:\n       // many of these are specified differently in ISO, but the following are\n       // \"functionally equivalent\"\n-      typedef typename _Pair_alloc_type::pointer         pointer;\n-      typedef typename _Pair_alloc_type::const_pointer   const_pointer;\n-      typedef typename _Pair_alloc_type::reference       reference;\n-      typedef typename _Pair_alloc_type::const_reference const_reference;\n+      typedef typename _Alloc_traits::pointer            pointer;\n+      typedef typename _Alloc_traits::const_pointer      const_pointer;\n+      typedef typename _Alloc_traits::reference          reference;\n+      typedef typename _Alloc_traits::const_reference    const_reference;\n       typedef typename _Rep_type::iterator               iterator;\n       typedef typename _Rep_type::const_iterator         const_iterator;\n       typedef typename _Rep_type::size_type              size_type;\n@@ -204,6 +206,33 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t       const allocator_type& __a = allocator_type())\n       : _M_t(__comp, _Pair_alloc_type(__a))\n       { _M_t._M_insert_equal(__l.begin(), __l.end()); }\n+\n+      /// Allocator-extended default constructor.\n+      explicit\n+      multimap(const allocator_type& __a)\n+      : _M_t(_Compare(), _Pair_alloc_type(__a)) { }\n+\n+      /// Allocator-extended copy constructor.\n+      multimap(const multimap& __m, const allocator_type& __a)\n+      : _M_t(__m._M_t, _Pair_alloc_type(__a)) { }\n+\n+      /// Allocator-extended move constructor.\n+      multimap(multimap&& __m, const allocator_type& __a)\n+      noexcept(is_nothrow_copy_constructible<_Compare>::value\n+\t       && _Alloc_traits::_S_always_equal())\n+      : _M_t(std::move(__m._M_t), _Pair_alloc_type(__a)) { }\n+\n+      /// Allocator-extended initialier-list constructor.\n+      multimap(initializer_list<value_type> __l, const allocator_type& __a)\n+      : _M_t(_Compare(), _Pair_alloc_type(__a))\n+      { _M_t._M_insert_equal(__l.begin(), __l.end()); }\n+\n+      /// Allocator-extended range constructor.\n+      template<typename _InputIterator>\n+        multimap(_InputIterator __first, _InputIterator __last,\n+\t\t const allocator_type& __a)\n+\t: _M_t(_Compare(), _Pair_alloc_type(__a))\n+        { _M_t._M_insert_equal(__first, __last); }\n #endif\n \n       /**\n@@ -270,12 +299,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @a __x is a valid, but unspecified multimap.\n        */\n       multimap&\n-      operator=(multimap&& __x)\n+      operator=(multimap&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n+\tif (!_M_t._M_move_assign(__x._M_t))\n+\t  {\n+\t    // The rvalue's allocator cannot be moved and is not equal,\n+\t    // so we need to individually move each element.\n+\t    clear();\n+\t    insert(std::__make_move_if_noexcept_iterator(__x.begin()),\n+\t\t   std::__make_move_if_noexcept_iterator(__x.end()));\n+\t    __x.clear();\n+\t  }\n \treturn *this;\n       }\n \n@@ -685,6 +719,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       swap(multimap& __x)\n+#if __cplusplus >= 201103L\n+      noexcept(_Alloc_traits::_S_nothrow_swap())\n+#endif\n       { _M_t.swap(__x._M_t); }\n \n       /**"}, {"sha": "5605801671c48345b5953b0d93c4bfda0c488321", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -108,18 +108,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n     private:\n       /// This turns a red-black tree into a [multi]set.\n-      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;\n+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n+\trebind<_Key>::other _Key_alloc_type;\n \n       typedef _Rb_tree<key_type, value_type, _Identity<value_type>,\n \t\t       key_compare, _Key_alloc_type> _Rep_type;\n       /// The actual tree structure.\n       _Rep_type _M_t;\n \n+      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;\n+\n     public:\n-      typedef typename _Key_alloc_type::pointer             pointer;\n-      typedef typename _Key_alloc_type::const_pointer       const_pointer;\n-      typedef typename _Key_alloc_type::reference           reference;\n-      typedef typename _Key_alloc_type::const_reference     const_reference;\n+      typedef typename _Alloc_traits::pointer\t\t    pointer;\n+      typedef typename _Alloc_traits::const_pointer\t    const_pointer;\n+      typedef typename _Alloc_traits::reference\t\t    reference;\n+      typedef typename _Alloc_traits::const_reference\t    const_reference;\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 103. set::iterator is required to be modifiable,\n       // but this allows modification of keys.\n@@ -216,6 +219,33 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t       const allocator_type& __a = allocator_type())\n       : _M_t(__comp, _Key_alloc_type(__a))\n       { _M_t._M_insert_equal(__l.begin(), __l.end()); }\n+\n+      /// Allocator-extended default constructor.\n+      explicit\n+      multiset(const allocator_type& __a)\n+      : _M_t(_Compare(), _Key_alloc_type(__a)) { }\n+\n+      /// Allocator-extended copy constructor.\n+      multiset(const multiset& __m, const allocator_type& __a)\n+      : _M_t(__m._M_t, _Key_alloc_type(__a)) { }\n+\n+      /// Allocator-extended move constructor.\n+      multiset(multiset&& __m, const allocator_type& __a)\n+      noexcept(is_nothrow_copy_constructible<_Compare>::value\n+\t       && _Alloc_traits::_S_always_equal())\n+      : _M_t(std::move(__m._M_t), _Key_alloc_type(__a)) { }\n+\n+      /// Allocator-extended initialier-list constructor.\n+      multiset(initializer_list<value_type> __l, const allocator_type& __a)\n+      : _M_t(_Compare(), _Key_alloc_type(__a))\n+      { _M_t._M_insert_equal(__l.begin(), __l.end()); }\n+\n+      /// Allocator-extended range constructor.\n+      template<typename _InputIterator>\n+        multiset(_InputIterator __first, _InputIterator __last,\n+\t\t const allocator_type& __a)\n+\t: _M_t(_Compare(), _Key_alloc_type(__a))\n+        { _M_t._M_insert_equal(__first, __last); }\n #endif\n \n       /**\n@@ -242,12 +272,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  %multiset.\n        */\n       multiset&\n-      operator=(multiset&& __x)\n+      operator=(multiset&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n+\tif (!_M_t._M_move_assign(__x._M_t))\n+\t  {\n+\t    // The rvalue's allocator cannot be moved and is not equal,\n+\t    // so we need to individually move each element.\n+\t    clear();\n+\t    insert(std::__make_move_if_noexcept_iterator(__x._M_t.begin()),\n+\t\t   std::__make_move_if_noexcept_iterator(__x._M_t.end()));\n+\t    __x.clear();\n+\t  }\n \treturn *this;\n       }\n \n@@ -388,6 +423,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       swap(multiset& __x)\n+#if __cplusplus >= 201103L\n+      noexcept(_Alloc_traits::_S_nothrow_swap())\n+#endif\n       { _M_t.swap(__x._M_t); }\n \n       // insert/erase\n@@ -747,7 +785,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  @return  True iff @a __x is lexicographically less than @a __y.\n    *\n    *  This is a total ordering relation.  It is linear in the size of the\n-   *  maps.  The elements must be comparable with @c <.\n+   *  sets.  The elements must be comparable with @c <.\n    *\n    *  See std::lexicographical_compare() for how the determination is made.\n   */"}, {"sha": "b405c491e47695e7cf7c19c085495abae6acf90a", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -108,19 +108,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       //@}\n \n     private:\n-      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;\n+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n+\trebind<_Key>::other _Key_alloc_type;\n \n       typedef _Rb_tree<key_type, value_type, _Identity<value_type>,\n \t\t       key_compare, _Key_alloc_type> _Rep_type;\n       _Rep_type _M_t;  // Red-black tree representing set.\n \n+      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;\n+\n     public:\n       //@{\n       ///  Iterator-related typedefs.\n-      typedef typename _Key_alloc_type::pointer             pointer;\n-      typedef typename _Key_alloc_type::const_pointer       const_pointer;\n-      typedef typename _Key_alloc_type::reference           reference;\n-      typedef typename _Key_alloc_type::const_reference     const_reference;\n+      typedef typename _Alloc_traits::pointer\t\t    pointer;\n+      typedef typename _Alloc_traits::const_pointer\t    const_pointer;\n+      typedef typename _Alloc_traits::reference\t\t    reference;\n+      typedef typename _Alloc_traits::const_reference\t    const_reference;\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 103. set::iterator is required to be modifiable,\n       // but this allows modification of keys.\n@@ -220,6 +223,33 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  const allocator_type& __a = allocator_type())\n       : _M_t(__comp, _Key_alloc_type(__a))\n       { _M_t._M_insert_unique(__l.begin(), __l.end()); }\n+\n+      /// Allocator-extended default constructor.\n+      explicit\n+      set(const allocator_type& __a)\n+      : _M_t(_Compare(), _Key_alloc_type(__a)) { }\n+\n+      /// Allocator-extended copy constructor.\n+      set(const set& __x, const allocator_type& __a)\n+      : _M_t(__x._M_t, _Key_alloc_type(__a)) { }\n+\n+      /// Allocator-extended move constructor.\n+      set(set&& __x, const allocator_type& __a)\n+      noexcept(is_nothrow_copy_constructible<_Compare>::value\n+\t       && _Alloc_traits::_S_always_equal())\n+      : _M_t(std::move(__x._M_t), _Key_alloc_type(__a)) { }\n+\n+      /// Allocator-extended initialier-list constructor.\n+      set(initializer_list<value_type> __l, const allocator_type& __a)\n+      : _M_t(_Compare(), _Key_alloc_type(__a))\n+      { _M_t._M_insert_unique(__l.begin(), __l.end()); }\n+\n+      /// Allocator-extended range constructor.\n+      template<typename _InputIterator>\n+        set(_InputIterator __first, _InputIterator __last,\n+\t    const allocator_type& __a)\n+\t: _M_t(_Compare(), _Key_alloc_type(__a))\n+        { _M_t._M_insert_unique(__first, __last); }\n #endif\n \n       /**\n@@ -245,12 +275,17 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        *  @a __x is a valid, but unspecified %set.\n        */\n       set&\n-      operator=(set&& __x)\n+      operator=(set&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n+\tif (!_M_t._M_move_assign(__x._M_t))\n+\t  {\n+\t    // The rvalue's allocator cannot be moved and is not equal,\n+\t    // so we need to individually move each element.\n+\t    clear();\n+\t    insert(std::__make_move_if_noexcept_iterator(__x._M_t.begin()),\n+\t\t   std::__make_move_if_noexcept_iterator(__x._M_t.end()));\n+\t    __x.clear();\n+\t  }\n       \treturn *this;\n       }\n \n@@ -391,6 +426,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n        */\n       void\n       swap(set& __x)\n+#if __cplusplus >= 201103L\n+      noexcept(_Alloc_traits::_S_nothrow_swap())\n+#endif\n       { _M_t.swap(__x._M_t); }\n \n       // insert/erase\n@@ -762,7 +800,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n    *  @return  True iff @a __x is lexicographically less than @a __y.\n    *\n    *  This is a total ordering relation.  It is linear in the size of the\n-   *  maps.  The elements must be comparable with @c <.\n+   *  sets.  The elements must be comparable with @c <.\n    *\n    *  See std::lexicographical_compare() for how the determination is made.\n   */"}, {"sha": "778fe2592faf529dd42605a325f6076f37a2b897", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 154, "deletions": 48, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -62,8 +62,9 @@\n #include <bits/allocator.h>\n #include <bits/stl_function.h>\n #include <bits/cpp_type_traits.h>\n+#include <ext/alloc_traits.h>\n #if __cplusplus >= 201103L\n-#include <bits/alloc_traits.h>\n+#include <ext/aligned_buffer.h>\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -131,13 +132,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct _Rb_tree_node : public _Rb_tree_node_base\n     {\n       typedef _Rb_tree_node<_Val>* _Link_type;\n+\n+#if __cplusplus < 201103L\n       _Val _M_value_field;\n \n-#if __cplusplus >= 201103L\n-      template<typename... _Args>\n-        _Rb_tree_node(_Args&&... __args)\n-\t: _Rb_tree_node_base(),\n-\t  _M_value_field(std::forward<_Args>(__args)...) { }\n+      _Val*\n+      _M_valptr()\n+      { return std::__addressof(_M_value_field); }\n+\n+      const _Val*\n+      _M_valptr() const\n+      { return std::__addressof(_M_value_field); }\n+#else\n+      __gnu_cxx::__aligned_buffer<_Val> _M_storage;\n+\n+      _Val*\n+      _M_valptr()\n+      { return _M_storage._M_ptr(); }\n+\n+      const _Val*\n+      _M_valptr() const\n+      { return _M_storage._M_ptr(); }\n #endif\n     };\n \n@@ -176,12 +191,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       reference\n       operator*() const _GLIBCXX_NOEXCEPT\n-      { return static_cast<_Link_type>(_M_node)->_M_value_field; }\n+      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }\n \n       pointer\n       operator->() const _GLIBCXX_NOEXCEPT\n-      { return std::__addressof(static_cast<_Link_type>\n-\t\t\t\t(_M_node)->_M_value_field); }\n+      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }\n \n       _Self&\n       operator++() _GLIBCXX_NOEXCEPT\n@@ -257,12 +271,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       reference\n       operator*() const _GLIBCXX_NOEXCEPT\n-      { return static_cast<_Link_type>(_M_node)->_M_value_field; }\n+      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }\n \n       pointer\n       operator->() const _GLIBCXX_NOEXCEPT\n-      { return std::__addressof(static_cast<_Link_type>\n-\t\t\t\t(_M_node)->_M_value_field); }\n+      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }\n \n       _Self&\n       operator++() _GLIBCXX_NOEXCEPT\n@@ -332,8 +345,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n            typename _Compare, typename _Alloc = allocator<_Val> >\n     class _Rb_tree\n     {\n-      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other\n-              _Node_allocator;\n+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n+        rebind<_Rb_tree_node<_Val> >::other _Node_allocator;\n+\n+      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;\n \n     protected:\n       typedef _Rb_tree_node_base* \t\t_Base_ptr;\n@@ -367,20 +382,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     protected:\n       _Link_type\n       _M_get_node()\n-      { return _M_impl._Node_allocator::allocate(1); }\n+      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }\n \n       void\n       _M_put_node(_Link_type __p) _GLIBCXX_NOEXCEPT\n-      { _M_impl._Node_allocator::deallocate(__p, 1); }\n+      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }\n \n #if __cplusplus < 201103L\n       _Link_type\n       _M_create_node(const value_type& __x)\n       {\n \t_Link_type __tmp = _M_get_node();\n \t__try\n-\t  { get_allocator().construct\n-\t      (std::__addressof(__tmp->_M_value_field), __x); }\n+\t  { get_allocator().construct(__tmp->_M_valptr(), __x); }\n \t__catch(...)\n \t  {\n \t    _M_put_node(__tmp);\n@@ -392,7 +406,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_destroy_node(_Link_type __p)\n       {\n-\tget_allocator().destroy(std::__addressof(__p->_M_value_field));\n+\tget_allocator().destroy(__p->_M_valptr());\n \t_M_put_node(__p);\n       }\n #else\n@@ -403,9 +417,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _Link_type __tmp = _M_get_node();\n \t  __try\n \t    {\n-\t      allocator_traits<_Node_allocator>::\n-\t\tconstruct(_M_get_Node_allocator(), __tmp,\n-\t\t\t  std::forward<_Args>(__args)...);\n+\t      ::new(__tmp) _Rb_tree_node<_Val>;\n+\t      _Alloc_traits::construct(_M_get_Node_allocator(),\n+\t\t\t\t       __tmp->_M_valptr(),\n+\t\t\t\t       std::forward<_Args>(__args)...);\n \t    }\n \t  __catch(...)\n \t    {\n@@ -418,15 +433,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_destroy_node(_Link_type __p) noexcept\n       {\n-\t_M_get_Node_allocator().destroy(__p);\n+\t_Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());\n+\t__p->~_Rb_tree_node<_Val>();\n \t_M_put_node(__p);\n       }\n #endif\n \n       _Link_type\n       _M_clone_node(_Const_Link_type __x)\n       {\n-\t_Link_type __tmp = _M_create_node(__x->_M_value_field);\n+\t_Link_type __tmp = _M_create_node(*__x->_M_valptr());\n \t__tmp->_M_color = __x->_M_color;\n \t__tmp->_M_left = 0;\n \t__tmp->_M_right = 0;\n@@ -518,7 +534,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       static const_reference\n       _S_value(_Const_Link_type __x)\n-      { return __x->_M_value_field; }\n+      { return *__x->_M_valptr(); }\n \n       static const _Key&\n       _S_key(_Const_Link_type __x)\n@@ -542,7 +558,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       static const_reference\n       _S_value(_Const_Base_ptr __x)\n-      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }\n+      { return *static_cast<_Const_Link_type>(__x)->_M_valptr(); }\n \n       static const _Key&\n       _S_key(_Const_Base_ptr __x)\n@@ -652,7 +668,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : _M_impl(__comp, _Node_allocator(__a)) { }\n \n       _Rb_tree(const _Rb_tree& __x)\n-      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())\n+      : _M_impl(__x._M_impl._M_key_compare,\n+\t        _Alloc_traits::_S_select_on_copy(__x._M_get_Node_allocator()))\n       {\n \tif (__x._M_root() != 0)\n \t  {\n@@ -664,7 +681,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n #if __cplusplus >= 201103L\n-      _Rb_tree(_Rb_tree&& __x);\n+      _Rb_tree(const allocator_type& __a)\n+      : _M_impl(_Compare(), _Node_allocator(__a))\n+      { }\n+\n+      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)\n+      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))\n+      {\n+\tif (__x._M_root() != 0)\n+\t  {\n+\t    _M_root() = _M_copy(__x._M_begin(), _M_end());\n+\t    _M_leftmost() = _S_minimum(_M_root());\n+\t    _M_rightmost() = _S_maximum(_M_root());\n+\t    _M_impl._M_node_count = __x._M_impl._M_node_count;\n+\t  }\n+      }\n+\n+      _Rb_tree(_Rb_tree&& __x)\n+      : _Rb_tree(std::move(__x), std::move(__x._M_get_Node_allocator()))\n+      { }\n+\n+      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)\n+      : _Rb_tree(std::move(__x), _Node_allocator(__a))\n+      { }\n+\n+      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);\n #endif\n \n       ~_Rb_tree() _GLIBCXX_NOEXCEPT\n@@ -729,10 +770,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       size_type\n       max_size() const _GLIBCXX_NOEXCEPT\n-      { return _M_get_Node_allocator().max_size(); }\n+      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }\n \n       void\n-      swap(_Rb_tree& __t);      \n+#if __cplusplus >= 201103L\n+      swap(_Rb_tree& __t) noexcept(_Alloc_traits::_S_nothrow_swap());\n+#else\n+      swap(_Rb_tree& __t);\n+#endif\n \n       // Insert/erase.\n #if __cplusplus >= 201103L\n@@ -899,6 +944,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Debugging.\n       bool\n       __rb_verify() const;\n+\n+#if __cplusplus >= 201103L\n+      bool\n+      _M_move_assign(_Rb_tree&);\n+#endif\n     };\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -960,37 +1010,92 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _Rb_tree(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&& __x)\n-    : _M_impl(__x._M_impl._M_key_compare,\n-\t      std::move(__x._M_get_Node_allocator()))\n+    _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)\n+    : _M_impl(__x._M_impl._M_key_compare, std::move(__a))\n     {\n       if (__x._M_root() != 0)\n \t{\n-\t  _M_root() = __x._M_root();\n-\t  _M_leftmost() = __x._M_leftmost();\n-\t  _M_rightmost() = __x._M_rightmost();\n-\t  _M_root()->_M_parent = _M_end();\n+\t  if (!_Alloc_traits::_S_always_equal()\n+\t      && __x._M_get_Node_allocator() != __a)\n+\t    {\n+\t      _M_root() = _M_copy(__x._M_begin(), _M_end());\n+\t      _M_leftmost() = _S_minimum(_M_root());\n+\t      _M_rightmost() = _S_maximum(_M_root());\n+\t      _M_impl._M_node_count = __x._M_impl._M_node_count;\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_root() = __x._M_root();\n+\t      _M_leftmost() = __x._M_leftmost();\n+\t      _M_rightmost() = __x._M_rightmost();\n+\t      _M_root()->_M_parent = _M_end();\n+\n+\t      __x._M_root() = 0;\n+\t      __x._M_leftmost() = __x._M_end();\n+\t      __x._M_rightmost() = __x._M_end();\n+\n+\t      this->_M_impl._M_node_count = __x._M_impl._M_node_count;\n+\t      __x._M_impl._M_node_count = 0;\n+\t    }\n+\t}\n+    }\n+\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+           typename _Compare, typename _Alloc>\n+    bool\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_move_assign(_Rb_tree& __x)\n+    {\n+      if (_Alloc_traits::_S_propagate_on_move_assign()\n+\t  || _Alloc_traits::_S_always_equal()\n+\t  || _M_get_Node_allocator() == __x._M_get_Node_allocator())\n+\t{\n+\t  clear();\n+\t  if (__x._M_root() != 0)\n+\t    {\n+\t      _M_root() = __x._M_root();\n+\t      _M_leftmost() = __x._M_leftmost();\n+\t      _M_rightmost() = __x._M_rightmost();\n+\t      _M_root()->_M_parent = _M_end();\n \n-\t  __x._M_root() = 0;\n-\t  __x._M_leftmost() = __x._M_end();\n-\t  __x._M_rightmost() = __x._M_end();\n+\t      __x._M_root() = 0;\n+\t      __x._M_leftmost() = __x._M_end();\n+\t      __x._M_rightmost() = __x._M_end();\n \n-\t  this->_M_impl._M_node_count = __x._M_impl._M_node_count;\n-\t  __x._M_impl._M_node_count = 0;\n+\t      this->_M_impl._M_node_count = __x._M_impl._M_node_count;\n+\t      __x._M_impl._M_node_count = 0;\n+\t    }\n+\t  if (_Alloc_traits::_S_propagate_on_move_assign())\n+\t    std::__alloc_on_move(_M_get_Node_allocator(),\n+\t\t\t\t __x._M_get_Node_allocator());\n+\t  return true;\n \t}\n+      return false;\n     }\n #endif\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)\n+    operator=(const _Rb_tree& __x)\n     {\n       if (this != &__x)\n \t{\n \t  // Note that _Key may be a constant type.\n \t  clear();\n+#if __cplusplus >= 201103L\n+\t  if (_Alloc_traits::_S_propagate_on_copy_assign())\n+\t    {\n+\t      auto& __this_alloc = this->_M_get_Node_allocator();\n+\t      auto& __that_alloc = __x._M_get_Node_allocator();\n+\t      if (!_Alloc_traits::_S_always_equal()\n+\t\t  && __this_alloc != __that_alloc)\n+\t\t{\n+\t\t  std::__alloc_on_copy(__this_alloc, __that_alloc);\n+\t\t}\n+\t    }\n+#endif\n \t  _M_impl._M_key_compare = __x._M_impl._M_key_compare;\n \t  if (__x._M_root() != 0)\n \t    {\n@@ -1260,6 +1365,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)\n+#if __cplusplus >= 201103L\n+    noexcept(_Alloc_traits::_S_nothrow_swap())\n+#endif\n     {\n       if (_M_root() == 0)\n \t{\n@@ -1298,11 +1406,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // No need to swap header's color as it does not change.\n       std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);\n       std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);\n-      \n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 431. Swapping containers with unequal allocators.\n-      std::__alloc_swap<_Node_allocator>::\n-\t_S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());\n+\n+      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),\n+\t\t\t\t__t._M_get_Node_allocator());\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,"}, {"sha": "5c8c16151e20ecab1b0b4d7842ad465c31e17834", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -332,6 +332,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /// Move constructor with alternative allocator\n       vector(vector&& __rv, const allocator_type& __m)\n+      noexcept(_Alloc_traits::_S_always_equal())\n       : _Base(std::move(__rv), __m)\n       {\n \tif (__rv.get_allocator() != __m)"}, {"sha": "c08e0e105a2b95f4deed584cf572d3094926e11d", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/allocator/copy.cc", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fcopy.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-options \"-std=gnu++0x\" }\n+// { dg-options \"-std=gnu++11\" }\n \n #include <forward_list>\n #include <testsuite_hooks.h>\n@@ -49,9 +49,22 @@ void test02()\n   VERIFY(1 == v2.get_allocator().get_personality());\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::forward_list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(T());\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "04d660a7ceb06a305fea72bfaf6cd134e1d0cfc3", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/allocator/move.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fallocator%2Fmove.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::forward_list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { T() };\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::forward_list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { T() };\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "39907d186d90217bac954a845785d700b5db1089", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/copy.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fcopy.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,76 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, false> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "1c2c8220517b6b754d02c49dccbc7b4a531df669", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/copy_assign.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fcopy_assign.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, false> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "4a04cfe4be13cd3a083ec7dfde221b4012b8cdee", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/minimal.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fminimal.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::map<T, U, Cmp, SimpleAllocator<std::pair<const T, U>>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef SimpleAllocator<std::pair<const T, U>> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v(alloc_type{});\n+  v = { test_type::value_type{} };\n+  VERIFY( v.max_size() == traits_type::max_size(v.get_allocator()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "94354e690b60d91f8ba71cd3d866e15575996597", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/move.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<std::pair<const T, U>> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<std::pair<const T, U>> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "920a38ca38c559fa816dc9862a42c9ed8e362409", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/move_assign.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fmove_assign.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, false> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = std::move(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = std::move(v1);\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "832a28ab63a71782cc59fcfd2f7b8c212a303d32", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/noexcept.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fnoexcept.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+namespace __gnu_test\n+{\n+  inline void\n+  swap(propagating_allocator<std::pair<const T, U>, true>& l,\n+       propagating_allocator<std::pair<const T, U>, true>& r)\n+  noexcept(false)\n+  {\n+    typedef uneq_allocator<std::pair<const T, U>> base_alloc;\n+    swap(static_cast<base_alloc&>(l), static_cast<base_alloc&>(r));\n+  }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<std::pair<const T, U>> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<std::pair<const T, U>, false> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "81020fcf1e6371841192d20138c1896753fa48a4", "filename": "libstdc++-v3/testsuite/23_containers/map/allocator/swap.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fallocator%2Fswap.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,86 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<std::pair<const T, U>, false>&,\n+           const propagating_allocator<std::pair<const T, U>, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<std::pair<const T, U>, false>&,\n+           const propagating_allocator<std::pair<const T, U>, false>&)\n+{\n+  return false;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, false> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::map<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "fdf197d297047b7e08111f9afca9bf271360e96d", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/copy.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fcopy.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,76 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, false> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "3f67999559f1e333ac992633a257f3ddf156f452", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/copy_assign.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fcopy_assign.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, false> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "92ad4895e820fe6565ec7ae6bf338dc0bc463625", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/minimal.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fminimal.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::multimap<T, U, Cmp, SimpleAllocator<std::pair<const T, U>>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef SimpleAllocator<std::pair<const T, U>> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v(alloc_type{});\n+  v = { test_type::value_type{} };\n+  VERIFY( v.max_size() == traits_type::max_size(v.get_allocator()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "7a80ce653fbad82bad62235cc1f72f633a3a5aac", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/move.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<std::pair<const T, U>> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<std::pair<const T, U>> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "70e2d488c92fc1f60eb0007b2d2d28b10ffa40b8", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/move_assign.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fmove_assign.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, false> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = std::move(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = std::move(v1);\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "aee4dc90029fcf4efea16824064dddc2eac9e2c8", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/noexcept.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fnoexcept.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,83 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+namespace __gnu_test\n+{\n+  inline void\n+  swap(propagating_allocator<std::pair<const T, U>, true>& l,\n+       propagating_allocator<std::pair<const T, U>, true>& r)\n+  noexcept(false)\n+  {\n+    typedef uneq_allocator<std::pair<const T, U>> base_alloc;\n+    swap(static_cast<base_alloc&>(l), static_cast<base_alloc&>(r));\n+  }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<std::pair<const T, U>> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<std::pair<const T, U>, false> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "57e460c32cafe8bd325cce20f9bfc4ad8e13febd", "filename": "libstdc++-v3/testsuite/23_containers/multimap/allocator/swap.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fallocator%2Fswap.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,86 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<std::pair<const T, U>, false>&,\n+           const propagating_allocator<std::pair<const T, U>, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<std::pair<const T, U>, false>&,\n+           const propagating_allocator<std::pair<const T, U>, false>&)\n+{\n+  return false;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, false> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<std::pair<const T, U>, true> alloc_type;\n+  typedef std::multimap<T, U, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "cecde4f3e1cea0c3d0dc0d96f11c0817c288d680", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/copy.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fcopy.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "6b47b099293a38b0ac9e376ecb1f020e78454b9a", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/copy_assign.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fcopy_assign.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,65 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "8be5394a42b38e461b28b7c6d3dee38c29e0d728", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/minimal.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fminimal.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::multiset<T, Cmp, SimpleAllocator<T>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef SimpleAllocator<T> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v(alloc_type{});\n+  v = { test_type::value_type{} };\n+  VERIFY( v.max_size() == traits_type::max_size(v.get_allocator()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "819d18d3fd45c1b325d2e7582eeeb4760b1c14f6", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/move.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "f553a95bf0d13327b406a53750e045a6e62e1c32", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/move_assign.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fmove_assign.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,65 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = std::move(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = std::move(v1);\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "89b0053d4c2a39abb242491cde9811cd2d0a3bcb", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/noexcept.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fnoexcept.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+namespace __gnu_test\n+{\n+  inline void\n+  swap(propagating_allocator<T, true>& l,\n+       propagating_allocator<T, true>& r)\n+  noexcept(false)\n+  {\n+    typedef uneq_allocator<T> base_alloc;\n+    swap(static_cast<base_alloc&>(l), static_cast<base_alloc&>(r));\n+  }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<T> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "f92ff074d0fade213ede0544974c4a1b8f753b61", "filename": "libstdc++-v3/testsuite/23_containers/multiset/allocator/swap.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fallocator%2Fswap.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return false;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::multiset<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "ac717f0e6b68b78925775a939623fa931a4a38ba", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/copy.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fcopy.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "5ac37c6d22cc35298bf9248b61239e20c4047ac1", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/copy_assign.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fcopy_assign.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,65 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "dd4c3b94c18ebd415436e2d70840606589d53fa0", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/minimal.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fminimal.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::set<T, Cmp, SimpleAllocator<T>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef SimpleAllocator<T> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v(alloc_type{});\n+  v = { test_type::value_type{} };\n+  VERIFY( v.max_size() == traits_type::max_size(v.get_allocator()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "0fdd9a0fe1a38d7b86a5e14a788058c529cae89e", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/move.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+struct U { };\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "60ef2affb5e56adbb5631ffb9fd6a2489d2cda5e", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/move_assign.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,65 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = std::move(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  v2 = std::move(v1);\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "07adbc08013e2adf026c3b17c5d56aa56b166e4d", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/noexcept.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fnoexcept.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+namespace __gnu_test\n+{\n+  inline void\n+  swap(propagating_allocator<T, true>& l,\n+       propagating_allocator<T, true>& r)\n+  noexcept(false)\n+  {\n+    typedef uneq_allocator<T> base_alloc;\n+    swap(static_cast<base_alloc&>(l), static_cast<base_alloc&>(r));\n+  }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<T> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "d5bc122abb826176dd094fad9fa62c33319349e2", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/swap.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fswap.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,84 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+bool operator<(T l, T r) { return l.i < r.i; }\n+\n+using Cmp = std::less<T>;\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return false;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::set<T, Cmp, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { test_type::value_type{} };\n+  test_type v2(alloc_type(2));\n+  v2 = { test_type::value_type{} };\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "faa3d1278655d8267ee3403dfa976dc5b6f4f670", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/copy.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fcopy.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -63,9 +63,23 @@ void test02()\n   VERIFY(1 == v2.get_allocator().get_personality());\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "d2648026bbb798cfe9f7bbd947850dcb74deb423", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/allocator/move.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fallocator%2Fmove.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,71 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::unordered_map<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "1a6a0bb6b96e07c84eea72c53d021c821996b312", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/allocator/copy.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fcopy.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -63,9 +63,23 @@ void test02()\n   VERIFY(1 == v2.get_allocator().get_personality());\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "fba6abbb22aed1453be1eebfcd5047a179d0c15d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/allocator/move.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fallocator%2Fmove.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,71 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::unordered_multimap<T, T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.emplace(std::piecewise_construct,\n+\t     std::make_tuple(T()), std::make_tuple(T()));\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "f5f01dc314097adff739331626e86e1f9bc4386d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/allocator/copy.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fcopy.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -61,9 +61,22 @@ void test02()\n   VERIFY(1 == v2.get_allocator().get_personality());\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "da1de2c861f414efcad231837ecf7a1b895f33c3", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/allocator/move.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fallocator%2Fmove.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::unordered_multiset<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "500d7c8081a9944287063dcd35f26cc89f2186d9", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/copy.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fcopy.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -61,9 +61,22 @@ void test02()\n   VERIFY(1 == v2.get_allocator().get_personality());\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "865dcaeb7b59f1830f80c0fede497ec147e512bf", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/allocator/move.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fallocator%2Fmove.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=c++11\" }\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+struct hash\n+{\n+  std::size_t operator()(const T t) const noexcept\n+  { return t.i; }\n+};\n+\n+struct equal_to\n+{\n+  bool operator()(const T& lhs, const T& rhs) const noexcept\n+  { return lhs.i == rhs.i; }\n+};\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::unordered_set<T, hash, equal_to, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.insert(T());\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "1b528927bc04b65e7cfef3f3ba74812ed1c8a580", "filename": "libstdc++-v3/testsuite/23_containers/vector/allocator/copy.cc", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fcopy.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-options \"-std=gnu++0x\" }\n+// { dg-options \"-std=gnu++11\" }\n \n #include <vector>\n #include <testsuite_hooks.h>\n@@ -49,9 +49,22 @@ void test02()\n   VERIFY(1 == v2.get_allocator().get_personality());\n }\n \n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_back(T());\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "810e66df0c90bc1387d788efb5dbc8c2d4cf2eb0", "filename": "libstdc++-v3/testsuite/23_containers/vector/allocator/move.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fmove.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { T() };\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { T() };\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "35da91eb40deab2c0a88f15dab603141a3122b07", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fassign_neg.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1305 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1306 }\n \n #include <vector>\n "}, {"sha": "9f025d17037d060e416a490ec7bd9b1cbfd16d2a", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1231 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1232 }\n \n #include <vector>\n "}, {"sha": "cc178cb02d7e1d24a289093abf17db875f893a36", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Fconstructor_2_neg.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1231 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1232 }\n \n #include <vector>\n #include <utility>"}, {"sha": "ac48068929c6f2f54ac68372ae65a4c7376ac938", "filename": "libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/insert_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Finsert_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Finsert_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Frequirements%2Fdr438%2Finsert_neg.cc?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-error \"no matching\" \"\" { target *-*-* } 1346 }\n+// { dg-error \"no matching\" \"\" { target *-*-* } 1347 }\n \n #include <vector>\n "}, {"sha": "3dcd94e13c66684cd11b279a7d40e14125f9affd", "filename": "libstdc++-v3/testsuite/util/testsuite_allocator.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_allocator.h?ref=ff90a89e480d318bbb1a09fca1ea76c1a86e3ebb", "patch": "@@ -411,11 +411,11 @@ namespace __gnu_test\n \n       propagating_allocator&\n       operator=(const propagating_allocator& a) noexcept\n-\t{\n-\t  static_assert(Propagate, \"assigning propagating_allocator<T, true>\");\n-\t  propagating_allocator(a).swap_base(*this);\n-\t  return *this;\n-\t}\n+      {\n+\tstatic_assert(Propagate, \"assigning propagating_allocator<T, true>\");\n+\tpropagating_allocator(a).swap_base(*this);\n+\treturn *this;\n+      }\n \n       template<bool P2>\n   \tpropagating_allocator&"}]}