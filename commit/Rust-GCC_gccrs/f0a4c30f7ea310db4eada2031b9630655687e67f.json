{"sha": "f0a4c30f7ea310db4eada2031b9630655687e67f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBhNGMzMGY3ZWEzMTBkYjRlYWRhMjAzMWI5NjMwNjU1Njg3ZTY3Zg==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2004-03-11T14:41:47Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-03-11T14:41:47Z"}, "message": "BufferedInputStream.java (marktarget): New field for max mark limit.\n\n2004-03-11  Guilhem Lavaux  <guilhem@kaffe.org>\n\n\t* java/io/BufferedInputStream.java (marktarget): New field for max\n\tmark limit.\n\t(CHUNKSIZE): New constant for incremental mark buffer allocation.\n\t(mark): Use new fields.\n\t(read): Likewise.\n\t(read(byte[],int,int)): Likewise.\n\t(skip): Likewise.\n\t(refill): Likewise.\n\nFrom-SVN: r79326", "tree": {"sha": "f7fbed2c53118efcbff37a49ff39a94a24397607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7fbed2c53118efcbff37a49ff39a94a24397607"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0a4c30f7ea310db4eada2031b9630655687e67f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0a4c30f7ea310db4eada2031b9630655687e67f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0a4c30f7ea310db4eada2031b9630655687e67f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0a4c30f7ea310db4eada2031b9630655687e67f/comments", "author": null, "committer": null, "parents": [{"sha": "6bbec498e5aba91b69c9b8060266042924321d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bbec498e5aba91b69c9b8060266042924321d4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bbec498e5aba91b69c9b8060266042924321d4e"}], "stats": {"total": 39, "additions": 34, "deletions": 5}, "files": [{"sha": "7a1b0e2d057d904bf2784215914b418c780036bc", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a4c30f7ea310db4eada2031b9630655687e67f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a4c30f7ea310db4eada2031b9630655687e67f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f0a4c30f7ea310db4eada2031b9630655687e67f", "patch": "@@ -1,3 +1,14 @@\n+2004-03-11  Guilhem Lavaux  <guilhem@kaffe.org>\n+\n+\t* java/io/BufferedInputStream.java (marktarget): New field for max\n+\tmark limit.\n+\t(CHUNKSIZE): New constant for incremental mark buffer allocation.\n+\t(mark): Use new fields.\n+\t(read): Likewise.\n+\t(read(byte[],int,int)): Likewise.\n+\t(skip): Likewise.\n+\t(refill): Likewise.\n+\n 2004-03-11  Mark Wielaard  <mark@klomp.org>\n \n \t* java/beans/BeanDescriptor.java (BeanDescriptor):"}, {"sha": "cd8e681ed1f7391e9282d3916cc08a00d38cc6b5", "filename": "libjava/java/io/BufferedInputStream.java", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0a4c30f7ea310db4eada2031b9630655687e67f/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0a4c30f7ea310db4eada2031b9630655687e67f/libjava%2Fjava%2Fio%2FBufferedInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedInputStream.java?ref=f0a4c30f7ea310db4eada2031b9630655687e67f", "patch": "@@ -102,6 +102,19 @@ public class BufferedInputStream extends FilterInputStream\n    */\n   protected int marklimit = 0;\n \n+  /**\n+   * This is the maximum size we have to allocate for the mark buffer.\n+   * This number may be huge (Integer.MAX_VALUE). The class will continue\n+   * to allocate new chunks (specified by <code>CHUNKSIZE</code>) until the\n+   * the size specified by this field is achieved.\n+   */\n+  private int marktarget = 0;\n+\n+  /**\n+   * This is the number of bytes to allocate to reach marktarget.\n+   */\n+  static final private int CHUNKSIZE = 1024;\n+\n   /**\n    * This method initializes a new <code>BufferedInputStream</code> that will\n    * read from the specified subordinate stream with a default buffer size\n@@ -183,7 +196,9 @@ public void close() throws IOException\n    */\n   public synchronized void mark(int readlimit)\n   {\n-    marklimit = readlimit;\n+    marktarget = marklimit = readlimit;\n+    if (marklimit > CHUNKSIZE)\n+\tmarklimit = CHUNKSIZE;\n     markpos = pos;\n   }\n \n@@ -216,7 +231,7 @@ public synchronized int read() throws IOException\n     if (pos >= count && !refill())\n       return -1;\t// EOF\n \n-    if (markpos >= 0 && pos - markpos > marklimit)\n+    if (markpos >= 0 && pos - markpos > marktarget)\n       markpos = -1;\n \n     return ((int) buf[pos++]) & 0xFF;\n@@ -255,7 +270,7 @@ public synchronized int read(byte[] b, int off, int len) throws IOException\n     System.arraycopy(buf, pos, b, off, remain);\n     pos += remain;\n \n-    if (markpos >= 0 && pos - markpos > marklimit)\n+    if (markpos >= 0 && pos - markpos > marktarget)\n       markpos = -1;\n \n     return remain;\n@@ -309,7 +324,7 @@ public synchronized long skip(long n) throws IOException\n \tpos += numread;\n \tn -= numread;\n \n-        if (markpos >= 0 && pos - markpos > marklimit)\n+        if (markpos >= 0 && pos - markpos > marktarget)\n           markpos = -1;\n       }\n \n@@ -337,13 +352,16 @@ else if (markpos > 0)\n \tpos -= markpos;\n \tmarkpos = 0;\n       }\n-    else if (marklimit >= buf.length)\t// BTW, markpos == 0\n+    else if (marktarget >= buf.length && marklimit < marktarget)\t// BTW, markpos == 0\n       {\n \t// Need to grow the buffer now to have room for marklimit bytes.\n \t// Note that the new buffer is one greater than marklimit.\n \t// This is so that there will be one byte past marklimit to be read\n \t// before having to call refill again, thus allowing marklimit to be\n \t// invalidated.  That way refill doesn't have to check marklimit.\n+\tmarklimit += CHUNKSIZE;\n+\tif (marklimit >= marktarget)\n+\t  marklimit = marktarget;\n \tbyte[] newbuf = new byte[marklimit + 1];\n \tSystem.arraycopy(buf, 0, newbuf, 0, count);\n \tbuf = newbuf;"}]}