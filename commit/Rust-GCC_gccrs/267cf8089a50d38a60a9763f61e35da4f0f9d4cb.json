{"sha": "267cf8089a50d38a60a9763f61e35da4f0f9d4cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY3Y2Y4MDg5YTUwZDM4YTYwYTk3NjNmNjFlMzVkYTRmMGY5ZDRjYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-05T08:31:48Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-05T08:31:48Z"}, "message": "[multiple changes]\n\nFri Nov  5 01:24:37 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n\n        * global.c (CONFLICTP, SET_CONFLICT): Avoid signed division.\n        (mirror_conflicts): New function.\n        (global_alloc): Call it.\n        (expand_preferences): Remove redundant CONFLICTP test.\n        (find_reg, dump_conflicts): Likewise.\n        (prune_preferences): Process conflicts one word at a time.\n\nFri Nov  5 01:05:21 1999  Richard Henderson <rth@cygnus.com>\n\n        * global.c (build_insn_chain): Use EXECUTE_IF_SET_IN_BITMAP\n        instead of an explicit loop.\n\nFrom-SVN: r30407", "tree": {"sha": "b6cf98ab906e110b2421fe21f3bd6bf7ba018b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6cf98ab906e110b2421fe21f3bd6bf7ba018b07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/267cf8089a50d38a60a9763f61e35da4f0f9d4cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/267cf8089a50d38a60a9763f61e35da4f0f9d4cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/267cf8089a50d38a60a9763f61e35da4f0f9d4cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/267cf8089a50d38a60a9763f61e35da4f0f9d4cb/comments", "author": null, "committer": null, "parents": [{"sha": "26132f7136c30b670786d3e8cb4b033de8d2a179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26132f7136c30b670786d3e8cb4b033de8d2a179", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26132f7136c30b670786d3e8cb4b033de8d2a179"}], "stats": {"total": 141, "additions": 108, "deletions": 33}, "files": [{"sha": "f0774977c501f57fc81ea43eb0abf1fbc9518f56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267cf8089a50d38a60a9763f61e35da4f0f9d4cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267cf8089a50d38a60a9763f61e35da4f0f9d4cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=267cf8089a50d38a60a9763f61e35da4f0f9d4cb", "patch": "@@ -1,3 +1,17 @@\n+Fri Nov  5 01:24:37 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* global.c (CONFLICTP, SET_CONFLICT): Avoid signed division.\n+\t(mirror_conflicts): New function.\n+\t(global_alloc): Call it.\n+\t(expand_preferences): Remove redundant CONFLICTP test.\n+\t(find_reg, dump_conflicts): Likewise.\n+\t(prune_preferences): Process conflicts one word at a time.\n+\n+Fri Nov  5 01:05:21 1999  Richard Henderson <rth@cygnus.com>\n+\n+\t* global.c (build_insn_chain): Use EXECUTE_IF_SET_IN_BITMAP\n+\tinstead of an explicit loop.\n+\n Thu Nov  4 23:07:14 1999  Jim Wilson  <wilson@cygnus.com>\n \n \t* cse.c (cse_insn): Revert Oct 31 change.  When computing src_elt,"}, {"sha": "3cb6b34ef252f4d8a2fc69b544f86c462b1354e0", "filename": "gcc/global.c", "status": "modified", "additions": 94, "deletions": 33, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/267cf8089a50d38a60a9763f61e35da4f0f9d4cb/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/267cf8089a50d38a60a9763f61e35da4f0f9d4cb/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=267cf8089a50d38a60a9763f61e35da4f0f9d4cb", "patch": "@@ -114,8 +114,7 @@ static int *reg_may_share;\n    recording whether two allocno's conflict (can't go in the same\n    hardware register).\n \n-   `conflicts' is not symmetric; a conflict between allocno's i and j\n-   is recorded either in element i,j or in element j,i.  */\n+   `conflicts' is symmetric after the call to mirror_conflicts.  */\n \n static INT_TYPE *conflicts;\n \n@@ -127,12 +126,18 @@ static int allocno_row_words;\n /* Two macros to test or store 1 in an element of `conflicts'.  */\n \n #define CONFLICTP(I, J) \\\n- (conflicts[(I) * allocno_row_words + (J) / INT_BITS]\t\\\n-  & ((INT_TYPE) 1 << ((J) % INT_BITS)))\n+ (conflicts[(I) * allocno_row_words + (unsigned)(J) / INT_BITS]\t\\\n+  & ((INT_TYPE) 1 << ((unsigned)(J) % INT_BITS)))\n \n #define SET_CONFLICT(I, J) \\\n- (conflicts[(I) * allocno_row_words + (J) / INT_BITS]\t\\\n-  |= ((INT_TYPE) 1 << ((J) % INT_BITS)))\n+ (conflicts[(I) * allocno_row_words + (unsigned)(J) / INT_BITS]\t\\\n+  |= ((INT_TYPE) 1 << ((unsigned)(J) % INT_BITS)))\n+\n+/* CYGNUS LOCAL LRS */\n+#define CLEAR_CONFLICT(I, J) \\\n+ (conflicts[(I) * allocno_row_words + (J) / INT_BITS]   \\\n+  &= ~ ((INT_TYPE) 1 << ((J) % INT_BITS)))\n+/* END CYGNUS LOCAL */\n \n /* Set of hard regs currently live (during scan of all insns).  */\n \n@@ -259,6 +264,7 @@ static HARD_REG_SET eliminable_regset;\n \n static int allocno_compare\tPROTO((const PTR, const PTR));\n static void global_conflicts\tPROTO((void));\n+static void mirror_conflicts\tPROTO((void));\n static void expand_preferences\tPROTO((void));\n static void prune_preferences\tPROTO((void));\n static void find_reg\t\tPROTO((int, HARD_REG_SET, int, int, int));\n@@ -486,6 +492,8 @@ global_alloc (file)\n \n       global_conflicts ();\n \n+      mirror_conflicts ();\n+\n       /* Eliminate conflicts between pseudos and eliminable registers.  If\n \t the register is not eliminated, the pseudo won't really be able to\n \t live in the eliminable register, so the conflict doesn't matter.\n@@ -818,9 +826,7 @@ expand_preferences ()\n \t    && GET_CODE (XEXP (link, 0)) == REG\n \t    && reg_allocno[REGNO (XEXP (link, 0))] >= 0\n \t    && ! CONFLICTP (reg_allocno[REGNO (SET_DEST (set))],\n-\t\t\t    reg_allocno[REGNO (XEXP (link, 0))])\n-\t    && ! CONFLICTP (reg_allocno[REGNO (XEXP (link, 0))],\n-\t\t\t    reg_allocno[REGNO (SET_DEST (set))]))\n+\t\t\t    reg_allocno[REGNO (XEXP (link, 0))]))\n \t  {\n \t    int a1 = reg_allocno[REGNO (SET_DEST (set))];\n \t    int a2 = reg_allocno[REGNO (XEXP (link, 0))];\n@@ -856,6 +862,7 @@ prune_preferences ()\n {\n   int i, j;\n   int allocno;\n+  int *allocno_to_order = (int *) xmalloc (max_allocno * sizeof (int));\n   \n   /* Scan least most important to most important.\n      For each allocno, remove from preferences registers that cannot be used,\n@@ -864,9 +871,10 @@ prune_preferences ()\n \n   for (i = max_allocno - 1; i >= 0; i--)\n     {\n-      HARD_REG_SET temp, temp2;\n+      HARD_REG_SET temp;\n \n       allocno = allocno_order[i];\n+      allocno_to_order[allocno] = i;\n       COPY_HARD_REG_SET (temp, hard_reg_conflicts[allocno]);\n \n       if (allocno_calls_crossed[allocno] == 0)\n@@ -881,29 +889,49 @@ prune_preferences ()\n       AND_COMPL_HARD_REG_SET (hard_reg_preferences[allocno], temp);\n       AND_COMPL_HARD_REG_SET (hard_reg_copy_preferences[allocno], temp);\n       AND_COMPL_HARD_REG_SET (hard_reg_full_preferences[allocno], temp);\n+    }\n \n+  for (i = max_allocno - 1; i >= 0; i--)\n+    {\n       /* Merge in the preferences of lower-priority registers (they have\n \t already been pruned).  If we also prefer some of those registers,\n \t don't exclude them unless we are of a smaller size (in which case\n \t we want to give the lower-priority allocno the first chance for\n \t these registers).  */\n+      HARD_REG_SET temp, temp2;\n+      INT_TYPE *p;\n+      int allocno2, allocno3;\n+\n+      allocno = allocno_order[i];\n+      p = conflicts + allocno * allocno_row_words;\n+\n       CLEAR_HARD_REG_SET (temp);\n       CLEAR_HARD_REG_SET (temp2);\n-      for (j = i + 1; j < max_allocno; j++)\n-\tif (CONFLICTP (allocno, allocno_order[j])\n-\t    || CONFLICTP (allocno_order[j], allocno))\n-\t  {\n-\t    if (allocno_size[allocno_order[j]] <= allocno_size[allocno])\n-\t      IOR_HARD_REG_SET (temp,\n-\t\t\t\thard_reg_full_preferences[allocno_order[j]]);\n-\t    else\n-\t      IOR_HARD_REG_SET (temp2,\n-\t\t\t\thard_reg_full_preferences[allocno_order[j]]);\n-\t  }\n+\n+      for (j = allocno_row_words - 1, allocno2 = 0; j >= 0;\n+\t   j--, allocno2 += INT_BITS)\n+\t{\n+\t  unsigned INT_TYPE word = (unsigned INT_TYPE) *p++;\n+\n+\t  for (allocno3 = allocno2; word; word >>= 1, allocno3++)\n+\t    {\n+\t      if ((word & 1) && allocno_to_order[allocno3] > i)\n+\t\t{\n+\t\t  if (allocno_size[allocno3] <= allocno_size[allocno])\n+\t\t    IOR_HARD_REG_SET (temp,\n+\t\t\t\t      hard_reg_full_preferences[allocno3]);\n+\t\t  else\n+\t\t    IOR_HARD_REG_SET (temp2,\n+\t\t\t\t      hard_reg_full_preferences[allocno3]);\n+\t\t}\n+\t    }\n+\t}\n+\n       AND_COMPL_HARD_REG_SET (temp, hard_reg_full_preferences[allocno]);\n       IOR_HARD_REG_SET (temp, temp2);\n       COPY_HARD_REG_SET (regs_someone_prefers[allocno], temp);\n     }\n+  free (allocno_to_order);\n }\n \f\n /* Assign a hard register to ALLOCNO; look for one that is the beginning\n@@ -1219,7 +1247,7 @@ find_reg (allocno, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t mark it as conflicting with the hard regs this one occupies.  */\n       lim = allocno;\n       for (j = 0; j < max_allocno; j++)\n-\tif (CONFLICTP (lim, j) || CONFLICTP (j, lim))\n+\tif (CONFLICTP (j, lim))\n \t  {\n \t    IOR_HARD_REG_SET (hard_reg_conflicts[j], this_reg);\n \t  }\n@@ -1327,6 +1355,38 @@ record_conflicts (allocno_vec, len)\n \tconflicts[ialloc_prod + j] |= allocnos_live[j];\n     }\n }\n+\n+/* If CONFLICTP (i, j) is true, make sure CONFLICTP (j, i) is also true.  */\n+static void\n+mirror_conflicts ()\n+{\n+  register int i, j;\n+  int rw = allocno_row_words;\n+  int rwb = rw * INT_BITS;\n+  INT_TYPE *p = conflicts;\n+  INT_TYPE *q0 = conflicts, *q1, *q2;\n+  unsigned INT_TYPE mask;\n+\n+  for (i = max_allocno - 1, mask = 1; i >= 0; i--, mask <<= 1)\n+    {\n+      if (! mask)\n+\t{\n+\t  mask = 1;\n+\t  q0++;\n+\t}\n+      for (j = allocno_row_words - 1, q1 = q0; j >= 0; j--, q1 += rwb)\n+\t{\n+\t  unsigned INT_TYPE word;\n+\n+\t  for (word = (unsigned INT_TYPE) *p++, q2 = q1; word;\n+\t       word >>= 1, q2 += rw)\n+\t    {\n+\t      if (word & 1)\n+\t\t*q2 |= mask;\n+\t    }\n+\t}\n+    }\n+}\n \f\n /* Handle the case where REG is set by the insn being scanned,\n    during the forward scan to accumulate conflicts.\n@@ -1689,17 +1749,18 @@ build_insn_chain (first)\n       if (first == BLOCK_HEAD (b))\n \t{\n \t  int i;\n+\n \t  CLEAR_REG_SET (live_relevant_regs);\n-\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t    if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, i)\n-\t\t&& ! TEST_HARD_REG_BIT (eliminable_regset, i))\n-\t      SET_REGNO_REG_SET (live_relevant_regs, i);\n-\n-\t  for (; i < max_regno; i++)\n-\t    if (reg_renumber[i] >= 0\n-\t\t&& REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, i))\n-\t      SET_REGNO_REG_SET (live_relevant_regs, i);\n-\t}\n+\n+\t  EXECUTE_IF_SET_IN_BITMAP\n+\t    (BASIC_BLOCK (b)->global_live_at_start, 0, i,\n+\t     {\n+\t       if (i < FIRST_PSEUDO_REGISTER\n+\t\t   ? ! TEST_HARD_REG_BIT (eliminable_regset, i)\n+\t\t   : reg_renumber[i] >= 0)\n+\t\t SET_REGNO_REG_SET (live_relevant_regs, i);\n+\t     });\n+ \t}\n \n       if (GET_CODE (first) != NOTE && GET_CODE (first) != BARRIER)\n \t{\n@@ -1805,7 +1866,7 @@ dump_conflicts (file)\n       register int j;\n       fprintf (file, \";; %d conflicts:\", allocno_reg[i]);\n       for (j = 0; j < max_allocno; j++)\n-\tif (CONFLICTP (i, j) || CONFLICTP (j, i))\n+\tif (CONFLICTP (j, i))\n \t  fprintf (file, \" %d\", allocno_reg[j]);\n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n \tif (TEST_HARD_REG_BIT (hard_reg_conflicts[i], j))"}]}