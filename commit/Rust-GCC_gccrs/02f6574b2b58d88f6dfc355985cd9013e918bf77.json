{"sha": "02f6574b2b58d88f6dfc355985cd9013e918bf77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJmNjU3NGIyYjU4ZDg4ZjZkZmMzNTU5ODVjZDkwMTNlOTE4YmY3Nw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2012-03-14T16:28:20Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2012-03-14T16:28:20Z"}, "message": "expr.c (expand_assignment): Use expand_expr with EXPAND_WRITE when expanding MEM_REFs...\n\n2012-03-14  Martin Jambor  <mjambor@suse.cz>\n\n\t* expr.c (expand_assignment): Use expand_expr with EXPAND_WRITE\n\twhen expanding MEM_REFs, MEM_TARGET_REFs and handled_component\n\tbases.\n\t(expand_expr_real_1): Do not handle misalignment if modifier is\n\tEXPAND_WRITE.\n\nFrom-SVN: r185389", "tree": {"sha": "e5c1e0b11cc42df11b58872df5f45f6e47e2a182", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5c1e0b11cc42df11b58872df5f45f6e47e2a182"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02f6574b2b58d88f6dfc355985cd9013e918bf77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f6574b2b58d88f6dfc355985cd9013e918bf77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02f6574b2b58d88f6dfc355985cd9013e918bf77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f6574b2b58d88f6dfc355985cd9013e918bf77/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "995ec13233c0c62086a11c49b9e4e9f420781036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/995ec13233c0c62086a11c49b9e4e9f420781036", "html_url": "https://github.com/Rust-GCC/gccrs/commit/995ec13233c0c62086a11c49b9e4e9f420781036"}], "stats": {"total": 79, "additions": 18, "deletions": 61}, "files": [{"sha": "e01bd4b578bc7438316b7129580cf976b204e418", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f6574b2b58d88f6dfc355985cd9013e918bf77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f6574b2b58d88f6dfc355985cd9013e918bf77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02f6574b2b58d88f6dfc355985cd9013e918bf77", "patch": "@@ -1,3 +1,11 @@\n+2012-03-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* expr.c (expand_assignment): Use expand_expr with EXPAND_WRITE\n+\twhen expanding MEM_REFs, MEM_TARGET_REFs and handled_component\n+\tbases.\n+\t(expand_expr_real_1): Do not handle misalignment if modifier is\n+\tEXPAND_WRITE.\n+\n 2012-03-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/52584"}, {"sha": "dc4a82e92ae82cdaf329ad94212e1087b2ec9740", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 61, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02f6574b2b58d88f6dfc355985cd9013e918bf77/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02f6574b2b58d88f6dfc355985cd9013e918bf77/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=02f6574b2b58d88f6dfc355985cd9013e918bf77", "patch": "@@ -4530,49 +4530,16 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t   != CODE_FOR_nothing)\n \t  || SLOW_UNALIGNED_ACCESS (mode, align)))\n     {\n-      addr_space_t as\n-\t= TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (to, 0))));\n-      struct expand_operand ops[2];\n-      enum machine_mode address_mode;\n-      rtx reg, op0, mem;\n+      rtx reg, mem;\n \n       reg = expand_expr (from, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n       reg = force_not_mem (reg);\n-\n-      if (TREE_CODE (to) == MEM_REF)\n-\t{\n-\t  tree base = TREE_OPERAND (to, 0);\n-\t  address_mode = targetm.addr_space.address_mode (as);\n-\t  op0 = expand_expr (base, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-\t  op0 = convert_memory_address_addr_space (address_mode, op0, as);\n-\t  if (!integer_zerop (TREE_OPERAND (to, 1)))\n-\t    {\n-\t      rtx off\n-\t\t= immed_double_int_const (mem_ref_offset (to), address_mode);\n-\t      op0 = simplify_gen_binary (PLUS, address_mode, op0, off);\n-\t    }\n-\t  op0 = memory_address_addr_space (mode, op0, as);\n-\t  mem = gen_rtx_MEM (mode, op0);\n-\t  set_mem_attributes (mem, to, 0);\n-\t  set_mem_addr_space (mem, as);\n-\t}\n-      else if (TREE_CODE (to) == TARGET_MEM_REF)\n-\t{\n-\t  struct mem_address addr;\n-\t  get_address_description (to, &addr);\n-\t  op0 = addr_for_mem_ref (&addr, as, true);\n-\t  op0 = memory_address_addr_space (mode, op0, as);\n-\t  mem = gen_rtx_MEM (mode, op0);\n-\t  set_mem_attributes (mem, to, 0);\n-\t  set_mem_addr_space (mem, as);\n-\t}\n-      else\n-\tgcc_unreachable ();\n-      if (TREE_THIS_VOLATILE (to))\n-\tMEM_VOLATILE_P (mem) = 1;\n+      mem = expand_expr (to, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n       if (icode != CODE_FOR_nothing)\n \t{\n+\t  struct expand_operand ops[2];\n+\n \t  create_fixed_operand (&ops[0], mem);\n \t  create_input_operand (&ops[1], reg, mode);\n \t  /* The movmisalign<mode> pattern cannot fail, else the assignment\n@@ -4624,31 +4591,11 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t  && ((icode = optab_handler (movmisalign_optab, mode))\n \t      != CODE_FOR_nothing))\n \t{\n-\t  enum machine_mode address_mode;\n-\t  rtx op0;\n \t  struct expand_operand ops[2];\n-\t  addr_space_t as = TYPE_ADDR_SPACE\n-\t      (TREE_TYPE (TREE_TYPE (TREE_OPERAND (tem, 0))));\n-\t  tree base = TREE_OPERAND (tem, 0);\n \n \t  misalignp = true;\n \t  to_rtx = gen_reg_rtx (mode);\n-\n-\t  address_mode = targetm.addr_space.address_mode (as);\n-\t  op0 = expand_expr (base, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-\t  op0 = convert_memory_address_addr_space (address_mode, op0, as);\n-\t  if (!integer_zerop (TREE_OPERAND (tem, 1)))\n-\t    {\n-\t      rtx off = immed_double_int_const (mem_ref_offset (tem),\n-\t\t\t\t\t\taddress_mode);\n-\t      op0 = simplify_gen_binary (PLUS, address_mode, op0, off);\n-\t    }\n-\t  op0 = memory_address_addr_space (mode, op0, as);\n-\t  mem = gen_rtx_MEM (mode, op0);\n-\t  set_mem_attributes (mem, tem, 0);\n-\t  set_mem_addr_space (mem, as);\n-\t  if (TREE_THIS_VOLATILE (tem))\n-\t    MEM_VOLATILE_P (mem) = 1;\n+\t  mem = expand_expr (tem, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \n \t  /* If the misaligned store doesn't overwrite all bits, perform\n \t     rmw cycle on MEM.  */\n@@ -4666,7 +4613,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       else\n \t{\n \t  misalignp = false;\n-\t  to_rtx = expand_normal (tem);\n+\t  to_rtx = expand_expr (tem, NULL_RTX, VOIDmode, EXPAND_WRITE);\n \t}\n \n       /* If the bitfield is volatile, we want to access it in the\n@@ -9302,7 +9249,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tset_mem_attributes (temp, exp, 0);\n \tset_mem_addr_space (temp, as);\n \talign = get_object_or_type_alignment (exp);\n-\tif (mode != BLKmode\n+\tif (modifier != EXPAND_WRITE\n+\t    && mode != BLKmode\n \t    && align < GET_MODE_ALIGNMENT (mode)\n \t    /* If the target does not have special handling for unaligned\n \t       loads of mode then it can use regular moves for them.  */\n@@ -9390,7 +9338,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tset_mem_addr_space (temp, as);\n \tif (TREE_THIS_VOLATILE (exp))\n \t  MEM_VOLATILE_P (temp) = 1;\n-\tif (mode != BLKmode\n+\tif (modifier != EXPAND_WRITE\n+\t    && mode != BLKmode\n \t    && align < GET_MODE_ALIGNMENT (mode)\n \t    /* If the target does not have special handling for unaligned\n \t       loads of mode then it can use regular moves for them.  */"}]}