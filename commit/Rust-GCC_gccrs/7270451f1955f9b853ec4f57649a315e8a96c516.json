{"sha": "7270451f1955f9b853ec4f57649a315e8a96c516", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI3MDQ1MWYxOTU1ZjliODUzZWM0ZjU3NjQ5YTMxNWU4YTk2YzUxNg==", "commit": {"author": {"name": "Eric Blake", "email": "ebb9@email.byu.edu", "date": "2003-03-30T06:43:45Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-03-30T06:43:45Z"}, "message": "natString.cc (hashCode): Use cachedHashCode.\n\n2003-03-29  Eric Blake  <ebb9@email.byu.edu>\n\t    Tom Tromey  <tromey@redhat.com>\n\n\t* java/lang/natString.cc (hashCode): Use cachedHashCode.\n\t(init()): Removed.\n\t(charAt): Put index in exception.\n\t(contentEquals): New method.\n\tInclude StringBuffer.h.\n\t* java/lang/String.java (cachedHashCode): New field.\n\t(String()): Follow classpath implementation.\n\t(init()): Removed.\n\t(contentEquals): Declare.\n\t(subSequence): Don't declare IndexOutIfBoundsException in throws\n\tclause.\n\t(matches, replaceFirst, replaceAll, split): New methods from\n\tClasspath.\n\nCo-Authored-By: Tom Tromey <tromey@redhat.com>\n\nFrom-SVN: r65037", "tree": {"sha": "2743db1170c10ebb6bc778029f9a50d57990a31e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2743db1170c10ebb6bc778029f9a50d57990a31e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7270451f1955f9b853ec4f57649a315e8a96c516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7270451f1955f9b853ec4f57649a315e8a96c516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7270451f1955f9b853ec4f57649a315e8a96c516", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7270451f1955f9b853ec4f57649a315e8a96c516/comments", "author": null, "committer": null, "parents": [{"sha": "9ba99c63ab5d93e5ab12888cfb44beb9940b234f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ba99c63ab5d93e5ab12888cfb44beb9940b234f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ba99c63ab5d93e5ab12888cfb44beb9940b234f"}], "stats": {"total": 199, "additions": 184, "deletions": 15}, "files": [{"sha": "ae9c68c0fce664e2dd1f57c9df9e24d1b8a79c48", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7270451f1955f9b853ec4f57649a315e8a96c516/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7270451f1955f9b853ec4f57649a315e8a96c516/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7270451f1955f9b853ec4f57649a315e8a96c516", "patch": "@@ -1,3 +1,20 @@\n+2003-03-29  Eric Blake  <ebb9@email.byu.edu>\n+\t    Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/natString.cc (hashCode): Use cachedHashCode.\n+\t(init()): Removed.\n+\t(charAt): Put index in exception.\n+\t(contentEquals): New method.\n+\tInclude StringBuffer.h.\n+\t* java/lang/String.java (cachedHashCode): New field.\n+\t(String()): Follow classpath implementation.\n+\t(init()): Removed.\n+\t(contentEquals): Declare.\n+\t(subSequence): Don't declare IndexOutIfBoundsException in throws\n+\tclause.\n+\t(matches, replaceFirst, replaceAll, split): New methods from\n+\tClasspath.\n+\n 2003-03-29  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/String.java: Reordered to follow Classpath; merged in"}, {"sha": "29b9c45d44d7f08390eeebd3169d9b0096adebfa", "filename": "libjava/java/lang/String.java", "status": "modified", "additions": 142, "deletions": 4, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7270451f1955f9b853ec4f57649a315e8a96c516/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7270451f1955f9b853ec4f57649a315e8a96c516/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=7270451f1955f9b853ec4f57649a315e8a96c516", "patch": "@@ -44,6 +44,8 @@\n import java.lang.Comparable;\n import java.util.Comparator;\n import java.util.Locale;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n \n /**\n  * Strings represent an immutable set of characters.  All String literals\n@@ -86,6 +88,12 @@ public final class String implements Serializable, Comparable, CharSequence\n   private int boffset; // Note this is a byte offset - don't use in Java code!\n   int count;\n \n+  /**\n+   * Caches the result of hashCode().  If this value is zero, the hashcode\n+   * is considered uncached (even if 0 is the correct hash value).\n+   */\n+  private int cachedHashCode;\n+\n   /**\n    * An implementation for {@link CASE_INSENSITIVE_ORDER}.\n    * This must be {@link Serializable}. The class name is dictated by\n@@ -137,9 +145,11 @@ public int compare(Object o1, Object o2)\n    * Creates an empty String (length 0). Unless you really need a new object,\n    * consider using <code>\"\"</code> instead.\n    */\n-  public String ()\n+  public String()\n   {\n-    init();\n+    data = \"\".data;\n+    boffset = 0;\n+    count = 0;\n   }\n \n   /**\n@@ -154,6 +164,7 @@ public String (String str)\n     data = str.data;\n     boffset = str.boffset;\n     count = str.count;\n+    cachedHashCode = str.cachedHashCode;\n   }\n \n   /**\n@@ -510,6 +521,17 @@ public byte[] getBytes ()\n    */\n   public native boolean equals (Object anObject);\n \n+  /**\n+   * Compares the given StringBuffer to this String. This is true if the\n+   * StringBuffer has the same content as this String at this moment.\n+   *\n+   * @param buffer the StringBuffer to compare to\n+   * @return true if StringBuffer has the same character sequence\n+   * @throws NullPointerException if the given StringBuffer is null\n+   * @since 1.4\n+   */\n+  public native boolean contentEquals(StringBuffer buffer);\n+\n   /**\n    * Compares a String to this String, ignoring case. This does not handle\n    * multi-character capitalization exceptions; instead the comparison is\n@@ -815,7 +837,6 @@ public String substring (int beginIndex)\n    * @since 1.4\n    */\n   public CharSequence subSequence(int beginIndex, int endIndex)\n-    throws IndexOutOfBoundsException\n   {\n     return substring(beginIndex, endIndex);\n   }\n@@ -840,6 +861,124 @@ public CharSequence subSequence(int beginIndex, int endIndex)\n    */\n   public native String replace (char oldChar, char newChar);\n \n+  /**\n+   * Test if this String matches a regular expression. This is shorthand for\n+   * <code>{@link Pattern}.matches(regex, this)</code>.\n+   *\n+   * @param regex the pattern to match\n+   * @return true if the pattern matches\n+   * @throws NullPointerException if regex is null\n+   * @throws PatternSyntaxException if regex is invalid\n+   * @see Pattern#matches(String, CharSequence)\n+   * @since 1.4\n+   */\n+  public boolean matches(String regex)\n+  {\n+    return Pattern.matches(regex, this);\n+  }\n+\n+  /**\n+   * Replaces the first substring match of the regular expression with a\n+   * given replacement. This is shorthand for <code>{@link Pattern}\n+   *   .compile(regex).matcher(this).replaceFirst(replacement)</code>.\n+   *\n+   * @param regex the pattern to match\n+   * @param replacement the replacement string\n+   * @return the modified string\n+   * @throws NullPointerException if regex or replacement is null\n+   * @throws PatternSyntaxException if regex is invalid\n+   * @see #replaceAll(String, String)\n+   * @see Pattern#compile(String)\n+   * @see Pattern#matcher(CharSequence)\n+   * @see Matcher#replaceFirst(String)\n+   * @since 1.4\n+   */\n+  public String replaceFirst(String regex, String replacement)\n+  {\n+    return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n+  }\n+\n+  /**\n+   * Replaces all matching substrings of the regular expression with a\n+   * given replacement. This is shorthand for <code>{@link Pattern}\n+   *   .compile(regex).matcher(this).replaceAll(replacement)</code>.\n+   *\n+   * @param regex the pattern to match\n+   * @param replacement the replacement string\n+   * @return the modified string\n+   * @throws NullPointerException if regex or replacement is null\n+   * @throws PatternSyntaxException if regex is invalid\n+   * @see #replaceFirst(String, String)\n+   * @see Pattern#compile(String)\n+   * @see Pattern#matcher(CharSequence)\n+   * @see Matcher#replaceAll(String)\n+   * @since 1.4\n+   */\n+  public String replaceAll(String regex, String replacement)\n+  {\n+    return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n+  }\n+\n+  /**\n+   * Split this string around the matches of a regular expression. Each\n+   * element of the returned array is the largest block of characters not\n+   * terminated by the regular expression, in the order the matches are found.\n+   *\n+   * <p>The limit affects the length of the array. If it is positive, the\n+   * array will contain at most n elements (n - 1 pattern matches). If\n+   * negative, the array length is unlimited, but there can be trailing empty\n+   * entries. if 0, the array length is unlimited, and trailing empty entries\n+   * are discarded.\n+   *\n+   * <p>For example, splitting \"boo:and:foo\" yields:<br>\n+   * <table border=0>\n+   * <th><td>Regex</td> <td>Limit</td> <td>Result</td></th>\n+   * <tr><td>\":\"</td>   <td>2</td>  <td>{ \"boo\", \"and:foo\" }</td></tr>\n+   * <tr><td>\":\"</td>   <td>t</td>  <td>{ \"boo\", \"and\", \"foo\" }</td></tr>\n+   * <tr><td>\":\"</td>   <td>-2</td> <td>{ \"boo\", \"and\", \"foo\" }</td></tr>\n+   * <tr><td>\"o\"</td>   <td>5</td>  <td>{ \"b\", \"\", \":and:f\", \"\", \"\" }</td></tr>\n+   * <tr><td>\"o\"</td>   <td>-2</td> <td>{ \"b\", \"\", \":and:f\", \"\", \"\" }</td></tr>\n+   * <tr><td>\"o\"</td>   <td>0</td>  <td>{ \"b\", \"\", \":and:f\" }</td></tr>\n+   * </table>\n+   *\n+   * <p>This is shorthand for\n+   * <code>{@link Pattern}.compile(regex).split(this, limit)</code>.\n+   *\n+   * @param regex the pattern to match\n+   * @param limit the limit threshold\n+   * @return the array of split strings\n+   * @throws NullPointerException if regex or replacement is null\n+   * @throws PatternSyntaxException if regex is invalid\n+   * @see Pattern#compile(String)\n+   * @see Pattern#split(CharSequence, int)\n+   * @since 1.4\n+   */\n+  public String[] split(String regex, int limit)\n+  {\n+    return Pattern.compile(regex).split(this, limit);\n+  }\n+\n+  /**\n+   * Split this string around the matches of a regular expression. Each\n+   * element of the returned array is the largest block of characters not\n+   * terminated by the regular expression, in the order the matches are found.\n+   * The array length is unlimited, and trailing empty entries are discarded,\n+   * as though calling <code>split(regex, 0)</code>.\n+   *\n+   * @param regex the pattern to match\n+   * @return the array of split strings\n+   * @throws NullPointerException if regex or replacement is null\n+   * @throws PatternSyntaxException if regex is invalid\n+   * @see #split(String, int)\n+   * @see Pattern#compile(String)\n+   * @see Pattern#split(CharSequence, int)\n+   * @since 1.4\n+   */\n+  public String[] split(String regex)\n+  {\n+    return Pattern.compile(regex).split(this, 0);\n+  }\n+\n   /**\n    * Lowercases this String according to a particular locale. This uses\n    * Unicode's special case mappings, as applied to the given Locale, so the\n@@ -1088,7 +1227,6 @@ public static String valueOf (double d)\n   public native String intern ();\n \n \n-  private native void init ();\n   private native void init (char[] chars, int offset, int count,\n \t\t\t    boolean dont_copy);\n   private native void init (byte[] chars, int hibyte, int offset, int count);"}, {"sha": "6514d816a029ca54edb896e309c35b993c20c4ac", "filename": "libjava/java/lang/natString.cc", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7270451f1955f9b853ec4f57649a315e8a96c516/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7270451f1955f9b853ec4f57649a315e8a96c516/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=7270451f1955f9b853ec4f57649a315e8a96c516", "patch": "@@ -1,6 +1,6 @@\n // natString.cc - Implementation of java.lang.String native methods.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -20,6 +20,7 @@ details.  */\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/StringIndexOutOfBoundsException.h>\n #include <java/lang/NullPointerException.h>\n+#include <java/lang/StringBuffer.h>\n #include <java/io/ByteArrayOutputStream.h>\n #include <java/io/OutputStreamWriter.h>\n #include <java/io/ByteArrayInputStream.h>\n@@ -102,7 +103,9 @@ hashChars (jchar* ptr, jint length)\n jint\n java::lang::String::hashCode()\n {\n-  return hashChars(JvGetStringChars(this), length());\n+  if (cachedHashCode == 0)\n+    cachedHashCode = hashChars(JvGetStringChars(this), length());\n+  return cachedHashCode;\n }\n \n jstring*\n@@ -428,14 +431,6 @@ _Jv_NewStringLatin1(const char *bytes, jsize len)\n   return str;\n }\n \n-void\n-java::lang::String::init ()\n-{\n-  count = 0;\n-  boffset = sizeof(java::lang::String);\n-  data = this;\n-}\n-\n void\n java::lang::String::init(jcharArray chars, jint offset, jint count,\n \t\t\t jboolean dont_copy)\n@@ -552,11 +547,30 @@ java::lang::String::equals(jobject anObject)\n   return true;\n }\n \n+jboolean\n+java::lang::String::contentEquals(java::lang::StringBuffer* buffer)\n+{\n+  if (buffer == NULL)\n+    throw new NullPointerException;\n+  JvSynchronize sync(buffer);\n+  if (count != buffer->count)\n+    return false;\n+  if (data == buffer->value)\n+    return true; // Possible if shared.\n+  jint i = count;\n+  jchar *xptr = JvGetStringChars(this);\n+  jchar *yptr = elements(buffer->value);\n+  while (--i >= 0)\n+    if (*xptr++ != *yptr++)\n+      return false;\n+  return true;\n+}\n+\n jchar\n java::lang::String::charAt(jint i)\n {\n   if (i < 0 || i >= count)\n-    throw new java::lang::StringIndexOutOfBoundsException;\n+    throw new java::lang::StringIndexOutOfBoundsException(i);\n   return JvGetStringChars(this)[i];\n }\n "}]}