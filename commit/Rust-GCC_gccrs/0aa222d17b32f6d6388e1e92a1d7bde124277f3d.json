{"sha": "0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFhMjIyZDE3YjMyZjZkNjM4OGUxZTkyYTFkN2JkZTEyNDI3N2YzZA==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2007-07-05T17:08:37Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2007-07-05T17:08:37Z"}, "message": "Add support for SmartMIPS ASE.\n\n2007-07-05  Sandra Loosemore  <sandra@codesourcery.com>\n\t    David Ung  <davidu@mips.com>\n\n\tAdd support for SmartMIPS ASE.\n\n\tgcc/\n\t* optabs.c (expand_binop_directly): New, broken out from...\n\t(expand_binop): Here.  Make it try rotating in the other\n\tdirection even when the second operand isn't constant.\n\t* config/mips/mips.md (*lwxs): New.\n\t* config/mips/mips.opt (msmartmips): New.\n\t* config/mips/mips.c (mips_lwxs_address_p): New.\n\t(mips_rtx_costs): Make it recognize scaled indexed addressing.\n\t* config/mips/mips.h (TARGET_CPU_CPP_BUILTINS): Define\n\t__mips_smartmips when compiling for TARGET_SMARTMIPS.\n\t(ISA_HAS_ROR): Define for TARGET_SMARTMIPS.\n\t(ISA_HAS_LWXS): New.\n\t(ASM_SPEC): Add -msmartmips/-mno-smartmips.\n\t* doc/invoke.texi (MIPS Options): Document -msmartmips/-mno-smartmips.\n\t* testsuite/gcc.target/mips/smartmips-lwxs.c: New test case.\n\t* testsuite/gcc.target/mips/smartmips-ror-1.c: New test case.\n\t* testsuite/gcc.target/mips/smartmips-ror-2.c: New test case.\n\t* testsuite/gcc.target/mips/smartmips-ror-3.c: New test case.\n\t* testsuite/gcc.target/mips/smartmips-ror-4.c: New test case.\n\nCo-Authored-By: David Ung <davidu@mips.com>\n\nFrom-SVN: r126370", "tree": {"sha": "412155942760389b80c2e11cd433bae27b0a1df4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/412155942760389b80c2e11cd433bae27b0a1df4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6fd2892a68b395f626c97657096e9a80afa9e154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd2892a68b395f626c97657096e9a80afa9e154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fd2892a68b395f626c97657096e9a80afa9e154"}], "stats": {"total": 382, "additions": 269, "deletions": 113}, "files": [{"sha": "2fecaf1c0cbd35307b093e62a89513f6b7c85aa7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -1,3 +1,27 @@\n+2007-07-05  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    David Ung  <davidu@mips.com>\n+\n+\tAdd support for SmartMIPS ASE.\n+\n+\t* optabs.c (expand_binop_directly): New, broken out from...\n+\t(expand_binop): Here.  Make it try rotating in the other\n+\tdirection even when the second operand isn't constant.\n+\t* config/mips/mips.md (*lwxs): New.\n+\t* config/mips/mips.opt (msmartmips): New.\n+\t* config/mips/mips.c (mips_lwxs_address_p): New.\n+\t(mips_rtx_costs): Make it recognize scaled indexed addressing.\n+\t* config/mips/mips.h (TARGET_CPU_CPP_BUILTINS): Define\n+\t__mips_smartmips when compiling for TARGET_SMARTMIPS.\n+\t(ISA_HAS_ROR): Define for TARGET_SMARTMIPS.\n+\t(ISA_HAS_LWXS): New.\n+\t(ASM_SPEC): Add -msmartmips/-mno-smartmips.\n+\t* doc/invoke.texi (MIPS Options): Document -msmartmips/-mno-smartmips.\n+\t* testsuite/gcc.target/mips/smartmips-lwxs.c: New test case.\n+\t* testsuite/gcc.target/mips/smartmips-ror-1.c: New test case.\n+\t* testsuite/gcc.target/mips/smartmips-ror-2.c: New test case.\n+\t* testsuite/gcc.target/mips/smartmips-ror-3.c: New test case.\n+\t* testsuite/gcc.target/mips/smartmips-ror-4.c: New test case.\n+\n 2007-07-05  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* tree-vectorizer.c (new_loop_vec_info): Initialize"}, {"sha": "7b101e32555b3b8512e83a0023f87a7df3790600", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -2682,6 +2682,26 @@ m16_nsimm8_8 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return m16_check_op (op, (- 0x7f) << 3, 0x80 << 3, 7);\n }\n \f\n+/* Return true if ADDR matches the pattern for the lwxs load scaled indexed\n+   address instruction.  */\n+\n+static bool\n+mips_lwxs_address_p (rtx addr)\n+{\n+  if (ISA_HAS_LWXS\n+      && GET_CODE (addr) == PLUS\n+      && REG_P (XEXP (addr, 1)))\n+    {\n+      rtx offset = XEXP (addr, 0);\n+      if (GET_CODE (offset) == MULT\n+\t  && REG_P (XEXP (offset, 0))\n+\t  && GET_CODE (XEXP (offset, 1)) == CONST_INT\n+\t  && INTVAL (XEXP (offset, 1)) == 4)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n static bool\n mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n@@ -2778,13 +2798,21 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case MEM:\n       {\n \t/* If the address is legitimate, return the number of\n-\t   instructions it needs, otherwise use the default handling.  */\n-\tint n = mips_address_insns (XEXP (x, 0), GET_MODE (x));\n+\t   instructions it needs.  */\n+\trtx addr = XEXP (x, 0);\n+\tint n = mips_address_insns (addr, GET_MODE (x));\n \tif (n > 0)\n \t  {\n \t    *total = COSTS_N_INSNS (n + 1);\n \t    return true;\n \t  }\n+\t/* Check for scaled indexed address.  */\n+\tif (mips_lwxs_address_p (addr))\n+\t  {\n+\t    *total = COSTS_N_INSNS (2);\n+\t    return true;\n+\t  }\n+\t/* Otherwise use the default handling.  */\n \treturn false;\n       }\n "}, {"sha": "2425d13ab1ee6208c0c563bec4162f6c3470459c", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -366,6 +366,9 @@ extern const struct mips_rtx_cost_data *mips_cost;\n \t\t\t\t\t\t\t\t\\\n       if (TARGET_MIPS3D)\t\t\t\t\t\\\n \tbuiltin_define (\"__mips3d\");\t\t\t\t\\\n+                                                                \\\n+      if (TARGET_SMARTMIPS)\t\t\t\t\t\\\n+\tbuiltin_define (\"__mips_smartmips\");\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n       if (TARGET_DSP)\t\t\t\t\t\t\\\n \tbuiltin_define (\"__mips_dsp\");\t\t\t\t\\\n@@ -733,7 +736,8 @@ extern const struct mips_rtx_cost_data *mips_cost;\n #define ISA_HAS_ROR\t\t((ISA_MIPS32R2\t\t\t\t\\\n \t\t\t\t  || TARGET_MIPS5400\t\t\t\\\n \t\t\t\t  || TARGET_MIPS5500\t\t\t\\\n-\t\t\t\t  || TARGET_SR71K)\t\t\t\\\n+\t\t\t\t  || TARGET_SR71K\t\t\t\\\n+\t\t\t\t  || TARGET_SMARTMIPS)\t\t\t\\\n \t\t\t\t && !TARGET_MIPS16)\n \n /* ISA has data prefetch instructions.  This controls use of 'pref'.  */\n@@ -768,6 +772,9 @@ extern const struct mips_rtx_cost_data *mips_cost;\n /* ISA has instructions for accessing top part of 64-bit fp regs.  */\n #define ISA_HAS_MXHC1\t\t(TARGET_FLOAT64 && ISA_MIPS32R2)\n \n+/* ISA has lwxs instruction (load w/scaled index address.  */\n+#define ISA_HAS_LWXS\t\t(TARGET_SMARTMIPS && !TARGET_MIPS16)\n+\n /* True if the result of a load is not available to the next instruction.\n    A nop will then be needed between instructions like \"lw $4,...\"\n    and \"addiu $4,$4,1\".  */\n@@ -883,6 +890,7 @@ extern const struct mips_rtx_cost_data *mips_cost;\n %{mdmx} %{mno-mdmx:-no-mdmx} \\\n %{mdsp} %{mno-dsp} \\\n %{mdspr2} %{mno-dspr2} \\\n+%{msmartmips} %{mno-smartmips} \\\n %{mmt} %{mno-mt} \\\n %{mfix-vr4120} %{mfix-vr4130} \\\n %(subtarget_asm_optimizing_spec) \\"}, {"sha": "2b7a2d2368f86f45e250a2f8323271c0d270e630", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -3654,6 +3654,21 @@\n   [(set_attr \"type\" \"fpidxstore\")\n    (set_attr \"mode\" \"<ANYF:UNITMODE>\")])\n \n+;; Scaled indexed address load.\n+;; Per md.texi, we only need to look for a pattern with multiply in the\n+;; address expression, not shift.\n+\n+(define_insn \"*lwxs\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(mem:SI (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t\t  (const_int 4))\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"ISA_HAS_LWXS\"\n+  \"lwxs\\t%0,%1(%2)\"\n+  [(set_attr \"type\"\t\"load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"   \"4\")])\n+\n ;; 16-bit Integer moves\n \n ;; Unlike most other insns, the move insns can't be split with"}, {"sha": "f7e751fb71322d1ec04a8fb56bb7c5e84a7920aa", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -209,6 +209,10 @@ msingle-float\n Target Report RejectNegative Mask(SINGLE_FLOAT)\n Restrict the use of hardware floating-point instructions to 32-bit operations\n \n+msmartmips\n+Target Report RejectNegative Mask(SMARTMIPS)\n+Use SmartMIPS instructions\n+\n msoft-float\n Target Report RejectNegative Mask(SOFT_FLOAT)\n Prevent the use of all hardware floating-point instructions"}, {"sha": "f7523c28b3abb555da51071ea21f126e40f92ef2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -622,6 +622,7 @@ Objective-C and Objective-C++ Dialects}.\n -mshared  -mno-shared  -mxgot  -mno-xgot  -mgp32  -mgp64 @gol\n -mfp32  -mfp64  -mhard-float  -msoft-float @gol\n -msingle-float  -mdouble-float  -mdsp  -mno-dsp  -mdspr2  -mno-dspr2 @gol\n+-msmartmips  -mno-smartmips @gol\n -mpaired-single  -mno-paired-single  -mdmx  -mno-mdmx @gol\n -mips3d  -mno-mips3d  -mmt  -mno-mt @gol\n -mlong64  -mlong32  -msym32  -mno-sym32 @gol\n@@ -11662,6 +11663,12 @@ Use (do not use) the MIPS DSP ASE.  @xref{MIPS DSP Built-in Functions}.\n Use (do not use) the MIPS DSP ASE REV 2.  @xref{MIPS DSP Built-in Functions}.\n The option @option{-mdspr2} implies @option{-mdsp}.\n \n+@item -msmartmips\n+@itemx -mno-smartmips\n+@opindex msmartmips\n+@opindex mno-smartmips\n+Use (do not use) the MIPS SmartMIPS ASE.\n+\n @item -mpaired-single\n @itemx -mno-paired-single\n @opindex mpaired-single"}, {"sha": "c07cc06abd6def7e146015ec9b968a8a6c34a1ed", "filename": "gcc/optabs.c", "status": "modified", "additions": 136, "deletions": 110, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -1246,6 +1246,113 @@ swap_commutative_operands_with_target (rtx target, rtx op0, rtx op1)\n }\n \n \n+/* Helper function for expand_binop: handle the case where there\n+   is an insn that directly implements the indicated operation.\n+   Returns null if this is not possible.  */\n+static rtx\n+expand_binop_directly (enum machine_mode mode, optab binoptab,\n+\t\t       rtx op0, rtx op1,\n+\t\t       rtx target, int unsignedp, enum optab_methods methods,\n+\t\t       int commutative_op, rtx last)\n+{\n+  int icode = (int) binoptab->handlers[(int) mode].insn_code;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+  enum machine_mode tmp_mode;\n+  rtx pat;\n+  rtx xop0 = op0, xop1 = op1;\n+  rtx temp;\n+  \n+  if (target)\n+    temp = target;\n+  else\n+    temp = gen_reg_rtx (mode);\n+  \n+  /* If it is a commutative operator and the modes would match\n+     if we would swap the operands, we can save the conversions.  */\n+  if (commutative_op)\n+    {\n+      if (GET_MODE (op0) != mode0 && GET_MODE (op1) != mode1\n+\t  && GET_MODE (op0) == mode1 && GET_MODE (op1) == mode0)\n+\t{\n+\t  rtx tmp;\n+\t  \n+\t  tmp = op0; op0 = op1; op1 = tmp;\n+\t  tmp = xop0; xop0 = xop1; xop1 = tmp;\n+\t}\n+    }\n+  \n+  /* In case the insn wants input operands in modes different from\n+     those of the actual operands, convert the operands.  It would\n+     seem that we don't need to convert CONST_INTs, but we do, so\n+     that they're properly zero-extended, sign-extended or truncated\n+     for their mode.  */\n+  \n+  if (GET_MODE (op0) != mode0 && mode0 != VOIDmode)\n+    xop0 = convert_modes (mode0,\n+\t\t\t  GET_MODE (op0) != VOIDmode\n+\t\t\t  ? GET_MODE (op0)\n+\t\t\t  : mode,\n+\t\t\t  xop0, unsignedp);\n+  \n+  if (GET_MODE (op1) != mode1 && mode1 != VOIDmode)\n+    xop1 = convert_modes (mode1,\n+\t\t\t  GET_MODE (op1) != VOIDmode\n+\t\t\t  ? GET_MODE (op1)\n+\t\t\t  : mode,\n+\t\t\t  xop1, unsignedp);\n+  \n+  /* Now, if insn's predicates don't allow our operands, put them into\n+     pseudo regs.  */\n+  \n+  if (!insn_data[icode].operand[1].predicate (xop0, mode0)\n+      && mode0 != VOIDmode)\n+    xop0 = copy_to_mode_reg (mode0, xop0);\n+  \n+  if (!insn_data[icode].operand[2].predicate (xop1, mode1)\n+      && mode1 != VOIDmode)\n+    xop1 = copy_to_mode_reg (mode1, xop1);\n+  \n+  if (binoptab == vec_pack_trunc_optab \n+      || binoptab == vec_pack_usat_optab\n+      || binoptab == vec_pack_ssat_optab\n+      || binoptab == vec_pack_ufix_trunc_optab\n+      || binoptab == vec_pack_sfix_trunc_optab)\n+    {\n+      /* The mode of the result is different then the mode of the\n+\t arguments.  */\n+      tmp_mode = insn_data[icode].operand[0].mode;\n+      if (GET_MODE_NUNITS (tmp_mode) != 2 * GET_MODE_NUNITS (mode))\n+\treturn 0;\n+    }\n+  else\n+    tmp_mode = mode;\n+\n+  if (!insn_data[icode].operand[0].predicate (temp, tmp_mode))\n+    temp = gen_reg_rtx (tmp_mode);\n+  \n+  pat = GEN_FCN (icode) (temp, xop0, xop1);\n+  if (pat)\n+    {\n+      /* If PAT is composed of more than one insn, try to add an appropriate\n+\t REG_EQUAL note to it.  If we can't because TEMP conflicts with an\n+\t operand, call expand_binop again, this time without a target.  */\n+      if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n+\t  && ! add_equal_note (pat, temp, binoptab->code, xop0, xop1))\n+\t{\n+\t  delete_insns_since (last);\n+\t  return expand_binop (mode, binoptab, op0, op1, NULL_RTX,\n+\t\t\t       unsignedp, methods);\n+\t}\n+      \n+      emit_insn (pat);\n+      return temp;\n+    }\n+\n+  delete_insns_since (last);\n+  return NULL_RTX;\n+}\n+\n /* Generate code to perform an operation specified by BINOPTAB\n    on operands OP0 and OP1, with result having machine-mode MODE.\n \n@@ -1275,7 +1382,6 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t\t  || binoptab->code == ROTATERT);\n   rtx entry_last = get_last_insn ();\n   rtx last;\n-  bool first_pass_p = true;\n \n   class = GET_MODE_CLASS (mode);\n \n@@ -1329,123 +1435,43 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t}\n     }\n \n- retry:\n-\n   /* If we can do it with a three-operand insn, do so.  */\n \n   if (methods != OPTAB_MUST_WIDEN\n       && binoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n     {\n-      int icode = (int) binoptab->handlers[(int) mode].insn_code;\n-      enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n-      enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n-      enum machine_mode tmp_mode;\n-      rtx pat;\n-      rtx xop0 = op0, xop1 = op1;\n-\n-      if (target)\n-\ttemp = target;\n-      else\n-\ttemp = gen_reg_rtx (mode);\n-\n-      /* If it is a commutative operator and the modes would match\n-\t if we would swap the operands, we can save the conversions.  */\n-      if (commutative_op)\n-\t{\n-\t  if (GET_MODE (op0) != mode0 && GET_MODE (op1) != mode1\n-\t      && GET_MODE (op0) == mode1 && GET_MODE (op1) == mode0)\n-\t    {\n-\t      rtx tmp;\n-\n-\t      tmp = op0; op0 = op1; op1 = tmp;\n-\t      tmp = xop0; xop0 = xop1; xop1 = tmp;\n-\t    }\n-\t}\n-\n-      /* In case the insn wants input operands in modes different from\n-\t those of the actual operands, convert the operands.  It would\n-\t seem that we don't need to convert CONST_INTs, but we do, so\n-\t that they're properly zero-extended, sign-extended or truncated\n-\t for their mode.  */\n-\n-      if (GET_MODE (op0) != mode0 && mode0 != VOIDmode)\n-\txop0 = convert_modes (mode0,\n-\t\t\t      GET_MODE (op0) != VOIDmode\n-\t\t\t      ? GET_MODE (op0)\n-\t\t\t      : mode,\n-\t\t\t      xop0, unsignedp);\n-\n-      if (GET_MODE (op1) != mode1 && mode1 != VOIDmode)\n-\txop1 = convert_modes (mode1,\n-\t\t\t      GET_MODE (op1) != VOIDmode\n-\t\t\t      ? GET_MODE (op1)\n-\t\t\t      : mode,\n-\t\t\t      xop1, unsignedp);\n-\n-      /* Now, if insn's predicates don't allow our operands, put them into\n-\t pseudo regs.  */\n-\n-      if (!insn_data[icode].operand[1].predicate (xop0, mode0)\n-\t  && mode0 != VOIDmode)\n-\txop0 = copy_to_mode_reg (mode0, xop0);\n-\n-      if (!insn_data[icode].operand[2].predicate (xop1, mode1)\n-\t  && mode1 != VOIDmode)\n-\txop1 = copy_to_mode_reg (mode1, xop1);\n-\n-      if (binoptab == vec_pack_trunc_optab \n-\t  || binoptab == vec_pack_usat_optab\n-\t  || binoptab == vec_pack_ssat_optab\n-\t  || binoptab == vec_pack_ufix_trunc_optab\n-\t  || binoptab == vec_pack_sfix_trunc_optab)\n-\t{\n-\t  /* The mode of the result is different then the mode of the\n-\t     arguments.  */\n-\t  tmp_mode = insn_data[icode].operand[0].mode;\n-\t  if (GET_MODE_NUNITS (tmp_mode) != 2 * GET_MODE_NUNITS (mode))\n-\t    return 0;\n-\t}\n-      else\n-        tmp_mode = mode;\n-\n-      if (!insn_data[icode].operand[0].predicate (temp, tmp_mode))\n-\ttemp = gen_reg_rtx (tmp_mode);\n-\n-      pat = GEN_FCN (icode) (temp, xop0, xop1);\n-      if (pat)\n-\t{\n-\t  /* If PAT is composed of more than one insn, try to add an appropriate\n-\t     REG_EQUAL note to it.  If we can't because TEMP conflicts with an\n-\t     operand, call ourselves again, this time without a target.  */\n-\t  if (INSN_P (pat) && NEXT_INSN (pat) != NULL_RTX\n-\t      && ! add_equal_note (pat, temp, binoptab->code, xop0, xop1))\n-\t    {\n-\t      delete_insns_since (last);\n-\t      return expand_binop (mode, binoptab, op0, op1, NULL_RTX,\n-\t\t\t\t   unsignedp, methods);\n-\t    }\n-\n-\t  emit_insn (pat);\n-\t  return temp;\n-\t}\n-      else\n-\tdelete_insns_since (last);\n+      temp = expand_binop_directly (mode, binoptab, op0, op1, target,\n+\t\t\t\t    unsignedp, methods, commutative_op, last);\n+      if (temp)\n+\treturn temp;\n     }\n \n-  /* If we were trying to rotate by a constant value, and that didn't\n-     work, try rotating the other direction before falling back to\n-     shifts and bitwise-or.  */\n-  if (first_pass_p\n-      && (binoptab == rotl_optab || binoptab == rotr_optab)\n-      && class == MODE_INT\n-      && GET_CODE (op1) == CONST_INT\n-      && INTVAL (op1) > 0\n-      && (unsigned int) INTVAL (op1) < GET_MODE_BITSIZE (mode))\n+  /* If we were trying to rotate, and that didn't work, try rotating\n+     the other direction before falling back to shifts and bitwise-or.  */\n+  if (((binoptab == rotl_optab\n+\t&& rotr_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+       || (binoptab == rotr_optab\n+\t   && rotl_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing))\n+      && class == MODE_INT)\n     {\n-      first_pass_p = false;\n-      op1 = GEN_INT (GET_MODE_BITSIZE (mode) - INTVAL (op1));\n-      binoptab = binoptab == rotl_optab ? rotr_optab : rotl_optab;\n-      goto retry;\n+      optab otheroptab = (binoptab == rotl_optab ? rotr_optab : rotl_optab);\n+      rtx newop1;\n+      int bits = GET_MODE_BITSIZE (mode);\n+\n+      if (GET_CODE (op1) == CONST_INT)\n+\tnewop1 = GEN_INT (bits - INTVAL (op1));\n+      else if (targetm.shift_truncation_mask (mode) == bits - 1)\n+\tnewop1 = negate_rtx (mode, op1);\n+      else\n+\tnewop1 = expand_binop (mode, sub_optab,\n+\t\t\t       GEN_INT (bits), op1,\n+\t\t\t       NULL_RTX, unsignedp, OPTAB_DIRECT);\n+\t\t\t\t   \n+      temp = expand_binop_directly (mode, otheroptab, op0, newop1,\n+\t\t\t\t    target, unsignedp, methods,\n+\t\t\t\t    commutative_op, last);\n+      if (temp)\n+\treturn temp;\n     }\n \n   /* If this is a multiply, see if we can do a widening operation that"}, {"sha": "cd9b0b3950f36dcffe9224ec2133700f5a929b71", "filename": "gcc/testsuite/gcc.target/mips/smartmips-lwxs.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-lwxs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-lwxs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-lwxs.c?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-O -msmartmips -mno-mips16\" } */\n+\n+int scaled_indexed_word_load (int a[], int b)\n+{\n+  return a[b];\n+}\n+/* { dg-final { scan-assembler \"\\tlwxs\\t\" } } */"}, {"sha": "5ad7f3424c89d80dea9af7ba40e193b0cf544b7a", "filename": "gcc/testsuite/gcc.target/mips/smartmips-ror-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-1.c?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-O -msmartmips -mno-mips16\" } */\n+\n+int rotate_left (unsigned a, unsigned s)\n+{\n+  return (a << s) | (a >> (32 - s));\n+}\n+/* { dg-final { scan-assembler \"\\tror\\t\" } } */"}, {"sha": "93d376d537d77ac2e5eb9f92763fc8d9149787ee", "filename": "gcc/testsuite/gcc.target/mips/smartmips-ror-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-2.c?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-O -msmartmips -mno-mips16\" } */\n+\n+int rotate_right (unsigned a, unsigned s)\n+{\n+  return (a >> s) | (a << (32 - s));\n+}\n+/* { dg-final { scan-assembler \"\\tror\\t\" } } */"}, {"sha": "ec1c6e27e59db83b341a37ecea96830449a1580c", "filename": "gcc/testsuite/gcc.target/mips/smartmips-ror-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-3.c?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-O -msmartmips -mno-mips16\" } */\n+\n+#define S 13\n+\n+int rotate_left_constant (unsigned a)\n+{\n+  return (a << S) | (a >> (32 - S));\n+}\n+/* { dg-final { scan-assembler \"\\tror\\t\" } } */"}, {"sha": "2a56210539f0ed5460e1f23271a350bdc7f23928", "filename": "gcc/testsuite/gcc.target/mips/smartmips-ror-4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa222d17b32f6d6388e1e92a1d7bde124277f3d/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsmartmips-ror-4.c?ref=0aa222d17b32f6d6388e1e92a1d7bde124277f3d", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-O -msmartmips -mno-mips16\" } */\n+\n+#define S 13\n+\n+int rotate_right_constant (unsigned a)\n+{\n+  return (a >> S) | (a << (32 - S));\n+}\n+/* { dg-final { scan-assembler \"\\tror\\t\" } } */"}]}