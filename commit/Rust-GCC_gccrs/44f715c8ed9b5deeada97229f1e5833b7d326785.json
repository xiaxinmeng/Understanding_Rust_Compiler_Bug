{"sha": "44f715c8ed9b5deeada97229f1e5833b7d326785", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRmNzE1YzhlZDliNWRlZWFkYTk3MjI5ZjFlNTgzM2I3ZDMyNjc4NQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2001-01-23T13:58:55Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2001-01-23T13:58:55Z"}, "message": "libgcc2.c (get_reg_addr): Don't abort if we haven't got a copy of a saved register; return NULL instead.\n\n2001-01-17  Andrew Haley  <aph@redhat.com>\n\n        * libgcc2.c (get_reg_addr): Don't abort if we haven't got a copy\n        of a saved register; return NULL instead.\n        (copy_reg): Take a pointer to a source register rather than a\n        frame_state.\n        (next_stack_level): Remember the address in the stack frame of all\n        saved registers.\n        Use the saved register pointer array as the source of the CFA.\n        (throw_helper): Rewrite.  Unwind once rather than twice and keep\n        track of saved registers as we go.\n\nFrom-SVN: r39199", "tree": {"sha": "7646e967fec8a2d8b017999ee3dd6c77f75e2fa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7646e967fec8a2d8b017999ee3dd6c77f75e2fa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44f715c8ed9b5deeada97229f1e5833b7d326785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44f715c8ed9b5deeada97229f1e5833b7d326785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44f715c8ed9b5deeada97229f1e5833b7d326785", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44f715c8ed9b5deeada97229f1e5833b7d326785/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "92ecdfb74c6b4c1e1812afcc9a7aa79217da11ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92ecdfb74c6b4c1e1812afcc9a7aa79217da11ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92ecdfb74c6b4c1e1812afcc9a7aa79217da11ad"}], "stats": {"total": 142, "additions": 73, "deletions": 69}, "files": [{"sha": "12ba67dd9639f50599d263d2971a6adbeadd448f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44f715c8ed9b5deeada97229f1e5833b7d326785/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44f715c8ed9b5deeada97229f1e5833b7d326785/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44f715c8ed9b5deeada97229f1e5833b7d326785", "patch": "@@ -1,3 +1,15 @@\n+2001-01-17  Andrew Haley  <aph@redhat.com>\n+\n+\t* libgcc2.c (get_reg_addr): Don't abort if we haven't got a copy\n+\tof a saved register; return NULL instead.\n+\t(copy_reg): Take a pointer to a source register rather than a\n+\tframe_state.\n+\t(next_stack_level): Remember the address in the stack frame of all\n+\tsaved registers.\n+\tUse the saved register pointer array as the source of the CFA.\n+\t(throw_helper): Rewrite.  Unwind once rather than twice and keep\n+\ttrack of saved registers as we go.\n+ \n 2001-01-23  Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \n \t* c4x-protos.h (c4x_legitimize_reload_address): Remove."}, {"sha": "cf6822bb565aec2bea5aa5c838350857ae013fa4", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 61, "deletions": 69, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44f715c8ed9b5deeada97229f1e5833b7d326785/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44f715c8ed9b5deeada97229f1e5833b7d326785/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=44f715c8ed9b5deeada97229f1e5833b7d326785", "patch": "@@ -3750,6 +3750,11 @@ find_exception_handler (void *pc, exception_descriptor *table,\n \n typedef int ptr_type __attribute__ ((mode (pointer)));\n \n+typedef struct\n+{\n+  word_type *reg[DWARF_FRAME_REGISTERS];\n+} saved_regs_t;\n+\n #ifdef INCOMING_REGNO\n /* Is the saved value for register REG in frame UDATA stored in a register\n    window in the previous frame?  */\n@@ -3802,7 +3807,8 @@ get_reg_addr (unsigned reg, frame_state *udata, frame_state *sub_udata)\n   if (udata->saved[reg] == REG_SAVED_OFFSET)\n     return (word_type *)(udata->cfa + udata->reg_or_offset[reg]);\n   else\n-    abort ();\n+    /* We don't have a saved copy of this register.  */\n+    return NULL;\n }\n \n /* Get the value of register REG as saved in UDATA, where SUB_UDATA is a\n@@ -3822,16 +3828,14 @@ put_reg (unsigned reg, void *val, frame_state *udata)\n   *get_reg_addr (reg, udata, NULL) = (word_type)(ptr_type) val;\n }\n \n-/* Copy the saved value for register REG from frame UDATA to frame\n+/* Copy the saved value for register REG from PTREG to frame\n    TARGET_UDATA.  Unlike the previous two functions, this can handle\n    registers that are not one word large.  */\n \n static void\n-copy_reg (unsigned reg, frame_state *udata, frame_state *target_udata)\n+copy_reg (unsigned reg, word_type *preg, frame_state *target_udata)\n {\n-  word_type *preg = get_reg_addr (reg, udata, NULL);\n   word_type *ptreg = get_reg_addr (reg, target_udata, NULL);\n-\n   memcpy (ptreg, preg, dwarf_reg_size_table [reg]);\n }\n \n@@ -3854,22 +3858,36 @@ put_return_addr (void *val, frame_state *udata)\n }\n \n /* Given the current frame UDATA and its return address PC, return the\n-   information about the calling frame in CALLER_UDATA.  */\n+   information about the calling frame in CALLER_UDATA and update the\n+   register array in SAVED_REGS.  */\n \n static void *\n-next_stack_level (void *pc, frame_state *udata, frame_state *caller_udata)\n+next_stack_level (void *pc, frame_state *udata, frame_state *caller_udata,\n+\t\t  saved_regs_t *saved_regs)\n {\n+  int i;\n+  word_type *p;\n+\n+  /* Collect all of the registers for the current frame.  */\n+  for (i = 0; i < DWARF_FRAME_REGISTERS; i++)\n+    if (udata->saved[i])\n+      saved_regs->reg[i] = get_reg_addr (i, udata, caller_udata);\n+\n   caller_udata = __frame_state_for (pc, caller_udata);\n   if (! caller_udata)\n     return 0;\n \n-  /* Now go back to our caller's stack frame.  If our caller's CFA register\n-     was saved in our stack frame, restore it; otherwise, assume the CFA\n-     register is SP and restore it to our CFA value.  */\n-  if (udata->saved[caller_udata->cfa_reg])\n-    caller_udata->cfa = get_reg (caller_udata->cfa_reg, udata, 0);\n+  /* Now go back to our caller's stack frame.  If our caller's CFA was\n+     saved in a register in this stack frame or a previous one,\n+     restore it; otherwise, assume CFA register was saved in SP and\n+     restore it to our CFA value.  */\n+\n+  p = saved_regs->reg[caller_udata->cfa_reg];\n+  if (p)\n+    caller_udata->cfa = (void *)(ptr_type)*p;\n   else\n     caller_udata->cfa = udata->cfa;\n+ \n   if (caller_udata->indirect)\n     caller_udata->cfa = * (void **) ((unsigned char *)caller_udata->cfa \n \t\t\t\t     + caller_udata->base_offset);\n@@ -3908,14 +3926,20 @@ throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n   void *handler;\n   void *handler_p = 0;\n   void *pc_p = 0;\n+  void *callee_cfa = 0;\n   frame_state saved_ustruct;\n   int new_eh_model;\n   int cleanup = 0;\n   int only_cleanup = 0;\n   int rethrow = 0;\n   int saved_state = 0;\n   long args_size;\n+  saved_regs_t saved_regs, cleanup_regs;\n   __eh_info *eh_info = (__eh_info *)eh->info;\n+  int i;\n+\n+  memset (saved_regs.reg, 0, sizeof saved_regs.reg);\n+  memset (sub_udata->saved, REG_UNSAVED, sizeof sub_udata->saved);\n \n   /* Do we find a handler based on a re-throw PC? */\n   if (eh->table_index != (void *) 0)\n@@ -3927,7 +3951,8 @@ throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n   for (;;)\n     { \n       frame_state *p = udata;\n-      udata = next_stack_level (pc, udata, sub_udata);\n+\n+      udata = next_stack_level (pc, udata, sub_udata, &saved_regs);\n       sub_udata = p;\n \n       /* If we couldn't find the next frame, we lose.  */\n@@ -3938,13 +3963,13 @@ throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n         new_eh_model = 0;\n       else\n         new_eh_model = (((exception_descriptor *)(udata->eh_ptr))->\n-                                          runtime_id_field == NEW_EH_RUNTIME);\n+\t\t\truntime_id_field == NEW_EH_RUNTIME);\n \n       if (rethrow) \n         {\n           rethrow = 0;\n           handler = find_exception_handler (eh->table_index, udata->eh_ptr, \n-                                          eh_info, 1, &cleanup);\n+\t\t\t\t\t    eh_info, 1, &cleanup);\n           eh->table_index = (void *)0;\n         }\n       else\n@@ -3959,20 +3984,28 @@ throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n          us to call a debug hook if there are nothing but cleanups left. */\n       if (handler)\n \t{\n+\t  /* sub_udata now refers to the frame called by the handler frame.  */\n+\n \t  if (cleanup)\n \t    {\n \t      if (!saved_state)\n \t\t{\n \t\t  saved_ustruct = *udata;\n+\t\t  cleanup_regs = saved_regs;\n \t\t  handler_p = handler;\n \t\t  pc_p = pc;\n \t\t  saved_state = 1;\n \t\t  only_cleanup = 1;\n+\t\t  /* Save the CFA of the frame called by the handler\n+                     frame.  */\n+\t\t  callee_cfa = sub_udata->cfa;\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      only_cleanup = 0;\n+\t      if (!saved_state)\n+\t\tcallee_cfa = sub_udata->cfa;\n \t      break;\n \t    }\n \t}\n@@ -3985,6 +4018,7 @@ throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n   if (saved_state) \n     {\n       udata = &saved_ustruct;\n+      saved_regs = cleanup_regs;\n       handler = handler_p;\n       pc = pc_p;\n       if (only_cleanup)\n@@ -4000,69 +4034,27 @@ throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n \n   args_size = udata->args_size;\n \n-  if (pc == saved_pc)\n-    /* We found a handler in the throw context, no need to unwind.  */\n-    udata = my_udata;\n-  else\n-    {\n-      int i;\n-\n-      /* Unwind all the frames between this one and the handler by copying\n-\t their saved register values into our register save slots.  */\n-\n-      /* Remember the PC where we found the handler.  */\n-      void *handler_pc = pc;\n-\n-      /* Start from the throw context again.  */\n-      pc = saved_pc;\n-      memcpy (udata, my_udata, sizeof (*udata));\n-\n-      while (pc != handler_pc)\n-\t{\n-\t  frame_state *p = udata;\n-\t  udata = next_stack_level (pc, udata, sub_udata);\n-\t  sub_udata = p;\n-\n-\t  for (i = 0; i < DWARF_FRAME_REGISTERS; ++i)\n-\t    if (i != udata->retaddr_column && udata->saved[i])\n-\t      {\n-\t\t/* If you modify the saved value of the return address\n-\t\t   register on the SPARC, you modify the return address for\n-\t\t   your caller's frame.  Don't do that here, as it will\n-\t\t   confuse get_return_addr.  */\n-\t\tif (in_reg_window (i, udata)\n-\t\t    && udata->saved[udata->retaddr_column] == REG_SAVED_REG\n-\t\t    && udata->reg_or_offset[udata->retaddr_column] == i)\n-\t\t  continue;\n-\t\tcopy_reg (i, udata, my_udata);\n-\t      }\n-\n-\t  pc = get_return_addr (udata, sub_udata) - 1;\n-\t}\n-\n-      /* But we do need to update the saved return address register from\n-\t the last frame we unwind, or the handler frame will have the wrong\n-\t return address.  */\n-      if (udata->saved[udata->retaddr_column] == REG_SAVED_REG)\n-\t{\n-\t  i = udata->reg_or_offset[udata->retaddr_column];\n-\t  if (in_reg_window (i, udata))\n-\t    copy_reg (i, udata, my_udata);\n-\t}\n-    }\n-  /* udata now refers to the frame called by the handler frame.  */\n-\n   /* We adjust SP by the difference between __throw's CFA and the CFA for\n      the frame called by the handler frame, because those CFAs correspond\n      to the SP values at the two call sites.  We need to further adjust by\n      the args_size of the handler frame itself to get the handler frame's\n      SP from before the args were pushed for that call.  */\n #ifdef STACK_GROWS_DOWNWARD\n-  *offset_p = udata->cfa - my_udata->cfa + args_size;\n+  *offset_p = callee_cfa - my_udata->cfa + args_size;\n #else\n-  *offset_p = my_udata->cfa - udata->cfa - args_size;\n+  *offset_p = my_udata->cfa - callee_cfa - args_size;\n #endif\n \t\t       \n+  /* If we found a handler in the throw context there's no need to\n+     unwind.  */\n+  if (pc != saved_pc)\n+    {\n+      /* Copy saved register values into our register save slots.  */\n+      for (i = 0; i < DWARF_FRAME_REGISTERS; i++)\n+\tif (i != udata->retaddr_column && saved_regs.reg[i])\n+\t  copy_reg (i, saved_regs.reg[i], my_udata);\n+    }\n+\n   return handler;\n }\n "}]}