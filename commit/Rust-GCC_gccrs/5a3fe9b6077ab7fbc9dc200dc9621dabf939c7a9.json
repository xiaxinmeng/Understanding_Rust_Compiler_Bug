{"sha": "5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEzZmU5YjYwNzdhYjdmYmM5ZGMyMDBkYzk2MjFkYWJmOTM5YzdhOQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2013-06-27T07:44:11Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2013-06-27T07:44:11Z"}, "message": "s390.c: Rename UNSPEC_CCU_TO_INT to UNSPEC_STRCMPCC_TO_INT and UNSPEC_CCZ_TO_INT to...\n\n2013-06-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* config/s390/s390.c: Rename UNSPEC_CCU_TO_INT to\n\tUNSPEC_STRCMPCC_TO_INT and UNSPEC_CCZ_TO_INT to UNSPEC_CC_TO_INT.\n\t(struct machine_function): Add tbegin_p.\n\t(s390_canonicalize_comparison): Fold CC mode compares to\n\tconditional jump if possible.\n\t(s390_emit_jump): Return the emitted jump.\n\t(s390_branch_condition_mask, s390_branch_condition_mnemonic):\n\tHandle CCRAWmode compares.\n\t(s390_option_override): Default to -mhtm if available.\n\t(s390_reg_clobbered_rtx): Handle floating point regs as well.\n\t(s390_regs_ever_clobbered): Use s390_regs_ever_clobbered also for\n\tFPRs instead of df_regs_ever_live_p.\n\t(s390_optimize_nonescaping_tx): New function.\n\t(s390_init_frame_layout): Extend clobbered_regs array to cover\n\tFPRs as well.\n\t(s390_emit_prologue): Call s390_optimize_nonescaping_tx.\n\t(s390_expand_tbegin): New function.\n\t(enum s390_builtin): New enum definition.\n\t(code_for_builtin): New array definition.\n\t(s390_init_builtins): New function.\n\t(s390_expand_builtin): New function.\n\t(TARGET_INIT_BUILTINS): Define.\n\t(TARGET_EXPAND_BUILTIN): Define.\n\t* common/config/s390/s390-common.c (processor_flags_table): Add\n\tPF_TX.\n\t* config/s390/predicates.md (s390_comparison): Handle CCRAWmode.\n\t(s390_alc_comparison): Likewise.\n\t* config/s390/s390-modes.def: Add CCRAWmode.\n\t* config/s390/s390.h (processor_flags): Add PF_TX.\n\t(TARGET_CPU_HTM): Define macro.\n\t(TARGET_HTM): Define macro.\n\t(TARGET_CPU_CPP_BUILTINS): Define __HTM__ for htm.\n\t* config/s390/s390.md: Rename UNSPEC_CCU_TO_INT to\n\tUNSPEC_STRCMPCC_TO_INT and UNSPEC_CCZ_TO_INT to UNSPEC_CC_TO_INT.\n\t(UNSPECV_TBEGIN, UNSPECV_TBEGINC, UNSPECV_TEND, UNSPECV_TABORT)\n\t(UNSPECV_ETND, UNSPECV_NTSTG, UNSPECV_PPA): New unspecv enum\n\tvalues.\n\t(TBEGIN_MASK, TBEGINC_MASK): New constants.\n\t(\"*cc_to_int\"): Move up.\n\t(\"*mov<mode>cc\", \"*cjump_64\", \"*cjump_31\"): Accept integer\n\tconstants other than 0.\n\t(\"*ccraw_to_int\"): New insn and splitter definition.\n\t(\"tbegin\", \"tbegin_nofloat\", \"tbegin_retry\")\n\t(\"tbegin_retry_nofloat\", \"tbeginc\", \"tend\", \"tabort\")\n\t(\"tx_assist\"): New expander.\n\t(\"tbegin_1\", \"tbegin_nofloat_1\", \"*tbeginc_1\", \"*tend_1\")\n\t(\"*tabort_1\", \"etnd\", \"ntstg\", \"*ppa\"): New insn definition.\n\t* config/s390/s390.opt: Add -mhtm option.\n\t* config/s390/s390-protos.h (s390_emit_jump): Add return type.\n\t* config/s390/htmxlintrin.h: New file.\n\t* config/s390/htmintrin.h: New file.\n\t* config/s390/s390intrin.h: New file.\n\t* doc/extend.texi: Document htm builtins.\n\t* config.gcc: Add the new header files to extra_headers.\n\n2013-06-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* gcc.target/s390/htm-1.c: New file.\n\t* gcc.target/s390/htm-nofloat-1.c: New file.\n\t* gcc.target/s390/htm-xl-intrin-1.c: New file.\n\n2013-06-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* config/s390/target.h: Include htmintrin.h.\n\t(_HTM_ITM_RETRIES): New macro definition.\n\t(htm_available, htm_init, htm_begin, htm_begin_success)\n\t(htm_commit, htm_abort, htm_abort_should_retry): New functions.\n\nFrom-SVN: r200454", "tree": {"sha": "9714280940ee187c9f5b17b68759e4465c6c3296", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9714280940ee187c9f5b17b68759e4465c6c3296"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/comments", "author": null, "committer": null, "parents": [{"sha": "b47a3fef9cd5483b5d4f21bd35204dfafc249eef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47a3fef9cd5483b5d4f21bd35204dfafc249eef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b47a3fef9cd5483b5d4f21bd35204dfafc249eef"}], "stats": {"total": 1515, "additions": 1438, "deletions": 77}, "files": [{"sha": "d1d1113bfc59570bb92784901f103899939dc822", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -1,3 +1,60 @@\n+2013-06-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* config/s390/s390.c: Rename UNSPEC_CCU_TO_INT to\n+\tUNSPEC_STRCMPCC_TO_INT and UNSPEC_CCZ_TO_INT to UNSPEC_CC_TO_INT.\n+\t(struct machine_function): Add tbegin_p.\n+\t(s390_canonicalize_comparison): Fold CC mode compares to\n+\tconditional jump if possible.\n+\t(s390_emit_jump): Return the emitted jump.\n+\t(s390_branch_condition_mask, s390_branch_condition_mnemonic):\n+\tHandle CCRAWmode compares.\n+\t(s390_option_override): Default to -mhtm if available.\n+\t(s390_reg_clobbered_rtx): Handle floating point regs as well.\n+\t(s390_regs_ever_clobbered): Use s390_regs_ever_clobbered also for\n+\tFPRs instead of df_regs_ever_live_p.\n+\t(s390_optimize_nonescaping_tx): New function.\n+\t(s390_init_frame_layout): Extend clobbered_regs array to cover\n+\tFPRs as well.\n+\t(s390_emit_prologue): Call s390_optimize_nonescaping_tx.\n+\t(s390_expand_tbegin): New function.\n+\t(enum s390_builtin): New enum definition.\n+\t(code_for_builtin): New array definition.\n+\t(s390_init_builtins): New function.\n+\t(s390_expand_builtin): New function.\n+\t(TARGET_INIT_BUILTINS): Define.\n+\t(TARGET_EXPAND_BUILTIN): Define.\n+\t* common/config/s390/s390-common.c (processor_flags_table): Add\n+\tPF_TX.\n+\t* config/s390/predicates.md (s390_comparison): Handle CCRAWmode.\n+\t(s390_alc_comparison): Likewise.\n+\t* config/s390/s390-modes.def: Add CCRAWmode.\n+\t* config/s390/s390.h (processor_flags): Add PF_TX.\n+\t(TARGET_CPU_HTM): Define macro.\n+\t(TARGET_HTM): Define macro.\n+\t(TARGET_CPU_CPP_BUILTINS): Define __HTM__ for htm.\n+\t* config/s390/s390.md: Rename UNSPEC_CCU_TO_INT to\n+\tUNSPEC_STRCMPCC_TO_INT and UNSPEC_CCZ_TO_INT to UNSPEC_CC_TO_INT.\n+\t(UNSPECV_TBEGIN, UNSPECV_TBEGINC, UNSPECV_TEND, UNSPECV_TABORT)\n+\t(UNSPECV_ETND, UNSPECV_NTSTG, UNSPECV_PPA): New unspecv enum\n+\tvalues.\n+\t(TBEGIN_MASK, TBEGINC_MASK): New constants.\n+\t(\"*cc_to_int\"): Move up.\n+\t(\"*mov<mode>cc\", \"*cjump_64\", \"*cjump_31\"): Accept integer\n+\tconstants other than 0.\n+\t(\"*ccraw_to_int\"): New insn and splitter definition.\n+\t(\"tbegin\", \"tbegin_nofloat\", \"tbegin_retry\")\n+\t(\"tbegin_retry_nofloat\", \"tbeginc\", \"tend\", \"tabort\")\n+\t(\"tx_assist\"): New expander.\n+\t(\"tbegin_1\", \"tbegin_nofloat_1\", \"*tbeginc_1\", \"*tend_1\")\n+\t(\"*tabort_1\", \"etnd\", \"ntstg\", \"*ppa\"): New insn definition.\n+\t* config/s390/s390.opt: Add -mhtm option.\n+\t* config/s390/s390-protos.h (s390_emit_jump): Add return type.\n+\t* config/s390/htmxlintrin.h: New file.\n+\t* config/s390/htmintrin.h: New file.\n+\t* config/s390/s390intrin.h: New file.\n+\t* doc/extend.texi: Document htm builtins.\n+\t* config.gcc: Add the new header files to extra_headers.\n+\n 2013-06-26  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* config/i386/gnu.h [TARGET_LIBC_PROVIDES_SSP]"}, {"sha": "c2031b74b1f6fea5702c8c7726b192d99333b77c", "filename": "gcc/common/config/s390/s390-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fcommon%2Fconfig%2Fs390%2Fs390-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fcommon%2Fconfig%2Fs390%2Fs390-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fs390%2Fs390-common.c?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -42,7 +42,7 @@ EXPORTED_CONST int processor_flags_table[] =\n     /* z196 */   PF_IEEE_FLOAT | PF_ZARCH | PF_LONG_DISPLACEMENT\n                  | PF_EXTIMM | PF_DFP | PF_Z10 | PF_Z196,\n     /* zEC12 */  PF_IEEE_FLOAT | PF_ZARCH | PF_LONG_DISPLACEMENT\n-                 | PF_EXTIMM | PF_DFP | PF_Z10 | PF_Z196 | PF_ZEC12\n+                 | PF_EXTIMM | PF_DFP | PF_Z10 | PF_Z196 | PF_ZEC12 | PF_TX\n   };\n \n /* Change optimizations to be performed, depending on the"}, {"sha": "e3c00b4707e98a8eb6f7ce6ac1faacb6a293e4fc", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -453,6 +453,7 @@ s390*-*-*)\n \tcpu_type=s390\n \tneed_64bit_hwint=yes\n \textra_options=\"${extra_options} fused-madd.opt\"\n+\textra_headers=\"s390intrin.h htmintrin.h htmxlintrin.h\"\n \t;;\n # Note the 'l'; we need to be able to match e.g. \"shle\" or \"shl\".\n sh[123456789lbe]*-*-* | sh-*-*)"}, {"sha": "7aaa9f5bf7c5106b824fe08fc1c3976fcaf83d00", "filename": "gcc/config/s390/htmintrin.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fhtmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fhtmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fhtmintrin.h?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -0,0 +1,57 @@\n+/* GNU compiler hardware transactional execution intrinsics\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Andreas Krebbel (Andreas.Krebbel@de.ibm.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _HTMINTRIN_H\n+#define _HTMINTRIN_H\n+\n+\n+/* Condition codes generated by tbegin  */\n+#define _HTM_TBEGIN_STARTED       0\n+#define _HTM_TBEGIN_INDETERMINATE 1\n+#define _HTM_TBEGIN_TRANSIENT     2\n+#define _HTM_TBEGIN_PERSISTENT    3\n+\n+/* The abort codes below this threshold are reserved for machine\n+   use.  */\n+#define _HTM_FIRST_USER_ABORT_CODE 256\n+\n+/* The transaction diagnostic block is it is defined in the Principles\n+   of Operation chapter 5-91.  */\n+\n+struct __htm_tdb {\n+  unsigned char format;                /*   0 */\n+  unsigned char flags;\n+  unsigned char reserved1[4];\n+  unsigned short nesting_depth;\n+  unsigned long long abort_code;       /*   8 */\n+  unsigned long long conflict_token;   /*  16 */\n+  unsigned long long atia;             /*  24 */\n+  unsigned char eaid;                  /*  32 */\n+  unsigned char dxc;\n+  unsigned char reserved2[2];\n+  unsigned int program_int_id;\n+  unsigned long long exception_id;     /*  40 */\n+  unsigned long long bea;              /*  48 */\n+  unsigned char reserved3[72];         /*  56 */\n+  unsigned long long gprs[16];         /* 128 */\n+} __attribute__((__packed__, __aligned__ (8)));\n+\n+\n+#endif /* _HTMINTRIN_H */"}, {"sha": "bb142195b2bc857e7839fe22a259e315192c6f71", "filename": "gcc/config/s390/htmxlintrin.h", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fhtmxlintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fhtmxlintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fhtmxlintrin.h?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -0,0 +1,182 @@\n+/* XL compiler hardware transactional execution intrinsics\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Andreas Krebbel (Andreas.Krebbel@de.ibm.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _HTMXLINTRIN_H\n+#define _HTMXLINTRIN_H\n+\n+#include <stdint.h>\n+\n+#include <htmintrin.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* These intrinsics are being made available for compatibility with\n+   the IBM XL compiler.  For documentation please see the \"z/OS XL\n+   C/C++ Programming Guide\" publically available on the web.  */\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_simple_begin ()\n+{\n+  return __builtin_tbegin_nofloat (0);\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_begin (void* const tdb)\n+{\n+  return __builtin_tbegin_nofloat (tdb);\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_end ()\n+{\n+  return __builtin_tend ();\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_abort ()\n+{\n+  return __builtin_tabort (_HTM_FIRST_USER_ABORT_CODE);\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_named_abort (unsigned char const code)\n+{\n+  return __builtin_tabort ((int)_HTM_FIRST_USER_ABORT_CODE + code);\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_non_transactional_store (void* const addr, long long const value)\n+{\n+  __builtin_non_tx_store ((uint64_t*)addr, (uint64_t)value);\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_nesting_depth (void* const tdb_ptr)\n+{\n+  int depth = __builtin_tx_nesting_depth ();\n+  struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n+\n+  if (depth != 0)\n+    return depth;\n+\n+  if (tdb->format == 0)\n+    return 0;\n+  return tdb->nesting_depth;\n+}\n+\n+/* Transaction failure diagnostics */\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_user_abort (void* const tdb_ptr)\n+{\n+  struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n+\n+  if (tdb->format == 0)\n+    return 0;\n+\n+  return !!(tdb->abort_code >= _HTM_FIRST_USER_ABORT_CODE);\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_named_user_abort (void* const tdb_ptr, unsigned char* code)\n+{\n+  struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n+\n+  if (tdb->format == 0)\n+    return 0;\n+\n+  if (tdb->abort_code >= _HTM_FIRST_USER_ABORT_CODE)\n+    {\n+      *code = tdb->abort_code - _HTM_FIRST_USER_ABORT_CODE;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_illegal (void* const tdb_ptr)\n+{\n+  struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n+\n+  return (tdb->format == 0\n+\t  && (tdb->abort_code == 4 /* unfiltered program interruption */\n+\t      || tdb->abort_code == 11 /* restricted instruction */));\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_footprint_exceeded (void* const tdb_ptr)\n+{\n+  struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n+\n+  return (tdb->format == 0\n+\t  && (tdb->abort_code == 7 /* fetch overflow */\n+\t      || tdb->abort_code == 8 /* store overflow */));\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_nested_too_deep (void* const tdb_ptr)\n+{\n+  struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n+\n+  return tdb->format == 0 && tdb->abort_code == 13; /* depth exceeded */\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_conflict (void* const tdb_ptr)\n+{\n+  struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n+\n+  return (tdb->format == 0\n+\t  && (tdb->abort_code == 9 /* fetch conflict */\n+\t      || tdb->abort_code == 10 /* store conflict */));\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_is_failure_persistent (long const result)\n+{\n+  return result == _HTM_TBEGIN_PERSISTENT;\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_failure_address (void* const tdb_ptr)\n+{\n+  struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n+#ifdef __s390x__\n+  return tdb->atia;\n+#else\n+  return tdb->atia & 0xffffffff;\n+#endif\n+}\n+\n+extern __inline long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+__TM_failure_code (void* const tdb_ptr)\n+{\n+  struct __htm_tdb *tdb = (struct __htm_tdb*)tdb_ptr;\n+\n+  return tdb->abort_code;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* _HTMXLINTRIN_H */"}, {"sha": "069b42489a7a8cb92286eaa873a74e98227f7195", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -176,7 +176,11 @@\n {\n   if (GET_CODE (XEXP (op, 0)) != REG\n       || REGNO (XEXP (op, 0)) != CC_REGNUM\n-      || XEXP (op, 1) != const0_rtx)\n+      || (XEXP (op, 1) != const0_rtx\n+          && !(CONST_INT_P (XEXP (op, 1))\n+\t       && GET_MODE (XEXP (op, 0)) == CCRAWmode\n+\t       && INTVAL (XEXP (op, 1)) >= 0\n+               && INTVAL (XEXP (op, 1)) <= 15)))\n     return false;\n \n   return (s390_branch_condition_mask (op) >= 0);\n@@ -224,7 +228,11 @@\n \n   if (GET_CODE (XEXP (op, 0)) != REG\n       || REGNO (XEXP (op, 0)) != CC_REGNUM\n-      || XEXP (op, 1) != const0_rtx)\n+      || (XEXP (op, 1) != const0_rtx\n+          && !(CONST_INT_P (XEXP (op, 1))\n+\t       && GET_MODE (XEXP (op, 0)) == CCRAWmode\n+\t       && INTVAL (XEXP (op, 1)) >= 0\n+               && INTVAL (XEXP (op, 1)) <= 15)))\n     return false;\n \n   switch (GET_MODE (XEXP (op, 0)))"}, {"sha": "5e0b50cafa1daa02e7a0cc75603b1d36bab7c7a9", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -152,6 +152,14 @@ The compare and swap instructions sets the condition code to 0/1 if the\n operands were equal/unequal. The CCZ1 mode ensures the result can be\n effectively placed into a register.\n \n+CCRAW\n+\n+The cc mode generated by a non-compare instruction.  The condition\n+code mask for the CC consumer is determined by the comparison operator\n+(only EQ and NE allowed) and the immediate value given as second\n+operand to the operator.  For the other CC modes this value used to be\n+0.\n+\n */\n \n \n@@ -172,3 +180,4 @@ CC_MODE (CCT);\n CC_MODE (CCT1);\n CC_MODE (CCT2);\n CC_MODE (CCT3);\n+CC_MODE (CCRAW);"}, {"sha": "67283df4553e7732371c0c10c1a9ac703ada9bdd", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -58,7 +58,7 @@ extern bool s390_match_ccmode (rtx, enum machine_mode);\n extern enum machine_mode s390_tm_ccmode (rtx, rtx, bool);\n extern enum machine_mode s390_select_ccmode (enum rtx_code, rtx, rtx);\n extern rtx s390_emit_compare (enum rtx_code, rtx, rtx);\n-extern void s390_emit_jump (rtx, rtx);\n+extern rtx s390_emit_jump (rtx, rtx);\n extern bool symbolic_reference_mentioned_p (rtx);\n extern bool tls_symbolic_reference_mentioned_p (rtx);\n extern bool legitimate_la_operand_p (rtx);\n@@ -87,6 +87,7 @@ extern void s390_expand_cs_hqi (enum machine_mode, rtx, rtx, rtx,\n \t\t\t\trtx, rtx, bool);\n extern void s390_expand_atomic (enum machine_mode, enum rtx_code,\n \t\t\t\trtx, rtx, rtx, bool);\n+extern void s390_expand_tbegin (rtx, rtx, rtx, bool);\n extern rtx s390_return_addr_rtx (int, rtx);\n extern rtx s390_back_chain_rtx (void);\n extern rtx s390_emit_call (rtx, rtx, rtx, rtx);"}, {"sha": "2cacf6f52ada06006262d6b20f1a39ca68c9409c", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 529, "deletions": 35, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -367,6 +367,10 @@ struct GTY(()) machine_function\n   const char *some_ld_name;\n \n   bool has_landing_pad_p;\n+\n+  /* True if the current function may contain a tbegin clobbering\n+     FPRs.  */\n+  bool tbegin_p;\n };\n \n /* Few accessor macros for struct cfun->machine->s390_frame_layout.  */\n@@ -824,9 +828,9 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n       *op1 = constm1_rtx;\n     }\n \n-  /* Remove redundant UNSPEC_CCU_TO_INT conversions if possible.  */\n+  /* Remove redundant UNSPEC_STRCMPCC_TO_INT conversions if possible.  */\n   if (GET_CODE (*op0) == UNSPEC\n-      && XINT (*op0, 1) == UNSPEC_CCU_TO_INT\n+      && XINT (*op0, 1) == UNSPEC_STRCMPCC_TO_INT\n       && XVECLEN (*op0, 0) == 1\n       && GET_MODE (XVECEXP (*op0, 0, 0)) == CCUmode\n       && GET_CODE (XVECEXP (*op0, 0, 0)) == REG\n@@ -852,25 +856,35 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t}\n     }\n \n-  /* Remove redundant UNSPEC_CCZ_TO_INT conversions if possible.  */\n+  /* Remove redundant UNSPEC_CC_TO_INT conversions if possible.  */\n   if (GET_CODE (*op0) == UNSPEC\n-      && XINT (*op0, 1) == UNSPEC_CCZ_TO_INT\n+      && XINT (*op0, 1) == UNSPEC_CC_TO_INT\n       && XVECLEN (*op0, 0) == 1\n-      && GET_MODE (XVECEXP (*op0, 0, 0)) == CCZmode\n       && GET_CODE (XVECEXP (*op0, 0, 0)) == REG\n       && REGNO (XVECEXP (*op0, 0, 0)) == CC_REGNUM\n-      && *op1 == const0_rtx)\n+      && CONST_INT_P (*op1))\n     {\n       enum rtx_code new_code = UNKNOWN;\n-      switch (*code)\n+      switch (GET_MODE (XVECEXP (*op0, 0, 0)))\n \t{\n-\t  case EQ: new_code = EQ;  break;\n-\t  case NE: new_code = NE;  break;\n-\t  default: break;\n+\tcase CCZmode:\n+\tcase CCRAWmode:\n+\t  switch (*code)\n+\t    {\n+\t    case EQ: new_code = EQ;  break;\n+\t    case NE: new_code = NE;  break;\n+\t    default: break;\n+\t    }\n+\t  break;\n+\tdefault: break;\n \t}\n \n       if (new_code != UNKNOWN)\n \t{\n+\t  /* For CCRAWmode put the required cc mask into the second\n+\t     operand.  */\n+\t  if (GET_MODE (XVECEXP (*op0, 0, 0)) == CCRAWmode)\n+\t    *op1 = gen_rtx_CONST_INT (VOIDmode, 1 << (3 - INTVAL (*op1)));\n \t  *op0 = XVECEXP (*op0, 0, 0);\n \t  *code = new_code;\n \t}\n@@ -942,10 +956,11 @@ s390_emit_compare_and_swap (enum rtx_code code, rtx old, rtx mem,\n \t\t\t    const0_rtx);\n }\n \n-/* Emit a jump instruction to TARGET.  If COND is NULL_RTX, emit an\n-   unconditional jump, else a conditional jump under condition COND.  */\n+/* Emit a jump instruction to TARGET and return it.  If COND is\n+   NULL_RTX, emit an unconditional jump, else a conditional jump under\n+   condition COND.  */\n \n-void\n+rtx\n s390_emit_jump (rtx target, rtx cond)\n {\n   rtx insn;\n@@ -955,7 +970,7 @@ s390_emit_jump (rtx target, rtx cond)\n     target = gen_rtx_IF_THEN_ELSE (VOIDmode, cond, target, pc_rtx);\n \n   insn = gen_rtx_SET (VOIDmode, pc_rtx, target);\n-  emit_jump_insn (insn);\n+  return emit_jump_insn (insn);\n }\n \n /* Return branch condition mask to implement a branch\n@@ -971,7 +986,10 @@ s390_branch_condition_mask (rtx code)\n \n   gcc_assert (GET_CODE (XEXP (code, 0)) == REG);\n   gcc_assert (REGNO (XEXP (code, 0)) == CC_REGNUM);\n-  gcc_assert (XEXP (code, 1) == const0_rtx);\n+  gcc_assert (XEXP (code, 1) == const0_rtx\n+\t      || (GET_MODE (XEXP (code, 0)) == CCRAWmode\n+\t\t  && CONST_INT_P (XEXP (code, 1))));\n+\n \n   switch (GET_MODE (XEXP (code, 0)))\n     {\n@@ -1145,6 +1163,17 @@ s390_branch_condition_mask (rtx code)\n         }\n       break;\n \n+    case CCRAWmode:\n+      switch (GET_CODE (code))\n+\t{\n+\tcase EQ:\n+\t  return INTVAL (XEXP (code, 1));\n+\tcase NE:\n+\t  return (INTVAL (XEXP (code, 1))) ^ 0xf;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n     default:\n       return -1;\n     }\n@@ -1204,7 +1233,9 @@ s390_branch_condition_mnemonic (rtx code, int inv)\n \n   if (GET_CODE (XEXP (code, 0)) == REG\n       && REGNO (XEXP (code, 0)) == CC_REGNUM\n-      && XEXP (code, 1) == const0_rtx)\n+      && (XEXP (code, 1) == const0_rtx\n+\t  || (GET_MODE (XEXP (code, 0)) == CCRAWmode\n+\t      && CONST_INT_P (XEXP (code, 1)))))\n     mask = s390_branch_condition_mask (code);\n   else\n     mask = s390_compare_and_branch_condition_mask (code);\n@@ -1602,6 +1633,11 @@ s390_option_override (void)\n   if (!(target_flags_explicit & MASK_HARD_DFP) && TARGET_DFP)\n     target_flags |= MASK_HARD_DFP;\n \n+  /* Enable hardware transactions if available and not explicitly\n+     disabled by user.  E.g. with -m31 -march=zEC12 -mzarch */\n+  if (!(target_flags_explicit & MASK_OPT_HTM) && TARGET_CPU_HTM && TARGET_ZARCH)\n+    target_flags |= MASK_OPT_HTM;\n+\n   if (TARGET_HARD_DFP && !TARGET_DFP)\n     {\n       if (target_flags_explicit & MASK_HARD_DFP)\n@@ -7334,11 +7370,11 @@ s390_reg_clobbered_rtx (rtx setreg, const_rtx set_insn ATTRIBUTE_UNUSED, void *d\n   if (GET_CODE (setreg) == SUBREG)\n     {\n       rtx inner = SUBREG_REG (setreg);\n-      if (!GENERAL_REG_P (inner))\n+      if (!GENERAL_REG_P (inner) && !FP_REG_P (inner))\n \treturn;\n       regno = subreg_regno (setreg);\n     }\n-  else if (GENERAL_REG_P (setreg))\n+  else if (GENERAL_REG_P (setreg) || FP_REG_P (setreg))\n     regno = REGNO (setreg);\n   else\n     return;\n@@ -7361,13 +7397,13 @@ s390_regs_ever_clobbered (int *regs_ever_clobbered)\n   rtx cur_insn;\n   unsigned int i;\n \n-  memset (regs_ever_clobbered, 0, 16 * sizeof (int));\n+  memset (regs_ever_clobbered, 0, 32 * sizeof (int));\n \n   /* For non-leaf functions we have to consider all call clobbered regs to be\n      clobbered.  */\n   if (!crtl->is_leaf)\n     {\n-      for (i = 0; i < 16; i++)\n+      for (i = 0; i < 32; i++)\n \tregs_ever_clobbered[i] = call_really_used_regs[i];\n     }\n \n@@ -7389,7 +7425,7 @@ s390_regs_ever_clobbered (int *regs_ever_clobbered)\n      See expand_builtin_unwind_init.  For regs_ever_live this is done by\n      reload.  */\n   if (cfun->has_nonlocal_label)\n-    for (i = 0; i < 16; i++)\n+    for (i = 0; i < 32; i++)\n       if (!call_really_used_regs[i])\n \tregs_ever_clobbered[i] = 1;\n \n@@ -7455,17 +7491,6 @@ s390_register_info (int clobbered_regs[])\n {\n   int i, j;\n \n-  /* fprs 8 - 15 are call saved for 64 Bit ABI.  */\n-  cfun_frame_layout.fpr_bitmap = 0;\n-  cfun_frame_layout.high_fprs = 0;\n-  if (TARGET_64BIT)\n-    for (i = 24; i < 32; i++)\n-      if (df_regs_ever_live_p (i) && !global_regs[i])\n-\t{\n-\t  cfun_set_fpr_bit (i - 16);\n-\t  cfun_frame_layout.high_fprs++;\n-\t}\n-\n   /* Find first and last gpr to be saved.  We trust regs_ever_live\n      data, except that we don't save and restore global registers.\n \n@@ -7474,6 +7499,29 @@ s390_register_info (int clobbered_regs[])\n \n   s390_regs_ever_clobbered (clobbered_regs);\n \n+  /* fprs 8 - 15 are call saved for 64 Bit ABI.  */\n+  if (!epilogue_completed)\n+    {\n+      cfun_frame_layout.fpr_bitmap = 0;\n+      cfun_frame_layout.high_fprs = 0;\n+      if (TARGET_64BIT)\n+\tfor (i = 24; i < 32; i++)\n+\t  /* During reload we have to use the df_regs_ever_live infos\n+\t     since reload is marking FPRs used as spill slots there as\n+\t     live before actually making the code changes.  Without\n+\t     this we fail during elimination offset verification.  */\n+\t  if ((clobbered_regs[i]\n+\t       || (df_regs_ever_live_p (i)\n+\t\t   && (lra_in_progress\n+\t\t       || reload_in_progress\n+\t\t       || crtl->saves_all_registers)))\n+\t      && !global_regs[i])\n+\t    {\n+\t      cfun_set_fpr_bit (i - 16);\n+\t      cfun_frame_layout.high_fprs++;\n+\t    }\n+    }\n+\n   for (i = 0; i < 16; i++)\n     clobbered_regs[i] = clobbered_regs[i] && !global_regs[i] && !fixed_regs[i];\n \n@@ -7724,7 +7772,7 @@ s390_init_frame_layout (void)\n {\n   HOST_WIDE_INT frame_size;\n   int base_used;\n-  int clobbered_regs[16];\n+  int clobbered_regs[32];\n \n   /* On S/390 machines, we may need to perform branch splitting, which\n      will require both base and return address register.  We have no\n@@ -7759,6 +7807,157 @@ s390_init_frame_layout (void)\n   while (frame_size != cfun_frame_layout.frame_size);\n }\n \n+/* Remove the FPR clobbers from a tbegin insn if it can be proven that\n+   the TX is nonescaping.  A transaction is considered escaping if\n+   there is at least one path from tbegin returning CC0 to the\n+   function exit block without an tend.\n+\n+   The check so far has some limitations:\n+   - only single tbegin/tend BBs are supported\n+   - the first cond jump after tbegin must separate the CC0 path from ~CC0\n+   - when CC is copied to a GPR and the CC0 check is done with the GPR\n+     this is not supported\n+*/\n+\n+static void\n+s390_optimize_nonescaping_tx (void)\n+{\n+  const unsigned int CC0 = 1 << 3;\n+  basic_block tbegin_bb = NULL;\n+  basic_block tend_bb = NULL;\n+  basic_block bb;\n+  rtx insn;\n+  bool result = true;\n+  int bb_index;\n+  rtx tbegin_insn = NULL_RTX;\n+\n+  if (!cfun->machine->tbegin_p)\n+    return;\n+\n+  for (bb_index = 0; bb_index < n_basic_blocks; bb_index++)\n+    {\n+      bb = BASIC_BLOCK (bb_index);\n+\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  rtx ite, cc, pat, target;\n+\t  unsigned HOST_WIDE_INT mask;\n+\n+\t  if (!INSN_P (insn) || INSN_CODE (insn) <= 0)\n+\t    continue;\n+\n+\t  pat = PATTERN (insn);\n+\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    pat = XVECEXP (pat, 0, 0);\n+\n+\t  if (GET_CODE (pat) != SET\n+\t      || GET_CODE (SET_SRC (pat)) != UNSPEC_VOLATILE)\n+\t    continue;\n+\n+\t  if (XINT (SET_SRC (pat), 1) == UNSPECV_TBEGIN)\n+\t    {\n+\t      rtx tmp;\n+\n+\t      tbegin_insn = insn;\n+\n+\t      /* Just return if the tbegin doesn't have clobbers.  */\n+\t      if (GET_CODE (PATTERN (insn)) != PARALLEL)\n+\t\treturn;\n+\n+\t      if (tbegin_bb != NULL)\n+\t\treturn;\n+\n+\t      /* Find the next conditional jump.  */\n+\t      for (tmp = NEXT_INSN (insn);\n+\t\t   tmp != NULL_RTX;\n+\t\t   tmp = NEXT_INSN (tmp))\n+\t\t{\n+\t\t  if (reg_set_p (gen_rtx_REG (CCmode, CC_REGNUM), tmp))\n+\t\t    return;\n+\t\t  if (!JUMP_P (tmp))\n+\t\t    continue;\n+\n+\t\t  ite = SET_SRC (PATTERN (tmp));\n+\t\t  if (GET_CODE (ite) != IF_THEN_ELSE)\n+\t\t    continue;\n+\n+\t\t  cc = XEXP (XEXP (ite, 0), 0);\n+\t\t  if (!REG_P (cc) || !CC_REGNO_P (REGNO (cc))\n+\t\t      || GET_MODE (cc) != CCRAWmode\n+\t\t      || GET_CODE (XEXP (XEXP (ite, 0), 1)) != CONST_INT)\n+\t\t    return;\n+\n+\t\t  if (bb->succs->length () != 2)\n+\t\t    return;\n+\n+\t\t  mask = INTVAL (XEXP (XEXP (ite, 0), 1));\n+\t\t  if (GET_CODE (XEXP (ite, 0)) == NE)\n+\t\t    mask ^= 0xf;\n+\n+\t\t  if (mask == CC0)\n+\t\t    target = XEXP (ite, 1);\n+\t\t  else if (mask == (CC0 ^ 0xf))\n+\t\t    target = XEXP (ite, 2);\n+\t\t  else\n+\t\t    return;\n+\n+\t\t  {\n+\t\t    edge_iterator ei;\n+\t\t    edge e1, e2;\n+\n+\t\t    ei = ei_start (bb->succs);\n+\t\t    e1 = ei_safe_edge (ei);\n+\t\t    ei_next (&ei);\n+\t\t    e2 = ei_safe_edge (ei);\n+\n+\t\t    if (e2->flags & EDGE_FALLTHRU)\n+\t\t      {\n+\t\t\te2 = e1;\n+\t\t\te1 = ei_safe_edge (ei);\n+\t\t      }\n+\n+\t\t    if (!(e1->flags & EDGE_FALLTHRU))\n+\t\t      return;\n+\n+\t\t    tbegin_bb = (target == pc_rtx) ? e1->dest : e2->dest;\n+\t\t  }\n+\t\t  if (tmp == BB_END (bb))\n+\t\t    break;\n+\t\t}\n+\t    }\n+\n+\t  if (XINT (SET_SRC (pat), 1) == UNSPECV_TEND)\n+\t    {\n+\t      if (tend_bb != NULL)\n+\t\treturn;\n+\t      tend_bb = bb;\n+\t    }\n+\t}\n+    }\n+\n+  /* Either we successfully remove the FPR clobbers here or we are not\n+     able to do anything for this TX.  Both cases don't qualify for\n+     another look.  */\n+  cfun->machine->tbegin_p = false;\n+\n+  if (tbegin_bb == NULL || tend_bb == NULL)\n+    return;\n+\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  result = dominated_by_p (CDI_POST_DOMINATORS, tbegin_bb, tend_bb);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n+  if (!result)\n+    return;\n+\n+  PATTERN (tbegin_insn) = XVECEXP (PATTERN (tbegin_insn), 0, 0);\n+  INSN_CODE (tbegin_insn) = -1;\n+  df_insn_rescan (tbegin_insn);\n+\n+  return;\n+}\n+\n /* Update frame layout.  Recompute actual register save data based on\n    current info and update regs_ever_live for the special registers.\n    May be called multiple times, but may never cause *more* registers\n@@ -7767,7 +7966,7 @@ s390_init_frame_layout (void)\n static void\n s390_update_frame_layout (void)\n {\n-  int clobbered_regs[16];\n+  int clobbered_regs[32];\n \n   s390_register_info (clobbered_regs);\n \n@@ -8204,8 +8403,10 @@ s390_emit_prologue (void)\n   int offset;\n   int next_fpr = 0;\n \n-  /* Complete frame layout.  */\n+  /* Try to get rid of the FPR clobbers.  */\n+  s390_optimize_nonescaping_tx ();\n \n+  /* Complete frame layout.  */\n   s390_update_frame_layout ();\n \n   /* Annotate all constant pool references to let the scheduler know\n@@ -9353,6 +9554,294 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n   return build_va_arg_indirect_ref (addr);\n }\n \n+/* Emit rtl for the tbegin or tbegin_retry (RETRY != NULL_RTX)\n+   expanders.\n+   DEST  - Register location where CC will be stored.\n+   TDB   - Pointer to a 256 byte area where to store the transaction.\n+           diagnostic block. NULL if TDB is not needed.\n+   RETRY - Retry count value.  If non-NULL a retry loop for CC2\n+           is emitted\n+   CLOBBER_FPRS_P - If true clobbers for all FPRs are emitted as part\n+                    of the tbegin instruction pattern.  */\n+\n+void\n+s390_expand_tbegin (rtx dest, rtx tdb, rtx retry, bool clobber_fprs_p)\n+{\n+  const int CC0 = 1 << 3;\n+  const int CC1 = 1 << 2;\n+  const int CC3 = 1 << 0;\n+  rtx abort_label = gen_label_rtx ();\n+  rtx leave_label = gen_label_rtx ();\n+  rtx retry_reg = gen_reg_rtx (SImode);\n+  rtx retry_label = NULL_RTX;\n+  rtx jump;\n+  rtx very_unlikely = GEN_INT (REG_BR_PROB_BASE / 100 - 1);\n+\n+  if (retry != NULL_RTX)\n+    {\n+      emit_move_insn (retry_reg, retry);\n+      retry_label = gen_label_rtx ();\n+      emit_label (retry_label);\n+    }\n+\n+  if (clobber_fprs_p)\n+    emit_insn (gen_tbegin_1 (tdb,\n+\t\t gen_rtx_CONST_INT (VOIDmode, TBEGIN_MASK)));\n+  else\n+    emit_insn (gen_tbegin_nofloat_1 (tdb,\n+\t\t gen_rtx_CONST_INT (VOIDmode, TBEGIN_MASK)));\n+\n+  jump = s390_emit_jump (abort_label,\n+\t\t\t gen_rtx_NE (VOIDmode,\n+\t\t\t\t     gen_rtx_REG (CCRAWmode, CC_REGNUM),\n+\t\t\t\t     gen_rtx_CONST_INT (VOIDmode, CC0)));\n+\n+  JUMP_LABEL (jump) = abort_label;\n+  LABEL_NUSES (abort_label) = 1;\n+  add_reg_note (jump, REG_BR_PROB, very_unlikely);\n+\n+  /* Initialize CC return value.  */\n+  emit_move_insn (dest, const0_rtx);\n+\n+  s390_emit_jump (leave_label, NULL_RTX);\n+  LABEL_NUSES (leave_label) = 1;\n+  emit_barrier ();\n+\n+  /* Abort handler code.  */\n+\n+  emit_label (abort_label);\n+  if (retry != NULL_RTX)\n+    {\n+      rtx count = gen_reg_rtx (SImode);\n+      jump = s390_emit_jump (leave_label,\n+\t\t\t     gen_rtx_EQ (VOIDmode,\n+\t\t\t       gen_rtx_REG (CCRAWmode, CC_REGNUM),\n+\t\t\t       gen_rtx_CONST_INT (VOIDmode, CC1 | CC3)));\n+      LABEL_NUSES (leave_label) = 2;\n+      add_reg_note (jump, REG_BR_PROB, very_unlikely);\n+\n+      /* CC2 - transient failure. Perform retry with ppa.  */\n+      emit_move_insn (count, retry);\n+      emit_insn (gen_subsi3 (count, count, retry_reg));\n+      emit_insn (gen_tx_assist (count));\n+      jump = emit_jump_insn (gen_doloop_si64 (retry_label,\n+\t\t\t\t\t      retry_reg,\n+\t\t\t\t\t      retry_reg));\n+      JUMP_LABEL (jump) = retry_label;\n+      LABEL_NUSES (retry_label) = 1;\n+    }\n+\n+  emit_move_insn (dest, gen_rtx_UNSPEC (SImode,\n+\t\t\t\t\tgen_rtvec (1, gen_rtx_REG (CCRAWmode,\n+\t\t\t\t\t\t\t\t   CC_REGNUM)),\n+\t\t\t\t\tUNSPEC_CC_TO_INT));\n+  emit_label (leave_label);\n+}\n+\n+/* Builtins.  */\n+\n+enum s390_builtin\n+{\n+  S390_BUILTIN_TBEGIN,\n+  S390_BUILTIN_TBEGIN_NOFLOAT,\n+  S390_BUILTIN_TBEGIN_RETRY,\n+  S390_BUILTIN_TBEGIN_RETRY_NOFLOAT,\n+  S390_BUILTIN_TBEGINC,\n+  S390_BUILTIN_TEND,\n+  S390_BUILTIN_TABORT,\n+  S390_BUILTIN_NON_TX_STORE,\n+  S390_BUILTIN_TX_NESTING_DEPTH,\n+  S390_BUILTIN_TX_ASSIST,\n+\n+  S390_BUILTIN_max\n+};\n+\n+static enum insn_code const code_for_builtin[S390_BUILTIN_max] = {\n+  CODE_FOR_tbegin,\n+  CODE_FOR_tbegin_nofloat,\n+  CODE_FOR_tbegin_retry,\n+  CODE_FOR_tbegin_retry_nofloat,\n+  CODE_FOR_tbeginc,\n+  CODE_FOR_tend,\n+  CODE_FOR_tabort,\n+  CODE_FOR_ntstg,\n+  CODE_FOR_etnd,\n+  CODE_FOR_tx_assist\n+};\n+\n+static void\n+s390_init_builtins (void)\n+{\n+  tree ftype, uint64_type;\n+\n+  /* void foo (void) */\n+  ftype = build_function_type_list (void_type_node, NULL_TREE);\n+  add_builtin_function (\"__builtin_tbeginc\", ftype, S390_BUILTIN_TBEGINC,\n+\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n+\n+  /* void foo (int) */\n+  ftype = build_function_type_list (void_type_node, integer_type_node,\n+\t\t\t\t    NULL_TREE);\n+  add_builtin_function (\"__builtin_tabort\", ftype,\n+\t\t\tS390_BUILTIN_TABORT, BUILT_IN_MD, NULL, NULL_TREE);\n+  add_builtin_function (\"__builtin_tx_assist\", ftype,\n+\t\t\tS390_BUILTIN_TX_ASSIST, BUILT_IN_MD, NULL, NULL_TREE);\n+\n+  /* int foo (void *) */\n+  ftype = build_function_type_list (integer_type_node, ptr_type_node, NULL_TREE);\n+  add_builtin_function (\"__builtin_tbegin\", ftype, S390_BUILTIN_TBEGIN,\n+\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n+  add_builtin_function (\"__builtin_tbegin_nofloat\", ftype,\n+\t\t\tS390_BUILTIN_TBEGIN_NOFLOAT,\n+\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n+\n+  /* int foo (void *, int) */\n+  ftype = build_function_type_list (integer_type_node, ptr_type_node,\n+\t\t\t\t    integer_type_node, NULL_TREE);\n+  add_builtin_function (\"__builtin_tbegin_retry\", ftype,\n+\t\t\tS390_BUILTIN_TBEGIN_RETRY,\n+\t\t\tBUILT_IN_MD,\n+\t\t\tNULL, NULL_TREE);\n+  add_builtin_function (\"__builtin_tbegin_retry_nofloat\", ftype,\n+\t\t\tS390_BUILTIN_TBEGIN_RETRY_NOFLOAT,\n+\t\t\tBUILT_IN_MD,\n+\t\t\tNULL, NULL_TREE);\n+\n+  /* int foo (void) */\n+  ftype = build_function_type_list (integer_type_node, NULL_TREE);\n+  add_builtin_function (\"__builtin_tx_nesting_depth\", ftype,\n+\t\t\tS390_BUILTIN_TX_NESTING_DEPTH,\n+\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n+  add_builtin_function (\"__builtin_tend\", ftype,\n+\t\t\tS390_BUILTIN_TEND, BUILT_IN_MD,\tNULL, NULL_TREE);\n+\n+  /* void foo (uint64_t *, uint64_t) */\n+  if (TARGET_64BIT)\n+    uint64_type = long_unsigned_type_node;\n+  else\n+    uint64_type = long_long_unsigned_type_node;\n+\n+   ftype = build_function_type_list (void_type_node,\n+ \t\t\t\t    build_pointer_type (uint64_type),\n+\t\t\t\t    uint64_type, NULL_TREE);\n+  add_builtin_function (\"__builtin_non_tx_store\", ftype,\n+\t\t\tS390_BUILTIN_NON_TX_STORE,\n+\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n+}\n+\n+/* Expand an expression EXP that calls a built-in function,\n+   with result going to TARGET if that's convenient\n+   (and in mode MODE if that's convenient).\n+   SUBTARGET may be used as the target for computing one of EXP's operands.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+\n+static rtx\n+s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t     int ignore ATTRIBUTE_UNUSED)\n+{\n+#define MAX_ARGS 2\n+\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  enum insn_code icode;\n+  rtx op[MAX_ARGS], pat;\n+  int arity;\n+  bool nonvoid;\n+  tree arg;\n+  call_expr_arg_iterator iter;\n+\n+  if (fcode >= S390_BUILTIN_max)\n+    internal_error (\"bad builtin fcode\");\n+  icode = code_for_builtin[fcode];\n+  if (icode == 0)\n+    internal_error (\"bad builtin fcode\");\n+\n+  if (!TARGET_ZEC12)\n+    error (\"Transactional execution builtins require zEC12 or later\\n\");\n+\n+  if (!TARGET_HTM && TARGET_ZEC12)\n+    error (\"Transactional execution builtins not enabled (-mtx)\\n\");\n+\n+  /* Set a flag in the machine specific cfun part in order to support\n+     saving/restoring of FPRs.  */\n+  if (fcode == S390_BUILTIN_TBEGIN || fcode == S390_BUILTIN_TBEGIN_RETRY)\n+    cfun->machine->tbegin_p = true;\n+\n+  nonvoid = TREE_TYPE (TREE_TYPE (fndecl)) != void_type_node;\n+\n+  arity = 0;\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, exp)\n+    {\n+      const struct insn_operand_data *insn_op;\n+\n+      if (arg == error_mark_node)\n+\treturn NULL_RTX;\n+      if (arity >= MAX_ARGS)\n+\treturn NULL_RTX;\n+\n+      insn_op = &insn_data[icode].operand[arity + nonvoid];\n+\n+      op[arity] = expand_expr (arg, NULL_RTX, insn_op->mode, EXPAND_NORMAL);\n+\n+      if (!(*insn_op->predicate) (op[arity], insn_op->mode))\n+\t{\n+\t  if (insn_op->predicate == memory_operand)\n+\t    {\n+\t      /* Don't move a NULL pointer into a register. Otherwise\n+\t\t we have to rely on combine being able to move it back\n+\t\t in order to get an immediate 0 in the instruction.  */\n+\t      if (op[arity] != const0_rtx)\n+\t\top[arity] = copy_to_mode_reg (Pmode, op[arity]);\n+\t      op[arity] = gen_rtx_MEM (insn_op->mode, op[arity]);\n+\t    }\n+\t  else\n+\t    op[arity] = copy_to_mode_reg (insn_op->mode, op[arity]);\n+\t}\n+\n+      arity++;\n+    }\n+\n+  if (nonvoid)\n+    {\n+      enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+      if (!target\n+\t  || GET_MODE (target) != tmode\n+\t  || !(*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+    }\n+\n+  switch (arity)\n+    {\n+    case 0:\n+      pat = GEN_FCN (icode) (target);\n+      break;\n+    case 1:\n+      if (nonvoid)\n+        pat = GEN_FCN (icode) (target, op[0]);\n+      else\n+\tpat = GEN_FCN (icode) (op[0]);\n+      break;\n+    case 2:\n+      if (nonvoid)\n+\tpat = GEN_FCN (icode) (target, op[0], op[1]);\n+      else\n+\tpat = GEN_FCN (icode) (op[0], op[1]);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  if (!pat)\n+    return NULL_RTX;\n+  emit_insn (pat);\n+\n+  if (nonvoid)\n+    return target;\n+  else\n+    return const0_rtx;\n+}\n+\n+\n /* Output assembly code for the trampoline template to\n    stdio stream FILE.\n \n@@ -11008,6 +11497,11 @@ s390_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY s390_return_in_memory\n \n+#undef  TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS s390_init_builtins\n+#undef  TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN s390_expand_builtin\n+\n #undef TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA\n #define TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA s390_output_addr_const_extra\n "}, {"sha": "d53fed7a6f2ee6b5e0b1972bebc5f549cba7c5c5", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -34,7 +34,8 @@ enum processor_flags\n   PF_DFP = 16,\n   PF_Z10 = 32,\n   PF_Z196 = 64,\n-  PF_ZEC12 = 128\n+  PF_ZEC12 = 128,\n+  PF_TX = 256\n };\n \n /* This is necessary to avoid a warning about comparing different enum\n@@ -61,6 +62,8 @@ enum processor_flags\n  \t(s390_arch_flags & PF_Z196)\n #define TARGET_CPU_ZEC12 \\\n  \t(s390_arch_flags & PF_ZEC12)\n+#define TARGET_CPU_HTM \\\n+ \t(s390_arch_flags & PF_TX)\n \n /* These flags indicate that the generated code should run on a cpu\n    providing the respective hardware facility when run in\n@@ -78,6 +81,8 @@ enum processor_flags\n        (TARGET_ZARCH && TARGET_CPU_Z196)\n #define TARGET_ZEC12 \\\n        (TARGET_ZARCH && TARGET_CPU_ZEC12)\n+#define TARGET_HTM \\\n+       (TARGET_ZARCH && TARGET_CPU_HTM && TARGET_OPT_HTM)\n \n \n #define TARGET_AVOID_CMP_AND_BRANCH (s390_tune == PROCESSOR_2817_Z196)\n@@ -93,23 +98,25 @@ enum processor_flags\n #define TARGET_TPF 0\n \n /* Target CPU builtins.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      builtin_assert (\"cpu=s390\");\t\t\t\\\n-      builtin_assert (\"machine=s390\");\t\t\t\\\n-      builtin_define (\"__s390__\");\t\t\t\\\n-      if (TARGET_ZARCH)\t\t\t\t\t\\\n-\tbuiltin_define (\"__zarch__\");\t\t\t\\\n-      if (TARGET_64BIT)\t\t\t\t\t\\\n-        builtin_define (\"__s390x__\");\t\t\t\\\n-      if (TARGET_LONG_DOUBLE_128)\t\t\t\\\n-        builtin_define (\"__LONG_DOUBLE_128__\");\t\t\\\n-    }\t\t\t\t\t\t\t\\\n+#define TARGET_CPU_CPP_BUILTINS()\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      builtin_assert (\"cpu=s390\");\t\t\t\t\t\\\n+      builtin_assert (\"machine=s390\");\t\t\t\t\t\\\n+      builtin_define (\"__s390__\");\t\t\t\t\t\\\n+      if (TARGET_ZARCH)\t\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__zarch__\");\t\t\t\t\t\\\n+      if (TARGET_64BIT)\t\t\t\t\t\t\t\\\n+        builtin_define (\"__s390x__\");\t\t\t\t\t\\\n+      if (TARGET_LONG_DOUBLE_128)\t\t\t\t\t\\\n+        builtin_define (\"__LONG_DOUBLE_128__\");\t\t\t\t\\\n+      if (TARGET_HTM)\t\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__HTM__\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n \n #ifdef DEFAULT_TARGET_64BIT\n-#define TARGET_DEFAULT             (MASK_64BIT | MASK_ZARCH | MASK_HARD_DFP)\n+#define TARGET_DEFAULT             (MASK_64BIT | MASK_ZARCH | MASK_HARD_DFP | MASK_OPT_HTM)\n #else\n #define TARGET_DEFAULT             0\n #endif"}, {"sha": "e12d1538a503cd60c309f5444161c19a0a743a4c", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 258, "deletions": 23, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -59,11 +59,17 @@\n (define_c_enum \"unspec\" [\n    ; Miscellaneous\n    UNSPEC_ROUND\n-   UNSPEC_CCU_TO_INT\n-   UNSPEC_CCZ_TO_INT\n    UNSPEC_ICM\n    UNSPEC_TIE\n \n+   ; Convert CC into a str comparison result and copy it into an\n+   ; integer register\n+   ; cc0->0, cc1->1, cc2->-1, (cc3->-1)\n+   UNSPEC_STRCMPCC_TO_INT\n+\n+   ; Copy CC as is into the lower 2 bits of an integer register\n+   UNSPEC_CC_TO_INT\n+\n    ; GOT/PLT and lt-relative accesses\n    UNSPEC_LTREL_OFFSET\n    UNSPEC_LTREL_BASE\n@@ -138,6 +144,15 @@\n    ; Atomic Support\n    UNSPECV_CAS\n    UNSPECV_ATOMIC_OP\n+\n+   ; Transactional Execution support\n+   UNSPECV_TBEGIN\n+   UNSPECV_TBEGINC\n+   UNSPECV_TEND\n+   UNSPECV_TABORT\n+   UNSPECV_ETND\n+   UNSPECV_NTSTG\n+   UNSPECV_PPA\n   ])\n \n ;;\n@@ -191,6 +206,9 @@\n    (PFPO_OP1_TYPE_SHIFT           8)\n   ])\n \n+; Immediate operands for tbegin and tbeginc\n+(define_constants [(TBEGIN_MASK  65292)]) ; 0xff0c\n+(define_constants [(TBEGINC_MASK 65288)]) ; 0xff08\n \n ;; Instruction operand type as used in the Principles of Operation.\n ;; Used to determine defaults for length and other attribute values.\n@@ -2251,7 +2269,7 @@\n \n (define_insn \"movcc\"\n   [(set (match_operand:CC 0 \"nonimmediate_operand\" \"=d,c,d,d,d,R,T\")\n-\t(match_operand:CC 1 \"nonimmediate_operand\" \"d,d,c,R,T,d,d\"))]\n+\t(match_operand:CC 1 \"nonimmediate_operand\" \" d,d,c,R,T,d,d\"))]\n   \"\"\n   \"@\n    lr\\t%0,%1\n@@ -2583,7 +2601,7 @@\n      (use (reg:SI 0))])\n    (parallel\n     [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t  (unspec:SI [(reg:CCU CC_REGNUM)] UNSPEC_CCU_TO_INT))\n+\t  (unspec:SI [(reg:CCU CC_REGNUM)] UNSPEC_STRCMPCC_TO_INT))\n      (clobber (reg:CC CC_REGNUM))])]\n   \"\"\n {\n@@ -2825,7 +2843,7 @@\n                      (match_dup 2)]\n                      UNSPEC_TDC_INSN))\n    (set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (unspec:SI [(reg:CCZ CC_REGNUM)] UNSPEC_CCZ_TO_INT))]\n+        (unspec:SI [(reg:CCZ CC_REGNUM)] UNSPEC_CC_TO_INT))]\n   \"TARGET_HARD_FLOAT\"\n {\n   operands[2] = GEN_INT (S390_TDC_SIGNBIT_SET);\n@@ -2837,12 +2855,21 @@\n                      (match_dup 2)]\n                      UNSPEC_TDC_INSN))\n    (set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (unspec:SI [(reg:CCZ CC_REGNUM)] UNSPEC_CCZ_TO_INT))]\n+        (unspec:SI [(reg:CCZ CC_REGNUM)] UNSPEC_CC_TO_INT))]\n   \"TARGET_HARD_FLOAT\"\n {\n   operands[2] = GEN_INT (S390_TDC_INFINITY);\n })\n \n+(define_insn_and_split \"*cc_to_int\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (unspec:SI [(match_operand 1 \"register_operand\" \"0\")]\n+                   UNSPEC_CC_TO_INT))]\n+  \"operands != NULL\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0) (lshiftrt:SI (match_dup 0) (const_int 28)))])\n+\n ; This insn is used to generate all variants of the Test Data Class\n ; instruction, namely tcxb, tcdb, and tceb.  The insn's first operand\n ; is the register to be tested and the second one is the bit mask\n@@ -2858,14 +2885,6 @@\n    [(set_attr \"op_type\" \"RXE\")\n     (set_attr \"type\"  \"fsimp<mode>\")])\n \n-(define_insn_and_split \"*ccz_to_int\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (unspec:SI [(match_operand:CCZ 1 \"register_operand\" \"0\")]\n-                   UNSPEC_CCZ_TO_INT))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(set (match_dup 0) (lshiftrt:SI (match_dup 0) (const_int 28)))])\n \n \n ;\n@@ -3210,7 +3229,7 @@\n (define_insn_and_split \"cmpint\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (unspec:SI [(match_operand:CCU 1 \"register_operand\" \"0\")]\n-                   UNSPEC_CCU_TO_INT))\n+                   UNSPEC_STRCMPCC_TO_INT))\n    (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"#\"\n@@ -3223,10 +3242,10 @@\n (define_insn_and_split \"*cmpint_cc\"\n   [(set (reg CC_REGNUM)\n         (compare (unspec:SI [(match_operand:CCU 1 \"register_operand\" \"0\")]\n-                            UNSPEC_CCU_TO_INT)\n+                            UNSPEC_STRCMPCC_TO_INT)\n                  (const_int 0)))\n    (set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (unspec:SI [(match_dup 1)] UNSPEC_CCU_TO_INT))]\n+        (unspec:SI [(match_dup 1)] UNSPEC_STRCMPCC_TO_INT))]\n   \"s390_match_ccmode (insn, CCSmode)\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -3243,7 +3262,7 @@\n (define_insn_and_split \"*cmpint_sign\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n         (sign_extend:DI (unspec:SI [(match_operand:CCU 1 \"register_operand\" \"0\")]\n-                                   UNSPEC_CCU_TO_INT)))\n+                                   UNSPEC_STRCMPCC_TO_INT)))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_ZARCH\"\n   \"#\"\n@@ -3257,11 +3276,11 @@\n   [(set (reg CC_REGNUM)\n         (compare (ashiftrt:DI (ashift:DI (subreg:DI\n                    (unspec:SI [(match_operand:CCU 1 \"register_operand\" \"0\")]\n-                              UNSPEC_CCU_TO_INT) 0)\n+                              UNSPEC_STRCMPCC_TO_INT) 0)\n                    (const_int 32)) (const_int 32))\n                  (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=d\")\n-        (sign_extend:DI (unspec:SI [(match_dup 1)] UNSPEC_CCU_TO_INT)))]\n+        (sign_extend:DI (unspec:SI [(match_dup 1)] UNSPEC_STRCMPCC_TO_INT)))]\n   \"s390_match_ccmode (insn, CCSmode) && TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -5512,7 +5531,7 @@\n \t(if_then_else:GPR\n \t  (match_operator 1 \"s390_comparison\"\n \t    [(match_operand 2 \"cc_reg_operand\"        \" c,c, c, c, c, c, c\")\n-\t     (const_int 0)])\n+\t     (match_operand 5 \"const_int_operand\"     \"\")])\n \t  (match_operand:GPR 3 \"nonimmediate_operand\" \" d,0,QS, 0, d, 0,QS\")\n \t  (match_operand:GPR 4 \"nonimmediate_operand\" \" 0,d, 0,QS, 0, d,QS\")))]\n   \"TARGET_Z196\"\n@@ -7912,7 +7931,8 @@\n (define_insn \"*cjump_64\"\n   [(set (pc)\n         (if_then_else\n-          (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM) (const_int 0)])\n+          (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM)\n+\t\t\t\t\t       (match_operand 2 \"const_int_operand\" \"\")])\n           (label_ref (match_operand 0 \"\" \"\"))\n           (pc)))]\n   \"TARGET_CPU_ZARCH\"\n@@ -7931,7 +7951,8 @@\n (define_insn \"*cjump_31\"\n   [(set (pc)\n         (if_then_else\n-          (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM) (const_int 0)])\n+          (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM)\n+\t\t\t\t\t       (match_operand 2 \"const_int_operand\" \"\")])\n           (label_ref (match_operand 0 \"\" \"\"))\n           (pc)))]\n   \"!TARGET_CPU_ZARCH\"\n@@ -9800,3 +9821,217 @@\n   \"cpsdr\\t%0,%2,%1\"\n   [(set_attr \"op_type\"  \"RRF\")\n    (set_attr \"type\"     \"fsimp<mode>\")])\n+\n+\n+;;\n+;;- Transactional execution instructions\n+;;\n+\n+; This splitter helps combine to make use of CC directly when\n+; comparing the integer result of a tbegin builtin with a constant.\n+; The unspec is already removed by canonicalize_comparison. So this\n+; splitters only job is to turn the PARALLEL into separate insns\n+; again.  Unfortunately this only works with the very first cc/int\n+; compare since combine is not able to deal with data flow across\n+; basic block boundaries.\n+\n+; It needs to be an insn pattern as well since combine does not apply\n+; the splitter directly.  Combine would only use it if it actually\n+; would reduce the number of instructions.\n+(define_insn_and_split \"*ccraw_to_int\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 0 \"s390_eqne_operator\"\n+\t\t\t [(reg:CCRAW CC_REGNUM)\n+\t\t\t  (match_operand 1 \"const_int_operand\" \"\")])\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n+\t(unspec:SI [(reg:CCRAW CC_REGNUM)] UNSPEC_CC_TO_INT))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 3)\n+\t(unspec:SI [(reg:CCRAW CC_REGNUM)] UNSPEC_CC_TO_INT))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 0 [(reg:CCRAW CC_REGNUM) (match_dup 1)])\n+\t\t      (label_ref (match_dup 2))\n+\t\t      (pc)))]\n+  \"\")\n+\n+; Non-constrained transaction begin\n+\n+(define_expand \"tbegin\"\n+  [(match_operand:SI 0 \"register_operand\" \"=d\")\n+   (match_operand:BLK 1 \"memory_operand\"  \"=Q\")]\n+  \"TARGET_HTM\"\n+{\n+  s390_expand_tbegin (operands[0], operands[1], NULL_RTX, true);\n+  DONE;\n+})\n+\n+(define_expand \"tbegin_nofloat\"\n+  [(match_operand:SI 0 \"register_operand\" \"=d\")\n+   (match_operand:BLK 1 \"memory_operand\"  \"=Q\")]\n+  \"TARGET_HTM\"\n+{\n+  s390_expand_tbegin (operands[0], operands[1], NULL_RTX, false);\n+  DONE;\n+})\n+\n+(define_expand \"tbegin_retry\"\n+  [(match_operand:SI 0 \"register_operand\" \"=d\")\n+   (match_operand:BLK 1 \"memory_operand\"  \"=Q\")\n+   (match_operand 2 \"const_int_operand\")]\n+  \"TARGET_HTM\"\n+{\n+  s390_expand_tbegin (operands[0], operands[1], operands[2], true);\n+  DONE;\n+})\n+\n+(define_expand \"tbegin_retry_nofloat\"\n+  [(match_operand:SI 0 \"register_operand\" \"=d\")\n+   (match_operand:BLK 1 \"memory_operand\"  \"=Q\")\n+   (match_operand 2 \"const_int_operand\")]\n+  \"TARGET_HTM\"\n+{\n+  s390_expand_tbegin (operands[0], operands[1], operands[2], false);\n+  DONE;\n+})\n+\n+(define_insn \"tbegin_1\"\n+  [(set (reg:CCRAW CC_REGNUM)\n+\t(unspec_volatile:CCRAW [(match_operand:BLK 0 \"memory_operand\"    \"=Q\")\n+\t\t\t\t(match_operand     1 \"const_int_operand\" \" D\")]\n+\t\t\t       UNSPECV_TBEGIN))\n+   (clobber (reg:DF 16))\n+   (clobber (reg:DF 17))\n+   (clobber (reg:DF 18))\n+   (clobber (reg:DF 19))\n+   (clobber (reg:DF 20))\n+   (clobber (reg:DF 21))\n+   (clobber (reg:DF 22))\n+   (clobber (reg:DF 23))\n+   (clobber (reg:DF 24))\n+   (clobber (reg:DF 25))\n+   (clobber (reg:DF 26))\n+   (clobber (reg:DF 27))\n+   (clobber (reg:DF 28))\n+   (clobber (reg:DF 29))\n+   (clobber (reg:DF 30))\n+   (clobber (reg:DF 31))]\n+; CONST_OK_FOR_CONSTRAINT_P does not work with D constraint since D is\n+; not supposed to be used for immediates (see genpreds.c).\n+  \"TARGET_HTM && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 0xffff\"\n+  \"tbegin\\t%0,%x1\"\n+  [(set_attr \"op_type\" \"SIL\")])\n+\n+; Same as above but without the FPR clobbers\n+(define_insn \"tbegin_nofloat_1\"\n+  [(set (reg:CCRAW CC_REGNUM)\n+\t(unspec_volatile:CCRAW [(match_operand:BLK 0 \"memory_operand\"    \"=Q\")\n+\t\t\t\t(match_operand     1 \"const_int_operand\" \" D\")]\n+\t\t\t       UNSPECV_TBEGIN))]\n+  \"TARGET_HTM && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 0xffff\"\n+  \"tbegin\\t%0,%x1\"\n+  [(set_attr \"op_type\" \"SIL\")])\n+\n+\n+; Constrained transaction begin\n+\n+(define_expand \"tbeginc\"\n+  [(set (reg:CCRAW CC_REGNUM)\n+\t(unspec_volatile:CCRAW [(const_int TBEGINC_MASK)]\n+\t\t\t       UNSPECV_TBEGINC))]\n+  \"TARGET_HTM\"\n+  \"\")\n+\n+(define_insn \"*tbeginc_1\"\n+  [(set (reg:CCRAW CC_REGNUM)\n+\t(unspec_volatile:CCRAW [(match_operand 0 \"const_int_operand\" \" D\")]\n+\t\t\t       UNSPECV_TBEGINC))]\n+  \"TARGET_HTM && INTVAL (operands[0]) >= 0 && INTVAL (operands[0]) <= 0xffff\"\n+  \"tbeginc\\t0,%x0\"\n+  [(set_attr \"op_type\" \"SIL\")])\n+\n+; Transaction end\n+\n+(define_expand \"tend\"\n+  [(set (reg:CCRAW CC_REGNUM)\n+\t(unspec_volatile:CCRAW [(const_int 0)] UNSPECV_TEND))\n+   (set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec:SI [(reg:CCRAW CC_REGNUM)] UNSPEC_CC_TO_INT))]\n+  \"TARGET_HTM\"\n+  \"\")\n+\n+(define_insn \"*tend_1\"\n+  [(set (reg:CCRAW CC_REGNUM)\n+\t(unspec_volatile:CCRAW [(const_int 0)] UNSPECV_TEND))]\n+  \"TARGET_HTM\"\n+  \"tend\"\n+  [(set_attr \"op_type\" \"S\")])\n+\n+; Transaction abort\n+\n+(define_expand \"tabort\"\n+  [(unspec_volatile [(match_operand 0 \"shift_count_or_setmem_operand\" \"\")]\n+\t\t    UNSPECV_TABORT)]\n+  \"TARGET_HTM && operands != NULL\"\n+{\n+  if (CONST_INT_P (operands[0])\n+      && INTVAL (operands[0]) >= 0 && INTVAL (operands[0]) <= 255)\n+    {\n+      error (\"Invalid transaction abort code: \" HOST_WIDE_INT_PRINT_DEC\n+\t     \".  Values in range 0 through 255 are reserved.\",\n+\t     INTVAL (operands[0]));\n+      FAIL;\n+    }\n+})\n+\n+(define_insn \"*tabort_1\"\n+  [(unspec_volatile [(match_operand 0 \"shift_count_or_setmem_operand\" \"\")]\n+\t\t    UNSPECV_TABORT)]\n+  \"TARGET_HTM && operands != NULL\"\n+  \"tabort\\t%Y0\"\n+  [(set_attr \"op_type\" \"S\")])\n+\n+; Transaction extract nesting depth\n+\n+(define_insn \"etnd\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_ETND))]\n+  \"TARGET_HTM\"\n+  \"etnd\\t%0\"\n+  [(set_attr \"op_type\" \"RRE\")])\n+\n+; Non-transactional store\n+\n+(define_insn \"ntstg\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=RT\")\n+\t(unspec_volatile:DI [(match_operand:DI 1 \"register_operand\" \"d\")]\n+\t\t\t    UNSPECV_NTSTG))]\n+  \"TARGET_HTM\"\n+  \"ntstg\\t%1,%0\"\n+  [(set_attr \"op_type\" \"RXY\")])\n+\n+; Transaction perform processor assist\n+\n+(define_expand \"tx_assist\"\n+  [(set (match_dup 1) (const_int 0))\n+   (unspec_volatile [(match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t     (match_dup 1)\n+\t\t     (const_int 1)]\n+\t\t    UNSPECV_PPA)]\n+  \"TARGET_HTM\"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+})\n+\n+(define_insn \"*ppa\"\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t     (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"I\")]\n+\t\t    UNSPECV_PPA)]\n+  \"TARGET_HTM && INTVAL (operands[2]) < 16\"\n+  \"ppa\\t%0,%1,1\"\n+  [(set_attr \"op_type\" \"RRF\")])"}, {"sha": "7dedb8367014866a688190490c82b7fb1e8bcc45", "filename": "gcc/config/s390/s390.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.opt?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -104,6 +104,10 @@ mlong-double-64\n Target Report RejectNegative Negative(mlong-double-128) InverseMask(LONG_DOUBLE_128)\n Use 64-bit long double\n \n+mhtm\n+Target Report Mask(OPT_HTM)\n+Use hardware transactional execution instructions\n+\n mpacked-stack\n Target Report Mask(PACKED_STACK)\n Use packed stack layout"}, {"sha": "e1a00ce58e3d9d15b1289daba4636c4de80f5b6c", "filename": "gcc/config/s390/s390intrin.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fconfig%2Fs390%2Fs390intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390intrin.h?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -0,0 +1,33 @@\n+/* S/390 System z specific intrinsics\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Andreas Krebbel (Andreas.Krebbel@de.ibm.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef  _S390INTRIN_H\n+#define _S390INTRIN_H\n+\n+#ifndef __s390__\n+  #error s390intrin.h included on wrong platform/compiler\n+#endif\n+\n+#ifdef __HTM__\n+#include <htmintrin.h>\n+#endif\n+\n+\n+#endif /* _S390INTRIN_H*/"}, {"sha": "1c85a3e738272e5d04fd031487be79b194214902", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -8847,6 +8847,7 @@ instructions, but allow the compiler to schedule those calls.\n * PowerPC Built-in Functions::\n * PowerPC AltiVec/VSX Built-in Functions::\n * RX Built-in Functions::\n+* S/390 System z Built-in Functions::\n * SH Built-in Functions::\n * SPARC VIS Built-in Functions::\n * SPU Built-in Functions::\n@@ -14422,6 +14423,120 @@ bit in the processor status word.\n Generates the @code{wait} machine instruction.\n @end deftypefn\n \n+@node S/390 System z Built-in Functions\n+@subsection S/390 System z Built-in Functions\n+@deftypefn {Built-in Function} int __builtin_tbegin (void*)\n+Generates the @code{tbegin} machine instruction starting a\n+non-constraint hardware transaction.  If the parameter is non-NULL the\n+memory area is used to store the transaction diagnostic buffer and\n+will be passed as first operand to @code{tbegin}.  This buffer can be\n+defined using the @code{struct __htm_tdb} C struct defined in\n+@code{htmintrin.h} and must reside on a double-word boundary.  The\n+second tbegin operand is set to @code{0xff0c}. This enables\n+save/restore of all GPRs and disables aborts for FPR and AR\n+manipulations inside the transaction body.  The condition code set by\n+the tbegin instruction is returned as integer value.  The tbegin\n+instruction by definition overwrites the content of all FPRs.  The\n+compiler will generate code which saves and restores the FPRs.  For\n+soft-float code it is recommended to used the @code{*_nofloat}\n+variant.  In order to prevent a TDB from being written it is required\n+to pass an constant zero value as parameter.  Passing the zero value\n+through a variable is not sufficient.  Although modifications of\n+access registers inside the transaction will not trigger an\n+transaction abort it is not supported to actually modify them.  Access\n+registers do not get saved when entering a transaction. They will have\n+undefined state when reaching the abort code.\n+@end deftypefn\n+\n+Macros for the possible return codes of tbegin are defined in the\n+@code{htmintrin.h} header file:\n+\n+@table @code\n+@item _HTM_TBEGIN_STARTED\n+@code{tbegin} has been executed as part of normal processing.  The\n+transaction body is supposed to be executed.\n+@item _HTM_TBEGIN_INDETERMINATE\n+The transaction was aborted due to an indeterminate condition which\n+might be persistent.\n+@item _HTM_TBEGIN_TRANSIENT\n+The transaction aborted due to a transient failure.  The transaction\n+should be re-executed in that case.\n+@item _HTM_TBEGIN_PERSISTENT\n+The transaction aborted due to a persistent failure.  Re-execution\n+under same circumstances will not be productive.\n+@end table\n+\n+@defmac _HTM_FIRST_USER_ABORT_CODE\n+The @code{_HTM_FIRST_USER_ABORT_CODE} defined in @code{htmintrin.h}\n+specifies the first abort code which can be used for\n+@code{__builtin_tabort}.  Values below this threshold are reserved for\n+machine use.\n+@end defmac\n+\n+@deftp {Data type} {struct __htm_tdb}\n+The @code{struct __htm_tdb} defined in @code{htmintrin.h} describes\n+the structure of the transaction diagnostic block as specified in the\n+Principles of Operation manual chapter 5-91.\n+@end deftp\n+\n+@deftypefn {Built-in Function} int __builtin_tbegin_nofloat (void*)\n+Same as @code{__builtin_tbegin} but without FPR saves and restores.\n+Using this variant in code making use of FPRs will leave the FPRs in\n+undefined state when entering the transaction abort handler code.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_tbegin_retry (void*, int)\n+In addition to @code{__builtin_tbegin} a loop for transient failures\n+is generated.  If tbegin returns a condition code of 2 the transaction\n+will be retried as often as specified in the second argument.  The\n+perform processor assist instruction is used to tell the CPU about the\n+number of fails so far.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_tbegin_retry_nofloat (void*, int)\n+Same as @code{__builtin_tbegin_retry} but without FPR saves and\n+restores.  Using this variant in code making use of FPRs will leave\n+the FPRs in undefined state when entering the transaction abort\n+handler code.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __builtin_tbeginc (void)\n+Generates the @code{tbeginc} machine instruction starting a constraint\n+hardware transaction.  The second operand is set to @code{0xff08}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_tend (void)\n+Generates the @code{tend} machine instruction finishing a transaction\n+and making the changes visible to other threads.  The condition code\n+generated by tend is returned as integer value.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __builtin_tabort (int)\n+Generates the @code{tabort} machine instruction with the specified\n+abort code.  Abort codes from 0 through 255 are reserved and will\n+result in an error message.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __builtin_tx_assist (int)\n+Generates the @code{ppa rX,rY,1} machine instruction.  Where the\n+integer parameter is loaded into rX and a value of zero is loaded into\n+rY.  The integer parameter specifies the number of times the\n+transaction repeatedly aborted.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} int __builtin_tx_nesting_depth (void)\n+Generates the @code{etnd} machine instruction.  The current nesting\n+depth is returned as integer value.  For a nesting depth of 0 the code\n+is not executed as part of an transaction.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function} void __builtin_non_tx_store (unsigned long long *, unsigned long long)\n+\n+Generates the @code{ntstg} machine instruction.  The second argument\n+is written to the first arguments location.  The store operation will\n+not be rolled-back in case of an transaction abort.\n+@end deftypefn\n+\n @node SH Built-in Functions\n @subsection SH Built-in Functions\n The following built-in functions are supported on the SH1, SH2, SH3 and SH4"}, {"sha": "f6ab2ba0468533458c5608bc5b6ac754b7949478", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -1,3 +1,9 @@\n+2013-06-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* gcc.target/s390/htm-1.c: New file.\n+\t* gcc.target/s390/htm-nofloat-1.c: New file.\n+\t* gcc.target/s390/htm-xl-intrin-1.c: New file.\n+\n 2013-06-26  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/29800"}, {"sha": "e6321de071e7b82cee70f0fcfe9614b7984434d7", "filename": "gcc/testsuite/gcc.target/s390/htm-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-1.c?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -0,0 +1,37 @@\n+/* This checks the availability of the low-level builtins introduced\n+   for transactional execution.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=zEC12 -mzarch\" } */\n+\n+#include <stdint.h>\n+#include <htmintrin.h>\n+\n+int a = 0;\n+uint64_t g;\n+\n+int\n+foo (struct __htm_tdb* tdb)\n+{\n+\n+  int cc;\n+  int n;\n+\n+  cc = __builtin_tbegin (0);\n+  cc = __builtin_tbegin (tdb);\n+  cc = __builtin_tbegin_nofloat (0);\n+  cc = __builtin_tbegin_nofloat (tdb);\n+  cc = __builtin_tbegin_retry (0, 42);\n+  cc = __builtin_tbegin_retry (tdb, 42);\n+  cc = __builtin_tbegin_retry_nofloat (0, 42);\n+  cc = __builtin_tbegin_retry_nofloat (tdb, 42);\n+  __builtin_tbeginc ();\n+  n = __builtin_tx_nesting_depth();\n+  __builtin_non_tx_store(&g, n);\n+  __builtin_tabort (42 + 255);\n+  __builtin_tend();\n+  __builtin_tx_assist (23);\n+}\n+/* Make sure the tdb NULL argument ends up as immediate value in the\n+   instruction.  */\n+/* { dg-final { scan-assembler-times \"tbegin\\t0,\" 4 } } */"}, {"sha": "df7e2bac874b2f3e14a6243836775ac9057b0a7a", "filename": "gcc/testsuite/gcc.target/s390/htm-nofloat-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-nofloat-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-nofloat-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-nofloat-1.c?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=zEC12 -mzarch\" } */\n+\n+int\n+foo ()\n+{\n+  __builtin_tbegin_nofloat (0);\n+  __builtin_tbegin_retry_nofloat (0, 42);\n+}\n+/* Make sure no FPR saves/restores are emitted.  */\n+/* { dg-final { scan-assembler-not \"std\" } } */\n+/* { dg-final { scan-assembler-not \"ld\" } } */"}, {"sha": "77ceeb7706f77688b219e4e1ea813b2a4e6d6d2e", "filename": "gcc/testsuite/gcc.target/s390/htm-xl-intrin-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-xl-intrin-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-xl-intrin-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fhtm-xl-intrin-1.c?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -0,0 +1,37 @@\n+/* This checks the availability of the XL compiler intrinsics for\n+   transactional execution with the expected prototypes.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=zEC12 -mzarch\" } */\n+\n+#include <htmxlintrin.h>\n+\n+int a = 0;\n+unsigned long g;\n+\n+int\n+foo ()\n+{\n+  struct __htm_tdb *tdb_struct;\n+  void * const tdb = tdb_struct;\n+  long result;\n+  unsigned char code;\n+\n+  result = __TM_simple_begin ();\n+  result = __TM_begin (tdb);\n+  result = __TM_end ();\n+  __TM_abort ();\n+  __TM_named_abort (42);\n+  __TM_non_transactional_store (&g, 42);\n+  result = __TM_nesting_depth (tdb);\n+\n+  result = __TM_is_user_abort (tdb);\n+  result = __TM_is_named_user_abort (tdb, &code);\n+  result = __TM_is_illegal (tdb);\n+  result = __TM_is_footprint_exceeded (tdb);\n+  result = __TM_is_nested_too_deep (tdb);\n+  result = __TM_is_conflict (tdb);\n+  result = __TM_is_failure_persistent (result);\n+  result = __TM_failure_address (tdb);\n+  result = __TM_failure_code (tdb);\n+}"}, {"sha": "27474d7b348e763e629ddb772c5d43e50ac3d3dc", "filename": "libitm/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -1,3 +1,10 @@\n+2013-06-27  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* config/s390/target.h: Include htmintrin.h.\n+\t(_HTM_ITM_RETRIES): New macro definition.\n+\t(htm_available, htm_init, htm_begin, htm_begin_success)\n+\t(htm_commit, htm_abort, htm_abort_should_retry): New functions.\n+\n 2013-06-20  Iain Sandoe  <iain@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n "}, {"sha": "580606f0270a361a00d36be80126cc5d673d7db1", "filename": "libitm/config/s390/target.h", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/libitm%2Fconfig%2Fs390%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9/libitm%2Fconfig%2Fs390%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fs390%2Ftarget.h?ref=5a3fe9b6077ab7fbc9dc200dc9621dabf939c7a9", "patch": "@@ -22,6 +22,12 @@\n    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    <http://www.gnu.org/licenses/>.  */\n \n+\n+#include <htmintrin.h>\n+\n+/* Number of retries for transient failures.  */\n+#define _HTM_ITM_RETRIES 10\n+\n namespace GTM HIDDEN {\n \n #define HW_CACHELINE_SIZE 256\n@@ -52,4 +58,57 @@ cpu_relax (void)\n   __asm volatile (\"\" : : : \"memory\");\n }\n \n+#ifdef __HTM__\n+#define USE_HTM_FASTPATH\n+\n+static inline bool\n+htm_available ()\n+{\n+  return true;\n+}\n+\n+static inline uint32_t\n+htm_init ()\n+{\n+  return htm_available () ? _HTM_ITM_RETRIES : 0;\n+}\n+\n+static inline uint32_t\n+htm_begin ()\n+{\n+  return __builtin_tbegin_nofloat (NULL);\n+}\n+\n+static inline bool\n+htm_begin_success (uint32_t begin_ret)\n+{\n+  return begin_ret == _HTM_TBEGIN_STARTED;\n+}\n+\n+static inline void\n+htm_commit ()\n+{\n+  __builtin_tend ();\n+}\n+\n+static inline void\n+htm_abort ()\n+{\n+  __builtin_tabort (_HTM_FIRST_USER_ABORT_CODE);\n+}\n+\n+static inline bool\n+htm_abort_should_retry (uint32_t begin_ret)\n+{\n+  return begin_ret == _HTM_TBEGIN_TRANSIENT;\n+}\n+\n+static inline bool\n+htm_transaction_active ()\n+{\n+  return __builtin_tx_nesting_depth() != 0;\n+}\n+\n+#endif\n+\n } // namespace GTM"}]}