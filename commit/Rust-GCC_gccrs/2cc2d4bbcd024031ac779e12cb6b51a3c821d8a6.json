{"sha": "2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNjMmQ0YmJjZDAyNDAzMWFjNzc5ZTEyY2I2YjUxYTNjODIxZDhhNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2002-01-01T22:22:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2002-01-01T22:22:25Z"}, "message": "attribs.c (handle_vector_size_attribute): Use host_integerp and tree_int_cst; remove warnings.\n\n\t* attribs.c (handle_vector_size_attribute): Use host_integerp\n\tand tree_int_cst; remove warnings.\n\t* caller-save.c (insert_restore): Add cast to get rid of warning.\n\t(insert_save): Likewise.\n\t* emit-rtl.c (adjust_address_1, offset_address): Likewise.\n\t* regmove.c (find_matches): Add temporary var to kill a warning.\n\nFrom-SVN: r48452", "tree": {"sha": "5db1dfd712c394d01480a188c6968a697f6d4ef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5db1dfd712c394d01480a188c6968a697f6d4ef4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/comments", "author": null, "committer": null, "parents": [{"sha": "16b617648e045601e68a067591450b2956dcdbac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16b617648e045601e68a067591450b2956dcdbac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16b617648e045601e68a067591450b2956dcdbac"}], "stats": {"total": 60, "additions": 37, "deletions": 23}, "files": [{"sha": "f17fa1df6eda7fcac4385c4f96df1691a398db29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6", "patch": "@@ -1,3 +1,12 @@\n+Tue Jan  1 17:12:56 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* attribs.c (handle_vector_size_attribute): Use host_integerp\n+\tand tree_int_cst; remove warnings.\n+\t* caller-save.c (insert_restore): Add cast to get rid of warning.\n+\t(insert_save): Likewise.\n+\t* emit-rtl.c (adjust_address_1, offset_address): Likewise.\n+\t* regmove.c (find_matches): Add temporary var to kill a warning.\n+\n 2002-01-01  Douglas B Rupp  <rupp@gnat.com>\n \n \t* config/alpha/vms.h (DWARF2_UNWIND_INFO, EH_RETURN_HANDLER_RTX,"}, {"sha": "19e99ad305592d8e9abff921ec8201fadbc782af", "filename": "gcc/attribs.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6", "patch": "@@ -1,6 +1,6 @@\n /* Functions dealing with attribute handling, used by most front ends.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n+   2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1142,20 +1142,20 @@ handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n      int flags ATTRIBUTE_UNUSED;\n      bool *no_add_attrs;\n {\n-  unsigned int vecsize, nunits;\n+  unsigned HOST_WIDE_INT vecsize, nunits;\n   enum machine_mode mode, orig_mode, new_mode;\n   tree type = *node, new_type;\n \n   *no_add_attrs = true;\n \n-  if (TREE_CODE (TREE_VALUE (args)) != INTEGER_CST)\n+  if (! host_integerp (TREE_VALUE (args), 1))\n     {\n       warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n       return NULL_TREE;\n     }\n \n   /* Get the vector size (in bytes).  */\n-  vecsize = TREE_INT_CST_LOW (TREE_VALUE (args));\n+  vecsize = tree_low_cst (TREE_VALUE (args), 1);\n \n   /* We need to provide for vector pointers, vector arrays, and\n      functions returning vectors.  For example:\n@@ -1173,17 +1173,18 @@ handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n   /* Get the mode of the type being modified.  */\n   orig_mode = TYPE_MODE (type);\n \n-  if (TREE_CODE (type) == RECORD_TYPE ||\n-      (GET_MODE_CLASS (orig_mode) != MODE_FLOAT\n-       && GET_MODE_CLASS (orig_mode) != MODE_INT))\n+  if (TREE_CODE (type) == RECORD_TYPE\n+      || (GET_MODE_CLASS (orig_mode) != MODE_FLOAT\n+\t  && GET_MODE_CLASS (orig_mode) != MODE_INT)\n+      || ! host_integerp (TYPE_SIZE_UNIT (type), 1))\n     {\n       error (\"invalid vector type for attribute `%s'\",\n \t     IDENTIFIER_POINTER (name));\n       return NULL_TREE;\n     }\n \n   /* Calculate how many units fit in the vector.  */\n-  nunits = vecsize / TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type));\n+  nunits = vecsize / tree_low_cst (TYPE_SIZE_UNIT (type), 1);\n \n   /* Find a suitably sized vector.  */\n   new_mode = VOIDmode;\n@@ -1192,7 +1193,8 @@ handle_vector_size_attribute (node, name, args, flags, no_add_attrs)\n \t\t\t\t\t: MODE_VECTOR_FLOAT);\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n-    if (vecsize == GET_MODE_SIZE (mode)\t&& nunits == GET_MODE_NUNITS (mode))\n+    if (vecsize == GET_MODE_SIZE (mode)\n+\t&& nunits == (unsigned HOST_WIDE_INT) GET_MODE_NUNITS (mode))\n       {\n \tnew_mode = mode;\n \tbreak;"}, {"sha": "87a13dc0fad69b6ef30cfd95ceeb415f8ce85ec9", "filename": "gcc/caller-save.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6", "patch": "@@ -1,6 +1,6 @@\n /* Save and restore call-clobbered registers which are live across a call.\n    Copyright (C) 1989, 1992, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -675,7 +675,7 @@ insert_restore (chain, before_p, regno, maxrestore, save_mode)\n   mem = regno_save_mem [regno][numregs];\n   if (save_mode [regno] != VOIDmode\n       && save_mode [regno] != GET_MODE (mem)\n-      && numregs == HARD_REGNO_NREGS (regno, save_mode [regno]))\n+      && numregs == (unsigned int) HARD_REGNO_NREGS (regno, save_mode [regno]))\n     mem = adjust_address (mem, save_mode[regno], 0);\n   pat = gen_rtx_SET (VOIDmode,\n \t\t     gen_rtx_REG (GET_MODE (mem), \n@@ -691,13 +691,12 @@ insert_restore (chain, before_p, regno, maxrestore, save_mode)\n       n_regs_saved--;\n     }\n \n-\n-\n   /* Tell our callers how many extra registers we saved/restored */\n   return numregs - 1;\n }\n \n /* Like insert_restore above, but save registers instead.  */\n+\n static int\n insert_save (chain, before_p, regno, to_save, save_mode)\n      struct insn_chain *chain;\n@@ -752,7 +751,7 @@ insert_save (chain, before_p, regno, to_save, save_mode)\n   mem = regno_save_mem [regno][numregs];\n   if (save_mode [regno] != VOIDmode\n       && save_mode [regno] != GET_MODE (mem)\n-      && numregs == HARD_REGNO_NREGS (regno, save_mode [regno]))\n+      && numregs == (unsigned int) HARD_REGNO_NREGS (regno, save_mode [regno]))\n     mem = adjust_address (mem, save_mode[regno], 0);\n   pat = gen_rtx_SET (VOIDmode, mem,\n \t\t     gen_rtx_REG (GET_MODE (mem),"}, {"sha": "6efdad7cb0711a53a96f9e9eac241ece642b4bf0", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6", "patch": "@@ -1,6 +1,6 @@\n /* Emit RTL for the GNU C-Compiler expander.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1996,7 +1996,8 @@ adjust_address_1 (memref, mode, offset, validate, adjust)\n      lowest-order set bit in OFFSET, but don't change the alignment if OFFSET\n      if zero.  */\n   if (offset != 0)\n-    memalign = MIN (memalign, (offset & -offset) * BITS_PER_UNIT);\n+    memalign = MIN (memalign,\n+\t\t    (unsigned int) (offset & -offset) * BITS_PER_UNIT);\n \n   /* We can compute the size in a number of ways.  */\n   if (GET_MODE (new) != BLKmode)\n@@ -2045,10 +2046,11 @@ offset_address (memref, offset, pow2)\n \n   /* Update the alignment to reflect the offset.  Reset the offset, which\n      we don't know.  */\n-  MEM_ATTRS (new) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref),\n-\t\t\t\t   0, 0, MIN (MEM_ALIGN (memref),\n-\t\t\t\t\t      pow2 * BITS_PER_UNIT),\n-\t\t\t\t   GET_MODE (new));\n+  MEM_ATTRS (new)\n+    = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref), 0, 0,\n+\t\t     MIN (MEM_ALIGN (memref),\n+\t\t\t  (unsigned int) pow2 * BITS_PER_UNIT),\n+\t\t     GET_MODE (new));\n   return new;\n }\n   "}, {"sha": "c11fbcbb15f03966ee7ab946272c34b0e8c05c45", "filename": "gcc/regmove.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=2cc2d4bbcd024031ac779e12cb6b51a3c821d8a6", "patch": "@@ -1,6 +1,6 @@\n /* Move registers around to reduce number of move instructions needed.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1581,7 +1581,9 @@ find_matches (insn, matchp)\n \t  case '5': case '6': case '7': case '8': case '9':\n \t    {\n \t      char *end;\n-\t      unsigned long match = strtoul (p - 1, &end, 10);\n+\t      unsigned long match_ul = strtoul (p - 1, &end, 10);\n+\t      int match = match_ul;\n+\n \t      p = end;\n \n \t      if (match < op_no && likely_spilled[match])"}]}