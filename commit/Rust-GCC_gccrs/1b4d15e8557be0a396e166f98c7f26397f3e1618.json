{"sha": "1b4d15e8557be0a396e166f98c7f26397f3e1618", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI0ZDE1ZTg1NTdiZTBhMzk2ZTE2NmY5OGM3ZjI2Mzk3ZjNlMTYxOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-04-11T09:02:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-04-11T09:02:47Z"}, "message": "re PR rtl-optimization/89965 (wrong code with -O -mtune=nano-x2 -fcaller-saves -fexpensive-optimizations -fno-tree-dce -fno-tree-ter)\n\n\tPR rtl-optimization/89965\n\t* dce.c (sp_based_mem_offset): New function.\n\t(find_call_stack_args): Use sp_based_mem_offset.\n\nFrom-SVN: r270278", "tree": {"sha": "e232414b5c9bf6098c5d73497af8c8ef96d6959c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e232414b5c9bf6098c5d73497af8c8ef96d6959c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b4d15e8557be0a396e166f98c7f26397f3e1618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b4d15e8557be0a396e166f98c7f26397f3e1618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b4d15e8557be0a396e166f98c7f26397f3e1618", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b4d15e8557be0a396e166f98c7f26397f3e1618/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ecb3e9a46e306b4c3328627dddd3d2079dfe7d18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb3e9a46e306b4c3328627dddd3d2079dfe7d18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecb3e9a46e306b4c3328627dddd3d2079dfe7d18"}], "stats": {"total": 210, "additions": 75, "deletions": 135}, "files": [{"sha": "6c26bf76832d3f377b4e5912de9a8cb5915991ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4d15e8557be0a396e166f98c7f26397f3e1618/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4d15e8557be0a396e166f98c7f26397f3e1618/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b4d15e8557be0a396e166f98c7f26397f3e1618", "patch": "@@ -1,3 +1,9 @@\n+2019-04-11  Jakub Jelinek  <jakub@redhat.com>\n+\t\n+\tPR rtl-optimization/89965\n+\t* dce.c (sp_based_mem_offset): New function.\n+\t(find_call_stack_args): Use sp_based_mem_offset.\n+\n 2019-04-11  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* doc/invoke.texi (Optimize Options): Clarify -flive-patching docs."}, {"sha": "98063dc44ac925de75c9762a48bf311855240f61", "filename": "gcc/dce.c", "status": "modified", "additions": 69, "deletions": 135, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b4d15e8557be0a396e166f98c7f26397f3e1618/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b4d15e8557be0a396e166f98c7f26397f3e1618/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=1b4d15e8557be0a396e166f98c7f26397f3e1618", "patch": "@@ -272,6 +272,58 @@ check_argument_store (HOST_WIDE_INT size, HOST_WIDE_INT off,\n   return true;\n }\n \n+/* If MEM has sp address, return 0, if it has sp + const address,\n+   return that const, if it has reg address where reg is set to sp + const\n+   and FAST is false, return const, otherwise return\n+   INTTYPE_MINUMUM (HOST_WIDE_INT).  */\n+\n+static HOST_WIDE_INT\n+sp_based_mem_offset (rtx_call_insn *call_insn, const_rtx mem, bool fast)\n+{\n+  HOST_WIDE_INT off = 0;\n+  rtx addr = XEXP (mem, 0);\n+  if (GET_CODE (addr) == PLUS\n+      && REG_P (XEXP (addr, 0))\n+      && CONST_INT_P (XEXP (addr, 1)))\n+    {\n+      off = INTVAL (XEXP (addr, 1));\n+      addr = XEXP (addr, 0);\n+    }\n+  if (addr == stack_pointer_rtx)\n+    return off;\n+\n+  if (!REG_P (addr) || fast)\n+    return INTTYPE_MINIMUM (HOST_WIDE_INT);\n+\n+  /* If not fast, use chains to see if addr wasn't set to sp + offset.  */\n+  df_ref use;\n+  FOR_EACH_INSN_USE (use, call_insn)\n+  if (rtx_equal_p (addr, DF_REF_REG (use)))\n+    break;\n+\n+  if (use == NULL)\n+    return INTTYPE_MINIMUM (HOST_WIDE_INT);\n+\n+  struct df_link *defs;\n+  for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n+    if (! DF_REF_IS_ARTIFICIAL (defs->ref))\n+      break;\n+\n+  if (defs == NULL)\n+    return INTTYPE_MINIMUM (HOST_WIDE_INT);\n+\n+  rtx set = single_set (DF_REF_INSN (defs->ref));\n+  if (!set)\n+    return INTTYPE_MINIMUM (HOST_WIDE_INT);\n+\n+  if (GET_CODE (SET_SRC (set)) != PLUS\n+      || XEXP (SET_SRC (set), 0) != stack_pointer_rtx\n+      || !CONST_INT_P (XEXP (SET_SRC (set), 1)))\n+    return INTTYPE_MINIMUM (HOST_WIDE_INT);\n+\n+  off += INTVAL (XEXP (SET_SRC (set), 1));\n+  return off;\n+}\n \n /* Try to find all stack stores of CALL_INSN arguments if\n    ACCUMULATE_OUTGOING_ARGS.  If all stack stores have been found\n@@ -309,58 +361,13 @@ find_call_stack_args (rtx_call_insn *call_insn, bool do_mark, bool fast,\n     if (GET_CODE (XEXP (p, 0)) == USE\n \t&& MEM_P (XEXP (XEXP (p, 0), 0)))\n       {\n-\trtx mem = XEXP (XEXP (p, 0), 0), addr;\n-\tHOST_WIDE_INT off = 0, size;\n+\trtx mem = XEXP (XEXP (p, 0), 0);\n+\tHOST_WIDE_INT size;\n \tif (!MEM_SIZE_KNOWN_P (mem) || !MEM_SIZE (mem).is_constant (&size))\n \t  return false;\n-\taddr = XEXP (mem, 0);\n-\tif (GET_CODE (addr) == PLUS\n-\t    && REG_P (XEXP (addr, 0))\n-\t    && CONST_INT_P (XEXP (addr, 1)))\n-\t  {\n-\t    off = INTVAL (XEXP (addr, 1));\n-\t    addr = XEXP (addr, 0);\n-\t  }\n-\tif (addr != stack_pointer_rtx)\n-\t  {\n-\t    if (!REG_P (addr))\n-\t      return false;\n-\t    /* If not fast, use chains to see if addr wasn't set to\n-\t       sp + offset.  */\n-\t    if (!fast)\n-\t      {\n-\t\tdf_ref use;\n-\t\tstruct df_link *defs;\n-\t\trtx set;\n-\n-\t\tFOR_EACH_INSN_USE (use, call_insn)\n-\t\t  if (rtx_equal_p (addr, DF_REF_REG (use)))\n-\t\t    break;\n-\n-\t\tif (use == NULL)\n-\t\t  return false;\n-\n-\t\tfor (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n-\t\t  if (! DF_REF_IS_ARTIFICIAL (defs->ref))\n-\t\t    break;\n-\n-\t\tif (defs == NULL)\n-\t\t  return false;\n-\n-\t\tset = single_set (DF_REF_INSN (defs->ref));\n-\t\tif (!set)\n-\t\t  return false;\n-\n-\t\tif (GET_CODE (SET_SRC (set)) != PLUS\n-\t\t    || XEXP (SET_SRC (set), 0) != stack_pointer_rtx\n-\t\t    || !CONST_INT_P (XEXP (SET_SRC (set), 1)))\n-\t\t  return false;\n-\n-\t\toff += INTVAL (XEXP (SET_SRC (set), 1));\n-\t      }\n-\t    else\n-\t      return false;\n-\t  }\n+\tHOST_WIDE_INT off = sp_based_mem_offset (call_insn, mem, fast);\n+\tif (off == INTTYPE_MINIMUM (HOST_WIDE_INT))\n+\t  return false;\n \tmin_sp_off = MIN (min_sp_off, off);\n \tmax_sp_off = MAX (max_sp_off, off + size);\n       }\n@@ -376,40 +383,14 @@ find_call_stack_args (rtx_call_insn *call_insn, bool do_mark, bool fast,\n     if (GET_CODE (XEXP (p, 0)) == USE\n \t&& MEM_P (XEXP (XEXP (p, 0), 0)))\n       {\n-\trtx mem = XEXP (XEXP (p, 0), 0), addr;\n-\tHOST_WIDE_INT off = 0, byte, size;\n+\trtx mem = XEXP (XEXP (p, 0), 0);\n \t/* Checked in the previous iteration.  */\n-\tsize = MEM_SIZE (mem).to_constant ();\n-\taddr = XEXP (mem, 0);\n-\tif (GET_CODE (addr) == PLUS\n-\t    && REG_P (XEXP (addr, 0))\n-\t    && CONST_INT_P (XEXP (addr, 1)))\n-\t  {\n-\t    off = INTVAL (XEXP (addr, 1));\n-\t    addr = XEXP (addr, 0);\n-\t  }\n-\tif (addr != stack_pointer_rtx)\n-\t  {\n-\t    df_ref use;\n-\t    struct df_link *defs;\n-\t    rtx set;\n-\n-\t    FOR_EACH_INSN_USE (use, call_insn)\n-\t      if (rtx_equal_p (addr, DF_REF_REG (use)))\n-\t\tbreak;\n-\n-\t    for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n-\t      if (! DF_REF_IS_ARTIFICIAL (defs->ref))\n-\t\tbreak;\n-\n-\t    set = single_set (DF_REF_INSN (defs->ref));\n-\t    off += INTVAL (XEXP (SET_SRC (set), 1));\n-\t  }\n-\tfor (byte = off; byte < off + size; byte++)\n-\t  {\n-\t    if (!bitmap_set_bit (sp_bytes, byte - min_sp_off))\n-\t      gcc_unreachable ();\n-\t  }\n+\tHOST_WIDE_INT size = MEM_SIZE (mem).to_constant ();\n+\tHOST_WIDE_INT off = sp_based_mem_offset (call_insn, mem, fast);\n+\tgcc_checking_assert (off != INTTYPE_MINIMUM (HOST_WIDE_INT));\n+\tfor (HOST_WIDE_INT byte = off; byte < off + size; byte++)\n+\t  if (!bitmap_set_bit (sp_bytes, byte - min_sp_off))\n+\t    gcc_unreachable ();\n       }\n \n   /* Walk backwards, looking for argument stores.  The search stops\n@@ -418,9 +399,6 @@ find_call_stack_args (rtx_call_insn *call_insn, bool do_mark, bool fast,\n   ret = false;\n   for (insn = PREV_INSN (call_insn); insn; insn = prev_insn)\n     {\n-      rtx set, mem, addr;\n-      HOST_WIDE_INT off;\n-\n       if (insn == BB_HEAD (BLOCK_FOR_INSN (call_insn)))\n \tprev_insn = NULL;\n       else\n@@ -432,61 +410,17 @@ find_call_stack_args (rtx_call_insn *call_insn, bool do_mark, bool fast,\n       if (!NONDEBUG_INSN_P (insn))\n \tcontinue;\n \n-      set = single_set (insn);\n+      rtx set = single_set (insn);\n       if (!set || SET_DEST (set) == stack_pointer_rtx)\n \tbreak;\n \n       if (!MEM_P (SET_DEST (set)))\n \tcontinue;\n \n-      mem = SET_DEST (set);\n-      addr = XEXP (mem, 0);\n-      off = 0;\n-      if (GET_CODE (addr) == PLUS\n-\t  && REG_P (XEXP (addr, 0))\n-\t  && CONST_INT_P (XEXP (addr, 1)))\n-\t{\n-\t  off = INTVAL (XEXP (addr, 1));\n-\t  addr = XEXP (addr, 0);\n-\t}\n-      if (addr != stack_pointer_rtx)\n-\t{\n-\t  if (!REG_P (addr))\n-\t    break;\n-\t  if (!fast)\n-\t    {\n-\t      df_ref use;\n-\t      struct df_link *defs;\n-\t      rtx set;\n-\n-\t      FOR_EACH_INSN_USE (use, insn)\n-\t\tif (rtx_equal_p (addr, DF_REF_REG (use)))\n-\t\t  break;\n-\n-\t      if (use == NULL)\n-\t\tbreak;\n-\n-\t      for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)\n-\t\tif (! DF_REF_IS_ARTIFICIAL (defs->ref))\n-\t\t  break;\n-\n-\t      if (defs == NULL)\n-\t\tbreak;\n-\n-\t      set = single_set (DF_REF_INSN (defs->ref));\n-\t      if (!set)\n-\t\tbreak;\n-\n-\t      if (GET_CODE (SET_SRC (set)) != PLUS\n-\t\t  || XEXP (SET_SRC (set), 0) != stack_pointer_rtx\n-\t\t  || !CONST_INT_P (XEXP (SET_SRC (set), 1)))\n-\t\tbreak;\n-\n-\t      off += INTVAL (XEXP (SET_SRC (set), 1));\n-\t    }\n-\t  else\n-\t    break;\n-\t}\n+      rtx mem = SET_DEST (set);\n+      HOST_WIDE_INT off = sp_based_mem_offset (call_insn, mem, fast);\n+      if (off == INTTYPE_MINIMUM (HOST_WIDE_INT))\n+\tbreak;\n \n       HOST_WIDE_INT size;\n       if (!MEM_SIZE_KNOWN_P (mem)"}]}