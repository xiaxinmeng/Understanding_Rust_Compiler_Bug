{"sha": "b2cb7511d481023b65b743ef4db855354e752406", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJjYjc1MTFkNDgxMDIzYjY1Yjc0M2VmNGRiODU1MzU0ZTc1MjQwNg==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2012-04-17T18:28:42Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2012-04-17T18:28:42Z"}, "message": "cp-gimplify.c (begin_bc_block): Add location parameter and use as location argument to create_artificial_label.\n\n2012-04-17  Tom de Vries  <tom@codesourcery.com>\n\n\t* cp-gimplify.c (begin_bc_block): Add location parameter and use as\n\tlocation argument to create_artificial_label.\n\t(finish_bc_block): Change return type to void.  Remove body_seq\n\tparameter, and add block parameter.  Append label to STMT_LIST and\n\treturn in block.\n\t(gimplify_cp_loop, gimplify_for_stmt, gimplify_while_stmt)\n\t(gimplify_do_stmt, gimplify_switch_stmt): Remove function.\n\t(genericize_cp_loop, genericize_for_stmt, genericize_while_stmt)\n\t(genericize_do_stmt, genericize_switch_stmt, genericize_continue_stmt)\n\t(genericize_break_stmt, genericize_omp_for_stmt): New function.\n\t(cp_gimplify_omp_for): Remove bc_continue processing.\n\t(cp_gimplify_expr): Genericize VEC_INIT_EXPR.\n\t(cp_gimplify_expr): Mark FOR_STMT, WHILE_STMT, DO_STMT, SWITCH_STMT,\n\tCONTINUE_STMT, and BREAK_STMT as unreachable.\n\t(cp_genericize_r): Genericize FOR_STMT, WHILE_STMT, DO_STMT,\n\tSWITCH_STMT, CONTINUE_STMT, BREAK_STMT and OMP_FOR.\n\t(cp_genericize_tree): New function, factored out of ...\n\t(cp_genericize): ... this function.\n\nFrom-SVN: r186546", "tree": {"sha": "ebc67b179a4f2a68530c232229b1027034a7374d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebc67b179a4f2a68530c232229b1027034a7374d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2cb7511d481023b65b743ef4db855354e752406", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2cb7511d481023b65b743ef4db855354e752406", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2cb7511d481023b65b743ef4db855354e752406", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2cb7511d481023b65b743ef4db855354e752406/comments", "author": null, "committer": null, "parents": [{"sha": "a60596b8e5f844177a4abbb0f02b0575d3c4b1cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a60596b8e5f844177a4abbb0f02b0575d3c4b1cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a60596b8e5f844177a4abbb0f02b0575d3c4b1cb"}], "stats": {"total": 353, "additions": 200, "deletions": 153}, "files": [{"sha": "8619b26e50703e5a53ec4e99e609897b273a3895", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2cb7511d481023b65b743ef4db855354e752406/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2cb7511d481023b65b743ef4db855354e752406/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b2cb7511d481023b65b743ef4db855354e752406", "patch": "@@ -1,3 +1,24 @@\n+2012-04-17  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* cp-gimplify.c (begin_bc_block): Add location parameter and use as\n+\tlocation argument to create_artificial_label.\n+\t(finish_bc_block): Change return type to void.  Remove body_seq\n+\tparameter, and add block parameter.  Append label to STMT_LIST and\n+\treturn in block.\n+\t(gimplify_cp_loop, gimplify_for_stmt, gimplify_while_stmt)\n+\t(gimplify_do_stmt, gimplify_switch_stmt): Remove function.\n+\t(genericize_cp_loop, genericize_for_stmt, genericize_while_stmt)\n+\t(genericize_do_stmt, genericize_switch_stmt, genericize_continue_stmt)\n+\t(genericize_break_stmt, genericize_omp_for_stmt): New function.\n+\t(cp_gimplify_omp_for): Remove bc_continue processing.\n+\t(cp_gimplify_expr): Genericize VEC_INIT_EXPR.\n+\t(cp_gimplify_expr): Mark FOR_STMT, WHILE_STMT, DO_STMT, SWITCH_STMT,\n+\tCONTINUE_STMT, and BREAK_STMT as unreachable.\n+\t(cp_genericize_r): Genericize FOR_STMT, WHILE_STMT, DO_STMT,\n+\tSWITCH_STMT, CONTINUE_STMT, BREAK_STMT and OMP_FOR.\n+\t(cp_genericize_tree): New function, factored out of ...\n+\t(cp_genericize): ... this function.\n+\n 2012-04-17  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/52599"}, {"sha": "416c640c68cb03a86d7237cba6114c641d2c5c91", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 179, "deletions": 153, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2cb7511d481023b65b743ef4db855354e752406/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2cb7511d481023b65b743ef4db855354e752406/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=b2cb7511d481023b65b743ef4db855354e752406", "patch": "@@ -34,6 +34,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"splay-tree.h\"\n \n+/* Forward declarations.  */\n+\n+static tree cp_genericize_r (tree *, int *, void *);\n+static void cp_genericize_tree (tree*);\n+\n /* Local declarations.  */\n \n enum bc_t { bc_break = 0, bc_continue = 1 };\n@@ -45,37 +50,36 @@ static tree bc_label[2];\n /* Begin a scope which can be exited by a break or continue statement.  BC\n    indicates which.\n \n-   Just creates a label and pushes it into the current context.  */\n+   Just creates a label with location LOCATION and pushes it into the current\n+   context.  */\n \n static tree\n-begin_bc_block (enum bc_t bc)\n+begin_bc_block (enum bc_t bc, location_t location)\n {\n-  tree label = create_artificial_label (input_location);\n+  tree label = create_artificial_label (location);\n   DECL_CHAIN (label) = bc_label[bc];\n   bc_label[bc] = label;\n   return label;\n }\n \n /* Finish a scope which can be exited by a break or continue statement.\n-   LABEL was returned from the most recent call to begin_bc_block.  BODY is\n+   LABEL was returned from the most recent call to begin_bc_block.  BLOCK is\n    an expression for the contents of the scope.\n \n    If we saw a break (or continue) in the scope, append a LABEL_EXPR to\n-   body.  Otherwise, just forget the label.  */\n+   BLOCK.  Otherwise, just forget the label.  */\n \n-static gimple_seq\n-finish_bc_block (enum bc_t bc, tree label, gimple_seq body)\n+static void\n+finish_bc_block (tree *block, enum bc_t bc, tree label)\n {\n   gcc_assert (label == bc_label[bc]);\n \n   if (TREE_USED (label))\n-    {\n-      gimple_seq_add_stmt (&body, gimple_build_label (label));\n-    }\n+    append_to_statement_list (build1 (LABEL_EXPR, void_type_node, label),\n+\t\t\t      block);\n \n   bc_label[bc] = DECL_CHAIN (label);\n   DECL_CHAIN (label) = NULL_TREE;\n-  return body;\n }\n \n /* Get the LABEL_EXPR to represent a break or continue statement\n@@ -183,192 +187,215 @@ genericize_if_stmt (tree *stmt_p)\n    evaluated before the loop body as in while and for loops, or after the\n    loop body as in do-while loops.  */\n \n-static gimple_seq\n-gimplify_cp_loop (tree cond, tree body, tree incr, bool cond_is_first)\n+static void\n+genericize_cp_loop (tree *stmt_p, location_t start_locus, tree cond, tree body,\n+\t\t    tree incr, bool cond_is_first, int *walk_subtrees,\n+\t\t    void *data)\n {\n-  gimple top, entry, stmt;\n-  gimple_seq stmt_list, body_seq, incr_seq, exit_seq;\n-  tree cont_block, break_block;\n-  location_t stmt_locus;\n+  tree blab, clab;\n+  tree entry = NULL, exit = NULL, t;\n+  tree stmt_list = NULL;\n+\n+  blab = begin_bc_block (bc_break, start_locus);\n+  clab = begin_bc_block (bc_continue, start_locus);\n \n-  stmt_locus = input_location;\n-  stmt_list = NULL;\n-  body_seq = NULL;\n-  incr_seq = NULL;\n-  exit_seq = NULL;\n-  entry = NULL;\n+  if (incr && EXPR_P (incr))\n+    SET_EXPR_LOCATION (incr, start_locus);\n \n-  break_block = begin_bc_block (bc_break);\n-  cont_block = begin_bc_block (bc_continue);\n+  cp_walk_tree (&cond, cp_genericize_r, data, NULL);\n+  cp_walk_tree (&body, cp_genericize_r, data, NULL);\n+  cp_walk_tree (&incr, cp_genericize_r, data, NULL);\n+  *walk_subtrees = 0;\n \n   /* If condition is zero don't generate a loop construct.  */\n   if (cond && integer_zerop (cond))\n     {\n-      top = NULL;\n       if (cond_is_first)\n \t{\n-\t  stmt = gimple_build_goto (get_bc_label (bc_break));\n-\t  gimple_set_location (stmt, stmt_locus);\n-\t  gimple_seq_add_stmt (&stmt_list, stmt);\n+\t  t = build1_loc (start_locus, GOTO_EXPR, void_type_node,\n+\t\t\t  get_bc_label (bc_break));\n+\t  append_to_statement_list (t, &stmt_list);\n \t}\n     }\n   else\n     {\n-      /* If we use a LOOP_EXPR here, we have to feed the whole thing\n-\t back through the main gimplifier to lower it.  Given that we\n-\t have to gimplify the loop body NOW so that we can resolve\n-\t break/continue stmts, seems easier to just expand to gotos.  */\n-      top = gimple_build_label (create_artificial_label (stmt_locus));\n+      /* Expand to gotos, just like c_finish_loop.  TODO: Use LOOP_EXPR.  */\n+      tree top = build1 (LABEL_EXPR, void_type_node,\n+\t\t\t create_artificial_label (start_locus));\n \n       /* If we have an exit condition, then we build an IF with gotos either\n \t out of the loop, or to the top of it.  If there's no exit condition,\n \t then we just build a jump back to the top.  */\n+      exit = build1 (GOTO_EXPR, void_type_node, LABEL_EXPR_LABEL (top));\n+\n       if (cond && !integer_nonzerop (cond))\n \t{\n-\t  if (cond != error_mark_node)\n-\t    { \n-\t      gimplify_expr (&cond, &exit_seq, NULL, is_gimple_val, fb_rvalue);\n-\t      stmt = gimple_build_cond (NE_EXPR, cond,\n-\t\t\t\t\tbuild_int_cst (TREE_TYPE (cond), 0),\n-\t\t\t\t\tgimple_label_label (top),\n-\t\t\t\t\tget_bc_label (bc_break));\n-\t      gimple_seq_add_stmt (&exit_seq, stmt);\n-\t    }\n-\n+\t  /* Canonicalize the loop condition to the end.  This means\n+\t     generating a branch to the loop condition.  Reuse the\n+\t     continue label, if possible.  */\n \t  if (cond_is_first)\n \t    {\n \t      if (incr)\n \t\t{\n-\t\t  entry = gimple_build_label \n-\t\t    (create_artificial_label (stmt_locus));\n-\t\t  stmt = gimple_build_goto (gimple_label_label (entry));\n+\t\t  entry = build1 (LABEL_EXPR, void_type_node,\n+\t\t\t\t  create_artificial_label (start_locus));\n+\t\t  t = build1_loc (start_locus, GOTO_EXPR, void_type_node,\n+\t\t\t\t  LABEL_EXPR_LABEL (entry));\n \t\t}\n \t      else\n-\t\tstmt = gimple_build_goto (get_bc_label (bc_continue));\n-\t      gimple_set_location (stmt, stmt_locus);\n-\t      gimple_seq_add_stmt (&stmt_list, stmt);\n+\t\tt = build1_loc (start_locus, GOTO_EXPR, void_type_node,\n+\t\t\t\tget_bc_label (bc_continue));\n+\t      append_to_statement_list (t, &stmt_list);\n \t    }\n-\t}\n-      else\n-\t{\n-\t  stmt = gimple_build_goto (gimple_label_label (top));\n-\t  gimple_seq_add_stmt (&exit_seq, stmt);\n-\t}\n-    }\n \n-  gimplify_stmt (&body, &body_seq);\n-  gimplify_stmt (&incr, &incr_seq);\n+\t  t = build1 (GOTO_EXPR, void_type_node, get_bc_label (bc_break));\n+\t  exit = fold_build3_loc (start_locus,\n+\t\t\t\t  COND_EXPR, void_type_node, cond, exit, t);\n+\t}\n \n-  body_seq = finish_bc_block (bc_continue, cont_block, body_seq);\n+      append_to_statement_list (top, &stmt_list);\n+    }\n \n-  gimple_seq_add_stmt (&stmt_list, top);\n-  gimple_seq_add_seq (&stmt_list, body_seq);\n-  gimple_seq_add_seq (&stmt_list, incr_seq);\n-  gimple_seq_add_stmt (&stmt_list, entry);\n-  gimple_seq_add_seq (&stmt_list, exit_seq);\n+  append_to_statement_list (body, &stmt_list);\n+  finish_bc_block (&stmt_list, bc_continue, clab);\n+  append_to_statement_list (incr, &stmt_list);\n+  append_to_statement_list (entry, &stmt_list);\n+  append_to_statement_list (exit, &stmt_list);\n+  finish_bc_block (&stmt_list, bc_break, blab);\n \n-  annotate_all_with_location (stmt_list, stmt_locus);\n+  if (stmt_list == NULL_TREE)\n+    stmt_list = build1 (NOP_EXPR, void_type_node, integer_zero_node);\n \n-  return finish_bc_block (bc_break, break_block, stmt_list);\n+  *stmt_p = stmt_list;\n }\n \n-/* Gimplify a FOR_STMT node.  Move the stuff in the for-init-stmt into the\n-   prequeue and hand off to gimplify_cp_loop.  */\n+/* Genericize a FOR_STMT node *STMT_P.  */\n \n static void\n-gimplify_for_stmt (tree *stmt_p, gimple_seq *pre_p)\n+genericize_for_stmt (tree *stmt_p, int *walk_subtrees, void *data)\n {\n   tree stmt = *stmt_p;\n+  tree expr = NULL;\n+  tree loop;\n+  tree init = FOR_INIT_STMT (stmt);\n \n-  if (FOR_INIT_STMT (stmt))\n-    gimplify_and_add (FOR_INIT_STMT (stmt), pre_p);\n+  if (init)\n+    {\n+      cp_walk_tree (&init, cp_genericize_r, data, NULL);\n+      append_to_statement_list (init, &expr);\n+    }\n \n-  gimple_seq_add_seq (pre_p,\n-\t\t      gimplify_cp_loop (FOR_COND (stmt), FOR_BODY (stmt),\n-\t\t\t\t\tFOR_EXPR (stmt), 1));\n-  *stmt_p = NULL_TREE;\n+  genericize_cp_loop (&loop, EXPR_LOCATION (stmt), FOR_COND (stmt),\n+\t\t      FOR_BODY (stmt), FOR_EXPR (stmt), 1, walk_subtrees, data);\n+  append_to_statement_list (loop, &expr);\n+  *stmt_p = expr;\n }\n \n-/* Gimplify a WHILE_STMT node.  */\n+/* Genericize a WHILE_STMT node *STMT_P.  */\n \n static void\n-gimplify_while_stmt (tree *stmt_p, gimple_seq *pre_p)\n+genericize_while_stmt (tree *stmt_p, int *walk_subtrees, void *data)\n {\n   tree stmt = *stmt_p;\n-  gimple_seq_add_seq (pre_p,\n-\t\t      gimplify_cp_loop (WHILE_COND (stmt), WHILE_BODY (stmt),\n-\t\t\t\t\tNULL_TREE, 1));\n-  *stmt_p = NULL_TREE;\n+  genericize_cp_loop (stmt_p, EXPR_LOCATION (stmt), WHILE_COND (stmt),\n+\t\t      WHILE_BODY (stmt), NULL_TREE, 1, walk_subtrees, data);\n }\n \n-/* Gimplify a DO_STMT node.  */\n+/* Genericize a DO_STMT node *STMT_P.  */\n \n static void\n-gimplify_do_stmt (tree *stmt_p, gimple_seq *pre_p)\n+genericize_do_stmt (tree *stmt_p, int *walk_subtrees, void *data)\n {\n   tree stmt = *stmt_p;\n-  gimple_seq_add_seq (pre_p,\n-\t\t      gimplify_cp_loop (DO_COND (stmt), DO_BODY (stmt),\n-\t\t\t\t\tNULL_TREE, 0));\n-  *stmt_p = NULL_TREE;\n+  genericize_cp_loop (stmt_p, EXPR_LOCATION (stmt), DO_COND (stmt),\n+\t\t      DO_BODY (stmt), NULL_TREE, 0, walk_subtrees, data);\n }\n \n-/* Genericize a SWITCH_STMT by turning it into a SWITCH_EXPR.  */\n+/* Genericize a SWITCH_STMT node *STMT_P by turning it into a SWITCH_EXPR.  */\n \n static void\n-gimplify_switch_stmt (tree *stmt_p, gimple_seq *pre_p)\n+genericize_switch_stmt (tree *stmt_p, int *walk_subtrees, void *data)\n {\n   tree stmt = *stmt_p;\n-  tree break_block, body, t;\n-  location_t stmt_locus = input_location;\n-  gimple_seq seq = NULL;\n+  tree break_block, body, cond, type;\n+  location_t stmt_locus = EXPR_LOCATION (stmt);\n \n-  break_block = begin_bc_block (bc_break);\n+  break_block = begin_bc_block (bc_break, stmt_locus);\n \n   body = SWITCH_STMT_BODY (stmt);\n   if (!body)\n     body = build_empty_stmt (stmt_locus);\n+  cond = SWITCH_STMT_COND (stmt);\n+  type = SWITCH_STMT_TYPE (stmt);\n \n-  t = build3 (SWITCH_EXPR, SWITCH_STMT_TYPE (stmt),\n-\t      SWITCH_STMT_COND (stmt), body, NULL_TREE);\n-  SET_EXPR_LOCATION (t, stmt_locus);\n-  gimplify_and_add (t, &seq);\n+  cp_walk_tree (&body, cp_genericize_r, data, NULL);\n+  cp_walk_tree (&cond, cp_genericize_r, data, NULL);\n+  cp_walk_tree (&type, cp_genericize_r, data, NULL);\n+  *walk_subtrees = 0;\n \n-  seq = finish_bc_block (bc_break, break_block, seq);\n-  gimple_seq_add_seq (pre_p, seq);\n-  *stmt_p = NULL_TREE;\n+  *stmt_p = build3_loc (stmt_locus, SWITCH_EXPR, type, cond, body, NULL_TREE);\n+  finish_bc_block (stmt_p, bc_break, break_block);\n+}\n+\n+/* Genericize a CONTINUE_STMT node *STMT_P.  */\n+\n+static void\n+genericize_continue_stmt (tree *stmt_p)\n+{\n+  tree stmt_list = NULL;\n+  tree pred = build_predict_expr (PRED_CONTINUE, NOT_TAKEN);\n+  tree label = get_bc_label (bc_continue);\n+  location_t location = EXPR_LOCATION (*stmt_p);\n+  tree jump = build1_loc (location, GOTO_EXPR, void_type_node, label);\n+  append_to_statement_list (pred, &stmt_list);\n+  append_to_statement_list (jump, &stmt_list);\n+  *stmt_p = stmt_list;\n }\n \n-/* Hook into the middle of gimplifying an OMP_FOR node.  This is required\n-   in order to properly gimplify CONTINUE statements.  Here we merely\n-   manage the continue stack; the rest of the job is performed by the\n-   regular gimplifier.  */\n+/* Genericize a BREAK_STMT node *STMT_P.  */\n+\n+static void\n+genericize_break_stmt (tree *stmt_p)\n+{\n+  tree label = get_bc_label (bc_break);\n+  location_t location = EXPR_LOCATION (*stmt_p);\n+  *stmt_p = build1_loc (location, GOTO_EXPR, void_type_node, label);\n+}\n+\n+/* Genericize a OMP_FOR node *STMT_P.  */\n+\n+static void\n+genericize_omp_for_stmt (tree *stmt_p, int *walk_subtrees, void *data)\n+{\n+  tree stmt = *stmt_p;\n+  location_t locus = EXPR_LOCATION (stmt);\n+  tree clab = begin_bc_block (bc_continue, locus);\n+\n+  cp_walk_tree (&OMP_FOR_BODY (stmt), cp_genericize_r, data, NULL);\n+  cp_walk_tree (&OMP_FOR_CLAUSES (stmt), cp_genericize_r, data, NULL);\n+  cp_walk_tree (&OMP_FOR_INIT (stmt), cp_genericize_r, data, NULL);\n+  cp_walk_tree (&OMP_FOR_COND (stmt), cp_genericize_r, data, NULL);\n+  cp_walk_tree (&OMP_FOR_INCR (stmt), cp_genericize_r, data, NULL);\n+  cp_walk_tree (&OMP_FOR_PRE_BODY (stmt), cp_genericize_r, data, NULL);\n+  *walk_subtrees = 0;\n+\n+  finish_bc_block (&OMP_FOR_BODY (stmt), bc_continue, clab);\n+}\n+\n+/* Hook into the middle of gimplifying an OMP_FOR node.  */\n \n static enum gimplify_status\n cp_gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n {\n   tree for_stmt = *expr_p;\n-  tree cont_block;\n-  gimple stmt;\n   gimple_seq seq = NULL;\n \n   /* Protect ourselves from recursion.  */\n   if (OMP_FOR_GIMPLIFYING_P (for_stmt))\n     return GS_UNHANDLED;\n   OMP_FOR_GIMPLIFYING_P (for_stmt) = 1;\n \n-  /* Note that while technically the continue label is enabled too soon\n-     here, we should have already diagnosed invalid continues nested within\n-     statement expressions within the INIT, COND, or INCR expressions.  */\n-  cont_block = begin_bc_block (bc_continue);\n-\n   gimplify_and_add (for_stmt, &seq);\n-  stmt = gimple_seq_last_stmt (seq);\n-  if (gimple_code (stmt) == GIMPLE_OMP_FOR)\n-    gimple_omp_set_body (stmt, finish_bc_block (bc_continue, cont_block,\n-\t\t\t\t\t\tgimple_omp_body (stmt)));\n-  else\n-    seq = finish_bc_block (bc_continue, cont_block, seq);\n   gimple_seq_add_seq (pre_p, seq);\n \n   OMP_FOR_GIMPLIFYING_P (for_stmt) = 0;\n@@ -528,6 +555,7 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t\t\t\t  init, VEC_INIT_EXPR_VALUE_INIT (*expr_p),\n \t\t\t\t  from_array,\n \t\t\t\t  tf_warning_or_error);\n+\tcp_genericize_tree (expr_p);\n \tret = GS_OK;\n \tinput_location = loc;\n       }\n@@ -634,42 +662,17 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       gcc_unreachable ();\n \n     case FOR_STMT:\n-      gimplify_for_stmt (expr_p, pre_p);\n-      ret = GS_OK;\n-      break;\n-\n     case WHILE_STMT:\n-      gimplify_while_stmt (expr_p, pre_p);\n-      ret = GS_OK;\n-      break;\n-\n     case DO_STMT:\n-      gimplify_do_stmt (expr_p, pre_p);\n-      ret = GS_OK;\n-      break;\n-\n     case SWITCH_STMT:\n-      gimplify_switch_stmt (expr_p, pre_p);\n-      ret = GS_OK;\n-      break;\n+    case CONTINUE_STMT:\n+    case BREAK_STMT:\n+      gcc_unreachable ();\n \n     case OMP_FOR:\n       ret = cp_gimplify_omp_for (expr_p, pre_p);\n       break;\n \n-    case CONTINUE_STMT:\n-      gimple_seq_add_stmt (pre_p, gimple_build_predict (PRED_CONTINUE, NOT_TAKEN));\n-      gimple_seq_add_stmt (pre_p, gimple_build_goto (get_bc_label (bc_continue)));\n-      *expr_p = NULL_TREE;\n-      ret = GS_ALL_DONE;\n-      break;\n-\n-    case BREAK_STMT:\n-      gimple_seq_add_stmt (pre_p, gimple_build_goto (get_bc_label (bc_break)));\n-      *expr_p = NULL_TREE;\n-      ret = GS_ALL_DONE;\n-      break;\n-\n     case EXPR_STMT:\n       gimplify_expr_stmt (expr_p);\n       ret = GS_OK;\n@@ -1102,17 +1105,45 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n     }\n   else if (TREE_CODE (stmt) == CONVERT_EXPR)\n     gcc_assert (!CONVERT_EXPR_VBASE_PATH (stmt));\n+  else if (TREE_CODE (stmt) == FOR_STMT)\n+    genericize_for_stmt (stmt_p, walk_subtrees, data);\n+  else if (TREE_CODE (stmt) == WHILE_STMT)\n+    genericize_while_stmt (stmt_p, walk_subtrees, data);\n+  else if (TREE_CODE (stmt) == DO_STMT)\n+    genericize_do_stmt (stmt_p, walk_subtrees, data);\n+  else if (TREE_CODE (stmt) == SWITCH_STMT)\n+    genericize_switch_stmt (stmt_p, walk_subtrees, data);\n+  else if (TREE_CODE (stmt) == CONTINUE_STMT)\n+    genericize_continue_stmt (stmt_p);\n+  else if (TREE_CODE (stmt) == BREAK_STMT)\n+    genericize_break_stmt (stmt_p);\n+  else if (TREE_CODE (stmt) == OMP_FOR)\n+    genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n \n   pointer_set_insert (p_set, *stmt_p);\n \n   return NULL;\n }\n \n+/* Lower C++ front end trees to GENERIC in T_P.  */\n+\n+static void\n+cp_genericize_tree (tree* t_p)\n+{\n+  struct cp_genericize_data wtd;\n+\n+  wtd.p_set = pointer_set_create ();\n+  wtd.bind_expr_stack = NULL;\n+  wtd.omp_ctx = NULL;\n+  cp_walk_tree (t_p, cp_genericize_r, &wtd, NULL);\n+  pointer_set_destroy (wtd.p_set);\n+  VEC_free (tree, heap, wtd.bind_expr_stack);\n+}\n+\n void\n cp_genericize (tree fndecl)\n {\n   tree t;\n-  struct cp_genericize_data wtd;\n \n   /* Fix up the types of parms passed by invisible reference.  */\n   for (t = DECL_ARGUMENTS (fndecl); t; t = DECL_CHAIN (t))\n@@ -1163,12 +1194,7 @@ cp_genericize (tree fndecl)\n \n   /* We do want to see every occurrence of the parms, so we can't just use\n      walk_tree's hash functionality.  */\n-  wtd.p_set = pointer_set_create ();\n-  wtd.bind_expr_stack = NULL;\n-  wtd.omp_ctx = NULL;\n-  cp_walk_tree (&DECL_SAVED_TREE (fndecl), cp_genericize_r, &wtd, NULL);\n-  pointer_set_destroy (wtd.p_set);\n-  VEC_free (tree, heap, wtd.bind_expr_stack);\n+  cp_genericize_tree (&DECL_SAVED_TREE (fndecl));\n \n   /* Do everything else.  */\n   c_genericize (fndecl);"}]}