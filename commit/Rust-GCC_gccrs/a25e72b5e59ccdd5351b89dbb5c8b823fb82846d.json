{"sha": "a25e72b5e59ccdd5351b89dbb5c8b823fb82846d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI1ZTcyYjVlNTljY2RkNTM1MWI4OWRiYjVjOGI4MjNmYjgyODQ2ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-18T10:40:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-18T10:40:47Z"}, "message": "[multiple changes]\n\n2015-11-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_aggr.adb (Is_Completely_Hidden_Discriminant): New routine.\n\t(Init_Hidden_Discriminants): Code reformatting. Do not initialize\n\ta completely hidden discriminant.\n\t* a-interr.ads (Get_CPU): Added SPARK_Mode, Volatile_Function\n\tand Global aspects on the function.\n\n2015-11-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_intr.adb (Expand_Unc_Deallocation): If the designated\n\ttype is a concurrent type, the deallocation applies to the\n\tcorresponding record type, or to its class-wide type if the type\n\tis tagged.\n\nFrom-SVN: r230535", "tree": {"sha": "8a79cecab9c05ea0b3d7ce408ecacb4c89496b73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a79cecab9c05ea0b3d7ce408ecacb4c89496b73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d/comments", "author": null, "committer": null, "parents": [{"sha": "86e066aa7a971af4b8e9deeb853bc3b3a2b479bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86e066aa7a971af4b8e9deeb853bc3b3a2b479bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86e066aa7a971af4b8e9deeb853bc3b3a2b479bd"}], "stats": {"total": 159, "additions": 121, "deletions": 38}, "files": [{"sha": "54ec26331a524ad6bf33a34c3160cff6ffa07e23", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a25e72b5e59ccdd5351b89dbb5c8b823fb82846d", "patch": "@@ -1,3 +1,18 @@\n+2015-11-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_aggr.adb (Is_Completely_Hidden_Discriminant): New routine.\n+\t(Init_Hidden_Discriminants): Code reformatting. Do not initialize\n+\ta completely hidden discriminant.\n+\t* a-interr.ads (Get_CPU): Added SPARK_Mode, Volatile_Function\n+\tand Global aspects on the function.\n+\n+2015-11-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_intr.adb (Expand_Unc_Deallocation): If the designated\n+\ttype is a concurrent type, the deallocation applies to the\n+\tcorresponding record type, or to its class-wide type if the type\n+\tis tagged.\n+\n 2015-11-18  Doug Rupp  <rupp@adacore.com>\n \n \t* s-parame-vxworks.adb: Reduce default stack size for stack"}, {"sha": "562f278144708cc6239cb8bfad4821b42ad9bc5e", "filename": "gcc/ada/a-interr.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d/gcc%2Fada%2Fa-interr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d/gcc%2Fada%2Fa-interr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-interr.ads?ref=a25e72b5e59ccdd5351b89dbb5c8b823fb82846d", "patch": "@@ -83,7 +83,11 @@ package Ada.Interrupts is\n      Global     => null;\n \n    function Get_CPU\n-     (Interrupt : Interrupt_ID) return System.Multiprocessors.CPU_Range;\n+     (Interrupt : Interrupt_ID) return System.Multiprocessors.CPU_Range\n+   with\n+     SPARK_Mode,\n+     Volatile_Function,\n+     Global => Ada.Task_Identification.Tasking_State;\n \n private\n    pragma Inline (Is_Reserved);"}, {"sha": "002579bf36613aff7f725971b610e1fdd80022c8", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 92, "deletions": 35, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=a25e72b5e59ccdd5351b89dbb5c8b823fb82846d", "patch": "@@ -2124,11 +2124,51 @@ package body Exp_Aggr is\n       -------------------------------\n \n       procedure Init_Hidden_Discriminants (Typ : Entity_Id; List : List_Id) is\n-         Btype        : Entity_Id;\n-         Parent_Type  : Entity_Id;\n-         Disc         : Entity_Id;\n-         Discr_Val    : Elmt_Id;\n+         function Is_Completely_Hidden_Discriminant\n+           (Discr : Entity_Id) return Boolean;\n+         --  Determine whether Discr is a completely hidden discriminant of\n+         --  type Typ.\n+\n+         ---------------------------------------\n+         -- Is_Completely_Hidden_Discriminant --\n+         ---------------------------------------\n+\n+         function Is_Completely_Hidden_Discriminant\n+           (Discr : Entity_Id) return Boolean\n+         is\n+            Item : Entity_Id;\n+\n+         begin\n+            --  Use First/Next_Entity as First/Next_Discriminant do not yield\n+            --  completely hidden discriminants.\n+\n+            Item := First_Entity (Typ);\n+            while Present (Item) loop\n+               if Ekind (Item) = E_Discriminant\n+                 and then Is_Completely_Hidden (Item)\n+                 and then Chars (Original_Record_Component (Item)) =\n+                          Chars (Discr)\n+               then\n+                  return True;\n+               end if;\n+\n+               Next_Entity (Item);\n+            end loop;\n+\n+            return False;\n+         end Is_Completely_Hidden_Discriminant;\n+\n+         --  Local variables\n+\n+         Base_Typ     : Entity_Id;\n+         Discr        : Entity_Id;\n+         Discr_Constr : Elmt_Id;\n+         Discr_Init   : Node_Id;\n+         Discr_Val    : Node_Id;\n          In_Aggr_Type : Boolean;\n+         Par_Typ      : Entity_Id;\n+\n+      --  Start of processing for Init_Hidden_Discriminants\n \n       begin\n          --  The constraints on the hidden discriminants, if present, are kept\n@@ -2139,67 +2179,84 @@ package body Exp_Aggr is\n \n          In_Aggr_Type := True;\n \n-         Btype := Base_Type (Typ);\n-         while Is_Derived_Type (Btype)\n+         Base_Typ := Base_Type (Typ);\n+         while Is_Derived_Type (Base_Typ)\n            and then\n-             (Present (Stored_Constraint (Btype))\n+             (Present (Stored_Constraint (Base_Typ))\n                or else\n                  (In_Aggr_Type and then Present (Stored_Constraint (Typ))))\n          loop\n-            Parent_Type := Etype (Btype);\n+            Par_Typ := Etype (Base_Typ);\n \n-            if not Has_Discriminants (Parent_Type) then\n+            if not Has_Discriminants (Par_Typ) then\n                return;\n             end if;\n \n-            Disc := First_Discriminant (Parent_Type);\n+            Discr := First_Discriminant (Par_Typ);\n \n             --  We know that one of the stored-constraint lists is present\n \n-            if Present (Stored_Constraint (Btype)) then\n-               Discr_Val := First_Elmt (Stored_Constraint (Btype));\n+            if Present (Stored_Constraint (Base_Typ)) then\n+               Discr_Constr := First_Elmt (Stored_Constraint (Base_Typ));\n \n             --  For private extension, stored constraint may be on full view\n \n-            elsif Is_Private_Type (Btype)\n-              and then Present (Full_View (Btype))\n-              and then Present (Stored_Constraint (Full_View (Btype)))\n+            elsif Is_Private_Type (Base_Typ)\n+              and then Present (Full_View (Base_Typ))\n+              and then Present (Stored_Constraint (Full_View (Base_Typ)))\n             then\n-               Discr_Val := First_Elmt (Stored_Constraint (Full_View (Btype)));\n+               Discr_Constr :=\n+                 First_Elmt (Stored_Constraint (Full_View (Base_Typ)));\n \n             else\n-               Discr_Val := First_Elmt (Stored_Constraint (Typ));\n+               Discr_Constr := First_Elmt (Stored_Constraint (Typ));\n             end if;\n \n-            while Present (Discr_Val) and then Present (Disc) loop\n+            while Present (Discr) and then Present (Discr_Constr) loop\n+               Discr_Val := Node (Discr_Constr);\n \n-               --  Only those discriminants of the parent that are not\n-               --  renamed by discriminants of the derived type need to\n-               --  be added explicitly.\n+               --  The parent discriminant is renamed in the derived type,\n+               --  nothing to initialize.\n \n-               if not Is_Entity_Name (Node (Discr_Val))\n-                 or else Ekind (Entity (Node (Discr_Val))) /= E_Discriminant\n+               --    type Deriv_Typ (Discr : ...)\n+               --      is new Parent_Typ (Discr => Discr);\n+\n+               if Is_Entity_Name (Discr_Val)\n+                 and then Ekind (Entity (Discr_Val)) = E_Discriminant\n                then\n-                  Comp_Expr :=\n-                    Make_Selected_Component (Loc,\n-                      Prefix        => New_Copy_Tree (Target),\n-                      Selector_Name => New_Occurrence_Of (Disc, Loc));\n+                  null;\n \n-                  Instr :=\n+               --  When the parent discriminant is constrained at the type\n+               --  extension level, it does not appear in the derived type.\n+\n+               --    type Deriv_Typ (Discr : ...)\n+               --      is new Parent_Typ (Discr        => Discr,\n+               --                         Hidden_Discr => Expression);\n+\n+               elsif Is_Completely_Hidden_Discriminant (Discr) then\n+                  null;\n+\n+               --  Otherwise initialize the discriminant\n+\n+               else\n+                  Discr_Init :=\n                     Make_OK_Assignment_Statement (Loc,\n-                      Name       => Comp_Expr,\n-                      Expression => New_Copy_Tree (Node (Discr_Val)));\n+                      Name       =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix        => New_Copy_Tree (Target),\n+                          Selector_Name => New_Occurrence_Of (Discr, Loc)),\n+                      Expression => New_Copy_Tree (Discr_Val));\n \n-                  Set_No_Ctrl_Actions (Instr);\n-                  Append_To (List, Instr);\n+                  Set_No_Ctrl_Actions (Discr_Init);\n+                  Append_To (List, Discr_Init);\n                end if;\n \n-               Next_Discriminant (Disc);\n-               Next_Elmt (Discr_Val);\n+               Next_Elmt (Discr_Constr);\n+               Next_Discriminant (Discr);\n             end loop;\n \n             In_Aggr_Type := False;\n-            Btype := Base_Type (Parent_Type);\n+            Base_Typ := Base_Type (Par_Typ);\n          end loop;\n       end Init_Hidden_Discriminants;\n "}, {"sha": "beaa24af9e5f27951668d16b6cfd6fc126ff7cb1", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a25e72b5e59ccdd5351b89dbb5c8b823fb82846d/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=a25e72b5e59ccdd5351b89dbb5c8b823fb82846d", "patch": "@@ -1071,10 +1071,17 @@ package body Exp_Intr is\n \n          --  If the designated type is tagged, the finalization call must\n          --  dispatch because the designated type may not be the actual type\n-         --  of the object.\n+         --  of the object. If the type is synchronized, the deallocation\n+         --  applies to the corresponding record type.\n \n          if Is_Tagged_Type (Desig_Typ) then\n-            if not Is_Class_Wide_Type (Desig_Typ) then\n+            if Is_Concurrent_Type (Desig_Typ) then\n+               Obj_Ref :=\n+                 Unchecked_Convert_To\n+                   (Class_Wide_Type (Corresponding_Record_Type (Desig_Typ)),\n+                      Obj_Ref);\n+\n+            elsif not Is_Class_Wide_Type (Desig_Typ) then\n                Obj_Ref :=\n                  Unchecked_Convert_To (Class_Wide_Type (Desig_Typ), Obj_Ref);\n             end if;"}]}