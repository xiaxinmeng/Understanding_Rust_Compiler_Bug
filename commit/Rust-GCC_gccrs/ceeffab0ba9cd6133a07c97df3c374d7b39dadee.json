{"sha": "ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VlZmZhYjBiYTljZDYxMzNhMDdjOTdkZjNjMzc0ZDdiMzlkYWRlZQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-12-15T13:19:46Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-12-15T13:19:46Z"}, "message": "re PR tree-optimization/46053 (g++.dg/torture/pr45699.C FAILs with -fno-early-inlining)\n\n2010-12-15  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/46053\n\tPR middle-end/46287\n\tPR middle-end/46242\n\t* cgraph.h (cgraph_indirect_call_info): New field thunk_delta.\n\t* gimple.h (gimple_fold_obj_type_ref): Declaration removed.\n\t(gimple_fold_call): Declare.\n\t(gimple_adjust_this_by_delta): Likewise.\n\t* cgraph.c (cgraph_make_edge_direct): New parameter delta.  Updated\n\tall users.\n\t(cgraph_clone_edge): Create a copy of indirect_info also for direct\n\tedges.\n\t* cgraphunit.c (cgraph_redirect_edge_call_stmt_to_callee): Adjust this\n\tparameters.\n\t* gimple-fold.c (gimple_fold_obj_type_ref_known_binfo): Renamed to\n\tgimple_get_virt_mehtod_for_binfo, new parameter delta.  Do not search\n\tthrough thunks, in fact bail out if we encounter one, check that\n\tBINFO_VIRTUALS is not NULL.\n\t(gimple_adjust_this_by_delta): New function.\n\t(gimple_fold_obj_type_ref): Removed.\n\t(gimple_fold_obj_type_ref_call): New function.\n\t(fold_gimple_call): Renamed to gimple_fold_call, made external.\n\tUpdated users.  Call gimple_fold_obj_type_ref_call instead of\n\tgimple_fold_obj_type_ref.\n\t* ipa-cp.c (ipcp_process_devirtualization_opportunities): Process\n\tthunk deltas.\n\t(ipcp_discover_new_direct_edges): Likewise.\n\t* ipa-prop.c (ipa_make_edge_direct_to_target): New parameter delta.\n\tUpdated callers.\n\t(ipa_write_indirect_edge_info): Stream thunk_delta.\n\t(ipa_read_indirect_edge_info): Likewise.\n\t* tree-ssa-ccp.c (ccp_fold_stmt): Use gimple_fold_call instead of\n\tgimple_fold_obj_type_ref.\n\n\t* testsuite/g++.dg/ipa/pr46053.C: New test.\n\t* testsuite/g++.dg/ipa/pr46287-1.C: Likewise.\n\t* testsuite/g++.dg/ipa/pr46287-2.C: Likewise.\n\t* testsuite/g++.dg/ipa/pr46287-3.C: Likewise.\n\t* testsuite/g++.dg/torture/covariant-1.C: Likewise.\n\t* testsuite/g++.dg/torture/pr46287.C: Likewise.\n\nFrom-SVN: r167855", "tree": {"sha": "526589a7e9753bc7a413ea63388bd8d0aa594f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/526589a7e9753bc7a413ea63388bd8d0aa594f12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9d0dcda15ccb43b5b24b370e793142736d5742d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d0dcda15ccb43b5b24b370e793142736d5742d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d0dcda15ccb43b5b24b370e793142736d5742d3"}], "stats": {"total": 664, "additions": 563, "deletions": 101}, "files": [{"sha": "64bf22e5d2c184f5e701548489e0b77ebfb2fae7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -1,3 +1,38 @@\n+2010-12-15  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/46053\n+\tPR middle-end/46287\n+\tPR middle-end/46242\n+\t* cgraph.h (cgraph_indirect_call_info): New field thunk_delta.\n+\t* gimple.h (gimple_fold_obj_type_ref): Declaration removed.\n+\t(gimple_fold_call): Declare.\n+\t(gimple_adjust_this_by_delta): Likewise.\n+\t* cgraph.c (cgraph_make_edge_direct): New parameter delta.  Updated\n+\tall users.\n+\t(cgraph_clone_edge): Create a copy of indirect_info also for direct\n+\tedges.\n+\t* cgraphunit.c (cgraph_redirect_edge_call_stmt_to_callee): Adjust this\n+\tparameters.\n+\t* gimple-fold.c (gimple_fold_obj_type_ref_known_binfo): Renamed to\n+\tgimple_get_virt_mehtod_for_binfo, new parameter delta.  Do not search\n+\tthrough thunks, in fact bail out if we encounter one, check that\n+\tBINFO_VIRTUALS is not NULL.\n+\t(gimple_adjust_this_by_delta): New function.\n+\t(gimple_fold_obj_type_ref): Removed.\n+\t(gimple_fold_obj_type_ref_call): New function.\n+\t(fold_gimple_call): Renamed to gimple_fold_call, made external.\n+\tUpdated users.  Call gimple_fold_obj_type_ref_call instead of\n+\tgimple_fold_obj_type_ref.\n+\t* ipa-cp.c (ipcp_process_devirtualization_opportunities): Process\n+\tthunk deltas.\n+\t(ipcp_discover_new_direct_edges): Likewise.\n+\t* ipa-prop.c (ipa_make_edge_direct_to_target): New parameter delta.\n+\tUpdated callers.\n+\t(ipa_write_indirect_edge_info): Stream thunk_delta.\n+\t(ipa_read_indirect_edge_info): Likewise.\n+\t* tree-ssa-ccp.c (ccp_fold_stmt): Use gimple_fold_call instead of\n+\tgimple_fold_obj_type_ref.\n+\n 2010-12-15  Alexander Monakov  <amonakov@ispras.ru>\n \n \tPR rtl-optimization/46649"}, {"sha": "f96bd6400a833382b046b253c8f7bc972bc2b256", "filename": "gcc/cgraph.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -860,7 +860,7 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n \t indirect call into a direct one.  */\n       struct cgraph_node *new_callee = cgraph_node (decl);\n \n-      cgraph_make_edge_direct (e, new_callee);\n+      cgraph_make_edge_direct (e, new_callee, NULL);\n     }\n \n   push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n@@ -1195,12 +1195,15 @@ cgraph_redirect_edge_callee (struct cgraph_edge *e, struct cgraph_node *n)\n }\n \n /* Make an indirect EDGE with an unknown callee an ordinary edge leading to\n-   CALLEE.  */\n+   CALLEE.  DELTA, if non-NULL, is an integer constant that is to be added to\n+   the this pointer (first parameter).  */\n \n void\n-cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)\n+cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee,\n+\t\t\t tree delta)\n {\n   edge->indirect_unknown_callee = 0;\n+  edge->indirect_info->thunk_delta = delta;\n \n   /* Get the edge out of the indirect edge list. */\n   if (edge->prev_callee)\n@@ -2116,8 +2119,16 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n \t}\n     }\n   else\n-    new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq,\n-\t\t\t\t   e->loop_nest + loop_nest);\n+    {\n+      new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq,\n+\t\t\t\t     e->loop_nest + loop_nest);\n+      if (e->indirect_info)\n+\t{\n+\t  new_edge->indirect_info\n+\t    = ggc_alloc_cleared_cgraph_indirect_call_info ();\n+\t  *new_edge->indirect_info = *e->indirect_info;\n+\t}\n+    }\n \n   new_edge->inline_failed = e->inline_failed;\n   new_edge->indirect_inlining_edge = e->indirect_inlining_edge;"}, {"sha": "69bc79c6b12ada10262463532c5e0ad4b1c0a76e", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -388,6 +388,9 @@ struct GTY(()) cgraph_indirect_call_info\n   HOST_WIDE_INT otr_token;\n   /* Type of the object from OBJ_TYPE_REF_OBJECT. */\n   tree otr_type;\n+  /* Delta by which must be added to this parameter.  For polymorphic calls\n+     only.  */\n+  tree thunk_delta;\n   /* Index of the parameter that is called.  */\n   int param_index;\n   /* ECF flags determined from the caller.  */\n@@ -575,7 +578,7 @@ struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type, i\n \t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *);\n \n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n-void cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *);\n+void cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *, tree);\n \n struct cgraph_asm_node *cgraph_add_asm_node (tree);\n "}, {"sha": "013cf638f717089fa42ec99b3d3db0a952bfc607", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -2134,6 +2134,8 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n {\n   tree decl = gimple_call_fndecl (e->call_stmt);\n   gimple new_stmt;\n+  gimple_stmt_iterator gsi;\n+  bool gsi_computed = false;\n #ifdef ENABLE_CHECKING\n   struct cgraph_node *node;\n #endif\n@@ -2166,9 +2168,26 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t}\n     }\n \n+  if (e->indirect_info && e->indirect_info->thunk_delta\n+      && integer_nonzerop (e->indirect_info->thunk_delta)\n+      && (!e->callee->clone.combined_args_to_skip\n+\t  || !bitmap_bit_p (e->callee->clone.combined_args_to_skip, 0)))\n+    {\n+      if (cgraph_dump_file)\n+\t{\n+\t  fprintf (cgraph_dump_file, \"          Thunk delta is \");\n+\t  print_generic_expr (cgraph_dump_file,\n+\t\t\t      e->indirect_info->thunk_delta, 0);\n+\t  fprintf (cgraph_dump_file, \"\\n\");\n+\t}\n+      gsi = gsi_for_stmt (e->call_stmt);\n+      gsi_computed = true;\n+      gimple_adjust_this_by_delta (&gsi, e->indirect_info->thunk_delta);\n+      e->indirect_info->thunk_delta = NULL_TREE;\n+    }\n+\n   if (e->callee->clone.combined_args_to_skip)\n     {\n-      gimple_stmt_iterator gsi;\n       int lp_nr;\n \n       new_stmt\n@@ -2180,7 +2199,8 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n \t  && TREE_CODE (gimple_vdef (new_stmt)) == SSA_NAME)\n \tSSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n \n-      gsi = gsi_for_stmt (e->call_stmt);\n+      if (!gsi_computed)\n+\tgsi = gsi_for_stmt (e->call_stmt);\n       gsi_replace (&gsi, new_stmt, false);\n       /* We need to defer cleaning EH info on the new statement to\n          fixup-cfg.  We may not have dominator information at this point"}, {"sha": "b6c06fca165e4f6a04b7a87b31a6a04f8f229036", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 87, "deletions": 59, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -1446,17 +1446,26 @@ gimple_get_relevant_ref_binfo (tree ref, tree known_binfo)\n     }\n }\n \n-/* Fold a OBJ_TYPE_REF expression to the address of a function. TOKEN is\n-   integer form of OBJ_TYPE_REF_TOKEN of the reference expression.  KNOWN_BINFO\n-   carries the binfo describing the true type of OBJ_TYPE_REF_OBJECT(REF).  */\n+/* Return a declaration of a function which an OBJ_TYPE_REF references. TOKEN\n+   is integer form of OBJ_TYPE_REF_TOKEN of the reference expression.\n+   KNOWN_BINFO carries the binfo describing the true type of\n+   OBJ_TYPE_REF_OBJECT(REF).  If a call to the function must be accompanied\n+   with a this adjustment, the constant which should be added to this pointer\n+   is stored to *DELTA.  If REFUSE_THUNKS is true, return NULL if the function\n+   is a thunk (other than a this adjustment which is dealt with by DELTA). */\n \n tree\n-gimple_fold_obj_type_ref_known_binfo (HOST_WIDE_INT token, tree known_binfo)\n+gimple_get_virt_mehtod_for_binfo (HOST_WIDE_INT token, tree known_binfo,\n+\t\t\t\t  tree *delta, bool refuse_thunks)\n {\n   HOST_WIDE_INT i;\n-  tree v, fndecl, delta;\n+  tree v, fndecl;\n+  struct cgraph_node *node;\n \n   v = BINFO_VIRTUALS (known_binfo);\n+  /* If there is no virtual methods leave the OBJ_TYPE_REF alone.  */\n+  if (!v)\n+    return NULL_TREE;\n   i = 0;\n   while (i != token)\n     {\n@@ -1466,71 +1475,100 @@ gimple_fold_obj_type_ref_known_binfo (HOST_WIDE_INT token, tree known_binfo)\n     }\n \n   fndecl = TREE_VALUE (v);\n-  delta = TREE_PURPOSE (v);\n-  gcc_assert (host_integerp (delta, 0));\n-\n-  if (integer_nonzerop (delta))\n-    {\n-      struct cgraph_node *node = cgraph_get_node (fndecl);\n-      HOST_WIDE_INT off = tree_low_cst (delta, 0);\n-\n-      if (!node)\n-        return NULL;\n-      for (node = node->same_body; node; node = node->next)\n-        if (node->thunk.thunk_p && off == node->thunk.fixed_offset)\n-          break;\n-      if (node)\n-        fndecl = node->decl;\n-      else\n-        return NULL;\n-     }\n+  node = cgraph_get_node_or_alias (fndecl);\n+  if (refuse_thunks\n+      && (!node\n+    /* Bail out if it is a thunk declaration.  Since simple this_adjusting\n+       thunks are represented by a constant in TREE_PURPOSE of items in\n+       BINFO_VIRTUALS, this is a more complicate type which we cannot handle as\n+       yet.\n+\n+       FIXME: Remove the following condition once we are able to represent\n+       thunk information on call graph edges.  */\n+\t  || (node->same_body_alias && node->thunk.thunk_p)))\n+    return NULL_TREE;\n \n   /* When cgraph node is missing and function is not public, we cannot\n      devirtualize.  This can happen in WHOPR when the actual method\n      ends up in other partition, because we found devirtualization\n      possibility too late.  */\n-  if (!can_refer_decl_in_current_unit_p (fndecl))\n-    return NULL;\n-  return build_fold_addr_expr (fndecl);\n+  if (!can_refer_decl_in_current_unit_p (TREE_VALUE (v)))\n+    return NULL_TREE;\n+\n+  *delta = TREE_PURPOSE (v);\n+  gcc_checking_assert (host_integerp (*delta, 0));\n+  return fndecl;\n }\n \n+/* Generate code adjusting the first parameter of a call statement determined\n+   by GSI by DELTA.  */\n+\n+void\n+gimple_adjust_this_by_delta (gimple_stmt_iterator *gsi, tree delta)\n+{\n+  gimple call_stmt = gsi_stmt (*gsi);\n+  tree parm, tmp;\n+  gimple new_stmt;\n+\n+  delta = fold_convert (sizetype, delta);\n+  gcc_assert (gimple_call_num_args (call_stmt) >= 1);\n+  parm = gimple_call_arg (call_stmt, 0);\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (parm)));\n+  tmp = create_tmp_var (TREE_TYPE (parm), NULL);\n+  add_referenced_var (tmp);\n+\n+  tmp = make_ssa_name (tmp, NULL);\n+  new_stmt = gimple_build_assign_with_ops (POINTER_PLUS_EXPR, tmp, parm, delta);\n+  SSA_NAME_DEF_STMT (tmp) = new_stmt;\n+  gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+  gimple_call_set_arg (call_stmt, 0, tmp);\n+}\n \n-/* Fold a OBJ_TYPE_REF expression to the address of a function.  If KNOWN_TYPE\n-   is not NULL_TREE, it is the true type of the outmost encapsulating object if\n-   that comes from a pointer SSA_NAME.  If the true outmost encapsulating type\n-   can be determined from a declaration OBJ_TYPE_REF_OBJECT(REF), it is used\n-   regardless of KNOWN_TYPE (which thus can be NULL_TREE).  */\n+/* Fold a call statement to OBJ_TYPE_REF to a direct call, if possible.  GSI\n+   determines the statement, generating new statements is allowed only if\n+   INPLACE is false.  Return true iff the statement was changed.  */\n \n-tree\n-gimple_fold_obj_type_ref (tree ref, tree known_type)\n+static bool\n+gimple_fold_obj_type_ref_call (gimple_stmt_iterator *gsi, bool inplace)\n {\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree ref = gimple_call_fn (stmt);\n   tree obj = OBJ_TYPE_REF_OBJECT (ref);\n-  tree known_binfo = known_type ? TYPE_BINFO (known_type) : NULL_TREE;\n-  tree binfo;\n+  tree binfo, fndecl, delta;\n+  HOST_WIDE_INT token;\n \n   if (TREE_CODE (obj) == ADDR_EXPR)\n     obj = TREE_OPERAND (obj, 0);\n+  else\n+    return false;\n+\n+  binfo = gimple_get_relevant_ref_binfo (obj, NULL_TREE);\n+  if (!binfo)\n+    return false;\n+  token = tree_low_cst (OBJ_TYPE_REF_TOKEN (ref), 1);\n+  fndecl = gimple_get_virt_mehtod_for_binfo (token, binfo, &delta,\n+\t\t\t\t\t     !DECL_P (obj));\n+  if (!fndecl)\n+    return false;\n \n-  binfo = gimple_get_relevant_ref_binfo (obj, known_binfo);\n-  if (binfo)\n+  if (integer_nonzerop (delta))\n     {\n-      HOST_WIDE_INT token = tree_low_cst (OBJ_TYPE_REF_TOKEN (ref), 1);\n-      /* If there is no virtual methods leave the OBJ_TYPE_REF alone.  */\n-      if (!BINFO_VIRTUALS (binfo))\n-\treturn NULL_TREE;\n-      return gimple_fold_obj_type_ref_known_binfo (token, binfo);\n+      if (inplace)\n+        return false;\n+      gimple_adjust_this_by_delta (gsi, delta);\n     }\n-  else\n-    return NULL_TREE;\n+\n+  gimple_call_set_fndecl (stmt, fndecl);\n+  return true;\n }\n \n /* Attempt to fold a call statement referenced by the statement iterator GSI.\n    The statement may be replaced by another statement, e.g., if the call\n    simplifies to a constant value. Return true if any changes were made.\n    It is assumed that the operands have been previously folded.  */\n \n-static bool\n-fold_gimple_call (gimple_stmt_iterator *gsi, bool inplace)\n+bool\n+gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n {\n   gimple stmt = gsi_stmt (*gsi);\n \n@@ -1556,18 +1594,8 @@ fold_gimple_call (gimple_stmt_iterator *gsi, bool inplace)\n          copying EH region info to the new node.  Easier to just do it\n          here where we can just smash the call operand.  */\n       callee = gimple_call_fn (stmt);\n-      if (TREE_CODE (callee) == OBJ_TYPE_REF\n-          && TREE_CODE (OBJ_TYPE_REF_OBJECT (callee)) == ADDR_EXPR)\n-        {\n-          tree t;\n-\n-          t = gimple_fold_obj_type_ref (callee, NULL_TREE);\n-          if (t)\n-            {\n-              gimple_call_set_fn (stmt, t);\n-              return true;\n-            }\n-        }\n+      if (TREE_CODE (callee) == OBJ_TYPE_REF)\n+\treturn gimple_fold_obj_type_ref_call (gsi, inplace);\n     }\n \n   return false;\n@@ -1621,7 +1649,7 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace)\n \t\tchanged = true;\n \t      }\n \t  }\n-      changed |= fold_gimple_call (gsi, inplace);\n+      changed |= gimple_fold_call (gsi, inplace);\n       break;\n \n     case GIMPLE_ASM:"}, {"sha": "c114e7cd834322ef67a23cbd495b597810855ea2", "filename": "gcc/gimple.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -891,10 +891,10 @@ unsigned get_gimple_rhs_num_ops (enum tree_code);\n #define gimple_alloc(c, n) gimple_alloc_stat (c, n MEM_STAT_INFO)\n gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n const char *gimple_decl_printable_name (tree, int);\n-tree gimple_fold_obj_type_ref (tree, tree);\n+bool gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace);\n tree gimple_get_relevant_ref_binfo (tree ref, tree known_binfo);\n-tree gimple_fold_obj_type_ref_known_binfo (HOST_WIDE_INT, tree);\n-\n+tree gimple_get_virt_mehtod_for_binfo (HOST_WIDE_INT, tree, tree *, bool);\n+void gimple_adjust_this_by_delta (gimple_stmt_iterator *, tree);\n /* Returns true iff T is a valid GIMPLE statement.  */\n extern bool is_gimple_stmt (tree);\n "}, {"sha": "24ccb92011833b7aa2a91fe1facacac160cc23b9", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -1214,7 +1214,7 @@ ipcp_process_devirtualization_opportunities (struct cgraph_node *node)\n     {\n       int param_index, types_count, j;\n       HOST_WIDE_INT token;\n-      tree target;\n+      tree target, delta;\n \n       next_ie = ie->next_callee;\n       if (!ie->indirect_info->polymorphic)\n@@ -1231,24 +1231,28 @@ ipcp_process_devirtualization_opportunities (struct cgraph_node *node)\n       for (j = 0; j < types_count; j++)\n \t{\n \t  tree binfo = VEC_index (tree, info->params[param_index].types, j);\n-\t  tree t = gimple_fold_obj_type_ref_known_binfo (token, binfo);\n+\t  tree d;\n+\t  tree t = gimple_get_virt_mehtod_for_binfo (token, binfo, &d, true);\n \n \t  if (!t)\n \t    {\n \t      target = NULL_TREE;\n \t      break;\n \t    }\n \t  else if (!target)\n-\t    target = t;\n-\t  else if (target != t)\n+\t    {\n+\t      target = t;\n+\t      delta = d;\n+\t    }\n+\t  else if (target != t || !tree_int_cst_equal (delta, d))\n \t    {\n \t      target = NULL_TREE;\n \t      break;\n \t    }\n \t}\n \n       if (target)\n-\tipa_make_edge_direct_to_target (ie, target);\n+\tipa_make_edge_direct_to_target (ie, target, delta);\n     }\n }\n \n@@ -1288,6 +1292,7 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node, int index, tree cst)\n   for (ie = node->indirect_calls; ie; ie = next_ie)\n     {\n       struct cgraph_indirect_call_info *ici = ie->indirect_info;\n+      tree target, delta = NULL_TREE;\n \n       next_ie = ie->next_callee;\n       if (ici->param_index != index)\n@@ -1307,12 +1312,15 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node, int index, tree cst)\n \t    continue;\n \t  gcc_assert (ie->indirect_info->anc_offset == 0);\n \t  token = ie->indirect_info->otr_token;\n-\t  cst = gimple_fold_obj_type_ref_known_binfo (token, binfo);\n-\t  if (!cst)\n+\t  target = gimple_get_virt_mehtod_for_binfo (token, binfo, &delta,\n+\t\t\t\t\t\t     true);\n+\t  if (!target)\n \t    continue;\n \t}\n+      else\n+\ttarget = cst;\n \n-      ipa_make_edge_direct_to_target (ie, cst);\n+      ipa_make_edge_direct_to_target (ie, target, delta);\n     }\n }\n "}, {"sha": "f0a5c609c0a5ed2a9fa46bf6e3ed583d4e54af99", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -1462,35 +1462,43 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n }\n \n /* If TARGET is an addr_expr of a function declaration, make it the destination\n-   of an indirect edge IE and return the edge.  Otherwise, return NULL.  */\n+   of an indirect edge IE and return the edge.  Otherwise, return NULL.  Delta,\n+   if non-NULL, is an integer constant that must be added to this pointer\n+   (first parameter).  */\n \n struct cgraph_edge *\n-ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n+ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target, tree delta)\n {\n   struct cgraph_node *callee;\n \n-  if (TREE_CODE (target) != ADDR_EXPR)\n-    return NULL;\n-  target = TREE_OPERAND (target, 0);\n+  if (TREE_CODE (target) == ADDR_EXPR)\n+    target = TREE_OPERAND (target, 0);\n   if (TREE_CODE (target) != FUNCTION_DECL)\n     return NULL;\n   callee = cgraph_node (target);\n   if (!callee)\n     return NULL;\n   ipa_check_create_node_params ();\n-  cgraph_make_edge_direct (ie, callee);\n+\n+  cgraph_make_edge_direct (ie, callee, delta);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"ipa-prop: Discovered %s call to a known target \"\n-\t       \"(%s/%i -> %s/%i) for stmt \",\n+\t       \"(%s/%i -> %s/%i), for stmt \",\n \t       ie->indirect_info->polymorphic ? \"a virtual\" : \"an indirect\",\n \t       cgraph_node_name (ie->caller), ie->caller->uid,\n \t       cgraph_node_name (ie->callee), ie->callee->uid);\n-\n       if (ie->call_stmt)\n \tprint_gimple_stmt (dump_file, ie->call_stmt, 2, TDF_SLIM);\n       else\n \tfprintf (dump_file, \"with uid %i\\n\", ie->lto_stmt_uid);\n+\n+      if (delta)\n+\t{\n+\t  fprintf (dump_file, \"          Thunk delta is \");\n+\t  print_generic_expr (dump_file, delta, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n     }\n \n   if (ipa_get_cs_argument_count (IPA_EDGE_REF (ie))\n@@ -1518,7 +1526,7 @@ try_make_edge_direct_simple_call (struct cgraph_edge *ie,\n   else\n     return NULL;\n \n-  return ipa_make_edge_direct_to_target (ie, target);\n+  return ipa_make_edge_direct_to_target (ie, target, NULL_TREE);\n }\n \n /* Try to find a destination for indirect edge IE that corresponds to a\n@@ -1530,7 +1538,7 @@ static struct cgraph_edge *\n try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t\t\t\t   struct ipa_jump_func *jfunc)\n {\n-  tree binfo, type, target;\n+  tree binfo, type, target, delta;\n   HOST_WIDE_INT token;\n \n   if (jfunc->type == IPA_JF_KNOWN_TYPE)\n@@ -1554,12 +1562,12 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n   type = ie->indirect_info->otr_type;\n   binfo = get_binfo_at_offset (binfo, ie->indirect_info->anc_offset, type);\n   if (binfo)\n-    target = gimple_fold_obj_type_ref_known_binfo (token, binfo);\n+    target = gimple_get_virt_mehtod_for_binfo (token, binfo, &delta, true);\n   else\n     return NULL;\n \n   if (target)\n-    return ipa_make_edge_direct_to_target (ie, target);\n+    return ipa_make_edge_direct_to_target (ie, target, delta);\n   else\n     return NULL;\n }\n@@ -2547,6 +2555,7 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n     {\n       lto_output_sleb128_stream (ob->main_stream, ii->otr_token);\n       lto_output_tree (ob, ii->otr_type, true);\n+      lto_output_tree (ob, ii->thunk_delta, true);\n     }\n }\n \n@@ -2569,6 +2578,7 @@ ipa_read_indirect_edge_info (struct lto_input_block *ib,\n     {\n       ii->otr_token = (HOST_WIDE_INT) lto_input_sleb128 (ib);\n       ii->otr_type = lto_input_tree (ib, data_in);\n+      ii->thunk_delta = lto_input_tree (ib, data_in);\n     }\n }\n "}, {"sha": "9fd2a39f022509b721a97cefa32d026c9aab631f", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -430,7 +430,8 @@ bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t\tVEC (cgraph_edge_p, heap) **new_edges);\n \n /* Indirect edge and binfo processing.  */\n-struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree);\n+struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree,\n+\t\t\t\t\t\t    tree);\n \n \n /* Debugging interface.  */"}, {"sha": "e52853e11c27450c244a5094d03da354b895c29f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -1,3 +1,15 @@\n+2010-12-15  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/46053\n+\tPR middle-end/46287\n+\tPR middle-end/46242\n+\t* g++.dg/ipa/pr46053.C: New test.\n+\t* g++.dg/ipa/pr46287-1.C: Likewise.\n+\t* g++.dg/ipa/pr46287-2.C: Likewise.\n+\t* g++.dg/ipa/pr46287-3.C: Likewise.\n+\t* g++.dg/torture/covariant-1.C: Likewise.\n+\t* g++.dg/torture/pr46287.C: Likewise.\n+\n 2010-12-15  Alexander Monakov  <amonakov@ispras.ru>\n \n \tPR rtl-optimization/46649"}, {"sha": "7be6fc3a0a65d0a240b2cb72d7d83539039fa7be", "filename": "gcc/testsuite/g++.dg/ipa/pr46053.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46053.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46053.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46053.C?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O -fipa-cp -fno-early-inlining\"  } */\n+\n+extern \"C\" void abort ();\n+\n+struct A\n+{\n+  virtual void foo () = 0;\n+};\n+\n+struct B : A\n+{\n+  virtual void foo () = 0;\n+};\n+\n+struct C : A\n+{\n+};\n+\n+struct D : C, B\n+{\n+  int i;\n+  D () : i(0xaaaa) {}\n+  virtual void foo ()\n+  {\n+    if (i != 0xaaaa)\n+      abort();\n+  }\n+};\n+\n+static inline void bar (B &b)\n+{\n+  b.foo ();\n+}\n+\n+int main()\n+{\n+  D d;\n+  bar (d);\n+  return 0;\n+}"}, {"sha": "0755529bdb09649591b5b45c250e0457d87c5430", "filename": "gcc/testsuite/g++.dg/ipa/pr46287-1.C", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46287-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46287-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46287-1.C?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -0,0 +1,67 @@\n+// Check that indirect calls to thunks do not lead to errors.\n+// { dg-do run }\n+// { dg-options \"-O\" }\n+\n+extern \"C\" void abort ();\n+\n+class A\n+{\n+public:\n+  virtual void foo () {abort();}\n+};\n+\n+class B : public A\n+{\n+public:\n+  int z;\n+  virtual void foo () {abort();}\n+};\n+\n+class C : public A\n+{\n+public:\n+  void *a[32];\n+  unsigned long b;\n+  long c[32];\n+\n+  virtual void foo () {abort();}\n+};\n+\n+class D : public C, public B\n+{\n+public:\n+  D () : C(), B()\n+  {\n+    int i;\n+    for (i = 0; i < 32; i++)\n+      {\n+\ta[i] = (void *) 0;\n+\tc[i] = 0;\n+      }\n+    b = 0xaaaa;\n+  }\n+\n+  virtual void foo ();\n+};\n+\n+inline void D::foo()\n+{\n+  if (b != 0xaaaa)\n+    abort();\n+}\n+\n+static inline void bar (B &b)\n+{\n+\n+  b.foo ();\n+}\n+\n+int main()\n+{\n+  int i;\n+  D d;\n+\n+  for (i = 0; i < 5000; i++)\n+    bar (d);\n+  return 0;\n+}"}, {"sha": "272852bad7f96129e6f7941212e7188baf3b8b2a", "filename": "gcc/testsuite/g++.dg/ipa/pr46287-2.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46287-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46287-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46287-2.C?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -0,0 +1,68 @@\n+// Check that indirect calls to thunks do not lead to errors.\n+// { dg-do run }\n+// { dg-options \"-O -finline -finline-small-functions -finline-functions\" }\n+\n+\n+extern \"C\" void abort ();\n+\n+class A\n+{\n+public:\n+  virtual void foo () {abort();}\n+};\n+\n+class B : public A\n+{\n+public:\n+  int z;\n+  virtual void foo () {abort();}\n+};\n+\n+class C : public A\n+{\n+public:\n+  void *a[32];\n+  unsigned long b;\n+  long c[32];\n+\n+  virtual void foo () {abort();}\n+};\n+\n+class D : public C, public B\n+{\n+public:\n+  D () : C(), B()\n+  {\n+    int i;\n+    for (i = 0; i < 32; i++)\n+      {\n+\ta[i] = (void *) 0;\n+\tc[i] = 0;\n+      }\n+    b = 0xaaaa;\n+  }\n+\n+  virtual void foo ();\n+};\n+\n+void D::foo()\n+{\n+  if (b != 0xaaaa)\n+    abort();\n+}\n+\n+static inline void bar (B &b)\n+{\n+\n+  b.foo ();\n+}\n+\n+int main()\n+{\n+  int i;\n+  D d;\n+\n+  for (i = 0; i < 5000; i++)\n+    bar (d);\n+  return 0;\n+}"}, {"sha": "5f291ce1f63571cf42b2c76c18cc1f6e668437f0", "filename": "gcc/testsuite/g++.dg/ipa/pr46287-3.C", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46287-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46287-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr46287-3.C?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -0,0 +1,67 @@\n+// Check that indirect calls to thunks do not lead to errors.\n+// { dg-do run }\n+// { dg-options \"-O -fipa-cp\" }\n+\n+extern \"C\" void abort ();\n+\n+class A\n+{\n+public:\n+  virtual void foo () {abort();}\n+};\n+\n+class B : public A\n+{\n+public:\n+  int z;\n+  virtual void foo () {abort();}\n+};\n+\n+class C : public A\n+{\n+public:\n+  void *a[32];\n+  unsigned long b;\n+  long c[32];\n+\n+  virtual void foo () {abort();}\n+};\n+\n+class D : public C, public B\n+{\n+public:\n+  D () : C(), B()\n+  {\n+    int i;\n+    for (i = 0; i < 32; i++)\n+      {\n+\ta[i] = (void *) 0;\n+\tc[i] = 0;\n+      }\n+    b = 0xaaaa;\n+  }\n+\n+  virtual void foo ();\n+};\n+\n+void D::foo()\n+{\n+  if (b != 0xaaaa)\n+    abort();\n+}\n+\n+static void bar (B &b)\n+{\n+\n+  b.foo ();\n+}\n+\n+int main()\n+{\n+  int i;\n+  D d;\n+\n+  for (i = 0; i < 5000; i++)\n+    bar (d);\n+  return 0;\n+}"}, {"sha": "9f1fd0a52ca2b753babf9e490b6a1dc778124c18", "filename": "gcc/testsuite/g++.dg/torture/covariant-1.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fcovariant-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fcovariant-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fcovariant-1.C?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+class A {\n+public:\n+  virtual A* getThis() { return this; }\n+};\n+\n+class B {\n+int a;\n+public:\n+  virtual B* getThis() { return this; }\n+};\n+\n+class AB : public A, public B {\n+public:\n+  virtual AB* getThis() { return this; }\n+};\n+\n+int main ()\n+{\n+  AB ab;\n+\n+  A* a = &ab;\n+  B* b = &ab;\n+\n+  if (a->getThis() != a\n+      || b->getThis() != b)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "fd201c48da83c5ec594d596738fa9a559f115bc0", "filename": "gcc/testsuite/g++.dg/torture/pr46287.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr46287.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr46287.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr46287.C?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -0,0 +1,66 @@\n+// Check that indirect calls to thunks do not lead to errors.\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+class A\n+{\n+public:\n+  virtual void foo () {abort();}\n+};\n+\n+class B : public A\n+{\n+public:\n+  int z;\n+  virtual void foo () {abort();}\n+};\n+\n+class C : public A\n+{\n+public:\n+  void *a[32];\n+  unsigned long b;\n+  long c[32];\n+\n+  virtual void foo () {abort();}\n+};\n+\n+class D : public C, public B\n+{\n+public:\n+  D () : C(), B()\n+  {\n+    int i;\n+    for (i = 0; i < 32; i++)\n+      {\n+\ta[i] = (void *) 0;\n+\tc[i] = 0;\n+      }\n+    b = 0xaaaa;\n+  }\n+\n+  virtual void foo ();\n+};\n+\n+void D::foo()\n+{\n+  if (b != 0xaaaa)\n+    abort();\n+}\n+\n+static inline void bar (B &b)\n+{\n+\n+  b.foo ();\n+}\n+\n+int main()\n+{\n+  int i;\n+  D d;\n+\n+  for (i = 0; i < 5000; i++)\n+    bar (d);\n+  return 0;\n+}"}, {"sha": "aea7edfb6f8ebc15ba4dbafc4ae4343f7354c81f", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeffab0ba9cd6133a07c97df3c374d7b39dadee/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=ceeffab0ba9cd6133a07c97df3c374d7b39dadee", "patch": "@@ -2316,16 +2316,8 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n \t  {\n \t    tree expr = OBJ_TYPE_REF_EXPR (callee);\n \t    OBJ_TYPE_REF_EXPR (callee) = valueize_op (expr);\n-\t    if (TREE_CODE (OBJ_TYPE_REF_EXPR (callee)) == ADDR_EXPR)\n-\t      {\n-\t\ttree t;\n-\t\tt = gimple_fold_obj_type_ref (callee, NULL_TREE);\n-\t\tif (t)\n-\t\t  {\n-\t\t    gimple_call_set_fn (stmt, t);\n-\t\t    changed = true;\n-\t\t  }\n-\t      }\n+\t    if (gimple_fold_call (gsi, false))\n+\t      changed = true;\n \t    OBJ_TYPE_REF_EXPR (callee) = expr;\n \t  }\n "}]}