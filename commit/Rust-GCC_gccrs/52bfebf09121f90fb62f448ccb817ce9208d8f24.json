{"sha": "52bfebf09121f90fb62f448ccb817ce9208d8f24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJiZmViZjA5MTIxZjkwZmI2MmY0NDhjY2I4MTdjZTkyMDhkOGYyNA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-07-28T02:11:05Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-07-28T02:11:05Z"}, "message": "Makefile.in: rtlanal.o now depends upon real.h.\n\n\n\t* Makefile.in: rtlanal.o now depends upon real.h.\n\n\t* flags.h [flag_signaling_nans]: New flag.\n\t[HONOR_SNANS]: New macro.\n\n\t* toplev.c [flag_signaling_nans]: Initialize to false.\n        (f_options): Add processing for \"-fsignaling-nans\".\n\t(set_fast_math_flags): Clear flag_signaling_nans with -ffast-math.\n\t(process_options): flag_signaling_nans implies flag_trapping_math.\n\n\t* c-common.c (cb_register_builtins): Define __SUPPORT_SNAN__\n\twhen -fsignaling-nans.  First step to implementing WG14's N965.\n\n\t* fold-const.c (fold) [MULT_EXPR]: Conditionalize transforming\n\t1.0 * x into x, and -1.0 * x into -x on !HONOR_SNANS.\n\t[RDIV_EXPR]: Conditionalize x/1.0 into x on !HONOR_SNANS.\n\n\t* simplify-rtx.c (simplify_relational_operation): Conditionalize\n\ttransforming abs(x) < 0.0 into false on !HONOR_SNANS.\n\n\t* rtlanal.c: #include real.c for TARGET_FLOAT_FORMAT definitions\n\trequired by HONOR_SNANS.  (may_trap_p): Floating point DIV, MOD,\n\tUDIV, UMOD, GE, GT, LE, LT and COMPARE may always trap with\n\t-fsignaling_nans.  EQ and NE only trap for flag_signaling_nans\n\tnot flag_trapping_math (i.e. HONOR_SNANS but not HONOR_NANS).\n\n\t* doc/invoke.texi: Document new -fsignaling-nans compiler option.\n\nFrom-SVN: r55804", "tree": {"sha": "811f8a9808cc8a4ff4fa003afa503d9d758bdcc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/811f8a9808cc8a4ff4fa003afa503d9d758bdcc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52bfebf09121f90fb62f448ccb817ce9208d8f24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52bfebf09121f90fb62f448ccb817ce9208d8f24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52bfebf09121f90fb62f448ccb817ce9208d8f24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52bfebf09121f90fb62f448ccb817ce9208d8f24/comments", "author": null, "committer": null, "parents": [{"sha": "e66f55b878b78b51895f907fd624b583732d7659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66f55b878b78b51895f907fd624b583732d7659", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e66f55b878b78b51895f907fd624b583732d7659"}], "stats": {"total": 125, "additions": 103, "deletions": 22}, "files": [{"sha": "cc9307ec797aed8c478c21062c84aaf8cae6904c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52bfebf09121f90fb62f448ccb817ce9208d8f24", "patch": "@@ -1,3 +1,33 @@\n+2002-07-27  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* Makefile.in: rtlanal.o now depends upon real.h.\n+\n+\t* flags.h [flag_signaling_nans]: New flag.\n+\t[HONOR_SNANS]: New macro.\n+\n+\t* toplev.c [flag_signaling_nans]: Initialize to false.\n+        (f_options): Add processing for \"-fsignaling-nans\".\n+\t(set_fast_math_flags): Clear flag_signaling_nans with -ffast-math.\n+\t(process_options): flag_signaling_nans implies flag_trapping_math.\n+\n+\t* c-common.c (cb_register_builtins): Define __SUPPORT_SNAN__\n+\twhen -fsignaling-nans.  First step to implementing WG14's N965.\n+\n+\t* fold-const.c (fold) [MULT_EXPR]: Conditionalize transforming\n+\t1.0 * x into x, and -1.0 * x into -x on !HONOR_SNANS.\n+\t[RDIV_EXPR]: Conditionalize x/1.0 into x on !HONOR_SNANS.\n+\n+\t* simplify-rtx.c (simplify_relational_operation): Conditionalize\n+\ttransforming abs(x) < 0.0 into false on !HONOR_SNANS.\n+\n+\t* rtlanal.c: #include real.c for TARGET_FLOAT_FORMAT definitions\n+\trequired by HONOR_SNANS.  (may_trap_p): Floating point DIV, MOD,\n+\tUDIV, UMOD, GE, GT, LE, LT and COMPARE may always trap with \n+\t-fsignaling_nans.  EQ and NE only trap for flag_signaling_nans \n+\tnot flag_trapping_math (i.e. HONOR_SNANS but not HONOR_NANS).\n+\n+\t* doc/invoke.texi: Document new -fsignaling-nans compiler option.\n+\n 2002-07-27  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.in (gengtype-lex.c): Work around a bug in flex."}, {"sha": "e87a1ea06261bd673deacd98d362fba99c2233cd", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=52bfebf09121f90fb62f448ccb817ce9208d8f24", "patch": "@@ -1403,7 +1403,7 @@ print-rtl.o : print-rtl.c $(GCONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) toplev.h $(RTL_H) \\\n-   hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) flags.h\n+   hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) real.h flags.h\n \n errors.o : errors.c $(GCONFIG_H) $(SYSTEM_H) errors.h\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)"}, {"sha": "f7bbc1b5f4497ff80a425e92bbb2b76c10180274", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=52bfebf09121f90fb62f448ccb817ce9208d8f24", "patch": "@@ -4383,6 +4383,8 @@ cb_register_builtins (pfile)\n     cpp_define (pfile, \"__FAST_MATH__\");\n   if (flag_no_inline)\n     cpp_define (pfile, \"__NO_INLINE__\");\n+  if (flag_signaling_nans)\n+    cpp_define (pfile, \"__SUPPORT_SNAN__\");\n \n   if (flag_iso)\n     cpp_define (pfile, \"__STRICT_ANSI__\");"}, {"sha": "8d5687b8a014fc440271ca789a20c65838b9f724", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=52bfebf09121f90fb62f448ccb817ce9208d8f24", "patch": "@@ -280,7 +280,7 @@ in the following sections.\n -freduce-all-givs -fregmove  -frename-registers @gol\n -freorder-blocks -freorder-functions @gol\n -frerun-cse-after-loop  -frerun-loop-opt @gol\n--fschedule-insns  -fschedule-insns2 @gol\n+-fschedule-insns  -fschedule-insns2 -fsignaling-nans @gol\n -fsingle-precision-constant  -fssa -fssa-ccp -fssa-dce @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer -fthread-jumps  -ftrapv @gol\n -funroll-all-loops  -funroll-loops  @gol\n@@ -3407,8 +3407,8 @@ performed when this option is not used.\n \n @item -ffast-math\n @opindex ffast-math\n-Sets @option{-fno-math-errno}, @option{-funsafe-math-optimizations}, and @*\n-@option{-fno-trapping-math}.\n+Sets @option{-fno-math-errno}, @option{-funsafe-math-optimizations}, @*\n+@option{-fno-trapping-math} and @option{-fno-signaling-nans}.\n \n This option causes the preprocessor macro @code{__FAST_MATH__} to be defined.\n \n@@ -3449,8 +3449,10 @@ The default is @option{-fno-unsafe-math-optimizations}.\n @item -fno-trapping-math\n @opindex fno-trapping-math\n Compile code assuming that floating-point operations cannot generate\n-user-visible traps.  Setting this option may allow faster code\n-if one relies on ``non-stop'' IEEE arithmetic, for example.\n+user-visible traps.  These traps include division by zero, overflow,\n+underflow, inexact result and invalid operation.  This option implies\n+@option{-fno-signaling-nans}.  Setting this option may allow faster\n+code if one relies on ``non-stop'' IEEE arithmetic, for example.\n \n This option should never be turned on by any @option{-O} option since\n it can result in incorrect output for programs which depend on\n@@ -3459,6 +3461,21 @@ math functions.\n \n The default is @option{-ftrapping-math}.\n \n+@item -fsignaling-nans\n+@opindex fsignaling-nans\n+Compile code assuming that IEEE signaling NaNs may generate user-visible\n+traps during floating-point operations.  Setting this option disables\n+optimizations that may change the number of exceptions visible with\n+signaling NaNs.  This option implies @option{-ftrapping-math}.\n+\n+This option causes the preprocessor macro @code{__SUPPORT_SNAN__} to\n+be defined.\n+\n+The default is @option{-fno-signaling-nans}.\n+\n+This option is experimental and does not currently guarantee to\n+disable all GCC optimizations that affect signaling NaN behavior.\n+\n @item -fno-zero-initialized-in-bss\n @opindex fno-zero-initialized-in-bss\n If the target supports a BSS section, GCC by default puts variables that"}, {"sha": "06ebd20a59d5ef15e4e94b7fc61cbb830572cffc", "filename": "gcc/flags.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=52bfebf09121f90fb62f448ccb817ce9208d8f24", "patch": "@@ -663,6 +663,9 @@ extern int flag_non_call_exceptions;\n /* Nonzero means put zero initialized data in the bss section.  */\n extern int flag_zero_initialized_in_bss;\n \n+/* Nonzero means disable transformations observable by signaling NaNs.  */\n+extern int flag_signaling_nans;\n+\n /* True if the given mode has a NaN representation and the treatment of\n    NaN operands is important.  Certain optimizations, such as folding\n    x * 0 into x, are not correct for NaN operands, and are normally\n@@ -671,6 +674,9 @@ extern int flag_zero_initialized_in_bss;\n #define HONOR_NANS(MODE) \\\n   (MODE_HAS_NANS (MODE) && !flag_unsafe_math_optimizations)\n \n+/* Like HONOR_NANs, but true if we honor signaling NaNs (or sNaNs).  */\n+#define HONOR_SNANS(MODE) (flag_signaling_nans && HONOR_NANS (MODE))\n+\n /* As for HONOR_NANS, but true if the mode can represent infinity and\n    the treatment of infinite values is important.  */\n #define HONOR_INFINITIES(MODE) \\"}, {"sha": "49c53cc0857daf3600ab9caab5873d05c0a77a22", "filename": "gcc/fold-const.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=52bfebf09121f90fb62f448ccb817ce9208d8f24", "patch": "@@ -5476,16 +5476,13 @@ fold (expr)\n \t      && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg0)))\n \t      && real_zerop (arg1))\n \t    return omit_one_operand (type, arg1, arg0);\n-\t  /* In IEEE floating point, x*1 is not equivalent to x for snans.\n-\t     However, ANSI says we can drop signals,\n-\t     so we can do this anyway.  */\n-\t  if (real_onep (arg1))\n+\t  /* In IEEE floating point, x*1 is not equivalent to x for snans.  */\n+\t  if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n+\t      && real_onep (arg1))\n \t    return non_lvalue (convert (type, arg0));\n \n-\t  /* Transform x * -1.0 into -x.  This should be safe for NaNs,\n-\t     signed zeros and signed infinities, but is currently\n-\t     restricted to \"unsafe math optimizations\" just in case.  */\n-\t  if (flag_unsafe_math_optimizations\n+\t  /* Transform x * -1.0 into -x.  */\n+\t  if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n \t      && real_minus_onep (arg1))\n \t    return fold (build1 (NEGATE_EXPR, type, arg0));\n \n@@ -5620,9 +5617,9 @@ fold (expr)\n \treturn fold (build (RDIV_EXPR, type, TREE_OPERAND (arg0, 0),\n \t\t\t    TREE_OPERAND (arg1, 0)));\n \n-      /* In IEEE floating point, x/1 is not equivalent to x for snans.\n-\t However, ANSI says we can drop signals, so we can do this anyway.  */\n-      if (real_onep (arg1))\n+      /* In IEEE floating point, x/1 is not equivalent to x for snans.  */\n+      if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n+\t  && real_onep (arg1))\n \treturn non_lvalue (convert (type, arg0));\n \n       /* If ARG1 is a constant, we can convert this to a multiply by the"}, {"sha": "6d391eaf374b55773a09686c3f2a1e50a28faaba", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=52bfebf09121f90fb62f448ccb817ce9208d8f24", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"flags.h\"\n #include \"basic-block.h\"\n+#include \"real.h\"\n \n /* Forward declarations */\n static int global_reg_mentioned_p_1 PARAMS ((rtx *, void *));\n@@ -2369,6 +2370,8 @@ may_trap_p (x)\n     case MOD:\n     case UDIV:\n     case UMOD:\n+      if (HONOR_SNANS (GET_MODE (x)))\n+\treturn 1;\n       if (! CONSTANT_P (XEXP (x, 1))\n \t  || (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT\n \t      && flag_trapping_math))\n@@ -2396,12 +2399,22 @@ may_trap_p (x)\n \t when COMPARE is used, though many targets do make this distinction.\n \t For instance, sparc uses CCFPE for compares which generate exceptions\n \t and CCFP for compares which do not generate exceptions.  */\n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+      if (HONOR_NANS (GET_MODE (x)))\n \treturn 1;\n       /* But often the compare has some CC mode, so check operand\n \t modes as well.  */\n-      if (GET_MODE_CLASS (GET_MODE (XEXP (x, 0))) == MODE_FLOAT\n-\t  || GET_MODE_CLASS (GET_MODE (XEXP (x, 1))) == MODE_FLOAT)\n+      if (HONOR_NANS (GET_MODE (XEXP (x, 0)))\n+\t  || HONOR_NANS (GET_MODE (XEXP (x, 1))))\n+\treturn 1;\n+      break;\n+\n+    case EQ:\n+    case NE:\n+      if (HONOR_SNANS (GET_MODE (x)))\n+\treturn 1;\n+      /* Often comparison is CC mode, so check operand modes.  */\n+      if (HONOR_SNANS (GET_MODE (XEXP (x, 0)))\n+\t  || HONOR_SNANS (GET_MODE (XEXP (x, 1))))\n \treturn 1;\n       break;\n "}, {"sha": "0565dcd32b888dcd0c0f92a85a92a8d66c83c0a1", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=52bfebf09121f90fb62f448ccb817ce9208d8f24", "patch": "@@ -2063,7 +2063,7 @@ simplify_relational_operation (code, mode, op0, op1)\n \n \tcase LT:\n \t  /* Optimize abs(x) < 0.0.  */\n-\t  if (trueop1 == CONST0_RTX (mode))\n+\t  if (trueop1 == CONST0_RTX (mode) && !HONOR_SNANS (mode))\n \t    {\n \t      tem = GET_CODE (trueop0) == FLOAT_EXTEND ? XEXP (trueop0, 0)\n \t\t\t\t\t\t       : trueop0;"}, {"sha": "e4aeca03875e44f2b39b8805830eb924914270b4", "filename": "gcc/toplev.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52bfebf09121f90fb62f448ccb817ce9208d8f24/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=52bfebf09121f90fb62f448ccb817ce9208d8f24", "patch": "@@ -577,10 +577,18 @@ int flag_unsafe_math_optimizations = 0;\n \n /* Zero means that floating-point math operations cannot generate a\n    (user-visible) trap.  This is the case, for example, in nonstop\n-   IEEE 754 arithmetic.  */\n+   IEEE 754 arithmetic.  Trapping conditions include division by zero,\n+   overflow, underflow, invalid and inexact, but does not include \n+   operations on signaling NaNs (see below).  */\n \n int flag_trapping_math = 1;\n \n+/* Nonzero means disable transformations observable by signaling NaNs.\n+   This option implies that any operation on a IEEE signaling NaN can\n+   generate a (user-visible) trap.  */\n+\n+int flag_signaling_nans = 0;\n+\n /* 0 means straightforward implementation of complex divide acceptable.\n    1 means wide ranges of inputs must work for complex divide.\n    2 means C99-like requirements for complex divide (not yet implemented).  */\n@@ -1170,6 +1178,8 @@ static const lang_independent_options f_options[] =\n    N_(\"Floating-point operations can trap\") },\n   {\"unsafe-math-optimizations\", &flag_unsafe_math_optimizations, 1,\n    N_(\"Allow math optimizations that may violate IEEE or ANSI standards\") },\n+  {\"signaling-nans\", &flag_signaling_nans, 1,\n+   N_(\"Disable optimizations observable by IEEE signaling NaNs\") },\n   {\"bounded-pointers\", &flag_bounded_pointers, 1,\n    N_(\"Compile pointers as triples: value, base & end\") },\n   {\"bounds-check\", &flag_bounds_check, 1,\n@@ -1566,6 +1576,8 @@ set_fast_math_flags (set)\n   flag_trapping_math = !set;\n   flag_unsafe_math_optimizations = set;\n   flag_errno_math = !set;\n+  if (set)\n+    flag_signaling_nans = 0;\n }\n \n /* Return true iff flags are set as if -ffast-math.  */\n@@ -5086,6 +5098,10 @@ process_options ()\n   if (flag_function_sections && write_symbols != NO_DEBUG)\n     warning (\"-ffunction-sections may affect debugging on some targets\");\n #endif\n+\n+    /* The presence of IEEE signaling NaNs, implies all math can trap.  */\n+    if (flag_signaling_nans)\n+      flag_trapping_math = 1;\n }\n \f\n /* Language-independent initialization, before language-dependent"}]}