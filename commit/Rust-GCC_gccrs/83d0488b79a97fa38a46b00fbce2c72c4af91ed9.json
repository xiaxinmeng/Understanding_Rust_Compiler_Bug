{"sha": "83d0488b79a97fa38a46b00fbce2c72c4af91ed9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNkMDQ4OGI3OWE5N2ZhMzhhNDZiMDBmYmNlMmM3MmM0YWY5MWVkOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-11-25T08:23:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-11-25T08:23:08Z"}, "message": "Tweak LRA handling of shared spill slots\n\nThe previous code processed the users of a stack slot in order of\ndecreasing size and allocated the slot based on the first user.\nThis seems a bit dangerous, since the ordering is based on the\nmode of the biggest reference while the allocation is based also\non the size of the register itself (which I think could be larger).\n\nThat scheme doesn't scale well to polynomial sizes, since there's\nno guarantee that the order of the sizes is known at compile time.\nThis patch instead records an upper bound on the size required\nby all users of a slot.  It also records the maximum alignment\nrequirement.\n\ngcc/\n2016-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\n\t* function.h (spill_slot_alignment): Declare.\n\t* function.c (spill_slot_alignment): New function.\n\t* lra-spills.c (slot): Add align and size fields.\n\t(assign_mem_slot): Use them in the call to assign_stack_local.\n\t(add_pseudo_to_slot): Update the fields.\n\t(assign_stack_slot_num_and_sort_pseudos): Initialise the fields.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r242863", "tree": {"sha": "a6a2d07e1d1291391656c78cb3726365e7c7a9a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6a2d07e1d1291391656c78cb3726365e7c7a9a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83d0488b79a97fa38a46b00fbce2c72c4af91ed9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d0488b79a97fa38a46b00fbce2c72c4af91ed9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83d0488b79a97fa38a46b00fbce2c72c4af91ed9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d0488b79a97fa38a46b00fbce2c72c4af91ed9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "664e69688d7681be99aaa900ef193d3196e4b7d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/664e69688d7681be99aaa900ef193d3196e4b7d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/664e69688d7681be99aaa900ef193d3196e4b7d1"}], "stats": {"total": 91, "additions": 51, "deletions": 40}, "files": [{"sha": "fefba90eab6c68c393f94ada579d63d8049f4446", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d0488b79a97fa38a46b00fbce2c72c4af91ed9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d0488b79a97fa38a46b00fbce2c72c4af91ed9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83d0488b79a97fa38a46b00fbce2c72c4af91ed9", "patch": "@@ -1,3 +1,14 @@\n+2016-11-25  Richard Sandiford  <richard.sandiford@arm.com>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* function.h (spill_slot_alignment): Declare.\n+\t* function.c (spill_slot_alignment): New function.\n+\t* lra-spills.c (slot): Add align and size fields.\n+\t(assign_mem_slot): Use them in the call to assign_stack_local.\n+\t(add_pseudo_to_slot): Update the fields.\n+\t(assign_stack_slot_num_and_sort_pseudos): Initialise the fields.\n+\n 2016-11-25  Richard Sandiford  <richard.sandiford@arm.com>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "c5a538f249b99299a7b831a38dc709afea0d2d92", "filename": "gcc/function.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d0488b79a97fa38a46b00fbce2c72c4af91ed9/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d0488b79a97fa38a46b00fbce2c72c4af91ed9/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=83d0488b79a97fa38a46b00fbce2c72c4af91ed9", "patch": "@@ -246,6 +246,14 @@ frame_offset_overflow (HOST_WIDE_INT offset, tree func)\n   return FALSE;\n }\n \n+/* Return the minimum spill slot alignment for a register of mode MODE.  */\n+\n+unsigned int\n+spill_slot_alignment (machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return STACK_SLOT_ALIGNMENT (NULL_TREE, mode, GET_MODE_ALIGNMENT (mode));\n+}\n+\n /* Return stack slot alignment in bits for TYPE and MODE.  */\n \n static unsigned int"}, {"sha": "74bd6abbb485895cf55ae7de366bd9fe13d9b8c0", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d0488b79a97fa38a46b00fbce2c72c4af91ed9/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d0488b79a97fa38a46b00fbce2c72c4af91ed9/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=83d0488b79a97fa38a46b00fbce2c72c4af91ed9", "patch": "@@ -570,6 +570,8 @@ extern HOST_WIDE_INT get_frame_size (void);\n    return FALSE.  */\n extern bool frame_offset_overflow (HOST_WIDE_INT, tree);\n \n+extern unsigned int spill_slot_alignment (machine_mode);\n+\n extern rtx assign_stack_local_1 (machine_mode, HOST_WIDE_INT, int, int);\n extern rtx assign_stack_local (machine_mode, HOST_WIDE_INT, int);\n extern rtx assign_stack_temp_for_type (machine_mode, HOST_WIDE_INT, tree);"}, {"sha": "9f1d5e97a5620205475a51bb78894765dba9c8e7", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83d0488b79a97fa38a46b00fbce2c72c4af91ed9/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83d0488b79a97fa38a46b00fbce2c72c4af91ed9/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=83d0488b79a97fa38a46b00fbce2c72c4af91ed9", "patch": "@@ -104,6 +104,10 @@ struct slot\n   /* Hard reg into which the slot pseudos are spilled.\tThe value is\n      negative for pseudos spilled into memory.\t*/\n   int hard_regno;\n+  /* Maximum alignment required by all users of the slot.  */\n+  unsigned int align;\n+  /* Maximum size required by all users of the slot.  */\n+  HOST_WIDE_INT size;\n   /* Memory representing the all stack slot.  It can be different from\n      memory representing a pseudo belonging to give stack slot because\n      pseudo can be placed in a part of the corresponding stack slot.\n@@ -128,51 +132,23 @@ assign_mem_slot (int i)\n {\n   rtx x = NULL_RTX;\n   machine_mode mode = GET_MODE (regno_reg_rtx[i]);\n-  unsigned int inherent_size = PSEUDO_REGNO_BYTES (i);\n-  unsigned int inherent_align = GET_MODE_ALIGNMENT (mode);\n-  unsigned int max_ref_width = GET_MODE_SIZE (lra_reg_info[i].biggest_mode);\n-  unsigned int total_size = MAX (inherent_size, max_ref_width);\n-  unsigned int min_align = max_ref_width * BITS_PER_UNIT;\n-  int adjust = 0;\n+  HOST_WIDE_INT inherent_size = PSEUDO_REGNO_BYTES (i);\n+  machine_mode wider_mode\n+    = (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (lra_reg_info[i].biggest_mode)\n+       ? mode : lra_reg_info[i].biggest_mode);\n+  HOST_WIDE_INT total_size = GET_MODE_SIZE (wider_mode);\n+  HOST_WIDE_INT adjust = 0;\n \n   lra_assert (regno_reg_rtx[i] != NULL_RTX && REG_P (regno_reg_rtx[i])\n \t      && lra_reg_info[i].nrefs != 0 && reg_renumber[i] < 0);\n \n-  x = slots[pseudo_slots[i].slot_num].mem;\n-\n-  /* We can use a slot already allocated because it is guaranteed the\n-     slot provides both enough inherent space and enough total\n-     space.  */\n-  if (x)\n-    ;\n-  /* Each pseudo has an inherent size which comes from its own mode,\n-     and a total size which provides room for paradoxical subregs\n-     which refer to the pseudo reg in wider modes.  We allocate a new\n-     slot, making sure that it has enough inherent space and total\n-     space.  */\n-  else\n+  unsigned int slot_num = pseudo_slots[i].slot_num;\n+  x = slots[slot_num].mem;\n+  if (!x)\n     {\n-      rtx stack_slot;\n-\n-      /* No known place to spill from => no slot to reuse.  */\n-      x = assign_stack_local (mode, total_size,\n-\t\t\t      min_align > inherent_align\n-\t\t\t      || total_size > inherent_size ? -1 : 0);\n-      stack_slot = x;\n-      /* Cancel the big-endian correction done in assign_stack_local.\n-\t Get the address of the beginning of the slot.\tThis is so we\n-\t can do a big-endian correction unconditionally below.\t*/\n-      if (BYTES_BIG_ENDIAN)\n-\t{\n-\t  adjust = inherent_size - total_size;\n-\t  if (adjust)\n-\t    stack_slot\n-\t      = adjust_address_nv (x,\n-\t\t\t\t   mode_for_size (total_size * BITS_PER_UNIT,\n-\t\t\t\t\t\t  MODE_INT, 1),\n-\t\t\t\t   adjust);\n-\t}\n-      slots[pseudo_slots[i].slot_num].mem = stack_slot;\n+      x = assign_stack_local (BLKmode, slots[slot_num].size,\n+\t\t\t      slots[slot_num].align);\n+      slots[slot_num].mem = x;\n     }\n \n   /* On a big endian machine, the \"address\" of the slot is the address\n@@ -335,6 +311,18 @@ add_pseudo_to_slot (int regno, int slot_num)\n {\n   struct pseudo_slot *first;\n \n+  /* Each pseudo has an inherent size which comes from its own mode,\n+     and a total size which provides room for paradoxical subregs.\n+     We need to make sure the size and alignment of the slot are\n+     sufficient for both.  */\n+  machine_mode mode = (GET_MODE_SIZE (PSEUDO_REGNO_MODE (regno))\n+\t\t       >= GET_MODE_SIZE (lra_reg_info[regno].biggest_mode)\n+\t\t       ? PSEUDO_REGNO_MODE (regno)\n+\t\t       : lra_reg_info[regno].biggest_mode);\n+  unsigned int align = spill_slot_alignment (mode);\n+  slots[slot_num].align = MAX (slots[slot_num].align, align);\n+  slots[slot_num].size = MAX (slots[slot_num].size, GET_MODE_SIZE (mode));\n+\n   if (slots[slot_num].regno < 0)\n     {\n       /* It is the first pseudo in the slot.  */\n@@ -385,6 +373,8 @@ assign_stack_slot_num_and_sort_pseudos (int *pseudo_regnos, int n)\n \t{\n \t  /* New slot.\t*/\n \t  slots[j].live_ranges = NULL;\n+\t  slots[j].size = 0;\n+\t  slots[j].align = BITS_PER_UNIT;\n \t  slots[j].regno = slots[j].hard_regno = -1;\n \t  slots[j].mem = NULL_RTX;\n \t  slots_num++;"}]}