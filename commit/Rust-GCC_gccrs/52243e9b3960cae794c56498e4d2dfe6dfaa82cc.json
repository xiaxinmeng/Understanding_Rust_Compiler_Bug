{"sha": "52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIyNDNlOWIzOTYwY2FlNzk0YzU2NDk4ZTRkMmRmZTZkZmFhODJjYw==", "commit": {"author": {"name": "Philip Herron", "email": "phil@nebuloninc.com", "date": "2020-04-13T21:52:23Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-27T17:02:35Z"}, "message": "Remove unused compilation code to GCC GENERIC.\n\nWire up Linemap abstraction object and location_t to Location", "tree": {"sha": "adedc08f42542c339589a5e6d6b745ae7215d2b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adedc08f42542c339589a5e6d6b745ae7215d2b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/comments", "author": null, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a2b1a2084aedb12154df1e523cf3092ff563a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a2b1a2084aedb12154df1e523cf3092ff563a95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a2b1a2084aedb12154df1e523cf3092ff563a95"}], "stats": {"total": 4475, "additions": 1250, "deletions": 3225}, "files": [{"sha": "588a05e348d6687b6fea9c3745d3bc8757961617", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -62,6 +62,7 @@ GRS_OBJS = \\\n     rust/rust-object-export.o \\\n     rust/rust-linemap.o \\\n     rust/rust-gcc-diagnostics.o \\\n+    rust/rust-diagnostics.o \\\n     rust/rust-gcc.o \\\n     rust/rust-token.o \\\n     rust/rust-lex.o \\"}, {"sha": "b68b770ba9d4dc66045672faa70bd49176e3ba97", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -1,8 +1,6 @@\n #include \"rust-ast-full.h\"\n-#include \"diagnostic.h\"\n-\n+#include \"rust-diagnostics.h\"\n #include \"rust-ast-visitor.h\"\n-\n #include \"rust-session-manager.h\"\n \n /* Compilation unit used for various AST-related functions that would make the headers too long if\n@@ -2128,9 +2126,9 @@ namespace Rust {\n             }\n \n             // kind of a HACK to get locus depending on opening scope resolution\n-            location_t locus = UNKNOWN_LOCATION;\n+            Location locus = Linemap::unknown_location();\n             if (with_opening_scope_resolution) {\n-                locus = simple_segments[0].get_locus() - 2; // minus 2 chars for ::\n+                locus = simple_segments[0].get_locus()/* - 2*/; // minus 2 chars for ::\n             } else {\n                 locus = simple_segments[0].get_locus();\n             }\n@@ -2513,7 +2511,7 @@ namespace Rust {\n         TraitBound* TypePath::to_trait_bound(bool in_parens) const {\n             // create clone FIXME is this required? or is copy constructor automatically called?\n             TypePath copy(*this);\n-            return new TraitBound(::std::move(copy), in_parens);\n+            return new TraitBound(::std::move(copy), copy.get_locus(), in_parens);\n         }\n \n         ::std::string InferredType::as_string() const {\n@@ -3457,7 +3455,7 @@ namespace Rust {\n                         return parse_path_meta_item();\n                     }\n                     default:\n-                        error_at(peek_token()->get_locus(), \"unrecognised token '%s' in meta item\",\n+                        rust_error_at(peek_token()->get_locus(), \"unrecognised token '%s' in meta item\",\n                           get_token_description(peek_token()->get_id()));\n                         return NULL;\n                 }\n@@ -3494,7 +3492,7 @@ namespace Rust {\n             }\n \n             if (peek_token(1)->get_id() != LEFT_PAREN) {\n-                error_at(peek_token(1)->get_locus(),\n+                rust_error_at(peek_token(1)->get_locus(),\n                   \"unexpected token '%s' after identifier in attribute\",\n                   get_token_description(peek_token(1)->get_id()));\n                 return NULL;\n@@ -3551,7 +3549,7 @@ namespace Rust {\n                   new MetaListPaths(::std::move(ident), ::std::move(path_items)));\n             }\n \n-            error_at(UNKNOWN_LOCATION, \"failed to parse any meta item inner\");\n+            rust_error_at(Linemap::unknown_location(), \"failed to parse any meta item inner\");\n             return NULL;\n         }\n \n@@ -3562,7 +3560,7 @@ namespace Rust {\n         ::std::unique_ptr<MetaItem> MacroParser::parse_path_meta_item() {\n             SimplePath path = parse_simple_path();\n             if (path.is_empty()) {\n-                error_at(peek_token()->get_locus(), \"failed to parse simple path in attribute\");\n+                rust_error_at(peek_token()->get_locus(), \"failed to parse simple path in attribute\");\n                 return NULL;\n             }\n \n@@ -3577,10 +3575,10 @@ namespace Rust {\n                 case EQUAL: {\n                     skip_token();\n \n-                    location_t locus = peek_token()->get_locus();\n+                    Location locus = peek_token()->get_locus();\n                     Literal lit = parse_literal();\n                     if (lit.is_error()) {\n-                        error_at(peek_token()->get_locus(), \"failed to parse literal in attribute\");\n+                        rust_error_at(peek_token()->get_locus(), \"failed to parse literal in attribute\");\n                         return NULL;\n                     }\n                     LiteralExpr expr(::std::move(lit), locus);\n@@ -3594,7 +3592,7 @@ namespace Rust {\n                     // just simple path\n                     return ::std::unique_ptr<MetaItemPath>(new MetaItemPath(::std::move(path)));\n                 default:\n-                    error_at(peek_token()->get_locus(), \"unrecognised token '%s' in meta item\",\n+                    rust_error_at(peek_token()->get_locus(), \"unrecognised token '%s' in meta item\",\n                       get_token_description(peek_token()->get_id()));\n                     return NULL;\n             }\n@@ -3612,15 +3610,15 @@ namespace Rust {\n             ::std::vector< ::std::unique_ptr<MetaItemInner> > meta_items;\n \n             if (peek_token()->get_id() != LEFT_PAREN) {\n-                error_at(peek_token()->get_locus(), \"missing left paren in delim token tree\");\n+                rust_error_at(peek_token()->get_locus(), \"missing left paren in delim token tree\");\n                 return {};\n             }\n             skip_token();\n \n             while (stream_pos < vec_length && peek_token()->get_id() != RIGHT_PAREN) {\n                 ::std::unique_ptr<MetaItemInner> inner = parse_meta_item_inner();\n                 if (inner == NULL) {\n-                    error_at(\n+                    rust_error_at(\n                       peek_token()->get_locus(), \"failed to parse inner meta item in attribute\");\n                     return {};\n                 }\n@@ -3633,7 +3631,7 @@ namespace Rust {\n             }\n \n             if (peek_token()->get_id() != RIGHT_PAREN) {\n-                error_at(peek_token()->get_locus(), \"missing right paren in delim token tree\");\n+                rust_error_at(peek_token()->get_locus(), \"missing right paren in delim token tree\");\n                 return {};\n             }\n             skip_token();\n@@ -3647,7 +3645,7 @@ namespace Rust {\n \n             // simulate presence of delimiters\n             tokens.push_back(::std::unique_ptr<Token>(\n-              new Token(LEFT_PAREN, UNKNOWN_LOCATION, \"\", CORETYPE_UNKNOWN)));\n+              new Token(LEFT_PAREN, Linemap::unknown_location(), \"\", CORETYPE_UNKNOWN)));\n \n             for (const auto& tree : token_trees) {\n                 ::std::vector< ::std::unique_ptr<Token> > stream = tree->to_token_stream();\n@@ -3657,7 +3655,7 @@ namespace Rust {\n             }\n \n             tokens.push_back(::std::unique_ptr<Token>(\n-              new Token(RIGHT_PAREN, UNKNOWN_LOCATION, \"\", CORETYPE_UNKNOWN)));\n+              new Token(RIGHT_PAREN, Linemap::unknown_location(), \"\", CORETYPE_UNKNOWN)));\n \n             tokens.shrink_to_fit();\n \n@@ -3692,7 +3690,7 @@ namespace Rust {\n                     skip_token();\n                     return Literal(\"false\", Literal::BOOL);\n                 default:\n-                    error_at(tok->get_locus(), \"expected literal - found '%s'\",\n+                    rust_error_at(tok->get_locus(), \"expected literal - found '%s'\",\n                       get_token_description(tok->get_id()));\n                     return Literal::create_error();\n             }\n@@ -3709,7 +3707,7 @@ namespace Rust {\n \n             SimplePathSegment segment = parse_simple_path_segment();\n             if (segment.is_error()) {\n-                error_at(peek_token()->get_locus(),\n+                rust_error_at(peek_token()->get_locus(),\n                   \"failed to parse simple path segment in attribute simple path\");\n                 return SimplePath::create_empty();\n             }\n@@ -3720,7 +3718,7 @@ namespace Rust {\n \n                 SimplePathSegment segment = parse_simple_path_segment();\n                 if (segment.is_error()) {\n-                    error_at(peek_token()->get_locus(),\n+                    rust_error_at(peek_token()->get_locus(),\n                       \"failed to parse simple path segment in attribute simple path\");\n                     return SimplePath::create_empty();\n                 }\n@@ -3753,14 +3751,14 @@ namespace Rust {\n                     }\n                     gcc_fallthrough();\n                 default:\n-                    error_at(tok->get_locus(), \"unexpected token '%s' in simple path segment\",\n+                    rust_error_at(tok->get_locus(), \"unexpected token '%s' in simple path segment\",\n                       get_token_description(tok->get_id()));\n                     return SimplePathSegment::create_error();\n             }\n         }\n \n         ::std::unique_ptr<MetaItemLitExpr> MacroParser::parse_meta_item_lit() {\n-            location_t locus = peek_token()->get_locus();\n+            Location locus = peek_token()->get_locus();\n             LiteralExpr lit_expr(parse_literal(), locus);\n             return ::std::unique_ptr<MetaItemLitExpr>(new MetaItemLitExpr(::std::move(lit_expr)));\n         }\n@@ -3802,7 +3800,7 @@ namespace Rust {\n             } else if (ident == \"not\") {\n                 if (strs.size() != 1) {\n                     // HACK: convert vector platform-dependent size_type to string to use in printf\n-                    error_at(UNKNOWN_LOCATION,\n+                    rust_error_at(Linemap::unknown_location(),\n                       \"cfg predicate could not be checked for MetaListNameValueStr with ident of \"\n                       \"'not' because there are '%s' elements, not '1'\",\n                       ::std::to_string(strs.size()).c_str());\n@@ -3811,7 +3809,7 @@ namespace Rust {\n \n                 return !strs[0].check_cfg_predicate(session);\n             } else {\n-                error_at(UNKNOWN_LOCATION,\n+                rust_error_at(Linemap::unknown_location(),\n                   \"cfg predicate could not be checked for MetaListNameValueStr with ident of \"\n                   \"'%s' - ident must be 'all' or 'any'\",\n                   ident.c_str());\n@@ -3837,7 +3835,7 @@ namespace Rust {\n             } else if (ident == \"not\") {\n                 if (paths.size() != 1) {\n                     // HACK: convert vector platform-dependent size_type to string to use in printf\n-                    error_at(UNKNOWN_LOCATION,\n+                    rust_error_at(Linemap::unknown_location(),\n                       \"cfg predicate could not be checked for MetaListPaths with ident of 'not' \"\n                       \"because there are '%s' elements, not '1'\",\n                       ::std::to_string(paths.size()).c_str());\n@@ -3846,7 +3844,7 @@ namespace Rust {\n \n                 return !check_path_exists_in_cfg(session, paths[0]);\n             } else {\n-                error_at(UNKNOWN_LOCATION,\n+                rust_error_at(Linemap::unknown_location(),\n                   \"cfg predicate could not be checked for MetaListNameValueStr with ident of \"\n                   \"'%s' - ident must be 'all' or 'any'\",\n                   ident.c_str());\n@@ -3881,7 +3879,7 @@ namespace Rust {\n             } else if (path.as_string() == \"not\") {\n                 if (seq.size() != 1) {\n                     // HACK: convert vector platform-dependent size_type to string to use in printf\n-                    error_at(UNKNOWN_LOCATION,\n+                    rust_error_at(Linemap::unknown_location(),\n                       \"cfg predicate could not be checked for MetaItemSeq with ident of 'not' \"\n                       \"because there are '%s' elements, not '1'\",\n                       ::std::to_string(seq.size()).c_str());\n@@ -3890,7 +3888,7 @@ namespace Rust {\n \n                 return !seq[0]->check_cfg_predicate(session);\n             } else {\n-                error_at(UNKNOWN_LOCATION,\n+                rust_error_at(Linemap::unknown_location(),\n                   \"cfg predicate could not be checked for MetaItemSeq with path of \"\n                   \"'%s' - path must be 'all' or 'any'\",\n                   path.as_string().c_str());"}, {"sha": "0d50f592db78569fa49d082690c4b28a1ec1f103", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -18,9 +18,11 @@\n // required for AST::Token\n #include \"rust-token.h\"\n \n+#include \"rust-location.h\"\n+\n namespace Rust {\n     // TODO: remove typedefs and make actual types for these\n-    // typedef int location_t;\n+    // typedef int Location;\n     // typedef ::std::string SimplePath;\n     typedef ::std::string Identifier;\n     typedef int TupleIndex;\n@@ -37,13 +39,13 @@ namespace Rust {\n         // Base AST node object - TODO is this really required or useful? Where to draw line?\n         /*class Node {\n           public:\n-            // Gets node's location_t.\n-            location_t get_locus() const {\n+            // Gets node's Location.\n+            Location get_locus() const {\n                 return loc;\n             }\n \n-            // Sets node's location_t.\n-            void set_locus(location_t loc_) {\n+            // Sets node's Location.\n+            void set_locus(Location loc_) {\n                 loc = loc_;\n             }\n \n@@ -52,11 +54,11 @@ namespace Rust {\n \n             virtual ~Node() {}\n \n-            // TODO: constructor including location_t? Make all derived classes have location_t?\n+            // TODO: constructor including Location? Make all derived classes have Location?\n \n           private:\n             // The node's location.\n-            location_t loc;\n+            Location loc;\n         };*/\n         // decided to not have node as a \"node\" would never need to be stored\n \n@@ -141,7 +143,7 @@ namespace Rust {\n             // Token kind.\n             TokenId token_id;\n             // Token location.\n-            location_t locus;\n+            Location locus;\n             // Associated text (if any) of token.\n             std::string str;\n             // Token type hint (if any).\n@@ -155,7 +157,7 @@ namespace Rust {\n \n             // constructor from general text - avoid using if lexer const_TokenPtr is available\n             Token(\n-              TokenId token_id, location_t locus, ::std::string str, PrimitiveCoreType type_hint) :\n+              TokenId token_id, Location locus, ::std::string str, PrimitiveCoreType type_hint) :\n               token_id(token_id),\n               locus(locus), str(::std::move(str)), type_hint(type_hint) {}\n \n@@ -197,7 +199,7 @@ namespace Rust {\n                 return token_id;\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -268,7 +270,7 @@ namespace Rust {\n             DelimType delim_type;\n             ::std::vector< ::std::unique_ptr<TokenTree> > token_trees;\n \n-            location_t locus;\n+            Location locus;\n \n             // TODO: move all the \"parse\" functions into a separate class that has the token stream\n             // reference - will be cleaner Parse a meta item inner.\n@@ -299,12 +301,12 @@ namespace Rust {\n \n           public:\n             DelimTokenTree(DelimType delim_type,\n-              ::std::vector< ::std::unique_ptr<TokenTree> > token_trees\n-              = ::std::vector< ::std::unique_ptr<TokenTree> >(),\n-              location_t locus = UNKNOWN_LOCATION) :\n-              delim_type(delim_type),\n-              token_trees(::std::move(token_trees)), locus(locus) {}\n-\n+                           ::std::vector< ::std::unique_ptr<TokenTree> > token_trees\n+                           = ::std::vector< ::std::unique_ptr<TokenTree> >(),\n+                           Location locus = Location()) :\n+                delim_type(delim_type),\n+                token_trees(::std::move(token_trees)), locus(locus) {}\n+            \n             // Copy constructor with vector clone\n             DelimTokenTree(DelimTokenTree const& other) :\n               delim_type(other.delim_type), locus(other.locus) {\n@@ -370,12 +372,12 @@ namespace Rust {\n         // A segment of a simple path without generic or type arguments\n         class SimplePathSegment : public PathSegment {\n             ::std::string segment_name;\n-            location_t locus;\n+            Location locus;\n \n             // only allow identifiers, \"super\", \"self\", \"crate\", or \"$crate\"\n           public:\n             // TODO: put checks in constructor to enforce this rule?\n-            SimplePathSegment(::std::string segment_name, location_t locus = UNKNOWN_LOCATION) :\n+            SimplePathSegment(::std::string segment_name, Location locus = Location()) :\n               segment_name(::std::move(segment_name)), locus(locus) {}\n \n             // Returns whether simple path segment is in an invalid state (currently, if empty).\n@@ -390,7 +392,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            inline location_t get_locus() const {\n+            inline Location get_locus() const {\n                 return locus;\n             }\n \n@@ -401,12 +403,12 @@ namespace Rust {\n         class SimplePath {\n             bool has_opening_scope_resolution;\n             ::std::vector<SimplePathSegment> segments;\n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Constructor\n             SimplePath(::std::vector<SimplePathSegment> path_segments,\n-              bool has_opening_scope_resolution = false, location_t locus = UNKNOWN_LOCATION) :\n+              bool has_opening_scope_resolution = false, Location locus = Location()) :\n               has_opening_scope_resolution(has_opening_scope_resolution),\n               segments(::std::move(path_segments)), locus(locus) {}\n \n@@ -422,7 +424,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -455,7 +457,7 @@ namespace Rust {\n             // AttrInput* attr_input;\n             ::std::unique_ptr<AttrInput> attr_input;\n \n-            location_t locus;\n+            Location locus;\n \n             // TODO: maybe a variable storing whether attr input is parsed or not\n \n@@ -467,7 +469,7 @@ namespace Rust {\n \n             // Constructor has pointer AttrInput for polymorphism reasons\n             Attribute(SimplePath path, ::std::unique_ptr<AttrInput> input,\n-              location_t locus = UNKNOWN_LOCATION) :\n+              Location locus = Location()) :\n               path(::std::move(path)),\n               attr_input(::std::move(input)), locus(locus) {}\n \n@@ -803,8 +805,8 @@ namespace Rust {\n             virtual ~Expr() {}\n \n             // HACK: slow way of getting location from base expression through virtual methods.\n-            virtual location_t get_locus_slow() const {\n-                return UNKNOWN_LOCATION;\n+            virtual Location get_locus_slow() const {\n+                return Location();\n             }\n \n             virtual void accept_vis(ASTVisitor& vis) = 0;\n@@ -860,10 +862,10 @@ namespace Rust {\n         class IdentifierExpr : public ExprWithoutBlock {\n             Identifier ident;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n-            IdentifierExpr(Identifier ident, location_t locus = UNKNOWN_LOCATION,\n+            IdentifierExpr(Identifier ident, Location locus = Location(),\n               ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n               ExprWithoutBlock(::std::move(outer_attrs)),\n               ident(::std::move(ident)), locus(locus) {}\n@@ -872,11 +874,11 @@ namespace Rust {\n                 return ident;\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -994,12 +996,12 @@ namespace Rust {\n             ::std::string lifetime_name;\n             // only applies for NAMED lifetime_type\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Constructor\n             Lifetime(LifetimeType type, ::std::string name = ::std::string(),\n-              location_t locus = UNKNOWN_LOCATION) :\n+              Location locus = Location()) :\n               lifetime_type(type),\n               lifetime_name(::std::move(name)), locus(locus) {}\n \n@@ -1055,7 +1057,7 @@ namespace Rust {\n             //::std::unique_ptr<Attribute> outer_attr;\n             Attribute outer_attr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether the lifetime param has any lifetime bounds.\n@@ -1079,7 +1081,7 @@ namespace Rust {\n             }\n \n             // Constructor\n-            LifetimeParam(Lifetime lifetime, location_t locus = UNKNOWN_LOCATION,\n+            LifetimeParam(Lifetime lifetime, Location locus = Location(),\n               ::std::vector<Lifetime> lifetime_bounds = ::std::vector<Lifetime>(),\n               Attribute outer_attr = Attribute::create_empty()) :\n               lifetime(::std::move(lifetime)),\n@@ -1213,14 +1215,14 @@ namespace Rust {\n             //::std::vector<TokenTree> token_trees;\n             ::std::vector< ::std::unique_ptr<TokenTree> > token_trees;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n             MacroInvocationSemi(SimplePath macro_path, DelimType delim_type,\n               ::std::vector< ::std::unique_ptr<TokenTree> > token_trees,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               MacroItem(::std::move(outer_attribs)),\n               path(::std::move(macro_path)), delim_type(delim_type),\n               token_trees(::std::move(token_trees)), locus(locus) {}"}, {"sha": "ea0ac204bd5c65764c2429ed003b342abb80bd09", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 151, "deletions": 151, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -67,7 +67,7 @@ namespace Rust {\n             // moved to Literal\n             Literal literal;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const {\n@@ -78,12 +78,12 @@ namespace Rust {\n                 return literal.get_lit_type();\n             }\n \n-            LiteralExpr(::std::string value_as_string, Literal::LitType type, location_t locus,\n+            LiteralExpr(::std::string value_as_string, Literal::LitType type, Location locus,\n               ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n               ExprWithoutBlock(::std::move(outer_attrs)),\n               literal(::std::move(value_as_string), type), locus(locus) {}\n \n-            LiteralExpr(Literal literal, location_t locus,\n+            LiteralExpr(Literal literal, Location locus,\n               ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n               ExprWithoutBlock(::std::move(outer_attrs)),\n               literal(::std::move(literal)), locus(locus) {}\n@@ -93,11 +93,11 @@ namespace Rust {\n                 return ::std::unique_ptr<LiteralExpr>(clone_literal_expr_impl());\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -261,7 +261,7 @@ namespace Rust {\n         class OperatorExpr : public ExprWithoutBlock {\n             // TODO: create binary and unary operator subclasses?\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Variable must be protected to allow derived classes to use it as a first class citizen\n@@ -270,7 +270,7 @@ namespace Rust {\n \n             // Constructor (only for initialisation of expr purposes)\n             OperatorExpr(::std::unique_ptr<Expr> main_or_left_expr,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               locus(locus), main_or_left_expr(::std::move(main_or_left_expr)) {}\n \n@@ -310,11 +310,11 @@ namespace Rust {\n                 delete main_or_left_expr;\n             }*/\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n         };\n@@ -328,7 +328,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             BorrowExpr(::std::unique_ptr<Expr> borrow_lvalue, bool is_mut_borrow,\n-              bool is_double_borrow, ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              bool is_double_borrow, ::std::vector<Attribute> outer_attribs, Location locus) :\n               OperatorExpr(::std::move(borrow_lvalue), ::std::move(outer_attribs), locus),\n               is_mut(is_mut_borrow), double_borrow(is_double_borrow) {}\n \n@@ -364,7 +364,7 @@ namespace Rust {\n \n             // Constructor calls OperatorExpr's protected constructor\n             DereferenceExpr(::std::unique_ptr<Expr> deref_lvalue,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               OperatorExpr(::std::move(deref_lvalue), ::std::move(outer_attribs), locus) {}\n \n             // Copy constructor - define here if required\n@@ -399,7 +399,7 @@ namespace Rust {\n \n             // Constructor calls OperatorExpr's protected constructor\n             ErrorPropagationExpr(::std::unique_ptr<Expr> potential_error_value,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               OperatorExpr(::std::move(potential_error_value), ::std::move(outer_attribs), locus) {}\n \n             // Copy constructor - define here if required\n@@ -447,7 +447,7 @@ namespace Rust {\n \n             // Constructor calls OperatorExpr's protected constructor\n             NegationExpr(::std::unique_ptr<Expr> negated_value, NegationType negation_kind,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               OperatorExpr(::std::move(negated_value), ::std::move(outer_attribs), locus),\n               negation_type(negation_kind) {}\n \n@@ -512,7 +512,7 @@ namespace Rust {\n \n             // Constructor calls OperatorExpr's protected constructor\n             ArithmeticOrLogicalExpr(::std::unique_ptr<Expr> left_value,\n-              ::std::unique_ptr<Expr> right_value, ExprType expr_kind, location_t locus) :\n+              ::std::unique_ptr<Expr> right_value, ExprType expr_kind, Location locus) :\n               OperatorExpr(::std::move(left_value), ::std::vector<Attribute>(), locus),\n               expr_type(expr_kind), right_expr(::std::move(right_value)) {}\n             // outer attributes not allowed\n@@ -588,7 +588,7 @@ namespace Rust {\n \n             // Constructor requires pointers for polymorphism\n             ComparisonExpr(::std::unique_ptr<Expr> left_value, ::std::unique_ptr<Expr> right_value,\n-              ExprType comparison_kind, location_t locus) :\n+              ExprType comparison_kind, Location locus) :\n               OperatorExpr(::std::move(left_value), ::std::vector<Attribute>(), locus),\n               expr_type(comparison_kind), right_expr(::std::move(right_value)) {}\n             // outer attributes not allowed\n@@ -651,7 +651,7 @@ namespace Rust {\n \n             // Constructor calls OperatorExpr's protected constructor\n             LazyBooleanExpr(::std::unique_ptr<Expr> left_bool_expr,\n-              ::std::unique_ptr<Expr> right_bool_expr, ExprType expr_kind, location_t locus) :\n+              ::std::unique_ptr<Expr> right_bool_expr, ExprType expr_kind, Location locus) :\n               OperatorExpr(::std::move(left_bool_expr), ::std::vector<Attribute>(), locus),\n               expr_type(expr_kind), right_expr(::std::move(right_bool_expr)) {}\n             // outer attributes not allowed\n@@ -711,7 +711,7 @@ namespace Rust {\n \n             // Constructor requires calling protected constructor of OperatorExpr\n             TypeCastExpr(::std::unique_ptr<Expr> expr_to_cast,\n-              ::std::unique_ptr<TypeNoBounds> type_to_cast_to, location_t locus) :\n+              ::std::unique_ptr<TypeNoBounds> type_to_cast_to, Location locus) :\n               OperatorExpr(::std::move(expr_to_cast), ::std::vector<Attribute>(), locus),\n               type_to_convert_to(::std::move(type_to_cast_to)) {}\n             // outer attributes not allowed\n@@ -767,7 +767,7 @@ namespace Rust {\n \n             // Call OperatorExpr constructor to initialise left_expr\n             AssignmentExpr(::std::unique_ptr<Expr> value_to_assign_to,\n-              ::std::unique_ptr<Expr> value_to_assign, location_t locus) :\n+              ::std::unique_ptr<Expr> value_to_assign, Location locus) :\n               OperatorExpr(::std::move(value_to_assign_to), ::std::vector<Attribute>(), locus),\n               right_expr(::std::move(value_to_assign)) {}\n             // outer attributes not allowed\n@@ -860,7 +860,7 @@ namespace Rust {\n \n             // Use pointers in constructor to enable polymorphism\n             CompoundAssignmentExpr(::std::unique_ptr<Expr> value_to_assign_to,\n-              ::std::unique_ptr<Expr> value_to_assign, ExprType expr_kind, location_t locus) :\n+              ::std::unique_ptr<Expr> value_to_assign, ExprType expr_kind, Location locus) :\n               OperatorExpr(::std::move(value_to_assign_to), ::std::vector<Attribute>(), locus),\n               expr_type(expr_kind), right_expr(::std::move(value_to_assign)) {}\n             // outer attributes not allowed\n@@ -910,7 +910,7 @@ namespace Rust {\n             // Expr* expr_in_parens;\n             ::std::unique_ptr<Expr> expr_in_parens;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~GroupedExpr() {\n@@ -925,7 +925,7 @@ namespace Rust {\n \n             GroupedExpr(::std::unique_ptr<Expr> parenthesised_expr,\n               ::std::vector<Attribute> inner_attribs, ::std::vector<Attribute> outer_attribs,\n-              location_t locus) :\n+              Location locus) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               inner_attrs(::std::move(inner_attribs)),\n               expr_in_parens(::std::move(parenthesised_expr)), locus(locus) {}\n@@ -952,11 +952,11 @@ namespace Rust {\n             GroupedExpr(GroupedExpr&& other) = default;\n             GroupedExpr& operator=(GroupedExpr&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -1101,7 +1101,7 @@ namespace Rust {\n             // ArrayElems internal_elements;\n             ::std::unique_ptr<ArrayElems> internal_elements;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -1118,7 +1118,7 @@ namespace Rust {\n             // Constructor requires ArrayElems pointer\n             ArrayExpr(::std::unique_ptr<ArrayElems> array_elems,\n               ::std::vector<Attribute> inner_attribs, ::std::vector<Attribute> outer_attribs,\n-              location_t locus) :\n+              Location locus) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               inner_attrs(::std::move(inner_attribs)), internal_elements(::std::move(array_elems)),\n               locus(locus) {}\n@@ -1150,11 +1150,11 @@ namespace Rust {\n             ArrayExpr(ArrayExpr&& other) = default;\n             ArrayExpr& operator=(ArrayExpr&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -1182,7 +1182,7 @@ namespace Rust {\n             ::std::unique_ptr<Expr> array_expr;\n             ::std::unique_ptr<Expr> index_expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~ArrayIndexExpr() {\n@@ -1194,7 +1194,7 @@ namespace Rust {\n \n             ArrayIndexExpr(::std::unique_ptr<Expr> array_expr,\n               ::std::unique_ptr<Expr> array_index_expr, ::std::vector<Attribute> outer_attribs,\n-              location_t locus) :\n+              Location locus) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               array_expr(::std::move(array_expr)), index_expr(::std::move(array_index_expr)),\n               locus(locus) {}\n@@ -1221,11 +1221,11 @@ namespace Rust {\n             ArrayIndexExpr(ArrayIndexExpr&& other) = default;\n             ArrayIndexExpr& operator=(ArrayIndexExpr&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -1251,7 +1251,7 @@ namespace Rust {\n             ::std::vector< ::std::unique_ptr<Expr> > tuple_elems;\n             // replaces (inlined version of) TupleElements\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -1262,7 +1262,7 @@ namespace Rust {\n \n             TupleExpr(::std::vector< ::std::unique_ptr<Expr> > tuple_elements,\n               ::std::vector<Attribute> inner_attribs, ::std::vector<Attribute> outer_attribs,\n-              location_t locus) :\n+              Location locus) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               inner_attrs(::std::move(inner_attribs)), tuple_elems(::std::move(tuple_elements)),\n               locus(locus) {}\n@@ -1301,11 +1301,11 @@ namespace Rust {\n             // Note: syntactically, can disambiguate single-element tuple from parens with comma, i.e.\n             // (0,) rather than (0)\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -1331,7 +1331,7 @@ namespace Rust {\n             // TupleIndex is a decimal int literal with no underscores or suffix\n             TupleIndex tuple_index;\n \n-            location_t locus;\n+            Location locus;\n \n             // i.e. pair.0\n \n@@ -1347,7 +1347,7 @@ namespace Rust {\n             }\n \n             TupleIndexExpr(::std::unique_ptr<Expr> tuple_expr, TupleIndex index,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               tuple_expr(::std::move(tuple_expr)), tuple_index(index), locus(locus) {}\n \n@@ -1373,11 +1373,11 @@ namespace Rust {\n             TupleIndexExpr(TupleIndexExpr&& other) = default;\n             TupleIndexExpr& operator=(TupleIndexExpr&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -1416,7 +1416,7 @@ namespace Rust {\n         class StructExprStruct : public StructExpr {\n             ::std::vector<Attribute> inner_attrs;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -1427,15 +1427,15 @@ namespace Rust {\n \n             // Constructor has to call protected constructor of base class\n             StructExprStruct(PathInExpression struct_path, ::std::vector<Attribute> inner_attribs,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               StructExpr(::std::move(struct_path), ::std::move(outer_attribs)),\n               inner_attrs(::std::move(inner_attribs)), locus(locus) {}\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -1656,7 +1656,7 @@ namespace Rust {\n \n             // Constructor for StructExprStructFields when no struct base is used\n             StructExprStructFields(PathInExpression struct_path,\n-              ::std::vector< ::std::unique_ptr<StructExprField> > expr_fields, location_t locus,\n+              ::std::vector< ::std::unique_ptr<StructExprField> > expr_fields, Location locus,\n               StructBase base_struct = StructBase::error(),\n               ::std::vector<Attribute> inner_attribs = ::std::vector<Attribute>(),\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n@@ -1756,7 +1756,7 @@ namespace Rust {\n \n             StructExprStructBase(PathInExpression struct_path, StructBase base_struct,\n               ::std::vector<Attribute> inner_attribs, ::std::vector<Attribute> outer_attribs,\n-              location_t locus) :\n+              Location locus) :\n               StructExprStruct(::std::move(struct_path), ::std::move(inner_attribs),\n                 ::std::move(outer_attribs), locus),\n               struct_base(::std::move(base_struct)) {}\n@@ -1781,7 +1781,7 @@ namespace Rust {\n             //::std::vector<Expr> exprs;\n             ::std::vector< ::std::unique_ptr<Expr> > exprs;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -1797,7 +1797,7 @@ namespace Rust {\n             StructExprTuple(PathInExpression struct_path,\n               ::std::vector< ::std::unique_ptr<Expr> > tuple_exprs,\n               ::std::vector<Attribute> inner_attribs, ::std::vector<Attribute> outer_attribs,\n-              location_t locus) :\n+              Location locus) :\n               StructExpr(::std::move(struct_path), ::std::move(outer_attribs)),\n               inner_attrs(::std::move(inner_attribs)), exprs(::std::move(tuple_exprs)), locus(locus) {\n             }\n@@ -1833,11 +1833,11 @@ namespace Rust {\n             StructExprTuple(StructExprTuple&& other) = default;\n             StructExprTuple& operator=(StructExprTuple&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -1857,7 +1857,7 @@ namespace Rust {\n \n         // AST node of a \"unit\" struct creator (no fields and no braces)\n         class StructExprUnit : public StructExpr {\n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const {\n@@ -1866,15 +1866,15 @@ namespace Rust {\n             }\n \n             StructExprUnit(PathInExpression struct_path, ::std::vector<Attribute> outer_attribs,\n-              location_t locus) :\n+              Location locus) :\n               StructExpr(::std::move(struct_path), ::std::move(outer_attribs)),\n               locus(locus) {}\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -2024,7 +2024,7 @@ namespace Rust {\n             //::std::vector<EnumExprField> fields;\n             ::std::vector< ::std::unique_ptr<EnumExprField> > fields;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -2035,7 +2035,7 @@ namespace Rust {\n \n             EnumExprStruct(PathInExpression enum_variant_path,\n               ::std::vector< ::std::unique_ptr<EnumExprField> > variant_fields,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               EnumVariantExpr(::std::move(enum_variant_path), ::std::move(outer_attribs)),\n               fields(::std::move(variant_fields)), locus(locus) {}\n \n@@ -2068,11 +2068,11 @@ namespace Rust {\n             EnumExprStruct(EnumExprStruct&& other) = default;\n             EnumExprStruct& operator=(EnumExprStruct&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -2095,7 +2095,7 @@ namespace Rust {\n             //::std::vector<Expr> values;\n             ::std::vector< ::std::unique_ptr<Expr> > values;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -2106,7 +2106,7 @@ namespace Rust {\n \n             EnumExprTuple(PathInExpression enum_variant_path,\n               ::std::vector< ::std::unique_ptr<Expr> > variant_values,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               EnumVariantExpr(::std::move(enum_variant_path), ::std::move(outer_attribs)),\n               values(::std::move(variant_values)), locus(locus) {}\n \n@@ -2139,11 +2139,11 @@ namespace Rust {\n             EnumExprTuple(EnumExprTuple&& other) = default;\n             EnumExprTuple& operator=(EnumExprTuple&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -2163,7 +2163,7 @@ namespace Rust {\n \n         // No-field enum variant instance creation AST node\n         class EnumExprFieldless : public EnumVariantExpr {\n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const {\n@@ -2172,17 +2172,17 @@ namespace Rust {\n             }\n \n             EnumExprFieldless(PathInExpression enum_variant_path,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               EnumVariantExpr(::std::move(enum_variant_path), ::std::move(outer_attribs)),\n               locus(locus) {}\n \n             // copy constructor, destructor, and assignment operator should not need defining\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -2207,7 +2207,7 @@ namespace Rust {\n             //::std::vector<Expr> params; // inlined form of CallParams\n             ::std::vector< ::std::unique_ptr<Expr> > params;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~CallExpr() {\n@@ -2222,7 +2222,7 @@ namespace Rust {\n \n             CallExpr(::std::unique_ptr<Expr> function_expr,\n               ::std::vector< ::std::unique_ptr<Expr> > function_params,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               function(::std::move(function_expr)), params(::std::move(function_params)),\n               locus(locus) {}\n@@ -2268,11 +2268,11 @@ namespace Rust {\n                 return !params.empty();\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -2298,7 +2298,7 @@ namespace Rust {\n             //::std::vector<Expr> params; // inlined form of CallParams\n             ::std::vector< ::std::unique_ptr<Expr> > params;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~MethodCallExpr() {\n@@ -2313,7 +2313,7 @@ namespace Rust {\n \n             MethodCallExpr(::std::unique_ptr<Expr> call_receiver, PathExprSegment method_path,\n               ::std::vector< ::std::unique_ptr<Expr> > method_params,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               receiver(::std::move(call_receiver)), method_name(::std::move(method_path)),\n               params(::std::move(method_params)), locus(locus) {}\n@@ -2356,11 +2356,11 @@ namespace Rust {\n             MethodCallExpr(MethodCallExpr&& other) = default;\n             MethodCallExpr& operator=(MethodCallExpr&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -2385,7 +2385,7 @@ namespace Rust {\n             ::std::unique_ptr<Expr> receiver;\n             Identifier field;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~FieldAccessExpr() {\n@@ -2395,7 +2395,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             FieldAccessExpr(::std::unique_ptr<Expr> field_access_receiver, Identifier field_name,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               receiver(::std::move(field_access_receiver)), field(::std::move(field_name)),\n               locus(locus) {}\n@@ -2422,11 +2422,11 @@ namespace Rust {\n             FieldAccessExpr(FieldAccessExpr&& other) = default;\n             FieldAccessExpr& operator=(FieldAccessExpr&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -2509,23 +2509,23 @@ namespace Rust {\n             ::std::vector<ClosureParam> params; // may be empty\n             // also note a double pipe \"||\" can be used for empty params - does not need a space\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             ClosureExpr(::std::vector<ClosureParam> closure_params, bool has_move,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               has_move(has_move), params(::std::move(closure_params)), locus(locus) {}\n \n             // Copy constructor, destructor, and assignment operator override should not be needed\n           public:\n             virtual ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n         };\n@@ -2544,7 +2544,7 @@ namespace Rust {\n \n             // Constructor for a ClosureExprInner\n             ClosureExprInner(::std::unique_ptr<Expr> closure_inner_expr,\n-              ::std::vector<ClosureParam> closure_params, location_t locus, bool is_move = false,\n+              ::std::vector<ClosureParam> closure_params, Location locus, bool is_move = false,\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n               ClosureExpr(::std::move(closure_params), is_move, ::std::move(outer_attribs), locus),\n               closure_inner(::std::move(closure_inner_expr)) {}\n@@ -2600,7 +2600,7 @@ namespace Rust {\n             // bool has_expr;\n             ::std::unique_ptr<ExprWithoutBlock> expr; // inlined from Statements\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -2617,7 +2617,7 @@ namespace Rust {\n \n             BlockExpr(::std::vector< ::std::unique_ptr<Stmt> > block_statements,\n               ::std::unique_ptr<ExprWithoutBlock> block_expr, ::std::vector<Attribute> inner_attribs,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               ExprWithBlock(::std::move(outer_attribs)),\n               inner_attrs(::std::move(inner_attribs)), statements(::std::move(block_statements)),\n               expr(::std::move(block_expr)), locus(locus) {}\n@@ -2669,11 +2669,11 @@ namespace Rust {\n                 return ::std::unique_ptr<BlockExpr>(clone_block_expr_impl());\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -2714,7 +2714,7 @@ namespace Rust {\n             // Constructor potentially with a move\n             ClosureExprInnerTyped(::std::unique_ptr<Type> closure_return_type,\n               ::std::unique_ptr<BlockExpr> closure_expr, ::std::vector<ClosureParam> closure_params,\n-              location_t locus, bool is_move = false,\n+              Location locus, bool is_move = false,\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n               ClosureExpr(::std::move(closure_params), is_move, ::std::move(outer_attribs), locus),\n               return_type(::std::move(closure_return_type)), expr(::std::move(closure_expr)) {}\n@@ -2761,7 +2761,7 @@ namespace Rust {\n             // bool has_label;\n             Lifetime label;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -2772,18 +2772,18 @@ namespace Rust {\n             }\n \n             // Constructor for a ContinueExpr with a label.\n-            ContinueExpr(location_t locus, Lifetime label = Lifetime::error(),\n+            ContinueExpr(Location locus, Lifetime label = Lifetime::error(),\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               label(::std::move(label)), locus(locus) {}\n \n             // copy constructor, destructor, and assignment operator should not need defining\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -2811,7 +2811,7 @@ namespace Rust {\n             // Expr* break_expr; // may be uninitialised\n             ::std::unique_ptr<Expr> break_expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~BreakExpr() {\n@@ -2833,7 +2833,7 @@ namespace Rust {\n             }\n \n             // Constructor for a break expression\n-            BreakExpr(location_t locus, Lifetime break_label = Lifetime::error(),\n+            BreakExpr(Location locus, Lifetime break_label = Lifetime::error(),\n               ::std::unique_ptr<Expr> expr_in_break = NULL,\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n@@ -2865,11 +2865,11 @@ namespace Rust {\n             BreakExpr(BreakExpr&& other) = default;\n             BreakExpr& operator=(BreakExpr&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -2889,19 +2889,19 @@ namespace Rust {\n \n         // Base range expression AST node object - abstract\n         class RangeExpr : public ExprWithoutBlock {\n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // outer attributes not allowed before range expressions\n-            RangeExpr(location_t locus) :\n+            RangeExpr(Location locus) :\n               ExprWithoutBlock(::std::vector<Attribute>()), locus(locus) {}\n \n           public:\n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n         };\n@@ -2923,7 +2923,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             RangeFromToExpr(::std::unique_ptr<Expr> range_from, ::std::unique_ptr<Expr> range_to,\n-              location_t locus) :\n+              Location locus) :\n               RangeExpr(locus),\n               from(::std::move(range_from)), to(::std::move(range_to)) {}\n \n@@ -2973,7 +2973,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            RangeFromExpr(::std::unique_ptr<Expr> range_from, location_t locus) :\n+            RangeFromExpr(::std::unique_ptr<Expr> range_from, Location locus) :\n               RangeExpr(locus), from(::std::move(range_from)) {}\n \n             // Copy constructor with clone\n@@ -3022,7 +3022,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             // outer attributes not allowed\n-            RangeToExpr(::std::unique_ptr<Expr> range_to, location_t locus) :\n+            RangeToExpr(::std::unique_ptr<Expr> range_to, Location locus) :\n               RangeExpr(locus), to(::std::move(range_to)) {}\n \n             // Copy constructor with clone\n@@ -3062,7 +3062,7 @@ namespace Rust {\n           public:\n             ::std::string as_string() const;\n \n-            RangeFullExpr(location_t locus) : RangeExpr(locus) {}\n+            RangeFullExpr(Location locus) : RangeExpr(locus) {}\n             // outer attributes not allowed\n \n             virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n@@ -3096,7 +3096,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             RangeFromToInclExpr(::std::unique_ptr<Expr> range_from, ::std::unique_ptr<Expr> range_to,\n-              location_t locus) :\n+              Location locus) :\n               RangeExpr(locus),\n               from(::std::move(range_from)), to(::std::move(range_to)) {}\n             // outer attributes not allowed\n@@ -3147,7 +3147,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            RangeToInclExpr(::std::unique_ptr<Expr> range_to, location_t locus) :\n+            RangeToInclExpr(::std::unique_ptr<Expr> range_to, Location locus) :\n               RangeExpr(locus), to(::std::move(range_to)) {}\n             // outer attributes not allowed\n \n@@ -3189,7 +3189,7 @@ namespace Rust {\n             // Expr* return_expr;\n             ::std::unique_ptr<Expr> return_expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~ReturnExpr() {\n@@ -3206,7 +3206,7 @@ namespace Rust {\n             }\n \n             // Constructor for ReturnExpr.\n-            ReturnExpr(location_t locus, ::std::unique_ptr<Expr> returned_expr = NULL,\n+            ReturnExpr(Location locus, ::std::unique_ptr<Expr> returned_expr = NULL,\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n               ExprWithoutBlock(::std::move(outer_attribs)),\n               return_expr(::std::move(returned_expr)), locus(locus) {}\n@@ -3235,11 +3235,11 @@ namespace Rust {\n             ReturnExpr(ReturnExpr&& other) = default;\n             ReturnExpr& operator=(ReturnExpr&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -3270,7 +3270,7 @@ namespace Rust {\n             // BlockExpr* expr;\n             ::std::unique_ptr<BlockExpr> expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~UnsafeBlockExpr() {\n@@ -3280,7 +3280,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             UnsafeBlockExpr(::std::unique_ptr<BlockExpr> block_expr,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               ExprWithBlock(::std::move(outer_attribs)),\n               expr(::std::move(block_expr)), locus(locus) {}\n \n@@ -3304,11 +3304,11 @@ namespace Rust {\n             UnsafeBlockExpr(UnsafeBlockExpr&& other) = default;\n             UnsafeBlockExpr& operator=(UnsafeBlockExpr&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -3331,12 +3331,12 @@ namespace Rust {\n         class LoopLabel /*: public Node*/ {\n             Lifetime label; // or type LIFETIME_OR_LABEL\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n-            LoopLabel(Lifetime loop_label, location_t locus = UNKNOWN_LOCATION) :\n+            LoopLabel(Lifetime loop_label, Location locus = Location()) :\n               label(::std::move(loop_label)), locus(locus) {}\n \n             // Returns whether the LoopLabel is in an error state.\n@@ -3349,7 +3349,7 @@ namespace Rust {\n                 return LoopLabel(Lifetime::error());\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n         };\n@@ -3365,11 +3365,11 @@ namespace Rust {\n             ::std::unique_ptr<BlockExpr> loop_block;\n \n           private:\n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Constructor for BaseLoopExpr\n-            BaseLoopExpr(::std::unique_ptr<BlockExpr> loop_block, location_t locus,\n+            BaseLoopExpr(::std::unique_ptr<BlockExpr> loop_block, Location locus,\n               LoopLabel loop_label = LoopLabel::error(),\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n               ExprWithBlock(::std::move(outer_attribs)),\n@@ -3407,11 +3407,11 @@ namespace Rust {\n                 return !loop_label.is_error();\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n         };\n@@ -3422,7 +3422,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             // Constructor for LoopExpr\n-            LoopExpr(::std::unique_ptr<BlockExpr> loop_block, location_t locus,\n+            LoopExpr(::std::unique_ptr<BlockExpr> loop_block, Location locus,\n               LoopLabel loop_label = LoopLabel::error(),\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n               BaseLoopExpr(::std::move(loop_block), locus, ::std::move(loop_label),\n@@ -3458,7 +3458,7 @@ namespace Rust {\n \n             // Constructor for while loop with loop label\n             WhileLoopExpr(::std::unique_ptr<Expr> loop_condition,\n-              ::std::unique_ptr<BlockExpr> loop_block, location_t locus,\n+              ::std::unique_ptr<BlockExpr> loop_block, Location locus,\n               LoopLabel loop_label = LoopLabel::error(),\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n               BaseLoopExpr(\n@@ -3520,7 +3520,7 @@ namespace Rust {\n             // Constructor with a loop label\n             WhileLetLoopExpr(::std::vector< ::std::unique_ptr<Pattern> > match_arm_patterns,\n               ::std::unique_ptr<Expr> condition, ::std::unique_ptr<BlockExpr> loop_block,\n-              location_t locus, LoopLabel loop_label = LoopLabel::error(),\n+              Location locus, LoopLabel loop_label = LoopLabel::error(),\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n               BaseLoopExpr(\n                 ::std::move(loop_block), locus, ::std::move(loop_label), ::std::move(outer_attribs)),\n@@ -3595,7 +3595,7 @@ namespace Rust {\n             // Constructor with loop label\n             ForLoopExpr(::std::unique_ptr<Pattern> loop_pattern,\n               ::std::unique_ptr<Expr> iterator_expr, ::std::unique_ptr<BlockExpr> loop_body,\n-              location_t locus, LoopLabel loop_label = LoopLabel::error(),\n+              Location locus, LoopLabel loop_label = LoopLabel::error(),\n               ::std::vector<Attribute> outer_attribs = ::std::vector<Attribute>()) :\n               BaseLoopExpr(\n                 ::std::move(loop_body), locus, ::std::move(loop_label), ::std::move(outer_attribs)),\n@@ -3653,7 +3653,7 @@ namespace Rust {\n                 IfLetExpr if_let_expr;\n             } consequent_block;*/\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*virtual ~IfExpr() {\n@@ -3664,7 +3664,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             IfExpr(::std::unique_ptr<Expr> condition, ::std::unique_ptr<BlockExpr> if_block,\n-              location_t locus) :\n+              Location locus) :\n               ExprWithBlock(::std::vector<Attribute>()),\n               condition(::std::move(condition)), if_block(::std::move(if_block)), locus(locus) {}\n             // outer attributes are never allowed on IfExprs\n@@ -3699,11 +3699,11 @@ namespace Rust {\n              * else ifs - i.e. not like a switch statement. TODO - is this a better approach? or\n              * does it not parse correctly and have downsides? */\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -3739,7 +3739,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             IfExprConseqElse(::std::unique_ptr<Expr> condition, ::std::unique_ptr<BlockExpr> if_block,\n-              ::std::unique_ptr<BlockExpr> else_block, location_t locus) :\n+              ::std::unique_ptr<BlockExpr> else_block, Location locus) :\n               IfExpr(::std::move(condition), ::std::move(if_block), locus),\n               else_block(::std::move(else_block)) {}\n             // again, outer attributes not allowed\n@@ -3796,7 +3796,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             IfExprConseqIf(::std::unique_ptr<Expr> condition, ::std::unique_ptr<BlockExpr> if_block,\n-              ::std::unique_ptr<IfExpr> conseq_if_expr, location_t locus) :\n+              ::std::unique_ptr<IfExpr> conseq_if_expr, Location locus) :\n               IfExpr(::std::move(condition), ::std::move(if_block), locus),\n               if_expr(::std::move(conseq_if_expr)) {}\n             // outer attributes not allowed\n@@ -3854,14 +3854,14 @@ namespace Rust {\n                 IfLetExpr* if_let_expr;\n             } consequent_block;*/\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n             IfLetExpr(::std::vector< ::std::unique_ptr<Pattern> > match_arm_patterns,\n               ::std::unique_ptr<Expr> value, ::std::unique_ptr<BlockExpr> if_block,\n-              location_t locus) :\n+              Location locus) :\n               ExprWithBlock(::std::vector<Attribute>()),\n               match_arm_patterns(::std::move(match_arm_patterns)), value(::std::move(value)),\n               if_block(::std::move(if_block)), locus(locus) {}\n@@ -3909,11 +3909,11 @@ namespace Rust {\n                 return ::std::unique_ptr<IfLetExpr>(clone_if_let_expr_impl());\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -3950,7 +3950,7 @@ namespace Rust {\n \n             IfExprConseqIfLet(::std::unique_ptr<Expr> condition,\n               ::std::unique_ptr<BlockExpr> if_block, ::std::unique_ptr<IfLetExpr> conseq_if_let_expr,\n-              location_t locus) :\n+              Location locus) :\n               IfExpr(::std::move(condition), ::std::move(if_block), locus),\n               if_let_expr(::std::move(conseq_if_let_expr)) {}\n             // outer attributes not allowed\n@@ -4008,7 +4008,7 @@ namespace Rust {\n \n             IfLetExprConseqElse(::std::vector< ::std::unique_ptr<Pattern> > match_arm_patterns,\n               ::std::unique_ptr<Expr> value, ::std::unique_ptr<BlockExpr> if_block,\n-              ::std::unique_ptr<BlockExpr> else_block, location_t locus) :\n+              ::std::unique_ptr<BlockExpr> else_block, Location locus) :\n               IfLetExpr(\n                 ::std::move(match_arm_patterns), ::std::move(value), ::std::move(if_block), locus),\n               else_block(::std::move(else_block)) {}\n@@ -4069,7 +4069,7 @@ namespace Rust {\n \n             IfLetExprConseqIf(::std::vector< ::std::unique_ptr<Pattern> > match_arm_patterns,\n               ::std::unique_ptr<Expr> value, ::std::unique_ptr<BlockExpr> if_block,\n-              ::std::unique_ptr<IfExpr> if_expr, location_t locus) :\n+              ::std::unique_ptr<IfExpr> if_expr, Location locus) :\n               IfLetExpr(\n                 ::std::move(match_arm_patterns), ::std::move(value), ::std::move(if_block), locus),\n               if_expr(::std::move(if_expr)) {}\n@@ -4129,7 +4129,7 @@ namespace Rust {\n \n             IfLetExprConseqIfLet(::std::vector< ::std::unique_ptr<Pattern> > match_arm_patterns,\n               ::std::unique_ptr<Expr> value, ::std::unique_ptr<BlockExpr> if_block,\n-              ::std::unique_ptr<IfLetExpr> if_let_expr, location_t locus) :\n+              ::std::unique_ptr<IfLetExpr> if_let_expr, Location locus) :\n               IfLetExpr(\n                 ::std::move(match_arm_patterns), ::std::move(value), ::std::move(if_block), locus),\n               if_let_expr(::std::move(if_let_expr)) {}\n@@ -4413,7 +4413,7 @@ namespace Rust {\n             // MatchArms match_arms;\n             ::std::vector< ::std::unique_ptr<MatchCase> > match_arms; // inlined from MatchArms\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~MatchExpr() {\n@@ -4430,7 +4430,7 @@ namespace Rust {\n             MatchExpr(::std::unique_ptr<Expr> branch_value,\n               ::std::vector< ::std::unique_ptr<MatchCase> > match_arms,\n               ::std::vector<Attribute> inner_attrs, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               ExprWithBlock(::std::move(outer_attrs)),\n               branch_value(::std::move(branch_value)), inner_attrs(::std::move(inner_attrs)),\n               match_arms(::std::move(match_arms)), locus(locus) {}\n@@ -4481,11 +4481,11 @@ namespace Rust {\n             MatchExpr(MatchExpr&& other) = default;\n             MatchExpr& operator=(MatchExpr&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -4507,12 +4507,12 @@ namespace Rust {\n         class AwaitExpr : public ExprWithoutBlock {\n             ::std::unique_ptr<Expr> awaited_expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // TODO: ensure outer attributes are actually allowed\n             AwaitExpr(::std::unique_ptr<Expr> awaited_expr, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               ExprWithoutBlock(::std::move(outer_attrs)),\n               awaited_expr(::std::move(awaited_expr)), locus(locus) {}\n \n@@ -4538,11 +4538,11 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -4561,11 +4561,11 @@ namespace Rust {\n             bool has_move;\n             ::std::unique_ptr<BlockExpr> block_expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             AsyncBlockExpr(::std::unique_ptr<BlockExpr> block_expr, bool has_move,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               ExprWithBlock(::std::move(outer_attrs)),\n               has_move(has_move), block_expr(::std::move(block_expr)), locus(locus) {}\n \n@@ -4592,11 +4592,11 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -4611,4 +4611,4 @@ namespace Rust {\n     }\n }\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "7c69978370496172cad60421fb0b9d63832928a5", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -50,7 +50,7 @@ namespace Rust {\n             // Type type;\n             ::std::unique_ptr<Type> type;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether the type of the type param has been specified.\n@@ -68,7 +68,7 @@ namespace Rust {\n                 return !outer_attr.is_empty();\n             }\n \n-            TypeParam(Identifier type_representation, location_t locus = UNKNOWN_LOCATION,\n+            TypeParam(Identifier type_representation, Location locus = Location(),\n               ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds\n               = ::std::vector< ::std::unique_ptr<TypeParamBound> >(),\n               ::std::unique_ptr<Type> type = NULL, Attribute outer_attr = Attribute::create_empty()) :\n@@ -116,7 +116,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -314,7 +314,7 @@ namespace Rust {\n             // Type type;\n             ::std::unique_ptr<Type> type;\n \n-            location_t locus;\n+            Location locus;\n \n             // Unrestricted constructor used for error state\n             SelfParam(Lifetime lifetime, bool has_ref, bool is_mut, Type* type) :\n@@ -347,12 +347,12 @@ namespace Rust {\n             }\n \n             // Type-based self parameter (not ref, no lifetime)\n-            SelfParam(::std::unique_ptr<Type> type, bool is_mut, location_t locus) :\n+            SelfParam(::std::unique_ptr<Type> type, bool is_mut, Location locus) :\n               has_ref(false), is_mut(is_mut), lifetime(Lifetime::error()), type(::std::move(type)),\n               locus(locus) {}\n \n             // Lifetime-based self parameter (is ref, no type)\n-            SelfParam(Lifetime lifetime, bool is_mut, location_t locus) :\n+            SelfParam(Lifetime lifetime, bool is_mut, Location locus) :\n               /*type(NULL), */ has_ref(true), is_mut(is_mut), lifetime(::std::move(lifetime)),\n               locus(locus) {}\n \n@@ -380,7 +380,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n         };\n@@ -432,11 +432,11 @@ namespace Rust {\n             // Type type;\n             ::std::unique_ptr<Type> type;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             FunctionParam(::std::unique_ptr<Pattern> param_name, ::std::unique_ptr<Type> param_type,\n-              location_t locus) :\n+              Location locus) :\n               param_name(::std::move(param_name)),\n               type(::std::move(param_type)), locus(locus) {}\n \n@@ -467,12 +467,12 @@ namespace Rust {\n \n             // Creates an error FunctionParam.\n             static FunctionParam create_error() {\n-                return FunctionParam(NULL, NULL, UNKNOWN_LOCATION);\n+                return FunctionParam(NULL, NULL, Location());\n             }\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n         };\n@@ -587,7 +587,7 @@ namespace Rust {\n             // BlockExpr* expr;\n             ::std::unique_ptr<BlockExpr> expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~Method() {\n@@ -637,7 +637,7 @@ namespace Rust {\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params, SelfParam self_param,\n               ::std::vector<FunctionParam> function_params, ::std::unique_ptr<Type> return_type,\n               WhereClause where_clause, ::std::unique_ptr<BlockExpr> function_body, Visibility vis,\n-              ::std::vector<Attribute> outer_attrs, location_t locus = UNKNOWN_LOCATION) :\n+              ::std::vector<Attribute> outer_attrs, Location locus = Location()) :\n               outer_attrs(::std::move(outer_attrs)),\n               vis(::std::move(vis)), qualifiers(::std::move(qualifiers)),\n               method_name(::std::move(method_name)), generic_params(::std::move(generic_params)),\n@@ -751,19 +751,19 @@ namespace Rust {\n         class Module : public VisItem {\n             Identifier module_name;\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Protected constructor\n-            Module(Identifier module_name, Visibility visibility, location_t locus,\n+            Module(Identifier module_name, Visibility visibility, Location locus,\n               ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n               VisItem(::std::move(visibility), ::std::move(outer_attrs)),\n               module_name(module_name), locus(locus) {}\n \n           public:\n             virtual ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n         };\n@@ -790,7 +790,7 @@ namespace Rust {\n             }\n \n             // Full constructor\n-            ModuleBodied(Identifier name, location_t locus,\n+            ModuleBodied(Identifier name, Location locus,\n               ::std::vector< ::std::unique_ptr<Item> > items\n               = ::std::vector< ::std::unique_ptr<Item> >(),\n               Visibility visibility = Visibility::create_error(),\n@@ -852,7 +852,7 @@ namespace Rust {\n \n             // Full constructor\n             ModuleNoBody(Identifier name, Visibility visibility, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               Module(::std::move(name), ::std::move(visibility), locus, ::std::move(outer_attrs)) {}\n \n             virtual void accept_vis(ASTVisitor& vis) OVERRIDE;\n@@ -878,7 +878,7 @@ namespace Rust {\n             // this is either an identifier or \"_\", with _ parsed to string\n             ::std::string as_clause_name;\n \n-            location_t locus;\n+            Location locus;\n \n             /* e.g.\n                 \"extern crate foo as _\"\n@@ -899,13 +899,13 @@ namespace Rust {\n \n             // Constructor\n             ExternCrate(::std::string referenced_crate, Visibility visibility,\n-              ::std::vector<Attribute> outer_attrs, location_t locus,\n+              ::std::vector<Attribute> outer_attrs, Location locus,\n               ::std::string as_clause_name = ::std::string()) :\n               VisItem(::std::move(visibility), ::std::move(outer_attrs)),\n               referenced_crate(::std::move(referenced_crate)),\n               as_clause_name(::std::move(as_clause_name)), locus(locus) {}\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -930,7 +930,7 @@ namespace Rust {\n \n         // The path-ish thing referred to in a use declaration - abstract base class\n         class UseTree {\n-            location_t locus;\n+            Location locus;\n \n           public:\n             virtual ~UseTree() {}\n@@ -942,7 +942,7 @@ namespace Rust {\n \n             virtual ::std::string as_string() const = 0;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -952,7 +952,7 @@ namespace Rust {\n             // Clone function implementation as pure virtual method\n             virtual UseTree* clone_use_tree_impl() const = 0;\n \n-            UseTree(location_t locus) : locus(locus) {}\n+            UseTree(Location locus) : locus(locus) {}\n         };\n \n         // Use tree with a glob (wildcard) operator\n@@ -965,7 +965,7 @@ namespace Rust {\n             SimplePath path;\n \n           public:\n-            UseTreeGlob(PathType glob_type, SimplePath path, location_t locus) :\n+            UseTreeGlob(PathType glob_type, SimplePath path, Location locus) :\n               UseTree(locus), glob_type(glob_type), path(::std::move(path)) {}\n \n             // Returns whether has path. Should be made redundant by PathType PATH_PREFIXED.\n@@ -998,7 +998,7 @@ namespace Rust {\n \n           public:\n             UseTreeList(PathType path_type, SimplePath path,\n-              ::std::vector< ::std::unique_ptr<UseTree> > trees, location_t locus) :\n+              ::std::vector< ::std::unique_ptr<UseTree> > trees, Location locus) :\n               UseTree(locus),\n               path_type(path_type), path(::std::move(path)), trees(::std::move(trees)) {}\n \n@@ -1067,7 +1067,7 @@ namespace Rust {\n             Identifier identifier; // only if NewBindType is IDENTIFIER\n \n           public:\n-            UseTreeRebind(NewBindType bind_type, SimplePath path, location_t locus,\n+            UseTreeRebind(NewBindType bind_type, SimplePath path, Location locus,\n               Identifier identifier = ::std::string()) :\n               UseTree(locus),\n               path(::std::move(path)), bind_type(bind_type), identifier(::std::move(identifier)) {}\n@@ -1098,13 +1098,13 @@ namespace Rust {\n         class UseDeclaration : public VisItem {\n             ::std::unique_ptr<UseTree> use_tree;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n             UseDeclaration(::std::unique_ptr<UseTree> use_tree, Visibility visibility,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               VisItem(::std::move(visibility), ::std::move(outer_attrs)),\n               use_tree(::std::move(use_tree)), locus(locus) {}\n \n@@ -1129,7 +1129,7 @@ namespace Rust {\n             UseDeclaration(UseDeclaration&& other) = default;\n             UseDeclaration& operator=(UseDeclaration&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -1179,7 +1179,7 @@ namespace Rust {\n             // BlockExpr* function_body;\n             ::std::unique_ptr<BlockExpr> function_body;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~Function() {\n@@ -1212,7 +1212,7 @@ namespace Rust {\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               ::std::vector<FunctionParam> function_params, ::std::unique_ptr<Type> return_type,\n               WhereClause where_clause, ::std::unique_ptr<BlockExpr> function_body, Visibility vis,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               VisItem(::std::move(vis), ::std::move(outer_attrs)),\n               qualifiers(::std::move(qualifiers)), function_name(::std::move(function_name)),\n               generic_params(::std::move(generic_params)),\n@@ -1266,7 +1266,7 @@ namespace Rust {\n             Function(Function&& other) = default;\n             Function& operator=(Function&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -1310,7 +1310,7 @@ namespace Rust {\n             // Type exiting_type;\n             ::std::unique_ptr<Type> existing_type;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -1329,7 +1329,7 @@ namespace Rust {\n             TypeAlias(Identifier new_type_name,\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               WhereClause where_clause, ::std::unique_ptr<Type> existing_type, Visibility vis,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               VisItem(::std::move(vis), ::std::move(outer_attrs)),\n               new_type_name(::std::move(new_type_name)), generic_params(::std::move(generic_params)),\n               where_clause(::std::move(where_clause)), existing_type(::std::move(existing_type)),\n@@ -1376,7 +1376,7 @@ namespace Rust {\n             TypeAlias(TypeAlias&& other) = default;\n             TypeAlias& operator=(TypeAlias&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -1412,7 +1412,7 @@ namespace Rust {\n             // bool has_where_clause;\n             WhereClause where_clause;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether struct has generic parameters.\n@@ -1425,14 +1425,14 @@ namespace Rust {\n                 return !where_clause.is_empty();\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n           protected:\n             Struct(Identifier struct_name,\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n-              WhereClause where_clause, Visibility vis, location_t locus,\n+              WhereClause where_clause, Visibility vis, Location locus,\n               ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n               VisItem(::std::move(vis), ::std::move(outer_attrs)),\n               struct_name(::std::move(struct_name)), generic_params(::std::move(generic_params)),\n@@ -1551,7 +1551,7 @@ namespace Rust {\n             StructStruct(::std::vector<StructField> fields, Identifier struct_name,\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               WhereClause where_clause, bool is_unit, Visibility vis,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               Struct(::std::move(struct_name), ::std::move(generic_params), ::std::move(where_clause),\n                 ::std::move(vis), locus, ::std::move(outer_attrs)),\n               fields(::std::move(fields)), is_unit(is_unit) {}\n@@ -1560,7 +1560,7 @@ namespace Rust {\n             StructStruct(Identifier struct_name,\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               WhereClause where_clause, Visibility vis, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               Struct(::std::move(struct_name), ::std::move(generic_params), ::std::move(where_clause),\n                 ::std::move(vis), locus, ::std::move(outer_attrs)),\n               is_unit(true) {}\n@@ -1661,7 +1661,7 @@ namespace Rust {\n             TupleStruct(::std::vector<TupleField> fields, Identifier struct_name,\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               WhereClause where_clause, Visibility vis, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               Struct(::std::move(struct_name), ::std::move(generic_params), ::std::move(where_clause),\n                 ::std::move(vis), locus, ::std::move(outer_attrs)),\n               fields(::std::move(fields)) {}\n@@ -1687,7 +1687,7 @@ namespace Rust {\n \n             Identifier variant_name;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             virtual ~EnumItem() {}\n@@ -1698,7 +1698,7 @@ namespace Rust {\n             }\n \n             EnumItem(\n-              Identifier variant_name, ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              Identifier variant_name, ::std::vector<Attribute> outer_attrs, Location locus) :\n               outer_attrs(::std::move(outer_attrs)),\n               variant_name(::std::move(variant_name)), locus(locus) {}\n \n@@ -1731,7 +1731,7 @@ namespace Rust {\n             }\n \n             EnumItemTuple(Identifier variant_name, ::std::vector<TupleField> tuple_fields,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               EnumItem(::std::move(variant_name), ::std::move(outer_attrs), locus),\n               tuple_fields(::std::move(tuple_fields)) {}\n \n@@ -1758,7 +1758,7 @@ namespace Rust {\n             }\n \n             EnumItemStruct(Identifier variant_name, ::std::vector<StructField> struct_fields,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               EnumItem(::std::move(variant_name), ::std::move(outer_attrs), locus),\n               struct_fields(::std::move(struct_fields)) {}\n \n@@ -1784,7 +1784,7 @@ namespace Rust {\n             }*/\n \n             EnumItemDiscriminant(Identifier variant_name, ::std::unique_ptr<Expr> expr,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               EnumItem(::std::move(variant_name), ::std::move(outer_attrs), locus),\n               expression(::std::move(expr)) {}\n \n@@ -1832,7 +1832,7 @@ namespace Rust {\n \n             ::std::vector< ::std::unique_ptr<EnumItem> > items;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -1857,7 +1857,7 @@ namespace Rust {\n             Enum(Identifier enum_name, Visibility vis,\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               WhereClause where_clause, ::std::vector< ::std::unique_ptr<EnumItem> > items,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               VisItem(::std::move(vis), ::std::move(outer_attrs)),\n               enum_name(::std::move(enum_name)), generic_params(::std::move(generic_params)),\n               where_clause(::std::move(where_clause)), items(::std::move(items)), locus(locus) {}\n@@ -1911,7 +1911,7 @@ namespace Rust {\n             Enum(Enum&& other) = default;\n             Enum& operator=(Enum&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -1942,7 +1942,7 @@ namespace Rust {\n \n             ::std::vector<StructField> variants;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -1960,7 +1960,7 @@ namespace Rust {\n             Union(Identifier union_name, Visibility vis,\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               WhereClause where_clause, ::std::vector<StructField> variants,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               VisItem(::std::move(vis), ::std::move(outer_attrs)),\n               union_name(::std::move(union_name)), generic_params(::std::move(generic_params)),\n               where_clause(::std::move(where_clause)), variants(::std::move(variants)), locus(locus) {\n@@ -2000,7 +2000,7 @@ namespace Rust {\n             Union(Union&& other) = default;\n             Union& operator=(Union&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -2034,7 +2034,7 @@ namespace Rust {\n             // Expr* const_expr;\n             ::std::unique_ptr<Expr> const_expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~ConstantItem() {\n@@ -2045,7 +2045,7 @@ namespace Rust {\n \n             ConstantItem(Identifier ident, Visibility vis, ::std::unique_ptr<Type> type,\n               ::std::unique_ptr<Expr> const_expr, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               VisItem(::std::move(vis), ::std::move(outer_attrs)),\n               identifier(::std::move(ident)), type(::std::move(type)),\n               const_expr(::std::move(const_expr)), locus(locus) {}\n@@ -2077,7 +2077,7 @@ namespace Rust {\n                 return identifier == ::std::string(\"_\");\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -2117,7 +2117,7 @@ namespace Rust {\n             // Expr* expr;\n             ::std::unique_ptr<Expr> expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~StaticItem() {\n@@ -2128,7 +2128,7 @@ namespace Rust {\n \n             StaticItem(Identifier name, bool is_mut, ::std::unique_ptr<Type> type,\n               ::std::unique_ptr<Expr> expr, Visibility vis, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               VisItem(::std::move(vis), ::std::move(outer_attrs)),\n               has_mut(is_mut), name(::std::move(name)), type(::std::move(type)),\n               expr(::std::move(expr)), locus(locus) {}\n@@ -2156,7 +2156,7 @@ namespace Rust {\n             StaticItem(StaticItem&& other) = default;\n             StaticItem& operator=(StaticItem&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -2277,7 +2277,7 @@ namespace Rust {\n             // BlockExpr* block_expr;\n             ::std::unique_ptr<BlockExpr> block_expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~TraitItemFunc() {\n@@ -2290,7 +2290,7 @@ namespace Rust {\n             }\n \n             TraitItemFunc(TraitFunctionDecl decl, ::std::unique_ptr<BlockExpr> block_expr,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               outer_attrs(::std::move(outer_attrs)),\n               decl(::std::move(decl)), block_expr(::std::move(block_expr)), locus(locus) {}\n \n@@ -2325,7 +2325,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -2445,7 +2445,7 @@ namespace Rust {\n             // BlockExpr* block_expr;\n             ::std::unique_ptr<BlockExpr> block_expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~TraitItemMethod() {\n@@ -2458,7 +2458,7 @@ namespace Rust {\n             }\n \n             TraitItemMethod(TraitMethodDecl decl, ::std::unique_ptr<BlockExpr> block_expr,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               outer_attrs(::std::move(outer_attrs)),\n               decl(::std::move(decl)), block_expr(::std::move(block_expr)), locus(locus) {}\n \n@@ -2486,7 +2486,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -2510,7 +2510,7 @@ namespace Rust {\n             // Expr* expr;\n             ::std::unique_ptr<Expr> expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~TraitItemConst() {\n@@ -2523,7 +2523,7 @@ namespace Rust {\n             }\n \n             TraitItemConst(Identifier name, ::std::unique_ptr<Type> type,\n-              ::std::unique_ptr<Expr> expr, ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::unique_ptr<Expr> expr, ::std::vector<Attribute> outer_attrs, Location locus) :\n               outer_attrs(::std::move(outer_attrs)),\n               name(::std::move(name)), type(::std::move(type)), expr(::std::move(expr)),\n               locus(locus) {}\n@@ -2553,7 +2553,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -2576,7 +2576,7 @@ namespace Rust {\n             // TypeParamBounds type_param_bounds;\n             ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds; // inlined form\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether trait item type has type param bounds.\n@@ -2586,7 +2586,7 @@ namespace Rust {\n \n             TraitItemType(Identifier name,\n               ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               outer_attrs(::std::move(outer_attrs)),\n               name(::std::move(name)), type_param_bounds(::std::move(type_param_bounds)),\n               locus(locus) {}\n@@ -2625,7 +2625,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -2671,7 +2671,7 @@ namespace Rust {\n             // bool has_trait_items;\n             ::std::vector< ::std::unique_ptr<TraitItem> > trait_items;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -2701,7 +2701,7 @@ namespace Rust {\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n               WhereClause where_clause, ::std::vector< ::std::unique_ptr<TraitItem> > trait_items,\n-              Visibility vis, ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              Visibility vis, ::std::vector<Attribute> outer_attrs, Location locus) :\n               VisItem(::std::move(vis), ::std::move(outer_attrs)),\n               has_unsafe(is_unsafe), name(::std::move(name)),\n               generic_params(::std::move(generic_params)),\n@@ -2771,7 +2771,7 @@ namespace Rust {\n             Trait(Trait&& other) = default;\n             Trait& operator=(Trait&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -2808,7 +2808,7 @@ namespace Rust {\n \n           private:\n             // doesn't really need to be protected as write access probably not needed\n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether impl has generic parameters.\n@@ -2826,7 +2826,7 @@ namespace Rust {\n                 return !inner_attrs.empty();\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -2835,7 +2835,7 @@ namespace Rust {\n             Impl(::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               ::std::unique_ptr<Type> trait_type, WhereClause where_clause, Visibility vis,\n               ::std::vector<Attribute> inner_attrs, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               VisItem(::std::move(vis), ::std::move(outer_attrs)),\n               generic_params(::std::move(generic_params)), trait_type(::std::move(trait_type)),\n               where_clause(::std::move(where_clause)), inner_attrs(::std::move(inner_attrs)),\n@@ -2898,7 +2898,7 @@ namespace Rust {\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               ::std::unique_ptr<Type> trait_type, WhereClause where_clause, Visibility vis,\n               ::std::vector<Attribute> inner_attrs, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               Impl(::std::move(generic_params), ::std::move(trait_type), ::std::move(where_clause),\n                 ::std::move(vis), ::std::move(inner_attrs), ::std::move(outer_attrs), locus),\n               impl_items(::std::move(impl_items)) {}\n@@ -2970,7 +2970,7 @@ namespace Rust {\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               ::std::unique_ptr<Type> trait_type, WhereClause where_clause, Visibility vis,\n               ::std::vector<Attribute> inner_attrs, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               Impl(::std::move(generic_params), ::std::move(trait_type), ::std::move(where_clause),\n                 ::std::move(vis), ::std::move(inner_attrs), ::std::move(outer_attrs), locus),\n               has_unsafe(is_unsafe), has_exclam(has_exclam), trait_path(::std::move(trait_path)),\n@@ -3035,7 +3035,7 @@ namespace Rust {\n \n             Identifier item_name;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             virtual ~ExternalItem() {}\n@@ -3057,15 +3057,15 @@ namespace Rust {\n \n             virtual ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n             virtual void accept_vis(ASTVisitor& vis) = 0;\n \n           protected:\n             ExternalItem(Identifier item_name, Visibility vis, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               outer_attrs(::std::move(outer_attrs)),\n               visibility(::std::move(vis)), item_name(::std::move(item_name)), locus(locus) {}\n \n@@ -3106,7 +3106,7 @@ namespace Rust {\n \n           public:\n             ExternalStaticItem(Identifier item_name, ::std::unique_ptr<Type> item_type, bool is_mut,\n-              Visibility vis, ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              Visibility vis, ::std::vector<Attribute> outer_attrs, Location locus) :\n               ExternalItem(::std::move(item_name), ::std::move(vis), ::std::move(outer_attrs), locus),\n               has_mut(is_mut), item_type(::std::move(item_type)) {}\n \n@@ -3230,7 +3230,7 @@ namespace Rust {\n               ::std::vector< ::std::unique_ptr<GenericParam> > generic_params,\n               ::std::unique_ptr<Type> return_type, WhereClause where_clause,\n               ::std::vector<NamedFunctionParam> function_params, bool has_variadics, Visibility vis,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               ExternalItem(::std::move(item_name), ::std::move(vis), ::std::move(outer_attrs), locus),\n               generic_params(::std::move(generic_params)), return_type(::std::move(return_type)),\n               where_clause(::std::move(where_clause)), function_params(::std::move(function_params)),\n@@ -3297,7 +3297,7 @@ namespace Rust {\n             // bool has_extern_items;\n             ::std::vector< ::std::unique_ptr<ExternalItem> > extern_items;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -3320,7 +3320,7 @@ namespace Rust {\n             ExternBlock(::std::string abi,\n               ::std::vector< ::std::unique_ptr<ExternalItem> > extern_items, Visibility vis,\n               ::std::vector<Attribute> inner_attrs, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               VisItem(::std::move(vis), ::std::move(outer_attrs)),\n               abi(::std::move(abi)), inner_attrs(::std::move(inner_attrs)),\n               extern_items(::std::move(extern_items)), locus(locus) {}\n@@ -3357,7 +3357,7 @@ namespace Rust {\n             ExternBlock(ExternBlock&& other) = default;\n             ExternBlock& operator=(ExternBlock&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -3382,4 +3382,4 @@ namespace Rust {\n     }\n }\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "4b8e4d63771cbe765a16c9d3b027b82942ad0f37", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -282,14 +282,14 @@ namespace Rust {\n             // MacroRules rules;\n             ::std::vector<MacroRule> rules; // inlined form\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n             MacroRulesDefinition(Identifier rule_name, DelimType delim_type,\n               ::std::vector<MacroRule> rules, ::std::vector<Attribute> outer_attrs,\n-              location_t locus) :\n+              Location locus) :\n               MacroItem(::std::move(outer_attrs)),\n               rule_name(::std::move(rule_name)), delim_type(delim_type), rules(::std::move(rules)),\n               locus(locus) {}\n@@ -311,21 +311,21 @@ namespace Rust {\n             SimplePath path;\n             DelimTokenTree token_tree;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n             MacroInvocation(SimplePath path, DelimTokenTree token_tree,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               ExprWithoutBlock(::std::move(outer_attrs)),\n               path(::std::move(path)), token_tree(::std::move(token_tree)), locus(locus) {}\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -585,4 +585,4 @@ namespace Rust {\n     }\n }\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "5fe7fd039b5485e984da9a10d03a7c7c90a0c167", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -53,7 +53,7 @@ namespace Rust {\n             // Type type;\n             ::std::unique_ptr<Type> type;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether binding is in an error state.\n@@ -68,7 +68,7 @@ namespace Rust {\n \n             // Pointer type for type in constructor to enable polymorphism\n             GenericArgsBinding(Identifier ident, ::std::unique_ptr<Type> type_ptr,\n-              location_t locus = UNKNOWN_LOCATION) :\n+              Location locus = Location()) :\n               identifier(::std::move(ident)),\n               type(::std::move(type_ptr)), locus(locus) {}\n \n@@ -101,7 +101,7 @@ namespace Rust {\n             ::std::vector< ::std::unique_ptr<Type> > type_args;\n             ::std::vector<GenericArgsBinding> binding_args;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns true if there are any generic arguments\n@@ -111,7 +111,7 @@ namespace Rust {\n \n             GenericArgs(::std::vector<Lifetime> lifetime_args,\n               ::std::vector< ::std::unique_ptr<Type> > type_args,\n-              ::std::vector<GenericArgsBinding> binding_args, location_t locus = UNKNOWN_LOCATION) :\n+              ::std::vector<GenericArgsBinding> binding_args, Location locus = Location()) :\n               lifetime_args(::std::move(lifetime_args)),\n               type_args(::std::move(type_args)), binding_args(::std::move(binding_args)),\n               locus(locus) {}\n@@ -167,7 +167,7 @@ namespace Rust {\n             // bool has_generic_args;\n             GenericArgs generic_args;\n \n-            location_t locus;\n+            Location locus;\n \n             // TODO: does this require visitor? pretty sure not polymorphic\n \n@@ -178,13 +178,13 @@ namespace Rust {\n             }\n \n             // Constructor for segment (from IdentSegment and GenericArgs)\n-            PathExprSegment(PathIdentSegment segment_name, location_t locus = UNKNOWN_LOCATION,\n+            PathExprSegment(PathIdentSegment segment_name, Location locus = Location(),\n               GenericArgs generic_args = GenericArgs::create_empty()) :\n               segment_name(::std::move(segment_name)),\n               generic_args(::std::move(generic_args)), locus(locus) {}\n \n             // Constructor for segment with generic arguments (from segment name and all args)\n-            PathExprSegment(::std::string segment_name, location_t locus,\n+            PathExprSegment(::std::string segment_name, Location locus,\n               ::std::vector<Lifetime> lifetime_args = ::std::vector<Lifetime>(),\n               ::std::vector< ::std::unique_ptr<Type> > type_args\n               = ::std::vector< ::std::unique_ptr<Type> >(),\n@@ -206,7 +206,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            inline location_t get_locus() const {\n+            inline Location get_locus() const {\n                 return locus;\n             }\n         };\n@@ -243,14 +243,14 @@ namespace Rust {\n           , public PathExpr {\n             bool has_opening_scope_resolution;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n             // Constructor\n             PathInExpression(::std::vector<PathExprSegment> path_segments,\n-              location_t locus = UNKNOWN_LOCATION, bool has_opening_scope_resolution = false,\n+              Location locus = Location(), bool has_opening_scope_resolution = false,\n               ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n               PathPattern(::std::move(path_segments)),\n               PathExpr(::std::move(outer_attrs)),\n@@ -276,11 +276,11 @@ namespace Rust {\n                 return convert_to_simple_path(has_opening_scope_resolution);\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -307,7 +307,7 @@ namespace Rust {\n              * so could disallow that in constructor, which won't give that much size overhead. */\n             PathIdentSegment ident_segment;\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // This is protected because it is only really used by derived classes, not the base.\n@@ -327,12 +327,12 @@ namespace Rust {\n             }\n \n             TypePathSegment(PathIdentSegment ident_segment, bool has_separating_scope_resolution,\n-              location_t locus) :\n+              Location locus) :\n               ident_segment(::std::move(ident_segment)),\n               locus(locus), has_separating_scope_resolution(has_separating_scope_resolution) {}\n \n             TypePathSegment(\n-              ::std::string segment_name, bool has_separating_scope_resolution, location_t locus) :\n+              ::std::string segment_name, bool has_separating_scope_resolution, Location locus) :\n               ident_segment(PathIdentSegment(::std::move(segment_name))),\n               locus(locus), has_separating_scope_resolution(has_separating_scope_resolution) {}\n \n@@ -351,7 +351,7 @@ namespace Rust {\n                 return true;\n             }\n \n-            inline bool get_locus() const {\n+            inline Location get_locus() const {\n                 return locus;\n             }\n \n@@ -374,15 +374,15 @@ namespace Rust {\n \n             // Constructor with PathIdentSegment and GenericArgs\n             TypePathSegmentGeneric(PathIdentSegment ident_segment,\n-              bool has_separating_scope_resolution, GenericArgs generic_args, location_t locus) :\n+              bool has_separating_scope_resolution, GenericArgs generic_args, Location locus) :\n               TypePathSegment(::std::move(ident_segment), has_separating_scope_resolution, locus),\n               generic_args(::std::move(generic_args)) {}\n \n             // Constructor from segment name and all args\n             TypePathSegmentGeneric(::std::string segment_name, bool has_separating_scope_resolution,\n               ::std::vector<Lifetime> lifetime_args,\n               ::std::vector< ::std::unique_ptr<Type> > type_args,\n-              ::std::vector<GenericArgsBinding> binding_args, location_t locus) :\n+              ::std::vector<GenericArgsBinding> binding_args, Location locus) :\n               TypePathSegment(::std::move(segment_name), has_separating_scope_resolution, locus),\n               generic_args(GenericArgs(\n                 ::std::move(lifetime_args), ::std::move(type_args), ::std::move(binding_args))) {}\n@@ -497,13 +497,13 @@ namespace Rust {\n             // Constructor with PathIdentSegment and TypePathFn\n             TypePathSegmentFunction(PathIdentSegment ident_segment,\n               bool has_separating_scope_resolution, TypePathFunction function_path,\n-              location_t locus) :\n+              Location locus) :\n               TypePathSegment(::std::move(ident_segment), has_separating_scope_resolution, locus),\n               function_path(::std::move(function_path)) {}\n \n             // Constructor with segment name and TypePathFn\n             TypePathSegmentFunction(::std::string segment_name, bool has_separating_scope_resolution,\n-              TypePathFunction function_path, location_t locus) :\n+              TypePathFunction function_path, Location locus) :\n               TypePathSegment(::std::move(segment_name), has_separating_scope_resolution, locus),\n               function_path(::std::move(function_path)) {}\n \n@@ -527,7 +527,7 @@ namespace Rust {\n             bool has_opening_scope_resolution;\n             ::std::vector< ::std::unique_ptr<TypePathSegment> > segments;\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -554,12 +554,16 @@ namespace Rust {\n \n             // Creates an error state TypePath.\n             static TypePath create_error() {\n-                return TypePath(::std::vector< ::std::unique_ptr<TypePathSegment> >());\n+                return TypePath(\n+                    ::std::vector< ::std::unique_ptr<TypePathSegment> >(),\n+                    Linemap::unknown_location(),\n+                    false);\n             }\n \n             // Constructor\n             TypePath(::std::vector< ::std::unique_ptr<TypePathSegment> > segments,\n-              location_t locus = UNKNOWN_LOCATION, bool has_opening_scope_resolution = false) :\n+                     Location locus,\n+                     bool has_opening_scope_resolution = false) :\n               has_opening_scope_resolution(has_opening_scope_resolution),\n               segments(::std::move(segments)), locus(locus) {}\n \n@@ -602,7 +606,7 @@ namespace Rust {\n             // Creates a trait bound with a clone of this type path as its only element.\n             virtual TraitBound* to_trait_bound(bool in_parens) const OVERRIDE;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -617,12 +621,12 @@ namespace Rust {\n             // bool has_as_clause;\n             TypePath trait_path;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Constructor\n             QualifiedPathType(::std::unique_ptr<Type> invoke_on_type,\n-              location_t locus = UNKNOWN_LOCATION, TypePath trait_path = TypePath::create_error()) :\n+              Location locus = Location(), TypePath trait_path = TypePath::create_error()) :\n               type_to_invoke_on(::std::move(invoke_on_type)),\n               trait_path(::std::move(trait_path)), locus(locus) {}\n \n@@ -663,7 +667,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            inline location_t get_locus() const {\n+            inline Location get_locus() const {\n                 return locus;\n             }\n         };\n@@ -675,13 +679,13 @@ namespace Rust {\n           , public PathExpr {\n             QualifiedPathType path_type;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n             QualifiedPathInExpression(QualifiedPathType qual_path_type,\n-              ::std::vector<PathExprSegment> path_segments, location_t locus = UNKNOWN_LOCATION,\n+              ::std::vector<PathExprSegment> path_segments, Location locus = Location(),\n               ::std::vector<Attribute> outer_attrs = ::std::vector<Attribute>()) :\n               PathPattern(::std::move(path_segments)),\n               PathExpr(::std::move(outer_attrs)), path_type(::std::move(qual_path_type)),\n@@ -702,11 +706,11 @@ namespace Rust {\n                   QualifiedPathType::create_error(), ::std::vector<PathExprSegment>());\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n-            location_t get_locus_slow() const OVERRIDE {\n+            Location get_locus_slow() const OVERRIDE {\n                 return get_locus();\n             }\n \n@@ -730,7 +734,7 @@ namespace Rust {\n             // ::std::vector<TypePathSegment> segments;\n             ::std::vector< ::std::unique_ptr<TypePathSegment> > segments;\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -746,7 +750,7 @@ namespace Rust {\n           public:\n             QualifiedPathInType(QualifiedPathType qual_path_type,\n               ::std::vector< ::std::unique_ptr<TypePathSegment> > path_segments,\n-              location_t locus = UNKNOWN_LOCATION) :\n+              Location locus = Location()) :\n               path_type(::std::move(qual_path_type)),\n               segments(::std::move(path_segments)), locus(locus) {}\n \n@@ -800,4 +804,4 @@ namespace Rust {\n     }\n }\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "5df05288091928e1df8dfdf9f2a1477f5cf6f70f", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -15,21 +15,21 @@ namespace Rust {\n             bool has_minus;\n             // Actually, this might be a good place to use a template.\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n             // Constructor for a literal pattern\n-            LiteralPattern(Literal lit, location_t locus, bool has_minus = false) :\n+            LiteralPattern(Literal lit, Location locus, bool has_minus = false) :\n               lit(::std::move(lit)), has_minus(has_minus), locus(locus) {}\n \n             LiteralPattern(\n-              ::std::string val, Literal::LitType type, location_t locus, bool has_minus = false) :\n+              ::std::string val, Literal::LitType type, Location locus, bool has_minus = false) :\n               lit(Literal(::std::move(val), type)),\n               has_minus(has_minus), locus(locus) {}\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -52,7 +52,7 @@ namespace Rust {\n             // Pattern* to_bind;\n             ::std::unique_ptr<Pattern> to_bind;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~IdentifierPattern() {\n@@ -67,7 +67,7 @@ namespace Rust {\n             }\n \n             // Constructor\n-            IdentifierPattern(Identifier ident, location_t locus, bool is_ref = false,\n+            IdentifierPattern(Identifier ident, Location locus, bool is_ref = false,\n               bool is_mut = false, ::std::unique_ptr<Pattern> to_bind = NULL) :\n               variable_ident(::std::move(ident)),\n               is_ref(is_ref), is_mut(is_mut), to_bind(::std::move(to_bind)), locus(locus) {}\n@@ -102,7 +102,7 @@ namespace Rust {\n             IdentifierPattern(IdentifierPattern&& other) = default;\n             IdentifierPattern& operator=(IdentifierPattern&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -117,16 +117,16 @@ namespace Rust {\n \n         // AST node for using the '_' wildcard \"match any value\" pattern\n         class WildcardPattern : public Pattern {\n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const {\n                 return ::std::string(1, '_');\n             }\n \n-            WildcardPattern(location_t locus) : locus(locus) {}\n+            WildcardPattern(Location locus) : locus(locus) {}\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -174,16 +174,16 @@ namespace Rust {\n             // Minus prefixed to literal (if integer or floating-point)\n             bool has_minus;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Constructor\n-            RangePatternBoundLiteral(Literal literal, location_t locus, bool has_minus = false) :\n+            RangePatternBoundLiteral(Literal literal, Location locus, bool has_minus = false) :\n               literal(literal), has_minus(has_minus), locus(locus) {}\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -210,7 +210,7 @@ namespace Rust {\n                 return path.as_string();\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return path.get_locus();\n             }\n \n@@ -237,7 +237,7 @@ namespace Rust {\n                 return path.as_string();\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return path.get_locus();\n             }\n \n@@ -261,14 +261,14 @@ namespace Rust {\n \n             // location only stored to avoid a dereference - lower pattern should give correct\n             // location so maybe change in future\n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n             // Constructor\n             RangePattern(::std::unique_ptr<RangePatternBound> lower,\n-              ::std::unique_ptr<RangePatternBound> upper, location_t locus,\n+              ::std::unique_ptr<RangePatternBound> upper, Location locus,\n               bool has_ellipsis_syntax = false) :\n               lower(::std::move(lower)),\n               upper(::std::move(upper)), has_ellipsis_syntax(has_ellipsis_syntax), locus(locus) {}\n@@ -295,7 +295,7 @@ namespace Rust {\n             RangePattern(RangePattern&& other) = default;\n             RangePattern& operator=(RangePattern&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -315,7 +315,7 @@ namespace Rust {\n             // Pattern* pattern;\n             ::std::unique_ptr<Pattern> pattern;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             /*~ReferencePattern() {\n@@ -325,7 +325,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             ReferencePattern(::std::unique_ptr<Pattern> pattern, bool is_mut_reference,\n-              bool ref_has_two_amps, location_t locus) :\n+              bool ref_has_two_amps, Location locus) :\n               has_two_amps(ref_has_two_amps),\n               is_mut(is_mut_reference), pattern(::std::move(pattern)), locus(locus) {}\n \n@@ -395,7 +395,7 @@ namespace Rust {\n                 } ident;\n             } pattern;*/\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             virtual ~StructPatternField() {}\n@@ -407,14 +407,14 @@ namespace Rust {\n \n             virtual ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n             virtual void accept_vis(ASTVisitor& vis) = 0;\n \n           protected:\n-            StructPatternField(::std::vector<Attribute> outer_attribs, location_t locus) :\n+            StructPatternField(::std::vector<Attribute> outer_attribs, Location locus) :\n               outer_attrs(::std::move(outer_attribs)), locus(locus) {}\n \n             // Clone function implementation as pure virtual method\n@@ -433,7 +433,7 @@ namespace Rust {\n             }*/\n \n             StructPatternFieldTuplePat(TupleIndex index, ::std::unique_ptr<Pattern> tuple_pattern,\n-              ::std::vector<Attribute> outer_attribs, location_t locus) :\n+              ::std::vector<Attribute> outer_attribs, Location locus) :\n               StructPatternField(::std::move(outer_attribs), locus),\n               index(index), tuple_pattern(::std::move(tuple_pattern)) {}\n \n@@ -481,7 +481,7 @@ namespace Rust {\n             }*/\n \n             StructPatternFieldIdentPat(Identifier ident, ::std::unique_ptr<Pattern> ident_pattern,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               StructPatternField(::std::move(outer_attrs), locus),\n               ident(::std::move(ident)), ident_pattern(::std::move(ident_pattern)) {}\n \n@@ -526,7 +526,7 @@ namespace Rust {\n \n           public:\n             StructPatternFieldIdent(Identifier ident, bool is_ref, bool is_mut,\n-              ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::vector<Attribute> outer_attrs, Location locus) :\n               StructPatternField(::std::move(outer_attrs), locus),\n               has_ref(is_ref), has_mut(is_mut), ident(::std::move(ident)) {}\n \n@@ -641,7 +641,7 @@ namespace Rust {\n                 return !elems.is_empty();\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return path.get_locus();\n             }\n \n@@ -819,7 +819,7 @@ namespace Rust {\n             TupleStructPattern(TupleStructPattern&& other) = default;\n             TupleStructPattern& operator=(TupleStructPattern&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return path.get_locus();\n             }\n \n@@ -1002,7 +1002,7 @@ namespace Rust {\n             // TuplePatternItems items;\n             ::std::unique_ptr<TuplePatternItems> items;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n@@ -1012,7 +1012,7 @@ namespace Rust {\n                 return items != NULL;\n             }\n \n-            TuplePattern(::std::unique_ptr<TuplePatternItems> items, location_t locus) :\n+            TuplePattern(::std::unique_ptr<TuplePatternItems> items, Location locus) :\n               items(::std::move(items)), locus(locus) {}\n \n             // Copy constructor requires clone\n@@ -1029,7 +1029,7 @@ namespace Rust {\n                 return *this;\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -1047,14 +1047,14 @@ namespace Rust {\n             // Pattern pattern_in_parens;\n             ::std::unique_ptr<Pattern> pattern_in_parens;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const {\n                 return \"(\" + pattern_in_parens->as_string() + \")\";\n             }\n \n-            GroupedPattern(::std::unique_ptr<Pattern> pattern_in_parens, location_t locus) :\n+            GroupedPattern(::std::unique_ptr<Pattern> pattern_in_parens, Location locus) :\n               pattern_in_parens(::std::move(pattern_in_parens)), locus(locus) {}\n \n             // Copy constructor uses clone\n@@ -1075,7 +1075,7 @@ namespace Rust {\n             GroupedPattern(GroupedPattern&& other) = default;\n             GroupedPattern& operator=(GroupedPattern&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -1093,12 +1093,12 @@ namespace Rust {\n             //::std::vector<Pattern> items;\n             ::std::vector< ::std::unique_ptr<Pattern> > items;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const;\n \n-            SlicePattern(::std::vector< ::std::unique_ptr<Pattern> > items, location_t locus) :\n+            SlicePattern(::std::vector< ::std::unique_ptr<Pattern> > items, Location locus) :\n               items(::std::move(items)), locus(locus) {}\n \n             // Copy constructor with vector clone\n@@ -1128,7 +1128,7 @@ namespace Rust {\n             SlicePattern(SlicePattern&& other) = default;\n             SlicePattern& operator=(SlicePattern&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -1160,4 +1160,4 @@ namespace Rust {\n     }\n }\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "767b6206ab9e7236f0db22ca3b13cddfccbe081f", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -9,16 +9,16 @@ namespace Rust {\n     namespace AST {\n         // Just a semi-colon, which apparently is a statement.\n         class EmptyStmt : public Stmt {\n-            location_t locus;\n+            Location locus;\n \n           public:\n             ::std::string as_string() const {\n                 return ::std::string(1, ';');\n             }\n \n-            EmptyStmt(location_t locus) : locus(locus) {}\n+            EmptyStmt(Location locus) : locus(locus) {}\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -59,7 +59,7 @@ namespace Rust {\n             // Expr* init_expr;\n             ::std::unique_ptr<Expr> init_expr;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether let statement has outer attributes.\n@@ -86,7 +86,7 @@ namespace Rust {\n             ::std::string as_string() const;\n \n             LetStmt(::std::unique_ptr<Pattern> variables_pattern, ::std::unique_ptr<Expr> init_expr,\n-              ::std::unique_ptr<Type> type, ::std::vector<Attribute> outer_attrs, location_t locus) :\n+              ::std::unique_ptr<Type> type, ::std::vector<Attribute> outer_attrs, Location locus) :\n               outer_attrs(::std::move(outer_attrs)),\n               variables_pattern(::std::move(variables_pattern)), type(::std::move(type)),\n               init_expr(::std::move(init_expr)), locus(locus) {}\n@@ -115,7 +115,7 @@ namespace Rust {\n             LetStmt(LetStmt&& other) = default;\n             LetStmt& operator=(LetStmt&& other) = default;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -132,15 +132,15 @@ namespace Rust {\n         class ExprStmt : public Stmt {\n             // TODO: add any useful virtual functions\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n           protected:\n-            ExprStmt(location_t locus) : locus(locus) {}\n+            ExprStmt(Location locus) : locus(locus) {}\n         };\n \n         /* Statement containing an expression without a block (or, due to technical difficulties, can\n@@ -161,7 +161,7 @@ namespace Rust {\n \n             // ExprStmtWithoutBlock(::std::unique_ptr<ExprWithoutBlock> expr) :\n             // expr(::std::move(expr)) {}\n-            ExprStmtWithoutBlock(::std::unique_ptr<Expr> expr, location_t locus) :\n+            ExprStmtWithoutBlock(::std::unique_ptr<Expr> expr, Location locus) :\n               ExprStmt(locus), expr(::std::move(expr)) {}\n \n             // Copy constructor with clone\n@@ -203,7 +203,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            ExprStmtWithBlock(::std::unique_ptr<ExprWithBlock> expr, location_t locus) :\n+            ExprStmtWithBlock(::std::unique_ptr<ExprWithBlock> expr, Location locus) :\n               ExprStmt(locus), expr(::std::move(expr)) {}\n \n             // Copy constructor with clone\n@@ -242,4 +242,4 @@ namespace Rust {\n     }\n }\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "d6bd2f4828fd80c6108c5c99b89aed412005118f", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -21,15 +21,15 @@ namespace Rust {\n \n             TypePath type_path;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether trait bound has \"for\" lifetimes\n             inline bool has_for_lifetimes() const {\n                 return !for_lifetimes.empty();\n             }\n \n-            TraitBound(TypePath type_path, location_t locus, bool in_parens = false,\n+            TraitBound(TypePath type_path, Location locus, bool in_parens = false,\n               bool opening_question_mark = false,\n               ::std::vector<LifetimeParam> for_lifetimes = ::std::vector<LifetimeParam>()) :\n               in_parens(in_parens),\n@@ -38,7 +38,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -59,7 +59,7 @@ namespace Rust {\n             // TypeParamBounds type_param_bounds;\n             ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds; // inlined form\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -69,7 +69,7 @@ namespace Rust {\n \n           public:\n             ImplTraitType(::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n-              location_t locus) :\n+              Location locus) :\n               type_param_bounds(::std::move(type_param_bounds)),\n               locus(locus) {}\n \n@@ -102,7 +102,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -115,7 +115,7 @@ namespace Rust {\n             // TypeParamBounds type_param_bounds;\n             ::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds; // inlined form\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -125,7 +125,7 @@ namespace Rust {\n \n           public:\n             TraitObjectType(::std::vector< ::std::unique_ptr<TypeParamBound> > type_param_bounds,\n-              location_t locus, bool is_dyn_dispatch = false) :\n+              Location locus, bool is_dyn_dispatch = false) :\n               has_dyn(is_dyn_dispatch),\n               type_param_bounds(::std::move(type_param_bounds)), locus(locus) {}\n \n@@ -160,7 +160,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -172,7 +172,7 @@ namespace Rust {\n             // Type type_in_parens;\n             ::std::unique_ptr<Type> type_in_parens;\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -187,7 +187,7 @@ namespace Rust {\n \n           public:\n             // Constructor uses Type pointer for polymorphism\n-            ParenthesisedType(::std::unique_ptr<Type> type_inside_parens, location_t locus) :\n+            ParenthesisedType(::std::unique_ptr<Type> type_inside_parens, Location locus) :\n               type_in_parens(::std::move(type_inside_parens)), locus(locus) {}\n \n             // Copy constructor uses custom deep copy method for type to preserve polymorphism\n@@ -219,7 +219,7 @@ namespace Rust {\n                 return type_in_parens->to_trait_bound(true);\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -230,7 +230,7 @@ namespace Rust {\n         class ImplTraitTypeOneBound : public TypeNoBounds {\n             TraitBound trait_bound;\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -244,12 +244,12 @@ namespace Rust {\n             }\n \n           public:\n-            ImplTraitTypeOneBound(TraitBound trait_bound, location_t locus) :\n+            ImplTraitTypeOneBound(TraitBound trait_bound, Location locus) :\n               trait_bound(::std::move(trait_bound)), locus(locus) {}\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -262,7 +262,7 @@ namespace Rust {\n             bool has_dyn;\n             TraitBound trait_bound;\n \n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -277,7 +277,7 @@ namespace Rust {\n \n           public:\n             TraitObjectTypeOneBound(\n-              TraitBound trait_bound, location_t locus, bool is_dyn_dispatch = false) :\n+              TraitBound trait_bound, Location locus, bool is_dyn_dispatch = false) :\n               has_dyn(is_dyn_dispatch),\n               trait_bound(::std::move(trait_bound)), locus(locus) {}\n \n@@ -290,7 +290,7 @@ namespace Rust {\n                 return new AST::TraitBound(trait_bound);\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -304,15 +304,15 @@ namespace Rust {\n             //::std::vector<Type> elems;\n             ::std::vector< ::std::unique_ptr<Type> > elems;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether the tuple type is the unit type, i.e. has no elements.\n             inline bool is_unit_type() const {\n                 return elems.empty();\n             }\n \n-            TupleType(::std::vector< ::std::unique_ptr<Type> > elems, location_t locus) :\n+            TupleType(::std::vector< ::std::unique_ptr<Type> > elems, Location locus) :\n               elems(::std::move(elems)), locus(locus) {}\n \n             // copy constructor with vector clone\n@@ -344,7 +344,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -365,7 +365,7 @@ namespace Rust {\n         /* A type with no values, representing the result of computations that never complete.\n          * Expressions of NeverType can be coerced into any other types. Represented as \"!\". */\n         class NeverType : public TypeNoBounds {\n-            location_t locus;\n+            Location locus;\n \n           protected:\n             // Use covariance to implement clone function as returning this object rather than base\n@@ -379,13 +379,13 @@ namespace Rust {\n             }\n \n           public:\n-            NeverType(location_t locus) : locus(locus) {}\n+            NeverType(Location locus) : locus(locus) {}\n \n             ::std::string as_string() const {\n                 return \"! (never type)\";\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -403,7 +403,7 @@ namespace Rust {\n             // TypeNoBounds type;\n             ::std::unique_ptr<TypeNoBounds> type;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether the pointer is mutable or constant.\n@@ -413,7 +413,7 @@ namespace Rust {\n \n             // Constructor requires pointer for polymorphism reasons\n             RawPointerType(PointerType pointer_type, ::std::unique_ptr<TypeNoBounds> type_no_bounds,\n-              location_t locus) :\n+              Location locus) :\n               pointer_type(pointer_type),\n               type(::std::move(type_no_bounds)), locus(locus) {}\n \n@@ -438,7 +438,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -466,7 +466,7 @@ namespace Rust {\n             // TypeNoBounds type;\n             ::std::unique_ptr<TypeNoBounds> type;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Returns whether the reference is mutable or immutable.\n@@ -481,7 +481,7 @@ namespace Rust {\n \n             // Constructor\n             ReferenceType(bool is_mut, ::std::unique_ptr<TypeNoBounds> type_no_bounds,\n-              location_t locus, Lifetime lifetime = Lifetime::error()) :\n+              Location locus, Lifetime lifetime = Lifetime::error()) :\n               lifetime(::std::move(lifetime)),\n               has_mut(is_mut), type(::std::move(type_no_bounds)), locus(locus) {}\n \n@@ -508,7 +508,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -533,12 +533,12 @@ namespace Rust {\n             // Expr* size;\n             ::std::unique_ptr<Expr> size;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Constructor requires pointers for polymorphism\n             ArrayType(\n-              ::std::unique_ptr<Type> type, ::std::unique_ptr<Expr> array_size, location_t locus) :\n+              ::std::unique_ptr<Type> type, ::std::unique_ptr<Expr> array_size, Location locus) :\n               elem_type(::std::move(type)),\n               size(::std::move(array_size)), locus(locus) {}\n \n@@ -563,7 +563,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -589,11 +589,11 @@ namespace Rust {\n             // Type elem_type;\n             ::std::unique_ptr<Type> elem_type;\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Constructor requires pointer for polymorphism\n-            SliceType(::std::unique_ptr<Type> type, location_t locus) :\n+            SliceType(::std::unique_ptr<Type> type, Location locus) :\n               elem_type(::std::move(type)), locus(locus) {}\n \n             // Copy constructor requires deep copy of Type smart pointer\n@@ -616,7 +616,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -636,7 +636,7 @@ namespace Rust {\n \n         // Type used in generic arguments to explicitly request type inference (wildcard pattern)\n         class InferredType : public TypeNoBounds {\n-            location_t locus;\n+            Location locus;\n \n             // e.g. Vec<_> = whatever\n           protected:\n@@ -651,11 +651,11 @@ namespace Rust {\n             }\n \n           public:\n-            InferredType(location_t locus) : locus(locus) {}\n+            InferredType(Location locus) : locus(locus) {}\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -676,11 +676,11 @@ namespace Rust {\n             ParamKind param_kind;\n             Identifier name; // technically, can be an identifier or '_'\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             MaybeNamedParam(Identifier name, ParamKind param_kind, ::std::unique_ptr<Type> param_type,\n-              location_t locus) :\n+              Location locus) :\n               param_type(::std::move(param_type)),\n               param_kind(param_kind), name(::std::move(name)), locus(locus) {}\n \n@@ -714,10 +714,10 @@ namespace Rust {\n \n             // Creates an error state param.\n             static MaybeNamedParam create_error() {\n-                return MaybeNamedParam(\"\", UNNAMED, NULL, UNKNOWN_LOCATION);\n+                return MaybeNamedParam(\"\", UNNAMED, NULL, Location());\n             }\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n         };\n@@ -737,7 +737,7 @@ namespace Rust {\n             // BareFunctionReturnType return_type;\n             ::std::unique_ptr<TypeNoBounds> return_type; // inlined version\n \n-            location_t locus;\n+            Location locus;\n \n           public:\n             // Whether a return type is defined with the function.\n@@ -752,7 +752,7 @@ namespace Rust {\n \n             BareFunctionType(::std::vector<LifetimeParam> lifetime_params,\n               FunctionQualifiers qualifiers, ::std::vector<MaybeNamedParam> named_params,\n-              bool is_variadic, ::std::unique_ptr<TypeNoBounds> type, location_t locus) :\n+              bool is_variadic, ::std::unique_ptr<TypeNoBounds> type, Location locus) :\n               for_lifetimes(::std::move(lifetime_params)),\n               function_qualifiers(::std::move(qualifiers)), params(::std::move(named_params)),\n               is_variadic(is_variadic), return_type(::std::move(type)), locus(locus) {}\n@@ -783,7 +783,7 @@ namespace Rust {\n \n             ::std::string as_string() const;\n \n-            location_t get_locus() const {\n+            Location get_locus() const {\n                 return locus;\n             }\n \n@@ -825,4 +825,4 @@ namespace Rust {\n     }\n }\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "f3979f1706c7b68cda7ab371862309af325e4669", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 62, "deletions": 63, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -1,6 +1,7 @@\n #include \"rust-lex.h\"\n \n-#include \"diagnostic.h\" // for error_at\n+#include \"rust-diagnostics.h\" // for rust_error_at\n+#include \"rust-linemap.h\"\n #include \"safe-ctype.h\"\n \n #include <sstream> // for ostringstream\n@@ -25,7 +26,7 @@ namespace Rust {\n             str += static_cast<char>(0x80 | ((char32.value >> 0) & 0x3F));\n         } else {\n             fprintf(stderr, \"Invalid unicode codepoint found: '%u' \\n\", char32.value);\n-            // error_at(get_current_location(), \"Invalid unicode codepoint found: '%u'\",\n+            // rust_error_at(get_current_location(), \"Invalid unicode codepoint found: '%u'\",\n             // char32.value);\n         }\n         return str;\n@@ -54,7 +55,7 @@ namespace Rust {\n             str += static_cast<char>(0x80 | ((value >> 6) & 0x3F));\n             str += static_cast<char>(0x80 | ((value >> 0) & 0x3F));\n         } else {\n-            error_at(get_current_location(), \"Invalid unicode codepoint found: '%u'\", value);\n+            rust_error_at(get_current_location(), \"Invalid unicode codepoint found: '%u'\", value);\n         }*/\n         return str;\n     }\n@@ -86,20 +87,18 @@ namespace Rust {\n         return ISSPACE(character);\n     }\n \n-    Lexer::Lexer(const char* filename, FILE* input) :\n-      input(input), current_line(1), current_column(1), line_map(0), input_source(input),\n+    Lexer::Lexer(const char* filename, FILE* input, Linemap* linemap) :\n+      input(input), current_line(1), current_column(1), line_map(linemap), input_source(input),\n       input_queue(input_source), token_source(this), token_queue(token_source) {\n         // inform line_table that file is being entered and is in line 1\n-        line_map\n-          = ::linemap_add(::line_table, ::LC_ENTER, /* sysp */ 0, filename, /* current_line */ 1);\n+        line_map->start_file(filename, current_line);\n     }\n \n     Lexer::~Lexer() {\n-        ::linemap_add(::line_table, ::LC_LEAVE, /* sysp */ 0, /* filename */ NULL, /* to_line */ 0);\n     }\n \n-    location_t Lexer::get_current_location() {\n-        return ::linemap_position_for_column(::line_table, current_column);\n+    Location Lexer::get_current_location() {\n+        return line_map->get_location(current_column);\n     }\n \n     int Lexer::peek_input(int n) {\n@@ -177,7 +176,7 @@ namespace Rust {\n     TokenPtr Lexer::build_token() {\n         // loop to go through multiple characters to build a single token\n         while (true) {\n-            location_t loc = get_current_location();\n+            Location loc = get_current_location();\n             /*int */ current_char = peek_input();\n             skip_input();\n \n@@ -187,7 +186,7 @@ namespace Rust {\n             }\n \n             // detect shebang\n-            if (loc == 1 && current_line == 1 && current_char == '#') {\n+            if (current_line == 1 && current_char == '#') {\n                 current_char = peek_input();\n \n                 if (current_char == '!') {\n@@ -210,7 +209,7 @@ namespace Rust {\n                             current_line++;\n                             current_column = 1;\n                             // tell line_table that new line starts\n-                            linemap_line_start(::line_table, current_line, max_column_hint);\n+                            line_map->start_line(current_line, max_column_hint);\n                             continue;\n                     }\n                 }\n@@ -609,7 +608,7 @@ namespace Rust {\n                         parse_escape(length, byte_char, '\\'');\n \n                         if (byte_char > 127) {\n-                            error_at(\n+                            rust_error_at(\n                               get_current_location(), \"byte char '%c' out of range\", byte_char);\n                             byte_char = 0;\n                         }\n@@ -619,7 +618,7 @@ namespace Rust {\n                         length++;\n \n                         if (current_char != '\\'') {\n-                            error_at(get_current_location(), \"unclosed byte char\");\n+                            rust_error_at(get_current_location(), \"unclosed byte char\");\n                         }\n \n                         // TODO: ensure skipping is needed here\n@@ -634,15 +633,15 @@ namespace Rust {\n                         current_char = peek_input();\n \n                         if (current_char != '\\'') {\n-                            error_at(get_current_location(), \"unclosed byte char\");\n+                            rust_error_at(get_current_location(), \"unclosed byte char\");\n                         }\n \n                         // TODO: ensure skipping is needed here\n                         skip_input();\n                         current_char = peek_input();\n                         length++; // go to next char\n                     } else {\n-                        error_at(get_current_location(), \"no character inside '' for byte char\");\n+                        rust_error_at(get_current_location(), \"no character inside '' for byte char\");\n                     }\n \n                     current_column += length;\n@@ -667,7 +666,7 @@ namespace Rust {\n                             parse_escape(length, output_char, '\"');\n \n                             if (output_char > 127) {\n-                                error_at(get_current_location(),\n+                                rust_error_at(get_current_location(),\n                                   \"char '%c' in byte string out of range\", output_char);\n                                 output_char = 0;\n                             }\n@@ -687,7 +686,7 @@ namespace Rust {\n                     current_column += length;\n \n                     if (current_char == '\\n') {\n-                        error_at(get_current_location(), \"unended byte string literal\");\n+                        rust_error_at(get_current_location(), \"unended byte string literal\");\n                     } else if (current_char == '\"') {\n                         skip_input();\n                         current_char = peek_input();\n@@ -717,7 +716,7 @@ namespace Rust {\n                     }\n \n                     if (current_char != '\"') {\n-                        error_at(get_current_location(), \"raw byte string has no opening '\\\"'\");\n+                        rust_error_at(get_current_location(), \"raw byte string has no opening '\\\"'\");\n                     }\n \n                     skip_input();\n@@ -790,12 +789,12 @@ namespace Rust {\n \n                     // if just a single underscore, not an identifier\n                     if (first_is_underscore && length == 1) {\n-                        error_at(get_current_location(), \"'_' is not a valid raw identifier\");\n+                        rust_error_at(get_current_location(), \"'_' is not a valid raw identifier\");\n                     }\n \n                     if (str == \"crate\" || str == \"extern\" || str == \"self\" || str == \"super\"\n                         || str == \"Self\") {\n-                        error_at(\n+                        rust_error_at(\n                           get_current_location(), \"'%s' is a forbidden raw identifier\", str.c_str());\n                     } else {\n                         return Token::make_identifier(loc, str);\n@@ -819,7 +818,7 @@ namespace Rust {\n                     }\n \n                     if (current_char != '\"') {\n-                        error_at(get_current_location(), \"raw string has no opening '\\\"'\");\n+                        rust_error_at(get_current_location(), \"raw string has no opening '\\\"'\");\n                     }\n \n                     skip_input();\n@@ -960,7 +959,7 @@ namespace Rust {\n                         parse_in_type_suffix(/*current_char, */ type_hint, length);\n \n                         if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64) {\n-                            error_at(get_current_location(),\n+                            rust_error_at(get_current_location(),\n                               \"invalid type suffix '%s' for integer (hex) literal\",\n                               get_type_hint_string(type_hint));\n                         }\n@@ -1012,7 +1011,7 @@ namespace Rust {\n                         parse_in_type_suffix(/*current_char, */ type_hint, length);\n \n                         if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64) {\n-                            error_at(get_current_location(),\n+                            rust_error_at(get_current_location(),\n                               \"invalid type suffix '%s' for integer (octal) literal\",\n                               get_type_hint_string(type_hint));\n                         }\n@@ -1065,7 +1064,7 @@ namespace Rust {\n                         parse_in_type_suffix(/*current_char, */ type_hint, length);\n \n                         if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64) {\n-                            error_at(get_current_location(),\n+                            rust_error_at(get_current_location(),\n                               \"invalid type suffix '%s' for integer (binary) literal\",\n                               get_type_hint_string(type_hint));\n                         }\n@@ -1106,7 +1105,7 @@ namespace Rust {\n \n                         if (type_hint != CORETYPE_F32 && type_hint != CORETYPE_F64\n                             && type_hint != CORETYPE_UNKNOWN) {\n-                            error_at(get_current_location(),\n+                            rust_error_at(get_current_location(),\n                               \"invalid type suffix '%s' for float literal\",\n                               get_type_hint_string(type_hint));\n                         }\n@@ -1134,7 +1133,7 @@ namespace Rust {\n \n                         if (type_hint != CORETYPE_F32 && type_hint != CORETYPE_F64\n                             && type_hint != CORETYPE_UNKNOWN) {\n-                            error_at(get_current_location(),\n+                            rust_error_at(get_current_location(),\n                               \"invalid type suffix '%s' for float literal\",\n                               get_type_hint_string(type_hint));\n                         }\n@@ -1149,7 +1148,7 @@ namespace Rust {\n \n                         if (type_hint != CORETYPE_F32 && type_hint != CORETYPE_F64\n                             && type_hint != CORETYPE_UNKNOWN) {\n-                            error_at(get_current_location(),\n+                            rust_error_at(get_current_location(),\n                               \"invalid type suffix '%s' for float literal\",\n                               get_type_hint_string(type_hint));\n                         }\n@@ -1160,7 +1159,7 @@ namespace Rust {\n                         parse_in_type_suffix(/*current_char, */ type_hint, length);\n \n                         if (type_hint == CORETYPE_F32 || type_hint == CORETYPE_F64) {\n-                            error_at(get_current_location(),\n+                            rust_error_at(get_current_location(),\n                               \"invalid type suffix '%s' for integer (decimal) literal\",\n                               get_type_hint_string(type_hint));\n                         }\n@@ -1217,7 +1216,7 @@ namespace Rust {\n                 current_column += length;\n \n                 if (current_char32.value == '\\n') {\n-                    error_at(get_current_location(), \"unended string literal\");\n+                    rust_error_at(get_current_location(), \"unended string literal\");\n                 } else if (current_char32.value == '\"') {\n                     skip_input();\n \n@@ -1249,7 +1248,7 @@ namespace Rust {\n                     // test_skip_codepoint_input();\n \n                     if (test_peek_codepoint_input().value != '\\'') {\n-                        error_at(get_current_location(), \"unended char literal\");\n+                        rust_error_at(get_current_location(), \"unended char literal\");\n                     } else {\n                         test_skip_codepoint_input();\n                         current_char = peek_input();\n@@ -1302,13 +1301,13 @@ namespace Rust {\n \n                         return Token::make_lifetime(loc, str);\n                     } else {\n-                        error_at(get_current_location(), \"expected ' after character constant\");\n+                        rust_error_at(get_current_location(), \"expected ' after character constant\");\n                     }\n                 }\n             }\n \n             // didn't match anything so error\n-            error_at(loc, \"unexpected character '%x'\", current_char);\n+            rust_error_at(loc, \"unexpected character '%x'\", current_char);\n             current_column++;\n         }\n     }\n@@ -1370,7 +1369,7 @@ namespace Rust {\n         } else if (suffix == \"usize\") {\n             type_hint = CORETYPE_USIZE;\n         } else {\n-            error_at(get_current_location(), \"unknown number suffix '%s'\", suffix.c_str());\n+            rust_error_at(get_current_location(), \"unknown number suffix '%s'\", suffix.c_str());\n \n             return false;\n         }\n@@ -1446,7 +1445,7 @@ namespace Rust {\n                 length++;\n \n                 if (!ISXDIGIT(current_char)) {\n-                    error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n+                    rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n                 hexNum[0] = current_char;\n@@ -1457,15 +1456,15 @@ namespace Rust {\n                 length++;\n \n                 if (!ISXDIGIT(current_char)) {\n-                    error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n+                    rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n                 hexNum[1] = current_char;\n \n                 long hexLong = ::std::strtol(hexNum, NULL, 16);\n \n                 if (hexLong > 127)\n-                    error_at(get_current_location(),\n+                    rust_error_at(get_current_location(),\n                       \"ascii \\\\x escape '\\\\x%s' out of range - allows up to '\\\\x7F'\", hexNum);\n                 // gcc_assert(hexLong < 128); // as ascii\n                 char hexChar = static_cast<char>(hexLong);\n@@ -1550,13 +1549,13 @@ namespace Rust {\n                 // ensure closing brace\n                 if (need_close_brace && current_char != '}') {\n                     // actually an error\n-                    error_at(get_current_location(), \"expected terminating '}' in unicode escape\");\n+                    rust_error_at(get_current_location(), \"expected terminating '}' in unicode escape\");\n                     return false;\n                 }\n \n                 // ensure 1-6 hex characters\n                 if (num_str.length() > 6 || num_str.length() < 1) {\n-                    error_at(get_current_location(),\n+                    rust_error_at(get_current_location(),\n                       \"unicode escape should be between 1 and 6 hex characters; it is %lu\",\n                       num_str.length());\n                     return false;\n@@ -1566,7 +1565,7 @@ namespace Rust {\n \n                 // as debug, check hex_num = test_val\n                 if (hex_num > 255) {\n-                    error_at(\n+                    rust_error_at(\n                       get_current_location(), \"non-ascii chars not implemented yet, defaulting to 0\");\n                     hex_num = 0;\n                 }\n@@ -1620,7 +1619,7 @@ namespace Rust {\n                     return true;\n                 }\n             default:\n-                error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n+                rust_error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n                 // returns false if no parsing could be done\n                 return false;\n                 break;\n@@ -1651,7 +1650,7 @@ namespace Rust {\n                 length++;\n \n                 if (!ISXDIGIT(current_char)) {\n-                    error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n+                    rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n                 hexNum[0] = current_char;\n@@ -1662,15 +1661,15 @@ namespace Rust {\n                 length++;\n \n                 if (!ISXDIGIT(current_char)) {\n-                    error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n+                    rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n                 hexNum[1] = current_char;\n \n                 long hexLong = ::std::strtol(hexNum, NULL, 16);\n \n                 if (hexLong > 127)\n-                    error_at(get_current_location(),\n+                    rust_error_at(get_current_location(),\n                       \"ascii \\\\x escape '\\\\x%s' out of range - allows up to '\\\\x7F'\", hexNum);\n                 // gcc_assert(hexLong < 128); // as ascii\n                 char hexChar = static_cast<char>(hexLong);\n@@ -1758,15 +1757,15 @@ namespace Rust {\n                         length++;\n                     } else {\n                         // actually an error\n-                        error_at(\n+                        rust_error_at(\n                           get_current_location(), \"expected terminating '}' in unicode escape\");\n                         return false;\n                     }\n                 }\n \n                 // ensure 1-6 hex characters\n                 if (num_str.length() > 6 || num_str.length() < 1) {\n-                    error_at(get_current_location(),\n+                    rust_error_at(get_current_location(),\n                       \"unicode escape should be between 1 and 6 hex characters; it is %lu\",\n                       num_str.length());\n                     return false;\n@@ -1828,7 +1827,7 @@ namespace Rust {\n                     return true;\n                 }\n             default:\n-                error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n+                rust_error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n                 // returns false if no parsing could be done\n                 return false;\n                 break;\n@@ -1860,7 +1859,7 @@ namespace Rust {\n                 length++;\n \n                 if (!ISXDIGIT(current_char)) {\n-                    error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n+                    rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n                 hexNum[0] = current_char;\n@@ -1871,15 +1870,15 @@ namespace Rust {\n                 length++;\n \n                 if (!ISXDIGIT(current_char)) {\n-                    error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n+                    rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n                 hexNum[1] = current_char;\n \n                 long hexLong = ::std::strtol(hexNum, NULL, 16);\n \n                 if (hexLong > 127)\n-                    error_at(get_current_location(),\n+                    rust_error_at(get_current_location(),\n                       \"ascii \\\\x escape '\\\\x%s' out of range - allows up to '\\\\x7F'\", hexNum);\n                 // gcc_assert(hexLong < 128); // as ascii\n                 char hexChar = static_cast<char>(hexLong);\n@@ -1903,7 +1902,7 @@ namespace Rust {\n                 output_char = '\\0';\n                 break;\n             default:\n-                // error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n+                // rust_error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n                 // returns false if no parsing could be done\n                 return false;\n                 break;\n@@ -1996,13 +1995,13 @@ namespace Rust {\n         // ensure closing brace\n         if (need_close_brace && current_char != '}') {\n             // actually an error\n-            error_at(get_current_location(), \"expected terminating '}' in unicode escape\");\n+            rust_error_at(get_current_location(), \"expected terminating '}' in unicode escape\");\n             return false;\n         }\n \n         // ensure 1-6 hex characters\n         if (num_str.length() > 6 || num_str.length() < 1) {\n-            error_at(get_current_location(),\n+            rust_error_at(get_current_location(),\n               \"unicode escape should be between 1 and 6 hex characters; it is %lu\", num_str.length());\n             return false;\n         }\n@@ -2035,7 +2034,7 @@ namespace Rust {\n                 length++;\n \n                 if (!ISXDIGIT(current_char)) {\n-                    error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n+                    rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n                 hexNum[0] = current_char;\n@@ -2046,15 +2045,15 @@ namespace Rust {\n                 length++;\n \n                 if (!ISXDIGIT(current_char)) {\n-                    error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n+                    rust_error_at(get_current_location(), \"invalid character '\\\\x%c' in \\\\x sequence\",\n                       current_char);\n                 }\n                 hexNum[1] = current_char;\n \n                 long hexLong = ::std::strtol(hexNum, NULL, 16);\n \n                 if (hexLong > 255)\n-                    error_at(get_current_location(),\n+                    rust_error_at(get_current_location(),\n                       \"ascii \\\\x escape '\\\\x%s' out of range - allows up to '\\\\xFF'\", hexNum);\n                 // gcc_assert(hexLong < 128); // as ascii\n                 char hexChar = static_cast<char>(hexLong);\n@@ -2078,7 +2077,7 @@ namespace Rust {\n                 output_char = '\\0';\n                 break;\n             default:\n-                // error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n+                // rust_error_at(get_current_location(), \"unknown escape sequence '\\\\%c'\", current_char);\n                 // returns false if no parsing could be done\n                 return false;\n                 break;\n@@ -2149,7 +2148,7 @@ namespace Rust {\n             return output;*/\n             return 4;\n         } else {\n-            error_at(get_current_location(), \"invalid UTF-8 (too long)\");\n+            rust_error_at(get_current_location(), \"invalid UTF-8 (too long)\");\n             return 0;\n         }\n     }\n@@ -2203,7 +2202,7 @@ namespace Rust {\n                               | ((input3 & 0x3F) << 6) | ((input4 & 0x3F) << 0);\n             return { output };\n         } else {\n-            error_at(get_current_location(), \"invalid UTF-8 (too long)\");\n+            rust_error_at(get_current_location(), \"invalid UTF-8 (too long)\");\n             return { 0xFFFE };\n         }\n     }\n@@ -2274,7 +2273,7 @@ namespace Rust {\n             return output;*/\n             return 4;\n         } else {\n-            error_at(get_current_location(), \"invalid UTF-8 (too long)\");\n+            rust_error_at(get_current_location(), \"invalid UTF-8 (too long)\");\n             return 0;\n         }\n     }\n@@ -2342,8 +2341,8 @@ namespace Rust {\n                                       | ((input3 & 0x3F) << 6) | ((input4 & 0x3F) << 0);\n                     return output;\n                 } else {\n-                    error_at(get_current_location(), \"invalid UTF-8 (too long)\");\n+                    rust_error_at(get_current_location(), \"invalid UTF-8 (too long)\");\n                     return 0xFFFE;\n                 }*/\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "14b369c4948a99b13a7a8188de156207ffbc2fb1", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -1,14 +1,15 @@\n #ifndef RUST_LEX_H\n #define RUST_LEX_H\n \n+#include \"rust-linemap.h\"\n #include \"rust-buffered-queue.h\"\n #include \"rust-token.h\"\n \n namespace Rust {\n     class Lexer {\n       private:\n-        // Request new location_t for current column in line_table\n-        location_t get_current_location();\n+        // Request new Location for current column in line_table\n+        Location get_current_location();\n \n         // Skips the current input char.\n         void skip_input();\n@@ -47,7 +48,7 @@ namespace Rust {\n \n       public:\n         // Construct lexer with input file and filename provided\n-        Lexer(const char* filename, FILE* input);\n+        Lexer(const char* filename, FILE* input, Linemap* linemap);\n         ~Lexer();\n \n         // Returns token n tokens ahead of current position.\n@@ -63,6 +64,8 @@ namespace Rust {\n         // Replaces the current token with a specified token.\n         void replace_current_token(TokenPtr replacement);\n \n+        Linemap* get_line_map() { return line_map; }\n+\n       private:\n         // File for use as input.\n         FILE* input;\n@@ -72,7 +75,7 @@ namespace Rust {\n         // Current column number.\n         int current_column;\n         // Line map.\n-        const struct line_map* line_map;\n+        Linemap* line_map;\n \n         // Max column number that can be quickly allocated - higher may require allocating new linemap\n         static const int max_column_hint = 80;\n@@ -122,4 +125,4 @@ namespace Rust {\n     };\n }\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "13f4a184c675fca82416cb136dbae6de7bf12732", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -12,6 +12,7 @@\n // replace with proper std::memory in c++11\n #include <memory>\n \n+#include \"rust-linemap.h\"\n #include \"rust-codepoint.h\"\n \n namespace Rust {\n@@ -216,33 +217,33 @@ namespace Rust {\n         // Token kind.\n         TokenId token_id;\n         // Token location.\n-        location_t locus;\n+        Location locus;\n         // Associated text (if any) of token.\n         ::std::string* str;\n         // Type hint for token based on lexer data (e.g. type suffix). Does not exist for most tokens.\n         PrimitiveCoreType type_hint;\n \n         // Token constructor from token id and location. Has a null string.\n-        Token(TokenId token_id, location_t location) :\n+        Token(TokenId token_id, Location location) :\n           token_id(token_id), locus(location), str(NULL), type_hint(CORETYPE_UNKNOWN) {}\n \n         // Token constructor from token id, location, and a string.\n-        Token(TokenId token_id, location_t location, const ::std::string& paramStr) :\n+        Token(TokenId token_id, Location location, const ::std::string& paramStr) :\n           token_id(token_id), locus(location), str(new ::std::string(paramStr)),\n           type_hint(CORETYPE_UNKNOWN) {}\n \n         // Token constructor from token id, location, and a char.\n-        Token(TokenId token_id, location_t location, char paramChar) :\n+        Token(TokenId token_id, Location location, char paramChar) :\n           token_id(token_id), locus(location), str(new ::std::string(1, paramChar)),\n           type_hint(CORETYPE_UNKNOWN) {}\n \n         // Token constructor from token id, location, and a \"codepoint\".\n-        Token(TokenId token_id, location_t location, Codepoint paramCodepoint) :\n+        Token(TokenId token_id, Location location, Codepoint paramCodepoint) :\n           token_id(token_id), locus(location), str(new ::std::string(paramCodepoint.as_string())),\n           type_hint(CORETYPE_UNKNOWN) {}\n \n         // Token constructor from token id, location, a string, and type hint.\n-        Token(TokenId token_id, location_t location, const ::std::string& paramStr,\n+        Token(TokenId token_id, Location location, const ::std::string& paramStr,\n           PrimitiveCoreType parType) :\n           token_id(token_id),\n           locus(location), str(new ::std::string(paramStr)), type_hint(parType) {}\n@@ -259,59 +260,59 @@ namespace Rust {\n         }\n \n         // Makes and returns a new TokenPtr (with null string).\n-        static TokenPtr make(TokenId token_id, location_t locus) {\n+        static TokenPtr make(TokenId token_id, Location locus) {\n             return TokenPtr(new Token(token_id, locus));\n         }\n \n         // Makes and returns a new TokenPtr of type IDENTIFIER.\n-        static TokenPtr make_identifier(location_t locus, const ::std::string& str) {\n+        static TokenPtr make_identifier(Location locus, const ::std::string& str) {\n             return TokenPtr(new Token(IDENTIFIER, locus, str));\n         }\n \n         // Makes and returns a new TokenPtr of type INT_LITERAL.\n-        static TokenPtr make_int(location_t locus, const ::std::string& str) {\n+        static TokenPtr make_int(Location locus, const ::std::string& str) {\n             return TokenPtr(new Token(INT_LITERAL, locus, str));\n         }\n \n         // Makes and returns a new TokenPtr of type INT_LITERAL.\n         static TokenPtr make_int(\n-          location_t locus, const ::std::string& str, PrimitiveCoreType type_hint) {\n+          Location locus, const ::std::string& str, PrimitiveCoreType type_hint) {\n             return TokenPtr(new Token(INT_LITERAL, locus, str, type_hint));\n         }\n \n         // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n-        static TokenPtr make_float(location_t locus, const ::std::string& str) {\n+        static TokenPtr make_float(Location locus, const ::std::string& str) {\n             return TokenPtr(new Token(FLOAT_LITERAL, locus, str));\n         }\n \n         // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n         static TokenPtr make_float(\n-          location_t locus, const ::std::string& str, PrimitiveCoreType type_hint) {\n+          Location locus, const ::std::string& str, PrimitiveCoreType type_hint) {\n             return TokenPtr(new Token(FLOAT_LITERAL, locus, str, type_hint));\n         }\n \n         // Makes and returns a new TokenPtr of type STRING_LITERAL.\n-        static TokenPtr make_string(location_t locus, const ::std::string& str) {\n+        static TokenPtr make_string(Location locus, const ::std::string& str) {\n             return TokenPtr(new Token(STRING_LITERAL, locus, str, CORETYPE_STR));\n         }\n \n         // Makes and returns a new TokenPtr of type CHAR_LITERAL (fix).\n-        static TokenPtr make_char(location_t locus, Codepoint char_lit) {\n+        static TokenPtr make_char(Location locus, Codepoint char_lit) {\n             return TokenPtr(new Token(CHAR_LITERAL, locus, char_lit));\n         }\n \n         // Makes and returns a new TokenPtr of type BYTE_CHAR_LITERAL (fix).\n-        static TokenPtr make_byte_char(location_t locus, char byte_char) {\n+        static TokenPtr make_byte_char(Location locus, char byte_char) {\n             return TokenPtr(new Token(BYTE_CHAR_LITERAL, locus, byte_char));\n         }\n \n         // Makes and returns a new TokenPtr of type BYTE_STRING_LITERAL (fix).\n-        static TokenPtr make_byte_string(location_t locus, const ::std::string& str) {\n+        static TokenPtr make_byte_string(Location locus, const ::std::string& str) {\n             return TokenPtr(new Token(BYTE_STRING_LITERAL, locus, str));\n         }\n \n         // Makes and returns a new TokenPtr of type LIFETIME.\n-        static TokenPtr make_lifetime(location_t locus, const ::std::string& str) {\n+        static TokenPtr make_lifetime(Location locus, const ::std::string& str) {\n             return TokenPtr(new Token(LIFETIME, locus, str));\n         }\n \n@@ -321,7 +322,7 @@ namespace Rust {\n         }\n \n         // Gets location of the token.\n-        location_t get_locus() const {\n+        Location get_locus() const {\n             return locus;\n         }\n \n@@ -382,4 +383,4 @@ namespace Rust {\n     };\n }\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "ad7b920bc28a7af0bd8f0248dce56fb6f7e7fb54", "filename": "gcc/rust/parse/rust-parse-includes.h", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2b1a2084aedb12154df1e523cf3092ff563a95/gcc%2Frust%2Fparse%2Frust-parse-includes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2b1a2084aedb12154df1e523cf3092ff563a95/gcc%2Frust%2Fparse%2Frust-parse-includes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-includes.h?ref=3a2b1a2084aedb12154df1e523cf3092ff563a95", "patch": "@@ -1,27 +0,0 @@\n-#ifndef RUST_PARSE_INCLUDES_H\n-#define RUST_PARSE_INCLUDES_H\n-/* basically, this is just to stop gcc includes in rust-parse.cc from getting out of order due to \n- * formatter, which I can not figure out how to modify to not do this. */\n-// HACK: remove for final or near-final compiler where I don't have to use auto formatter anymore\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"target.h\"\n-#include \"tree.h\"\n-#include \"tree-iterator.h\"\n-#include \"input.h\"\n-#include \"diagnostic.h\"\n-#include \"stringpool.h\"\n-#include \"cgraph.h\"\n-#include \"gimplify.h\"\n-#include \"gimple-expr.h\"\n-#include \"convert.h\"\n-#include \"print-tree.h\"\n-#include \"stor-layout.h\"\n-#include \"fold-const.h\"\n-/* order: config, system, coretypes, target, tree, tree-iterator, input, diagnostic, stringpool,\n- * cgraph, gimplify, gimple-expr, convert, print-tree, stor-layout, fold-const  */\n-// probably don't need all these\n-\n-#endif\n\\ No newline at end of file"}, {"sha": "abd8831be923c08f25f6d2cfc95d9af7a32beac8", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 471, "deletions": 2156, "changes": 2627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc"}, {"sha": "ca846593210171a61fe8dbd94605b594c5086abb", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 3, "deletions": 157, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -2,11 +2,6 @@\n #define RUST_PARSE_H\n \n #include \"rust-lex.h\"\n-//#include \"rust-tree.h\"\n-#include \"rust-scope.h\"\n-\n-//#include \"rust-ast-containers.h\"\n-// TODO: change, maybe?\n #include \"rust-ast-full.h\"\n \n namespace Rust {\n@@ -78,44 +73,6 @@ namespace Rust {\n         void unexpected_token(const_TokenPtr t);\n         bool skip_generics_right_angle();\n \n-        // expression parsing\n-        int left_binding_power(const_TokenPtr tok);\n-        Tree null_denotation(const_TokenPtr tok);\n-        Tree left_denotation(const_TokenPtr tok, Tree left);\n-\n-        Tree parse_expression(int right_binding_power);\n-\n-        Tree coerce_binary_arithmetic(const_TokenPtr tok, Tree* left, Tree* right);\n-        bool check_logical_operands(const_TokenPtr tok, Tree left, Tree right);\n-\n-        Tree get_printf_addr();\n-        Tree get_puts_addr();\n-\n-        Tree get_scanf_addr();\n-\n-        Tree build_label_decl(const char* name, location_t loc);\n-        Tree build_if_statement(Tree bool_expr, Tree then_part, Tree else_part);\n-        Tree build_while_statement(Tree bool_expr, Tree while_body);\n-        Tree build_for_statement(\n-          SymbolPtr ind_var, Tree lower_bound, Tree upper_bound, Tree for_body_stmt_list);\n-\n-        const char* print_type(Tree type);\n-\n-        TreeStmtList& get_current_stmt_list();\n-\n-        void enter_scope();\n-\n-        struct TreeSymbolMapping {\n-            Tree bind_expr;\n-            Tree block;\n-        };\n-\n-        TreeSymbolMapping leave_scope();\n-\n-        SymbolPtr query_type(const std::string& name, location_t loc);\n-        SymbolPtr query_variable(const std::string& name, location_t loc);\n-        SymbolPtr query_integer_variable(const std::string& name, location_t loc);\n-\n         void parse_statement_seq(bool (Parser::*done)());\n \n         // AST-related stuff - maybe move or something?\n@@ -476,138 +433,27 @@ namespace Rust {\n         AST::StructPatternElements parse_struct_pattern_elems();\n         ::std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field();\n \n-        // void parse_crate();\n-        // AST::Module parse_module();\n-        // void parse_module_item(AST::Module module_for_items, AST::AttributeList\n-        // item_outer_attributes); AST::Visibility parse_visibility();\n+        int left_binding_power(const_TokenPtr token);\n \n         bool done_end();\n         bool done_end_or_else();\n         bool done_end_of_file();\n \n-        typedef Tree (Parser::*BinaryHandler)(const_TokenPtr, Tree);\n-        BinaryHandler get_binary_handler(TokenId id);\n-\n       public:\n         // Construct parser with specified lexer reference.\n-        Parser(Lexer& parLexer) : lexer(parLexer), printf_fn(), puts_fn(), scanf_fn() {}\n-\n-        // (old) Main entry point for parser.\n-        void parse_program();\n+        Parser(Lexer& parLexer) : lexer(parLexer) {}\n \n         // Main entry point for parser.\n         AST::Crate parse_crate();\n \n-        Tree parse_statement();\n-\n-        Tree parse_variable_declaration();\n-        Tree parse_type_declaration();\n-\n-        // Tree parse_type();\n-        Tree parse_record();\n-        Tree parse_field_declaration(std::vector<std::string>& field_names);\n-\n-        Tree parse_assignment_statement();\n-        Tree parse_if_statement();\n-        Tree parse_while_statement();\n-        Tree parse_for_statement();\n-        Tree parse_read_statement();\n-        Tree parse_write_statement();\n-\n-        Tree parse_expression();\n-        Tree parse_expression_naming_variable();\n-        Tree parse_lhs_assignment_expression();\n-        Tree parse_boolean_expression();\n-        Tree parse_integer_expression();\n-\n         // Dumps all lexer output.\n         void debug_dump_lex_output();\n         void debug_dump_ast_output();\n \n       private:\n         // The lexer associated with the parser.\n         Lexer& lexer;\n-        // The current scope.\n-        Scope scope;\n-\n-        // The simulated \"main\" function inside which the entire program lies.\n-        tree main_fndecl;\n-\n-        // Address to function declaration of printf.\n-        Tree printf_fn;\n-        // Address to function declaration of puts.\n-        Tree puts_fn;\n-        // Address to function declaration of scanf.\n-        Tree scanf_fn;\n-\n-        // The statement stack.\n-        std::vector<TreeStmtList> stack_stmt_list;\n-        // The VAR_DECL stack.\n-        std::vector<TreeChain> stack_var_decl_chain;\n-\n-        // The block stack.\n-        std::vector<BlockChain> stack_block_chain;\n-\n-// x-macro list for binary operators - only defined here to be inside Parser class\n-#define BINARY_HANDLER_LIST                                             \\\n-    BINARY_HANDLER(plus, PLUS)                                          \\\n-    BINARY_HANDLER(minus, MINUS)                                        \\\n-    BINARY_HANDLER(mult, ASTERISK)                                      \\\n-    BINARY_HANDLER(div, DIV)                                            \\\n-    BINARY_HANDLER(mod, PERCENT)                                        \\\n-    BINARY_HANDLER(bitwise_and, AMP)                                    \\\n-    BINARY_HANDLER(bitwise_or, PIPE)                                    \\\n-    BINARY_HANDLER(bitwise_xor, CARET)                                  \\\n-    BINARY_HANDLER(left_shift, LEFT_SHIFT)                              \\\n-    BINARY_HANDLER(right_shift, RIGHT_SHIFT)                            \\\n-                                                                        \\\n-    BINARY_HANDLER(equal, EQUAL_EQUAL)                                  \\\n-    BINARY_HANDLER(not_equal, NOT_EQUAL)                                \\\n-    BINARY_HANDLER(smaller_than, LEFT_ANGLE)                            \\\n-    BINARY_HANDLER(smaller_equal, LESS_OR_EQUAL)                        \\\n-    BINARY_HANDLER(greater_than, RIGHT_ANGLE)                           \\\n-    BINARY_HANDLER(greater_equal, GREATER_OR_EQUAL)                     \\\n-                                                                        \\\n-    BINARY_HANDLER(logical_and, LOGICAL_AND)                            \\\n-    BINARY_HANDLER(logical_or, OR)                                      \\\n-                                                                        \\\n-    BINARY_HANDLER(as_cast, AS)                                         \\\n-    /* should this really be an operator? */                            \\\n-                                                                        \\\n-    BINARY_HANDLER(array_index, LEFT_SQUARE)                            \\\n-                                                                        \\\n-    BINARY_HANDLER(field_ref, DOT)                                      \\\n-    /*BINARY_HANDLER(method_call, DOT)*/                                \\\n-    BINARY_HANDLER(error_propagation, QUESTION_MARK)                    \\\n-    /* not a binary operator, technically, but still left denotation */ \\\n-    BINARY_HANDLER(assignment_expr, EQUAL)                              \\\n-    /* should this really be an operator? or a binary one? */           \\\n-    /* if it should, also add all operation-assign below:*/             \\\n-    BINARY_HANDLER(plus_assig, PLUS_EQ)                                 \\\n-    BINARY_HANDLER(minus_assig, MINUS_EQ)                               \\\n-    BINARY_HANDLER(mult_assig, ASTERISK_EQ)                             \\\n-    BINARY_HANDLER(div_assig, DIV_EQ)                                   \\\n-    BINARY_HANDLER(mod_assig, PERCENT_EQ)                               \\\n-    BINARY_HANDLER(bitwise_and_assig, AMP_EQ)                           \\\n-    BINARY_HANDLER(bitwise_or_assig, PIPE_EQ)                           \\\n-    BINARY_HANDLER(bitwise_xor_assig, CARET_EQ)                         \\\n-    BINARY_HANDLER(left_shift_assig, LEFT_SHIFT_EQ)                     \\\n-    BINARY_HANDLER(right_shift_assig, RIGHT_SHIFT_EQ)                   \\\n-                                                                        \\\n-    BINARY_HANDLER(range_exclusive, DOT_DOT)                            \\\n-    BINARY_HANDLER(range_inclusive, DOT_DOT_EQ)                         \\\n-                                                                        \\\n-    BINARY_HANDLER(path, SCOPE_RESOLUTION)                              \\\n-                                                                        \\\n-    BINARY_HANDLER(return, RETURN_TOK)                                  \\\n-    BINARY_HANDLER(break, BREAK)                                        \\\n-    BINARY_HANDLER(closure, MOVE)\n-\n-// create declarations for binary op handling\n-#define BINARY_HANDLER(name, _) Tree binary_##name(const_TokenPtr tok, Tree left);\n-        BINARY_HANDLER_LIST\n-#undef BINARY_HANDLER\n     };\n }\n \n-#endif // RUST_PARSE_H\n\\ No newline at end of file\n+#endif // RUST_PARSE_H"}, {"sha": "d38a07801cc0280c501b04ea6499d61f6403581e", "filename": "gcc/rust/parse/rust-scope.cc", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2b1a2084aedb12154df1e523cf3092ff563a95/gcc%2Frust%2Fparse%2Frust-scope.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2b1a2084aedb12154df1e523cf3092ff563a95/gcc%2Frust%2Fparse%2Frust-scope.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-scope.cc?ref=3a2b1a2084aedb12154df1e523cf3092ff563a95", "patch": "@@ -1,43 +0,0 @@\n-#include \"rust-scope.h\"\n-\n-#include <utility> // for std::make_pair\n-\n-namespace Rust {\n-    Scope::Scope() {}\n-\n-    void SymbolMapping::insert(SymbolPtr s) {\n-        gcc_assert(s != NULL);\n-        std::pair<Map::iterator, bool> p = map.insert(std::make_pair(s->get_name(), s));\n-\n-        gcc_assert(p.second);\n-    }\n-\n-    SymbolPtr SymbolMapping::get(const std::string& str) const {\n-        Map::const_iterator it = map.find(str);\n-        if (it != map.end()) {\n-            return it->second;\n-        }\n-\n-        return SymbolPtr();\n-    }\n-\n-    SymbolPtr Scope::lookup(const std::string& str) {\n-        // Traverse stack from top (end of MapStack) to bottom, so use reverse_iterator.\n-        for (MapStack::reverse_iterator map = map_stack.rbegin(); map != map_stack.rend(); map++) {\n-            if (SymbolPtr sym = map->get(str)) {\n-                return sym;\n-            }\n-        }\n-\n-        return SymbolPtr();\n-    }\n-\n-    void Scope::push_scope() {\n-        map_stack.push_back(SymbolMapping());\n-    }\n-\n-    void Scope::pop_scope() {\n-        gcc_assert(!map_stack.empty());\n-        map_stack.pop_back();\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "7ac38c998b6a9506981bea5b0f635ae1eb6938d4", "filename": "gcc/rust/parse/rust-scope.h", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2b1a2084aedb12154df1e523cf3092ff563a95/gcc%2Frust%2Fparse%2Frust-scope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2b1a2084aedb12154df1e523cf3092ff563a95/gcc%2Frust%2Fparse%2Frust-scope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-scope.h?ref=3a2b1a2084aedb12154df1e523cf3092ff563a95", "patch": "@@ -1,61 +0,0 @@\n-#ifndef RUST_SCOPE_H\n-#define RUST_SCOPE_H\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree.h\"\n-// order: config, system, coretypes, tree\n-// may not all be required\n-\n-#include <map>\n-#include <string>\n-#include <vector>\n-\n-#include \"rust-tree.h\"\n-#include \"rust-symbol.h\"\n-\n-// maybe split out scope into Symbol, SymbolMapping, and Scope headers\n-\n-namespace Rust {\n-    // Map of strings (identifiers) to SymbolPtrs\n-    struct SymbolMapping {\n-      public:\n-        // Inserts a new Symbol into the map using its name as the key. Also checks name is unique.\n-        void insert(SymbolPtr s);\n-        // Returns the mapped Symbol for the given string. May return a null Symbol.\n-        SymbolPtr get(const std::string& str) const;\n-\n-      private:\n-        typedef std::map<std::string, SymbolPtr> Map;\n-        // SymbolMapping's map.\n-        Map map;\n-    };\n-\n-    // Scope class that holds mapping in it.\n-    class Scope {\n-      public:\n-        // Gets current mapping (created in last push that hasn't been popped yet).\n-        SymbolMapping& get_current_mapping() {\n-            gcc_assert(!map_stack.empty());\n-            return map_stack.back();\n-        }\n-\n-        // Create new mapping.\n-        void push_scope();\n-        // Get rid of mapping?\n-        void pop_scope();\n-\n-        Scope();\n-\n-        // Get the last mapping for a given string (or null if no such mapping exists).\n-        SymbolPtr lookup(const std::string& str);\n-\n-      private:\n-        typedef std::vector<SymbolMapping> MapStack;\n-        // Scope's MapStack.\n-        MapStack map_stack;\n-    }; // TODO: have multiple scopes (for modules, function, etc) at once?\n-}\n-\n-#endif // RUST_SCOPE_H\n\\ No newline at end of file"}, {"sha": "439325b68feef10fde45cc76c4a4bf58b761f143", "filename": "gcc/rust/parse/rust-symbol.h", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2b1a2084aedb12154df1e523cf3092ff563a95/gcc%2Frust%2Fparse%2Frust-symbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2b1a2084aedb12154df1e523cf3092ff563a95/gcc%2Frust%2Fparse%2Frust-symbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-symbol.h?ref=3a2b1a2084aedb12154df1e523cf3092ff563a95", "patch": "@@ -1,78 +0,0 @@\n-#ifndef RUST_SYMBOL_H\n-#define RUST_SYMBOL_H\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree.h\"\n-// order: config, system, coretypes, tree\n-\n-#include <string>\n-//#include <tr1/memory> // as shared_ptr is not available in std memory in c++03\n-// replaced with proper memory in c++11\n-#include <memory>\n-\n-namespace Rust {\n-    // Kinds of symbols.\n-    enum SymbolKind { INVALID, VARIABLE, TYPENAME /*change to STRUCT*/, FUNCTION };\n-    // TODO: possibly add typedef, struct, union, \"enum\"\n-\n-    /* TODO: apparently Rust's type symbol table is separate to its identifier symbol table, so have a\n-     * different symbol table for each? */\n-\n-    /* The symbol table(s) will be generated as a pass over the AST (the first, probably) and each \n-     * scope, including module namespacing, will be a separate symbol table (with earlier ones still\n-     * accessible but searched afterward). It will be preserved in later passes over the AST to type\n-     * check and maybe bind identifiers together or something. \n-     * It may have to be preserved, at least partially, for GENERIC lowering. */\n-\n-    // A symbol used for identifiers, etc. - TODO: extend to support namespacing (Rust paths?)\n-    struct Symbol {\n-      public:\n-        // Constructs a new symbol of name with no declaration tree set.\n-        Symbol(SymbolKind kind, const std::string& name_) :\n-          kind(kind), name(name_), decl(error_mark_node) {\n-            gcc_assert(name.size() > 0);\n-        }\n-\n-        // Gets symbol's kind.\n-        SymbolKind get_kind() const {\n-            return kind;\n-        }\n-\n-        // Gets symbol's name.\n-        std::string get_name() const {\n-            return name;\n-        }\n-\n-        // Sets symbol's declaration tree.\n-        void set_tree_decl(Tree decl_) {\n-            // Ensure declaration tree is a variable or type declaration.\n-            gcc_assert((decl_.get_tree_code() == VAR_DECL) || (decl_.get_tree_code() == TYPE_DECL));\n-            decl = decl_;\n-        }\n-\n-        // Gets tree with the location of variable declaration.\n-        Tree get_tree_decl() const {\n-            return decl;\n-        }\n-\n-      private:\n-        // Symbol's kind.\n-        SymbolKind kind;\n-        // Symbol's name.\n-        std::string name;\n-        // Symbol's declaration tree.\n-        Tree decl;\n-\n-        // Note: in other languages, other info about symbols would also be kept, e.g. \"kind\"\n-        // Also would be able to store more than just variable declaration trees.\n-    };\n-\n-    // Symbol shared pointer.\n-    typedef std::shared_ptr<Symbol> SymbolPtr;\n-    // Const symbol shared pointer (i.e. to const Symbol).\n-    typedef std::shared_ptr<const Symbol> const_SymbolPtr;\n-}\n-\n-#endif\n\\ No newline at end of file"}, {"sha": "6318a50d31468955dfe42dd314696cd2aa2bf0ed", "filename": "gcc/rust/parse/rust-tree.h", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a2b1a2084aedb12154df1e523cf3092ff563a95/gcc%2Frust%2Fparse%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a2b1a2084aedb12154df1e523cf3092ff563a95/gcc%2Frust%2Fparse%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-tree.h?ref=3a2b1a2084aedb12154df1e523cf3092ff563a95", "patch": "@@ -1,167 +0,0 @@\n-#ifndef RUST_TREE_H\n-#define RUST_TREE_H\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tree.h\"\n-#include \"tree-iterator.h\"\n-#include \"input.h\"\n-// order: config, system, coretypes, tree, tree-iterator, input\n-// may not need all of them\n-\n-namespace Rust {\n-    // Wrapper around tree to keep location and tree in one data structure.\n-    struct Tree {\n-      public:\n-        Tree() : t(NULL_TREE), loc(UNKNOWN_LOCATION) {}\n-        Tree(tree t_) : t(t_), loc(EXPR_LOCATION(t)) {}\n-        Tree(tree t_, location_t loc_) : t(t_), loc(loc_) {}\n-        Tree(Tree t_, location_t loc_) : t(t_.get_tree()), loc(loc_) {}\n-\n-        // Get tree's location_t.\n-        location_t get_locus() const {\n-            return loc;\n-        }\n-\n-        // Sets tree's location_t.\n-        void set_locus(location_t loc_) {\n-            loc = loc_;\n-        }\n-\n-        // Gets tree's tree in GCC form.\n-        tree get_tree() const {\n-            return t;\n-        }\n-\n-        // Gets tree's GCC tree code.\n-        tree_code get_tree_code() const {\n-            return TREE_CODE(t);\n-        }\n-\n-        // Sets tree's GCC tree.\n-        void set_tree(tree t_) {\n-            t = t_;\n-        }\n-\n-        // Returns if tree is an error node?\n-        bool is_error() const {\n-            return error_operand_p(t);\n-        }\n-\n-        // Returns whether tree node is null.\n-        bool is_null() {\n-            return t == NULL_TREE;\n-        }\n-\n-        // Creates an error Tree.\n-        static Tree error() {\n-            return Tree(error_mark_node);\n-        }\n-\n-        // Gets tree's GCC type.\n-        Tree get_type() const {\n-            return TREE_TYPE(t);\n-        }\n-\n-      private:\n-        // The tree object's gcc tree representation.\n-        tree t;\n-        // The tree's location.\n-        location_t loc;\n-    };\n-\n-    // Comparison by identity as tree is a pointer.\n-    inline bool operator==(Tree t1, Tree t2) {\n-        return t1.get_tree() == t2.get_tree();\n-    }\n-    inline bool operator!=(Tree t1, Tree t2) {\n-        return !(t1 == t2);\n-    }\n-\n-    inline Tree build_tree(tree_code tc, location_t loc, Tree type, Tree t1) {\n-        return build1_loc(loc, tc, type.get_tree(), t1.get_tree());\n-    }\n-\n-    inline Tree build_tree(tree_code tc, location_t loc, Tree type, Tree t1, Tree t2) {\n-        return build2_loc(loc, tc, type.get_tree(), t1.get_tree(), t2.get_tree());\n-    }\n-\n-    inline Tree build_tree(tree_code tc, location_t loc, Tree type, Tree t1, Tree t2, Tree t3) {\n-        return build3_loc(loc, tc, type.get_tree(), t1.get_tree(), t2.get_tree(), t3.get_tree());\n-    }\n-\n-    inline Tree build_tree(\n-      tree_code tc, location_t loc, Tree type, Tree t1, Tree t2, Tree t3, Tree t4) {\n-        return build4_loc(\n-          loc, tc, type.get_tree(), t1.get_tree(), t2.get_tree(), t3.get_tree(), t4.get_tree());\n-    }\n-\n-    inline Tree build_tree(\n-      tree_code tc, location_t loc, Tree type, Tree t1, Tree t2, Tree t3, Tree t4, Tree t5) {\n-        return build5_loc(loc, tc, type.get_tree(), t1.get_tree(), t2.get_tree(), t3.get_tree(),\n-          t4.get_tree(), t5.get_tree());\n-    }\n-\n-    // Wrapper around STATEMENT_LIST, used to represent lists of statements. Adapter for TREE_LIST.\n-    struct TreeStmtList {\n-      public:\n-        // Create new statement list from nothing.\n-        TreeStmtList() : list(alloc_stmt_list()) {}\n-        // Create new statement list from given tree.\n-        TreeStmtList(Tree param_tree) : list(param_tree.get_tree()) {}\n-\n-        // Append to statement list.\n-        void append(Tree param_tree) {\n-            append_to_statement_list(param_tree.get_tree(), &list);\n-        }\n-\n-        // Get the statement list.\n-        tree get_tree() const {\n-            return list;\n-        }\n-\n-      private:\n-        // The statement list.\n-        tree list;\n-    };\n-\n-    // TODO: Check if already exists in GCC\n-    template<typename Append>\n-    struct TreeChainBase {\n-        Tree first;\n-        Tree last;\n-\n-        TreeChainBase() : first(), last() {}\n-\n-        void append(Tree t) {\n-            gcc_assert(!t.is_null());\n-            if (first.is_null()) {\n-                first = last = t;\n-            } else {\n-                Append()(last, t);\n-                last = t;\n-            }\n-        }\n-    };\n-\n-    struct tree_chain_append {\n-        void operator()(Tree t, Tree a) {\n-            TREE_CHAIN(t.get_tree()) = a.get_tree();\n-        }\n-    };\n-\n-    // Single-linked list implemented with trees. Used for VAR_DECLs.\n-    struct TreeChain : TreeChainBase<tree_chain_append> {};\n-\n-    struct block_chain_append {\n-        void operator()(Tree t, Tree a) {\n-            BLOCK_CHAIN(t.get_tree()) = a.get_tree();\n-        }\n-    };\n-\n-    // Single-linked list implemented with trees. Used for chains of blocks.\n-    struct BlockChain : TreeChainBase<block_chain_append> {};\n-}\n-\n-#endif // RUST_TREE_H\n\\ No newline at end of file"}, {"sha": "d7c6475a1d3a2f319b188416e0bda909655d6ddc", "filename": "gcc/rust/rust-diagnostics.cc", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Frust-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Frust-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.cc?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -0,0 +1,215 @@\n+// rust-diagnostics.cc -- GCC implementation of rust diagnostics interface.\n+// Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+// Contributed by Than McIntosh, Google.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+#include \"rust-diagnostics.h\"\n+\n+static std::string\n+mformat_value()\n+{\n+  return std::string(xstrerror(errno));\n+}\n+\n+// Rewrite a format string to expand any extensions not\n+// supported by sprintf(). See comments in rust-diagnostics.h\n+// for list of supported format specifiers.\n+\n+static std::string\n+expand_format(const char* fmt)\n+{\n+  std::stringstream ss;\n+  for (const char* c = fmt; *c; ++c)\n+    {\n+      if (*c != '%')\n+        {\n+          ss << *c;\n+          continue;\n+        }\n+      c++;\n+      switch (*c)\n+        {\n+          case '\\0':\n+            {\n+              // malformed format string\n+              rust_unreachable();\n+            }\n+          case '%':\n+            {\n+              ss << \"%\";\n+              break;\n+            }\n+          case 'm':\n+            {\n+              ss << mformat_value();\n+              break;\n+            }\n+          case '<':\n+            {\n+              ss << rust_open_quote();\n+              break;\n+            }\n+          case '>':\n+            {\n+              ss << rust_close_quote();\n+              break;\n+            }\n+          case 'q':\n+            {\n+              ss << rust_open_quote();\n+              c++;\n+              if (*c == 'm')\n+                {\n+                  ss << mformat_value();\n+                }\n+              else\n+                {\n+                  ss << \"%\" << *c;\n+                }\n+              ss << rust_close_quote();\n+              break;\n+            }\n+          default:\n+            {\n+              ss << \"%\" << *c;\n+            }\n+        }\n+    }\n+  return ss.str();\n+}\n+\n+// Expand message format specifiers, using a combination of\n+// expand_format above to handle extensions (ex: %m, %q) and vasprintf()\n+// to handle regular printf-style formatting. A pragma is being used here to\n+// suppress this warning:\n+//\n+//   warning: function \u2018std::__cxx11::string expand_message(const char*, __va_list_tag*)\u2019 might be a candidate for \u2018gnu_printf\u2019 format attribute [-Wsuggest-attribute=format]\n+//\n+// What appears to be happening here is that the checker is deciding that\n+// because of the call to vasprintf() (which has attribute gnu_printf), the\n+// calling function must need to have attribute gnu_printf as well, even\n+// though there is already an attribute declaration for it.\n+\n+static std::string\n+expand_message(const char* fmt, va_list ap) RUST_ATTRIBUTE_GCC_DIAG(1,0);\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wsuggest-attribute=format\"\n+\n+static std::string\n+expand_message(const char* fmt, va_list ap)\n+{\n+  char* mbuf = 0;\n+  std::string expanded_fmt = expand_format(fmt);\n+  int nwr = vasprintf(&mbuf, expanded_fmt.c_str(), ap);\n+  if (nwr == -1)\n+    {\n+      // memory allocation failed\n+      rust_be_error_at(Linemap::unknown_location(),\n+                     \"memory allocation failed in vasprintf\");\n+      rust_assert(0);\n+    }\n+  std::string rval = std::string(mbuf);\n+  free(mbuf);\n+  return rval;\n+}\n+\n+#pragma GCC diagnostic pop\n+\n+static const char* cached_open_quote = NULL;\n+static const char* cached_close_quote = NULL;\n+\n+const char*\n+rust_open_quote()\n+{\n+  if (cached_open_quote == NULL)\n+    rust_be_get_quotechars(&cached_open_quote, &cached_close_quote);\n+  return cached_open_quote;\n+}\n+\n+const char*\n+rust_close_quote()\n+{\n+  if (cached_close_quote == NULL)\n+    rust_be_get_quotechars(&cached_open_quote, &cached_close_quote);\n+  return cached_close_quote;\n+}\n+\n+void\n+rust_error_at(const Location location, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  rust_be_error_at(location, expand_message(fmt, ap));\n+  va_end(ap);\n+}\n+\n+void\n+rust_warning_at(const Location location, int opt, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  rust_be_warning_at(location, opt, expand_message(fmt, ap));\n+  va_end(ap);\n+}\n+\n+void\n+rust_fatal_error(const Location location, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  rust_be_fatal_error(location, expand_message(fmt, ap));\n+  va_end(ap);\n+}\n+\n+void\n+rust_inform(const Location location, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  rust_be_inform(location, expand_message(fmt, ap));\n+  va_end(ap);\n+}\n+\n+// rust_debug uses normal printf formatting, not GCC diagnostic formatting.\n+\n+void\n+rust_debug(const Location location, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  char* mbuf = NULL;\n+  int nwr = vasprintf(&mbuf, fmt, ap);\n+  va_end(ap);\n+  if (nwr == -1)\n+    {\n+      rust_be_error_at(Linemap::unknown_location(),\n+\t\t     \"memory allocation failed in vasprintf\");\n+      rust_assert(0);\n+    }\n+  std::string rval = std::string(mbuf);\n+  free(mbuf);\n+  rust_be_inform(location, rval);\n+}\n+"}, {"sha": "170199938b62262e095b085793c77c9a60672d06", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -8,6 +8,8 @@\n \n #include <algorithm>\n \n+extern Linemap* rust_get_linemap();\n+\n namespace Rust {\n     // Simple wrapper for FILE* that simplifies destruction.\n     struct RAIIFile {\n@@ -280,7 +282,7 @@ namespace Rust {\n \n         // parse file here\n         // create lexer and parser - these are file-specific and so aren't instance variables\n-        Rust::Lexer lex(filename, file_wrap.file);\n+        Rust::Lexer lex(filename, file_wrap.file, rust_get_linemap());\n         Rust::Parser parser(lex);\n \n         // determine parsing method from options\n@@ -515,8 +517,13 @@ namespace Rust {\n             AST::Attribute attr(AST::SimplePath::from_str(\"macro_use\"), NULL);\n \n             // create \"extern crate\" item with the name\n-            ::std::unique_ptr<AST::ExternCrate> extern_crate(new AST::ExternCrate(\n-              *it, AST::Visibility::create_error(), { ::std::move(attr) }, UNKNOWN_LOCATION));\n+            ::std::unique_ptr<AST::ExternCrate> extern_crate(\n+                new AST::ExternCrate(\n+                    *it,\n+                    AST::Visibility::create_error(),\n+                    { ::std::move(attr) },\n+                    Linemap::unknown_location())\n+                );\n \n             // insert at beginning\n             crate.items.insert(crate.items.begin(), ::std::move(extern_crate));\n@@ -529,10 +536,10 @@ namespace Rust {\n                 AST::SimplePathSegment(\"v1\") };\n         // create use tree and decl\n         ::std::unique_ptr<AST::UseTreeGlob> use_tree(new AST::UseTreeGlob(\n-          AST::UseTreeGlob::PATH_PREFIXED, AST::SimplePath(::std::move(segments)), UNKNOWN_LOCATION));\n+          AST::UseTreeGlob::PATH_PREFIXED, AST::SimplePath(::std::move(segments)), Linemap::unknown_location()));\n         AST::Attribute prelude_attr(AST::SimplePath::from_str(\"prelude_import\"), NULL);\n         ::std::unique_ptr<AST::UseDeclaration> use_decl(new AST::UseDeclaration(::std::move(use_tree),\n-          AST::Visibility::create_error(), { ::std::move(prelude_attr) }, UNKNOWN_LOCATION));\n+          AST::Visibility::create_error(), { ::std::move(prelude_attr) }, Linemap::unknown_location()));\n \n         crate.items.insert(crate.items.begin(), ::std::move(use_decl));\n \n@@ -651,4 +658,4 @@ namespace Rust {\n      *  - analysis on global context (HIR optimisations? create MIR?)\n      *  - code generation\n      *  - link */\n-}\n\\ No newline at end of file\n+}"}, {"sha": "167d494395f2abf955f82d3357c7b4c0a48df839", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52243e9b3960cae794c56498e4d2dfe6dfaa82cc/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=52243e9b3960cae794c56498e4d2dfe6dfaa82cc", "patch": "@@ -7,6 +7,10 @@\n #include \"coretypes.h\"\n #include \"options.h\"\n #include \"rust-system.h\"\n+\n+#include \"rust-linemap.h\"\n+#include \"backend.h\"\n+\n #include <utility>\n \n namespace Rust {\n@@ -135,6 +139,12 @@ namespace Rust {\n         // This should really be in a per-crate storage area but it is wiped with every file so eh.\n         ::std::string injected_crate_name;\n \n+        // backend wrapper to GCC GENERIC\n+        Backend* backend;\n+\n+        // backend linemap\n+        Linemap* linemap;\n+\n       public:\n         /* Initialise compiler session. Corresponds to langhook grs_langhook_init(). Note that this is\n          * called after option handling. */"}]}