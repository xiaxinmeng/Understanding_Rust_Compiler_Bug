{"sha": "2118438f49f0c193abe3fa3def350a8129045746", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjExODQzOGY0OWYwYzE5M2FiZTNmYTNkZWYzNTBhODEyOTA0NTc0Ng==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-26T16:50:37Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-26T18:05:53Z"}, "message": "Handle signed 1-bit ranges in irange::invert.\n\nThe problem here is we are trying to add 1 to a -1 in a signed 1-bit\nfield and coming up with UNDEFINED because of the overflow.\n\nSigned 1-bits are annoying because you can't really add or subtract\none, because the one is unrepresentable.  For invert() we have a\nspecial subtract_one() function that handles 1-bit signed fields.\n\nThis patch implements the analogous add_one() function so that invert\nworks.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/97555\n\t* range-op.cc (range_tests): Test 1-bit signed invert.\n\t* value-range.cc (subtract_one): Adjust comment.\n\t(add_one): New.\n\t(irange::invert): Call add_one.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/pr97555.c: New test.", "tree": {"sha": "9a14a7334ad2760d8c7ccbdb4de9220544e1c068", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a14a7334ad2760d8c7ccbdb4de9220544e1c068"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2118438f49f0c193abe3fa3def350a8129045746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2118438f49f0c193abe3fa3def350a8129045746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2118438f49f0c193abe3fa3def350a8129045746", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2118438f49f0c193abe3fa3def350a8129045746/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f20a6c57f0f26d9c60d6d6182f1e2181f727c834", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f20a6c57f0f26d9c60d6d6182f1e2181f727c834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f20a6c57f0f26d9c60d6d6182f1e2181f727c834"}], "stats": {"total": 62, "additions": 54, "deletions": 8}, "files": [{"sha": "74ab2e57fdea265727f7796ed6bcc5043b3562eb", "filename": "gcc/range-op.cc", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2118438f49f0c193abe3fa3def350a8129045746/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2118438f49f0c193abe3fa3def350a8129045746/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=2118438f49f0c193abe3fa3def350a8129045746", "patch": "@@ -3680,15 +3680,28 @@ range_tests ()\n   // Test 1-bit signed integer union.\n   // [-1,-1] U [0,0] = VARYING.\n   tree one_bit_type = build_nonstandard_integer_type (1, 0);\n+  tree one_bit_min = vrp_val_min (one_bit_type);\n+  tree one_bit_max = vrp_val_max (one_bit_type);\n   {\n-    tree one_bit_min = vrp_val_min (one_bit_type);\n-    tree one_bit_max = vrp_val_max (one_bit_type);\n     int_range<2> min (one_bit_min, one_bit_min);\n     int_range<2> max (one_bit_max, one_bit_max);\n     max.union_ (min);\n     ASSERT_TRUE (max.varying_p ());\n   }\n \n+  // Test inversion of 1-bit signed integers.\n+  {\n+    int_range<2> min (one_bit_min, one_bit_min);\n+    int_range<2> max (one_bit_max, one_bit_max);\n+    int_range<2> t;\n+    t = min;\n+    t.invert ();\n+    ASSERT_TRUE (t == max);\n+    t = max;\n+    t.invert ();\n+    ASSERT_TRUE (t == min);\n+  }\n+\n   // Test that NOT(255) is [0..254] in 8-bit land.\n   int_range<1> not_255 (UCHAR (255), UCHAR (255), VR_ANTI_RANGE);\n   ASSERT_TRUE (not_255 == int_range<1> (UCHAR (0), UCHAR (254)));"}, {"sha": "625bc6fa14b3aa65d43c4b26edb83eebfcdae5fe", "filename": "gcc/testsuite/gcc.dg/pr97555.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2118438f49f0c193abe3fa3def350a8129045746/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97555.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2118438f49f0c193abe3fa3def350a8129045746/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97555.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97555.c?ref=2118438f49f0c193abe3fa3def350a8129045746", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do run }\n+// { dg-options \"-Os\" }\n+\n+struct {\n+  int a:1;\n+} b;\n+\n+int c, d, e, f = 1, g;\n+\n+int main ()\n+{\n+  for (; d < 3; d++) {\n+    char h = 1 % f, i = ~(0 || ~0);\n+    c = h;\n+    f = ~b.a;\n+    ~b.a | 1 ^ ~i && g;\n+    if (~e)\n+      i = b.a;\n+    b.a = i;\n+  }\n+  return 0;\n+}"}, {"sha": "0e633c1c673ca333a5dcd8319dffe63d828cefed", "filename": "gcc/value-range.cc", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2118438f49f0c193abe3fa3def350a8129045746/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2118438f49f0c193abe3fa3def350a8129045746/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=2118438f49f0c193abe3fa3def350a8129045746", "patch": "@@ -1772,19 +1772,30 @@ irange::irange_intersect (const irange &r)\n     verify_range ();\n }\n \n+// Signed 1-bits are strange.  You can't subtract 1, because you can't\n+// represent the number 1.  This works around that for the invert routine.\n+\n static wide_int inline\n subtract_one (const wide_int &x, tree type, wi::overflow_type &overflow)\n {\n-  // A signed 1-bit bit-field, has a range of [-1,0] so subtracting +1\n-  // overflows, since +1 is unrepresentable.  This is why we have an\n-  // addition of -1 here.\n   if (TYPE_SIGN (type) == SIGNED)\n-    return wi::add (x, -1 , SIGNED, &overflow);\n+    return wi::add (x, -1, SIGNED, &overflow);\n   else\n     return wi::sub (x, 1, UNSIGNED, &overflow);\n }\n \n-/* Return the inverse of a range.  */\n+// The analogous function for adding 1.\n+\n+static wide_int inline\n+add_one (const wide_int &x, tree type, wi::overflow_type &overflow)\n+{\n+  if (TYPE_SIGN (type) == SIGNED)\n+    return wi::sub (x, -1, SIGNED, &overflow);\n+  else\n+    return wi::add (x, 1, UNSIGNED, &overflow);\n+}\n+\n+// Return the inverse of a range.\n \n void\n irange::invert ()\n@@ -1881,7 +1892,7 @@ irange::invert ()\n   // set the overflow bit.\n   if (type_max != wi::to_wide (orig_range.m_base[i]))\n     {\n-      tmp = wi::add (wi::to_wide (orig_range.m_base[i]), 1, sign, &ovf);\n+      tmp = add_one (wi::to_wide (orig_range.m_base[i]), ttype, ovf);\n       m_base[nitems++] = wide_int_to_tree (ttype, tmp);\n       m_base[nitems++] = wide_int_to_tree (ttype, type_max);\n       if (ovf)"}]}