{"sha": "49721058b7e6479d58affffaaaabc8781ab1b1a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk3MjEwNThiN2U2NDc5ZDU4YWZmZmZhYWFhYmM4NzgxYWIxYjFhNw==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2006-04-18T20:50:45Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2006-04-18T20:50:45Z"}, "message": "soft-fp: New directory.\n\n\t* config/soft-fp: New directory.  From glibc.\n\t* config/soft-fp/t-softfp: New.\n\t* config/soft-fp/README: New.\n\t* mklibgcc.in: Handle LIB2FUNCS_EXCLUDE.\n\t* Makefile.in (LIB2FUNCS_EXCLUDE, SFP_MACHINE): New.\n\t(libgcc.mk): Pass LIB2FUNCS_EXCLUDE.\n\t(LIBGCC_DEPS): Add $(SFP_MACHINE).\n\t* config.gcc: Use rs6000/t-fprules-fpbit or\n\trs6000/t-fprules-softfp and soft-fp/t-softfp together with\n\trs6000/t-fprules.\n\t* config/rs6000/sfp-machine.h: New.  Based on glibc.\n\t* config/rs6000/t-fprules-fpbit, config/rs6000/t-fprules-softfp:\n\tNew.\n\t* config/rs6000/t-fprules: Remove fp-bit rules.\n\t* config/rs6000/t-ppccomm (LIB2FUNCS_EXTRA): Use +=.\n\t* config/rs6000/t-linux64: Likewise.  Remove duplicates from\n\tLIB2FUNCS_EXTRA.  Remove fp-bit rules.\n\t(softfp_wrap_start, softfp_wrap_end): New.\n\nFrom-SVN: r113056", "tree": {"sha": "d5dadc6511455887ad655991208544aac9ceffd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5dadc6511455887ad655991208544aac9ceffd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49721058b7e6479d58affffaaaabc8781ab1b1a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49721058b7e6479d58affffaaaabc8781ab1b1a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49721058b7e6479d58affffaaaabc8781ab1b1a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49721058b7e6479d58affffaaaabc8781ab1b1a7/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e96ee360634d421ee8eb7293fcfe76dbcc0d7f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e96ee360634d421ee8eb7293fcfe76dbcc0d7f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e96ee360634d421ee8eb7293fcfe76dbcc0d7f5"}], "stats": {"total": 7470, "additions": 7411, "deletions": 59}, "files": [{"sha": "e6efdcd8939137b7ff6c72b42107fa84fd146a4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -1,3 +1,24 @@\n+2006-04-18  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* config/soft-fp: New directory.  From glibc.\n+\t* config/soft-fp/t-softfp: New.\n+\t* config/soft-fp/README: New.\n+\t* mklibgcc.in: Handle LIB2FUNCS_EXCLUDE.\n+\t* Makefile.in (LIB2FUNCS_EXCLUDE, SFP_MACHINE): New.\n+\t(libgcc.mk): Pass LIB2FUNCS_EXCLUDE.\n+\t(LIBGCC_DEPS): Add $(SFP_MACHINE).\n+\t* config.gcc: Use rs6000/t-fprules-fpbit or\n+\trs6000/t-fprules-softfp and soft-fp/t-softfp together with\n+\trs6000/t-fprules.\n+\t* config/rs6000/sfp-machine.h: New.  Based on glibc.\n+\t* config/rs6000/t-fprules-fpbit, config/rs6000/t-fprules-softfp:\n+\tNew.\n+\t* config/rs6000/t-fprules: Remove fp-bit rules.\n+\t* config/rs6000/t-ppccomm (LIB2FUNCS_EXTRA): Use +=.\n+\t* config/rs6000/t-linux64: Likewise.  Remove duplicates from\n+\tLIB2FUNCS_EXTRA.  Remove fp-bit rules.\n+\t(softfp_wrap_start, softfp_wrap_end): New.\n+\n 2006-04-18  DJ Delorie  <dj@redhat.com>\n \n \t* config/m32c/m32c.h (PTRDIFF_TYPE): Define."}, {"sha": "925ee6c1ddfd25913f98bbd902a3bbedf86141f6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -611,6 +611,12 @@ LIB2FUNCS_EXTRA =\n # Assembler files should have names ending in `.asm'.\n LIB2FUNCS_STATIC_EXTRA =\n \n+# List of functions not to build from libgcc2.c.\n+LIB2FUNCS_EXCLUDE =\n+\n+# Target sfp-machine.h file.\n+SFP_MACHINE =\n+\n # Program to convert libraries.\n LIBCONVERT =\n \n@@ -1398,6 +1404,7 @@ libgcc.mk: config.status Makefile mklibgcc $(LIB2ADD) $(LIB2ADD_ST) specs \\\n \tobjext='$(objext)' \\\n \tLIB1ASMFUNCS='$(LIB1ASMFUNCS)' \\\n \tLIB2FUNCS_ST='$(LIB2FUNCS_ST)' \\\n+\tLIB2FUNCS_EXCLUDE='$(LIB2FUNCS_EXCLUDE)' \\\n \tLIBGCOV='$(LIBGCOV)' \\\n \tLIB2ADD='$(LIB2ADD)' \\\n \tLIB2ADD_ST='$(LIB2ADD_ST)' \\\n@@ -1449,7 +1456,7 @@ LIBGCC_DEPS = $(GCC_PASSES) $(LANGUAGES) stmp-int-hdrs $(STMP_FIXPROTO) \\\n \tconfig/dfp-bit.h config/dfp-bit.c \\\n \t$(LIB2ADD_ST) $(LIB2ADDEH) $(LIB2ADDEHDEP) $(EXTRA_PARTS) \\\n \t$(srcdir)/config/$(LIB1ASMSRC) \\\n-\t$(srcdir)/gcov-io.h $(srcdir)/gcov-io.c gcov-iov.h\n+\t$(srcdir)/gcov-io.h $(srcdir)/gcov-io.c gcov-iov.h $(SFP_MACHINE)\n \n libgcov.a: libgcc.a; @true\n "}, {"sha": "dbc6debdd9f87c6aa441d21cba03c515f2aedd29", "filename": "gcc/config.gcc", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -1642,7 +1642,7 @@ pdp11-*-*)\n \t;;\n # port not yet contributed\n #powerpc-*-openbsd*)\n-#\ttmake_file=\"${tmake_file} rs6000/t-fprules \"\n+#\ttmake_file=\"${tmake_file} rs6000/t-fprules rs6000/t-fprules-fpbit \"\n #\textra_headers=\n #\t;;\n powerpc64-*-linux*)\n@@ -1654,16 +1654,16 @@ powerpc64-*-linux*)\n \t\ttm_file=\"rs6000/secureplt.h ${tm_file}\"\n \tfi\n \textra_options=\"${extra_options} rs6000/sysv4.opt rs6000/linux64.opt\"\n-\ttmake_file=\"t-dfprules rs6000/t-fprules ${tmake_file} rs6000/t-ppccomm rs6000/t-linux64\"\n+\ttmake_file=\"t-dfprules rs6000/t-fprules ${tmake_file} rs6000/t-ppccomm rs6000/t-linux64 rs6000/t-fprules-softfp soft-fp/t-softfp\"\n \t;;\n powerpc64-*-gnu*)\n \ttm_file=\"${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux64.h rs6000/gnu.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt rs6000/linux64.opt\"\n-\ttmake_file=\"rs6000/t-fprules t-slibgcc-elf-ver t-gnu rs6000/t-linux64\"\n+\ttmake_file=\"rs6000/t-fprules t-slibgcc-elf-ver t-gnu rs6000/t-linux64 rs6000/t-fprules-softfp soft-fp/t-softfp\"\n \t;;\n powerpc-*-beos*)\n \ttm_file=\"${tm_file} rs6000/aix.h rs6000/beos.h rs6000/xcoff.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-beos\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-beos\"\n \textra_headers=\n \tuse_fixproto=yes\n \t;;\n@@ -1685,7 +1685,7 @@ powerpc-*-darwin*)\n \t;;\n powerpc*-*-freebsd*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h ${fbsd_tm_file} rs6000/sysv4.h rs6000/freebsd.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \t;;\n powerpc-*-netbsd*)\n@@ -1695,7 +1695,7 @@ powerpc-*-netbsd*)\n \t;;\n powerpc-*-chorusos*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h chorus.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \tcase ${enable_threads} in\n \t  yes | posix)\n@@ -1712,48 +1712,48 @@ powerpc-*-eabispe*)\n powerpc-*-eabisimaltivec*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/eabisim.h rs6000/eabialtivec.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcendian rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcendian rs6000/t-ppccomm\"\n \t;;\n powerpc-*-eabisim*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/eabisim.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm\"\n \t;;\n powerpc-*-elf*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm\"\n \tuse_fixproto=yes\n \t;;\n powerpc-*-eabialtivec*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/eabialtivec.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcendian rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcendian rs6000/t-ppccomm\"\n \t;;\n powerpc-*-eabi*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm\"\n \t;;\n powerpc-*-rtems*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/rtems.h rtems.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-rtems t-rtems rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-rtems t-rtems rs6000/t-ppccomm\"\n \t;;\n powerpc-*-linux*altivec*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxaltivec.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-softfp soft-fp/t-softfp rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n \t;;\n powerpc-*-linux*spe*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxspe.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-softfp soft-fp/t-softfp rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n \t;;\n powerpc-*-linux*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"t-dfprules rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n+\ttmake_file=\"t-dfprules rs6000/t-fprules rs6000/t-fprules-softfp soft-fp/t-softfp rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n \tcase ${enable_targets}:${cpu_is_64bit} in\n \t    *powerpc64* | all:* | *:yes)\n \t\tif test x$cpu_is_64bit = xyes; then\n@@ -1774,14 +1774,14 @@ powerpc-*-linux*)\n powerpc-*-gnu-gnualtivec*)\n \ttm_file=\"${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxaltivec.h rs6000/gnu.h\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos t-slibgcc-elf-ver t-gnu rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos t-slibgcc-elf-ver t-gnu rs6000/t-ppccomm\"\n \tif test x$enable_threads = xyes; then\n \t\tthread_file='posix'\n \tfi\n \t;;\n powerpc-*-gnu*)\n \ttm_file=\"${cpu_type}/${cpu_type}.h elfos.h svr4.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/gnu.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos t-slibgcc-elf-ver t-gnu rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos t-slibgcc-elf-ver t-gnu rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \tif test x$enable_threads = xyes; then\n \t\tthread_file='posix'\n@@ -1791,7 +1791,7 @@ powerpc-wrs-vxworks|powerpc-wrs-vxworksae)\n \t# We want vxworks.h after rs6000/sysv4.h, which unfortunately\n \t# means we have to redo the tm_file list from scratch.\n \ttm_file=\"rs6000/rs6000.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h\"\n-\ttmake_file=\"${tmake_file} rs6000/t-fprules rs6000/t-ppccomm rs6000/t-vxworks\"\n+\ttmake_file=\"${tmake_file} rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppccomm rs6000/t-vxworks\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \textra_headers=ppc-asm.h\n \tcase ${target} in\n@@ -1806,7 +1806,7 @@ powerpc-wrs-vxworks|powerpc-wrs-vxworksae)\n \t;;\n powerpc-wrs-windiss*)  # Instruction-level simulator for VxWorks.\n \ttm_file=\"${tm_file} elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/windiss.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \tthread_file=\"\"\n \tuse_fixproto=yes\n@@ -1824,39 +1824,39 @@ powerpc-*-lynxos*)\n \t;;\n powerpcle-*-sysv*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \tuse_fixproto=yes\n \t;;\n powerpcle-*-elf*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \tuse_fixproto=yes\n \t;;\n powerpcle-*-eabisim*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h rs6000/eabi.h rs6000/eabisim.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \t;;\n powerpcle-*-eabi*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h rs6000/eabi.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \t;;\n powerpc-*-kaos*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h kaos.h rs6000/kaos-ppc.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \t;;\n powerpcle-*-kaos*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h kaos.h rs6000/kaos-ppc.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcgas rs6000/t-ppccomm\"\n \textra_options=\"${extra_options} rs6000/sysv4.opt\"\n \t;;\n rs6000-ibm-aix4.[12]* | powerpc-ibm-aix4.[12]*)\n \ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix41.h rs6000/xcoff.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-newas\"\n+\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-newas\"\n \textra_options=\"${extra_options} rs6000/aix41.opt\"\n \tuse_collect2=yes\n \textra_headers="}, {"sha": "29173e235dcccdfbcb445f2b86e502c0df751148", "filename": "gcc/config/rs6000/sfp-machine.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsfp-machine.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,63 @@\n+#define _FP_W_TYPE_SIZE\t\t32\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tlong\n+\n+#define _FP_MUL_MEAT_S(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_D(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_S(R,X,Y)\t_FP_DIV_MEAT_1_loop(S,R,X,Y)\n+#define _FP_DIV_MEAT_D(R,X,Y)\t_FP_DIV_MEAT_2_udiv(D,R,X,Y)\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t((_FP_QNANBIT_S << 1) - 1)\n+#define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1), -1\n+#define _FP_NANFRAC_Q\t\t((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1\n+#define _FP_NANSIGN_S\t\t0\n+#define _FP_NANSIGN_D\t\t0\n+#define _FP_NANSIGN_Q\t\t0\n+\n+#define _FP_KEEPNANFRACP 1\n+\n+/* Someone please check this.  */\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n+\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+#if defined __BIG_ENDIAN__ || defined _BIG_ENDIAN\n+# if defined __LITTLE_ENDIAN__ || defined _LITTLE_ENDIAN\n+#  error \"Both BIG_ENDIAN and LITTLE_ENDIAN defined!\"\n+# endif\n+# define __BYTE_ORDER __BIG_ENDIAN\n+#else\n+# if defined __LITTLE_ENDIAN__ || defined _LITTLE_ENDIAN\n+#  define __BYTE_ORDER __LITTLE_ENDIAN\n+# else\n+#  error \"Cannot determine current byte order\"\n+# endif\n+#endif\n+\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));"}, {"sha": "aa686c15b00d154ec4fac85d825717d53b556b0b", "filename": "gcc/config/rs6000/t-fprules", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Ft-fprules", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Ft-fprules", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-fprules?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -1,15 +1,3 @@\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n MULTILIB_MATCHES_FLOAT\t= msoft-float=mcpu?401 \\\n \t\t\t  msoft-float=mcpu?403 \\\n \t\t\t  msoft-float=mcpu?405 \\"}, {"sha": "a80c1cf4eec0c56c627b7417370084d9e250c839", "filename": "gcc/config/rs6000/t-fprules-fpbit", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Ft-fprules-fpbit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Ft-fprules-fpbit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-fprules-fpbit?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,11 @@\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c"}, {"sha": "10b271f036df8cd0052911eb2f0f4487cd7c33e6", "filename": "gcc/config/rs6000/t-fprules-softfp", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Ft-fprules-softfp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Ft-fprules-softfp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-fprules-softfp?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,6 @@\n+softfp_float_modes := sf df\n+softfp_int_modes := si di\n+softfp_extensions := sfdf\n+softfp_truncations := dfsf\n+softfp_machine_header := rs6000/sfp-machine.h\n+softfp_exclude_libgcc2 := y"}, {"sha": "a2c04f928e6c8de8e3918cba7e1f751e96a4529c", "filename": "gcc/config/rs6000/t-linux64", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Ft-linux64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Ft-linux64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-linux64?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -1,8 +1,9 @@\n \n #rs6000/t-linux64\n \n-LIB2FUNCS_EXTRA = tramp.S $(srcdir)/config/rs6000/ppc64-fp.c \\\n+LIB2FUNCS_EXTRA += tramp.S $(srcdir)/config/rs6000/ppc64-fp.c \\\n \t$(srcdir)/config/rs6000/darwin-ldouble.c\n+LIB2FUNCS_EXTRA := $(sort $(LIB2FUNCS_EXTRA))\n \n TARGET_LIBGCC2_CFLAGS += -mno-minimal-toc\n \n@@ -14,19 +15,5 @@ MULTILIB_EXCLUSIONS     = m64/!m32/msoft-float\n MULTILIB_OSDIRNAMES\t= ../lib64 ../lib nof\n MULTILIB_MATCHES        = $(MULTILIB_MATCHES_FLOAT)\n \n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-# fp-bit is only to be used by 32-bit multilibs\n-FPBIT = fp-bit32.c\n-DPBIT = dp-bit32.c\n-\n-dp-bit32.c: $(srcdir)/config/fp-bit.c\n-\t( echo '#ifndef __powerpc64__'; \\\n-\t  cat $(srcdir)/config/fp-bit.c; \\\n-\t  echo '#endif' ) > dp-bit32.c\n-\n-fp-bit32.c: $(srcdir)/config/fp-bit.c\n-\t( echo '#ifndef __powerpc64__'; \\\n-\t  echo '#define FLOAT'; \\\n-\t  cat $(srcdir)/config/fp-bit.c; \\\n-\t  echo '#endif' ) > fp-bit32.c\n+softfp_wrap_start := '\\#ifndef __powerpc64__'\n+softfp_wrap_end := '\\#endif'"}, {"sha": "1ca509cd59a2b0c4d823aa1fb5f8d4ec4776480b", "filename": "gcc/config/rs6000/t-ppccomm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Ft-ppccomm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Frs6000%2Ft-ppccomm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-ppccomm?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -1,6 +1,6 @@\n # Common support for PowerPC ELF targets (both EABI and SVR4).\n \n-LIB2FUNCS_EXTRA = tramp.S $(srcdir)/config/rs6000/darwin-ldouble.c\n+LIB2FUNCS_EXTRA += tramp.S $(srcdir)/config/rs6000/darwin-ldouble.c\n \n # This one can't end up in shared libgcc\n LIB2FUNCS_STATIC_EXTRA = eabi.S"}, {"sha": "870025cc53adf69d7b1bc67043c6d4672e8651af", "filename": "gcc/config/soft-fp/README", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2FREADME?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,4 @@\n+Except for t-softfp, the files in this directory are part of the GNU C\n+Library, not part of GCC.  As described at\n+<http://gcc.gnu.org/codingconventions.html>, changes should be made to\n+the GNU C Library and the changed files then imported into GCC."}, {"sha": "24c03db0a644ba121b7bab1aa1bf933422369729", "filename": "gcc/config/soft-fp/adddf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fadddf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fadddf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fadddf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a + b\n+   Copyright (C) 1997,1999, 2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+DFtype __adddf3(DFtype a, DFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A); FP_DECL_D(B); FP_DECL_D(R);\n+  DFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_D(A, a);\n+  FP_UNPACK_SEMIRAW_D(B, b);\n+  FP_ADD_D(R, A, B);\n+  FP_PACK_SEMIRAW_D(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "b86991ee56298577a3790699a3250d73fd3ebdb2", "filename": "gcc/config/soft-fp/addsf3.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Faddsf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Faddsf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Faddsf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,50 @@\n+/* Software floating-point emulation.\n+   Return a + b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+SFtype __addsf3(SFtype a, SFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A); FP_DECL_S(B); FP_DECL_S(R);\n+  SFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_S(A, a);\n+  FP_UNPACK_SEMIRAW_S(B, b);\n+  FP_ADD_S(R, A, B);\n+  FP_PACK_SEMIRAW_S(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+"}, {"sha": "49b67f0ba96fad4cb48e4d010b85a5b240a0902e", "filename": "gcc/config/soft-fp/addtf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Faddtf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Faddtf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Faddtf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a + b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+TFtype __addtf3(TFtype a, TFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(R);\n+  TFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_Q(A, a);\n+  FP_UNPACK_SEMIRAW_Q(B, b);\n+  FP_ADD_Q(R, A, B);\n+  FP_PACK_SEMIRAW_Q(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "c3bb0d247cb7620b3b65e520eb3d27d7169c10df", "filename": "gcc/config/soft-fp/divdf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fdivdf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fdivdf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fdivdf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a / b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+DFtype __divdf3(DFtype a, DFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A); FP_DECL_D(B); FP_DECL_D(R);\n+  DFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_D(A, a);\n+  FP_UNPACK_D(B, b);\n+  FP_DIV_D(R, A, B);\n+  FP_PACK_D(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "176bb3c2cb350bd0d746e8aa3c14db4a0334c755", "filename": "gcc/config/soft-fp/divsf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fdivsf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fdivsf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fdivsf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a / b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+SFtype __divsf3(SFtype a, SFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A); FP_DECL_S(B); FP_DECL_S(R);\n+  SFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_S(A, a);\n+  FP_UNPACK_S(B, b);\n+  FP_DIV_S(R, A, B);\n+  FP_PACK_S(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "916fbfe9748d24ed79ad18ae72dfe3ad6d5d1c78", "filename": "gcc/config/soft-fp/divtf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fdivtf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fdivtf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fdivtf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a / b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+TFtype __divtf3(TFtype a, TFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(R);\n+  TFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_Q(A, a);\n+  FP_UNPACK_Q(B, b);\n+  FP_DIV_Q(R, A, B);\n+  FP_PACK_Q(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "c8f4420af859b60fff396c3fa1cf6b1896106b93", "filename": "gcc/config/soft-fp/double.h", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fdouble.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fdouble.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fdouble.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,264 @@\n+/* Software floating-point emulation.\n+   Definitions for IEEE Double Precision\n+   Copyright (C) 1997,1998,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com),\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz),\n+\t\t  David S. Miller (davem@redhat.com) and\n+\t\t  Peter Maydell (pmaydell@chiark.greenend.org.uk).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#if _FP_W_TYPE_SIZE < 32\n+#error \"Here's a nickel kid.  Go buy yourself a real computer.\"\n+#endif\n+\n+#if _FP_W_TYPE_SIZE < 64\n+#define _FP_FRACTBITS_D\t\t(2 * _FP_W_TYPE_SIZE)\n+#else\n+#define _FP_FRACTBITS_D\t\t_FP_W_TYPE_SIZE\n+#endif\n+\n+#define _FP_FRACBITS_D\t\t53\n+#define _FP_FRACXBITS_D\t\t(_FP_FRACTBITS_D - _FP_FRACBITS_D)\n+#define _FP_WFRACBITS_D\t\t(_FP_WORKBITS + _FP_FRACBITS_D)\n+#define _FP_WFRACXBITS_D\t(_FP_FRACTBITS_D - _FP_WFRACBITS_D)\n+#define _FP_EXPBITS_D\t\t11\n+#define _FP_EXPBIAS_D\t\t1023\n+#define _FP_EXPMAX_D\t\t2047\n+\n+#define _FP_QNANBIT_D\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_D-2) % _FP_W_TYPE_SIZE)\n+#define _FP_QNANBIT_SH_D\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_D-2+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+#define _FP_IMPLBIT_D\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_D-1) % _FP_W_TYPE_SIZE)\n+#define _FP_IMPLBIT_SH_D\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_D-1+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+#define _FP_OVERFLOW_D\t\t\\\n+\t((_FP_W_TYPE)1 << _FP_WFRACBITS_D % _FP_W_TYPE_SIZE)\n+\n+typedef float DFtype __attribute__((mode(DF)));\n+\n+#if _FP_W_TYPE_SIZE < 64\n+\n+union _FP_UNION_D\n+{\n+  DFtype flt;\n+  struct {\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+    unsigned sign  : 1;\n+    unsigned exp   : _FP_EXPBITS_D;\n+    unsigned frac1 : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0) - _FP_W_TYPE_SIZE;\n+    unsigned frac0 : _FP_W_TYPE_SIZE;\n+#else\n+    unsigned frac0 : _FP_W_TYPE_SIZE;\n+    unsigned frac1 : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0) - _FP_W_TYPE_SIZE;\n+    unsigned exp   : _FP_EXPBITS_D;\n+    unsigned sign  : 1;\n+#endif\n+  } bits __attribute__((packed));\n+};\n+\n+#define FP_DECL_D(X)\t\t_FP_DECL(2,X)\n+#define FP_UNPACK_RAW_D(X,val)\t_FP_UNPACK_RAW_2(D,X,val)\n+#define FP_UNPACK_RAW_DP(X,val)\t_FP_UNPACK_RAW_2_P(D,X,val)\n+#define FP_PACK_RAW_D(val,X)\t_FP_PACK_RAW_2(D,val,X)\n+#define FP_PACK_RAW_DP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_2_P(D,val,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_D(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_2(D,X,val);\t\t\\\n+    _FP_UNPACK_CANONICAL(D,2,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_DP(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_2_P(D,X,val);\t\\\n+    _FP_UNPACK_CANONICAL(D,2,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_D(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_2(D,X,val);\t\t\\\n+    _FP_UNPACK_SEMIRAW(D,2,X);\t\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_DP(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_2_P(D,X,val);\t\\\n+    _FP_UNPACK_SEMIRAW(D,2,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_D(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(D,2,X);\t\t\\\n+    _FP_PACK_RAW_2(D,val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_DP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(D,2,X);\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_2_P(D,val,X);\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_D(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(D,2,X);\t\t\\\n+    _FP_PACK_RAW_2(D,val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_DP(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(D,2,X);\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_2_P(D,val,X);\t\\\n+  } while (0)\n+\n+#define FP_ISSIGNAN_D(X)\t\t_FP_ISSIGNAN(D,2,X)\n+#define FP_NEG_D(R,X)\t\t\t_FP_NEG(D,2,R,X)\n+#define FP_ADD_D(R,X,Y)\t\t\t_FP_ADD(D,2,R,X,Y)\n+#define FP_SUB_D(R,X,Y)\t\t\t_FP_SUB(D,2,R,X,Y)\n+#define FP_MUL_D(R,X,Y)\t\t\t_FP_MUL(D,2,R,X,Y)\n+#define FP_DIV_D(R,X,Y)\t\t\t_FP_DIV(D,2,R,X,Y)\n+#define FP_SQRT_D(R,X)\t\t\t_FP_SQRT(D,2,R,X)\n+#define _FP_SQRT_MEAT_D(R,S,T,X,Q)\t_FP_SQRT_MEAT_2(R,S,T,X,Q)\n+\n+#define FP_CMP_D(r,X,Y,un)\t_FP_CMP(D,2,r,X,Y,un)\n+#define FP_CMP_EQ_D(r,X,Y)\t_FP_CMP_EQ(D,2,r,X,Y)\n+#define FP_CMP_UNORD_D(r,X,Y)\t_FP_CMP_UNORD(D,2,r,X,Y)\n+\n+#define FP_TO_INT_D(r,X,rsz,rsg)\t_FP_TO_INT(D,2,r,X,rsz,rsg)\n+#define FP_FROM_INT_D(X,r,rs,rt)\t_FP_FROM_INT(D,2,X,r,rs,rt)\n+\n+#define _FP_FRAC_HIGH_D(X)\t_FP_FRAC_HIGH_2(X)\n+#define _FP_FRAC_HIGH_RAW_D(X)\t_FP_FRAC_HIGH_2(X)\n+\n+#else\n+\n+union _FP_UNION_D\n+{\n+  DFtype flt;\n+  struct {\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+    unsigned sign : 1;\n+    unsigned exp  : _FP_EXPBITS_D;\n+    unsigned long frac : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0);\n+#else\n+    unsigned long frac : _FP_FRACBITS_D - (_FP_IMPLBIT_D != 0);\n+    unsigned exp  : _FP_EXPBITS_D;\n+    unsigned sign : 1;\n+#endif\n+  } bits __attribute__((packed));\n+};\n+\n+#define FP_DECL_D(X)\t\t_FP_DECL(1,X)\n+#define FP_UNPACK_RAW_D(X,val)\t_FP_UNPACK_RAW_1(D,X,val)\n+#define FP_UNPACK_RAW_DP(X,val)\t_FP_UNPACK_RAW_1_P(D,X,val)\n+#define FP_PACK_RAW_D(val,X)\t_FP_PACK_RAW_1(D,val,X)\n+#define FP_PACK_RAW_DP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_1_P(D,val,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_D(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_1(D,X,val);\t\t\\\n+    _FP_UNPACK_CANONICAL(D,1,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_DP(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_1_P(D,X,val);\t\\\n+    _FP_UNPACK_CANONICAL(D,1,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_D(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_2(1,X,val);\t\t\\\n+    _FP_UNPACK_SEMIRAW(D,1,X);\t\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_DP(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_2_P(1,X,val);\t\\\n+    _FP_UNPACK_SEMIRAW(D,1,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_D(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(D,1,X);\t\t\\\n+    _FP_PACK_RAW_1(D,val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_DP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(D,1,X);\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_1_P(D,val,X);\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_D(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(D,1,X);\t\t\\\n+    _FP_PACK_RAW_1(D,val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_DP(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(D,1,X);\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_1_P(D,val,X);\t\\\n+  } while (0)\n+\n+#define FP_ISSIGNAN_D(X)\t\t_FP_ISSIGNAN(D,1,X)\n+#define FP_NEG_D(R,X)\t\t\t_FP_NEG(D,1,R,X)\n+#define FP_ADD_D(R,X,Y)\t\t\t_FP_ADD(D,1,R,X,Y)\n+#define FP_SUB_D(R,X,Y)\t\t\t_FP_SUB(D,1,R,X,Y)\n+#define FP_MUL_D(R,X,Y)\t\t\t_FP_MUL(D,1,R,X,Y)\n+#define FP_DIV_D(R,X,Y)\t\t\t_FP_DIV(D,1,R,X,Y)\n+#define FP_SQRT_D(R,X)\t\t\t_FP_SQRT(D,1,R,X)\n+#define _FP_SQRT_MEAT_D(R,S,T,X,Q)\t_FP_SQRT_MEAT_1(R,S,T,X,Q)\n+\n+/* The implementation of _FP_MUL_D and _FP_DIV_D should be chosen by\n+   the target machine.  */\n+\n+#define FP_CMP_D(r,X,Y,un)\t_FP_CMP(D,1,r,X,Y,un)\n+#define FP_CMP_EQ_D(r,X,Y)\t_FP_CMP_EQ(D,1,r,X,Y)\n+#define FP_CMP_UNORD_D(r,X,Y)\t_FP_CMP_UNORD(D,1,r,X,Y)\n+\n+#define FP_TO_INT_D(r,X,rsz,rsg)\t_FP_TO_INT(D,1,r,X,rsz,rsg)\n+#define FP_FROM_INT_D(X,r,rs,rt)\t_FP_FROM_INT(D,1,X,r,rs,rt)\n+\n+#define _FP_FRAC_HIGH_D(X)\t_FP_FRAC_HIGH_1(X)\n+#define _FP_FRAC_HIGH_RAW_D(X)\t_FP_FRAC_HIGH_1(X)\n+\n+#endif /* W_TYPE_SIZE < 64 */"}, {"sha": "efa769e986dd8217e38f404ea149daacc09ccbdd", "filename": "gcc/config/soft-fp/eqdf2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Feqdf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Feqdf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Feqdf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation.\n+   Return 0 iff a == b, 1 otherwise\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+int __eqdf2(DFtype a, DFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A); FP_DECL_D(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_D(A, a);\n+  FP_UNPACK_RAW_D(B, b);\n+  FP_CMP_EQ_D(r, A, B);\n+  if (r && (FP_ISSIGNAN_D(A) || FP_ISSIGNAN_D(B)))\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+\n+strong_alias(__eqdf2, __nedf2);"}, {"sha": "7e01c01d2f4a32d6df3ca169a76d5355f86e24b0", "filename": "gcc/config/soft-fp/eqsf2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Feqsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Feqsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Feqsf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation.\n+   Return 0 iff a == b, 1 otherwise\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+int __eqsf2(SFtype a, SFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A); FP_DECL_S(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_S(A, a);\n+  FP_UNPACK_RAW_S(B, b);\n+  FP_CMP_EQ_S(r, A, B);\n+  if (r && (FP_ISSIGNAN_S(A) || FP_ISSIGNAN_S(B)))\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+\n+strong_alias(__eqsf2, __nesf2);"}, {"sha": "fd6ffd1ebefd9c367baec16274253288adfafbdb", "filename": "gcc/config/soft-fp/eqtf2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Feqtf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Feqtf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Feqtf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation.\n+   Return 0 iff a == b, 1 otherwise\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+int __eqtf2(TFtype a, TFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A); FP_DECL_Q(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_Q(A, a);\n+  FP_UNPACK_RAW_Q(B, b);\n+  FP_CMP_EQ_Q(r, A, B);\n+  if (r && (FP_ISSIGNAN_Q(A) || FP_ISSIGNAN_Q(B)))\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+\n+strong_alias(__eqtf2, __netf2);"}, {"sha": "4101639a947bb715f2fb66cbe555cd78d4633624", "filename": "gcc/config/soft-fp/extenddftf2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fextenddftf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fextenddftf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fextenddftf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,54 @@\n+/* Software floating-point emulation.\n+   Return a converted to IEEE quad\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+#include \"quad.h\"\n+\n+TFtype __extenddftf2(DFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A);\n+  FP_DECL_Q(R);\n+  TFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_RAW_D(A, a);\n+#if (2 * _FP_W_TYPE_SIZE) < _FP_FRACBITS_Q\n+  FP_EXTEND(Q,D,4,2,R,A);\n+#else\n+  FP_EXTEND(Q,D,2,1,R,A);\n+#endif\n+  FP_PACK_RAW_Q(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "bbf39429e7f74fe4f2c12fb70b46508493838d9e", "filename": "gcc/config/soft-fp/extended.h", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fextended.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fextended.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fextended.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,453 @@\n+/* Software floating-point emulation.\n+   Definitions for IEEE Extended Precision.\n+   Copyright (C) 1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#if _FP_W_TYPE_SIZE < 32\n+#error \"Here's a nickel, kid. Go buy yourself a real computer.\"\n+#endif\n+\n+#if _FP_W_TYPE_SIZE < 64\n+#define _FP_FRACTBITS_E         (4*_FP_W_TYPE_SIZE)\n+#else\n+#define _FP_FRACTBITS_E\t\t(2*_FP_W_TYPE_SIZE)\n+#endif\n+\n+#define _FP_FRACBITS_E\t\t64\n+#define _FP_FRACXBITS_E\t\t(_FP_FRACTBITS_E - _FP_FRACBITS_E)\n+#define _FP_WFRACBITS_E\t\t(_FP_WORKBITS + _FP_FRACBITS_E)\n+#define _FP_WFRACXBITS_E\t(_FP_FRACTBITS_E - _FP_WFRACBITS_E)\n+#define _FP_EXPBITS_E\t\t15\n+#define _FP_EXPBIAS_E\t\t16383\n+#define _FP_EXPMAX_E\t\t32767\n+\n+#define _FP_QNANBIT_E\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_E-2) % _FP_W_TYPE_SIZE)\n+#define _FP_QNANBIT_SH_E\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_E-2+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+#define _FP_IMPLBIT_E\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_E-1) % _FP_W_TYPE_SIZE)\n+#define _FP_IMPLBIT_SH_E\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_E-1+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+#define _FP_OVERFLOW_E\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_WFRACBITS_E % _FP_W_TYPE_SIZE))\n+\n+typedef float XFtype __attribute__((mode(XF)));\n+\n+#if _FP_W_TYPE_SIZE < 64\n+\n+union _FP_UNION_E\n+{\n+   XFtype flt;\n+   struct \n+   {\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+      unsigned long pad1 : _FP_W_TYPE_SIZE;\n+      unsigned long pad2 : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);\n+      unsigned long sign : 1;\n+      unsigned long exp : _FP_EXPBITS_E;\n+      unsigned long frac1 : _FP_W_TYPE_SIZE;\n+      unsigned long frac0 : _FP_W_TYPE_SIZE;\n+#else\n+      unsigned long frac0 : _FP_W_TYPE_SIZE;\n+      unsigned long frac1 : _FP_W_TYPE_SIZE;\n+      unsigned exp : _FP_EXPBITS_E;\n+      unsigned sign : 1;\n+#endif /* not bigendian */\n+   } bits __attribute__((packed));\n+};\n+\n+\n+#define FP_DECL_E(X)\t\t_FP_DECL(4,X)\n+\n+#define FP_UNPACK_RAW_E(X, val)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    union _FP_UNION_E _flo; _flo.flt = (val);\t\t\\\n+\t\t\t\t\t\t\t\\\n+    X##_f[2] = 0; X##_f[3] = 0;\t\t\t\t\\\n+    X##_f[0] = _flo.bits.frac0;\t\t\t\t\\\n+    X##_f[1] = _flo.bits.frac1;\t\t\t\t\\\n+    X##_e  = _flo.bits.exp;\t\t\t\t\\\n+    X##_s  = _flo.bits.sign;\t\t\t\t\\\n+    if (!X##_e && (X##_f[1] || X##_f[0])\t\t\\\n+        && !(X##_f[1] & _FP_IMPLBIT_E))\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+        X##_e++;\t\t\t\t\t\\\n+        FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_RAW_EP(X, val)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    union _FP_UNION_E *_flo =\t\t\t\t\\\n+    (union _FP_UNION_E *)(val);\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    X##_f[2] = 0; X##_f[3] = 0;\t\t\t\t\\\n+    X##_f[0] = _flo->bits.frac0;\t\t\t\\\n+    X##_f[1] = _flo->bits.frac1;\t\t\t\\\n+    X##_e  = _flo->bits.exp;\t\t\t\t\\\n+    X##_s  = _flo->bits.sign;\t\t\t\t\\\n+    if (!X##_e && (X##_f[1] || X##_f[0])\t\t\\\n+        && !(X##_f[1] & _FP_IMPLBIT_E))\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+        X##_e++;\t\t\t\t\t\\\n+        FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_RAW_E(val, X)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    union _FP_UNION_E _flo;\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    if (X##_e) X##_f[1] |= _FP_IMPLBIT_E;\t\t\\\n+    else X##_f[1] &= ~(_FP_IMPLBIT_E);\t\t\t\\\n+    _flo.bits.frac0 = X##_f[0];\t\t\t\t\\\n+    _flo.bits.frac1 = X##_f[1];\t\t\t\t\\\n+    _flo.bits.exp   = X##_e;\t\t\t\t\\\n+    _flo.bits.sign  = X##_s;\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    (val) = _flo.flt;\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_RAW_EP(val, X)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tunion _FP_UNION_E *_flo =\t\t\t\\\n+\t  (union _FP_UNION_E *)(val);\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+\tif (X##_e) X##_f[1] |= _FP_IMPLBIT_E;\t\t\\\n+\telse X##_f[1] &= ~(_FP_IMPLBIT_E);\t\t\\\n+\t_flo->bits.frac0 = X##_f[0];\t\t\t\\\n+\t_flo->bits.frac1 = X##_f[1];\t\t\t\\\n+\t_flo->bits.exp   = X##_e;\t\t\t\\\n+\t_flo->bits.sign  = X##_s;\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_E(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    FP_UNPACK_RAW_E(X,val);\t\t\\\n+    _FP_UNPACK_CANONICAL(E,4,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_EP(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    FP_UNPACK_RAW_EP(X,val);\t\t\\\n+    _FP_UNPACK_CANONICAL(E,4,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_E(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_E(X,val);\t\t\\\n+    _FP_UNPACK_SEMIRAW(E,4,X);\t\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_EP(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_EP(X,val);\t\t\\\n+    _FP_UNPACK_SEMIRAW(E,4,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_E(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(E,4,X);\t\t\\\n+    FP_PACK_RAW_E(val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_EP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(E,4,X);\t\t\\\n+    FP_PACK_RAW_EP(val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_E(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(E,4,X);\t\t\\\n+    _FP_PACK_RAW_E(val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_EP(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(E,4,X);\t\t\\\n+    _FP_PACK_RAW_EP(val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_ISSIGNAN_E(X)\t_FP_ISSIGNAN(E,4,X)\n+#define FP_NEG_E(R,X)\t\t_FP_NEG(E,4,R,X)\n+#define FP_ADD_E(R,X,Y)\t\t_FP_ADD(E,4,R,X,Y)\n+#define FP_SUB_E(R,X,Y)\t\t_FP_SUB(E,4,R,X,Y)\n+#define FP_MUL_E(R,X,Y)\t\t_FP_MUL(E,4,R,X,Y)\n+#define FP_DIV_E(R,X,Y)\t\t_FP_DIV(E,4,R,X,Y)\n+#define FP_SQRT_E(R,X)\t\t_FP_SQRT(E,4,R,X)\n+\n+/*\n+ * Square root algorithms:\n+ * We have just one right now, maybe Newton approximation\n+ * should be added for those machines where division is fast.\n+ * This has special _E version because standard _4 square\n+ * root would not work (it has to start normally with the\n+ * second word and not the first), but as we have to do it\n+ * anyway, we optimize it by doing most of the calculations\n+ * in two UWtype registers instead of four.\n+ */\n+ \n+#define _FP_SQRT_MEAT_E(R, S, T, X, q)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\\\n+    _FP_FRAC_SRL_4(X, (_FP_WORKBITS));\t\t\t\\\n+    while (q)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tT##_f[1] = S##_f[1] + q;\t\t\t\\\n+\tif (T##_f[1] <= X##_f[1])\t\t\t\\\n+\t  {\t\t\t\t\t\t\\\n+\t    S##_f[1] = T##_f[1] + q;\t\t\t\\\n+\t    X##_f[1] -= T##_f[1];\t\t\t\\\n+\t    R##_f[1] += q;\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\\\n+\t_FP_FRAC_SLL_2(X, 1);\t\t\t\t\\\n+\tq >>= 1;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\\\n+    while (q)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tT##_f[0] = S##_f[0] + q;\t\t\t\\\n+\tT##_f[1] = S##_f[1];\t\t\t\t\\\n+\tif (T##_f[1] < X##_f[1] || \t\t\t\\\n+\t    (T##_f[1] == X##_f[1] &&\t\t\t\\\n+\t     T##_f[0] <= X##_f[0]))\t\t\t\\\n+\t  {\t\t\t\t\t\t\\\n+\t    S##_f[0] = T##_f[0] + q;\t\t\t\\\n+\t    S##_f[1] += (T##_f[0] > S##_f[0]);\t\t\\\n+\t    _FP_FRAC_DEC_2(X, T);\t\t\t\\\n+\t    R##_f[0] += q;\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\\\n+\t_FP_FRAC_SLL_2(X, 1);\t\t\t\t\\\n+\tq >>= 1;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    _FP_FRAC_SLL_4(R, (_FP_WORKBITS));\t\t\t\\\n+    if (X##_f[0] | X##_f[1])\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (S##_f[1] < X##_f[1] || \t\t\t\\\n+\t    (S##_f[1] == X##_f[1] &&\t\t\t\\\n+\t     S##_f[0] < X##_f[0]))\t\t\t\\\n+\t  R##_f[0] |= _FP_WORK_ROUND;\t\t\t\\\n+\tR##_f[0] |= _FP_WORK_STICKY;\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_CMP_E(r,X,Y,un)\t_FP_CMP(E,4,r,X,Y,un)\n+#define FP_CMP_EQ_E(r,X,Y)\t_FP_CMP_EQ(E,4,r,X,Y)\n+#define FP_CMP_UNORD_E(r,X,Y)\t_FP_CMP_UNORD(E,4,r,X,Y)\n+\n+#define FP_TO_INT_E(r,X,rsz,rsg)\t_FP_TO_INT(E,4,r,X,rsz,rsg)\n+#define FP_FROM_INT_E(X,r,rs,rt)\t_FP_FROM_INT(E,4,X,r,rs,rt)\n+\n+#define _FP_FRAC_HIGH_E(X)\t(X##_f[2])\n+#define _FP_FRAC_HIGH_RAW_E(X)\t(X##_f[1])\n+\n+#else   /* not _FP_W_TYPE_SIZE < 64 */\n+union _FP_UNION_E\n+{\n+  XFtype flt;\n+  struct {\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+    unsigned long pad : (_FP_W_TYPE_SIZE - 1 - _FP_EXPBITS_E);\n+    unsigned sign  : 1;\n+    unsigned exp   : _FP_EXPBITS_E;\n+    unsigned long frac : _FP_W_TYPE_SIZE;\n+#else\n+    unsigned long frac : _FP_W_TYPE_SIZE;\n+    unsigned exp   : _FP_EXPBITS_E;\n+    unsigned sign  : 1;\n+#endif\n+  } bits;\n+};\n+\n+#define FP_DECL_E(X)\t\t_FP_DECL(2,X)\n+\n+#define FP_UNPACK_RAW_E(X, val)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_E _flo; _flo.flt = (val);\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    X##_f0 = _flo.bits.frac;\t\t\t\t\t\\\n+    X##_f1 = 0;\t\t\t\t\t\t\t\\\n+    X##_e = _flo.bits.exp;\t\t\t\t\t\\\n+    X##_s = _flo.bits.sign;\t\t\t\t\t\\\n+    if (!X##_e && X##_f0 && !(X##_f0 & _FP_IMPLBIT_E))\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        X##_e++;\t\t\t\t\t\t\\\n+        FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_RAW_EP(X, val)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_E *_flo =\t\t\t\t\t\\\n+      (union _FP_UNION_E *)(val);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    X##_f0 = _flo->bits.frac;\t\t\t\t\t\\\n+    X##_f1 = 0;\t\t\t\t\t\t\t\\\n+    X##_e = _flo->bits.exp;\t\t\t\t\t\\\n+    X##_s = _flo->bits.sign;\t\t\t\t\t\\\n+    if (!X##_e && X##_f0 && !(X##_f0 & _FP_IMPLBIT_E))\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        X##_e++;\t\t\t\t\t\t\\\n+        FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_RAW_E(val, X)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_E _flo;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    if (X##_e) X##_f0 |= _FP_IMPLBIT_E;\t\t\t\t\\\n+    else X##_f0 &= ~(_FP_IMPLBIT_E);\t\t\t\t\\\n+    _flo.bits.frac = X##_f0;\t\t\t\t\t\\\n+    _flo.bits.exp  = X##_e;\t\t\t\t\t\\\n+    _flo.bits.sign = X##_s;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    (val) = _flo.flt;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_RAW_EP(fs, val, X)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tunion _FP_UNION_E *_flo =\t\t\t\t\\\n+\t  (union _FP_UNION_E *)(val);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\tif (X##_e) X##_f0 |= _FP_IMPLBIT_E;\t\t\t\\\n+\telse X##_f0 &= ~(_FP_IMPLBIT_E);\t\t\t\\\n+\t_flo->bits.frac = X##_f0;\t\t\t\t\\\n+\t_flo->bits.exp  = X##_e;\t\t\t\t\\\n+\t_flo->bits.sign = X##_s;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+#define FP_UNPACK_E(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    FP_UNPACK_RAW_E(X,val);\t\t\\\n+    _FP_UNPACK_CANONICAL(E,2,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_EP(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    FP_UNPACK_RAW_EP(X,val);\t\t\\\n+    _FP_UNPACK_CANONICAL(E,2,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_E(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_E(X,val);\t\t\\\n+    _FP_UNPACK_SEMIRAW(E,2,X);\t\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_EP(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_EP(X,val);\t\t\\\n+    _FP_UNPACK_SEMIRAW(E,2,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_E(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(E,2,X);\t\t\\\n+    FP_PACK_RAW_E(val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_EP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(E,2,X);\t\t\\\n+    FP_PACK_RAW_EP(val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_E(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(E,2,X);\t\t\\\n+    _FP_PACK_RAW_E(val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_EP(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(E,2,X);\t\t\\\n+    _FP_PACK_RAW_EP(val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_ISSIGNAN_E(X)\t_FP_ISSIGNAN(E,2,X)\n+#define FP_NEG_E(R,X)\t\t_FP_NEG(E,2,R,X)\n+#define FP_ADD_E(R,X,Y)\t\t_FP_ADD(E,2,R,X,Y)\n+#define FP_SUB_E(R,X,Y)\t\t_FP_SUB(E,2,R,X,Y)\n+#define FP_MUL_E(R,X,Y)\t\t_FP_MUL(E,2,R,X,Y)\n+#define FP_DIV_E(R,X,Y)\t\t_FP_DIV(E,2,R,X,Y)\n+#define FP_SQRT_E(R,X)\t\t_FP_SQRT(E,2,R,X)\n+\n+/*\n+ * Square root algorithms:\n+ * We have just one right now, maybe Newton approximation\n+ * should be added for those machines where division is fast.\n+ * We optimize it by doing most of the calculations\n+ * in one UWtype registers instead of two, although we don't\n+ * have to.\n+ */\n+#define _FP_SQRT_MEAT_E(R, S, T, X, q)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\\\n+    _FP_FRAC_SRL_2(X, (_FP_WORKBITS));\t\t\t\\\n+    while (q)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+        T##_f0 = S##_f0 + q;\t\t\t\t\\\n+        if (T##_f0 <= X##_f0)\t\t\t\t\\\n+          {\t\t\t\t\t\t\\\n+            S##_f0 = T##_f0 + q;\t\t\t\\\n+            X##_f0 -= T##_f0;\t\t\t\t\\\n+            R##_f0 += q;\t\t\t\t\\\n+          }\t\t\t\t\t\t\\\n+        _FP_FRAC_SLL_1(X, 1);\t\t\t\t\\\n+        q >>= 1;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    _FP_FRAC_SLL_2(R, (_FP_WORKBITS));\t\t\t\\\n+    if (X##_f0)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (S##_f0 < X##_f0)\t\t\t\t\\\n+\t  R##_f0 |= _FP_WORK_ROUND;\t\t\t\\\n+\tR##_f0 |= _FP_WORK_STICKY;\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while (0)\n+ \n+#define FP_CMP_E(r,X,Y,un)\t_FP_CMP(E,2,r,X,Y,un)\n+#define FP_CMP_EQ_E(r,X,Y)\t_FP_CMP_EQ(E,2,r,X,Y)\n+#define FP_CMP_UNORD_E(r,X,Y)\t_FP_CMP_UNORD(E,2,r,X,Y)\n+\n+#define FP_TO_INT_E(r,X,rsz,rsg)\t_FP_TO_INT(E,2,r,X,rsz,rsg)\n+#define FP_FROM_INT_E(X,r,rs,rt)\t_FP_FROM_INT(E,2,X,r,rs,rt)\n+\n+#define _FP_FRAC_HIGH_E(X)\t(X##_f1)\n+#define _FP_FRAC_HIGH_RAW_E(X)\t(X##_f0)\n+\n+#endif /* not _FP_W_TYPE_SIZE < 64 */"}, {"sha": "fba22d5a197d9ed2598d708c15366f1a92f808b0", "filename": "gcc/config/soft-fp/extendsfdf2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fextendsfdf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fextendsfdf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fextendsfdf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,54 @@\n+/* Software floating-point emulation.\n+   Return a converted to IEEE double\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+#include \"double.h\"\n+\n+DFtype __extendsfdf2(SFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A);\n+  FP_DECL_D(R);\n+  DFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_RAW_S(A, a);\n+#if _FP_W_TYPE_SIZE < _FP_FRACBITS_D\n+  FP_EXTEND(D,S,2,1,R,A);\n+#else\n+  FP_EXTEND(D,S,1,1,R,A);\n+#endif\n+  FP_PACK_RAW_D(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "c43cf1edee579938a0d9e0ac4a1cfebeeee36431", "filename": "gcc/config/soft-fp/extendsftf2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fextendsftf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fextendsftf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fextendsftf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,54 @@\n+/* Software floating-point emulation.\n+   Return a converted to IEEE quad\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+#include \"quad.h\"\n+\n+TFtype __extendsftf2(SFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A);\n+  FP_DECL_Q(R);\n+  TFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_RAW_S(A, a);\n+#if (2 * _FP_W_TYPE_SIZE) < _FP_FRACBITS_Q\n+  FP_EXTEND(Q,S,4,1,R,A);\n+#else\n+  FP_EXTEND(Q,S,2,1,R,A);\n+#endif\n+  FP_PACK_RAW_Q(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "fdfe35af519f078ea0a858550c6335f420c3f3ac", "filename": "gcc/config/soft-fp/fixdfdi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixdfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixdfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixdfdi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 64bit signed integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+DItype __fixdfdi(DFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A);\n+  UDItype r;\n+\n+  FP_UNPACK_RAW_D(A, a);\n+  FP_TO_INT_D(r, A, DI_BITS, 1);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "a05f3e39a5f6704583cf5d6f2c73fe3ba2d46ea6", "filename": "gcc/config/soft-fp/fixdfsi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixdfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixdfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixdfsi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 32bit signed integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+SItype __fixdfsi(DFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A);\n+  USItype r;\n+\n+  FP_UNPACK_RAW_D(A, a);\n+  FP_TO_INT_D(r, A, SI_BITS, 1);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "384d9bdd5362ce56d0bf4622002737c0922cca87", "filename": "gcc/config/soft-fp/fixsfdi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixsfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixsfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixsfdi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 64bit signed integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+DItype __fixsfdi(SFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A);\n+  UDItype r;\n+\n+  FP_UNPACK_RAW_S(A, a);\n+  FP_TO_INT_S(r, A, DI_BITS, 1);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "1d40ed05df75a007a01893793f846c77494e8d98", "filename": "gcc/config/soft-fp/fixsfsi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixsfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixsfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixsfsi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 32bit signed integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+SItype __fixsfsi(SFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A);\n+  USItype r;\n+\n+  FP_UNPACK_RAW_S(A, a);\n+  FP_TO_INT_S(r, A, SI_BITS, 1);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "ea10ce2dd3b9e489f9c49d9fc19b1e4780b77753", "filename": "gcc/config/soft-fp/fixtfdi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixtfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixtfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixtfdi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 64bit signed integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+DItype __fixtfdi(TFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A);\n+  UDItype r;\n+\n+  FP_UNPACK_RAW_Q(A, a);\n+  FP_TO_INT_Q(r, A, DI_BITS, 1);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "eb71038bc35a3d7c704a2b8abc1cbc8e902361cb", "filename": "gcc/config/soft-fp/fixtfsi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixtfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixtfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixtfsi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 32bit signed integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+SItype __fixtfsi(TFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A);\n+  USItype r;\n+\n+  FP_UNPACK_RAW_Q(A, a);\n+  FP_TO_INT_Q(r, A, SI_BITS, 1);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "d85198f18539eeef3341954d0871b5c6729c1a71", "filename": "gcc/config/soft-fp/fixunsdfdi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunsdfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunsdfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixunsdfdi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 64bit unsigned integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+UDItype __fixunsdfdi(DFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A);\n+  UDItype r;\n+\n+  FP_UNPACK_RAW_D(A, a);\n+  FP_TO_INT_D(r, A, DI_BITS, 0);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "492ffdea68077210863391bcd5a35901f5488c1e", "filename": "gcc/config/soft-fp/fixunsdfsi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunsdfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunsdfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixunsdfsi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 32bit unsigned integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+USItype __fixunsdfsi(DFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A);\n+  USItype r;\n+\n+  FP_UNPACK_RAW_D(A, a);\n+  FP_TO_INT_D(r, A, SI_BITS, 0);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "5484153837282fcd510215f7dc1dc0c61ce01b6c", "filename": "gcc/config/soft-fp/fixunssfdi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunssfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunssfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixunssfdi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 64bit unsigned integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+UDItype __fixunssfdi(SFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A);\n+  UDItype r;\n+\n+  FP_UNPACK_RAW_S(A, a);\n+  FP_TO_INT_S(r, A, DI_BITS, 0);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "ac9d4b9654f8bbdd68c91989ae9c7385fd6d1b34", "filename": "gcc/config/soft-fp/fixunssfsi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunssfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunssfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixunssfsi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 32bit unsigned integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+USItype __fixunssfsi(SFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A);\n+  USItype r;\n+\n+  FP_UNPACK_RAW_S(A, a);\n+  FP_TO_INT_S(r, A, SI_BITS, 0);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "86f1fc856295c410258d599f8017ce5e21abd960", "filename": "gcc/config/soft-fp/fixunstfdi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunstfdi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunstfdi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixunstfdi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 64bit unsigned integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+UDItype __fixunstfdi(TFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A);\n+  UDItype r;\n+\n+  FP_UNPACK_RAW_Q(A, a);\n+  FP_TO_INT_Q(r, A, DI_BITS, 0);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "e0335da47902d7db7f3f595c1482d5bf39a7e7cf", "filename": "gcc/config/soft-fp/fixunstfsi.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunstfsi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffixunstfsi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffixunstfsi.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a to 32bit unsigned integer\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+USItype __fixunstfsi(TFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A);\n+  USItype r;\n+\n+  FP_UNPACK_RAW_Q(A, a);\n+  FP_TO_INT_Q(r, A, SI_BITS, 0);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "21e9fb1899c25e9ad44fc89881c93701101a291d", "filename": "gcc/config/soft-fp/floatdidf.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatdidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatdidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatdidf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a 64bit signed integer to IEEE double\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+DFtype __floatdidf(DItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A);\n+  DFtype a;\n+\n+  FP_FROM_INT_D(A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_D(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "ee57915c3b847f8d0cfbdba399d66468c9f12d9b", "filename": "gcc/config/soft-fp/floatdisf.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatdisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatdisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatdisf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a 64bit signed integer to IEEE single\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+SFtype __floatdisf(DItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A);\n+  SFtype a;\n+\n+  FP_FROM_INT_S(A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_S(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "564800bc05ab4b98e7fc01474a5313382ddd3a06", "filename": "gcc/config/soft-fp/floatditf.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatditf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatditf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatditf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a 64bit signed integer to IEEE quad\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+TFtype __floatditf(DItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A);\n+  TFtype a;\n+\n+  FP_FROM_INT_Q(A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_Q(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "b6d5f8d1d2ad70f12df0b6e73fbe52703046e31b", "filename": "gcc/config/soft-fp/floatsidf.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatsidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatsidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatsidf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a 32bit signed integer to IEEE double\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+DFtype __floatsidf(SItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A);\n+  DFtype a;\n+\n+  FP_FROM_INT_D(A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_D(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "76217fe347871ad0215d20ff690aa74cbee840a6", "filename": "gcc/config/soft-fp/floatsisf.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatsisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatsisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatsisf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a 32bit signed integer to IEEE single\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+SFtype __floatsisf(SItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A);\n+  SFtype a;\n+\n+  FP_FROM_INT_S(A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_S(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "8c3d9cc619376beaf7669ed2cca06bf6405861c7", "filename": "gcc/config/soft-fp/floatsitf.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatsitf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatsitf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatsitf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Convert a 32bit signed integer to IEEE quad\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+TFtype __floatsitf(SItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A);\n+  TFtype a;\n+\n+  FP_FROM_INT_Q(A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_Q(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "2169a3f1988979885da1c62e1a53704512b4ee5a", "filename": "gcc/config/soft-fp/floatundidf.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatundidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatundidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatundidf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,47 @@\n+/* Software floating-point emulation.\n+   Convert a 64bit unsigned integer to IEEE double\n+   Copyright (C) 1997,1999, 2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+double\n+__floatundidf(UDItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A);\n+  DFtype a;\n+\n+  FP_FROM_INT_D(A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_D(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "5f08764dc50c7ca07372d85a855ca44ab7e8a33b", "filename": "gcc/config/soft-fp/floatundisf.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatundisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatundisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatundisf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,47 @@\n+/* Software floating-point emulation.\n+   Convert a 64bit unsigned integer to IEEE single\n+   Copyright (C) 1997,1999, 2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+float\n+__floatundisf(UDItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A);\n+  SFtype a;\n+\n+  FP_FROM_INT_S(A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_S(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "ab357f051c330d6343bc12f461aea701bd97942a", "filename": "gcc/config/soft-fp/floatunditf.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatunditf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatunditf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatunditf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,47 @@\n+/* Software floating-point emulation.\n+   Convert a 64bit unsigned integer to IEEE quad\n+   Copyright (C) 1997,1999, 2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+TFtype\n+__floatunditf(UDItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A);\n+  TFtype a;\n+\n+  FP_FROM_INT_Q(A, i, DI_BITS, UDItype);\n+  FP_PACK_RAW_Q(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "97b488ab68a3d47425c600b2c1c0e40ceb2bd86d", "filename": "gcc/config/soft-fp/floatunsidf.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatunsidf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatunsidf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatunsidf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,47 @@\n+/* Software floating-point emulation.\n+   Convert a 32bit unsigned integer to IEEE double\n+   Copyright (C) 1997,1999, 2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+double\n+__floatunsidf(USItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A);\n+  DFtype a;\n+\n+  FP_FROM_INT_D(A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_D(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "2ec16ba7b7f9376c36904e0f2d2775910f302332", "filename": "gcc/config/soft-fp/floatunsisf.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatunsisf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatunsisf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatunsisf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,47 @@\n+/* Software floating-point emulation.\n+   Convert a 32bit unsigned integer to IEEE single\n+   Copyright (C) 1997,1999, 2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+float\n+__floatunsisf(USItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A);\n+  SFtype a;\n+\n+  FP_FROM_INT_S(A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_S(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "c993716e54aadf861f349bb297bc7c2a09fbdb36", "filename": "gcc/config/soft-fp/floatunsitf.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatunsitf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ffloatunsitf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ffloatunsitf.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,47 @@\n+/* Software floating-point emulation.\n+   Convert a 32bit unsigned integer to IEEE quad\n+   Copyright (C) 1997,1999, 2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+TFtype\n+__floatunsitf(USItype i)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A);\n+  TFtype a;\n+\n+  FP_FROM_INT_Q(A, i, SI_BITS, USItype);\n+  FP_PACK_RAW_Q(a, A);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return a;\n+}"}, {"sha": "e0dc8620eeea2dc68db82af3bc6e4879cac9a711", "filename": "gcc/config/soft-fp/gedf2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fgedf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fgedf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fgedf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation.\n+   Return 0 iff a == b, 1 iff a > b, -2 iff a ? b, -1 iff a < b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+int __gedf2(DFtype a, DFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A); FP_DECL_D(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_D(A, a);\n+  FP_UNPACK_RAW_D(B, b);\n+  FP_CMP_D(r, A, B, -2);\n+  if (r == -2 && (FP_ISSIGNAN_D(A) || FP_ISSIGNAN_D(B)))\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+\n+strong_alias(__gedf2, __gtdf2);"}, {"sha": "d1f3ba2f9f5a18d9236f228552d4c87356371aff", "filename": "gcc/config/soft-fp/gesf2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fgesf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fgesf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fgesf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation.\n+   Return 0 iff a == b, 1 iff a > b, -2 iff a ? b, -1 iff a < b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+int __gesf2(SFtype a, SFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A); FP_DECL_S(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_S(A, a);\n+  FP_UNPACK_RAW_S(B, b);\n+  FP_CMP_S(r, A, B, -2);\n+  if (r == -2 && (FP_ISSIGNAN_S(A) || FP_ISSIGNAN_S(B)))\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+\n+strong_alias(__gesf2, __gtsf2);"}, {"sha": "82ff283d0d9bc4ba47a8786a9977ca874ced8ecd", "filename": "gcc/config/soft-fp/getf2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fgetf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fgetf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fgetf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation.\n+   Return 0 iff a == b, 1 iff a > b, -2 iff a ? b, -1 iff a < b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+int __getf2(TFtype a, TFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A); FP_DECL_Q(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_Q(A, a);\n+  FP_UNPACK_RAW_Q(B, b);\n+  FP_CMP_Q(r, A, B, -2);\n+  if (r == -2 && (FP_ISSIGNAN_Q(A) || FP_ISSIGNAN_Q(B)))\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+\n+strong_alias(__getf2, __gttf2);"}, {"sha": "528a9819cef833cbb57ea2f27d56ebe62e68765f", "filename": "gcc/config/soft-fp/ledf2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fledf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fledf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fledf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation.\n+   Return 0 iff a == b, 1 iff a > b, 2 iff a ? b, -1 iff a < b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+int __ledf2(DFtype a, DFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A); FP_DECL_D(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_D(A, a);\n+  FP_UNPACK_RAW_D(B, b);\n+  FP_CMP_D(r, A, B, 2);\n+  if (r == 2 && (FP_ISSIGNAN_D(A) || FP_ISSIGNAN_D(B)))\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+\n+strong_alias(__ledf2, __ltdf2);"}, {"sha": "c564bd9539e27197ad9c59561e3e2cf4c359cf78", "filename": "gcc/config/soft-fp/lesf2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Flesf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Flesf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Flesf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation.\n+   Return 0 iff a == b, 1 iff a > b, 2 iff a ? b, -1 iff a < b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+int __lesf2(SFtype a, SFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A); FP_DECL_S(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_S(A, a);\n+  FP_UNPACK_RAW_S(B, b);\n+  FP_CMP_S(r, A, B, 2);\n+  if (r == 2 && (FP_ISSIGNAN_S(A) || FP_ISSIGNAN_S(B)))\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+\n+strong_alias(__lesf2, __ltsf2);"}, {"sha": "35e03aaacfedf7cef94db74d10fa5e41e407bc91", "filename": "gcc/config/soft-fp/letf2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fletf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fletf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fletf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,51 @@\n+/* Software floating-point emulation.\n+   Return 0 iff a == b, 1 iff a > b, 2 iff a ? b, -1 iff a < b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+int __letf2(TFtype a, TFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A); FP_DECL_Q(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_Q(A, a);\n+  FP_UNPACK_RAW_Q(B, b);\n+  FP_CMP_Q(r, A, B, 2);\n+  if (r == 2 && (FP_ISSIGNAN_Q(A) || FP_ISSIGNAN_Q(B)))\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}\n+\n+strong_alias(__letf2, __lttf2);"}, {"sha": "7eb2015ae5697f091e335106f2d189742cf96aa6", "filename": "gcc/config/soft-fp/muldf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fmuldf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fmuldf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fmuldf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a * b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+DFtype __muldf3(DFtype a, DFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A); FP_DECL_D(B); FP_DECL_D(R);\n+  DFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_D(A, a);\n+  FP_UNPACK_D(B, b);\n+  FP_MUL_D(R, A, B);\n+  FP_PACK_D(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "5df4406872015bc1e894130f6038d1fb8022d4a5", "filename": "gcc/config/soft-fp/mulsf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fmulsf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fmulsf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fmulsf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a * b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+SFtype __mulsf3(SFtype a, SFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A); FP_DECL_S(B); FP_DECL_S(R);\n+  SFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_S(A, a);\n+  FP_UNPACK_S(B, b);\n+  FP_MUL_S(R, A, B);\n+  FP_PACK_S(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "0abab6ddc3b2e9959a3ec97e72868143b72d9768", "filename": "gcc/config/soft-fp/multf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fmultf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fmultf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fmultf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a * b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+TFtype __multf3(TFtype a, TFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(R);\n+  TFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_Q(A, a);\n+  FP_UNPACK_Q(B, b);\n+  FP_MUL_Q(R, A, B);\n+  FP_PACK_Q(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "54869e9a68d26e3471000936fd26b2ec7d75d04b", "filename": "gcc/config/soft-fp/negdf2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fnegdf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fnegdf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fnegdf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,48 @@\n+/* Software floating-point emulation.\n+   Return -a\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+DFtype __negdf2(DFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A); FP_DECL_D(R);\n+  DFtype r;\n+\n+  FP_UNPACK_D(A, a);\n+  FP_NEG_D(R, A);\n+  FP_PACK_D(r, R);\n+  FP_CLEAR_EXCEPTIONS;\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "bf5db7a452c6b5c1d21438ee1e0ebe01fb16d920", "filename": "gcc/config/soft-fp/negsf2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fnegsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fnegsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fnegsf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,48 @@\n+/* Software floating-point emulation.\n+   Return -a\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+SFtype __negsf2(SFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A); FP_DECL_S(R);\n+  SFtype r;\n+\n+  FP_UNPACK_S(A, a);\n+  FP_NEG_S(R, A);\n+  FP_PACK_S(r, R);\n+  FP_CLEAR_EXCEPTIONS;\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "5524c82df1ce1bf324e96e975fdb651a37b2c331", "filename": "gcc/config/soft-fp/negtf2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fnegtf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fnegtf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fnegtf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,48 @@\n+/* Software floating-point emulation.\n+   Return -a\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+TFtype __negtf2(TFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A); FP_DECL_Q(R);\n+  TFtype r;\n+\n+  FP_UNPACK_Q(A, a);\n+  FP_NEG_Q(R, A);\n+  FP_PACK_Q(r, R);\n+  FP_CLEAR_EXCEPTIONS;\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "35cd0ba7bb159b816600c79e4a4381d57f23157f", "filename": "gcc/config/soft-fp/op-1.h", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fop-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fop-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fop-1.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,302 @@\n+/* Software floating-point emulation.\n+   Basic one-word fraction declaration and manipulation.\n+   Copyright (C) 1997,1998,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com),\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz),\n+\t\t  David S. Miller (davem@redhat.com) and\n+\t\t  Peter Maydell (pmaydell@chiark.greenend.org.uk).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#define _FP_FRAC_DECL_1(X)\t_FP_W_TYPE X##_f\n+#define _FP_FRAC_COPY_1(D,S)\t(D##_f = S##_f)\n+#define _FP_FRAC_SET_1(X,I)\t(X##_f = I)\n+#define _FP_FRAC_HIGH_1(X)\t(X##_f)\n+#define _FP_FRAC_LOW_1(X)\t(X##_f)\n+#define _FP_FRAC_WORD_1(X,w)\t(X##_f)\n+\n+#define _FP_FRAC_ADDI_1(X,I)\t(X##_f += I)\n+#define _FP_FRAC_SLL_1(X,N)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (__builtin_constant_p(N) && (N) == 1)\t\\\n+      X##_f += X##_f;\t\t\t\t\\\n+    else\t\t\t\t\t\\\n+      X##_f <<= (N);\t\t\t\t\\\n+  } while (0)\n+#define _FP_FRAC_SRL_1(X,N)\t(X##_f >>= N)\n+\n+/* Right shift with sticky-lsb.  */\n+#define _FP_FRAC_SRST_1(X,S,N,sz)\t__FP_FRAC_SRST_1(X##_f, S, N, sz)\n+#define _FP_FRAC_SRS_1(X,N,sz)\t__FP_FRAC_SRS_1(X##_f, N, sz)\n+\n+#define __FP_FRAC_SRST_1(X,S,N,sz)\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+  S = (__builtin_constant_p(N) && (N) == 1\t\t\\\n+       ? X & 1 : (X << (_FP_W_TYPE_SIZE - (N))) != 0);\t\\\n+  X = X >> (N);\t\t\t\t\t\t\\\n+} while (0)\n+\n+#define __FP_FRAC_SRS_1(X,N,sz)\t\t\t\t\t\t\\\n+   (X = (X >> (N) | (__builtin_constant_p(N) && (N) == 1\t\t\\\n+\t\t     ? X & 1 : (X << (_FP_W_TYPE_SIZE - (N))) != 0)))\n+\n+#define _FP_FRAC_ADD_1(R,X,Y)\t(R##_f = X##_f + Y##_f)\n+#define _FP_FRAC_SUB_1(R,X,Y)\t(R##_f = X##_f - Y##_f)\n+#define _FP_FRAC_DEC_1(X,Y)\t(X##_f -= Y##_f)\n+#define _FP_FRAC_CLZ_1(z, X)\t__FP_CLZ(z, X##_f)\n+\n+/* Predicates */\n+#define _FP_FRAC_NEGP_1(X)\t((_FP_WS_TYPE)X##_f < 0)\n+#define _FP_FRAC_ZEROP_1(X)\t(X##_f == 0)\n+#define _FP_FRAC_OVERP_1(fs,X)\t(X##_f & _FP_OVERFLOW_##fs)\n+#define _FP_FRAC_CLEAR_OVERP_1(fs,X)\t(X##_f &= ~_FP_OVERFLOW_##fs)\n+#define _FP_FRAC_EQ_1(X, Y)\t(X##_f == Y##_f)\n+#define _FP_FRAC_GE_1(X, Y)\t(X##_f >= Y##_f)\n+#define _FP_FRAC_GT_1(X, Y)\t(X##_f > Y##_f)\n+\n+#define _FP_ZEROFRAC_1\t\t0\n+#define _FP_MINFRAC_1\t\t1\n+#define _FP_MAXFRAC_1\t\t(~(_FP_WS_TYPE)0)\n+\n+/*\n+ * Unpack the raw bits of a native fp value.  Do not classify or\n+ * normalize the data.\n+ */\n+\n+#define _FP_UNPACK_RAW_1(fs, X, val)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs _flo; _flo.flt = (val);\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    X##_f = _flo.bits.frac;\t\t\t\t\t\\\n+    X##_e = _flo.bits.exp;\t\t\t\t\t\\\n+    X##_s = _flo.bits.sign;\t\t\t\t\t\\\n+  } while (0)\n+\n+#define _FP_UNPACK_RAW_1_P(fs, X, val)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs *_flo =\t\t\t\t\\\n+      (union _FP_UNION_##fs *)(val);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    X##_f = _flo->bits.frac;\t\t\t\t\t\\\n+    X##_e = _flo->bits.exp;\t\t\t\t\t\\\n+    X##_s = _flo->bits.sign;\t\t\t\t\t\\\n+  } while (0)\n+\n+/*\n+ * Repack the raw bits of a native fp value.\n+ */\n+\n+#define _FP_PACK_RAW_1(fs, val, X)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs _flo;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    _flo.bits.frac = X##_f;\t\t\t\t\t\\\n+    _flo.bits.exp  = X##_e;\t\t\t\t\t\\\n+    _flo.bits.sign = X##_s;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    (val) = _flo.flt;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define _FP_PACK_RAW_1_P(fs, val, X)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs *_flo =\t\t\t\t\\\n+      (union _FP_UNION_##fs *)(val);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    _flo->bits.frac = X##_f;\t\t\t\t\t\\\n+    _flo->bits.exp  = X##_e;\t\t\t\t\t\\\n+    _flo->bits.sign = X##_s;\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/*\n+ * Multiplication algorithms:\n+ */\n+\n+/* Basic.  Assuming the host word size is >= 2*FRACBITS, we can do the\n+   multiplication immediately.  */\n+\n+#define _FP_MUL_MEAT_1_imm(wfracbits, R, X, Y)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    R##_f = X##_f * Y##_f;\t\t\t\t\t\t\\\n+    /* Normalize since we know where the msb of the multiplicands\t\\\n+       were (bit B), we know that the msb of the of the product is\t\\\n+       at either 2B or 2B-1.  */\t\t\t\t\t\\\n+    _FP_FRAC_SRS_1(R, wfracbits-1, 2*wfracbits);\t\t\t\\\n+  } while (0)\n+\n+/* Given a 1W * 1W => 2W primitive, do the extended multiplication.  */\n+\n+#define _FP_MUL_MEAT_1_wide(wfracbits, R, X, Y, doit)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _Z_f0, _Z_f1;\t\t\t\t\t\t\\\n+    doit(_Z_f1, _Z_f0, X##_f, Y##_f);\t\t\t\t\t\\\n+    /* Normalize since we know where the msb of the multiplicands\t\\\n+       were (bit B), we know that the msb of the of the product is\t\\\n+       at either 2B or 2B-1.  */\t\t\t\t\t\\\n+    _FP_FRAC_SRS_2(_Z, wfracbits-1, 2*wfracbits);\t\t\t\\\n+    R##_f = _Z_f0;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Finally, a simple widening multiply algorithm.  What fun!  */\n+\n+#define _FP_MUL_MEAT_1_hard(wfracbits, R, X, Y)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _xh, _xl, _yh, _yl, _z_f0, _z_f1, _a_f0, _a_f1;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* split the words in half */\t\t\t\t\t\\\n+    _xh = X##_f >> (_FP_W_TYPE_SIZE/2);\t\t\t\t\t\\\n+    _xl = X##_f & (((_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE/2)) - 1);\t\t\\\n+    _yh = Y##_f >> (_FP_W_TYPE_SIZE/2);\t\t\t\t\t\\\n+    _yl = Y##_f & (((_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE/2)) - 1);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* multiply the pieces */\t\t\t\t\t\t\\\n+    _z_f0 = _xl * _yl;\t\t\t\t\t\t\t\\\n+    _a_f0 = _xh * _yl;\t\t\t\t\t\t\t\\\n+    _a_f1 = _xl * _yh;\t\t\t\t\t\t\t\\\n+    _z_f1 = _xh * _yh;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* reassemble into two full words */\t\t\t\t\\\n+    if ((_a_f0 += _a_f1) < _a_f1)\t\t\t\t\t\\\n+      _z_f1 += (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE/2);\t\t\t\\\n+    _a_f1 = _a_f0 >> (_FP_W_TYPE_SIZE/2);\t\t\t\t\\\n+    _a_f0 = _a_f0 << (_FP_W_TYPE_SIZE/2);\t\t\t\t\\\n+    _FP_FRAC_ADD_2(_z, _z, _a);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* normalize */\t\t\t\t\t\t\t\\\n+    _FP_FRAC_SRS_2(_z, wfracbits - 1, 2*wfracbits);\t\t\t\\\n+    R##_f = _z_f0;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/*\n+ * Division algorithms:\n+ */\n+\n+/* Basic.  Assuming the host word size is >= 2*FRACBITS, we can do the\n+   division immediately.  Give this macro either _FP_DIV_HELP_imm for\n+   C primitives or _FP_DIV_HELP_ldiv for the ISO function.  Which you\n+   choose will depend on what the compiler does with divrem4.  */\n+\n+#define _FP_DIV_MEAT_1_imm(fs, R, X, Y, doit)\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _q, _r;\t\t\t\t\t\\\n+    X##_f <<= (X##_f < Y##_f\t\t\t\t\\\n+\t       ? R##_e--, _FP_WFRACBITS_##fs\t\t\\\n+\t       : _FP_WFRACBITS_##fs - 1);\t\t\\\n+    doit(_q, _r, X##_f, Y##_f);\t\t\t\t\\\n+    R##_f = _q | (_r != 0);\t\t\t\t\\\n+  } while (0)\n+\n+/* GCC's longlong.h defines a 2W / 1W => (1W,1W) primitive udiv_qrnnd\n+   that may be useful in this situation.  This first is for a primitive\n+   that requires normalization, the second for one that does not.  Look\n+   for UDIV_NEEDS_NORMALIZATION to tell which your machine needs.  */\n+\n+#define _FP_DIV_MEAT_1_udiv_norm(fs, R, X, Y)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _nh, _nl, _q, _r, _y;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* Normalize Y -- i.e. make the most significant bit set.  */\t\\\n+    _y = Y##_f << _FP_WFRACXBITS_##fs;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* Shift X op correspondingly high, that is, up one full word.  */\t\\\n+    if (X##_f < Y##_f)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tR##_e--;\t\t\t\t\t\t\t\\\n+\t_nl = 0;\t\t\t\t\t\t\t\\\n+\t_nh = X##_f;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t_nl = X##_f << (_FP_W_TYPE_SIZE - 1);\t\t\t\t\\\n+\t_nh = X##_f >> 1;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    \t\t\t\t\t\t\t\t\t\\\n+    udiv_qrnnd(_q, _r, _nh, _nl, _y);\t\t\t\t\t\\\n+    R##_f = _q | (_r != 0);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define _FP_DIV_MEAT_1_udiv(fs, R, X, Y)\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _nh, _nl, _q, _r;\t\t\t\\\n+    if (X##_f < Y##_f)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tR##_e--;\t\t\t\t\t\\\n+\t_nl = X##_f << _FP_WFRACBITS_##fs;\t\t\\\n+\t_nh = X##_f >> _FP_WFRACXBITS_##fs;\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\t_nl = X##_f << (_FP_WFRACBITS_##fs - 1);\t\\\n+\t_nh = X##_f >> (_FP_WFRACXBITS_##fs + 1);\t\\\n+      }\t\t\t\t\t\t\t\\\n+    udiv_qrnnd(_q, _r, _nh, _nl, Y##_f);\t\t\\\n+    R##_f = _q | (_r != 0);\t\t\t\t\\\n+  } while (0)\n+  \n+  \n+/*\n+ * Square root algorithms:\n+ * We have just one right now, maybe Newton approximation\n+ * should be added for those machines where division is fast.\n+ */\n+ \n+#define _FP_SQRT_MEAT_1(R, S, T, X, q)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    while (q != _FP_WORK_ROUND)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+        T##_f = S##_f + q;\t\t\t\t\\\n+        if (T##_f <= X##_f)\t\t\t\t\\\n+          {\t\t\t\t\t\t\\\n+            S##_f = T##_f + q;\t\t\t\t\\\n+            X##_f -= T##_f;\t\t\t\t\\\n+            R##_f += q;\t\t\t\t\t\\\n+          }\t\t\t\t\t\t\\\n+        _FP_FRAC_SLL_1(X, 1);\t\t\t\t\\\n+        q >>= 1;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    if (X##_f)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (S##_f < X##_f)\t\t\t\t\\\n+\t  R##_f |= _FP_WORK_ROUND;\t\t\t\\\n+\tR##_f |= _FP_WORK_STICKY;\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/*\n+ * Assembly/disassembly for converting to/from integral types.  \n+ * No shifting or overflow handled here.\n+ */\n+\n+#define _FP_FRAC_ASSEMBLE_1(r, X, rsize)\t(r = X##_f)\n+#define _FP_FRAC_DISASSEMBLE_1(X, r, rsize)\t(X##_f = r)\n+\n+\n+/*\n+ * Convert FP values between word sizes\n+ */\n+\n+#define _FP_FRAC_COPY_1_1(D, S)\t\t(D##_f = S##_f)"}, {"sha": "5c9bce4c1792ee760c8d1e4f1ef52b524563d8ee", "filename": "gcc/config/soft-fp/op-2.h", "status": "added", "additions": 615, "deletions": 0, "changes": 615, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fop-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fop-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fop-2.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,615 @@\n+/* Software floating-point emulation.\n+   Basic two-word fraction declaration and manipulation.\n+   Copyright (C) 1997,1998,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com),\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz),\n+\t\t  David S. Miller (davem@redhat.com) and\n+\t\t  Peter Maydell (pmaydell@chiark.greenend.org.uk).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#define _FP_FRAC_DECL_2(X)\t_FP_W_TYPE X##_f0, X##_f1\n+#define _FP_FRAC_COPY_2(D,S)\t(D##_f0 = S##_f0, D##_f1 = S##_f1)\n+#define _FP_FRAC_SET_2(X,I)\t__FP_FRAC_SET_2(X, I)\n+#define _FP_FRAC_HIGH_2(X)\t(X##_f1)\n+#define _FP_FRAC_LOW_2(X)\t(X##_f0)\n+#define _FP_FRAC_WORD_2(X,w)\t(X##_f##w)\n+\n+#define _FP_FRAC_SLL_2(X,N)\t\t\t\t\t\t    \\\n+(void)(((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\t    \\\n+       ? ({\t\t\t\t\t\t\t\t    \\\n+\t    if (__builtin_constant_p(N) && (N) == 1)\t\t\t    \\\n+\t      {\t\t\t\t\t\t\t\t    \\\n+\t\tX##_f1 = X##_f1 + X##_f1 + (((_FP_WS_TYPE)(X##_f0)) < 0);   \\\n+\t\tX##_f0 += X##_f0;\t\t\t\t\t    \\\n+\t      }\t\t\t\t\t\t\t\t    \\\n+\t    else\t\t\t\t\t\t\t    \\\n+\t      {\t\t\t\t\t\t\t\t    \\\n+\t\tX##_f1 = X##_f1 << (N) | X##_f0 >> (_FP_W_TYPE_SIZE - (N)); \\\n+\t\tX##_f0 <<= (N);\t\t\t\t\t\t    \\\n+\t      }\t\t\t\t\t\t\t\t    \\\n+\t    0;\t\t\t\t\t\t\t\t    \\\n+\t  })\t\t\t\t\t\t\t\t    \\\n+       : ({\t\t\t\t\t\t\t\t    \\\n+\t    X##_f1 = X##_f0 << ((N) - _FP_W_TYPE_SIZE);\t\t\t    \\\n+\t    X##_f0 = 0;\t\t\t\t\t\t\t    \\\n+\t  }))\n+\n+\n+#define _FP_FRAC_SRL_2(X,N)\t\t\t\t\t\t\\\n+(void)(((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\t\\\n+       ? ({\t\t\t\t\t\t\t\t\\\n+\t    X##_f0 = X##_f0 >> (N) | X##_f1 << (_FP_W_TYPE_SIZE - (N));\t\\\n+\t    X##_f1 >>= (N);\t\t\t\t\t\t\\\n+\t  })\t\t\t\t\t\t\t\t\\\n+       : ({\t\t\t\t\t\t\t\t\\\n+\t    X##_f0 = X##_f1 >> ((N) - _FP_W_TYPE_SIZE);\t\t\t\\\n+\t    X##_f1 = 0;\t\t\t\t\t\t\t\\\n+\t  }))\n+\n+/* Right shift with sticky-lsb.  */\n+#define _FP_FRAC_SRST_2(X,S, N,sz)\t\t\t\t\t  \\\n+(void)(((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\t  \\\n+       ? ({\t\t\t\t\t\t\t\t  \\\n+\t    S = (__builtin_constant_p(N) && (N) == 1\t\t\t  \\\n+\t\t ? X##_f0 & 1\t\t\t\t\t\t  \\\n+\t\t : (X##_f0 << (_FP_W_TYPE_SIZE - (N))) != 0);\t\t  \\\n+\t    X##_f0 = (X##_f1 << (_FP_W_TYPE_SIZE - (N)) | X##_f0 >> (N)); \\\n+\t    X##_f1 >>= (N);\t\t\t\t\t\t  \\\n+\t  })\t\t\t\t\t\t\t\t  \\\n+       : ({\t\t\t\t\t\t\t\t  \\\n+\t    S = ((((N) == _FP_W_TYPE_SIZE\t\t\t\t  \\\n+\t\t   ? 0\t\t\t\t\t\t\t  \\\n+\t\t   : (X##_f1 << (2*_FP_W_TYPE_SIZE - (N))))\t\t  \\\n+\t\t  | X##_f0) != 0);\t\t\t\t\t  \\\n+\t    X##_f0 = (X##_f1 >> ((N) - _FP_W_TYPE_SIZE));\t\t  \\\n+\t    X##_f1 = 0;\t\t\t\t\t\t\t  \\\n+\t  }))\n+\n+#define _FP_FRAC_SRS_2(X,N,sz)\t\t\t\t\t\t  \\\n+(void)(((N) < _FP_W_TYPE_SIZE)\t\t\t\t\t\t  \\\n+       ? ({\t\t\t\t\t\t\t\t  \\\n+\t    X##_f0 = (X##_f1 << (_FP_W_TYPE_SIZE - (N)) | X##_f0 >> (N) | \\\n+\t\t      (__builtin_constant_p(N) && (N) == 1\t\t  \\\n+\t\t       ? X##_f0 & 1\t\t\t\t\t  \\\n+\t\t       : (X##_f0 << (_FP_W_TYPE_SIZE - (N))) != 0));\t  \\\n+\t    X##_f1 >>= (N);\t\t\t\t\t\t  \\\n+\t  })\t\t\t\t\t\t\t\t  \\\n+       : ({\t\t\t\t\t\t\t\t  \\\n+\t    X##_f0 = (X##_f1 >> ((N) - _FP_W_TYPE_SIZE) |\t\t  \\\n+\t\t      ((((N) == _FP_W_TYPE_SIZE\t\t\t\t  \\\n+\t\t\t ? 0\t\t\t\t\t\t  \\\n+\t\t\t : (X##_f1 << (2*_FP_W_TYPE_SIZE - (N))))\t  \\\n+\t\t\t| X##_f0) != 0));\t\t\t\t  \\\n+\t    X##_f1 = 0;\t\t\t\t\t\t\t  \\\n+\t  }))\n+\n+#define _FP_FRAC_ADDI_2(X,I)\t\\\n+  __FP_FRAC_ADDI_2(X##_f1, X##_f0, I)\n+\n+#define _FP_FRAC_ADD_2(R,X,Y)\t\\\n+  __FP_FRAC_ADD_2(R##_f1, R##_f0, X##_f1, X##_f0, Y##_f1, Y##_f0)\n+\n+#define _FP_FRAC_SUB_2(R,X,Y)\t\\\n+  __FP_FRAC_SUB_2(R##_f1, R##_f0, X##_f1, X##_f0, Y##_f1, Y##_f0)\n+\n+#define _FP_FRAC_DEC_2(X,Y)\t\\\n+  __FP_FRAC_DEC_2(X##_f1, X##_f0, Y##_f1, Y##_f0)\n+\n+#define _FP_FRAC_CLZ_2(R,X)\t\\\n+  do {\t\t\t\t\\\n+    if (X##_f1)\t\t\t\\\n+      __FP_CLZ(R,X##_f1);\t\\\n+    else \t\t\t\\\n+    {\t\t\t\t\\\n+      __FP_CLZ(R,X##_f0);\t\\\n+      R += _FP_W_TYPE_SIZE;\t\\\n+    }\t\t\t\t\\\n+  } while(0)\n+\n+/* Predicates */\n+#define _FP_FRAC_NEGP_2(X)\t((_FP_WS_TYPE)X##_f1 < 0)\n+#define _FP_FRAC_ZEROP_2(X)\t((X##_f1 | X##_f0) == 0)\n+#define _FP_FRAC_OVERP_2(fs,X)\t(_FP_FRAC_HIGH_##fs(X) & _FP_OVERFLOW_##fs)\n+#define _FP_FRAC_CLEAR_OVERP_2(fs,X)\t(_FP_FRAC_HIGH_##fs(X) &= ~_FP_OVERFLOW_##fs)\n+#define _FP_FRAC_EQ_2(X, Y)\t(X##_f1 == Y##_f1 && X##_f0 == Y##_f0)\n+#define _FP_FRAC_GT_2(X, Y)\t\\\n+  (X##_f1 > Y##_f1 || (X##_f1 == Y##_f1 && X##_f0 > Y##_f0))\n+#define _FP_FRAC_GE_2(X, Y)\t\\\n+  (X##_f1 > Y##_f1 || (X##_f1 == Y##_f1 && X##_f0 >= Y##_f0))\n+\n+#define _FP_ZEROFRAC_2\t\t0, 0\n+#define _FP_MINFRAC_2\t\t0, 1\n+#define _FP_MAXFRAC_2\t\t(~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0)\n+\n+/*\n+ * Internals \n+ */\n+\n+#define __FP_FRAC_SET_2(X,I1,I0)\t(X##_f0 = I0, X##_f1 = I1)\n+\n+#define __FP_CLZ_2(R, xh, xl)\t\\\n+  do {\t\t\t\t\\\n+    if (xh)\t\t\t\\\n+      __FP_CLZ(R,xh);\t\t\\\n+    else \t\t\t\\\n+    {\t\t\t\t\\\n+      __FP_CLZ(R,xl);\t\t\\\n+      R += _FP_W_TYPE_SIZE;\t\\\n+    }\t\t\t\t\\\n+  } while(0)\n+\n+#if 0\n+\n+#ifndef __FP_FRAC_ADDI_2\n+#define __FP_FRAC_ADDI_2(xh, xl, i)\t\\\n+  (xh += ((xl += i) < i))\n+#endif\n+#ifndef __FP_FRAC_ADD_2\n+#define __FP_FRAC_ADD_2(rh, rl, xh, xl, yh, yl)\t\\\n+  (rh = xh + yh + ((rl = xl + yl) < xl))\n+#endif\n+#ifndef __FP_FRAC_SUB_2\n+#define __FP_FRAC_SUB_2(rh, rl, xh, xl, yh, yl)\t\\\n+  (rh = xh - yh - ((rl = xl - yl) > xl))\n+#endif\n+#ifndef __FP_FRAC_DEC_2\n+#define __FP_FRAC_DEC_2(xh, xl, yh, yl)\t\\\n+  do {\t\t\t\t\t\\\n+    UWtype _t = xl;\t\t\t\\\n+    xh -= yh + ((xl -= yl) > _t);\t\\\n+  } while (0)\n+#endif\n+\n+#else\n+\n+#undef __FP_FRAC_ADDI_2\n+#define __FP_FRAC_ADDI_2(xh, xl, i)\tadd_ssaaaa(xh, xl, xh, xl, 0, i)\n+#undef __FP_FRAC_ADD_2\n+#define __FP_FRAC_ADD_2\t\t\tadd_ssaaaa\n+#undef __FP_FRAC_SUB_2\n+#define __FP_FRAC_SUB_2\t\t\tsub_ddmmss\n+#undef __FP_FRAC_DEC_2\n+#define __FP_FRAC_DEC_2(xh, xl, yh, yl)\tsub_ddmmss(xh, xl, xh, xl, yh, yl)\n+\n+#endif\n+\n+/*\n+ * Unpack the raw bits of a native fp value.  Do not classify or\n+ * normalize the data.\n+ */\n+\n+#define _FP_UNPACK_RAW_2(fs, X, val)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs _flo; _flo.flt = (val);\t\\\n+\t\t\t\t\t\t\t\\\n+    X##_f0 = _flo.bits.frac0;\t\t\t\t\\\n+    X##_f1 = _flo.bits.frac1;\t\t\t\t\\\n+    X##_e  = _flo.bits.exp;\t\t\t\t\\\n+    X##_s  = _flo.bits.sign;\t\t\t\t\\\n+  } while (0)\n+\n+#define _FP_UNPACK_RAW_2_P(fs, X, val)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs *_flo =\t\t\t\\\n+      (union _FP_UNION_##fs *)(val);\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    X##_f0 = _flo->bits.frac0;\t\t\t\t\\\n+    X##_f1 = _flo->bits.frac1;\t\t\t\t\\\n+    X##_e  = _flo->bits.exp;\t\t\t\t\\\n+    X##_s  = _flo->bits.sign;\t\t\t\t\\\n+  } while (0)\n+\n+\n+/*\n+ * Repack the raw bits of a native fp value.\n+ */\n+\n+#define _FP_PACK_RAW_2(fs, val, X)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs _flo;\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    _flo.bits.frac0 = X##_f0;\t\t\t\t\\\n+    _flo.bits.frac1 = X##_f1;\t\t\t\t\\\n+    _flo.bits.exp   = X##_e;\t\t\t\t\\\n+    _flo.bits.sign  = X##_s;\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    (val) = _flo.flt;\t\t\t\t\t\\\n+  } while (0)\n+\n+#define _FP_PACK_RAW_2_P(fs, val, X)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs *_flo =\t\t\t\\\n+      (union _FP_UNION_##fs *)(val);\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    _flo->bits.frac0 = X##_f0;\t\t\t\t\\\n+    _flo->bits.frac1 = X##_f1;\t\t\t\t\\\n+    _flo->bits.exp   = X##_e;\t\t\t\t\\\n+    _flo->bits.sign  = X##_s;\t\t\t\t\\\n+  } while (0)\n+\n+\n+/*\n+ * Multiplication algorithms:\n+ */\n+\n+/* Given a 1W * 1W => 2W primitive, do the extended multiplication.  */\n+\n+#define _FP_MUL_MEAT_2_wide(wfracbits, R, X, Y, doit)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_FRAC_DECL_4(_z); _FP_FRAC_DECL_2(_b); _FP_FRAC_DECL_2(_c);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    doit(_FP_FRAC_WORD_4(_z,1), _FP_FRAC_WORD_4(_z,0), X##_f0, Y##_f0);\t\\\n+    doit(_b_f1, _b_f0, X##_f0, Y##_f1);\t\t\t\t\t\\\n+    doit(_c_f1, _c_f0, X##_f1, Y##_f0);\t\t\t\t\t\\\n+    doit(_FP_FRAC_WORD_4(_z,3), _FP_FRAC_WORD_4(_z,2), X##_f1, Y##_f1);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n+\t\t    _FP_FRAC_WORD_4(_z,1), 0, _b_f1, _b_f0,\t\t\\\n+\t\t    _FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n+\t\t    _FP_FRAC_WORD_4(_z,1));\t\t\t\t\\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n+\t\t    _FP_FRAC_WORD_4(_z,1), 0, _c_f1, _c_f0,\t\t\\\n+\t\t    _FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n+\t\t    _FP_FRAC_WORD_4(_z,1));\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* Normalize since we know where the msb of the multiplicands\t\\\n+       were (bit B), we know that the msb of the of the product is\t\\\n+       at either 2B or 2B-1.  */\t\t\t\t\t\\\n+    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n+    R##_f0 = _FP_FRAC_WORD_4(_z,0);\t\t\t\t\t\\\n+    R##_f1 = _FP_FRAC_WORD_4(_z,1);\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Given a 1W * 1W => 2W primitive, do the extended multiplication.\n+   Do only 3 multiplications instead of four. This one is for machines\n+   where multiplication is much more expensive than subtraction.  */\n+\n+#define _FP_MUL_MEAT_2_wide_3mul(wfracbits, R, X, Y, doit)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_FRAC_DECL_4(_z); _FP_FRAC_DECL_2(_b); _FP_FRAC_DECL_2(_c);\t\\\n+    _FP_W_TYPE _d;\t\t\t\t\t\t\t\\\n+    int _c1, _c2;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    _b_f0 = X##_f0 + X##_f1;\t\t\t\t\t\t\\\n+    _c1 = _b_f0 < X##_f0;\t\t\t\t\t\t\\\n+    _b_f1 = Y##_f0 + Y##_f1;\t\t\t\t\t\t\\\n+    _c2 = _b_f1 < Y##_f0;\t\t\t\t\t\t\\\n+    doit(_d, _FP_FRAC_WORD_4(_z,0), X##_f0, Y##_f0);\t\t\t\\\n+    doit(_FP_FRAC_WORD_4(_z,2), _FP_FRAC_WORD_4(_z,1), _b_f0, _b_f1);\t\\\n+    doit(_c_f1, _c_f0, X##_f1, Y##_f1);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    _b_f0 &= -_c2;\t\t\t\t\t\t\t\\\n+    _b_f1 &= -_c1;\t\t\t\t\t\t\t\\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n+\t\t    _FP_FRAC_WORD_4(_z,1), (_c1 & _c2), 0, _d,\t\t\\\n+\t\t    0, _FP_FRAC_WORD_4(_z,2), _FP_FRAC_WORD_4(_z,1));\t\\\n+    __FP_FRAC_ADDI_2(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n+\t\t     _b_f0);\t\t\t\t\t\t\\\n+    __FP_FRAC_ADDI_2(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n+\t\t     _b_f1);\t\t\t\t\t\t\\\n+    __FP_FRAC_DEC_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n+\t\t    _FP_FRAC_WORD_4(_z,1),\t\t\t\t\\\n+\t\t    0, _d, _FP_FRAC_WORD_4(_z,0));\t\t\t\\\n+    __FP_FRAC_DEC_3(_FP_FRAC_WORD_4(_z,3),_FP_FRAC_WORD_4(_z,2),\t\\\n+\t\t    _FP_FRAC_WORD_4(_z,1), 0, _c_f1, _c_f0);\t\t\\\n+    __FP_FRAC_ADD_2(_FP_FRAC_WORD_4(_z,3), _FP_FRAC_WORD_4(_z,2),\t\\\n+\t\t    _c_f1, _c_f0,\t\t\t\t\t\\\n+\t\t    _FP_FRAC_WORD_4(_z,3), _FP_FRAC_WORD_4(_z,2));\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* Normalize since we know where the msb of the multiplicands\t\\\n+       were (bit B), we know that the msb of the of the product is\t\\\n+       at either 2B or 2B-1.  */\t\t\t\t\t\\\n+    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n+    R##_f0 = _FP_FRAC_WORD_4(_z,0);\t\t\t\t\t\\\n+    R##_f1 = _FP_FRAC_WORD_4(_z,1);\t\t\t\t\t\\\n+  } while (0)\n+\n+#define _FP_MUL_MEAT_2_gmp(wfracbits, R, X, Y)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_FRAC_DECL_4(_z);\t\t\t\t\t\t\\\n+    _FP_W_TYPE _x[2], _y[2];\t\t\t\t\t\t\\\n+    _x[0] = X##_f0; _x[1] = X##_f1;\t\t\t\t\t\\\n+    _y[0] = Y##_f0; _y[1] = Y##_f1;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    mpn_mul_n(_z_f, _x, _y, 2);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* Normalize since we know where the msb of the multiplicands\t\\\n+       were (bit B), we know that the msb of the of the product is\t\\\n+       at either 2B or 2B-1.  */\t\t\t\t\t\\\n+    _FP_FRAC_SRS_4(_z, wfracbits-1, 2*wfracbits);\t\t\t\\\n+    R##_f0 = _z_f[0];\t\t\t\t\t\t\t\\\n+    R##_f1 = _z_f[1];\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Do at most 120x120=240 bits multiplication using double floating\n+   point multiplication.  This is useful if floating point\n+   multiplication has much bigger throughput than integer multiply.\n+   It is supposed to work for _FP_W_TYPE_SIZE 64 and wfracbits\n+   between 106 and 120 only.  \n+   Caller guarantees that X and Y has (1LLL << (wfracbits - 1)) set.\n+   SETFETZ is a macro which will disable all FPU exceptions and set rounding\n+   towards zero,  RESETFE should optionally reset it back.  */\n+\n+#define _FP_MUL_MEAT_2_120_240_double(wfracbits, R, X, Y, setfetz, resetfe)\t\\\n+  do {\t\t\t\t\t\t\t\t\t\t\\\n+    static const double _const[] = {\t\t\t\t\t\t\\\n+      /* 2^-24 */ 5.9604644775390625e-08,\t\t\t\t\t\\\n+      /* 2^-48 */ 3.5527136788005009e-15,\t\t\t\t\t\\\n+      /* 2^-72 */ 2.1175823681357508e-22,\t\t\t\t\t\\\n+      /* 2^-96 */ 1.2621774483536189e-29,\t\t\t\t\t\\\n+      /* 2^28 */ 2.68435456e+08,\t\t\t\t\t\t\\\n+      /* 2^4 */ 1.600000e+01,\t\t\t\t\t\t\t\\\n+      /* 2^-20 */ 9.5367431640625e-07,\t\t\t\t\t\t\\\n+      /* 2^-44 */ 5.6843418860808015e-14,\t\t\t\t\t\\\n+      /* 2^-68 */ 3.3881317890172014e-21,\t\t\t\t\t\\\n+      /* 2^-92 */ 2.0194839173657902e-28,\t\t\t\t\t\\\n+      /* 2^-116 */ 1.2037062152420224e-35};\t\t\t\t\t\\\n+    double _a240, _b240, _c240, _d240, _e240, _f240, \t\t\t\t\\\n+\t   _g240, _h240, _i240, _j240, _k240;\t\t\t\t\t\\\n+    union { double d; UDItype i; } _l240, _m240, _n240, _o240,\t\t\t\\\n+\t\t\t\t   _p240, _q240, _r240, _s240;\t\t\t\\\n+    UDItype _t240, _u240, _v240, _w240, _x240, _y240 = 0;\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\t\\\n+    if (wfracbits < 106 || wfracbits > 120)\t\t\t\t\t\\\n+      abort();\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\t\\\n+    setfetz;\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\t\\\n+    _e240 = (double)(long)(X##_f0 & 0xffffff);\t\t\t\t\t\\\n+    _j240 = (double)(long)(Y##_f0 & 0xffffff);\t\t\t\t\t\\\n+    _d240 = (double)(long)((X##_f0 >> 24) & 0xffffff);\t\t\t\t\\\n+    _i240 = (double)(long)((Y##_f0 >> 24) & 0xffffff);\t\t\t\t\\\n+    _c240 = (double)(long)(((X##_f1 << 16) & 0xffffff) | (X##_f0 >> 48));\t\\\n+    _h240 = (double)(long)(((Y##_f1 << 16) & 0xffffff) | (Y##_f0 >> 48));\t\\\n+    _b240 = (double)(long)((X##_f1 >> 8) & 0xffffff);\t\t\t\t\\\n+    _g240 = (double)(long)((Y##_f1 >> 8) & 0xffffff);\t\t\t\t\\\n+    _a240 = (double)(long)(X##_f1 >> 32);\t\t\t\t\t\\\n+    _f240 = (double)(long)(Y##_f1 >> 32);\t\t\t\t\t\\\n+    _e240 *= _const[3];\t\t\t\t\t\t\t\t\\\n+    _j240 *= _const[3];\t\t\t\t\t\t\t\t\\\n+    _d240 *= _const[2];\t\t\t\t\t\t\t\t\\\n+    _i240 *= _const[2];\t\t\t\t\t\t\t\t\\\n+    _c240 *= _const[1];\t\t\t\t\t\t\t\t\\\n+    _h240 *= _const[1];\t\t\t\t\t\t\t\t\\\n+    _b240 *= _const[0];\t\t\t\t\t\t\t\t\\\n+    _g240 *= _const[0];\t\t\t\t\t\t\t\t\\\n+    _s240.d =\t\t\t\t\t\t\t      _e240*_j240;\\\n+    _r240.d =\t\t\t\t\t\t_d240*_j240 + _e240*_i240;\\\n+    _q240.d =\t\t\t\t  _c240*_j240 + _d240*_i240 + _e240*_h240;\\\n+    _p240.d =\t\t    _b240*_j240 + _c240*_i240 + _d240*_h240 + _e240*_g240;\\\n+    _o240.d = _a240*_j240 + _b240*_i240 + _c240*_h240 + _d240*_g240 + _e240*_f240;\\\n+    _n240.d = _a240*_i240 + _b240*_h240 + _c240*_g240 + _d240*_f240;\t\t\\\n+    _m240.d = _a240*_h240 + _b240*_g240 + _c240*_f240;\t\t\t\t\\\n+    _l240.d = _a240*_g240 + _b240*_f240;\t\t\t\t\t\\\n+    _k240 =   _a240*_f240;\t\t\t\t\t\t\t\\\n+    _r240.d += _s240.d;\t\t\t\t\t\t\t\t\\\n+    _q240.d += _r240.d;\t\t\t\t\t\t\t\t\\\n+    _p240.d += _q240.d;\t\t\t\t\t\t\t\t\\\n+    _o240.d += _p240.d;\t\t\t\t\t\t\t\t\\\n+    _n240.d += _o240.d;\t\t\t\t\t\t\t\t\\\n+    _m240.d += _n240.d;\t\t\t\t\t\t\t\t\\\n+    _l240.d += _m240.d;\t\t\t\t\t\t\t\t\\\n+    _k240 += _l240.d;\t\t\t\t\t\t\t\t\\\n+    _s240.d -= ((_const[10]+_s240.d)-_const[10]);\t\t\t\t\\\n+    _r240.d -= ((_const[9]+_r240.d)-_const[9]);\t\t\t\t\t\\\n+    _q240.d -= ((_const[8]+_q240.d)-_const[8]);\t\t\t\t\t\\\n+    _p240.d -= ((_const[7]+_p240.d)-_const[7]);\t\t\t\t\t\\\n+    _o240.d += _const[7];\t\t\t\t\t\t\t\\\n+    _n240.d += _const[6];\t\t\t\t\t\t\t\\\n+    _m240.d += _const[5];\t\t\t\t\t\t\t\\\n+    _l240.d += _const[4];\t\t\t\t\t\t\t\\\n+    if (_s240.d != 0.0) _y240 = 1;\t\t\t\t\t\t\\\n+    if (_r240.d != 0.0) _y240 = 1;\t\t\t\t\t\t\\\n+    if (_q240.d != 0.0) _y240 = 1;\t\t\t\t\t\t\\\n+    if (_p240.d != 0.0) _y240 = 1;\t\t\t\t\t\t\\\n+    _t240 = (DItype)_k240;\t\t\t\t\t\t\t\\\n+    _u240 = _l240.i;\t\t\t\t\t\t\t\t\\\n+    _v240 = _m240.i;\t\t\t\t\t\t\t\t\\\n+    _w240 = _n240.i;\t\t\t\t\t\t\t\t\\\n+    _x240 = _o240.i;\t\t\t\t\t\t\t\t\\\n+    R##_f1 = (_t240 << (128 - (wfracbits - 1)))\t\t\t\t\t\\\n+\t     | ((_u240 & 0xffffff) >> ((wfracbits - 1) - 104));\t\t\t\\\n+    R##_f0 = ((_u240 & 0xffffff) << (168 - (wfracbits - 1)))\t\t\t\\\n+    \t     | ((_v240 & 0xffffff) << (144 - (wfracbits - 1)))\t\t\t\\\n+    \t     | ((_w240 & 0xffffff) << (120 - (wfracbits - 1)))\t\t\t\\\n+    \t     | ((_x240 & 0xffffff) >> ((wfracbits - 1) - 96))\t\t\t\\\n+    \t     | _y240;\t\t\t\t\t\t\t\t\\\n+    resetfe;\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/*\n+ * Division algorithms:\n+ */\n+\n+#define _FP_DIV_MEAT_2_udiv(fs, R, X, Y)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _n_f2, _n_f1, _n_f0, _r_f1, _r_f0, _m_f1, _m_f0;\t\t\\\n+    if (_FP_FRAC_GT_2(X, Y))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t_n_f2 = X##_f1 >> 1;\t\t\t\t\t\t\\\n+\t_n_f1 = X##_f1 << (_FP_W_TYPE_SIZE - 1) | X##_f0 >> 1;\t\t\\\n+\t_n_f0 = X##_f0 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tR##_e--;\t\t\t\t\t\t\t\\\n+\t_n_f2 = X##_f1;\t\t\t\t\t\t\t\\\n+\t_n_f1 = X##_f0;\t\t\t\t\t\t\t\\\n+\t_n_f0 = 0;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* Normalize, i.e. make the most significant bit of the \t\t\\\n+       denominator set. */\t\t\t\t\t\t\\\n+    _FP_FRAC_SLL_2(Y, _FP_WFRACXBITS_##fs);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    udiv_qrnnd(R##_f1, _r_f1, _n_f2, _n_f1, Y##_f1);\t\t\t\\\n+    umul_ppmm(_m_f1, _m_f0, R##_f1, Y##_f0);\t\t\t\t\\\n+    _r_f0 = _n_f0;\t\t\t\t\t\t\t\\\n+    if (_FP_FRAC_GT_2(_m, _r))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tR##_f1--;\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_ADD_2(_r, Y, _r);\t\t\t\t\t\\\n+\tif (_FP_FRAC_GE_2(_r, Y) && _FP_FRAC_GT_2(_m, _r))\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    R##_f1--;\t\t\t\t\t\t\t\\\n+\t    _FP_FRAC_ADD_2(_r, Y, _r);\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    _FP_FRAC_DEC_2(_r, _m);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (_r_f1 == Y##_f1)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t/* This is a special case, not an optimization\t\t\t\\\n+\t   (_r/Y##_f1 would not fit into UWtype).\t\t\t\\\n+\t   As _r is guaranteed to be < Y,  R##_f0 can be either\t\t\\\n+\t   (UWtype)-1 or (UWtype)-2.  But as we know what kind\t\t\\\n+\t   of bits it is (sticky, guard, round),  we don't care.\t\\\n+\t   We also don't care what the reminder is,  because the\t\\\n+\t   guard bit will be set anyway.  -jj */\t\t\t\\\n+\tR##_f0 = -1;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tudiv_qrnnd(R##_f0, _r_f1, _r_f1, _r_f0, Y##_f1);\t\t\\\n+\tumul_ppmm(_m_f1, _m_f0, R##_f0, Y##_f0);\t\t\t\\\n+\t_r_f0 = 0;\t\t\t\t\t\t\t\\\n+\tif (_FP_FRAC_GT_2(_m, _r))\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    R##_f0--;\t\t\t\t\t\t\t\\\n+\t    _FP_FRAC_ADD_2(_r, Y, _r);\t\t\t\t\t\\\n+\t    if (_FP_FRAC_GE_2(_r, Y) && _FP_FRAC_GT_2(_m, _r))\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tR##_f0--;\t\t\t\t\t\t\\\n+\t\t_FP_FRAC_ADD_2(_r, Y, _r);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tif (!_FP_FRAC_EQ_2(_r, _m))\t\t\t\t\t\\\n+\t  R##_f0 |= _FP_WORK_STICKY;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+#define _FP_DIV_MEAT_2_gmp(fs, R, X, Y)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _x[4], _y[2], _z[4];\t\t\t\t\t\\\n+    _y[0] = Y##_f0; _y[1] = Y##_f1;\t\t\t\t\t\\\n+    _x[0] = _x[3] = 0;\t\t\t\t\t\t\t\\\n+    if (_FP_FRAC_GT_2(X, Y))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tR##_e++;\t\t\t\t\t\t\t\\\n+\t_x[1] = (X##_f0 << (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE) |\t\\\n+\t\t X##_f1 >> (_FP_W_TYPE_SIZE -\t\t\t\t\\\n+\t\t\t    (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE)));\t\\\n+\t_x[2] = X##_f1 << (_FP_WFRACBITS_##fs-1 - _FP_W_TYPE_SIZE);\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t_x[1] = (X##_f0 << (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE) |\t\\\n+\t\t X##_f1 >> (_FP_W_TYPE_SIZE -\t\t\t\t\\\n+\t\t\t    (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE)));\t\\\n+\t_x[2] = X##_f1 << (_FP_WFRACBITS_##fs - _FP_W_TYPE_SIZE);\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    (void) mpn_divrem (_z, 0, _x, 4, _y, 2);\t\t\t\t\\\n+    R##_f1 = _z[1];\t\t\t\t\t\t\t\\\n+    R##_f0 = _z[0] | ((_x[0] | _x[1]) != 0);\t\t\t\t\\\n+  } while (0)\n+\n+\n+/*\n+ * Square root algorithms:\n+ * We have just one right now, maybe Newton approximation\n+ * should be added for those machines where division is fast.\n+ */\n+ \n+#define _FP_SQRT_MEAT_2(R, S, T, X, q)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    while (q)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tT##_f1 = S##_f1 + q;\t\t\t\t\\\n+\tif (T##_f1 <= X##_f1)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\\\n+\t    S##_f1 = T##_f1 + q;\t\t\t\\\n+\t    X##_f1 -= T##_f1;\t\t\t\t\\\n+\t    R##_f1 += q;\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\\\n+\t_FP_FRAC_SLL_2(X, 1);\t\t\t\t\\\n+\tq >>= 1;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\\\n+    while (q != _FP_WORK_ROUND)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tT##_f0 = S##_f0 + q;\t\t\t\t\\\n+\tT##_f1 = S##_f1;\t\t\t\t\\\n+\tif (T##_f1 < X##_f1 || \t\t\t\t\\\n+\t    (T##_f1 == X##_f1 && T##_f0 <= X##_f0))\t\\\n+\t  {\t\t\t\t\t\t\\\n+\t    S##_f0 = T##_f0 + q;\t\t\t\\\n+\t    S##_f1 += (T##_f0 > S##_f0);\t\t\\\n+\t    _FP_FRAC_DEC_2(X, T);\t\t\t\\\n+\t    R##_f0 += q;\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\\\n+\t_FP_FRAC_SLL_2(X, 1);\t\t\t\t\\\n+\tq >>= 1;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    if (X##_f0 | X##_f1)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tif (S##_f1 < X##_f1 || \t\t\t\t\\\n+\t    (S##_f1 == X##_f1 && S##_f0 < X##_f0))\t\\\n+\t  R##_f0 |= _FP_WORK_ROUND;\t\t\t\\\n+\tR##_f0 |= _FP_WORK_STICKY;\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/*\n+ * Assembly/disassembly for converting to/from integral types.  \n+ * No shifting or overflow handled here.\n+ */\n+\n+#define _FP_FRAC_ASSEMBLE_2(r, X, rsize)\t\\\n+(void)((rsize <= _FP_W_TYPE_SIZE)\t\t\\\n+       ? ({ r = X##_f0; })\t\t\t\\\n+       : ({\t\t\t\t\t\\\n+\t    r = X##_f1;\t\t\t\t\\\n+\t    r <<= _FP_W_TYPE_SIZE;\t\t\\\n+\t    r += X##_f0;\t\t\t\\\n+\t  }))\n+\n+#define _FP_FRAC_DISASSEMBLE_2(X, r, rsize)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    X##_f0 = r;\t\t\t\t\t\t\t\t\\\n+    X##_f1 = (rsize <= _FP_W_TYPE_SIZE ? 0 : r >> _FP_W_TYPE_SIZE);\t\\\n+  } while (0)\n+\n+/*\n+ * Convert FP values between word sizes\n+ */\n+\n+#define _FP_FRAC_COPY_1_2(D, S)\t\t(D##_f = S##_f0)\n+\n+#define _FP_FRAC_COPY_2_1(D, S)\t\t((D##_f0 = S##_f), (D##_f1 = 0))"}, {"sha": "34f5098e8c21b624c5b2afca0004535395001868", "filename": "gcc/config/soft-fp/op-4.h", "status": "added", "additions": 686, "deletions": 0, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fop-4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fop-4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fop-4.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,686 @@\n+/* Software floating-point emulation.\n+   Basic four-word fraction declaration and manipulation.\n+   Copyright (C) 1997,1998,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com),\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz),\n+\t\t  David S. Miller (davem@redhat.com) and\n+\t\t  Peter Maydell (pmaydell@chiark.greenend.org.uk).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#define _FP_FRAC_DECL_4(X)\t_FP_W_TYPE X##_f[4]\n+#define _FP_FRAC_COPY_4(D,S)\t\t\t\\\n+  (D##_f[0] = S##_f[0], D##_f[1] = S##_f[1],\t\\\n+   D##_f[2] = S##_f[2], D##_f[3] = S##_f[3])\n+#define _FP_FRAC_SET_4(X,I)\t__FP_FRAC_SET_4(X, I)\n+#define _FP_FRAC_HIGH_4(X)\t(X##_f[3])\n+#define _FP_FRAC_LOW_4(X)\t(X##_f[0])\n+#define _FP_FRAC_WORD_4(X,w)\t(X##_f[w])\n+\n+#define _FP_FRAC_SLL_4(X,N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n+    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+    _up = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+    _down = _FP_W_TYPE_SIZE - _up;\t\t\t\t\t\\\n+    if (!_up)\t\t\t\t\t\t\t\t\\\n+      for (_i = 3; _i >= _skip; --_i)\t\t\t\t\t\\\n+\tX##_f[_i] = X##_f[_i-_skip];\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfor (_i = 3; _i > _skip; --_i)\t\t\t\t\t\\\n+\t  X##_f[_i] = X##_f[_i-_skip] << _up\t\t\t\t\\\n+\t\t      | X##_f[_i-_skip-1] >> _down;\t\t\t\\\n+\tX##_f[_i--] = X##_f[0] << _up; \t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    for (; _i >= 0; --_i)\t\t\t\t\t\t\\\n+      X##_f[_i] = 0;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This one was broken too */\n+#define _FP_FRAC_SRL_4(X,N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n+    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+    _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+    _up = _FP_W_TYPE_SIZE - _down;\t\t\t\t\t\\\n+    if (!_down)\t\t\t\t\t\t\t\t\\\n+      for (_i = 0; _i <= 3-_skip; ++_i)\t\t\t\t\t\\\n+\tX##_f[_i] = X##_f[_i+_skip];\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfor (_i = 0; _i < 3-_skip; ++_i)\t\t\t\t\\\n+\t  X##_f[_i] = X##_f[_i+_skip] >> _down\t\t\t\t\\\n+\t\t      | X##_f[_i+_skip+1] << _up;\t\t\t\\\n+\tX##_f[_i++] = X##_f[3] >> _down;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    for (; _i < 4; ++_i)\t\t\t\t\t\t\\\n+      X##_f[_i] = 0;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/* Right shift with sticky-lsb. \n+ * What this actually means is that we do a standard right-shift,\n+ * but that if any of the bits that fall off the right hand side\n+ * were one then we always set the LSbit.\n+ */\n+#define _FP_FRAC_SRST_4(X,S,N,size)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\\\n+    _FP_W_TYPE _s;\t\t\t\t\t\\\n+    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\\\n+    _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\\\n+    _up = _FP_W_TYPE_SIZE - _down;\t\t\t\\\n+    for (_s = _i = 0; _i < _skip; ++_i)\t\t\t\\\n+      _s |= X##_f[_i];\t\t\t\t\t\\\n+    if (!_down)\t\t\t\t\t\t\\\n+      for (_i = 0; _i <= 3-_skip; ++_i)\t\t\t\\\n+\tX##_f[_i] = X##_f[_i+_skip];\t\t\t\\\n+    else\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\t_s |= X##_f[_i] << _up;\t\t\t\t\\\n+\tfor (_i = 0; _i < 3-_skip; ++_i)\t\t\\\n+\t  X##_f[_i] = X##_f[_i+_skip] >> _down\t\t\\\n+\t\t      | X##_f[_i+_skip+1] << _up;\t\\\n+\tX##_f[_i++] = X##_f[3] >> _down;\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    for (; _i < 4; ++_i)\t\t\t\t\\\n+      X##_f[_i] = 0;\t\t\t\t\t\\\n+    S = (_s != 0);\t\t\t\t\t\\\n+  } while (0)\n+\n+#define _FP_FRAC_SRS_4(X,N,size)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    int _sticky;\t\t\t\t\\\n+    _FP_FRAC_SRST_4(X, _sticky, N, size);\t\\\n+    X##_f[0] |= _sticky;\t\t\t\\\n+  } while (0)\n+\n+#define _FP_FRAC_ADD_4(R,X,Y)\t\t\t\t\t\t\\\n+  __FP_FRAC_ADD_4(R##_f[3], R##_f[2], R##_f[1], R##_f[0],\t\t\\\n+\t\t  X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t\t\\\n+\t\t  Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])\n+\n+#define _FP_FRAC_SUB_4(R,X,Y)\t\t\t\t\t\t\\\n+  __FP_FRAC_SUB_4(R##_f[3], R##_f[2], R##_f[1], R##_f[0],\t\t\\\n+\t\t  X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t\t\\\n+\t\t  Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])\n+\n+#define _FP_FRAC_DEC_4(X,Y)\t\t\t\t\t\t\\\n+  __FP_FRAC_DEC_4(X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t\t\\\n+\t\t  Y##_f[3], Y##_f[2], Y##_f[1], Y##_f[0])\n+\n+#define _FP_FRAC_ADDI_4(X,I)\t\t\t\t\t\t\\\n+  __FP_FRAC_ADDI_4(X##_f[3], X##_f[2], X##_f[1], X##_f[0], I)\n+\n+#define _FP_ZEROFRAC_4  0,0,0,0\n+#define _FP_MINFRAC_4   0,0,0,1\n+#define _FP_MAXFRAC_4\t(~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0), (~(_FP_WS_TYPE)0)\n+\n+#define _FP_FRAC_ZEROP_4(X)     ((X##_f[0] | X##_f[1] | X##_f[2] | X##_f[3]) == 0)\n+#define _FP_FRAC_NEGP_4(X)      ((_FP_WS_TYPE)X##_f[3] < 0)\n+#define _FP_FRAC_OVERP_4(fs,X)  (_FP_FRAC_HIGH_##fs(X) & _FP_OVERFLOW_##fs)\n+#define _FP_FRAC_CLEAR_OVERP_4(fs,X)  (_FP_FRAC_HIGH_##fs(X) &= ~_FP_OVERFLOW_##fs)\n+\n+#define _FP_FRAC_EQ_4(X,Y)\t\t\t\t\\\n+ (X##_f[0] == Y##_f[0] && X##_f[1] == Y##_f[1]\t\t\\\n+  && X##_f[2] == Y##_f[2] && X##_f[3] == Y##_f[3])\n+\n+#define _FP_FRAC_GT_4(X,Y)\t\t\t\t\\\n+ (X##_f[3] > Y##_f[3] ||\t\t\t\t\\\n+  (X##_f[3] == Y##_f[3] && (X##_f[2] > Y##_f[2] ||\t\\\n+   (X##_f[2] == Y##_f[2] && (X##_f[1] > Y##_f[1] ||\t\\\n+    (X##_f[1] == Y##_f[1] && X##_f[0] > Y##_f[0])\t\\\n+   ))\t\t\t\t\t\t\t\\\n+  ))\t\t\t\t\t\t\t\\\n+ )\n+\n+#define _FP_FRAC_GE_4(X,Y)\t\t\t\t\\\n+ (X##_f[3] > Y##_f[3] ||\t\t\t\t\\\n+  (X##_f[3] == Y##_f[3] && (X##_f[2] > Y##_f[2] ||\t\\\n+   (X##_f[2] == Y##_f[2] && (X##_f[1] > Y##_f[1] ||\t\\\n+    (X##_f[1] == Y##_f[1] && X##_f[0] >= Y##_f[0])\t\\\n+   ))\t\t\t\t\t\t\t\\\n+  ))\t\t\t\t\t\t\t\\\n+ )\n+\n+\n+#define _FP_FRAC_CLZ_4(R,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    if (X##_f[3])\t\t\t\\\n+    {\t\t\t\t\t\\\n+\t__FP_CLZ(R,X##_f[3]);\t\t\\\n+    }\t\t\t\t\t\\\n+    else if (X##_f[2])\t\t\t\\\n+    {\t\t\t\t\t\\\n+\t__FP_CLZ(R,X##_f[2]);\t\t\\\n+\tR += _FP_W_TYPE_SIZE;\t\t\\\n+    }\t\t\t\t\t\\\n+    else if (X##_f[1])\t\t\t\\\n+    {\t\t\t\t\t\\\n+\t__FP_CLZ(R,X##_f[1]);\t\t\\\n+\tR += _FP_W_TYPE_SIZE*2;\t\t\\\n+    }\t\t\t\t\t\\\n+    else\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+\t__FP_CLZ(R,X##_f[0]);\t\t\\\n+\tR += _FP_W_TYPE_SIZE*3;\t\t\\\n+    }\t\t\t\t\t\\\n+  } while(0)\n+\n+\n+#define _FP_UNPACK_RAW_4(fs, X, val)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs _flo; _flo.flt = (val);\t\t\\\n+    X##_f[0] = _flo.bits.frac0;\t\t\t\t\t\\\n+    X##_f[1] = _flo.bits.frac1;\t\t\t\t\t\\\n+    X##_f[2] = _flo.bits.frac2;\t\t\t\t\t\\\n+    X##_f[3] = _flo.bits.frac3;\t\t\t\t\t\\\n+    X##_e  = _flo.bits.exp;\t\t\t\t\t\\\n+    X##_s  = _flo.bits.sign;\t\t\t\t\t\\\n+  } while (0)\n+\n+#define _FP_UNPACK_RAW_4_P(fs, X, val)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs *_flo =\t\t\t\t\\\n+      (union _FP_UNION_##fs *)(val);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    X##_f[0] = _flo->bits.frac0;\t\t\t\t\\\n+    X##_f[1] = _flo->bits.frac1;\t\t\t\t\\\n+    X##_f[2] = _flo->bits.frac2;\t\t\t\t\\\n+    X##_f[3] = _flo->bits.frac3;\t\t\t\t\\\n+    X##_e  = _flo->bits.exp;\t\t\t\t\t\\\n+    X##_s  = _flo->bits.sign;\t\t\t\t\t\\\n+  } while (0)\n+\n+#define _FP_PACK_RAW_4(fs, val, X)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs _flo;\t\t\t\t\t\\\n+    _flo.bits.frac0 = X##_f[0];\t\t\t\t\t\\\n+    _flo.bits.frac1 = X##_f[1];\t\t\t\t\t\\\n+    _flo.bits.frac2 = X##_f[2];\t\t\t\t\t\\\n+    _flo.bits.frac3 = X##_f[3];\t\t\t\t\t\\\n+    _flo.bits.exp   = X##_e;\t\t\t\t\t\\\n+    _flo.bits.sign  = X##_s;\t\t\t\t\t\\\n+    (val) = _flo.flt;\t\t\t\t   \t\t\\\n+  } while (0)\n+\n+#define _FP_PACK_RAW_4_P(fs, val, X)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union _FP_UNION_##fs *_flo =\t\t\t\t\\\n+      (union _FP_UNION_##fs *)(val);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    _flo->bits.frac0 = X##_f[0];\t\t\t\t\\\n+    _flo->bits.frac1 = X##_f[1];\t\t\t\t\\\n+    _flo->bits.frac2 = X##_f[2];\t\t\t\t\\\n+    _flo->bits.frac3 = X##_f[3];\t\t\t\t\\\n+    _flo->bits.exp   = X##_e;\t\t\t\t\t\\\n+    _flo->bits.sign  = X##_s;\t\t\t\t\t\\\n+  } while (0)\n+\n+/*\n+ * Multiplication algorithms:\n+ */\n+\n+/* Given a 1W * 1W => 2W primitive, do the extended multiplication.  */\n+\n+#define _FP_MUL_MEAT_4_wide(wfracbits, R, X, Y, doit)\t\t\t    \\\n+  do {\t\t\t\t\t\t\t\t\t    \\\n+    _FP_FRAC_DECL_8(_z); _FP_FRAC_DECL_2(_b); _FP_FRAC_DECL_2(_c);\t    \\\n+    _FP_FRAC_DECL_2(_d); _FP_FRAC_DECL_2(_e); _FP_FRAC_DECL_2(_f);\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+    doit(_FP_FRAC_WORD_8(_z,1), _FP_FRAC_WORD_8(_z,0), X##_f[0], Y##_f[0]); \\\n+    doit(_b_f1, _b_f0, X##_f[0], Y##_f[1]);\t\t\t\t    \\\n+    doit(_c_f1, _c_f0, X##_f[1], Y##_f[0]);\t\t\t\t    \\\n+    doit(_d_f1, _d_f0, X##_f[1], Y##_f[1]);\t\t\t\t    \\\n+    doit(_e_f1, _e_f0, X##_f[0], Y##_f[2]);\t\t\t\t    \\\n+    doit(_f_f1, _f_f0, X##_f[2], Y##_f[0]);\t\t\t\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,1), 0,_b_f1,_b_f0,\t\t    \\\n+\t\t    0,0,_FP_FRAC_WORD_8(_z,1));\t\t\t\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,1), 0,_c_f1,_c_f0,\t\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,1));\t\t\t\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,2), 0,_d_f1,_d_f0,\t\t    \\\n+\t\t    0,_FP_FRAC_WORD_8(_z,3),_FP_FRAC_WORD_8(_z,2));\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,2), 0,_e_f1,_e_f0,\t\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,2));\t\t\t\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,2), 0,_f_f1,_f_f0,\t\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,2));\t\t\t\t    \\\n+    doit(_b_f1, _b_f0, X##_f[0], Y##_f[3]);\t\t\t\t    \\\n+    doit(_c_f1, _c_f0, X##_f[3], Y##_f[0]);\t\t\t\t    \\\n+    doit(_d_f1, _d_f0, X##_f[1], Y##_f[2]);\t\t\t\t    \\\n+    doit(_e_f1, _e_f0, X##_f[2], Y##_f[1]);\t\t\t\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,3), 0,_b_f1,_b_f0,\t\t    \\\n+\t\t    0,_FP_FRAC_WORD_8(_z,4),_FP_FRAC_WORD_8(_z,3));\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,3), 0,_c_f1,_c_f0,\t\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,3));\t\t\t\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,3), 0,_d_f1,_d_f0,\t\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,3));\t\t\t\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,3), 0,_e_f1,_e_f0,\t\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,3));\t\t\t\t    \\\n+    doit(_b_f1, _b_f0, X##_f[2], Y##_f[2]);\t\t\t\t    \\\n+    doit(_c_f1, _c_f0, X##_f[1], Y##_f[3]);\t\t\t\t    \\\n+    doit(_d_f1, _d_f0, X##_f[3], Y##_f[1]);\t\t\t\t    \\\n+    doit(_e_f1, _e_f0, X##_f[2], Y##_f[3]);\t\t\t\t    \\\n+    doit(_f_f1, _f_f0, X##_f[3], Y##_f[2]);\t\t\t\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,4), 0,_b_f1,_b_f0,\t\t    \\\n+\t\t    0,_FP_FRAC_WORD_8(_z,5),_FP_FRAC_WORD_8(_z,4));\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,4), 0,_c_f1,_c_f0,\t\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,4));\t\t\t\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,4), 0,_d_f1,_d_f0,\t\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,4));\t\t\t\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,5), 0,_e_f1,_e_f0,\t\t    \\\n+\t\t    0,_FP_FRAC_WORD_8(_z,6),_FP_FRAC_WORD_8(_z,5));\t    \\\n+    __FP_FRAC_ADD_3(_FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,5), 0,_f_f1,_f_f0,\t\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,5));\t\t\t\t    \\\n+    doit(_b_f1, _b_f0, X##_f[3], Y##_f[3]);\t\t\t\t    \\\n+    __FP_FRAC_ADD_2(_FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6),\t    \\\n+\t\t    _b_f1,_b_f0,\t\t\t\t\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,7),_FP_FRAC_WORD_8(_z,6));\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+    /* Normalize since we know where the msb of the multiplicands\t    \\\n+       were (bit B), we know that the msb of the of the product is\t    \\\n+       at either 2B or 2B-1.  */\t\t\t\t\t    \\\n+    _FP_FRAC_SRS_8(_z, wfracbits-1, 2*wfracbits);\t\t\t    \\\n+    __FP_FRAC_SET_4(R, _FP_FRAC_WORD_8(_z,3), _FP_FRAC_WORD_8(_z,2),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,1), _FP_FRAC_WORD_8(_z,0));\t    \\\n+  } while (0)\n+\n+#define _FP_MUL_MEAT_4_gmp(wfracbits, R, X, Y)\t\t\t\t    \\\n+  do {\t\t\t\t\t\t\t\t\t    \\\n+    _FP_FRAC_DECL_8(_z);\t\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+    mpn_mul_n(_z_f, _x_f, _y_f, 4);\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+    /* Normalize since we know where the msb of the multiplicands\t    \\\n+       were (bit B), we know that the msb of the of the product is\t    \\\n+       at either 2B or 2B-1.  */\t\t\t\t\t    \\\n+    _FP_FRAC_SRS_8(_z, wfracbits-1, 2*wfracbits);\t \t\t    \\\n+    __FP_FRAC_SET_4(R, _FP_FRAC_WORD_8(_z,3), _FP_FRAC_WORD_8(_z,2),\t    \\\n+\t\t    _FP_FRAC_WORD_8(_z,1), _FP_FRAC_WORD_8(_z,0));\t    \\\n+  } while (0)\n+\n+/*\n+ * Helper utility for _FP_DIV_MEAT_4_udiv:\n+ * pppp = m * nnn\n+ */\n+#define umul_ppppmnnn(p3,p2,p1,p0,m,n2,n1,n0)\t\t\t\t    \\\n+  do {\t\t\t\t\t\t\t\t\t    \\\n+    UWtype _t;\t\t\t\t\t\t\t\t    \\\n+    umul_ppmm(p1,p0,m,n0);\t\t\t\t\t\t    \\\n+    umul_ppmm(p2,_t,m,n1);\t\t\t\t\t\t    \\\n+    __FP_FRAC_ADDI_2(p2,p1,_t);\t\t\t\t\t\t    \\\n+    umul_ppmm(p3,_t,m,n2);\t\t\t\t\t\t    \\\n+    __FP_FRAC_ADDI_2(p3,p2,_t);\t\t\t\t\t\t    \\\n+  } while (0)\n+\n+/*\n+ * Division algorithms:\n+ */\n+\n+#define _FP_DIV_MEAT_4_udiv(fs, R, X, Y)\t\t\t\t    \\\n+  do {\t\t\t\t\t\t\t\t\t    \\\n+    int _i;\t\t\t\t\t\t\t\t    \\\n+    _FP_FRAC_DECL_4(_n); _FP_FRAC_DECL_4(_m);\t\t\t\t    \\\n+    _FP_FRAC_SET_4(_n, _FP_ZEROFRAC_4);\t\t\t\t\t    \\\n+    if (_FP_FRAC_GT_4(X, Y))\t\t\t\t\t\t    \\\n+      {\t\t\t\t\t\t\t\t\t    \\\n+\t_n_f[3] = X##_f[0] << (_FP_W_TYPE_SIZE - 1);\t\t\t    \\\n+\t_FP_FRAC_SRL_4(X, 1);\t\t\t\t\t\t    \\\n+      }\t\t\t\t\t\t\t\t\t    \\\n+    else\t\t\t\t\t\t\t\t    \\\n+      R##_e--;\t\t\t\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+    /* Normalize, i.e. make the most significant bit of the \t\t    \\\n+       denominator set. */\t\t\t\t\t\t    \\\n+    _FP_FRAC_SLL_4(Y, _FP_WFRACXBITS_##fs);\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+    for (_i = 3; ; _i--)\t\t\t\t\t\t    \\\n+      {\t\t\t\t\t\t\t\t\t    \\\n+        if (X##_f[3] == Y##_f[3])\t\t\t\t\t    \\\n+          {\t\t\t\t\t\t\t\t    \\\n+            /* This is a special case, not an optimization\t\t    \\\n+               (X##_f[3]/Y##_f[3] would not fit into UWtype).\t\t    \\\n+               As X## is guaranteed to be < Y,  R##_f[_i] can be either\t    \\\n+               (UWtype)-1 or (UWtype)-2.  */\t\t\t\t    \\\n+            R##_f[_i] = -1;\t\t\t\t\t\t    \\\n+            if (!_i)\t\t\t\t\t\t\t    \\\n+\t      break;\t\t\t\t\t\t\t    \\\n+            __FP_FRAC_SUB_4(X##_f[3], X##_f[2], X##_f[1], X##_f[0],\t    \\\n+\t\t\t    Y##_f[2], Y##_f[1], Y##_f[0], 0,\t\t    \\\n+\t\t\t    X##_f[2], X##_f[1], X##_f[0], _n_f[_i]);\t    \\\n+            _FP_FRAC_SUB_4(X, Y, X);\t\t\t\t\t    \\\n+            if (X##_f[3] > Y##_f[3])\t\t\t\t\t    \\\n+              {\t\t\t\t\t\t\t\t    \\\n+                R##_f[_i] = -2;\t\t\t\t\t\t    \\\n+                _FP_FRAC_ADD_4(X, Y, X);\t\t\t\t    \\\n+              }\t\t\t\t\t\t\t\t    \\\n+          }\t\t\t\t\t\t\t\t    \\\n+        else\t\t\t\t\t\t\t\t    \\\n+          {\t\t\t\t\t\t\t\t    \\\n+            udiv_qrnnd(R##_f[_i], X##_f[3], X##_f[3], X##_f[2], Y##_f[3]);  \\\n+            umul_ppppmnnn(_m_f[3], _m_f[2], _m_f[1], _m_f[0],\t\t    \\\n+\t\t\t  R##_f[_i], Y##_f[2], Y##_f[1], Y##_f[0]);\t    \\\n+            X##_f[2] = X##_f[1];\t\t\t\t\t    \\\n+            X##_f[1] = X##_f[0];\t\t\t\t\t    \\\n+            X##_f[0] = _n_f[_i];\t\t\t\t\t    \\\n+            if (_FP_FRAC_GT_4(_m, X))\t\t\t\t\t    \\\n+              {\t\t\t\t\t\t\t\t    \\\n+                R##_f[_i]--;\t\t\t\t\t\t    \\\n+                _FP_FRAC_ADD_4(X, Y, X);\t\t\t\t    \\\n+                if (_FP_FRAC_GE_4(X, Y) && _FP_FRAC_GT_4(_m, X))\t    \\\n+                  {\t\t\t\t\t\t\t    \\\n+\t\t    R##_f[_i]--;\t\t\t\t\t    \\\n+\t\t    _FP_FRAC_ADD_4(X, Y, X);\t\t\t\t    \\\n+                  }\t\t\t\t\t\t\t    \\\n+              }\t\t\t\t\t\t\t\t    \\\n+            _FP_FRAC_DEC_4(X, _m);\t\t\t\t\t    \\\n+            if (!_i)\t\t\t\t\t\t\t    \\\n+\t      {\t\t\t\t\t\t\t\t    \\\n+\t\tif (!_FP_FRAC_EQ_4(X, _m))\t\t\t\t    \\\n+\t\t  R##_f[0] |= _FP_WORK_STICKY;\t\t\t\t    \\\n+\t\tbreak;\t\t\t\t\t\t\t    \\\n+\t      }\t\t\t\t\t\t\t\t    \\\n+          }\t\t\t\t\t\t\t\t    \\\n+      }\t\t\t\t\t\t\t\t\t    \\\n+  } while (0)\n+\n+\n+/*\n+ * Square root algorithms:\n+ * We have just one right now, maybe Newton approximation\n+ * should be added for those machines where division is fast.\n+ */\n+ \n+#define _FP_SQRT_MEAT_4(R, S, T, X, q)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    while (q)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tT##_f[3] = S##_f[3] + q;\t\t\t\t\\\n+\tif (T##_f[3] <= X##_f[3])\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    S##_f[3] = T##_f[3] + q;\t\t\t\t\\\n+\t    X##_f[3] -= T##_f[3];\t\t\t\t\\\n+\t    R##_f[3] += q;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_SLL_4(X, 1);\t\t\t\t\t\\\n+\tq >>= 1;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n+    while (q)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tT##_f[2] = S##_f[2] + q;\t\t\t\t\\\n+\tT##_f[3] = S##_f[3];\t\t\t\t\t\\\n+\tif (T##_f[3] < X##_f[3] || \t\t\t\t\\\n+\t    (T##_f[3] == X##_f[3] && T##_f[2] <= X##_f[2]))\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    S##_f[2] = T##_f[2] + q;\t\t\t\t\\\n+\t    S##_f[3] += (T##_f[2] > S##_f[2]);\t\t\t\\\n+\t    __FP_FRAC_DEC_2(X##_f[3], X##_f[2],\t\t\t\\\n+\t\t\t    T##_f[3], T##_f[2]);\t\t\\\n+\t    R##_f[2] += q;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_SLL_4(X, 1);\t\t\t\t\t\\\n+\tq >>= 1;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n+    while (q)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tT##_f[1] = S##_f[1] + q;\t\t\t\t\\\n+\tT##_f[2] = S##_f[2];\t\t\t\t\t\\\n+\tT##_f[3] = S##_f[3];\t\t\t\t\t\\\n+\tif (T##_f[3] < X##_f[3] || \t\t\t\t\\\n+\t    (T##_f[3] == X##_f[3] && (T##_f[2] < X##_f[2] ||\t\\\n+\t     (T##_f[2] == X##_f[2] && T##_f[1] <= X##_f[1]))))\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    S##_f[1] = T##_f[1] + q;\t\t\t\t\\\n+\t    S##_f[2] += (T##_f[1] > S##_f[1]);\t\t\t\\\n+\t    S##_f[3] += (T##_f[2] > S##_f[2]);\t\t\t\\\n+\t    __FP_FRAC_DEC_3(X##_f[3], X##_f[2], X##_f[1],\t\\\n+\t    \t\t    T##_f[3], T##_f[2], T##_f[1]);\t\\\n+\t    R##_f[1] += q;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_SLL_4(X, 1);\t\t\t\t\t\\\n+\tq >>= 1;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    q = (_FP_W_TYPE)1 << (_FP_W_TYPE_SIZE - 1);\t\t\t\\\n+    while (q != _FP_WORK_ROUND)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tT##_f[0] = S##_f[0] + q;\t\t\t\t\\\n+\tT##_f[1] = S##_f[1];\t\t\t\t\t\\\n+\tT##_f[2] = S##_f[2];\t\t\t\t\t\\\n+\tT##_f[3] = S##_f[3];\t\t\t\t\t\\\n+\tif (_FP_FRAC_GE_4(X,T))\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    S##_f[0] = T##_f[0] + q;\t\t\t\t\\\n+\t    S##_f[1] += (T##_f[0] > S##_f[0]);\t\t\t\\\n+\t    S##_f[2] += (T##_f[1] > S##_f[1]);\t\t\t\\\n+\t    S##_f[3] += (T##_f[2] > S##_f[2]);\t\t\t\\\n+\t    _FP_FRAC_DEC_4(X, T);\t\t\t\t\\\n+\t    R##_f[0] += q;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_SLL_4(X, 1);\t\t\t\t\t\\\n+\tq >>= 1;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    if (!_FP_FRAC_ZEROP_4(X))\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tif (_FP_FRAC_GT_4(X,S))\t\t\t\t\t\\\n+\t  R##_f[0] |= _FP_WORK_ROUND;\t\t\t\t\\\n+\tR##_f[0] |= _FP_WORK_STICKY;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/*\n+ * Internals \n+ */\n+\n+#define __FP_FRAC_SET_4(X,I3,I2,I1,I0)\t\t\t\t\t\\\n+  (X##_f[3] = I3, X##_f[2] = I2, X##_f[1] = I1, X##_f[0] = I0)\n+\n+#ifndef __FP_FRAC_ADD_3\n+#define __FP_FRAC_ADD_3(r2,r1,r0,x2,x1,x0,y2,y1,y0)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _c1, _c2;\t\t\t\t\t\\\n+    r0 = x0 + y0;\t\t\t\t\t\t\\\n+    _c1 = r0 < x0;\t\t\t\t\t\t\\\n+    r1 = x1 + y1;\t\t\t\t\t\t\\\n+    _c2 = r1 < x1;\t\t\t\t\t\t\\\n+    r1 += _c1;\t\t\t\t\t\t\t\\\n+    _c2 |= r1 < _c1;\t\t\t\t\t\t\\\n+    r2 = x2 + y2 + _c2;\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef __FP_FRAC_ADD_4\n+#define __FP_FRAC_ADD_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _c1, _c2, _c3;\t\t\t\t\t\\\n+    r0 = x0 + y0;\t\t\t\t\t\t\\\n+    _c1 = r0 < x0;\t\t\t\t\t\t\\\n+    r1 = x1 + y1;\t\t\t\t\t\t\\\n+    _c2 = r1 < x1;\t\t\t\t\t\t\\\n+    r1 += _c1;\t\t\t\t\t\t\t\\\n+    _c2 |= r1 < _c1;\t\t\t\t\t\t\\\n+    r2 = x2 + y2;\t\t\t\t\t\t\\\n+    _c3 = r2 < x2;\t\t\t\t\t\t\\\n+    r2 += _c2;\t\t\t\t\t\t\t\\\n+    _c3 |= r2 < _c2;\t\t\t\t\t\t\\\n+    r3 = x3 + y3 + _c3;\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef __FP_FRAC_SUB_3\n+#define __FP_FRAC_SUB_3(r2,r1,r0,x2,x1,x0,y2,y1,y0)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _c1, _c2;\t\t\t\t\t\\\n+    r0 = x0 - y0;\t\t\t\t\t\t\\\n+    _c1 = r0 > x0;\t\t\t\t\t\t\\\n+    r1 = x1 - y1;\t\t\t\t\t\t\\\n+    _c2 = r1 > x1;\t\t\t\t\t\t\\\n+    r1 -= _c1;\t\t\t\t\t\t\t\\\n+    _c2 |= r1 > _c1;\t\t\t\t\t\t\\\n+    r2 = x2 - y2 - _c2;\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef __FP_FRAC_SUB_4\n+#define __FP_FRAC_SUB_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    _FP_W_TYPE _c1, _c2, _c3;\t\t\t\t\t\\\n+    r0 = x0 - y0;\t\t\t\t\t\t\\\n+    _c1 = r0 > x0;\t\t\t\t\t\t\\\n+    r1 = x1 - y1;\t\t\t\t\t\t\\\n+    _c2 = r1 > x1;\t\t\t\t\t\t\\\n+    r1 -= _c1;\t\t\t\t\t\t\t\\\n+    _c2 |= r1 > _c1;\t\t\t\t\t\t\\\n+    r2 = x2 - y2;\t\t\t\t\t\t\\\n+    _c3 = r2 > x2;\t\t\t\t\t\t\\\n+    r2 -= _c2;\t\t\t\t\t\t\t\\\n+    _c3 |= r2 > _c2;\t\t\t\t\t\t\\\n+    r3 = x3 - y3 - _c3;\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef __FP_FRAC_DEC_3\n+#define __FP_FRAC_DEC_3(x2,x1,x0,y2,y1,y0)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    UWtype _t0, _t1, _t2;\t\t\t\t\t\t\\\n+    _t0 = x0, _t1 = x1, _t2 = x2;\t\t\t\t\t\\\n+    __FP_FRAC_SUB_3 (x2, x1, x0, _t2, _t1, _t0, y2, y1, y0);\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef __FP_FRAC_DEC_4\n+#define __FP_FRAC_DEC_4(x3,x2,x1,x0,y3,y2,y1,y0)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    UWtype _t0, _t1, _t2, _t3;\t\t\t\t\t\t\\\n+    _t0 = x0, _t1 = x1, _t2 = x2, _t3 = x3;\t\t\t\t\\\n+    __FP_FRAC_SUB_4 (x3,x2,x1,x0,_t3,_t2,_t1,_t0, y3,y2,y1,y0);\t\t\\\n+  } while (0)\n+#endif\n+\n+#ifndef __FP_FRAC_ADDI_4\n+#define __FP_FRAC_ADDI_4(x3,x2,x1,x0,i)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    UWtype _t;\t\t\t\t\t\t\t\t\\\n+    _t = ((x0 += i) < i);\t\t\t\t\t\t\\\n+    x1 += _t; _t = (x1 < _t);\t\t\t\t\t\t\\\n+    x2 += _t; _t = (x2 < _t);\t\t\t\t\t\t\\\n+    x3 += _t;\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+/* Convert FP values between word sizes. This appears to be more\n+ * complicated than I'd have expected it to be, so these might be\n+ * wrong... These macros are in any case somewhat bogus because they\n+ * use information about what various FRAC_n variables look like \n+ * internally [eg, that 2 word vars are X_f0 and x_f1]. But so do\n+ * the ones in op-2.h and op-1.h. \n+ */\n+#define _FP_FRAC_COPY_1_4(D, S)\t\t(D##_f = S##_f[0])\n+\n+#define _FP_FRAC_COPY_2_4(D, S)\t\t\t\\\n+do {\t\t\t\t\t\t\\\n+  D##_f0 = S##_f[0];\t\t\t\t\\\n+  D##_f1 = S##_f[1];\t\t\t\t\\\n+} while (0)\n+\n+/* Assembly/disassembly for converting to/from integral types.  \n+ * No shifting or overflow handled here.\n+ */\n+/* Put the FP value X into r, which is an integer of size rsize. */\n+#define _FP_FRAC_ASSEMBLE_4(r, X, rsize)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (rsize <= _FP_W_TYPE_SIZE)\t\t\t\t\t\\\n+      r = X##_f[0];\t\t\t\t\t\t\t\\\n+    else if (rsize <= 2*_FP_W_TYPE_SIZE)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      r = X##_f[1];\t\t\t\t\t\t\t\\\n+      r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\t\\\n+      r += X##_f[0];\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* I'm feeling lazy so we deal with int == 3words (implausible)*/\t\\\n+      /* and int == 4words as a single case.\t\t\t */\t\\\n+      r = X##_f[3];\t\t\t\t\t\t\t\\\n+      r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\t\\\n+      r += X##_f[2];\t\t\t\t\t\t\t\\\n+      r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\t\\\n+      r += X##_f[1];\t\t\t\t\t\t\t\\\n+      r <<= _FP_W_TYPE_SIZE;\t\t\t\t\t\t\\\n+      r += X##_f[0];\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* \"No disassemble Number Five!\" */\n+/* move an integer of size rsize into X's fractional part. We rely on\n+ * the _f[] array consisting of words of size _FP_W_TYPE_SIZE to avoid\n+ * having to mask the values we store into it.\n+ */\n+#define _FP_FRAC_DISASSEMBLE_4(X, r, rsize)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    X##_f[0] = r;\t\t\t\t\t\t\t\\\n+    X##_f[1] = (rsize <= _FP_W_TYPE_SIZE ? 0 : r >> _FP_W_TYPE_SIZE);\t\\\n+    X##_f[2] = (rsize <= 2*_FP_W_TYPE_SIZE ? 0 : r >> 2*_FP_W_TYPE_SIZE); \\\n+    X##_f[3] = (rsize <= 3*_FP_W_TYPE_SIZE ? 0 : r >> 3*_FP_W_TYPE_SIZE); \\\n+  } while (0);\n+\n+#define _FP_FRAC_COPY_4_1(D, S)\t\t\t\\\n+do {\t\t\t\t\t\t\\\n+  D##_f[0] = S##_f;\t\t\t\t\\\n+  D##_f[1] = D##_f[2] = D##_f[3] = 0;\t\t\\\n+} while (0)\n+\n+#define _FP_FRAC_COPY_4_2(D, S)\t\t\t\\\n+do {\t\t\t\t\t\t\\\n+  D##_f[0] = S##_f0;\t\t\t\t\\\n+  D##_f[1] = S##_f1;\t\t\t\t\\\n+  D##_f[2] = D##_f[3] = 0;\t\t\t\\\n+} while (0)"}, {"sha": "e0612a5e62f652a6509d2ff8df2d8100515ebdfb", "filename": "gcc/config/soft-fp/op-8.h", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fop-8.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fop-8.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fop-8.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,111 @@\n+/* Software floating-point emulation.\n+   Basic eight-word fraction declaration and manipulation.\n+   Copyright (C) 1997,1998,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com),\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz) and\n+\t\t  Peter Maydell (pmaydell@chiark.greenend.org.uk).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+/* We need just a few things from here for op-4, if we ever need some\n+   other macros, they can be added. */\n+#define _FP_FRAC_DECL_8(X)\t_FP_W_TYPE X##_f[8]\n+#define _FP_FRAC_HIGH_8(X)\t(X##_f[7])\n+#define _FP_FRAC_LOW_8(X)\t(X##_f[0])\n+#define _FP_FRAC_WORD_8(X,w)\t(X##_f[w])\n+\n+#define _FP_FRAC_SLL_8(X,N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n+    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+    _up = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+    _down = _FP_W_TYPE_SIZE - _up;\t\t\t\t\t\\\n+    if (!_up)\t\t\t\t\t\t\t\t\\\n+      for (_i = 7; _i >= _skip; --_i)\t\t\t\t\t\\\n+\tX##_f[_i] = X##_f[_i-_skip];\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfor (_i = 7; _i > _skip; --_i)\t\t\t\t\t\\\n+\t  X##_f[_i] = X##_f[_i-_skip] << _up\t\t\t\t\\\n+\t\t      | X##_f[_i-_skip-1] >> _down;\t\t\t\\\n+\tX##_f[_i--] = X##_f[0] << _up; \t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    for (; _i >= 0; --_i)\t\t\t\t\t\t\\\n+      X##_f[_i] = 0;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define _FP_FRAC_SRL_8(X,N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n+    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+    _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+    _up = _FP_W_TYPE_SIZE - _down;\t\t\t\t\t\\\n+    if (!_down)\t\t\t\t\t\t\t\t\\\n+      for (_i = 0; _i <= 7-_skip; ++_i)\t\t\t\t\t\\\n+\tX##_f[_i] = X##_f[_i+_skip];\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfor (_i = 0; _i < 7-_skip; ++_i)\t\t\t\t\\\n+\t  X##_f[_i] = X##_f[_i+_skip] >> _down\t\t\t\t\\\n+\t\t      | X##_f[_i+_skip+1] << _up;\t\t\t\\\n+\tX##_f[_i++] = X##_f[7] >> _down;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    for (; _i < 8; ++_i)\t\t\t\t\t\t\\\n+      X##_f[_i] = 0;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/* Right shift with sticky-lsb. \n+ * What this actually means is that we do a standard right-shift,\n+ * but that if any of the bits that fall off the right hand side\n+ * were one then we always set the LSbit.\n+ */\n+#define _FP_FRAC_SRS_8(X,N,size)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_I_TYPE _up, _down, _skip, _i;\t\t\t\t\t\\\n+    _FP_W_TYPE _s;\t\t\t\t\t\t\t\\\n+    _skip = (N) / _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+    _down = (N) % _FP_W_TYPE_SIZE;\t\t\t\t\t\\\n+    _up = _FP_W_TYPE_SIZE - _down;\t\t\t\t\t\\\n+    for (_s = _i = 0; _i < _skip; ++_i)\t\t\t\t\t\\\n+      _s |= X##_f[_i];\t\t\t\t\t\t\t\\\n+    if (!_down)\t\t\t\t\t\t\t\t\\\n+      for (_i = 0; _i <= 7-_skip; ++_i)\t\t\t\t\t\\\n+\tX##_f[_i] = X##_f[_i+_skip];\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t_s |= X##_f[_i] << _up;\t\t\t\t\t\t\\\n+\tfor (_i = 0; _i < 7-_skip; ++_i)\t\t\t\t\\\n+\t  X##_f[_i] = X##_f[_i+_skip] >> _down\t\t\t\t\\\n+\t\t      | X##_f[_i+_skip+1] << _up;\t\t\t\\\n+\tX##_f[_i++] = X##_f[7] >> _down;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    for (; _i < 8; ++_i)\t\t\t\t\t\t\\\n+      X##_f[_i] = 0;\t\t\t\t\t\t\t\\\n+    /* don't fix the LSB until the very end when we're sure f[0] is stable */\t\\\n+    X##_f[0] |= (_s != 0);\t\t\t\t\t\t\\\n+  } while (0)\n+"}, {"sha": "4ec7fade485e04dafa5b24e9b843a5a6b83bf6fc", "filename": "gcc/config/soft-fp/op-common.h", "status": "added", "additions": 1330, "deletions": 0, "changes": 1330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fop-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fop-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fop-common.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,1330 @@\n+/* Software floating-point emulation. Common operations.\n+   Copyright (C) 1997,1998,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com),\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz),\n+\t\t  David S. Miller (davem@redhat.com) and\n+\t\t  Peter Maydell (pmaydell@chiark.greenend.org.uk).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#define _FP_DECL(wc, X)\t\t\t\t\t\t\\\n+  _FP_I_TYPE X##_c __attribute__((unused)), X##_s, X##_e;\t\\\n+  _FP_FRAC_DECL_##wc(X)\n+\n+/*\n+ * Finish truely unpacking a native fp value by classifying the kind\n+ * of fp value and normalizing both the exponent and the fraction.\n+ */\n+\n+#define _FP_UNPACK_CANONICAL(fs, wc, X)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  switch (X##_e)\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+  default:\t\t\t\t\t\t\t\t\\\n+    _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_IMPLBIT_##fs;\t\t\t\\\n+    _FP_FRAC_SLL_##wc(X, _FP_WORKBITS);\t\t\t\t\t\\\n+    X##_e -= _FP_EXPBIAS_##fs;\t\t\t\t\t\t\\\n+    X##_c = FP_CLS_NORMAL;\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case 0:\t\t\t\t\t\t\t\t\\\n+    if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t\t\t\\\n+      X##_c = FP_CLS_ZERO;\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t/* a denormalized number */\t\t\t\t\t\\\n+\t_FP_I_TYPE _shift;\t\t\t\t\t\t\\\n+\t_FP_FRAC_CLZ_##wc(_shift, X);\t\t\t\t\t\\\n+\t_shift -= _FP_FRACXBITS_##fs;\t\t\t\t\t\\\n+\t_FP_FRAC_SLL_##wc(X, (_shift+_FP_WORKBITS));\t\t\t\\\n+\tX##_e -= _FP_EXPBIAS_##fs - 1 + _shift;\t\t\t\t\\\n+\tX##_c = FP_CLS_NORMAL;\t\t\t\t\t\t\\\n+\tFP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case _FP_EXPMAX_##fs:\t\t\t\t\t\t\t\\\n+    if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t\t\t\\\n+      X##_c = FP_CLS_INF;\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tX##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+\t/* Check for signaling NaN */\t\t\t\t\t\\\n+\tif (!(_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs))\t\t\\\n+\t  FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Finish unpacking an fp value in semi-raw mode: the mantissa is\n+   shifted by _FP_WORKBITS but the implicit MSB is not inserted and\n+   other classification is not done.  */\n+#define _FP_UNPACK_SEMIRAW(fs, wc, X)\t_FP_FRAC_SLL_##wc(X, _FP_WORKBITS)\n+\n+/* A semi-raw value has overflowed to infinity.  Adjust the mantissa\n+   and exponent appropriately.  */\n+#define _FP_OVERFLOW_SEMIRAW(fs, wc, X)\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+  if (FP_ROUNDMODE == FP_RND_NEAREST\t\t\t\\\n+      || (FP_ROUNDMODE == FP_RND_PINF && !X##_s)\t\\\n+      || (FP_ROUNDMODE == FP_RND_MINF && X##_s))\t\\\n+    {\t\t\t\t\t\t\t\\\n+      X##_e = _FP_EXPMAX_##fs;\t\t\t\t\\\n+      _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      X##_e = _FP_EXPMAX_##fs - 1;\t\t\t\\\n+      FP_SET_EXCEPTION(FP_EX_OVERFLOW);\t\t\t\\\n+      FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\\\n+      _FP_FRAC_SET_##wc(X, _FP_MAXFRAC_##wc);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Check for a semi-raw value being a signaling NaN and raise the\n+   invalid exception if so.  */\n+#define _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if (X##_e == _FP_EXPMAX_##fs\t\t\t\t\t\\\n+      && !_FP_FRAC_ZEROP_##wc(X)\t\t\t\t\\\n+      && !(_FP_FRAC_HIGH_##fs(X) & _FP_QNANBIT_SH_##fs))\t\\\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n+} while (0)\n+\n+/* Choose a NaN result from an operation on two semi-raw NaN\n+   values.  */\n+#define _FP_CHOOSENAN_SEMIRAW(fs, wc, R, X, Y, OP)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  /* _FP_CHOOSENAN expects raw values, so shift as required.  */\t\\\n+  _FP_FRAC_SRL_##wc(X, _FP_WORKBITS);\t\t\t\t\t\\\n+  _FP_FRAC_SRL_##wc(Y, _FP_WORKBITS);\t\t\t\t\t\\\n+  _FP_CHOOSENAN(fs, wc, R, X, Y, OP);\t\t\t\t\t\\\n+  _FP_FRAC_SLL_##wc(R, _FP_WORKBITS);\t\t\t\t\t\\\n+} while (0)\n+\n+/* Test whether a biased exponent is normal (not zero or maximum).  */\n+#define _FP_EXP_NORMAL(fs, wc, X)\t(((X##_e + 1) & _FP_EXPMAX_##fs) > 1)\n+\n+/* Prepare to pack an fp value in semi-raw mode: the mantissa is\n+   rounded and shifted right, with the rounding possibly increasing\n+   the exponent (including changing a finite value to infinity).  */\n+#define _FP_PACK_SEMIRAW(fs, wc, X)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  _FP_ROUND(wc, X);\t\t\t\t\t\t\\\n+  if (_FP_FRAC_HIGH_##fs(X)\t\t\t\t\t\\\n+      & (_FP_OVERFLOW_##fs >> 1))\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_HIGH_##fs(X) &= ~(_FP_OVERFLOW_##fs >> 1);\t\\\n+      X##_e++;\t\t\t\t\t\t\t\\\n+      if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t\\\n+\t_FP_OVERFLOW_SEMIRAW(fs, wc, X);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  _FP_FRAC_SRL_##wc(X, _FP_WORKBITS);\t\t\t\t\\\n+  if (!_FP_EXP_NORMAL(fs, wc, X) && !_FP_FRAC_ZEROP_##wc(X))\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (X##_e == 0)\t\t\t\t\t\t\\\n+\tFP_SET_EXCEPTION(FP_EX_UNDERFLOW);\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (!_FP_KEEPNANFRACP)\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      _FP_FRAC_SET_##wc(X, _FP_NANFRAC_##fs);\t\t\\\n+\t      X##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_QNANBIT_##fs;\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/*\n+ * Before packing the bits back into the native fp result, take care\n+ * of such mundane things as rounding and overflow.  Also, for some\n+ * kinds of fp values, the original parts may not have been fully\n+ * extracted -- but that is ok, we can regenerate them now.\n+ */\n+\n+#define _FP_PACK_CANONICAL(fs, wc, X)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  switch (X##_c)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+  case FP_CLS_NORMAL:\t\t\t\t\t\t\\\n+    X##_e += _FP_EXPBIAS_##fs;\t\t\t\t\t\\\n+    if (X##_e > 0)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\t_FP_ROUND(wc, X);\t\t\t\t\t\\\n+\tif (_FP_FRAC_OVERP_##wc(fs, X))\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    _FP_FRAC_CLEAR_OVERP_##wc(fs, X);\t\t\t\\\n+\t    X##_e++;\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_SRL_##wc(X, _FP_WORKBITS);\t\t\t\\\n+\tif (X##_e >= _FP_EXPMAX_##fs)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    /* overflow */\t\t\t\t\t\\\n+\t    switch (FP_ROUNDMODE)\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\\\n+\t      case FP_RND_NEAREST:\t\t\t\t\\\n+\t\tX##_c = FP_CLS_INF;\t\t\t\t\\\n+\t\tbreak;\t\t\t\t\t\t\\\n+\t      case FP_RND_PINF:\t\t\t\t\t\\\n+\t\tif (!X##_s) X##_c = FP_CLS_INF;\t\t\t\\\n+\t\tbreak;\t\t\t\t\t\t\\\n+\t      case FP_RND_MINF:\t\t\t\t\t\\\n+\t\tif (X##_s) X##_c = FP_CLS_INF;\t\t\t\\\n+\t\tbreak;\t\t\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\\\n+\t    if (X##_c == FP_CLS_INF)\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\\\n+\t\t/* Overflow to infinity */\t\t\t\\\n+\t\tX##_e = _FP_EXPMAX_##fs;\t\t\t\\\n+\t\t_FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\\\n+\t      }\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\\\n+\t\t/* Overflow to maximum normal */\t\t\\\n+\t\tX##_e = _FP_EXPMAX_##fs - 1;\t\t\t\\\n+\t\t_FP_FRAC_SET_##wc(X, _FP_MAXFRAC_##wc);\t\t\\\n+\t      }\t\t\t\t\t\t\t\\\n+\t    FP_SET_EXCEPTION(FP_EX_OVERFLOW);\t\t\t\\\n+            FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\t/* we've got a denormalized number */\t\t\t\\\n+\tX##_e = -X##_e + 1;\t\t\t\t\t\\\n+\tif (X##_e <= _FP_WFRACBITS_##fs)\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    _FP_FRAC_SRS_##wc(X, X##_e, _FP_WFRACBITS_##fs);\t\\\n+\t    _FP_ROUND(wc, X);\t\t\t\t\t\\\n+\t    if (_FP_FRAC_HIGH_##fs(X)\t\t\t\t\\\n+\t\t& (_FP_OVERFLOW_##fs >> 1))\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\\\n+\t        X##_e = 1;\t\t\t\t\t\\\n+\t        _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\\\n+\t      }\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\\\n+\t\tX##_e = 0;\t\t\t\t\t\\\n+\t\t_FP_FRAC_SRL_##wc(X, _FP_WORKBITS);\t\t\\\n+\t\tFP_SET_EXCEPTION(FP_EX_UNDERFLOW);\t\t\\\n+\t      }\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    /* underflow to zero */\t\t\t\t\\\n+\t    X##_e = 0;\t\t\t\t\t\t\\\n+\t    if (!_FP_FRAC_ZEROP_##wc(X))\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\\\n+\t        _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);\t\t\\\n+\t        _FP_ROUND(wc, X);\t\t\t\t\\\n+\t        _FP_FRAC_LOW_##wc(X) >>= (_FP_WORKBITS);\t\\\n+\t      }\t\t\t\t\t\t\t\\\n+\t    FP_SET_EXCEPTION(FP_EX_UNDERFLOW);\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  case FP_CLS_ZERO:\t\t\t\t\t\t\\\n+    X##_e = 0;\t\t\t\t\t\t\t\\\n+    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\t\t\\\n+    break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  case FP_CLS_INF:\t\t\t\t\t\t\\\n+    X##_e = _FP_EXPMAX_##fs;\t\t\t\t\t\\\n+    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\t\t\\\n+    break;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  case FP_CLS_NAN:\t\t\t\t\t\t\\\n+    X##_e = _FP_EXPMAX_##fs;\t\t\t\t\t\\\n+    if (!_FP_KEEPNANFRACP)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_SET_##wc(X, _FP_NANFRAC_##fs);\t\t\t\\\n+\tX##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_QNANBIT_##fs;\t\t\\\n+    break;\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This one accepts raw argument and not cooked,  returns\n+ * 1 if X is a signaling NaN.\n+ */\n+#define _FP_ISSIGNAN(fs, wc, X)\t\t\t\t\t\\\n+({\t\t\t\t\t\t\t\t\\\n+  int __ret = 0;\t\t\t\t\t\t\\\n+  if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!_FP_FRAC_ZEROP_##wc(X)\t\t\t\t\\\n+\t  && !(_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs))\t\\\n+\t__ret = 1;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  __ret;\t\t\t\t\t\t\t\\\n+})\n+\n+\n+\n+\n+\n+/* Addition on semi-raw values.  */\n+#define _FP_ADD_INTERNAL(fs, wc, R, X, Y, OP)\t\t\t\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+  if (X##_s == Y##_s)\t\t\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      /* Addition.  */\t\t\t\t\t\t\t \\\n+      R##_s = X##_s;\t\t\t\t\t\t\t \\\n+      int ediff = X##_e - Y##_e;\t\t\t\t\t \\\n+      if (ediff > 0)\t\t\t\t\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  R##_e = X##_e;\t\t\t\t\t\t \\\n+\t  if (Y##_e == 0)\t\t\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      /* Y is zero or denormalized.  */\t\t\t\t \\\n+\t      if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n+\t\t  _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n+\t\t  goto add_done;\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t      else\t\t\t\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n+\t\t  ediff--;\t\t\t\t\t\t \\\n+\t\t  if (ediff == 0)\t\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      _FP_FRAC_ADD_##wc(R, X, Y);\t\t\t \\\n+\t\t      goto add3;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t \\\n+\t\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n+\t\t      goto add_done;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  goto add1;\t\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  else if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      /* X is NaN or Inf, Y is normal.  */\t\t\t \\\n+\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n+\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t\t \\\n+\t      goto add_done;\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+\t  /* Insert implicit MSB of Y.  */\t\t\t\t \\\n+\t  _FP_FRAC_HIGH_##fs(Y) |= _FP_IMPLBIT_SH_##fs;\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+\tadd1:\t\t\t\t\t\t\t\t \\\n+\t  /* Shift the mantissa of Y to the right EDIFF steps;\t\t \\\n+\t     remember to account later for the implicit MSB of X.  */\t \\\n+\t  if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t \\\n+\t    _FP_FRAC_SRS_##wc(Y, ediff, _FP_WFRACBITS_##fs);\t\t \\\n+\t  else if (!_FP_FRAC_ZEROP_##wc(Y))\t\t\t\t \\\n+\t    _FP_FRAC_SET_##wc(Y, _FP_MINFRAC_##wc);\t\t\t \\\n+\t  _FP_FRAC_ADD_##wc(R, X, Y);\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+      else if (ediff < 0)\t\t\t\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  ediff = -ediff;\t\t\t\t\t\t \\\n+\t  R##_e = Y##_e;\t\t\t\t\t\t \\\n+\t  if (X##_e == 0)\t\t\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      /* X is zero or denormalized.  */\t\t\t\t \\\n+\t      if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n+\t\t  _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n+\t\t  goto add_done;\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t      else\t\t\t\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n+\t\t  ediff--;\t\t\t\t\t\t \\\n+\t\t  if (ediff == 0)\t\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      _FP_FRAC_ADD_##wc(R, Y, X);\t\t\t \\\n+\t\t      goto add3;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t \\\n+\t\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n+\t\t      goto add_done;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  goto add2;\t\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  else if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      /* Y is NaN or Inf, X is normal.  */\t\t\t \\\n+\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n+\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t\t \\\n+\t      goto add_done;\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+\t  /* Insert implicit MSB of X.  */\t\t\t\t \\\n+\t  _FP_FRAC_HIGH_##fs(X) |= _FP_IMPLBIT_SH_##fs;\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+\tadd2:\t\t\t\t\t\t\t\t \\\n+\t  /* Shift the mantissa of X to the right EDIFF steps;\t\t \\\n+\t     remember to account later for the implicit MSB of Y.  */\t \\\n+\t  if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t \\\n+\t    _FP_FRAC_SRS_##wc(X, ediff, _FP_WFRACBITS_##fs);\t\t \\\n+\t  else if (!_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n+\t    _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);\t\t\t \\\n+\t  _FP_FRAC_ADD_##wc(R, Y, X);\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+      else\t\t\t\t\t\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  /* ediff == 0.  */\t\t\t\t\t\t \\\n+\t  if (!_FP_EXP_NORMAL(fs, wc, X))\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      if (X##_e == 0)\t\t\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  /* X and Y are zero or denormalized.  */\t\t \\\n+\t\t  R##_e = 0;\t\t\t\t\t\t \\\n+\t\t  if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      if (!_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n+\t\t\tFP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n+\t\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n+\t\t      goto add_done;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  else if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n+\t\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n+\t\t      goto add_done;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  else\t\t\t\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n+\t\t      _FP_FRAC_ADD_##wc(R, X, Y);\t\t\t \\\n+\t\t      if (_FP_FRAC_HIGH_##fs(R) & _FP_IMPLBIT_SH_##fs)\t \\\n+\t\t\t{\t\t\t\t\t\t \\\n+\t\t\t  /* Normalized result.  */\t\t\t \\\n+\t\t\t  _FP_FRAC_HIGH_##fs(R)\t\t\t\t \\\n+\t\t\t    &= ~(_FP_W_TYPE)_FP_IMPLBIT_SH_##fs;\t \\\n+\t\t\t  R##_e = 1;\t\t\t\t\t \\\n+\t\t\t}\t\t\t\t\t\t \\\n+\t\t      goto add_done;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t      else\t\t\t\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  /* X and Y are NaN or Inf.  */\t\t\t \\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n+\t\t  R##_e = _FP_EXPMAX_##fs;\t\t\t\t \\\n+\t\t  if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n+\t\t    _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n+\t\t  else if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n+\t\t    _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n+\t\t  else\t\t\t\t\t\t\t \\\n+\t\t    _FP_CHOOSENAN_SEMIRAW(fs, wc, R, X, Y, OP);\t\t \\\n+\t\t  goto add_done;\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  /* The exponents of X and Y, both normal, are equal.  The\t \\\n+\t     implicit MSBs will always add to increase the\t\t \\\n+\t     exponent.  */\t\t\t\t\t\t \\\n+\t  _FP_FRAC_ADD_##wc(R, X, Y);\t\t\t\t\t \\\n+\t  R##_e = X##_e + 1;\t\t\t\t\t\t \\\n+\t  _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);\t\t\t \\\n+\t  if (R##_e == _FP_EXPMAX_##fs)\t\t\t\t\t \\\n+\t    /* Overflow to infinity (depending on rounding mode).  */\t \\\n+\t    _FP_OVERFLOW_SEMIRAW(fs, wc, R);\t\t\t\t \\\n+\t  goto add_done;\t\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+    add3:\t\t\t\t\t\t\t\t \\\n+      if (_FP_FRAC_HIGH_##fs(R) & _FP_IMPLBIT_SH_##fs)\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  /* Overflow.  */\t\t\t\t\t\t \\\n+\t  _FP_FRAC_HIGH_##fs(R) &= ~(_FP_W_TYPE)_FP_IMPLBIT_SH_##fs;\t \\\n+\t  R##_e++;\t\t\t\t\t\t\t \\\n+\t  _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);\t\t\t \\\n+\t  if (R##_e == _FP_EXPMAX_##fs)\t\t\t\t\t \\\n+\t    /* Overflow to infinity (depending on rounding mode).  */\t \\\n+\t    _FP_OVERFLOW_SEMIRAW(fs, wc, R);\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+    add_done: ;\t\t\t\t\t\t\t\t \\\n+    }\t\t\t\t\t\t\t\t\t \\\n+  else\t\t\t\t\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      /* Subtraction.  */\t\t\t\t\t\t \\\n+      int ediff = X##_e - Y##_e;\t\t\t\t\t \\\n+      if (ediff > 0)\t\t\t\t\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  R##_e = X##_e;\t\t\t\t\t\t \\\n+\t  R##_s = X##_s;\t\t\t\t\t\t \\\n+\t  if (Y##_e == 0)\t\t\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      /* Y is zero or denormalized.  */\t\t\t\t \\\n+\t      if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n+\t\t  _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n+\t\t  goto sub_done;\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t      else\t\t\t\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n+\t\t  ediff--;\t\t\t\t\t\t \\\n+\t\t  if (ediff == 0)\t\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      _FP_FRAC_SUB_##wc(R, X, Y);\t\t\t \\\n+\t\t      goto sub3;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t \\\n+\t\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n+\t\t      goto sub_done;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  goto sub1;\t\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  else if (X##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      /* X is NaN or Inf, Y is normal.  */\t\t\t \\\n+\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n+\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t\t \\\n+\t      goto sub_done;\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+\t  /* Insert implicit MSB of Y.  */\t\t\t\t \\\n+\t  _FP_FRAC_HIGH_##fs(Y) |= _FP_IMPLBIT_SH_##fs;\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+\tsub1:\t\t\t\t\t\t\t\t \\\n+\t  /* Shift the mantissa of Y to the right EDIFF steps;\t\t \\\n+\t     remember to account later for the implicit MSB of X.  */\t \\\n+\t  if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t \\\n+\t    _FP_FRAC_SRS_##wc(Y, ediff, _FP_WFRACBITS_##fs);\t\t \\\n+\t  else if (!_FP_FRAC_ZEROP_##wc(Y))\t\t\t\t \\\n+\t    _FP_FRAC_SET_##wc(Y, _FP_MINFRAC_##wc);\t\t\t \\\n+\t  _FP_FRAC_SUB_##wc(R, X, Y);\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+      else if (ediff < 0)\t\t\t\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  ediff = -ediff;\t\t\t\t\t\t \\\n+\t  R##_e = Y##_e;\t\t\t\t\t\t \\\n+\t  R##_s = Y##_s;\t\t\t\t\t\t \\\n+\t  if (X##_e == 0)\t\t\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      /* X is zero or denormalized.  */\t\t\t\t \\\n+\t      if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n+\t\t  _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n+\t\t  goto sub_done;\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t      else\t\t\t\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n+\t\t  ediff--;\t\t\t\t\t\t \\\n+\t\t  if (ediff == 0)\t\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      _FP_FRAC_SUB_##wc(R, Y, X);\t\t\t \\\n+\t\t      goto sub3;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t \\\n+\t\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n+\t\t      goto sub_done;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  goto sub2;\t\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  else if (Y##_e == _FP_EXPMAX_##fs)\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      /* Y is NaN or Inf, X is normal.  */\t\t\t \\\n+\t      _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n+\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t\t \\\n+\t      goto sub_done;\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+\t  /* Insert implicit MSB of X.  */\t\t\t\t \\\n+\t  _FP_FRAC_HIGH_##fs(X) |= _FP_IMPLBIT_SH_##fs;\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+\tsub2:\t\t\t\t\t\t\t\t \\\n+\t  /* Shift the mantissa of X to the right EDIFF steps;\t\t \\\n+\t     remember to account later for the implicit MSB of Y.  */\t \\\n+\t  if (ediff <= _FP_WFRACBITS_##fs)\t\t\t\t \\\n+\t    _FP_FRAC_SRS_##wc(X, ediff, _FP_WFRACBITS_##fs);\t\t \\\n+\t  else if (!_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n+\t    _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);\t\t\t \\\n+\t  _FP_FRAC_SUB_##wc(R, Y, X);\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+      else\t\t\t\t\t\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  /* ediff == 0.  */\t\t\t\t\t\t \\\n+\t  if (!_FP_EXP_NORMAL(fs, wc, X))\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      if (X##_e == 0)\t\t\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  /* X and Y are zero or denormalized.  */\t\t \\\n+\t\t  R##_e = 0;\t\t\t\t\t\t \\\n+\t\t  if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t \\\n+\t\t      if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n+\t\t\tR##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\t \\\n+\t\t      else\t\t\t\t\t\t \\\n+\t\t\t{\t\t\t\t\t\t \\\n+\t\t\t  FP_SET_EXCEPTION(FP_EX_DENORM);\t\t \\\n+\t\t\t  R##_s = Y##_s;\t\t\t\t \\\n+\t\t\t}\t\t\t\t\t\t \\\n+\t\t      goto sub_done;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  else if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n+\t\t      _FP_FRAC_COPY_##wc(R, X);\t\t\t\t \\\n+\t\t      R##_s = X##_s;\t\t\t\t\t \\\n+\t\t      goto sub_done;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  else\t\t\t\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t \\\n+\t\t      _FP_FRAC_SUB_##wc(R, X, Y);\t\t\t \\\n+\t\t      R##_s = X##_s;\t\t\t\t\t \\\n+\t\t      if (_FP_FRAC_HIGH_##fs(R) & _FP_IMPLBIT_SH_##fs)\t \\\n+\t\t\t{\t\t\t\t\t\t \\\n+\t\t\t  /* |X| < |Y|, negate result.  */\t\t \\\n+\t\t\t  _FP_FRAC_SUB_##wc(R, Y, X);\t\t\t \\\n+\t\t\t  R##_s = Y##_s;\t\t\t\t \\\n+\t\t\t}\t\t\t\t\t\t \\\n+\t\t      else if (_FP_FRAC_ZEROP_##wc(R))\t\t\t \\\n+\t\t\tR##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\t \\\n+\t\t      goto sub_done;\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t      else\t\t\t\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  /* X and Y are NaN or Inf, of opposite signs.  */\t \\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, X);\t\t\t \\\n+\t\t  _FP_CHECK_SIGNAN_SEMIRAW(fs, wc, Y);\t\t\t \\\n+\t\t  R##_e = _FP_EXPMAX_##fs;\t\t\t\t \\\n+\t\t  if (_FP_FRAC_ZEROP_##wc(X))\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n+\t\t\t{\t\t\t\t\t\t \\\n+\t\t\t  /* Inf - Inf.  */\t\t\t\t \\\n+\t\t\t  R##_s = _FP_NANSIGN_##fs;\t\t\t \\\n+\t\t\t  _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);\t \\\n+\t\t\t  _FP_FRAC_SLL_##wc(R, _FP_WORKBITS);\t\t \\\n+\t\t\t  FP_SET_EXCEPTION(FP_EX_INVALID);\t\t \\\n+\t\t\t}\t\t\t\t\t\t \\\n+\t\t      else\t\t\t\t\t\t \\\n+\t\t\t{\t\t\t\t\t\t \\\n+\t\t\t  /* Inf - NaN.  */\t\t\t\t \\\n+\t\t\t  R##_s = Y##_s;\t\t\t\t \\\n+\t\t\t  _FP_FRAC_COPY_##wc(R, Y);\t\t\t \\\n+\t\t\t}\t\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  else\t\t\t\t\t\t\t \\\n+\t\t    {\t\t\t\t\t\t\t \\\n+\t\t      if (_FP_FRAC_ZEROP_##wc(Y))\t\t\t \\\n+\t\t\t{\t\t\t\t\t\t \\\n+\t\t\t  /* NaN - Inf.  */\t\t\t\t \\\n+\t\t\t  R##_s = X##_s;\t\t\t\t \\\n+\t\t\t  _FP_FRAC_COPY_##wc(R, X);\t\t\t \\\n+\t\t\t}\t\t\t\t\t\t \\\n+\t\t      else\t\t\t\t\t\t \\\n+\t\t\t{\t\t\t\t\t\t \\\n+\t\t\t  /* NaN - NaN.  */\t\t\t\t \\\n+\t\t\t  _FP_CHOOSENAN_SEMIRAW(fs, wc, R, X, Y, OP);\t \\\n+\t\t\t}\t\t\t\t\t\t \\\n+\t\t    }\t\t\t\t\t\t\t \\\n+\t\t  goto sub_done;\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  /* The exponents of X and Y, both normal, are equal.  The\t \\\n+\t     implicit MSBs cancel.  */\t\t\t\t\t \\\n+\t  R##_e = X##_e;\t\t\t\t\t\t \\\n+\t  _FP_FRAC_SUB_##wc(R, X, Y);\t\t\t\t\t \\\n+\t  R##_s = X##_s;\t\t\t\t\t\t \\\n+\t  if (_FP_FRAC_HIGH_##fs(R) & _FP_IMPLBIT_SH_##fs)\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      /* |X| < |Y|, negate result.  */\t\t\t\t \\\n+\t      _FP_FRAC_SUB_##wc(R, Y, X);\t\t\t\t \\\n+\t      R##_s = Y##_s;\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  else if (_FP_FRAC_ZEROP_##wc(R))\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      R##_e = 0;\t\t\t\t\t\t \\\n+\t      R##_s = (FP_ROUNDMODE == FP_RND_MINF);\t\t\t \\\n+\t      goto sub_done;\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  goto norm;\t\t\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+    sub3:\t\t\t\t\t\t\t\t \\\n+      if (_FP_FRAC_HIGH_##fs(R) & _FP_IMPLBIT_SH_##fs)\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  int diff;\t\t\t\t\t\t\t \\\n+\t  /* Carry into most significant bit of larger one of X and Y,\t \\\n+\t     canceling it; renormalize.  */\t\t\t\t \\\n+\t  _FP_FRAC_HIGH_##fs(R) &= _FP_IMPLBIT_SH_##fs - 1;\t\t \\\n+\tnorm:\t\t\t\t\t\t\t\t \\\n+\t  _FP_FRAC_CLZ_##wc(diff, R);\t\t\t\t\t \\\n+\t  diff -= _FP_WFRACXBITS_##fs;\t\t\t\t\t \\\n+\t  _FP_FRAC_SLL_##wc(R, diff);\t\t\t\t\t \\\n+\t  if (R##_e <= diff)\t\t\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      /* R is denormalized.  */\t\t\t\t\t \\\n+\t      diff = diff - R##_e + 1;\t\t\t\t\t \\\n+\t      _FP_FRAC_SRS_##wc(R, diff, _FP_WFRACBITS_##fs);\t\t \\\n+\t      R##_e = 0;\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  else\t\t\t\t\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      R##_e -= diff;\t\t\t\t\t\t \\\n+\t      _FP_FRAC_HIGH_##fs(R) &= ~(_FP_W_TYPE)_FP_IMPLBIT_SH_##fs; \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+    sub_done: ;\t\t\t\t\t\t\t\t \\\n+    }\t\t\t\t\t\t\t\t\t \\\n+} while (0)\n+\n+#define _FP_ADD(fs, wc, R, X, Y) _FP_ADD_INTERNAL(fs, wc, R, X, Y, '+')\n+#define _FP_SUB(fs, wc, R, X, Y)\t\t\t\t\t    \\\n+  do {\t\t\t\t\t\t\t\t\t    \\\n+    if (!(Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(Y))) Y##_s ^= 1; \\\n+    _FP_ADD_INTERNAL(fs, wc, R, X, Y, '-');\t\t\t\t    \\\n+  } while (0)\n+\n+\n+/*\n+ * Main negation routine.  FIXME -- when we care about setting exception\n+ * bits reliably, this will not do.  We should examine all of the fp classes.\n+ */\n+\n+#define _FP_NEG(fs, wc, R, X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_FRAC_COPY_##wc(R, X);\t\t\\\n+    R##_c = X##_c;\t\t\t\\\n+    R##_e = X##_e;\t\t\t\\\n+    R##_s = 1 ^ X##_s;\t\t\t\\\n+  } while (0)\n+\n+\n+/*\n+ * Main multiplication routine.  The input values should be cooked.\n+ */\n+\n+#define _FP_MUL(fs, wc, R, X, Y)\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+  R##_s = X##_s ^ Y##_s;\t\t\t\t\\\n+  switch (_FP_CLS_COMBINE(X##_c, Y##_c))\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):\t\\\n+    R##_c = FP_CLS_NORMAL;\t\t\t\t\\\n+    R##_e = X##_e + Y##_e + 1;\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    _FP_MUL_MEAT_##fs(R,X,Y);\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    if (_FP_FRAC_OVERP_##wc(fs, R))\t\t\t\\\n+      _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);\t\\\n+    else\t\t\t\t\t\t\\\n+      R##_e--;\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):\t\t\\\n+    _FP_CHOOSENAN(fs, wc, R, X, Y, '*');\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):\t\t\\\n+    R##_s = X##_s;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):\t\\\n+    _FP_FRAC_COPY_##wc(R, X);\t\t\t\t\\\n+    R##_c = X##_c;\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):\t\t\\\n+    R##_s = Y##_s;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):\t\\\n+    _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t\\\n+    R##_c = Y##_c;\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):\t\t\\\n+    R##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\\\n+    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);\t\t\\\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  default:\t\t\t\t\t\t\\\n+    abort();\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+\n+/*\n+ * Main division routine.  The input values should be cooked.\n+ */\n+\n+#define _FP_DIV(fs, wc, R, X, Y)\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+  R##_s = X##_s ^ Y##_s;\t\t\t\t\\\n+  switch (_FP_CLS_COMBINE(X##_c, Y##_c))\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):\t\\\n+    R##_c = FP_CLS_NORMAL;\t\t\t\t\\\n+    R##_e = X##_e - Y##_e;\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+    _FP_DIV_MEAT_##fs(R,X,Y);\t\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):\t\t\\\n+    _FP_CHOOSENAN(fs, wc, R, X, Y, '/');\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):\t\t\\\n+    R##_s = X##_s;\t\t\t\t\t\\\n+    _FP_FRAC_COPY_##wc(R, X);\t\t\t\t\\\n+    R##_c = X##_c;\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):\t\t\\\n+    R##_s = Y##_s;\t\t\t\t\t\\\n+    _FP_FRAC_COPY_##wc(R, Y);\t\t\t\t\\\n+    R##_c = Y##_c;\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):\t\\\n+    R##_c = FP_CLS_ZERO;\t\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):\t\\\n+    FP_SET_EXCEPTION(FP_EX_DIVZERO);\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):\t\\\n+    R##_c = FP_CLS_INF;\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):\t\t\\\n+  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):\t\\\n+    R##_s = _FP_NANSIGN_##fs;\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\\\n+    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);\t\t\\\n+    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\\\n+    break;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+  default:\t\t\t\t\t\t\\\n+    abort();\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+\n+/*\n+ * Main differential comparison routine.  The inputs should be raw not\n+ * cooked.  The return is -1,0,1 for normal values, 2 otherwise.\n+ */\n+\n+#define _FP_CMP(fs, wc, ret, X, Y, un)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    /* NANs are unordered */\t\t\t\t\t\t\\\n+    if ((X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(X))\t\t\\\n+\t|| (Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(Y)))\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tret = un;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tint __is_zero_x;\t\t\t\t\t\t\\\n+\tint __is_zero_y;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t__is_zero_x = (!X##_e && _FP_FRAC_ZEROP_##wc(X)) ? 1 : 0;\t\\\n+\t__is_zero_y = (!Y##_e && _FP_FRAC_ZEROP_##wc(Y)) ? 1 : 0;\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (__is_zero_x && __is_zero_y)\t\t\t\t\t\\\n+\t\tret = 0;\t\t\t\t\t\t\\\n+\telse if (__is_zero_x)\t\t\t\t\t\t\\\n+\t\tret = Y##_s ? 1 : -1;\t\t\t\t\t\\\n+\telse if (__is_zero_y)\t\t\t\t\t\t\\\n+\t\tret = X##_s ? -1 : 1;\t\t\t\t\t\\\n+\telse if (X##_s != Y##_s)\t\t\t\t\t\\\n+\t  ret = X##_s ? -1 : 1;\t\t\t\t\t\t\\\n+\telse if (X##_e > Y##_e)\t\t\t\t\t\t\\\n+\t  ret = X##_s ? -1 : 1;\t\t\t\t\t\t\\\n+\telse if (X##_e < Y##_e)\t\t\t\t\t\t\\\n+\t  ret = X##_s ? 1 : -1;\t\t\t\t\t\t\\\n+\telse if (_FP_FRAC_GT_##wc(X, Y))\t\t\t\t\\\n+\t  ret = X##_s ? -1 : 1;\t\t\t\t\t\t\\\n+\telse if (_FP_FRAC_GT_##wc(Y, X))\t\t\t\t\\\n+\t  ret = X##_s ? 1 : -1;\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  ret = 0;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/* Simplification for strict equality.  */\n+\n+#define _FP_CMP_EQ(fs, wc, ret, X, Y)\t\t\t\t\t    \\\n+  do {\t\t\t\t\t\t\t\t\t    \\\n+    /* NANs are unordered */\t\t\t\t\t\t    \\\n+    if ((X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(X))\t\t    \\\n+\t|| (Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(Y)))\t    \\\n+      {\t\t\t\t\t\t\t\t\t    \\\n+\tret = 1;\t\t\t\t\t\t\t    \\\n+      }\t\t\t\t\t\t\t\t\t    \\\n+    else\t\t\t\t\t\t\t\t    \\\n+      {\t\t\t\t\t\t\t\t\t    \\\n+\tret = !(X##_e == Y##_e\t\t\t\t\t\t    \\\n+\t\t&& _FP_FRAC_EQ_##wc(X, Y)\t\t\t\t    \\\n+\t\t&& (X##_s == Y##_s || (!X##_e && _FP_FRAC_ZEROP_##wc(X)))); \\\n+      }\t\t\t\t\t\t\t\t\t    \\\n+  } while (0)\n+\n+/* Version to test unordered.  */\n+\n+#define _FP_CMP_UNORD(fs, wc, ret, X, Y)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ret = ((X##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(X))\t\\\n+\t   || (Y##_e == _FP_EXPMAX_##fs && !_FP_FRAC_ZEROP_##wc(Y)));\t\\\n+  } while (0)\n+\n+/*\n+ * Main square root routine.  The input value should be cooked.\n+ */\n+\n+#define _FP_SQRT(fs, wc, R, X)\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+    _FP_FRAC_DECL_##wc(T); _FP_FRAC_DECL_##wc(S);\t\t\t\\\n+    _FP_W_TYPE q;\t\t\t\t\t\t\t\\\n+    switch (X##_c)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case FP_CLS_NAN:\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R, X);\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\t\\\n+    \tR##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+    \tbreak;\t\t\t\t\t\t\t\t\\\n+    case FP_CLS_INF:\t\t\t\t\t\t\t\\\n+    \tif (X##_s)\t\t\t\t\t\t\t\\\n+    \t  {\t\t\t\t\t\t\t\t\\\n+    \t    R##_s = _FP_NANSIGN_##fs;\t\t\t\t\t\\\n+\t    R##_c = FP_CLS_NAN; /* NAN */\t\t\t\t\\\n+\t    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);\t\t\t\\\n+\t    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n+    \t  }\t\t\t\t\t\t\t\t\\\n+    \telse\t\t\t\t\t\t\t\t\\\n+    \t  {\t\t\t\t\t\t\t\t\\\n+    \t    R##_s = 0;\t\t\t\t\t\t\t\\\n+    \t    R##_c = FP_CLS_INF; /* sqrt(+inf) = +inf */\t\t\t\\\n+    \t  }\t\t\t\t\t\t\t\t\\\n+    \tbreak;\t\t\t\t\t\t\t\t\\\n+    case FP_CLS_ZERO:\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\t\\\n+\tR##_c = FP_CLS_ZERO; /* sqrt(+-0) = +-0 */\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+    case FP_CLS_NORMAL:\t\t\t\t\t\t\t\\\n+    \tR##_s = 0;\t\t\t\t\t\t\t\\\n+        if (X##_s)\t\t\t\t\t\t\t\\\n+          {\t\t\t\t\t\t\t\t\\\n+\t    R##_c = FP_CLS_NAN; /* sNAN */\t\t\t\t\\\n+\t    R##_s = _FP_NANSIGN_##fs;\t\t\t\t\t\\\n+\t    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);\t\t\t\\\n+\t    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+          }\t\t\t\t\t\t\t\t\\\n+    \tR##_c = FP_CLS_NORMAL;\t\t\t\t\t\t\\\n+        if (X##_e & 1)\t\t\t\t\t\t\t\\\n+          _FP_FRAC_SLL_##wc(X, 1);\t\t\t\t\t\\\n+        R##_e = X##_e >> 1;\t\t\t\t\t\t\\\n+        _FP_FRAC_SET_##wc(S, _FP_ZEROFRAC_##wc);\t\t\t\\\n+        _FP_FRAC_SET_##wc(R, _FP_ZEROFRAC_##wc);\t\t\t\\\n+        q = _FP_OVERFLOW_##fs >> 1;\t\t\t\t\t\\\n+        _FP_SQRT_MEAT_##wc(R, S, T, X, q);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/*\n+ * Convert from FP to integer.  Input is raw.\n+ */\n+\n+/* RSIGNED can have following values:\n+ * 0:  the number is required to be 0..(2^rsize)-1, if not, NV is set plus\n+ *     the result is either 0 or (2^rsize)-1 depending on the sign in such\n+ *     case.\n+ * 1:  the number is required to be -(2^(rsize-1))..(2^(rsize-1))-1, if not,\n+ *     NV is set plus the result is either -(2^(rsize-1)) or (2^(rsize-1))-1\n+ *     depending on the sign in such case.\n+ * -1: the number is required to be -(2^(rsize-1))..(2^rsize)-1, if not, NV is\n+ *     set plus the result is either -(2^(rsize-1)) or (2^(rsize-1))-1\n+ *     depending on the sign in such case.\n+ */\n+#define _FP_TO_INT(fs, wc, r, X, rsize, rsigned)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (X##_e < _FP_EXPBIAS_##fs)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      r = 0;\t\t\t\t\t\t\t\t\\\n+      if (X##_e == 0)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (!_FP_FRAC_ZEROP_##wc(X))\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\t\\\n+\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tFP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (X##_e >= _FP_EXPBIAS_##fs + rsize - (rsigned > 0 || X##_s)\t\\\n+\t   || (!rsigned && X##_s))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* Overflow or converting to the most negative integer.  */\t\\\n+      if (rsigned)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  r = 1;\t\t\t\t\t\t\t\\\n+\t  r <<= rsize - 1;\t\t\t\t\t\t\\\n+\t  r -= 1 - X##_s;\t\t\t\t\t\t\\\n+\t} else {\t\t\t\t\t\t\t\\\n+\t  r = 0;\t\t\t\t\t\t\t\\\n+\t  if (X##_s)\t\t\t\t\t\t\t\\\n+\t    r = ~r;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (rsigned && X##_s && X##_e == _FP_EXPBIAS_##fs + rsize - 1)\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* Possibly converting to most negative integer; check the\t\\\n+\t     mantissa.  */\t\t\t\t\t\t\\\n+\t  int inexact = 0;\t\t\t\t\t\t\\\n+\t  (void)((_FP_FRACBITS_##fs > rsize)\t\t\t\t\\\n+\t\t ? ({ _FP_FRAC_SRST_##wc(X, inexact,\t\t\t\\\n+\t\t\t\t\t _FP_FRACBITS_##fs - rsize,\t\\\n+\t\t\t\t\t _FP_FRACBITS_##fs); 0; })\t\\\n+\t\t : 0);\t\t\t\t\t\t\t\\\n+\t  if (!_FP_FRAC_ZEROP_##wc(X))\t\t\t\t\t\\\n+\t    FP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n+\t  else if (inexact)\t\t\t\t\t\t\\\n+\t    FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tFP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_IMPLBIT_##fs;\t\t\t\\\n+      if (X##_e >= _FP_EXPBIAS_##fs + _FP_FRACBITS_##fs - 1)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);\t\t\t\t\\\n+\t  r <<= X##_e - _FP_EXPBIAS_##fs - _FP_FRACBITS_##fs + 1;\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  int inexact;\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SRST_##wc(X, inexact,\t\t\t\t\\\n+\t\t\t    (_FP_FRACBITS_##fs + _FP_EXPBIAS_##fs - 1\t\\\n+\t\t\t     - X##_e),\t\t\t\t\t\\\n+\t\t\t    _FP_FRACBITS_##fs);\t\t\t\t\\\n+\t  if (inexact)\t\t\t\t\t\t\t\\\n+\t    FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\t\\\n+\t  _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (rsigned && X##_s)\t\t\t\t\t\t\\\n+\tr = -r;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Convert integer to fp.  Output is raw.  RTYPE is unsigned even if\n+   input is signed.  */\n+#define _FP_FROM_INT(fs, wc, X, r, rsize, rtype)\t\t\t     \\\n+  do {\t\t\t\t\t\t\t\t\t     \\\n+    if (r)\t\t\t\t\t\t\t\t     \\\n+      {\t\t\t\t\t\t\t\t\t     \\\n+\trtype ur_;\t\t\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+\tif ((X##_s = (r < 0)))\t\t\t\t\t\t     \\\n+\t  r = -(rtype)r;\t\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+\tur_ = (rtype) r;\t\t\t\t\t\t     \\\n+\t(void)((rsize <= _FP_W_TYPE_SIZE)\t\t\t\t     \\\n+\t       ? ({\t\t\t\t\t\t\t     \\\n+\t\t    int lz_;\t\t\t\t\t\t     \\\n+\t\t    __FP_CLZ(lz_, (_FP_W_TYPE)ur_);\t\t\t     \\\n+\t\t    X##_e = _FP_EXPBIAS_##fs + _FP_W_TYPE_SIZE - 1 - lz_;    \\\n+\t\t  })\t\t\t\t\t\t\t     \\\n+\t       : ((rsize <= 2 * _FP_W_TYPE_SIZE)\t\t\t     \\\n+\t\t  ? ({\t\t\t\t\t\t\t     \\\n+\t\t       int lz_;\t\t\t\t\t\t     \\\n+\t\t       __FP_CLZ_2(lz_, (_FP_W_TYPE)(ur_ >> _FP_W_TYPE_SIZE), \\\n+\t\t\t\t  (_FP_W_TYPE)ur_);\t\t\t     \\\n+\t\t       X##_e = (_FP_EXPBIAS_##fs + 2 * _FP_W_TYPE_SIZE - 1   \\\n+\t\t\t\t- lz_);\t\t\t\t\t     \\\n+\t\t     })\t\t\t\t\t\t\t     \\\n+\t\t  : (abort(), 0)));\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+\tif (rsize - 1 + _FP_EXPBIAS_##fs >= _FP_EXPMAX_##fs\t\t     \\\n+\t    && X##_e >= _FP_EXPMAX_##fs)\t\t\t\t     \\\n+\t  {\t\t\t\t\t\t\t\t     \\\n+\t    /* Exponent too big; overflow to infinity.  (May also\t     \\\n+\t       happen after rounding below.)  */\t\t\t     \\\n+\t    _FP_OVERFLOW_SEMIRAW(fs, wc, X);\t\t\t\t     \\\n+\t    goto pack_semiraw;\t\t\t\t\t\t     \\\n+\t  }\t\t\t\t\t\t\t\t     \\\n+\t\t\t\t\t\t\t\t\t     \\\n+\tif (rsize <= _FP_FRACBITS_##fs\t\t\t\t\t     \\\n+\t    || X##_e < _FP_EXPBIAS_##fs + _FP_FRACBITS_##fs)\t\t     \\\n+\t  {\t\t\t\t\t\t\t\t     \\\n+\t    /* Exactly representable; shift left.  */\t\t\t     \\\n+\t    _FP_FRAC_DISASSEMBLE_##wc(X, ur_, rsize);\t\t\t     \\\n+\t    _FP_FRAC_SLL_##wc(X, (_FP_EXPBIAS_##fs\t\t\t     \\\n+\t\t\t\t  + _FP_FRACBITS_##fs - 1 - X##_e));\t     \\\n+\t  }\t\t\t\t\t\t\t\t     \\\n+\telse\t\t\t\t\t\t\t\t     \\\n+\t  {\t\t\t\t\t\t\t\t     \\\n+\t    /* More bits in integer than in floating type; need to\t     \\\n+\t       round.  */\t\t\t\t\t\t     \\\n+\t    if (_FP_EXPBIAS_##fs + _FP_WFRACBITS_##fs - 1 < X##_e)\t     \\\n+\t      ur_ = ((ur_ >> (X##_e - _FP_EXPBIAS_##fs\t\t\t     \\\n+\t\t\t      - _FP_WFRACBITS_##fs + 1))\t\t     \\\n+\t\t     | ((ur_ << (rsize - (X##_e - _FP_EXPBIAS_##fs\t     \\\n+\t\t\t\t\t  - _FP_WFRACBITS_##fs + 1)))\t     \\\n+\t\t\t!= 0));\t\t\t\t\t\t     \\\n+\t    _FP_FRAC_DISASSEMBLE_##wc(X, ur_, rsize);\t\t\t     \\\n+\t    if ((_FP_EXPBIAS_##fs + _FP_WFRACBITS_##fs - 1 - X##_e) > 0)     \\\n+\t      _FP_FRAC_SLL_##wc(X, (_FP_EXPBIAS_##fs\t\t\t     \\\n+\t\t\t\t    + _FP_WFRACBITS_##fs - 1 - X##_e));\t     \\\n+\t    _FP_FRAC_HIGH_##fs(X) &= ~(_FP_W_TYPE)_FP_IMPLBIT_SH_##fs;\t     \\\n+\t  pack_semiraw:\t\t\t\t\t\t\t     \\\n+\t    _FP_PACK_SEMIRAW(fs, wc, X);\t\t\t\t     \\\n+\t  }\t\t\t\t\t\t\t\t     \\\n+      }\t\t\t\t\t\t\t\t\t     \\\n+    else\t\t\t\t\t\t\t\t     \\\n+      {\t\t\t\t\t\t\t\t\t     \\\n+\tX##_s = 0;\t\t\t\t\t\t\t     \\\n+\tX##_e = 0;\t\t\t\t\t\t\t     \\\n+\t_FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);\t\t\t     \\\n+      }\t\t\t\t\t\t\t\t\t     \\\n+  } while (0)\n+\n+\n+/* Extend from a narrower floating-point format to a wider one.  Input\n+   and output are raw.  */\n+#define FP_EXTEND(dfs,sfs,dwc,swc,D,S)\t\t\t\t\t \\\n+do {\t\t\t\t\t\t\t\t\t \\\n+  if (_FP_FRACBITS_##dfs < _FP_FRACBITS_##sfs\t\t\t\t \\\n+      || (_FP_EXPMAX_##dfs - _FP_EXPBIAS_##dfs\t\t\t\t \\\n+\t  < _FP_EXPMAX_##sfs - _FP_EXPBIAS_##sfs)\t\t\t \\\n+      || _FP_EXPBIAS_##dfs < _FP_EXPBIAS_##sfs + _FP_FRACBITS_##sfs - 1) \\\n+    abort();\t\t\t\t\t\t\t\t \\\n+  D##_s = S##_s;\t\t\t\t\t\t\t \\\n+  _FP_FRAC_COPY_##dwc##_##swc(D, S);\t\t\t\t\t \\\n+  if (_FP_EXP_NORMAL(sfs, swc, S))\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      D##_e = S##_e + _FP_EXPBIAS_##dfs - _FP_EXPBIAS_##sfs;\t\t \\\n+      _FP_FRAC_SLL_##dwc(D, (_FP_FRACBITS_##dfs - _FP_FRACBITS_##sfs));\t \\\n+    }\t\t\t\t\t\t\t\t\t \\\n+  else\t\t\t\t\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      if (S##_e == 0)\t\t\t\t\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  if (_FP_FRAC_ZEROP_##swc(S))\t\t\t\t\t \\\n+\t    D##_e = 0;\t\t\t\t\t\t\t \\\n+\t  else\t\t\t\t\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      int _lz;\t\t\t\t\t\t\t \\\n+\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t \\\n+\t      _FP_FRAC_CLZ_##swc(_lz, S);\t\t\t\t \\\n+\t      _FP_FRAC_SLL_##dwc(D,\t\t\t\t\t \\\n+\t\t\t\t _lz + _FP_FRACBITS_##dfs\t\t \\\n+\t\t\t\t - _FP_FRACTBITS_##sfs);\t\t \\\n+\t      D##_e = (_FP_EXPBIAS_##dfs - _FP_EXPBIAS_##sfs + 1\t \\\n+\t\t       + _FP_FRACXBITS_##sfs - _lz);\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+      else\t\t\t\t\t\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  D##_e = _FP_EXPMAX_##dfs;\t\t\t\t\t \\\n+\t  if (!_FP_FRAC_ZEROP_##swc(S))\t\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      if (!(_FP_FRAC_HIGH_RAW_##sfs(S) & _FP_QNANBIT_##sfs))\t \\\n+\t\tFP_SET_EXCEPTION(FP_EX_INVALID);\t\t\t \\\n+\t      _FP_FRAC_SLL_##dwc(D, (_FP_FRACBITS_##dfs\t\t\t \\\n+\t\t\t\t     - _FP_FRACBITS_##sfs));\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+    }\t\t\t\t\t\t\t\t\t \\\n+} while (0)\n+\n+/* Truncate from a wider floating-point format to a narrower one.\n+   Input and output are semi-raw.  */\n+#define FP_TRUNC(dfs,sfs,dwc,swc,D,S)\t\t\t\t\t     \\\n+do {\t\t\t\t\t\t\t\t\t     \\\n+  if (_FP_FRACBITS_##sfs < _FP_FRACBITS_##dfs\t\t\t\t     \\\n+      || _FP_EXPBIAS_##sfs < _FP_EXPBIAS_##dfs + _FP_FRACBITS_##dfs - 1)     \\\n+    abort();\t\t\t\t\t\t\t\t     \\\n+  D##_s = S##_s;\t\t\t\t\t\t\t     \\\n+  if (_FP_EXP_NORMAL(sfs, swc, S))\t\t\t\t\t     \\\n+    {\t\t\t\t\t\t\t\t\t     \\\n+      D##_e = S##_e + _FP_EXPBIAS_##dfs - _FP_EXPBIAS_##sfs;\t\t     \\\n+      if (D##_e >= _FP_EXPMAX_##dfs)\t\t\t\t\t     \\\n+\t_FP_OVERFLOW_SEMIRAW(dfs, dwc, D);\t\t\t\t     \\\n+      else\t\t\t\t\t\t\t\t     \\\n+\t{\t\t\t\t\t\t\t\t     \\\n+\t  if (D##_e <= 0)\t\t\t\t\t\t     \\\n+\t    {\t\t\t\t\t\t\t\t     \\\n+\t      if (D##_e <= 1 - _FP_FRACBITS_##dfs)\t\t\t     \\\n+\t\t_FP_FRAC_SET_##swc(S, _FP_ZEROFRAC_##swc);\t\t     \\\n+\t      else\t\t\t\t\t\t\t     \\\n+\t\t{\t\t\t\t\t\t\t     \\\n+\t\t  _FP_FRAC_HIGH_##sfs(S) |= _FP_IMPLBIT_SH_##sfs;\t     \\\n+\t\t  _FP_FRAC_SRS_##swc(S, (_FP_WFRACBITS_##sfs\t\t     \\\n+\t\t\t\t\t - _FP_WFRACBITS_##dfs + 1 - D##_e), \\\n+\t\t\t\t     _FP_WFRACBITS_##sfs);\t\t     \\\n+\t\t}\t\t\t\t\t\t\t     \\\n+\t      D##_e = 0;\t\t\t\t\t\t     \\\n+\t    }\t\t\t\t\t\t\t\t     \\\n+\t  else\t\t\t\t\t\t\t\t     \\\n+\t    _FP_FRAC_SRS_##swc(S, (_FP_WFRACBITS_##sfs\t\t\t     \\\n+\t\t\t\t   - _FP_WFRACBITS_##dfs),\t\t     \\\n+\t\t\t       _FP_WFRACBITS_##sfs);\t\t\t     \\\n+\t  _FP_FRAC_COPY_##dwc##_##swc(D, S);\t\t\t\t     \\\n+\t}\t\t\t\t\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t\t\t     \\\n+  else\t\t\t\t\t\t\t\t\t     \\\n+    {\t\t\t\t\t\t\t\t\t     \\\n+      if (S##_e == 0)\t\t\t\t\t\t\t     \\\n+\t{\t\t\t\t\t\t\t\t     \\\n+\t  D##_e = 0;\t\t\t\t\t\t\t     \\\n+\t  _FP_FRAC_SET_##dwc(D, _FP_ZEROFRAC_##dwc);\t\t\t     \\\n+\t  if (!_FP_FRAC_ZEROP_##swc(S))\t\t\t\t\t     \\\n+\t    {\t\t\t\t\t\t\t\t     \\\n+\t      FP_SET_EXCEPTION(FP_EX_DENORM);\t\t\t\t     \\\n+\t      FP_SET_EXCEPTION(FP_EX_INEXACT);\t\t\t\t     \\\n+\t    }\t\t\t\t\t\t\t\t     \\\n+\t}\t\t\t\t\t\t\t\t     \\\n+      else\t\t\t\t\t\t\t\t     \\\n+\t{\t\t\t\t\t\t\t\t     \\\n+\t  D##_e = _FP_EXPMAX_##dfs;\t\t\t\t\t     \\\n+\t  if (_FP_FRAC_ZEROP_##swc(S))\t\t\t\t\t     \\\n+\t    _FP_FRAC_SET_##dwc(D, _FP_ZEROFRAC_##dwc);\t\t\t     \\\n+\t  else\t\t\t\t\t\t\t\t     \\\n+\t    {\t\t\t\t\t\t\t\t     \\\n+\t      _FP_CHECK_SIGNAN_SEMIRAW(sfs, swc, S);\t\t\t     \\\n+\t      _FP_FRAC_SRL_##swc(S, (_FP_WFRACBITS_##sfs\t\t     \\\n+\t\t\t\t     - _FP_WFRACBITS_##dfs));\t\t     \\\n+\t      _FP_FRAC_COPY_##dwc##_##swc(D, S);\t\t\t     \\\n+\t      _FP_FRAC_HIGH_##dfs(D) |= _FP_QNANBIT_SH_##dfs;\t\t     \\\n+\t    }\t\t\t\t\t\t\t\t     \\\n+\t}\t\t\t\t\t\t\t\t     \\\n+    }\t\t\t\t\t\t\t\t\t     \\\n+} while (0)\n+\n+/*\n+ * Helper primitives.\n+ */\n+\n+/* Count leading zeros in a word.  */\n+\n+#ifndef __FP_CLZ\n+/* GCC 3.4 and later provide the builtins for us.  */\n+#define __FP_CLZ(r, x)\t\t\t\t\t\t\t      \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    if (sizeof (_FP_W_TYPE) == sizeof (unsigned int))\t\t\t      \\\n+      r = __builtin_clz (x);\t\t\t\t\t\t      \\\n+    else if (sizeof (_FP_W_TYPE) == sizeof (unsigned long))\t\t      \\\n+      r = __builtin_clzl (x);\t\t\t\t\t\t      \\\n+    else if (sizeof (_FP_W_TYPE) == sizeof (unsigned long long))\t      \\\n+      r = __builtin_clzll (x);\t\t\t\t\t\t      \\\n+    else\t\t\t\t\t\t\t\t      \\\n+      abort ();\t\t\t\t\t\t\t\t      \\\n+  } while (0)\n+#endif /* ndef __FP_CLZ */\n+\n+#define _FP_DIV_HELP_imm(q, r, n, d)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    q = n / d, r = n % d;\t\t\t\\\n+  } while (0)\n+\n+\n+/* A restoring bit-by-bit division primitive.  */\n+\n+#define _FP_DIV_MEAT_N_loop(fs, wc, R, X, Y)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    int count = _FP_WFRACBITS_##fs;\t\t\t\t\t\\\n+    _FP_FRAC_DECL_##wc (u);\t\t\t\t\t\t\\\n+    _FP_FRAC_DECL_##wc (v);\t\t\t\t\t\t\\\n+    _FP_FRAC_COPY_##wc (u, X);\t\t\t\t\t\t\\\n+    _FP_FRAC_COPY_##wc (v, Y);\t\t\t\t\t\t\\\n+    _FP_FRAC_SET_##wc (R, _FP_ZEROFRAC_##wc);\t\t\t\t\\\n+    /* Normalize U and V.  */\t\t\t\t\t\t\\\n+    _FP_FRAC_SLL_##wc (u, _FP_WFRACXBITS_##fs);\t\t\t\t\\\n+    _FP_FRAC_SLL_##wc (v, _FP_WFRACXBITS_##fs);\t\t\t\t\\\n+    /* First round.  Since the operands are normalized, either the\t\\\n+       first or second bit will be set in the fraction.  Produce a\t\\\n+       normalized result by checking which and adjusting the loop\t\\\n+       count and exponent accordingly.  */\t\t\t\t\\\n+    if (_FP_FRAC_GE_1 (u, v))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t_FP_FRAC_SUB_##wc (u, u, v);\t\t\t\t\t\\\n+\t_FP_FRAC_LOW_##wc (R) |= 1;\t\t\t\t\t\\\n+\tcount--;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      R##_e--;\t\t\t\t\t\t\t\t\\\n+    /* Subsequent rounds.  */\t\t\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+      int msb = (_FP_WS_TYPE) _FP_FRAC_HIGH_##wc (u) < 0;\t\t\\\n+      _FP_FRAC_SLL_##wc (u, 1);\t\t\t\t\t\t\\\n+      _FP_FRAC_SLL_##wc (R, 1);\t\t\t\t\t\t\\\n+      if (msb || _FP_FRAC_GE_1 (u, v))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  _FP_FRAC_SUB_##wc (u, u, v);\t\t\t\t\t\\\n+\t  _FP_FRAC_LOW_##wc (R) |= 1;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    } while (--count > 0);\t\t\t\t\t\t\\\n+    /* If there's anything left in U, the result is inexact.  */\t\\\n+    _FP_FRAC_LOW_##wc (R) |= !_FP_FRAC_ZEROP_##wc (u);\t\t\t\\\n+  } while (0)\n+\n+#define _FP_DIV_MEAT_1_loop(fs, R, X, Y)  _FP_DIV_MEAT_N_loop (fs, 1, R, X, Y)\n+#define _FP_DIV_MEAT_2_loop(fs, R, X, Y)  _FP_DIV_MEAT_N_loop (fs, 2, R, X, Y)\n+#define _FP_DIV_MEAT_4_loop(fs, R, X, Y)  _FP_DIV_MEAT_N_loop (fs, 4, R, X, Y)"}, {"sha": "d7840ff06623c0ab8cc89d77e9719c1cb48b16dd", "filename": "gcc/config/soft-fp/quad.h", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fquad.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fquad.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fquad.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,271 @@\n+/* Software floating-point emulation.\n+   Definitions for IEEE Quad Precision.\n+   Copyright (C) 1997,1998,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com),\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz),\n+\t\t  David S. Miller (davem@redhat.com) and\n+\t\t  Peter Maydell (pmaydell@chiark.greenend.org.uk).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#if _FP_W_TYPE_SIZE < 32\n+#error \"Here's a nickel, kid. Go buy yourself a real computer.\"\n+#endif\n+\n+#if _FP_W_TYPE_SIZE < 64\n+#define _FP_FRACTBITS_Q         (4*_FP_W_TYPE_SIZE)\n+#else\n+#define _FP_FRACTBITS_Q\t\t(2*_FP_W_TYPE_SIZE)\n+#endif\n+\n+#define _FP_FRACBITS_Q\t\t113\n+#define _FP_FRACXBITS_Q\t\t(_FP_FRACTBITS_Q - _FP_FRACBITS_Q)\n+#define _FP_WFRACBITS_Q\t\t(_FP_WORKBITS + _FP_FRACBITS_Q)\n+#define _FP_WFRACXBITS_Q\t(_FP_FRACTBITS_Q - _FP_WFRACBITS_Q)\n+#define _FP_EXPBITS_Q\t\t15\n+#define _FP_EXPBIAS_Q\t\t16383\n+#define _FP_EXPMAX_Q\t\t32767\n+\n+#define _FP_QNANBIT_Q\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_Q-2) % _FP_W_TYPE_SIZE)\n+#define _FP_QNANBIT_SH_Q\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_Q-2+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+#define _FP_IMPLBIT_Q\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_Q-1) % _FP_W_TYPE_SIZE)\n+#define _FP_IMPLBIT_SH_Q\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_FRACBITS_Q-1+_FP_WORKBITS) % _FP_W_TYPE_SIZE)\n+#define _FP_OVERFLOW_Q\t\t\\\n+\t((_FP_W_TYPE)1 << (_FP_WFRACBITS_Q % _FP_W_TYPE_SIZE))\n+\n+typedef float TFtype __attribute__((mode(TF)));\n+\n+#if _FP_W_TYPE_SIZE < 64\n+\n+union _FP_UNION_Q\n+{\n+   TFtype flt;\n+   struct \n+   {\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+      unsigned sign : 1;\n+      unsigned exp : _FP_EXPBITS_Q;\n+      unsigned long frac3 : _FP_FRACBITS_Q - (_FP_IMPLBIT_Q != 0)-(_FP_W_TYPE_SIZE * 3);\n+      unsigned long frac2 : _FP_W_TYPE_SIZE;\n+      unsigned long frac1 : _FP_W_TYPE_SIZE;\n+      unsigned long frac0 : _FP_W_TYPE_SIZE;\n+#else\n+      unsigned long frac0 : _FP_W_TYPE_SIZE;\n+      unsigned long frac1 : _FP_W_TYPE_SIZE;\n+      unsigned long frac2 : _FP_W_TYPE_SIZE;\n+      unsigned long frac3 : _FP_FRACBITS_Q - (_FP_IMPLBIT_Q != 0)-(_FP_W_TYPE_SIZE * 3);\n+      unsigned exp : _FP_EXPBITS_Q;\n+      unsigned sign : 1;\n+#endif /* not bigendian */\n+   } bits __attribute__((packed));\n+};\n+\n+\n+#define FP_DECL_Q(X)\t\t_FP_DECL(4,X)\n+#define FP_UNPACK_RAW_Q(X,val)\t_FP_UNPACK_RAW_4(Q,X,val)\n+#define FP_UNPACK_RAW_QP(X,val)\t_FP_UNPACK_RAW_4_P(Q,X,val)\n+#define FP_PACK_RAW_Q(val,X)\t_FP_PACK_RAW_4(Q,val,X)\n+#define FP_PACK_RAW_QP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_4_P(Q,val,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_Q(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_4(Q,X,val);\t\t\\\n+    _FP_UNPACK_CANONICAL(Q,4,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_QP(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_4_P(Q,X,val);\t\\\n+    _FP_UNPACK_CANONICAL(Q,4,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_Q(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_4(Q,X,val);\t\t\\\n+    _FP_UNPACK_SEMIRAW(Q,4,X);\t\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_QP(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_4_P(Q,X,val);\t\\\n+    _FP_UNPACK_SEMIRAW(Q,4,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_Q(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(Q,4,X);\t\t\\\n+    _FP_PACK_RAW_4(Q,val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_QP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(Q,4,X);\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_4_P(Q,val,X);\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_Q(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(Q,4,X);\t\t\\\n+    _FP_PACK_RAW_4(Q,val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_QP(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(Q,4,X);\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_4_P(Q,val,X);\t\\\n+  } while (0)\n+\n+#define FP_ISSIGNAN_Q(X)\t\t_FP_ISSIGNAN(Q,4,X)\n+#define FP_NEG_Q(R,X)\t\t\t_FP_NEG(Q,4,R,X)\n+#define FP_ADD_Q(R,X,Y)\t\t\t_FP_ADD(Q,4,R,X,Y)\n+#define FP_SUB_Q(R,X,Y)\t\t\t_FP_SUB(Q,4,R,X,Y)\n+#define FP_MUL_Q(R,X,Y)\t\t\t_FP_MUL(Q,4,R,X,Y)\n+#define FP_DIV_Q(R,X,Y)\t\t\t_FP_DIV(Q,4,R,X,Y)\n+#define FP_SQRT_Q(R,X)\t\t\t_FP_SQRT(Q,4,R,X)\n+#define _FP_SQRT_MEAT_Q(R,S,T,X,Q)\t_FP_SQRT_MEAT_4(R,S,T,X,Q)\n+\n+#define FP_CMP_Q(r,X,Y,un)\t_FP_CMP(Q,4,r,X,Y,un)\n+#define FP_CMP_EQ_Q(r,X,Y)\t_FP_CMP_EQ(Q,4,r,X,Y)\n+#define FP_CMP_UNORD_Q(r,X,Y)\t_FP_CMP_UNORD(Q,4,r,X,Y)\n+\n+#define FP_TO_INT_Q(r,X,rsz,rsg)\t_FP_TO_INT(Q,4,r,X,rsz,rsg)\n+#define FP_FROM_INT_Q(X,r,rs,rt)\t_FP_FROM_INT(Q,4,X,r,rs,rt)\n+\n+#define _FP_FRAC_HIGH_Q(X)\t_FP_FRAC_HIGH_4(X)\n+#define _FP_FRAC_HIGH_RAW_Q(X)\t_FP_FRAC_HIGH_4(X)\n+\n+#else   /* not _FP_W_TYPE_SIZE < 64 */\n+union _FP_UNION_Q\n+{\n+  TFtype flt /* __attribute__((mode(TF))) */ ;\n+  struct {\n+    _FP_W_TYPE a, b;\n+  } longs;\n+  struct {\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+    unsigned sign  : 1;\n+    unsigned exp   : _FP_EXPBITS_Q;\n+    unsigned long frac1 : _FP_FRACBITS_Q-(_FP_IMPLBIT_Q != 0)-_FP_W_TYPE_SIZE;\n+    unsigned long frac0 : _FP_W_TYPE_SIZE;\n+#else\n+    unsigned long frac0 : _FP_W_TYPE_SIZE;\n+    unsigned long frac1 : _FP_FRACBITS_Q-(_FP_IMPLBIT_Q != 0)-_FP_W_TYPE_SIZE;\n+    unsigned exp   : _FP_EXPBITS_Q;\n+    unsigned sign  : 1;\n+#endif\n+  } bits;\n+};\n+\n+#define FP_DECL_Q(X)\t\t_FP_DECL(2,X)\n+#define FP_UNPACK_RAW_Q(X,val)\t_FP_UNPACK_RAW_2(Q,X,val)\n+#define FP_UNPACK_RAW_QP(X,val)\t_FP_UNPACK_RAW_2_P(Q,X,val)\n+#define FP_PACK_RAW_Q(val,X)\t_FP_PACK_RAW_2(Q,val,X)\n+#define FP_PACK_RAW_QP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_2_P(Q,val,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_Q(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_2(Q,X,val);\t\t\\\n+    _FP_UNPACK_CANONICAL(Q,2,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_QP(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_2_P(Q,X,val);\t\\\n+    _FP_UNPACK_CANONICAL(Q,2,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_Q(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_2(Q,X,val);\t\t\\\n+    _FP_UNPACK_SEMIRAW(Q,2,X);\t\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_QP(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_2_P(Q,X,val);\t\\\n+    _FP_UNPACK_SEMIRAW(Q,2,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_Q(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(Q,2,X);\t\t\\\n+    _FP_PACK_RAW_2(Q,val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_QP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(Q,2,X);\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_2_P(Q,val,X);\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_Q(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(Q,2,X);\t\t\\\n+    _FP_PACK_RAW_2(Q,val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_QP(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(Q,2,X);\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_2_P(Q,val,X);\t\\\n+  } while (0)\n+\n+#define FP_ISSIGNAN_Q(X)\t\t_FP_ISSIGNAN(Q,2,X)\n+#define FP_NEG_Q(R,X)\t\t\t_FP_NEG(Q,2,R,X)\n+#define FP_ADD_Q(R,X,Y)\t\t\t_FP_ADD(Q,2,R,X,Y)\n+#define FP_SUB_Q(R,X,Y)\t\t\t_FP_SUB(Q,2,R,X,Y)\n+#define FP_MUL_Q(R,X,Y)\t\t\t_FP_MUL(Q,2,R,X,Y)\n+#define FP_DIV_Q(R,X,Y)\t\t\t_FP_DIV(Q,2,R,X,Y)\n+#define FP_SQRT_Q(R,X)\t\t\t_FP_SQRT(Q,2,R,X)\n+#define _FP_SQRT_MEAT_Q(R,S,T,X,Q)\t_FP_SQRT_MEAT_2(R,S,T,X,Q)\n+\n+#define FP_CMP_Q(r,X,Y,un)\t_FP_CMP(Q,2,r,X,Y,un)\n+#define FP_CMP_EQ_Q(r,X,Y)\t_FP_CMP_EQ(Q,2,r,X,Y)\n+#define FP_CMP_UNORD_Q(r,X,Y)\t_FP_CMP_UNORD(Q,2,r,X,Y)\n+\n+#define FP_TO_INT_Q(r,X,rsz,rsg)\t_FP_TO_INT(Q,2,r,X,rsz,rsg)\n+#define FP_FROM_INT_Q(X,r,rs,rt)\t_FP_FROM_INT(Q,2,X,r,rs,rt)\n+\n+#define _FP_FRAC_HIGH_Q(X)\t_FP_FRAC_HIGH_2(X)\n+#define _FP_FRAC_HIGH_RAW_Q(X)\t_FP_FRAC_HIGH_2(X)\n+\n+#endif /* not _FP_W_TYPE_SIZE < 64 */"}, {"sha": "9c3734adf48f68a7289d30aaf48f09b599ef8960", "filename": "gcc/config/soft-fp/single.h", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fsingle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fsingle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fsingle.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,151 @@\n+/* Software floating-point emulation.\n+   Definitions for IEEE Single Precision.\n+   Copyright (C) 1997,1998,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com),\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz),\n+\t\t  David S. Miller (davem@redhat.com) and\n+\t\t  Peter Maydell (pmaydell@chiark.greenend.org.uk).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#if _FP_W_TYPE_SIZE < 32\n+#error \"Here's a nickel kid.  Go buy yourself a real computer.\"\n+#endif\n+\n+#define _FP_FRACTBITS_S\t\t_FP_W_TYPE_SIZE\n+\n+#define _FP_FRACBITS_S\t\t24\n+#define _FP_FRACXBITS_S\t\t(_FP_FRACTBITS_S - _FP_FRACBITS_S)\n+#define _FP_WFRACBITS_S\t\t(_FP_WORKBITS + _FP_FRACBITS_S)\n+#define _FP_WFRACXBITS_S\t(_FP_FRACTBITS_S - _FP_WFRACBITS_S)\n+#define _FP_EXPBITS_S\t\t8\n+#define _FP_EXPBIAS_S\t\t127\n+#define _FP_EXPMAX_S\t\t255\n+#define _FP_QNANBIT_S\t\t((_FP_W_TYPE)1 << (_FP_FRACBITS_S-2))\n+#define _FP_QNANBIT_SH_S\t((_FP_W_TYPE)1 << (_FP_FRACBITS_S-2+_FP_WORKBITS))\n+#define _FP_IMPLBIT_S\t\t((_FP_W_TYPE)1 << (_FP_FRACBITS_S-1))\n+#define _FP_IMPLBIT_SH_S\t((_FP_W_TYPE)1 << (_FP_FRACBITS_S-1+_FP_WORKBITS))\n+#define _FP_OVERFLOW_S\t\t((_FP_W_TYPE)1 << (_FP_WFRACBITS_S))\n+\n+/* The implementation of _FP_MUL_MEAT_S and _FP_DIV_MEAT_S should be\n+   chosen by the target machine.  */\n+\n+typedef float SFtype __attribute__((mode(SF)));\n+\n+union _FP_UNION_S\n+{\n+  SFtype flt;\n+  struct {\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+    unsigned sign : 1;\n+    unsigned exp  : _FP_EXPBITS_S;\n+    unsigned frac : _FP_FRACBITS_S - (_FP_IMPLBIT_S != 0);\n+#else\n+    unsigned frac : _FP_FRACBITS_S - (_FP_IMPLBIT_S != 0);\n+    unsigned exp  : _FP_EXPBITS_S;\n+    unsigned sign : 1;\n+#endif\n+  } bits __attribute__((packed));\n+};\n+\n+#define FP_DECL_S(X)\t\t_FP_DECL(1,X)\n+#define FP_UNPACK_RAW_S(X,val)\t_FP_UNPACK_RAW_1(S,X,val)\n+#define FP_UNPACK_RAW_SP(X,val)\t_FP_UNPACK_RAW_1_P(S,X,val)\n+#define FP_PACK_RAW_S(val,X)\t_FP_PACK_RAW_1(S,val,X)\n+#define FP_PACK_RAW_SP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_1_P(S,val,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_S(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_1(S,X,val);\t\t\\\n+    _FP_UNPACK_CANONICAL(S,1,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SP(X,val)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_1_P(S,X,val);\t\\\n+    _FP_UNPACK_CANONICAL(S,1,X);\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_S(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_1(S,X,val);\t\t\\\n+    _FP_UNPACK_SEMIRAW(S,1,X);\t\t\\\n+  } while (0)\n+\n+#define FP_UNPACK_SEMIRAW_SP(X,val)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_UNPACK_RAW_1_P(S,X,val);\t\\\n+    _FP_UNPACK_SEMIRAW(S,1,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_S(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(S,1,X);\t\t\\\n+    _FP_PACK_RAW_1(S,val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_SP(val,X)\t\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_CANONICAL(S,1,X);\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_1_P(S,val,X);\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_S(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(S,1,X);\t\t\\\n+    _FP_PACK_RAW_1(S,val,X);\t\t\\\n+  } while (0)\n+\n+#define FP_PACK_SEMIRAW_SP(val,X)\t\\\n+  do {\t\t\t\t\t\\\n+    _FP_PACK_SEMIRAW(S,1,X);\t\t\\\n+    if (!FP_INHIBIT_RESULTS)\t\t\\\n+      _FP_PACK_RAW_1_P(S,val,X);\t\\\n+  } while (0)\n+\n+#define FP_ISSIGNAN_S(X)\t\t_FP_ISSIGNAN(S,1,X)\n+#define FP_NEG_S(R,X)\t\t\t_FP_NEG(S,1,R,X)\n+#define FP_ADD_S(R,X,Y)\t\t\t_FP_ADD(S,1,R,X,Y)\n+#define FP_SUB_S(R,X,Y)\t\t\t_FP_SUB(S,1,R,X,Y)\n+#define FP_MUL_S(R,X,Y)\t\t\t_FP_MUL(S,1,R,X,Y)\n+#define FP_DIV_S(R,X,Y)\t\t\t_FP_DIV(S,1,R,X,Y)\n+#define FP_SQRT_S(R,X)\t\t\t_FP_SQRT(S,1,R,X)\n+#define _FP_SQRT_MEAT_S(R,S,T,X,Q)\t_FP_SQRT_MEAT_1(R,S,T,X,Q)\n+\n+#define FP_CMP_S(r,X,Y,un)\t_FP_CMP(S,1,r,X,Y,un)\n+#define FP_CMP_EQ_S(r,X,Y)\t_FP_CMP_EQ(S,1,r,X,Y)\n+#define FP_CMP_UNORD_S(r,X,Y)\t_FP_CMP_UNORD(S,1,r,X,Y)\n+\n+#define FP_TO_INT_S(r,X,rsz,rsg)\t_FP_TO_INT(S,1,r,X,rsz,rsg)\n+#define FP_FROM_INT_S(X,r,rs,rt)\t_FP_FROM_INT(S,1,X,r,rs,rt)\n+\n+#define _FP_FRAC_HIGH_S(X)\t_FP_FRAC_HIGH_1(X)\n+#define _FP_FRAC_HIGH_RAW_S(X)\t_FP_FRAC_HIGH_1(X)"}, {"sha": "dbf080e7f489a827f2387eb8c8fa5d2670193671", "filename": "gcc/config/soft-fp/soft-fp.h", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fsoft-fp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fsoft-fp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fsoft-fp.h?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,209 @@\n+/* Software floating-point emulation.\n+   Copyright (C) 1997,1998,1999,2000,2002,2003,2005,2006\n+\tFree Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com),\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz),\n+\t\t  David S. Miller (davem@redhat.com) and\n+\t\t  Peter Maydell (pmaydell@chiark.greenend.org.uk).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#ifndef SOFT_FP_H\n+#define SOFT_FP_H\n+\n+#ifdef _LIBC\n+#include <sfp-machine.h>\n+#else\n+#include \"sfp-machine.h\"\n+#endif\n+\n+/* Allow sfp-machine to have its own byte order definitions. */\n+#ifndef __BYTE_ORDER\n+#ifdef _LIBC\n+#include <endian.h>\n+#else\n+#error \"endianness not defined by sfp-machine.h\"\n+#endif\n+#endif\n+\n+#define _FP_WORKBITS\t\t3\n+#define _FP_WORK_LSB\t\t((_FP_W_TYPE)1 << 3)\n+#define _FP_WORK_ROUND\t\t((_FP_W_TYPE)1 << 2)\n+#define _FP_WORK_GUARD\t\t((_FP_W_TYPE)1 << 1)\n+#define _FP_WORK_STICKY\t\t((_FP_W_TYPE)1 << 0)\n+\n+#ifndef FP_RND_NEAREST\n+# define FP_RND_NEAREST\t\t0\n+# define FP_RND_ZERO\t\t1\n+# define FP_RND_PINF\t\t2\n+# define FP_RND_MINF\t\t3\n+#endif\n+#ifndef FP_ROUNDMODE\n+# define FP_ROUNDMODE\t\tFP_RND_NEAREST\n+#endif\n+\n+/* By default don't care about exceptions. */\n+#ifndef FP_EX_INVALID\n+#define FP_EX_INVALID\t\t0\n+#endif\n+#ifndef FP_EX_OVERFLOW\n+#define FP_EX_OVERFLOW\t\t0\n+#endif\n+#ifndef FP_EX_UNDERFLOW\n+#define FP_EX_UNDERFLOW\t\t0\n+#endif\n+#ifndef FP_EX_DIVZERO\n+#define FP_EX_DIVZERO\t\t0\n+#endif\n+#ifndef FP_EX_INEXACT\n+#define FP_EX_INEXACT\t\t0\n+#endif\n+#ifndef FP_EX_DENORM\n+#define FP_EX_DENORM\t\t0\n+#endif\n+\n+#ifdef _FP_DECL_EX\n+#define FP_DECL_EX\t\t\t\t\t\\\n+  int _fex = 0;\t\t\t\t\t\t\\\n+  _FP_DECL_EX\n+#else\n+#define FP_DECL_EX int _fex = 0\n+#endif\n+\n+#ifndef FP_INIT_ROUNDMODE\n+#define FP_INIT_ROUNDMODE do {} while (0)\n+#endif\n+\n+#ifndef FP_HANDLE_EXCEPTIONS\n+#define FP_HANDLE_EXCEPTIONS do {} while (0)\n+#endif\n+\n+#ifndef FP_INHIBIT_RESULTS\n+/* By default we write the results always.\n+ * sfp-machine may override this and e.g.\n+ * check if some exceptions are unmasked\n+ * and inhibit it in such a case.\n+ */\n+#define FP_INHIBIT_RESULTS 0\n+#endif\n+\n+#define FP_SET_EXCEPTION(ex)\t\t\t\t\\\n+  _fex |= (ex)\n+\n+#define FP_UNSET_EXCEPTION(ex)\t\t\t\t\\\n+  _fex &= ~(ex)\n+\n+#define FP_CLEAR_EXCEPTIONS\t\t\t\t\\\n+  _fex = 0\n+\n+#define _FP_ROUND_NEAREST(wc, X)\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_LOW_##wc(X) & 15) != _FP_WORK_ROUND)\t\\\n+      _FP_FRAC_ADDI_##wc(X, _FP_WORK_ROUND);\t\t\\\n+} while (0)\n+\n+#define _FP_ROUND_ZERO(wc, X)\t\t(void)0\n+\n+#define _FP_ROUND_PINF(wc, X)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+    if (!X##_s && (_FP_FRAC_LOW_##wc(X) & 7))\t\t\\\n+      _FP_FRAC_ADDI_##wc(X, _FP_WORK_LSB);\t\t\\\n+} while (0)\n+\n+#define _FP_ROUND_MINF(wc, X)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+    if (X##_s && (_FP_FRAC_LOW_##wc(X) & 7))\t\t\\\n+      _FP_FRAC_ADDI_##wc(X, _FP_WORK_LSB);\t\t\\\n+} while (0)\n+\n+#define _FP_ROUND(wc, X)\t\t\t\\\n+do {\t\t\t\t\t\t\\\n+\tif (_FP_FRAC_LOW_##wc(X) & 7)\t\t\\\n+\t  FP_SET_EXCEPTION(FP_EX_INEXACT);\t\\\n+\tswitch (FP_ROUNDMODE)\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  case FP_RND_NEAREST:\t\t\t\\\n+\t    _FP_ROUND_NEAREST(wc,X);\t\t\\\n+\t    break;\t\t\t\t\\\n+\t  case FP_RND_ZERO:\t\t\t\\\n+\t    _FP_ROUND_ZERO(wc,X);\t\t\\\n+\t    break;\t\t\t\t\\\n+\t  case FP_RND_PINF:\t\t\t\\\n+\t    _FP_ROUND_PINF(wc,X);\t\t\\\n+\t    break;\t\t\t\t\\\n+\t  case FP_RND_MINF:\t\t\t\\\n+\t    _FP_ROUND_MINF(wc,X);\t\t\\\n+\t    break;\t\t\t\t\\\n+\t}\t\t\t\t\t\\\n+} while (0)\n+\n+#define FP_CLS_NORMAL\t\t0\n+#define FP_CLS_ZERO\t\t1\n+#define FP_CLS_INF\t\t2\n+#define FP_CLS_NAN\t\t3\n+\n+#define _FP_CLS_COMBINE(x,y)\t(((x) << 2) | (y))\n+\n+#include \"op-1.h\"\n+#include \"op-2.h\"\n+#include \"op-4.h\"\n+#include \"op-8.h\"\n+#include \"op-common.h\"\n+\n+/* Sigh.  Silly things longlong.h needs.  */\n+#define UWtype\t\t_FP_W_TYPE\n+#define W_TYPE_SIZE\t_FP_W_TYPE_SIZE\n+\n+typedef int QItype __attribute__((mode(QI)));\n+typedef int SItype __attribute__((mode(SI)));\n+typedef int DItype __attribute__((mode(DI)));\n+typedef unsigned int UQItype __attribute__((mode(QI)));\n+typedef unsigned int USItype __attribute__((mode(SI)));\n+typedef unsigned int UDItype __attribute__((mode(DI)));\n+#if _FP_W_TYPE_SIZE == 32\n+typedef unsigned int UHWtype __attribute__((mode(HI)));\n+#elif _FP_W_TYPE_SIZE == 64\n+typedef USItype UHWtype;\n+#endif\n+\n+#define SI_BITS\t\t(__CHAR_BIT__ * (int)sizeof(SItype))\n+#define DI_BITS\t\t(__CHAR_BIT__ * (int)sizeof(DItype))\n+\n+#ifndef umul_ppmm\n+#ifdef _LIBC\n+#include <stdlib/longlong.h>\n+#else\n+#include \"longlong.h\"\n+#endif\n+#endif\n+\n+#ifdef _LIBC\n+#include <stdlib.h>\n+#else\n+extern void abort (void);\n+#endif\n+\n+#endif"}, {"sha": "3978b52998dac3be2a1d607efeddd920547f931e", "filename": "gcc/config/soft-fp/subdf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fsubdf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fsubdf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fsubdf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a - b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+DFtype __subdf3(DFtype a, DFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A); FP_DECL_D(B); FP_DECL_D(R);\n+  DFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_D(A, a);\n+  FP_UNPACK_SEMIRAW_D(B, b);\n+  FP_SUB_D(R, A, B);\n+  FP_PACK_SEMIRAW_D(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "f1cbdd1ff1f9a64e090b410c1083680ef562ac73", "filename": "gcc/config/soft-fp/subsf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fsubsf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fsubsf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fsubsf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a - b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+SFtype __subsf3(SFtype a, SFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S(A); FP_DECL_S(B); FP_DECL_S(R);\n+  SFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_S(A, a);\n+  FP_UNPACK_SEMIRAW_S(B, b);\n+  FP_SUB_S(R, A, B);\n+  FP_PACK_SEMIRAW_S(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "7ba4c8c5ea0f1b745f8df01893f86e73d9c3251c", "filename": "gcc/config/soft-fp/subtf3.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fsubtf3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Fsubtf3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Fsubtf3.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return a - b\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+TFtype __subtf3(TFtype a, TFtype b)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A); FP_DECL_Q(B); FP_DECL_Q(R);\n+  TFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_Q(A, a);\n+  FP_UNPACK_SEMIRAW_Q(B, b);\n+  FP_SUB_Q(R, A, B);\n+  FP_PACK_SEMIRAW_Q(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "4a3f91e15eef4f01ac9c112eb58caa055e0d173c", "filename": "gcc/config/soft-fp/t-softfp", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ft-softfp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ft-softfp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ft-softfp?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,108 @@\n+# Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+# Boston MA 02110-1301, USA.\n+\n+# Targets using soft-fp should define the following variables:\n+#\n+# softfp_float_modes: a list of soft-float floating-point modes,\n+#                     e.g. sf df\n+# softfp_int_modes: a list of integer modes for which to define conversions,\n+#                   e.g. si di\n+# softfp_extensions: a list of extensions between floating-point modes,\n+#                    e.g. sfdf\n+# softfp_truncations: a list of truncations between floating-point modes,\n+#                     e.g. dfsf\n+# softfp_machine_header: the target sfp-machine.h file (relative to config/),\n+#                        e.g. rs6000/sfp-machine.h\n+#\n+# Extensions and truncations should include those where only one mode\n+# is a soft-float mode; for example, sftf where sf is hard-float and\n+# tf is soft-float.\n+#\n+# If the libgcc2.c functions should not be replaced, also define:\n+#\n+# softfp_exclude_libgcc2 := y\n+#\n+# Avoiding replacing the libgcc2.c functions is a temporary measure\n+# for targets with both hard-float and soft-float multilibs, since\n+# these variables apply for all multilibs.  With toplevel libgcc,\n+# soft-fp can be used conditionally on the multilib instead.\n+#\n+# If the code should not be compiled at all for some multilibs, define:\n+#\n+# softfp_wrap_start: text to put at the start of wrapper source files,\n+#                    output with echo\n+#                    e.g. '#ifndef __powerpc64__'\n+# softfp_wrap_end: text to put at the end of wrapper source files,\n+#                  e.g. '#endif'\n+#\n+# This is another temporary measure.\n+\n+softfp_float_funcs = add$(m)3 div$(m)3 eq$(m)2 ge$(m)2 le$(m)2 mul$(m)3 \\\n+  neg$(m)2 sub$(m)3 unord$(m)2\n+softfp_floatint_funcs = fix$(m)$(i) fixuns$(m)$(i) \\\n+  float$(i)$(m) floatun$(i)$(m)\n+\n+softfp_func_list := \\\n+  $(foreach m,$(softfp_float_modes), \\\n+              $(softfp_float_funcs) \\\n+              $(foreach i,$(softfp_int_modes), \\\n+                          $(softfp_floatint_funcs))) \\\n+  $(foreach e,$(softfp_extensions),extend$(e)2) \\\n+  $(foreach t,$(softfp_truncations),trunc$(t)2)\n+\n+ifeq ($(softfp_exclude_libgcc2),y)\n+# This list is taken from mklibgcc.in and doesn't presently allow for\n+# 64-bit targets where si should become di and di should become ti.\n+softfp_func_list := $(filter-out floatdidf floatdisf fixunsdfsi fixunssfsi \\\n+  fixunsdfdi fixdfdi fixunssfdi fixsfdi fixxfdi fixunsxfdi \\\n+  floatdixf fixunsxfsi fixtfdi fixunstfdi floatditf \\\n+  floatundidf floatundisf floatundixf floatunditf,$(softfp_func_list))\n+endif\n+\n+ifeq ($(softfp_wrap_start),)\n+softfp_file_list := \\\n+  $(addsuffix .c,$(addprefix $(srcdir)/config/soft-fp/,$(softfp_func_list)))\n+else\n+softfp_file_list := $(addsuffix .c,$(softfp_func_list))\n+\n+$(softfp_file_list):\n+\techo $(softfp_wrap_start) > $@\n+\techo '#include \"config/soft-fp/$@\"' >> $@\n+\techo $(softfp_wrap_end) >> $@\n+endif\n+\n+LIB2FUNCS_EXTRA += $(softfp_file_list)\n+\n+ifneq ($(softfp_exclude_libgcc2),y)\n+# Functions in libgcc2.c are excluded for each soft-float mode (a\n+# target may have both soft-float and hard-float modes), for the fixed\n+# list of integer modes (si and di) for which libgcc2.c defines any\n+# such functions.  Depending on the target, the si and di symbols may\n+# in fact define di and ti functions.\n+\n+LIB2FUNCS_EXCLUDE += \\\n+  $(addprefix _,$(foreach m,$(softfp_float_modes), \\\n+                            $(foreach i,si di, \\\n+                                        $(softfp_floatint_funcs))))\n+endif\n+\n+SFP_MACHINE := sfp-machine.h\n+\n+$(SFP_MACHINE): $(srcdir)/config/$(softfp_machine_header)\n+\tcp $(srcdir)/config/$(softfp_machine_header) $(SFP_MACHINE)"}, {"sha": "bd953912e98eb2bbd4461b93bf7cb0e5c5938411", "filename": "gcc/config/soft-fp/truncdfsf2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ftruncdfsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ftruncdfsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ftruncdfsf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,54 @@\n+/* Software floating-point emulation.\n+   Truncate IEEE double into IEEE single\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+#include \"double.h\"\n+\n+SFtype __truncdfsf2(DFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D(A);\n+  FP_DECL_S(R);\n+  SFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_D(A, a);\n+#if _FP_W_TYPE_SIZE < _FP_FRACBITS_D\n+  FP_TRUNC(S,D,1,2,R,A);\n+#else\n+  FP_TRUNC(S,D,1,1,R,A);\n+#endif\n+  FP_PACK_SEMIRAW_S(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "c3827b08abe919c95540efe4cac198c0c41dd12c", "filename": "gcc/config/soft-fp/trunctfdf2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ftrunctfdf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ftrunctfdf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ftrunctfdf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,54 @@\n+/* Software floating-point emulation.\n+   Truncate IEEE quad into IEEE double\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+#include \"quad.h\"\n+\n+DFtype __trunctfdf2(TFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A);\n+  FP_DECL_D(R);\n+  DFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_Q(A, a);\n+#if (2 * _FP_W_TYPE_SIZE) < _FP_FRACBITS_Q\n+  FP_TRUNC(D,Q,2,4,R,A);\n+#else\n+  FP_TRUNC(D,Q,1,2,R,A);\n+#endif\n+  FP_PACK_SEMIRAW_D(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "676c937e20abbaaa86a44618532dc4e19391dd1b", "filename": "gcc/config/soft-fp/trunctfsf2.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ftrunctfsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Ftrunctfsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Ftrunctfsf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,54 @@\n+/* Software floating-point emulation.\n+   Truncate IEEE quad into IEEE single\n+   Copyright (C) 1997,1999,2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Richard Henderson (rth@cygnus.com) and\n+\t\t  Jakub Jelinek (jj@ultra.linux.cz).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+#include \"quad.h\"\n+\n+SFtype __trunctfsf2(TFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q(A);\n+  FP_DECL_S(R);\n+  SFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_Q(A, a);\n+#if (2 * _FP_W_TYPE_SIZE) < _FP_FRACBITS_Q\n+  FP_TRUNC(S,Q,1,4,R,A);\n+#else\n+  FP_TRUNC(S,Q,1,2,R,A);\n+#endif\n+  FP_PACK_SEMIRAW_S(r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "c83a56327591077f09264fbaa2b890bcb7895d75", "filename": "gcc/config/soft-fp/unorddf2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Funorddf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Funorddf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Funorddf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,45 @@\n+/* Software floating-point emulation.\n+   Return 1 iff a or b is a NaN, 0 otherwise.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Joseph Myers (joseph@codesourcery.com).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"double.h\"\n+\n+int\n+__unorddf2(DFtype a, DFtype b)\n+{\n+  FP_DECL_D(A); FP_DECL_D(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_D(A, a);\n+  FP_UNPACK_RAW_D(B, b);\n+  FP_CMP_UNORD_D(r, A, B);\n+\n+  return r;\n+}"}, {"sha": "8de75635660ca05790ffdd9bf915b3d6e6a46549", "filename": "gcc/config/soft-fp/unordsf2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Funordsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Funordsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Funordsf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Return 1 iff a or b is a NaN, 0 otherwise.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Joseph Myers (joseph@codesourcery.com).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"single.h\"\n+\n+int\n+__unordsf2(SFtype a, SFtype b)\n+{\n+  FP_DECL_S(A);\n+  FP_DECL_S(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_S(A, a);\n+  FP_UNPACK_RAW_S(B, b);\n+  FP_CMP_UNORD_S(r, A, B);\n+\n+  return r;\n+}"}, {"sha": "134b1d09b8a16fad7c1dc454b09b35f106ea3ec6", "filename": "gcc/config/soft-fp/unordtf2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Funordtf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fconfig%2Fsoft-fp%2Funordtf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsoft-fp%2Funordtf2.c?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -0,0 +1,46 @@\n+/* Software floating-point emulation.\n+   Return 1 iff a or b is a NaN, 0 otherwise.\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Joseph Myers (joseph@codesourcery.com).\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"soft-fp.h\"\n+#include \"quad.h\"\n+\n+int\n+__unordtf2(TFtype a, TFtype b)\n+{\n+  FP_DECL_Q(A);\n+  FP_DECL_Q(B);\n+  int r;\n+\n+  FP_UNPACK_RAW_Q(A, a);\n+  FP_UNPACK_RAW_Q(B, b);\n+  FP_CMP_UNORD_Q(r, A, B);\n+\n+  return r;\n+}"}, {"sha": "bf320d9e5538e5bef243465d4d8d55070be5953b", "filename": "gcc/mklibgcc.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fmklibgcc.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49721058b7e6479d58affffaaaabc8781ab1b1a7/gcc%2Fmklibgcc.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmklibgcc.in?ref=49721058b7e6479d58affffaaaabc8781ab1b1a7", "patch": "@@ -11,6 +11,7 @@\n # objext\n # LIB1ASMFUNCS\n # LIB2FUNCS_ST\n+# LIB2FUNCS_EXCLUDE\n # LIBGCOV\n # LIB2ADD\n # LIB2ADD_ST \n@@ -158,8 +159,9 @@ else\n fi\n \n # Remove any objects from lib2funcs and LIB2_DIVMOD_FUNCS that are\n-# defined as optimized assembly code in LIB1ASMFUNCS.\n-for name in $LIB1ASMFUNCS; do\n+# defined as optimized assembly code in LIB1ASMFUNCS or as C code\n+# in LIB2FUNCS_EXCLUDE.\n+for name in $LIB1ASMFUNCS $LIB2FUNCS_EXCLUDE; do\n   lib2funcs=`echo $lib2funcs | sed -e 's/^'$name' //' \\\n \t\t\t\t   -e 's/ '$name' / /' \\\n \t\t\t\t   -e 's/ '$name'$//'`"}]}