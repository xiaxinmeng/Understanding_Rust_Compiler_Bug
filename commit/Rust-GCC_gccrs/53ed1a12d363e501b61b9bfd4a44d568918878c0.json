{"sha": "53ed1a12d363e501b61b9bfd4a44d568918878c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNlZDFhMTJkMzYzZTUwMWI2MWI5YmZkNGE0NGQ1Njg5MTg4NzhjMA==", "commit": {"author": {"name": "Bernardo Innocenti", "email": "bernie@develer.com", "date": "2004-07-25T19:09:36Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2004-07-25T19:09:36Z"}, "message": "c-common.c: Rename all identifiers named `new'.\n\n\t* c-common.c: Rename all identifiers named `new'.\n\t* c-decl.c: Likewise.\n\t* gensupport.c: Likewise.\n\t* simplify-rtx.c: Likewise.\n\nFrom-SVN: r85159", "tree": {"sha": "d2cc8faade466b0fef91333b25f7d99df0de4599", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2cc8faade466b0fef91333b25f7d99df0de4599"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53ed1a12d363e501b61b9bfd4a44d568918878c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53ed1a12d363e501b61b9bfd4a44d568918878c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53ed1a12d363e501b61b9bfd4a44d568918878c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53ed1a12d363e501b61b9bfd4a44d568918878c0/comments", "author": {"login": "codewiz", "id": 1184492, "node_id": "MDQ6VXNlcjExODQ0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1184492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/codewiz", "html_url": "https://github.com/codewiz", "followers_url": "https://api.github.com/users/codewiz/followers", "following_url": "https://api.github.com/users/codewiz/following{/other_user}", "gists_url": "https://api.github.com/users/codewiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/codewiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/codewiz/subscriptions", "organizations_url": "https://api.github.com/users/codewiz/orgs", "repos_url": "https://api.github.com/users/codewiz/repos", "events_url": "https://api.github.com/users/codewiz/events{/privacy}", "received_events_url": "https://api.github.com/users/codewiz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bbbcb2e1c4e122b5e10c3439c271ab0e00adbf08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbbcb2e1c4e122b5e10c3439c271ab0e00adbf08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbbcb2e1c4e122b5e10c3439c271ab0e00adbf08"}], "stats": {"total": 117, "additions": 62, "deletions": 55}, "files": [{"sha": "d38c8268c717170cb7d911858754f5b44a8cdc15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ed1a12d363e501b61b9bfd4a44d568918878c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ed1a12d363e501b61b9bfd4a44d568918878c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=53ed1a12d363e501b61b9bfd4a44d568918878c0", "patch": "@@ -1,3 +1,10 @@\n+2004-07-25  Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* c-common.c: Rename all identifiers named `new'.\n+\t* c-decl.c: Likewise.\n+\t* gensupport.c: Likewise.\n+\t* simplify-rtx.c: Likewise.\n+\n 2004-07-25  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c/15360"}, {"sha": "12fbb116cb4812a170a962ac6d7bef144a8cb842", "filename": "gcc/c-common.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ed1a12d363e501b61b9bfd4a44d568918878c0/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ed1a12d363e501b61b9bfd4a44d568918878c0/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=53ed1a12d363e501b61b9bfd4a44d568918878c0", "patch": "@@ -3242,10 +3242,10 @@ disable_builtin_function (const char *name)\n     error (\"cannot disable built-in function `%s'\", name);\n   else\n     {\n-      disabled_builtin *new = xmalloc (sizeof (disabled_builtin));\n-      new->name = name;\n-      new->next = disabled_builtins;\n-      disabled_builtins = new;\n+      disabled_builtin *n = XNEW (disabled_builtin);\n+      n->name = name;\n+      n->next = disabled_builtins;\n+      disabled_builtins = n;\n     }\n }\n "}, {"sha": "31927a456a9217360667f6642b216d21ab8cfa4b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ed1a12d363e501b61b9bfd4a44d568918878c0/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ed1a12d363e501b61b9bfd4a44d568918878c0/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=53ed1a12d363e501b61b9bfd4a44d568918878c0", "patch": "@@ -1731,42 +1731,42 @@ duplicate_decls (tree newdecl, tree olddecl)\n }\n \n \f\n-/* Check whether decl-node NEW shadows an existing declaration.  */\n+/* Check whether decl-node DECL shadows an existing declaration.  */\n static void\n-warn_if_shadowing (tree new)\n+warn_if_shadowing (tree decl)\n {\n   struct c_binding *b;\n \n   /* Shadow warnings wanted?  */\n   if (!warn_shadow\n       /* No shadow warnings for internally generated vars.  */\n-      || DECL_IS_BUILTIN (new)\n+      || DECL_IS_BUILTIN (decl)\n       /* No shadow warnings for vars made for inlining.  */\n-      || DECL_FROM_INLINE (new)\n+      || DECL_FROM_INLINE (decl)\n       /* Don't warn about the parm names in function declarator\n \t within a function declarator.  It would be nice to avoid\n \t warning in any function declarator in a declaration, as\n \t opposed to a definition, but there is no way to tell\n \t it's not a definition at this point.  */\n-      || (TREE_CODE (new) == PARM_DECL && current_scope->outer->parm_flag))\n+      || (TREE_CODE (decl) == PARM_DECL && current_scope->outer->parm_flag))\n     return;\n \n   /* Is anything being shadowed?  Invisible decls do not count.  */\n-  for (b = I_SYMBOL_BINDING (DECL_NAME (new)); b; b = b->shadowed)\n-    if (b->decl && b->decl != new && !b->invisible)\n+  for (b = I_SYMBOL_BINDING (DECL_NAME (decl)); b; b = b->shadowed)\n+    if (b->decl && b->decl != decl && !b->invisible)\n       {\n \ttree old = b->decl;\n \n \tif (TREE_CODE (old) == PARM_DECL)\n-\t  warning (\"%Jdeclaration of '%D' shadows a parameter\", new, new);\n+\t  warning (\"%Jdeclaration of '%D' shadows a parameter\", decl, decl);\n \telse if (DECL_FILE_SCOPE_P (old))\n \t  warning (\"%Jdeclaration of '%D' shadows a global declaration\",\n-\t\t   new, new);\n+\t\t   decl, decl);\n \telse if (TREE_CODE (old) == FUNCTION_DECL && DECL_BUILT_IN (old))\n \t  warning (\"%Jdeclaration of '%D' shadows a built-in function\",\n-\t\t   new, new);\n+\t\t   decl, decl);\n \telse\n-\t  warning (\"%Jdeclaration of '%D' shadows a previous local\", new, new);\n+\t  warning (\"%Jdeclaration of '%D' shadows a previous local\", decl, decl);\n \n \tif (TREE_CODE (old) != FUNCTION_DECL || !DECL_BUILT_IN (old))\n \t  warning (\"%Jshadowed declaration is here\", old);"}, {"sha": "56eff3a43945b28899ae7467679a7c86fd446b96", "filename": "gcc/gensupport.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ed1a12d363e501b61b9bfd4a44d568918878c0/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ed1a12d363e501b61b9bfd4a44d568918878c0/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=53ed1a12d363e501b61b9bfd4a44d568918878c0", "patch": "@@ -675,27 +675,27 @@ alter_test_for_insn (struct queue_elem *ce_elem,\n    adjusted string.  */\n \n static char *\n-shift_output_template (char *new, const char *old, int disp)\n+shift_output_template (char *dest, const char *old, int disp)\n {\n   while (*old)\n     {\n       char c = *old++;\n-      *new++ = c;\n+      *dest++ = c;\n       if (c == '%')\n \t{\n \t  c = *old++;\n \t  if (ISDIGIT ((unsigned char) c))\n \t    c += disp;\n \t  else if (ISALPHA (c))\n \t    {\n-\t      *new++ = c;\n+\t      *dest++ = c;\n \t      c = *old++ + disp;\n \t    }\n-\t  *new++ = c;\n+\t  *dest++ = c;\n \t}\n     }\n \n-  return new;\n+  return dest;\n }\n \n static const char *\n@@ -704,7 +704,7 @@ alter_output_for_insn (struct queue_elem *ce_elem,\n \t\t       int alt, int max_op)\n {\n   const char *ce_out, *insn_out;\n-  char *new, *p;\n+  char *result, *p;\n   size_t len, ce_len, insn_len;\n \n   /* ??? Could coordinate with genoutput to not duplicate code here.  */\n@@ -724,7 +724,7 @@ alter_output_for_insn (struct queue_elem *ce_elem,\n   if (*insn_out == '@')\n     {\n       len = (ce_len + 1) * alt + insn_len + 1;\n-      p = new = xmalloc (len);\n+      p = result = XNEWVEC(char, len);\n \n       do\n \t{\n@@ -748,14 +748,14 @@ alter_output_for_insn (struct queue_elem *ce_elem,\n   else\n     {\n       len = ce_len + 1 + insn_len + 1;\n-      new = xmalloc (len);\n+      result = XNEWVEC (char, len);\n \n-      p = shift_output_template (new, ce_out, max_op);\n+      p = shift_output_template (result, ce_out, max_op);\n       *p++ = ' ';\n       memcpy (p, insn_out, insn_len + 1);\n     }\n \n-  return new;\n+  return result;\n }\n \n /* Replicate insns as appropriate for the given DEFINE_COND_EXEC.  */"}, {"sha": "8fbe750acefc17e71ffc1f8246e305de4c1b43bd", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ed1a12d363e501b61b9bfd4a44d568918878c0/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ed1a12d363e501b61b9bfd4a44d568918878c0/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=53ed1a12d363e501b61b9bfd4a44d568918878c0", "patch": "@@ -240,38 +240,38 @@ simplify_gen_relational (enum rtx_code code, enum machine_mode mode,\n   return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n \f\n-/* Replace all occurrences of OLD in X with NEW and try to simplify the\n+/* Replace all occurrences of OLDX in X with NEWX and try to simplify the\n    resulting RTX.  Return a new RTX which is as simplified as possible.  */\n \n rtx\n-simplify_replace_rtx (rtx x, rtx old, rtx new)\n+simplify_replace_rtx (rtx x, rtx oldx, rtx newx)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n   enum machine_mode op_mode;\n   rtx op0, op1, op2;\n \n-  /* If X is OLD, return NEW.  Otherwise, if this is an expression, try\n+  /* If X is OLDX, return NEWX.  Otherwise, if this is an expression, try\n      to build a new expression substituting recursively.  If we can't do\n      anything, return our input.  */\n \n-  if (x == old)\n-    return new;\n+  if (x == oldx)\n+    return newx;\n \n   switch (GET_RTX_CLASS (code))\n     {\n     case RTX_UNARY:\n       op0 = XEXP (x, 0);\n       op_mode = GET_MODE (op0);\n-      op0 = simplify_replace_rtx (op0, old, new);\n+      op0 = simplify_replace_rtx (op0, oldx, newx);\n       if (op0 == XEXP (x, 0))\n \treturn x;\n       return simplify_gen_unary (code, mode, op0, op_mode);\n \n     case RTX_BIN_ARITH:\n     case RTX_COMM_ARITH:\n-      op0 = simplify_replace_rtx (XEXP (x, 0), old, new);\n-      op1 = simplify_replace_rtx (XEXP (x, 1), old, new);\n+      op0 = simplify_replace_rtx (XEXP (x, 0), oldx, newx);\n+      op1 = simplify_replace_rtx (XEXP (x, 1), oldx, newx);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \treturn x;\n       return simplify_gen_binary (code, mode, op0, op1);\n@@ -281,8 +281,8 @@ simplify_replace_rtx (rtx x, rtx old, rtx new)\n       op0 = XEXP (x, 0);\n       op1 = XEXP (x, 1);\n       op_mode = GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n-      op0 = simplify_replace_rtx (op0, old, new);\n-      op1 = simplify_replace_rtx (op1, old, new);\n+      op0 = simplify_replace_rtx (op0, oldx, newx);\n+      op1 = simplify_replace_rtx (op1, oldx, newx);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \treturn x;\n       return simplify_gen_relational (code, mode, op_mode, op0, op1);\n@@ -291,9 +291,9 @@ simplify_replace_rtx (rtx x, rtx old, rtx new)\n     case RTX_BITFIELD_OPS:\n       op0 = XEXP (x, 0);\n       op_mode = GET_MODE (op0);\n-      op0 = simplify_replace_rtx (op0, old, new);\n-      op1 = simplify_replace_rtx (XEXP (x, 1), old, new);\n-      op2 = simplify_replace_rtx (XEXP (x, 2), old, new);\n+      op0 = simplify_replace_rtx (op0, oldx, newx);\n+      op1 = simplify_replace_rtx (XEXP (x, 1), oldx, newx);\n+      op2 = simplify_replace_rtx (XEXP (x, 2), oldx, newx);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1) && op2 == XEXP (x, 2))\n \treturn x;\n       if (op_mode == VOIDmode)\n@@ -304,7 +304,7 @@ simplify_replace_rtx (rtx x, rtx old, rtx new)\n       /* The only case we try to handle is a SUBREG.  */\n       if (code == SUBREG)\n \t{\n-\t  op0 = simplify_replace_rtx (SUBREG_REG (x), old, new);\n+\t  op0 = simplify_replace_rtx (SUBREG_REG (x), oldx, newx);\n \t  if (op0 == SUBREG_REG (x))\n \t    return x;\n \t  op0 = simplify_gen_subreg (GET_MODE (x), op0,\n@@ -317,15 +317,15 @@ simplify_replace_rtx (rtx x, rtx old, rtx new)\n     case RTX_OBJ:\n       if (code == MEM)\n \t{\n-\t  op0 = simplify_replace_rtx (XEXP (x, 0), old, new);\n+\t  op0 = simplify_replace_rtx (XEXP (x, 0), oldx, newx);\n \t  if (op0 == XEXP (x, 0))\n \t    return x;\n \t  return replace_equiv_address_nv (x, op0);\n \t}\n       else if (code == LO_SUM)\n \t{\n-\t  op0 = simplify_replace_rtx (XEXP (x, 0), old, new);\n-\t  op1 = simplify_replace_rtx (XEXP (x, 1), old, new);\n+\t  op0 = simplify_replace_rtx (XEXP (x, 0), oldx, newx);\n+\t  op1 = simplify_replace_rtx (XEXP (x, 1), oldx, newx);\n \n \t  /* (lo_sum (high x) x) -> x  */\n \t  if (GET_CODE (op0) == HIGH && rtx_equal_p (XEXP (op0, 0), op1))\n@@ -337,8 +337,8 @@ simplify_replace_rtx (rtx x, rtx old, rtx new)\n \t}\n       else if (code == REG)\n \t{\n-\t  if (REG_P (old) && REGNO (x) == REGNO (old))\n-\t    return new;\n+\t  if (REG_P (oldx) && REGNO (x) == REGNO (oldx))\n+\t    return newx;\n \t}\n       break;\n \n@@ -2789,9 +2789,9 @@ simplify_relational_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t    }\n \t  else if (code == EQ)\n \t    {\n-\t      enum rtx_code new = reversed_comparison_code (op0, NULL_RTX);\n-\t      if (new != UNKNOWN)\n-\t        return simplify_gen_relational (new, mode, VOIDmode,\n+\t      enum rtx_code new_code = reversed_comparison_code (op0, NULL_RTX);\n+\t      if (new_code != UNKNOWN)\n+\t        return simplify_gen_relational (new_code, mode, VOIDmode,\n \t\t\t\t\t        XEXP (op0, 0), XEXP (op0, 1));\n \t    }\n \t}\n@@ -3598,7 +3598,7 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n     {\n       enum machine_mode innermostmode = GET_MODE (SUBREG_REG (op));\n       int final_offset = byte + SUBREG_BYTE (op);\n-      rtx new;\n+      rtx newx;\n \n       if (outermode == innermostmode\n \t  && byte == 0 && SUBREG_BYTE (op) == 0)\n@@ -3655,11 +3655,11 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n \t}\n \n       /* Recurse for further possible simplifications.  */\n-      new = simplify_subreg (outermode, SUBREG_REG (op),\n+      newx = simplify_subreg (outermode, SUBREG_REG (op),\n \t\t\t     GET_MODE (SUBREG_REG (op)),\n \t\t\t     final_offset);\n-      if (new)\n-\treturn new;\n+      if (newx)\n+\treturn newx;\n       return gen_rtx_SUBREG (outermode, SUBREG_REG (op), final_offset);\n     }\n \n@@ -3788,7 +3788,7 @@ rtx\n simplify_gen_subreg (enum machine_mode outermode, rtx op,\n \t\t     enum machine_mode innermode, unsigned int byte)\n {\n-  rtx new;\n+  rtx newx;\n   /* Little bit of sanity checking.  */\n   if (innermode == VOIDmode || outermode == VOIDmode\n       || innermode == BLKmode || outermode == BLKmode)\n@@ -3802,9 +3802,9 @@ simplify_gen_subreg (enum machine_mode outermode, rtx op,\n       || byte >= GET_MODE_SIZE (innermode))\n     abort ();\n \n-  new = simplify_subreg (outermode, op, innermode, byte);\n-  if (new)\n-    return new;\n+  newx = simplify_subreg (outermode, op, innermode, byte);\n+  if (newx)\n+    return newx;\n \n   if (GET_CODE (op) == SUBREG || GET_MODE (op) == VOIDmode)\n     return NULL_RTX;"}]}