{"sha": "83a24b1d0d7894b76f1ad1e31dd149f2c6a79baf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNhMjRiMWQwZDc4OTRiNzZmMWFkMWUzMWRkMTQ5ZjJjNmE3OWJhZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-05T17:39:17Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-05T17:39:17Z"}, "message": "(movhi): Simplify code involving jump-table reference.\n\n(load_address): Handle case of jump-table reference; output required label.\n\nFrom-SVN: r7215", "tree": {"sha": "8524451d1947c273c293ca2e6c2b7de6c39cf17c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8524451d1947c273c293ca2e6c2b7de6c39cf17c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83a24b1d0d7894b76f1ad1e31dd149f2c6a79baf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a24b1d0d7894b76f1ad1e31dd149f2c6a79baf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83a24b1d0d7894b76f1ad1e31dd149f2c6a79baf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83a24b1d0d7894b76f1ad1e31dd149f2c6a79baf/comments", "author": null, "committer": null, "parents": [{"sha": "0016a02db305538fdf351b6d1d2923ac7e5b0b39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0016a02db305538fdf351b6d1d2923ac7e5b0b39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0016a02db305538fdf351b6d1d2923ac7e5b0b39"}], "stats": {"total": 52, "additions": 41, "deletions": 11}, "files": [{"sha": "7e4d89e9d506a09eb2d9df09d27f6c852fca75ad", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83a24b1d0d7894b76f1ad1e31dd149f2c6a79baf/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83a24b1d0d7894b76f1ad1e31dd149f2c6a79baf/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=83a24b1d0d7894b76f1ad1e31dd149f2c6a79baf", "patch": "@@ -832,19 +832,15 @@\n   /* Recognize the insn before a tablejump, one that refers\n      to a table of offsets.  Such an insn will need to refer\n      to a label on the insn.  So output one.  Use the label-number\n-     of the table of offsets to generate this label.  */\n+     of the table of offsets to generate this label.  This code,\n+     and similar code below, assumes that there will be at most one\n+     reference to each table.  */\n   if (GET_CODE (operands[1]) == MEM\n       && GET_CODE (XEXP (operands[1], 0)) == PLUS\n-      && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n-\t  || GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == LABEL_REF)\n-      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) != PLUS\n-      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) != PLUS)\n+      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == LABEL_REF\n+      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) != PLUS)\n     {\n-      rtx labelref;\n-      if (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF)\n-\tlabelref = XEXP (XEXP (operands[1], 0), 0);\n-      else\n-\tlabelref = XEXP (XEXP (operands[1], 0), 1);\n+      rtx labelref = XEXP (XEXP (operands[1], 0), 1);\n #if defined (MOTOROLA) && !defined (SGS_SWITCH_TABLES)\n #ifdef SGS\n       asm_fprintf (asm_out_file, \\\"\\\\tset %LLI%d,.+2\\\\n\\\",\n@@ -4946,7 +4942,41 @@\n   [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n \t(match_operand:QI 1 \"address_operand\" \"p\"))]\n   \"\"\n-  \"lea %a1,%0\")\n+  \"*\n+{\n+#ifndef SGS_NO_LI\n+  /* Recognize an insn that refers to a table of offsets.  Such an insn will\n+     need to refer to a label on the insn.  So output one.  Use the\n+     label-number of the table of offsets to generate this label.  This code,\n+     and similar code above, assumes that there will be at most one reference\n+     to each table.  */\n+  if (GET_CODE (operands[1]) == PLUS\n+      && GET_CODE (XEXP (operands[1], 1)) == LABEL_REF\n+      && GET_CODE (XEXP (operands[1], 0)) != PLUS)\n+    {\n+      rtx labelref = XEXP (operands[1], 1);\n+#if defined (MOTOROLA) && !defined (SGS_SWITCH_TABLES)\n+#ifdef SGS\n+      asm_fprintf (asm_out_file, \\\"\\\\tset %LLI%d,.+2\\\\n\\\",\n+\t\t   CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n+#else /* not SGS */\n+      asm_fprintf (asm_out_file, \\\"\\\\t.set %LLI%d,.+2\\\\n\\\",\n+\t           CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n+#endif /* not SGS */\n+#else /* SGS_SWITCH_TABLES or not MOTOROLA */\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"LI\\\",\n+\t\t\t\t CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n+#ifdef SGS_SWITCH_TABLES\n+      /* Set flag saying we need to define the symbol\n+\t LD%n (with value L%n-LI%n) at the end of the switch table.  */\n+      switch_table_difference_label_flag = 1;\n+#endif /* SGS_SWITCH_TABLES */\n+#endif /* SGS_SWITCH_TABLES or not MOTOROLA */\n+    }\n+#endif /* SGS_NO_LI */\n+\n+  return \\\"lea %a1,%0\\\";\n+}\")\n \f\n ;; This is the first machine-dependent peephole optimization.\n ;; It is useful when a floating value is returned from a function call"}]}