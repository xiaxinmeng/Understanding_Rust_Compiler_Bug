{"sha": "418967ca275853a570b0ae566d7022ff38e7cd0d", "node_id": "C_kwDOANBUbNoAKDQxODk2N2NhMjc1ODUzYTU3MGIwYWU1NjZkNzAyMmZmMzhlN2NkMGQ", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2022-04-05T04:28:20Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2022-04-05T04:28:20Z"}, "message": "try multi-reg dest in default_zero_call_used_regs\n\nWhen the mode of regno_reg_rtx is not hard_regno_mode_ok for the\ntarget, try grouping the register with subsequent ones.  This enables\ns16 to s31 and their hidden pairs to be zeroed with the default logic\non some arm variants.\n\n\nfor  gcc/ChangeLog\n\n\t* targhooks.cc (default_zero_call_used_regs): Attempt to group\n\tregs that the target refuses to use in their natural modes.\n\t(zcur_select_mode_rtx): New.\n\t* regs.h (struct target_regs): Add x_hard_regno_max_nregs.\n\t(hard_regno_max_nregs): Define.\n\t* reginfo.cc (init_reg_modes_target): Set hard_regno_max_nregs.", "tree": {"sha": "151cad8b0371780b64ba9d9ded748720d1b66636", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/151cad8b0371780b64ba9d9ded748720d1b66636"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/418967ca275853a570b0ae566d7022ff38e7cd0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/418967ca275853a570b0ae566d7022ff38e7cd0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/418967ca275853a570b0ae566d7022ff38e7cd0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/418967ca275853a570b0ae566d7022ff38e7cd0d/comments", "author": null, "committer": null, "parents": [{"sha": "5e09bb1b2e7ccea480a448fc45db3f3e1c1ae081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e09bb1b2e7ccea480a448fc45db3f3e1c1ae081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e09bb1b2e7ccea480a448fc45db3f3e1c1ae081"}], "stats": {"total": 97, "additions": 86, "deletions": 11}, "files": [{"sha": "67e30cab428557f04536c9f97b80ab63d720c81b", "filename": "gcc/reginfo.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418967ca275853a570b0ae566d7022ff38e7cd0d/gcc%2Freginfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418967ca275853a570b0ae566d7022ff38e7cd0d/gcc%2Freginfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.cc?ref=418967ca275853a570b0ae566d7022ff38e7cd0d", "patch": "@@ -441,10 +441,15 @@ init_reg_modes_target (void)\n {\n   int i, j;\n \n+  this_target_regs->x_hard_regno_max_nregs = 1;\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     for (j = 0; j < MAX_MACHINE_MODE; j++)\n-      this_target_regs->x_hard_regno_nregs[i][j]\n-\t= targetm.hard_regno_nregs (i, (machine_mode) j);\n+      {\n+\tunsigned char nregs = targetm.hard_regno_nregs (i, (machine_mode) j);\n+\tthis_target_regs->x_hard_regno_nregs[i][j] = nregs;\n+\tif (nregs > this_target_regs->x_hard_regno_max_nregs)\n+\t  this_target_regs->x_hard_regno_max_nregs = nregs;\n+      }\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {"}, {"sha": "f72b06fb5650838eb8e264f1ac9a1e9253ce8ffa", "filename": "gcc/regs.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418967ca275853a570b0ae566d7022ff38e7cd0d/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418967ca275853a570b0ae566d7022ff38e7cd0d/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=418967ca275853a570b0ae566d7022ff38e7cd0d", "patch": "@@ -202,6 +202,9 @@ struct target_regs {\n      registers that a given machine mode occupies.  */\n   unsigned char x_hard_regno_nregs[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n \n+  /* The max value found in x_hard_regno_nregs.  */\n+  unsigned char x_hard_regno_max_nregs;\n+\n   /* For each hard register, the widest mode object that it can contain.\n      This will be a MODE_INT mode if the register can hold integers.  Otherwise\n      it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the\n@@ -235,6 +238,8 @@ extern struct target_regs *this_target_regs;\n #else\n #define this_target_regs (&default_target_regs)\n #endif\n+#define hard_regno_max_nregs \\\n+  (this_target_regs->x_hard_regno_max_nregs)\n #define reg_raw_mode \\\n   (this_target_regs->x_reg_raw_mode)\n #define have_regs_of_mode \\"}, {"sha": "e22bc66a6c8967f65db5127d5a4823afef3e67af", "filename": "gcc/targhooks.cc", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/418967ca275853a570b0ae566d7022ff38e7cd0d/gcc%2Ftarghooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/418967ca275853a570b0ae566d7022ff38e7cd0d/gcc%2Ftarghooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.cc?ref=418967ca275853a570b0ae566d7022ff38e7cd0d", "patch": "@@ -1017,6 +1017,45 @@ default_function_value_regno_p (const unsigned int regno ATTRIBUTE_UNUSED)\n #endif\n }\n \n+/* Choose the mode and rtx to use to zero REGNO, storing tem in PMODE and\n+   PREGNO_RTX and returning TRUE if successful, otherwise returning FALSE.  If\n+   the natural mode for REGNO doesn't work, attempt to group it with subsequent\n+   adjacent registers set in TOZERO.  */\n+\n+static inline bool\n+zcur_select_mode_rtx (unsigned int regno, machine_mode *pmode,\n+\t\t      rtx *pregno_rtx, HARD_REG_SET tozero)\n+{\n+  rtx regno_rtx = regno_reg_rtx[regno];\n+  machine_mode mode = GET_MODE (regno_rtx);\n+\n+  /* If the natural mode doesn't work, try some wider mode.  */\n+  if (!targetm.hard_regno_mode_ok (regno, mode))\n+    {\n+      bool found = false;\n+      for (int nregs = 2;\n+\t   !found && nregs <= hard_regno_max_nregs\n+\t     && regno + nregs <= FIRST_PSEUDO_REGISTER\n+\t     && TEST_HARD_REG_BIT (tozero,\n+\t\t\t\t   regno + nregs - 1);\n+\t   nregs++)\n+\t{\n+\t  mode = choose_hard_reg_mode (regno, nregs, 0);\n+\t  if (mode == E_VOIDmode)\n+\t    continue;\n+\t  gcc_checking_assert (targetm.hard_regno_mode_ok (regno, mode));\n+\t  regno_rtx = gen_rtx_REG (mode, regno);\n+\t  found = true;\n+\t}\n+      if (!found)\n+\treturn false;\n+    }\n+\n+  *pmode = mode;\n+  *pregno_rtx = regno_rtx;\n+  return true;\n+}\n+\n /* The default hook for TARGET_ZERO_CALL_USED_REGS.  */\n \n HARD_REG_SET\n@@ -1035,16 +1074,28 @@ default_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n     if (TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))\n       {\n \trtx_insn *last_insn = get_last_insn ();\n-\tmachine_mode mode = GET_MODE (regno_reg_rtx[regno]);\n+\trtx regno_rtx;\n+\tmachine_mode mode;\n+\n+\tif (!zcur_select_mode_rtx (regno, &mode, &regno_rtx,\n+\t\t\t\t   need_zeroed_hardregs))\n+\t  {\n+\t    SET_HARD_REG_BIT (failed, regno);\n+\t    continue;\n+\t  }\n+\n \trtx zero = CONST0_RTX (mode);\n-\trtx_insn *insn = emit_move_insn (regno_reg_rtx[regno], zero);\n+\trtx_insn *insn = emit_move_insn (regno_rtx, zero);\n \tif (!valid_insn_p (insn))\n \t  {\n \t    SET_HARD_REG_BIT (failed, regno);\n \t    delete_insns_since (last_insn);\n \t  }\n \telse\n-\t  progress = true;\n+\t  {\n+\t    progress = true;\n+\t    regno += hard_regno_nregs (regno, mode) - 1;\n+\t  }\n       }\n \n   /* Now retry with copies from zeroed registers, as long as we've\n@@ -1060,7 +1111,18 @@ default_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n       for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \tif (TEST_HARD_REG_BIT (retrying, regno))\n \t  {\n-\t    machine_mode mode = GET_MODE (regno_reg_rtx[regno]);\n+\t    rtx regno_rtx;\n+\t    machine_mode mode;\n+\n+\t    /* This might select registers we've already zeroed.  If grouping\n+\t       with them is what it takes to get regno zeroed, so be it.  */\n+\t    if (!zcur_select_mode_rtx (regno, &mode, &regno_rtx,\n+\t\t\t\t       need_zeroed_hardregs))\n+\t      {\n+\t\tSET_HARD_REG_BIT (failed, regno);\n+\t\tcontinue;\n+\t      }\n+\n \t    bool success = false;\n \t    /* Look for a source.  */\n \t    for (unsigned int src = 0; src < FIRST_PSEUDO_REGISTER; src++)\n@@ -1086,8 +1148,8 @@ default_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n \n \t\t/* SRC is usable, try to copy from it.  */\n \t\trtx_insn *last_insn = get_last_insn ();\n-\t\trtx zsrc = gen_rtx_REG (mode, src);\n-\t\trtx_insn *insn = emit_move_insn (regno_reg_rtx[regno], zsrc);\n+\t\trtx src_rtx = gen_rtx_REG (mode, src);\n+\t\trtx_insn *insn = emit_move_insn (regno_rtx, src_rtx);\n \t\tif (!valid_insn_p (insn))\n \t\t  /* It didn't work, remove any inserts.  We'll look\n \t\t     for another SRC.  */\n@@ -1100,13 +1162,16 @@ default_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n \t\t  }\n \t      }\n \n-\t    /* If nothing worked for REGNO this round, marked it to be\n+\t    /* If nothing worked for REGNO this round, mark it to be\n \t       retried if we get another round.  */\n \t    if (!success)\n \t      SET_HARD_REG_BIT (failed, regno);\n \t    else\n-\t      /* Take note so as to enable another round if needed.  */\n-\t      progress = true;\n+\t      {\n+\t\t/* Take note so as to enable another round if needed.  */\n+\t\tprogress = true;\n+\t\tregno += hard_regno_nregs (regno, mode) - 1;\n+\t      }\n \t  }\n     }\n "}]}