{"sha": "e0cea8d93a0760335c5c5fa8269bb3633196c227", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBjZWE4ZDkzYTA3NjAzMzVjNWM1ZmE4MjY5YmIzNjMzMTk2YzIyNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-06-02T11:14:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-06-02T11:14:06Z"}, "message": "tree.h (struct record_layout_info_s): New field unpadded_align.\n\n\t* tree.h (struct record_layout_info_s): New field unpadded_align.\n\t(set_lang_adjust_rli): New declaration.\n\t* stor-layout.c (layout_decl): If DECL is packed, but at alignment\n\tit would have if not packed, do not downgrade DECL_ALIGN.\n\t(lang_adjust_rli, set_lang_adjust_rli): New.\n\t(start_record_layout): Initialize new field unpadded_align.\n\t(debug_rli): Display it.\n\t(place_union_field, place_field): Set it.\n\t(layout_type, case RECORD_TYPE): Call via lang_adjust_rli if set.\n\nFrom-SVN: r42796", "tree": {"sha": "5fa74511443ee609e45e64f0848bb19aa235a285", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fa74511443ee609e45e64f0848bb19aa235a285"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0cea8d93a0760335c5c5fa8269bb3633196c227", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0cea8d93a0760335c5c5fa8269bb3633196c227", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0cea8d93a0760335c5c5fa8269bb3633196c227", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0cea8d93a0760335c5c5fa8269bb3633196c227/comments", "author": null, "committer": null, "parents": [{"sha": "3af78b060b5ec8bf79a2d1460ed12d7501c91c35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3af78b060b5ec8bf79a2d1460ed12d7501c91c35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3af78b060b5ec8bf79a2d1460ed12d7501c91c35"}], "stats": {"total": 53, "additions": 45, "deletions": 8}, "files": [{"sha": "fad7c99c1d3e4f236feb0cdf1079e6332a7b504b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cea8d93a0760335c5c5fa8269bb3633196c227/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cea8d93a0760335c5c5fa8269bb3633196c227/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0cea8d93a0760335c5c5fa8269bb3633196c227", "patch": "@@ -1,5 +1,15 @@\n Sat Jun  2 06:53:50 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* tree.h (struct record_layout_info_s): New field unpadded_align.\n+\t(set_lang_adjust_rli): New declaration.\n+\t* stor-layout.c (layout_decl): If DECL is packed, but at alignment\n+\tit would have if not packed, do not downgrade DECL_ALIGN.\n+\t(lang_adjust_rli, set_lang_adjust_rli): New.\n+\t(start_record_layout): Initialize new field unpadded_align.\n+\t(debug_rli): Display it.\n+\t(place_union_field, place_field): Set it.\n+\t(layout_type, case RECORD_TYPE): Call via lang_adjust_rli if set.\n+\n \t* print-tree.c (print_node): Don't print \"regdecl\" when bit doesn't\n \tmean that; use proper names instead.\n \tPrint DECL_NO_STATIC_CHAIN."}, {"sha": "52e23cb4c8707e9f54eb5df504fa5632c877305b", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cea8d93a0760335c5c5fa8269bb3633196c227/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cea8d93a0760335c5c5fa8269bb3633196c227/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=e0cea8d93a0760335c5c5fa8269bb3633196c227", "patch": "@@ -381,7 +381,7 @@ layout_decl (decl, known_align)\n       DECL_BIT_FIELD_TYPE (decl) = DECL_BIT_FIELD (decl) ? type : 0;\n       if (maximum_field_alignment != 0)\n \tDECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), maximum_field_alignment);\n-      else if (DECL_PACKED (decl))\n+      else if (DECL_PACKED (decl) && known_align % DECL_ALIGN (decl) != 0)\n \t{\n \t  DECL_ALIGN (decl) = MIN (DECL_ALIGN (decl), BITS_PER_UNIT);\n \t  DECL_USER_ALIGN (decl) = 0;\n@@ -444,6 +444,18 @@ layout_decl (decl, known_align)\n     }\n }\n \f\n+/* Hook for a front-end function that can modify the record layout as needed\n+   immediately before it is finalized.  */\n+\n+void (*lang_adjust_rli) PARAMS ((record_layout_info)) = 0;\n+\n+void\n+set_lang_adjust_rli (f)\n+     void (*f) PARAMS ((record_layout_info));\n+{\n+  lang_adjust_rli = f;\n+}\n+\n /* Begin laying out type T, which may be a RECORD_TYPE, UNION_TYPE, or\n    QUAL_UNION_TYPE.  Return a pointer to a struct record_layout_info which\n    is to be passed to all other layout functions for this record.  It is the\n@@ -464,7 +476,7 @@ start_record_layout (t)\n      declaration, for example) use it -- otherwise, start with a\n      one-byte alignment.  */\n   rli->record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (t));\n-  rli->unpacked_align = rli->record_align;\n+  rli->unpacked_align = rli->unpadded_align = rli->record_align;\n   rli->offset_align = MAX (rli->record_align, BIGGEST_ALIGNMENT);\n \n #ifdef STRUCTURE_SIZE_BOUNDARY\n@@ -571,8 +583,9 @@ debug_rli (rli)\n   print_node_brief (stderr, \"\\noffset\", rli->offset, 0);\n   print_node_brief (stderr, \" bitpos\", rli->bitpos, 0);\n \n-  fprintf (stderr, \"\\nrec_align = %u, unpack_align = %u, off_align = %u\\n\",\n-\t   rli->record_align, rli->unpacked_align, rli->offset_align);\n+  fprintf (stderr, \"\\naligns: rec = %u, unpack = %u, unpad = %u, off = %u\\n\",\n+\t   rli->record_align, rli->unpacked_align, rli->unpadded_align,\n+\t   rli->offset_align);\n   if (rli->packed_maybe_necessary)\n     fprintf (stderr, \"packed may be necessary\\n\");\n \n@@ -639,13 +652,18 @@ place_union_field (rli, field)\n \n   /* Union must be at least as aligned as any field requires.  */\n   rli->record_align = MAX (rli->record_align, desired_align);\n+  rli->unpadded_align = MAX (rli->unpadded_align, desired_align);\n \n #ifdef PCC_BITFIELD_TYPE_MATTERS\n   /* On the m88000, a bit field of declare type `int' forces the\n      entire union to have `int' alignment.  */\n   if (PCC_BITFIELD_TYPE_MATTERS && DECL_BIT_FIELD_TYPE (field))\n-    rli->record_align = MAX (rli->record_align, \n-\t\t\t     TYPE_ALIGN (TREE_TYPE (field)));\n+    {\n+      rli->record_align = MAX (rli->record_align, \n+\t\t\t       TYPE_ALIGN (TREE_TYPE (field)));\n+      rli->unpadded_align = MAX (rli->unpadded_align,\n+\t\t\t\t TYPE_ALIGN (TREE_TYPE (field)));\n+    }\n #endif\n \n   /* We assume the union's size will be a multiple of a byte so we don't\n@@ -773,16 +791,17 @@ place_field (rli, field)\n \t    type_align = MIN (type_align, BITS_PER_UNIT);\n \n \t  rli->record_align = MAX (rli->record_align, type_align);\n+\t  rli->unpadded_align = MAX (rli->unpadded_align, DECL_ALIGN (field));\n \t  if (warn_packed)\n-\t    rli->unpacked_align = MAX (rli->unpacked_align, \n-\t\t\t\t       TYPE_ALIGN (type));\n+\t    rli->unpacked_align = MAX (rli->unpacked_align, TYPE_ALIGN (type));\n \t}\n     }\n   else\n #endif\n     {\n       rli->record_align = MAX (rli->record_align, desired_align);\n       rli->unpacked_align = MAX (rli->unpacked_align, TYPE_ALIGN (type));\n+      rli->unpadded_align = MAX (rli->unpadded_align, DECL_ALIGN (field));\n     }\n \n   if (warn_packed && DECL_PACKED (field))\n@@ -1498,6 +1517,9 @@ layout_type (type)\n \tif (TREE_CODE (type) == QUAL_UNION_TYPE)\n \t  TYPE_FIELDS (type) = nreverse (TYPE_FIELDS (type));\n \n+\tif (lang_adjust_rli)\n+\t  (*lang_adjust_rli) (rli);\n+\n \t/* Finish laying out the record.  */\n \tfinish_record_layout (rli);\n       }"}, {"sha": "af784ad42632f362583ee23ff37eeaf5302aeb2f", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0cea8d93a0760335c5c5fa8269bb3633196c227/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0cea8d93a0760335c5c5fa8269bb3633196c227/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e0cea8d93a0760335c5c5fa8269bb3633196c227", "patch": "@@ -2118,12 +2118,17 @@ typedef struct record_layout_info_s\n   unsigned int record_align;\n   /* The alignment of the record so far, not including padding, in bits.  */\n   unsigned int unpacked_align;\n+  /* The alignment of the record so far, allowing for the record to be\n+     padded only at the end, in bits.  */\n+  unsigned int unpadded_align;\n   /* The static variables (i.e., class variables, as opposed to\n      instance variables) encountered in T.  */\n   tree pending_statics;\n   int packed_maybe_necessary;\n } *record_layout_info;\n \n+extern void set_lang_adjust_rli\t\tPARAMS ((void (*) PARAMS\n+\t\t\t\t\t\t ((record_layout_info))));\n extern record_layout_info start_record_layout PARAMS ((tree));\n extern tree bit_from_pos\t\tPARAMS ((tree, tree));\n extern tree byte_from_pos\t\tPARAMS ((tree, tree));"}]}