{"sha": "e25b7843ec7184bf740693005ab35619ab9ed561", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI1Yjc4NDNlYzcxODRiZjc0MDY5MzAwNWFiMzU2MTlhYjllZDU2MQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2009-08-23T02:57:26Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2009-08-23T02:57:26Z"}, "message": "re PR target/41081 (redundant ZERO_EXTENDs)\n\n\tPR target/41081\n\t* fwprop.c (try_fwprop_subst): Allow multiple sets.\n\t(get_reg_use_in): New function.\n\t(forward_propagate_subreg): Propagate through subreg of zero_extend\n\tor sign_extend.\n\nFrom-SVN: r151022", "tree": {"sha": "8a20e3006159e44742462f90f0e5276bb50e8f4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a20e3006159e44742462f90f0e5276bb50e8f4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e25b7843ec7184bf740693005ab35619ab9ed561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25b7843ec7184bf740693005ab35619ab9ed561", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e25b7843ec7184bf740693005ab35619ab9ed561", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e25b7843ec7184bf740693005ab35619ab9ed561/comments", "author": null, "committer": null, "parents": [{"sha": "94d342534efdfcdbc6410c9247ec81a2c13217e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d342534efdfcdbc6410c9247ec81a2c13217e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94d342534efdfcdbc6410c9247ec81a2c13217e9"}], "stats": {"total": 110, "additions": 88, "deletions": 22}, "files": [{"sha": "cce751b2ed92101132568e34ff10515eff1e7740", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25b7843ec7184bf740693005ab35619ab9ed561/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25b7843ec7184bf740693005ab35619ab9ed561/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e25b7843ec7184bf740693005ab35619ab9ed561", "patch": "@@ -1,3 +1,11 @@\n+2009-08-23  Alan Modra  <amodra@bigpond.net.au>\n+\n+\tPR target/41081\n+\t* fwprop.c (try_fwprop_subst): Allow multiple sets.\n+\t(get_reg_use_in): New function.\n+\t(forward_propagate_subreg): Propagate through subreg of zero_extend\n+\tor sign_extend.\n+\n 2009-08-22  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/t-sh (TARGET_LIBGCC2_CFLAGS): Define."}, {"sha": "50daed2fc880c26c1686bd3e322027c7ce3dcc44", "filename": "gcc/fwprop.c", "status": "modified", "additions": 80, "deletions": 22, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e25b7843ec7184bf740693005ab35619ab9ed561/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e25b7843ec7184bf740693005ab35619ab9ed561/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=e25b7843ec7184bf740693005ab35619ab9ed561", "patch": "@@ -929,9 +929,14 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_\n   int flags = DF_REF_FLAGS (use);\n   rtx set = single_set (insn);\n   bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n-  int old_cost = rtx_cost (SET_SRC (set), SET, speed);\n+  int old_cost = 0;\n   bool ok;\n \n+  /* forward_propagate_subreg may be operating on an instruction with\n+     multiple sets.  If so, assume the cost of the new instruction is\n+     not greater than the old one.  */\n+  if (set)\n+    old_cost = rtx_cost (SET_SRC (set), SET, speed);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nIn insn %d, replacing\\n \", INSN_UID (insn));\n@@ -951,6 +956,7 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_\n     }\n \n   else if (DF_REF_TYPE (use) == DF_REF_REG_USE\n+\t   && set\n \t   && rtx_cost (SET_SRC (set), SET, speed) > old_cost)\n     {\n       if (dump_file)\n@@ -1008,39 +1014,91 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_\n   return ok;\n }\n \n+#ifdef LOAD_EXTEND_OP\n+static df_ref\n+get_reg_use_in (rtx insn, rtx reg)\n+{\n+  df_ref *use_vec;\n \n-/* If USE is a paradoxical subreg, see if it can be replaced by a pseudo.  */\n+  for (use_vec = DF_INSN_USES (insn); *use_vec; use_vec++)\n+    {\n+      df_ref use = *use_vec;\n+\n+      if (!DF_REF_IS_ARTIFICIAL (use)\n+\t  && DF_REF_TYPE (use) == DF_REF_REG_USE\n+\t  && DF_REF_REG (use) == reg)\n+\treturn use;\n+    }\n+  return NULL;\n+}\n+#endif\n+\n+/* If USE is a subreg, see if it can be replaced by a pseudo.  */\n \n static bool\n forward_propagate_subreg (df_ref use, rtx def_insn, rtx def_set)\n {\n   rtx use_reg = DF_REF_REG (use);\n   rtx use_insn, src;\n \n-  /* Only consider paradoxical subregs... */\n+  /* Only consider subregs... */\n   enum machine_mode use_mode = GET_MODE (use_reg);\n   if (GET_CODE (use_reg) != SUBREG\n-      || !REG_P (SET_DEST (def_set))\n-      || GET_MODE_SIZE (use_mode)\n-\t <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (use_reg))))\n+      || !REG_P (SET_DEST (def_set)))\n     return false;\n \n-  /* If this is a paradoxical SUBREG, we have no idea what value the\n-     extra bits would have.  However, if the operand is equivalent to\n-     a SUBREG whose operand is the same as our mode, and all the modes\n-     are within a word, we can just use the inner operand because\n-     these SUBREGs just say how to treat the register.  */\n-  use_insn = DF_REF_INSN (use);\n-  src = SET_SRC (def_set);\n-  if (GET_CODE (src) == SUBREG\n-      && REG_P (SUBREG_REG (src))\n-      && GET_MODE (SUBREG_REG (src)) == use_mode\n-      && subreg_lowpart_p (src)\n-      && all_uses_available_at (def_insn, use_insn))\n-    return try_fwprop_subst (use, DF_REF_LOC (use), SUBREG_REG (src),\n-\t\t\t     def_insn, false);\n-  else\n-    return false;\n+  /* If this is a paradoxical SUBREG...  */\n+  if (GET_MODE_SIZE (use_mode)\n+      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (use_reg))))\n+    {\n+      /* If this is a paradoxical SUBREG, we have no idea what value the\n+\t extra bits would have.  However, if the operand is equivalent to\n+\t a SUBREG whose operand is the same as our mode, and all the modes\n+\t are within a word, we can just use the inner operand because\n+\t these SUBREGs just say how to treat the register.  */\n+      use_insn = DF_REF_INSN (use);\n+      src = SET_SRC (def_set);\n+      if (GET_CODE (src) == SUBREG\n+\t  && REG_P (SUBREG_REG (src))\n+\t  && GET_MODE (SUBREG_REG (src)) == use_mode\n+\t  && subreg_lowpart_p (src)\n+\t  && all_uses_available_at (def_insn, use_insn))\n+\treturn try_fwprop_subst (use, DF_REF_LOC (use), SUBREG_REG (src),\n+\t\t\t\t def_insn, false);\n+    }\n+\n+  /* If this is a SUBREG of a ZERO_EXTEND or SIGN_EXTEND, and the SUBREG\n+     is the low part of the reg being extended then just use the inner\n+     operand.  Don't do this if the ZERO_EXTEND or SIGN_EXTEND insn will\n+     be removed due to it matching a LOAD_EXTEND_OP load from memory.  */\n+  else if (subreg_lowpart_p (use_reg))\n+    {\n+#ifdef LOAD_EXTEND_OP\n+      df_ref prev_use, prev_def;\n+#endif\n+      use_insn = DF_REF_INSN (use);\n+      src = SET_SRC (def_set);\n+      if ((GET_CODE (src) == ZERO_EXTEND\n+\t   || GET_CODE (src) == SIGN_EXTEND)\n+\t  && REG_P (XEXP (src, 0))\n+\t  && GET_MODE (XEXP (src, 0)) == use_mode\n+#ifdef LOAD_EXTEND_OP\n+\t  && !(LOAD_EXTEND_OP (use_mode) == GET_CODE (src)\n+\t       && (prev_use = get_reg_use_in (def_insn, XEXP (src, 0))) != NULL\n+\t       && (prev_def = get_def_for_use (prev_use)) != NULL\n+\t       && !DF_REF_IS_ARTIFICIAL (prev_def)\n+\t       && NONJUMP_INSN_P (DF_REF_INSN (prev_def))\n+\t       && GET_CODE (PATTERN (DF_REF_INSN (prev_def))) == SET\n+\t       && GET_CODE (SET_SRC (PATTERN (DF_REF_INSN (prev_def)))) == MEM\n+\t       && rtx_equal_p (SET_DEST (PATTERN (DF_REF_INSN (prev_def))),\n+\t\t\t       XEXP (src, 0)))\n+#endif\n+\t  && all_uses_available_at (def_insn, use_insn))\n+\treturn try_fwprop_subst (use, DF_REF_LOC (use), XEXP (src, 0),\n+\t\t\t\t def_insn, false);\n+    }\n+\n+  return false;\n }\n \n /* Try to replace USE with SRC (defined in DEF_INSN) in __asm.  */"}]}