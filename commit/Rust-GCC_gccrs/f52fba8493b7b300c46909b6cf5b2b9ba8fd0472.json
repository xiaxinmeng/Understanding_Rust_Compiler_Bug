{"sha": "f52fba8493b7b300c46909b6cf5b2b9ba8fd0472", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjUyZmJhODQ5M2I3YjMwMGM0NjkwOWI2Y2Y1YjJiOWJhOGZkMDQ3Mg==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1993-07-02T01:26:01Z"}, "committer": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1993-07-02T01:26:01Z"}, "message": "(pushcase...\n\n(pushcase, pushcase_range): Add a new converter\nfunction argument that specifies how to convert case labels to the\nnominal type.\n\nFrom-SVN: r4829", "tree": {"sha": "b48c8e6cef70a8378df90895f229ad2e75bb91be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b48c8e6cef70a8378df90895f229ad2e75bb91be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f52fba8493b7b300c46909b6cf5b2b9ba8fd0472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f52fba8493b7b300c46909b6cf5b2b9ba8fd0472", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f52fba8493b7b300c46909b6cf5b2b9ba8fd0472", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f52fba8493b7b300c46909b6cf5b2b9ba8fd0472/comments", "author": null, "committer": null, "parents": [{"sha": "dc3907c5c1412fd4e573f0e991a7ddb0b2d1c3e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3907c5c1412fd4e573f0e991a7ddb0b2d1c3e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc3907c5c1412fd4e573f0e991a7ddb0b2d1c3e3"}], "stats": {"total": 16, "additions": 10, "deletions": 6}, "files": [{"sha": "d767362fb7eaad75ae9be32c84236b88f083303f", "filename": "gcc/stmt.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f52fba8493b7b300c46909b6cf5b2b9ba8fd0472/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f52fba8493b7b300c46909b6cf5b2b9ba8fd0472/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=f52fba8493b7b300c46909b6cf5b2b9ba8fd0472", "patch": "@@ -3330,6 +3330,8 @@ case_index_expr_type ()\n \f\n /* Accumulate one case or default label inside a case or switch statement.\n    VALUE is the value of the case (a null pointer, for a default label).\n+   The function CONVERTER, when applied to arguments T and V,\n+   converts the value V to the type T.\n \n    If not currently inside a case or switch statement, return 1 and do\n    nothing.  The caller will print a language-specific error message.\n@@ -3342,8 +3344,9 @@ case_index_expr_type ()\n    Extended to handle range statements.  */\n \n int\n-pushcase (value, label, duplicate)\n+pushcase (value, converter, label, duplicate)\n      register tree value;\n+     tree (*converter) PROTO((tree, tree));\n      register tree label;\n      tree *duplicate;\n {\n@@ -3369,7 +3372,7 @@ pushcase (value, label, duplicate)\n \n   /* Convert VALUE to the type in which the comparisons are nominally done.  */\n   if (value != 0)\n-    value = convert (nominal_type, value);\n+    value = (*converter) (nominal_type, value);\n \n   /* If this is the first label, warn if any insns have been emitted.  */\n   if (case_stack->data.case_stmt.seenlabel == 0)\n@@ -3450,8 +3453,9 @@ pushcase (value, label, duplicate)\n    4 means the specified range was empty.  */\n \n int\n-pushcase_range (value1, value2, label, duplicate)\n+pushcase_range (value1, value2, converter, label, duplicate)\n      register tree value1, value2;\n+     tree (*converter) PROTO((tree, tree));\n      register tree label;\n      tree *duplicate;\n {\n@@ -3499,11 +3503,11 @@ pushcase_range (value1, value2, label, duplicate)\n   /* Convert VALUEs to type in which the comparisons are nominally done.  */\n   if (value1 == 0)  /* Negative infinity. */\n     value1 = TYPE_MIN_VALUE(index_type);\n-  value1 = convert (nominal_type, value1);\n+  value1 = (*converter) (nominal_type, value1);\n \n   if (value2 == 0)  /* Positive infinity. */\n     value2 = TYPE_MAX_VALUE(index_type);\n-  value2 = convert (nominal_type, value2);\n+  value2 = (*converter) (nominal_type, value2);\n \n   /* Fail if these values are out of range.  */\n   if (! int_fits_type_p (value1, index_type))\n@@ -3518,7 +3522,7 @@ pushcase_range (value1, value2, label, duplicate)\n \n   /* If the bounds are equal, turn this into the one-value case.  */\n   if (tree_int_cst_equal (value1, value2))\n-    return pushcase (value1, label, duplicate);\n+    return pushcase (value1, converter, label, duplicate);\n \n   /* Find the elt in the chain before which to insert the new value,\n      to keep the chain sorted in increasing order."}]}