{"sha": "ec3ae3da7f683ca358ad01d5aa3fb9187297448e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMzYWUzZGE3ZjY4M2NhMzU4YWQwMWQ1YWEzZmI5MTg3Mjk3NDQ4ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-03-10T14:31:10Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-03-10T14:31:10Z"}, "message": "cfgcleanup.c (merge_blocks): Return where to iterate next.\n\n\t* cfgcleanup.c (merge_blocks): Return where to iterate next.\n\t(try_optimize_cfg): Use return value of merge_blocks\n\nFrom-SVN: r64079", "tree": {"sha": "8d156f7f3b0848b9f046e696ff62c46dbe3ae384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d156f7f3b0848b9f046e696ff62c46dbe3ae384"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec3ae3da7f683ca358ad01d5aa3fb9187297448e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec3ae3da7f683ca358ad01d5aa3fb9187297448e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec3ae3da7f683ca358ad01d5aa3fb9187297448e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec3ae3da7f683ca358ad01d5aa3fb9187297448e/comments", "author": null, "committer": null, "parents": [{"sha": "76c16dd4c24cbf9ca6c311edcde5336e8c8b63f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76c16dd4c24cbf9ca6c311edcde5336e8c8b63f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76c16dd4c24cbf9ca6c311edcde5336e8c8b63f0"}], "stats": {"total": 67, "additions": 42, "deletions": 25}, "files": [{"sha": "c449f4fc4961b253215cfd349898ab1bb8c44a45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3ae3da7f683ca358ad01d5aa3fb9187297448e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3ae3da7f683ca358ad01d5aa3fb9187297448e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec3ae3da7f683ca358ad01d5aa3fb9187297448e", "patch": "@@ -1,3 +1,8 @@\n+Mon Mar 10 15:30:36 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cfgcleanup.c (merge_blocks): Return where to iterate next.\n+\t(try_optimize_cfg): Use return value of merge_blocks\n+\n 2003-03-10  Michael Matz  <matz@suse.de>\n \n \t* cfg.c (unchecked_make_edge): New."}, {"sha": "58b6efddc1390267d514b5dde55b55baa78505f4", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec3ae3da7f683ca358ad01d5aa3fb9187297448e/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec3ae3da7f683ca358ad01d5aa3fb9187297448e/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=ec3ae3da7f683ca358ad01d5aa3fb9187297448e", "patch": "@@ -81,7 +81,7 @@ static void merge_blocks_move_predecessor_nojumps PARAMS ((basic_block,\n \t\t\t\t\t\t\t  basic_block));\n static void merge_blocks_move_successor_nojumps PARAMS ((basic_block,\n \t\t\t\t\t\t\tbasic_block));\n-static bool merge_blocks\t\tPARAMS ((edge,basic_block,basic_block,\n+static basic_block merge_blocks\t\tPARAMS ((edge,basic_block,basic_block,\n \t\t\t\t\t\t int));\n static bool try_optimize_cfg\t\tPARAMS ((int));\n static bool try_simplify_condjump\tPARAMS ((basic_block));\n@@ -788,22 +788,32 @@ merge_blocks_move_successor_nojumps (a, b)\n }\n \n /* Attempt to merge basic blocks that are potentially non-adjacent.\n-   Return true iff the attempt succeeded.  */\n-\n-static bool\n+   Return NULL iff the attempt failed, otherwise return basic block\n+   where cleanup_cfg should continue.  Because the merging commonly\n+   moves basic block away or introduces another optimization\n+   possiblity, return basic block just before B so cleanup_cfg don't\n+   need to iterate.\n+\n+   It may be good idea to return basic block before C in the case\n+   C has been moved after B and originally appeared earlier in the\n+   insn seqeunce, but we have no infromation available about the\n+   relative ordering of these two.  Hopefully it is not too common.  */\n+\n+static basic_block\n merge_blocks (e, b, c, mode)\n      edge e;\n      basic_block b, c;\n      int mode;\n {\n+  basic_block next;\n   /* If C has a tail recursion label, do not merge.  There is no\n      edge recorded from the call_placeholder back to this label, as\n      that would make optimize_sibling_and_tail_recursive_calls more\n      complex for no gain.  */\n   if ((mode & CLEANUP_PRE_SIBCALL)\n       && GET_CODE (c->head) == CODE_LABEL\n       && tail_recursion_label_p (c->head))\n-    return false;\n+    return NULL;\n \n   /* If B has a fallthru edge to C, no need to move anything.  */\n   if (e->flags & EDGE_FALLTHRU)\n@@ -816,7 +826,7 @@ merge_blocks (e, b, c, mode)\n \tfprintf (rtl_dump_file, \"Merged %d and %d without moving.\\n\",\n \t\t b_index, c_index);\n \n-      return true;\n+      return b->prev_bb == ENTRY_BLOCK_PTR ? b : b->prev_bb;\n     }\n \n   /* Otherwise we will need to move code around.  Do that only if expensive\n@@ -832,7 +842,7 @@ merge_blocks (e, b, c, mode)\n \t been if B is a forwarder block and C has no fallthru edge, but\n \t that should be cleaned up by bb-reorder instead.  */\n       if (FORWARDER_BLOCK_P (b) || FORWARDER_BLOCK_P (c))\n-\treturn false;\n+\treturn NULL;\n \n       /* We must make sure to not munge nesting of lexical blocks,\n \t and loop notes.  This is done by squeezing out all the notes\n@@ -850,14 +860,15 @@ merge_blocks (e, b, c, mode)\n \n       b_has_incoming_fallthru = (tmp_edge != NULL);\n       b_fallthru_edge = tmp_edge;\n+      next = b->prev_bb;\n \n       /* Otherwise, we're going to try to move C after B.  If C does\n \t not have an outgoing fallthru, then it can be moved\n \t immediately after B without introducing or modifying jumps.  */\n       if (! c_has_outgoing_fallthru)\n \t{\n \t  merge_blocks_move_successor_nojumps (b, c);\n-\t  return true;\n+          return next == ENTRY_BLOCK_PTR ? next->next_bb : next;\n \t}\n \n       /* If B does not have an incoming fallthru, then it can be moved\n@@ -870,14 +881,14 @@ merge_blocks (e, b, c, mode)\n \t  basic_block bb;\n \n \t  if (b_fallthru_edge->src == ENTRY_BLOCK_PTR)\n-\t    return false;\n+\t    return NULL;\n \t  bb = force_nonfallthru (b_fallthru_edge);\n \t  if (bb)\n \t    notice_new_block (bb);\n \t}\n \n       merge_blocks_move_predecessor_nojumps (b, c);\n-      return true;\n+      return next == ENTRY_BLOCK_PTR ? next->next_bb : next;\n     }\n \n   return false;\n@@ -1560,7 +1571,7 @@ try_optimize_cfg (mode)\n   bool changed_overall = false;\n   bool changed;\n   int iterations = 0;\n-  basic_block bb, b;\n+  basic_block bb, b, next;\n \n   if (mode & CLEANUP_CROSSJUMP)\n     add_noreturn_fake_exit_edges ();\n@@ -1656,20 +1667,21 @@ try_optimize_cfg (mode)\n \t\t  b = c;\n \t\t}\n \n-\t      /* Merge blocks.  Loop because chains of blocks might be\n-\t\t combineable.  */\n-\t      while ((s = b->succ) != NULL\n-\t\t     && s->succ_next == NULL\n-\t\t     && !(s->flags & EDGE_COMPLEX)\n-\t\t     && (c = s->dest) != EXIT_BLOCK_PTR\n-\t\t     && c->pred->pred_next == NULL\n-\t\t     && b != c\n-\t\t     /* If the jump insn has side effects,\n-\t\t\twe can't kill the edge.  */\n-\t\t     && (GET_CODE (b->end) != JUMP_INSN\n-\t\t\t || simplejump_p (b->end))\n-\t\t     && merge_blocks (s, b, c, mode))\n-\t\tchanged_here = true;\n+\t      if ((s = b->succ) != NULL\n+\t\t  && s->succ_next == NULL\n+\t\t  && !(s->flags & EDGE_COMPLEX)\n+\t\t  && (c = s->dest) != EXIT_BLOCK_PTR\n+\t\t  && c->pred->pred_next == NULL\n+\t\t  && b != c\n+\t\t  /* If the jump insn has side effects,\n+\t\t     we can't kill the edge.  */\n+\t\t  && (GET_CODE (b->end) != JUMP_INSN\n+\t\t      || simplejump_p (b->end))\n+\t\t  && (next = merge_blocks (s, b, c, mode)))\n+\t        {\n+\t\t  b = next;\n+\t\t  changed_here = true;\n+\t\t}\n \n \t      /* Simplify branch over branch.  */\n \t      if ((mode & CLEANUP_EXPENSIVE) && try_simplify_condjump (b))"}]}