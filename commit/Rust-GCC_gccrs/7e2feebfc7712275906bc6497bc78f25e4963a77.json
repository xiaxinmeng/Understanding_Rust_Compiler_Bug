{"sha": "7e2feebfc7712275906bc6497bc78f25e4963a77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UyZmVlYmZjNzcxMjI3NTkwNmJjNjQ5N2JjNzhmMjVlNDk2M2E3Nw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-08-12T17:52:48Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-08-12T17:52:48Z"}, "message": "(legitimize_pic_address): Delete 4th arg SCRATCH.\n\nFix all callers.\n(emit_move_sequence): Delete 3rd arg SCRATCH_REG.  Fix all\ncallers.  If operand1 is an invalid PIC address, then legitimize\nit before doing anything else.\n\nFrom-SVN: r5145", "tree": {"sha": "109319081b254f1954dc13d4c9ee2e901df1b7a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/109319081b254f1954dc13d4c9ee2e901df1b7a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e2feebfc7712275906bc6497bc78f25e4963a77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2feebfc7712275906bc6497bc78f25e4963a77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e2feebfc7712275906bc6497bc78f25e4963a77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2feebfc7712275906bc6497bc78f25e4963a77/comments", "author": null, "committer": null, "parents": [{"sha": "7aca9b9c4e6b744c5e78dc34601f6466fdf2b89e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aca9b9c4e6b744c5e78dc34601f6466fdf2b89e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aca9b9c4e6b744c5e78dc34601f6466fdf2b89e"}], "stats": {"total": 39, "additions": 13, "deletions": 26}, "files": [{"sha": "a0d455f738cde3e379a5572b8cd8dfe22959cac1", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2feebfc7712275906bc6497bc78f25e4963a77/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2feebfc7712275906bc6497bc78f25e4963a77/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=7e2feebfc7712275906bc6497bc78f25e4963a77", "patch": "@@ -624,15 +624,13 @@ reg_unused_after (reg, insn)\n /* Legitimize PIC addresses.  If the address is already position-independent,\n    we return ORIG.  Newly generated position-independent addresses go into a\n    reg.  This is REG if non zero, otherwise we allocate register(s) as\n-   necessary.  If this is called during reload, and we need a second temp\n-   register, then we use SCRATCH, which is provided via the\n-   SECONDARY_INPUT_RELOAD_CLASS mechanism.  */\n+   necessary.  */\n \n rtx\n-legitimize_pic_address (orig, mode, reg, scratch)\n+legitimize_pic_address (orig, mode, reg)\n      rtx orig;\n      enum machine_mode mode;\n-     rtx reg, scratch;\n+     rtx reg;\n {\n   if (GET_CODE (orig) == SYMBOL_REF)\n     {\n@@ -704,10 +702,9 @@ legitimize_pic_address (orig, mode, reg, scratch)\n \n       if (GET_CODE (XEXP (orig, 0)) == PLUS)\n \t{\n-\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode,\n-\t\t\t\t\t reg, 0);\n+\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n \t  offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n-\t\t\t\t\t base == reg ? 0 : reg, 0);\n+\t\t\t\t\t base == reg ? 0 : reg);\n \t}\n       else\n \tabort ();\n@@ -718,17 +715,8 @@ legitimize_pic_address (orig, mode, reg, scratch)\n \t    return plus_constant_for_output (base, INTVAL (offset));\n \t  else if (! reload_in_progress && ! reload_completed)\n \t    offset = force_reg (Pmode, offset);\n-\t  /* We can't create any new registers during reload, so use the\n-\t     SCRATCH reg provided by the reload_insi pattern.  */\n-\t  else if (scratch)\n-\t    {\n-\t      emit_move_insn (scratch, offset);\n-\t      offset = scratch;\n-\t    }\n \t  else\n-\t    /* If we reach here, then the SECONDARY_INPUT_RELOAD_CLASS\n-\t       macro needs to be adjusted so that a scratch reg is provided\n-\t       for this address.  */\n+\t    /* If we reach here, then something is seriously wrong.  */\n \t    abort ();\n \t}\n       return gen_rtx (PLUS, Pmode, base, offset);\n@@ -851,20 +839,20 @@ sparc_address_cost (X)\n \n    Return 1 if we have written out everything that needs to be done to\n    do the move.  Otherwise, return 0 and the caller will emit the move\n-   normally.\n-\n-   SCRATCH_REG if non zero can be used as a scratch register for the move\n-   operation.  It is provided by a SECONDARY_RELOAD_* macro if needed.  */\n+   normally.  */\n \n int\n-emit_move_sequence (operands, mode, scratch_reg)\n+emit_move_sequence (operands, mode)\n      rtx *operands;\n      enum machine_mode mode;\n-     rtx scratch_reg;\n {\n   register rtx operand0 = operands[0];\n   register rtx operand1 = operands[1];\n \n+  if (CONSTANT_P (operand1) && flag_pic\n+      && pic_address_needs_scratch (operand1))\n+    operands[1] = operand1 = legitimize_pic_address (operand1, mode, 0);\n+\n   /* Handle most common case first: storing into a register.  */\n   if (register_operand (operand0, mode))\n     {\n@@ -905,8 +893,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t{\n \t  rtx temp_reg = reload_in_progress ? operand0 : 0;\n \n-\t  operands[1] = legitimize_pic_address (operand1, mode, temp_reg,\n-\t\t\t\t\t\tscratch_reg);\n+\t  operands[1] = legitimize_pic_address (operand1, mode, temp_reg);\n \t}\n       else if (GET_CODE (operand1) == CONST_INT\n \t       ? (! SMALL_INT (operand1)"}]}