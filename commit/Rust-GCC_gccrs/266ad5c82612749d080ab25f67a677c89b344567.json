{"sha": "266ad5c82612749d080ab25f67a677c89b344567", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY2YWQ1YzgyNjEyNzQ5ZDA4MGFiMjVmNjdhNjc3Yzg5YjM0NDU2Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-07-13T10:06:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-07-13T10:06:19Z"}, "message": "cgraph.c (assembler_name_hash): New static var.\n\n\n\t* cgraph.c (assembler_name_hash): New static var.\n\t(hash_node_by_assembler_name, eq_assembler_name): New.\n\t(cgraph_node_for_asm): Use hashtable.\n\t(cgraph_remove_node): Maintain hashtable.\n\t(change_decl_assembler_name): Sanity check that names are not changing\n\tafter aliasing was processed.\n\t* cgraph.h (varpoon_node): Add next GGC marker.\n\t* tree.c (decl_assembler_name_equal): Constify.\n\t(decl_assembler_name_hash): New.\n\t* tree.h (decl_assembler_name_equal): Constify.\n\t(decl_assembler_name_hash): Update.\n\nFrom-SVN: r137753", "tree": {"sha": "1ee8898b82ca9a88353189796c35234da2da21d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ee8898b82ca9a88353189796c35234da2da21d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/266ad5c82612749d080ab25f67a677c89b344567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266ad5c82612749d080ab25f67a677c89b344567", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266ad5c82612749d080ab25f67a677c89b344567", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266ad5c82612749d080ab25f67a677c89b344567/comments", "author": null, "committer": null, "parents": [{"sha": "52ca125521c3e1d5b9fff7e3710ccbfdd3b2d797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ca125521c3e1d5b9fff7e3710ccbfdd3b2d797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52ca125521c3e1d5b9fff7e3710ccbfdd3b2d797"}], "stats": {"total": 122, "additions": 115, "deletions": 7}, "files": [{"sha": "d38611b8fb28d337eed1d0b3ca321c14b0e0c72b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266ad5c82612749d080ab25f67a677c89b344567/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266ad5c82612749d080ab25f67a677c89b344567/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=266ad5c82612749d080ab25f67a677c89b344567", "patch": "@@ -1,3 +1,17 @@\n+2008-07-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (assembler_name_hash): New static var.\n+\t(hash_node_by_assembler_name, eq_assembler_name): New.\n+\t(cgraph_node_for_asm): Use hashtable.\n+\t(cgraph_remove_node): Maintain hashtable.\n+\t(change_decl_assembler_name): Sanity check that names are not changing\n+\tafter aliasing was processed.\n+\t* cgraph.h (varpoon_node): Add next GGC marker.\n+\t* tree.c (decl_assembler_name_equal): Constify.\n+\t(decl_assembler_name_hash): New.\n+\t* tree.h (decl_assembler_name_equal): Constify.\n+\t(decl_assembler_name_hash): Update.\n+\n 2008-07-12  David Daney  <ddaney@avtrex.com>\n \n \t* config/mips/driver-native.c (host_detect_local_cpu): Handle"}, {"sha": "881bc42dfe195f38dd48bca57dffcaf49c39022d", "filename": "gcc/cgraph.c", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266ad5c82612749d080ab25f67a677c89b344567/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266ad5c82612749d080ab25f67a677c89b344567/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=266ad5c82612749d080ab25f67a677c89b344567", "patch": "@@ -91,6 +91,8 @@ static inline void cgraph_edge_remove_callee (struct cgraph_edge *e);\n \n /* Hash table used to convert declarations into nodes.  */\n static GTY((param_is (struct cgraph_node))) htab_t cgraph_hash;\n+/* Hash table used to convert assembler names into nodes.  */\n+static GTY((param_is (struct cgraph_node))) htab_t assembler_name_hash;\n \n /* The linked list of cgraph nodes.  */\n struct cgraph_node *cgraph_nodes;\n@@ -409,6 +411,18 @@ cgraph_node (tree decl)\n       node->origin->nested = node;\n       node->master_clone = node;\n     }\n+\n+  /* This code can go away once flag_unit_at_a_mode is removed.  */\n+  if (assembler_name_hash)\n+    {\n+      tree name = DECL_ASSEMBLER_NAME (node->decl);\n+      slot = ((struct cgraph_node **)\n+              htab_find_slot_with_hash (assembler_name_hash, name,\n+\t\t\t\t        decl_assembler_name_hash (name),\n+\t\t\t\t        INSERT));\n+      if (!*slot)\n+        *slot = node;\n+    }\n   return node;\n }\n \n@@ -425,6 +439,24 @@ cgraph_insert_node_to_hashtable (struct cgraph_node *node)\n   *slot = node;\n }\n \n+/* Returns a hash code for P.  */\n+\n+static hashval_t\n+hash_node_by_assembler_name (const void *p)\n+{\n+  const struct cgraph_node *n = (const struct cgraph_node *) p;\n+  return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->decl));\n+}\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+eq_assembler_name (const void *p1, const void *p2)\n+{\n+  const struct cgraph_node *n1 = (const struct cgraph_node *) p1;\n+  const_tree name = (const_tree)p2;\n+  return (decl_assembler_name_equal (n1->decl, name));\n+}\n \n /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n    Return NULL if there's no such node.  */\n@@ -433,11 +465,36 @@ struct cgraph_node *\n cgraph_node_for_asm (tree asmname)\n {\n   struct cgraph_node *node;\n+  void **slot;\n \n-  for (node = cgraph_nodes; node ; node = node->next)\n-    if (decl_assembler_name_equal (node->decl, asmname))\n-      return node;\n+  if (!assembler_name_hash)\n+    {\n+      assembler_name_hash =\n+\thtab_create_ggc (10, hash_node_by_assembler_name, eq_assembler_name,\n+\t\t\t NULL);\n+      for (node = cgraph_nodes; node; node = node->next)\n+        if (!node->global.inlined_to)\n+\t  {\n+\t    tree name = DECL_ASSEMBLER_NAME (node->decl);\n+\t    slot = htab_find_slot_with_hash (assembler_name_hash, name,\n+\t\t\t\t\t     decl_assembler_name_hash (name),\n+\t\t\t\t\t     INSERT);\n+\t    /* We can have multiple declarations with same assembler name. For C++\n+\t       it is __builtin_strlen and strlen, for instance.  Do we need to\n+\t       record them all?  Original implementation marked just first one\n+\t       so lets hope for the best.  */\n+\t    if (*slot)\n+\t      continue;\n+\t    *slot = node;\n+\t  }\n+    }\n+\n+  slot = htab_find_slot_with_hash (assembler_name_hash, asmname,\n+\t\t\t\t   decl_assembler_name_hash (asmname),\n+\t\t\t\t   NO_INSERT);\n \n+  if (slot)\n+    return (struct cgraph_node *) *slot;\n   return NULL;\n }\n \n@@ -763,6 +820,7 @@ cgraph_remove_node (struct cgraph_node *node)\n   cgraph_call_node_removal_hooks (node);\n   cgraph_node_remove_callers (node);\n   cgraph_node_remove_callees (node);\n+\n   /* Incremental inlining access removed nodes stored in the postorder list.\n      */\n   node->needed = node->reachable = false;\n@@ -824,6 +882,16 @@ cgraph_remove_node (struct cgraph_node *node)\n \t      && (TREE_ASM_WRITTEN (n->decl) || DECL_EXTERNAL (n->decl))))\n \tkill_body = true;\n     }\n+  if (assembler_name_hash)\n+    {\n+      tree name = DECL_ASSEMBLER_NAME (node->decl);\n+      slot = htab_find_slot_with_hash (assembler_name_hash, name,\n+\t\t\t\t       decl_assembler_name_hash (name),\n+\t\t\t\t       NO_INSERT);\n+      /* Inline clones are not hashed.  */\n+      if (slot && *slot == node)\n+        htab_clear_slot (assembler_name_hash, slot);\n+    }\n \n   if (kill_body && flag_unit_at_a_time)\n     cgraph_release_function_body (node);\n@@ -1038,6 +1106,7 @@ debug_cgraph (void)\n void\n change_decl_assembler_name (tree decl, tree name)\n {\n+  gcc_assert (!assembler_name_hash);\n   if (!DECL_ASSEMBLER_NAME_SET_P (decl))\n     {\n       SET_DECL_ASSEMBLER_NAME (decl, name);"}, {"sha": "070bd77dcdc06f91bd5c03542d8e94ed547bd831", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266ad5c82612749d080ab25f67a677c89b344567/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266ad5c82612749d080ab25f67a677c89b344567/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=266ad5c82612749d080ab25f67a677c89b344567", "patch": "@@ -224,7 +224,7 @@ DEF_VEC_ALLOC_P(cgraph_edge_p,heap);\n /* The varpool data structure.\n    Each static variable decl has assigned varpool_node.  */\n \n-struct varpool_node GTY(())\n+struct varpool_node GTY((chain_next (\"%h.next\")))\n {\n   tree decl;\n   /* Pointer to the next function in varpool_nodes.  */"}, {"sha": "81c471b706731e79edabd5093ad982d8d14c30c4", "filename": "gcc/tree.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266ad5c82612749d080ab25f67a677c89b344567/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266ad5c82612749d080ab25f67a677c89b344567/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=266ad5c82612749d080ab25f67a677c89b344567", "patch": "@@ -347,7 +347,7 @@ decl_assembler_name (tree decl)\n /* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n \n bool\n-decl_assembler_name_equal (tree decl, tree asmname)\n+decl_assembler_name_equal (tree decl, const_tree asmname)\n {\n   tree decl_asmname = DECL_ASSEMBLER_NAME (decl);\n \n@@ -378,6 +378,27 @@ decl_assembler_name_equal (tree decl, tree asmname)\n   return false;\n }\n \n+/* Hash asmnames ignoring the user specified marks.  */\n+\n+hashval_t\n+decl_assembler_name_hash (const_tree asmname)\n+{\n+  if (IDENTIFIER_POINTER (asmname)[0] == '*')\n+    {\n+      const char *decl_str = IDENTIFIER_POINTER (asmname) + 1;\n+      size_t ulp_len = strlen (user_label_prefix);\n+\n+      if (ulp_len == 0)\n+\t;\n+      else if (strncmp (decl_str, user_label_prefix, ulp_len) == 0)\n+\tdecl_str += ulp_len;\n+\n+      return htab_hash_string (decl_str);\n+    }\n+\n+  return htab_hash_string (IDENTIFIER_POINTER (asmname));\n+}\n+\n /* Compute the number of bytes occupied by a tree with code CODE.\n    This function cannot be used for nodes that have variable sizes,\n    including TREE_VEC, PHI_NODE, STRING_CST, and CALL_EXPR.  */"}, {"sha": "103f802c80649a81166c30b1777bbf5c05457fd3", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266ad5c82612749d080ab25f67a677c89b344567/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266ad5c82612749d080ab25f67a677c89b344567/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=266ad5c82612749d080ab25f67a677c89b344567", "patch": "@@ -3923,7 +3923,8 @@ enum ptrmemfunc_vbit_where_t\n #define NULL_TREE (tree) NULL\n \n extern tree decl_assembler_name (tree);\n-extern bool decl_assembler_name_equal (tree decl, tree asmname);\n+extern bool decl_assembler_name_equal (tree decl, const_tree asmname);\n+extern hashval_t decl_assembler_name_hash (const_tree asmname);\n \n /* Compute the number of bytes occupied by 'node'.  This routine only\n    looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */"}, {"sha": "49cdda4c9a5619db0096eb3a60618b18a7f6667f", "filename": "gcc/varasm.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/266ad5c82612749d080ab25f67a677c89b344567/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/266ad5c82612749d080ab25f67a677c89b344567/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=266ad5c82612749d080ab25f67a677c89b344567", "patch": "@@ -5380,7 +5380,10 @@ assemble_alias (tree decl, tree target)\n \n   /* If the target has already been emitted, we don't have to queue the\n      alias.  This saves a tad of memory.  */\n-  target_decl = find_decl_and_mark_needed (decl, target);\n+  if (!flag_unit_at_a_time || cgraph_global_info_ready)\n+    target_decl = find_decl_and_mark_needed (decl, target);\n+  else\n+    target_decl= NULL;\n   if (target_decl && TREE_ASM_WRITTEN (target_decl))\n     do_assemble_alias (decl, target);\n   else"}]}