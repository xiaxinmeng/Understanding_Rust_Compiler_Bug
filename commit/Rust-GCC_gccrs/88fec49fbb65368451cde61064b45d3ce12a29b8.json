{"sha": "88fec49fbb65368451cde61064b45d3ce12a29b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmZWM0OWZiYjY1MzY4NDUxY2RlNjEwNjRiNDVkM2NlMTJhMjliOA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-06-17T20:24:20Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-06-17T20:24:20Z"}, "message": "re PR fortran/36112 (Bounds-checking on character length not working for array-constructors)\n\n2008-06-17  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/36112\n\t* array.c (gfc_resolve_character_array_constructor):  Check that all\n\telements with constant character length have the same one rather than\n\tfixing it if no typespec is given, emit an error if they don't.  Changed\n\treturn type to \"try\" and return FAILURE for the case above.\n\t(gfc_resolve_array_constructor):  Removed unneeded call to\n\tgfc_resolve_character_array_constructor in this function.\n\t* gfortran.h (gfc_resolve_character_array_constructor):  Returns try.\n\t* trans-array.c (get_array_ctor_strlen):  Return length of first element\n\trather than last element.\n\t* resolve.c (gfc_resolve_expr):  Handle FAILURE return from\n\tgfc_resolve_character_array_constructor.\n\n2008-06-17  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/36112\n\t* gfortran.dg/bounds_check_array_ctor_1.f90:  New test.\n\t* gfortran.dg/bounds_check_array_ctor_2.f90:  New test.\n\t* gfortran.dg/bounds_check_array_ctor_3.f90:  New test.\n\t* gfortran.dg/bounds_check_array_ctor_4.f90:  New test.\n\t* gfortran.dg/bounds_check_array_ctor_5.f90:  New test.\n\t* gfortran.dg/bounds_check_array_ctor_6.f90:  New test.\n\t* gfortran.dg/bounds_check_array_ctor_7.f90:  New test.\n\t* gfortran.dg/bounds_check_array_ctor_8.f90:  New test.\n\t* gfortran.dg/arrayio_0.f90:  Fixed invalid array constructor.\n\t* gfortran.dg/char_cons_len.f90:  Ditto.\n\t* gfortran.dg/char_initializer_actual.f90:  Ditto.\n\t* gfortran.dg/pr15959.f90:  Ditto.\n\t* gfortran.dg/transfer_simplify_2.f90:  Ditto.\n\t* gfortran.dg/char_length_1.f90:  Changed expected error messages.\n\nFrom-SVN: r136872", "tree": {"sha": "5c2c5289e8a828727de4afdeb3de36331297bdc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c2c5289e8a828727de4afdeb3de36331297bdc3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88fec49fbb65368451cde61064b45d3ce12a29b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fec49fbb65368451cde61064b45d3ce12a29b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88fec49fbb65368451cde61064b45d3ce12a29b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fec49fbb65368451cde61064b45d3ce12a29b8/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9d5c21c1f0bc3888f494dc9114e27570646c0a8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5c21c1f0bc3888f494dc9114e27570646c0a8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d5c21c1f0bc3888f494dc9114e27570646c0a8f"}], "stats": {"total": 312, "additions": 243, "deletions": 69}, "files": [{"sha": "e83c3cb0c959f8c32890bc9ed8789b6910c5b082", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -1,3 +1,18 @@\n+2008-06-17  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/36112\n+\t* array.c (gfc_resolve_character_array_constructor):  Check that all\n+\telements with constant character length have the same one rather than\n+\tfixing it if no typespec is given, emit an error if they don't.  Changed\n+\treturn type to \"try\" and return FAILURE for the case above.\n+\t(gfc_resolve_array_constructor):  Removed unneeded call to\n+\tgfc_resolve_character_array_constructor in this function.\n+\t* gfortran.h (gfc_resolve_character_array_constructor):  Returns try.\n+\t* trans-array.c (get_array_ctor_strlen):  Return length of first element\n+\trather than last element.\n+\t* resolve.c (gfc_resolve_expr):  Handle FAILURE return from\n+\tgfc_resolve_character_array_constructor.\n+\n 2008-06-17  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/34396"}, {"sha": "73b78c3f2fcebe08ec65cd200165637ba85a92b4", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 64, "deletions": 51, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -1576,23 +1576,20 @@ resolve_array_list (gfc_constructor *p)\n   return t;\n }\n \n-/* Resolve character array constructor. If it is a constant character array and\n-   not specified character length, update character length to the maximum of\n-   its element constructors' length.  For arrays with fixed length, pad the\n-   elements as necessary with needed_length.  */\n+/* Resolve character array constructor. If it has a specified constant character\n+   length, pad/trunkate the elements here; if the length is not specified and\n+   all elements are of compile-time known length, emit an error as this is\n+   invalid.  */\n \n-void\n+try\n gfc_resolve_character_array_constructor (gfc_expr *expr)\n {\n   gfc_constructor *p;\n-  int max_length;\n-  bool generated_length;\n+  int found_length;\n \n   gcc_assert (expr->expr_type == EXPR_ARRAY);\n   gcc_assert (expr->ts.type == BT_CHARACTER);\n \n-  max_length = -1;\n-\n   if (expr->ts.cl == NULL)\n     {\n       for (p = expr->value.constructor; p; p = p->next)\n@@ -1611,15 +1608,16 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \n got_charlen:\n \n-  generated_length = false;\n+  found_length = -1;\n+\n   if (expr->ts.cl->length == NULL)\n     {\n-      /* Find the maximum length of the elements. Do nothing for variable\n-\t array constructor, unless the character length is constant or\n-\t there is a constant substring reference.  */\n+      /* Check that all constant string elements have the same length until\n+\t we reach the end or find a variable-length one.  */\n \n       for (p = expr->value.constructor; p; p = p->next)\n \t{\n+\t  int current_length = -1;\n \t  gfc_ref *ref;\n \t  for (ref = p->expr->ref; ref; ref = ref->next)\n \t    if (ref->type == REF_SUBSTRING\n@@ -1628,32 +1626,43 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \t      break;\n \n \t  if (p->expr->expr_type == EXPR_CONSTANT)\n-\t    max_length = MAX (p->expr->value.character.length, max_length);\n+\t    current_length = p->expr->value.character.length;\n \t  else if (ref)\n \t    {\n \t      long j;\n \t      j = mpz_get_ui (ref->u.ss.end->value.integer)\n \t\t- mpz_get_ui (ref->u.ss.start->value.integer) + 1;\n-\t      max_length = MAX ((int) j, max_length);\n+\t      current_length = (int) j;\n \t    }\n \t  else if (p->expr->ts.cl && p->expr->ts.cl->length\n \t\t   && p->expr->ts.cl->length->expr_type == EXPR_CONSTANT)\n \t    {\n \t      long j;\n \t      j = mpz_get_si (p->expr->ts.cl->length->value.integer);\n-\t      max_length = MAX ((int) j, max_length);\n+\t      current_length = (int) j;\n \t    }\n \t  else\n-\t    return;\n-\t}\n+\t    return SUCCESS;\n \n-      if (max_length != -1)\n-\t{\n-\t  /* Update the character length of the array constructor.  */\n-\t  expr->ts.cl->length = gfc_int_expr (max_length);\n-\t  generated_length = true;\n-\t  /* Real update follows below.  */\n+\t  gcc_assert (current_length != -1);\n+\n+\t  if (found_length == -1)\n+\t    found_length = current_length;\n+\t  else if (found_length != current_length)\n+\t    {\n+\t      gfc_error (\"Different CHARACTER lengths (%d/%d) in array\"\n+\t\t\t \" constructor at %L\", found_length, current_length,\n+\t\t\t &p->expr->where);\n+\t      return FAILURE;\n+\t    }\n+\n+\t  gcc_assert (found_length == current_length);\n \t}\n+\n+      gcc_assert (found_length != -1);\n+\n+      /* Update the character length of the array constructor.  */\n+      expr->ts.cl->length = gfc_int_expr (found_length);\n     }\n   else \n     {\n@@ -1664,33 +1673,35 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n       /* If we've got a constant character length, pad according to this.\n \t gfc_extract_int does check for BT_INTEGER and EXPR_CONSTANT and sets\n \t max_length only if they pass.  */\n-      gfc_extract_int (expr->ts.cl->length, &max_length);\n+      gfc_extract_int (expr->ts.cl->length, &found_length);\n+\n+      /* Now pad/trunkate the elements accordingly to the specified character\n+\t length.  This is ok inside this conditional, as in the case above\n+\t (without typespec) all elements are verified to have the same length\n+\t anyway.  */\n+      if (found_length != -1)\n+        for (p = expr->value.constructor; p; p = p->next)\n+          if (p->expr->expr_type == EXPR_CONSTANT)\n+            {\n+              gfc_expr *cl = NULL;\n+              int current_length = -1;\n+\n+              if (p->expr->ts.cl && p->expr->ts.cl->length)\n+              {\n+                cl = p->expr->ts.cl->length;\n+                gfc_extract_int (cl, &current_length);\n+              }\n+\n+              /* If gfc_extract_int above set current_length, we implicitly\n+                 know the type is BT_INTEGER and it's EXPR_CONSTANT.  */\n+\n+              if (! cl\n+                  || (current_length != -1 && current_length < found_length))\n+                gfc_set_constant_character_len (found_length, p->expr, true);\n+            }\n     }\n \n-  /* Found a length to update to, do it for all element strings shorter than\n-     the target length.  */\n-  if (max_length != -1)\n-    {\n-      for (p = expr->value.constructor; p; p = p->next)\n-\tif (p->expr->expr_type == EXPR_CONSTANT)\n-\t  {\n-\t    gfc_expr *cl = NULL;\n-\t    int current_length = -1;\n-\n-\t    if (p->expr->ts.cl && p->expr->ts.cl->length)\n-\t    {\n-\t      cl = p->expr->ts.cl->length;\n-\t      gfc_extract_int (cl, &current_length);\n-\t    }\n-\n-\t    /* If gfc_extract_int above set current_length, we implicitly\n-\t       know the type is BT_INTEGER and it's EXPR_CONSTANT.  */\n-\n-\t    if (generated_length || ! cl\n-\t\t|| (current_length != -1 && current_length < max_length))\n-\t      gfc_set_constant_character_len (max_length, p->expr, true);\n-\t  }\n-    }\n+  return SUCCESS;\n }\n \n \n@@ -1704,8 +1715,10 @@ gfc_resolve_array_constructor (gfc_expr *expr)\n   t = resolve_array_list (expr->value.constructor);\n   if (t == SUCCESS)\n     t = gfc_check_constructor_type (expr);\n-  if (t == SUCCESS && expr->ts.type == BT_CHARACTER)\n-    gfc_resolve_character_array_constructor (expr);\n+\n+  /* gfc_resolve_character_array_constructor is called in gfc_resolve_expr after\n+     the call to this function, so we don't need to call it here; if it was\n+     called twice, an error message there would be duplicated.  */\n \n   return t;\n }"}, {"sha": "ee60f9ae6455586c713fe020195dcbcb969604ef", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -2363,7 +2363,7 @@ void gfc_simplify_iterator_var (gfc_expr *);\n try gfc_expand_constructor (gfc_expr *);\n int gfc_constant_ac (gfc_expr *);\n int gfc_expanded_ac (gfc_expr *);\n-void gfc_resolve_character_array_constructor (gfc_expr *);\n+try gfc_resolve_character_array_constructor (gfc_expr *);\n try gfc_resolve_array_constructor (gfc_expr *);\n try gfc_check_constructor_type (gfc_expr *);\n try gfc_check_iter_variable (gfc_expr *);"}, {"sha": "3b798d8643c90eae0d385d9a2f7e017ed5a85e5d", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -4342,8 +4342,8 @@ gfc_resolve_expr (gfc_expr *e)\n       /* This provides the opportunity for the length of constructors with\n \t character valued function elements to propagate the string length\n \t to the expression.  */\n-      if (e->ts.type == BT_CHARACTER)\n-\tgfc_resolve_character_array_constructor (e);\n+      if (t == SUCCESS && e->ts.type == BT_CHARACTER)\n+\tt = gfc_resolve_character_array_constructor (e);\n \n       break;\n "}, {"sha": "2a966988dec0994c90d7346d27918663331d0d2f", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -1459,6 +1459,9 @@ get_array_ctor_all_strlen (stmtblock_t *block, gfc_expr *e, tree *len)\n \n \n /* Figure out the string length of a character array constructor.\n+   If len is NULL, don't calculate the length; this happens for recursive calls\n+   when a sub-array-constructor is an element but not at the first position,\n+   so when we're not interested in the length.\n    Returns TRUE if all elements are character constants.  */\n \n bool\n@@ -1470,16 +1473,20 @@ get_array_ctor_strlen (stmtblock_t *block, gfc_constructor * c, tree * len)\n \n   if (c == NULL)\n     {\n-      *len = build_int_cstu (gfc_charlen_type_node, 0);\n+      if (len)\n+\t*len = build_int_cstu (gfc_charlen_type_node, 0);\n       return is_const;\n     }\n \n-  for (; c; c = c->next)\n+  /* Loop over all constructor elements to find out is_const, but in len we\n+     want to store the length of the first, not the last, element.  We can\n+     of course exit the loop as soon as is_const is found to be false.  */\n+  for (; c && is_const; c = c->next)\n     {\n       switch (c->expr->expr_type)\n \t{\n \tcase EXPR_CONSTANT:\n-\t  if (!(*len && INTEGER_CST_P (*len)))\n+\t  if (len && !(*len && INTEGER_CST_P (*len)))\n \t    *len = build_int_cstu (gfc_charlen_type_node,\n \t\t\t\t   c->expr->value.character.length);\n \t  break;\n@@ -1491,14 +1498,19 @@ get_array_ctor_strlen (stmtblock_t *block, gfc_constructor * c, tree * len)\n \n \tcase EXPR_VARIABLE:\n \t  is_const = false;\n-\t  get_array_ctor_var_strlen (c->expr, len);\n+\t  if (len)\n+\t    get_array_ctor_var_strlen (c->expr, len);\n \t  break;\n \n \tdefault:\n \t  is_const = false;\n-\t  get_array_ctor_all_strlen (block, c->expr, len);\n+\t  if (len)\n+\t    get_array_ctor_all_strlen (block, c->expr, len);\n \t  break;\n \t}\n+\n+      /* After the first iteration, we don't want the length modified.  */\n+      len = NULL;\n     }\n \n   return is_const;"}, {"sha": "8b2d63c2979c8feb3538884375c9d35f16b09948", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -1,3 +1,21 @@\n+2008-06-17  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/36112\n+\t* gfortran.dg/bounds_check_array_ctor_1.f90:  New test.\n+\t* gfortran.dg/bounds_check_array_ctor_2.f90:  New test.\n+\t* gfortran.dg/bounds_check_array_ctor_3.f90:  New test.\n+\t* gfortran.dg/bounds_check_array_ctor_4.f90:  New test.\n+\t* gfortran.dg/bounds_check_array_ctor_5.f90:  New test.\n+\t* gfortran.dg/bounds_check_array_ctor_6.f90:  New test.\n+\t* gfortran.dg/bounds_check_array_ctor_7.f90:  New test.\n+\t* gfortran.dg/bounds_check_array_ctor_8.f90:  New test.\n+\t* gfortran.dg/arrayio_0.f90:  Fixed invalid array constructor.\n+\t* gfortran.dg/char_cons_len.f90:  Ditto.\n+\t* gfortran.dg/char_initializer_actual.f90:  Ditto.\n+\t* gfortran.dg/pr15959.f90:  Ditto.\n+\t* gfortran.dg/transfer_simplify_2.f90:  Ditto.\n+\t* gfortran.dg/char_length_1.f90:  Changed expected error messages.\n+\n 2008-06-17  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/36366"}, {"sha": "3801a69e9c24d9d6528c37efcb01ea59c97042e6", "filename": "gcc/testsuite/gfortran.dg/arrayio_0.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Farrayio_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Farrayio_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farrayio_0.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -8,7 +8,7 @@\n   character(len=48), dimension(2) :: iue\n   equivalence (iu, iue)\n   integer, dimension(4) :: v = (/2,1,4,3/)\n-  iu = (/\"Vector\",\"subscripts\",\"not\",\"allowed!\"/)\n+  iu = (/\"Vector    \",\"subscripts\",\"not       \",\"allowed!  \"/)\n   read (iu, '(a12/)') buff\n   read (iue(1), '(4a12)') buff\n   read (iu(4:1:-1), '(a12/)') buff"}, {"sha": "45b21d21e70b980f11655c64c7669fec7e8f4675", "filename": "gcc/testsuite/gfortran.dg/bounds_check_array_ctor_1.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_1.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"foo\" }\n+!\n+! PR 36112\n+! Check correct bounds-checking behaviour for character-array-constructors.\n+\n+  call test (\"this is long\")\n+contains\n+  subroutine test(s)\n+    character(len=*) :: s\n+    character(len=128) :: arr(2)\n+    arr = (/ s, \"abc\" /)\n+  end subroutine test\n+end\n+! { dg-output \"Different CHARACTER lengths \\\\(12/3\\\\) in array constructor\" }"}, {"sha": "e0cbf1061d7d376ac53e94e92b35ce1029127103", "filename": "gcc/testsuite/gfortran.dg/bounds_check_array_ctor_2.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_2.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"foo\" }\n+!\n+! PR 36112\n+! Check correct bounds-checking behaviour for character-array-constructors.\n+\n+  call test (\"this is long\")\n+contains\n+  subroutine test(s)\n+    character(len=*) :: s\n+    character(len=128) :: arr(2)\n+    arr = (/ \"abc\", s /)\n+  end subroutine test\n+end\n+! { dg-output \"Different CHARACTER lengths \\\\(3/12\\\\) in array constructor\" }"}, {"sha": "5e566ba9bc9e5df3957ea7f10bfbd377065418bb", "filename": "gcc/testsuite/gfortran.dg/bounds_check_array_ctor_3.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_3.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+!\n+! PR 36112\n+! Check correct bounds-checking behaviour for character-array-constructors.\n+! This should not need any -fbounds-check and is enabled all the time.\n+\n+  character(len=128) :: arr(2) = (/ \"abc\", \"foobar\" /) ! { dg-error \"Different CHARACTER lengths\" }\n+  arr = (/ \"abc\", \"foobar\" /) ! { dg-error \"Different CHARACTER lengths\" }\n+end"}, {"sha": "1d3bac83a715ec2902da8308f5fac7917fe58b50", "filename": "gcc/testsuite/gfortran.dg/bounds_check_array_ctor_4.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_4.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"foo\" }\n+!\n+! PR 36112\n+! Check correct bounds-checking behaviour for character-array-constructors.\n+\n+  call test (\"short\", \"this is long\")\n+contains\n+  subroutine test(r, s)\n+    character(len=*) :: r, s\n+    character(len=128) :: arr(2)\n+    arr = (/ r, s /)\n+  end subroutine test\n+end\n+! { dg-output \"Different CHARACTER lengths \\\\(5/12\\\\) in array constructor\" }"}, {"sha": "ad7f1b05469065dbc2b30643e9bbc023276cb084", "filename": "gcc/testsuite/gfortran.dg/bounds_check_array_ctor_5.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_5.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+!\n+! PR 36112\n+! Check correct bounds-checking behaviour for character-array-constructors.\n+! No need for -fbounds-check, enabled unconditionally.\n+\n+  character(len=5) :: s = \"hello\"\n+  character(len=128) :: arr(3)\n+  arr = (/ \"abc\", \"foo\", s /) ! { dg-error \"Different CHARACTER lengths\" }\n+end"}, {"sha": "c6f89e0de92e213621ec2b1c121f3ad8c9f16f1a", "filename": "gcc/testsuite/gfortran.dg/bounds_check_array_ctor_6.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_6.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"foo\" }\n+!\n+! PR 36112\n+! Check correct bounds-checking behaviour for character-array-constructors.\n+\n+  call test (\"short\", \"also5\")\n+contains\n+  subroutine test(r, s)\n+    character(len=*) :: r, s\n+    character(len=128) :: arr(3)\n+    arr = (/ r, s, \"this is too long\" /)\n+  end subroutine test\n+end\n+! { dg-output \"Different CHARACTER lengths \\\\(5/16\\\\) in array constructor\" }"}, {"sha": "2a13be2beb00fcd1e2dbdb6ebdb39310768d0c85", "filename": "gcc/testsuite/gfortran.dg/bounds_check_array_ctor_7.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_7.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"foo\" }\n+!\n+! PR 36112\n+! Check correct bounds-checking behaviour for character-array-constructors.\n+\n+  call test (\"short\")\n+contains\n+  subroutine test(s)\n+    character(len=*) :: s\n+    character(len=128) :: arr(3)\n+    arr = (/ \"this is long\", \"this one too\", s /)\n+  end subroutine test\n+end\n+! { dg-output \"Different CHARACTER lengths \\\\(12/5\\\\) in array constructor\" }"}, {"sha": "0d4ad0cfeb449382817f22c8c80aa540a791ada4", "filename": "gcc/testsuite/gfortran.dg/bounds_check_array_ctor_8.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_array_ctor_8.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"foo\" }\n+!\n+! PR 36112\n+! Check correct bounds-checking behaviour for character-array-constructors.\n+\n+  call test (\"short\")\n+contains\n+  subroutine test(s)\n+    character(len=*) :: s\n+    character(len=128) :: arr(3)\n+    arr = (/ s, \"this is long\", \"this one too\" /)\n+  end subroutine test\n+end\n+! { dg-output \"Different CHARACTER lengths \\\\(5/12\\\\) in array constructor\" }"}, {"sha": "cf920bdfb29e04fcde3c51d26ee05483828b7357", "filename": "gcc/testsuite/gfortran.dg/char_cons_len.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cons_len.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cons_len.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cons_len.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -3,7 +3,7 @@\n ! constructor, as an argument for LEN, would cause an ICE.\n !\n   character(11) :: chr1, chr2\n-  i = len ((/chr1, chr2, \"ggg\"/))\n+  i = len ((/chr1, chr2, \"ggg        \"/))\n   j = len ((/\"abcdefghijk\", chr1, chr2/))\n   k = len ((/'hello  ','goodbye'/))\n   l = foo (\"yes siree, Bob\")"}, {"sha": "920e106601483afd27265c7e03d2fdda03d8bc4d", "filename": "gcc/testsuite/gfortran.dg/char_initialiser_actual.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_initialiser_actual.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_initialiser_actual.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_initialiser_actual.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -5,10 +5,10 @@\n program char_initialiser\n   character*5, dimension(3) :: x\n   character*5, dimension(:), pointer :: y\n-  x=(/\"is Ja\",\"ne Fo\",\"nda\"/)\n+  x=(/\"is Ja\",\"ne Fo\",\"nda  \"/)\n   call sfoo (\"is Ja\", x(1))\n-  call afoo ((/\"is Ja\",\"ne Fo\",\"nda\"/), x)\n-  y => pfoo ((/\"is Ja\",\"ne Fo\",\"nda\"/))\n+  call afoo ((/\"is Ja\",\"ne Fo\",\"nda  \"/), x)\n+  y => pfoo ((/\"is Ja\",\"ne Fo\",\"nda  \"/))\n   call afoo (y, x)\n contains\n   subroutine sfoo(ch1, ch2)"}, {"sha": "3f92f0efa90324eacc7a5cd5d622bda6d0211637", "filename": "gcc/testsuite/gfortran.dg/char_length_1.f90", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_1.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -7,12 +7,13 @@\n ! Contributed by Tobias Burnus <tobias.burnus@physik.fu-berlin.de> \n !\n program test\n+  implicit none\n   character(10) :: a(3)\n   character(10) :: b(3)= &\n-       (/ 'Takata ', 'Tanaka', 'Hayashi' /) ! { dg-error \"same length\" }\n+       (/ 'Takata ', 'Tanaka', 'Hayashi' /) ! { dg-error \"Different CHARACTER\" }\n   character(4) :: c = \"abcde\"  ! { dg-warning \"being truncated\" }\n-  a =  (/ 'Takata', 'Tanaka ', 'Hayashi' /) ! { dg-error \"same length\" }\n+  a =  (/ 'Takata', 'Tanaka ', 'Hayashi' /) ! { dg-error \"Different CHARACTER\" }\n   a =  (/ 'Takata ', 'Tanaka ', 'Hayashi' /)\n-  b = \"abc\"\n+  b = \"abc\" ! { dg-error \"no IMPLICIT\" }\n   c = \"abcdefg\"   ! { dg-warning \"will be truncated\" }\n end program test"}, {"sha": "c28dce5255e2aefe9375b49aded10d3644e09618", "filename": "gcc/testsuite/gfortran.dg/pr15959.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr15959.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr15959.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr15959.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n ! Test initializer of character array. PR15959\n-character (*), parameter :: a (1:2) = (/'ab', 'abc'/)\n+character (*), parameter :: a (1:2) = (/'ab ', 'abc'/)\n if (a(2) .ne. 'abc') call abort()\n end"}, {"sha": "96bf283f0366b83bd042f2593ed25e362d025692", "filename": "gcc/testsuite/gfortran.dg/transfer_simplify_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fec49fbb65368451cde61064b45d3ce12a29b8/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_simplify_2.f90?ref=88fec49fbb65368451cde61064b45d3ce12a29b8", "patch": "@@ -92,7 +92,7 @@ subroutine integer8_to_complex4\n   end subroutine integer8_to_complex4\n \n   subroutine character16_to_complex8\n-    character(16), parameter ::  c1(2) = (/\"abcdefghijklmnop\",\"qrstuvwxyz1234567890\"/)\n+    character(16), parameter ::  c1(2) = (/\"abcdefghijklmnop\",\"qrstuvwxyz123456\"/)\n     character(16)            ::  c2(2) = c1\n     complex(8), parameter    ::  z1(2) = transfer (c1, (1.0_8,1.0_8), 2)\n     complex(8)               ::  z2(2)"}]}