{"sha": "29f26978866f32bddd656847441a3a953ffd7a21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlmMjY5Nzg4NjZmMzJiZGRkNjU2ODQ3NDQxYTNhOTUzZmZkN2EyMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-09-27T13:19:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-09-27T13:19:58Z"}, "message": "tree-vectorizer.h (_stmt_vec_info::reduc_fn): New.\n\n2019-09-27  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_stmt_vec_info::reduc_fn): New.\n\t(STMT_VINFO_REDUC_FN): Likewise.\n\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Initialize\n\tSTMT_VINFO_REDUC_FN.\n\t* tree-vect-loop.c (vect_is_simple_reduction): Fix STMT_VINFO_REDUC_IDX\n\tfor condition reductions.\n\t(vect_create_epilog_for_reduction): Compute all required state\n\tfrom the stmt to be vectorized.\n\t(vectorizable_reduction): Simplify vect_create_epilog_for_reduction\n\tinvocation and remove then dead code.  For single def-use chains\n\trecord only a single vector stmt.\n\nFrom-SVN: r276180", "tree": {"sha": "ab0278dd3939f70a41b9ab2739ff86508ebefc0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab0278dd3939f70a41b9ab2739ff86508ebefc0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29f26978866f32bddd656847441a3a953ffd7a21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f26978866f32bddd656847441a3a953ffd7a21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29f26978866f32bddd656847441a3a953ffd7a21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f26978866f32bddd656847441a3a953ffd7a21/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "67cb34efd8696f2710d8f818d4e25da818a9bff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67cb34efd8696f2710d8f818d4e25da818a9bff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67cb34efd8696f2710d8f818d4e25da818a9bff9"}], "stats": {"total": 166, "additions": 86, "deletions": 80}, "files": [{"sha": "0258bfc43ad9f00c47b2393d9db8dfdee62af0b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f26978866f32bddd656847441a3a953ffd7a21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f26978866f32bddd656847441a3a953ffd7a21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29f26978866f32bddd656847441a3a953ffd7a21", "patch": "@@ -1,3 +1,17 @@\n+2019-09-27  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (_stmt_vec_info::reduc_fn): New.\n+\t(STMT_VINFO_REDUC_FN): Likewise.\n+\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Initialize\n+\tSTMT_VINFO_REDUC_FN.\n+\t* tree-vect-loop.c (vect_is_simple_reduction): Fix STMT_VINFO_REDUC_IDX\n+\tfor condition reductions.\n+\t(vect_create_epilog_for_reduction): Compute all required state\n+\tfrom the stmt to be vectorized.\n+\t(vectorizable_reduction): Simplify vect_create_epilog_for_reduction\n+\tinvocation and remove then dead code.  For single def-use chains\n+\trecord only a single vector stmt.\n+\n 2019-09-27  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (aarch64_builtin_class): New enum."}, {"sha": "2947b0239fe1be66c839f2e809ad18e81a571390", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 68, "deletions": 80, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f26978866f32bddd656847441a3a953ffd7a21/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f26978866f32bddd656847441a3a953ffd7a21/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=29f26978866f32bddd656847441a3a953ffd7a21", "patch": "@@ -3070,7 +3070,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n \t  || !flow_bb_inside_loop_p (loop, gimple_bb (def1_info->stmt))\n \t  || vect_valid_reduction_input_p (def1_info)))\n     {\n-      STMT_VINFO_REDUC_IDX (def_stmt_info) = 1;\n+      STMT_VINFO_REDUC_IDX (def_stmt_info) = 1 + (code == COND_EXPR ? 1 : 0);\n       if (dump_enabled_p ())\n \treport_vect_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n       return def_stmt_info;\n@@ -3083,7 +3083,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n \t  || !flow_bb_inside_loop_p (loop, gimple_bb (def2_info->stmt))\n \t  || vect_valid_reduction_input_p (def2_info)))\n     {\n-      STMT_VINFO_REDUC_IDX (def_stmt_info) = 0;\n+      STMT_VINFO_REDUC_IDX (def_stmt_info) = 0 + (code == COND_EXPR ? 1 : 0);\n       if (dump_enabled_p ())\n \treport_vect_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n       return def_stmt_info;\n@@ -4212,38 +4212,15 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n    Create code at the loop-epilog to finalize the result of a reduction\n    computation. \n   \n-   VECT_DEFS is list of vector of partial results, i.e., the lhs's of vector \n-     reduction statements. \n    STMT_INFO is the scalar reduction stmt that is being vectorized.\n-   NCOPIES is > 1 in case the vectorization factor (VF) is bigger than the\n-     number of elements that we can fit in a vectype (nunits).  In this case\n-     we have to generate more than one vector stmt - i.e - we need to \"unroll\"\n-     the vector stmt by a factor VF/nunits.  For more details see documentation\n-     in vectorizable_operation.\n-   REDUC_FN is the internal function for the epilog reduction.\n-   REDUCTION_PHIS is a list of the phi-nodes that carry the reduction \n-     computation.\n-   REDUC_INDEX is the index of the operand in the right hand side of the \n-     statement that is defined by REDUCTION_PHI.\n-   DOUBLE_REDUC is TRUE if double reduction phi nodes should be handled.\n    SLP_NODE is an SLP node containing a group of reduction statements. The \n      first one in this group is STMT_INFO.\n-   INDUC_VAL is for INTEGER_INDUC_COND_REDUCTION the value to use for the case\n-     when the COND_EXPR is never true in the loop.  For MAX_EXPR, it needs to\n-     be smaller than any value of the IV in the loop, for MIN_EXPR larger than\n-     any value of the IV in the loop.\n-   INDUC_CODE is the code for epilog reduction if INTEGER_INDUC_COND_REDUCTION.\n-   NEUTRAL_OP is the value given by neutral_op_for_slp_reduction; it is\n-     null if this is not an SLP reduction\n+   SLP_NODE_INSTANCE is the SLP node instance containing SLP_NODE\n    REDUC_INDEX says which rhs operand of the STMT_INFO is the reduction phi\n      (counting from 0)\n \n    This function:\n-   1. Creates the reduction def-use cycles: sets the arguments for \n-      REDUCTION_PHIS:\n-      The loop-entry argument is the vectorized initial-value of the reduction.\n-      The loop-latch argument is taken from VECT_DEFS - the vector of partial \n-      sums.\n+   1. Completes the reduction def-use cycles.\n    2. \"Reduces\" each vector of partial results VECT_DEFS into a single result,\n       by calling the function specified by REDUC_FN if available, or by\n       other means (whole-vector shifts or a scalar loop).\n@@ -4253,7 +4230,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n      The flow at the entry to this function:\n \n         loop:\n-          vec_def = phi <null, null>            # REDUCTION_PHI\n+          vec_def = phi <vec_init, null>        # REDUCTION_PHI\n           VECT_DEF = vector_stmt                # vectorized form of STMT_INFO\n           s_loop = scalar_stmt                  # (scalar) STMT_INFO\n         loop_exit:\n@@ -4278,22 +4255,37 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n */\n \n static void\n-vect_create_epilog_for_reduction (vec<tree> vect_defs,\n-\t\t\t\t  stmt_vec_info stmt_info,\n-\t\t\t\t  gimple *reduc_def_stmt,\n-\t\t\t\t  enum tree_code code,\n-\t\t\t\t  int ncopies, internal_fn reduc_fn,\n-\t\t\t\t  vec<stmt_vec_info> reduction_phis,\n-                                  bool double_reduc, \n+vect_create_epilog_for_reduction (stmt_vec_info stmt_info,\n \t\t\t\t  slp_tree slp_node,\n-\t\t\t\t  slp_instance slp_node_instance,\n-\t\t\t\t  tree neutral_op, int reduc_index)\n+\t\t\t\t  slp_instance slp_node_instance)\n {\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  gphi *reduc_def_stmt\n+    = as_a <gphi *> (STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info))->stmt);\n+  enum tree_code code = STMT_VINFO_REDUC_CODE (stmt_info);\n+  internal_fn reduc_fn = STMT_VINFO_REDUC_FN (stmt_info);\n+  tree neutral_op = NULL_TREE;\n+  if (slp_node)\n+    neutral_op\n+      = neutral_op_for_slp_reduction (slp_node_instance->reduc_phis, code,\n+\t\t\t\t      REDUC_GROUP_FIRST_ELEMENT (stmt_info));\n+  bool double_reduc = false;\n+  if (nested_in_vect_loop_p (LOOP_VINFO_LOOP (loop_vinfo), stmt_info))\n+    {\n+      tree def_arg\n+\t= PHI_ARG_DEF_FROM_EDGE (reduc_def_stmt,\n+\t\t\t\t loop_preheader_edge \n+\t\t\t\t   (LOOP_VINFO_LOOP (loop_vinfo)->inner));\n+      stmt_vec_info def_arg_stmt_info = loop_vinfo->lookup_def (def_arg);\n+      if (def_arg_stmt_info\n+\t  && (STMT_VINFO_DEF_TYPE (def_arg_stmt_info)\n+\t      == vect_double_reduction_def))\n+\tdouble_reduc = true;\n+    }\n   tree induc_val = NULL_TREE;\n   stmt_vec_info prev_phi_info;\n   tree vectype;\n   machine_mode mode;\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo), *outer_loop = NULL;\n   basic_block exit_bb;\n   tree scalar_dest;\n@@ -4380,15 +4372,32 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n     }\n \n   /* Set phi nodes latch arguments.  */\n-  FOR_EACH_VEC_ELT (reduction_phis, i, phi_info)\n+  unsigned vec_num = 1;\n+  int ncopies = 0;\n+  if (slp_node)\n+    vec_num = SLP_TREE_VEC_STMTS (slp_node_instance->reduc_phis).length ();\n+  for (unsigned i = 0; i < vec_num; i++)\n     {\n-      tree def = vect_defs[i];\n-      for (j = 0; j < ncopies; j++)\n+      if (slp_node)\n+\t{\n+\t  def = gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[i]->stmt);\n+\t  phi_info = SLP_TREE_VEC_STMTS (slp_node_instance->reduc_phis)[i];\n+\t}\n+      else\n+\t{\n+\t  def = gimple_get_lhs (STMT_VINFO_VEC_STMT (stmt_info)->stmt);\n+\t  phi_info = STMT_VINFO_VEC_STMT (loop_vinfo->lookup_stmt (reduc_def_stmt));\n+\t}\n+      for (ncopies = 0;; ncopies++)\n         {\n           /* Set the loop-latch arg for the reduction-phi.  */\n-\t  if (j != 0)\n+\t  if (ncopies != 0)\n \t    {\n+\t      if (slp_node)\n+\t\tbreak;\n \t      phi_info = STMT_VINFO_RELATED_STMT (phi_info);\n+\t      if (!phi_info)\n+\t\tbreak;\n \t      def = vect_get_vec_def_for_stmt_copy (loop_vinfo, def);\n \t    }\n \n@@ -4474,9 +4483,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \t (CCOMPARE).  The then and else values mirror the main VEC_COND_EXPR:\n \t the reduction phi corresponds to NEW_PHI_TREE and the new values\n \t correspond to INDEX_BEFORE_INCR.  */\n-      gcc_assert (reduc_index >= 1);\n+      gcc_assert (STMT_VINFO_REDUC_IDX (stmt_info) >= 1);\n       tree index_cond_expr;\n-      if (reduc_index == 2)\n+      if (STMT_VINFO_REDUC_IDX (stmt_info) == 2)\n \tindex_cond_expr = build3 (VEC_COND_EXPR, cr_index_vector_type,\n \t\t\t\t  ccompare, indx_before_incr, new_phi_tree);\n       else\n@@ -4527,9 +4536,13 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \n   exit_bb = single_exit (loop)->dest;\n   prev_phi_info = NULL;\n-  new_phis.create (vect_defs.length ());\n-  FOR_EACH_VEC_ELT (vect_defs, i, def)\n+  new_phis.create (slp_node ? vec_num : ncopies);\n+  for (unsigned i = 0; i < vec_num; i++)\n     {\n+      if (slp_node)\n+\tdef = gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[i]->stmt);\n+      else\n+\tdef = gimple_get_lhs (STMT_VINFO_VEC_STMT (stmt_info)->stmt);\n       for (j = 0; j < ncopies; j++)\n         {\n \t  tree new_def = copy_ssa_name (def);\n@@ -4554,7 +4567,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n     {\n       loop = outer_loop;\n       exit_bb = single_exit (loop)->dest;\n-      inner_phis.create (vect_defs.length ());\n+      inner_phis.create (slp_node ? vec_num : ncopies);\n       FOR_EACH_VEC_ELT (new_phis, i, phi)\n \t{\n \t  stmt_vec_info phi_info = loop_vinfo->lookup_stmt (phi);\n@@ -5932,7 +5945,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   bool is_simple_use;\n   int i;\n   int ncopies;\n-  int epilog_copies;\n   stmt_vec_info prev_stmt_info, prev_phi_info;\n   bool single_defuse_cycle = false;\n   stmt_vec_info new_stmt_info = NULL;\n@@ -5947,8 +5959,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   auto_vec<tree> vec_oprnds0;\n   auto_vec<tree> vec_oprnds1;\n   auto_vec<tree> vec_oprnds2;\n-  auto_vec<tree> vect_defs;\n-  auto_vec<stmt_vec_info> phis;\n   int vec_num;\n   tree def0, tem;\n   tree cr_index_scalar_type = NULL_TREE, cr_index_vector_type = NULL_TREE;\n@@ -6705,6 +6715,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t\t\t  OPTIMIZE_FOR_SPEED))\n \treduc_fn = IFN_REDUC_MAX;\n     }\n+  STMT_VINFO_REDUC_FN (stmt_info) = reduc_fn;\n \n   if (reduction_type != EXTRACT_LAST_REDUCTION\n       && (!nested_cycle || double_reduc)\n@@ -6898,12 +6909,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       && (!STMT_VINFO_IN_PATTERN_P (use_stmt_info)\n \t  || !STMT_VINFO_PATTERN_DEF_SEQ (use_stmt_info))\n       && vect_stmt_to_vectorize (use_stmt_info) == stmt_info)\n-    {\n-      single_defuse_cycle = true;\n-      epilog_copies = 1;\n-    }\n-  else\n-    epilog_copies = ncopies;\n+    single_defuse_cycle = true;\n \n   /* If the reduction stmt is one of the patterns that have lane\n      reduction embedded we cannot handle the case of ! single_defuse_cycle.  */\n@@ -7002,16 +7008,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n         vec_oprnds2.create (1);\n     }\n \n-  phis.create (vec_num);\n-  vect_defs.create (vec_num);\n-  if (!slp_node)\n-    vect_defs.quick_push (NULL_TREE);\n-\n-  if (slp_node)\n-    phis.splice (SLP_TREE_VEC_STMTS (slp_node_instance->reduc_phis));\n-  else\n-    phis.quick_push (STMT_VINFO_VEC_STMT (reduc_def_info));\n-\n   for (j = 0; j < ncopies; j++)\n     {\n       if (code == COND_EXPR)\n@@ -7140,15 +7136,10 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    }\n \n           if (slp_node)\n-            {\n-\t      SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n-              vect_defs.quick_push (new_temp);\n-            }\n-          else\n-            vect_defs[0] = new_temp;\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n         }\n \n-      if (slp_node)\n+      if (slp_node || single_defuse_cycle)\n         continue;\n \n       if (j == 0)\n@@ -7159,15 +7150,12 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       prev_stmt_info = new_stmt_info;\n     }\n \n+  if (single_defuse_cycle && !slp_node)\n+    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt_info;\n+\n   /* Finalize the reduction-phi (set its arguments) and create the\n      epilog reduction code.  */\n-  if ((!single_defuse_cycle || code == COND_EXPR) && !slp_node)\n-    vect_defs[0] = gimple_get_lhs ((*vec_stmt)->stmt);\n-\n-  vect_create_epilog_for_reduction (vect_defs, stmt_info, reduc_def_phi,\n-\t\t\t\t    orig_code, epilog_copies, reduc_fn, phis,\n-\t\t\t\t    double_reduc, slp_node, slp_node_instance,\n-\t\t\t\t    neutral_op, reduc_index);\n+  vect_create_epilog_for_reduction (stmt_info, slp_node, slp_node_instance);\n \n   return true;\n }"}, {"sha": "800c99fea266fc65f2941652d7bad562e4562c69", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f26978866f32bddd656847441a3a953ffd7a21/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f26978866f32bddd656847441a3a953ffd7a21/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=29f26978866f32bddd656847441a3a953ffd7a21", "patch": "@@ -640,6 +640,7 @@ vec_info::new_stmt_vec_info (gimple *stmt)\n   STMT_VINFO_VEC_REDUCTION_TYPE (res) = TREE_CODE_REDUCTION;\n   STMT_VINFO_VEC_COND_REDUC_CODE (res) = ERROR_MARK;\n   STMT_VINFO_REDUC_CODE (res) = ERROR_MARK;\n+  STMT_VINFO_REDUC_FN (res) = IFN_LAST;\n   STMT_VINFO_REDUC_IDX (res) = -1;\n   STMT_VINFO_SLP_VECT_ONLY (res) = false;\n "}, {"sha": "d9171c0a3e8bb61cd0ad6d4a2c58fb3e4069f304", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f26978866f32bddd656847441a3a953ffd7a21/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f26978866f32bddd656847441a3a953ffd7a21/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=29f26978866f32bddd656847441a3a953ffd7a21", "patch": "@@ -951,6 +951,8 @@ class _stmt_vec_info {\n \n   /* The original reduction code, to be used in the epilogue.  */\n   enum tree_code reduc_code;\n+  /* An internal function we should use in the epilogue.  */\n+  internal_fn reduc_fn;\n \n   /* On a stmt participating in the reduction the index of the operand\n      on the reduction SSA cycle.  */\n@@ -1079,6 +1081,7 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_NUM_SLP_USES(S)\t(S)->num_slp_uses\n #define STMT_VINFO_REDUC_TYPE(S)\t(S)->reduc_type\n #define STMT_VINFO_REDUC_CODE(S)\t(S)->reduc_code\n+#define STMT_VINFO_REDUC_FN(S)\t\t(S)->reduc_fn\n #define STMT_VINFO_REDUC_DEF(S)\t\t(S)->reduc_def\n #define STMT_VINFO_SLP_VECT_ONLY(S)     (S)->slp_vect_only_p\n "}]}