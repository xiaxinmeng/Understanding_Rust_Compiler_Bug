{"sha": "5a06474ce9fc9e586e3ae5a51bed465335dc3c75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEwNjQ3NGNlOWZjOWU1ODZlM2FlNWE1MWJlZDQ2NTMzNWRjM2M3NQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-10-03T03:58:20Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-10-03T03:58:20Z"}, "message": "re PR fortran/19262 (more than thirty-nine continuation lines should issue a std-warn)\n\n2006-10-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n    PR fortran/19262\n    * gfortran.h (gfc_option_t): Add max_continue_fixed and max_continue_free.\n    * options.c (gfc_init_options): Initialize fixed form and free form\n    consecutive continuation line limits.\n    * scanner.c (gfc_scanner_init_1): Initialize continue_line\n    and continue_count. (gfc_next_char_literal): Count the number of\n    continuation lines in the current statement and warn if\n    limit is exceeded.\n\n2006-10-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n    PR fortran/19260\n    * scanner.c (gfc_next_char_literal): Add check for missing '&'\n    and warn if in_string, otherwise return ' '.\n\nFrom-SVN: r117384", "tree": {"sha": "e74b55da3e465b70067b338b94f7b616d7926f52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e74b55da3e465b70067b338b94f7b616d7926f52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a06474ce9fc9e586e3ae5a51bed465335dc3c75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a06474ce9fc9e586e3ae5a51bed465335dc3c75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a06474ce9fc9e586e3ae5a51bed465335dc3c75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a06474ce9fc9e586e3ae5a51bed465335dc3c75/comments", "author": null, "committer": null, "parents": [{"sha": "2834a5fe89e275ce695eaf2a64bb99f3cdc76dd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2834a5fe89e275ce695eaf2a64bb99f3cdc76dd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2834a5fe89e275ce695eaf2a64bb99f3cdc76dd3"}], "stats": {"total": 86, "additions": 79, "deletions": 7}, "files": [{"sha": "983d892958b14e030efe20ad2a05a4a694984068", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a06474ce9fc9e586e3ae5a51bed465335dc3c75/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a06474ce9fc9e586e3ae5a51bed465335dc3c75/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5a06474ce9fc9e586e3ae5a51bed465335dc3c75", "patch": "@@ -1,3 +1,20 @@\n+2006-10-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+    PR fortran/19262\n+    * gfortran.h (gfc_option_t): Add max_continue_fixed and max_continue_free.\n+    * options.c (gfc_init_options): Initialize fixed form and free form\n+    consecutive continuation line limits.\n+    * scanner.c (gfc_scanner_init_1): Initialize continue_line\n+    and continue_count. (gfc_next_char_literal): Count the number of\n+    continuation lines in the current statement and warn if\n+    limit is exceeded.\n+\n+2006-10-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+    PR fortran/19260\n+    * scanner.c (gfc_next_char_literal): Add check for missing '&'\n+    and warn if in_string, otherwise return ' '.\n+\n 2006-10-02  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR fortran/29210"}, {"sha": "0daa8f58888085cbb16fa5702dbb90619199c2a6", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a06474ce9fc9e586e3ae5a51bed465335dc3c75/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a06474ce9fc9e586e3ae5a51bed465335dc3c75/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5a06474ce9fc9e586e3ae5a51bed465335dc3c75", "patch": "@@ -1613,6 +1613,8 @@ typedef struct\n      emits a fatal error.  */\n   int fixed_line_length; /* maximum line length in fixed-form.  */\n   int free_line_length; /* maximum line length in free-form.  */\n+  int max_continue_fixed;\n+  int max_continue_free;\n   int max_identifier_length;\n   int verbose;\n "}, {"sha": "4d76030548cd070c0022bd02384fe5c872273305", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a06474ce9fc9e586e3ae5a51bed465335dc3c75/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a06474ce9fc9e586e3ae5a51bed465335dc3c75/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=5a06474ce9fc9e586e3ae5a51bed465335dc3c75", "patch": "@@ -48,6 +48,8 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   gfc_option.source_form = FORM_UNKNOWN;\n   gfc_option.fixed_line_length = -1;\n   gfc_option.free_line_length = -1;\n+  gfc_option.max_continue_fixed = 19;\n+  gfc_option.max_continue_free = 39;\n   gfc_option.max_identifier_length = GFC_MAX_SYMBOL_LEN;\n   gfc_option.verbose = 0;\n \n@@ -586,6 +588,8 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n       gfc_option.allow_std = GFC_STD_F95_OBS | GFC_STD_F77 \n \t| GFC_STD_F2003 | GFC_STD_F95;\n       gfc_option.warn_std = GFC_STD_F95_OBS;\n+      gfc_option.max_continue_fixed = 255;\n+      gfc_option.max_continue_free = 255;\n       gfc_option.max_identifier_length = 63;\n       gfc_option.warn_ampersand = 1;\n       break;"}, {"sha": "59b2e704bfa7ed1a4f2d22a8058762fd1b3f8797", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a06474ce9fc9e586e3ae5a51bed465335dc3c75/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a06474ce9fc9e586e3ae5a51bed465335dc3c75/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=5a06474ce9fc9e586e3ae5a51bed465335dc3c75", "patch": "@@ -61,6 +61,7 @@ static gfc_directorylist *include_dirs;\n static gfc_file *file_head, *current_file;\n \n static int continue_flag, end_flag, openmp_flag;\n+static int continue_count, continue_line;\n static locus openmp_locus;\n \n gfc_source_form gfc_current_form;\n@@ -71,6 +72,7 @@ const char *gfc_source_file;\n static FILE *gfc_src_file;\n static char *gfc_src_preprocessor_lines[2];\n \n+extern int pedantic;\n \n /* Main scanner initialization.  */\n \n@@ -81,6 +83,9 @@ gfc_scanner_init_1 (void)\n   line_head = NULL;\n   line_tail = NULL;\n \n+  continue_count = 0;\n+  continue_line = 0;\n+\n   end_flag = 0;\n }\n \n@@ -585,7 +590,10 @@ gfc_next_char_literal (int in_string)\n restart:\n   c = next_char ();\n   if (gfc_at_end ())\n-    return c;\n+    {\n+      continue_count = 0;\n+      return c;\n+    }\n \n   if (gfc_current_form == FORM_FREE)\n     {\n@@ -644,8 +652,22 @@ gfc_next_char_literal (int in_string)\n       else\n \tgfc_advance_line ();\n \n-      /* We've got a continuation line and need to find where it continues.\n-\t First eat any comment lines.  */\n+      /* We've got a continuation line.  If we are on the very next line after\n+\t the last continuation, increment the continuation line count and\n+\t check whether the limit has been exceeded.  */\n+      if (gfc_current_locus.lb->linenum == continue_line + 1)\n+\t{\n+\t  if (++continue_count == gfc_option.max_continue_free)\n+\t    {\n+\t      if (gfc_notification_std (GFC_STD_GNU)\n+\t\t  || pedantic)\n+\t\tgfc_warning (\"Limit of %d continuations exceeded in statement at %C\",\n+\t\t\t      gfc_option.max_continue_free);\n+\t    }\n+\t}\n+      continue_line = gfc_current_locus.lb->linenum;\n+\n+      /* Now find where it continues. First eat any comment lines.  */\n       gfc_skip_comments ();\n \n       if (prev_openmp_flag != openmp_flag)\n@@ -681,10 +703,18 @@ gfc_next_char_literal (int in_string)\n \n       if (c != '&')\n \t{\n-\t  if (in_string && gfc_option.warn_ampersand)\n-\t    gfc_warning (\"Missing '&' in continued character constant at %C\");\n-\n-\t  gfc_current_locus.nextc--;\n+\t  if (in_string)\n+\t    {\n+\t      if (gfc_option.warn_ampersand)\n+\t\tgfc_warning_now (\"Missing '&' in continued character constant at %C\");\n+\t      gfc_current_locus.nextc--;\n+\t    }\n+\t  else\n+\t    {\n+\t      c = ' ';\n+\t      gfc_current_locus = old_loc;\n+\t      goto done;\n+\t    }\n \t}\n     }\n   else\n@@ -738,6 +768,23 @@ gfc_next_char_literal (int in_string)\n       c = next_char ();\n       if (c == '0' || c == ' ' || c == '\\n')\n \tgoto not_continuation;\n+\n+      /* We've got a continuation line.  If we are on the very next line after\n+\t the last continuation, increment the continuation line count and\n+\t check whether the limit has been exceeded.  */\n+      if (gfc_current_locus.lb->linenum == continue_line + 1)\n+\t{\n+\t  if (++continue_count == gfc_option.max_continue_fixed)\n+\t    {\n+\t      if (gfc_notification_std (GFC_STD_GNU)\n+\t\t  || pedantic)\n+\t\tgfc_warning (\"Limit of %d continuations exceeded in statement at %C\",\n+\t\t\t      gfc_option.max_continue_fixed);\n+\t    }\n+\t}\n+\n+      if (continue_line < gfc_current_locus.lb->linenum)\n+\tcontinue_line = gfc_current_locus.lb->linenum;\n     }\n \n   /* Ready to read first character of continuation line, which might\n@@ -749,6 +796,8 @@ gfc_next_char_literal (int in_string)\n   gfc_current_locus = old_loc;\n \n done:\n+  if (c == '\\n')\n+    continue_count = 0;\n   continue_flag = 0;\n   return c;\n }"}]}