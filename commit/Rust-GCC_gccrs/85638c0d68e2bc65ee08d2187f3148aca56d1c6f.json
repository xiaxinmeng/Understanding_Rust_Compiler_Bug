{"sha": "85638c0d68e2bc65ee08d2187f3148aca56d1c6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU2MzhjMGQ2OGUyYmM2NWVlMDhkMjE4N2YzMTQ4YWNhNTZkMWM2Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-12T12:03:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-12T12:03:47Z"}, "message": "(rs6000_override_options): Use new TARGET flags and add some more cpu choices.\n\n(output_prolog, output_epilog): Support new mnemonics and avoid using\nlm/stm when not POWER.\n\nFrom-SVN: r5747", "tree": {"sha": "e6804f2e4469fcfea9821727bdd119473437ccd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6804f2e4469fcfea9821727bdd119473437ccd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85638c0d68e2bc65ee08d2187f3148aca56d1c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85638c0d68e2bc65ee08d2187f3148aca56d1c6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85638c0d68e2bc65ee08d2187f3148aca56d1c6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85638c0d68e2bc65ee08d2187f3148aca56d1c6f/comments", "author": null, "committer": null, "parents": [{"sha": "6febd5819dbd5e3407b8880416f16c77018081ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6febd5819dbd5e3407b8880416f16c77018081ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6febd5819dbd5e3407b8880416f16c77018081ab"}], "stats": {"total": 140, "additions": 92, "deletions": 48}, "files": [{"sha": "62fe8cfa05405cc0087a202833a9d48d5d65f409", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 92, "deletions": 48, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85638c0d68e2bc65ee08d2187f3148aca56d1c6f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85638c0d68e2bc65ee08d2187f3148aca56d1c6f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=85638c0d68e2bc65ee08d2187f3148aca56d1c6f", "patch": "@@ -69,37 +69,62 @@ rs6000_override_options ()\n {\n   int i;\n \n+  /* Simplify the entries below by making a mask for any POWER\n+     variant and any PowerPC variant.  */\n+\n+#define POWER_MASKS (MASK_POWER | MASK_POWER2)\n+#define POWERPC_MASKS (MASK_POWERPC | MASK_POWERPCSQR | MASK_POWERPC64)\n+\n   static struct ptt\n     {\n       char *name;\t\t/* Canonical processor name.  */\n       enum processor_type processor; /* Processor type enum value.  */\n       int target_enable;\t/* Target flags to enable.  */\n       int target_disable;\t/* Target flags to disable.  */\n     } processor_target_table[]\n-      = {{\"all\", PROCESSOR_DEFAULT,\n-\t    0, MASK_POWER | MASK_POWERPC | MASK_POWERPC64},\n-\t {\"rios\", PROCESSOR_RIOS1,\n-\t    MASK_POWER, MASK_POWERPC | MASK_POWERPC64},\n-\t {\"rios1\", PROCESSOR_RIOS1,\n-\t    MASK_POWER, MASK_POWERPC | MASK_POWERPC64},\n-\t {\"rios2\", PROCESSOR_RIOS2,\n-\t    MASK_POWER, MASK_POWERPC | MASK_POWERPC64},\n+      = {{\"all\", PROCESSOR_DEFAULT, 0, POWER_MASKS | POWERPC_MASKS},\n+\t {\"rios\", PROCESSOR_RIOS1, MASK_POWER, MASK_POWER2 | POWERPC_MASKS},\n+\t {\"rios1\", PROCESSOR_RIOS1, MASK_POWER, MASK_POWER2 | POWERPC_MASKS},\n+\t {\"rios2\", PROCESSOR_RIOS2, MASK_POWER | MASK_POWER2 , POWERPC_MASKS},\n \t {\"601\", PROCESSOR_PPC601,\n-\t    MASK_POWER | MASK_POWERPC | MASK_NEW_MNEMONICS, MASK_POWERPC64},\n+\t    MASK_POWER | MASK_POWERPC | MASK_NEW_MNEMONICS,\n+\t    MASK_POWER2 | MASK_POWERPCSQR | MASK_POWERPC64},\n \t {\"mpc601\", PROCESSOR_PPC601,\n-\t    MASK_POWER | MASK_POWERPC | MASK_NEW_MNEMONICS, MASK_POWERPC64},\n+\t    MASK_POWER | MASK_POWERPC | MASK_NEW_MNEMONICS,\n+\t    MASK_POWER2 | MASK_POWERPCSQR | MASK_POWERPC64},\n+\t {\"ppc601\", PROCESSOR_PPC601,\n+\t    MASK_POWER | MASK_POWERPC | MASK_NEW_MNEMONICS,\n+\t    MASK_POWER2 | MASK_POWERPCSQR | MASK_POWERPC64},\n \t {\"603\", PROCESSOR_PPC603,\n-\t    MASK_POWERPC | MASK_NEW_MNEMONICS, MASK_POWER | MASK_POWERPC64},\n+\t    MASK_POWERPC | MASK_POWERPCSQR | MASK_NEW_MNEMONICS,\n+\t    POWER_MASKS | MASK_POWERPC64},\n \t {\"mpc603\", PROCESSOR_PPC603,\n-\t    MASK_POWERPC | MASK_NEW_MNEMONICS, MASK_POWER | MASK_POWERPC64},\n+\t    MASK_POWERPC | MASK_POWERPCSQR | MASK_NEW_MNEMONICS,\n+\t    POWER_MASKS | MASK_POWERPC64},\n+\t {\"ppc603\", PROCESSOR_PPC603,\n+\t    MASK_POWERPC | MASK_POWERPCSQR | MASK_NEW_MNEMONICS,\n+\t    POWER_MASKS | MASK_POWERPC64},\n \t {\"604\", PROCESSOR_PPC604,\n-\t    MASK_POWERPC | MASK_NEW_MNEMONICS, MASK_POWER | MASK_POWERPC64},\n+\t    MASK_POWERPC | MASK_POWERPCSQR | MASK_NEW_MNEMONICS,\n+\t    POWER_MASKS | MASK_POWERPC64},\n \t {\"mpc604\", PROCESSOR_PPC604,\n-\t    MASK_POWERPC | MASK_NEW_MNEMONICS, MASK_POWER | MASK_POWERPC64},\n+\t    MASK_POWERPC | MASK_POWERPCSQR | MASK_NEW_MNEMONICS,\n+\t    POWER_MASKS | MASK_POWERPC64},\n+\t {\"ppc604\", PROCESSOR_PPC604,\n+\t    MASK_POWERPC | MASK_POWERPCSQR | MASK_NEW_MNEMONICS,\n+\t    POWER_MASKS | MASK_POWERPC64},\n \t {\"620\", PROCESSOR_PPC620,\n-\t    MASK_POWERPC | MASK_POWERPC64 | MASK_NEW_MNEMONICS, MASK_POWER},\n+\t    (MASK_POWERPC | MASK_POWERPCSQR | MASK_POWERPC64\n+\t     | MASK_NEW_MNEMONICS),\n+\t      POWER_MASKS},\n \t {\"mpc620\", PROCESSOR_PPC620,\n-\t    MASK_POWERPC | MASK_POWERPC64 | MASK_NEW_MNEMONICS, MASK_POWER}};\n+\t    (MASK_POWERPC | MASK_POWERPCSQR | MASK_POWERPC64\n+\t     | MASK_NEW_MNEMONICS),\n+\t      POWER_MASKS},\n+\t {\"ppc620\", PROCESSOR_PPC620,\n+\t    (MASK_POWERPC | MASK_POWERPCSQR | MASK_POWERPC64\n+\t     | MASK_NEW_MNEMONICS),\n+\t      POWER_MASKS}};\n \n   int ptt_size = sizeof (processor_target_table) / sizeof (struct ptt);\n \n@@ -1407,58 +1432,68 @@ output_prolog (file, size)\n \n   /* If we use the link register, get it into r0.  */\n   if (regs_ever_live[65])\n-    fprintf (file, \"\\tmflr 0\\n\");\n+    asm_fprintf (file, \"\\tmflr 0\\n\");\n \n   /* If we need to save CR, put it into r12.  */\n   if (must_save_cr ())\n-    fprintf (file, \"\\tmfcr 12\\n\");\n+    asm_fprintf (file, \"\\tmfcr 12\\n\");\n \n   /* Do any required saving of fpr's.  If only one or two to save, do it\n      ourself.  Otherwise, call function.  Note that since they are statically\n      linked, we do not need a nop following them.  */\n   if (first_fp_reg == 62)\n-    fprintf (file, \"\\tstfd 30,-16(1)\\n\\tstfd 31,-8(1)\\n\");\n+    asm_fprintf (file, \"\\tstfd 30,-16(1)\\n\\tstfd 31,-8(1)\\n\");\n   else if (first_fp_reg == 63)\n-    fprintf (file, \"\\tstfd 31,-8(1)\\n\");\n+    asm_fprintf (file, \"\\tstfd 31,-8(1)\\n\");\n   else if (first_fp_reg != 64)\n-    fprintf (file, \"\\tbl ._savef%d\\n\", first_fp_reg - 32);\n+    asm_fprintf (file, \"\\tbl ._savef%d\\n\", first_fp_reg - 32);\n \n   /* Now save gpr's.  */\n-  if (first_reg == 31)\n-    fprintf (file, \"\\tst 31,%d(1)\\n\", -4 - (64 - first_fp_reg) * 8);\n+  if (! TARGET_POWER || first_reg == 31)\n+    {\n+      int regno, loc;\n+\n+      for (regno = first_reg,\n+\t   loc = - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8;\n+\t   regno < 32;\n+\t   regno++, loc += 4)\n+\tasm_fprintf (file, \"\\t{st|stw} %d,%d(1)\\n\", regno, loc);\n+    }\n+\n   else if (first_reg != 32)\n-    fprintf (file, \"\\tstm %d,%d(1)\\n\", first_reg,\n+    asm_fprintf (file, \"\\t{stm|stmw} %d,%d(1)\\n\", first_reg,\n \t     - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8);\n \n   /* Save lr if we used it.  */\n   if (regs_ever_live[65])\n-    fprintf (file, \"\\tst 0,8(1)\\n\");\n+    asm_fprintf (file, \"\\t{st|stw} 0,8(1)\\n\");\n \n   /* Save CR if we use any that must be preserved.  */\n   if (must_save_cr ())\n-    fprintf (file, \"\\tst 12,4(1)\\n\");\n+    asm_fprintf (file, \"\\t{st|stw} 12,4(1)\\n\");\n \n   /* Update stack and set back pointer.  */\n   if (must_push)\n     {\n       if (total_size < 32767)\n-\tfprintf (file, \"\\tstu 1,%d(1)\\n\", - total_size);\n+\tasm_fprintf (file, \"\\t{stu|stwu} 1,%d(1)\\n\", - total_size);\n       else\n \t{\n-\t  fprintf (file, \"\\tcau 0,0,%d\\n\\toril 0,0,%d\\n\",\n+\t  asm_fprintf (file, \"\\t{cau|addis} 0,0,%d\\n\\t{oril|ori} 0,0,%d\\n\",\n \t\t   (total_size >> 16) & 0xffff, total_size & 0xffff);\n-\t  fprintf (file, \"\\tsf 12,0,1\\n\\tst 1,0(12)\\n\\toril 1,12,0\\n\");\n+\t  asm_fprintf (file, \"\\t{sf|subfc} 12,0,1\\n\");\n+\t  asm_fprintf (file, \"\\t{st|stw} 1,0(12)\\n\\t{oril|ori} 1,12,0\\n\");\n \t}\n     }\n \n   /* Set frame pointer, if needed.  */\n   if (frame_pointer_needed)\n-    fprintf (file, \"\\toril 31,1,0\\n\");\n+    asm_fprintf (file, \"\\t{oril|ori} 31,1,0\\n\");\n \n   /* If TARGET_MINIMAL_TOC, and the constant pool is needed, then load the\n      TOC_TABLE address into register 30.  */\n   if (TARGET_MINIMAL_TOC && get_pool_size () != 0)\n-    fprintf (file, \"\\tl 30,LCTOC..0(2)\\n\");\n+    asm_fprintf (file, \"\\t{l|lwz} 30,LCTOC..0(2)\\n\");\n }\n \n /* Write function epilogue.  */\n@@ -1489,49 +1524,58 @@ output_epilog (file, size)\n \t we know what size to update it with.  */\n       if (frame_pointer_needed || current_function_calls_alloca\n \t  || total_size > 32767)\n-\tfprintf (file, \"\\tl 1,0(1)\\n\");\n+\tasm_fprintf (file, \"\\t{l|lwz} 1,0(1)\\n\");\n       else if (must_push)\n-\tfprintf (file, \"\\tai 1,1,%d\\n\", total_size);\n+\tasm_fprintf (file, \"\\t{ai|addic} 1,1,%d\\n\", total_size);\n \n       /* Get the old lr if we saved it.  */\n       if (regs_ever_live[65])\n-\tfprintf (file, \"\\tl 0,8(1)\\n\");\n+\tasm_fprintf (file, \"\\t{l|lwz} 0,8(1)\\n\");\n \n       /* Get the old cr if we saved it.  */\n       if (must_save_cr ())\n-\tfprintf (file, \"\\tl 12,4(1)\\n\");\n+\tasm_fprintf (file, \"\\t{l|lwz} 12,4(1)\\n\");\n \n       /* Set LR here to try to overlap restores below.  */\n       if (regs_ever_live[65])\n-\tfprintf (file, \"\\tmtlr 0\\n\");\n+\tasm_fprintf (file, \"\\tmtlr 0\\n\");\n \n       /* Restore gpr's.  */\n-      if (first_reg == 31)\n-\tfprintf (file, \"\\tl 31,%d(1)\\n\", -4 - (64 - first_fp_reg) * 8);\n+      if (! TARGET_POWER || first_reg == 31)\n+\t{\n+\t  int regno, loc;\n+\n+\t  for (regno = first_reg,\n+\t       loc = - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8;\n+\t       regno < 32;\n+\t       regno++, loc += 4)\n+\t    asm_fprintf (file, \"\\t{l|lwz} %d,%d(1)\\n\", regno, loc);\n+\t}\n+\n       else if (first_reg != 32)\n-\tfprintf (file, \"\\tlm %d,%d(1)\\n\", first_reg,\n-\t\t - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8);\n+\tasm_fprintf (file, \"\\t{lm|lmw} %d,%d(1)\\n\", first_reg,\n+\t     - (32 - first_reg) * 4 - (64 - first_fp_reg) * 8);\n \n       /* Restore fpr's if we can do it without calling a function.  */\n       if (first_fp_reg == 62)\n-\tfprintf (file, \"\\tlfd 30,-16(1)\\n\\tlfd 31,-8(1)\\n\");\n+\tasm_fprintf (file, \"\\tlfd 30,-16(1)\\n\\tlfd 31,-8(1)\\n\");\n       else if (first_fp_reg == 63)\n-\tfprintf (file, \"\\tlfd 31,-8(1)\\n\");\n+\tasm_fprintf (file, \"\\tlfd 31,-8(1)\\n\");\n \n       /* If we saved cr, restore it here.  Just those of cr2, cr3, and cr4\n \t that were used.  */\n       if (must_save_cr ())\n-\tfprintf (file, \"\\tmtcrf %d,12\\n\",\n-\t\t (regs_ever_live[70] != 0) * 0x20\n-\t\t + (regs_ever_live[71] != 0) * 0x10\n-\t\t + (regs_ever_live[72] != 0) * 0x8);\n+\tasm_fprintf (file, \"\\tmtcrf %d,12\\n\",\n+\t\t     (regs_ever_live[70] != 0) * 0x20\n+\t\t     + (regs_ever_live[71] != 0) * 0x10\n+\t\t     + (regs_ever_live[72] != 0) * 0x8);\n \n       /* If we have to restore more than two FP registers, branch to the\n \t restore function.  It will return to our caller.  */\n       if (first_fp_reg < 62)\n-\tfprintf (file, \"\\tb ._restf%d\\n\", first_fp_reg - 32);\n+\tasm_fprintf (file, \"\\tb ._restf%d\\n\", first_fp_reg - 32);\n       else\n-\tfprintf (file, \"\\tbr\\n\");\n+\tasm_fprintf (file, \"\\t{br|blr}\\n\");\n     }\n \n   /* Output a traceback table here.  See /usr/include/sys/debug.h for info"}]}