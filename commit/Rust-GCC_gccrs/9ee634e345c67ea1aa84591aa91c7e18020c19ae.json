{"sha": "9ee634e345c67ea1aa84591aa91c7e18020c19ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVlNjM0ZTM0NWM2N2VhMWFhODQ1OTFhYTkxYzdlMTgwMjBjMTlhZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-06-06T09:24:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-06-06T09:24:26Z"}, "message": "function.c (FLOOR_ROUND, CEIL_ROUND): Fix.\n\n\t* function.c (FLOOR_ROUND, CEIL_ROUND): Fix.\n\t* i386.md (gen_pro_epilogue_adjust_stack): Deal with gigantic stack frames.\n\t(pro_epilogue_adjust_stack_rex64_2): New pattern\n\n\t* cfghooks.h, cfghooks.c: New files.\n\t* Makefile.in (BASIC_BLOCK_H): Depends on cfghooks.h.\n\t(OBJS): Add cfghooks.o.\n\t(cfghooks.o): New rule.\n\t* basic-block.h (split_edge): Rename to rtl_split_edge.\n\t(verify_flow_info): Rename to rtl_verify_flow_info.\n\t(cfghooks.h): Included here.\n\t* cfgrtl.c (split_edge): Renamed rtl_split_edge.\n\t(verify_flow_info): Renamed rtl_verify_flow_info.\n\t* toplev.c (rest_of_compilation): Call rtl_register_cfg_hooks.\n\n\t* basic-block.h (split_block, split_edge, flow_delete_block,\n\tredirect_edge_and_branch, redirect_edge_and_branch_force): Delete.\n\t(flow_delete_block_noexpunge):  Return void.\n\t* cfg.c (verify_flow_info): New function.\n\t* cfgcleanup.c (try_simplify_condjump, outgoing_edges_match,\n\ttry_crossjump_to_edge, try_optimize_cfg, delete_unreachable_blocks):\n\tUse delete_block.\n\t* cfglayout.c (function_footer): Rename to...\n\t(cfg_layout_function_footer): ... this variable\n\t(unlink_insn_chain): Make global.\n\t(fixup_reorder_chain, record_effective_endpoints): Update.\n\t(cleanup_unconditional_jumps): Use delete_block.\n\t(cfg_layout_redirect_edge, cfg_layout_split_block): Move to cfgrtl.c\n\t(cfg_layout_duplicate_bb): Use redirect_edge_and_branch_force.\n\t(cfg_layout_initialize, cfg_layout_finalize): Update hooks.\n\t* cfglayout.h (cfg_layout_redirect_edge, cfg_layout_split_block):  Delete.\n\t(cfg_layout_function_footer): Declare.\n\t* cfgloopmanip (split_loop_bb): Do not update RBI.\n\t(remove_bbs): Use delete_block.\n\t(loop_reidrect_edge, loop_delete_branch_edge): Use\n\tredirect_edge_and_branch.\n\t(create_preheader): Use split_block and redirect_edge_and_branch_force.\n\t(split_edge_with): Likewise.\n\t* cfgrtl.c: Include cfglayout.h\n\t(split_edge): Rename to ...\n\t(rtl_split_edge) ... this one; make local.\n\t(redirect_edge_and_branch): Rename to ...\n\t(rtl_redirect_edge_and_branch) ... this one; make local.\n\t(redirect_edge_and_branch_force): Rename to ...\n\t(rtl_redirect_edge_and_branch_force) ... this one; make local.\n\t(cfg_layout_delete_block, cfg_layout_delete_edge_and_branch_force): New.\n\t(cfg_layout_redirect_edge_and_branch, cfg_layout_split_block): Move here from\n\tcfglayout.c; update to directly call RTL counterparts.\n\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hooks): New functions.\n\t* ifcvt.c (find_cond_trap): Use delete_block.\n\t(find_if_case_1): Use delete_block.\n\t(find_if_case_2): Use delete_block.\n\t* rtl.h (unlink_insn_chain): Declare.\n\t* toplev.c (rtl_reigster_cfg_hooks): New.\n\nFrom-SVN: r67535", "tree": {"sha": "366519e64f386e83f2c89bfffb438c340d608e78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/366519e64f386e83f2c89bfffb438c340d608e78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ee634e345c67ea1aa84591aa91c7e18020c19ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee634e345c67ea1aa84591aa91c7e18020c19ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ee634e345c67ea1aa84591aa91c7e18020c19ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee634e345c67ea1aa84591aa91c7e18020c19ae/comments", "author": null, "committer": null, "parents": [{"sha": "7654db1b6667c4bb7fa927c3628cf661ca8465d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7654db1b6667c4bb7fa927c3628cf661ca8465d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7654db1b6667c4bb7fa927c3628cf661ca8465d9"}], "stats": {"total": 567, "additions": 427, "deletions": 140}, "files": [{"sha": "af477d2eed60c16586b96f2879ad608377aa33c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -1,3 +1,64 @@\n+Fri Jun  6 11:02:35 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* function.c (FLOOR_ROUND, CEIL_ROUND): Fix.\n+\t* i386.md (gen_pro_epilogue_adjust_stack): Deal with gigantic stack frames.\n+\t(pro_epilogue_adjust_stack_rex64_2): New pattern\n+\n+Fri Jun  6 11:03:14 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\t\t\t       Pop Sebastian\n+\t\t\t       Zdenek Dvorak <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cfghooks.h, cfghooks.c: New files.\n+\t* Makefile.in (BASIC_BLOCK_H): Depends on cfghooks.h.\n+\t(OBJS): Add cfghooks.o.\n+\t(cfghooks.o): New rule.\n+\t* basic-block.h (split_edge): Rename to rtl_split_edge.\n+\t(verify_flow_info): Rename to rtl_verify_flow_info.\n+\t(cfghooks.h): Included here.\n+\t* cfgrtl.c (split_edge): Renamed rtl_split_edge.\n+\t(verify_flow_info): Renamed rtl_verify_flow_info.\n+\t* toplev.c (rest_of_compilation): Call rtl_register_cfg_hooks.\n+\n+\t* basic-block.h (split_block, split_edge, flow_delete_block,\n+\tredirect_edge_and_branch, redirect_edge_and_branch_force): Delete.\n+\t(flow_delete_block_noexpunge):  Return void.\n+\t* cfg.c (verify_flow_info): New function.\n+\t* cfgcleanup.c (try_simplify_condjump, outgoing_edges_match,\n+\ttry_crossjump_to_edge, try_optimize_cfg, delete_unreachable_blocks):\n+\tUse delete_block.\n+\t* cfglayout.c (function_footer): Rename to...\n+\t(cfg_layout_function_footer): ... this variable\n+\t(unlink_insn_chain): Make global.\n+\t(fixup_reorder_chain, record_effective_endpoints): Update.\n+\t(cleanup_unconditional_jumps): Use delete_block.\n+\t(cfg_layout_redirect_edge, cfg_layout_split_block): Move to cfgrtl.c\n+\t(cfg_layout_duplicate_bb): Use redirect_edge_and_branch_force.\n+\t(cfg_layout_initialize, cfg_layout_finalize): Update hooks.\n+\t* cfglayout.h (cfg_layout_redirect_edge, cfg_layout_split_block):  Delete.\n+\t(cfg_layout_function_footer): Declare.\n+\t* cfgloopmanip (split_loop_bb): Do not update RBI.\n+\t(remove_bbs): Use delete_block.\n+\t(loop_reidrect_edge, loop_delete_branch_edge): Use\n+\tredirect_edge_and_branch.\n+\t(create_preheader): Use split_block and redirect_edge_and_branch_force.\n+\t(split_edge_with): Likewise.\n+\t* cfgrtl.c: Include cfglayout.h\n+\t(split_edge): Rename to ...\n+\t(rtl_split_edge) ... this one; make local.\n+\t(redirect_edge_and_branch): Rename to ...\n+\t(rtl_redirect_edge_and_branch) ... this one; make local.\n+\t(redirect_edge_and_branch_force): Rename to ...\n+\t(rtl_redirect_edge_and_branch_force) ... this one; make local.\n+\t(cfg_layout_delete_block, cfg_layout_delete_edge_and_branch_force): New.\n+\t(cfg_layout_redirect_edge_and_branch, cfg_layout_split_block): Move here from\n+\tcfglayout.c; update to directly call RTL counterparts.\n+\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hooks): New functions.\n+\t* ifcvt.c (find_cond_trap): Use delete_block.\n+\t(find_if_case_1): Use delete_block.\n+\t(find_if_case_2): Use delete_block.\n+\t* rtl.h (unlink_insn_chain): Declare.\n+\t* toplev.c (rtl_reigster_cfg_hooks): New.\n+\n 2003-06-05  Richard Henderson  <rth@redhat.com>\n \n \t* recog.c (peephole2_optimize): Revert last change."}, {"sha": "396744a1849242eaacfa22a0fc971cb0b161bd35", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -635,7 +635,7 @@ PARAMS_H = params.h params.def\n TREE_H = tree.h tree.def $(MACHMODE_H) tree-check.h version.h builtins.def \\\n           input.h\n BASIC_BLOCK_H = basic-block.h bitmap.h sbitmap.h varray.h $(PARTITION_H) \\\n-          hard-reg-set.h\n+          hard-reg-set.h cfghooks.h\n COVERAGE_H = coverage.h gcov-io.h gcov-iov.h\n DEMANGLE_H = $(srcdir)/../include/demangle.h\n RECOG_H = recog.h\n@@ -820,7 +820,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  sibcall.o simplify-rtx.o sreal.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t   \\\n  stor-layout.o stringpool.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \\\n- alloc-pool.o et-forest.o cgraph.o cgraphunit.o\t\t\t\t   \\\n+ alloc-pool.o et-forest.o cgraph.o cgraphunit.o cfghooks.o\t\t   \\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS) $(host_hook_obj)\n \n BACKEND = main.o libbackend.a\n@@ -1650,6 +1650,8 @@ flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H) alloc-pool.h\n+cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n+   $(BASIC_BLOCK_H) cfglayout.h\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H) insn-config.h"}, {"sha": "a229367c9ec858ed3d997973208015b382584e09", "filename": "gcc/basic-block.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -338,8 +338,6 @@ extern void update_bb_for_insn\t\tPARAMS ((basic_block));\n \n extern void free_basic_block_vars\tPARAMS ((int));\n \n-extern edge split_block\t\t\tPARAMS ((basic_block, rtx));\n-extern basic_block split_edge\t\tPARAMS ((edge));\n extern void insert_insn_on_edge\t\tPARAMS ((rtx, edge));\n \n extern void commit_edge_insertions\tPARAMS ((void));\n@@ -363,8 +361,7 @@ extern edge redirect_edge_succ_nodup\tPARAMS ((edge, basic_block));\n extern void redirect_edge_pred\t\tPARAMS ((edge, basic_block));\n extern basic_block create_basic_block_structure PARAMS ((rtx, rtx, rtx, basic_block));\n extern basic_block create_basic_block\tPARAMS ((rtx, rtx, basic_block));\n-extern int flow_delete_block\t\tPARAMS ((basic_block));\n-extern int flow_delete_block_noexpunge\tPARAMS ((basic_block));\n+extern void flow_delete_block_noexpunge\tPARAMS ((basic_block));\n extern void clear_bb_flags\t\tPARAMS ((void));\n extern void merge_blocks_nomove\t\tPARAMS ((basic_block, basic_block));\n extern void tidy_fallthru_edge\t\tPARAMS ((edge, basic_block,\n@@ -560,9 +557,7 @@ extern void compact_blocks\t\tPARAMS ((void));\n extern basic_block alloc_block\t\tPARAMS ((void));\n extern void find_unreachable_blocks\tPARAMS ((void));\n extern int delete_noop_moves\t\tPARAMS ((rtx));\n-extern basic_block redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n extern basic_block force_nonfallthru\tPARAMS ((edge));\n-extern bool redirect_edge_and_branch\tPARAMS ((edge, basic_block));\n extern rtx block_label\t\t\tPARAMS ((basic_block));\n extern bool forwarder_block_p\t\tPARAMS ((basic_block));\n extern bool purge_all_dead_edges\tPARAMS ((int));\n@@ -649,4 +644,7 @@ extern void redirect_immediate_dominators PARAMS ((dominance_info, basic_block,\n \t\t\t\t\t\t basic_block));\n void iterate_fix_dominators PARAMS ((dominance_info, basic_block *, int));\n extern void verify_dominators PARAMS ((dominance_info));\n+\n+#include \"cfghooks.h\"\n+\n #endif /* GCC_BASIC_BLOCK_H */"}, {"sha": "7e4aa4035dc38b84b8bca90dcaadb0eee3e820a8", "filename": "gcc/cfg.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -828,3 +828,11 @@ free_aux_for_edges ()\n \n   clear_aux_for_edges ();\n }\n+\n+/* Verify the CFG consistency.  \n+   ??? In the future move IL idepdendent checks here.  */\n+void\n+verify_flow_info ()\n+{\n+  cfg_hooks->cfgh_verify_flow_info ();\n+}"}, {"sha": "b61d287bca40753f6082a41bd6811416e799facf", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -180,7 +180,7 @@ try_simplify_condjump (cbranch_block)\n   update_br_prob_note (cbranch_block);\n \n   /* Delete the block with the unconditional jump, and clean up the mess.  */\n-  flow_delete_block (jump_block);\n+  delete_block (jump_block);\n   tidy_fallthru_edge (cbranch_jump_edge, cbranch_block, cbranch_dest_block);\n \n   return true;\n@@ -1271,7 +1271,7 @@ outgoing_edges_match (mode, bb1, bb2)\n \t  /* The labels should never be the same rtx.  If they really are same\n \t     the jump tables are same too. So disable crossjumping of blocks BB1\n \t     and BB2 because when deleting the common insns in the end of BB1\n-\t     by flow_delete_block () the jump table would be deleted too.  */\n+\t     by delete_block () the jump table would be deleted too.  */\n \t  /* If LABEL2 is referenced in BB1->END do not do anything\n \t     because we would loose information when replacing\n \t     LABEL1 by LABEL2 and then LABEL2 by LABEL1 in BB1->END.  */\n@@ -1568,7 +1568,7 @@ try_crossjump_to_edge (mode, e1, e2)\n   to_remove = redirect_from->succ->dest;\n \n   redirect_edge_and_branch_force (redirect_from->succ, redirect_to);\n-  flow_delete_block (to_remove);\n+  delete_block (to_remove);\n \n   update_forwarder_flag (redirect_from);\n \n@@ -1721,7 +1721,7 @@ try_optimize_cfg (mode)\n \t\t    fprintf (rtl_dump_file, \"Deleting block %i.\\n\",\n \t\t\t     b->index);\n \n-\t\t  flow_delete_block (b);\n+\t\t  delete_block (b);\n \t\t  changed = true;\n \t\t  b = c;\n \t\t}\n@@ -1772,7 +1772,7 @@ try_optimize_cfg (mode)\n \n \t\t  c = b->prev_bb == ENTRY_BLOCK_PTR ? b->next_bb : b->prev_bb;\n \t\t  redirect_edge_succ_nodup (b->pred, b->succ->dest);\n-\t\t  flow_delete_block (b);\n+\t\t  delete_block (b);\n \t\t  changed = true;\n \t\t  b = c;\n \t\t}\n@@ -1871,7 +1871,7 @@ delete_unreachable_blocks ()\n \n       if (!(b->flags & BB_REACHABLE))\n \t{\n-\t  flow_delete_block (b);\n+\t  delete_block (b);\n \t  changed = true;\n \t}\n     }"}, {"sha": "d5815a12307a82d1adf660c64471ba8cc94ec1b3", "filename": "gcc/cfghooks.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -0,0 +1,48 @@\n+/* Hooks for cfg representation specific functions.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <s.pop@laposte.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+\n+extern struct cfg_hooks rtl_cfg_hooks;\n+extern struct cfg_hooks cfg_layout_rtl_cfg_hooks;\n+\n+/* A pointer to one of the hooks containers.  */\n+struct cfg_hooks *cfg_hooks;\n+\n+/* Initialization of functions specific to the rtl IR.  */\n+void \n+rtl_register_cfg_hooks ()\n+{\n+  cfg_hooks = &rtl_cfg_hooks;\n+}\n+\n+/* Initialization of functions specific to the rtl IR.  */\n+void \n+cfg_layout_rtl_register_cfg_hooks ()\n+{\n+  cfg_hooks = &cfg_layout_rtl_cfg_hooks;\n+}"}, {"sha": "c214b64cdc02aff1b8c61dadf18a4122f5a838d0", "filename": "gcc/cfghooks.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -0,0 +1,70 @@\n+/* Hooks for cfg representation specific functions.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <s.pop@laposte.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef GCC_CFGHOOKS_H\n+#define GCC_CFGHOOKS_H\n+\n+struct cfg_hooks\n+{\n+  /* Debugging.  Do not use macros to hook these so they can be called from\n+     debugger!  */\n+  void (*cfgh_verify_flow_info)\t        PARAMS ((void));\n+\n+  /* Basic CFG manipulation.  */\n+\n+  /* Redirect edge E to the given basic block B and update underlying program\n+     representation.  Returns false when edge is not easilly redirectable for\n+     whatever reason.  */\n+  bool (*redirect_edge_and_branch)      PARAMS ((edge e, basic_block b));\n+\n+  /* Same as the above but allows redirecting of fallthru edges.  In that case\n+     newly created forwarder basic block is returned.  It aborts when called\n+     on abnormal edge.  */\n+  basic_block (*redirect_edge_and_branch_force)PARAMS ((edge, basic_block));\n+\n+  /* Remove given basic block and all edges possibly pointing into it.  */\n+  void (*delete_block)PARAMS ((basic_block));\n+\n+  /* Split basic block B after specified instruction I.  */\n+  edge (*split_block)\t\t\tPARAMS ((basic_block b, void * i));\n+\n+  /* Higher level functions representable by primitive operations above if\n+     we didn't have some oddities in RTL and Tree representations.  */\n+  basic_block (*cfgh_split_edge)        PARAMS ((edge));\n+};\n+\n+#define redirect_edge_and_branch(e,b)        cfg_hooks->redirect_edge_and_branch (e,b)\n+#define redirect_edge_and_branch_force(e,b)  cfg_hooks->redirect_edge_and_branch_force (e,b)\n+#define split_block(e,i)                     cfg_hooks->split_block (e,i)\n+#define delete_block(b)\t\t\t     cfg_hooks->delete_block (b)\n+#define split_edge(e)                        cfg_hooks->cfgh_split_edge (e)\n+\n+/* Hooks containers.  */\n+extern struct cfg_hooks rtl_cfg_hooks;\n+\n+/* A pointer to one of the hooks containers.  */\n+extern struct cfg_hooks *cfg_hooks;\n+\n+/* Declarations.  */\n+extern void rtl_register_cfg_hooks     PARAMS ((void));\n+extern void cfg_layout_rtl_register_cfg_hooks PARAMS ((void));\n+\n+#endif  /* GCC_CFGHOOKS_H */"}, {"sha": "bf41013b9eb0686cf79e500c71e2c7fb2e871799", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 12, "deletions": 80, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -39,7 +39,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n extern struct obstack flow_obstack;\n \n /* Holds the interesting trailing notes for the function.  */\n-static rtx function_footer;\n+rtx cfg_layout_function_footer;\n \n static rtx skip_insns_after_block\tPARAMS ((basic_block));\n static void record_effective_endpoints\tPARAMS ((void));\n@@ -52,11 +52,10 @@ static void change_scope\t\tPARAMS ((rtx, tree, tree));\n void verify_insn_chain\t\t\tPARAMS ((void));\n static void cleanup_unconditional_jumps\tPARAMS ((struct loops *));\n static void fixup_fallthru_exit_predecessor PARAMS ((void));\n-static rtx unlink_insn_chain PARAMS ((rtx, rtx));\n static rtx duplicate_insn_chain PARAMS ((rtx, rtx));\n static void break_superblocks PARAMS ((void));\n \f\n-static rtx\n+rtx\n unlink_insn_chain (first, last)\n      rtx first;\n      rtx last;\n@@ -208,9 +207,9 @@ record_effective_endpoints ()\n       next_insn = NEXT_INSN (bb->end);\n     }\n \n-  function_footer = next_insn;\n-  if (function_footer)\n-    function_footer = unlink_insn_chain (function_footer, get_last_insn ());\n+  cfg_layout_function_footer = next_insn;\n+  if (cfg_layout_function_footer)\n+    cfg_layout_function_footer = unlink_insn_chain (cfg_layout_function_footer, get_last_insn ());\n }\n \f\n /* Build a varray mapping INSN_UID to lexical block.  Return it.  */\n@@ -423,9 +422,9 @@ fixup_reorder_chain ()\n   if (index != n_basic_blocks)\n     abort ();\n \n-  NEXT_INSN (insn) = function_footer;\n-  if (function_footer)\n-    PREV_INSN (function_footer) = insn;\n+  NEXT_INSN (insn) = cfg_layout_function_footer;\n+  if (cfg_layout_function_footer)\n+    PREV_INSN (cfg_layout_function_footer) = insn;\n \n   while (NEXT_INSN (insn))\n     insn = NEXT_INSN (insn);\n@@ -696,7 +695,7 @@ cleanup_unconditional_jumps (loops)\n \t\t}\n \n \t      redirect_edge_succ_nodup (bb->pred, bb->succ->dest);\n-\t      flow_delete_block (bb);\n+\t      delete_block (bb);\n \t      bb = prev;\n \t    }\n \t  else if (simplejump_p (bb->end))\n@@ -888,75 +887,6 @@ duplicate_insn_chain (from, to)\n   delete_insn (last);\n   return insn;\n }\n-\n-/* Redirect Edge to DEST.  */\n-bool\n-cfg_layout_redirect_edge (e, dest)\n-     edge e;\n-     basic_block dest;\n-{\n-  basic_block src = e->src;\n-  basic_block old_next_bb = src->next_bb;\n-  bool ret;\n-\n-  /* Redirect_edge_and_branch may decide to turn branch into fallthru edge\n-     in the case the basic block appears to be in sequence.  Avoid this\n-     transformation.  */\n-\n-  src->next_bb = NULL;\n-  if (e->flags & EDGE_FALLTHRU)\n-    {\n-      /* Redirect any branch edges unified with the fallthru one.  */\n-      if (GET_CODE (src->end) == JUMP_INSN\n-\t  && JUMP_LABEL (src->end) == e->dest->head)\n-\t{\n-          if (!redirect_jump (src->end, block_label (dest), 0))\n-\t    abort ();\n-\t}\n-      /* In case we are redirecting fallthru edge to the branch edge\n-         of conditional jump, remove it.  */\n-      if (src->succ->succ_next\n-\t  && !src->succ->succ_next->succ_next)\n-\t{\n-\t  edge s = e->succ_next ? e->succ_next : src->succ;\n-\t  if (s->dest == dest\n-\t      && any_condjump_p (src->end)\n-\t      && onlyjump_p (src->end))\n-\t    delete_insn (src->end);\n-\t}\n-      redirect_edge_succ_nodup (e, dest);\n-\n-      ret = true;\n-    }\n-  else\n-    ret = redirect_edge_and_branch (e, dest);\n-\n-  /* We don't want simplejumps in the insn stream during cfglayout.  */\n-  if (simplejump_p (src->end))\n-    {\n-      delete_insn (src->end);\n-      delete_barrier (NEXT_INSN (src->end));\n-      src->succ->flags |= EDGE_FALLTHRU;\n-    }\n-  src->next_bb = old_next_bb;\n-\n-  return ret;\n-}\n-\n-/* Same as split_block but update cfg_layout structures.  */\n-edge\n-cfg_layout_split_block (bb, insn)\n-     basic_block bb;\n-     rtx insn;\n-{\n-  edge fallthru = split_block (bb, insn);\n-\n-  alloc_aux_for_block (fallthru->dest, sizeof (struct reorder_block_def));\n-  RBI (fallthru->dest)->footer = RBI (fallthru->src)->footer;\n-  RBI (fallthru->src)->footer = NULL;\n-  return fallthru;\n-}\n-\n /* Create a duplicate of the basic block BB and redirect edge E into it.  */\n \n basic_block\n@@ -1037,7 +967,7 @@ cfg_layout_duplicate_bb (bb, e)\n       new_bb->frequency = EDGE_FREQUENCY (e);\n       bb->frequency -= EDGE_FREQUENCY (e);\n \n-      cfg_layout_redirect_edge (e, new_bb);\n+      redirect_edge_and_branch_force (e, new_bb);\n     }\n \n   if (bb->count < 0)\n@@ -1060,6 +990,7 @@ cfg_layout_initialize (loops)\n   /* Our algorithm depends on fact that there are now dead jumptables\n      around the code.  */\n   alloc_aux_for_blocks (sizeof (struct reorder_block_def));\n+  cfg_layout_rtl_register_cfg_hooks ();\n \n   cleanup_unconditional_jumps (loops);\n \n@@ -1101,6 +1032,7 @@ break_superblocks ()\n void\n cfg_layout_finalize ()\n {\n+  rtl_register_cfg_hooks ();\n   fixup_fallthru_exit_predecessor ();\n   fixup_reorder_chain ();\n "}, {"sha": "48f11af753bb15c63e66200547411a0e0710772e", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -35,11 +35,11 @@ typedef struct reorder_block_def\n \n #define RBI(BB)\t((reorder_block_def) (BB)->aux)\n \n+extern rtx cfg_layout_function_footer;\n+\n extern void cfg_layout_initialize\tPARAMS ((struct loops *));\n extern void cfg_layout_finalize\t\tPARAMS ((void));\n extern bool cfg_layout_can_duplicate_bb_p PARAMS ((basic_block));\n extern basic_block cfg_layout_duplicate_bb PARAMS ((basic_block, edge));\n extern void scope_to_insns_initialize\tPARAMS ((void));\n extern void scope_to_insns_finalize\tPARAMS ((void));\n-extern bool cfg_layout_redirect_edge\tPARAMS ((edge, basic_block));\n-extern edge cfg_layout_split_block\tPARAMS ((basic_block, rtx));"}, {"sha": "1e878a5b7d46ac2f50c85fa31aa6fcfbfbf0ffed", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -86,9 +86,6 @@ split_loop_bb (loops, bb, insn)\n   free (dom_bbs);\n   set_immediate_dominator (loops->cfg.dom, e->dest, e->src);\n \n-  /* Take care of RBI.  */\n-  alloc_aux_for_block (e->dest, sizeof (struct reorder_block_def));\n-\n   return e;\n }\n \n@@ -123,7 +120,7 @@ remove_bbs (dom, bbs, nbbs)\n     {\n       remove_bb_from_loops (bbs[i]);\n       delete_from_dominance_info (dom, bbs[i]);\n-      flow_delete_block (bbs[i]);\n+      delete_block (bbs[i]);\n     }\n }\n \n@@ -828,7 +825,7 @@ loop_redirect_edge (e, dest)\n   if (e->dest == dest)\n     return;\n \n-  cfg_layout_redirect_edge (e, dest);\n+  redirect_edge_and_branch_force (e, dest);\n }\n \n /* Deletes edge E from a branch if possible.  Unless REALLY_DELETE is set,\n@@ -865,7 +862,7 @@ loop_delete_branch_edge (e, really_delete)\n       /* Redirecting behaves wrongly wrto this flag.  */\n       irr = snd->flags & EDGE_IRREDUCIBLE_LOOP;\n       \n-      if (!cfg_layout_redirect_edge (e, newdest))\n+      if (!redirect_edge_and_branch (e, newdest))\n \treturn false;\n       src->succ->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n       src->succ->flags |= irr;\n@@ -1396,10 +1393,7 @@ create_preheader (loop, dom, flags)\n       /* Split_block would not split block after its end.  */\n       emit_note_after (NOTE_INSN_DELETED, insn);\n     }\n-  if (flags & CP_INSIDE_CFGLAYOUT)\n-    fallthru = cfg_layout_split_block (loop->header, insn);\n-  else\n-    fallthru = split_block (loop->header, insn);\n+  fallthru = split_block (loop->header, insn);\n   dummy = fallthru->src;\n   loop->header = fallthru->dest;\n \n@@ -1424,18 +1418,13 @@ create_preheader (loop, dom, flags)\n   dummy->frequency -= EDGE_FREQUENCY (e);\n   dummy->count -= e->count;\n   fallthru->count -= e->count;\n-  if (flags & CP_INSIDE_CFGLAYOUT)\n-    cfg_layout_redirect_edge (e, loop->header);\n-  else\n+  jump = redirect_edge_and_branch_force (e, loop->header);\n+  if (jump)\n     {\n-      jump = redirect_edge_and_branch_force (e, loop->header);\n-      if (jump)\n-\t{\n-\t  add_to_dominance_info (dom, jump);\n-\t  set_immediate_dominator (dom, jump, src);\n-\t  add_bb_to_loop (jump, loop);\n-\t  loop->latch = jump;\n-\t}\n+      add_to_dominance_info (dom, jump);\n+      set_immediate_dominator (dom, jump, src);\n+      add_bb_to_loop (jump, loop);\n+      loop->latch = jump;\n     }\n \n   /* Update structures.  */\n@@ -1524,7 +1513,7 @@ loop_split_edge_with (e, insns, loops)\n \n   new_bb->count = e->count;\n   new_bb->frequency = EDGE_FREQUENCY (e);\n-  cfg_layout_redirect_edge (e, new_bb);\n+  redirect_edge_and_branch_force (e, new_bb);\n \n   alloc_aux_for_block (new_bb, sizeof (struct reorder_block_def));\n   if (insns)"}, {"sha": "b0678f09f1cc0a0cc79d1b91aa98cfc5434601bc", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 194, "deletions": 19, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -26,7 +26,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n      - CFG-aware instruction chain manipulation\n \t delete_insn, delete_insn_chain\n      - Basic block manipulation\n-\t create_basic_block, flow_delete_block, split_block,\n+\t create_basic_block, rtl_delete_block,rtl_split_block,\n \t merge_blocks_nomove\n      - Infrastructure to determine quickly basic block for insn\n \t compute_bb_for_insn, update_bb_for_insn, set_block_for_insn,\n@@ -59,6 +59,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"obstack.h\"\n #include \"insn-config.h\"\n+#include \"cfglayout.h\"\n \n /* Stubs in case we don't have a return insn.  */\n #ifndef HAVE_return\n@@ -79,6 +80,16 @@ static bool try_redirect_by_replacing_jump PARAMS ((edge, basic_block));\n static rtx last_loop_beg_note\t\tPARAMS ((rtx));\n static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n basic_block force_nonfallthru_and_redirect PARAMS ((edge, basic_block));\n+static basic_block rtl_split_edge\tPARAMS ((edge));\n+static void rtl_verify_flow_info\tPARAMS ((void));\n+static edge cfg_layout_split_block\tPARAMS ((basic_block, void *));\n+static bool cfg_layout_redirect_edge_and_branch\tPARAMS ((edge, basic_block));\n+static basic_block cfg_layout_redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n+static void cfg_layout_delete_block\tPARAMS ((basic_block));\n+static void rtl_delete_block\t\tPARAMS ((basic_block));\n+static basic_block rtl_redirect_edge_and_branch_force PARAMS ((edge, basic_block));\n+static bool rtl_redirect_edge_and_branch PARAMS ((edge, basic_block));\n+static edge rtl_split_block\t\tPARAMS ((basic_block, void *));\n \f\n /* Return true if NOTE is not one of the ones that must be kept paired,\n    so that we may simply delete it.  */\n@@ -348,11 +359,10 @@ create_basic_block (head, end, after)\n /* ??? Preserving all such notes strikes me as wrong.  It would be nice\n    to post-process the stream to remove empty blocks, loops, ranges, etc.  */\n \n-int\n+void\n flow_delete_block_noexpunge (b)\n      basic_block b;\n {\n-  int deleted_handler = 0;\n   rtx insn, end, tmp;\n \n   /* If the head of this block is a CODE_LABEL, then it might be the\n@@ -404,20 +414,16 @@ flow_delete_block_noexpunge (b)\n \n   b->pred = NULL;\n   b->succ = NULL;\n-\n-  return deleted_handler;\n }\n \n-int\n-flow_delete_block (b)\n+static void\n+rtl_delete_block (b)\n      basic_block b;\n {\n-  int deleted_handler = flow_delete_block_noexpunge (b);\n+  flow_delete_block_noexpunge (b);\n \n   /* Remove the basic block from the array.  */\n   expunge_block (b);\n-\n-  return deleted_handler;\n }\n \f\n /* Records the basic block struct in BLOCK_FOR_INSN for every insn.  */\n@@ -474,14 +480,15 @@ update_bb_for_insn (bb)\n    this function renumbers all the basic blocks so that the new\n    one has a number one greater than the block split.  */\n \n-edge\n-split_block (bb, insn)\n+static edge\n+rtl_split_block (bb, insnp)\n      basic_block bb;\n-     rtx insn;\n+     void *insnp;\n {\n   basic_block new_bb;\n   edge new_edge;\n   edge e;\n+  rtx insn = insnp;\n \n   /* There is no point splitting the block after its end.  */\n   if (bb->end == insn)\n@@ -811,8 +818,8 @@ last_loop_beg_note (insn)\n    already destinated TARGET and we didn't managed to simplify instruction\n    stream.  */\n \n-bool\n-redirect_edge_and_branch (e, target)\n+static bool\n+rtl_redirect_edge_and_branch (e, target)\n      edge e;\n      basic_block target;\n {\n@@ -1076,8 +1083,8 @@ force_nonfallthru (e)\n    basic block.  Return new basic block if created, NULL otherwise.\n    Abort if conversion is impossible.  */\n \n-basic_block\n-redirect_edge_and_branch_force (e, target)\n+static basic_block\n+rtl_redirect_edge_and_branch_force (e, target)\n      edge e;\n      basic_block target;\n {\n@@ -1230,7 +1237,7 @@ back_edge_of_syntactic_loop_p (bb1, bb2)\n    block with multiple predecessors is not handled optimally.  */\n \n basic_block\n-split_edge (edge_in)\n+rtl_split_edge (edge_in)\n      edge edge_in;\n {\n   basic_block bb;\n@@ -1741,7 +1748,7 @@ update_br_prob_note (bb)\n    (reachability of basic blocks, life information, etc. etc.).  */\n \n void\n-verify_flow_info ()\n+rtl_verify_flow_info ()\n {\n   const int max_uid = get_max_uid ();\n   const rtx rtx_first = get_insns ();\n@@ -2363,3 +2370,171 @@ purge_all_dead_edges (update_life_p)\n     sbitmap_free (blocks);\n   return purged;\n }\n+\n+/* Same as split_block but update cfg_layout structures.  */\n+static edge\n+cfg_layout_split_block (bb, insnp)\n+     basic_block bb;\n+     void *insnp;\n+{\n+  rtx insn = insnp;\n+\n+  edge fallthru = rtl_split_block (bb, insn);\n+\n+  alloc_aux_for_block (fallthru->dest, sizeof (struct reorder_block_def));\n+  RBI (fallthru->dest)->footer = RBI (fallthru->src)->footer;\n+  RBI (fallthru->src)->footer = NULL;\n+  return fallthru;\n+}\n+\n+\n+/* Redirect Edge to DEST.  */\n+static bool\n+cfg_layout_redirect_edge_and_branch (e, dest)\n+     edge e;\n+     basic_block dest;\n+{\n+  basic_block src = e->src;\n+  basic_block old_next_bb = src->next_bb;\n+  bool ret;\n+\n+  /* Redirect_edge_and_branch may decide to turn branch into fallthru edge\n+     in the case the basic block appears to be in sequence.  Avoid this\n+     transformation.  */\n+\n+  src->next_bb = NULL;\n+  if (e->flags & EDGE_FALLTHRU)\n+    {\n+      /* Redirect any branch edges unified with the fallthru one.  */\n+      if (GET_CODE (src->end) == JUMP_INSN\n+\t  && JUMP_LABEL (src->end) == e->dest->head)\n+\t{\n+          if (!redirect_jump (src->end, block_label (dest), 0))\n+\t    abort ();\n+\t}\n+      /* In case we are redirecting fallthru edge to the branch edge\n+         of conditional jump, remove it.  */\n+      if (src->succ->succ_next\n+\t  && !src->succ->succ_next->succ_next)\n+\t{\n+\t  edge s = e->succ_next ? e->succ_next : src->succ;\n+\t  if (s->dest == dest\n+\t      && any_condjump_p (src->end)\n+\t      && onlyjump_p (src->end))\n+\t    delete_insn (src->end);\n+\t}\n+      redirect_edge_succ_nodup (e, dest);\n+\n+      ret = true;\n+    }\n+  else\n+    ret = rtl_redirect_edge_and_branch (e, dest);\n+\n+  /* We don't want simplejumps in the insn stream during cfglayout.  */\n+  if (simplejump_p (src->end))\n+    {\n+      delete_insn (src->end);\n+      delete_barrier (NEXT_INSN (src->end));\n+      src->succ->flags |= EDGE_FALLTHRU;\n+    }\n+  src->next_bb = old_next_bb;\n+\n+  return ret;\n+}\n+\n+/* Simple wrapper as we always can redirect fallthru edges.  */\n+static basic_block\n+cfg_layout_redirect_edge_and_branch_force (e, dest)\n+     edge e;\n+     basic_block dest;\n+{\n+  if (!cfg_layout_redirect_edge_and_branch (e, dest))\n+    abort ();\n+  return NULL;\n+}\n+\n+/* Same as flow_delete_block but update cfg_layout structures.  */\n+static void\n+cfg_layout_delete_block (bb)\n+     basic_block bb;\n+{\n+  rtx insn, next, prev = PREV_INSN (bb->head), *to, remaints;\n+\n+  if (RBI (bb)->header)\n+    {\n+      next = bb->head;\n+      if (prev)\n+\tNEXT_INSN (prev) = RBI (bb)->header;\n+      else\n+\tset_first_insn (RBI (bb)->header);\n+      PREV_INSN (RBI (bb)->header) = prev;\n+      insn = RBI (bb)->header;\n+      while (NEXT_INSN (insn))\n+\tinsn = NEXT_INSN (insn);\n+      NEXT_INSN (insn) = next;\n+      PREV_INSN (next) = insn;\n+    }\n+  next = NEXT_INSN (bb->end);\n+  if (RBI (bb)->footer)\n+    {\n+      insn = bb->end;\n+      NEXT_INSN (insn) = RBI (bb)->footer;\n+      PREV_INSN (RBI (bb)->footer) = insn;\n+      while (NEXT_INSN (insn))\n+\tinsn = NEXT_INSN (insn);\n+      NEXT_INSN (insn) = next;\n+      if (next)\n+\tPREV_INSN (next) = insn;\n+      else\n+\tset_last_insn (insn);\n+    }\n+  if (bb->next_bb != EXIT_BLOCK_PTR)\n+    to = &RBI(bb->next_bb)->header;\n+  else\n+    to = &cfg_layout_function_footer;\n+  rtl_delete_block (bb);\n+\n+  if (prev)\n+    prev = NEXT_INSN (prev);\n+  else \n+    prev = get_insns ();\n+  if (next)\n+    next = PREV_INSN (next);\n+  else \n+    next = get_last_insn ();\n+\n+  if (next && NEXT_INSN (next) != prev)\n+    {\n+      remaints = unlink_insn_chain (prev, next);\n+      insn = remaints;\n+      while (NEXT_INSN (insn))\n+\tinsn = NEXT_INSN (insn);\n+      NEXT_INSN (insn) = *to;\n+      if (*to)\n+\tPREV_INSN (*to) = insn;\n+      *to = remaints;\n+    }\n+}\n+\n+/* Implementation of CFG manipulation for linearized RTL.  */\n+struct cfg_hooks rtl_cfg_hooks = {\n+  rtl_verify_flow_info,\n+  rtl_redirect_edge_and_branch,\n+  rtl_redirect_edge_and_branch_force,\n+  rtl_delete_block,\n+  rtl_split_block,\n+  rtl_split_edge\n+};\n+\n+/* Implementation of CFG manipulation for cfg layout RTL, where\n+   basic block connected via fallthru edges does not have to be adjacent.\n+   This representation will hopefully become the default one in future\n+   version of the compiler.  */\n+struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n+  NULL,   /* verify_flow_info.  */\n+  cfg_layout_redirect_edge_and_branch,\n+  cfg_layout_redirect_edge_and_branch_force,\n+  cfg_layout_delete_block,\n+  cfg_layout_split_block,\n+  NULL  /* split_edge.  */\n+};"}, {"sha": "baac0413176498a7385d217105ded2400aff73a6", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -2547,7 +2547,7 @@ find_cond_trap (test_bb, then_edge, else_edge)\n     {\n       if (post_dominators)\n \tdelete_from_dominance_info (post_dominators, trap_bb);\n-      flow_delete_block (trap_bb);\n+      delete_block (trap_bb);\n       num_removed_blocks++;\n     }\n \n@@ -2736,7 +2736,7 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n   then_bb_index = then_bb->index;\n   if (post_dominators)\n     delete_from_dominance_info (post_dominators, then_bb);\n-  flow_delete_block (then_bb);\n+  delete_block (then_bb);\n \n   /* Make rest of code believe that the newly created block is the THEN_BB\n      block we removed.  */\n@@ -2818,7 +2818,7 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n   \n   if (post_dominators)\n     delete_from_dominance_info (post_dominators, else_bb);\n-  flow_delete_block (else_bb);\n+  delete_block (else_bb);\n \n   num_removed_blocks++;\n   num_updated_if_blocks++;"}, {"sha": "21998a605ff78e977d1c27054a0c8de3bc4ff223", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -2082,6 +2082,7 @@ extern void renumber_insns                      PARAMS ((FILE *));\n extern void remove_unnecessary_notes             PARAMS ((void));\n extern rtx delete_insn\t\t\tPARAMS ((rtx));\n extern void delete_insn_chain\t\tPARAMS ((rtx, rtx));\n+extern rtx unlink_insn_chain\t\tPARAMS ((rtx, rtx));\n extern rtx delete_insn_and_edges\tPARAMS ((rtx));\n extern void delete_insn_chain_and_edges\tPARAMS ((rtx, rtx));\n "}, {"sha": "1a82946a8a683c57b6e5e718c2c79528d0b76a9f", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee634e345c67ea1aa84591aa91c7e18020c19ae/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=9ee634e345c67ea1aa84591aa91c7e18020c19ae", "patch": "@@ -3472,6 +3472,9 @@ rest_of_compilation (tree decl)\n \n   timevar_push (TV_REST_OF_COMPILATION);\n \n+  /* Register rtl specific functions for cfg.  */\n+  rtl_register_cfg_hooks ();\n+  \n   /* Now that we're out of the frontend, we shouldn't have any more\n      CONCATs anywhere.  */\n   generating_concat_p = 0;"}]}