{"sha": "4269f19c09163d6ef65043171eeccc9c521d9b5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI2OWYxOWMwOTE2M2Q2ZWY2NTA0MzE3MWVlY2NjOWM1MjFkOWI1Zg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2014-05-22T03:51:25Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2014-05-22T03:51:25Z"}, "message": "PR 60324 Handle long path names, don't use PATH_MAX.\n\nFrom-SVN: r210738", "tree": {"sha": "b97492f2a8d9b9b3d41f020dde39ac89bad83229", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b97492f2a8d9b9b3d41f020dde39ac89bad83229"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4269f19c09163d6ef65043171eeccc9c521d9b5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4269f19c09163d6ef65043171eeccc9c521d9b5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4269f19c09163d6ef65043171eeccc9c521d9b5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4269f19c09163d6ef65043171eeccc9c521d9b5f/comments", "author": null, "committer": null, "parents": [{"sha": "d5c67efda0d5e2d42abd49c0d58bb39a038d20ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c67efda0d5e2d42abd49c0d58bb39a038d20ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c67efda0d5e2d42abd49c0d58bb39a038d20ec"}], "stats": {"total": 373, "additions": 238, "deletions": 135}, "files": [{"sha": "9f5a39bfcd6808f8b0ccb05f9c8c8a36a9e86144", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -1,3 +1,35 @@\n+2014-05-22  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libfortran/60324\n+\t* config.h.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* configure.ac (AC_CHECK_FUNCS_ONCE): Check for strnlen and\n+\tstrndup.\n+\t* libgfortran.h (fc_strdup): New prototype.\n+\t* runtime/string.c (strnlen): New fallback function.\n+\t(strndup): New fallback function.\n+\t(fc_strdup): New function.\n+\t* io/close.c (st_close): Use fc_strdup.\n+\t* io/open.c (new_unit): Likewise.\n+\t(already_open): Likewise.\n+\t* io/unit.c (filename_from_unit): Likewise.\n+\t* io/unix.c (unpack_filename): Remove function.\n+\t(regular_file): Rename to regular_file2, add path argument.\n+\t(regular_file): New function calling regular_file2.\n+\t(compare_file_filename): Use fc_strdup.\n+\t(find_file): Likewise.\n+\t(delete_file): Likewise.\n+\t(file_exists): Likewise.\n+\t(file_size): Likewise.\n+\t(inquire_sequential): Likewise.\n+\t(inquire_direct): Likewise.\n+\t(inquire_formatted): Likewise.\n+\t(inquire_access): Likewise.\n+\t* io/unix.h (unpack_filename): Remove prototype.\n+\t* runtime/main.c (please_free_exe_path_when_done): Change type to\n+\tbool.\n+\t(store_exe_path): Use malloced buffer, grow as needed.\n+\n 2014-05-17  Jerry DeLisle  <jvdelisle@gcc.gnu>\n \n \tPR libfortran/52539"}, {"sha": "110fb6d5b9a87552eb1278d918086caa1fdc8ce7", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -729,6 +729,12 @@\n /* Define to 1 if you have the <string.h> header file. */\n #undef HAVE_STRING_H\n \n+/* Define to 1 if you have the `strndup' function. */\n+#undef HAVE_STRNDUP\n+\n+/* Define to 1 if you have the `strnlen' function. */\n+#undef HAVE_STRNLEN\n+\n /* Define to 1 if you have the `strtof' function. */\n #undef HAVE_STRTOF\n "}, {"sha": "d46a6e2d796055e495d510de496aac83fd3c5057", "filename": "libgfortran/configure", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -2599,6 +2599,8 @@ as_fn_append ac_func_list \" getegid\"\n as_fn_append ac_func_list \" secure_getenv\"\n as_fn_append ac_func_list \" __secure_getenv\"\n as_fn_append ac_func_list \" mkostemp\"\n+as_fn_append ac_func_list \" strnlen\"\n+as_fn_append ac_func_list \" strndup\"\n as_fn_append ac_header_list \" math.h\"\n # Check that the precious variables saved in the cache have kept the same\n # value.\n@@ -12344,7 +12346,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12347 \"configure\"\n+#line 12349 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12450,7 +12452,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12453 \"configure\"\n+#line 12455 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -16601,6 +16603,10 @@ done\n \n \n \n+\n+\n+\n+\n \n \n "}, {"sha": "fb29c147666fe5dc0f655e443a693f5104d2feb6", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -287,7 +287,7 @@ else\n    strcasestr getrlimit gettimeofday stat fstat lstat getpwuid vsnprintf dup \\\n    getcwd localtime_r gmtime_r getpwuid_r ttyname_r clock_gettime \\\n    readlink getgid getpid getppid getuid geteuid umask getegid \\\n-   secure_getenv __secure_getenv mkostemp)\n+   secure_getenv __secure_getenv mkostemp strnlen strndup)\n fi\n \n # Check strerror_r, cannot be above as versions with two and three arguments exist"}, {"sha": "55f49da831ecb07b4a687d62eeaad09f45cb3b56", "filename": "libgfortran/io/close.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fio%2Fclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fio%2Fclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fclose.c?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -72,8 +72,7 @@ st_close (st_parameter_close *clp)\n \t    generate_error (&clp->common, LIBERROR_BAD_OPTION,\n \t\t\t    \"Can't KEEP a scratch file on CLOSE\");\n #if !HAVE_UNLINK_OPEN_FILE\n-\t  path = (char *) gfc_alloca (u->file_len + 1);\n-          unpack_filename (path, u->file, u->file_len);\n+\t  path = fc_strdup (u->file, u->file_len);\n #endif\n \t}\n       else\n@@ -83,8 +82,7 @@ st_close (st_parameter_close *clp)\n #if HAVE_UNLINK_OPEN_FILE\n \t      delete_file (u);\n #else\n-\t      path = (char *) gfc_alloca (u->file_len + 1);\n-              unpack_filename (path, u->file, u->file_len);\n+\t      path = fc_strdup (u->file, u->file_len);\n #endif\n             }\n \t}\n@@ -93,7 +91,10 @@ st_close (st_parameter_close *clp)\n \n #if !HAVE_UNLINK_OPEN_FILE\n       if (path != NULL)\n-        unlink (path);\n+\t{\n+\t  unlink (path);\n+\t  free (path);\n+\t}\n #endif\n     }\n "}, {"sha": "b803859ac3d8f45318c149007e0d655163a38589", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -502,12 +502,9 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n   s = open_external (opp, flags);\n   if (s == NULL)\n     {\n-      char *path, *msg;\n-      size_t msglen;\n-      path = (char *) gfc_alloca (opp->file_len + 1);\n-      msglen = opp->file_len + 51;\n-      msg = (char *) gfc_alloca (msglen);\n-      unpack_filename (path, opp->file, opp->file_len);\n+      char *path = fc_strdup (opp->file, opp->file_len);\n+      size_t msglen = opp->file_len + 51;\n+      char *msg = xmalloc (msglen);\n \n       switch (errno)\n \t{\n@@ -529,10 +526,13 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \t  break;\n \n \tdefault:\n+\t  free (msg);\n \t  msg = NULL;\n \t}\n \n       generate_error (&opp->common, LIBERROR_OS, msg);\n+      free (msg);\n+      free (path);\n       goto cleanup;\n     }\n \n@@ -676,15 +676,6 @@ already_open (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n \n   if (!compare_file_filename (u, opp->file, opp->file_len))\n     {\n-#if !HAVE_UNLINK_OPEN_FILE\n-      char *path = NULL;\n-      if (u->file && u->flags.status == STATUS_SCRATCH)\n-\t{\n-\t  path = (char *) gfc_alloca (u->file_len + 1);\n-\t  unpack_filename (path, u->file, u->file_len);\n-\t}\n-#endif\n-\n       if (sclose (u->s) == -1)\n \t{\n \t  unlock_unit (u);\n@@ -699,8 +690,14 @@ already_open (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n       u->file_len = 0;\n \n #if !HAVE_UNLINK_OPEN_FILE\n+      char *path = NULL;\n+      if (u->file && u->flags.status == STATUS_SCRATCH)\n+\tpath = fc_strdup (u->file, u->file_len);\n       if (path != NULL)\n-\tunlink (path);\n+\t{\n+\t  unlink (path);\n+\t  free (path);\n+\t}\n #endif\n \n       u = new_unit (opp, u, flags);"}, {"sha": "a406c9e8be91972e6658cc351cc2983ca9144b8c", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -786,7 +786,6 @@ unit_truncate (gfc_unit * u, gfc_offset pos, st_parameter_common * common)\n char *\n filename_from_unit (int n)\n {\n-  char *filename;\n   gfc_unit *u;\n   int c;\n \n@@ -805,11 +804,7 @@ filename_from_unit (int n)\n \n   /* Get the filename.  */\n   if (u != NULL)\n-    {\n-      filename = (char *) xmalloc (u->file_len + 1);\n-      unpack_filename (filename, u->file, u->file_len);\n-      return filename;\n-    }\n+    return fc_strdup (u->file, u->file_len);\n   else\n     return (char *) NULL;\n }"}, {"sha": "3721b71f9948cd3080734fce982dc1a0a5611411", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 79, "deletions": 83, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -114,9 +114,6 @@ id_from_fd (const int fd)\n     typeof (b) _b = (b);\t\\\n     _a < _b ? _a : _b; })\n \n-#ifndef PATH_MAX\n-#define PATH_MAX 1024\n-#endif\n \n /* These flags aren't defined on all targets (mingw32), so provide them\n    here.  */\n@@ -1060,26 +1057,6 @@ unit_to_fd (int unit)\n }\n \n \n-/* unpack_filename()-- Given a fortran string and a pointer to a\n- * buffer that is PATH_MAX characters, convert the fortran string to a\n- * C string in the buffer.  Returns nonzero if this is not possible.  */\n-\n-int\n-unpack_filename (char *cstring, const char *fstring, int len)\n-{\n-  if (fstring == NULL)\n-    return EFAULT;\n-  len = fstrlen (fstring, len);\n-  if (len >= PATH_MAX)\n-    return ENAMETOOLONG;\n-\n-  memmove (cstring, fstring, len);\n-  cstring[len] = '\\0';\n-\n-  return 0;\n-}\n-\n-\n /* Set the close-on-exec flag for an existing fd, if the system\n    supports such.  */\n \n@@ -1244,27 +1221,18 @@ tempfile (st_parameter_open *opp)\n }\n \n \n-/* regular_file()-- Open a regular file.\n+/* regular_file2()-- Open a regular file.\n  * Change flags->action if it is ACTION_UNSPECIFIED on entry,\n  * unless an error occurs.\n  * Returns the descriptor, which is less than zero on error. */\n \n static int\n-regular_file (st_parameter_open *opp, unit_flags *flags)\n+regular_file2 (const char *path, st_parameter_open *opp, unit_flags *flags)\n {\n-  char path[min(PATH_MAX, opp->file_len + 1)];\n   int mode;\n   int rwflag;\n   int crflag, crflag2;\n   int fd;\n-  int err;\n-\n-  err = unpack_filename (path, opp->file, opp->file_len);\n-  if (err)\n-    {\n-      errno = err;\t\t/* Fake an OS error */\n-      return -1;\n-    }\n \n #ifdef __CYGWIN__\n   if (opp->file_len == 7)\n@@ -1404,6 +1372,18 @@ regular_file (st_parameter_open *opp, unit_flags *flags)\n }\n \n \n+/* Wrapper around regular_file2, to make sure we free the path after\n+   we're done.  */\n+\n+static int\n+regular_file (st_parameter_open *opp, unit_flags *flags)\n+{\n+  char *path = fc_strdup (opp->file, opp->file_len);\n+  int fd = regular_file2 (path, opp, flags);\n+  free (path);\n+  return fd;\n+}\n+\n /* open_external()-- Open an external file, unix specific version.\n  * Change flags->action if it is ACTION_UNSPECIFIED on entry.\n  * Returns NULL on operating system error. */\n@@ -1494,8 +1474,8 @@ error_stream (void)\n int\n compare_file_filename (gfc_unit *u, const char *name, int len)\n {\n-  char path[min(PATH_MAX, len + 1)];\n   struct stat st;\n+  int ret;\n #ifdef HAVE_WORKING_STAT\n   unix_stream *s;\n #else\n@@ -1504,18 +1484,21 @@ compare_file_filename (gfc_unit *u, const char *name, int len)\n # endif\n #endif\n \n-  if (unpack_filename (path, name, len))\n-    return 0;\t\t\t/* Can't be the same */\n+  char *path = fc_strdup (name, len);\n \n   /* If the filename doesn't exist, then there is no match with the\n    * existing file. */\n \n   if (stat (path, &st) < 0)\n-    return 0;\n+    {\n+      ret = 0;\n+      goto done;\n+    }\n \n #ifdef HAVE_WORKING_STAT\n   s = (unix_stream *) (u->s);\n-  return (st.st_dev == s->st_dev) && (st.st_ino == s->st_ino);\n+  ret = (st.st_dev == s->st_dev) && (st.st_ino == s->st_ino);\n+  goto done;\n #else\n \n # ifdef __MINGW32__\n@@ -1525,13 +1508,20 @@ compare_file_filename (gfc_unit *u, const char *name, int len)\n   id1 = id_from_path (path);\n   id2 = id_from_fd (((unix_stream *) (u->s))->fd);\n   if (id1 || id2)\n-    return (id1 == id2);\n+    {\n+      ret = (id1 == id2);\n+      goto done;\n+    }\n # endif\n \n   if (len != u->file_len)\n-    return 0;\n-  return (memcmp(path, u->file, len) == 0);\n+    ret = 0;\n+  else\n+    ret = (memcmp(path, u->file, len) == 0);\n #endif\n+ done:\n+  free (path);\n+  return ret;\n }\n \n \n@@ -1594,18 +1584,19 @@ find_file0 (gfc_unit *u, FIND_FILE0_DECL)\n gfc_unit *\n find_file (const char *file, gfc_charlen_type file_len)\n {\n-  char path[min(PATH_MAX, file_len + 1)];\n   struct stat st[1];\n   gfc_unit *u;\n #if defined(__MINGW32__) && !HAVE_WORKING_STAT\n   uint64_t id = 0ULL;\n #endif\n \n-  if (unpack_filename (path, file, file_len))\n-    return NULL;\n+  char *path = fc_strdup (file, file_len);\n \n   if (stat (path, &st[0]) < 0)\n-    return NULL;\n+    {\n+      u = NULL;\n+      goto done;\n+    }\n \n #if defined(__MINGW32__) && !HAVE_WORKING_STAT\n   id = id_from_path (path);\n@@ -1621,7 +1612,7 @@ find_file (const char *file, gfc_charlen_type file_len)\n \t{\n \t  /* assert (u->closed == 0); */\n \t  __gthread_mutex_unlock (&unit_lock);\n-\t  return u;\n+\t  goto done;\n \t}\n \n       inc_waiting_locked (u);\n@@ -1641,6 +1632,8 @@ find_file (const char *file, gfc_charlen_type file_len)\n \n       dec_waiting_unlocked (u);\n     }\n+ done:\n+  free (path);\n   return u;\n }\n \n@@ -1713,16 +1706,10 @@ flush_all_units (void)\n int\n delete_file (gfc_unit * u)\n {\n-  char path[min(PATH_MAX, u->file_len + 1)];\n-  int err = unpack_filename (path, u->file, u->file_len);\n-\n-  if (err)\n-    {\t\t\t\t/* Shouldn't be possible */\n-      errno = err;\n-      return 1;\n-    }\n-\n-  return unlink (path);\n+  char *path = fc_strdup (u->file, u->file_len);\n+  int err = unlink (path);\n+  free (path);\n+  return err;\n }\n \n \n@@ -1732,12 +1719,10 @@ delete_file (gfc_unit * u)\n int\n file_exists (const char *file, gfc_charlen_type file_len)\n {\n-  char path[min(PATH_MAX, file_len + 1)];\n-\n-  if (unpack_filename (path, file, file_len))\n-    return 0;\n-\n-  return !(access (path, F_OK));\n+  char *path = fc_strdup (file, file_len);\n+  int res = !(access (path, F_OK));\n+  free (path);\n+  return res;\n }\n \n \n@@ -1746,15 +1731,12 @@ file_exists (const char *file, gfc_charlen_type file_len)\n GFC_IO_INT\n file_size (const char *file, gfc_charlen_type file_len)\n {\n-  char path[min(PATH_MAX, file_len + 1)];\n+  char *path = fc_strdup (file, file_len);\n   struct stat statbuf;\n-\n-  if (unpack_filename (path, file, file_len))\n-    return -1;\n-\n-  if (stat (path, &statbuf) < 0)\n+  int err = stat (path, &statbuf);\n+  free (path);\n+  if (err == -1)\n     return -1;\n-\n   return (GFC_IO_INT) statbuf.st_size;\n }\n \n@@ -1767,11 +1749,15 @@ static const char yes[] = \"YES\", no[] = \"NO\", unknown[] = \"UNKNOWN\";\n const char *\n inquire_sequential (const char *string, int len)\n {\n-  char path[min(PATH_MAX, len + 1)];\n   struct stat statbuf;\n \n-  if (string == NULL ||\n-      unpack_filename (path, string, len) || stat (path, &statbuf) < 0)\n+  if (string == NULL)\n+    return unknown;\n+\n+  char *path = fc_strdup (string, len);\n+  int err = stat (path, &statbuf);\n+  free (path);\n+  if (err == -1)\n     return unknown;\n \n   if (S_ISREG (statbuf.st_mode) ||\n@@ -1791,11 +1777,15 @@ inquire_sequential (const char *string, int len)\n const char *\n inquire_direct (const char *string, int len)\n {\n-  char path[min(PATH_MAX, len + 1)];\n   struct stat statbuf;\n \n-  if (string == NULL ||\n-      unpack_filename (path, string, len) || stat (path, &statbuf) < 0)\n+  if (string == NULL)\n+    return unknown;\n+\n+  char *path = fc_strdup (string, len);\n+  int err = stat (path, &statbuf);\n+  free (path);\n+  if (err == -1)\n     return unknown;\n \n   if (S_ISREG (statbuf.st_mode) || S_ISBLK (statbuf.st_mode))\n@@ -1815,11 +1805,15 @@ inquire_direct (const char *string, int len)\n const char *\n inquire_formatted (const char *string, int len)\n {\n-  char path[min(PATH_MAX, len + 1)];\n   struct stat statbuf;\n \n-  if (string == NULL ||\n-      unpack_filename (path, string, len) || stat (path, &statbuf) < 0)\n+  if (string == NULL)\n+    return unknown;\n+\n+  char *path = fc_strdup (string, len);\n+  int err = stat (path, &statbuf);\n+  free (path);\n+  if (err == -1)\n     return unknown;\n \n   if (S_ISREG (statbuf.st_mode) ||\n@@ -1850,10 +1844,12 @@ inquire_unformatted (const char *string, int len)\n static const char *\n inquire_access (const char *string, int len, int mode)\n {\n-  char path[min(PATH_MAX, len + 1)];\n-\n-  if (string == NULL || unpack_filename (path, string, len) ||\n-      access (path, mode) < 0)\n+  if (string == NULL)\n+    return no;\n+  char *path = fc_strdup (string, len);\n+  int res = access (path, mode);\n+  free (path);\n+  if (res == -1)\n     return no;\n \n   return yes;"}, {"sha": "910f2c2e6507233abb86229c8c15f3ffcbae69b3", "filename": "libgfortran/io/unix.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fio%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fio%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.h?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -185,8 +185,4 @@ internal_proto(stream_isatty);\n extern int stream_ttyname (stream *, char *, size_t);\n internal_proto(stream_ttyname);\n \n-extern int unpack_filename (char *, const char *, int);\n-internal_proto(unpack_filename);\n-\n-\n #endif"}, {"sha": "ba6c1e918930f6c285d1523d46b3f34bcebee76a", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -822,6 +822,9 @@ extern gfc_charlen_type string_len_trim_char4 (gfc_charlen_type,\n \t\t\t\t\t       const gfc_char4_t *);\n export_proto(string_len_trim_char4);\n \n+extern char *fc_strdup(const char *, gfc_charlen_type);\n+internal_proto(fc_strdup);\n+\n /* io/intrinsics.c */\n \n extern void flush_all_units (void);"}, {"sha": "8a572ecd5efa6e30f5189682e5e13abbbdbc4436", "filename": "libgfortran/runtime/main.c", "status": "modified", "additions": 46, "deletions": 18, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fruntime%2Fmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fruntime%2Fmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fmain.c?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -26,6 +26,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <stdlib.h>\n #include <string.h>\n #include <limits.h>\n+#include <errno.h>\n \n \n #ifdef HAVE_UNISTD_H\n@@ -70,23 +71,18 @@ static int argc_save;\n static char **argv_save;\n \n static const char *exe_path;\n-static int please_free_exe_path_when_done;\n+static bool please_free_exe_path_when_done;\n \n /* Save the path under which the program was called, for use in the\n    backtrace routines.  */\n void\n store_exe_path (const char * argv0)\n {\n-#ifndef PATH_MAX\n-#define PATH_MAX 1024\n-#endif\n-\n #ifndef DIR_SEPARATOR   \n #define DIR_SEPARATOR '/'\n #endif\n \n-  char buf[PATH_MAX], *path;\n-  const char *cwd;\n+  char *cwd, *path;\n \n   /* This can only happen if store_exe_path is called multiple times.  */\n   if (please_free_exe_path_when_done)\n@@ -95,13 +91,27 @@ store_exe_path (const char * argv0)\n   /* Reading the /proc/self/exe symlink is Linux-specific(?), but if\n      it works it gives the correct answer.  */\n #ifdef HAVE_READLINK\n-  int len;\n-  if ((len = readlink (\"/proc/self/exe\", buf, sizeof (buf) - 1)) != -1)\n+  ssize_t len, psize = 256;\n+  while (1)\n     {\n-      buf[len] = '\\0';\n-      exe_path = strdup (buf);\n-      please_free_exe_path_when_done = 1;\n-      return;\n+      path = xmalloc (psize);\n+      len = readlink (\"/proc/self/exe\", path, psize);\n+      if (len < 0)\n+\t{\n+\t  free (path);\n+\t  break;\n+\t}\n+      else if (len < psize)\n+\t{\n+\t  path[len] = '\\0';\n+\t  exe_path = strdup (path);\n+\t  free (path);\n+\t  please_free_exe_path_when_done = true;\n+\t  return;\n+\t}\n+      /* The remaining option is len == psize.  */\n+      free (path);\n+      psize *= 4;\n     }\n #endif\n \n@@ -117,31 +127,49 @@ store_exe_path (const char * argv0)\n #endif\n     {\n       exe_path = argv0;\n-      please_free_exe_path_when_done = 0;\n+      please_free_exe_path_when_done = false;\n       return;\n     }\n \n #ifdef HAVE_GETCWD\n-  cwd = getcwd (buf, sizeof (buf));\n+  size_t cwdsize = 256;\n+  while (1)\n+    {\n+      cwd = xmalloc (cwdsize);\n+      if (getcwd (cwd, cwdsize))\n+\tbreak;\n+      else if (errno == ERANGE)\n+\t{\n+\t  free (cwd);\n+\t  cwdsize *= 4;\n+\t}\n+      else\n+\t{\n+\t  free (cwd);\n+\t  cwd = NULL;\n+\t  break;\n+\t}\n+    }\n #else\n   cwd = NULL;\n #endif\n \n   if (!cwd)\n     {\n       exe_path = argv0;\n-      please_free_exe_path_when_done = 0;\n+      please_free_exe_path_when_done = false;\n       return;\n     }\n \n   /* exe_path will be cwd + \"/\" + argv[0] + \"\\0\".  This will not work\n      if the executable is not in the cwd, but at this point we're out\n      of better ideas.  */\n   size_t pathlen = strlen (cwd) + 1 + strlen (argv0) + 1;\n-  path = malloc (pathlen);\n+  path = xmalloc (pathlen);\n   snprintf (path, pathlen, \"%s%c%s\", cwd, DIR_SEPARATOR, argv0);\n+  free (cwd);\n   exe_path = path;\n-  please_free_exe_path_when_done = 1;\n+  please_free_exe_path_when_done = true;\n }\n \n "}, {"sha": "5beb0fbd97139d670dfd31b81fda53f8804a820c", "filename": "libgfortran/runtime/string.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fruntime%2Fstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4269f19c09163d6ef65043171eeccc9c521d9b5f/libgfortran%2Fruntime%2Fstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstring.c?ref=4269f19c09163d6ef65043171eeccc9c521d9b5f", "patch": "@@ -90,6 +90,49 @@ cf_strcpy (char *dest, gfc_charlen_type dest_len, const char *src)\n }\n \n \n+#ifndef HAVE_STRNLEN\n+static size_t\n+strnlen (const char *s, size_t maxlen)\n+{\n+  for (size_t ii = 0; ii < maxlen; ii++)\n+    {\n+      if (s[ii] == '\\0')\n+\treturn ii;\n+    }\n+  return maxlen;\n+}\n+#endif\n+\n+\n+#ifndef HAVE_STRNDUP\n+static char *\n+strndup (const char *s, size_t n)\n+{\n+  size_t len = strnlen (s, n);\n+  char *p = malloc (len + 1);\n+  if (!p)\n+    return NULL;\n+  memcpy (p, s, len);\n+  p[len] = '\\0';\n+  return p;\n+}\n+#endif\n+\n+\n+/* Duplicate a non-null-terminated Fortran string to a malloced\n+   null-terminated C string.  */\n+\n+char *\n+fc_strdup (const char *src, gfc_charlen_type src_len)\n+{\n+  gfc_charlen_type n = fstrlen (src, src_len);\n+  char *p = strndup (src, n);\n+  if (!p)\n+    os_error (\"Memory allocation failed in fc_strdup\");\n+  return p;\n+}\n+\n+\n /* Given a fortran string and an array of st_option structures, search through\n    the array to find a match.  If the option is not found, we generate an error\n    if no default is provided.  */"}]}