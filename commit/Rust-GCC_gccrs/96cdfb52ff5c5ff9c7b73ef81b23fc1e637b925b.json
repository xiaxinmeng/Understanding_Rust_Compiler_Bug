{"sha": "96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZjZGZiNTJmZjVjNWZmOWM3YjczZWY4MWIyM2ZjMWU2MzdiOTI1Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2007-11-09T12:49:55Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2007-11-09T12:49:55Z"}, "message": "re PR rtl-optimization/33732 (gcc.c-torture/execute/longlong.c execution at -O3)\n\n\tPR rtl-optimization/33732\n\t* reload.c (push_reload): Check that the REG_DEAD note was referring\n\tto a hardreg or to a pseudo that has been assigned exactly one hardreg\n\tbefore considering it in order to select the reload register.\n\t(combine_reloads): Likewise.\n\t(find_dummy_reload): Likewise.\n\nFrom-SVN: r130042", "tree": {"sha": "02eb0b8225223e9a89c38c461a3257d4c11bc7ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02eb0b8225223e9a89c38c461a3257d4c11bc7ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "91a17a346ef6b2f901a3fe4077228d918a98a8b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a17a346ef6b2f901a3fe4077228d918a98a8b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91a17a346ef6b2f901a3fe4077228d918a98a8b5"}], "stats": {"total": 83, "additions": 49, "deletions": 34}, "files": [{"sha": "53c97771f9d29c5062d48cd22fa70a092aa2ee41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b", "patch": "@@ -1,3 +1,12 @@\n+2007-11-09  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR rtl-optimization/33732\n+\t* reload.c (push_reload): Check that the REG_DEAD note was referring\n+\tto a hardreg or to a pseudo that has been assigned exactly one hardreg\n+\tbefore considering it in order to select the reload register.\n+\t(combine_reloads): Likewise.\n+\t(find_dummy_reload): Likewise.\n+\n 2007-11-09  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-flow.h (struct ptr_info_def): Make escape_mask a"}, {"sha": "fd791b2d57f8151ed5b4f4d390038f24171553a1", "filename": "gcc/reload.c", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=96cdfb52ff5c5ff9c7b73ef81b23fc1e637b925b", "patch": "@@ -1518,11 +1518,11 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    && REG_P (XEXP (note, 0))\n \t    && (regno = REGNO (XEXP (note, 0))) < FIRST_PSEUDO_REGISTER\n \t    && reg_mentioned_p (XEXP (note, 0), in)\n-\t    /* Check that we don't use a hardreg for an uninitialized\n-\t       pseudo.  See also find_dummy_reload().  */\n+\t    /* Check that a former pseudo is valid; see find_dummy_reload.  */\n \t    && (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n-\t\t|| ! bitmap_bit_p (DF_LIVE_OUT (ENTRY_BLOCK_PTR),\n-\t\t\t\t   ORIGINAL_REGNO (XEXP (note, 0))))\n+\t\t|| (!bitmap_bit_p (DF_LIVE_OUT (ENTRY_BLOCK_PTR),\n+\t\t\t\t   ORIGINAL_REGNO (XEXP (note, 0)))\n+\t\t    && hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))] == 1))\n \t    && ! refers_to_regno_for_reload_p (regno,\n \t\t\t\t\t       end_hard_regno (rel_mode,\n \t\t\t\t\t\t\t       regno),\n@@ -1678,7 +1678,7 @@ remove_address_replacements (rtx in_rtx)\n static void\n combine_reloads (void)\n {\n-  int i;\n+  int i, regno;\n   int output_reload = -1;\n   int secondary_out = -1;\n   rtx note;\n@@ -1825,34 +1825,32 @@ combine_reloads (void)\n   for (note = REG_NOTES (this_insn); note; note = XEXP (note, 1))\n     if (REG_NOTE_KIND (note) == REG_DEAD\n \t&& REG_P (XEXP (note, 0))\n-\t&& ! reg_overlap_mentioned_for_reload_p (XEXP (note, 0),\n-\t\t\t\t\t\t rld[output_reload].out)\n-\t&& REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n-\t&& HARD_REGNO_MODE_OK (REGNO (XEXP (note, 0)), rld[output_reload].outmode)\n+\t&& !reg_overlap_mentioned_for_reload_p (XEXP (note, 0),\n+\t\t\t\t\t\trld[output_reload].out)\n+\t&& (regno = REGNO (XEXP (note, 0))) < FIRST_PSEUDO_REGISTER\n+\t&& HARD_REGNO_MODE_OK (regno, rld[output_reload].outmode)\n \t&& TEST_HARD_REG_BIT (reg_class_contents[(int) rld[output_reload].class],\n-\t\t\t      REGNO (XEXP (note, 0)))\n-\t&& (hard_regno_nregs[REGNO (XEXP (note, 0))][rld[output_reload].outmode]\n-\t    <= hard_regno_nregs[REGNO (XEXP (note, 0))][GET_MODE (XEXP (note, 0))])\n+\t\t\t      regno)\n+\t&& (hard_regno_nregs[regno][rld[output_reload].outmode]\n+\t    <= hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))])\n \t/* Ensure that a secondary or tertiary reload for this output\n \t   won't want this register.  */\n \t&& ((secondary_out = rld[output_reload].secondary_out_reload) == -1\n-\t    || (! (TEST_HARD_REG_BIT\n-\t\t   (reg_class_contents[(int) rld[secondary_out].class],\n-\t\t    REGNO (XEXP (note, 0))))\n+\t    || (!(TEST_HARD_REG_BIT\n+\t\t  (reg_class_contents[(int) rld[secondary_out].class], regno))\n \t\t&& ((secondary_out = rld[secondary_out].secondary_out_reload) == -1\n-\t\t    ||  ! (TEST_HARD_REG_BIT\n-\t\t\t   (reg_class_contents[(int) rld[secondary_out].class],\n-\t\t\t    REGNO (XEXP (note, 0)))))))\n-\t&& ! fixed_regs[REGNO (XEXP (note, 0))]\n-\t/* Check that we don't use a hardreg for an uninitialized\n-\t   pseudo.  See also find_dummy_reload().  */\n+\t\t    || !(TEST_HARD_REG_BIT\n+\t\t\t (reg_class_contents[(int) rld[secondary_out].class],\n+\t\t\t  regno)))))\n+\t&& !fixed_regs[regno]\n+\t/* Check that a former pseudo is valid; see find_dummy_reload.  */\n \t&& (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n-\t    || ! bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR),\n-\t\t\t       ORIGINAL_REGNO (XEXP (note, 0)))))\n+\t    || (!bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR),\n+\t\t\t       ORIGINAL_REGNO (XEXP (note, 0)))\n+\t\t&& hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))] == 1)))\n       {\n \trld[output_reload].reg_rtx\n-\t  = gen_rtx_REG (rld[output_reload].outmode,\n-\t\t\t REGNO (XEXP (note, 0)));\n+\t  = gen_rtx_REG (rld[output_reload].outmode, regno);\n \treturn;\n       }\n }\n@@ -1992,16 +1990,24 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t\t\t\thas a real mode.  */\n \t\t\t     (GET_MODE (out) != VOIDmode\n \t\t\t      ? GET_MODE (out) : outmode))\n-        /* But only do all this if we can be sure, that this input\n-           operand doesn't correspond with an uninitialized pseudoreg.\n-           global can assign some hardreg to it, which is the same as\n-\t   a different pseudo also currently live (as it can ignore the\n-\t   conflict).  So we never must introduce writes to such hardregs,\n-\t   as they would clobber the other live pseudo using the same.\n-\t   See also PR20973.  */\n       && (ORIGINAL_REGNO (in) < FIRST_PSEUDO_REGISTER\n-          || ! bitmap_bit_p (DF_LIVE_OUT (ENTRY_BLOCK_PTR),\n-\t\t\t     ORIGINAL_REGNO (in))))\n+\t  /* However only do this if we can be sure that this input\n+\t     operand doesn't correspond with an uninitialized pseudo.\n+\t     global can assign some hardreg to it that is the same as\n+\t     the one assigned to a different, also live pseudo (as it\n+\t     can ignore the conflict).  We must never introduce writes\n+\t     to such hardregs, as they would clobber the other live\n+\t     pseudo.  See PR 20973.  */\n+          || (!bitmap_bit_p (DF_LIVE_OUT (ENTRY_BLOCK_PTR),\n+\t\t\t     ORIGINAL_REGNO (in))\n+\t      /* Similarly, only do this if we can be sure that the death\n+\t\t note is still valid.  global can assign some hardreg to\n+\t\t the pseudo referenced in the note and simultaneously a\n+\t\t subword of this hardreg to a different, also live pseudo,\n+\t\t because only another subword of the hardreg is actually\n+\t\t used in the insn.  This cannot happen if the pseudo has\n+\t\t been assigned exactly one hardreg.  See PR 33732.  */\n+\t      && hard_regno_nregs[REGNO (in)][GET_MODE (in)] == 1)))\n     {\n       unsigned int regno = REGNO (in) + in_offset;\n       unsigned int nwords = hard_regno_nregs[regno][inmode];"}]}