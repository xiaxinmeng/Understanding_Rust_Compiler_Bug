{"sha": "9e95d15fd865706efec69a2ca415cb992e9cb99a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU5NWQxNWZkODY1NzA2ZWZlYzY5YTJjYTQxNWNiOTkyZTljYjk5YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-07-21T08:28:33Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-21T08:28:33Z"}, "message": "cp-tree.h (hack_identifier): Remove.\n\ncp:\n\t* cp-tree.h (hack_identifier): Remove.\n\t* method.c (hack_identifier): Remove.\n\t* semantics.c (finish_id_expression): Expand hack_identifier\n\there. Simplify.\n\nFrom-SVN: r69625", "tree": {"sha": "9a939f3bd0297ef0e3cfe8d75b551bd84a11c54f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a939f3bd0297ef0e3cfe8d75b551bd84a11c54f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e95d15fd865706efec69a2ca415cb992e9cb99a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e95d15fd865706efec69a2ca415cb992e9cb99a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e95d15fd865706efec69a2ca415cb992e9cb99a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e95d15fd865706efec69a2ca415cb992e9cb99a/comments", "author": null, "committer": null, "parents": [{"sha": "49e58846cfcf8e0fab50e43aa82901a5c74653c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e58846cfcf8e0fab50e43aa82901a5c74653c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49e58846cfcf8e0fab50e43aa82901a5c74653c4"}], "stats": {"total": 209, "additions": 89, "deletions": 120}, "files": [{"sha": "d13909bf29b427483a4a336d308a762ba67105a7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e95d15fd865706efec69a2ca415cb992e9cb99a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e95d15fd865706efec69a2ca415cb992e9cb99a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9e95d15fd865706efec69a2ca415cb992e9cb99a", "patch": "@@ -1,8 +1,22 @@\n+2003-07-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (hack_identifier): Remove.\n+\t* method.c (hack_identifier): Remove.\n+\t* semantics.c (finish_id_expression): Expand hack_identifier\n+\there. Simplify.\n+\n 2003-07-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* call.c class.c decl.c decl2.c g++spec.c lex.c parser.c pt.c rtti.c\n \tsemantics.c typeck.c: Remove unnecessary casts.\n \n+2003-07-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (hack_identifier): Remove.\n+\t* method.c (hack_identifier): Remove.\n+\t* semantics.c (finish_id_expression): Expand hack_identifier\n+\there. Simplify.\n+\n 2003-07-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (finish_non_static_data_member): Add object param."}, {"sha": "29a9f290d9baa25963181fe6e9970eea0dd55dff", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e95d15fd865706efec69a2ca415cb992e9cb99a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e95d15fd865706efec69a2ca415cb992e9cb99a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9e95d15fd865706efec69a2ca415cb992e9cb99a", "patch": "@@ -3923,7 +3923,6 @@ extern void cxx_finish (void);\n /* in method.c */\n extern void init_method\t(void);\n extern void set_mangled_name_for_decl (tree);\n-extern tree hack_identifier (tree, tree);\n extern tree make_thunk (tree, bool, tree, tree);\n extern void finish_thunk (tree);\n extern void use_thunk (tree, bool);"}, {"sha": "35319de9346c2a7af567a582c288103800502200", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e95d15fd865706efec69a2ca415cb992e9cb99a/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e95d15fd865706efec69a2ca415cb992e9cb99a/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9e95d15fd865706efec69a2ca415cb992e9cb99a", "patch": "@@ -87,119 +87,6 @@ set_mangled_name_for_decl (tree decl)\n   mangle_decl (decl);\n }\n \n-\f\n-/* This function takes an identifier, ID, and attempts to figure out what\n-   it means. There are a number of possible scenarios, presented in increasing\n-   order of hair:\n-\n-   1) not in a class's scope\n-   2) in class's scope, member name of the class's method\n-   3) in class's scope, but not a member name of the class\n-   4) in class's scope, member name of a class's variable\n-\n-   NAME is $1 from the bison rule. It is an IDENTIFIER_NODE.\n-   VALUE is $$ from the bison rule. It is the value returned by lookup_name ($1)\n-\n-   As a last ditch, try to look up the name as a label and return that\n-   address.\n-\n-   Values which are declared as being of REFERENCE_TYPE are\n-   automatically dereferenced here (as a hack to make the\n-   compiler faster).  */\n-\n-tree\n-hack_identifier (tree value, tree name)\n-{\n-  tree type;\n-\n-  if (value == error_mark_node)\n-    return error_mark_node;\n-\n-  type = TREE_TYPE (value);\n-  if (TREE_CODE (value) == FIELD_DECL)\n-    value = finish_non_static_data_member (value, current_class_ref,\n-\t\t\t\t\t   /*qualifying_scope=*/NULL_TREE);\n-  else if ((TREE_CODE (value) == FUNCTION_DECL\n-\t    && DECL_FUNCTION_MEMBER_P (value))\n-\t   || (TREE_CODE (value) == OVERLOAD\n-\t       && DECL_FUNCTION_MEMBER_P (OVL_CURRENT (value))))\n-    {\n-      tree decl;\n-\n-      if (TREE_CODE (value) == OVERLOAD)\n-\tvalue = OVL_CURRENT (value);\n-\n-      decl = maybe_dummy_object (DECL_CONTEXT (value), 0);\n-      value = finish_class_member_access_expr (decl, name);\n-    }\n-  else if (really_overloaded_fn (value))\n-    ;\n-  else if (TREE_CODE (value) == OVERLOAD)\n-    /* not really overloaded function */\n-    mark_used (OVL_FUNCTION (value));\n-  else if (TREE_CODE (value) == TREE_LIST)\n-    {\n-      /* Ambiguous reference to base members, possibly other cases?.  */\n-      tree t = value;\n-      while (t && TREE_CODE (t) == TREE_LIST)\n-\t{\n-\t  mark_used (TREE_VALUE (t));\n-\t  t = TREE_CHAIN (t);\n-\t}\n-    }\n-  else if (TREE_CODE (value) == NAMESPACE_DECL)\n-    {\n-      error (\"use of namespace `%D' as expression\", value);\n-      return error_mark_node;\n-    }\n-  else if (DECL_CLASS_TEMPLATE_P (value))\n-    {\n-      error (\"use of class template `%T' as expression\", value);\n-      return error_mark_node;\n-    }\n-  else\n-    mark_used (value);\n-\n-  if (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == PARM_DECL\n-      || TREE_CODE (value) == RESULT_DECL)\n-    {\n-      tree context = decl_function_context (value);\n-      if (context != NULL_TREE && context != current_function_decl\n-\t  && ! TREE_STATIC (value))\n-\t{\n-\t  error (\"use of %s from containing function\",\n-\t\t      (TREE_CODE (value) == VAR_DECL\n-\t\t       ? \"`auto' variable\" : \"parameter\"));\n-\t  cp_error_at (\"  `%#D' declared here\", value);\n-\t  value = error_mark_node;\n-\t}\n-    }\n-\n-  if (DECL_P (value) && DECL_NONLOCAL (value))\n-    {\n-      if (DECL_CLASS_SCOPE_P (value)\n-\t  && DECL_CONTEXT (value) != current_class_type)\n-\t{\n-\t  tree path;\n-\t  path = currently_open_derived_class (DECL_CONTEXT (value));\n-\t  perform_or_defer_access_check (TYPE_BINFO (path), value);\n-\t}\n-    }\n-  else if (TREE_CODE (value) == TREE_LIST \n-\t   && TREE_TYPE (value) == error_mark_node)\n-    {\n-      error (\"\\\n-request for member `%D' is ambiguous in multiple inheritance lattice\",\n-\t\tname);\n-      print_candidates (value);\n-      return error_mark_node;\n-    }\n-\n-  if (! processing_template_decl)\n-    value = convert_from_reference (value);\n-  return value;\n-}\n-\n \f\n /* Return a this or result adjusting thunk to FUNCTION.  THIS_ADJUSTING\n    indicates whether it is a this or result adjusting thunk."}, {"sha": "c490ab80c702051274bdf3789c86189bab6e3302", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 75, "deletions": 6, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e95d15fd865706efec69a2ca415cb992e9cb99a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e95d15fd865706efec69a2ca415cb992e9cb99a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9e95d15fd865706efec69a2ca415cb992e9cb99a", "patch": "@@ -1248,11 +1248,11 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \t  \n \t  if (DECL_MUTABLE_P (decl))\n \t    quals &= ~TYPE_QUAL_CONST;\n-\t  \n+\n \t  quals |= cp_type_quals (TREE_TYPE (decl));\n \t  type = cp_build_qualified_type (type, quals);\n \t}\n-\n+      \n       return build_min (COMPONENT_REF, type, object, decl);\n     }\n   else\n@@ -2522,11 +2522,80 @@ finish_id_expression (tree id_expression,\n \t  else if (TYPE_P (scope))\n \t    decl = build (SCOPE_REF, TREE_TYPE (decl), scope, decl);\n \t}\n-      else\n-\t/* Transform references to non-static data members into\n-\t   COMPONENT_REFs.  */\n-\tdecl = hack_identifier (decl, id_expression);\n+      else if (TREE_CODE (decl) == NAMESPACE_DECL)\n+\t{\n+\t  error (\"use of namespace `%D' as expression\", decl);\n+\t  return error_mark_node;\n+\t}\n+      else if (DECL_CLASS_TEMPLATE_P (decl))\n+\t{\n+\t  error (\"use of class template `%T' as expression\", decl);\n+\t  return error_mark_node;\n+\t}\n+      else if (TREE_CODE (decl) == TREE_LIST)\n+\t{\n+\t  /* Ambiguous reference to base members.  */\n+\t  error (\"request for member `%D' is ambiguous in \"\n+\t\t \"multiple inheritance lattice\", id_expression);\n+\t  print_candidates (decl);\n+\t  return error_mark_node;\n+\t}\n+      else if (TREE_CODE (decl) == FIELD_DECL)\n+\tdecl = finish_non_static_data_member (decl, current_class_ref,\n+\t\t\t\t\t      /*qualifying_scope=*/NULL_TREE);\n+      else if (is_overloaded_fn (decl))\n+\t{\n+\t  tree first_fn = OVL_CURRENT (decl);\n \n+\t  if (TREE_CODE (first_fn) == TEMPLATE_DECL)\n+\t    first_fn = DECL_TEMPLATE_RESULT (first_fn);\n+\t  \n+\t  if (TREE_CODE (first_fn) == FUNCTION_DECL\n+\t      && DECL_FUNCTION_MEMBER_P (first_fn))\n+\t    {\n+\t      /* A set of member functions.  */\n+\t      decl = maybe_dummy_object (DECL_CONTEXT (first_fn), 0);\n+\t      return finish_class_member_access_expr (decl, id_expression);\n+\t    }\n+\t  else if (!really_overloaded_fn (decl))\n+\t    /* not really overloaded function */\n+\t    mark_used (first_fn);\n+\t}\n+      else\n+\t{\n+\t  if (TREE_CODE (decl) == VAR_DECL\n+\t      || TREE_CODE (decl) == PARM_DECL\n+\t      || TREE_CODE (decl) == RESULT_DECL)\n+\t    {\n+\t      tree context = decl_function_context (decl);\n+\t      \n+\t      if (context != NULL_TREE && context != current_function_decl\n+\t\t  && ! TREE_STATIC (decl))\n+\t\t{\n+\t\t  error (\"use of %s from containing function\",\n+\t\t\t (TREE_CODE (decl) == VAR_DECL\n+\t\t\t  ? \"`auto' variable\" : \"parameter\"));\n+\t\t  cp_error_at (\"  `%#D' declared here\", decl);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t  \n+\t  if (DECL_P (decl) && DECL_NONLOCAL (decl)\n+\t      && DECL_CLASS_SCOPE_P (decl)\n+\t      && DECL_CONTEXT (decl) != current_class_type)\n+\t    {\n+\t      tree path;\n+\t      \n+\t      path = currently_open_derived_class (DECL_CONTEXT (decl));\n+\t      perform_or_defer_access_check (TYPE_BINFO (path), decl);\n+\t    }\n+\t  \n+\t  mark_used (decl);\n+\t  \n+\t  if (! processing_template_decl)\n+\t    decl = convert_from_reference (decl);\n+\t}\n+      \n       /* Resolve references to variables of anonymous unions\n \t into COMPONENT_REFs.  */\n       if (TREE_CODE (decl) == ALIAS_DECL)"}]}