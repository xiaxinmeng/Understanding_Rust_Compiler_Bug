{"sha": "0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEwMGM1ZjliN2Q2ZTYyMmQ2NmJjOTBkYTBmMmJmY2RmOTcyMmQ3MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T20:46:46Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T20:46:46Z"}, "message": "[AArch64] Move code around\n\nThis patch simply moves code around, in order to make the later\npatches easier to read, and to avoid forward declarations.\nIt doesn't add the missing function comments because the interfaces\nwill change in a later patch.\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_add_constant_internal)\n\t(aarch64_add_constant, aarch64_add_sp, aarch64_sub_sp): Move\n\tearlier in file.\n\nReviewed-by: James Greenhalgh <james.greenhalgh@arm.com>\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254325", "tree": {"sha": "781916211d877adf4ae1142551bb815763abccfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/781916211d877adf4ae1142551bb815763abccfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71/comments", "author": null, "committer": null, "parents": [{"sha": "3f8334a56feab6b165fb642ba5260510660e2e5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f8334a56feab6b165fb642ba5260510660e2e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f8334a56feab6b165fb642ba5260510660e2e5f"}], "stats": {"total": 171, "additions": 89, "deletions": 82}, "files": [{"sha": "fc88c85a4a6cc101271836cf827ca6a53dec6213", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71", "patch": "@@ -1,3 +1,11 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_add_constant_internal)\n+\t(aarch64_add_constant, aarch64_add_sp, aarch64_sub_sp): Move\n+\tearlier in file.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "39ba21876bab2b99ac8442711cb946f404ca235b", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 81, "deletions": 82, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=0100c5f9b7d6e622d66bc90da0f2bfcdf9722d71", "patch": "@@ -1964,6 +1964,87 @@ aarch64_internal_mov_immediate (rtx dest, rtx imm, bool generate,\n   return num_insns;\n }\n \n+/* Add DELTA to REGNUM in mode MODE.  SCRATCHREG can be used to hold a\n+   temporary value if necessary.  FRAME_RELATED_P should be true if\n+   the RTX_FRAME_RELATED flag should be set and CFA adjustments added\n+   to the generated instructions.  If SCRATCHREG is known to hold\n+   abs (delta), EMIT_MOVE_IMM can be set to false to avoid emitting the\n+   immediate again.\n+\n+   Since this function may be used to adjust the stack pointer, we must\n+   ensure that it cannot cause transient stack deallocation (for example\n+   by first incrementing SP and then decrementing when adjusting by a\n+   large immediate).  */\n+\n+static void\n+aarch64_add_constant_internal (scalar_int_mode mode, int regnum,\n+\t\t\t       int scratchreg, HOST_WIDE_INT delta,\n+\t\t\t       bool frame_related_p, bool emit_move_imm)\n+{\n+  HOST_WIDE_INT mdelta = abs_hwi (delta);\n+  rtx this_rtx = gen_rtx_REG (mode, regnum);\n+  rtx_insn *insn;\n+\n+  if (!mdelta)\n+    return;\n+\n+  /* Single instruction adjustment.  */\n+  if (aarch64_uimm12_shift (mdelta))\n+    {\n+      insn = emit_insn (gen_add2_insn (this_rtx, GEN_INT (delta)));\n+      RTX_FRAME_RELATED_P (insn) = frame_related_p;\n+      return;\n+    }\n+\n+  /* Emit 2 additions/subtractions if the adjustment is less than 24 bits.\n+     Only do this if mdelta is not a 16-bit move as adjusting using a move\n+     is better.  */\n+  if (mdelta < 0x1000000 && !aarch64_move_imm (mdelta, mode))\n+    {\n+      HOST_WIDE_INT low_off = mdelta & 0xfff;\n+\n+      low_off = delta < 0 ? -low_off : low_off;\n+      insn = emit_insn (gen_add2_insn (this_rtx, GEN_INT (low_off)));\n+      RTX_FRAME_RELATED_P (insn) = frame_related_p;\n+      insn = emit_insn (gen_add2_insn (this_rtx, GEN_INT (delta - low_off)));\n+      RTX_FRAME_RELATED_P (insn) = frame_related_p;\n+      return;\n+    }\n+\n+  /* Emit a move immediate if required and an addition/subtraction.  */\n+  rtx scratch_rtx = gen_rtx_REG (mode, scratchreg);\n+  if (emit_move_imm)\n+    aarch64_internal_mov_immediate (scratch_rtx, GEN_INT (mdelta), true, mode);\n+  insn = emit_insn (delta < 0 ? gen_sub2_insn (this_rtx, scratch_rtx)\n+\t\t\t      : gen_add2_insn (this_rtx, scratch_rtx));\n+  if (frame_related_p)\n+    {\n+      RTX_FRAME_RELATED_P (insn) = frame_related_p;\n+      rtx adj = plus_constant (mode, this_rtx, delta);\n+      add_reg_note (insn , REG_CFA_ADJUST_CFA, gen_rtx_SET (this_rtx, adj));\n+    }\n+}\n+\n+static inline void\n+aarch64_add_constant (scalar_int_mode mode, int regnum, int scratchreg,\n+\t\t      HOST_WIDE_INT delta)\n+{\n+  aarch64_add_constant_internal (mode, regnum, scratchreg, delta, false, true);\n+}\n+\n+static inline void\n+aarch64_add_sp (int scratchreg, HOST_WIDE_INT delta, bool emit_move_imm)\n+{\n+  aarch64_add_constant_internal (Pmode, SP_REGNUM, scratchreg, delta,\n+\t\t\t\t true, emit_move_imm);\n+}\n+\n+static inline void\n+aarch64_sub_sp (int scratchreg, HOST_WIDE_INT delta, bool frame_related_p)\n+{\n+  aarch64_add_constant_internal (Pmode, SP_REGNUM, scratchreg, -delta,\n+\t\t\t\t frame_related_p, true);\n+}\n \n void\n aarch64_expand_mov_immediate (rtx dest, rtx imm)\n@@ -2075,88 +2156,6 @@ aarch64_expand_mov_immediate (rtx dest, rtx imm)\n \t\t\t\t  as_a <scalar_int_mode> (mode));\n }\n \n-/* Add DELTA to REGNUM in mode MODE.  SCRATCHREG can be used to hold a\n-   temporary value if necessary.  FRAME_RELATED_P should be true if\n-   the RTX_FRAME_RELATED flag should be set and CFA adjustments added\n-   to the generated instructions.  If SCRATCHREG is known to hold\n-   abs (delta), EMIT_MOVE_IMM can be set to false to avoid emitting the\n-   immediate again.\n-\n-   Since this function may be used to adjust the stack pointer, we must\n-   ensure that it cannot cause transient stack deallocation (for example\n-   by first incrementing SP and then decrementing when adjusting by a\n-   large immediate).  */\n-\n-static void\n-aarch64_add_constant_internal (scalar_int_mode mode, int regnum,\n-\t\t\t       int scratchreg, HOST_WIDE_INT delta,\n-\t\t\t       bool frame_related_p, bool emit_move_imm)\n-{\n-  HOST_WIDE_INT mdelta = abs_hwi (delta);\n-  rtx this_rtx = gen_rtx_REG (mode, regnum);\n-  rtx_insn *insn;\n-\n-  if (!mdelta)\n-    return;\n-\n-  /* Single instruction adjustment.  */\n-  if (aarch64_uimm12_shift (mdelta))\n-    {\n-      insn = emit_insn (gen_add2_insn (this_rtx, GEN_INT (delta)));\n-      RTX_FRAME_RELATED_P (insn) = frame_related_p;\n-      return;\n-    }\n-\n-  /* Emit 2 additions/subtractions if the adjustment is less than 24 bits.\n-     Only do this if mdelta is not a 16-bit move as adjusting using a move\n-     is better.  */\n-  if (mdelta < 0x1000000 && !aarch64_move_imm (mdelta, mode))\n-    {\n-      HOST_WIDE_INT low_off = mdelta & 0xfff;\n-\n-      low_off = delta < 0 ? -low_off : low_off;\n-      insn = emit_insn (gen_add2_insn (this_rtx, GEN_INT (low_off)));\n-      RTX_FRAME_RELATED_P (insn) = frame_related_p;\n-      insn = emit_insn (gen_add2_insn (this_rtx, GEN_INT (delta - low_off)));\n-      RTX_FRAME_RELATED_P (insn) = frame_related_p;\n-      return;\n-    }\n-\n-  /* Emit a move immediate if required and an addition/subtraction.  */\n-  rtx scratch_rtx = gen_rtx_REG (mode, scratchreg);\n-  if (emit_move_imm)\n-    aarch64_internal_mov_immediate (scratch_rtx, GEN_INT (mdelta), true, mode);\n-  insn = emit_insn (delta < 0 ? gen_sub2_insn (this_rtx, scratch_rtx)\n-\t\t\t      : gen_add2_insn (this_rtx, scratch_rtx));\n-  if (frame_related_p)\n-    {\n-      RTX_FRAME_RELATED_P (insn) = frame_related_p;\n-      rtx adj = plus_constant (mode, this_rtx, delta);\n-      add_reg_note (insn , REG_CFA_ADJUST_CFA, gen_rtx_SET (this_rtx, adj));\n-    }\n-}\n-\n-static inline void\n-aarch64_add_constant (scalar_int_mode mode, int regnum, int scratchreg,\n-\t\t      HOST_WIDE_INT delta)\n-{\n-  aarch64_add_constant_internal (mode, regnum, scratchreg, delta, false, true);\n-}\n-\n-static inline void\n-aarch64_add_sp (int scratchreg, HOST_WIDE_INT delta, bool emit_move_imm)\n-{\n-  aarch64_add_constant_internal (Pmode, SP_REGNUM, scratchreg, delta,\n-\t\t\t\t true, emit_move_imm);\n-}\n-\n-static inline void\n-aarch64_sub_sp (int scratchreg, HOST_WIDE_INT delta, bool frame_related_p)\n-{\n-  aarch64_add_constant_internal (Pmode, SP_REGNUM, scratchreg, -delta,\n-\t\t\t\t frame_related_p, true);\n-}\n-\n static bool\n aarch64_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n \t\t\t\t tree exp ATTRIBUTE_UNUSED)"}]}