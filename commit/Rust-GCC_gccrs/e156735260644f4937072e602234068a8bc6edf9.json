{"sha": "e156735260644f4937072e602234068a8bc6edf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE1NjczNTI2MDY0NGY0OTM3MDcyZTYwMjIzNDA2OGE4YmM2ZWRmOQ==", "commit": {"author": {"name": "Jason Eckhardt", "email": "jle@rice.edu", "date": "2003-08-23T02:02:18Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2003-08-23T02:02:18Z"}, "message": "MAINTAINERS: Resurrect the i860 maintainer.\n\n2003-08-22  Jason Eckhardt  <jle@rice.edu>\n\nChangeLog\n\t* MAINTAINERS: Resurrect the i860 maintainer.\n\ngcc/ChangeLog:\n\t* gcc/config.gcc (i860-*-sysv4*): Add target.\n\t* config/i860/i860-protos.h: New.\n\t* config/i860/i860.c: New.\n\t* config/i860/i860.h: New.\n\t* config/i860/i860.md: New.\n\t* config/i860/sysv4.h: New.\n\t* config/i860/varargs.asm: New.\n\t* config/i860/x-sysv4: New.\n\nFrom-SVN: r70719", "tree": {"sha": "d3af9a9bf50559d84be1c7c057f153b1e5c86d66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3af9a9bf50559d84be1c7c057f153b1e5c86d66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e156735260644f4937072e602234068a8bc6edf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e156735260644f4937072e602234068a8bc6edf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e156735260644f4937072e602234068a8bc6edf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e156735260644f4937072e602234068a8bc6edf9/comments", "author": null, "committer": null, "parents": [{"sha": "6560773ad422624e12629599afda8952c4c8eb57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6560773ad422624e12629599afda8952c4c8eb57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6560773ad422624e12629599afda8952c4c8eb57"}], "stats": {"total": 6479, "additions": 6479, "deletions": 0}, "files": [{"sha": "a46f68d9e7b95e73a82b02cb13a41c614b7bab54", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -1,3 +1,7 @@\n+2003-08-22  Jason Eckhardt  <jle@rice.edu>\n+\n+\t* MAINTAINERS: Resurrect the i860 maintainer.\n+\n 2003-08-20  Geoffrey Keating  <geoffk@apple.com>\n \n \tPR 8180"}, {"sha": "1cdcb8b5a46f0a7502639b86d2bbe2cd5afb6f08", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -49,6 +49,7 @@ h8 port\t\t\tKazu Hirata\t\tkazu@cs.umass.edu\n hppa port\t\tJeff Law\t\tlaw@redhat.com\n hppa port\t\tDave Anglin\t\tdave.anglin@nrc.ca\n i386 port\t\tRichard Henderson\trth@redhat.com\n+i860 port\t\tJason Eckhardt\t\tjle@rice.edu\n i960 port\t\tJim Wilson\t\twilson@tuliptree.org\n ia64 port\t\tJim Wilson\t\twilson@tuliptree.org\n ip2k port\t\tDenis Chertykov\t\tdenisc@overta.ru"}, {"sha": "55fbc0ab134e593439481a7896059dfcc53e2093", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -1,3 +1,14 @@\n+2003-08-22  Jason Eckhardt  <jle@rice.edu>\n+\n+\t* config.gcc (i860-*-sysv4*): Add target.\n+\t* config/i860/i860-protos.h: New.\n+\t* config/i860/i860.c: New.\n+\t* config/i860/i860.h: New.\n+\t* config/i860/i860.md: New.\n+\t* config/i860/sysv4.h: New.\n+\t* config/i860/varargs.asm: New.\n+\t* config/i860/x-sysv4: New.\n+\n 2003-08-22  Jason Eckhardt  <jle@rice.edu>\n \n \t* config/pa/pa.c: Replace 'GNU CC' with 'GCC'."}, {"sha": "e98544d465f007627aea2e2cee91f795821c8b05", "filename": "gcc/config.gcc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -1235,6 +1235,13 @@ i[34567]86-*-kaos*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h kaos.h i386/kaos-i386.h\"\n \ttmake_file=\"i386/t-i386elf t-svr4\"\n \t;;\n+i860-*-sysv4*)\n+        tm_file=\"${tm_file} elfos.h svr4.h i860/sysv4.h\"\n+        xm_defines=\"USG SVR3\"\n+        xmake_file=i860/x-sysv4\n+        tmake_file=t-svr4\n+        extra_parts=\"crtbegin.o crtend.o\"\n+        ;;\n i960-*-coff*)\n \ttm_file=\"${tm_file} dbxcoff.h i960/i960-coff.h libgloss.h\"\n \ttmake_file=i960/t-960bare"}, {"sha": "42cbe184fae31d48cb00f2d36f78f1ecb1ea40e2", "filename": "gcc/config/i860/i860-protos.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fi860-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fi860-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860-protos.h?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -0,0 +1,61 @@\n+/* Definitions of target machine for GNU compiler, for Intel 860.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Hacked substantially by Ron Guilmette (rfg@monkeys.com) to cater to\n+   the whims of the System V Release 4 assembler.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Declare things which are defined in i860.c but called from\n+   insn-output.c.  */\n+\n+#ifdef RTX_CODE\n+extern unsigned long sfmode_constant_to_ulong PARAMS ((rtx));\n+extern const char *output_load PARAMS ((rtx *));\n+extern const char *output_store PARAMS ((rtx *));\n+extern const char *output_move_double PARAMS ((rtx *));\n+extern const char *output_fp_move_double PARAMS ((rtx *));\n+extern const char *output_block_move PARAMS ((rtx *));\n+extern const char *output_delay_insn PARAMS ((rtx));\n+#if 0\n+extern const char *output_delayed_branch PARAMS ((const char *, rtx *, rtx));\n+#endif\n+extern void output_load_address PARAMS ((rtx *));\n+extern int safe_insn_src_p PARAMS ((rtx, enum machine_mode));\n+extern int operand_clobbered_before_used_after PARAMS ((rtx, rtx));\n+extern int single_insn_src_p PARAMS ((rtx, enum machine_mode));\n+extern int reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_operand PARAMS ((rtx, enum machine_mode));\n+extern int logic_operand PARAMS ((rtx, enum machine_mode));\n+extern int shift_operand PARAMS ((rtx, enum machine_mode));\n+extern int compare_operand PARAMS ((rtx, enum machine_mode));\n+extern int bte_operand PARAMS ((rtx, enum machine_mode));\n+extern int indexed_operand PARAMS ((rtx, enum machine_mode));\n+extern int load_operand PARAMS ((rtx, enum machine_mode));\n+extern int small_int PARAMS ((rtx, enum machine_mode));\n+extern int logic_int PARAMS ((rtx, enum machine_mode));\n+extern int call_insn_operand PARAMS ((rtx, enum machine_mode));\n+extern rtx i860_saveregs PARAMS ((void));\n+#ifdef TREE_CODE\n+extern void i860_va_start PARAMS ((int, tree, rtx));\n+extern rtx i860_va_arg PARAMS ((tree, tree));\n+#endif /* TREE_CODE */\n+#endif /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+extern tree i860_build_va_list PARAMS ((void));\n+#endif /* TREE_CODE */"}, {"sha": "18493976615d5b935907510fd88ccd1e758a9b2f", "filename": "gcc/config/i860/i860.c", "status": "added", "additions": 2361, "deletions": 0, "changes": 2361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -0,0 +1,2361 @@\n+/* Subroutines for insn-output.c for Intel 860\n+   Copyright (C) 1989, 1991, 1997, 1998, 1999, 2000, 2001, 2002\n+   Free Software Foundation, Inc.\n+   Derived from sparc.c.\n+\n+   Written by Richard Stallman (rms@ai.mit.edu).\n+\n+   Hacked substantially by Ron Guilmette (rfg@netcom.com) to cater\n+   to the whims of the System V Release 4 assembler.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"recog.h\"\n+#include \"insn-attr.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"tm_p.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+\n+static rtx find_addr_reg PARAMS ((rtx));\n+static int reg_clobbered_p PARAMS ((rtx, rtx));\n+static const char *singlemove_string PARAMS ((rtx *));\n+static const char *load_opcode PARAMS ((enum machine_mode, const char *, rtx));\n+static const char *store_opcode PARAMS ((enum machine_mode, const char *, rtx));\n+static void output_size_for_block_move PARAMS ((rtx, rtx, rtx));\n+static void i860_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n+static void i860_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n+\n+#ifndef I860_REG_PREFIX\n+#define I860_REG_PREFIX \"\"\n+#endif\n+\n+const char *i860_reg_prefix = I860_REG_PREFIX;\n+\n+/* Save information from a \"cmpxx\" operation until the branch is emitted.  */\n+\n+rtx i860_compare_op0, i860_compare_op1;\n+\f\n+/* Initialize the GCC target structure.  */\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE i860_output_function_prologue\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE i860_output_function_epilogue\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\f\n+/* Return non-zero if this pattern, can be evaluated safely, even if it\n+   was not asked for.  */\n+int\n+safe_insn_src_p (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Just experimenting.  */\n+\n+  /* No floating point src is safe if it contains an arithmetic\n+     operation, since that operation may trap.  */\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST:\n+      return 1;\n+\n+    case REG:\n+      return 1;\n+\n+    case MEM:\n+      return CONSTANT_ADDRESS_P (XEXP (op, 0));\n+\n+      /* We never need to negate or complement constants.  */\n+    case NEG:\n+      return (mode != SFmode && mode != DFmode);\n+    case NOT:\n+    case ZERO_EXTEND:\n+      return 1;\n+\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case GT:\n+    case LE:\n+    case GE:\n+    case LTU:\n+    case GTU:\n+    case LEU:\n+    case GEU:\n+    case MINUS:\n+    case PLUS:\n+      return (mode != SFmode && mode != DFmode);\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if ((GET_CODE (XEXP (op, 0)) == CONST_INT && ! SMALL_INT (XEXP (op, 0)))\n+\t  || (GET_CODE (XEXP (op, 1)) == CONST_INT && ! SMALL_INT (XEXP (op, 1))))\n+\treturn 0;\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if REG is clobbered in IN.\n+   Return 2 if REG is used in IN. \n+   Return 3 if REG is both used and clobbered in IN.\n+   Return 0 if neither.  */\n+\n+static int\n+reg_clobbered_p (reg, in)\n+     rtx reg;\n+     rtx in;\n+{\n+  register enum rtx_code code;\n+\n+  if (in == 0)\n+    return 0;\n+\n+  code = GET_CODE (in);\n+\n+  if (code == SET || code == CLOBBER)\n+    {\n+      rtx dest = SET_DEST (in);\n+      int set = 0;\n+      int used = 0;\n+\n+      while (GET_CODE (dest) == STRICT_LOW_PART\n+\t     || GET_CODE (dest) == SUBREG\n+\t     || GET_CODE (dest) == SIGN_EXTRACT\n+\t     || GET_CODE (dest) == ZERO_EXTRACT)\n+\tdest = XEXP (dest, 0);\n+\n+      if (dest == reg)\n+\tset = 1;\n+      else if (GET_CODE (dest) == REG\n+\t       && refers_to_regno_p (REGNO (reg),\n+\t\t\t\t     REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t\t     SET_DEST (in), 0))\n+\t{\n+\t  set = 1;\n+\t  /* Anything that sets just part of the register\n+\t     is considered using as well as setting it.\n+\t     But note that a straight SUBREG of a single-word value\n+\t     clobbers the entire value.   */\n+\t  if (dest != SET_DEST (in)\n+\t      && ! (GET_CODE (SET_DEST (in)) == SUBREG\n+\t\t    || UNITS_PER_WORD >= GET_MODE_SIZE (GET_MODE (dest))))\n+\t    used = 1;\n+\t}\n+\n+      if (code == SET)\n+\t{\n+\t  if (set)\n+\t    used = refers_to_regno_p (REGNO (reg),\n+\t\t\t\t      REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t\t      SET_SRC (in), 0);\n+\t  else\n+\t    used = refers_to_regno_p (REGNO (reg),\n+\t\t\t\t      REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t\t      in, 0);\n+\t}\n+\n+      return set + used * 2;\n+    }\n+\n+  if (refers_to_regno_p (REGNO (reg),\n+\t\t\t REGNO (reg) + HARD_REGNO_NREGS (reg, GET_MODE (reg)),\n+\t\t\t in, 0))\n+    return 2;\n+  return 0;\n+}\n+\n+/* Return non-zero if OP can be written to without screwing up\n+   GCC's model of what's going on.  It is assumed that this operand\n+   appears in the dest position of a SET insn in a conditional\n+   branch's delay slot.  AFTER is the label to start looking from.  */\n+int\n+operand_clobbered_before_used_after (op, after)\n+     rtx op;\n+     rtx after;\n+{\n+  /* Just experimenting.  */\n+  if (GET_CODE (op) == CC0)\n+    return 1;\n+  if (GET_CODE (op) == REG)\n+    {\n+      rtx insn;\n+\n+      if (op == stack_pointer_rtx)\n+\treturn 0;\n+\n+      /* Scan forward from the label, to see if the value of OP\n+\t is clobbered before the first use.  */\n+\n+      for (insn = NEXT_INSN (after); insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (GET_CODE (insn) == NOTE)\n+\t    continue;\n+\t  if (GET_CODE (insn) == INSN\n+\t      || GET_CODE (insn) == JUMP_INSN\n+\t      || GET_CODE (insn) == CALL_INSN)\n+\t    {\n+\t      switch (reg_clobbered_p (op, PATTERN (insn)))\n+\t\t{\n+\t\tdefault:\n+\t\t  return 0;\n+\t\tcase 1:\n+\t\t  return 1;\n+\t\tcase 0:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  /* If we reach another label without clobbering OP,\n+\t     then we cannot safely write it here.  */\n+\t  else if (GET_CODE (insn) == CODE_LABEL)\n+\t    return 0;\n+\t  if (GET_CODE (insn) == JUMP_INSN)\n+\t    {\n+\t      if (condjump_p (insn))\n+\t\treturn 0;\n+\t      /* This is a jump insn which has already\n+\t\t been mangled.  We can't tell what it does.  */\n+\t      if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+\t\treturn 0;\n+\t      if (! JUMP_LABEL (insn))\n+\t\treturn 0;\n+\t      /* Keep following jumps.  */\n+\t      insn = JUMP_LABEL (insn);\n+\t    }\n+\t}\n+      return 1;\n+    }\n+\n+  /* In both of these cases, the first insn executed\n+     for this op will be a orh whatever%h,%?r0,%?r31,\n+     which is tolerable.  */\n+  if (GET_CODE (op) == MEM)\n+    return (CONSTANT_ADDRESS_P (XEXP (op, 0)));\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if this pattern, as a source to a \"SET\",\n+   is known to yield an instruction of unit size.  */\n+int\n+single_insn_src_p (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_INT:\n+      /* This is not always a single insn src, technically,\n+\t but output_delayed_branch knows how to deal with it.  */\n+      return 1;\n+\n+    case SYMBOL_REF:\n+    case CONST:\n+      /* This is not a single insn src, technically,\n+\t but output_delayed_branch knows how to deal with it.  */\n+      return 1;\n+\n+    case REG:\n+      return 1;\n+\n+    case MEM:\n+      return 1;\n+\n+      /* We never need to negate or complement constants.  */\n+    case NEG:\n+      return (mode != DFmode);\n+    case NOT:\n+    case ZERO_EXTEND:\n+      return 1;\n+\n+    case PLUS:\n+    case MINUS:\n+      /* Detect cases that require multiple instructions.  */\n+      if (CONSTANT_P (XEXP (op, 1))\n+\t  && !(GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t       && SMALL_INT (XEXP (op, 1))))\n+\treturn 0;\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case GT:\n+    case LE:\n+    case GE:\n+    case LTU:\n+    case GTU:\n+    case LEU:\n+    case GEU:\n+      /* Not doing floating point, since they probably\n+\t take longer than the branch slot they might fill.  */\n+      return (mode != SFmode && mode != DFmode);\n+\n+    case AND:\n+      if (GET_CODE (XEXP (op, 1)) == NOT)\n+\t{\n+\t  rtx arg = XEXP (XEXP (op, 1), 0);\n+\t  if (CONSTANT_P (arg)\n+\t      && !(GET_CODE (arg) == CONST_INT\n+\t\t   && (SMALL_INT (arg)\n+\t\t       || (INTVAL (arg) & 0xffff) == 0)))\n+\t    return 0;\n+\t}\n+    case IOR:\n+    case XOR:\n+      /* Both small and round numbers take one instruction;\n+\t others take two.  */\n+      if (CONSTANT_P (XEXP (op, 1))\n+\t  && !(GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t       && (SMALL_INT (XEXP (op, 1))\n+\t\t   || (INTVAL (XEXP (op, 1)) & 0xffff) == 0)))\n+\treturn 0;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      return 1;\n+\n+    case SUBREG:\n+      if (SUBREG_BYTE (op) != 0)\n+\treturn 0;\n+      return single_insn_src_p (SUBREG_REG (op), mode);\n+\n+      /* Not doing floating point, since they probably\n+\t take longer than the branch slot they might fill.  */\n+    case FLOAT_EXTEND:\n+    case FLOAT_TRUNCATE:\n+    case FLOAT:\n+    case FIX:\n+    case UNSIGNED_FLOAT:\n+    case UNSIGNED_FIX:\n+      return 0;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\f\n+/* Return non-zero only if OP is a register of mode MODE,\n+   or const0_rtx.  */\n+int\n+reg_or_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (op == const0_rtx || register_operand (op, mode)\n+\t  || op == CONST0_RTX (mode));\n+}\n+\n+/* Return truth value of whether OP can be used as an operands in a three\n+   address add/subtract insn (such as add %o1,7,%l2) of mode MODE.  */\n+\n+int\n+arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op)));\n+}\n+\n+/* Return 1 if OP is a valid first operand for a logical insn of mode MODE.  */\n+\n+int\n+logic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && LOGIC_INT (op)));\n+}\n+\n+/* Return 1 if OP is a valid first operand for a shift insn of mode MODE.  */\n+\n+int\n+shift_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+          || (GET_CODE (op) == CONST_INT));\n+}\n+\n+/* Return 1 if OP is a valid first operand for either a logical insn\n+   or an add insn of mode MODE.  */\n+\n+int\n+compare_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op) && LOGIC_INT (op)));\n+}\n+\n+/* Return truth value of whether OP can be used as the 5-bit immediate\n+   operand of a bte or btne insn.  */\n+\n+int\n+bte_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT\n+\t      && (unsigned) INTVAL (op) < 0x20));\n+}\n+\n+/* Return 1 if OP is an indexed memory reference of mode MODE.  */\n+\n+int\n+indexed_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == MEM && GET_MODE (op) == mode\n+\t  && GET_CODE (XEXP (op, 0)) == PLUS\n+\t  && GET_MODE (XEXP (op, 0)) == SImode\n+\t  && register_operand (XEXP (XEXP (op, 0), 0), SImode)\n+\t  && register_operand (XEXP (XEXP (op, 0), 1), SImode));\n+}\n+\n+/* Return 1 if OP is a suitable source operand for a load insn\n+   with mode MODE.  */\n+\n+int\n+load_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (memory_operand (op, mode) || indexed_operand (op, mode));\n+}\n+\n+/* Return truth value of whether OP is an integer which fits the\n+   range constraining immediate operands in add/subtract insns.  */\n+\n+int\n+small_int (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n+}\n+\n+/* Return truth value of whether OP is an integer which fits the\n+   range constraining immediate operands in logic insns.  */\n+\n+int\n+logic_int (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return (GET_CODE (op) == CONST_INT && LOGIC_INT (op));\n+}\n+\n+/* Test for a valid operand for a call instruction.\n+   Don't allow the arg pointer register or virtual regs\n+   since they may change into reg + const, which the patterns\n+   can't handle yet.  */\n+\n+int\n+call_insn_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  if (GET_CODE (op) == MEM\n+      && (CONSTANT_ADDRESS_P (XEXP (op, 0))\n+\t  || (GET_CODE (XEXP (op, 0)) == REG\n+\t      && XEXP (op, 0) != arg_pointer_rtx\n+\t      && !(REGNO (XEXP (op, 0)) >= FIRST_PSEUDO_REGISTER\n+\t\t   && REGNO (XEXP (op, 0)) <= LAST_VIRTUAL_REGISTER))))\n+    return 1;\n+  return 0;\n+}\n+\f\n+/* Return the best assembler insn template\n+   for moving operands[1] into operands[0] as a fullword.  */\n+\n+static const char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (GET_CODE (operands[1]) != MEM)\n+\tif (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\t  {\n+\t    if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t   && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t   && cc_prev_status.mdep == XEXP (operands[0], 0)))\n+\t      {\n+\t\tCC_STATUS_INIT;\n+\t        output_asm_insn (\"orh %h0,%?r0,%?r31\", operands);\n+\t      }\n+\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t    cc_status.mdep = XEXP (operands[0], 0);\n+\t    return \"st.l %r1,%L0(%?r31)\";\n+\t  }\n+\telse\n+\t  return \"st.l %r1,%0\";\n+      else\n+\tabort ();\n+#if 0\n+\t{\n+\t  rtx xoperands[2];\n+\n+\t  cc_status.flags &= ~CC_F0_IS_0;\n+\t  xoperands[0] = gen_rtx_REG (SFmode, 32);\n+\t  xoperands[1] = operands[1];\n+\t  output_asm_insn (singlemove_string (xoperands), xoperands);\n+\t  xoperands[1] = xoperands[0];\n+\t  xoperands[0] = operands[0];\n+\t  output_asm_insn (singlemove_string (xoperands), xoperands);\n+\t  return \"\";\n+\t}\n+#endif\n+    }\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP (operands[1], 0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      output_asm_insn (\"orh %h1,%?r0,%?r31\", operands);\n+\t    }\n+\t  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t  cc_status.mdep = XEXP (operands[1], 0);\n+\t  return \"ld.l %L1(%?r31),%0\";\n+\t}\n+      return \"ld.l %m1,%0\";\n+    }\n+ if (GET_CODE (operands[1]) == CONST_INT)\n+   {\n+     if (operands[1] == const0_rtx)\n+      return \"mov %?r0,%0\";\n+     if((INTVAL (operands[1]) & 0xffff0000) == 0)\n+      return \"or %L1,%?r0,%0\";\n+     if((INTVAL (operands[1]) & 0xffff8000) == 0xffff8000)\n+      return \"adds %1,%?r0,%0\";\n+     if((INTVAL (operands[1]) & 0x0000ffff) == 0)\n+      return \"orh %H1,%?r0,%0\";\n+\n+     return \"orh %H1,%?r0,%0\\n\\tor %L1,%0,%0\";\n+   }\n+  return \"mov %1,%0\";\n+}\n+\f\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+\n+const char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+  int highest_first = 0;\n+  int no_addreg1_decrement = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1]))\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    abort ();\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+\n+/* ??? Perhaps in some cases move double words\n+   if there is a spare pair of floating regs.  */\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adjust_address (operands[0], SImode, 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adjust_address (operands[1], SImode, 4);\n+  else if (optype1 == CNSTOP)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n+      else if (CONSTANT_P (operands[1]))\n+\tlatehalf[1] = const0_rtx;\n+    }\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If the first move would clobber the source of the second one,\n+     do them in the other order.\n+\n+     RMS says \"This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.\"\n+\n+     but it happens on the sparc when loading parameter registers,\n+     so I am going to define that circumstance, and make it work\n+     as expected.  */\n+\n+  if (optype0 == REGOP && optype1 == REGOP\n+      && REGNO (operands[0]) == REGNO (latehalf[1]))\n+    {\n+      CC_STATUS_PARTIAL_INIT;\n+      /* Make any unoffsettable addresses point at high-numbered word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"adds 0x4,%0,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"adds 0x4,%0,%0\", &addreg1);\n+\n+      /* Do that word.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"adds -0x4,%0,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"adds -0x4,%0,%0\", &addreg1);\n+\n+      /* Do low-numbered word.  */\n+      return singlemove_string (operands);\n+    }\n+  else if (optype0 == REGOP && optype1 != REGOP\n+\t   && reg_overlap_mentioned_p (operands[0], operands[1]))\n+    {\n+      /* If both halves of dest are used in the src memory address,\n+\t add the two regs and put them in the low reg (operands[0]).\n+\t Then it works to load latehalf first.  */\n+      if (reg_mentioned_p (operands[0], XEXP (operands[1], 0))\n+\t  && reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n+\t{\n+\t  rtx xops[2];\n+\t  xops[0] = latehalf[0];\n+\t  xops[1] = operands[0];\n+\t  output_asm_insn (\"adds %1,%0,%1\", xops);\n+\t  operands[1] = gen_rtx_MEM (DImode, operands[0]);\n+\t  latehalf[1] = adjust_address (operands[1], SImode, 4);\n+\t  addreg1 = 0;\n+\t  highest_first = 1;\n+\t}\n+      /* Only one register in the dest is used in the src memory address,\n+\t and this is the first register of the dest, so we want to do\n+\t the late half first here also.  */\n+      else if (! reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n+\thighest_first = 1;\n+      /* Only one register in the dest is used in the src memory address,\n+\t and this is the second register of the dest, so we want to do\n+\t the late half last.  If addreg1 is set, and addreg1 is the same\n+\t register as latehalf, then we must suppress the trailing decrement,\n+\t because it would clobber the value just loaded.  */\n+      else if (addreg1 && reg_mentioned_p (addreg1, latehalf[0]))\n+\tno_addreg1_decrement = 1;\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.\n+     Overlap case (highest_first set): do high-numbered word first.  */\n+\n+  if (! highest_first)\n+    output_asm_insn (singlemove_string (operands), operands);\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    output_asm_insn (\"adds 0x4,%0,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"adds 0x4,%0,%0\", &addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"adds -0x4,%0,%0\", &addreg0);\n+  if (addreg1 && !no_addreg1_decrement)\n+    output_asm_insn (\"adds -0x4,%0,%0\", &addreg1);\n+\n+  if (highest_first)\n+    output_asm_insn (singlemove_string (operands), operands);\n+\n+  return \"\";\n+}\n+\f\n+const char *\n+output_fp_move_double (operands)\n+     rtx *operands;\n+{\n+  /* If the source operand is any sort of zero, use f0 instead.  */\n+\n+  if (operands[1] == CONST0_RTX (GET_MODE (operands[1])))\n+    operands[1] = gen_rtx_REG (DFmode, F0_REGNUM);\n+\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \"fmov.dd %1,%0\";\n+      if (GET_CODE (operands[1]) == REG)\n+\t{\n+\t  output_asm_insn (\"ixfr %1,%0\", operands);\n+\t  operands[0] = gen_rtx_REG (VOIDmode, REGNO (operands[0]) + 1);\n+\t  operands[1] = gen_rtx_REG (VOIDmode, REGNO (operands[1]) + 1);\n+\t  return \"ixfr %1,%0\";\n+\t}\n+      if (operands[1] == CONST0_RTX (DFmode))\n+\treturn \"fmov.dd f0,%0\";\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP (operands[1], 0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      output_asm_insn (\"orh %h1,%?r0,%?r31\", operands);\n+\t    }\n+\t  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t  cc_status.mdep = XEXP (operands[1], 0);\n+\t  return \"fld.d %L1(%?r31),%0\";\n+\t}\n+      return \"fld.d %1,%0\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (GET_CODE (operands[0]) == REG)\n+\t{\n+\t  output_asm_insn (\"fxfr %1,%0\", operands);\n+\t  operands[0] = gen_rtx_REG (VOIDmode, REGNO (operands[0]) + 1);\n+\t  operands[1] = gen_rtx_REG (VOIDmode, REGNO (operands[1]) + 1);\n+\t  return \"fxfr %1,%0\";\n+\t}\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP (operands[0], 0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      output_asm_insn (\"orh %h0,%?r0,%?r31\", operands);\n+\t    }\n+\t  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t  cc_status.mdep = XEXP (operands[0], 0);\n+\t  return \"fst.d %1,%L0(%?r31)\";\n+\t}\n+      return \"fst.d %1,%0\";\n+    }\n+  else\n+    abort ();\n+  /* NOTREACHED */\n+  return NULL;\n+}\n+\f\n+/* Return a REG that occurs in ADDR with coefficient 1.\n+   ADDR can be effectively incremented by incrementing REG.  */\n+\n+static rtx\n+find_addr_reg (addr)\n+     rtx addr;\n+{\n+  while (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\taddr = XEXP (addr, 0);\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 0)))\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 1)))\n+\taddr = XEXP (addr, 0);\n+      else\n+\tabort ();\n+    }\n+  if (GET_CODE (addr) == REG)\n+    return addr;\n+  abort ();\n+  /* NOTREACHED */\n+  return NULL;\n+}\n+\n+/* Return a template for a load instruction with mode MODE and\n+   arguments from the string ARGS.\n+\n+   This string is in static storage.   */\n+\n+static const char *\n+load_opcode (mode, args, reg)\n+     enum machine_mode mode;\n+     const char *args;\n+     rtx reg;\n+{\n+  static char buf[30];\n+  const char *opcode;\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+      opcode = \"ld.b\";\n+      break;\n+\n+    case HImode:\n+      opcode = \"ld.s\";\n+      break;\n+\n+    case SImode:\n+    case SFmode:\n+      if (FP_REG_P (reg))\n+\topcode = \"fld.l\";\n+      else\n+\topcode = \"ld.l\";\n+      break;\n+\n+    case DImode:\n+      if (!FP_REG_P (reg))\n+\tabort ();\n+    case DFmode:\n+      opcode = \"fld.d\";\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  sprintf (buf, \"%s %s\", opcode, args);\n+  return buf;\n+}\n+\n+/* Return a template for a store instruction with mode MODE and\n+   arguments from the string ARGS.\n+\n+   This string is in static storage.   */\n+\n+static const char *\n+store_opcode (mode, args, reg)\n+     enum machine_mode mode;\n+     const char *args;\n+     rtx reg;\n+{\n+  static char buf[30];\n+  const char *opcode;\n+\n+  switch (mode)\n+    {\n+    case QImode:\n+      opcode = \"st.b\";\n+      break;\n+\n+    case HImode:\n+      opcode = \"st.s\";\n+      break;\n+\n+    case SImode:\n+    case SFmode:\n+      if (FP_REG_P (reg))\n+\topcode = \"fst.l\";\n+      else\n+\topcode = \"st.l\";\n+      break;\n+\n+    case DImode:\n+      if (!FP_REG_P (reg))\n+\tabort ();\n+    case DFmode:\n+      opcode = \"fst.d\";\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  sprintf (buf, \"%s %s\", opcode, args);\n+  return buf;\n+}\n+\f\n+/* Output a store-in-memory whose operands are OPERANDS[0,1].\n+   OPERANDS[0] is a MEM, and OPERANDS[1] is a reg or zero.\n+\n+   This function returns a template for an insn.\n+   This is in static storage.\n+\n+   It may also output some insns directly.\n+   It may alter the values of operands[0] and operands[1].  */\n+\n+const char *\n+output_store (operands)\n+     rtx *operands;\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  rtx address = XEXP (operands[0], 0);\n+\n+  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+  cc_status.mdep = address;\n+\n+  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t && address == cc_prev_status.mdep))\n+    {\n+      CC_STATUS_INIT;\n+      output_asm_insn (\"orh %h0,%?r0,%?r31\", operands);\n+      cc_prev_status.mdep = address;\n+    }\n+\n+  /* Store zero in two parts when appropriate.  */\n+  if (mode == DFmode && operands[1] == CONST0_RTX (DFmode))\n+    return store_opcode (DFmode, \"%r1,%L0(%?r31)\", operands[1]);\n+\n+  /* Code below isn't smart enough to move a doubleword in two parts,\n+     so use output_move_double to do that in the cases that require it.  */\n+  if ((mode == DImode || mode == DFmode)\n+      && ! FP_REG_P (operands[1]))\n+    return output_move_double (operands);\n+\n+  return store_opcode (mode, \"%r1,%L0(%?r31)\", operands[1]);\n+}\n+\n+/* Output a load-from-memory whose operands are OPERANDS[0,1].\n+   OPERANDS[0] is a reg, and OPERANDS[1] is a mem.\n+\n+   This function returns a template for an insn.\n+   This is in static storage.\n+\n+   It may also output some insns directly.\n+   It may alter the values of operands[0] and operands[1].  */\n+\n+const char *\n+output_load (operands)\n+     rtx *operands;\n+{\n+  enum machine_mode mode = GET_MODE (operands[0]);\n+  rtx address = XEXP (operands[1], 0);\n+\n+  /* We don't bother trying to see if we know %hi(address).\n+     This is because we are doing a load, and if we know the\n+     %hi value, we probably also know that value in memory.  */\n+  cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+  cc_status.mdep = address;\n+\n+  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t && address == cc_prev_status.mdep\n+\t && cc_prev_status.mdep == cc_status.mdep))\n+    {\n+      CC_STATUS_INIT;\n+      output_asm_insn (\"orh %h1,%?r0,%?r31\", operands);\n+      cc_prev_status.mdep = address;\n+    }\n+\n+  /* Code below isn't smart enough to move a doubleword in two parts,\n+     so use output_move_double to do that in the cases that require it.  */\n+  if ((mode == DImode || mode == DFmode)\n+      && ! FP_REG_P (operands[0]))\n+    return output_move_double (operands);\n+\n+  return load_opcode (mode, \"%L1(%?r31),%0\", operands[0]);\n+}\n+\f\n+#if 0\n+/* Load the address specified by OPERANDS[3] into the register\n+   specified by OPERANDS[0].\n+\n+   OPERANDS[3] may be the result of a sum, hence it could either be:\n+\n+   (1) CONST\n+   (2) REG\n+   (2) REG + CONST_INT\n+   (3) REG + REG + CONST_INT\n+   (4) REG + REG  (special case of 3).\n+\n+   Note that (3) is not a legitimate address.\n+   All cases are handled here.  */\n+\n+void\n+output_load_address (operands)\n+     rtx *operands;\n+{\n+  rtx base, offset;\n+\n+  if (CONSTANT_P (operands[3]))\n+    {\n+      output_asm_insn (\"mov %3,%0\", operands);\n+      return;\n+    }\n+\n+  if (REG_P (operands[3]))\n+    {\n+      if (REGNO (operands[0]) != REGNO (operands[3]))\n+\toutput_asm_insn (\"shl %?r0,%3,%0\", operands);\n+      return;\n+    }\n+\n+  if (GET_CODE (operands[3]) != PLUS)\n+    abort ();\n+\n+  base = XEXP (operands[3], 0);\n+  offset = XEXP (operands[3], 1);\n+\n+  if (GET_CODE (base) == CONST_INT)\n+    {\n+      rtx tmp = base;\n+      base = offset;\n+      offset = tmp;\n+    }\n+\n+  if (GET_CODE (offset) != CONST_INT)\n+    {\n+      /* Operand is (PLUS (REG) (REG)).  */\n+      base = operands[3];\n+      offset = const0_rtx;\n+    }\n+\n+  if (REG_P (base))\n+    {\n+      operands[6] = base;\n+      operands[7] = offset;\n+      CC_STATUS_PARTIAL_INIT;\n+      if (SMALL_INT (offset))\n+\toutput_asm_insn (\"adds %7,%6,%0\", operands);\n+      else\n+\toutput_asm_insn (\"mov %7,%0\\n\\tadds %0,%6,%0\", operands);\n+    }\n+  else if (GET_CODE (base) == PLUS)\n+    {\n+      operands[6] = XEXP (base, 0);\n+      operands[7] = XEXP (base, 1);\n+      operands[8] = offset;\n+\n+      CC_STATUS_PARTIAL_INIT;\n+      if (SMALL_INT (offset))\n+\toutput_asm_insn (\"adds %6,%7,%0\\n\\tadds %8,%0,%0\", operands);\n+      else\n+\toutput_asm_insn (\"mov %8,%0\\n\\tadds %0,%6,%0\\n\\tadds %0,%7,%0\", operands);\n+    }\n+  else\n+    abort ();\n+}\n+#endif\n+\n+/* Output code to place a size count SIZE in register REG.\n+   Because block moves are pipelined, we don't include the\n+   first element in the transfer of SIZE to REG.\n+   For this, we subtract ALIGN.  (Actually, I think it is not\n+   right to subtract on this machine, so right now we don't.)  */\n+\n+static void\n+output_size_for_block_move (size, reg, align)\n+     rtx size, reg, align;\n+{\n+  rtx xoperands[3];\n+\n+  xoperands[0] = reg;\n+  xoperands[1] = size;\n+  xoperands[2] = align;\n+\n+#if 1\n+  cc_status.flags &= ~ CC_KNOW_HI_R31;\n+  output_asm_insn (singlemove_string (xoperands), xoperands);\n+#else\n+  if (GET_CODE (size) == REG)\n+    output_asm_insn (\"sub %2,%1,%0\", xoperands);\n+  else\n+    {\n+      xoperands[1] = GEN_INT (INTVAL (size) - INTVAL (align));\n+      cc_status.flags &= ~ CC_KNOW_HI_R31;\n+      output_asm_insn (\"mov %1,%0\", xoperands);\n+    }\n+#endif\n+}\n+\n+/* Emit code to perform a block move.\n+\n+   OPERANDS[0] is the destination.\n+   OPERANDS[1] is the source.\n+   OPERANDS[2] is the size.\n+   OPERANDS[3] is the known safe alignment.\n+   OPERANDS[4..6] are pseudos we can safely clobber as temps.  */\n+\n+const char *\n+output_block_move (operands)\n+     rtx *operands;\n+{\n+  /* A vector for our computed operands.  Note that load_output_address\n+     makes use of (and can clobber) up to the 8th element of this vector.  */\n+  rtx xoperands[10];\n+#if 0\n+  rtx zoperands[10];\n+#endif\n+  static int movstrsi_label = 0;\n+  int i;\n+  rtx temp1 = operands[4];\n+  rtx alignrtx = operands[3];\n+  int align = INTVAL (alignrtx);\n+  int chunk_size;\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[1];\n+  xoperands[2] = temp1;\n+\n+  /* We can't move more than four bytes at a time\n+     because we have only one register to move them through.  */\n+  if (align > 4)\n+    {\n+      align = 4;\n+      alignrtx = GEN_INT (4);\n+    }\n+\n+  /* Recognize special cases of block moves.  These occur\n+     when GNU C++ is forced to treat something as BLKmode\n+     to keep it in memory, when its mode could be represented\n+     with something smaller.\n+\n+     We cannot do this for global variables, since we don't know\n+     what pages they don't cross.  Sigh.  */\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && ! CONSTANT_ADDRESS_P (operands[0])\n+      && ! CONSTANT_ADDRESS_P (operands[1]))\n+    {\n+      int size = INTVAL (operands[2]);\n+      rtx op0 = xoperands[0];\n+      rtx op1 = xoperands[1];\n+\n+      if ((align & 3) == 0 && (size & 3) == 0 && (size >> 2) <= 16)\n+\t{\n+\t  if (memory_address_p (SImode, plus_constant (op0, size))\n+\t      && memory_address_p (SImode, plus_constant (op1, size)))\n+\t    {\n+\t      cc_status.flags &= ~CC_KNOW_HI_R31;\n+\t      for (i = (size>>2)-1; i >= 0; i--)\n+\t\t{\n+\t\t  xoperands[0] = plus_constant (op0, i * 4);\n+\t\t  xoperands[1] = plus_constant (op1, i * 4);\n+\t\t  output_asm_insn (\"ld.l %a1,%?r31\\n\\tst.l %?r31,%a0\",\n+\t\t\t\t   xoperands);\n+\t\t}\n+\t      return \"\";\n+\t    }\n+\t}\n+      else if ((align & 1) == 0 && (size & 1) == 0 && (size >> 1) <= 16)\n+\t{\n+\t  if (memory_address_p (HImode, plus_constant (op0, size))\n+\t      && memory_address_p (HImode, plus_constant (op1, size)))\n+\t    {\n+\t      cc_status.flags &= ~CC_KNOW_HI_R31;\n+\t      for (i = (size>>1)-1; i >= 0; i--)\n+\t\t{\n+\t\t  xoperands[0] = plus_constant (op0, i * 2);\n+\t\t  xoperands[1] = plus_constant (op1, i * 2);\n+\t\t  output_asm_insn (\"ld.s %a1,%?r31\\n\\tst.s %?r31,%a0\",\n+\t\t\t\t   xoperands);\n+\t\t}\n+\t      return \"\";\n+\t    }\n+\t}\n+      else if (size <= 16)\n+\t{\n+\t  if (memory_address_p (QImode, plus_constant (op0, size))\n+\t      && memory_address_p (QImode, plus_constant (op1, size)))\n+\t    {\n+\t      cc_status.flags &= ~CC_KNOW_HI_R31;\n+\t      for (i = size-1; i >= 0; i--)\n+\t\t{\n+\t\t  xoperands[0] = plus_constant (op0, i);\n+\t\t  xoperands[1] = plus_constant (op1, i);\n+\t\t  output_asm_insn (\"ld.b %a1,%?r31\\n\\tst.b %?r31,%a0\",\n+\t\t\t\t   xoperands);\n+\t\t}\n+\t      return \"\";\n+\t    }\n+\t}\n+    }\n+\n+  /* Since we clobber untold things, nix the condition codes.  */\n+  CC_STATUS_INIT;\n+\n+  /* This is the size of the transfer.\n+     Either use the register which already contains the size,\n+     or use a free register (used by no operands).  */\n+  output_size_for_block_move (operands[2], operands[4], alignrtx);\n+\n+#if 0\n+  /* Also emit code to decrement the size value by ALIGN.  */\n+  zoperands[0] = operands[0];\n+  zoperands[3] = plus_constant (operands[0], align);\n+  output_load_address (zoperands);\n+#endif\n+\n+  /* Generate number for unique label.  */\n+\n+  xoperands[3] = GEN_INT (movstrsi_label++);\n+\n+  /* Calculate the size of the chunks we will be trying to move first.  */\n+\n+#if 0\n+  if ((align & 3) == 0)\n+    chunk_size = 4;\n+  else if ((align & 1) == 0)\n+    chunk_size = 2;\n+  else\n+#endif\n+    chunk_size = 1;\n+\n+  /* Copy the increment (negative) to a register for bla insn.  */\n+\n+  xoperands[4] = GEN_INT (- chunk_size);\n+  xoperands[5] = operands[5];\n+  output_asm_insn (\"adds %4,%?r0,%5\", xoperands);\n+\n+  /* Predecrement the loop counter.  This happens again also in the `bla'\n+     instruction which precedes the loop, but we need to have it done\n+     two times before we enter the loop because of the bizarre semantics\n+     of the bla instruction.  */\n+\n+  output_asm_insn (\"adds %5,%2,%2\", xoperands);\n+\n+  /* Check for the case where the original count was less than or equal to\n+     zero.  Avoid going through the loop at all if the original count was\n+     indeed less than or equal to zero.  Note that we treat the count as\n+     if it were a signed 32-bit quantity here, rather than an unsigned one,\n+     even though we really shouldn't.  We have to do this because of the\n+     semantics of the `ble' instruction, which assume that the count is\n+     a signed 32-bit value.  Anyway, in practice it won't matter because\n+     nobody is going to try to do a memcpy() of more than half of the\n+     entire address space (i.e. 2 gigabytes) anyway.  */\n+\n+  output_asm_insn (\"bc .Le%3\", xoperands);\n+\n+  /* Make available a register which is a temporary.  */\n+\n+  xoperands[6] = operands[6];\n+\n+  /* Now the actual loop.\n+     In xoperands, elements 1 and 0 are the input and output vectors.\n+     Element 2 is the loop index.  Element 5 is the increment.  */\n+\n+  output_asm_insn (\"subs %1,%5,%1\", xoperands);\n+  output_asm_insn (\"bla %5,%2,.Lm%3\", xoperands);\n+  output_asm_insn (\"adds %0,%2,%6\", xoperands);\n+  output_asm_insn (\"\\n.Lm%3:\", xoperands);\t    /* Label for bla above.  */\n+  output_asm_insn (\"\\n.Ls%3:\",  xoperands);\t    /* Loop start label. */\n+  output_asm_insn (\"adds %5,%6,%6\", xoperands);\n+\n+  /* NOTE:  The code here which is supposed to handle the cases where the\n+     sources and destinations are known to start on a 4 or 2 byte boundary\n+     are currently broken.  They fail to do anything about the overflow\n+     bytes which might still need to be copied even after we have copied\n+     some number of words or halfwords.  Thus, for now we use the lowest\n+     common denominator, i.e. the code which just copies some number of\n+     totally unaligned individual bytes.  (See the calculation of\n+     chunk_size above.  */\n+\n+  if (chunk_size == 4)\n+    {\n+      output_asm_insn (\"ld.l %2(%1),%?r31\", xoperands);\n+      output_asm_insn (\"bla %5,%2,.Ls%3\", xoperands);\n+      output_asm_insn (\"st.l %?r31,8(%6)\", xoperands);\n+    }\n+  else if (chunk_size == 2)\n+    {\n+      output_asm_insn (\"ld.s %2(%1),%?r31\", xoperands);\n+      output_asm_insn (\"bla %5,%2,.Ls%3\", xoperands);\n+      output_asm_insn (\"st.s %?r31,4(%6)\", xoperands);\n+    }\n+  else /* chunk_size == 1 */\n+    {\n+      output_asm_insn (\"ld.b %2(%1),%?r31\", xoperands);\n+      output_asm_insn (\"bla %5,%2,.Ls%3\", xoperands);\n+      output_asm_insn (\"st.b %?r31,2(%6)\", xoperands);\n+    }\n+  output_asm_insn (\"\\n.Le%3:\", xoperands);\t    /* Here if count <= 0.  */\n+\n+  return \"\";\n+}\n+\f\n+#if 0\n+/* Output a delayed branch insn with the delay insn in its\n+   branch slot.  The delayed branch insn template is in TEMPLATE,\n+   with operands OPERANDS.  The insn in its delay slot is INSN.\n+\n+   As a special case, since we know that all memory transfers are via\n+   ld/st insns, if we see a (MEM (SYMBOL_REF ...)) we divide the memory\n+   reference around the branch as\n+\n+\torh ha%x,%?r0,%?r31\n+\tb ...\n+\tld/st l%x(%?r31),...\n+\n+   As another special case, we handle loading (SYMBOL_REF ...) and\n+   other large constants around branches as well:\n+\n+\torh h%x,%?r0,%0\n+\tb ...\n+\tor l%x,%0,%1\n+\n+   */\n+/* ??? Disabled because this re-recognition is incomplete and causes\n+   constrain_operands to segfault.  Anyone who cares should fix up\n+   the code to use the DBR pass.  */\n+\n+const char *\n+output_delayed_branch (template, operands, insn)\n+     const char *template;\n+     rtx *operands;\n+     rtx insn;\n+{\n+  rtx src = XVECEXP (PATTERN (insn), 0, 1);\n+  rtx dest = XVECEXP (PATTERN (insn), 0, 0);\n+\n+  /* See if we are doing some branch together with setting some register\n+     to some 32-bit value which does (or may) have some of the high-order\n+     16 bits set.  If so, we need to set the register in two stages.  One\n+     stage must be done before the branch, and the other one can be done\n+     in the delay slot.  */\n+\n+  if ( (GET_CODE (src) == CONST_INT\n+\t&& ((unsigned) INTVAL (src) & (unsigned) 0xffff0000) != (unsigned) 0)\n+      || (GET_CODE (src) == SYMBOL_REF)\n+      || (GET_CODE (src) == LABEL_REF)\n+      || (GET_CODE (src) == CONST))\n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = dest;\n+      xoperands[1] = src;\n+\n+      CC_STATUS_PARTIAL_INIT;\n+      /* Output the `orh' insn.  */\n+      output_asm_insn (\"orh %H1,%?r0,%0\", xoperands);\n+\n+      /* Output the branch instruction next.  */\n+      output_asm_insn (template, operands);\n+\n+      /* Now output the `or' insn.  */\n+      output_asm_insn (\"or %L1,%0,%0\", xoperands);\n+    }\n+  else if ((GET_CODE (src) == MEM\n+\t    && CONSTANT_ADDRESS_P (XEXP (src, 0)))\n+\t   || (GET_CODE (dest) == MEM\n+\t       && CONSTANT_ADDRESS_P (XEXP (dest, 0))))\n+    {\n+      rtx xoperands[2];\n+      const char *split_template;\n+      xoperands[0] = dest;\n+      xoperands[1] = src;\n+\n+      /* Output the `orh' insn.  */\n+      if (GET_CODE (src) == MEM)\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP (operands[1], 0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      output_asm_insn (\"orh %h1,%?r0,%?r31\", xoperands);\n+\t    }\n+\t  split_template = load_opcode (GET_MODE (dest),\n+\t\t\t\t\t\"%L1(%?r31),%0\", dest);\n+\t}\n+      else\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP (operands[0], 0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      output_asm_insn (\"orh %h0,%?r0,%?r31\", xoperands);\n+\t    }\n+\t  split_template = store_opcode (GET_MODE (dest),\n+\t\t\t\t\t \"%r1,%L0(%?r31)\", src);\n+\t}\n+\n+      /* Output the branch instruction next.  */\n+      output_asm_insn (template, operands);\n+\n+      /* Now output the load or store.\n+\t No need to do a CC_STATUS_INIT, because we are branching anyway.  */\n+      output_asm_insn (split_template, xoperands);\n+    }\n+  else\n+    {\n+      int insn_code_number;\n+      rtx pat = gen_rtx_SET (VOIDmode, dest, src);\n+      rtx delay_insn = gen_rtx_INSN (VOIDmode, 0, 0, 0, pat, -1, 0, 0);\n+      int i;\n+\n+      /* Output the branch instruction first.  */\n+      output_asm_insn (template, operands);\n+\n+      /* Now recognize the insn which we put in its delay slot.\n+\t We must do this after outputting the branch insn,\n+\t since operands may just be a pointer to `recog_data.operand'.  */\n+      INSN_CODE (delay_insn) = insn_code_number\n+\t= recog (pat, delay_insn, NULL);\n+      if (insn_code_number == -1)\n+\tabort ();\n+\n+      for (i = 0; i < insn_data[insn_code_number].n_operands; i++)\n+\t{\n+\t  if (GET_CODE (recog_data.operand[i]) == SUBREG)\n+\t    alter_subreg (&recog_data.operand[i]);\n+\t}\n+\n+      insn_extract (delay_insn);\n+      if (! constrain_operands (1))\n+\tfatal_insn_not_found (delay_insn);\n+\n+      template = get_insn_template (insn_code_number, delay_insn);\n+      output_asm_insn (template, recog_data.operand);\n+    }\n+  CC_STATUS_INIT;\n+  return \"\";\n+}\n+\n+/* Output a newly constructed insn DELAY_INSN.  */\n+const char *\n+output_delay_insn (delay_insn)\n+     rtx delay_insn;\n+{\n+  const char *template;\n+  int insn_code_number;\n+  int i;\n+\n+  /* Now recognize the insn which we put in its delay slot.\n+     We must do this after outputting the branch insn,\n+     since operands may just be a pointer to `recog_data.operand'.  */\n+  insn_code_number = recog_memoized (delay_insn);\n+  if (insn_code_number == -1)\n+    abort ();\n+\n+  /* Extract the operands of this delay insn.  */\n+  INSN_CODE (delay_insn) = insn_code_number;\n+  insn_extract (delay_insn);\n+\n+  /* It is possible that this insn has not been properly scanned by final\n+     yet.  If this insn's operands don't appear in the peephole's\n+     actual operands, then they won't be fixed up by final, so we\n+     make sure they get fixed up here.  -- This is a kludge.  */\n+  for (i = 0; i < insn_data[insn_code_number].n_operands; i++)\n+    {\n+      if (GET_CODE (recog_data.operand[i]) == SUBREG)\n+\talter_subreg (&recog_data.operand[i]);\n+    }\n+\n+  if (! constrain_operands (1))\n+    abort ();\n+\n+  cc_prev_status = cc_status;\n+\n+  /* Update `cc_status' for this instruction.\n+     The instruction's output routine may change it further.\n+     If the output routine for a jump insn needs to depend\n+     on the cc status, it should look at cc_prev_status.  */\n+\n+  NOTICE_UPDATE_CC (PATTERN (delay_insn), delay_insn);\n+\n+  /* Now get the template for what this insn would\n+     have been, without the branch.  */\n+\n+  template = get_insn_template (insn_code_number, delay_insn);\n+  output_asm_insn (template, recog_data.operand);\n+  return \"\";\n+}\n+#endif\n+\f\n+/* Special routine to convert an SFmode value represented as a\n+   CONST_DOUBLE into its equivalent unsigned long bit pattern.\n+   We convert the value from a double precision floating-point\n+   value to single precision first, and thence to a bit-wise\n+   equivalent unsigned long value.  This routine is used when\n+   generating an immediate move of an SFmode value directly\n+   into a general register because the svr4 assembler doesn't\n+   grok floating literals in instruction operand contexts.  */\n+\n+unsigned long\n+sfmode_constant_to_ulong (x)\n+     rtx x;\n+{\n+  REAL_VALUE_TYPE d;\n+  unsigned long l;\n+\n+  if (GET_CODE (x) != CONST_DOUBLE || GET_MODE (x) != SFmode)\n+    abort ();\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+  REAL_VALUE_TO_TARGET_SINGLE (d, l);\n+  return l;\n+}\n+\f\n+/* This function generates the assembly code for function entry.\n+\n+   ASM_FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.\n+\n+   NOTE: `frame_lower_bytes' is the count of bytes which will lie\n+   between the new `fp' value and the new `sp' value after the\n+   prologue is done.  `frame_upper_bytes' is the count of bytes\n+   that will lie between the new `fp' and the *old* `sp' value\n+   after the new `fp' is setup (in the prologue).  The upper\n+   part of each frame always includes at least 2 words (8 bytes)\n+   to hold the saved frame pointer and the saved return address.\n+\n+   The svr4 ABI for the i860 now requires that the values of the\n+   stack pointer and frame pointer registers be kept aligned to\n+   16-byte boundaries at all times.  We obey that restriction here.\n+\n+   The svr4 ABI for the i860 is entirely vague when it comes to specifying\n+   exactly where the \"preserved\" registers should be saved.  The native\n+   svr4 C compiler I now have doesn't help to clarify the requirements\n+   very much because it is plainly out-of-date and non-ABI-compliant\n+   (in at least one important way, i.e. how it generates function\n+   epilogues).\n+\n+   The native svr4 C compiler saves the \"preserved\" registers (i.e.\n+   r4-r15 and f2-f7) in the lower part of a frame (i.e. at negative\n+   offsets from the frame pointer).\n+\n+   Previous versions of GCC also saved the \"preserved\" registers in the\n+   \"negative\" part of the frame, but they saved them using positive\n+   offsets from the (adjusted) stack pointer (after it had been adjusted\n+   to allocate space for the new frame).  That's just plain wrong\n+   because if the current function calls alloca(), the stack pointer\n+   will get moved, and it will be impossible to restore the registers\n+   properly again after that.\n+\n+   Both compilers handled parameter registers (i.e. r16-r27 and f8-f15)\n+   by copying their values either into various \"preserved\" registers or\n+   into stack slots in the lower part of the current frame (as seemed\n+   appropriate, depending upon subsequent usage of these values).\n+\n+   Here we want to save the preserved registers at some offset from the\n+   frame pointer register so as to avoid any possible problems arising\n+   from calls to alloca().  We can either save them at small positive\n+   offsets from the frame pointer, or at small negative offsets from\n+   the frame pointer.  If we save them at small negative offsets from\n+   the frame pointer (i.e. in the lower part of the frame) then we\n+   must tell the rest of GCC (via STARTING_FRAME_OFFSET) exactly how\n+   many bytes of space we plan to use in the lower part of the frame\n+   for this purpose.  Since other parts of the compiler reference the\n+   value of STARTING_FRAME_OFFSET long before final() calls this function,\n+   we would have to go ahead and assume the worst-case storage requirements\n+   for saving all of the \"preserved\" registers (and use that number, i.e.\n+   `80', to define STARTING_FRAME_OFFSET) if we wanted to save them in\n+   the lower part of the frame.  That could potentially be very wasteful,\n+   and that wastefulness could really hamper people compiling for embedded\n+   i860 targets with very tight limits on stack space.  Thus, we choose\n+   here to save the preserved registers in the upper part of the\n+   frame, so that we can decide at the very last minute how much (or how\n+   little) space we must allocate for this purpose.\n+\n+   To satisfy the needs of the svr4 ABI \"tdesc\" scheme, preserved\n+   registers must always be saved so that the saved values of registers\n+   with higher numbers are at higher addresses.  We obey that restriction\n+   here.\n+\n+   There are two somewhat different ways that you can generate prologues\n+   here... i.e. pedantically ABI-compliant, and the \"other\" way.  The\n+   \"other\" way is more consistent with what is currently generated by the\n+   \"native\" svr4 C compiler for the i860.  That's important if you want\n+   to use the current (as of 8/91) incarnation of svr4 SDB for the i860.\n+   The SVR4 SDB for the i860 insists on having function prologues be\n+   non-ABI-compliant!\n+\n+   To get fully ABI-compliant prologues, define I860_STRICT_ABI_PROLOGUES\n+   in the i860svr4.h file.  (By default this is *not* defined).\n+\n+   The differences between the ABI-compliant and non-ABI-compliant prologues\n+   are that (a) the ABI version seems to require the use of *signed*\n+   (rather than unsigned) adds and subtracts, and (b) the ordering of\n+   the various steps (e.g. saving preserved registers, saving the\n+   return address, setting up the new frame pointer value) is different.\n+\n+   For strict ABI compliance, it seems to be the case that the very last\n+   thing that is supposed to happen in the prologue is getting the frame\n+   pointer set to its new value (but only after everything else has\n+   already been properly setup).  We do that here, but only if the symbol\n+   I860_STRICT_ABI_PROLOGUES is defined.\n+*/\n+\n+#ifndef STACK_ALIGNMENT\n+#define STACK_ALIGNMENT\t16\n+#endif\n+\n+const char *current_function_original_name;\n+\n+static int must_preserve_r1;\n+static unsigned must_preserve_bytes;\n+\n+static void\n+i860_output_function_prologue (asm_file, local_bytes)\n+     register FILE *asm_file;\n+     register HOST_WIDE_INT local_bytes;\n+{\n+  register HOST_WIDE_INT frame_lower_bytes;\n+  register HOST_WIDE_INT frame_upper_bytes;\n+  register HOST_WIDE_INT total_fsize;\n+  register unsigned preserved_reg_bytes = 0;\n+  register unsigned i;\n+  register unsigned preserved_so_far = 0;\n+\n+  must_preserve_r1 = (optimize < 2 || ! leaf_function_p ());\n+  must_preserve_bytes = 4 + (must_preserve_r1 ? 4 : 0);\n+\n+  /* Count registers that need preserving.  Ignore r0.  It never needs\n+     preserving.  */\n+\n+  for (i = 1; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (regs_ever_live[i] && ! call_used_regs[i])\n+        preserved_reg_bytes += 4;\n+    }\n+\n+  /* Round-up the frame_lower_bytes so that it's a multiple of 16. */\n+\n+  frame_lower_bytes = (local_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n+\n+  /* The upper part of each frame will contain the saved fp,\n+     the saved r1, and stack slots for all of the other \"preserved\"\n+     registers that we find we will need to save & restore. */\n+\n+  frame_upper_bytes = must_preserve_bytes + preserved_reg_bytes;\n+\n+  /* Round-up the frame_upper_bytes so that it's a multiple of 16. */\n+\n+  frame_upper_bytes\n+    = (frame_upper_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n+\n+  total_fsize = frame_upper_bytes + frame_lower_bytes;\n+\n+#ifndef I860_STRICT_ABI_PROLOGUES\n+\n+  /* There are two kinds of function prologues.\n+     You use the \"small\" version if the total frame size is\n+     small enough so that it can fit into an immediate 16-bit\n+     value in one instruction.  Otherwise, you use the \"large\"\n+     version of the function prologue.  */\n+\n+  if (total_fsize > 0x7fff)\n+    {\n+      /* Adjust the stack pointer.  The ABI sez to do this using `adds',\n+\t but the native C compiler on svr4 uses `addu'.  */\n+\n+      fprintf (asm_file, \"\\taddu -%d,%ssp,%ssp\\n\",\n+\tframe_upper_bytes, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Save the old frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tst.l %sfp,0(%ssp)\\n\",\n+\ti860_reg_prefix, i860_reg_prefix);\n+\n+      /* Setup the new frame pointer.  The ABI sez to do this after\n+\t preserving registers (using adds), but that's not what the\n+\t native C compiler on svr4 does.  */\n+\n+      fprintf (asm_file, \"\\taddu 0,%ssp,%sfp\\n\",\n+\ti860_reg_prefix, i860_reg_prefix);\n+\n+      /* Get the value of frame_lower_bytes into r31.  */\n+\n+      fprintf (asm_file, \"\\torh %d,%sr0,%sr31\\n\",\n+\tframe_lower_bytes >> 16, i860_reg_prefix, i860_reg_prefix);\n+      fprintf (asm_file, \"\\tor %d,%sr31,%sr31\\n\",\n+\tframe_lower_bytes & 0xffff, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Now re-adjust the stack pointer using the value in r31.\n+\t The ABI sez to do this with `subs' but SDB may prefer `subu'.  */\n+\n+      fprintf (asm_file, \"\\tsubu %ssp,%sr31,%ssp\\n\",\n+\ti860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Preserve registers.  The ABI sez to do this before setting\n+\t up the new frame pointer, but that's not what the native\n+\t C compiler on svr4 does.  */\n+\n+      for (i = 1; i < 32; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tst.l %s%s,%d(%sfp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes  + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      for (i = 32; i < 64; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tfst.l %s%s,%d(%sfp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      /* Save the return address.  */\n+\n+      if (must_preserve_r1)\n+        fprintf (asm_file, \"\\tst.l %sr1,4(%sfp)\\n\",\n+\t  i860_reg_prefix, i860_reg_prefix);\n+    }\n+  else\n+    {\n+      /* Adjust the stack pointer.  The ABI sez to do this using `adds',\n+\t but the native C compiler on svr4 uses `addu'.  */\n+\n+      fprintf (asm_file, \"\\taddu -%d,%ssp,%ssp\\n\",\n+\ttotal_fsize, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Save the old frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tst.l %sfp,%d(%ssp)\\n\",\n+\ti860_reg_prefix, frame_lower_bytes, i860_reg_prefix);\n+\n+      /* Setup the new frame pointer.  The ABI sez to do this after\n+\t preserving registers and after saving the return address,\n+\t(and its saz to do this using adds), but that's not what the\n+\t native C compiler on svr4 does.  */\n+\n+      fprintf (asm_file, \"\\taddu %d,%ssp,%sfp\\n\",\n+\tframe_lower_bytes, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Preserve registers.  The ABI sez to do this before setting\n+\t up the new frame pointer, but that's not what the native\n+\t compiler on svr4 does.  */\n+\n+      for (i = 1; i < 32; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tst.l %s%s,%d(%sfp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      for (i = 32; i < 64; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tfst.l %s%s,%d(%sfp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      /* Save the return address.  The ABI sez to do this earlier,\n+\t and also via an offset from %sp, but the native C compiler\n+\t on svr4 does it later (i.e. now) and uses an offset from\n+\t %fp.  */\n+\n+      if (must_preserve_r1)\n+        fprintf (asm_file, \"\\tst.l %sr1,4(%sfp)\\n\",\n+\t  i860_reg_prefix, i860_reg_prefix);\n+    }\n+\n+#else /* defined(I860_STRICT_ABI_PROLOGUES) */\n+\n+  /* There are two kinds of function prologues.\n+     You use the \"small\" version if the total frame size is\n+     small enough so that it can fit into an immediate 16-bit\n+     value in one instruction.  Otherwise, you use the \"large\"\n+     version of the function prologue.  */\n+\n+  if (total_fsize > 0x7fff)\n+    {\n+      /* Adjust the stack pointer (thereby allocating a new frame).  */\n+\n+      fprintf (asm_file, \"\\tadds -%d,%ssp,%ssp\\n\",\n+\tframe_upper_bytes, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Save the caller's frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tst.l %sfp,0(%ssp)\\n\",\n+\ti860_reg_prefix, i860_reg_prefix);\n+\n+      /* Save return address.  */\n+\n+      if (must_preserve_r1)\n+        fprintf (asm_file, \"\\tst.l %sr1,4(%ssp)\\n\",\n+\t  i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Get the value of frame_lower_bytes into r31 for later use.  */\n+\n+      fprintf (asm_file, \"\\torh %d,%sr0,%sr31\\n\",\n+\tframe_lower_bytes >> 16, i860_reg_prefix, i860_reg_prefix);\n+      fprintf (asm_file, \"\\tor %d,%sr31,%sr31\\n\",\n+\tframe_lower_bytes & 0xffff, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Now re-adjust the stack pointer using the value in r31.  */\n+\n+      fprintf (asm_file, \"\\tsubs %ssp,%sr31,%ssp\\n\",\n+\ti860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Pre-compute value to be used as the new frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tadds %ssp,%sr31,%sr31\\n\",\n+\ti860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Preserve registers.  */\n+\n+      for (i = 1; i < 32; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tst.l %s%s,%d(%sr31)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      for (i = 32; i < 64; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tfst.l %s%s,%d(%sr31)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      /* Actually set the new value of the frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tmov %sr31,%sfp\\n\",\n+\ti860_reg_prefix, i860_reg_prefix);\n+    }\n+  else\n+    {\n+      /* Adjust the stack pointer.  */\n+\n+      fprintf (asm_file, \"\\tadds -%d,%ssp,%ssp\\n\",\n+\ttotal_fsize, i860_reg_prefix, i860_reg_prefix);\n+\n+      /* Save the caller's frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tst.l %sfp,%d(%ssp)\\n\",\n+\ti860_reg_prefix, frame_lower_bytes, i860_reg_prefix);\n+\n+      /* Save the return address.  */\n+\n+      if (must_preserve_r1)\n+        fprintf (asm_file, \"\\tst.l %sr1,%d(%ssp)\\n\",\n+\t  i860_reg_prefix, frame_lower_bytes + 4, i860_reg_prefix);\n+\n+      /* Preserve registers.  */\n+\n+      for (i = 1; i < 32; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tst.l %s%s,%d(%ssp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    frame_lower_bytes + must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      for (i = 32; i < 64; i++)\n+        if (regs_ever_live[i] && ! call_used_regs[i])\n+          fprintf (asm_file, \"\\tfst.l %s%s,%d(%ssp)\\n\",\n+\t    i860_reg_prefix, reg_names[i],\n+\t    frame_lower_bytes + must_preserve_bytes + (4 * preserved_so_far++),\n+\t    i860_reg_prefix);\n+\n+      /* Setup the new frame pointer.  */\n+\n+      fprintf (asm_file, \"\\tadds %d,%ssp,%sfp\\n\",\n+\tframe_lower_bytes, i860_reg_prefix, i860_reg_prefix);\n+    }\n+#endif /* defined(I860_STRICT_ABI_PROLOGUES) */\n+\n+#ifdef ASM_OUTPUT_PROLOGUE_SUFFIX\n+  ASM_OUTPUT_PROLOGUE_SUFFIX (asm_file);\n+#endif /* defined(ASM_OUTPUT_PROLOGUE_SUFFIX) */\n+}\n+\f\n+/* This function generates the assembly code for function exit.\n+\n+   ASM_FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.\n+\n+   Note that when we go to restore the preserved register values we must\n+   not try to address their slots by using offsets from the stack pointer.\n+   That's because the stack pointer may have been moved during the function\n+   execution due to a call to alloca().  Rather, we must restore all\n+   preserved registers via offsets from the frame pointer value.\n+\n+   Note also that when the current frame is being \"popped\" (by adjusting\n+   the value of the stack pointer) on function exit, we must (for the\n+   sake of alloca) set the new value of the stack pointer based upon\n+   the current value of the frame pointer.  We can't just add what we\n+   believe to be the (static) frame size to the stack pointer because\n+   if we did that, and alloca() had been called during this function,\n+   we would end up returning *without* having fully deallocated all of\n+   the space grabbed by alloca.  If that happened, and a function\n+   containing one or more alloca() calls was called over and over again,\n+   then the stack would grow without limit!\n+\n+   Finally note that the epilogues generated here are completely ABI\n+   compliant.  They go out of their way to insure that the value in\n+   the frame pointer register is never less than the value in the stack\n+   pointer register.  It's not clear why this relationship needs to be\n+   maintained at all times, but maintaining it only costs one extra\n+   instruction, so what the hell.\n+*/\n+\n+/* This corresponds to a version 4 TDESC structure. Lower numbered\n+   versions successively omit the last word of the structure. We\n+   don't try to handle version 5 here. */\n+\n+typedef struct TDESC_flags {\n+\tint version:4;\n+\tint reg_packing:1;\n+\tint callable_block:1;\n+\tint reserved:4;\n+\tint fregs:6;\t/* fp regs 2-7 */\n+\tint iregs:16;\t/* regs 0-15 */\n+} TDESC_flags;\n+\n+typedef struct TDESC {\n+\tTDESC_flags flags;\n+\tint integer_reg_offset;\t\t/* same as must_preserve_bytes */\n+\tint floating_point_reg_offset;\n+\tunsigned int positive_frame_size;\t/* same as frame_upper_bytes */\n+\tunsigned int negative_frame_size;\t/* same as frame_lower_bytes */\n+} TDESC;\n+\n+static void\n+i860_output_function_epilogue (asm_file, local_bytes)\n+     register FILE *asm_file;\n+     register HOST_WIDE_INT local_bytes;\n+{\n+  register HOST_WIDE_INT frame_upper_bytes;\n+  register HOST_WIDE_INT frame_lower_bytes;\n+  register HOST_WIDE_INT preserved_reg_bytes = 0;\n+  register unsigned i;\n+  register unsigned restored_so_far = 0;\n+  register unsigned int_restored;\n+  register unsigned mask;\n+  unsigned intflags=0;\n+  register TDESC_flags *flags = (TDESC_flags *) &intflags;\n+#ifdef\tOUTPUT_TDESC\t/* Output an ABI-compliant TDESC entry */\n+  const char *long_op = integer_asm_op (4, TRUE);\n+#endif\n+\n+  flags->version = 4;\n+  flags->reg_packing = 1;\n+  flags->iregs = 8;\t/* old fp always gets saved */\n+\n+  /* Round-up the frame_lower_bytes so that it's a multiple of 16. */\n+\n+  frame_lower_bytes = (local_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n+\n+  /* Count the number of registers that were preserved in the prologue.\n+     Ignore r0.  It is never preserved.  */\n+\n+  for (i = 1; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (regs_ever_live[i] && ! call_used_regs[i])\n+        preserved_reg_bytes += 4;\n+    }\n+\n+  /* The upper part of each frame will contain only saved fp,\n+     the saved r1, and stack slots for all of the other \"preserved\"\n+     registers that we find we will need to save & restore. */\n+\n+  frame_upper_bytes = must_preserve_bytes + preserved_reg_bytes;\n+\n+  /* Round-up frame_upper_bytes so that t is a multiple of 16. */\n+\n+  frame_upper_bytes\n+    = (frame_upper_bytes + STACK_ALIGNMENT - 1) & -STACK_ALIGNMENT;\n+\n+  /* Restore all of the \"preserved\" registers that need restoring.  */\n+\n+  mask = 2;\n+\n+  for (i = 1; i < 32; i++, mask<<=1)\n+    if (regs_ever_live[i] && ! call_used_regs[i]) {\n+      fprintf (asm_file, \"\\tld.l %d(%sfp),%s%s\\n\",\n+\tmust_preserve_bytes + (4 * restored_so_far++),\n+\ti860_reg_prefix, i860_reg_prefix, reg_names[i]);\n+      if (i > 3 && i < 16)\n+\tflags->iregs |= mask;\n+    }\n+\n+  int_restored = restored_so_far;\n+  mask = 1;\n+\n+  for (i = 32; i < 64; i++) {\n+    if (regs_ever_live[i] && ! call_used_regs[i]) {\n+      fprintf (asm_file, \"\\tfld.l %d(%sfp),%s%s\\n\",\n+\tmust_preserve_bytes + (4 * restored_so_far++),\n+\ti860_reg_prefix, i860_reg_prefix, reg_names[i]);\n+      if (i > 33 && i < 40)\n+\tflags->fregs |= mask;\n+    }\n+    if (i > 33 && i < 40)\n+      mask<<=1;\n+  }\n+\n+  /* Get the value we plan to use to restore the stack pointer into r31.  */\n+\n+  fprintf (asm_file, \"\\tadds %d,%sfp,%sr31\\n\",\n+    frame_upper_bytes, i860_reg_prefix, i860_reg_prefix);\n+\n+  /* Restore the return address and the old frame pointer.  */\n+\n+  if (must_preserve_r1) {\n+    fprintf (asm_file, \"\\tld.l 4(%sfp),%sr1\\n\",\n+      i860_reg_prefix, i860_reg_prefix);\n+    flags->iregs |= 2;\n+  }\n+\n+  fprintf (asm_file, \"\\tld.l 0(%sfp),%sfp\\n\",\n+    i860_reg_prefix, i860_reg_prefix);\n+\n+  /* Return and restore the old stack pointer value.  */\n+\n+  fprintf (asm_file, \"\\tbri %sr1\\n\\tmov %sr31,%ssp\\n\",\n+    i860_reg_prefix, i860_reg_prefix, i860_reg_prefix);\n+\n+#ifdef\tOUTPUT_TDESC\t/* Output an ABI-compliant TDESC entry */\n+  if (! frame_lower_bytes) {\n+    flags->version--;\n+    if (! frame_upper_bytes) {\n+      flags->version--;\n+      if (restored_so_far == int_restored)\t/* No FP saves */\n+\tflags->version--;\n+    }\n+  }\n+  assemble_name(asm_file,current_function_original_name);\n+  fputs(\".TDESC:\\n\", asm_file);\n+  fprintf(asm_file, \"%s 0x%0x\\n\", long_op, intflags);\n+  fprintf(asm_file, \"%s %d\\n\", long_op,\n+\tint_restored ? must_preserve_bytes : 0);\n+  if (flags->version > 1) {\n+    fprintf(asm_file, \"%s %d\\n\", long_op,\n+\t(restored_so_far == int_restored) ? 0 : must_preserve_bytes +\n+\t  (4 * int_restored));\n+    if (flags->version > 2) {\n+      fprintf(asm_file, \"%s %d\\n\", long_op, frame_upper_bytes);\n+      if (flags->version > 3)\n+\tfprintf(asm_file, \"%s %d\\n\", long_op, frame_lower_bytes);\n+    }\n+  }\n+  tdesc_section();\n+  fprintf(asm_file, \"%s \", long_op);\n+  assemble_name(asm_file, current_function_original_name);\n+  fprintf(asm_file, \"\\n%s \", long_op);\n+  assemble_name(asm_file, current_function_original_name);\n+  fputs(\".TDESC\\n\", asm_file);\n+  text_section();\n+#endif\n+}\n+\f\n+\n+/* Expand a library call to __builtin_saveregs.  */\n+rtx\n+i860_saveregs ()\n+{\n+  rtx fn = gen_rtx_SYMBOL_REF (Pmode, \"__builtin_saveregs\");\n+  rtx save = gen_reg_rtx (Pmode);\n+  rtx valreg = LIBCALL_VALUE (Pmode);\n+  rtx ret;\n+\n+  /* The return value register overlaps the first argument register.\n+     Save and restore it around the call.  */\n+  emit_move_insn (save, valreg);\n+  ret = emit_library_call_value (fn, NULL_RTX, 1, Pmode, 0);\n+  if (GET_CODE (ret) != REG || REGNO (ret) < FIRST_PSEUDO_REGISTER)\n+    ret = copy_to_reg (ret);\n+  emit_move_insn (valreg, save);\n+\n+  return ret;\n+}\n+\n+tree\n+i860_build_va_list ()\n+{\n+  tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n+  tree record;\n+\n+  record = make_node (RECORD_TYPE);\n+\n+  field_ireg_used = build_decl (FIELD_DECL, get_identifier (\"__ireg_used\"),\n+\t\t\t\tunsigned_type_node);\n+  field_freg_used = build_decl (FIELD_DECL, get_identifier (\"__freg_used\"),\n+\t\t\t\tunsigned_type_node);\n+  field_reg_base = build_decl (FIELD_DECL, get_identifier (\"__reg_base\"),\n+\t\t\t       ptr_type_node);\n+  field_mem_ptr = build_decl (FIELD_DECL, get_identifier (\"__mem_ptr\"),\n+\t\t\t      ptr_type_node);\n+\n+  DECL_FIELD_CONTEXT (field_ireg_used) = record;\n+  DECL_FIELD_CONTEXT (field_freg_used) = record;\n+  DECL_FIELD_CONTEXT (field_reg_base) = record;\n+  DECL_FIELD_CONTEXT (field_mem_ptr) = record;\n+\n+#ifdef I860_SVR4_VA_LIST\n+  TYPE_FIELDS (record) = field_ireg_used;\n+  TREE_CHAIN (field_ireg_used) = field_freg_used;\n+  TREE_CHAIN (field_freg_used) = field_reg_base;\n+  TREE_CHAIN (field_reg_base) = field_mem_ptr;\n+#else\n+  TYPE_FIELDS (record) = field_reg_base;\n+  TREE_CHAIN (field_reg_base) = field_mem_ptr;\n+  TREE_CHAIN (field_mem_ptr) = field_ireg_used;\n+  TREE_CHAIN (field_ireg_used) = field_freg_used;\n+#endif\n+\n+  layout_type (record);\n+  return record;\n+}\n+\n+void\n+i860_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p;\n+     tree valist;\n+     rtx nextarg;\n+{\n+  tree saveregs, t;\n+\n+  saveregs = make_tree (build_pointer_type (va_list_type_node),\n+\t\t\texpand_builtin_saveregs ());\n+  saveregs = build1 (INDIRECT_REF, va_list_type_node, saveregs);\n+\n+  if (stdarg_p)\n+    {\n+      tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n+      tree ireg_used, freg_used, reg_base, mem_ptr;\n+\n+#ifdef I860_SVR4_VA_LIST\n+      field_ireg_used = TYPE_FIELDS (va_list_type_node);\n+      field_freg_used = TREE_CHAIN (field_ireg_used);\n+      field_reg_base = TREE_CHAIN (field_freg_used);\n+      field_mem_ptr = TREE_CHAIN (field_reg_base);\n+#else\n+      field_reg_base = TYPE_FIELDS (va_list_type_node);\n+      field_mem_ptr = TREE_CHAIN (field_reg_base);\n+      field_ireg_used = TREE_CHAIN (field_mem_ptr);\n+      field_freg_used = TREE_CHAIN (field_ireg_used);\n+#endif\n+\n+      ireg_used = build (COMPONENT_REF, TREE_TYPE (field_ireg_used),\n+\t\t\t valist, field_ireg_used);\n+      freg_used = build (COMPONENT_REF, TREE_TYPE (field_freg_used),\n+\t\t\t valist, field_freg_used);\n+      reg_base = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n+\t\t\tvalist, field_reg_base);\n+      mem_ptr = build (COMPONENT_REF, TREE_TYPE (field_mem_ptr),\n+\t\t       valist, field_mem_ptr);\n+\n+      t = build_int_2 (current_function_args_info.ints, 0);\n+      t = build (MODIFY_EXPR, TREE_TYPE (ireg_used), ireg_used, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      \n+      t = build_int_2 (ROUNDUP (current_function_args_info.floats, 8), 0);\n+      t = build (MODIFY_EXPR, TREE_TYPE (freg_used), freg_used, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      \n+      t = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n+\t\t saveregs, field_reg_base);\n+      t = build (MODIFY_EXPR, TREE_TYPE (reg_base), reg_base, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+      t = make_tree (ptr_type_node, nextarg);\n+      t = build (MODIFY_EXPR, TREE_TYPE (mem_ptr), mem_ptr, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n+  else\n+    {\n+      t = build (MODIFY_EXPR, va_list_type_node, valist, saveregs);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n+}\n+\n+#define NUM_PARM_FREGS\t8\n+#define NUM_PARM_IREGS\t12\n+#ifdef I860_SVR4_VARARGS\n+#define FREG_OFFSET 0\n+#define IREG_OFFSET (NUM_PARM_FREGS * UNITS_PER_WORD)\n+#else\n+#define FREG_OFFSET (NUM_PARM_IREGS * UNITS_PER_WORD)\n+#define IREG_OFFSET 0\n+#endif\n+\n+rtx\n+i860_va_arg (valist, type)\n+     tree valist, type;\n+{\n+  tree field_ireg_used, field_freg_used, field_reg_base, field_mem_ptr;\n+  tree type_ptr_node, t;\n+  rtx lab_over = NULL_RTX;\n+  rtx ret, val;\n+  HOST_WIDE_INT align;\n+\n+#ifdef I860_SVR4_VA_LIST\n+  field_ireg_used = TYPE_FIELDS (va_list_type_node);\n+  field_freg_used = TREE_CHAIN (field_ireg_used);\n+  field_reg_base = TREE_CHAIN (field_freg_used);\n+  field_mem_ptr = TREE_CHAIN (field_reg_base);\n+#else\n+  field_reg_base = TYPE_FIELDS (va_list_type_node);\n+  field_mem_ptr = TREE_CHAIN (field_reg_base);\n+  field_ireg_used = TREE_CHAIN (field_mem_ptr);\n+  field_freg_used = TREE_CHAIN (field_ireg_used);\n+#endif\n+\n+  field_ireg_used = build (COMPONENT_REF, TREE_TYPE (field_ireg_used),\n+\t\t\t   valist, field_ireg_used);\n+  field_freg_used = build (COMPONENT_REF, TREE_TYPE (field_freg_used),\n+\t\t\t   valist, field_freg_used);\n+  field_reg_base = build (COMPONENT_REF, TREE_TYPE (field_reg_base),\n+\t\t\t  valist, field_reg_base);\n+  field_mem_ptr = build (COMPONENT_REF, TREE_TYPE (field_mem_ptr),\n+\t\t\t valist, field_mem_ptr);\n+\n+  ret = gen_reg_rtx (Pmode);\n+  type_ptr_node = build_pointer_type (type);\n+\n+  if (! AGGREGATE_TYPE_P (type))\n+    {\n+      int nparm, incr, ofs;\n+      tree field;\n+      rtx lab_false;\n+\n+      if (FLOAT_TYPE_P (type))\n+\t{\n+\t  field = field_freg_used;\n+\t  nparm = NUM_PARM_FREGS;\n+\t  incr = 2;\n+\t  ofs = FREG_OFFSET;\n+\t}\n+      else\n+\t{\n+\t  field = field_ireg_used;\n+\t  nparm = NUM_PARM_IREGS;\n+\t  incr = int_size_in_bytes (type) / UNITS_PER_WORD;\n+\t  ofs = IREG_OFFSET;\n+\t}\n+\n+      lab_false = gen_label_rtx ();\n+      lab_over = gen_label_rtx ();\n+\n+      emit_cmp_and_jump_insns (expand_expr (field, NULL_RTX, 0, 0),\n+\t\t\t       GEN_INT (nparm - incr), GT, const0_rtx,\n+\t\t\t       TYPE_MODE (TREE_TYPE (field)),\n+\t\t\t       TREE_UNSIGNED (field), lab_false);\n+\n+      t = fold (build (POSTINCREMENT_EXPR, TREE_TYPE (field), field,\n+\t\t       build_int_2 (incr, 0)));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+\n+      t = fold (build (MULT_EXPR, TREE_TYPE (field), field,\n+\t\t       build_int_2 (UNITS_PER_WORD, 0)));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      \n+      t = fold (build (PLUS_EXPR, ptr_type_node, field_reg_base,\n+\t\t       fold (build (PLUS_EXPR, TREE_TYPE (field), t,\n+\t\t\t\t    build_int_2 (ofs, 0)))));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      \n+      val = expand_expr (t, ret, VOIDmode, EXPAND_NORMAL);\n+      if (val != ret)\n+\temit_move_insn (ret, val);\n+\n+      emit_jump_insn (gen_jump (lab_over));\n+      emit_barrier ();\n+      emit_label (lab_false);\n+    }\n+\n+  align = TYPE_ALIGN (type);\n+  if (align < BITS_PER_WORD)\n+    align = BITS_PER_WORD;\n+  align /= BITS_PER_UNIT;\n+\n+  t = build (PLUS_EXPR, ptr_type_node, field_mem_ptr,\n+\t     build_int_2 (align - 1, 0));\n+  t = build (BIT_AND_EXPR, ptr_type_node, t, build_int_2 (-align, -1));\n+\n+  val = expand_expr (t, ret, VOIDmode, EXPAND_NORMAL);\n+  if (val != ret)\n+    emit_move_insn (ret, val);\n+\n+  t = fold (build (PLUS_EXPR, ptr_type_node,\n+\t\t   make_tree (ptr_type_node, ret),\n+\t\t   build_int_2 (int_size_in_bytes (type), 0)));\n+  t = build (MODIFY_EXPR, ptr_type_node, field_mem_ptr, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  if (lab_over)\n+    emit_label (lab_over);\n+\n+  return ret;\n+}"}, {"sha": "f9fd62c88d6a2205197b8b0c21221e6f4f04a762", "filename": "gcc/config/i860/i860.h", "status": "added", "additions": 1319, "deletions": 0, "changes": 1319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -0,0 +1,1319 @@\n+/* Definitions of target machine for GNU compiler, for Intel 860.\n+   Copyright (C) 1989, 1991, 1993, 1995, 1996, 1997, 1998, 1999, 2000,\n+   2001, 2002 Free Software Foundation, Inc.\n+   Hacked substantially by Ron Guilmette (rfg@monkeys.com) to cater to\n+   the whims of the System V Release 4 assembler.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+/* Note that some other tm.h files include this one and then override\n+   many of the definitions that relate to assembler syntax.  */\n+\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Di860 -Dunix -Asystem=unix -Asystem=svr4 -Acpu=i860 -Amachine=i860\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION fprintf (stderr, \" (i860)\");\n+\n+/* Run-time compilation parameters selecting different hardware subsets\n+   or supersets.\n+\n+   On the i860, we have one: TARGET_XP.  This option allows gcc to generate\n+   additional instructions available only on the newer i860 XP (but not on\n+   the older i860 XR).\n+*/\n+\n+extern int target_flags;\n+\n+/* Nonzero if we should generate code to use the fpu.  */\n+#define TARGET_XP (target_flags & 1)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { {\"xp\", 1, N_(\"Generate code which uses the FPU\")},\t\t\t\\\n+    {\"noxp\", -1, N_(\"Do not generate code which uses the FPU\")},\t\\\n+    {\"xr\", -1, N_(\"Do not generate code which uses the FPU\")},\t\t\\\n+    { \"\", TARGET_DEFAULT, NULL}}\n+\n+#define TARGET_DEFAULT 0\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is a moot question on the i860 due to the lack of bit-field insns.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is not true on i860 in the mode we will use.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+/* For the i860 this goes with BYTES_BIG_ENDIAN.  */\n+/* NOTE: GCC probably cannot support a big-endian i860\n+   because GCC fundamentally assumes that the order of words\n+   in memory as the same as the order in registers.\n+   That's not true for the big-endian i860.\n+   The big-endian i860 isn't important enough to\n+   justify the trouble of changing this assumption.  */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 128\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 64\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* Minimum size in bits of the largest boundary to which any\n+   and all fundamental data types supported by the hardware\n+   might need to be aligned. No data type wants to be aligned\n+   rounder than this.  The i860 supports 128-bit (long double)\n+   floating point quantities, and the System V Release 4 i860\n+   ABI requires these to be aligned to 16-byte (128-bit)\n+   boundaries.  */\n+#define BIGGEST_ALIGNMENT 128\n+\n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* If bit field type is int, don't let it cross an int,\n+   and give entire struct the alignment of an int.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   i860 has 32 fullword registers and 32 floating point registers.  */\n+\n+#define FIRST_PSEUDO_REGISTER 64\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the i860, this includes the always-0 registers\n+   and fp, sp, arg pointer, and the return address.\n+   Also r31, used for special purposes for constant addresses.  */\n+#define FIXED_REGISTERS  \\\n+ {1, 1, 1, 1, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 1,\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   On the i860, these are r0-r3, r16-r31, f0, f1, and f16-f31.  */\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 1, 1, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1}\n+\n+/* Try to get a non-preserved register before trying to get one we will\n+   have to preserve.  Try to get an FP register only *after* trying to\n+   get a general register, because it is relatively expensive to move\n+   into or out of an FP register.  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\\\n+ {31, 30, 29, 28, 27, 26, 25, 24,\t\\\n+  23, 22, 21, 20, 19, 18, 17, 16,\t\\\n+  15, 14, 13, 12, 11, 10,  9,  8,\t\\\n+   7,  6,  5,  4,  3,  2,  1,  0,\t\\\n+  63, 62, 61, 60, 59, 58, 57, 56,\t\\\n+  55, 54, 53, 52, 51, 50, 49, 48,\t\\\n+  47, 46, 45, 44, 43, 42, 41, 40,\t\\\n+  39, 38, 37, 36, 35, 34, 33, 32}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On the i860, all registers hold 32 bits worth.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+#define REGNO_MODE_ALIGNED(REGNO, MODE) \\\n+  (((REGNO) % ((GET_MODE_UNIT_SIZE (MODE) + 3) / 4)) == 0)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+\n+   On the i860, we allow anything to go into any registers, but we require\n+   any sort of value going into the FP registers to be properly aligned\n+   (based on its size) within the FP register set.\n+*/\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+  (((REGNO) < 32) \t\t\t\t\t\t\t\\\n+   || (MODE) == VOIDmode || (MODE) == BLKmode\t\t\t\t\\\n+   || REGNO_MODE_ALIGNED (REGNO, MODE))\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+/* I think that is not always true; alignment restrictions for doubles\n+   should not prevent tying them with singles.  So try allowing that.\n+   On the other hand, don't let fixed and floating be tied;\n+   this restriction is not necessary, but may make better code.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n+    || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\\\n+   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\\\n+       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* i860 pc isn't overloaded on a register that the compiler knows about.  */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 2\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 3\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 28\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 29\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 16\n+\n+/* Register to use when a source of a floating-point zero is needed.  */\n+#define F0_REGNUM\t32\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* The i860 has two kinds of registers, hence four classes.  */\n+\n+enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS\t\\\n+ {{0, 0}, {0xffffffff, 0},\t\\\n+  {0, 0xffffffff}, {0xffffffff, 0xffffffff}}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+ ((REGNO) >= 32 ? FP_REGS : GENERAL_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'f' ? FP_REGS : NO_REGS)\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   For the i860, `I' is used for the range of constants \n+   an add/subtract insn can actually contain.\n+   But not including -0x8000, since we need\n+   to negate the constant sometimes.\n+   `J' is used for the range which is just zero (since that is R0).\n+   `K' is used for the range allowed in bte.\n+   `L' is used for the range allowed in logical insns.  */\n+\n+#define SMALL_INT(X) ((unsigned) (INTVAL (X) + 0x7fff) < 0xffff)\n+\n+#define LOGIC_INT(X) ((unsigned) INTVAL (X) < 0x10000)\n+\n+#define SMALL_INTVAL(X) ((unsigned) ((X) + 0x7fff) < 0xffff)\n+\n+#define LOGIC_INTVAL(X) ((unsigned) (X) < 0x10000)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'I' ? ((unsigned) (VALUE) + 0x7fff) < 0xffff\t\\\n+   : (C) == 'J' ? (VALUE) == 0\t\t\t\t\\\n+   : (C) == 'K' ? (unsigned) (VALUE) < 0x20\t\\\n+   : (C) == 'L' ? (unsigned) (VALUE) < 0x10000\t\\\n+   : 0)\n+\n+/* Return non-zero if the given VALUE is acceptable for the\n+   constraint letter C.  For the i860, constraint letter 'G'\n+   permits only a floating-point zero value.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \t\\\n+  ((C) == 'G' && CONST_DOUBLE_LOW ((VALUE)) == 0\t\\\n+   && CONST_DOUBLE_HIGH ((VALUE)) == 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+\n+   If we are trying to put an integer constant into some register, prefer an\n+   integer register to an FP register.  If we are trying to put a \n+   non-zero floating-point constant into some register, use an integer\n+   register if the constant is SFmode and GENERAL_REGS is one of our options.\n+   Otherwise, put the constant into memory.\n+\n+   When reloading something smaller than a word, use a general reg\n+   rather than an FP reg.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  \\\n+  ((CLASS) == ALL_REGS && GET_CODE (X) == CONST_INT ? GENERAL_REGS\t\\\n+   : ((GET_MODE (X) == HImode || GET_MODE (X) == QImode)\t\t\\\n+      && (CLASS) == ALL_REGS)\t\t\t\t\t\t\\\n+   ? GENERAL_REGS\t\t\t\t\t\t\t\\\n+   : (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n+      && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n+      && ! CONST_DOUBLE_OK_FOR_LETTER_P (X, 'G'))\t\t\t\\\n+   ? ((CLASS) == ALL_REGS && GET_MODE (X) == SFmode ? GENERAL_REGS\t\\\n+      : (CLASS) == GENERAL_REGS && GET_MODE (X) == SFmode ? (CLASS)\t\\\n+      : NO_REGS)\t\t\t\t\t\t\t\\\n+   : (CLASS))\n+\n+/* Return the register class of a scratch register needed to copy IN into\n+   a register in CLASS in MODE.  If it can be done directly, NO_REGS is\n+   returned.  */\n+\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  ((CLASS) == FP_REGS && CONSTANT_P (IN) ? GENERAL_REGS : NO_REGS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On the i860, this is the size of MODE in words.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On the i860, don't define this because there are no push insns.  */\n+/*  #define PUSH_ROUNDING(BYTES) */\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNDECL is the declaration node of the function (as a tree),\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On the i860, the value register depends on the mode.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx_REG (TYPE_MODE (VALTYPE),\t\t\t\t\\\n+\t       (GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT\t\\\n+\t\t? 40 : 16))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\\\n+  gen_rtx_REG (MODE,\t\t\t\t\t\\\n+\t       (GET_MODE_CLASS ((MODE)) == MODE_FLOAT\t\\\n+\t\t? 40 : 16))\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 40 || (N) == 16)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the i860, these are r16-r27 and f8-f15.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N)\t\t\\\n+  (((N) < 28 && (N) > 15) || ((N) < 48 && (N) >= 40))\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the i860, we must count separately the number of general registers used\n+   and the number of float registers used.  */\n+\n+struct cumulative_args { int ints, floats; };\n+#define CUMULATIVE_ARGS struct cumulative_args\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the i860, the general-reg offset normally starts at 0,\n+   but starts at 4 bytes\n+   when the function gets a structure-value-address as an\n+   invisible first argument.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n+ ((CUM).ints = ((FNTYPE) != 0 && aggregate_value_p (TREE_TYPE ((FNTYPE))) \\\n+\t\t? 4 : 0),\t\t\t\\\n+  (CUM).floats = 0)\n+\n+/* Machine-specific subroutines of the following macros.  */\n+#define CEILING(X,Y)  (((X) + (Y) - 1) / (Y))\n+#define ROUNDUP(X,Y)  (CEILING ((X), (Y)) * (Y))\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)\n+   Floats, and doubleword ints, are returned in f regs;\n+   other ints, in r regs.\n+   Aggregates, even short ones, are passed in memory.  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+ ((TYPE) != 0 && (TREE_CODE ((TYPE)) == RECORD_TYPE\t\t\\\n+\t\t  || TREE_CODE ((TYPE)) == UNION_TYPE)\t\t\\\n+  ? 0\t\t\t\t\t\t\t\t\\\n+  : GET_MODE_CLASS ((MODE)) == MODE_FLOAT || (MODE) == DImode\t\\\n+  ? ((CUM).floats = (ROUNDUP ((CUM).floats, GET_MODE_SIZE ((MODE)))\t\\\n+\t\t     + ROUNDUP (GET_MODE_SIZE (MODE), 4)))\t\\\n+  : GET_MODE_CLASS ((MODE)) == MODE_INT\t\t\t\t\\\n+  ? ((CUM).ints = (ROUNDUP ((CUM).ints, GET_MODE_SIZE ((MODE))) \\\n+\t\t   + ROUNDUP (GET_MODE_SIZE (MODE), 4)))\t\\\n+  : 0)\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the i860, the first 12 words of integer arguments go in r16-r27,\n+   and the first 8 words of floating arguments go in f8-f15.\n+   DImode values are treated as floats.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\\\n+ ((TYPE) != 0 && (TREE_CODE ((TYPE)) == RECORD_TYPE\t\\\n+\t\t  || TREE_CODE ((TYPE)) == UNION_TYPE)\t\\\n+  ? 0\t\t\t\t\t\t\t\\\n+  : GET_MODE_CLASS ((MODE)) == MODE_FLOAT || (MODE) == DImode\t\\\n+  ? (ROUNDUP ((CUM).floats, GET_MODE_SIZE ((MODE))) < 32\t\\\n+     ? gen_rtx_REG ((MODE),\t\t\t\t\\\n+\t\t    40 + (ROUNDUP ((CUM).floats,\t\\\n+\t\t\t\t   GET_MODE_SIZE ((MODE)))\t\\\n+\t\t\t  / 4))\t\t\t\t\\\n+     : 0)\t\t\t\t\t\t\\\n+  : GET_MODE_CLASS ((MODE)) == MODE_INT\t\t\t\\\n+  ? (ROUNDUP ((CUM).ints, GET_MODE_SIZE ((MODE))) < 48\t\\\n+     ? gen_rtx_REG ((MODE),\t\t\t\t\\\n+\t\t    16 + (ROUNDUP ((CUM).ints,\t\t\\\n+\t\t\t\t   GET_MODE_SIZE ((MODE)))\t\\\n+\t\t\t  / 4))\t\t\t\t\\\n+     : 0)\t\t\t\t\t\t\\\n+  : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\n+/* If defined, a C expression that gives the alignment boundary, in\n+   bits, of an argument with the specified mode and type.  If it is\n+   not defined,  `PARM_BOUNDARY' is used for all arguments.  */\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\\\n+  (((TYPE) != 0)\t\t\t\t\t\t\\\n+   ? ((TYPE_ALIGN(TYPE) <= PARM_BOUNDARY)\t\t\t\\\n+      ? PARM_BOUNDARY\t\t\t\t\t\t\\\n+      : TYPE_ALIGN(TYPE))\t\t\t\t\t\\\n+   : ((GET_MODE_ALIGNMENT(MODE) <= PARM_BOUNDARY)\t\t\\\n+      ? PARM_BOUNDARY\t\t\t\t\t\t\\\n+      : GET_MODE_ALIGNMENT(MODE)))\n+\n+/* Output a no-op just before the beginning of the function,\n+   to ensure that there does not appear to be a delayed branch there.\n+   Such a thing would confuse interrupt recovery.  */\n+#define ASM_OUTPUT_FUNCTION_PREFIX(FILE,NAME) \\\n+  fprintf (FILE, \"\\tnop\\n\")\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   abort ();\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* Generate necessary RTL for __builtin_saveregs().  */\n+#define EXPAND_BUILTIN_SAVEREGS() \\\n+  i860_saveregs()\n+\n+/* Define the `__builtin_va_list' type for the ABI.  */\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = i860_build_va_list ()\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  i860_va_start (stdarg, valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  i860_va_arg (valist, type)\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.\n+\n+   On the i860, FRAME_POINTER_REQUIRED is always 1, so the definition of this\n+   macro doesn't matter.  But it must be defined.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) \\\n+  do { (DEPTH) = 0; } while (0)\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On the i860, the trampoline contains five instructions:\n+     orh #TOP_OF_FUNCTION,r0,r31\n+     or #BOTTOM_OF_FUNCTION,r31,r31\n+     orh #TOP_OF_STATIC,r0,r29\n+     bri r31\n+     or #BOTTOM_OF_STATIC,r29,r29  */\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xec1f0000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xe7ff0000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xec1d0000));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x4000f800));\t\\\n+  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0xe7bd0000));\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 20\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.\n+\n+   Store hi function at +0, low function at +4,\n+   hi static at +8, low static at +16  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx cxt = force_reg (Pmode, CXT);\t\t\t\t\t\\\n+  rtx fn = force_reg (Pmode, FNADDR);\t\t\t\t\t\\\n+  rtx hi_cxt = expand_shift (RSHIFT_EXPR, SImode, cxt,\t\t\t\\\n+\t\t\t     size_int (16), 0, 0);\t\t\t\\\n+  rtx hi_fn = expand_shift (RSHIFT_EXPR, SImode, fn,\t\t\t\\\n+\t\t\t    size_int (16), 0, 0);\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 16)),\t\\\n+\t\t  gen_lowpart (HImode, cxt));\t\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 4)),\t\\\n+\t\t  gen_lowpart (HImode, fn));\t\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 8)),\t\\\n+\t\t  gen_lowpart (HImode, hi_cxt));\t\t\t\\\n+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (TRAMP, 0)),\t\\\n+\t\t  gen_lowpart (HImode, hi_fn));\t\t\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT 0 */\n+/* #define HAVE_POST_DECREMENT 0 */\n+\n+/* #define HAVE_PRE_DECREMENT 0 */\n+/* #define HAVE_PRE_INCREMENT 0 */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n+#define REGNO_OK_FOR_FP_P(REGNO) \\\n+(((REGNO) ^ 0x20) < 32 || (unsigned) (reg_renumber[REGNO] ^ 0x20) < 32)\n+\n+/* Now macros that check whether X is a register and also,\n+   strictly, whether it is in a specified class.\n+\n+   These macros are specific to the i860, and may be used only\n+   in code for printing assembler insns and in conditions for\n+   define_optimization.  */\n+\n+/* 1 if X is an fp register.  */\n+\n+#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X)   \\\n+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n+   || GET_CODE (X) == HIGH)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n+\n+   On the Sparc, this is anything but a CONST_DOUBLE.\n+   Let's try permitting CONST_DOUBLEs and see what happens.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) (((unsigned) REGNO (X)) - 32 >= 14)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) (((unsigned) REGNO (X)) - 32 >= 14)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On the i860, the actual addresses must be REG+REG or REG+SMALLINT.\n+   But we can treat a SYMBOL_REF as legitimate if it is part of this\n+   function's constant-pool, because such addresses can actually\n+   be output as REG+SMALLINT.\n+\n+   The displacement in an address must be a multiple of the alignment.\n+\n+   Try making SYMBOL_REF (and other things which are CONSTANT_ADDRESS_P)\n+   a legitimate address, regardless.  Because the only insns which can use\n+   memory are load or store insns, the added hair in the machine description\n+   is not that bad.  It should also speed up the compiler by halving the number\n+   of insns it must manage for each (MEM (SYMBOL_REF ...)) involved.  */\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n+{ if (GET_CODE (X) == REG)\t\t\t\t\\\n+    { if (REG_OK_FOR_BASE_P (X)) goto ADDR; }\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n+\t      && INTVAL (XEXP (X, 1)) >= -0x8000\t\\\n+\t      && INTVAL (XEXP (X, 1)) < 0x8000\t\t\\\n+\t      && (INTVAL (XEXP (X, 1)) & (GET_MODE_SIZE (MODE) - 1)) == 0) \\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (X, 1)) == REG\t\t\\\n+\t  && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (X, 0)) == CONST_INT\t\\\n+\t      && INTVAL (XEXP (X, 0)) >= -0x8000\t\\\n+\t      && INTVAL (XEXP (X, 0)) < 0x8000\t\t\\\n+\t      && (INTVAL (XEXP (X, 0)) & (GET_MODE_SIZE (MODE) - 1)) == 0) \\\n+\t    goto ADDR;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  else if (CONSTANT_ADDRESS_P (X))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+}\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.  */\n+\n+/* On the i860, change COMPLICATED + CONSTANT to REG+CONSTANT.\n+   Also change a symbolic constant to a REG,\n+   though that may not be necessary.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n+{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 0), 0));\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 1), 0));\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 0), 0));\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n+\t\t\tforce_operand (XEXP (X, 1), 0));\t\\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) != REG\t\\\n+      && GET_CODE (XEXP (X, 0)) != CONST_INT)\t\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n+\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0))); \\\n+  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) != REG\t\\\n+      && GET_CODE (XEXP (X, 1)) != CONST_INT)\t\t\t\\\n+    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n+\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1))); \\\n+  if (GET_CODE (x) == SYMBOL_REF)\t\t\t\t\\\n+    (X) = copy_to_reg (X);\t\t\t\t\t\\\n+  if (GET_CODE (x) == CONST)\t\t\t\t\t\\\n+    (X) = copy_to_reg (X);\t\t\t\t\t\\\n+  if (memory_address_p (MODE, X))\t\t\t\t\\\n+    goto WIN; }\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the i860 this is never true.\n+   There are some addresses that are invalid in wide modes\n+   but valid for narrower modes, but they shouldn't affect\n+   the places that use this macro.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define as C expression which evaluates to nonzero if the tablejump\n+   instruction expects the table to contain offsets from the address of the\n+   table.\n+   Do not define this if the table should contain absolute addresses. */\n+/* #define CASE_VECTOR_PC_RELATIVE 1 */\n+\n+/* Must pass floats to libgcc functions as doubles.  */\n+#define LIBGCC_NEEDS_DOUBLE 1\n+\n+#define DIVSI3_LIBCALL \"*.div\"\n+#define UDIVSI3_LIBCALL \"*.udiv\"\n+#define REMSI3_LIBCALL \"*.rem\"\n+#define UREMSI3_LIBCALL \"*.urem\"\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 16\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Value is 1 if it generates better code to perform an unsigned comparison\n+   on the given literal integer value in the given mode when we are only\n+   looking for an equal/non-equal result.  */\n+/* For the i860, if the immediate value has its high-order 27 bits zero,\n+   then we want to engineer an unsigned comparison for EQ/NE because\n+   such values can fit in the 5-bit immediate field of a bte or btne\n+   instruction (which gets zero extended before comparing).  For all\n+   other immediate values on the i860, we will use signed compares\n+   because that avoids the need for doing explicit xor's to zero_extend\n+   the non-constant operand in cases where it was (mem:QI ...) or a\n+   (mem:HI ...) which always gets automatically sign-extended by the\n+   hardware upon loading.  */\n+\n+#define LITERAL_COMPARE_BETTER_UNSIGNED(intval, mode)                   \\\n+  (((unsigned) (intval) & 0x1f) == (unsigned) (intval))\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE SImode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE, OUTER_CODE)\t\t\t\\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if (INTVAL (RTX) == 0)\t\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\\\n+    if (INTVAL (RTX) < 0x2000 && INTVAL (RTX) >= -0x2000) return 1; \\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 4;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 6;\n+\n+/* Specify the cost of a branch insn; roughly the number of extra insns that\n+   should be added to avoid a branch.\n+\n+   Set this to 3 on the i860 since branches may often take three cycles.  */\n+\n+#define BRANCH_COST 3\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+\n+/* This holds the value sourcing h%r31.  We keep this info\n+   around so that mem/mem ops, such as increment and decrement,\n+   etc, can be performed reasonably.  */\n+#define CC_STATUS_MDEP rtx\n+\n+#define CC_STATUS_MDEP_INIT (cc_status.mdep = 0)\n+\n+#define CC_NEGATED\t01000\n+\n+/* We use this macro in those places in the i860.md file where we would\n+   normally just do a CC_STATUS_INIT (for other machines).  This macro\n+   differs from CC_STATUS_INIT in that it doesn't mess with the special\n+   bits or fields which describe what is currently in the special r31\n+   scratch register, but it does clear out everything that actually\n+   relates to the condition code bit of the i860.  */\n+\n+#define CC_STATUS_PARTIAL_INIT\t\t\t\t\t\t\\\n+ (cc_status.flags &= (CC_KNOW_HI_R31 | CC_HI_R31_ADJ),\t\t\t\\\n+  cc_status.value1 = 0,\t\t\t\t\t\t\t\\\n+  cc_status.value2 = 0)\n+\n+/* Nonzero if we know the value of h%r31.  */\n+#define CC_KNOW_HI_R31 0100000\n+\n+/* Nonzero if h%r31 is actually ha%something, rather than h%something.  */\n+#define CC_HI_R31_ADJ 0200000\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+/* On the i860, only compare insns set a useful condition code.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+{ cc_status.flags &= (CC_KNOW_HI_R31 | CC_HI_R31_ADJ);\t\\\n+  cc_status.value1 = 0; cc_status.value2 = 0; }\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Assembler pseudos to introduce constants of various size.  */\n+\n+#define ASM_DOUBLE \"\\t.double\"\n+\n+/* Output at beginning of assembler file.  */\n+/* The .file command should always begin the output.  */\n+\n+#define ASM_FILE_START(FILE)\n+#if 0\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+  do { output_file_directive ((FILE), main_input_filename);\t\\\n+       if (optimize) ASM_FILE_START_1 (FILE);\t\t\t\\\n+     } while (0)\n+#endif\n+\n+#define ASM_FILE_START_1(FILE)\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"\"\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \"\\t.data\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"sp\", \"fp\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\",\t\t\\\n+ \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\",\t\\\n+ \"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",\t\\\n+ \"r30\", \"r31\",\t\t\t\t\t\t\t\t\\\n+ \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \"f9\",\t\t\\\n+ \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\", \"f16\", \"f17\", \"f18\", \"f19\",\t\\\n+ \"f20\", \"f21\", \"f22\", \"f23\", \"f24\", \"f25\", \"f26\", \"f27\", \"f28\", \"f29\",\t\\\n+ \"f30\", \"f31\" }\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\t\t\t\t\\\n+  do { fputs (\".globl \", FILE);\t\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+\tfputs (\"\\n\", FILE);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* The prefix to add to user-visible assembler symbols.\n+\n+   This definition is overridden in i860v4.h because under System V\n+   Release 4, user-level symbols are *not* prefixed with underscores in\n+   the generated assembly code.  */\n+\n+#define USER_LABEL_PREFIX \"_\"\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to output an internal numbered label which\n+   labels a jump table.  */\n+\n+#undef ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, JUMPTABLE)\t\t\\\n+do { ASM_OUTPUT_ALIGN ((FILE), 2);\t\t\t\t\t\\\n+     ASM_OUTPUT_INTERNAL_LABEL ((FILE), PREFIX, NUM);\t\t\t\\\n+   } while (0)\n+\n+/* Output at the end of a jump table.  */\n+\n+#define ASM_OUTPUT_CASE_END(FILE,NUM,INSN)\t\\\n+  fprintf (FILE, \".text\\n\")\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*.%s%d\", PREFIX, NUM)\n+\n+/* This is how to output code to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\taddu -16,%ssp,%ssp\\n\\t%sst.l %s%s,0(%ssp)\\n\",\t\\\n+\ti860_reg_prefix, i860_reg_prefix,\t\t\t\t\\\n+\t((REGNO) < 32 ? \"\" : \"f\"),\t\t\t\t\t\\\n+\ti860_reg_prefix, reg_names[REGNO],\t\t\t\t\\\n+\ti860_reg_prefix)\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t%sld.l 0(%ssp),%s%s\\n\\taddu 16,%ssp,%ssp\\n\",\t\\\n+\t((REGNO) < 32 ? \"\" : \"f\"),\t\t\t\t\t\\\n+\ti860_reg_prefix,\t\t\t\t\t\t\\\n+\ti860_reg_prefix, reg_names[REGNO],\t\t\t\t\\\n+\ti860_reg_prefix, i860_reg_prefix)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.long .L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   (The i860 does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.blkb %u\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+\n+   In the following comments, the term \"constant address\" is used frequently.\n+   For an exact definition of what constitutes a \"constant address\" see the\n+   output_addr_const routine in final.c\n+\n+   On the i860, the following target-specific special codes are recognized:\n+\n+\t`r'\tThe operand can be anything, but if it is an immediate zero\n+\t\tvalue (either integer or floating point) then it will be\n+\t\trepresented as `r0' or as `f0' (respectively).\n+\n+\t`m'\tThe operand is a memory ref (to a constant address) but print\n+\t\tits address as a constant.\n+\n+\t`L'\tThe operand is a numeric constant, a constant address, or\n+\t\ta memory ref to a constant address.  Print the correct\n+\t\tnotation to yield the low part of the given value or\n+\t\taddress or the low part of the address of the referred\n+\t\tto memory object.\n+\n+\t`H'\tThe operand is a numeric constant, a constant address, or\n+\t\ta memory ref to a constant address.  Print the correct\n+\t\tnotation to yield the high part of the given value or\n+\t\taddress or the high part of the address of the referred\n+\t\tto memory object.\n+\n+\t`h'\tThe operand is a numeric constant, a constant address, or\n+\t\ta memory ref to a constant address.  Either print the\n+\t\tcorrect notation to yield the plain high part of the\n+\t\tgiven value or address (or the plain high part of the\n+\t\taddress of the memory object) or else print the correct\n+\t\tnotation to yield the \"adjusted\" high part of the given\n+\t\taddress (or of the address of the referred to memory object).\n+\n+\t\tThe choice of what to print depends upon whether the address\n+\t\tin question is relocatable or not.  If it is relocatable,\n+\t\tprint the notation to get the adjusted high part.  Otherwise\n+\t\tjust print the notation to get the plain high part.  Note\n+\t\tthat \"adjusted\" high parts are generally used *only* when\n+\t\tthe next following instruction uses the low part of the\n+\t\taddress as an offset, as in `offset(reg)'.\n+\n+\t`R'\tThe operand is a floating-pointer register.  Print the\n+\t\tname of the next following (32-bit) floating-point register.\n+\t\t(This is used when moving a value into just the most\n+\t\tsignificant part of a floating-point register pair.)\n+\n+\t`?'\t(takes no operand) Substitute the value of i860_reg_prefix\n+\t\tat this point.  The value of i860_reg_prefix is typically\n+\t\ta null string for most i860 targets, but for System V\n+\t\tRelease 4 the i860 assembler syntax requires that all\n+\t\tnames of registers be prefixed with a percent-sign, so\n+\t\tfor SVR4, the value of i860_reg_prefix is initialized to\n+\t\t\"%\" in i860.c.\n+*/\n+\n+extern const char *i860_reg_prefix;\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '?')\n+\n+/* The following macro definition is overridden in i860v4.h\n+   because the svr4 i860 assembler required a different syntax\n+   for getting parts of constant/relocatable values.  */\n+\n+#define PRINT_OPERAND_PART(FILE, X, PART_CODE)\t\t\t\t\\\n+  do { fprintf (FILE, \"%s%%\", PART_CODE);\t\t\t\t\\\n+\toutput_address (X);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define OPERAND_LOW_PART\t\"l\"\n+#define OPERAND_HIGH_PART\t\"h\"\n+/* NOTE: All documentation available for the i860 sez that you must\n+   use \"ha\" to get the relocated high part of a relocatable, but\n+   reality sez different.  */\n+#define OPERAND_HIGH_ADJ_PART\t\"ha\"\n+\n+#define PRINT_OPERAND(FILE, X, CODE)\t\t\t\t\t\\\n+{ if ((CODE) == '?')\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", i860_reg_prefix);\t\t\t\t\\\n+  else if (CODE == 'R')\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s%s\", i860_reg_prefix, reg_names[REGNO (X) + 1]);\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s%s\", i860_reg_prefix, reg_names[REGNO (X)]);\t\\\n+  else if ((CODE) == 'm')\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if ((CODE) == 'L')\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+\tPRINT_OPERAND_PART (FILE, XEXP (X, 0), OPERAND_LOW_PART);\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tPRINT_OPERAND_PART (FILE, X, OPERAND_LOW_PART);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if ((CODE) == 'H')\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+\tPRINT_OPERAND_PART (FILE, XEXP (X, 0), OPERAND_HIGH_PART);\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tPRINT_OPERAND_PART (FILE, X, OPERAND_HIGH_PART);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if ((CODE) == 'h')\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+\tPRINT_OPERAND_PART (FILE, XEXP (X, 0), OPERAND_HIGH_ADJ_PART);\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tPRINT_OPERAND_PART (FILE, X, OPERAND_HIGH_ADJ_PART);\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else if ((CODE) == 'r' && (X) == const0_rtx)\t\t\t\t\\\n+    fprintf (FILE, \"%sr0\", i860_reg_prefix);\t\t\t\t\\\n+  else if ((CODE) == 'r' && (X) == CONST0_RTX (GET_MODE (X)))\t\t\\\n+    fprintf (FILE, \"%sf0\", i860_reg_prefix);\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE)\t\t\t\t\\\n+    fprintf (FILE, \"0x%lx\", sfmode_constant_to_ulong (X));\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    output_addr_const (FILE, X); }\n+\f\n+/* Print a memory address as an operand to reference that memory location.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{ register rtx addr = ADDR;\t\t\t\t\t\\\n+  if (GET_CODE (addr) == REG)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"0(%s%s)\",\t\t\t\t\t\\\n+\ti860_reg_prefix, reg_names[REGNO (addr)]);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (addr) == CONST_DOUBLE\t\t\t\\\n+            && GET_MODE (addr) == SFmode)\t\t\t\\\n+    fprintf (FILE, \"0x%lx\", sfmode_constant_to_ulong (addr));\t\\\n+  else if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((GET_CODE (XEXP (addr, 0)) == CONST_INT)\t\t\\\n+\t  && (GET_CODE (XEXP (addr, 1)) == REG))\t\t\\\n+\tfprintf (FILE, \"%d(%s%s)\", INTVAL (XEXP (addr, 0)),\t\\\n+\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 1))]);\\\n+      else if ((GET_CODE (XEXP (addr, 1)) == CONST_INT)\t\t\\\n+\t  && (GET_CODE (XEXP (addr, 0)) == REG))\t\t\\\n+\tfprintf (FILE, \"%d(%s%s)\", INTVAL (XEXP (addr, 1)),\t\\\n+\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 0))]);\\\n+      else if ((GET_CODE (XEXP (addr, 0)) == REG)\t\t\\\n+\t  && (GET_CODE (XEXP (addr, 1)) == REG))\t\t\\\n+\tfprintf (FILE, \"%s%s(%s%s)\",\t\t\t\t\\\n+\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 0))],\t\\\n+\t    i860_reg_prefix, reg_names[REGNO (XEXP (addr, 1))]);\\\n+      else\t\t\t\t\t\t\t\\\n+\toutput_addr_const (FILE, addr);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      output_addr_const (FILE, addr);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Optionally define this if you have added predicates to\n+   `MACHINE.c'.  This macro is called within an initializer of an\n+   array of structures.  The first field in the structure is the\n+   name of a predicate and the second field is an array of rtl\n+   codes.  For each predicate, list all rtl codes that can be in\n+   expressions matched by the predicate.  The list should have a\n+   trailing comma.  Here is an example of two entries in the list\n+   for a typical RISC machine:\n+\n+   #define PREDICATE_CODES \\\n+     {\"gen_reg_rtx_operand\", {SUBREG, REG}},  \\\n+     {\"reg_or_short_cint_operand\", {SUBREG, REG, CONST_INT}},\n+\n+   Defining this macro does not affect the generated code (however,\n+   incorrect definitions that omit an rtl code that may be matched\n+   by the predicate can cause the compiler to malfunction). \n+   Instead, it allows the table built by `genrecog' to be more\n+   compact and efficient, thus speeding up the compiler.  The most\n+   important predicates to include in the list specified by this\n+   macro are thoses used in the most insn patterns.  */\n+\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+   {\"reg_or_0_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"arith_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"logic_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"shift_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"compare_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"arith_const_operand\",\t{CONST_INT}},\t\t\t\t\\\n+   {\"logic_const_operand\",\t{CONST_INT}},\t\t\t\t\\\n+   {\"bte_operand\",\t\t{REG, SUBREG, CONST_INT}},\t\t\\\n+   {\"indexed_operand\",\t\t{MEM}},\t\t\t\t\t\\\n+   {\"load_operand\",\t\t{MEM}},\t\t\t\t\t\\\n+   {\"small_int\",\t\t{CONST_INT}},\t\t\t\t\\\n+   {\"logic_int\",\t\t{CONST_INT}},\t\t\t\t\\\n+   {\"call_insn_operand\",\t{MEM}},\n+\n+/* Define the information needed to generate branch insns.  This is stored\n+   from the compare operation.  Note that we can't use \"rtx\" here since it\n+   hasn't been defined!  */\n+\n+extern struct rtx_def *i860_compare_op0, *i860_compare_op1;"}, {"sha": "b866c91386a20a32c5f5eb7cc02792c9baf4e50c", "filename": "gcc/config/i860/i860.md", "status": "added", "additions": 2327, "deletions": 0, "changes": 2327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -0,0 +1,2327 @@\n+;;- Machine description for Intel 860 chip for GNU C compiler\n+;;  Copyright (C) 1989, 1990, 1997, 1998, 1999, 2000\n+;;  Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n+;;- updates for most instructions.\n+\n+;;- Operand classes for the register allocator:\n+\f\n+/* Bit-test instructions.  */\n+\n+(define_insn \"\"\n+  [(set (cc0) (eq (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"logic_operand\" \"rL\"))\n+\t\t  (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and %1,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (ne (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"logic_operand\" \"rL\"))\n+\t\t  (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"and %1,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (eq (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+\t\t  (const_int 0)))]\n+  \"GET_CODE (operands[1]) == CONST_INT && (INTVAL (operands[1]) & 0xffff) == 0\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"andh %H1,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (ne (and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+\t\t  (const_int 0)))]\n+  \"GET_CODE (operands[1]) == CONST_INT && (INTVAL (operands[1]) & 0xffff) == 0\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"andh %H1,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (eq (ashiftrt:SI\n+\t\t   (sign_extend:SI\n+\t\t    (ashift:QI (match_operand:QI 0 \"register_operand\" \"r\")\n+\t\t\t       (match_operand:QI 1 \"logic_int\" \"n\")))\n+\t\t   (match_operand:SI 2 \"logic_int\" \"n\"))\n+\t\t  (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  int width = 8 - INTVAL (operands[2]);\n+  int pos = 8 - width - INTVAL (operands[1]);\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  operands[2] = GEN_INT (~((-1) << width) << pos);\n+  return \\\"and %2,%0,%?r0\\\";\n+}\")\n+\f\n+;; -------------------------------------------------------------------------\n+;; SImode signed integer comparisons\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"cmpeqsi\"\n+  [(set (cc0) (eq (match_operand:SI 0 \"logic_operand\" \"r,rL\")\n+\t\t  (match_operand:SI 1 \"logic_operand\" \"L,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[0]))\n+    return \\\"xor %1,%0,%?r0\\\";\n+  else\n+    return \\\"xor %0,%1,%?r0\\\";\n+}\")\n+\n+(define_insn \"cmpnesi\"\n+  [(set (cc0) (ne (match_operand:SI 0 \"logic_operand\" \"r,rL\")\n+\t\t  (match_operand:SI 1 \"logic_operand\" \"L,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  if (REG_P (operands[0]))\n+    return \\\"xor %1,%0,%?r0\\\";\n+  else\n+    return \\\"xor %0,%1,%?r0\\\";\n+}\")\n+\n+(define_insn \"cmpltsi\"\n+  [(set (cc0) (lt (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[1]))\n+    return \\\"subs %0,%1,%?r0\\\";\n+  else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      operands[1] = GEN_INT (- INTVAL (operands[1]));\n+      return \\\"adds %1,%0,%?r0\\\";\n+    }\n+}\")\n+\n+(define_insn \"cmpgtsi\"\n+  [(set (cc0) (gt (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[0]))\n+    return \\\"subs %1,%0,%?r0\\\";\n+  else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      operands[0] = GEN_INT (- INTVAL (operands[0]));\n+      return \\\"adds %0,%1,%?r0\\\";\n+    }\n+}\")\n+\n+(define_insn \"cmplesi\"\n+  [(set (cc0) (le (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  if (REG_P (operands[0]))\n+    return \\\"subs %1,%0,%?r0\\\";\n+  else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      operands[0] = GEN_INT (- INTVAL (operands[0]));\n+      return \\\"adds %0,%1,%?r0\\\";\n+    }\n+}\")\n+\n+(define_insn \"cmpgesi\"\n+  [(set (cc0) (ge (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  if (REG_P (operands[1]))\n+    return \\\"subs %0,%1,%?r0\\\";\n+  else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      operands[1] = GEN_INT (- INTVAL (operands[1]));\n+      return \\\"adds %1,%0,%?r0\\\";\n+    }\n+}\")\n+\n+;; -------------------------------------------------------------------------\n+;; SImode unsigned integer comparisons\n+;; -------------------------------------------------------------------------\n+\n+;; WARNING!  There is a small i860 hardware limitation (bug?) which we\n+;; may run up against (if we are not careful) when we are trying to do\n+;; unsigned comparisons like (x >= 0), (x < 0), (0 <= x), and (0 > x).\n+;; Specifically, we must avoid using an `addu' instruction to perform\n+;; such comparisons because the result (in the CC bit register) will\n+;; come out wrong.  (This fact is documented in a footnote on page 7-10\n+;; of the 1991 version of the i860 Microprocessor Family Programmer's\n+;; Reference Manual).  Note that unsigned comparisons of this sort are\n+;; always redundant anyway, because an unsigned quantity can never be\n+;; less than zero.  When we see cases like this, we generate an\n+;; `or K,%r0,%r0' instruction instead (where K is a constant 0 or -1)\n+;; so as to get the CC bit register set properly for any subsequent\n+;; conditional jump instruction.\n+\n+(define_insn \"cmpgeusi\"\n+  [(set (cc0) (geu (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t   (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[1]))\n+    return \\\"subu %0,%1,%?r0\\\";\n+  else\n+    {\n+      if (INTVAL (operands[1]) == 0)\n+\treturn \\\"or 0,%?r0,%?r0\\\";\n+      else\n+\t{\n+\t  cc_status.flags |= CC_REVERSED;\n+\t  operands[1] = GEN_INT (- INTVAL (operands[1]));\n+\t  return \\\"addu %1,%0,%?r0\\\";\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"cmpleusi\"\n+  [(set (cc0) (leu (match_operand:SI 0 \"arith_operand\" \"r,rI\")\n+\t\t   (match_operand:SI 1 \"arith_operand\" \"I,r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[0]))\n+    return \\\"subu %1,%0,%?r0\\\";\n+  else\n+    {\n+      if (INTVAL (operands[0]) == 0)\n+\treturn \\\"or 0,%?r0,%?r0\\\";\n+      else\n+\t{\n+\t  cc_status.flags |= CC_REVERSED;\n+\t  operands[0] = GEN_INT (- INTVAL (operands[0]));\n+\t  return \\\"addu %0,%1,%?r0\\\";\n+\t}\n+    }\n+}\")\n+\n+;; -------------------------------------------------------------------------\n+;; SFmode floating-point comparisons\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"cmpeqsf\"\n+  [(set (cc0) (eq (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfeq.ss %r0,%r1,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpnesf\"\n+  [(set (cc0) (ne (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfeq.ss %r1,%r0,%?f0\\\";\n+}\")\n+\n+;; NOTE:  The i860 Programmer's Reference Manual says that when we are\n+;; doing (A < B) or (A > B) comparisons, we have to use pfgt for these\n+;; in order to be IEEE compliant (in case a trap occurs during these\n+;; operations).  Conversely, for (A <= B) or (A >= B) comparisons, we\n+;; must use pfle to be IEEE compliant.\n+\n+(define_insn \"cmpltsf\"\n+  [(set (cc0) (lt (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfgt.ss %r1,%r0,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpgtsf\"\n+  [(set (cc0) (gt (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfgt.ss %r0,%r1,%?f0\\\";\n+}\")\n+\n+;; NOTE:  The pfle opcode doesn't do what you think it does.  It is\n+;; bass-ackwards.  It *clears* the CC flag if the first operand is\n+;; less than or equal to the second.  Thus, we have to set CC_NEGATED\n+;; for the following two patterns.\n+\n+(define_insn \"cmplesf\"\n+  [(set (cc0) (le (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfle.ss %r0,%r1,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpgesf\"\n+  [(set (cc0) (ge (match_operand:SF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:SF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfle.ss %r1,%r0,%?f0\\\";\n+}\")\n+\n+;; -------------------------------------------------------------------------\n+;; DFmode floating-point comparisons\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"cmpeqdf\"\n+  [(set (cc0) (eq (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfeq.dd %r0,%r1,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpnedf\"\n+  [(set (cc0) (ne (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfeq.dd %r1,%r0,%?f0\\\";\n+}\")\n+\n+;; NOTE:  The i860 Programmer's Reference Manual says that when we are\n+;; doing (A < B) or (A > B) comparisons, we have to use pfgt for these\n+;; in order to be IEEE compliant (in case a trap occurs during these\n+;; operations).  Conversely, for (A <= B) or (A >= B) comparisons, we\n+;; must use pfle to be IEEE compliant.\n+\n+(define_insn \"cmpltdf\"\n+  [(set (cc0) (lt (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfgt.dd %r1,%r0,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpgtdf\"\n+  [(set (cc0) (gt (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"pfgt.dd %r0,%r1,%?f0\\\";\n+}\")\n+\n+;; NOTE:  The pfle opcode doesn't do what you think it does.  It is\n+;; bass-ackwards.  It *clears* the CC flag if the first operand is\n+;; less than or equal to the second.  Thus, we have to set CC_NEGATED\n+;; for the following two patterns.\n+\n+(define_insn \"cmpledf\"\n+  [(set (cc0) (le (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfle.dd %r0,%r1,%?f0\\\";\n+}\")\n+\n+(define_insn \"cmpgedf\"\n+  [(set (cc0) (ge (match_operand:DF 0 \"reg_or_0_operand\" \"fG\")\n+\t\t  (match_operand:DF 1 \"reg_or_0_operand\" \"fG\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  cc_status.flags |= CC_NEGATED;\n+  return \\\"pfle.dd %r1,%r0,%?f0\\\";\n+}\")\n+\n+;; ------------------------------------------------------------------------\n+;; Integer EQ/NE comparisons against constant values which will fit in the\n+;; 16-bit immediate field of an instruction.  These are made by combining.\n+;; ------------------------------------------------------------------------\n+\n+(define_insn \"\"\n+  [(set (cc0) (eq (zero_extend:SI (match_operand:HI 0 \"load_operand\" \"m\"))\n+\t          (match_operand:SI 1 \"small_int\" \"I\")))]\n+  \"INTVAL (operands[1]) >= 0\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"ld.s %0,%?r31\\;xor %1,%?r31,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (eq (match_operand:SI 0 \"small_int\" \"I\")\n+\t          (zero_extend:SI (match_operand:HI 1 \"load_operand\" \"m\"))))]\n+  \"INTVAL (operands[0]) >= 0\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"ld.s %1,%?r31\\;xor %0,%?r31,%?r0\\\";\n+}\")\n+\f\n+;; ------------------------------------------------------------------------\n+;; Define the real conditional branch instructions.\n+;; ------------------------------------------------------------------------\n+\n+(define_insn \"cbranch\"\n+  [(set (pc) (if_then_else (eq (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n+    return \\\"bnc %l0\\\";\n+  else\n+    return \\\"bc %l0\\\";\n+}\")\n+\n+(define_insn \"flipped_cbranch\"\n+  [(set (pc) (if_then_else (ne (cc0)\n+\t\t\t       (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n+    return \\\"bnc %l0\\\";\n+  else\n+    return \\\"bc %l0\\\";\n+}\")\n+\n+(define_insn \"inverse_cbranch\"\n+  [(set (pc) (if_then_else (eq (cc0)\n+\t\t\t       (const_int 0))\n+\t\t\t   (pc)\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n+    return \\\"bc %l0\\\";\n+  else\n+    return \\\"bnc %l0\\\";\n+}\")\n+\n+\n+(define_insn \"flipped_inverse_cbranch\"\n+  [(set (pc) (if_then_else (ne (cc0)\n+\t\t\t       (const_int 0))\n+\t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t   (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if ((cc_prev_status.flags & CC_NEGATED) == 0)\n+    return \\\"bc %l0\\\";\n+  else\n+    return \\\"bnc %l0\\\";\n+}\")\n+\n+;; Simple BTE/BTNE compare-and-branch insns made by combining.\n+;; Note that it is wrong to add similar patterns for QI or HImode\n+;; because bte/btne always compare the whole register.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"bte %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"btne %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"btne %1,%0,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"bte_operand\" \"rK\"))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"bte %1,%0,%2\")\n+\n+;; Load byte/halfword, zero-extend, & compare-and-branch insns.\n+;; These are made by combining.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.b %0,%3;bte %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.b %0,%3;btne %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (pc)\n+                      (label_ref (match_operand 2 \"\" \"\"))))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.b %0,%3;btne %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (pc)\n+                      (label_ref (match_operand 2 \"\" \"\"))))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.b %0,%3;bte %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.s %0,%3;bte %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (label_ref (match_operand 2 \"\" \"\"))\n+                      (pc)))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.s %0,%3;btne %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (eq (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (pc)\n+                      (label_ref (match_operand 2 \"\" \"\"))))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.s %0,%3;btne %1,%3,%2\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+        (if_then_else (ne (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"m\"))\n+                          (match_operand:SI 1 \"bte_operand\" \"K\"))\n+                      (pc)\n+                      (label_ref (match_operand 2 \"\" \"\"))))\n+   (match_scratch:SI 3 \"=r\")]\n+  \"\"\n+  \"ld.s %0,%3;bte %1,%3,%2\")\n+\n+\f\n+;; Generation of conditionals.\n+\n+;; We save the compare operands in the cmpxx patterns and use then when\n+;; we generate the branch.\n+\n+(define_expand \"cmpsi\"\n+  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t       (match_operand:SI 1 \"compare_operand\" \"\")))]\n+  \"\"\n+  \"\n+{ i860_compare_op0 = operands[0];\n+  i860_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpsf\"\n+  [(set (cc0) (compare (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t       (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{ i860_compare_op0 = operands[0];\n+  i860_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpdf\"\n+  [(set (cc0) (compare (match_operand:DF 0 \"register_operand\" \"\")\n+\t\t       (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{ i860_compare_op0 = operands[0];\n+  i860_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+;; These are the standard-named conditional branch patterns.\n+;; Detailed comments are found in the first one only.\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  /* Emit a single-condition compare insn according to\n+     the type of operands and the condition to be tested.  */\n+\n+  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n+    emit_insn (gen_cmpeqsi (i860_compare_op0, i860_compare_op1));\n+  else if (GET_MODE (i860_compare_op0) == SFmode)\n+    emit_insn (gen_cmpeqsf (i860_compare_op0, i860_compare_op1));\n+  else if (GET_MODE (i860_compare_op0) == DFmode)\n+    emit_insn (gen_cmpeqdf (i860_compare_op0, i860_compare_op1));\n+  else\n+    abort ();\n+\n+  /* Emit branch-if-true.  */\n+\n+  emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n+  DONE;\n+}\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n+    emit_insn (gen_cmpeqsi (i860_compare_op0, i860_compare_op1));\n+  else if (GET_MODE (i860_compare_op0) == SFmode)\n+    emit_insn (gen_cmpeqsf (i860_compare_op0, i860_compare_op1));\n+  else if (GET_MODE (i860_compare_op0) == DFmode)\n+    emit_insn (gen_cmpeqdf (i860_compare_op0, i860_compare_op1));\n+  else\n+    abort ();\n+\n+  emit_jump_insn (gen_flipped_cbranch (operands[0]));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n+    emit_insn (gen_cmpgtsi (i860_compare_op0, i860_compare_op1));\n+  else if (GET_MODE (i860_compare_op0) == SFmode)\n+    emit_insn (gen_cmpgtsf (i860_compare_op0, i860_compare_op1));\n+  else if (GET_MODE (i860_compare_op0) == DFmode)\n+    emit_insn (gen_cmpgtdf (i860_compare_op0, i860_compare_op1));\n+  else\n+    abort ();\n+\n+  emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n+  DONE;\n+}\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n+    emit_insn (gen_cmpltsi (i860_compare_op0, i860_compare_op1));\n+  else if (GET_MODE (i860_compare_op0) == SFmode)\n+    emit_insn (gen_cmpltsf (i860_compare_op0, i860_compare_op1));\n+  else if (GET_MODE (i860_compare_op0) == DFmode)\n+    emit_insn (gen_cmpltdf (i860_compare_op0, i860_compare_op1));\n+  else\n+    abort ();\n+\n+  emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n+  DONE;\n+}\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n+    {\n+      emit_insn (gen_cmpgtsi (i860_compare_op0, i860_compare_op1));\n+      emit_jump_insn (gen_flipped_cbranch (operands[0]));\n+    }\n+  else\n+    {\n+      if (GET_MODE (i860_compare_op0) == SFmode)\n+\temit_insn (gen_cmplesf (i860_compare_op0, i860_compare_op1));\n+      else if (GET_MODE (i860_compare_op0) == DFmode)\n+\temit_insn (gen_cmpledf (i860_compare_op0, i860_compare_op1));\n+      else\n+\tabort ();\n+      emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n+    }\n+  DONE;\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) == MODE_INT)\n+    {\n+      emit_insn (gen_cmpltsi (i860_compare_op0, i860_compare_op1));\n+      emit_jump_insn (gen_flipped_cbranch (operands[0]));\n+    }\n+  else\n+    {\n+      if (GET_MODE (i860_compare_op0) == SFmode)\n+\temit_insn (gen_cmpgesf (i860_compare_op0, i860_compare_op1));\n+      else if (GET_MODE (i860_compare_op0) == DFmode)\n+\temit_insn (gen_cmpgedf (i860_compare_op0, i860_compare_op1));\n+      else\n+\tabort ();\n+      emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n+    }\n+  DONE;\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) != MODE_INT)\n+    abort ();\n+\n+  emit_insn (gen_cmpleusi (i860_compare_op0, i860_compare_op1));\n+  emit_jump_insn (gen_flipped_cbranch (operands[0]));\n+  DONE;\n+}\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) != MODE_INT)\n+    abort ();\n+\n+  emit_insn (gen_cmpgeusi (i860_compare_op0, i860_compare_op1));\n+  emit_jump_insn (gen_flipped_cbranch (operands[0]));\n+  DONE;\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) != MODE_INT)\n+    abort ();\n+\n+  emit_insn (gen_cmpgeusi (i860_compare_op0, i860_compare_op1));\n+  emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n+  DONE;\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  if (GET_MODE_CLASS (GET_MODE (i860_compare_op0)) != MODE_INT)\n+    abort ();\n+\n+  emit_insn (gen_cmpleusi (i860_compare_op0, i860_compare_op1));\n+  emit_jump_insn (gen_flipped_inverse_cbranch (operands[0]));\n+  DONE;\n+}\")\n+\f\n+;; Move instructions\n+\n+;; Note that source operands for `mov' pseudo-instructions are no longer\n+;; allowed (by the svr4 assembler) to be \"big\" things, i.e. constants that\n+;; won't fit in 16-bits.  (This includes any sort of a relocatable address\n+;; also.)  Thus, we must use an explicit orh/or pair of instructions if\n+;; the source operand is something \"big\".\n+\n+(define_insn \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r,m,f\")\n+\t(match_operand:SI 1 \"general_operand\" \"rmif,rfJ,rmfJ\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\treturn output_store (operands);\n+      if (FP_REG_P (operands[1]))\n+\treturn \\\"fst.l %1,%0\\\";\n+      return \\\"st.l %r1,%0\\\";\n+    }\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\treturn output_load (operands);\n+      if (FP_REG_P (operands[0]))\n+\treturn \\\"fld.l %1,%0\\\";\n+      return \\\"ld.l %1,%0\\\";\n+    }\n+  if (FP_REG_P (operands[1]) && FP_REG_P (operands[0]))\n+    return \\\"fmov.ss %1,%0\\\";\n+  if (FP_REG_P (operands[1]))\n+    return \\\"fxfr %1,%0\\\";\n+  if (FP_REG_P (operands[0]) && operands[1] == const0_rtx)\n+    return \\\"fmov.ss %?f0,%0\\\";\n+  if (FP_REG_P (operands[0]))\n+    return \\\"ixfr %1,%0\\\";\n+\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"shl %?r0,%1,%0\\\";\n+\n+  CC_STATUS_PARTIAL_INIT;\n+\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if((INTVAL (operands[1]) & 0xffff0000) == 0)\n+        return \\\"or %L1,%?r0,%0\\\";\n+      if((INTVAL (operands[1]) & 0x0000ffff) == 0)\n+        return \\\"orh %H1,%?r0,%0\\\";\n+    }\n+  return \\\"orh %H1,%?r0,%0\\;or %L1,%0,%0\\\";\n+}\")\n+ \n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,m,!*f,!r\")\n+\t(match_operand:HI 1 \"general_operand\" \"rmi,rJ,rJ*f,*f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\treturn output_store (operands);\n+      return \\\"st.s %r1,%0\\\";\n+    }\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\treturn output_load (operands);\n+      return \\\"ld.s %1,%0\\\";\n+    }\n+  if (FP_REG_P (operands[1]) && FP_REG_P (operands[0]))\n+    return \\\"fmov.ss %1,%0\\\";\n+  if (FP_REG_P (operands[1]))\n+    return \\\"fxfr %1,%0\\\";\n+  if (FP_REG_P (operands[0]) && operands[1] == const0_rtx)\n+    return \\\"fmov.ss %?f0,%0\\\";\n+  if (FP_REG_P (operands[0]))\n+    return \\\"ixfr %1,%0\\\";\n+\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"shl %?r0,%1,%0\\\";\n+\n+  CC_STATUS_PARTIAL_INIT;\n+\n+  return \\\"or %L1,%?r0,%0\\\";\n+}\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,m,!*f,!r\")\n+\t(match_operand:QI 1 \"general_operand\" \"rmi,rJ,rJ*f,*f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\treturn output_store (operands);\n+      return \\\"st.b %r1,%0\\\";\n+    }\n+  if (GET_CODE (operands[1]) == MEM)\n+    {\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\treturn output_load (operands);\n+      return \\\"ld.b %1,%0\\\";\n+    }\n+  if (FP_REG_P (operands[1]) && FP_REG_P (operands[0]))\n+    return \\\"fmov.ss %1,%0\\\";\n+  if (FP_REG_P (operands[1]))\n+    return \\\"fxfr %1,%0\\\";\n+  if (FP_REG_P (operands[0]) && operands[1] == const0_rtx)\n+    return \\\"fmov.ss %?f0,%0\\\";\n+  if (FP_REG_P (operands[0]))\n+    return \\\"ixfr %1,%0\\\";\n+\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"shl %?r0,%1,%0\\\";\n+\n+  CC_STATUS_PARTIAL_INIT;\n+\n+  return \\\"or %L1,%?r0,%0\\\";\n+}\")\n+\n+;; The definition of this insn does not really explain what it does,\n+;; but it should suffice\n+;; that anything generated as this insn will be recognized as one\n+;; and that it won't successfully combine with anything.\n+(define_expand \"movstrsi\"\n+  [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"general_operand\" \"\"))\n+\t      (use (match_operand:SI 2 \"nonmemory_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_dup 5))\n+\t      (clobber (match_dup 6))\n+\t      (clobber (match_dup 7))\n+\t      (clobber (match_dup 8))])]\n+  \"\"\n+  \"\n+{\n+  operands[4] = gen_reg_rtx (SImode);\n+  operands[5] = gen_reg_rtx (SImode);\n+  operands[6] = gen_reg_rtx (SImode);\n+  operands[7] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n+  operands[8] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n+\n+  operands[0] = replace_equiv_address (operands[0], operands[7]);\n+  operands[1] = replace_equiv_address (operands[1], operands[8]);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (use (match_operand:SI 2 \"general_operand\" \"rn\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n+   (clobber (match_operand:SI 4 \"register_operand\" \"=r\"))\n+   (clobber (match_operand:SI 5 \"register_operand\" \"=r\"))\n+   (clobber (match_operand:SI 6 \"register_operand\" \"=r\"))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"* return output_block_move (operands);\")\n+\f\n+;; Floating point move insns\n+\n+;; This pattern forces (set (reg:DF ...) (const_double ...))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general movdf pattern.\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=r,f,o\")\n+\t(match_operand:DF 1 \"\" \"mG,m,G\"))]\n+  \"GET_CODE (operands[1]) == CONST_DOUBLE\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]) || operands[1] == CONST0_RTX (DFmode))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=*rm,*r,?f,?*rm\")\n+\t(match_operand:DF 1 \"general_operand\" \"*r,m,*rfmG,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+    return output_store (operands);\n+  if (GET_CODE (operands[1]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    return output_load (operands);\n+\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=rm,r,?f,?rm\")\n+\t(match_operand:DI 1 \"general_operand\" \"r,miF,rfmG,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+    return output_store (operands);\n+  if (GET_CODE (operands[1]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    return output_load (operands);\n+\n+  /* ??? How can we have a DFmode arg here with DImode above? */\n+  if (FP_REG_P (operands[0]) && operands[1] == CONST0_RTX (DFmode))\n+    return \\\"fmov.dd %?f0,%0\\\";\n+\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\")\n+\n+;; The alternative m/r is separate from m/f\n+;; The first alternative is separate from the second for the same reason.\n+(define_insn \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=*rf,*rf,*r,m,m\")\n+\t(match_operand:SF 1 \"general_operand\" \"*r,fmG,F,*r,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+    return output_store (operands);\n+  if (GET_CODE (operands[1]) == MEM\n+      && CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    return output_load (operands);\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \\\"fmov.ss %1,%0\\\";\n+      if (GET_CODE (operands[1]) == REG)\n+\treturn \\\"ixfr %1,%0\\\";\n+      if (operands[1] == CONST0_RTX (SFmode))\n+        return \\\"fmov.ss %?f0,%0\\\";\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && cc_prev_status.mdep == XEXP(operands[1],0)))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t      cc_status.mdep = XEXP (operands[1], 0);\n+\t      return \\\"orh %h1,%?r0,%?r31\\;fld.l %L1(%?r31),%0\\\";\n+\t    }\n+\t  return \\\"fld.l %L1(%?r31),%0\\\";\n+\t}\n+      return \\\"fld.l %1,%0\\\";\n+    }\n+  if (FP_REG_P (operands[1]) || GET_CODE (operands[1]) == CONST_DOUBLE)\n+    {\n+      if (GET_CODE (operands[0]) == REG && FP_REG_P (operands[1]))\n+\treturn \\\"fxfr %1,%0\\\";\n+      if (GET_CODE (operands[0]) == REG)\n+\t{\n+\t  CC_STATUS_PARTIAL_INIT;\n+\t  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    {\n+\t      register unsigned long ul;\n+\n+              ul = sfmode_constant_to_ulong (operands[1]);\n+\t      if ((ul & 0x0000ffff) == 0)\n+\t\treturn \\\"orh %H1,%?r0,%0\\\";\n+\t      if ((ul & 0xffff0000) == 0)\n+\t\treturn \\\"or %L1,%?r0,%0\\\";\n+\t    }\n+          return \\\"orh %H1,%?r0,%0\\;or %L1,%0,%0\\\";\n+\t}\n+      /* Now operand 0 must be memory.\n+         If operand 1 is CONST_DOUBLE, its value must be 0.  */\n+      if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+\t{\n+\t  if (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t\t && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t\t && XEXP (operands[0], 0) == cc_prev_status.mdep))\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t      cc_status.mdep = XEXP (operands[0], 0);\n+\t      output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n+\t    }\n+\t  return \\\"fst.l %r1,%L0(%?r31)\\\";\n+\t}\n+      return \\\"fst.l %r1,%0\\\";\n+    }\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \\\"st.l %r1,%0\\\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \\\"ld.l %1,%0\\\";\n+  if (operands[1] == CONST0_RTX (SFmode))\n+    return \\\"shl %?r0,%?r0,%0\\\";\n+  return \\\"mov %1,%0\\\";\n+}\")\n+\f\n+;; Special load insns for REG+REG addresses.\n+;; Such addresses are not \"legitimate\" because st rejects them.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=rf\")\n+\t(match_operand:DF 1 \"indexed_operand\" \"m\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=rf\")\n+\t(match_operand:SF 1 \"indexed_operand\" \"m\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    return \\\"fld.l %1,%0\\\";\n+  return \\\"ld.l %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+\t(match_operand:SI 1 \"indexed_operand\" \"m\"))]\n+  \"\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    return \\\"fld.l %1,%0\\\";\n+  return \\\"ld.l %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_operand:HI 1 \"indexed_operand\" \"m\"))]\n+  \"\"\n+  \"ld.s %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(match_operand:QI 1 \"indexed_operand\" \"m\"))]\n+  \"\"\n+  \"ld.b %1,%0\")\n+\n+;; Likewise for floating-point store insns.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"indexed_operand\" \"=m\")\n+\t(match_operand:DF 1 \"register_operand\" \"f\"))]\n+  \"\"\n+  \"fst.d %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"indexed_operand\" \"=m\")\n+\t(match_operand:SF 1 \"register_operand\" \"f\"))]\n+  \"\"\n+  \"fst.l %1,%0\")\n+\f\n+;;- truncation instructions\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(truncate:QI\n+\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+  {\n+    if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+      {\n+\tif (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t       && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t       && XEXP (operands[0], 0) == cc_prev_status.mdep))\n+\t  {\n+\t    CC_STATUS_INIT;\n+\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t    cc_status.mdep = XEXP (operands[0], 0);\n+\t    output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n+\t  }\n+\treturn \\\"st.b %1,%L0(%?r31)\\\";\n+      }\n+    else\n+      return \\\"st.b %1,%0\\\";\n+  }\n+  return \\\"shl %?r0,%1,%0\\\";\n+}\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n+\t(truncate:QI\n+\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+  {\n+    if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+      {\n+\tif (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t       && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t       && XEXP (operands[0], 0) == cc_prev_status.mdep))\n+\t  {\n+\t    CC_STATUS_INIT;\n+\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t    cc_status.mdep = XEXP (operands[0], 0);\n+\t    output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n+\t  }\n+\treturn \\\"st.b %1,%L0(%?r31)\\\";\n+      }\n+    else\n+      return \\\"st.b %1,%0\\\";\n+  }\n+  return \\\"shl %?r0,%1,%0\\\";\n+}\")\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(truncate:HI\n+\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+  {\n+    if (CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+      {\n+\tif (! ((cc_prev_status.flags & CC_KNOW_HI_R31)\n+\t       && (cc_prev_status.flags & CC_HI_R31_ADJ)\n+\t       && XEXP (operands[0], 0) == cc_prev_status.mdep))\n+\t  {\n+\t    CC_STATUS_INIT;\n+\t    cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+\t    cc_status.mdep = XEXP (operands[0], 0);\n+\t    output_asm_insn (\\\"orh %h0,%?r0,%?r31\\\", operands);\n+\t  }\n+\treturn \\\"st.s %1,%L0(%?r31)\\\";\n+      }\n+    else\n+      return \\\"st.s %1,%0\\\";\n+  }\n+  return \\\"shl %?r0,%1,%0\\\";\n+}\")\n+\f\n+;;- zero extension instructions\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and 0xffff,%1,%0\\\";\n+}\")\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI\n+\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and 0xff,%1,%0\\\";\n+}\")\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and 0xff,%1,%0\\\";\n+}\")\n+\f\n+;; Sign extension instructions.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t (match_operand:HI 1 \"indexed_operand\" \"m\")))]\n+  \"\"\n+  \"ld.s %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI\n+\t (match_operand:QI 1 \"indexed_operand\" \"m\")))]\n+  \"\"\n+  \"ld.b %1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t (match_operand:QI 1 \"indexed_operand\" \"m\")))]\n+  \"\"\n+  \"ld.b %1,%0\")\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \"mr\")))]\n+  \"\"\n+  \"*\n+{\n+  if (REG_P (operands[1]))\n+    return \\\"shl 16,%1,%0\\;shra 16,%0,%0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    abort ();\n+  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    {\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+      cc_status.mdep = XEXP (operands[1], 0);\n+      return \\\"orh %h1,%?r0,%?r31\\;ld.s %L1(%?r31),%0\\\";\n+    }\n+  else\n+    return \\\"ld.s %1,%0\\\";\n+}\")\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"mr\")))]\n+  \"\"\n+  \"*\n+{\n+  if (REG_P (operands[1]))\n+    return \\\"shl 24,%1,%0\\;shra 24,%0,%0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    abort ();\n+  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    {\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+      cc_status.mdep = XEXP (operands[1], 0);\n+      return \\\"orh %h1,%?r0,%?r31\\;ld.b %L1(%?r31),%0\\\";\n+    }\n+  else\n+    return \\\"ld.b %1,%0\\\";\n+}\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"mr\")))]\n+  \"\"\n+  \"*\n+{\n+  if (REG_P (operands[1]))\n+    return \\\"shl 24,%1,%0\\;shra 24,%0,%0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    abort ();\n+  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    {\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+      cc_status.mdep = XEXP (operands[1], 0);\n+      return \\\"orh %h1,%?r0,%?r31\\;ld.b %L1(%?r31),%0\\\";\n+    }\n+  else\n+    return \\\"ld.b %1,%0\\\";\n+}\")\n+\n+;; Signed bitfield extractions come out looking like\n+;;\t(shiftrt (sign_extend (shift <Y> <C1>)) <C2>)\n+;; which we expand poorly as four shift insns.\n+;; These patterns yield two shifts:\n+;;\t(shiftrt (shift <Y> <C3>) <C4>)\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI\n+\t (sign_extend:SI\n+\t  (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t (match_operand:SI 2 \"logic_int\" \"n\")))]\n+  \"INTVAL (operands[2]) < 8\"\n+  \"*\n+{\n+  return \\\"shl 24,%1,%0\\;shra 24+%2,%0,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI\n+\t (sign_extend:SI\n+\t  (subreg:QI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t(match_operand:SI 2 \"logic_int\" \"n\")) 0))\n+\t (match_operand:SI 3 \"logic_int\" \"n\")))]\n+  \"INTVAL (operands[3]) < 8\"\n+  \"*\n+{\n+  return \\\"shl 0x18+%2,%1,%0\\;shra 0x18+%3,%0,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI\n+\t (sign_extend:SI\n+\t  (ashift:QI (match_operand:QI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:QI 2 \"logic_int\" \"n\")))\n+\t (match_operand:SI 3 \"logic_int\" \"n\")))]\n+  \"INTVAL (operands[3]) < 8\"\n+  \"*\n+{\n+  return \\\"shl 0x18+%2,%1,%0\\;shra 0x18+%3,%0,%0\\\";\n+}\")\n+\f\n+;; Special patterns for optimizing bit-field instructions.\n+\n+;; First two patterns are for bitfields that came from memory\n+;; testing only the high bit.  They work with old combiner.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(eq (zero_extend:SI (subreg:QI (lshiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t\t\t    (const_int 7)) 0))\n+\t    (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and 128,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(eq (sign_extend:SI (subreg:QI (ashiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t\t\t    (const_int 7)) 0))\n+\t    (const_int 0)))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"and 128,%0,%?r0\\\";\n+}\")\n+\n+;; next two patterns are good for bitfields coming from memory\n+;; (via pseudo-register) or from a register, though this optimization\n+;; is only good for values contained wholly within the bottom 13 bits\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(eq \n+\t (and:SI (lshiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 1 \"logic_int\" \"n\"))\n+\t\t (match_operand:SI 2 \"logic_int\" \"n\"))\n+\t (const_int 0)))]\n+  \"LOGIC_INTVAL (INTVAL (operands[2]) << INTVAL (operands[1]))\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  operands[2] = GEN_INT (INTVAL (operands[2]) << INTVAL (operands[1]));\n+  return \\\"and %2,%0,%?r0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(eq \n+\t (and:SI (ashiftrt:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (match_operand:SI 1 \"logic_int\" \"n\"))\n+\t\t (match_operand:SI 2 \"logic_int\" \"n\"))\n+\t (const_int 0)))]\n+  \"LOGIC_INTVAL (INTVAL (operands[2]) << INTVAL (operands[1]))\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  operands[2] = GEN_INT (INTVAL (operands[2]) << INTVAL (operands[1]));\n+  return \\\"and %2,%0,%?r0\\\";\n+}\")\n+\f\n+;; Conversions between float and double.\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float_extend:DF\n+\t (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmov.sd %1,%0\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float_truncate:SF\n+\t (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmov.ds %1,%0\")\n+\f\n+;; Conversion between fixed point and floating point.\n+;; Note that among the fix-to-float insns\n+;; the ones that start with SImode come first.\n+;; That is so that an operand that is a CONST_INT\n+;; (and therefore lacks a specific machine mode).\n+;; will be recognized as SImode (which is always valid)\n+;; rather than as QImode or HImode.\n+\n+;; This pattern forces (set (reg:SF ...) (float:SF (const_int ...)))\n+;; to be reloaded by putting the constant into memory.\n+;; It must come before the more general floatsisf2 pattern.\n+(define_expand \"floatsidf2\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t      (const_int -2147483648)))\n+   (set (match_dup 5) (match_dup 3))\n+   (set (subreg:SI (match_dup 5) 0) (match_dup 4))\n+   (set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(minus:DF (match_dup 5) (match_dup 2)))]\n+  \"\"\n+  \"\n+{\n+  REAL_VALUE_TYPE d;\n+  /* 4503601774854144 is  (1 << 30) * ((1 << 22) + (1 << 1)).  */\n+  d = REAL_VALUE_ATOF (\\\"4503601774854144\\\", DFmode);\n+  operands[2] = gen_reg_rtx (DFmode);\n+  operands[3] = CONST_DOUBLE_FROM_REAL_VALUE (d, DFmode);\n+  operands[4] = gen_reg_rtx (SImode);\n+  operands[5] = gen_reg_rtx (DFmode);\n+}\")\n+\f\n+;; Floating to fixed conversion.\n+\n+(define_expand \"fix_truncdfsi2\"\n+  ;; This first insn produces a double-word value\n+  ;; in which only the low word is valid.\n+  [(set (match_dup 2)\n+\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(subreg:SI (match_dup 2) 0))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n+}\")\n+\n+;; Recognize the first insn generated above.\n+;; This RTL looks like a fix_truncdfdi2 insn,\n+;; but we don't call it that, because only 32 bits\n+;; of the result are valid.\n+;; This pattern will work for the intended purposes \n+;; as long as we do not have any fixdfdi2 or fix_truncdfdi2.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(fix:DI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n+  \"\"\n+  \"ftrunc.dd %1,%0\")\n+\n+(define_expand \"fix_truncsfsi2\"\n+  ;; This first insn produces a double-word value\n+  ;; in which only the low word is valid.\n+  [(set (match_dup 2)\n+\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(subreg:SI (match_dup 2) 0))]\n+  \"\"\n+  \"\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n+}\")\n+\n+;; Recognize the first insn generated above.\n+;; This RTL looks like a fix_truncsfdi2 insn,\n+;; but we don't call it that, because only 32 bits\n+;; of the result are valid.\n+;; This pattern will work for the intended purposes \n+;; as long as we do not have any fixsfdi2 or fix_truncsfdi2.\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(fix:DI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n+  \"\"\n+  \"ftrunc.sd %1,%0\")\n+\f\n+;;- arithmetic instructions\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,*f\")\n+\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r,*f\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI,*f\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 1)\n+    return \\\"fiadd.ss %2,%1,%0\\\";\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"addu %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%f\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fiadd.dd %1,%2,%0\")\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,*f\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r,I,*f\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"rI,r,*f\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 2)\n+    return \\\"fisub.ss %1,%2,%0\\\";\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[2]))\n+    return \\\"subu %1,%2,%0\\\";\n+  operands[2] = GEN_INT (- INTVAL (operands[2]));\n+  return \\\"addu %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:DI 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fisub.dd %1,%2,%0\")\n+\n+(define_expand \"mulsi3\"\n+  [(set (subreg:SI (match_dup 4) 0) (match_operand:SI 1 \"general_operand\" \"\"))\n+   (set (subreg:SI (match_dup 5) 0) (match_operand:SI 2 \"general_operand\" \"\"))\n+   (clobber (match_dup 3))\n+   (set (subreg:SI (match_dup 3) 0)\n+\t(mult:SI (subreg:SI (match_dup 4) 0) (subreg:SI (match_dup 5) 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\") (subreg:SI (match_dup 3) 0))]\n+  \"\"\n+  \"\n+{\n+  if (WORDS_BIG_ENDIAN)\n+    emit_insn (gen_mulsi3_big (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_mulsi3_little (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"mulsi3_little\"\n+  [(set (subreg:SI (match_dup 4) 0) (match_operand:SI 1 \"general_operand\" \"\"))\n+   (set (subreg:SI (match_dup 5) 0) (match_operand:SI 2 \"general_operand\" \"\"))\n+   (clobber (match_dup 3))\n+   (set (subreg:SI (match_dup 3) 0)\n+\t(mult:SI (subreg:SI (match_dup 4) 0) (subreg:SI (match_dup 5) 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\") (subreg:SI (match_dup 3) 0))]\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"\n+{\n+  operands[3] = gen_reg_rtx (DImode);\n+  operands[4] = gen_reg_rtx (DImode);\n+  operands[5] = gen_reg_rtx (DImode);\n+}\")\n+\n+(define_expand \"mulsi3_big\"\n+  [(set (subreg:SI (match_dup 4) 4) (match_operand:SI 1 \"general_operand\" \"\"))\n+   (set (subreg:SI (match_dup 5) 4) (match_operand:SI 2 \"general_operand\" \"\"))\n+   (clobber (match_dup 3))\n+   (set (subreg:SI (match_dup 3) 4)\n+\t(mult:SI (subreg:SI (match_dup 4) 4) (subreg:SI (match_dup 5) 4)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\") (subreg:SI (match_dup 3) 4))]\n+  \"WORDS_BIG_ENDIAN\"\n+  \"\n+{\n+  operands[3] = gen_reg_rtx (DImode);\n+  operands[4] = gen_reg_rtx (DImode);\n+  operands[5] = gen_reg_rtx (DImode);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=f\") 0)\n+\t(mult:SI (subreg:SI (match_operand:DI 1 \"register_operand\" \"f\") 0)\n+\t\t (subreg:SI (match_operand:DI 2 \"register_operand\" \"f\") 0)))]\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"fmlow.dd %2,%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=f\") 4)\n+\t(mult:SI (subreg:SI (match_operand:DI 1 \"register_operand\" \"f\") 4)\n+\t\t (subreg:SI (match_operand:DI 2 \"register_operand\" \"f\") 4)))]\n+  \"WORDS_BIG_ENDIAN\"\n+  \"fmlow.dd %2,%1,%0\")\n+\f\n+;;- and instructions (with compliment also)\t\t\t   \n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rL\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xop[3];\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[2]) || LOGIC_INT (operands[2]))\n+    return \\\"and %2,%1,%0\\\";\n+  if ((INTVAL (operands[2]) & 0xffff) == 0)\n+    {\n+      operands[2]\n+\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n+      return \\\"andh %2,%1,%0\\\";\n+    }\n+  xop[0] = operands[0];\n+  xop[1] = operands[1];\n+  xop[2] = GEN_INT (~INTVAL (operands[2]) & 0xffff);\n+  output_asm_insn (\\\"andnot %2,%1,%0\\\", xop);\n+  operands[2] = GEN_INT (~(unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n+  return \\\"andnoth %2,%0,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"rn\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xop[3];\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[1]) || LOGIC_INT (operands[1]))\n+    return \\\"andnot %1,%2,%0\\\";\n+  if ((INTVAL (operands[1]) & 0xffff) == 0)\n+    {\n+      operands[1]\n+\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[1]) >> 16);\n+      return \\\"andnoth %1,%2,%0\\\";\n+    }\n+  xop[0] = operands[0];\n+  xop[1] = GEN_INT (INTVAL (operands[1]) & 0xffff);\n+  xop[2] = operands[2];\n+  output_asm_insn (\\\"andnot %1,%2,%0\\\", xop);\n+  operands[1] = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[1]) >> 16);\n+  return \\\"andnoth %1,%0,%0\\\";\n+}\")\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rL\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xop[3];\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[2]) || LOGIC_INT (operands[2]))\n+    return \\\"or %2,%1,%0\\\";\n+  if ((INTVAL (operands[2]) & 0xffff) == 0)\n+    {\n+      operands[2]\n+\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n+      return \\\"orh %2,%1,%0\\\";\n+    }\n+  xop[0] = operands[0];\n+  xop[1] = operands[1];\n+  xop[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n+  output_asm_insn (\\\"or %2,%1,%0\\\", xop);\n+  operands[2] = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n+  return \\\"orh %2,%0,%0\\\";\n+}\")\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rL\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xop[3];\n+\n+  CC_STATUS_PARTIAL_INIT;\n+  if (REG_P (operands[2]) || LOGIC_INT (operands[2]))\n+    return \\\"xor %2,%1,%0\\\";\n+  if ((INTVAL (operands[2]) & 0xffff) == 0)\n+    {\n+      operands[2]\n+\t= GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n+      return \\\"xorh %2,%1,%0\\\";\n+    }\n+  xop[0] = operands[0];\n+  xop[1] = operands[1];\n+  xop[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n+  output_asm_insn (\\\"xor %2,%1,%0\\\", xop);\n+  operands[2] = GEN_INT ((unsigned HOST_WIDE_INT) INTVAL (operands[2]) >> 16);\n+  return \\\"xorh %2,%0,%0\\\";\n+}\")\n+\n+;(The i860 instruction set doesn't allow an immediate second operand in\n+; a subtraction.)\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"arith_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"subu %?r0,%1,%0\\\";\n+}\")\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"arith_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  return \\\"subu -1,%1,%0\\\";\n+}\")\n+\f\n+;; Floating point arithmetic instructions.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fadd.dd %1,%2,%0\")\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fadd.ss %1,%2,%0\")\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsub.dd %1,%2,%0\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsub.ss %1,%2,%0\")\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmul.dd %1,%2,%0\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmul.ss %1,%2,%0\")\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsub.dd %?f0,%1,%0\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsub.ss %?f0,%1,%0\")\n+\f\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=&f\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:DF 3 \"=&f\"))\n+   (clobber (match_scratch:DF 4 \"=&f\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (((cc_prev_status.flags & CC_KNOW_HI_R31) == 0)\n+      || (cc_prev_status.flags & CC_HI_R31_ADJ)\n+      || (cc_prev_status.mdep != CONST2_RTX (SFmode)))\n+    {\n+      cc_status.flags |= CC_KNOW_HI_R31;\n+      cc_status.flags &= ~CC_HI_R31_ADJ;\n+      cc_status.mdep = CONST2_RTX (SFmode); \n+      return \\\"frcp.dd %2,%3\\;fmul.dd %2,%3,%0\\;fmov.dd %?f0,%4\\;\\\\\n+orh 0x4000,%?r0,%?r31\\;ixfr %?r31,%R4\\;fsub.dd %4,%0,%0\\;\\\\\n+fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\n+fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\n+fmul.dd %3,%1,%3\\;fmul.dd %0,%3,%0\\\";\n+    }\n+  else\n+    return \\\"frcp.dd %2,%3\\;fmul.dd %2,%3,%0\\;fmov.dd %?f0,%4\\;\\\\\n+ixfr %?r31,%R4\\;fsub.dd %4,%0,%0\\;\\\\\n+fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\n+fmul.dd %3,%0,%3\\;fmul.dd %2,%3,%0\\;fsub.dd %4,%0,%0\\;\\\\\n+fmul.dd %3,%1,%3\\;fmul.dd %0,%3,%0\\\";\n+}\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))\n+   (clobber (match_scratch:SF 3 \"=&f\"))\n+   (clobber (match_scratch:SF 4 \"=&f\"))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_PARTIAL_INIT;\n+  if (((cc_prev_status.flags & CC_KNOW_HI_R31) == 0)\n+      || (cc_prev_status.flags & CC_HI_R31_ADJ)\n+      || (cc_prev_status.mdep != CONST2_RTX (SFmode)))\n+    {\n+      cc_status.flags |= CC_KNOW_HI_R31;\n+      cc_status.flags &= ~CC_HI_R31_ADJ;\n+      cc_status.mdep = CONST2_RTX (SFmode);\n+      output_asm_insn (\\\"orh 0x4000,%?r0,%?r31\\\", operands);\n+    }\n+  return \\\"ixfr %?r31,%4\\;frcp.ss %2,%0\\;\\\\\n+fmul.ss %2,%0,%3\\;fsub.ss %4,%3,%3\\;fmul.ss %0,%3,%0\\;\\\\\n+fmul.ss %2,%0,%3\\;fsub.ss %4,%3,%3\\;\\\\\n+fmul.ss %1,%0,%4\\;fmul.ss %3,%4,%0\\\";\n+}\")\n+\f\n+;; Shift instructions\n+\n+;; Optimized special case of shifting.\n+;; Must precede the general case.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t\t     (const_int 24)))]\n+  \"\"\n+  \"*\n+{\n+  if (CONSTANT_ADDRESS_P (XEXP (operands[1], 0)))\n+    {\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_KNOW_HI_R31 | CC_HI_R31_ADJ;\n+      cc_status.mdep = XEXP (operands[1], 0);\n+      return \\\"orh %h1,%?r0,%?r31\\;ld.b %L1(%?r31),%0\\\";\n+    }\n+  return \\\"ld.b %1,%0\\\";\n+}\")\n+\n+\f\n+;;- arithmetic shift instructions\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"shift_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"shl %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:HI 2 \"shift_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"shl %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:QI 2 \"shift_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"shl %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"shift_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"shra %2,%1,%0\\\";\n+}\")\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 2 \"shift_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"shr %2,%1,%0\\\";\n+}\")\n+\f\n+;; Unconditional and other jump instructions\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"br %l0\\;nop\\\";\n+}\")\n+\n+;; Here are two simple peepholes which fill the delay slot of\n+;; an unconditional branch.\n+;\n+;; ??? All disabled, because output_delayed_branch is a crock\n+;; that will reliably segfault.  This should be using the dbr\n+;; pass in any case.  Anyone who cares is welcome to fix it.\n+;\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+;   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n+;  \"\"\n+;  \"* return output_delayed_branch (\\\"br %l2\\\", operands, insn);\")\n+;\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n+;   (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n+;  \"\"\n+;  \"* return output_delayed_branch (\\\"br %l2\\\", operands, insn);\")\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"bri %0\\;nop\")\n+\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n+;   (set (pc) (match_operand:SI 2 \"register_operand\" \"r\"))\n+;   (use (label_ref (match_operand 3 \"\" \"\")))]\n+;  \"\"\n+;  \"* return output_delayed_branch (\\\"bri %2\\\", operands, insn);\")\n+\n+;;- jump to subroutine\n+(define_expand \"call\"\n+  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n+\t (match_operand 1 \"\" \"i\"))]\n+  ;; operand[2] is next_arg_register\n+  \"\"\n+  \"\n+{\n+  /* Make sure the address is just one reg and will stay that way.  */\n+  if (! call_insn_operand (operands[0], QImode))\n+    operands[0]\n+      = replace_equiv_address (operands[0],\n+\t\t\t       copy_to_mode_reg (Pmode,\n+\t\t\t\t\t\t XEXP (operands[0], 0)));\n+  if (INTVAL (operands[1]) > 0)\n+    {\n+      emit_move_insn (arg_pointer_rtx, stack_pointer_rtx);\n+      emit_insn (gen_rtx_USE (VOIDmode, arg_pointer_rtx));\n+    }\n+}\")\n+\n+;;- jump to subroutine\n+(define_insn \"\"\n+  [(call (match_operand:SI 0 \"call_insn_operand\" \"m\")\n+\t (match_operand 1 \"\" \"i\"))]\n+  ;; operand[2] is next_arg_register\n+  \"\"\n+  \"*\n+{\n+  /* strip the MEM.  */\n+  operands[0] = XEXP (operands[0], 0);\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[0]) == REG)\n+    return \\\"calli %0\\;nop\\\";\n+  return \\\"call %0\\;nop\\\";\n+}\")\n+\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+;   (call (match_operand:SI 2 \"memory_operand\" \"m\")\n+;\t (match_operand 3 \"\" \"i\"))]\n+;  ;;- Don't use operand 1 for most machines.\n+;  \"! reg_mentioned_p (operands[0], operands[2])\"\n+;  \"*\n+;{\n+;  /* strip the MEM.  */\n+;  operands[2] = XEXP (operands[2], 0);\n+;  if (GET_CODE (operands[2]) == REG)\n+;    return output_delayed_branch (\\\"calli %2\\\", operands, insn);\n+;  return output_delayed_branch (\\\"call %2\\\", operands, insn);\n+;}\")\n+\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rfJ\"))\n+;   (call (match_operand:SI 2 \"call_insn_operand\" \"m\")\n+;\t (match_operand 3 \"\" \"i\"))]\n+;  ;;- Don't use operand 1 for most machines.\n+;  \"\"\n+;  \"*\n+;{\n+;  /* strip the MEM.  */\n+;  operands[2] = XEXP (operands[2], 0);\n+;  if (GET_CODE (operands[2]) == REG)\n+;    return output_delayed_branch (\\\"calli %2\\\", operands, insn);\n+;  return output_delayed_branch (\\\"call %2\\\", operands, insn);\n+;}\")\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"=rf\")\n+\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n+\t      (match_operand 2 \"\" \"i\")))]\n+  ;; operand 3 is next_arg_register\n+  \"\"\n+  \"\n+{\n+  /* Make sure the address is just one reg and will stay that way.  */\n+  if (! call_insn_operand (operands[1], QImode))\n+    operands[1]\n+      = replace_equiv_address (operands[1],\n+\t\t\t       copy_to_mode_reg (Pmode,\n+\t\t\t\t\t\t XEXP (operands[1], 0)));\n+  if (INTVAL (operands[2]) > 0)\n+    {\n+      emit_move_insn (arg_pointer_rtx, stack_pointer_rtx);\n+      emit_insn (gen_rtx_USE (VOIDmode, arg_pointer_rtx));\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand 0 \"register_operand\" \"=rf\")\n+\t(call (match_operand:SI 1 \"call_insn_operand\" \"m\")\n+\t      (match_operand 2 \"\" \"i\")))]\n+  ;; operand 3 is next_arg_register\n+  \"\"\n+  \"*\n+{\n+  /* strip the MEM.  */\n+  operands[1] = XEXP (operands[1], 0);\n+  CC_STATUS_INIT;\n+  if (GET_CODE (operands[1]) == REG)\n+    return \\\"calli %1\\;nop\\\";\n+  return \\\"call %1\\;nop\\\";\n+}\")\n+\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+;   (set (match_operand 2 \"\" \"=rf\")\n+;\t(call (match_operand:SI 3 \"call_insn_operand\" \"m\")\n+;\t      (match_operand 4 \"\" \"i\")))]\n+;  ;;- Don't use operand 4 for most machines.\n+;  \"! reg_mentioned_p (operands[0], operands[3])\"\n+;  \"*\n+;{\n+;  /* strip the MEM.  */\n+;  operands[3] = XEXP (operands[3], 0);\n+;  if (GET_CODE (operands[3]) == REG)\n+;    return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n+;  return output_delayed_branch (\\\"call %3\\\", operands, insn);\n+;}\")\n+\n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+;\t(match_operand:SI 1 \"reg_or_0_operand\" \"rJf\"))\n+;   (set (match_operand 2 \"\" \"=rf\")\n+;\t(call (match_operand:SI 3 \"call_insn_operand\" \"m\")\n+;\t      (match_operand 4 \"\" \"i\")))]\n+;  ;;- Don't use operand 4 for most machines.\n+;  \"\"\n+;  \"*\n+;{\n+;  /* strip the MEM.  */\n+;  operands[3] = XEXP (operands[3], 0);\n+;  if (GET_CODE (operands[3]) == REG)\n+;    return output_delayed_branch (\\\"calli %3\\\", operands, insn);\n+;  return output_delayed_branch (\\\"call %3\\\", operands, insn);\n+;}\")\n+\n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+  \"\n+{\n+  int i;\n+\n+  emit_call_insn (GEN_CALL (operands[0], const0_rtx, NULL, const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+}\")\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n+  \"\"\n+  \"\")\n+\f\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"bri %0\")\n+\f\n+;;\n+;; A special insn that does the work to get setup just\n+;; before a table jump.\n+;;\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (label_ref (match_operand 2 \"\" \"\")))))]\n+  \"\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"orh %H2,%?r0,%?r31\\;or %L2,%?r31,%?r31\\;ld.l %?r31(%1),%0\\\";\n+}\")\n+  \n+;(define_peephole\n+;  [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n+;\t(match_operand:SI 1 \"single_insn_src_p\" \"gfG\"))\n+;   (set (pc) (match_operand:SI 2 \"register_operand\" \"r\"))\n+;   (use (label_ref (match_operand 3 \"\" \"\")))]\n+;  \"REGNO (operands[0]) != REGNO (operands[2])\"\n+;  \"* return output_delayed_branch (\\\"bri %2\\\", operands, insn);\")"}, {"sha": "753807fe123ca3f200a931206530e68eae3528c6", "filename": "gcc/config/i860/sysv4.h", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fsysv4.h?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -0,0 +1,143 @@\n+/* Target definitions for GNU compiler for Intel 80860 running System V.4\n+   Copyright (C) 1991, 1996, 2000, 2002 Free Software Foundation, Inc.\n+   Contributed by Ron Guilmette (rfg@monkeys.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (i860 System V Release 4)\");\n+\n+/* Provide a set of pre-definitions and pre-assertions appropriate for\n+   the i860 running svr4.  Note that the symbol `__svr4__' MUST BE\n+   DEFINED!  It is needed so that the va_list struct in va-i860.h\n+   will get correctly defined for the svr4 (ABI compliant) case rather\n+   than for the previous (svr3, svr2, ...) case.  It also needs to be\n+   defined so that the correct (svr4) version of __builtin_saveregs\n+   will be selected when we are building gnulib2.c.\n+   __svr4__ is our extension.  */\n+\n+#define CPP_PREDEFINES \\\n+  \"-Di860 -Dunix -DSVR4 -D__svr4__ -Asystem=unix -Asystem=svr4 -Acpu=i860 -Amachine=i860\"\n+\n+/* For the benefit of i860_va_arg, flag it this way too.  */\n+\n+#define I860_SVR4_VA_LIST 1\n+\n+/* The prefix to be used in assembler output for all names of registers.\n+   This string gets prepended to all i860 register names (svr4 only).  */\n+\n+#define I860_REG_PREFIX\t\"%\"\n+\n+#define ASM_COMMENT_START \"#\"\n+\n+#undef TYPE_OPERAND_FMT\n+#define TYPE_OPERAND_FMT      \"\\\"%s\\\"\"\n+\n+/* The following macro definition overrides the one in i860.h\n+   because the svr4 i860 assembler requires a different syntax\n+   for getting parts of constant/relocatable values.  */\n+\n+#undef PRINT_OPERAND_PART\n+#define PRINT_OPERAND_PART(FILE, X, PART_CODE)\t\t\t\t\\\n+  do { fprintf (FILE, \"[\");\t\t\t\t\t\t\\\n+\toutput_address (X);\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"]@%s\", PART_CODE);\t\t\t\t\\\n+  } while (0)\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n+  do {\toutput_file_directive (FILE, main_input_filename);\t\t\\\n+\tfprintf (FILE, \"\\t.version\\t\\\"01.01\\\"\\n\");\t\t\t\\\n+  } while (0)\n+\n+/* Output the special word the svr4 SDB wants to see just before\n+   the first word of each function's prologue code.  */\n+\n+extern const char *current_function_original_name;\n+\n+/* This special macro is used to output a magic word just before the\n+   first word of each function.  On some versions of UNIX running on\n+   the i860, this word can be any word that looks like a NOP, however\n+   under svr4, this neds to be an `shr r0,r0,r0' instruction in which\n+   the normally unused low-order bits contain the length of the function\n+   prologue code (in bytes).  This is needed to make the svr4 SDB debugger\n+   happy.  */\n+\n+#undef ASM_OUTPUT_FUNCTION_PREFIX\n+#define ASM_OUTPUT_FUNCTION_PREFIX(FILE, FNNAME)\t\t\t\\\n+  do {\tASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\\\n+  \tfprintf ((FILE), \"\\t.long\\t.ep.\");\t\t\t\t\\\n+\tassemble_name (FILE, FNNAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \"-\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, FNNAME);\t\t\t\t\t\\\n+\tfprintf (FILE, \"+0xc8000000\\n\");\t\t\t\t\\\n+\tcurrent_function_original_name = (FNNAME);\t\t\t\\\n+  } while (0)\n+\n+/* Output the special label that must go just after each function's\n+   prologue code to support svr4 SDB.  */\n+\n+#define ASM_OUTPUT_PROLOGUE_SUFFIX(FILE)\t\t\t\t\\\n+  do {\tfprintf (FILE, \".ep.\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, current_function_original_name);\t\t\\\n+\tfprintf (FILE, \":\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n+ \n+   Note that we want to give these sections the SHF_WRITE attribute\n+   because these sections will actually contain data (i.e. tables of\n+   addresses of functions in the current root executable or shared library\n+   file) and, in the case of a shared library, the relocatable addresses\n+   will have to be properly resolved/relocated (and then written into) by\n+   the dynamic linker when it actually attaches the given shared library\n+   to the executing process.  (Note that on SVR4, you may wish to use the\n+   `-z text' option to the ELF linker, when building a shared library, as\n+   an additional check that you are doing everything right.  But if you do\n+   use the `-z text' option when building a shared library, you will get\n+   errors unless the .ctors and .dtors sections are marked as writable\n+   via the SHF_WRITE attribute.)  */\n+ \n+#undef CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"aw\\\"\"\n+#undef DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"aw\\\"\"\n+\n+/* Add definitions to support the .tdesc section as specified in the svr4\n+   ABI for the i860.  */\n+\n+#define TDESC_SECTION_ASM_OP    \"\\t.section\\t.tdesc\"\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_tdesc\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n+  TDESC_SECTION_FUNCTION\n+\n+#define TDESC_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+tdesc_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_tdesc)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", TDESC_SECTION_ASM_OP);\t\t\\\n+      in_section = in_tdesc;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+"}, {"sha": "8f870063c4164574ef2981c51c16412330b391e4", "filename": "gcc/config/i860/varargs.asm", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fvarargs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fvarargs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fvarargs.asm?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -0,0 +1,201 @@\n+/* Special varargs support for i860.\n+   Copyright (C) 2001  Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#if defined(__svr4__) || defined(__alliant__)\n+\t.text\n+\t.align\t4\n+\n+/* The Alliant needs the added underscore.  */\n+\t.globl\t__builtin_saveregs\n+__builtin_saveregs:\n+\t.globl\t___builtin_saveregs\n+___builtin_saveregs:\n+\n+\tandnot\t0x0f,%sp,%sp\t/* round down to 16-byte boundary */\n+\tadds\t-96,%sp,%sp  /* allocate stack space for reg save\n+\t\t\t   area and also for a new va_list\n+\t\t\t   structure */\n+\t/* Save all argument registers in the arg reg save area.  The\n+\t   arg reg save area must have the following layout (according\n+\t   to the svr4 ABI):\n+\n+\tstruct {\n+\t  union  {\n+\t    float freg[8];\n+\t    double dreg[4];\n+\t  } float_regs;\n+\t  long\tireg[12];\n+\t};\n+\t*/\n+\n+\tfst.q\t%f8,  0(%sp) /* save floating regs (f8-f15)  */\n+\tfst.q\t%f12,16(%sp) \n+\n+\tst.l\t%r16,32(%sp) /* save integer regs (r16-r27) */\n+\tst.l\t%r17,36(%sp) \n+\tst.l\t%r18,40(%sp)\n+\tst.l\t%r19,44(%sp)\n+\tst.l\t%r20,48(%sp)\n+\tst.l\t%r21,52(%sp)\n+\tst.l\t%r22,56(%sp)\n+\tst.l\t%r23,60(%sp)\n+\tst.l\t%r24,64(%sp)\n+\tst.l\t%r25,68(%sp)\n+\tst.l\t%r26,72(%sp)\n+\tst.l\t%r27,76(%sp)\n+\n+\tadds\t80,%sp,%r16  /* compute the address of the new\n+\t\t\t   va_list structure.  Put in into\n+\t\t\t   r16 so that it will be returned\n+\t\t\t   to the caller.  */\n+\n+\t/* Initialize all fields of the new va_list structure.  This\n+\t   structure looks like:\n+\n+\ttypedef struct {\n+\t    unsigned long\tireg_used;\n+\t    unsigned long\tfreg_used;\n+\t    long\t*reg_base;\n+\t    long\t*mem_ptr;\n+\t} va_list;\n+\t*/\n+\n+\tst.l\t%r0, 0(%r16) /* nfixed */\n+\tst.l\t%r0, 4(%r16) /* nfloating */\n+\tst.l    %sp, 8(%r16) /* __va_ctl points to __va_struct.  */\n+\tbri\t%r1\t/* delayed return */\n+\tst.l\t%r28,12(%r16) /* pointer to overflow args */\n+\n+#else /* not __svr4__ */\n+#if defined(__PARAGON__)\n+\t/*\n+\t *\twe'll use SVR4-ish varargs but need SVR3.2 assembler syntax,\n+\t *\tand we stand a better chance of hooking into libraries\n+\t *\tcompiled by PGI.  [andyp@ssd.intel.com]\n+\t */\n+\t.text\n+\t.align\t4\n+\t.globl\t__builtin_saveregs\n+__builtin_saveregs:\n+\t.globl\t___builtin_saveregs\n+___builtin_saveregs:\n+\n+\tandnot\t0x0f,sp,sp\t/* round down to 16-byte boundary */\n+\tadds\t-96,sp,sp\t/* allocate stack space for reg save\n+\t\t\t   area and also for a new va_list\n+\t\t\t   structure */\n+\t/* Save all argument registers in the arg reg save area.  The\n+\t   arg reg save area must have the following layout (according\n+\t   to the svr4 ABI):\n+\n+\tstruct {\n+\t  union  {\n+\t    float freg[8];\n+\t    double dreg[4];\n+\t  } float_regs;\n+\t  long\tireg[12];\n+\t};\n+\t*/\n+\n+\tfst.q\tf8,  0(sp)\n+\tfst.q\tf12,16(sp) \n+\tst.l\tr16,32(sp)\n+\tst.l\tr17,36(sp) \n+\tst.l\tr18,40(sp)\n+\tst.l\tr19,44(sp)\n+\tst.l\tr20,48(sp)\n+\tst.l\tr21,52(sp)\n+\tst.l\tr22,56(sp)\n+\tst.l\tr23,60(sp)\n+\tst.l\tr24,64(sp)\n+\tst.l\tr25,68(sp)\n+\tst.l\tr26,72(sp)\n+\tst.l\tr27,76(sp)\n+\n+\tadds\t80,sp,r16  /* compute the address of the new\n+\t\t\t   va_list structure.  Put in into\n+\t\t\t   r16 so that it will be returned\n+\t\t\t   to the caller.  */\n+\n+\t/* Initialize all fields of the new va_list structure.  This\n+\t   structure looks like:\n+\n+\ttypedef struct {\n+\t    unsigned long\tireg_used;\n+\t    unsigned long\tfreg_used;\n+\t    long\t*reg_base;\n+\t    long\t*mem_ptr;\n+\t} va_list;\n+\t*/\n+\n+\tst.l\tr0, 0(r16) /* nfixed */\n+\tst.l\tr0, 4(r16) /* nfloating */\n+\tst.l    sp, 8(r16) /* __va_ctl points to __va_struct.  */\n+\tbri\tr1\t/* delayed return */\n+\tst.l\tr28,12(r16) /* pointer to overflow args */\n+#else /* not __PARAGON__ */\n+\t.text\n+\t.align\t4\n+\n+\t.globl\t___builtin_saveregs\n+___builtin_saveregs:\n+\tmov\tsp,r30\n+\tandnot\t0x0f,sp,sp\n+\tadds\t-96,sp,sp  /* allocate sufficient space on the stack */\n+\n+/* Fill in the __va_struct.  */\n+\tst.l\tr16, 0(sp) /* save integer regs (r16-r27) */\n+\tst.l\tr17, 4(sp) /* int\tfixed[12] */\n+\tst.l\tr18, 8(sp)\n+\tst.l\tr19,12(sp)\n+\tst.l\tr20,16(sp)\n+\tst.l\tr21,20(sp)\n+\tst.l\tr22,24(sp)\n+\tst.l\tr23,28(sp)\n+\tst.l\tr24,32(sp)\n+\tst.l\tr25,36(sp)\n+\tst.l\tr26,40(sp)\n+\tst.l\tr27,44(sp)\n+\n+\tfst.q\tf8, 48(sp) /* save floating regs (f8-f15) */\n+\tfst.q\tf12,64(sp) /* int floating[8] */\n+\n+/* Fill in the __va_ctl.  */\n+\tst.l    sp, 80(sp) /* __va_ctl points to __va_struct.  */\n+\tst.l\tr28,84(sp) /* pointer to more args */\n+\tst.l\tr0, 88(sp) /* nfixed */\n+\tst.l\tr0, 92(sp) /* nfloating */\n+\n+\tadds\t80,sp,r16  /* return address of the __va_ctl.  */\n+\tbri\tr1\n+\tmov\tr30,sp\n+\t\t/* recover stack and pass address to start \n+\t\t   of data.  */\n+#endif /* not __PARAGON__ */\n+#endif /* not __svr4__ */"}, {"sha": "c01fb887dcafc7b2ad239fd0a6895037f2521e2e", "filename": "gcc/config/i860/x-sysv4", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fx-sysv4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e156735260644f4937072e602234068a8bc6edf9/gcc%2Fconfig%2Fi860%2Fx-sysv4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fx-sysv4?ref=e156735260644f4937072e602234068a8bc6edf9", "patch": "@@ -0,0 +1,44 @@\n+# The svr4 reference port for the i860 contains an alloca.o routine\n+# in /usr/ucblib/libucb.a, but we can't just try to get that by\n+# setting CLIB to /usr/ucblib/libucb.a because (unfortunately)\n+# there are a lot of other routines in libucb.a which are supposed\n+# to be the Berkeley versions of library routines normally found in\n+# libc.a and many of these Berkeley versions are badly broken.  Thus,\n+# if we try to link programs with libucb.a before libc.a, those\n+# programs tend to crash.\n+\n+# Also, the alloca() routine supplied in early version of svr4 for\n+# the i860 is non-ABI compliant.  It doesn't keep the stack aligned\n+# to a 16-byte boundary as the ABI requires.\n+\n+# More importantly however, even a fully ABI compliant alloca() routine\n+# would fail to work correctly with some versions of the native svr4 C\n+# compiler currently being distributed for the i860 (as of 1/29/92).\n+# The problem is that the native C compiler generates non-ABI-compliant\n+# function epilogues which cut back the stack (upon function exit) in\n+# an incorrect manner.  Specifically, they cut back the stack by adding\n+# the nominal *static* frame size (determined statically at compile-time)\n+# to the stack pointer rather than setting the stack pointer based upon\n+# the current value of the frame pointer (as called for in the i860 ABI).\n+# This can cause serious trouble in cases where you repeatedly call a\n+# routine which itself calls alloca().  In such cases, the stack will\n+# grow continuously until you finally run out of swap space or exceed\n+# the system's process size limit.  To avoid this problem (which can\n+# arise when a stage1 gcc is being used to build a stage2 gcc) you\n+# *must* link in the C language version of alloca() which is supplied\n+# with gcc to your stage1 version of gcc.  The following definition\n+# forces that to happen.\n+\n+ALLOCA=alloca.o\n+\n+# We build all stages *without* shared libraries because that may make\n+# debugging the compiler easier (until there is a GDB which supports\n+# both Dwarf *and* svr4 shared libraries).\n+\n+# Note that the native C compiler for the svr4 reference port on the\n+# i860 recognizes a special -gg option.  Using that option causes *full*\n+# Dwarf debugging information to be generated, whereas using only -g\n+# causes only limited Dwarf debugging information to be generated.\n+# (This is an undocumented feature of the native svr4 C compiler.)\n+\n+CCLIBFLAGS=-Bstatic -dn -gg"}]}