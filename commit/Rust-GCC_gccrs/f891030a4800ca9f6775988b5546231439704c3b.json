{"sha": "f891030a4800ca9f6775988b5546231439704c3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg5MTAzMGE0ODAwY2E5ZjY3NzU5ODhiNTU0NjIzMTQzOTcwNGMzYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-11-03T17:53:51Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-11-03T17:53:51Z"}, "message": "combine.c (try_combine): Fix formatting issues, improve comments and fix a pasto.\n\n\t* combine.c (try_combine): Fix formatting issues, improve comments and\n\tfix a pasto.\n\nFrom-SVN: r166263", "tree": {"sha": "ddf48beff885c9e0a0059a938ee7b4e3237c98c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddf48beff885c9e0a0059a938ee7b4e3237c98c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f891030a4800ca9f6775988b5546231439704c3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f891030a4800ca9f6775988b5546231439704c3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f891030a4800ca9f6775988b5546231439704c3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f891030a4800ca9f6775988b5546231439704c3b/comments", "author": null, "committer": null, "parents": [{"sha": "8cf8ca52aec350b6ea36e352c0ab8cd1b6482b48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf8ca52aec350b6ea36e352c0ab8cd1b6482b48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf8ca52aec350b6ea36e352c0ab8cd1b6482b48"}], "stats": {"total": 53, "additions": 34, "deletions": 19}, "files": [{"sha": "d9e67dc5feef0acea3787d4ad319c4c06f3d2796", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f891030a4800ca9f6775988b5546231439704c3b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f891030a4800ca9f6775988b5546231439704c3b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f891030a4800ca9f6775988b5546231439704c3b", "patch": "@@ -1,3 +1,8 @@\n+2010-11-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* combine.c (try_combine): Fix formatting issues, improve comments and\n+\tfix a pasto.\n+\n 2010-11-03  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-tailcall.c (find_tail_calls): Convert the operands to the type"}, {"sha": "ee26c905d4613540bec49d53b93a2ae0da6ad424", "filename": "gcc/combine.c", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f891030a4800ca9f6775988b5546231439704c3b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f891030a4800ca9f6775988b5546231439704c3b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f891030a4800ca9f6775988b5546231439704c3b", "patch": "@@ -2502,6 +2502,7 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n   rtx i3dest_killed = 0;\n   /* SET_DEST and SET_SRC of I2, I1 and I0.  */\n   rtx i2dest = 0, i2src = 0, i1dest = 0, i1src = 0, i0dest = 0, i0src = 0;\n+  /* Copy of SET_SRC of I1, if needed.  */\n   rtx i1src_copy = 0;\n   /* Set if I2DEST was reused as a scratch register.  */\n   bool i2scratch = false;\n@@ -3072,23 +3073,23 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \t}\n \n       n_occurrences = 0;\t\t/* `subst' counts here */\n-\n-      /* If I1 feeds into I2 and I1DEST is in I1SRC, we need to make a\n-\t unique copy of I2SRC each time we substitute it to avoid\n-\t self-referential rtl.  */\n-\n       subst_low_luid = DF_INSN_LUID (i2);\n+\n+      /* If I1 feeds into I2 and I1DEST is in I1SRC, we need to make a unique\n+\t copy of I2SRC each time we substitute it, in order to avoid creating\n+\t self-referential RTL when we will be substituting I1SRC for I1DEST\n+\t later.  Likewise if I0 feeds into I2 and I0DEST is in I0SRC.  */\n       newpat = subst (PATTERN (i3), i2dest, i2src, 0,\n-\t\t      ((i1_feeds_i2_n && i1dest_in_i1src)\n-\t\t       || (i0_feeds_i2_n && i0dest_in_i0src)));\n+\t\t      (i1_feeds_i2_n && i1dest_in_i1src)\n+\t\t      || (i0_feeds_i2_n && i0dest_in_i0src));\n       substed_i2 = 1;\n \n-      /* Record whether i2's body now appears within i3's body.  */\n+      /* Record whether I2's body now appears within I3's body.  */\n       i2_is_used = n_occurrences;\n     }\n \n-  /* If we already got a failure, don't try to do more.  Otherwise,\n-     try to substitute in I1 if we have it.  */\n+  /* If we already got a failure, don't try to do more.  Otherwise, try to\n+     substitute I1 if we have it.  */\n \n   if (i1 && GET_CODE (newpat) != CLOBBER)\n     {\n@@ -3099,10 +3100,10 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \t   && i1_feeds_i2_n\n \t   && dead_or_set_p (i2, i1dest)\n \t   && !reg_overlap_mentioned_p (i1dest, newpat))\n-\t  /* Before we can do this substitution, we must redo the test done\n-\t     above (see detailed comments there) that ensures  that I1DEST\n-\t     isn't mentioned in any SETs in NEWPAT that are field assignments.  */\n-          || !combinable_i3pat (NULL_RTX, &newpat, i1dest, NULL_RTX, NULL_RTX,\n+\t   /* Before we can do this substitution, we must redo the test done\n+\t      above (see detailed comments there) that ensures I1DEST isn't\n+\t      mentioned in any SETs in NEWPAT that are field assignments.  */\n+\t  || !combinable_i3pat (NULL_RTX, &newpat, i1dest, NULL_RTX, NULL_RTX,\n \t\t\t\t0, 0, 0))\n \t{\n \t  undo_all ();\n@@ -3111,33 +3112,42 @@ try_combine (rtx i3, rtx i2, rtx i1, rtx i0, int *new_direct_jump_p)\n \n       n_occurrences = 0;\n       subst_low_luid = DF_INSN_LUID (i1);\n+\n+      /* If I0 feeds into I1 and I0DEST is in I0SRC, we need to make a unique\n+\t copy of I1SRC each time we substitute it, in order to avoid creating\n+\t self-referential RTL when we will be substituting I0SRC for I0DEST\n+\t later.  */\n       newpat = subst (newpat, i1dest, i1src, 0,\n \t\t      i0_feeds_i1_n && i0dest_in_i0src);\n       substed_i1 = 1;\n+\n+      /* Record whether I1's body now appears within I3's body.  */\n       i1_is_used = n_occurrences;\n     }\n+\n+  /* Likewise for I0 if we have it.  */\n+\n   if (i0 && GET_CODE (newpat) != CLOBBER)\n     {\n       if ((FIND_REG_INC_NOTE (i0, NULL_RTX) != 0\n \t   && ((i0_feeds_i2_n && dead_or_set_p (i2, i0dest))\n \t       || (i0_feeds_i1_n && dead_or_set_p (i1, i0dest)))\n \t   && !reg_overlap_mentioned_p (i0dest, newpat))\n-          || !combinable_i3pat (NULL_RTX, &newpat, i0dest, NULL_RTX, NULL_RTX,\n+\t  || !combinable_i3pat (NULL_RTX, &newpat, i0dest, NULL_RTX, NULL_RTX,\n \t\t\t\t0, 0, 0))\n \t{\n \t  undo_all ();\n \t  return 0;\n \t}\n \n-      /* Following subst may modify i1src, make a copy of it\n-\t before it is for added_sets_2 handling if needed.  */\n+      /* If the following substitution will modify I1SRC, make a copy of it\n+\t for the case where it is substituted for I1DEST in I2PAT later.  */\n       if (i0_feeds_i1_n && added_sets_2 && i1_feeds_i2_n)\n \ti1src_copy = copy_rtx (i1src);\n \n       n_occurrences = 0;\n       subst_low_luid = DF_INSN_LUID (i0);\n-      newpat = subst (newpat, i0dest, i0src, 0,\n-\t\t      i0_feeds_i1_n && i0dest_in_i0src);\n+      newpat = subst (newpat, i0dest, i0src, 0, 0);\n       substed_i0 = 1;\n     }\n "}]}