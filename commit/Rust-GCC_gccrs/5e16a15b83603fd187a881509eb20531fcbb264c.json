{"sha": "5e16a15b83603fd187a881509eb20531fcbb264c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUxNmExNWI4MzYwM2ZkMTg3YTg4MTUwOWViMjA1MzFmY2JiMjY0Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-05T11:06:14Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-05T11:06:14Z"}, "message": "arc.c (get_arc_condition_code): Use gcc_assert & gcc_unreachable as appropriate.\n\n\t* config/arc/arc.c (get_arc_condition_code): Use gcc_assert &\n\tgcc_unreachable as appropriate.\n\t(arc_double_limm_p, arc_setup_incoming_varargs,\n\tarc_compute_function_type, arc_output_function_prologue,\n\tarc_output_function_epilogue, arc_eligible_for_epilogue_delay,\n\toutput_shift, arc_print_operand, arc_print_operand_address,\n\tarc_final_prescan_insn): Likewise.\n\t* config/arc/arc.md (*movdi_insn, *movdf_insn): Likewise.\n\nFrom-SVN: r99264", "tree": {"sha": "11f3cc548f0ac93e7ee419de2f1f039cb444e6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11f3cc548f0ac93e7ee419de2f1f039cb444e6e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e16a15b83603fd187a881509eb20531fcbb264c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e16a15b83603fd187a881509eb20531fcbb264c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e16a15b83603fd187a881509eb20531fcbb264c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e16a15b83603fd187a881509eb20531fcbb264c/comments", "author": null, "committer": null, "parents": [{"sha": "0354e5d8b61664785e30c27c44138f3d1cbe83a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0354e5d8b61664785e30c27c44138f3d1cbe83a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0354e5d8b61664785e30c27c44138f3d1cbe83a3"}], "stats": {"total": 92, "additions": 49, "deletions": 43}, "files": [{"sha": "f799bbb03e29508aa3716bc5b01845142b6f6687", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e16a15b83603fd187a881509eb20531fcbb264c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e16a15b83603fd187a881509eb20531fcbb264c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e16a15b83603fd187a881509eb20531fcbb264c", "patch": "@@ -1,3 +1,14 @@\n+2005-05-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/arc/arc.c (get_arc_condition_code): Use gcc_assert &\n+\tgcc_unreachable as appropriate.\n+\t(arc_double_limm_p, arc_setup_incoming_varargs,\n+\tarc_compute_function_type, arc_output_function_prologue,\n+\tarc_output_function_epilogue, arc_eligible_for_epilogue_delay,\n+\toutput_shift, arc_print_operand, arc_print_operand_address,\n+\tarc_final_prescan_insn): Likewise.\n+\t* config/arc/arc.md (*movdi_insn, *movdf_insn): Likewise.\n+\n 2005-05-04  Geoffrey Keating  <geoffk@apple.com>\n \n \t* config/rs6000/rs6000.md (P): Use TARGET_*BIT rather than"}, {"sha": "52eca9f0f0e0fbc7cf6ad35c7d68c02fe51197c6", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e16a15b83603fd187a881509eb20531fcbb264c/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e16a15b83603fd187a881509eb20531fcbb264c/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=5e16a15b83603fd187a881509eb20531fcbb264c", "patch": "@@ -241,7 +241,7 @@ get_arc_condition_code (rtx comparison)\n     case LEU : return 15;\n     case LTU : return 6;\n     case GEU : return 7;\n-    default : abort ();\n+    default : gcc_unreachable ();\n     }\n   /*NOTREACHED*/\n   return (42);\n@@ -774,8 +774,7 @@ arc_double_limm_p (rtx value)\n {\n   HOST_WIDE_INT low, high;\n \n-  if (GET_CODE (value) != CONST_DOUBLE)\n-    abort ();\n+  gcc_assert (GET_CODE (value) == CONST_DOUBLE);\n \n   low = CONST_DOUBLE_LOW (value);\n   high = CONST_DOUBLE_HIGH (value);\n@@ -815,8 +814,7 @@ arc_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n   int first_anon_arg;\n \n   /* All BLKmode values are passed by reference.  */\n-  if (mode == BLKmode)\n-    abort ();\n+  gcc_assert (mode != BLKmode);\n \n   first_anon_arg = *cum + ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)\n \t\t\t   / UNITS_PER_WORD);\n@@ -1061,7 +1059,7 @@ arc_compute_function_type (tree decl)\n \t  else if (!strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n \t    fn_type = ARC_FUNCTION_ILINK2;\n \t  else\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  break;\n \t}\n     }\n@@ -1229,8 +1227,7 @@ arc_output_function_prologue (FILE *file, HOST_WIDE_INT size)\n \t   : current_frame_info.total_size);\n \n   /* These cases shouldn't happen.  Catch them now.  */\n-  if (size == 0 && gmask)\n-    abort ();\n+  gcc_assert (size || !gmask);\n \n   /* Allocate space for register arguments if this is a variadic function.  */\n   if (current_frame_info.pretend_size != 0)\n@@ -1317,8 +1314,7 @@ arc_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n \n       if (!can_trust_sp_p)\n \t{\n-\t  if (!frame_pointer_needed)\n-\t    abort ();\n+\t  gcc_assert (frame_pointer_needed);\n \t  fprintf (file,\"\\tsub %s,%s,%d\\t\\t%s sp not trusted here\\n\",\n \t\t   sp_str, fp_str, frame_size, ASM_COMMENT_START);\n \t}\n@@ -1400,23 +1396,19 @@ arc_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n \tfprintf (file, \"\\tadd %s,%s,16\\n\", sp_str, sp_str);\n       else if (epilogue_delay != NULL_RTX)\n \t{\n-\t  if (frame_pointer_needed && !fp_restored_p)\n-\t    abort ();\n-\t  if (restored < size)\n-\t    abort ();\n+\t  gcc_assert (!frame_pointer_needed || fp_restored_p);\n+\t  gcc_assert (restored >= size);\n \t  final_scan_insn (XEXP (epilogue_delay, 0), file, 1, 1, NULL);\n \t}\n       else if (frame_pointer_needed && !fp_restored_p)\n \t{\n-\t  if (!SMALL_INT (frame_size))\n-\t    abort ();\n+\t  gcc_assert (SMALL_INT (frame_size));\n \t  /* Note that we restore fp and sp here!  */\n \t  fprintf (file, \"\\tld.a %s,[%s,%d]\\n\", fp_str, sp_str, frame_size);\n \t}\n       else if (restored < size)\n \t{\n-\t  if (!SMALL_INT (size - restored))\n-\t    abort ();\n+\t  gcc_assert (SMALL_INT (size - restored));\n \t  fprintf (file, \"\\tadd %s,%s,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t\t   sp_str, sp_str, size - restored);\n \t}\n@@ -1456,8 +1448,7 @@ arc_delay_slots_for_epilogue (void)\n int\n arc_eligible_for_epilogue_delay (rtx trial, int slot)\n {\n-  if (slot != 0)\n-    abort ();\n+  gcc_assert (!slot);\n \n   if (get_attr_length (trial) == 1\n       /* If registers where saved, presumably there's more than enough\n@@ -1522,15 +1513,14 @@ output_shift (rtx *operands)\n   enum rtx_code code = GET_CODE (shift);\n   const char *shift_one;\n \n-  if (mode != SImode)\n-    abort ();\n+  gcc_assert (mode == SImode);\n \n   switch (code)\n     {\n     case ASHIFT:   shift_one = \"asl %0,%0\"; break;\n     case ASHIFTRT: shift_one = \"asr %0,%0\"; break;\n     case LSHIFTRT: shift_one = \"lsr %0,%0\"; break;\n-    default:       abort ();\n+    default:       gcc_unreachable ();\n     }\n \n   if (GET_CODE (operands[2]) != CONST_INT)\n@@ -1792,9 +1782,8 @@ arc_print_operand (FILE *file, rtx x, int code)\n       {\n \tchar str[30];\n \n-\tif (GET_CODE (x) != CONST_DOUBLE\n-\t    || GET_MODE_CLASS (GET_MODE (x)) != MODE_FLOAT)\n-\t  abort ();\n+\tgcc_assert (GET_CODE (x) == CONST_DOUBLE\n+\t\t    && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT);\n \n \treal_to_decimal (str, CONST_DOUBLE_REAL_VALUE (x), sizeof (str), 0, 1);\n \tfprintf (file, \"%s\", str);\n@@ -1896,26 +1885,33 @@ arc_print_operand_address (FILE *file, rtx addr)\n \toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\n       else\n \tbase = XEXP (addr, 0), index = XEXP (addr, 1);\n-      if (GET_CODE (base) != REG)\n-\tabort ();\n+      gcc_assert (GET_CODE (base) == REG);\n       fputs (reg_names[REGNO (base)], file);\n       if (index == 0)\n \t{\n \t  if (offset != 0)\n \t    fprintf (file, \",%d\", offset);\n \t}\n-      else if (GET_CODE (index) == REG)\n-\tfprintf (file, \",%s\", reg_names[REGNO (index)]);\n-      else if (GET_CODE (index) == SYMBOL_REF)\n-\tfputc (',', file), output_addr_const (file, index);\n       else\n-\tabort ();\n+\t{\n+\t  switch (GET_CODE (index))\n+\t    {\n+\t    case REG:\n+\t      fprintf (file, \",%s\", reg_names[REGNO (index)]);\n+\t      break;\n+\t    case SYMBOL_REF:\n+\t      fputc (',', file), output_addr_const (file, index);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n       break;\n     case PRE_INC :\n     case PRE_DEC :\n       /* We shouldn't get here as we've lost the mode of the memory object\n \t (which says how much to inc/dec by.  */\n-      abort ();\n+      gcc_unreachable ();\n       break;\n     default :\n       output_addr_const (file, addr);\n@@ -2102,7 +2098,7 @@ arc_final_prescan_insn (rtx insn,\n \t  then_not_else = FALSE;\n         }\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n \n       /* See how many insns this branch skips, and what kind of insns.  If all\n \t insns are okay, and the label or unconditional branch to the same\n@@ -2221,14 +2217,15 @@ arc_final_prescan_insn (rtx insn,\n \t{\n \t  if ((!seeking_return) && (arc_ccfsm_state == 1 || reverse))\n \t    arc_ccfsm_target_label = CODE_LABEL_NUMBER (label);\n-\t  else if (seeking_return || arc_ccfsm_state == 2)\n+\t  else\n \t    {\n+\t      gcc_assert (seeking_return || arc_ccfsm_state == 2);\n \t      while (this_insn && GET_CODE (PATTERN (this_insn)) == USE)\n \t        {\n \t\t  this_insn = next_nonnote_insn (this_insn);\n-\t\t  if (this_insn && (GET_CODE (this_insn) == BARRIER\n-\t\t\t\t    || GET_CODE (this_insn) == CODE_LABEL))\n-\t\t    abort ();\n+\t\t  gcc_assert (!this_insn\n+\t\t\t      || (GET_CODE (this_insn) != BARRIER\n+\t\t\t\t  && GET_CODE (this_insn) != CODE_LABEL));\n \t        }\n \t      if (!this_insn)\n \t        {\n@@ -2240,8 +2237,6 @@ arc_final_prescan_insn (rtx insn,\n \t        }\n \t      arc_ccfsm_target_insn = this_insn;\n \t    }\n-\t  else\n-\t    abort ();\n \n \t  /* If REVERSE is true, ARM_CURRENT_CC needs to be inverted from\n \t     what it was.  */"}, {"sha": "2ae3c446905658cb1a30eee7d7e4b85a1781ade3", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e16a15b83603fd187a881509eb20531fcbb264c/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e16a15b83603fd187a881509eb20531fcbb264c/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=5e16a15b83603fd187a881509eb20531fcbb264c", "patch": "@@ -299,7 +299,7 @@\n     case 3 :\n       return \\\"st%V0 %1,%0\\;st%V0 %R1,%R0\\\";\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"type\" \"move,move,load,store\")\n@@ -392,7 +392,7 @@\n     case 3 :\n       return \\\"st%V0 %1,%0\\;st%V0 %R1,%R0\\\";\n     default:\n-      abort();\n+      gcc_unreachable ();\n     }\n }\"\n   [(set_attr \"type\" \"move,move,load,store\")"}]}