{"sha": "8f9ca9127473a43ba75f03fbfc30c32e9984c982", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY5Y2E5MTI3NDczYTQzYmE3NWYwM2ZiZmMzMGMzMmU5OTg0Yzk4Mg==", "commit": {"author": {"name": "Bruce Korb", "email": "autogen@linuxbox.com", "date": "1999-10-22T13:23:43Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1999-10-22T13:23:43Z"}, "message": "Use C-coded tests and fixes for #endif/#else labels\n\nFrom-SVN: r30130", "tree": {"sha": "88fc11438fcbc6ce10007f2c432098fe2e8447a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88fc11438fcbc6ce10007f2c432098fe2e8447a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f9ca9127473a43ba75f03fbfc30c32e9984c982", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9ca9127473a43ba75f03fbfc30c32e9984c982", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f9ca9127473a43ba75f03fbfc30c32e9984c982", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9ca9127473a43ba75f03fbfc30c32e9984c982/comments", "author": null, "committer": null, "parents": [{"sha": "5685b5d3c2b08fefc01342406d0c2cc2405fe47c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5685b5d3c2b08fefc01342406d0c2cc2405fe47c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5685b5d3c2b08fefc01342406d0c2cc2405fe47c"}], "stats": {"total": 425, "additions": 344, "deletions": 81}, "files": [{"sha": "6646c8c399a2ed00e761f8c3c3b0f2e043e9453a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f9ca9127473a43ba75f03fbfc30c32e9984c982", "patch": "@@ -1,3 +1,13 @@\n+1999-10-22  Bruce Korb  <autogen@linuxbox.com>\n+\n+\t* fixinc/README: document the \"mach\" machine matching test\n+\t* fixinc/fixfixes.c: Implement the #else/#endif label fix\n+\t* fixinc/fixtests.c: Implement the #else/#endif label test\n+\t* fixinc/inclhack.def: utilize these tests and fixes\n+\t* fixinc/inclhack.sh:  regen\n+\t* fixinc/fixincl.x:  regen\n+\t* fixinc/fixincl.sh:  regen\n+\n Thu Oct 21 20:37:19 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* Makefile.in (cse.o): Depend on hashtab.h, not splay-tree.h.  Also"}, {"sha": "8fb70839342ed02f875adc0fb4abccd0aa1e339c", "filename": "gcc/fixinc/README", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2FREADME?ref=8f9ca9127473a43ba75f03fbfc30c32e9984c982", "patch": "@@ -71,7 +71,10 @@ Here are the rules for making fixes in the inclhack.def file:\n     \"c_test\" because they are performed internally.  \"test\" sends\n     a command to a server shell that actually fires off one or more\n     processes to do the testing.  Avoid it, if you can, but it is\n-    still more efficient than a fix process.\n+    still more efficient than a fix process.  Also available is\n+    \"mach\".  If the target machine matches any of the named\n+    globbing-style patterns, then the machine name test will pass.\n+    It is desired, however, to limit the use of this test.\n \n     These tests are required to:\n "}, {"sha": "c1586e8cfb7ce45b6e9d2de1c196cd208629e092", "filename": "gcc/fixinc/fixfixes.c", "status": "modified", "additions": 186, "deletions": 6, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2Ffixfixes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2Ffixfixes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixfixes.c?ref=8f9ca9127473a43ba75f03fbfc30c32e9984c982", "patch": "@@ -72,7 +72,8 @@ typedef struct {\n } fix_entry_t;\n \n #define FIXUP_TABLE \\\n-  _FT_( \"no_double_slash\", double_slash_fix )\n+  _FT_( \"no_double_slash\",  double_slash_fix ) \\\n+  _FT_( \"else_endif_label\", else_endif_label_fix )\n \n \n #define FIX_PROC_HEAD( fix ) \\\n@@ -180,6 +181,184 @@ FIX_PROC_HEAD( double_slash_fix )\n   fclose (stdout);;\n }\n \n+\n+FIX_PROC_HEAD( else_endif_label_fix )\n+{\n+  static const char label_pat[] = \"^[ \\t]*#[ \\t]*(else|endif)\";\n+  static regex_t label_re;\n+\n+  char ch;\n+  char* pz_next = (char*)NULL;\n+  regmatch_t match[2];\n+\n+  re_set_syntax (RE_SYNTAX_EGREP);\n+  (void)re_compile_pattern (label_pat, sizeof (label_pat)-1,\n+                            &label_re);\n+\n+  for (;;) /* entire file */\n+    {\n+      /*\n+        See if we need to advance to the next candidate directive\n+        If the scanning pointer passes over the end of the directive,\n+        then the directive is inside a comment */\n+      if (pz_next < text)\n+        {\n+          if (regexec (&label_re, text, 2, match, 0) != 0)\n+            {\n+              fputs( text, stdout );\n+              break;\n+            }\n+\n+          pz_next = text + match[0].rm_eo;\n+        }\n+\n+      /*\n+        IF the scan pointer has not reached the directive end, ... */\n+      if (pz_next > text)\n+        {\n+          /*\n+            Advance the scanning pointer.  If we are at the start\n+            of a quoted string or a comment, then skip the entire unit */\n+          ch = *text;\n+\n+          switch (ch)\n+            {\n+            case '/':\n+              /*\n+                Skip comments */\n+              if (text[1] == '*')\n+                {\n+                  char* pz = strstr( text+2, \"*/\" );\n+                  if (pz == (char*)NULL)\n+                    {\n+                      fputs( text, stdout );\n+                      return;\n+                    }\n+                  pz += 2;\n+                  fwrite( text, 1, (pz - text), stdout );\n+                  text = pz;\n+                  continue;\n+                }\n+              putc( ch, stdout );\n+              text++;\n+              break;\n+\n+            case '\"':\n+            case '\\'':\n+              text = print_quote( ch, text+1 );\n+              break;\n+\n+            default:\n+              putc( ch, stdout );\n+              text++;\n+            } /* switch (ch) */\n+          continue;\n+        } /* if (still shy of directive end) */\n+\n+      /*\n+         The scanning pointer (text) has reached the end of the current\n+         directive under test.  Check for bogons here.  */\n+      for (;;) /* bogon check */\n+        {\n+          char ch = *(text++);\n+          if (isspace (ch))\n+            {\n+              putc( ch, stdout );\n+              if (ch == '\\n')\n+                {\n+                  /*\n+                    It is clean.  No bogons on this directive */\n+                  pz_next = (char*)NULL; /* force a new regex search */\n+                  goto dont_fix_bogon;\n+                }\n+              continue;\n+            }\n+\n+          switch (ch)\n+            {\n+            case NUL:\n+              return;\n+\n+            case '\\\\':\n+              /*\n+                Skip escaped newlines.  Otherwise, we have a bogon */\n+              if (*text != '\\n') {\n+                text--;\n+                goto fix_the_bogon;\n+              }\n+\n+              /*\n+                Emit the escaped newline and keep scanning for possible junk */\n+              putc( '\\\\', stdout );\n+              putc( '\\n', stdout );\n+              text++;\n+              break;\n+\n+            case '/':\n+              /*\n+                Skip comments.  Otherwise, we have a bogon */\n+              if (*text == '*')\n+                {\n+                  text--;\n+                  pz_next = strstr( text+2, \"*/\" );\n+                  if (pz_next == (char*)NULL)\n+                    {\n+                      putc( '\\n', stdout );\n+                      return;\n+                    }\n+                  pz_next += 2;\n+                  fwrite( text, 1, (pz_next - text), stdout );\n+                  text = pz_next;\n+                  break;\n+                }\n+\n+              /*\n+                FIXME:  if this is a C++ file, then a double slash comment\n+                is allowed to follow the directive.  */\n+\n+              /* FALLTHROUGH */\n+\n+            default:\n+              /*\n+                GOTTA BE A BOGON */\n+              text--;\n+              goto fix_the_bogon;\n+            } /* switch (ch) */\n+        } /* for (bogon check loop) */\n+\n+    fix_the_bogon:\n+      /*\n+        `text' points to the start of the bogus data */\n+      for (;;)\n+        {\n+          /*\n+            NOT an escaped newline.  Find the end of line that\n+            is not preceeded by an escape character:  */\n+          pz_next = strchr( text, '\\n' );\n+          if (pz_next == (char*)NULL)\n+            {\n+              putc( '\\n', stdout );\n+              return;\n+            }\n+\n+          if (pz_next[-1] != '\\\\')\n+            {\n+              text = pz_next;\n+              pz_next = (char*)NULL; /* force a new regex search */\n+              break;\n+            }\n+\n+          /*\n+            The newline was escaped.  We gotta keep going.  */\n+          text = pz_next + 1;\n+        }\n+\n+    dont_fix_bogon:;\n+    } /* for (entire file) loop */\n+\n+  return;\n+}\n+\n /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n \n      test for fix selector\n@@ -206,11 +385,12 @@ apply_fix( fixname, filname )\n       if (strcmp (pfe->fix_name, fixname) == 0)\n         break;\n       if (--ct <= 0)\n-\t{\n-\t  fprintf (stderr, \"fixincludes error:  the `%s' fix is unknown\\n\",\n-\t\t   fixname );\n-\t  exit (3);\n-\t}\n+        {\n+          fprintf (stderr, \"fixincludes error:  the `%s' fix is unknown\\n\",\n+                   fixname );\n+          exit (3);\n+        }\n+      pfe++;\n     }\n \n   buf = load_file_data (stdin);"}, {"sha": "c6c8460061848a92f3192746e8594240c8c69aac", "filename": "gcc/fixinc/fixincl.x", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.x?ref=8f9ca9127473a43ba75f03fbfc30c32e9984c982", "patch": "@@ -994,30 +994,19 @@ tSCC zEnd_Else_LabelName[] =\n #define apzEnd_Else_LabelMachs (const char**)NULL\n \n /*\n- *  content selection pattern - do fix if pattern found\n+ *  perform the C function call test\n  */\n-tSCC zEnd_Else_LabelSelect0[] =\n-       \"^[ \\t]*#[ \\t]*(else|endif)[ \\t]+([!-.0-z\\\\{\\\\|\\\\}\\\\~]|/[^\\\\*])\";\n+tSCC zEnd_Else_LabelFTst0[] = \"else_endif_label\";\n \n #define    END_ELSE_LABEL_TEST_CT  1\n-#define    END_ELSE_LABEL_RE_CT    1\n+#define    END_ELSE_LABEL_RE_CT    0\n tTestDesc aEnd_Else_LabelTests[] = {\n-  { TT_EGREP,    zEnd_Else_LabelSelect0, (regex_t*)NULL }, };\n+  { TT_FUNCTION, zEnd_Else_LabelFTst0,   0 /* unused */ }, };\n \n /*\n  *  Fix Command Arguments for End_Else_Label\n  */\n-const char* apzEnd_Else_LabelPatch[] = { \"sed\",\n-    \"-e\", \":loop\\n\\\n-/\\\\\\\\$/N\\n\\\n-s/\\\\\\\\$/\\\\\\\\+++fixinc_eol+++/\\n\\\n-/\\\\\\\\$/b loop\\n\\\n-s/\\\\\\\\+++fixinc_eol+++/\\\\\\\\/g\\n\\\n-s%^\\\\([ \\t]*#[ \\t]*else\\\\)[ \\t][ \\t]*/[^*].*%\\\\1%\\n\\\n-s%^\\\\([ \\t]*#[ \\t]*else\\\\)[ \\t][ \\t]*[^/ \\t].*%\\\\1%\\n\\\n-s%^\\\\([ \\t]*#[ \\t]*endif\\\\)[ \\t][ \\t]*/[^*].*%\\\\1%\\n\\\n-s%^\\\\([ \\t]*#[ \\t]*endif\\\\)[ \\t][ \\t]*\\\\*[^/].*%\\\\1%\\n\\\n-s%^\\\\([ \\t]*#[ \\t]*endif\\\\)[ \\t][ \\t]*[^/* \\t].*%\\\\1%\",\n+const char* apzEnd_Else_LabelPatch[] = {\"else_endif_label\",\n     (char*)NULL };\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n@@ -4042,7 +4031,7 @@ extern char *\\tsprintf();\\\\\\n\\\n  *\n  *  List of all fixes\n  */\n-#define REGEX_COUNT          75\n+#define REGEX_COUNT          74\n #define MACH_LIST_SIZE_LIMIT 154\n #define FIX_COUNT            107\n \n@@ -4179,7 +4168,7 @@ tFixDesc fixDescList[ FIX_COUNT ] = {\n \n   {  zEnd_Else_LabelName,    zEnd_Else_LabelList,\n      apzEnd_Else_LabelMachs, (regex_t*)NULL,\n-     END_ELSE_LABEL_TEST_CT, FD_MACH_ONLY,\n+     END_ELSE_LABEL_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n      aEnd_Else_LabelTests,   apzEnd_Else_LabelPatch },\n \n   {  zHp_InlineName,    zHp_InlineList,"}, {"sha": "aac14924c0497076b25b1f59716b2f87a727dc68", "filename": "gcc/fixinc/fixtests.c", "status": "modified", "additions": 130, "deletions": 1, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2Ffixtests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2Ffixtests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixtests.c?ref=8f9ca9127473a43ba75f03fbfc30c32e9984c982", "patch": "@@ -62,7 +62,8 @@ typedef struct {\n } test_entry_t;\n \n #define FIX_TEST_TABLE \\\n-  _FT_( \"double_slash\", double_slash_test )\n+  _FT_( \"double_slash\",     double_slash_test ) \\\n+  _FT_( \"else_endif_label\", else_endif_label_test )\n \n \n #define TEST_FOR_FIX_PROC_HEAD( test ) \\\n@@ -154,6 +155,133 @@ TEST_FOR_FIX_PROC_HEAD( double_slash_test )\n   return SKIP_FIX;\n }\n \n+\n+TEST_FOR_FIX_PROC_HEAD( else_endif_label_test )\n+{\n+  static int compiled = 0;\n+  static const char label_pat[] = \"^[ \\t]*#[ \\t]*(else|endif)\";\n+  static regex_t label_re;\n+\n+  char ch;\n+  const char* pz_next = (char*)NULL;\n+  regmatch_t match[2];\n+\n+  /*\n+     This routine may be run many times within a single execution.\n+     Do the compile once only in that case.  In the standalone case,\n+     we waste 10 bytes of memory and a test, branch and increment delay.  */\n+  if (! compiled)\n+    {\n+      compiled++;\n+      re_set_syntax (RE_SYNTAX_EGREP);\n+      (void)re_compile_pattern (label_pat, sizeof (label_pat)-1,\n+                                &label_re);\n+    }\n+\n+  for (;;) /* entire file */\n+    {\n+      /*\n+        See if we need to advance to the next candidate directive\n+        If the scanning pointer passes over the end of the directive,\n+        then the directive is inside a comment */\n+      if (pz_next < text)\n+        {\n+          if (regexec (&label_re, text, 2, match, 0) != 0)\n+            break;\n+          pz_next = text + match[0].rm_eo;\n+        }\n+\n+      /*\n+        IF the scan pointer has not reached the directive end, ... */\n+      if (pz_next > text)\n+        {\n+          /*\n+            Advance the scanning pointer.  If we are at the start\n+            of a quoted string or a comment, then skip the entire unit */\n+          ch = *(text++);\n+\n+          switch (ch)\n+            {\n+            case '/':\n+              /*\n+                Skip comments */\n+              if (*text == '*')\n+                {\n+                  text = strstr( text+1, \"*/\" );\n+                  if (text == (char*)NULL)\n+                    return SKIP_FIX;\n+                  text += 2;\n+                  continue;\n+                }\n+              break;\n+\n+            case '\"':\n+            case '\\'':\n+              text = skip_quote( ch, text );\n+              break;\n+            } /* switch (ch) */\n+          continue;\n+        } /* if (still shy of directive end) */\n+\n+      /*\n+         The scanning pointer (text) has reached the end of the current\n+         directive under test, then check for bogons here */\n+      for (;;) /* bogon check */\n+        {\n+          char ch = *(pz_next++);\n+          if (isspace (ch))\n+            {\n+              if (ch == '\\n')\n+                {\n+                  /*\n+                    It is clean.  No bogons on this directive */\n+                  text = pz_next;\n+                  pz_next = (char*)NULL; /* force a new regex search */\n+                  break;\n+                }\n+              continue;\n+            }\n+\n+          switch (ch)\n+            {\n+            case '\\\\':\n+              /*\n+                Skip escaped newlines.  Otherwise, we have a bogon */\n+              if (*pz_next != '\\n')\n+                return APPLY_FIX;\n+\n+              pz_next++;\n+              break;\n+\n+            case '/':\n+              /*\n+                Skip comments.  Otherwise, we have a bogon */\n+              if (*pz_next == '*')\n+                {\n+                  pz_next = strstr( pz_next+1, \"*/\" );\n+                  if (pz_next == (char*)NULL)\n+                    return SKIP_FIX;\n+                  pz_next += 2;\n+                  break;\n+                }\n+\n+              /*\n+                FIXME:  if this is a C++ file, then a double slash comment\n+                is allowed to follow the directive.  */\n+\n+              /* FALLTHROUGH */\n+\n+            default:\n+              /*\n+                GOTTA BE A BOGON */\n+              return APPLY_FIX;\n+            } /* switch (ch) */\n+        } /* for (bogon check loop) */\n+    } /* for (entire file) loop */\n+\n+  return SKIP_FIX;\n+}\n+\n /* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =\n \n      test for fix selector\n@@ -179,6 +307,7 @@ run_test( tname, fname, text )\n     {\n       if (strcmp( pte->test_name, tname ) == 0)\n         return (*pte->test_proc)( fname, text );\n+      pte++;\n     } while (--ct > 0);\n   fprintf( stderr, \"fixincludes error:  the `%s' fix test is unknown\\n\",\n            tname );"}, {"sha": "5802d1ea27226ce1638f28ec80921e9c037f0575", "filename": "gcc/fixinc/inclhack.def", "status": "modified", "additions": 3, "deletions": 40, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.def?ref=8f9ca9127473a43ba75f03fbfc30c32e9984c982", "patch": "@@ -527,47 +527,10 @@ fix = {\n \n     /*\n      *  Select files that contain '#endif' or '#else' directives with\n-     *  some sort of following junk.  (Between the ascii '.'\n-     *  and '0' lies the character '/'.  This will *NOT*\n-     *  match '#endif / * foo * /', but it also wont match\n-     *  '#endif / done' either.\n-     *\n-     *  We have a second regexp in the selector to detect\n-     *  #endif followed by a / followed by anything other\n-     *  than a *.  For example \"#endif / * foo * /\" or \n-     *  \"#endif /% blah %/ which appear on OSF4.0A and AIX4.2\n-     *  repsectively.\n-     * \n-     *  We use the pattern [!-.0-z{|}~] instead of [^/ \\t] to match a\n-     *  noncomment following #else or #endif because some buggy egreps\n-     *  think [^/] matches newline, and they thus think `#else ' matches\n-     *  `#e[ndiflse]*[ \\t]+[^/ \\t]'.\n-     *  [!-.0-~] does not work properly on AIX 4.1.\n-     */\n-    select   = \"^[ \\t]*#[ \\t]*(else|endif)[ \\t]+\"\n-               \"(\"  '[!-.0-z\\{\\|\\}\\~]'  \"|\"  '/[^\\*]'  \")\";\n-\n-    /*\n-     *  First, join the continued input lines.\n-     *  IF the resulting line is an endif preprocessing directive,\n-     *  then trim off the following patterns:\n-     *  1.  sequences that start with '/' and is *NOT* followed by '*'\n-     *  2.  Sequences that start with '*' and is *NOT* followed by '/'\n-     *  3.  sequences that do not start with any of '/', '*', '\\t' or ' '.\n-     *\n-     * The fixinc_eol stuff is to work around a bug in the sed\n+     *  some sort of following junk.\n      */\n-    sed =      \":loop\\n\"\n-               '/\\\\\\\\$/'                       \"N\\n\"\n-               's/\\\\\\\\$/\\\\\\\\+++fixinc_eol+++/' \"\\n\"\n-               '/\\\\\\\\$/'                       \"b loop\\n\"\n-               's/\\\\\\\\+++fixinc_eol+++/\\\\\\\\/g' \"\\n\"\n-\n-               \"s%^\\\\([ \\t]*#[ \\t]*else\\\\)[ \\t][ \\t]*/[^*].*%\\\\1%\\n\"\n-               \"s%^\\\\([ \\t]*#[ \\t]*else\\\\)[ \\t][ \\t]*[^/ \\t].*%\\\\1%\\n\"\n-               \"s%^\\\\([ \\t]*#[ \\t]*endif\\\\)[ \\t][ \\t]*/[^*].*%\\\\1%\\n\"\n-               \"s%^\\\\([ \\t]*#[ \\t]*endif\\\\)[ \\t][ \\t]*\\\\*[^/].*%\\\\1%\\n\"\n-               \"s%^\\\\([ \\t]*#[ \\t]*endif\\\\)[ \\t][ \\t]*[^/* \\t].*%\\\\1%\";\n+    c_test = \"else_endif_label\";\n+    c_fix  = \"else_endif_label\";\n };\n \n "}, {"sha": "7ad7648ff5ea32e7b28849106897503a08af55ae", "filename": "gcc/fixinc/inclhack.sh", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2Finclhack.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9ca9127473a43ba75f03fbfc30c32e9984c982/gcc%2Ffixinc%2Finclhack.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.sh?ref=8f9ca9127473a43ba75f03fbfc30c32e9984c982", "patch": "@@ -979,28 +979,17 @@ extern \"C\"\\\n     #\n     # Fix  27:  End_Else_Label\n     #\n-    if ( test -n \"`egrep '^[ \t]*#[ \t]*(else|endif)[ \t]+([!-.0-z\\\\{\\\\|\\\\}\\\\~]|/[^\\\\*])' ${file}`\"\n-       ) > /dev/null 2>&1 ; then\n+    if ${FIXTESTS} ${file} else_endif_label\n+    then\n     fixlist=\"${fixlist}\n       end_else_label\"\n     if [ ! -r ${DESTFILE} ]\n     then infile=${file}\n     else infile=${DESTFILE} ; fi \n-\n-    sed -e ':loop\n-/\\\\$/N\n-s/\\\\$/\\\\+++fixinc_eol+++/\n-/\\\\$/b loop\n-s/\\\\+++fixinc_eol+++/\\\\/g\n-s%^\\([ \t]*#[ \t]*else\\)[ \t][ \t]*/[^*].*%\\1%\n-s%^\\([ \t]*#[ \t]*else\\)[ \t][ \t]*[^/ \t].*%\\1%\n-s%^\\([ \t]*#[ \t]*endif\\)[ \t][ \t]*/[^*].*%\\1%\n-s%^\\([ \t]*#[ \t]*endif\\)[ \t][ \t]*\\*[^/].*%\\1%\n-s%^\\([ \t]*#[ \t]*endif\\)[ \t][ \t]*[^/* \t].*%\\1%' \\\n-          < $infile > ${DESTDIR}/fixinc.tmp\n+    ${FIXFIXES} ${file} else_endif_label < $infile > ${DESTDIR}/fixinc.tmp\n     rm -f ${DESTFILE}\n     mv -f ${DESTDIR}/fixinc.tmp ${DESTFILE}\n-    fi # end of select 'if'\n+    fi # end of c_test 'if'\n \n \n     #"}]}