{"sha": "1cc521f1a824b5913aeda06ebe296de98f2d9453", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNjNTIxZjFhODI0YjU5MTNhZWRhMDZlYmUyOTZkZTk4ZjJkOTQ1Mw==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2017-12-07T14:49:54Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2017-12-07T14:49:54Z"}, "message": "Add unroll and jam pass\n\n\t* gimple-loop-jam.c: New file.\n\t* Makefile.in (OBJS): Add gimple-loop-jam.o.\n\t* common.opt (funroll-and-jam): New option.\n\t* opts.c (default_options_table): Add unroll-and-jam at -O3.\n\t* params.def (PARAM_UNROLL_JAM_MIN_PERCENT): New param.\n\t(PARAM_UNROLL_JAM_MAX_UNROLL): Ditto.\n\t* passes.def: Add pass_loop_jam.\n\t* timevar.def (TV_LOOP_JAM): Add.\n\t* tree-pass.h (make_pass_loop_jam): Declare.\n\t* cfgloop.c (flow_loop_tree_node_add): Add AFTER argument.\n\t* cfgloop.h (flow_loop_tree_node_add): Adjust declaration.\n\t* cfgloopmanip.c (duplicate_loop): Add AFTER argument, adjust call\n\tto flow_loop_tree_node_add.\n\t(duplicate_subloops, copy_loops_to): Append to sibling list.\n\t* cfgloopmanip.h: (duplicate_loop): Adjust declaration.\n\t* doc/invoke.texi (-funroll-and-jam): Document new option.\n\t(unroll-jam-min-percent, unroll-jam-max-unroll): Document new params.\n\ntestsuite/\n\t* gcc.dg/unroll-and-jam.c: New test.\n\nFrom-SVN: r255467", "tree": {"sha": "906285fc77b9852eb7e207a988b9d0144496c8b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/906285fc77b9852eb7e207a988b9d0144496c8b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cc521f1a824b5913aeda06ebe296de98f2d9453", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cc521f1a824b5913aeda06ebe296de98f2d9453", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cc521f1a824b5913aeda06ebe296de98f2d9453", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cc521f1a824b5913aeda06ebe296de98f2d9453/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a40ae3c3acf7eaabc9599f5701adbd2f6ec607e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a40ae3c3acf7eaabc9599f5701adbd2f6ec607e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a40ae3c3acf7eaabc9599f5701adbd2f6ec607e"}], "stats": {"total": 814, "additions": 790, "deletions": 24}, "files": [{"sha": "1a9a401cb772f4455bb958574aca677f6e23d466", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -1,3 +1,25 @@\n+2017-12-07  Michael Matz  <matz@suse.de>\n+\n+\tAdd unroll and jam pass\n+\n+\t* gimple-loop-jam.c: New file.\n+\t* Makefile.in (OBJS): Add gimple-loop-jam.o.\n+\t* common.opt (funroll-and-jam): New option.\n+\t* opts.c (default_options_table): Add unroll-and-jam at -O3.\n+\t* params.def (PARAM_UNROLL_JAM_MIN_PERCENT): New param.\n+\t(PARAM_UNROLL_JAM_MAX_UNROLL): Ditto.\n+\t* passes.def: Add pass_loop_jam.\n+\t* timevar.def (TV_LOOP_JAM): Add.\n+\t* tree-pass.h (make_pass_loop_jam): Declare.\n+\t* cfgloop.c (flow_loop_tree_node_add): Add AT argument.\n+\t* cfgloop.h (flow_loop_tree_node_add): Adjust declaration.\n+\t* cfgloopmanip.c (duplicate_loop): Add AT argument, adjust call\n+\tto flow_loop_tree_node_add.\n+\t(duplicate_subloops, copy_loops_to): Append to sibling list.\n+\t* cfgloopmanip.h: (duplicate_loop): Adjust declaration.\n+\t* doc/invoke.texi (-funroll-and-jam): Document new option.\n+\t(unroll-jam-min-percent, unroll-jam-max-unroll): Document new params.\n+\n 2017-12-07  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/83296"}, {"sha": "ff92e3b59c2ae406714a238b15059f02ede90905", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -1302,6 +1302,7 @@ OBJS = \\\n \tgimple-iterator.o \\\n \tgimple-fold.o \\\n \tgimple-laddress.o \\\n+\tgimple-loop-jam.o \\\n \tgimple-low.o \\\n \tgimple-pretty-print.o \\\n \tgimple-ssa-backprop.o \\"}, {"sha": "0d8cf1e5688200b02d909689b012119c78c4924c", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -296,13 +296,25 @@ establish_preds (struct loop *loop, struct loop *father)\n \n /* Add LOOP to the loop hierarchy tree where FATHER is father of the\n    added loop.  If LOOP has some children, take care of that their\n-   pred field will be initialized correctly.  */\n+   pred field will be initialized correctly.  If AFTER is non-null\n+   then it's expected it's a pointer into FATHERs inner sibling\n+   list and LOOP is added behind AFTER, otherwise it's added in front\n+   of FATHERs siblings.  */\n \n void\n-flow_loop_tree_node_add (struct loop *father, struct loop *loop)\n+flow_loop_tree_node_add (struct loop *father, struct loop *loop,\n+\t\t\t struct loop *after)\n {\n-  loop->next = father->inner;\n-  father->inner = loop;\n+  if (after)\n+    {\n+      loop->next = after->next;\n+      after->next = loop;\n+    }\n+  else\n+    {\n+      loop->next = father->inner;\n+      father->inner = loop;\n+    }\n \n   establish_preds (loop, father);\n }"}, {"sha": "ff88933fdcdbae4b58fe4a95b6d0b8eeea61c24b", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -342,7 +342,8 @@ void rescan_loop_exit (edge, bool, bool);\n void sort_sibling_loops (function *);\n \n /* Loop data structure manipulation/querying.  */\n-extern void flow_loop_tree_node_add (struct loop *, struct loop *);\n+extern void flow_loop_tree_node_add (struct loop *, struct loop *,\n+\t\t\t\t     struct loop * = NULL);\n extern void flow_loop_tree_node_remove (struct loop *);\n extern bool flow_loop_nested_p\t(const struct loop *, const struct loop *);\n extern bool flow_bb_inside_loop_p (const struct loop *, const_basic_block);"}, {"sha": "3fa499acd57b6f749530d09d5d0b78b47cbc2b6f", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -1000,9 +1000,11 @@ copy_loop_info (struct loop *loop, struct loop *target)\n }\n \n /* Copies copy of LOOP as subloop of TARGET loop, placing newly\n-   created loop into loops structure.  */\n+   created loop into loops structure.  If AFTER is non-null\n+   the new loop is added at AFTER->next, otherwise in front of TARGETs\n+   sibling list.  */\n struct loop *\n-duplicate_loop (struct loop *loop, struct loop *target)\n+duplicate_loop (struct loop *loop, struct loop *target, struct loop *after)\n {\n   struct loop *cloop;\n   cloop = alloc_loop ();\n@@ -1014,36 +1016,46 @@ duplicate_loop (struct loop *loop, struct loop *target)\n   set_loop_copy (loop, cloop);\n \n   /* Add it to target.  */\n-  flow_loop_tree_node_add (target, cloop);\n+  flow_loop_tree_node_add (target, cloop, after);\n \n   return cloop;\n }\n \n /* Copies structure of subloops of LOOP into TARGET loop, placing\n-   newly created loops into loop tree.  */\n+   newly created loops into loop tree at the end of TARGETs sibling\n+   list in the original order.  */\n void\n duplicate_subloops (struct loop *loop, struct loop *target)\n {\n-  struct loop *aloop, *cloop;\n+  struct loop *aloop, *cloop, *tail;\n \n+  for (tail = target->inner; tail && tail->next; tail = tail->next)\n+    ;\n   for (aloop = loop->inner; aloop; aloop = aloop->next)\n     {\n-      cloop = duplicate_loop (aloop, target);\n+      cloop = duplicate_loop (aloop, target, tail);\n+      tail = cloop;\n+      gcc_assert(!tail->next);\n       duplicate_subloops (aloop, cloop);\n     }\n }\n \n /* Copies structure of subloops of N loops, stored in array COPIED_LOOPS,\n-   into TARGET loop, placing newly created loops into loop tree.  */\n+   into TARGET loop, placing newly created loops into loop tree adding\n+   them to TARGETs sibling list at the end in order.  */\n static void\n copy_loops_to (struct loop **copied_loops, int n, struct loop *target)\n {\n-  struct loop *aloop;\n+  struct loop *aloop, *tail;\n   int i;\n \n+  for (tail = target->inner; tail && tail->next; tail = tail->next)\n+    ;\n   for (i = 0; i < n; i++)\n     {\n-      aloop = duplicate_loop (copied_loops[i], target);\n+      aloop = duplicate_loop (copied_loops[i], target, tail);\n+      tail = aloop;\n+      gcc_assert(!tail->next);\n       duplicate_subloops (copied_loops[i], aloop);\n     }\n }\n@@ -1072,14 +1084,15 @@ can_duplicate_loop_p (const struct loop *loop)\n }\n \n /* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating\n-   loop structure and dominators.  E's destination must be LOOP header for\n-   this to work, i.e. it must be entry or latch edge of this loop; these are\n-   unique, as the loops must have preheaders for this function to work\n-   correctly (in case E is latch, the function unrolls the loop, if E is entry\n-   edge, it peels the loop).  Store edges created by copying ORIG edge from\n-   copies corresponding to set bits in WONT_EXIT bitmap (bit 0 corresponds to\n-   original LOOP body, the other copies are numbered in order given by control\n-   flow through them) into TO_REMOVE array.  Returns false if duplication is\n+   loop structure and dominators (order of inner subloops is retained).\n+   E's destination must be LOOP header for this to work, i.e. it must be entry\n+   or latch edge of this loop; these are unique, as the loops must have\n+   preheaders for this function to work correctly (in case E is latch, the\n+   function unrolls the loop, if E is entry edge, it peels the loop).  Store\n+   edges created by copying ORIG edge from copies corresponding to set bits in\n+   WONT_EXIT bitmap (bit 0 corresponds to original LOOP body, the other copies\n+   are numbered in order given by control flow through them) into TO_REMOVE\n+   array.  Returns false if duplication is\n    impossible.  */\n \n bool"}, {"sha": "725c4be382a1f7db32e245efd312fb9e2ff5e4a1", "filename": "gcc/cfgloopmanip.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fcfgloopmanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fcfgloopmanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.h?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -47,7 +47,8 @@ extern struct loop *loopify (edge, edge,\n \t\t\t     profile_probability, profile_probability);\n extern void unloop (struct loop *, bool *, bitmap);\n extern void copy_loop_info (struct loop *loop, struct loop *target);\n-extern struct loop * duplicate_loop (struct loop *, struct loop *);\n+extern struct loop * duplicate_loop (struct loop *, struct loop *,\n+\t\t\t\t     struct loop * = NULL);\n extern void duplicate_subloops (struct loop *, struct loop *);\n extern bool can_duplicate_loop_p (const struct loop *loop);\n extern bool duplicate_loop_to_header_edge (struct loop *, edge,"}, {"sha": "682755f398a664db5293d91740f5b2cac17fccac", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -2695,6 +2695,10 @@ fsplit-loops\n Common Report Var(flag_split_loops) Optimization\n Perform loop splitting.\n \n+funroll-and-jam\n+Common Report Var(flag_unroll_jam) Optimization\n+Perform unroll-and-jam on loops.\n+\n funwind-tables\n Common Report Var(flag_unwind_tables) Optimization\n Just generate unwind tables for exception handling."}, {"sha": "447b66acc7761ff4e8a697d9a1556975d04cff53", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -437,7 +437,7 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-reassoc  -ftree-sink  -ftree-slsr  -ftree-sra @gol\n -ftree-switch-conversion  -ftree-tail-merge @gol\n -ftree-ter  -ftree-vectorize  -ftree-vrp  -funconstrained-commons @gol\n--funit-at-a-time  -funroll-all-loops  -funroll-loops @gol\n+-funit-at-a-time  -funroll-all-loops  -funroll-loops -funroll-and-jam @gol\n -funsafe-math-optimizations  -funswitch-loops @gol\n -fipa-ra  -fvariable-expansion-in-unroller  -fvect-cost-model  -fvpt @gol\n -fweb  -fwhole-program  -fwpa  -fuse-linker-plugin @gol\n@@ -9771,6 +9771,12 @@ for one side of the iteration space and false for the other.\n Move branches with loop invariant conditions out of the loop, with duplicates\n of the loop on both branches (modified according to result of the condition).\n \n+@item -funroll-and-jam\n+@opindex funroll-and-jam\n+Apply unroll and jam transoformations on feasible loops.  In a loop\n+nest this unrolls the outer loop by some factor and fuses the resulting\n+multiple inner loops.\n+\n @item -ffunction-sections\n @itemx -fdata-sections\n @opindex ffunction-sections\n@@ -10838,6 +10844,14 @@ we may be able to devirtualize speculatively.\n @item max-vrp-switch-assertions\n The maximum number of assertions to add along the default edge of a switch\n statement during VRP.  The default is 10.\n+\n+@item unroll-jam-min-percent\n+The minimum percentage of memory references that must be optimized\n+away for the unroll-and-jam transformation to be considered profitable.\n+\n+@item unroll-jam-max-unroll\n+The maximum number of times the outer loop should be unrolled by\n+the unroll-and-jam transformation.\n @end table\n @end table\n "}, {"sha": "32f813b13e1efdf4f0d8f5d2f36e5a0398cae62d", "filename": "gcc/gimple-loop-jam.c", "status": "added", "additions": 569, "deletions": 0, "changes": 569, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fgimple-loop-jam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fgimple-loop-jam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-jam.c?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -0,0 +1,569 @@\n+/* Loop unroll-and-jam.\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 3, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"params.h\"\n+#include \"tree-pass.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"fold-const.h\"\n+#include \"tree-cfg.h\"\n+#include \"tree-ssa.h\"\n+#include \"tree-ssa-loop-niter.h\"\n+#include \"tree-ssa-loop.h\"\n+#include \"tree-ssa-loop-manip.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cfghooks.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-ssa-loop-ivopts.h\"\n+#include \"tree-vectorizer.h\"\n+\n+/* Unroll and Jam transformation\n+   \n+   This is a combination of two transformations, where the second\n+   is not always valid.  It's applicable if a loop nest has redundancies\n+   over the iterations of an outer loop while not having that with\n+   an inner loop.\n+\n+   Given this nest:\n+       for (i) {\n+\t for (j) {\n+\t   B(i,j)\n+\t }\n+       }\n+\n+   first unroll:\n+       for (i by 2) {\n+\t for (j) {\n+\t   B(i,j)\n+\t }\n+\t for (j) {\n+\t   B(i+1,j)\n+\t }\n+       }\n+\n+   then fuse the two adjacent inner loops resulting from that:\n+       for (i by 2) {\n+\t for (j) {\n+\t   B(i,j)\n+\t   B(i+1,j)\n+\t }\n+       }\n+\n+   As the order of evaluations of the body B changes this is valid\n+   only in certain situations: all distance vectors need to be forward.\n+   Additionally if there are multiple induction variables than just\n+   a counting control IV (j above) we can also deal with some situations.\n+\n+   The validity is checked by unroll_jam_possible_p, and the data-dep\n+   testing below.\n+\n+   A trivial example where the fusion is wrong would be when\n+   B(i,j) == x[j-1] = x[j];\n+       for (i by 2) {\n+\t for (j) {\n+\t   x[j-1] = x[j];\n+\t }\n+\t for (j) {\n+\t   x[j-1] = x[j];\n+\t }\n+       }  effect: move content to front by two elements\n+       -->\n+       for (i by 2) {\n+\t for (j) {\n+\t   x[j-1] = x[j];\n+\t   x[j-1] = x[j];\n+\t }\n+       }  effect: move content to front by one element\n+*/\n+\n+/* Modify the loop tree for the fact that all code once belonging\n+   to the OLD loop or the outer loop of OLD now is inside LOOP.  */\n+\n+static void\n+merge_loop_tree (struct loop *loop, struct loop *old)\n+{\n+  basic_block *bbs;\n+  int i, n;\n+  struct loop *subloop;\n+  edge e;\n+  edge_iterator ei;\n+\n+  /* Find its nodes.  */\n+  bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n+  n = get_loop_body_with_size (loop, bbs, n_basic_blocks_for_fn (cfun));\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      /* If the block was direct child of OLD loop it's now part\n+         of LOOP.  If it was outside OLD, then it moved into LOOP\n+\t as well.  This avoids changing the loop father for BBs\n+\t in inner loops of OLD.  */\n+      if (bbs[i]->loop_father == old\n+\t  || loop_depth (bbs[i]->loop_father) < loop_depth (old))\n+\t{\n+\t  remove_bb_from_loops (bbs[i]);\n+\t  add_bb_to_loop (bbs[i], loop);\n+\t  continue;\n+\t}\n+\n+      /* If we find a direct subloop of OLD, move it to LOOP.  */\n+      subloop = bbs[i]->loop_father;\n+      if (loop_outer (subloop) == old && subloop->header == bbs[i])\n+\t{\n+\t  flow_loop_tree_node_remove (subloop);\n+\t  flow_loop_tree_node_add (loop, subloop);\n+\t}\n+    }\n+\n+  /* Update the information about loop exit edges.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n+\t{\n+\t  rescan_loop_exit (e, false, false);\n+\t}\n+    }\n+\n+  loop->num_nodes = n;\n+\n+  free (bbs);\n+}\n+\n+/* BB exits the outer loop of an unroll-and-jam situation.\n+   Check if any statements therein would prevent the transformation.  */\n+\n+static bool\n+bb_prevents_fusion_p (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+  /* BB is duplicated by outer unrolling and then all N-1 first copies\n+     move into the body of the fused inner loop.  The last copy remains\n+     the exit block of the outer loop and is still outside the inner loop\n+     also after fusion.  We can't allow this for some effects of BB:\n+       * stores or unknown side-effects prevent fusion\n+       * loads don't\n+       * computations into SSA names: these aren't problematic.  Their\n+         result will be unused on the exit edges of the first N-1 copies\n+\t (those aren't taken after unrolling).  If they are used on the\n+\t other edge (the one leading to the outer latch block) they are\n+\t loop-carried (on the outer loop) and the Nth copy of BB will\n+\t compute them again (i.e. the first N-1 copies will be dead).  */\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *g = gsi_stmt (gsi);\n+      if (gimple_vdef (g) || gimple_has_side_effects (g))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Given an inner loop LOOP (of some OUTER loop) determine if\n+   we can safely fuse copies of it (generated by outer unrolling).\n+   If so return true, otherwise return false.  */\n+\n+static bool\n+unroll_jam_possible_p (struct loop *outer, struct loop *loop)\n+{\n+  basic_block *bbs;\n+  int i, n;\n+  struct tree_niter_desc niter;\n+\n+  /* When fusing the loops we skip the latch block\n+     of the first one, so it mustn't have any effects to\n+     preserve.  */\n+  if (!empty_block_p (loop->latch))\n+    return false;\n+\n+  if (!single_exit (loop))\n+    return false;\n+\n+  /* We need a perfect nest.  Quick check for adjacent inner loops.  */\n+  if (outer->inner != loop || loop->next)\n+    return false;\n+\n+  /* The number of iterations of the inner loop must be loop invariant\n+     with respect to the outer loop.  */\n+  if (!number_of_iterations_exit (loop, single_exit (loop), &niter,\n+\t\t\t\t false, true)\n+      || niter.cmp == ERROR_MARK\n+      || !integer_zerop (niter.may_be_zero)\n+      || !expr_invariant_in_loop_p (outer, niter.niter))\n+    return false;\n+\n+  /* And check blocks belonging to just outer loop.  */\n+  bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));\n+  n = get_loop_body_with_size (outer, bbs, n_basic_blocks_for_fn (cfun));\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      if (bbs[i]->loop_father == outer\n+\t  && bbs[i] != outer->latch && bbs[i] != outer->header\n+\t  && (!loop_exits_from_bb_p (outer, bbs[i])\n+\t      || bb_prevents_fusion_p (bbs[i])))\n+\tbreak;\n+      /* XXX Note that the above disallows head-controlled inner loops,\n+         that we usually have.  The guard block would need to be accepted\n+\t (invariant condition either entering or skipping the loop),\n+\t without also accepting arbitrary control flow.  When unswitching\n+\t ran before us (as with -O3) this won't be a problem because its\n+\t outer loop unswitching will have moved out the invariant condition.\n+\t \n+\t If we do that we need to extend fuse_loops() to cope with this\n+\t by threading through the (still invariant) copied condition\n+\t between the two loop copies.  */\n+    }\n+  free (bbs);\n+  if (i != n)\n+    return false;\n+\n+  /* For now we can safely fuse copies of LOOP only if all\n+     loop carried variables are inductions (or the virtual op).\n+\n+     We could handle reductions as well (the initial value in the second\n+     body would be the after-iter value of the first body) if it's over\n+     an associative and commutative operation.  We wouldn't\n+     be able to handle unknown cycles.  */\n+  gphi_iterator psi;\n+  for (psi = gsi_start_phis (loop->header); !gsi_end_p (psi); gsi_next (&psi))\n+    {\n+      affine_iv iv;\n+      tree op = gimple_phi_result (psi.phi ());\n+\n+      if (virtual_operand_p (op))\n+\tcontinue;\n+      if (!simple_iv (loop, loop, op, &iv, true))\n+\treturn false;\n+      /* The inductions must be regular, loop invariant step and initial\n+         value.  */\n+      if (!expr_invariant_in_loop_p (outer, iv.step)\n+\t  || !expr_invariant_in_loop_p (outer, iv.base))\n+\treturn false;\n+      /* XXX With more effort we could also be able to deal with inductions\n+         where the initial value is loop variant but a simple IV in the\n+\t outer loop.  The initial value for the second body would be\n+\t the original initial value plus iv.base.step.  The next value\n+\t for the fused loop would be the original next value of the first\n+\t copy, _not_ the next value of the second body.  */\n+    }\n+\n+  return true;\n+}\n+\n+/* Fuse LOOP with all further neighbors.  The loops are expected to\n+   be in appropriate form.  */\n+\n+static void\n+fuse_loops (struct loop *loop)\n+{\n+  struct loop *next = loop->next;\n+\n+  while (next)\n+    {\n+      edge e;\n+\n+      remove_branch (single_pred_edge (loop->latch));\n+      /* Make delete_basic_block not fiddle with the loop structure.  */\n+      basic_block oldlatch = loop->latch;\n+      loop->latch = NULL;\n+      delete_basic_block (oldlatch);\n+      e = redirect_edge_and_branch (loop_latch_edge (next),\n+\t\t\t\t    loop->header);\n+      loop->latch = e->src;\n+      flush_pending_stmts (e);\n+\n+      gcc_assert (EDGE_COUNT (next->header->preds) == 1);\n+\n+      /* The PHI nodes of the second body (single-argument now)\n+         need adjustments to use the right values: either directly\n+\t the value of the corresponding PHI in the first copy or\n+\t the one leaving the first body which unrolling did for us.\n+\n+\t See also unroll_jam_possible_p() for further possibilities.  */\n+      gphi_iterator psi_first, psi_second;\n+      e = single_pred_edge (next->header);\n+      for (psi_first = gsi_start_phis (loop->header),\n+\t   psi_second = gsi_start_phis (next->header);\n+\t   !gsi_end_p (psi_first);\n+\t   gsi_next (&psi_first), gsi_next (&psi_second))\n+\t{\n+\t  gphi *phi_first = psi_first.phi ();\n+\t  gphi *phi_second = psi_second.phi ();\n+\t  tree firstop = gimple_phi_result (phi_first);\n+\t  /* The virtual operand is correct already as it's\n+\t     always live at exit, hence has a LCSSA node and outer\n+\t     loop unrolling updated SSA form.  */\n+\t  if (virtual_operand_p (firstop))\n+\t    continue;\n+\n+\t  /* Due to unroll_jam_possible_p() we know that this is\n+\t     an induction.  The second body goes over the same\n+\t     iteration space.  */\n+\t  add_phi_arg (phi_second, firstop, e,\n+\t\t       gimple_location (phi_first));\n+\t}\n+      gcc_assert (gsi_end_p (psi_second));\n+\n+      merge_loop_tree (loop, next);\n+      gcc_assert (!next->num_nodes);\n+      struct loop *ln = next->next;\n+      delete_loop (next);\n+      next = ln;\n+    }\n+  rewrite_into_loop_closed_ssa_1 (NULL, 0, SSA_OP_USE, loop);\n+}\n+\n+/* Returns true if the distance in DDR can be determined and adjusts\n+   the unroll factor in *UNROLL to make unrolling valid for that distance.\n+   Otherwise return false.\n+\n+   If this data dep can lead to a removed memory reference, increment\n+   *REMOVED and adjust *PROFIT_UNROLL to be the necessary unroll factor\n+   for this to happen.  */\n+\n+static bool\n+adjust_unroll_factor (struct data_dependence_relation *ddr,\n+\t\t      unsigned *unroll, unsigned *profit_unroll,\n+\t\t      unsigned *removed)\n+{\n+  bool ret = false;\n+  if (DDR_ARE_DEPENDENT (ddr) != chrec_known)\n+    {\n+      if (DDR_NUM_DIST_VECTS (ddr) == 0)\n+\treturn false;\n+      unsigned i;\n+      lambda_vector dist_v;\n+      FOR_EACH_VEC_ELT (DDR_DIST_VECTS (ddr), i, dist_v)\n+\t{\n+\t  /* A distance (a,b) is at worst transformed into (a/N,b) by the\n+\t     unrolling (factor N), so the transformation is valid if\n+\t     a >= N, or b > 0, or b is zero and a > 0.  Otherwise the unroll\n+\t     factor needs to be limited so that the first condition holds.\n+\t     That may limit the factor down to zero in the worst case.  */\n+\t  int dist = dist_v[0];\n+\t  if (dist < 0)\n+\t    gcc_unreachable ();\n+\t  else if ((unsigned)dist >= *unroll)\n+\t    ;\n+\t  else if (lambda_vector_lexico_pos (dist_v + 1, DDR_NB_LOOPS (ddr) - 1)\n+\t\t   || (lambda_vector_zerop (dist_v + 1, DDR_NB_LOOPS (ddr) - 1)\n+\t\t       && dist > 0))\n+\t    ;\n+\t  else\n+\t    *unroll = dist;\n+\n+\t  /* With a distance (a,0) it's always profitable to unroll-and-jam\n+\t     (by a+1), because one memory reference will go away.  With\n+\t     (a,b) and b != 0 that's less clear.  We will increase the\n+\t     number of streams without lowering the number of mem refs.\n+\t     So for now only handle the first situation.  */\n+\t  if (lambda_vector_zerop (dist_v + 1, DDR_NB_LOOPS (ddr) - 1))\n+\t    {\n+\t      *profit_unroll = MAX (*profit_unroll, (unsigned)dist + 1);\n+\t      (*removed)++;\n+\t    }\n+\n+\t  ret = true;\n+\t}\n+    }\n+  return ret;\n+}\n+\n+/* Main entry point for the unroll-and-jam transformation\n+   described above.  */\n+\n+static unsigned int\n+tree_loop_unroll_and_jam (void)\n+{\n+  struct loop *loop;\n+  bool changed = false;\n+\n+  gcc_assert (scev_initialized_p ());\n+\n+  /* Go through all innermost loops.  */\n+  FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n+    {\n+      struct loop *outer = loop_outer (loop);\n+\n+      if (loop_depth (loop) < 2\n+\t  || optimize_loop_nest_for_size_p (outer))\n+\tcontinue;\n+\n+      if (!unroll_jam_possible_p (outer, loop))\n+\tcontinue;\n+\n+      vec<data_reference_p> datarefs;\n+      vec<ddr_p> dependences;\n+      unsigned unroll_factor, profit_unroll, removed;\n+      struct tree_niter_desc desc;\n+      bool unroll = false;\n+\n+      auto_vec<loop_p, 3> loop_nest;\n+      dependences.create (10);\n+      datarefs.create (10);\n+      if (!compute_data_dependences_for_loop (outer, true, &loop_nest,\n+\t\t\t\t\t       &datarefs, &dependences))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Cannot analyze data dependencies\\n\");\n+\t  free_data_refs (datarefs);\n+\t  free_dependence_relations (dependences);\n+\t  return false;\n+\t}\n+      if (!datarefs.length ())\n+\tcontinue;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tdump_data_dependence_relations (dump_file, dependences);\n+\n+      unroll_factor = (unsigned)-1;\n+      profit_unroll = 1;\n+      removed = 0;\n+\n+      /* Check all dependencies.  */\n+      unsigned i;\n+      struct data_dependence_relation *ddr;\n+      FOR_EACH_VEC_ELT (dependences, i, ddr)\n+\t{\n+\t  struct data_reference *dra, *drb;\n+\n+\t  /* If the refs are independend there's nothing to do.  */\n+\t  if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+\t    continue;\n+\t  dra = DDR_A (ddr);\n+\t  drb = DDR_B (ddr);\n+\t  /* Nothing interesting for the self dependencies.  */\n+\t  if (dra == drb)\n+\t    continue;\n+\n+\t  /* Now check the distance vector, for determining a sensible\n+\t     outer unroll factor, and for validity of merging the inner\n+\t     loop copies.  */\n+\t  if (!adjust_unroll_factor (ddr, &unroll_factor, &profit_unroll,\n+\t\t\t\t     &removed))\n+\t    {\n+\t      /* Couldn't get the distance vector.  For two reads that's\n+\t         harmless (we assume we should unroll).  For at least\n+\t\t one write this means we can't check the dependence direction\n+\t\t and hence can't determine safety.  */\n+\n+\t      if (DR_IS_WRITE (dra) || DR_IS_WRITE (drb))\n+\t\t{\n+\t\t  unroll_factor = 0;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* We regard a user-specified minimum percentage of zero as a request\n+         to ignore all profitability concerns and apply the transformation\n+\t always.  */\n+      if (!PARAM_VALUE (PARAM_UNROLL_JAM_MIN_PERCENT))\n+\tprofit_unroll = 2;\n+      else if (removed * 100 / datarefs.length ()\n+\t  < (unsigned)PARAM_VALUE (PARAM_UNROLL_JAM_MIN_PERCENT))\n+\tprofit_unroll = 1;\n+      if (unroll_factor > profit_unroll)\n+\tunroll_factor = profit_unroll;\n+      if (unroll_factor > (unsigned)PARAM_VALUE (PARAM_UNROLL_JAM_MAX_UNROLL))\n+\tunroll_factor = PARAM_VALUE (PARAM_UNROLL_JAM_MAX_UNROLL);\n+      unroll = (unroll_factor > 1\n+\t\t&& can_unroll_loop_p (outer, unroll_factor, &desc));\n+\n+      if (unroll)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS | TDF_DETAILS,\n+\t\t\t     find_loop_location (outer),\n+\t\t\t     \"applying unroll and jam with factor %d\\n\",\n+\t\t\t     unroll_factor);\n+\t  initialize_original_copy_tables ();\n+\t  tree_unroll_loop (outer, unroll_factor, single_dom_exit (outer),\n+\t\t\t    &desc);\n+\t  free_original_copy_tables ();\n+\t  fuse_loops (outer->inner);\n+\t  changed = true;\n+\t}\n+\n+      loop_nest.release ();\n+      free_dependence_relations (dependences);\n+      free_data_refs (datarefs);\n+    }\n+\n+  if (changed)\n+    {\n+      scev_reset ();\n+      free_dominance_info (CDI_DOMINATORS);\n+      return TODO_cleanup_cfg;\n+    }\n+  return 0;\n+}\n+\n+/* Pass boilerplate */\n+\n+namespace {\n+\n+const pass_data pass_data_loop_jam =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"unrolljam\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  TV_LOOP_JAM, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_loop_jam : public gimple_opt_pass\n+{\n+public:\n+  pass_loop_jam (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_loop_jam, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *) { return flag_unroll_jam != 0; }\n+  virtual unsigned int execute (function *);\n+\n+};\n+\n+unsigned int\n+pass_loop_jam::execute (function *fun)\n+{\n+  if (number_of_loops (fun) <= 1)\n+    return 0;\n+\n+  return tree_loop_unroll_and_jam ();\n+}\n+\n+}\n+\n+gimple_opt_pass *\n+make_pass_loop_jam (gcc::context *ctxt)\n+{\n+  return new pass_loop_jam (ctxt);\n+}"}, {"sha": "cb86b24ae235ad21585c2db0e850199cffcf4110", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -535,6 +535,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_1_PLUS_NOT_DEBUG, OPT_finline_functions_called_once, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_fsplit_loops, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_funswitch_loops, NULL, 1 },\n+    { OPT_LEVELS_3_PLUS, OPT_funroll_and_jam, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_fgcse_after_reload, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_vectorize, NULL, 1 },\n     { OPT_LEVELS_3_PLUS, OPT_ftree_slp_vectorize, NULL, 1 },"}, {"sha": "0f4b367335dfc99c90acf2d8342127d6c4afcb35", "filename": "gcc/params.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -1293,6 +1293,16 @@ DEFPARAM (PARAM_VECT_EPILOGUES_NOMASK,\n \t  \"Enable loop epilogue vectorization using smaller vector size.\",\n \t  0, 0, 1)\n \n+DEFPARAM(PARAM_UNROLL_JAM_MIN_PERCENT,\n+\t \"unroll-jam-min-percent\",\n+\t \"Minimum percentage of memrefs that must go away for unroll-and-jam to be considered profitable.\",\n+\t 1, 0, 100)\n+\n+DEFPARAM(PARAM_UNROLL_JAM_MAX_UNROLL,\n+\t \"unroll-jam-max-unroll\",\n+\t \"Maximum unroll factor for the unroll-and-jam transformation.\",\n+\t 4, 0, 0)\n+\n /*\n \n Local variables:"}, {"sha": "09bea09699e21508d5de83c1c58b9070e41ee586", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -273,6 +273,7 @@ along with GCC; see the file COPYING3.  If not see\n \t  NEXT_PASS (pass_tree_unswitch);\n \t  NEXT_PASS (pass_scev_cprop);\n \t  NEXT_PASS (pass_loop_split);\n+\t  NEXT_PASS (pass_loop_jam);\n \t  /* All unswitching, final value replacement and splitting can expose\n \t     empty loops.  Remove them now.  */\n \t  NEXT_PASS (pass_cd_dce);"}, {"sha": "5ee5db43106c192035453c2f9995ba71bc44ae39", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -1,3 +1,7 @@\n+2017-12-07  Michael Matz  <matz@suse.de>\n+\n+\t* gcc.dg/unroll-and-jam.c: New test.\n+\n 2017-12-07  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/83296"}, {"sha": "59d60abe1b69b69a7eca7951457d6c664466f642", "filename": "gcc/testsuite/gcc.dg/unroll-and-jam.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-and-jam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-and-jam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-and-jam.c?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -0,0 +1,111 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -funroll-and-jam --param unroll-jam-min-percent=0 -fdump-tree-unrolljam-details\" } */\n+/* { dg-require-effective-target int32plus } */\n+\n+#include <stdio.h>\n+extern unsigned int a[];\n+extern unsigned int b[];\n+extern unsigned int aa[][1024];\n+unsigned int checksum;\n+void checkaa(void)\n+{\n+  unsigned sum = 1;\n+  unsigned long i, j;\n+  for (i = 0; i < 1024; i++) {\n+      for (j = 0; j < 16; j++) {\n+\t  sum += aa[j][i]*31+47;\n+      }\n+  }\n+  checksum = checksum * 27 + sum;\n+  //printf(\"  %d\\n\", sum);\n+}\n+\n+void checkb(void)\n+{\n+  unsigned sum = 1;\n+  unsigned long i, j;\n+  for (i = 0; i < 1024; i++) {\n+      sum += b[i]*31+47;\n+  }\n+  checksum = checksum * 27 + sum;\n+  //printf(\"  %d\\n\", sum);\n+}\n+\n+#define TEST(name, body, test) \\\n+static void __attribute__((noinline,noclone)) name (unsigned long n, unsigned long m) \\\n+{ \\\n+  unsigned long i, j; \\\n+  for (i = 1; i < m; i++) { \\\n+      for (j = 1; j < n; j++) { \\\n+\t  body; \\\n+      } \\\n+  } \\\n+  test; \\\n+} \\\n+static void __attribute__((noinline,noclone,optimize(\"O1\"))) name ## noopt (unsigned long n, unsigned long m) \\\n+{ \\\n+  unsigned long i, j; \\\n+  for (i = 1; i < m; i++) { \\\n+      for (j = 1; j < n; j++) { \\\n+\t  body; \\\n+      } \\\n+  } \\\n+  test; \\\n+}\n+TEST(foo1, aa[i+1][j+1]=aa[i][j] * aa[i][j] / 2, checkaa()) //ok, -1,-1\n+TEST(foo2, aa[i][j+1]=3*aa[i+1][j], checkaa()) //notok, 1,-1\n+TEST(foo3, aa[i+1][j-1]=aa[i][j] * aa[i][j] / 2, checkaa()) //notok, -1,1\n+TEST(foo4, aa[i][j] = aa[i-1][j+1] * aa[i-1][j+1] / 2, checkaa()) //notok, -1,1\n+TEST(foo5, aa[i][j] = aa[i+1][j+1] * aa[i+1][j+1] / 2, checkaa()) //ok, 1,1\n+TEST(foo6, aa[i][j] = aa[i+1][j] * aa[i+1][j] / 2, checkaa()) //ok, -1,0\n+TEST(foo7, aa[i+1][j] = aa[i][j] * aa[i][j] / 2, checkaa()) //ok, 1,0\n+TEST(foo9, b[j] = 3*b[j+1] + 1, checkb()) //notok, 0,-1\n+TEST(foo10, b[j] = 3*b[j] + 1, checkb()) //ok, 0,0\n+\n+/* foo8 should work as well, but currently doesn't because the distance\n+   vectors we compute are too pessimistic.  We compute\n+     (0,1), (1,1) and (1,-1) \n+   and the last one causes us to lose.  */\n+TEST(foo8, b[j+1] = 3*b[j] + 1, checkb()) //ok, 0,1\n+\n+unsigned int a[1024];\n+unsigned int b[1024];\n+unsigned int aa[16][1024];\n+void init(void)\n+{\n+  unsigned long i,j;\n+  for (i = 0; i < 1024; i++) {\n+      for (j = 0; j < 16; j++) {\n+\t  aa[j][i] = ((j+1)*2+i+1) % 17;\n+      }\n+      a[i] = ((i+1)*31) % 19;\n+      b[i] = ((i+1)*47) % 23;\n+  }\n+  checksum = 1;\n+}\n+\n+#define RUN(name) \\\n+    printf(\" %s\\n\", #name); \\\n+    init();for(i=0;i<4;i++)name##noopt(32,8); checka = checksum; \\\n+    init();for(i=0;i<4;i++)name(32,8); \\\n+    printf(\"%sok %s\\n\", checka != checksum ? \"NOT \" : \"\", #name);\n+\n+int main()\n+{\n+  int i;\n+  unsigned checka;\n+  RUN(foo1);\n+  RUN(foo2);\n+  RUN(foo3);\n+  RUN(foo4);\n+  RUN(foo5);\n+  RUN(foo6);\n+  RUN(foo7);\n+  RUN(foo8);\n+  RUN(foo9);\n+  RUN(foo10);\n+  return 0;\n+}\n+\n+/* Five loops should be unroll-jammed (actually six, but see above).  */\n+/* { dg-final { scan-tree-dump-times \"applying unroll and jam\" 5 \"unrolljam\" } } */"}, {"sha": "9be3908ba0694ded2c15a85a7bf6a770247d9e9a", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -188,6 +188,7 @@ DEFTIMEVAR (TV_TREE_LOOP_IVCANON     , \"tree canonical iv\")\n DEFTIMEVAR (TV_SCEV_CONST            , \"scev constant prop\")\n DEFTIMEVAR (TV_TREE_LOOP_UNSWITCH    , \"tree loop unswitching\")\n DEFTIMEVAR (TV_LOOP_SPLIT            , \"loop splitting\")\n+DEFTIMEVAR (TV_LOOP_JAM              , \"unroll and jam\")\n DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_PARALLELIZE_LOOPS, \"tree parallelize loops\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree vectorization\")"}, {"sha": "3a6d83d33b89886472ae5c12bf87c8c529553439", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cc521f1a824b5913aeda06ebe296de98f2d9453/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=1cc521f1a824b5913aeda06ebe296de98f2d9453", "patch": "@@ -370,6 +370,7 @@ extern gimple_opt_pass *make_pass_tree_loop_init (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_lim (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_unswitch (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_loop_split (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_loop_jam (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_predcom (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_iv_canon (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_scev_cprop (gcc::context *ctxt);"}]}