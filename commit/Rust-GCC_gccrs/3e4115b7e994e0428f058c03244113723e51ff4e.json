{"sha": "3e4115b7e994e0428f058c03244113723e51ff4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U0MTE1YjdlOTk0ZTA0MjhmMDU4YzAzMjQ0MTEzNzIzZTUxZmY0ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-17T11:56:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-17T11:56:42Z"}, "message": "Try harder not to open or stat the same include file twice.\n\nSimplify include file names so that they are more likely to match.\nE.g. simplify \"./a//b\" to \"a/b\".  Represent directories with simplified\nprefixes, e.g. replace \"./a//b\" with \"a/b/\", and \".\" with \"\".\n\n(absolute_filename): New function.\n(do_include): Use it.\n(read_name_map): Likewise; this makes things more consistent for DOS.\n\n(main, do_include, open_include_file): -M output now contains operands\nof -imacros and -include.\n\n(skip_to_end_of_comment): When copying a // comment, don't try to\nchange it to a /* comment.\n(rescan, skip_if_group, skip_to_end_of_comment, macarg1): Tune.\n\n(rescan, skip_if_group, skip_to_end_of_comment, macarg1):\nIf warn_comments is nonzero, warn if backslash-newline appears\nin a // comment.  Simplify method for finding /* /* */ comment.\n(skip_if_group): Optionally warn if /* /* */ appears between # and\na directive inside a skipped if group.\n(macarg): Optionally warn if /* /* */ appears in a macro argument.\n\n(strncat, VMS_strncat, vms_ino_t, ino_t): Remove.\n(INCLUDE_LEN_FUDGE): Add 2 if VMS, for trailing \".h\".\n(INO_T_EQ, INO_T_HASH): New macros.\n\n(struct file_buf): New member `inc'.\n(expand_to_temp_buffer): Initialize it.\n\n(struct file_name_list): New member `inc'.\n(struct file_name_list): New member `st'.\nc_system_include_path is now 1 if not 0.\nfname is now an array, not a pointer.\n(struct include_file): New members `next_ino', `deps_output', `st'.\nRemove members `inode' and `dev'; they are now in `st'.\n\n(INCLUDE_HASHSIZE): Rename from INCLUDE_HASH_SIZE.\n(include_hashtab): Rename from include_hash_table.\n(include_ino_hashtab): New variable.\n\n(main): Store file status in struct stat, not in long and int pieces.\nUse base_name to strip prefixes from file names.\nWhen printing directory prefixes, omit trailing / and print \"\" as \".\".\nFatal error if the input file is a directory.\n(main, path_include): Regularize operands of -include, -imacros,\n-isystem, -iwithprefix, and -iwithprefixbefore.\nRegularize default include directories.\n\n(do_include):\nAllocate dsp with alloca, since fname is now dynamically allocated.\nUse -3 to represent a never-opened file descriptor.\nMake copy of file name, and simplify the copy.\nUse base_name to identify the end of fname's directory.\nDo not prepend dir for \"...\" if it matches the search list's first dir.\nopen_include_file now subsumes redundant_include_p and lookup_import.\nUse bypass_slot to remember when to skip directories when including\na file that has already been seen.\nInstead of using 0 to represent the working directory, and \"\"\nto represent a directory to be ignored, use \"\" for the former,\nand assume the latter has been removed before we get here.\nAssume the directory prefixes have already been simplified.\nReport as errors all open failures other than ENOENT.\nFatal error if fstat fails.\nUse new deps_output member to avoid printing dependencies twice.\n(bypass_hashtab): New variable.\n\n(do_include, open_control_file, record_control_macro): New convention:\ncontrol_macro is \"\" if the file was imported or had #pragma once.\n(pragma_once_marker): Remove.\n\n(redundant_include_p, include_hash, lookup_include, lookup_import,\nadd_import, file_size_and_mode): Remove; subsumed by open_include_file.\n(skip_redundant_dir_prefix): Remove; subsumed by simplify_filename.\n\n(is_system_include, read_name_map, remap_include_file):\nAssume arg is a directory prefix.\n\n(base_name, simplify_filename, remap_include_file,\nlookup_ino_include, new_include_prefix): New functions.\n\n(open_include_file): New arguments `importing' and `pinc'.\nMove filename mapping into new remap_include_file function.\nFirst try to find file by name in include_hashtab;\nif that doesn't work, open and fstat it and try to find it\nby inode and dev in include_ino_hashtab.\n\n(finclude): Get file status from inc->st instead of invoking fstat.\nStore inc into fp->inc so that record_control_macro doesn't\nneed to do a table lookup.\n(finclude, record_control_macro): Accept struct include_file *\ninstead of char * to identify include file.  All callers changed.\n\n(check_precompiled): Get file status from new argument `st'.\n\n(do_pragma): Output at most one warning about #pragma implementation.\nAlways return 0 instead of returning garbage sometimes.\n(do_pragma, hack_vms_include_specification):\nUse base_name for consistency, and remove redundant code.\n\nFrom Per Bothner:\nUnify the 3 separate mechanisms for avoiding processing\nof redundant include files: #import, #pragma once, and\nredundant_include_p to use a single more efficient data structure.\n(struct file_name_list):  Remove no-longer needed field control_macro.\n(dont_repeat_files, all_include_files):  Remove, no longer used.\n(struct import_file):  Renmed to struct include_file, moved earlier\nin file, renamed field name to fname, and added control_macro field.\n(pragma_once_marker):  New constant.\n(import_hash_table):  Renamed to include_hash_table.\n(import_hash):  Renamed to include_hash.\n(IMPORT_HASH_SIZE):  Renamed to INCLUDE_HASH_SIZE.\n(main, path_include):  Don't clear removed control_macro field.\n(lookup_include):  New function - look up fname in include_hash_table.\n(redundant_include_p):  Re-write to use lookup_include.\n(lookup_import, record_control_macro):  Likewise.\n(add_import):  Defer fstat to caller.  Combine two xmallocs into one.\n(do_once):  Use pragma_once_marker in include_hash_table.\n(do_pragma):  Re-implement to scan include_hash_table.\n(do_include):  Use new lookup_include and add_import.\n\nFrom-SVN: r10784", "tree": {"sha": "823f149c6daf3b2db6fecd8420489de49c46424b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/823f149c6daf3b2db6fecd8420489de49c46424b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e4115b7e994e0428f058c03244113723e51ff4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e4115b7e994e0428f058c03244113723e51ff4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e4115b7e994e0428f058c03244113723e51ff4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e4115b7e994e0428f058c03244113723e51ff4e/comments", "author": null, "committer": null, "parents": [{"sha": "393de53f612cdae21b53be55d42b40c674b23252", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/393de53f612cdae21b53be55d42b40c674b23252", "html_url": "https://github.com/Rust-GCC/gccrs/commit/393de53f612cdae21b53be55d42b40c674b23252"}], "stats": {"total": 1530, "additions": 706, "deletions": 824}, "files": [{"sha": "8338f6d25c53d4c3b26fde1484c9469ece4b7506", "filename": "gcc/cccp.c", "status": "modified", "additions": 706, "deletions": 824, "changes": 1530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e4115b7e994e0428f058c03244113723e51ff4e/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e4115b7e994e0428f058c03244113723e51ff4e/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=3e4115b7e994e0428f058c03244113723e51ff4e", "patch": "@@ -117,7 +117,6 @@ typedef unsigned char U_CHAR;\n # include <fcntl.h>\n #endif\n \n-/* This defines \"errno\" properly for VMS, and gives us EACCES. */\n #include <errno.h>\n \n #if HAVE_STDLIB_H\n@@ -239,19 +238,17 @@ my_bzero (b, length)\n #define open(fname,mode,prot)\tVMS_open (fname,mode,prot)\n #define fopen(fname,mode)\tVMS_fopen (fname,mode)\n #define freopen(fname,mode,ofile) VMS_freopen (fname,mode,ofile)\n-#define strncat(dst,src,cnt) VMS_strncat (dst,src,cnt)\n #define fstat(fd,stbuf)\t\tVMS_fstat (fd,stbuf)\n static int VMS_fstat (), VMS_stat ();\n-static char * VMS_strncat ();\n static int VMS_read ();\n static int VMS_write ();\n static int VMS_open ();\n static FILE * VMS_fopen ();\n static FILE * VMS_freopen ();\n static void hack_vms_include_specification ();\n-typedef struct { unsigned :16, :16, :16; } vms_ino_t;\n-#define ino_t vms_ino_t\n-#define INCLUDE_LEN_FUDGE 10\t/* leave room for VMS syntax conversion */\n+#define INO_T_EQ(a, b) (!bcmp((char *) &(a), (char *) &(b), sizeof (a)))\n+#define INO_T_HASH(a) 0\n+#define INCLUDE_LEN_FUDGE 12\t/* leave room for VMS syntax conversion */\n #ifdef __GNUC__\n #define BSTRING\t\t\t/* VMS/GCC supplies the bstring routines */\n #endif /* __GNUC__ */\n@@ -288,6 +285,14 @@ typedef struct { unsigned :16, :16, :16; } vms_ino_t;\n #define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)\n #endif\n \n+#ifndef INO_T_EQ\n+#define INO_T_EQ(a, b) ((a) == (b))\n+#endif\n+\n+#ifndef INO_T_HASH\n+#define INO_T_HASH(a) (a)\n+#endif\n+\n /* Define a generic NULL if one hasn't already been defined.  */\n \n #ifndef NULL\n@@ -449,7 +454,8 @@ static int pedantic_errors;\n \n static int inhibit_warnings = 0;\n \n-/* Nonzero means warn if slash-star appears in a comment.  */\n+/* Nonzero means warn if slash-star appears in a slash-star comment,\n+   or if newline-backslash appears in a slash-slash comment.  */\n \n static int warn_comments;\n \n@@ -505,6 +511,8 @@ static struct file_buf {\n   char *fname;\n   /* Filename specified with #line directive.  */\n   char *nominal_fname;\n+  /* Include file description.  */\n+  struct include_file *inc;\n   /* Record where in the search path this file was found.\n      For #include_next.  */\n   struct file_name_list *dir;\n@@ -561,17 +569,19 @@ static FILE_BUF outbuf;\n struct file_name_list\n   {\n     struct file_name_list *next;\n-    char *fname;\n-    /* If the following is nonzero, it is a macro name.\n-       Don't include the file again if that macro is defined.  */\n-    U_CHAR *control_macro;\n-    /* If the following is nonzero, it is a C-language system include\n+    /* If the following is 1, it is a C-language system include\n        directory.  */\n     int c_system_include_path;\n     /* Mapping of file names for this directory.  */\n     struct file_name_map *name_map;\n     /* Non-zero if name_map is valid.  */\n     int got_name_map;\n+    /* The include directory status.  */\n+    struct stat st;\n+    /* The include prefix: \"\" denotes the working directory,\n+       otherwise fname must end in '/'.\n+       The actual size is dynamically allocated.  */\n+    char fname[1];\n   };\n \n /* #include \"file\" looks in source file dir, then stack. */\n@@ -643,18 +653,33 @@ static struct file_name_list *last_after_include = 0;\t/* Last in chain */\n static struct file_name_list *before_system = 0;\n static struct file_name_list *last_before_system = 0;\t/* Last in chain */\n \n-/* List of included files that contained #pragma once.  */\n-static struct file_name_list *dont_repeat_files = 0;\n-\n-/* List of other included files.\n-   If ->control_macro if nonzero, the file had a #ifndef\n-   around the entire contents, and ->control_macro gives the macro name.  */\n-static struct file_name_list *all_include_files = 0;\n-\n /* Directory prefix that should replace `/usr' in the standard\n    include file directories.  */\n static char *include_prefix;\n \n+/* Maintain and search list of included files.  */\n+\n+struct include_file {\n+  struct include_file *next; /* for include_hashtab */\n+  struct include_file *next_ino; /* for include_ino_hashtab */\n+  char *fname;\n+  /* If the following is the empty string, it means #pragma once\n+     was seen in this include file, or #import was applied to the file.\n+     Otherwise, if it is nonzero, it is a macro name.\n+     Don't include the file again if that macro is defined.  */\n+  U_CHAR *control_macro;\n+  /* Nonzero if the dependency on this include file has been output.  */\n+  int deps_output;\n+  struct stat st;\n+};\n+\n+/* Hash tables of files already included with #include or #import.\n+   include_hashtab is by full name; include_ino_hashtab is by inode number.  */\n+\n+#define INCLUDE_HASHSIZE 61\n+static struct include_file *include_hashtab[INCLUDE_HASHSIZE];\n+static struct include_file *include_ino_hashtab[INCLUDE_HASHSIZE];\n+\n /* Global list of strings read in from precompiled files.  This list\n    is kept in the order the strings are read in, with new strings being\n    added at the end through stringlist_tailp.  We use this list to output\n@@ -1081,22 +1106,21 @@ static int handle_directive PROTO((FILE_BUF *, FILE_BUF *));\n static struct tm *timestamp PROTO((void));\n static void special_symbol PROTO((HASHNODE *, FILE_BUF *));\n \n-static int redundant_include_p PROTO((char *));\n static int is_system_include PROTO((char *));\n-static char *skip_redundant_dir_prefix PROTO((char *));\n+static char *base_name PROTO((char *));\n+static int absolute_filename PROTO((char *));\n+static size_t simplify_filename PROTO((char *));\n \n static char *read_filename_string PROTO((int, FILE *));\n static struct file_name_map *read_name_map PROTO((char *));\n-static int open_include_file PROTO((char *, struct file_name_list *));\n-\n-static void finclude PROTO((int, char *, FILE_BUF *, int, struct file_name_list *));\n-static void record_control_macro PROTO((char *, U_CHAR *));\n+static int open_include_file PROTO((char *, struct file_name_list *, U_CHAR *, struct include_file **));\n+static char *remap_include_file PROTO((char *, struct file_name_list *));\n+static int lookup_ino_include PROTO((struct include_file *));\n \n-static int import_hash PROTO((char *));\n-static int lookup_import PROTO((char *, struct file_name_list *));\n-static void add_import PROTO((int, char *));\n+static void finclude PROTO((int, struct include_file *, FILE_BUF *, int, struct file_name_list *));\n+static void record_control_macro PROTO((struct include_file *, U_CHAR *));\n \n-static char *check_precompiled PROTO((int, char *, char **));\n+static char *check_precompiled PROTO((int, struct stat *, char *, char **));\n static int check_preconditions PROTO((char *));\n static void pcfinclude PROTO((U_CHAR *, U_CHAR *, U_CHAR *, FILE_BUF *));\n static void pcstring_used PROTO((HASHNODE *));\n@@ -1185,6 +1209,7 @@ static void make_undef PROTO((char *, FILE_BUF *));\n \n static void make_assertion PROTO((char *, char *));\n \n+static struct file_name_list *new_include_prefix PROTO((struct file_name_list *, char *, char *));\n static void append_include_chain PROTO((struct file_name_list *, struct file_name_list *));\n \n static void deps_output PROTO((char *, int));\n@@ -1200,8 +1225,6 @@ GENERIC_PTR xmalloc PROTO((size_t));\n static GENERIC_PTR xrealloc PROTO((GENERIC_PTR, size_t));\n static GENERIC_PTR xcalloc PROTO((size_t, size_t));\n static char *savestring PROTO((char *));\n-\n-static int file_size_and_mode PROTO((int, int *, long int *));\n \f\n /* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,\n    retrying if necessary.  Return a negative value if an error occurs,\n@@ -1262,8 +1285,7 @@ main (argc, argv)\n      int argc;\n      char **argv;\n {\n-  int st_mode;\n-  long st_size;\n+  struct stat st;\n   char *in_fname;\n   char *cp;\n   int f, i;\n@@ -1315,25 +1337,14 @@ main (argc, argv)\n   signal (SIGPIPE, pipe_closed);\n #endif\n \n-  cp = argv[0] + strlen (argv[0]);\n-  while (cp != argv[0] && cp[-1] != '/'\n-#ifdef DIR_SEPARATOR\n-\t && cp[-1] != DIR_SEPARATOR\n-#endif\n-\t )\n-    --cp;\n-  progname = cp;\n+  progname = base_name (argv[0]);\n \n #ifdef VMS\n   {\n-    /* Remove directories from PROGNAME.  */\n+    /* Remove extension from PROGNAME.  */\n     char *p;\n-    char *s = progname;\n+    char *s = progname = savestring (progname);\n \n-    if ((p = rindex (s, ':')) != 0) s = p + 1;\t/* skip device */\n-    if ((p = rindex (s, ']')) != 0) s = p + 1;\t/* skip directory */\n-    if ((p = rindex (s, '>')) != 0) s = p + 1;\t/* alternate (int'n'l) dir */\n-    s = progname = savestring (s);\n     if ((p = rindex (s, ';')) != 0) *p = '\\0';\t/* strip version number */\n     if ((p = rindex (s, '.')) != 0\t\t/* strip type iff \".exe\" */\n \t&& (p[1] == 'e' || p[1] == 'E')\n@@ -1383,13 +1394,13 @@ main (argc, argv)\n \t  if (i + 1 == argc)\n \t    fatal (\"Filename missing after `-include' option\");\n \t  else\n-\t    pend_includes[i] = argv[i+1], i++;\n+\t    simplify_filename (pend_includes[i] = argv[++i]);\n \t}\n \tif (!strcmp (argv[i], \"-imacros\")) {\n \t  if (i + 1 == argc)\n \t    fatal (\"Filename missing after `-imacros' option\");\n \t  else\n-\t    pend_files[i] = argv[i+1], i++;\n+\t    simplify_filename (pend_files[i] = argv[++i]);\n \t}\n \tif (!strcmp (argv[i], \"-iprefix\")) {\n \t  if (i + 1 == argc)\n@@ -1403,17 +1414,9 @@ main (argc, argv)\n \tif (!strcmp (argv[i], \"-isystem\")) {\n \t  struct file_name_list *dirtmp;\n \n-\t  if (i + 1 == argc)\n-\t    fatal (\"Filename missing after `-isystem' option\");\n-\n-\t  dirtmp = (struct file_name_list *)\n-\t    xmalloc (sizeof (struct file_name_list));\n-\t  dirtmp->next = 0;\n-\t  dirtmp->control_macro = 0;\n+\t  if (! (dirtmp = new_include_prefix (NULL_PTR, \"\", argv[++i])))\n+\t    break;\n \t  dirtmp->c_system_include_path = 1;\n-\t  dirtmp->fname = xmalloc (strlen (argv[i+1]) + 1);\n-\t  strcpy (dirtmp->fname, argv[++i]);\n-\t  dirtmp->got_name_map = 0;\n \n \t  if (before_system == 0)\n \t    before_system = dirtmp;\n@@ -1436,18 +1439,8 @@ main (argc, argv)\n \t      prefix[strlen (prefix) - 7] = 0;\n \t  }\n \n-\t  dirtmp = (struct file_name_list *)\n-\t    xmalloc (sizeof (struct file_name_list));\n-\t  dirtmp->next = 0;\t/* New one goes on the end */\n-\t  dirtmp->control_macro = 0;\n-\t  dirtmp->c_system_include_path = 0;\n-\t  if (i + 1 == argc)\n-\t    fatal (\"Directory name missing after `-iwithprefix' option\");\n-\n-\t  dirtmp->fname = xmalloc (strlen (argv[i+1]) + strlen (prefix) + 1);\n-\t  strcpy (dirtmp->fname, prefix);\n-\t  strcat (dirtmp->fname, argv[++i]);\n-\t  dirtmp->got_name_map = 0;\n+\t  if (! (dirtmp = new_include_prefix (NULL_PTR, prefix, argv[++i])))\n+\t    break;\n \n \t  if (after_include == 0)\n \t    after_include = dirtmp;\n@@ -1470,35 +1463,15 @@ main (argc, argv)\n \t      prefix[strlen (prefix) - 7] = 0;\n \t  }\n \n-\t  dirtmp = (struct file_name_list *)\n-\t    xmalloc (sizeof (struct file_name_list));\n-\t  dirtmp->next = 0;\t/* New one goes on the end */\n-\t  dirtmp->control_macro = 0;\n-\t  dirtmp->c_system_include_path = 0;\n-\t  if (i + 1 == argc)\n-\t    fatal (\"Directory name missing after `-iwithprefixbefore' option\");\n-\n-\t  dirtmp->fname = xmalloc (strlen (argv[i+1]) + strlen (prefix) + 1);\n-\t  strcpy (dirtmp->fname, prefix);\n-\t  strcat (dirtmp->fname, argv[++i]);\n-\t  dirtmp->got_name_map = 0;\n-\n+\t  dirtmp = new_include_prefix (NULL_PTR, prefix, argv[++i]);\n \t  append_include_chain (dirtmp, dirtmp);\n \t}\n \t/* Add directory to end of path for includes.  */\n \tif (!strcmp (argv[i], \"-idirafter\")) {\n \t  struct file_name_list *dirtmp;\n \n-\t  dirtmp = (struct file_name_list *)\n-\t    xmalloc (sizeof (struct file_name_list));\n-\t  dirtmp->next = 0;\t/* New one goes on the end */\n-\t  dirtmp->control_macro = 0;\n-\t  dirtmp->c_system_include_path = 0;\n-\t  if (i + 1 == argc)\n-\t    fatal (\"Directory name missing after `-idirafter' option\");\n-\t  else\n-\t    dirtmp->fname = argv[++i];\n-\t  dirtmp->got_name_map = 0;\n+\t  if (! (dirtmp = new_include_prefix (NULL_PTR, \"\", argv[++i])))\n+\t    break;\n \n \t  if (after_include == 0)\n \t    after_include = dirtmp;\n@@ -1759,18 +1732,8 @@ main (argc, argv)\n \t    first_bracket_include = 0;\n \t  }\n \t  else {\n-\t    dirtmp = (struct file_name_list *)\n-\t      xmalloc (sizeof (struct file_name_list));\n-\t    dirtmp->next = 0;\t\t/* New one goes on the end */\n-\t    dirtmp->control_macro = 0;\n-\t    dirtmp->c_system_include_path = 0;\n-\t    if (argv[i][2] != 0)\n-\t      dirtmp->fname = argv[i] + 2;\n-\t    else if (i + 1 == argc)\n-\t      fatal (\"Directory name missing after -I option\");\n-\t    else\n-\t      dirtmp->fname = argv[++i];\n-\t    dirtmp->got_name_map = 0;\n+\t    dirtmp = new_include_prefix (last_include, \"\",\n+\t\t\t\t\t argv[i][2] ? argv[i] + 2 : argv[++i]);\n \t    append_include_chain (dirtmp, dirtmp);\n \t  }\n \t}\n@@ -1959,7 +1922,6 @@ main (argc, argv)\n     /* If the environment var for this language is set,\n        add to the default list of include directories.  */\n     if (epath) {\n-      char *nstore = (char *) alloca (strlen (epath) + 2);\n       int num_dirs;\n       char *startp, *endp;\n \n@@ -1973,30 +1935,19 @@ main (argc, argv)\n       startp = endp = epath;\n       num_dirs = 0;\n       while (1) {\n-        /* Handle cases like c:/usr/lib:d:/gcc/lib */\n-        if ((*endp == PATH_SEPARATOR\n-#if 0 /* Obsolete, now that we use semicolons as the path separator.  */\n-#ifdef __MSDOS__\n-\t     && (endp-startp != 1 || !isalpha (*startp))\n-#endif\n-#endif\n-\t     )\n-            || *endp == 0) {\n-\t  strncpy (nstore, startp, endp-startp);\n-\t  if (endp == startp)\n-\t    strcpy (nstore, \".\");\n-\t  else\n-\t    nstore[endp-startp] = '\\0';\n-\n-\t  include_defaults[num_dirs].fname = savestring (nstore);\n+\tchar c = *endp++;\n+\tif (c == PATH_SEPARATOR || !c) {\n+\t  endp[-1] = 0;\n+\t  include_defaults[num_dirs].fname\n+\t    = startp == endp ? \".\" : savestring (startp);\n+\t  endp[-1] = c;\n \t  include_defaults[num_dirs].cplusplus = cplusplus;\n \t  include_defaults[num_dirs].cxx_aware = 1;\n \t  num_dirs++;\n-\t  if (*endp == '\\0')\n+\t  if (!c)\n \t    break;\n-\t  endp = startp = endp + 1;\n-\t} else\n-\t  endp++;\n+\t  startp = endp;\n+\t}\n       }\n       /* Put the usual defaults back in at the end.  */\n       bcopy ((char *) include_defaults_array,\n@@ -2030,18 +1981,14 @@ main (argc, argv)\n \t  if (!strncmp (p->fname, default_prefix, default_len)) {\n \t    /* Yes; change prefix and add to search list.  */\n \t    struct file_name_list *new\n-\t      = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n-\t    int this_len = strlen (specd_prefix) + strlen (p->fname) - default_len;\n-\t    char *str = xmalloc (this_len + 1);\n-\t    strcpy (str, specd_prefix);\n-\t    strcat (str, p->fname + default_len);\n-\t    new->fname = str;\n-\t    new->control_macro = 0;\n-\t    new->c_system_include_path = !p->cxx_aware;\n-\t    new->got_name_map = 0;\n-\t    append_include_chain (new, new);\n-\t    if (first_system_include == 0)\n-\t      first_system_include = new;\n+\t      = new_include_prefix (NULL_PTR, specd_prefix,\n+\t\t\t\t    p->fname + default_len);\n+\t    if (new) {\n+\t      new->c_system_include_path = !p->cxx_aware;\n+\t      append_include_chain (new, new);\n+\t      if (first_system_include == 0)\n+\t\tfirst_system_include = new;\n+\t    }\n \t  }\n \t}\n       }\n@@ -2050,14 +1997,13 @@ main (argc, argv)\n       /* Some standard dirs are only for C++.  */\n       if (!p->cplusplus || (cplusplus && !no_standard_cplusplus_includes)) {\n \tstruct file_name_list *new\n-\t  = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n-\tnew->control_macro = 0;\n-\tnew->c_system_include_path = !p->cxx_aware;\n-\tnew->fname = p->fname;\n-\tnew->got_name_map = 0;\n-\tappend_include_chain (new, new);\n-\tif (first_system_include == 0)\n-\t  first_system_include = new;\n+\t  = new_include_prefix (NULL_PTR, \"\", p->fname);\n+\tif (new) {\n+\t  new->c_system_include_path = !p->cxx_aware;\n+\t  append_include_chain (new, new);\n+\t  if (first_system_include == 0)\n+\t    first_system_include = new;\n+\t}\n       }\n     }\n   }\n@@ -2074,37 +2020,17 @@ main (argc, argv)\n     for (p = include; p; p = p->next) {\n       if (p == first_bracket_include)\n \tfprintf (stderr, \"#include <...> search starts here:\\n\");\n-      fprintf (stderr, \" %s\\n\", p->fname);\n+      if (!p->fname[0])\n+\tfprintf (stderr, \" .\\n\");\n+      else if (!strcmp (p->fname, \"/\") || !strcmp (p->fname, \"//\"))\n+\tfprintf (stderr, \" %s\\n\", p->fname);\n+      else\n+\t/* Omit trailing '/'.  */\n+\tfprintf (stderr, \" %.*s\\n\", (int) strlen (p->fname) - 1, p->fname);\n     }\n     fprintf (stderr, \"End of search list.\\n\");\n   }\n \n-  /* Scan the -imacros files before the main input.\n-     Much like #including them, but with no_output set\n-     so that only their macro definitions matter.  */\n-\n-  no_output++; no_record_file++;\n-  for (i = 1; i < argc; i++)\n-    if (pend_files[i]) {\n-      int fd = open (pend_files[i], O_RDONLY, 0666);\n-      if (fd < 0) {\n-\tperror_with_name (pend_files[i]);\n-\treturn FATAL_EXIT_CODE;\n-      }\n-      finclude (fd, pend_files[i], &outbuf, 0, NULL_PTR);\n-    }\n-  no_output--; no_record_file--;\n-\n-  /* Copy the entire contents of the main input file into\n-     the stacked input buffer previously allocated for it.  */\n-\n-  /* JF check for stdin */\n-  if (in_fname == NULL || *in_fname == 0) {\n-    in_fname = \"\";\n-    f = 0;\n-  } else if ((f = open (in_fname, O_RDONLY, 0666)) < 0)\n-    goto perror;\n-\n   /* -MG doesn't select the form of output and must be specified with one of\n      -M or -MM.  -MG doesn't make sense with -MD or -MMD since they don't\n      inhibit compilation.  */\n@@ -2166,15 +2092,7 @@ main (argc, argv)\n       char *p, *q;\n       int len;\n \n-      /* Discard all directory prefixes from filename.  */\n-      if ((q = rindex (in_fname, '/')) != NULL\n-#ifdef DIR_SEPARATOR\n-\t  && (q = rindex (in_fname, DIR_SEPARATOR)) != NULL\n-#endif\n-\t  )\n-\t++q;\n-      else\n-\tq = in_fname;\n+      q = base_name (in_fname);\n \n       /* Copy remainder to mungable area.  */\n       p = (char *) alloca (strlen(q) + 8);\n@@ -2217,19 +2135,50 @@ main (argc, argv)\n     }\n   }\n \n-  file_size_and_mode (f, &st_mode, &st_size);\n+  /* Scan the -imacros files before the main input.\n+     Much like #including them, but with no_output set\n+     so that only their macro definitions matter.  */\n+\n+  no_output++; no_record_file++;\n+  for (i = 1; i < argc; i++)\n+    if (pend_files[i]) {\n+      struct include_file *inc;\n+      int fd = open_include_file (pend_files[i], NULL_PTR, NULL_PTR, &inc);\n+      if (fd < 0) {\n+\tperror_with_name (pend_files[i]);\n+\treturn FATAL_EXIT_CODE;\n+      }\n+      finclude (fd, inc, &outbuf, 0, NULL_PTR);\n+    }\n+  no_output--; no_record_file--;\n+\n+  /* Copy the entire contents of the main input file into\n+     the stacked input buffer previously allocated for it.  */\n+\n+  /* JF check for stdin */\n+  if (in_fname == NULL || *in_fname == 0) {\n+    in_fname = \"\";\n+    f = 0;\n+  } else if ((f = open (in_fname, O_RDONLY, 0666)) < 0)\n+    goto perror;\n+\n+  if (fstat (f, &st) != 0)\n+    pfatal_with_name (in_fname);\n   fp->nominal_fname = fp->fname = in_fname;\n   fp->lineno = 1;\n   fp->system_header_p = 0;\n   /* JF all this is mine about reading pipes and ttys */\n-  if (! S_ISREG (st_mode)) {\n+  if (! S_ISREG (st.st_mode)) {\n     /* Read input from a file that is not a normal disk file.\n        We cannot preallocate a buffer with the correct size,\n        so we must read in the file a piece at the time and make it bigger.  */\n     int size;\n     int bsize;\n     int cnt;\n \n+    if (S_ISDIR (st.st_mode))\n+      fatal (\"Input file `%s' is a directory\", in_fname);\n+\n     bsize = 2000;\n     size = 0;\n     fp->buf = (U_CHAR *) xmalloc (bsize + 2);\n@@ -2244,9 +2193,9 @@ main (argc, argv)\n     fp->length = size;\n   } else {\n     /* Read a file whose size we can determine in advance.\n-       For the sake of VMS, st_size is just an upper bound.  */\n-    fp->buf = (U_CHAR *) xmalloc (st_size + 2);\n-    fp->length = safe_read (f, (char *) fp->buf, st_size);\n+       For the sake of VMS, st.st_size is just an upper bound.  */\n+    fp->buf = (U_CHAR *) xmalloc (st.st_size + 2);\n+    fp->length = safe_read (f, (char *) fp->buf, st.st_size);\n     if (fp->length < 0) goto perror;\n   }\n   fp->bufp = fp->buf;\n@@ -2281,12 +2230,13 @@ main (argc, argv)\n   no_record_file++;\n   for (i = 1; i < argc; i++)\n     if (pend_includes[i]) {\n-      int fd = open (pend_includes[i], O_RDONLY, 0666);\n+      struct include_file *inc;\n+      int fd = open_include_file (pend_includes[i], NULL_PTR, NULL_PTR, &inc);\n       if (fd < 0) {\n \tperror_with_name (pend_includes[i]);\n \treturn FATAL_EXIT_CODE;\n       }\n-      finclude (fd, pend_includes[i], &outbuf, 0, NULL_PTR);\n+      finclude (fd, inc, &outbuf, 0, NULL_PTR);\n     }\n   no_record_file--;\n \n@@ -2353,38 +2303,22 @@ path_include (path)\n   if (*p)\n     while (1) {\n       char *q = p;\n-      char *name;\n+      char c;\n       struct file_name_list *dirtmp;\n \n       /* Find the end of this name.  */\n-      while (*q != 0 && *q != PATH_SEPARATOR) q++;\n-      if (p == q) {\n-\t/* An empty name in the path stands for the current directory.  */\n-\tname = xmalloc (2);\n-\tname[0] = '.';\n-\tname[1] = 0;\n-      } else {\n-\t/* Otherwise use the directory that is named.  */\n-\tname = xmalloc (q - p + 1);\n-\tbcopy (p, name, q - p);\n-\tname[q - p] = 0;\n-      }\n+      while ((c = *q++) != PATH_SEPARATOR && c)\n+\tcontinue;\n \n-      dirtmp = (struct file_name_list *)\n-\txmalloc (sizeof (struct file_name_list));\n-      dirtmp->next = 0;\t\t/* New one goes on the end */\n-      dirtmp->control_macro = 0;\n-      dirtmp->c_system_include_path = 0;\n-      dirtmp->fname = name;\n-      dirtmp->got_name_map = 0;\n+      q[-1] = 0;\n+      dirtmp = new_include_prefix (last_include, \"\", p == q ? \".\" : p);\n+      q[-1] = c;\n       append_include_chain (dirtmp, dirtmp);\n \n       /* Advance past this name.  */\n       p = q;\n-      if (*p == 0)\n+      if (! c)\n \tbreak;\n-      /* Skip the colon.  */\n-      p++;\n     }\n }\n \f\n@@ -3012,6 +2946,8 @@ do { ip = &instack[indepth];\t\t\\\n \t\t}\n \t\tbreak;\n \t      }\n+\t      if (warn_comments)\n+\t\twarning (\"multiline `//' comment\");\n \t      ++ip->lineno;\n \t      /* Copy the newline into the output buffer, in order to\n \t\t avoid the pain of a #line every time a multiline comment\n@@ -3080,18 +3016,17 @@ do { ip = &instack[indepth];\t\t\\\n       {\n \tU_CHAR *before_bp = ibp;\n \n-\twhile (ibp < limit) {\n+\tfor (;;) {\n \t  switch (*ibp++) {\n-\t  case '/':\n-\t    if (warn_comments && *ibp == '*')\n-\t      warning (\"`/*' within comment\");\n-\t    break;\n \t  case '*':\n+\t    if (ibp[-2] == '/' && warn_comments)\n+\t      warning (\"`/*' within comment\");\n \t    if (*ibp == '\\\\' && ibp[1] == '\\n')\n \t      newline_fix (ibp);\n-\t    if (ibp >= limit || *ibp == '/')\n+\t    if (*ibp == '/')\n \t      goto comment_end;\n \t    break;\n+\n \t  case '\\n':\n \t    ++ip->lineno;\n \t    /* Copy the newline into the output buffer, in order to\n@@ -3100,19 +3035,23 @@ do { ip = &instack[indepth];\t\t\\\n \t    if (!put_out_comments)\n \t      *obp++ = '\\n';\n \t    ++op->lineno;\n+\t    break;\n+\n+\t  case 0:\n+\t    if (limit < ibp) {\n+\t      error_with_line (line_for_error (start_line),\n+\t\t\t       \"unterminated comment\");\n+\t      goto limit_reached;\n+\t    }\n+\t    break;\n \t  }\n \t}\n       comment_end:\n \n-\tif (ibp >= limit)\n-\t  error_with_line (line_for_error (start_line),\n-\t\t\t   \"unterminated comment\");\n-\telse {\n-\t  ibp++;\n-\t  if (put_out_comments) {\n-\t    bcopy ((char *) before_bp, (char *) obp, ibp - before_bp);\n-\t    obp += ibp - before_bp;\n-\t  }\n+\tibp++;\n+\tif (put_out_comments) {\n+\t  bcopy ((char *) before_bp, (char *) obp, ibp - before_bp);\n+\t  obp += ibp - before_bp;\n \t}\n       }\n       break;\n@@ -3251,6 +3190,7 @@ do { ip = &instack[indepth];\t\t\\\n \t/* Our input really contains a null character.  */\n \tgoto randomchar;\n \n+    limit_reached:\n       /* At end of a macro-expansion level, pop it and read next level.  */\n       if (ip->macro != 0) {\n \tobp--;\n@@ -3615,6 +3555,7 @@ expand_to_temp_buffer (buf, limit, output_marks, assertions)\n   ip = &instack[indepth];\n   ip->fname = 0;\n   ip->nominal_fname = 0;\n+  ip->inc = 0;\n   ip->system_header_p = 0;\n   ip->macro = 0;\n   ip->free_ptr = 0;\n@@ -4254,20 +4195,22 @@ do_include (buf, limit, op, keyword)\n      FILE_BUF *op;\n      struct directive *keyword;\n {\n-  int importing = (keyword->type == T_IMPORT);\n+  U_CHAR *importing = keyword->type == T_IMPORT ? (U_CHAR *) \"\" : (U_CHAR *) 0;\n   int skip_dirs = (keyword->type == T_INCLUDE_NEXT);\n   static int import_warning = 0;\n   char *fname;\t\t/* Dynamically allocated fname buffer */\n   char *pcftry;\n   char *pcfname;\n-  U_CHAR *fbeg, *fend;\t\t/* Beginning and end of fname */\n+  char *fbeg, *fend;\t\t/* Beginning and end of fname */\n+  U_CHAR *fin;\n \n   struct file_name_list *search_start = include; /* Chain of dirs to search */\n-  struct file_name_list dsp[1];\t/* First in chain, if #include \"...\" */\n+  struct file_name_list *dsp;\t/* First in chain, if #include \"...\" */\n   struct file_name_list *searchptr = 0;\n   size_t flen;\n \n-  int f;\t\t\t/* file number */\n+  int f = -3;\t\t\t/* file number */\n+  struct include_file *inc = 0;\n \n   int retried = 0;\t\t/* Have already tried macro\n \t\t\t\t   expanding the include line*/\n@@ -4276,7 +4219,6 @@ do_include (buf, limit, op, keyword)\n   char *pcfbuf;\n   char *pcfbuflimit;\n   int pcfnum;\n-  f= -1;\t\t\t/* JF we iz paranoid! */\n \n   if (importing && warn_import && !inhibit_warnings\n       && !instack[indepth].system_header_p && !import_warning) {\n@@ -4296,21 +4238,19 @@ do_include (buf, limit, op, keyword)\n \n get_filename:\n \n-  fbeg = buf;\n-  SKIP_WHITE_SPACE (fbeg);\n+  fin = buf;\n+  SKIP_WHITE_SPACE (fin);\n   /* Discard trailing whitespace so we can easily see\n      if we have parsed all the significant chars we were given.  */\n-  while (limit != fbeg && is_hor_space[limit[-1]]) limit--;\n+  while (limit != fin && is_hor_space[limit[-1]]) limit--;\n+  fbeg = fend = (char *) alloca (limit - fin);\n \n-  switch (*fbeg++) {\n+  switch (*fin++) {\n   case '\\\"':\n     {\n       FILE_BUF *fp;\n       /* Copy the operand text, concatenating the strings.  */\n       {\n-\tU_CHAR *fin = fbeg;\n-\tfbeg = (U_CHAR *) alloca (limit - fbeg + 1);\n-\tfend = fbeg;\n \twhile (fin != limit) {\n \t  while (fin != limit && *fin != '\\\"')\n \t    *fend++ = *fin++;\n@@ -4326,7 +4266,6 @@ do_include (buf, limit, op, keyword)\n \t    goto fail;\n \t}\n       }\n-      *fend = 0;\n \n       /* We have \"filename\".  Figure out directory this source\n \t file is coming from and put it on the front of the list. */\n@@ -4337,37 +4276,25 @@ do_include (buf, limit, op, keyword)\n       for (fp = &instack[indepth]; fp >= instack; fp--)\n \t{\n \t  int n;\n-\t  char *ep,*nam;\n+\t  char *nam;\n \n \t  if ((nam = fp->nominal_fname) != NULL) {\n \t    /* Found a named file.  Figure out dir of the file,\n \t       and put it in front of the search list.  */\n-\t    dsp[0].next = search_start;\n-\t    search_start = dsp;\n-#ifndef VMS\n-\t    ep = rindex (nam, '/');\n-#ifdef DIR_SEPARATOR\n-\t    if (ep == NULL) ep = rindex (nam, DIR_SEPARATOR);\n-\t    else {\n-\t      char *tmp = rindex (nam, DIR_SEPARATOR);\n-\t      if (tmp != NULL && tmp > ep) ep = tmp;\n-\t    }\n-#endif\n-#else\t\t\t\t/* VMS */\n-\t    ep = rindex (nam, ']');\n-\t    if (ep == NULL) ep = rindex (nam, '>');\n-\t    if (ep == NULL) ep = rindex (nam, ':');\n-\t    if (ep != NULL) ep++;\n-#endif\t\t\t\t/* VMS */\n-\t    if (ep != NULL) {\n-\t      n = ep - nam;\n-\t      dsp[0].fname = (char *) alloca (n + 1);\n-\t      strncpy (dsp[0].fname, nam, n);\n-\t      dsp[0].fname[n] = '\\0';\n+\t    dsp = ((struct file_name_list *)\n+\t\t   alloca (sizeof (struct file_name_list) + strlen (nam)));\n+\t    strcpy (dsp->fname, nam);\n+\t    simplify_filename (dsp->fname);\n+\t    nam = base_name (dsp->fname);\n+\t    *nam = 0;\n+\t    /* But for efficiency's sake, do not insert the dir\n+\t       if it matches the search list's first dir.  */\n+\t    dsp->next = search_start;\n+\t    if (!search_start || strcmp (dsp->fname, search_start->fname)) {\n+\t      search_start = dsp;\n+\t      n = nam - dsp->fname;\n \t      if (n + INCLUDE_LEN_FUDGE > max_include_len)\n \t\tmax_include_len = n + INCLUDE_LEN_FUDGE;\n-\t    } else {\n-\t      dsp[0].fname = 0; /* Current directory */\n \t    }\n \t    dsp[0].got_name_map = 0;\n \t    break;\n@@ -4377,13 +4304,12 @@ do_include (buf, limit, op, keyword)\n     }\n \n   case '<':\n-    fend = fbeg;\n-    while (fend != limit && *fend != '>') fend++;\n-    if (*fend == '>' && fend + 1 == limit) {\n+    while (fin != limit && *fin != '>')\n+      *fend++ = *fin++;\n+    if (*fin == '>' && fin + 1 == limit) {\n       angle_brackets = 1;\n       /* If -I-, start with the first -I dir after the -I-.  */\n-      if (first_bracket_include)\n-\tsearch_start = first_bracket_include;\n+      search_start = first_bracket_include;\n       break;\n     }\n     goto fail;\n@@ -4396,15 +4322,14 @@ do_include (buf, limit, op, keyword)\n      * code from case '<' is repeated here) and generates a warning.\n      * (Note: macro expansion of `xyz' takes precedence.)\n      */\n-    if (retried && isalpha(*(--fbeg))) {\n-      fend = fbeg;\n-      while (fend != limit && (!isspace(*fend))) fend++;\n+    if (retried && isalpha(*(U_CHAR *)(--fbeg))) {\n+      while (fin != limit && (!isspace(*fin)))\n+\t*fend++ = *fin++;\n       warning (\"VAX-C-style include specification found, use '#include <filename.h>' !\");\n-      if (fend  == limit) {\n+      if (fin == limit) {\n \tangle_brackets = 1;\n \t/* If -I-, start with the first -I dir after the -I-.  */\n-\tif (first_bracket_include)\n-\t  search_start = first_bracket_include;\n+\tsearch_start = first_bracket_include;\n \tbreak;\n       }\n     }\n@@ -4463,7 +4388,8 @@ do_include (buf, limit, op, keyword)\n       }\n   }\n \n-  flen = fend - fbeg;\n+  *fend = 0;\n+  flen = simplify_filename (fbeg);\n \n   if (flen == 0)\n     {\n@@ -4473,198 +4399,134 @@ do_include (buf, limit, op, keyword)\n \n   /* Allocate this permanently, because it gets stored in the definitions\n      of macros.  */\n-  fname = xmalloc (max_include_len + flen + 4);\n-  /* + 2 above for slash and terminating null.  */\n-  /* + 2 added for '.h' on VMS (to support '#include filename') */\n+  fname = xmalloc (max_include_len + flen + 1);\n+  /* + 1 above for terminating null.  */\n+\n+  system_include_depth += angle_brackets;\n \n   /* If specified file name is absolute, just open it.  */\n \n-  if (*fbeg == '/'\n-#ifdef DIR_SEPARATOR\n-      || *fbeg == DIR_SEPARATOR\n-#endif\n-#if defined (__MSDOS__) || defined (_WIN32)\n-      || (isalpha (fbeg[0]) && fbeg[1] == ':'\n-\t  && (fbeg[2] == '/'\n-#ifdef DIR_SEPARATOR\n-\t      || fbeg[2] == DIR_SEPARATOR\n-#endif\n-\t      ))\n-#endif\n-      ) {\n-    strncpy (fname, (char *) fbeg, flen);\n-    fname[flen] = 0;\n-    if (redundant_include_p (fname))\n-      return 0;\n-    if (importing)\n-      f = lookup_import (fname, NULL_PTR);\n-    else\n-      f = open_include_file (fname, NULL_PTR);\n-    if (f == -2)\n-      return 0;\t\t/* Already included this file */\n+  if (absolute_filename (fbeg)) {\n+    strcpy (fname, fbeg);\n+    f = open_include_file (fname, NULL_PTR, importing, &inc);\n   } else {\n+\n+    struct bypass_dir {\n+      struct bypass_dir *next;\n+      char *fname;\n+      struct file_name_list *searchptr;\n+    } **bypass_slot = 0;\n+\n     /* Search directory path, trying to open the file.\n        Copy each filename tried into FNAME.  */\n \n     for (searchptr = search_start; searchptr; searchptr = searchptr->next) {\n-      if (searchptr->fname) {\n-\t/* The empty string in a search path is ignored.\n-\t   This makes it possible to turn off entirely\n-\t   a standard piece of the list.  */\n-\tif (searchptr->fname[0] == 0)\n-\t  continue;\n-\tstrcpy (fname, skip_redundant_dir_prefix (searchptr->fname));\n-\tif (fname[0] && fname[strlen (fname) - 1] != '/')\n-\t  strcat (fname, \"/\");\n-      } else {\n-\tfname[0] = 0;\n+\n+      if (searchptr == first_bracket_include) {\n+\t/* Go to bypass directory if we know we've seen this file before.  */\n+\tstatic struct bypass_dir *bypass_hashtab[INCLUDE_HASHSIZE];\n+\tstruct bypass_dir *p;\n+\tbypass_slot = &bypass_hashtab[hashf ((U_CHAR *) fbeg, flen,\n+\t\t\t\t\t     INCLUDE_HASHSIZE)];\n+\tfor (p = *bypass_slot; p; p = p->next)\n+\t  if (!strcmp (fbeg, p->fname)) {\n+\t    searchptr = p->searchptr;\n+\t    bypass_slot = 0;\n+\t    break;\n+\t  }\n       }\n-      strncat (fname, (char *) fbeg, flen);\n+\n+      strcpy (fname, searchptr->fname);\n+      strcat (fname, fbeg);\n #ifdef VMS\n       /* Change this 1/2 Unix 1/2 VMS file specification into a\n          full VMS file specification */\n-      if (searchptr->fname && (searchptr->fname[0] != 0)) {\n+      if (searchptr->fname[0]) {\n \t/* Fix up the filename */\n \thack_vms_include_specification (fname);\n       } else {\n       \t/* This is a normal VMS filespec, so use it unchanged.  */\n-\tstrncpy (fname, fbeg, flen);\n-\tfname[flen] = 0;\n+\tstrcpy (fname, fbeg);\n \t/* if it's '#include filename', add the missing .h */\n \tif (index(fname,'.')==NULL) {\n \t  strcat (fname, \".h\");\n \t}\n       }\n #endif /* VMS */\n-      /* ??? There are currently 3 separate mechanisms for avoiding processing\n-\t of redundant include files: #import, #pragma once, and\n-\t redundant_include_p.  It would be nice if they were unified.  */\n-      if (redundant_include_p (fname))\n-\treturn 0;\n-      if (importing)\n-\tf = lookup_import (fname, searchptr);\n-      else\n-\tf = open_include_file (fname, searchptr);\n-      if (f == -2)\n-\treturn 0;\t\t\t/* Already included this file */\n-#ifdef EACCES\n-      else if (f == -1 && errno == EACCES)\n-\twarning (\"Header file %s exists, but is not readable\", fname);\n-#endif\n-      if (f >= 0)\n+      f = open_include_file (fname, searchptr, importing, &inc);\n+      if (f != -1) {\n+\tif (bypass_slot && searchptr != first_bracket_include) {\n+\t  /* This is the first time we found this include file,\n+\t     and we found it after first_bracket_include.\n+\t     Record its location so that we can bypass to here next time.  */\n+\t  struct bypass_dir *p\n+\t    = (struct bypass_dir *) xmalloc (sizeof (struct bypass_dir));\n+\t  p->next = *bypass_slot;\n+\t  p->fname = fname + strlen (searchptr->fname);\n+\t  p->searchptr = searchptr;\n+\t  *bypass_slot = p;\n+\t}\n+\tbreak;\n+      }\n+      if (errno != ENOENT)\n \tbreak;\n     }\n   }\n \n+\n   if (f < 0) {\n-    /* A file that was not found.  */\n \n-    strncpy (fname, (char *) fbeg, flen);\n-    fname[flen] = 0;\n+    if (f == -2) {\n+      /* The file was already included.  */\n+\n     /* If generating dependencies and -MG was specified, we assume missing\n        files are leaf files, living in the same directory as the source file\n        or other similar place; these missing files may be generated from\n        other files and may not exist yet (eg: y.tab.h).  */\n-    if (print_deps_missing_files\n-\t&& print_deps > (angle_brackets || (system_include_depth > 0)))\n+    } else if (print_deps_missing_files\n+\t       && (system_include_depth != 0) < print_deps)\n       {\n \t/* If it was requested as a system header file,\n \t   then assume it belongs in the first place to look for such.  */\n \tif (angle_brackets)\n \t  {\n-\t    for (searchptr = search_start; searchptr; searchptr = searchptr->next)\n-\t      {\n-\t\tif (searchptr->fname)\n-\t\t  {\n-\t\t    char *p;\n-\n-\t\t    if (searchptr->fname[0] == 0)\n-\t\t      continue;\n-\t\t    p = (char *) alloca (strlen (searchptr->fname)\n-\t\t\t\t\t + strlen (fname) + 2);\n-\t\t    strcpy (p, skip_redundant_dir_prefix (searchptr->fname));\n-\t\t    if (p[0] && p[strlen (p) - 1] != '/')\n-\t\t      strcat (p, \"/\");\n-\t\t    strcat (p, fname);\n-\t\t    deps_output (p, ' ');\n-\t\t    break;\n-\t\t  }\n-\t      }\n+\t    if (search_start) {\n+\t      char *p = (char *) alloca (strlen (search_start->fname)\n+\t\t\t\t\t + strlen (fbeg) + 1);\n+\t      strcpy (p, search_start->fname);\n+\t      strcat (p, fbeg);\n+\t      deps_output (p, ' ');\n+\t    }\n \t  }\n \telse\n \t  {\n \t    /* Otherwise, omit the directory, as if the file existed\n \t       in the directory with the source.  */\n-\t    deps_output (fname, ' ');\n+\t    deps_output (fbeg, ' ');\n \t  }\n       }\n     /* If -M was specified, and this header file won't be added to the\n        dependency list, then don't count this as an error, because we can\n        still produce correct output.  Otherwise, we can't produce correct\n        output, because there may be dependencies we need inside the missing\n        file, and we don't know what directory this missing file exists in.  */\n-    else if (print_deps\n-\t&& (print_deps <= (angle_brackets || (system_include_depth > 0))))\n-      warning (\"No include path in which to find %s\", fname);\n-    else if (search_start)\n-      error_from_errno (fname);\n+    else if (0 < print_deps  &&  print_deps <= (system_include_depth != 0))\n+      warning (\"No include path in which to find %s\", fbeg);\n+    else if (f != -3)\n+      error_from_errno (fbeg);\n     else\n-      error (\"No include path in which to find %s\", fname);\n-  } else {\n-    /* Check to see if this include file is a once-only include file.\n-       If so, give up.  */\n-\n-    struct file_name_list* ptr;\n-\n-    for (ptr = dont_repeat_files; ptr; ptr = ptr->next) {\n-      if (!strcmp (ptr->fname, fname)) {\n-\tclose (f);\n-        return 0;\t\t\t\t/* This file was once'd. */\n-      }\n-    }\n-\n-    for (ptr = all_include_files; ptr; ptr = ptr->next) {\n-      if (!strcmp (ptr->fname, fname))\n-        break;\t\t\t\t/* This file was included before. */\n-    }\n+      error (\"No include path in which to find %s\", fbeg);\n \n-    if (ptr == 0) {\n-      /* This is the first time for this file.  */\n-      /* Add it to list of files included.  */\n-\n-      ptr = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n-      ptr->control_macro = 0;\n-      ptr->c_system_include_path = 0;\n-      ptr->next = all_include_files;\n-      all_include_files = ptr;\n-      ptr->fname = savestring (fname);\n-      ptr->got_name_map = 0;\n-\n-      /* For -M, add this file to the dependencies.  */\n-      if (print_deps > (angle_brackets || (system_include_depth > 0)))\n-\tdeps_output (fname, ' ');\n-    }   \n-\n-    /* Handle -H option.  */\n-    if (print_include_names)\n-      fprintf (stderr, \"%*s%s\\n\", indepth, \"\", fname);\n-\n-    if (angle_brackets)\n-      system_include_depth++;\n+  } else {\n \n     /* Actually process the file.  */\n-    add_import (f, fname);\t/* Record file on \"seen\" list for #import. */\n \n     pcftry = (char *) alloca (strlen (fname) + 30);\n     pcfbuf = 0;\n     pcfnum = 0;\n \n     if (!no_precomp)\n       {\n-\tstruct stat stat_f;\n-\n-\tfstat (f, &stat_f);\n-\n \tdo {\n \t  sprintf (pcftry, \"%s%d\", fname, pcfnum++);\n \n@@ -4673,12 +4535,12 @@ do_include (buf, limit, op, keyword)\n \t    {\n \t      struct stat s;\n \n-\t      fstat (pcf, &s);\n-\t      if (bcmp ((char *) &stat_f.st_ino, (char *) &s.st_ino,\n-\t\t\tsizeof (s.st_ino))\n-\t\t  || stat_f.st_dev != s.st_dev)\n+\t      if (fstat (pcf, &s) != 0)\n+\t\tpfatal_with_name (pcftry);\n+\t      if (! INO_T_EQ (inc->st.st_ino, s.st_ino)\n+\t\t  || inc->st.st_dev != s.st_dev)\n \t\t{\n-\t\t  pcfbuf = check_precompiled (pcf, fname, &pcfbuflimit);\n+\t\t  pcfbuf = check_precompiled (pcf, &s, fname, &pcfbuflimit);\n \t\t  /* Don't need it any more.  */\n \t\t  close (pcf);\n \t\t}\n@@ -4700,28 +4562,11 @@ do_include (buf, limit, op, keyword)\n \t\t  (U_CHAR *) fname, op);\n     }\n     else\n-      finclude (f, fname, op, is_system_include (fname), searchptr);\n-\n-    if (angle_brackets)\n-      system_include_depth--;\n+      finclude (f, inc, op, is_system_include (fname), searchptr);\n   }\n-  return 0;\n-}\n \n-/* Return nonzero if there is no need to include file NAME\n-   because it has already been included and it contains a conditional\n-   to make a repeated include do nothing.  */\n+  system_include_depth -= angle_brackets;\n \n-static int\n-redundant_include_p (name)\n-     char *name;\n-{\n-  struct file_name_list *l = all_include_files;\n-  for (; l; l = l->next)\n-    if (! strcmp (name, l->fname)\n-\t&& l->control_macro\n-\t&& lookup (l->control_macro, -1, -1))\n-      return 1;\n   return 0;\n }\n \n@@ -4744,38 +4589,116 @@ is_system_include (filename)\n \n   for (searchptr = first_system_include; searchptr;\n        searchptr = searchptr->next)\n-    if (searchptr->fname) {\n-      register char *sys_dir = skip_redundant_dir_prefix (searchptr->fname);\n-      register unsigned length = strlen (sys_dir);\n+    if (! strncmp (searchptr->fname, filename, strlen (searchptr->fname)))\n+      return searchptr->c_system_include_path + 1;\n+  return 0;\n+}\n+\f\n+/* Yield the non-directory suffix of a file name.  */\n \n-      if (! strncmp (sys_dir, filename, length)\n-\t  && (filename[length] == '/'\n+static char *\n+base_name (fname)\n+     char *fname;\n+{\n+  char *s = fname;\n+  char *p;\n+#if defined (__MSDOS__) || defined (_WIN32)\n+  if (isalpha (s[0]) && s[1] == ':') s += 2;\n+#endif\n+#ifdef VMS\n+  if ((p = rindex (s, ':'))) s = p + 1;\t/* Skip device.  */\n+  if ((p = rindex (s, ']'))) s = p + 1;\t/* Skip directory.  */\n+  if ((p = rindex (s, '>'))) s = p + 1;\t/* Skip alternate (int'n'l) dir.  */\n+  if (s != fname)\n+    return s;\n+#endif\n+  if ((p = rindex (s, '/'))) s = p + 1;\n #ifdef DIR_SEPARATOR\n-\t      || filename[length] == DIR_SEPARATOR\n+  if ((p = rindex (s, DIR_SEPARATOR))) s = p + 1;\n+#endif\n+  return s;\n+}\n+\n+/* Yield nonzero if FILENAME is absolute (i.e. not relative).  */\n+static int\n+absolute_filename (filename)\n+     char *filename;\n+{\n+#if defined (__MSDOS__) || defined (_WIN32)\n+  if (isalpha (filename[0]) && filename[1] == ':') filename += 2;\n+#endif\n+  if (filename[0] == '/') return 1;\n+#ifdef DIR_SEPARATOR\n+  if (filename[0] == DIR_SEPARATOR) return 1;\n #endif\n-\t      )) {\n-\tif (searchptr->c_system_include_path)\n-\t  return 2;\n-\telse\n-\t  return 1;\n-      }\n-    }\n   return 0;\n }\n-\f\n-/* Skip leading \"./\" from a directory name.\n-   This may yield the empty string, which represents the current directory.  */\n \n-static char *\n-skip_redundant_dir_prefix (dir)\n-     char *dir;\n+/* Remove unnecessary characters from FILENAME in place,\n+   to avoid unnecessary filename aliasing.\n+   Return the length of the resulting string.\n+\n+   Do only the simplifications allowed by Posix.\n+   It is OK to miss simplifications on non-Posix hosts,\n+   since this merely leads to suboptimial results.  */\n+\n+static size_t\n+simplify_filename (filename)\n+     char *filename;\n {\n-  while (dir[0] == '.' && dir[1] == '/')\n-    for (dir += 2; *dir == '/'; dir++)\n-      continue;\n-  if (dir[0] == '.' && !dir[1])\n-    dir++;\n-  return dir;\n+  register char *from = filename;\n+  register char *to = filename;\n+  char *to0;\n+\n+  /* Remove redundant initial /s.  */\n+  if (*from == '/') {\n+    *to++ = '/';\n+    if (*++from == '/') {\n+      if (*++from == '/') {\n+\t/* 3 or more initial /s are equivalent to 1 /.  */\n+\twhile (*++from == '/')\n+\t  continue;\n+      } else {\n+\t/* On some hosts // differs from /; Posix allows this.  */\n+\tstatic int slashslash_vs_slash;\n+\tif (slashslash_vs_slash == 0) {\n+\t  struct stat s1, s2;\n+\t  slashslash_vs_slash = ((stat (\"/\", &s1) == 0 && stat (\"//\", &s2) == 0\n+\t\t\t\t  && INO_T_EQ (s1.st_ino, s2.st_ino)\n+\t\t\t\t  && s1.st_dev == s2.st_dev)\n+\t\t\t\t ? 1 : -1);\n+\t}\n+\tif (slashslash_vs_slash < 0)\n+\t  *to++ = '/';\n+      }\n+    }\n+  }\n+  to0 = to;\n+\n+  for (;;) {\n+    if (from[0] == '.' && from[1] == '/')\n+      from += 2;\n+    else {\n+      /* Copy this component and trailing /, if any.  */\n+      while ((*to++ = *from++) != '/') {\n+\tif (!to[-1]) {\n+\t  /* Trim . component at end of nonempty name.  */\n+\t  to -= filename <= to - 3 && to[-3] == '/' && to[-2] == '.';\n+\n+\t  /* Trim unnecessary trailing /s.  */\n+\t  while (to0 < --to && to[-1] == '/')\n+\t    continue;\n+\n+\t  *to = 0;\n+\t  return to - filename;\n+\t}\n+      }\n+    }\n+\n+    /* Skip /s after a /.  */\n+    while (*from == '/')\n+      from++;\n+  }\n }\n \f\n /* The file_name_map structure holds a mapping of file names for a\n@@ -4827,7 +4750,9 @@ read_filename_string (ch, f)\n   return alloc;\n }\n \n-/* Read the file name map file for DIRNAME.  */\n+/* Read the file name map file for DIRNAME.\n+   If DIRNAME is empty, read the map file for the working directory;\n+   otherwise DIRNAME must end in '/'.  */\n \n static struct file_name_map *\n read_name_map (dirname)\n@@ -4846,9 +4771,6 @@ read_name_map (dirname)\n   char *name;\n   FILE *f;\n   size_t dirlen;\n-  int separator_needed;\n-\n-  dirname = skip_redundant_dir_prefix (dirname);\n \n   for (map_list_ptr = map_list; map_list_ptr;\n        map_list_ptr = map_list_ptr->map_list_next)\n@@ -4861,11 +4783,9 @@ read_name_map (dirname)\n   map_list_ptr->map_list_map = NULL;\n \n   dirlen = strlen (dirname);\n-  separator_needed = dirlen != 0 && dirname[dirlen - 1] != '/';\n-  name = (char *) alloca (dirlen + strlen (FILE_NAME_MAP_FILE) + 2);\n+  name = (char *) alloca (dirlen + strlen (FILE_NAME_MAP_FILE) + 1);\n   strcpy (name, dirname);\n-  name[dirlen] = '/';\n-  strcpy (name + dirlen + separator_needed, FILE_NAME_MAP_FILE);\n+  strcat (name, FILE_NAME_MAP_FILE);\n   f = fopen (name, \"r\");\n   if (!f)\n     map_list_ptr->map_list_map = NULL;\n@@ -4877,6 +4797,7 @@ read_name_map (dirname)\n \t{\n \t  char *from, *to;\n \t  struct file_name_map *ptr;\n+\t  size_t tolen;\n \n \t  if (is_space[ch])\n \t    continue;\n@@ -4885,19 +4806,21 @@ read_name_map (dirname)\n \t    ;\n \t  to = read_filename_string (ch, f);\n \n+\t  simplify_filename (from);\n+\t  tolen = simplify_filename (to);\n+\n \t  ptr = ((struct file_name_map *)\n \t\t xmalloc (sizeof (struct file_name_map)));\n \t  ptr->map_from = from;\n \n \t  /* Make the real filename absolute.  */\n-\t  if (*to == '/')\n+\t  if (absolute_filename (to))\n \t    ptr->map_to = to;\n \t  else\n \t    {\n-\t      ptr->map_to = xmalloc (dirlen + strlen (to) + 2);\n+\t      ptr->map_to = xmalloc (dirlen + tolen + 1);\n \t      strcpy (ptr->map_to, dirname);\n-\t      ptr->map_to[dirlen] = '/';\n-\t      strcpy (ptr->map_to + dirlen + separator_needed, to);\n+\t      strcat (ptr->map_to, to);\n \t      free (to);\n \t    }\t      \n \n@@ -4918,85 +4841,153 @@ read_name_map (dirname)\n }  \n \n /* Try to open include file FILENAME.  SEARCHPTR is the directory\n-   being tried from the include file search path.  This function maps\n-   filenames on file systems based on information read by\n+   being tried from the include file search path.\n+   IMPORTING is \"\" if we are importing, null otherwise.\n+   Return -2 if found, either a matching name or a matching inode.\n+   Otherwise, open the file and return a file descriptor if successful\n+   or -1 if unsuccessful.\n+   Unless unsuccessful, put a descriptor of the included file into *PINC.\n+   This function maps filenames on file systems based on information read by\n    read_name_map.  */\n \n static int\n-open_include_file (filename, searchptr)\n+open_include_file (filename, searchptr, importing, pinc)\n+     char *filename;\n+     struct file_name_list *searchptr;\n+     U_CHAR *importing;\n+     struct include_file **pinc;\n+{\n+  char *fname = remap_include_file (filename, searchptr);\n+  int fd = -2;\n+\n+  /* Look up FNAME in include_hashtab.  */\n+  struct include_file **phead = &include_hashtab[hashf ((U_CHAR *) fname,\n+\t\t\t\t\t\t\tstrlen (fname),\n+\t\t\t\t\t\t\tINCLUDE_HASHSIZE)];\n+  struct include_file *inc, *head = *phead;\n+  for (inc = head; inc; inc = inc->next)\n+    if (!strcmp (fname, inc->fname))\n+      break;\n+\n+  if (!inc\n+      || ! inc->control_macro\n+      || (inc->control_macro[0] && ! lookup (inc->control_macro, -1, -1))) {\n+\n+    fd = open (fname, O_RDONLY, 0);\n+\n+    if (fd < 0)\n+      return fd;\n+\n+    if (!inc) {\n+      /* FNAME was not in include_hashtab; insert a new entry.  */\n+      inc = (struct include_file *) xmalloc (sizeof (struct include_file));\n+      inc->next = head;\n+      inc->fname = fname;\n+      inc->control_macro = 0;\n+      inc->deps_output = 0;\n+      if (fstat (fd, &inc->st) != 0)\n+\tpfatal_with_name (fname);\n+      *phead = inc;\n+\n+      /* Look for another file with the same inode and device.  */\n+      if (lookup_ino_include (inc)\n+\t  && inc->control_macro\n+\t  && (!inc->control_macro[0] || lookup (inc->control_macro, -1, -1))) {\n+\tclose (fd);\n+\tfd = -2;\n+      }\n+    }\n+\n+    /* For -M, add this file to the dependencies.  */\n+    if (! inc->deps_output  &&  (system_include_depth != 0) < print_deps) {\n+      inc->deps_output = 1;\n+      deps_output (fname, ' ');\n+    }   \n+\n+    /* Handle -H option.  */\n+    if (print_include_names)\n+      fprintf (stderr, \"%*s%s\\n\", indepth, \"\", fname);\n+  }\n+\n+  if (importing)\n+    inc->control_macro = importing;\n+\n+  *pinc = inc;\n+  return fd;\n+}\n+\n+/* Return the remapped name of the the include file FILENAME.\n+   SEARCHPTR is the directory being tried from the include file path.  */\n+\n+static char *\n+remap_include_file (filename, searchptr)\n      char *filename;\n      struct file_name_list *searchptr;\n {\n   register struct file_name_map *map;\n   register char *from;\n-  char *p, *dir;\n \n-  if (searchptr && ! searchptr->got_name_map)\n+  if (searchptr)\n     {\n-      searchptr->name_map = read_name_map (searchptr->fname\n-\t\t\t\t\t   ? searchptr->fname : \".\");\n-      searchptr->got_name_map = 1;\n-    }\n-\n-  /* First check the mapping for the directory we are using.  */\n-  if (searchptr && searchptr->name_map)\n-    {\n-      from = filename;\n-      if (searchptr->fname)\n-\tfrom += strlen (searchptr->fname) + 1;\n-      for (map = searchptr->name_map; map; map = map->map_next)\n+      if (! searchptr->got_name_map)\n \t{\n-\t  if (! strcmp (map->map_from, from))\n-\t    {\n-\t      /* Found a match.  */\n-\t      return open (map->map_to, O_RDONLY, 0666);\n-\t    }\n+\t  searchptr->name_map = read_name_map (searchptr->fname);\n+\t  searchptr->got_name_map = 1;\n \t}\n-    }\n \n-  /* Try to find a mapping file for the particular directory we are\n-     looking in.  Thus #include <sys/types.h> will look up sys/types.h\n-     in /usr/include/header.gcc and look up types.h in\n-     /usr/include/sys/header.gcc.  */\n-  p = rindex (filename, '/');\n-#ifdef DIR_SEPARATOR\n-  if (! p) p = rindex (filename, DIR_SEPARATOR);\n-  else {\n-    char *tmp = rindex (filename, DIR_SEPARATOR);\n-    if (tmp != NULL && tmp > p) p = tmp;\n-  }\n-#endif\n-  if (! p)\n-    p = filename;\n-  if (searchptr\n-      && searchptr->fname\n-      && strlen (searchptr->fname) == p - filename\n-      && ! strncmp (searchptr->fname, filename, p - filename))\n-    {\n-      /* FILENAME is in SEARCHPTR, which we've already checked.  */\n-      return open (filename, O_RDONLY, 0666);\n+      /* Check the mapping for the directory we are using.  */\n+      from = filename + strlen (searchptr->fname);\n+      for (map = searchptr->name_map; map; map = map->map_next)\n+\tif (! strcmp (map->map_from, from))\n+\t  return map->map_to;\n     }\n \n-  if (p == filename)\n+  from = base_name (filename);\n+\n+  if (from != filename || !searchptr)\n     {\n-      dir = \".\";\n-      from = filename;\n+      /* Try to find a mapping file for the particular directory we are\n+\t looking in.  Thus #include <sys/types.h> will look up sys/types.h\n+\t in /usr/include/header.gcc and look up types.h in\n+\t /usr/include/sys/header.gcc.  */\n+\n+      char *dir = (char *) alloca (from - filename + 1);\n+      bcopy (filename, dir, from - filename);\n+      dir[from - filename] = '\\0';\n+\n+      for (map = read_name_map (dir); map; map = map->map_next)\n+\tif (! strcmp (map->map_from, from))\n+\t  return map->map_to;\n     }\n-  else\n-    {\n-      dir = (char *) alloca (p - filename + 1);\n-      bcopy (filename, dir, p - filename);\n-      dir[p - filename] = '\\0';\n-      from = p + 1;\n+\n+  return filename;\n+}\n+\n+/* Insert INC into the include file table, hashed by device and inode number.\n+   If a file with different name but same dev+ino was already in the table,\n+   return 1 and set INC's control macro to the already-known macro.  */\n+\n+static int\n+lookup_ino_include (inc)\n+     struct include_file *inc;\n+{\n+  int hash = ((unsigned) (inc->st.st_dev + INO_T_HASH (inc->st.st_ino))\n+\t      % INCLUDE_HASHSIZE);\n+  struct include_file *i = include_ino_hashtab[hash];\n+  inc->next_ino = i;\n+  include_ino_hashtab[hash] = inc;\n+\n+  for (; i; i = i->next_ino)\n+    if (INO_T_EQ (inc->st.st_ino, i->st.st_ino)\n+\t&& inc->st.st_dev == i->st.st_dev) {\n+      inc->control_macro = i->control_macro;\n+      return 1;\n     }\n-  for (map = read_name_map (dir); map; map = map->map_next)\n-    if (! strcmp (map->map_from, from))\n-      return open (map->map_to, O_RDONLY, 0666);\n \n-  return open (filename, O_RDONLY, 0666);\n+  return 0;\n }\n \f\n-/* Process the contents of include file FNAME, already open on descriptor F,\n+/* Process file descriptor F, which corresponds to include file INC,\n    with output to OP.\n    SYSTEM_HEADER_P is 1 if this file resides in any one of the known\n    \"system\" include directories (as decided by the `is_system_include'\n@@ -5005,47 +4996,40 @@ open_include_file (filename, searchptr)\n    or 0 if the file name was absolute.  */\n \n static void\n-finclude (f, fname, op, system_header_p, dirptr)\n+finclude (f, inc, op, system_header_p, dirptr)\n      int f;\n-     char *fname;\n+     struct include_file *inc;\n      FILE_BUF *op;\n      int system_header_p;\n      struct file_name_list *dirptr;\n {\n-  int st_mode;\n-  long st_size;\n-  long i;\n+  char *fname = inc->fname;\n+  int i;\n   FILE_BUF *fp;\t\t\t/* For input stack frame */\n   int missing_newline = 0;\n \n   CHECK_DEPTH (return;);\n \n-  if (file_size_and_mode (f, &st_mode, &st_size) < 0)\n-    {\n-      perror_with_name (fname);\n-      close (f);\n-      return;\n-    }\n-\n   fp = &instack[indepth + 1];\n   bzero ((char *) fp, sizeof (FILE_BUF));\n   fp->nominal_fname = fp->fname = fname;\n+  fp->inc = inc;\n   fp->length = 0;\n   fp->lineno = 1;\n   fp->if_stack = if_stack;\n   fp->system_header_p = system_header_p;\n   fp->dir = dirptr;\n \n-  if (S_ISREG (st_mode)) {\n-    fp->buf = (U_CHAR *) xmalloc (st_size + 2);\n+  if (S_ISREG (inc->st.st_mode)) {\n+    fp->buf = (U_CHAR *) xmalloc (inc->st.st_size + 2);\n     fp->bufp = fp->buf;\n \n-    /* Read the file contents, knowing that st_size is an upper bound\n+    /* Read the file contents, knowing that inc->st.st_size is an upper bound\n        on the number of bytes we can read.  */\n-    fp->length = safe_read (f, (char *) fp->buf, st_size);\n+    fp->length = safe_read (f, (char *) fp->buf, inc->st.st_size);\n     if (fp->length < 0) goto nope;\n   }\n-  else if (S_ISDIR (st_mode)) {\n+  else if (S_ISDIR (inc->st.st_mode)) {\n     error (\"directory `%s' specified in #include\", fname);\n     close (f);\n     return;\n@@ -5055,8 +5039,8 @@ finclude (f, fname, op, system_header_p, dirptr)\n        copy them into buffer on stack. */\n \n     int bsize = 2000;\n+    int st_size = 0;\n \n-    st_size = 0;\n     fp->buf = (U_CHAR *) xmalloc (bsize + 2);\n \n     for (;;) {\n@@ -5115,129 +5099,25 @@ finclude (f, fname, op, system_header_p, dirptr)\n   free (fp->buf);\n }\n \n-/* Record that inclusion of the file named FILE\n+/* Record that inclusion of the include file INC\n    should be controlled by the macro named MACRO_NAME.\n    This means that trying to include the file again\n    will do something if that macro is defined.  */\n \n static void\n-record_control_macro (file, macro_name)\n-     char *file;\n+record_control_macro (inc, macro_name)\n+     struct include_file *inc;\n      U_CHAR *macro_name;\n {\n-  struct file_name_list *new;\n-\n-  for (new = all_include_files; new; new = new->next) {\n-    if (!strcmp (new->fname, file)) {\n-      new->control_macro = macro_name;\n-      return;\n-    }\n-  }\n-\n-  /* If the file is not in all_include_files, something's wrong.  */\n-  abort ();\n-}\n-\f\n-/* Maintain and search list of included files, for #import.  */\n-\n-#define IMPORT_HASH_SIZE 31\n-\n-struct import_file {\n-  char *name;\n-  ino_t inode;\n-  dev_t dev;\n-  struct import_file *next;\n-};\n-\n-/* Hash table of files already included with #include or #import.  */\n-\n-static struct import_file *import_hash_table[IMPORT_HASH_SIZE];\n-\n-/* Hash a file name for import_hash_table.  */\n-\n-static int \n-import_hash (f)\n-     char *f;\n-{\n-  int val = 0;\n-\n-  while (*f) val += *f++;\n-  return (val%IMPORT_HASH_SIZE);\n-}\n-\n-/* Search for file FILENAME in import_hash_table.\n-   Return -2 if found, either a matching name or a matching inode.\n-   Otherwise, open the file and return a file descriptor if successful\n-   or -1 if unsuccessful.  */\n-\n-static int\n-lookup_import (filename, searchptr)\n-     char *filename;\n-     struct file_name_list *searchptr;\n-{\n-  struct import_file *i;\n-  int h;\n-  int hashval;\n-  struct stat sb;\n-  int fd;\n-\n-  hashval = import_hash (filename);\n-\n-  /* Attempt to find file in list of already included files */\n-  i = import_hash_table[hashval];\n-\n-  while (i) {\n-    if (!strcmp (filename, i->name))\n-      return -2;\t\t/* return found */\n-    i = i->next;\n-  }\n-  /* Open it and try a match on inode/dev */\n-  fd = open_include_file (filename, searchptr);\n-  if (fd < 0)\n-    return fd;\n-  fstat (fd, &sb);\n-  for (h = 0; h < IMPORT_HASH_SIZE; h++) {\n-    i = import_hash_table[h];\n-    while (i) {\n-      /* Compare the inode and the device.\n-\t Supposedly on some systems the inode is not a scalar.  */\n-      if (!bcmp ((char *) &i->inode, (char *) &sb.st_ino, sizeof (sb.st_ino))\n-\t  && i->dev == sb.st_dev) {\n-        close (fd);\n-        return -2;\t\t/* return found */\n-      }\n-      i = i->next;\n-    }\n-  }\n-  return fd;\t\t\t/* Not found, return open file */\n-}\n-\n-/* Add the file FNAME, open on descriptor FD, to import_hash_table.  */\n-\n-static void\n-add_import (fd, fname)\n-     int fd;\n-     char *fname;\n-{\n-  struct import_file *i;\n-  int hashval;\n-  struct stat sb;\n-\n-  hashval = import_hash (fname);\n-  fstat (fd, &sb);\n-  i = (struct import_file *)xmalloc (sizeof (struct import_file));\n-  i->name = xmalloc (strlen (fname)+1);\n-  strcpy (i->name, fname);\n-  bcopy ((char *) &sb.st_ino, (char *) &i->inode, sizeof (sb.st_ino));\n-  i->dev = sb.st_dev;\n-  i->next = import_hash_table[hashval];\n-  import_hash_table[hashval] = i;\n+  if (!inc->control_macro || inc->control_macro[0])\n+    inc->control_macro = macro_name;\n }\n \f\n /* Load the specified precompiled header into core, and verify its\n    preconditions.  PCF indicates the file descriptor to read, which must\n-   be a regular file.  FNAME indicates the file name of the original \n-   header.  *LIMIT will be set to an address one past the end of the file.\n+   be a regular file.  *ST is its file status.\n+   FNAME indicates the file name of the original header.\n+   *LIMIT will be set to an address one past the end of the file.\n    If the preconditions of the file are not satisfied, the buffer is \n    freed and we return 0.  If the preconditions are satisfied, return\n    the address of the buffer following the preconditions.  The buffer, in\n@@ -5246,27 +5126,23 @@ add_import (fd, fname)\n    the run.\n */\n static char *\n-check_precompiled (pcf, fname, limit)\n+check_precompiled (pcf, st, fname, limit)\n      int pcf;\n+     struct stat *st;\n      char *fname;\n      char **limit;\n {\n-  int st_mode;\n-  long st_size;\n   int length = 0;\n   char *buf;\n   char *cp;\n \n   if (pcp_outfile)\n     return 0;\n-  \n-  if (file_size_and_mode (pcf, &st_mode, &st_size) < 0)\n-    return 0;\n \n-  if (S_ISREG (st_mode))\n+  if (S_ISREG (st->st_mode))\n     {\n-      buf = xmalloc (st_size + 2);\n-      length = safe_read (pcf, buf, st_size);\n+      buf = xmalloc (st->st_size + 2);\n+      length = safe_read (pcf, buf, st->st_size);\n       if (length < 0)\n \tgoto nope;\n     }\n@@ -6872,25 +6748,12 @@ static void\n do_once ()\n {\n   int i;\n-  FILE_BUF *ip = NULL;\n \n   for (i = indepth; i >= 0; i--)\n-    if (instack[i].fname != NULL) {\n-      ip = &instack[i];\n+    if (instack[i].inc) {\n+      record_control_macro (instack[i].inc, (U_CHAR *) \"\");\n       break;\n     }\n-\n-  if (ip != NULL) {\n-    struct file_name_list *new;\n-    \n-    new = (struct file_name_list *) xmalloc (sizeof (struct file_name_list));\n-    new->next = dont_repeat_files;\n-    dont_repeat_files = new;\n-    new->fname = savestring (ip->fname);\n-    new->control_macro = 0;\n-    new->got_name_map = 0;\n-    new->c_system_include_path = 0;\n-  }\n }\n \n /* #ident has already been copied to the output file, so just ignore it.  */\n@@ -6949,8 +6812,9 @@ do_pragma (buf, limit, op, keyword)\n   if (!strncmp ((char *) buf, \"implementation\", 14)) {\n     /* Be quiet about `#pragma implementation' for a file only if it hasn't\n        been included yet.  */\n-    struct file_name_list *ptr;\n-    U_CHAR *p = buf + 14, *fname, *inc_fname;\n+\n+    int h;\n+    U_CHAR *p = buf + 14, *fname;\n     SKIP_WHITE_SPACE (p);\n     if (*p == '\\n' || *p != '\\\"')\n       return 0;\n@@ -6959,15 +6823,16 @@ do_pragma (buf, limit, op, keyword)\n     if ((p = (U_CHAR *) index ((char *) fname, '\\\"')))\n       *p = '\\0';\n     \n-    for (ptr = all_include_files; ptr; ptr = ptr->next) {\n-      inc_fname = (U_CHAR *) rindex (ptr->fname, '/');\n-      inc_fname = inc_fname ? inc_fname + 1 : (U_CHAR *) ptr->fname;\n-      if (inc_fname && !strcmp ((char *) inc_fname, (char *) fname))\n-\twarning (\"`#pragma implementation' for `%s' appears after file is included\",\n-\t\t fname);\n+    for (h = 0; h < INCLUDE_HASHSIZE; h++) {\n+      struct include_file *inc;\n+      for (inc = include_hashtab[h]; inc; inc = inc->next) {\n+\tif (!strcmp (base_name (inc->fname), (char *) fname)) {\n+\t  warning (\"`#pragma implementation' for \\\"%s\\\" appears after its #include\",fname);\n+\t  return 0;\n+\t}\n+      }\n     }\n   }\n-\n   return 0;\n }\n \n@@ -7365,23 +7230,33 @@ skip_if_group (ip, any, op)\n \t  bp++;\n \telse if (*bp == '\\\\' && bp[1] == '\\n')\n \t  bp += 2;\n-\telse if (*bp == '/' && bp[1] == '*') {\n-\t  bp += 2;\n-\t  while (!(*bp == '*' && bp[1] == '/')) {\n-\t    if (*bp == '\\n')\n-\t      ip->lineno++;\n-\t    bp++;\n-\t  }\n-\t  bp += 2;\n-\t} else if (cplusplus_comments && *bp == '/' && bp[1] == '/') {\n-\t  bp += 2;\n-\t  while (bp[-1] == '\\\\' || *bp != '\\n') {\n-\t    if (*bp == '\\n')\n-\t      ip->lineno++;\n-\t    bp++;\n-\t  }\n-        }\n-\telse break;\n+\telse if (*bp == '/') {\n+\t  if (bp[1] == '*') {\n+\t    for (bp += 2; ; bp++) {\n+\t      if (*bp == '\\n')\n+\t\tip->lineno++;\n+\t      else if (*bp == '*') {\n+\t\tif (bp[-1] == '/' && warn_comments)\n+\t\t  warning (\"`/*' within comment\");\n+\t\tif (bp[1] == '/')\n+\t\t  break;\n+\t      }\n+\t    }\n+\t    bp += 2;\n+\t  } else if (bp[1] == '/' && cplusplus_comments) {\n+\t    for (bp += 2; ; bp++) {\n+\t      if (*bp == '\\n') {\n+\t\tif (bp[-1] != '\\\\')\n+\t\t  break;\n+\t\tif (warn_comments)\n+\t\t  warning (\"multiline `//' comment\");\n+\t\tip->lineno++;\n+\t      }\n+\t    }\n+\t  } else\n+\t    break;\n+        } else\n+\t  break;\n       }\n \n       cp = bp;\n@@ -7623,7 +7498,7 @@ do_endif (buf, limit, op, keyword)\n       if (indepth != 0\n \t  && ! (indepth == 1 && no_record_file)\n \t  && ! (no_record_file && no_output))\n-\trecord_control_macro (ip->fname, temp->control_macro);\n+\trecord_control_macro (ip->inc, temp->control_macro);\n     fail: ;\n     }\n     free (temp);\n@@ -7693,54 +7568,38 @@ skip_to_end_of_comment (ip, line_counter, nowarn)\n {\n   register U_CHAR *limit = ip->buf + ip->length;\n   register U_CHAR *bp = ip->bufp;\n-  FILE_BUF *op = &outbuf;\t/* JF */\n-  int output = put_out_comments && !line_counter;\n+  FILE_BUF *op = put_out_comments && !line_counter ? &outbuf : (FILE_BUF *) 0;\n   int start_line = line_counter ? *line_counter : 0;\n \n \t/* JF this line_counter stuff is a crock to make sure the\n \t   comment is only put out once, no matter how many times\n \t   the comment is skipped.  It almost works */\n-  if (output) {\n+  if (op) {\n     *op->bufp++ = '/';\n-    *op->bufp++ = '*';\n+    *op->bufp++ = bp[-1];\n   }\n   if (cplusplus_comments && bp[-1] == '/') {\n-    if (output) {\n-      while (bp < limit) {\n+    for (; bp < limit; bp++) {\n+      if (op)\n \t*op->bufp++ = *bp;\n-\tif (*bp == '\\n' && bp[-1] != '\\\\')\n+      if (*bp == '\\n') {\n+\tif (bp[-1] != '\\\\')\n \t  break;\n-\tif (*bp == '\\n') {\n+\tif (!nowarn && warn_comments)\n+\t  warning (\"multiline `//' comment\");\n+\tif (line_counter)\n \t  ++*line_counter;\n+\tif (op)\n \t  ++op->lineno;\n-\t}\n-\tbp++;\n-      }\n-      op->bufp[-1] = '*';\n-      *op->bufp++ = '/';\n-      *op->bufp++ = '\\n';\n-    } else {\n-      while (bp < limit) {\n-\tif (bp[-1] != '\\\\' && *bp == '\\n') {\n-\t  break;\n-\t} else {\n-\t  if (*bp == '\\n' && line_counter)\n-\t    ++*line_counter;\n-\t  bp++;\n-\t}\n       }\n     }\n     ip->bufp = bp;\n     return bp;\n   }\n   while (bp < limit) {\n-    if (output)\n+    if (op)\n       *op->bufp++ = *bp;\n     switch (*bp++) {\n-    case '/':\n-      if (warn_comments && !nowarn && bp < limit && *bp == '*')\n-\twarning (\"`/*' within comment\");\n-      break;\n     case '\\n':\n       /* If this is the end of the file, we have an unterminated comment.\n \t Don't swallow the newline.  We are guaranteed that there will be a\n@@ -7753,14 +7612,16 @@ skip_to_end_of_comment (ip, line_counter, nowarn)\n \t}\n       if (line_counter != NULL)\n \t++*line_counter;\n-      if (output)\n+      if (op)\n \t++op->lineno;\n       break;\n     case '*':\n+      if (bp[-2] == '/' && !nowarn && warn_comments)\n+\twarning (\"`/*' within comment\");\n       if (*bp == '\\\\' && bp[1] == '\\n')\n \tnewline_fix (bp);\n       if (*bp == '/') {\n-        if (output)\n+        if (op)\n \t  *op->bufp++ = '/';\n \tip->bufp = ++bp;\n \treturn bp;\n@@ -8418,6 +8279,7 @@ macroexpand (hp, op)\n \n     ip2->fname = 0;\n     ip2->nominal_fname = 0;\n+    ip2->inc = 0;\n     /* This may not be exactly correct, but will give much better error\n        messages for nested macro calls than using a line number of zero.  */\n     ip2->lineno = start_line;\n@@ -8613,29 +8475,31 @@ macarg1 (start, limit, depthptr, newlines, comments, rest_args)\n     case '/':\n       if (bp[1] == '\\\\' && bp[2] == '\\n')\n \tnewline_fix (bp + 1);\n-      if (cplusplus_comments && bp[1] == '/') {\n+      if (bp[1] == '*') {\n \t*comments = 1;\n-\tbp += 2;\n-\twhile (bp < limit && (*bp != '\\n' || bp[-1] == '\\\\')) {\n-\t  if (*bp == '\\n') ++*newlines;\n-\t  bp++;\n+\tfor (bp += 2; bp < limit; bp++) {\n+\t  if (*bp == '\\n')\n+\t    ++*newlines;\n+\t  else if (*bp == '*') {\n+\t    if (bp[-1] == '/' && warn_comments)\n+\t      warning (\"`/*' within comment\");\n+\t    if (bp[1] == '\\\\' && bp[2] == '\\n')\n+\t      newline_fix (bp + 1);\n+\t    if (bp[1] == '/')\n+\t      break;\n+\t  }\n+\t}\n+      } else if (bp[1] == '/' && cplusplus_comments) {\n+\t*comments = 1;\n+\tfor (bp += 2; bp < limit; bp++) {\n+\t  if (*bp == '\\n') {\n+\t    ++*newlines;\n+\t    if (bp[-1] != '\\\\')\n+\t      break;\n+\t    if (warn_comments)\n+\t      warning (\"multiline `//' comment\");\n+\t  }\n \t}\n-\t/* Now count the newline that we are about to skip.  */\n-\t++*newlines;\n-\tbreak;\n-      }\n-      if (bp[1] != '*' || bp + 1 >= limit)\n-\tbreak;\n-      *comments = 1;\n-      bp += 2;\n-      while (bp + 1 < limit) {\n-\tif (bp[0] == '*'\n-\t    && bp[1] == '\\\\' && bp[2] == '\\n')\n-\t  newline_fix (bp + 1);\n-\tif (bp[0] == '*' && bp[1] == '/')\n-\t  break;\n-\tif (*bp == '\\n') ++*newlines;\n-\tbp++;\n       }\n       break;\n     case '\\'':\n@@ -9879,6 +9743,80 @@ make_assertion (option, str)\n   --indepth;\n }\n \f\n+/* The previous include prefix, if any, is PREV_FILE_NAME.\n+   Allocate a new include prefix whose name is the\n+   simplified concatenation of PREFIX and NAME,\n+   with a trailing / added if needed.\n+   But return 0 if the include prefix should be ignored,\n+   e.g. because it is a duplicate of PREV_FILE_NAME.  */\n+\n+static struct file_name_list *\n+new_include_prefix (prev_file_name, prefix, name)\n+     struct file_name_list *prev_file_name;\n+     char *prefix;\n+     char *name;\n+{\n+  if (!name)\n+    fatal (\"Directory name missing after command line option\");\n+\n+  if (!*name)\n+    /* Ignore the empty string.  */\n+    return 0;\n+  else {\n+    struct file_name_list *dir\n+      = ((struct file_name_list *)\n+\t xmalloc (sizeof (struct file_name_list)\n+\t\t  + strlen (prefix) + strlen (name) + 1 /* for trailing / */));\n+    size_t len;\n+    strcpy (dir->fname, prefix);\n+    strcat (dir->fname, name);\n+    len = simplify_filename (dir->fname);\n+\n+    /* Convert directory name to a prefix.  */\n+    if (dir->fname[len - 1] != '/') {\n+      if (len == 1 && dir->fname[len - 1] == '.')\n+\tlen = 0;\n+      else\n+\tdir->fname[len++] = '/';\n+      dir->fname[len] = 0;\n+    }\n+\n+    /* Ignore a directory whose name matches the previous one.  */\n+    if (prev_file_name && !strcmp (prev_file_name->fname, dir->fname)) {\n+      /* But treat `-Idir -I- -Idir' as `-I- -Idir'.  */\n+      if (!first_bracket_include)\n+\tfirst_bracket_include = prev_file_name;\n+      free (dir);\n+      return 0;\n+    }\n+\n+    /* Ignore a nonexistent directory.  */\n+    if (stat (len ? dir->fname : \".\", &dir->st) != 0) {\n+      if (errno != ENOENT)\n+\terror_from_errno (dir->fname);\n+      free (dir);\n+      return 0;\n+    }\n+\n+    /* Ignore a directory whose identity matches the previous one.  */\n+    if (prev_file_name\n+\t&& INO_T_EQ (prev_file_name->st.st_ino, dir->st.st_ino)\n+\t&& prev_file_name->st.st_dev == dir->st.st_dev) {\n+      /* But treat `-Idir -I- -Idir' as `-I- -Idir'.  */\n+      if (!first_bracket_include)\n+\tfirst_bracket_include = prev_file_name;\n+      free (dir);\n+      return 0;\n+    }\n+\n+    dir->next = 0;\n+    dir->c_system_include_path = 0;\n+    dir->got_name_map = 0;\n+\n+    return dir;\n+  }\n+}\n+\n /* Append a chain of `struct file_name_list's\n    to the end of the main include chain.\n    FIRST is the beginning of the chain to append, and LAST is the end.  */\n@@ -10060,23 +9998,6 @@ savestring (input)\n   return output;\n }\n \f\n-/* Get the file-mode and data size of the file open on FD\n-   and store them in *MODE_POINTER and *SIZE_POINTER.  */\n-\n-static int\n-file_size_and_mode (fd, mode_pointer, size_pointer)\n-     int fd;\n-     int *mode_pointer;\n-     long int *size_pointer;\n-{\n-  struct stat sbuf;\n-\n-  if (fstat (fd, &sbuf) < 0) return (-1);\n-  if (mode_pointer) *mode_pointer = sbuf.st_mode;\n-  if (size_pointer) *size_pointer = sbuf.st_size;\n-  return 0;\n-}\n-\f\n #ifdef VMS\n \n /* Under VMS we need to fix up the \"include\" specification\n@@ -10088,38 +10009,19 @@ hack_vms_include_specification (fname)\n      char *fname;\n {\n   register char *cp, *cp1, *cp2;\n-  int f, check_filename_before_returning, no_prefix_seen;\n+  int f, check_filename_before_returning;\n   char Local[512];\n \n   check_filename_before_returning = 0;\n-  no_prefix_seen = 0;\n-\n-  /* Ignore leading \"./\"s */\n-  while (fname[0] == '.' && fname[1] == '/') {\n-    strcpy (fname, fname+2);\n-    no_prefix_seen = 1;\t\t/* mark this for later */\n-  }\n-  /* Look for the boundary between the VMS and UNIX filespecs */\n-  cp = rindex (fname, ']');\t/* Look for end of dirspec. */\n-  if (cp == 0) cp = rindex (fname, '>'); /* ... Ditto\t\t    */\n-  if (cp == 0) cp = rindex (fname, ':'); /* Look for end of devspec. */\n-  if (cp) {\n-    cp++;\n-  } else {\n-    cp = index (fname, '/');\t/* Look for the \"/\" */\n-  }\n+\n+  cp = base_name (fname);\n \n   /*\n    * Check if we have a vax-c style '#include filename'\n    * and add the missing .h\n    */\n-  if (cp == 0) {\n-    if (index(fname,'.') == 0)\n-      strcat(fname, \".h\");\n-  } else {\n-    if (index(cp,'.') == 0)\n-      strcat(cp, \".h\");\n-  }\n+  if (!index (cp,'.'))\n+    strcat (cp, \".h\");\n \n   cp2 = Local;\t\t\t/* initialize */\n \n@@ -10226,7 +10128,7 @@ hack_vms_include_specification (fname)\n      to the user in that they can use both rooted and non-rooted logical names\n      to point to the location of the file.  */\n \n-  if (check_filename_before_returning && no_prefix_seen) {\n+  if (check_filename_before_returning) {\n     f = open (fname, O_RDONLY, 0666);\n     if (f >= 0) {\n       /* The file name is OK as it is, so return it as is.  */\n@@ -10346,26 +10248,6 @@ open (fname, flags, prot)\n #undef open\t/* Get back the REAL open routine */\n   return open (fname, flags, prot, \"mbc=16\", \"deq=64\", \"fop=tef\");\n }\n-\n-/* Avoid run-time library bug, where copying M out of N+M characters with\n-   N >= 65535 results in VAXCRTL's strncat falling into an infinite loop.\n-   gcc-cpp exercises this particular bug.  [Fixed in V5.5-2's VAXCRTL.]  */\n-\n-static char *\n-strncat (dst, src, cnt)\n-     char *dst;\n-     const char *src;\n-     unsigned cnt;\n-{\n-  register char *d = dst, *s = (char *) src;\n-  register int n = cnt;\t/* convert to _signed_ type */\n-\n-  while (*d) d++;\t/* advance to end */\n-  while (--n >= 0)\n-    if (!(*d++ = *s++)) break;\n-  if (n < 0) *d = '\\0';\n-  return dst;\n-}\n \f\n /* more VMS hackery */\n #include <fab.h>"}]}