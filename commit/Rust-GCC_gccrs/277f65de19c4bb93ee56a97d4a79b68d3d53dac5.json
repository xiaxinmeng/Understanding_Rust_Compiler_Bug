{"sha": "277f65de19c4bb93ee56a97d4a79b68d3d53dac5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc3ZjY1ZGUxOWM0YmI5M2VlNTZhOTdkNGE3OWI2OGQzZDUzZGFjNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-10-26T06:41:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-10-26T06:41:53Z"}, "message": "re PR bootstrap/55049 (bootstrap failed with  --with-multilib-list=m32,m64,mx32)\n\ngcc/\n\tPR bootstrap/55049\n\t* Makefile.in (rtlanal.o): Add dependency on addresses.h.\n\t* rtl.h (address_info): New structure.\n\t(strip_address_mutations, decompose_address, decompose_lea_address)\n\t(decompose_mem_address, update_address, get_index_scale)\n\t(get_index_code): Declare.\n\t* rtlanal.c: Include addresses.h.\n\t(strip_address_mutations, must_be_base_p, must_be_index_p)\n\t(set_address_segment, set_address_base, set_address_index)\n\t(set_address_disp, decompose_incdec_address, decompose_automod_address)\n\t(extract_plus_operands, baseness, decompose_normal_address)\n\t(decompose_address, decompose_lea_address, decompose_mem_address)\n\t(update_address, get_index_scale, get_index_code): New functions.\n\t* lra-constraints.c (strip_subreg): New function.\n\t(address, extract_loc_address_regs, extract_address_regs)\n\t(get_index_scale): Delete.\n\t(process_addr_reg): Apply strip_subreg to the location.\n\t(uses_hard_regs_p): Use decompose_mem_address.\n\t(valid_address_p, base_plus_disp_to_reg, can_add_disp_p)\n\t(equiv_address_substitution): Take an address_info rather\n\tthan an address.  Remove other arguments.  Avoid using Pmode.\n\t(process_address): Use decompose_mem_address and decompose_lea_address.\n\tUpdate calls to above functions.\n\nFrom-SVN: r192837", "tree": {"sha": "14915af2d40b8cb97045fa32be1ed0f4df090f74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14915af2d40b8cb97045fa32be1ed0f4df090f74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/277f65de19c4bb93ee56a97d4a79b68d3d53dac5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/277f65de19c4bb93ee56a97d4a79b68d3d53dac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/277f65de19c4bb93ee56a97d4a79b68d3d53dac5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f9d4ecd445d717e0309cec1882ab57f92c2dad6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9d4ecd445d717e0309cec1882ab57f92c2dad6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9d4ecd445d717e0309cec1882ab57f92c2dad6d"}], "stats": {"total": 1076, "additions": 595, "deletions": 481}, "files": [{"sha": "9d1dd5069a27dd48d868fc59a9c9e5ae3f8afb96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=277f65de19c4bb93ee56a97d4a79b68d3d53dac5", "patch": "@@ -1,3 +1,29 @@\n+2012-10-26  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR bootstrap/55049\n+\t* Makefile.in (rtlanal.o): Add dependency on addresses.h.\n+\t* rtl.h (address_info): New structure.\n+\t(strip_address_mutations, decompose_address, decompose_lea_address)\n+\t(decompose_mem_address, update_address, get_index_scale)\n+\t(get_index_code): Declare.\n+\t* rtlanal.c: Include addresses.h.\n+\t(strip_address_mutations, must_be_base_p, must_be_index_p)\n+\t(set_address_segment, set_address_base, set_address_index)\n+\t(set_address_disp, decompose_incdec_address, decompose_automod_address)\n+\t(extract_plus_operands, baseness, decompose_normal_address)\n+\t(decompose_address, decompose_lea_address, decompose_mem_address)\n+\t(update_address, get_index_scale, get_index_code): New functions.\n+\t* lra-constraints.c (strip_subreg): New function.\n+\t(address, extract_loc_address_regs, extract_address_regs)\n+\t(get_index_scale): Delete.\n+\t(process_addr_reg): Apply strip_subreg to the location.\n+\t(uses_hard_regs_p): Use decompose_mem_address.\n+\t(valid_address_p, base_plus_disp_to_reg, can_add_disp_p)\n+\t(equiv_address_substitution): Take an address_info rather\n+\tthan an address.  Remove other arguments.  Avoid using Pmode.\n+\t(process_address): Use decompose_mem_address and decompose_lea_address.\n+\tUpdate calls to above functions.\n+\n 2012-10-26  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* lra-constraints.c (process_address): Tighten arguments to"}, {"sha": "96765fe3dd098a87d0c2f769ded9a781ffa767e5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=277f65de19c4bb93ee56a97d4a79b68d3d53dac5", "patch": "@@ -2709,7 +2709,7 @@ print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H)\n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(DIAGNOSTIC_CORE_H) \\\n    $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) \\\n    $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) $(FUNCTION_H) $(TREE_H) \\\n-   $(DF_H) $(EMIT_RTL_H)\n+   $(DF_H) $(EMIT_RTL_H) addresses.h\n \n varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) hard-reg-set.h $(REGS_H) \\"}, {"sha": "9e4d3b1f6def1946af7ce69d4465c433c1579f0f", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 120, "deletions": 480, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=277f65de19c4bb93ee56a97d4a79b68d3d53dac5", "patch": "@@ -152,6 +152,13 @@ static enum machine_mode curr_operand_mode[MAX_RECOG_OPERANDS];\n static int new_regno_start;\n static int new_insn_uid_start;\n \n+/* If LOC is nonnull, strip any outer subreg from it.  */\n+static inline rtx *\n+strip_subreg (rtx *loc)\n+{\n+  return loc && GET_CODE (*loc) == SUBREG ? &SUBREG_REG (*loc) : loc;\n+}\n+\n /* Return hard regno of REGNO or if it is was not assigned to a hard\n    register, use a hard register from its allocno class.  */\n static int\n@@ -435,28 +442,6 @@ get_reload_reg (enum op_type type, enum machine_mode mode, rtx original,\n \n /* The page contains code to extract memory address parts.  */\n \n-/* Info about base and index regs of an address.  In some rare cases,\n-   base/index register can be actually memory.\tIn this case we will\n-   reload it.  */\n-struct address\n-{\n-  /* NULL if there is no a base register.  */\n-  rtx *base_reg_loc;\n-  /* Second location of {post/pre}_modify, NULL otherwise.  */\n-  rtx *base_reg_loc2;\n-  /* NULL if there is no an index register.  */\n-  rtx *index_reg_loc;\n-  /* Location of index reg * scale or index_reg_loc otherwise.  */\n-  rtx *index_loc;\n-  /* NULL if there is no a displacement.  */\n-  rtx *disp_loc;\n-  /* Defined if base_reg_loc is not NULL.  */\n-  enum rtx_code base_outer_code, index_code;\n-  /* True if the base register is modified in the address, for\n-     example, in PRE_INC.  */\n-  bool base_modify_p;\n-};\n-\n /* Wrapper around REGNO_OK_FOR_INDEX_P, to allow pseudos.  */\n static inline bool\n ok_for_index_p_nonstrict (rtx reg)\n@@ -479,305 +464,6 @@ ok_for_base_p_nonstrict (rtx reg, enum machine_mode mode, addr_space_t as,\n   return ok_for_base_p_1 (regno, mode, as, outer_code, index_code);\n }\n \n-/* Process address part in space AS (or all address if TOP_P) with\n-   location *LOC to extract address characteristics.\n-\n-   If CONTEXT_P is false, we are looking at the base part of an\n-   address, otherwise we are looking at the index part.\n-\n-   MODE is the mode of the memory reference; OUTER_CODE and INDEX_CODE\n-   give the context that the rtx appears in; MODIFY_P if *LOC is\n-   modified.  */\n-static void\n-extract_loc_address_regs (bool top_p, enum machine_mode mode, addr_space_t as,\n-\t\t\t  rtx *loc, bool context_p, enum rtx_code outer_code,\n-\t\t\t  enum rtx_code index_code,\n-\t\t\t  bool modify_p, struct address *ad)\n-{\n-  rtx x = *loc;\n-  enum rtx_code code = GET_CODE (x);\n-  bool base_ok_p;\n-\n-  switch (code)\n-    {\n-    case CONST_INT:\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      if (! context_p)\n-\t{\n-\t  lra_assert (top_p);\n-\t  ad->disp_loc = loc;\n-\t}\n-      return;\n-\n-    case CC0:\n-    case PC:\n-      return;\n-\n-    case ZERO_EXTEND:\n-      /* Pass TOP_P for displacement.  */\n-      extract_loc_address_regs (top_p, mode, as, &XEXP (*loc, 0), context_p,\n-\t\t\t\tcode, index_code, modify_p, ad);\n-      return;\n-\n-    case PLUS:\n-    case LO_SUM:\n-      /* When we have an address that is a sum, we must determine\n-\t whether registers are \"base\" or \"index\" regs.\tIf there is a\n-\t sum of two registers, we must choose one to be the\n-\t \"base\".  */\n-      {\n-\trtx *arg0_loc = &XEXP (x, 0);\n-\trtx *arg1_loc = &XEXP (x, 1);\n-\trtx *tloc;\n-\trtx arg0 = *arg0_loc;\n-\trtx arg1 = *arg1_loc;\n-\tenum rtx_code code0 = GET_CODE (arg0);\n-\tenum rtx_code code1 = GET_CODE (arg1);\n-\n-\t/* Look inside subregs.\t */\n-\tif (code0 == SUBREG)\n-\t  {\n-\t    arg0_loc = &SUBREG_REG (arg0);\n-\t    arg0 = *arg0_loc;\n-\t    code0 = GET_CODE (arg0);\n-\t  }\n-\tif (code1 == SUBREG)\n-\t  {\n-\t    arg1_loc = &SUBREG_REG (arg1);\n-\t    arg1 = *arg1_loc;\n-\t    code1 = GET_CODE (arg1);\n-\t  }\n-\n-\tif (CONSTANT_P (arg0)\n-\t    || code1 == PLUS || code1 == MULT || code1 == ASHIFT)\n-\t  {\n-\t    tloc = arg1_loc;\n-\t    arg1_loc = arg0_loc;\n-\t    arg0_loc = tloc;\n-\t    arg0 = *arg0_loc;\n-\t    code0 = GET_CODE (arg0);\n-\t    arg1 = *arg1_loc;\n-\t    code1 = GET_CODE (arg1);\n-\t  }\n-\t/* If this machine only allows one register per address, it\n-\t   must be in the first operand.  */\n-\tif (MAX_REGS_PER_ADDRESS == 1 || code == LO_SUM)\n-\t  {\n-\t    lra_assert (ad->disp_loc == NULL);\n-\t    ad->disp_loc = arg1_loc;\n-\t    extract_loc_address_regs (false, mode, as, arg0_loc, false, code,\n-\t\t\t\t      code1, modify_p, ad);\n-\t  }\n-\t/* Base + disp addressing  */\n-\telse if (code0 != PLUS && code0 != MULT && code0 != ASHIFT\n-\t\t && CONSTANT_P (arg1))\n-\t  {\n-\t    lra_assert (ad->disp_loc == NULL);\n-\t    ad->disp_loc = arg1_loc;\n-\t    extract_loc_address_regs (false, mode, as, arg0_loc, false, PLUS,\n-\t\t\t\t      code1, modify_p, ad);\n-\t  }\n-\t/* If index and base registers are the same on this machine,\n-\t   just record registers in any non-constant operands.\tWe\n-\t   assume here, as well as in the tests below, that all\n-\t   addresses are in canonical form.  */\n-\telse if (INDEX_REG_CLASS\n-\t\t == base_reg_class (VOIDmode, as, PLUS, SCRATCH)\n-\t\t && code0 != PLUS && code0 != MULT && code0 != ASHIFT)\n-\t  {\n-\t    extract_loc_address_regs (false, mode, as, arg0_loc, false, PLUS,\n-\t\t\t\t      code1, modify_p, ad);\n-\t    lra_assert (! CONSTANT_P (arg1));\n-\t    extract_loc_address_regs (false, mode, as, arg1_loc, true, PLUS,\n-\t\t\t\t      code0, modify_p, ad);\n-\t  }\n-\t/* It might be [base + ]index * scale + disp. */\n-\telse if (CONSTANT_P (arg1))\n-\t  {\n-\t    lra_assert (ad->disp_loc == NULL);\n-\t    ad->disp_loc = arg1_loc;\n-\t    extract_loc_address_regs (false, mode, as, arg0_loc, context_p,\n-\t\t\t\t      PLUS, code0, modify_p, ad);\n-\t  }\n-\t/* If both operands are registers but one is already a hard\n-\t   register of index or reg-base class, give the other the\n-\t   class that the hard register is not.\t */\n-\telse if (code0 == REG && code1 == REG\n-\t\t && REGNO (arg0) < FIRST_PSEUDO_REGISTER\n-\t\t && ((base_ok_p\n-\t\t      = ok_for_base_p_nonstrict (arg0, mode, as, PLUS, REG))\n-\t\t     || ok_for_index_p_nonstrict (arg0)))\n-\t  {\n-\t    extract_loc_address_regs (false, mode, as, arg0_loc, ! base_ok_p,\n-\t\t\t\t      PLUS, REG, modify_p, ad);\n-\t    extract_loc_address_regs (false, mode, as, arg1_loc, base_ok_p,\n-\t\t\t\t      PLUS, REG, modify_p, ad);\n-\t  }\n-\telse if (code0 == REG && code1 == REG\n-\t\t && REGNO (arg1) < FIRST_PSEUDO_REGISTER\n-\t\t && ((base_ok_p\n-\t\t      = ok_for_base_p_nonstrict (arg1, mode, as, PLUS, REG))\n-\t\t     || ok_for_index_p_nonstrict (arg1)))\n-\t  {\n-\t    extract_loc_address_regs (false, mode, as, arg0_loc, base_ok_p,\n-\t\t\t\t      PLUS, REG, modify_p, ad);\n-\t    extract_loc_address_regs (false, mode, as, arg1_loc, ! base_ok_p,\n-\t\t\t\t      PLUS, REG, modify_p, ad);\n-\t  }\n-\t/* Otherwise, count equal chances that each might be a base or\n-\t   index register.  This case should be rare.  */\n-\telse\n-\t  {\n-\t    extract_loc_address_regs (false, mode, as, arg0_loc, false, PLUS,\n-\t\t\t\t      code1, modify_p, ad);\n-\t    extract_loc_address_regs (false, mode, as, arg1_loc,\n-\t\t\t\t      ad->base_reg_loc != NULL, PLUS,\n-\t\t\t\t      code0, modify_p, ad);\n-\t  }\n-      }\n-      break;\n-\n-    case MULT:\n-    case ASHIFT:\n-      {\n-\trtx *arg0_loc = &XEXP (x, 0);\n-\tenum rtx_code code0 = GET_CODE (*arg0_loc);\n-\t\n-\tif (code0 == CONST_INT)\n-\t  arg0_loc = &XEXP (x, 1);\n-\textract_loc_address_regs (false, mode, as, arg0_loc, true,\n-\t\t\t\t  outer_code, code, modify_p, ad);\n-\tlra_assert (ad->index_loc == NULL);\n-\tad->index_loc = loc;\n-\tbreak;\n-      }\n-\n-    case POST_MODIFY:\n-    case PRE_MODIFY:\n-      extract_loc_address_regs (false, mode, as, &XEXP (x, 0), false,\n-\t\t\t\tcode, GET_CODE (XEXP (XEXP (x, 1), 1)),\n-\t\t\t\ttrue, ad);\n-      lra_assert (rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)));\n-      ad->base_reg_loc2 = &XEXP (XEXP (x, 1), 0);\n-      if (REG_P (XEXP (XEXP (x, 1), 1)))\n-\textract_loc_address_regs (false, mode, as, &XEXP (XEXP (x, 1), 1),\n-\t\t\t\t  true, code, REG, modify_p, ad);\n-      break;\n-\n-    case POST_INC:\n-    case PRE_INC:\n-    case POST_DEC:\n-    case PRE_DEC:\n-      extract_loc_address_regs (false, mode, as, &XEXP (x, 0), false, code,\n-\t\t\t\tSCRATCH, true, ad);\n-      break;\n-\n-      /* We process memory as a register.  That means we flatten\n-\t addresses.  In other words, the final code will never\n-\t contains memory in an address even if the target supports\n-\t such addresses (it is too rare these days).  Memory also can\n-\t occur in address as a result some previous transformations\n-\t like equivalence substitution.\t */\n-    case MEM:\n-    case REG:\n-      if (context_p)\n-\t{\n-\t  lra_assert (ad->index_reg_loc == NULL);\n-\t  ad->index_reg_loc = loc;\n-\t}\n-      else\n-\t{\n-\t  lra_assert (ad->base_reg_loc == NULL);\n-\t  ad->base_reg_loc = loc;\n-\t  ad->base_outer_code = outer_code;\n-\t  ad->index_code = index_code;\n-\t  ad->base_modify_p = modify_p;\n-\t}\n-      break;\n-    default:\n-      {\n-\tconst char *fmt = GET_RTX_FORMAT (code);\n-\tint i;\n-\n-\tif (GET_RTX_LENGTH (code) != 1\n-\t    || fmt[0] != 'e' || GET_CODE (XEXP (x, 0)) != UNSPEC)\n-\t  {\n-\t    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-\t      if (fmt[i] == 'e')\n-\t\textract_loc_address_regs (false, mode, as, &XEXP (x, i),\n-\t\t\t\t\t  context_p, code, SCRATCH,\n-\t\t\t\t\t  modify_p, ad);\n-\t    break;\n-\t  }\n-\t/* fall through for case UNARY_OP (UNSPEC ...)\t*/\n-      }\n-\n-    case UNSPEC:\n-      if (ad->disp_loc == NULL)\n-\tad->disp_loc = loc;\n-      else if (ad->base_reg_loc == NULL)\n-\t{\n-\t  ad->base_reg_loc = loc;\n-\t  ad->base_outer_code = outer_code;\n-\t  ad->index_code = index_code;\n-\t  ad->base_modify_p = modify_p;\n-\t}\n-      else\n-\t{\n-\t  lra_assert (ad->index_reg_loc == NULL);\n-\t  ad->index_reg_loc = loc;\n-\t}\n-      break;\n-\n-    }\n-}\n-\n-\n-/* Describe address *LOC in AD.  There are two cases:\n-   - *LOC is the address in a (mem ...).  In this case OUTER_CODE is MEM\n-     and AS is the mem's address space.\n-   - *LOC is matched to an address constraint such as 'p'.  In this case\n-     OUTER_CODE is ADDRESS and AS is ADDR_SPACE_GENERIC.  */\n-static void\n-extract_address_regs (enum machine_mode mem_mode, addr_space_t as,\n-\t\t      rtx *loc, enum rtx_code outer_code, struct address *ad)\n-{\n-  ad->base_reg_loc = ad->base_reg_loc2\n-    = ad->index_reg_loc = ad->index_loc = ad->disp_loc = NULL;\n-  ad->base_outer_code = SCRATCH;\n-  ad->index_code = SCRATCH;\n-  ad->base_modify_p = false;\n-  extract_loc_address_regs (true, mem_mode, as, loc, false, outer_code,\n-\t\t\t    SCRATCH, false, ad);  \n-  if (ad->index_loc == NULL)\n-    /* SUBREG ??? */\n-    ad->index_loc = ad->index_reg_loc;\n-}\n-\n-/* Return the scale applied to *AD->INDEX_REG_LOC, or 0 if the index is\n-   more complicated than that.  */\n-static HOST_WIDE_INT\n-get_index_scale (struct address *ad)\n-{\n-  rtx index = *ad->index_loc;\n-  if (GET_CODE (index) == MULT\n-      && CONST_INT_P (XEXP (index, 1))\n-      && ad->index_reg_loc == &XEXP (index, 0))\n-    return INTVAL (XEXP (index, 1));\n-\n-  if (GET_CODE (index) == ASHIFT\n-      && CONST_INT_P (XEXP (index, 1))\n-      && ad->index_reg_loc == &XEXP (index, 0))\n-    return (HOST_WIDE_INT) 1 << INTVAL (XEXP (index, 1));\n-\n-  if (ad->index_reg_loc == ad->index_loc)\n-    return 1;\n-\n-  return 0;\n-}\n-\n \f\n \n /* The page contains major code to choose the current insn alternative\n@@ -1354,11 +1040,13 @@ process_addr_reg (rtx *loc, rtx *before, rtx *after, enum reg_class cl)\n {\n   int regno;\n   enum reg_class rclass, new_class;\n-  rtx reg = *loc;\n+  rtx reg;\n   rtx new_reg;\n   enum machine_mode mode;\n   bool before_p = false;\n \n+  loc = strip_subreg (loc);\n+  reg = *loc;\n   mode = GET_MODE (reg);\n   if (! REG_P (reg))\n     {\n@@ -1538,21 +1226,13 @@ uses_hard_regs_p (rtx x, HARD_REG_SET set)\n     }\n   if (MEM_P (x))\n     {\n-      struct address ad;\n-      enum machine_mode mode = GET_MODE (x);\n-      rtx *addr_loc = &XEXP (x, 0);\n+      struct address_info ad;\n \n-      extract_address_regs (mode, MEM_ADDR_SPACE (x), addr_loc, MEM, &ad);\n-      if (ad.base_reg_loc != NULL)\n-\t{\n-\t  if (uses_hard_regs_p (*ad.base_reg_loc, set))\n-\t    return true;\n-\t}\n-      if (ad.index_reg_loc != NULL)\n-\t{\n-\t  if (uses_hard_regs_p (*ad.index_reg_loc, set))\n-\t    return true;\n-\t}\n+      decompose_mem_address (&ad, x);\n+      if (ad.base_term != NULL && uses_hard_regs_p (*ad.base_term, set))\n+\treturn true;\n+      if (ad.index_term != NULL && uses_hard_regs_p (*ad.index_term, set))\n+\treturn true;\n     }\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -2399,115 +2079,92 @@ valid_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n #endif\n }\n \n-/* Return whether address X, described by AD, is valid for mode MODE\n-   and address space AS.  */\n+/* Return whether address AD is valid.  */\n \n static bool\n-valid_address_p (struct address *ad, enum machine_mode mode, rtx x,\n-\t\t addr_space_t as)\n+valid_address_p (struct address_info *ad)\n {\n   /* Some ports do not check displacements for eliminable registers,\n      so we replace them temporarily with the elimination target.  */\n   rtx saved_base_reg = NULL_RTX;\n   rtx saved_index_reg = NULL_RTX;\n-  if (ad->base_reg_loc != NULL)\n+  rtx *base_term = strip_subreg (ad->base_term);\n+  rtx *index_term = strip_subreg (ad->index_term);\n+  if (base_term != NULL)\n     {\n-      saved_base_reg = *ad->base_reg_loc;\n-      lra_eliminate_reg_if_possible (ad->base_reg_loc);\n-      if (ad->base_reg_loc2 != NULL)\n-\t*ad->base_reg_loc2 = *ad->base_reg_loc;\n+      saved_base_reg = *base_term;\n+      lra_eliminate_reg_if_possible (base_term);\n+      if (ad->base_term2 != NULL)\n+\t*ad->base_term2 = *ad->base_term;\n     }\n-  if (ad->index_reg_loc != NULL)\n+  if (index_term != NULL)\n     {\n-      saved_index_reg = *ad->index_reg_loc;\n-      lra_eliminate_reg_if_possible (ad->index_reg_loc);\n+      saved_index_reg = *index_term;\n+      lra_eliminate_reg_if_possible (index_term);\n     }\n-  bool ok_p = valid_address_p (mode, x, as);\n+  bool ok_p = valid_address_p (ad->mode, *ad->outer, ad->as);\n   if (saved_base_reg != NULL_RTX)\n     {\n-      *ad->base_reg_loc = saved_base_reg;\n-      if (ad->base_reg_loc2 != NULL)\n-\t*ad->base_reg_loc2 = saved_base_reg;\n+      *base_term = saved_base_reg;\n+      if (ad->base_term2 != NULL)\n+\t*ad->base_term2 = *ad->base_term;\n     }\n   if (saved_index_reg != NULL_RTX)\n-    *ad->index_reg_loc = saved_index_reg;\n+    *index_term = saved_index_reg;\n   return ok_p;\n }\n \n-/* Make reload base reg + disp from address AD in space AS of memory\n-   with MODE into a new pseudo.\t Return the new pseudo.\t */\n+/* Make reload base reg + disp from address AD.  Return the new pseudo.  */\n static rtx\n-base_plus_disp_to_reg (enum machine_mode mode, addr_space_t as,\n-\t\t       struct address *ad)\n+base_plus_disp_to_reg (struct address_info *ad)\n {\n   enum reg_class cl;\n   rtx new_reg;\n \n-  lra_assert (ad->base_reg_loc != NULL && ad->disp_loc != NULL);\n-  cl = base_reg_class (mode, as, ad->base_outer_code, ad->index_code);\n-  new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, \"base + disp\");\n-  lra_emit_add (new_reg, *ad->base_reg_loc, *ad->disp_loc);\n+  lra_assert (ad->base == ad->base_term && ad->disp == ad->disp_term);\n+  cl = base_reg_class (ad->mode, ad->as, ad->base_outer_code,\n+\t\t       get_index_code (ad));\n+  new_reg = lra_create_new_reg (GET_MODE (*ad->base_term), NULL_RTX,\n+\t\t\t\tcl, \"base + disp\");\n+  lra_emit_add (new_reg, *ad->base_term, *ad->disp_term);\n   return new_reg;\n }\n \n-/* Return true if we can add a displacement to address ADDR_LOC,\n-   which is described by AD, even if that makes the address invalid.\n-   The fix-up code requires any new address to be the sum of the base,\n-   index and displacement fields of an AD-like structure.  */\n+/* Return true if we can add a displacement to address AD, even if that\n+   makes the address invalid.  The fix-up code requires any new address\n+   to be the sum of the BASE_TERM, INDEX and DISP_TERM fields.  */\n static bool\n-can_add_disp_p (struct address *ad, rtx *addr_loc)\n+can_add_disp_p (struct address_info *ad)\n {\n-  /* Automodified addresses have a fixed form.  */\n-  if (ad->base_modify_p)\n-    return false;\n-\n-  /* If the address already has a displacement, and is not an UNSPEC,\n-     we can simply add the new displacement to it.  */\n-  if (ad->disp_loc && GET_CODE (*ad->disp_loc) == UNSPEC)\n-    return true;\n-\n-  /* If the address is entirely a base or index, we can try adding\n-     a constant to it.  */\n-  if (addr_loc == ad->base_reg_loc || addr_loc == ad->index_loc)\n-    return true;\n-\n-  /* Likewise if the address is entirely a sum of the base and index.  */\n-  if (GET_CODE (*addr_loc) == PLUS)\n-    {\n-      rtx *op0 = &XEXP (*addr_loc, 0);\n-      rtx *op1 = &XEXP (*addr_loc, 1);\n-      if (op0 == ad->base_reg_loc && op1 == ad->index_loc)\n-\treturn true;\n-      if (op1 == ad->base_reg_loc && op0 == ad->index_loc)\n-\treturn true;\n-    }\n-  return false;\n+  return (!ad->autoinc_p\n+\t  && ad->segment == NULL\n+\t  && ad->base == ad->base_term\n+\t  && ad->disp == ad->disp_term);\n }\n \n-/* Make substitution in address AD in space AS with location ADDR_LOC.\n-   Update AD and ADDR_LOC if it is necessary.  Return true if a\n-   substitution was made.  */\n+/* Make equiv substitution in address AD.  Return true if a substitution\n+   was made.  */\n static bool\n-equiv_address_substitution (struct address *ad, rtx *addr_loc,\n-\t\t\t    enum machine_mode mode, addr_space_t as,\n-\t\t\t    enum rtx_code code)\n+equiv_address_substitution (struct address_info *ad)\n {\n-  rtx base_reg, new_base_reg, index_reg, new_index_reg;\n+  rtx base_reg, new_base_reg, index_reg, new_index_reg, *base_term, *index_term;\n   HOST_WIDE_INT disp, scale;\n   bool change_p;\n \n-  if (ad->base_reg_loc == NULL)\n+  base_term = strip_subreg (ad->base_term);\n+  if (base_term == NULL)\n     base_reg = new_base_reg = NULL_RTX;\n   else\n     {\n-      base_reg = *ad->base_reg_loc;\n+      base_reg = *base_term;\n       new_base_reg = get_equiv_substitution (base_reg);\n     }\n-  if (ad->index_reg_loc == NULL)\n+  index_term = strip_subreg (ad->index_term);\n+  if (index_term == NULL)\n     index_reg = new_index_reg = NULL_RTX;\n   else\n     {\n-      index_reg = *ad->index_reg_loc;\n+      index_reg = *index_term;\n       new_index_reg = get_equiv_substitution (index_reg);\n     }\n   if (base_reg == new_base_reg && index_reg == new_index_reg)\n@@ -2518,53 +2175,53 @@ equiv_address_substitution (struct address *ad, rtx *addr_loc,\n     {\n       fprintf (lra_dump_file, \"Changing address in insn %d \",\n \t       INSN_UID (curr_insn));\n-      print_value_slim (lra_dump_file, *addr_loc, 1);\n+      print_value_slim (lra_dump_file, *ad->outer, 1);\n     }\n   if (base_reg != new_base_reg)\n     {\n       if (REG_P (new_base_reg))\n \t{\n-\t  *ad->base_reg_loc = new_base_reg;\n+\t  *base_term = new_base_reg;\n \t  change_p = true;\n \t}\n       else if (GET_CODE (new_base_reg) == PLUS\n \t       && REG_P (XEXP (new_base_reg, 0))\n \t       && CONST_INT_P (XEXP (new_base_reg, 1))\n-\t       && can_add_disp_p (ad, addr_loc))\n+\t       && can_add_disp_p (ad))\n \t{\n \t  disp += INTVAL (XEXP (new_base_reg, 1));\n-\t  *ad->base_reg_loc = XEXP (new_base_reg, 0);\n+\t  *base_term = XEXP (new_base_reg, 0);\n \t  change_p = true;\n \t}\n-      if (ad->base_reg_loc2 != NULL)\n-\t*ad->base_reg_loc2 = *ad->base_reg_loc;\n+      if (ad->base_term2 != NULL)\n+\t*ad->base_term2 = *ad->base_term;\n     }\n   if (index_reg != new_index_reg)\n     {\n       if (REG_P (new_index_reg))\n \t{\n-\t  *ad->index_reg_loc = new_index_reg;\n+\t  *index_term = new_index_reg;\n \t  change_p = true;\n \t}\n       else if (GET_CODE (new_index_reg) == PLUS\n \t       && REG_P (XEXP (new_index_reg, 0))\n \t       && CONST_INT_P (XEXP (new_index_reg, 1))\n-\t       && can_add_disp_p (ad, addr_loc)\n+\t       && can_add_disp_p (ad)\n \t       && (scale = get_index_scale (ad)))\n \t{\n \t  disp += INTVAL (XEXP (new_index_reg, 1)) * scale;\n-\t  *ad->index_reg_loc = XEXP (new_index_reg, 0);\n+\t  *index_term = XEXP (new_index_reg, 0);\n \t  change_p = true;\n \t}\n     }\n   if (disp != 0)\n     {\n-      if (ad->disp_loc != NULL)\n-\t*ad->disp_loc = plus_constant (Pmode, *ad->disp_loc, disp);\n+      if (ad->disp != NULL)\n+\t*ad->disp = plus_constant (GET_MODE (*ad->inner), *ad->disp, disp);\n       else\n \t{\n-\t  *addr_loc = gen_rtx_PLUS (Pmode, *addr_loc, GEN_INT (disp));\n-\t  extract_address_regs (mode, as, addr_loc, code, ad);\n+\t  *ad->inner = plus_constant (GET_MODE (*ad->inner), *ad->inner, disp);\n+\t  update_address (ad);\n \t}\n       change_p = true;\n     }\n@@ -2575,7 +2232,7 @@ equiv_address_substitution (struct address *ad, rtx *addr_loc,\n       else\n \t{\n \t  fprintf (lra_dump_file, \" on equiv \");\n-\t  print_value_slim (lra_dump_file, *addr_loc, 1);\n+\t  print_value_slim (lra_dump_file, *ad->outer, 1);\n \t  fprintf (lra_dump_file, \"\\n\");\n \t}\n     }\n@@ -2604,62 +2261,43 @@ equiv_address_substitution (struct address *ad, rtx *addr_loc,\n static bool\n process_address (int nop, rtx *before, rtx *after)\n {\n-  struct address ad;\n-  enum machine_mode mode;\n-  rtx new_reg, *addr_loc;\n-  addr_space_t as;\n+  struct address_info ad;\n+  rtx new_reg;\n   rtx op = *curr_id->operand_loc[nop];\n   const char *constraint = curr_static_id->operand[nop].constraint;\n   bool change_p;\n-  enum rtx_code code;\n \n   if (constraint[0] == 'p'\n       || EXTRA_ADDRESS_CONSTRAINT (constraint[0], constraint))\n-    {\n-      mode = VOIDmode;\n-      addr_loc = curr_id->operand_loc[nop];\n-      as = ADDR_SPACE_GENERIC;\n-      code = ADDRESS;\n-    }\n+    decompose_lea_address (&ad, curr_id->operand_loc[nop]);\n   else if (MEM_P (op))\n-    {\n-      mode = GET_MODE (op);\n-      addr_loc = &XEXP (op, 0);\n-      as = MEM_ADDR_SPACE (op);\n-      code = MEM;\n-    }\n+    decompose_mem_address (&ad, op);\n   else if (GET_CODE (op) == SUBREG\n \t   && MEM_P (SUBREG_REG (op)))\n-    {\n-      mode = GET_MODE (SUBREG_REG (op));\n-      addr_loc = &XEXP (SUBREG_REG (op), 0);\n-      as = MEM_ADDR_SPACE (SUBREG_REG (op));\n-      code = MEM;\n-    }\n+    decompose_mem_address (&ad, SUBREG_REG (op));\n   else\n     return false;\n-  if (GET_CODE (*addr_loc) == AND)\n-    addr_loc = &XEXP (*addr_loc, 0);\n-  extract_address_regs (mode, as, addr_loc, code, &ad);\n-  change_p = equiv_address_substitution (&ad, addr_loc, mode, as, code);\n-  if (ad.base_reg_loc != NULL\n+  change_p = equiv_address_substitution (&ad);\n+  if (ad.base_term != NULL\n       && (process_addr_reg\n-\t  (ad.base_reg_loc, before,\n-\t   (ad.base_modify_p && REG_P (*ad.base_reg_loc)\n-\t    && find_regno_note (curr_insn, REG_DEAD,\n-\t\t\t\tREGNO (*ad.base_reg_loc)) == NULL_RTX\n+\t  (ad.base_term, before,\n+\t   (ad.autoinc_p\n+\t    && !(REG_P (*ad.base_term)\n+\t\t && find_regno_note (curr_insn, REG_DEAD,\n+\t\t\t\t     REGNO (*ad.base_term)) != NULL_RTX)\n \t    ? after : NULL),\n-\t   base_reg_class (mode, as, ad.base_outer_code, ad.index_code))))\n+\t   base_reg_class (ad.mode, ad.as, ad.base_outer_code,\n+\t\t\t   get_index_code (&ad)))))\n     {\n       change_p = true;\n-      if (ad.base_reg_loc2 != NULL)\n-\t*ad.base_reg_loc2 = *ad.base_reg_loc;\n+      if (ad.base_term2 != NULL)\n+\t*ad.base_term2 = *ad.base_term;\n     }\n-  if (ad.index_reg_loc != NULL\n-      && process_addr_reg (ad.index_reg_loc, before, NULL, INDEX_REG_CLASS))\n+  if (ad.index_term != NULL\n+      && process_addr_reg (ad.index_term, before, NULL, INDEX_REG_CLASS))\n     change_p = true;\n \n-  /* There are three cases where the shape of *ADDR_LOC may now be invalid:\n+  /* There are three cases where the shape of *AD.INNER may now be invalid:\n \n      1) the original address was valid, but either elimination or\n \tequiv_address_substitution applied a displacement that made\n@@ -2670,21 +2308,25 @@ process_address (int nop, rtx *before, rtx *after)\n \n      3) the address is a frame address with an invalid offset.\n \n-     All these cases involve a displacement, so there is no point\n-     revalidating when there is no displacement.  */\n-  if (ad.disp_loc == NULL || valid_address_p (&ad, mode, *addr_loc, as))\n+     All these cases involve a displacement and a non-autoinc address,\n+     so there is no point revalidating other types.  */\n+  if (ad.disp == NULL || ad.autoinc_p || valid_address_p (&ad))\n     return change_p;\n \n   /* Any index existed before LRA started, so we can assume that the\n      presence and shape of the index is valid.  */\n   push_to_sequence (*before);\n-  if (ad.base_reg_loc == NULL)\n+  gcc_assert (ad.segment == NULL);\n+  gcc_assert (ad.disp == ad.disp_term);\n+  if (ad.base == NULL)\n     {\n-      if (ad.index_reg_loc == NULL)\n+      if (ad.index == NULL)\n \t{\n \t  int code = -1;\n-\t  enum reg_class cl = base_reg_class (mode, as, SCRATCH, SCRATCH);\n-\t  \n+\t  enum reg_class cl = base_reg_class (ad.mode, ad.as,\n+\t\t\t\t\t      SCRATCH, SCRATCH);\n+\t  rtx disp = *ad.disp;\n+\n \t  new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, \"disp\");\n #ifdef HAVE_lo_sum\n \t  {\n@@ -2694,16 +2336,14 @@ process_address (int nop, rtx *before, rtx *after)\n \t    /* disp => lo_sum (new_base, disp), case (2) above.  */\n \t    insn = emit_insn (gen_rtx_SET\n \t\t\t      (VOIDmode, new_reg,\n-\t\t\t       gen_rtx_HIGH (Pmode, copy_rtx (*ad.disp_loc))));\n+\t\t\t       gen_rtx_HIGH (Pmode, copy_rtx (disp))));\n \t    code = recog_memoized (insn);\n \t    if (code >= 0)\n \t      {\n-\t\trtx save = *ad.disp_loc;\n-\n-\t\t*ad.disp_loc = gen_rtx_LO_SUM (Pmode, new_reg, *ad.disp_loc);\n-\t\tif (! valid_address_p (mode, *ad.disp_loc, as))\n+\t\t*ad.disp = gen_rtx_LO_SUM (Pmode, new_reg, disp);\n+\t\tif (! valid_address_p (ad.mode, *ad.outer, ad.as))\n \t\t  {\n-\t\t    *ad.disp_loc = save;\n+\t\t    *ad.disp = disp;\n \t\t    code = -1;\n \t\t  }\n \t      }\n@@ -2714,42 +2354,42 @@ process_address (int nop, rtx *before, rtx *after)\n \t  if (code < 0)\n \t    {\n \t      /* disp => new_base, case (2) above.  */\n-\t      lra_emit_move (new_reg, *ad.disp_loc);\n-\t      *ad.disp_loc = new_reg;\n+\t      lra_emit_move (new_reg, disp);\n+\t      *ad.disp = new_reg;\n \t    }\n \t}\n       else\n \t{\n \t  /* index * scale + disp => new base + index * scale,\n \t     case (1) above.  */\n-\t  enum reg_class cl = base_reg_class (mode, as, PLUS,\n-\t\t\t\t\t      GET_CODE (*ad.index_loc));\n+\t  enum reg_class cl = base_reg_class (ad.mode, ad.as, PLUS,\n+\t\t\t\t\t      GET_CODE (*ad.index));\n \n \t  lra_assert (INDEX_REG_CLASS != NO_REGS);\n \t  new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, \"disp\");\n-\t  lra_emit_move (new_reg, *ad.disp_loc);\n-\t  *addr_loc = simplify_gen_binary (PLUS, GET_MODE (new_reg),\n-\t\t\t\t\t   new_reg, *ad.index_loc);\n+\t  lra_emit_move (new_reg, *ad.disp);\n+\t  *ad.inner = simplify_gen_binary (PLUS, GET_MODE (new_reg),\n+\t\t\t\t\t   new_reg, *ad.index);\n \t}\n     }\n-  else if (ad.index_reg_loc == NULL)\n+  else if (ad.index == NULL)\n     {\n       /* base + disp => new base, cases (1) and (3) above.  */\n       /* Another option would be to reload the displacement into an\n \t index register.  However, postreload has code to optimize\n \t address reloads that have the same base and different\n \t displacements, so reloading into an index register would\n \t not necessarily be a win.  */\n-      new_reg = base_plus_disp_to_reg (mode, as, &ad);\n-      *addr_loc = new_reg;\n+      new_reg = base_plus_disp_to_reg (&ad);\n+      *ad.inner = new_reg;\n     }\n   else\n     {\n       /* base + scale * index + disp => new base + scale * index,\n \t case (1) above.  */\n-      new_reg = base_plus_disp_to_reg (mode, as, &ad);\n-      *addr_loc = simplify_gen_binary (PLUS, GET_MODE (new_reg),\n-\t\t\t\t       new_reg, *ad.index_loc);\n+      new_reg = base_plus_disp_to_reg (&ad);\n+      *ad.inner = simplify_gen_binary (PLUS, GET_MODE (new_reg),\n+\t\t\t\t       new_reg, *ad.index);\n     }\n   *before = get_insns ();\n   end_sequence ();"}, {"sha": "43a49c44ed7c412ac63f502aedc45d6212785401", "filename": "gcc/rtl.h", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=277f65de19c4bb93ee56a97d4a79b68d3d53dac5", "patch": "@@ -1237,6 +1237,77 @@ costs_add_n_insns (struct full_rtx_costs *c, int n)\n   c->size += COSTS_N_INSNS (n);\n }\n \n+/* Information about an address.  This structure is supposed to be able\n+   to represent all supported target addresses.  Please extend it if it\n+   is not yet general enough.  */\n+struct address_info {\n+  /* The mode of the value being addressed, or VOIDmode if this is\n+     a load-address operation with no known address mode.  */\n+  enum machine_mode mode;\n+\n+  /* The address space.  */\n+  addr_space_t as;\n+\n+  /* A pointer to the top-level address.  */\n+  rtx *outer;\n+\n+  /* A pointer to the inner address, after all address mutations\n+     have been stripped from the top-level address.  It can be one\n+     of the following:\n+\n+     - A {PRE,POST}_{INC,DEC} of *BASE.  SEGMENT, INDEX and DISP are null.\n+\n+     - A {PRE,POST}_MODIFY of *BASE.  In this case either INDEX or DISP\n+       points to the step value, depending on whether the step is variable\n+       or constant respectively.  SEGMENT is null.\n+\n+     - A plain sum of the form SEGMENT + BASE + INDEX + DISP,\n+       with null fields evaluating to 0.  */\n+  rtx *inner;\n+\n+  /* Components that make up *INNER.  Each one may be null or nonnull.\n+     When nonnull, their meanings are as follows:\n+\n+     - *SEGMENT is the \"segment\" of memory to which the address refers.\n+       This value is entirely target-specific and is only called a \"segment\"\n+       because that's its most typical use.  It contains exactly one UNSPEC,\n+       pointed to by SEGMENT_TERM.  The contents of *SEGMENT do not need\n+       reloading.\n+\n+     - *BASE is a variable expression representing a base address.\n+       It contains exactly one REG, SUBREG or MEM, pointed to by BASE_TERM.\n+\n+     - *INDEX is a variable expression representing an index value.\n+       It may be a scaled expression, such as a MULT.  It has exactly\n+       one REG, SUBREG or MEM, pointed to by INDEX_TERM.\n+\n+     - *DISP is a constant, possibly mutated.  DISP_TERM points to the\n+       unmutated RTX_CONST_OBJ.  */\n+  rtx *segment;\n+  rtx *base;\n+  rtx *index;\n+  rtx *disp;\n+\n+  rtx *segment_term;\n+  rtx *base_term;\n+  rtx *index_term;\n+  rtx *disp_term;\n+\n+  /* In a {PRE,POST}_MODIFY address, this points to a second copy\n+     of BASE_TERM, otherwise it is null.  */\n+  rtx *base_term2;\n+\n+  /* ADDRESS if this structure describes an address operand, MEM if\n+     it describes a MEM address.  */\n+  enum rtx_code addr_outer_code;\n+\n+  /* If BASE is nonnull, this is the code of the rtx that contains it.  */\n+  enum rtx_code base_outer_code;\n+\n+  /* True if this is an RTX_AUTOINC address.  */\n+  bool autoinc_p;\n+};\n+\n extern void init_rtlanal (void);\n extern int rtx_cost (rtx, enum rtx_code, int, bool);\n extern int address_cost (rtx, enum machine_mode, addr_space_t, bool);\n@@ -1260,6 +1331,14 @@ extern bool constant_pool_constant_p (rtx);\n extern bool truncated_to_mode (enum machine_mode, const_rtx);\n extern int low_bitmask_len (enum machine_mode, unsigned HOST_WIDE_INT);\n extern void split_double (rtx, rtx *, rtx *);\n+extern rtx *strip_address_mutations (rtx *, enum rtx_code * = 0);\n+extern void decompose_address (struct address_info *, rtx *,\n+\t\t\t       enum machine_mode, addr_space_t, enum rtx_code);\n+extern void decompose_lea_address (struct address_info *, rtx *);\n+extern void decompose_mem_address (struct address_info *, rtx);\n+extern void update_address (struct address_info *);\n+extern HOST_WIDE_INT get_index_scale (const struct address_info *);\n+extern enum rtx_code get_index_code (const struct address_info *);\n \n #ifndef GENERATOR_FILE\n /* Return the cost of SET X.  SPEED_P is true if optimizing for speed"}, {"sha": "399886c1a94a1994721f8bcc6352fefb5a4c216a", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277f65de19c4bb93ee56a97d4a79b68d3d53dac5/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=277f65de19c4bb93ee56a97d4a79b68d3d53dac5", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"tree.h\"\n #include \"emit-rtl.h\"  /* FIXME: Can go away once crtl is moved to rtl.h.  */\n+#include \"addresses.h\"\n \n /* Forward declarations */\n static void set_of_1 (rtx, const_rtx, void *);\n@@ -5438,3 +5439,371 @@ split_double (rtx value, rtx *first, rtx *second)\n     }\n }\n \n+/* Strip outer address \"mutations\" from LOC and return a pointer to the\n+   inner value.  If OUTER_CODE is nonnull, store the code of the innermost\n+   stripped expression there.\n+\n+   \"Mutations\" either convert between modes or apply some kind of\n+   alignment.  */\n+\n+rtx *\n+strip_address_mutations (rtx *loc, enum rtx_code *outer_code)\n+{\n+  for (;;)\n+    {\n+      enum rtx_code code = GET_CODE (*loc);\n+      if (GET_RTX_CLASS (code) == RTX_UNARY)\n+\t/* Things like SIGN_EXTEND, ZERO_EXTEND and TRUNCATE can be\n+\t   used to convert between pointer sizes.  */\n+\tloc = &XEXP (*loc, 0);\n+      else if (code == AND && CONST_INT_P (XEXP (*loc, 1)))\n+\t/* (and ... (const_int -X)) is used to align to X bytes.  */\n+\tloc = &XEXP (*loc, 0);\n+      else\n+\treturn loc;\n+      if (outer_code)\n+\t*outer_code = code;\n+    }\n+}\n+\n+/* Return true if X must be a base rather than an index.  */\n+\n+static bool\n+must_be_base_p (rtx x)\n+{\n+  return GET_CODE (x) == LO_SUM;\n+}\n+\n+/* Return true if X must be an index rather than a base.  */\n+\n+static bool\n+must_be_index_p (rtx x)\n+{\n+  return GET_CODE (x) == MULT || GET_CODE (x) == ASHIFT;\n+}\n+\n+/* Set the segment part of address INFO to LOC, given that INNER is the\n+   unmutated value.  */\n+\n+static void\n+set_address_segment (struct address_info *info, rtx *loc, rtx *inner)\n+{\n+  gcc_checking_assert (GET_CODE (*inner) == UNSPEC);\n+\n+  gcc_assert (!info->segment);\n+  info->segment = loc;\n+  info->segment_term = inner;\n+}\n+\n+/* Set the base part of address INFO to LOC, given that INNER is the\n+   unmutated value.  */\n+\n+static void\n+set_address_base (struct address_info *info, rtx *loc, rtx *inner)\n+{\n+  if (GET_CODE (*inner) == LO_SUM)\n+    inner = strip_address_mutations (&XEXP (*inner, 0));\n+  gcc_checking_assert (REG_P (*inner)\n+\t\t       || MEM_P (*inner)\n+\t\t       || GET_CODE (*inner) == SUBREG);\n+\n+  gcc_assert (!info->base);\n+  info->base = loc;\n+  info->base_term = inner;\n+}\n+\n+/* Set the index part of address INFO to LOC, given that INNER is the\n+   unmutated value.  */\n+\n+static void\n+set_address_index (struct address_info *info, rtx *loc, rtx *inner)\n+{\n+  if ((GET_CODE (*inner) == MULT || GET_CODE (*inner) == ASHIFT)\n+      && CONSTANT_P (XEXP (*inner, 1)))\n+    inner = strip_address_mutations (&XEXP (*inner, 0));\n+  gcc_checking_assert (REG_P (*inner)\n+\t\t       || MEM_P (*inner)\n+\t\t       || GET_CODE (*inner) == SUBREG);\n+\n+  gcc_assert (!info->index);\n+  info->index = loc;\n+  info->index_term = inner;\n+}\n+\n+/* Set the displacement part of address INFO to LOC, given that INNER\n+   is the constant term.  */\n+\n+static void\n+set_address_disp (struct address_info *info, rtx *loc, rtx *inner)\n+{\n+  gcc_checking_assert (CONSTANT_P (*inner));\n+\n+  gcc_assert (!info->disp);\n+  info->disp = loc;\n+  info->disp_term = inner;\n+}\n+\n+/* INFO->INNER describes a {PRE,POST}_{INC,DEC} address.  Set up the\n+   rest of INFO accordingly.  */\n+\n+static void\n+decompose_incdec_address (struct address_info *info)\n+{\n+  info->autoinc_p = true;\n+\n+  rtx *base = &XEXP (*info->inner, 0);\n+  set_address_base (info, base, base);\n+  gcc_checking_assert (info->base == info->base_term);\n+\n+  /* These addresses are only valid when the size of the addressed\n+     value is known.  */\n+  gcc_checking_assert (info->mode != VOIDmode);\n+}\n+\n+/* INFO->INNER describes a {PRE,POST}_MODIFY address.  Set up the rest\n+   of INFO accordingly.  */\n+\n+static void\n+decompose_automod_address (struct address_info *info)\n+{\n+  info->autoinc_p = true;\n+\n+  rtx *base = &XEXP (*info->inner, 0);\n+  set_address_base (info, base, base);\n+  gcc_checking_assert (info->base == info->base_term);\n+\n+  rtx plus = XEXP (*info->inner, 1);\n+  gcc_assert (GET_CODE (plus) == PLUS);\n+\n+  info->base_term2 = &XEXP (plus, 0);\n+  gcc_checking_assert (rtx_equal_p (*info->base_term, *info->base_term2));\n+\n+  rtx *step = &XEXP (plus, 1);\n+  rtx *inner_step = strip_address_mutations (step);\n+  if (CONSTANT_P (*inner_step))\n+    set_address_disp (info, step, inner_step);\n+  else\n+    set_address_index (info, step, inner_step);\n+}\n+\n+/* Treat *LOC as a tree of PLUS operands and store pointers to the summed\n+   values in [PTR, END).  Return a pointer to the end of the used array.  */\n+\n+static rtx **\n+extract_plus_operands (rtx *loc, rtx **ptr, rtx **end)\n+{\n+  rtx x = *loc;\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      ptr = extract_plus_operands (&XEXP (x, 0), ptr, end);\n+      ptr = extract_plus_operands (&XEXP (x, 1), ptr, end);\n+    }\n+  else\n+    {\n+      gcc_assert (ptr != end);\n+      *ptr++ = loc;\n+    }\n+  return ptr;\n+}\n+\n+/* Evaluate the likelihood of X being a base or index value, returning\n+   positive if it is likely to be a base, negative if it is likely to be\n+   an index, and 0 if we can't tell.  Make the magnitude of the return\n+   value reflect the amount of confidence we have in the answer.\n+\n+   MODE, AS, OUTER_CODE and INDEX_CODE are as for ok_for_base_p_1.  */\n+\n+static int\n+baseness (rtx x, enum machine_mode mode, addr_space_t as,\n+\t  enum rtx_code outer_code, enum rtx_code index_code)\n+{\n+  /* See whether we can be certain.  */\n+  if (must_be_base_p (x))\n+    return 3;\n+  if (must_be_index_p (x))\n+    return -3;\n+\n+  /* Believe *_POINTER unless the address shape requires otherwise.  */\n+  if (REG_P (x) && REG_POINTER (x))\n+    return 2;\n+  if (MEM_P (x) && MEM_POINTER (x))\n+    return 2;\n+\n+  if (REG_P (x) && HARD_REGISTER_P (x))\n+    {\n+      /* X is a hard register.  If it only fits one of the base\n+\t or index classes, choose that interpretation.  */\n+      int regno = REGNO (x);\n+      bool base_p = ok_for_base_p_1 (regno, mode, as, outer_code, index_code);\n+      bool index_p = REGNO_OK_FOR_INDEX_P (regno);\n+      if (base_p != index_p)\n+\treturn base_p ? 1 : -1;\n+    }\n+  return 0;\n+}\n+\n+/* INFO->INNER describes a normal, non-automodified address.\n+   Fill in the rest of INFO accordingly.  */\n+\n+static void\n+decompose_normal_address (struct address_info *info)\n+{\n+  /* Treat the address as the sum of up to four values.  */\n+  rtx *ops[4];\n+  size_t n_ops = extract_plus_operands (info->inner, ops,\n+\t\t\t\t\tops + ARRAY_SIZE (ops)) - ops;\n+\n+  /* If there is more than one component, any base component is in a PLUS.  */\n+  if (n_ops > 1)\n+    info->base_outer_code = PLUS;\n+\n+  /* Separate the parts that contain a REG or MEM from those that don't.\n+     Record the latter in INFO and leave the former in OPS.  */\n+  rtx *inner_ops[4];\n+  size_t out = 0;\n+  for (size_t in = 0; in < n_ops; ++in)\n+    {\n+      rtx *loc = ops[in];\n+      rtx *inner = strip_address_mutations (loc);\n+      if (CONSTANT_P (*inner))\n+\tset_address_disp (info, loc, inner);\n+      else if (GET_CODE (*inner) == UNSPEC)\n+\tset_address_segment (info, loc, inner);\n+      else\n+\t{\n+\t  ops[out] = loc;\n+\t  inner_ops[out] = inner;\n+\t  ++out;\n+\t}\n+    }\n+\n+  /* Classify the remaining OPS members as bases and indexes.  */\n+  if (out == 1)\n+    {\n+      /* Assume that the remaining value is a base unless the shape\n+\t requires otherwise.  */\n+      if (!must_be_index_p (*inner_ops[0]))\n+\tset_address_base (info, ops[0], inner_ops[0]);\n+      else\n+\tset_address_index (info, ops[0], inner_ops[0]);\n+    }\n+  else if (out == 2)\n+    {\n+      /* In the event of a tie, assume the base comes first.  */\n+      if (baseness (*inner_ops[0], info->mode, info->as, PLUS,\n+\t\t    GET_CODE (*ops[1]))\n+\t  >= baseness (*inner_ops[1], info->mode, info->as, PLUS,\n+\t\t       GET_CODE (*ops[0])))\n+\t{\n+\t  set_address_base (info, ops[0], inner_ops[0]);\n+\t  set_address_index (info, ops[1], inner_ops[1]);\n+\t}\n+      else\n+\t{\n+\t  set_address_base (info, ops[1], inner_ops[1]);\n+\t  set_address_index (info, ops[0], inner_ops[0]);\n+\t}\n+    }\n+  else\n+    gcc_assert (out == 0);\n+}\n+\n+/* Describe address *LOC in *INFO.  MODE is the mode of the addressed value,\n+   or VOIDmode if not known.  AS is the address space associated with LOC.\n+   OUTER_CODE is MEM if *LOC is a MEM address and ADDRESS otherwise.  */\n+\n+void\n+decompose_address (struct address_info *info, rtx *loc, enum machine_mode mode,\n+\t\t   addr_space_t as, enum rtx_code outer_code)\n+{\n+  memset (info, 0, sizeof (*info));\n+  info->mode = mode;\n+  info->as = as;\n+  info->addr_outer_code = outer_code;\n+  info->outer = loc;\n+  info->inner = strip_address_mutations (loc, &outer_code);\n+  info->base_outer_code = outer_code;\n+  switch (GET_CODE (*info->inner))\n+    {\n+    case PRE_DEC:\n+    case PRE_INC:\n+    case POST_DEC:\n+    case POST_INC:\n+      decompose_incdec_address (info);\n+      break;\n+\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      decompose_automod_address (info);\n+      break;\n+\n+    default:\n+      decompose_normal_address (info);\n+      break;\n+    }\n+}\n+\n+/* Describe address operand LOC in INFO.  */\n+\n+void\n+decompose_lea_address (struct address_info *info, rtx *loc)\n+{\n+  decompose_address (info, loc, VOIDmode, ADDR_SPACE_GENERIC, ADDRESS);\n+}\n+\n+/* Describe the address of MEM X in INFO.  */\n+\n+void\n+decompose_mem_address (struct address_info *info, rtx x)\n+{\n+  gcc_assert (MEM_P (x));\n+  decompose_address (info, &XEXP (x, 0), GET_MODE (x),\n+\t\t     MEM_ADDR_SPACE (x), MEM);\n+}\n+\n+/* Update INFO after a change to the address it describes.  */\n+\n+void\n+update_address (struct address_info *info)\n+{\n+  decompose_address (info, info->outer, info->mode, info->as,\n+\t\t     info->addr_outer_code);\n+}\n+\n+/* Return the scale applied to *INFO->INDEX_TERM, or 0 if the index is\n+   more complicated than that.  */\n+\n+HOST_WIDE_INT\n+get_index_scale (const struct address_info *info)\n+{\n+  rtx index = *info->index;\n+  if (GET_CODE (index) == MULT\n+      && CONST_INT_P (XEXP (index, 1))\n+      && info->index_term == &XEXP (index, 0))\n+    return INTVAL (XEXP (index, 1));\n+\n+  if (GET_CODE (index) == ASHIFT\n+      && CONST_INT_P (XEXP (index, 1))\n+      && info->index_term == &XEXP (index, 0))\n+    return (HOST_WIDE_INT) 1 << INTVAL (XEXP (index, 1));\n+\n+  if (info->index == info->index_term)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return the \"index code\" of INFO, in the form required by\n+   ok_for_base_p_1.  */\n+\n+enum rtx_code\n+get_index_code (const struct address_info *info)\n+{\n+  if (info->index)\n+    return GET_CODE (*info->index);\n+\n+  if (info->disp)\n+    return GET_CODE (*info->disp);\n+\n+  return SCRATCH;\n+}"}]}