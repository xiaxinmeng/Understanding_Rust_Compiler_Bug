{"sha": "e2839e47894f0b4917ddbd59013071e98f525336", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI4MzllNDc4OTRmMGI0OTE3ZGRiZDU5MDEzMDcxZTk4ZjUyNTMzNg==", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2019-07-08T14:40:48Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@gcc.gnu.org", "date": "2019-07-08T14:40:48Z"}, "message": "S/390: Rework shift count handling.\n\nAdd s390_valid_shift_count to determine the validity of a\nshift-count operand.  This is used to replace increasingly\ncomplex substitutions that should have allowed address-style\nshift-count handling, an and mask as well as no-op subregs\non the operand.\n\ngcc/ChangeLog:\n\n2019-07-08  Robin Dapp  <rdapp@linux.ibm.com>\n\n        * config/s390/constraints.md: Add new jsc constraint.\n        * config/s390/predicates.md: New predicates.\n        * config/s390/s390-protos.h (s390_valid_shift_count): New function.\n        * config/s390/s390.c (s390_valid_shift_count): New function.\n        (print_shift_count_operand): Use s390_valid_shift_count.\n        (print_operand): Likewise.\n        * config/s390/s390.md: Use new predicate.\n        * config/s390/subst.md: Remove addr_style_op and masked_op substs.\n        * config/s390/vector.md: Use new predicate.\n\n2019-07-08  Robin Dapp  <rdapp@linux.ibm.com>\n\n        * gcc.target/s390/combine-rotate-modulo.c: New test.\n        * gcc.target/s390/combine-shift-rotate-add-mod.c: New test.\n        * gcc.target/s390/vector/combine-shift-vec.c: New test.\n\nFrom-SVN: r273236", "tree": {"sha": "5f0d0cb4e462dfba33273ddc206a817fadcb9e68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f0d0cb4e462dfba33273ddc206a817fadcb9e68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2839e47894f0b4917ddbd59013071e98f525336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2839e47894f0b4917ddbd59013071e98f525336", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2839e47894f0b4917ddbd59013071e98f525336", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2839e47894f0b4917ddbd59013071e98f525336/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f069f0f20fb7a8467cb0dd6f01575e9c56aa8bc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f069f0f20fb7a8467cb0dd6f01575e9c56aa8bc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f069f0f20fb7a8467cb0dd6f01575e9c56aa8bc2"}], "stats": {"total": 427, "additions": 328, "deletions": 99}, "files": [{"sha": "c4f0503365a88c010a89f01822ff783927839971", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -1,3 +1,15 @@\n+2019-07-08  Robin Dapp  <rdapp@linux.ibm.com>\n+\n+\t* config/s390/constraints.md: Add new jsc constraint.\n+\t* config/s390/predicates.md: New predicates.\n+\t* config/s390/s390-protos.h (s390_valid_shift_count): New function.\n+\t* config/s390/s390.c (s390_valid_shift_count): New function.\n+\t(print_shift_count_operand): Use s390_valid_shift_count.\n+\t(print_operand): Likewise.\n+\t* config/s390/s390.md: Use new predicate.\n+\t* config/s390/subst.md: Remove addr_style_op and masked_op substs.\n+\t* config/s390/vector.md: Use new predicate.\n+\n 2019-07-08  Joern Rennecke  <joern.rennecke@riscy-ip.com>\n \n \tAvoid clash with system header declaration."}, {"sha": "45d41ae8bf8190b7dc6489570f9638eaa309ea12", "filename": "gcc/config/s390/constraints.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fconstraints.md?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -204,6 +204,18 @@\n   (match_test \"s390_decompose_addrstyle_without_index (op, NULL, NULL)\"  ))\n \n \n+;; Shift count operands are not necessarily legitimate addresses\n+;; but the predicate shift_count_operand will only allow\n+;; proper operands.  If reload/lra need to change e.g. a spilled register\n+;; they can still do so via the special handling of address constraints.\n+;; To avoid further reloading (caused by a non-matching constraint) we\n+;; always return true here as the predicate's checks are already sufficient.\n+\n+(define_address_constraint \"jsc\"\n+  \"Address style operand used as shift count.\"\n+  (match_test \"true\" ))\n+\n+\n ;;    N -- Multiple letter constraint followed by 4 parameter letters.\n ;;         0..9,x:  number of the part counting from most to least significant\n ;;         S,H,Q:   mode of the part"}, {"sha": "4d2f8b25d836a3d6f504457e972367fecfae7bae", "filename": "gcc/config/s390/predicates.md", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fpredicates.md?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -556,3 +556,32 @@\n {\n   return memory_operand (op, mode) && !contains_symbol_ref_p (op);\n })\n+\n+;; Check for a valid shift count operand with an implicit\n+;; shift truncation mask of 63.\n+\n+(define_predicate \"shift_count_operand\"\n+ (and (match_code \"reg, subreg, and, plus, const_int\")\n+  (match_test \"CONST_INT_P (op) || GET_MODE (op) == E_QImode\"))\n+{\n+  return s390_valid_shift_count (op, 63);\n+}\n+)\n+\n+;; This is used as operand predicate.  As we do not know\n+;; the mode of the first operand here and the shift truncation\n+;; mask depends on the mode, we cannot check the mask.\n+;; This is supposed to happen in the insn condition which\n+;; calls s390_valid_shift_count with the proper mode size.\n+;; We need two separate predicates for non-vector and vector\n+;; shifts since the (less restrictive) insn condition is checked\n+;; after the more restrictive operand predicate which will\n+;; disallow the operand before we can check the condition.\n+\n+(define_predicate \"shift_count_operand_vec\"\n+ (and (match_code \"reg, subreg, and, plus, const_int\")\n+  (match_test \"CONST_INT_P (op) || GET_MODE (op) == E_QImode\"))\n+{\n+  return s390_valid_shift_count (op, 0);\n+}\n+)"}, {"sha": "ae70b2fee18aaebca69818cac886bd7cee240462", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -141,6 +141,7 @@ extern void s390_emit_tpf_eh_return (rtx);\n extern bool s390_legitimate_address_without_index_p (rtx);\n extern bool s390_decompose_addrstyle_without_index (rtx, rtx *,\n \t\t\t\t\t\t    HOST_WIDE_INT *);\n+extern bool s390_valid_shift_count (rtx op, HOST_WIDE_INT required_mask = 63);\n extern int s390_branch_condition_mask (rtx);\n extern int s390_compare_and_branch_condition_mask (rtx);\n extern bool s390_extzv_shift_ok (int, int, unsigned HOST_WIDE_INT);"}, {"sha": "324d9d2321023e2e61fead4765bc5ea38ef7536e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -3131,6 +3131,49 @@ s390_decompose_addrstyle_without_index (rtx op, rtx *base,\n    return true;\n }\n \n+/*  Check that OP is a valid shift count operand.\n+    It should be of the following structure:\n+      (subreg (and (plus (reg imm_op)) 2^k-1) 7)\n+    where subreg, and and plus are optional.\n+\n+    If IMPLICIT_MASK is > 0 and OP contains and\n+      (AND ... immediate)\n+    it is checked whether IMPLICIT_MASK and the immediate match.\n+    Otherwise, no checking is performed.\n+  */\n+bool\n+s390_valid_shift_count (rtx op, HOST_WIDE_INT implicit_mask)\n+{\n+  /* Strip subreg.  */\n+  while (GET_CODE (op) == SUBREG && subreg_lowpart_p (op))\n+    op = XEXP (op, 0);\n+\n+  /* Check for an and with proper constant.  */\n+  if (GET_CODE (op) == AND)\n+  {\n+    rtx op1 = XEXP (op, 0);\n+    rtx imm = XEXP (op, 1);\n+\n+    if (GET_CODE (op1) == SUBREG && subreg_lowpart_p (op1))\n+      op1 = XEXP (op1, 0);\n+\n+    if (!(register_operand (op1, GET_MODE (op1)) || GET_CODE (op1) == PLUS))\n+      return false;\n+\n+    if (!immediate_operand (imm, GET_MODE (imm)))\n+      return false;\n+\n+    HOST_WIDE_INT val = INTVAL (imm);\n+    if (implicit_mask > 0\n+\t&& (val & implicit_mask) != implicit_mask)\n+      return false;\n+\n+    op = op1;\n+  }\n+\n+  /* Check the rest.  */\n+  return s390_decompose_addrstyle_without_index (op, NULL, NULL);\n+}\n \n /* Return true if CODE is a valid address without index.  */\n \n@@ -7448,6 +7491,27 @@ print_addrstyle_operand (FILE *file, rtx op)\n     fprintf (file, \"(%s)\", reg_names[REGNO (base)]);\n }\n \n+/* Print the shift count operand OP to FILE.\n+   OP is an address-style operand in a form which\n+   s390_valid_shift_count permits.  Subregs and no-op\n+   and-masking of the operand are stripped.  */\n+\n+static void\n+print_shift_count_operand (FILE *file, rtx op)\n+{\n+  /* No checking of the and mask required here.  */\n+  if (!s390_valid_shift_count (op, 0))\n+    gcc_unreachable ();\n+\n+  while (op && GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) == AND)\n+    op = XEXP (op, 0);\n+\n+  print_addrstyle_operand (file, op);\n+}\n+\n /* Assigns the number of NOP halfwords to be emitted before and after the\n    function label to *HW_BEFORE and *HW_AFTER.  Both pointers must not be NULL.\n    If hotpatching is disabled for the function, the values are set to zero.\n@@ -7912,7 +7976,7 @@ print_operand (FILE *file, rtx x, int code)\n       break;\n \n     case 'Y':\n-      print_addrstyle_operand (file, x);\n+      print_shift_count_operand (file, x);\n       return;\n     }\n "}, {"sha": "94a7340401d982f01789e1c31fa6b34c82d5531d", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -8937,17 +8937,17 @@\n (define_expand \"rotl<mode>3\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"\")\n         (rotate:GPR (match_operand:GPR 1 \"register_operand\" \"\")\n-\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+\t\t    (match_operand:QI 2 \"shift_count_operand\" \"\")))]\n   \"\"\n   \"\")\n \n ; rll, rllg\n-(define_insn \"*rotl<mode>3<addr_style_op><masked_op>\"\n+(define_insn \"*rotl<mode>3\"\n   [(set (match_operand:GPR             0 \"register_operand\"  \"=d\")\n \t(rotate:GPR (match_operand:GPR 1 \"register_operand\"   \"d\")\n-\t\t    (match_operand:SI  2 \"nonmemory_operand\" \"an\")))]\n+\t\t    (match_operand:QI  2 \"shift_count_operand\" \"jsc\")))]\n   \"\"\n-  \"rll<g>\\t%0,%1,<addr_style_op_ops>\"\n+  \"rll<g>\\t%0,%1,%Y2\"\n   [(set_attr \"op_type\"  \"RSE\")\n    (set_attr \"atype\"    \"reg\")\n    (set_attr \"z10prop\"  \"z10_super_E1\")])\n@@ -8964,38 +8964,39 @@\n (define_expand \"<shift><mode>3\"\n   [(set (match_operand:DSI 0 \"register_operand\" \"\")\n         (SHIFT:DSI (match_operand:DSI 1 \"register_operand\" \"\")\n-                   (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+                   (match_operand:QI 2 \"shift_count_operand\" \"\")))]\n   \"\"\n   \"\")\n \n ; ESA 64 bit register pair shift with reg or imm shift count\n ; sldl, srdl\n-(define_insn \"*<shift>di3_31<addr_style_op><masked_op>\"\n+(define_insn \"*<shift>di3_31\"\n   [(set (match_operand:DI 0 \"register_operand\"            \"=d\")\n         (SHIFT:DI (match_operand:DI 1 \"register_operand\"   \"0\")\n-                  (match_operand:SI 2 \"nonmemory_operand\" \"an\")))]\n+                  (match_operand:QI 2 \"shift_count_operand\" \"jsc\")))]\n   \"!TARGET_ZARCH\"\n-  \"s<lr>dl\\t%0,<addr_style_op_ops>\"\n+  \"s<lr>dl\\t%0,%Y2\"\n   [(set_attr \"op_type\"  \"RS\")\n    (set_attr \"atype\"    \"reg\")\n    (set_attr \"z196prop\" \"z196_cracked\")])\n \n \n ; 64 bit register shift with reg or imm shift count\n ; sll, srl, sllg, srlg, sllk, srlk\n-(define_insn \"*<shift><mode>3<addr_style_op><masked_op>\"\n+(define_insn \"*<shift><mode>3\"\n   [(set (match_operand:GPR 0 \"register_operand\"              \"=d, d\")\n         (SHIFT:GPR (match_operand:GPR 1 \"register_operand\" \"<d0>, d\")\n-                   (match_operand:SI 2 \"nonmemory_operand\"   \"an,an\")))]\n+                   (match_operand:QI 2 \"shift_count_operand\"   \"jsc,jsc\")))]\n   \"\"\n   \"@\n-   s<lr>l<g>\\t%0,<1><addr_style_op_ops>\n-   s<lr>l<gk>\\t%0,%1,<addr_style_op_ops>\"\n+   s<lr>l<g>\\t%0,<1>%Y2\n+   s<lr>l<gk>\\t%0,%1,%Y2\"\n   [(set_attr \"op_type\"  \"RS<E>,RSY\")\n    (set_attr \"atype\"    \"reg,reg\")\n    (set_attr \"cpu_facility\" \"*,z196\")\n    (set_attr \"z10prop\"  \"z10_super_E1,*\")])\n \n+\n ;\n ; ashr(di|si)3 instruction pattern(s).\n ; Arithmetic right shifts\n@@ -9004,7 +9005,7 @@\n   [(parallel\n     [(set (match_operand:DSI 0 \"register_operand\" \"\")\n           (ashiftrt:DSI (match_operand:DSI 1 \"register_operand\" \"\")\n-                        (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+                        (match_operand:QI 2 \"shift_count_operand\" \"\")))\n      (clobber (reg:CC CC_REGNUM))])]\n   \"\"\n   \"\")\n@@ -9013,29 +9014,29 @@\n ; number of 2 in the subst pattern for the (clobber (match_scratch...\n ; The right fix should be to support match_scratch in the output\n ; pattern of a define_subst.\n-(define_insn \"*ashrdi3_31<addr_style_op_cc><masked_op_cc><setcc><cconly>\"\n+(define_insn \"*ashrdi3_31<setcc><cconly>\"\n   [(set (match_operand:DI 0 \"register_operand\"               \"=d, d\")\n         (ashiftrt:DI (match_operand:DI 1 \"register_operand\"   \"0, 0\")\n-                     (match_operand:SI 2 \"nonmemory_operand\" \"an,an\")))\n+                     (match_operand:QI 2 \"shift_count_operand\" \"jsc,jsc\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"!TARGET_ZARCH\"\n   \"@\n-   srda\\t%0,<addr_style_op_cc_ops>\n-   srda\\t%0,<addr_style_op_cc_ops>\"\n+   srda\\t%0,%Y2\n+   srda\\t%0,%Y2\"\n   [(set_attr \"op_type\" \"RS\")\n    (set_attr \"atype\"   \"reg\")])\n \n \n ; sra, srag\n-(define_insn \"*ashr<mode>3<addr_style_op_cc><masked_op_cc><setcc><cconly>\"\n+(define_insn \"*ashr<mode>3<setcc><cconly>\"\n   [(set (match_operand:GPR 0 \"register_operand\"                 \"=d, d\")\n         (ashiftrt:GPR (match_operand:GPR 1 \"register_operand\" \"<d0>, d\")\n-                      (match_operand:SI 2 \"nonmemory_operand\"   \"an,an\")))\n+                      (match_operand:QI 2 \"shift_count_operand\"   \"jsc,jsc\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n-   sra<g>\\t%0,<1><addr_style_op_cc_ops>\n-   sra<gk>\\t%0,%1,<addr_style_op_cc_ops>\"\n+   sra<g>\\t%0,<1>%Y2\n+   sra<gk>\\t%0,%1,%Y2\"\n   [(set_attr \"op_type\"  \"RS<E>,RSY\")\n    (set_attr \"atype\"    \"reg\")\n    (set_attr \"cpu_facility\" \"*,z196\")"}, {"sha": "9c0c87a13bea3720a7ee1237acab067d00a3db8d", "filename": "gcc/config/s390/subst.md", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fsubst.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fsubst.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fsubst.md?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -22,78 +22,6 @@\n (define_code_iterator SUBST [rotate ashift lshiftrt ashiftrt])\n (define_mode_iterator DSI_VI [SI DI V2QI V4QI V8QI V16QI V2HI V4HI V8HI V2SI V4SI V2DI])\n \n-; This expands an register/immediate operand to a register+immediate\n-; operand to draw advantage of the address style operand format\n-; providing a addition for free.\n-(define_subst \"addr_style_op_subst\"\n-  [(set (match_operand:DSI_VI 0 \"\" \"\")\n-        (SUBST:DSI_VI (match_operand:DSI_VI 1 \"\" \"\")\n-\t\t      (match_operand:SI 2 \"\" \"\")))]\n-  \"\"\n-  [(set (match_dup 0)\n-        (SUBST:DSI_VI (match_dup 1)\n-\t\t      (plus:SI (match_operand:SI 2 \"register_operand\" \"a\")\n-\t\t\t       (match_operand 3 \"const_int_operand\"   \"n\"))))])\n-\n-; Use this in the insn name.\n-(define_subst_attr \"addr_style_op\"     \"addr_style_op_subst\" \"\" \"_plus\")\n-\n-; In the subst pattern the additional const int operand will be used\n-; as displacement.  In the normal version %Y is able to print the\n-; operand either as displacement or as base register.\n-(define_subst_attr \"addr_style_op_ops\" \"addr_style_op_subst\" \"%Y2\" \"%Y3(%2)\")\n-\n-\n-; This substitution adds an explicit AND operation to the second\n-; operand.  This way previous operations on the now masked out bits\n-; might get optimized away.\n-(define_subst \"masked_op_subst\"\n-  [(set (match_operand:DSI 0 \"\"           \"\")\n-        (SUBST:DSI (match_operand:DSI 1 \"\" \"\")\n-\t\t   (match_operand:SI  2 \"\" \"\")))]\n-  \"\"\n-  [(set (match_dup 0)\n-        (SUBST:DSI (match_dup 1)\n-\t\t   (and:SI (match_dup 2)\n-\t\t\t   (match_operand:SI 3 \"const_int_6bitset_operand\" \"jm6\"))))])\n-\n-; Use this in the insn name.\n-(define_subst_attr \"masked_op\" \"masked_op_subst\" \"\" \"_and\")\n-\n-\n-\n-; This is like the addr_style_op substitution above but with a CC clobber.\n-(define_subst \"addr_style_op_cc_subst\"\n-  [(set (match_operand:DSI 0 \"\"           \"\")\n-        (ashiftrt:DSI (match_operand:DSI 1 \"\" \"\")\n-\t\t      (match_operand:SI 2 \"\" \"\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"REG_P (operands[2])\"\n-  [(set (match_dup 0)\n-        (ashiftrt:DSI (match_dup 1)\n-\t\t      (plus:SI (match_dup 2)\n-\t\t\t       (match_operand 3 \"const_int_operand\" \"n\"))))\n-   (clobber (reg:CC CC_REGNUM))])\n-\n-(define_subst_attr \"addr_style_op_cc\"     \"addr_style_op_cc_subst\" \"\" \"_plus\")\n-(define_subst_attr \"addr_style_op_cc_ops\" \"addr_style_op_cc_subst\" \"%Y2\" \"%Y3(%2)\")\n-\n-\n-; This is like the masked_op substitution but with a CC clobber.\n-(define_subst \"masked_op_cc_subst\"\n-  [(set (match_operand:DSI 0 \"\"           \"\")\n-        (ashiftrt:DSI (match_operand:DSI 1 \"\" \"\")\n-\t\t      (match_operand:SI  2 \"\" \"\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  [(set (match_dup 0)\n-        (ashiftrt:DSI (match_dup 1)\n-\t\t      (and:SI (match_dup 2)\n-\t\t\t      (match_operand:SI 3 \"const_int_6bitset_operand\" \"\"))))\n-   (clobber (reg:CC CC_REGNUM))])\n-(define_subst_attr \"masked_op_cc\" \"masked_op_cc_subst\" \"\" \"_and\")\n-\n-\n ; This adds an explicit CC reg set to an operation while keeping the\n ; set for the operation result as well.\n (define_subst \"setcc_subst\""}, {"sha": "0702e1de83524661691f12bc0be5d8eb588606d9", "filename": "gcc/config/s390/vector.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Fconfig%2Fs390%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvector.md?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -969,21 +969,25 @@\n (define_expand \"<vec_shifts_name><mode>3\"\n   [(set (match_operand:VI 0 \"register_operand\" \"\")\n \t(VEC_SHIFTS:VI (match_operand:VI 1 \"register_operand\" \"\")\n-\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+\t\t       (match_operand:QI 2 \"shift_count_operand\" \"\")))]\n   \"TARGET_VX\")\n \n ; verllb, verllh, verllf, verllg\n ; veslb,  veslh,  veslf,  veslg\n ; vesrab, vesrah, vesraf, vesrag\n ; vesrlb, vesrlh, vesrlf, vesrlg\n-(define_insn \"*<vec_shifts_name><mode>3<addr_style_op>\"\n+(define_insn \"*<vec_shifts_name><mode>3\"\n   [(set (match_operand:VI                0 \"register_operand\"  \"=v\")\n \t(VEC_SHIFTS:VI (match_operand:VI 1 \"register_operand\"   \"v\")\n-\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"an\")))]\n-  \"TARGET_VX\"\n-  \"<vec_shifts_mnem><bhfgq>\\t%v0,%v1,<addr_style_op_ops>\"\n+\t\t       (match_operand:QI 2 \"shift_count_operand_vec\" \"jsc\")))]\n+  \"TARGET_VX\n+  && s390_valid_shift_count (operands[2],\n+    GET_MODE_BITSIZE (GET_MODE_INNER (<MODE>mode)) - 1)\n+  \"\n+  \"<vec_shifts_mnem><bhfgq>\\t%v0,%v1,%Y2\"\n   [(set_attr \"op_type\" \"VRS\")])\n \n+\n ; Shift each element by corresponding vector element\n \n ; veslvb, veslvh, veslvf, veslvg"}, {"sha": "b1c6ea25cedf0a54bb294c851c6b3f81d7484b64", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -1,3 +1,9 @@\n+2019-07-08  Robin Dapp  <rdapp@linux.ibm.com>\n+\n+\t* gcc.target/s390/combine-rotate-modulo.c: New test.\n+\t* gcc.target/s390/combine-shift-rotate-add-mod.c: New test.\n+\t* gcc.target/s390/vector/combine-shift-vec.c: New test.\n+\n 2019-07-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91108"}, {"sha": "6cbbb552cd12da71febf9c870587cd36be027fc6", "filename": "gcc/testsuite/gcc.target/s390/combine-rotate-modulo.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fcombine-rotate-modulo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fcombine-rotate-modulo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fcombine-rotate-modulo.c?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -0,0 +1,36 @@\n+/* Check that we do not emit & 63 via risbg for rotating.  */\n+\n+/* { dg-options \"-O1 -m64\" } */\n+\n+/* { dg-final { scan-assembler-not \"risbg\" } } */\n+/* { dg-final { scan-assembler-not \"nilf\" } } */\n+\n+long shiftl (long in, unsigned long sh)\n+{\n+   sh %= 64;\n+   return (in << sh);\n+}\n+\n+unsigned long shiftll (unsigned long in, unsigned long sh)\n+{\n+   sh %= 64;\n+   return (in << sh);\n+}\n+\n+long shiftr (long in, unsigned long sh)\n+{\n+   sh %= 64;\n+   return (in >> sh);\n+}\n+\n+unsigned long shiftrl (unsigned long in, unsigned long sh)\n+{\n+   sh %= 64;\n+   return (in >> sh);\n+}\n+\n+unsigned long rotlmod (unsigned long in, unsigned long sh)\n+{\n+   sh %= 64;\n+   return (in << sh) | (in >> (64 - sh));\n+}"}, {"sha": "dc63bfa148161a75a30d19b8bb16a2bb01d4cd1c", "filename": "gcc/testsuite/gcc.target/s390/combine-shift-rotate-add-mod.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fcombine-shift-rotate-add-mod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fcombine-shift-rotate-add-mod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fcombine-shift-rotate-add-mod.c?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -0,0 +1,29 @@\n+/* Check shift via address-style displacement.  There should not be any\n+   and operations that the instructions perform implicitly anyway.*/\n+\n+/* { dg-options \"-O1 -m64\" } */\n+\n+/* { dg-final { scan-assembler-not \"risbg\\t%r.+,.*63\" } } */\n+/* { dg-final { scan-assembler \"rllg\\t%r.+,3.%r.+\" } } */\n+/* { dg-final { scan-assembler \"sllg\\t%r.+,2.%r.+\" } } */\n+\n+unsigned long rotlmodp (unsigned long in, unsigned long sh)\n+{\n+   sh = (sh + 3) % 64;\n+   return (in << sh) | (in >> (64 - sh));\n+}\n+\n+unsigned long shiftmodp (unsigned long in, unsigned long sh)\n+{\n+   sh = (sh + 2) % 64;\n+   return (in << sh);\n+}\n+\n+/* We expect a displacement of 1 here since combine simplifies\n+   modulo 255 when substituting into a QImode subreg.  */\n+/* { dg-final { scan-assembler \"sllg\\t%r.+,1.%r.+\" } } */\n+unsigned long shiftp (unsigned long in, unsigned long sh)\n+{\n+   sh = sh + 4097;\n+   return (in << sh);\n+}"}, {"sha": "1ac9496cf9f1e86879e0a7cb3e147b1e0eaaf5c4", "filename": "gcc/testsuite/gcc.target/s390/vector/combine-shift-vec.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fcombine-shift-vec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2839e47894f0b4917ddbd59013071e98f525336/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fcombine-shift-vec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fvector%2Fcombine-shift-vec.c?ref=e2839e47894f0b4917ddbd59013071e98f525336", "patch": "@@ -0,0 +1,107 @@\n+/* Check vector shift patterns.  */\n+\n+/* { dg-options \"-march=z13 -O1 -m64\" } */\n+\n+/* { dg-final { scan-assembler \"veslb\\t%v.+,%v.+,2.%r2\" } } */\n+/* { dg-final { scan-assembler \"veslh\\t%v.+,%v.+,3.%r2\" } } */\n+/* { dg-final { scan-assembler \"veslf\\t%v.+,%v.+,4.%r2\" } } */\n+/* { dg-final { scan-assembler \"veslg\\t%v.+,%v.+,5.%r2\" } } */\n+/* { dg-final { scan-assembler \"vesrab\\t%v.+,%v.+,2.%r2\" } } */\n+/* { dg-final { scan-assembler \"vesrah\\t%v.+,%v.+,3.%r2\" } } */\n+/* { dg-final { scan-assembler \"vesraf\\t%v.+,%v.+,4.%r2\" } } */\n+/* { dg-final { scan-assembler \"vesrag\\t%v.+,%v.+,5.%r2\" } } */\n+/* { dg-final { scan-assembler \"vesrlb\\t%v.+,%v.+,2.%r2\" } } */\n+/* { dg-final { scan-assembler \"vesrlh\\t%v.+,%v.+,3.%r2\" } } */\n+/* { dg-final { scan-assembler \"vesrlf\\t%v.+,%v.+,4.%r2\" } } */\n+/* { dg-final { scan-assembler \"vesrlg\\t%v.+,%v.+,5.%r2\" } } */\n+/* { dg-final { scan-assembler-not \"ahi\" } } */\n+/* { dg-final { scan-assembler-not \"nilf\" } } */\n+/* { dg-final { scan-assembler-not \"risbg\" } } */\n+\n+typedef __attribute__((vector_size(16))) signed char v16qi;\n+\n+v16qi vshiftlqi (v16qi in, unsigned int sh)\n+{\n+  sh = (sh + 2) % 8;\n+  return (in << sh);\n+}\n+\n+typedef __attribute__((vector_size(16))) signed short v8hi;\n+\n+v8hi vshiftlhi (v8hi in, unsigned int sh)\n+{\n+  sh = (sh + 3) % 16;\n+  return (in << sh);\n+}\n+\n+typedef __attribute__((vector_size(16))) signed int v4si;\n+\n+v4si vshiftlsi (v4si in, unsigned int sh)\n+{\n+  sh = (sh + 4) % 32;\n+  return (in << sh);\n+}\n+\n+typedef __attribute__((vector_size(16))) signed long v2di;\n+\n+v2di vshiftldi (v2di in, unsigned int sh)\n+{\n+  sh = (sh + 5) % 64;\n+  return (in << sh);\n+}\n+\n+typedef __attribute__((vector_size(16))) unsigned char uv16qi;\n+\n+uv16qi vshiftrqiu (uv16qi in, unsigned int sh)\n+{\n+  sh = (sh + 2) % 8;\n+  return (in >> sh);\n+}\n+\n+typedef __attribute__((vector_size(16))) unsigned short uv8hi;\n+\n+uv8hi vshiftrhiu (uv8hi in, unsigned int sh)\n+{\n+  sh = (sh + 3) % 16;\n+  return (in >> sh);\n+}\n+\n+typedef __attribute__((vector_size(16))) unsigned int uv4si;\n+\n+uv4si vshiftrsiu (uv4si in, unsigned int sh)\n+{\n+  sh = (sh + 4) % 32;\n+  return (in >> sh);\n+}\n+\n+typedef __attribute__((vector_size(16))) unsigned long uv2di;\n+\n+uv2di vshiftrdiu (uv2di in, unsigned int sh)\n+{\n+  sh = (sh + 5) % 64;\n+  return (in >> sh);\n+}\n+\n+v16qi vshiftrqi (v16qi in, unsigned int sh)\n+{\n+  sh = (sh + 2) % 8;\n+  return (in >> sh);\n+}\n+\n+v8hi vshiftrhi (v8hi in, unsigned int sh)\n+{\n+  sh = (sh + 3) % 16;\n+  return (in >> sh);\n+}\n+\n+v4si vshiftrsi (v4si in, unsigned int sh)\n+{\n+  sh = (sh + 4) % 32;\n+  return (in >> sh);\n+}\n+\n+v2di vshiftrdi (v2di in, unsigned int sh)\n+{\n+  sh = (sh + 5) % 64;\n+  return (in >> sh);\n+}"}]}