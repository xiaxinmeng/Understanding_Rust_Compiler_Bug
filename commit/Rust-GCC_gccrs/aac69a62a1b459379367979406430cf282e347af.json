{"sha": "aac69a62a1b459379367979406430cf282e347af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFjNjlhNjJhMWI0NTkzNzkzNjc5Nzk0MDY0MzBjZjI4MmUzNDdhZg==", "commit": {"author": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-04-10T16:51:44Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-04-10T16:51:44Z"}, "message": "re PR tree-optimization/80153 (ivopt generate wrong code)\n\n\tPR tree-optimization/80153\n\t* tree-affine.c (aff_combination_to_tree): Get base pointer from\n\tthe first element of pointer type aff_tree.  Build result expr in\n\taff_tree's type.\n\t(add_elt_to_tree): Convert to type unconditionally.  Remove other\n\tfold_convert calls.\n\t* tree-ssa-loop-ivopts.c (alloc_iv): Pass in consistent types.\n\t(rewrite_use_nonlinear_expr): Check invariant using iv information.\n\tgcc/testsuite\n\tPR tree-optimization/80153\n\t* gcc.c-torture/execute/pr80153.c: New.\n\nFrom-SVN: r246810", "tree": {"sha": "ce538165c098e3055e063f69c9876a34ae4441db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce538165c098e3055e063f69c9876a34ae4441db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aac69a62a1b459379367979406430cf282e347af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac69a62a1b459379367979406430cf282e347af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac69a62a1b459379367979406430cf282e347af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac69a62a1b459379367979406430cf282e347af/comments", "author": null, "committer": null, "parents": [{"sha": "78a9876f98df16eaf58aec37b207fa8cbd2c946a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a9876f98df16eaf58aec37b207fa8cbd2c946a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a9876f98df16eaf58aec37b207fa8cbd2c946a"}], "stats": {"total": 167, "additions": 107, "deletions": 60}, "files": [{"sha": "3bd0951bb62a66ca26d72b4a9dde869b693d8382", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac69a62a1b459379367979406430cf282e347af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac69a62a1b459379367979406430cf282e347af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aac69a62a1b459379367979406430cf282e347af", "patch": "@@ -1,3 +1,15 @@\n+2017-04-10  Richard Biener  <rguenther@suse.de>\n+\t    Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/80153\n+\t* tree-affine.c (aff_combination_to_tree): Get base pointer from\n+\tthe first element of pointer type aff_tree.  Build result expr in\n+\taff_tree's type.\n+\t(add_elt_to_tree): Convert to type unconditionally.  Remove other\n+\tfold_convert calls.\n+\t* tree-ssa-loop-ivopts.c (alloc_iv): Pass in consistent types.\n+\t(rewrite_use_nonlinear_expr): Check invariant using iv information.\n+\n 2017-04-10  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-structalias.c (find_func_aliases): Properly handle"}, {"sha": "1c5d5baba7e6b1316715e3d22c5926a0ed98d100", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac69a62a1b459379367979406430cf282e347af/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac69a62a1b459379367979406430cf282e347af/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aac69a62a1b459379367979406430cf282e347af", "patch": "@@ -1,3 +1,8 @@\n+2017-04-10  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/80153\n+\t* gcc.c-torture/execute/pr80153.c: New.\n+\n 2017-04-10  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/80362"}, {"sha": "3eed57828bec900e790f8379cfe5cb23f4caef5d", "filename": "gcc/testsuite/gcc.c-torture/execute/pr80153.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac69a62a1b459379367979406430cf282e347af/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr80153.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac69a62a1b459379367979406430cf282e347af/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr80153.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr80153.c?ref=aac69a62a1b459379367979406430cf282e347af", "patch": "@@ -0,0 +1,48 @@\n+/* PR tree-optimization/80153 */\n+\n+void check (int, int, int) __attribute__((noinline));\n+void check (int c, int c2, int val)\n+{\n+  if (!val) {\n+    __builtin_abort();\n+  }\n+}\n+\n+static const char *buf;\n+static int l, i;\n+\n+void _fputs(const char *str)  __attribute__((noinline));\n+void _fputs(const char *str)\n+{\n+  buf = str;\n+  i = 0;\n+  l = __builtin_strlen(buf);\n+}\n+\n+char _fgetc() __attribute__((noinline));\n+char _fgetc()\n+{\n+  char val = buf[i];\n+  i++;\n+  if (i > l)\n+    return -1;\n+  else\n+    return val;\n+}\n+\n+static const char *string = \"oops!\\n\";\n+\n+int main(void)\n+{\n+  int i;\n+  int c;\n+\n+  _fputs(string);\n+\n+  for (i = 0; i < __builtin_strlen(string); i++) {\n+    c = _fgetc();\n+    check(c, string[i], c == string[i]);\n+  }\n+\n+  return 0;\n+}"}, {"sha": "13c477dc7d6dcfebdea9c852d1266726be01250c", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 28, "deletions": 52, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac69a62a1b459379367979406430cf282e347af/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac69a62a1b459379367979406430cf282e347af/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=aac69a62a1b459379367979406430cf282e347af", "patch": "@@ -377,58 +377,28 @@ static tree\n add_elt_to_tree (tree expr, tree type, tree elt, const widest_int &scale_in)\n {\n   enum tree_code code;\n-  tree type1 = type;\n-  if (POINTER_TYPE_P (type))\n-    type1 = sizetype;\n \n   widest_int scale = wide_int_ext_for_comb (scale_in, type);\n \n-  if (scale == -1\n-      && POINTER_TYPE_P (TREE_TYPE (elt)))\n-    {\n-      elt = convert_to_ptrofftype (elt);\n-      elt = fold_build1 (NEGATE_EXPR, TREE_TYPE (elt), elt);\n-      scale = 1;\n-    }\n-\n+  elt = fold_convert (type, elt);\n   if (scale == 1)\n     {\n       if (!expr)\n-\t{\n-\t  if (POINTER_TYPE_P (TREE_TYPE (elt)))\n-\t    return elt;\n-\t  else\n-\t    return fold_convert (type1, elt);\n-\t}\n+\treturn elt;\n \n-      if (POINTER_TYPE_P (TREE_TYPE (expr)))\n-\treturn fold_build_pointer_plus (expr, elt);\n-      if (POINTER_TYPE_P (TREE_TYPE (elt)))\n-\treturn fold_build_pointer_plus (elt, expr);\n-      return fold_build2 (PLUS_EXPR, type1,\n-\t\t\t  expr, fold_convert (type1, elt));\n+      return fold_build2 (PLUS_EXPR, type, expr, elt);\n     }\n \n   if (scale == -1)\n     {\n       if (!expr)\n-\treturn fold_build1 (NEGATE_EXPR, type1,\n-\t\t\t    fold_convert (type1, elt));\n+\treturn fold_build1 (NEGATE_EXPR, type, elt);\n \n-      if (POINTER_TYPE_P (TREE_TYPE (expr)))\n-\t{\n-\t  elt = convert_to_ptrofftype (elt);\n-\t  elt = fold_build1 (NEGATE_EXPR, TREE_TYPE (elt), elt);\n-\t  return fold_build_pointer_plus (expr, elt);\n-\t}\n-      return fold_build2 (MINUS_EXPR, type1,\n-\t\t\t  expr, fold_convert (type1, elt));\n+      return fold_build2 (MINUS_EXPR, type, expr, elt);\n     }\n \n-  elt = fold_convert (type1, elt);\n   if (!expr)\n-    return fold_build2 (MULT_EXPR, type1, elt,\n-\t\t\twide_int_to_tree (type1, scale));\n+    return fold_build2 (MULT_EXPR, type, elt, wide_int_to_tree (type, scale));\n \n   if (wi::neg_p (scale))\n     {\n@@ -438,33 +408,34 @@ add_elt_to_tree (tree expr, tree type, tree elt, const widest_int &scale_in)\n   else\n     code = PLUS_EXPR;\n \n-  elt = fold_build2 (MULT_EXPR, type1, elt,\n-\t\t     wide_int_to_tree (type1, scale));\n-  if (POINTER_TYPE_P (TREE_TYPE (expr)))\n-    {\n-      if (code == MINUS_EXPR)\n-        elt = fold_build1 (NEGATE_EXPR, type1, elt);\n-      return fold_build_pointer_plus (expr, elt);\n-    }\n-  return fold_build2 (code, type1, expr, elt);\n+  elt = fold_build2 (MULT_EXPR, type, elt, wide_int_to_tree (type, scale));\n+  return fold_build2 (code, type, expr, elt);\n }\n \n /* Makes tree from the affine combination COMB.  */\n \n tree\n aff_combination_to_tree (aff_tree *comb)\n {\n-  tree type = comb->type;\n-  tree expr = NULL_TREE;\n+  tree type = comb->type, base = NULL_TREE, expr = NULL_TREE;\n   unsigned i;\n   widest_int off, sgn;\n-  tree type1 = type;\n-  if (POINTER_TYPE_P (type))\n-    type1 = sizetype;\n \n   gcc_assert (comb->n == MAX_AFF_ELTS || comb->rest == NULL_TREE);\n \n-  for (i = 0; i < comb->n; i++)\n+  i = 0;\n+  if (POINTER_TYPE_P (type))\n+    {\n+      type = sizetype;\n+      if (comb->n > 0 && comb->elts[0].coef == 1\n+\t  && POINTER_TYPE_P (TREE_TYPE (comb->elts[0].val)))\n+\t{\n+\t  base = comb->elts[0].val;\n+\t  ++i;\n+\t}\n+    }\n+\n+  for (; i < comb->n; i++)\n     expr = add_elt_to_tree (expr, type, comb->elts[i].val, comb->elts[i].coef);\n \n   if (comb->rest)\n@@ -482,7 +453,12 @@ aff_combination_to_tree (aff_tree *comb)\n       off = comb->offset;\n       sgn = 1;\n     }\n-  return add_elt_to_tree (expr, type, wide_int_to_tree (type1, off), sgn);\n+  expr = add_elt_to_tree (expr, type, wide_int_to_tree (type, off), sgn);\n+\n+  if (base)\n+    return fold_build_pointer_plus (base, expr);\n+  else\n+    return fold_convert (comb->type, expr);\n }\n \n /* Copies the tree elements of COMB to ensure that they are not shared.  */"}, {"sha": "036e04161765c8f19bc6f2c8d914ab3bd8ae0e9a", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aac69a62a1b459379367979406430cf282e347af/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aac69a62a1b459379367979406430cf282e347af/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=aac69a62a1b459379367979406430cf282e347af", "patch": "@@ -1171,7 +1171,7 @@ alloc_iv (struct ivopts_data *data, tree base, tree step,\n       || contain_complex_addr_expr (expr))\n     {\n       aff_tree comb;\n-      tree_to_aff_combination (expr, TREE_TYPE (base), &comb);\n+      tree_to_aff_combination (expr, TREE_TYPE (expr), &comb);\n       base = fold_convert (TREE_TYPE (base), aff_combination_to_tree (&comb));\n     }\n \n@@ -7183,7 +7183,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \t\t\t    struct iv_use *use, struct iv_cand *cand)\n {\n   tree comp;\n-  tree op, tgt;\n+  tree tgt;\n   gassign *ass;\n   gimple_stmt_iterator bsi;\n \n@@ -7194,6 +7194,7 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n   if (cand->pos == IP_ORIGINAL\n       && cand->incremented_at == use->stmt)\n     {\n+      tree op = NULL_TREE;\n       enum tree_code stmt_code;\n \n       gcc_assert (is_gimple_assign (use->stmt));\n@@ -7213,14 +7214,19 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n \t    op = gimple_assign_rhs2 (use->stmt);\n \t  else if (gimple_assign_rhs2 (use->stmt) == cand->var_before)\n \t    op = gimple_assign_rhs1 (use->stmt);\n-\t  else\n-\t    op = NULL_TREE;\n \t}\n-      else\n-\top = NULL_TREE;\n \n-      if (op && expr_invariant_in_loop_p (data->current_loop, op))\n-\treturn;\n+      if (op != NULL_TREE)\n+\t{\n+\t  if (expr_invariant_in_loop_p (data->current_loop, op))\n+\t    return;\n+\t  if (TREE_CODE (op) == SSA_NAME)\n+\t    {\n+\t      struct iv *iv = get_iv (data, op);\n+\t      if (iv != NULL && integer_zerop (iv->step))\n+\t\treturn;\n+\t    }\n+\t}\n     }\n \n   comp = get_computation (data->current_loop, use, cand);"}]}