{"sha": "2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjYyMmM3OWQyZDUxZjZiZjkxMjJhM2I1ZjQ1OGRhYTUwYzBiYWYxOQ==", "commit": {"author": {"name": "Rolf W. Rasmussen", "email": "rolfwr@ii.uib.no", "date": "2000-10-22T17:46:09Z"}, "committer": {"name": "Rolf Rasmussen", "email": "rolfwr@gcc.gnu.org", "date": "2000-10-22T17:46:09Z"}, "message": "Makefile.am: Added rules for libgcjx library.\n\n\t* Makefile.am: Added rules for libgcjx library.\n\t* Makefile.in: Rebuilt.\n\t* configure.in: Added check for X.\n\t* configure: Rebuilt.\n\t* gnu/awt/LightweightRedirector.java: New file.\n\t* gnu/awt/j2d/AbstractGraphicsState.java: New file.\n\t* gnu/awt/j2d/DirectRasterGraphics.java: New file.\n\t* gnu/awt/j2d/Graphics2DImpl.java: New file.\n\t* gnu/awt/j2d/IntegerGraphicsState.java: New file.\n\t* gnu/awt/j2d/MappedRaster.java: New file.\n\t* gnu/awt/xlib/XCanvasPeer.java: New file.\n\t* gnu/awt/xlib/XEventLoop.java: New file.\n\t* gnu/awt/xlib/XEventQueue.java: New file.\n\t* gnu/awt/xlib/XFontMetrics.java: New file.\n\t* gnu/awt/xlib/XFramePeer.java: New file.\n\t* gnu/awt/xlib/XGraphics.java: New file.\n\t* gnu/awt/xlib/XGraphicsConfiguration.java: New file.\n\t* gnu/awt/xlib/XPanelPeer.java: New file.\n\t* gnu/awt/xlib/XToolkit.java: New file.\n\t* gnu/gcj/xlib/Clip.java: New file.\n\t* gnu/gcj/xlib/Colormap.java: New file.\n\t* gnu/gcj/xlib/Display.java: New file.\n\t* gnu/gcj/xlib/Drawable.java: New file.\n\t* gnu/gcj/xlib/Font.java: New file.\n\t* gnu/gcj/xlib/GC.java: New file.\n\t* gnu/gcj/xlib/Pixmap.java: New file.\n\t* gnu/gcj/xlib/Screen.java: New file.\n\t* gnu/gcj/xlib/Visual.java: New file.\n\t* gnu/gcj/xlib/WMSizeHints.java: New file.\n\t* gnu/gcj/xlib/Window.java: New file.\n\t* gnu/gcj/xlib/WindowAttributes.java: New file.\n\t* gnu/gcj/xlib/XAnyEvent.java: New file.\n\t* gnu/gcj/xlib/XButtonEvent.java: New file.\n\t* gnu/gcj/xlib/XColor.java: New file.\n\t* gnu/gcj/xlib/XConfigureEvent.java: New file.\n\t* gnu/gcj/xlib/XConnectException.java: New file.\n\t* gnu/gcj/xlib/XEvent.java: New file.\n\t* gnu/gcj/xlib/XException.java: New file.\n\t* gnu/gcj/xlib/XExposeEvent.java: New file.\n\t* gnu/gcj/xlib/XID.java: New file.\n\t* gnu/gcj/xlib/XImage.java: New file.\n\t* gnu/gcj/xlib/XUnmapEvent.java: New file.\n\t* gnu/gcj/xlib/natClip.cc: New file.\n\t* gnu/gcj/xlib/natColormap.cc: New file.\n\t* gnu/gcj/xlib/natDisplay.cc: New file.\n\t* gnu/gcj/xlib/natDrawable.cc: New file.\n\t* gnu/gcj/xlib/natFont.cc: New file.\n\t* gnu/gcj/xlib/natGC.cc: New file.\n\t* gnu/gcj/xlib/natPixmap.cc: New file.\n\t* gnu/gcj/xlib/natScreen.cc: New file.\n\t* gnu/gcj/xlib/natVisual.cc: New file.\n\t* gnu/gcj/xlib/natWMSizeHints.cc: New file.\n\t* gnu/gcj/xlib/natWindow.cc: New file.\n\t* gnu/gcj/xlib/natWindowAttributes.cc: New file.\n\t* gnu/gcj/xlib/natXAnyEvent.cc: New file.\n\t* gnu/gcj/xlib/natXButtonEvent.cc: New file.\n\t* gnu/gcj/xlib/natXColor.cc: New file.\n\t* gnu/gcj/xlib/natXConfigureEvent.cc: New file.\n\t* gnu/gcj/xlib/natXException.cc: New file.\n\t* gnu/gcj/xlib/natXExposeEvent.cc: New file.\n\t* gnu/gcj/xlib/natXImage.cc: New file.\n\t* gnu/gcj/xlib/natXUnmapEvent.cc: New file.\n\t* java/awt/EventDispatchThread.java: Start thead on creation.\n\nFrom-SVN: r37005", "tree": {"sha": "1165199489e8bc851f2bb5c11ff0228f3667453e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1165199489e8bc851f2bb5c11ff0228f3667453e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/comments", "author": null, "committer": null, "parents": [{"sha": "9b95cc4a34af1148dc18c7912ab77f19a753bf80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b95cc4a34af1148dc18c7912ab77f19a753bf80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b95cc4a34af1148dc18c7912ab77f19a753bf80"}], "stats": {"total": 8502, "additions": 8192, "deletions": 310}, "files": [{"sha": "785a36ee61bc7169a6d15cc064395095f034a6ac", "filename": "libjava/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -1,3 +1,69 @@\n+2000-10-22  Rolf W. Rasmussen  <rolfwr@ii.uib.no>\n+\n+\t* Makefile.am: Added rules for libgcjx library.\n+\t* Makefile.in: Rebuilt.\n+\t* configure.in: Added check for X.\n+\t* configure: Rebuilt.\n+\t* gnu/awt/LightweightRedirector.java: New file.\n+\t* gnu/awt/j2d/AbstractGraphicsState.java: New file.\n+\t* gnu/awt/j2d/DirectRasterGraphics.java: New file.\n+\t* gnu/awt/j2d/Graphics2DImpl.java: New file.\n+\t* gnu/awt/j2d/IntegerGraphicsState.java: New file.\n+\t* gnu/awt/j2d/MappedRaster.java: New file.\n+\t* gnu/awt/xlib/XCanvasPeer.java: New file.\n+\t* gnu/awt/xlib/XEventLoop.java: New file.\n+\t* gnu/awt/xlib/XEventQueue.java: New file.\n+\t* gnu/awt/xlib/XFontMetrics.java: New file.\n+\t* gnu/awt/xlib/XFramePeer.java: New file.\n+\t* gnu/awt/xlib/XGraphics.java: New file.\n+\t* gnu/awt/xlib/XGraphicsConfiguration.java: New file.\n+\t* gnu/awt/xlib/XPanelPeer.java: New file.\n+\t* gnu/awt/xlib/XToolkit.java: New file.\n+\t* gnu/gcj/xlib/Clip.java: New file.\n+\t* gnu/gcj/xlib/Colormap.java: New file.\n+\t* gnu/gcj/xlib/Display.java: New file.\n+\t* gnu/gcj/xlib/Drawable.java: New file.\n+\t* gnu/gcj/xlib/Font.java: New file.\n+\t* gnu/gcj/xlib/GC.java: New file.\n+\t* gnu/gcj/xlib/Pixmap.java: New file.\n+\t* gnu/gcj/xlib/Screen.java: New file.\n+\t* gnu/gcj/xlib/Visual.java: New file.\n+\t* gnu/gcj/xlib/WMSizeHints.java: New file.\n+\t* gnu/gcj/xlib/Window.java: New file.\n+\t* gnu/gcj/xlib/WindowAttributes.java: New file.\n+\t* gnu/gcj/xlib/XAnyEvent.java: New file.\n+\t* gnu/gcj/xlib/XButtonEvent.java: New file.\n+\t* gnu/gcj/xlib/XColor.java: New file.\n+\t* gnu/gcj/xlib/XConfigureEvent.java: New file.\n+\t* gnu/gcj/xlib/XConnectException.java: New file.\n+\t* gnu/gcj/xlib/XEvent.java: New file.\n+\t* gnu/gcj/xlib/XException.java: New file.\n+\t* gnu/gcj/xlib/XExposeEvent.java: New file.\n+\t* gnu/gcj/xlib/XID.java: New file.\n+\t* gnu/gcj/xlib/XImage.java: New file.\n+\t* gnu/gcj/xlib/XUnmapEvent.java: New file.\n+\t* gnu/gcj/xlib/natClip.cc: New file.\n+\t* gnu/gcj/xlib/natColormap.cc: New file.\n+\t* gnu/gcj/xlib/natDisplay.cc: New file.\n+\t* gnu/gcj/xlib/natDrawable.cc: New file.\n+\t* gnu/gcj/xlib/natFont.cc: New file.\n+\t* gnu/gcj/xlib/natGC.cc: New file.\n+\t* gnu/gcj/xlib/natPixmap.cc: New file.\n+\t* gnu/gcj/xlib/natScreen.cc: New file.\n+\t* gnu/gcj/xlib/natVisual.cc: New file.\n+\t* gnu/gcj/xlib/natWMSizeHints.cc: New file.\n+\t* gnu/gcj/xlib/natWindow.cc: New file.\n+\t* gnu/gcj/xlib/natWindowAttributes.cc: New file.\n+\t* gnu/gcj/xlib/natXAnyEvent.cc: New file.\n+\t* gnu/gcj/xlib/natXButtonEvent.cc: New file.\n+\t* gnu/gcj/xlib/natXColor.cc: New file.\n+\t* gnu/gcj/xlib/natXConfigureEvent.cc: New file.\n+\t* gnu/gcj/xlib/natXException.cc: New file.\n+\t* gnu/gcj/xlib/natXExposeEvent.cc: New file.\n+\t* gnu/gcj/xlib/natXImage.cc: New file.\n+\t* gnu/gcj/xlib/natXUnmapEvent.cc: New file.\n+\t* java/awt/EventDispatchThread.java: Start thead on creation.\n+\n 2000-10-20  Tom Tromey  <tromey@cygnus.com>\n \n \tFrom Arno J. Klaassen:"}, {"sha": "d3e5a706527e86fa30f5dabd85a64b6a8c19f83d", "filename": "libjava/Makefile.am", "status": "modified", "additions": 100, "deletions": 12, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -23,7 +23,13 @@ toolexecdir = $(exec_prefix)/$(target_alias)\n toolexeclibdir = $(toolexecdir)/lib$(MULTISUBDIR)\n endif\n \n-toolexeclib_LTLIBRARIES = libgcj.la\n+if NO_X\n+cond_x_ltlibrary =\n+else\n+cond_x_ltlibrary = libgcjx.la\n+endif\n+\n+toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.zip\n \n@@ -82,7 +88,7 @@ WARNINGS = -W -Wall\n AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fasynchronous-exceptions \\\n ## Some systems don't allow `$' in identifiers by default, so we force it.\n \t-fdollars-in-identifiers \\\n-\t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ $(WARNINGS) -D_GNU_SOURCE\n+\t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n if USING_GCC\n AM_CFLAGS = @LIBGCJ_CFLAGS@ $(WARNINGS)\n else\n@@ -107,11 +113,13 @@ INCLUDES = -I$(top_srcdir) -Iinclude -I$(top_srcdir)/include \\\n \n ## Objects from C++ sources in subdirs.\n nat_files = $(nat_source_files:.cc=.lo)\n+x_nat_files = $(x_nat_source_files:.cc=.lo)\n ## Objects from C sources in subdirs.\n c_files = $(c_source_files:.c=.lo)\n ## Objects from Java sources in subdirs.\n javao_files = $(java_source_files:.java=.lo) \\\n \t$(built_java_source_files:.java=.lo)\n+x_javao_files = $(x_java_source_files:.java=.lo)\n \n ## Extract the libffi object file names.\n libffi_files = `$(AR) t ../libffi/.libs/libffi.a 2>/dev/null | sed 's/\\.o/\\.lo/g' | sed 's/^/..\\/libffi\\//g'`\n@@ -130,6 +138,15 @@ libgcj_la_LDFLAGS = -lsupc++ -rpath $(toolexeclibdir) \\\n \t-version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n libgcj_la_LINK = $(LIBLINK)\n \n+libgcjx_la_SOURCES = $(x_nat_source_files)\n+EXTRA_libgcjx_la_SOURCES = $(x_java_source_files)\n+libgcjx_la_DEPENDENCIES = libgcj.zip $(x_javao_files)\n+libgcjx_la_LIBADD = $(x_javao_files)\n+libgcjx_la_LDFLAGS = @X_PRE_LIBS@ @X_LIBS@ -lX11 @X_EXTRA_LIBS@ \\\n+        -lsupc++ -rpath $(toolexeclibdir) \\\n+## The mysterious backslash is consumed by make.\n+        -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+libgcjx_la_LINK = $(LIBLINK)\n \n ## Make the .class files depend on the .zip file.  This seems\n ## backwards, but is right.  This doesn't catch all the .class files,\n@@ -139,6 +156,11 @@ libgcj_la_LINK = $(LIBLINK)\n ## hand-maintained headers.\n $(java_source_files:.java=.class): libgcj.zip\n \n+## The .class files for X will not be included in libgcj.zip, but the\n+## rule for libgcj.zip will cause all out-of-date .class files to be\n+## built. We need this to generate headers for the nat-files.\n+$(x_java_source_files:.java=.class): libgcj.zip\n+\n ## FIXME: this isn't really correct.\n $(built_java_source_files:.java=.class): $(built_java_source_files)\n ## This little nastiness is here so that the backquoted stuff in the\n@@ -156,7 +178,7 @@ $(built_java_source_files:.java=.class): $(built_java_source_files)\n ## up-to-date, and foo.class is removed, and bar.java is touched, then\n ## `make libgcj.zip' will not rebuilt foo.class.  That's because\n ## libgcj.zip is not out-of-date with respect to foo.java.\n-libgcj.zip: $(java_source_files)\n+libgcj.zip: $(java_source_files) $(x_java_source_files)\n ## Create a list of all Java sources, without exceeding any shell limits.\n \t@: $(shell echo Creating list of files to compile...) $(shell rm -f tmp-list || :) $(shell touch tmp-list) $(foreach source,$(subst $(srcdir)/,,$?),$(shell echo $(source) >> tmp-list))\n ## FIXME: this ought to depend on built_java_source_files, but right\n@@ -171,9 +193,11 @@ libgcj.zip: $(java_source_files)\n \tdone\n \t-@rm -f tmp-list libgcj.zip\n ## Note that we explicitly want to include directory information.\n-\t$(ZIP) -r libgcj java gnu -n .class -i '*.class' -i '*/'\n+\tfind java gnu -type d -o -type f -name '*.class' | \\\n+\t  sed -e '/\\/\\./d' -e '/\\/xlib/d' | \\\n+\t  $(ZIP) libgcj -@ -n .class\n \n-MOSTLYCLEANFILES = $(javao_files) $(nat_files) $(nat_headers) $(c_files)\n+MOSTLYCLEANFILES = $(javao_files) $(nat_files) $(nat_headers) $(c_files) $(x_javao_files) $(x_nat_files) $(x_nat_headers)\n CLEANFILES = tmp-list libgcj.zip\n \n clean-local:\n@@ -192,7 +216,7 @@ SUFFIXES = .class .java .h\n ## special rule.  The standard automake rule can't be overridden (this\n ## is a bug in automake), and it also won't put the .o files into\n ## subdirs.  FIXME.\n-$(nat_files): %.lo: %.cc\n+$(nat_files) $(x_nat_files): %.lo: %.cc\n \t@echo '$(LTCXXCOMPILE) -c -o $@ $<'; \\\n \t$(LTCXXCOMPILE) -Wp,-MD,.deps/$(*F).pp -c -o $@ $<\n \t@-sed -e 's/^\\([^:]*\\)\\.o[ \t]*:/\\1.lo \\1.o :/' \\\n@@ -209,7 +233,7 @@ $(c_files): %.lo: %.c\n $(c_files): java/lang/fdlibm.h java/lang/ieeefp.h java/lang/mprec.h\n \n ## FIXME: GNU make.\n-$(javao_files): %.lo: %.java\n+$(javao_files) $(x_javao_files): %.lo: %.java\n \t$(GCJCOMPILE) -o $@ $<\n \n ## ################################################################\n@@ -228,6 +252,8 @@ nat_headers = $(ordinary_java_source_files:.java=.h) \\\n \tjava/io/ObjectOutputStream$$PutField.h \\\n \tjava/io/ObjectInputStream$$GetField.h\n \n+x_nat_headers = $(x_java_source_files:.java=.h)\n+\n java/lang/ClassLoader.h: java/lang/ClassLoader.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t\t-friend 'jclass _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader);' \\\n@@ -491,6 +517,16 @@ gnu/gcj/convert/UnicodeToBytes.java\n special_java_source_files = java/lang/Class.java java/lang/Object.java\n \n awt_java_source_files =\t\\\n+gnu/awt/LightweightRedirector.java \\\n+gnu/awt/j2d/AbstractGraphicsState.java \\\n+gnu/awt/j2d/DirectRasterGraphics.java \\\n+gnu/awt/j2d/Graphics2DImpl.java \\\n+gnu/awt/j2d/IntegerGraphicsState.java \\\n+gnu/awt/j2d/MappedRaster.java \\\n+gnu/gcj/awt/BitMaskExtent.java \\\n+gnu/gcj/awt/Buffers.java \\\n+gnu/gcj/awt/ComponentDataBlitOp.java \\\n+gnu/gcj/awt/GLightweightPeer.java \\\n gnu/java/beans/editors/ColorEditor.java\t\\\n gnu/java/beans/editors/FontEditor.java \\\n gnu/java/beans/editors/NativeBooleanEditor.java\t\\\n@@ -506,10 +542,6 @@ gnu/java/beans/BeanInfoEmbryo.java \\\n gnu/java/beans/EmptyBeanInfo.java \\\n gnu/java/beans/ExplicitBeanInfo.java \\\n gnu/java/beans/IntrospectionIncubator.java \\\n-gnu/gcj/awt/BitMaskExtent.java \\\n-gnu/gcj/awt/Buffers.java \\\n-gnu/gcj/awt/ComponentDataBlitOp.java \\\n-gnu/gcj/awt/GLightweightPeer.java \\\n java/applet/Applet.java \\\n java/applet/AppletStub.java \\\n java/applet/AppletContext.java \\\n@@ -1168,6 +1200,62 @@ java/util/natGregorianCalendar.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n \n+x_java_source_files = \\\n+gnu/gcj/xlib/Clip.java \\\n+gnu/gcj/xlib/Colormap.java \\\n+gnu/gcj/xlib/Display.java \\\n+gnu/gcj/xlib/Drawable.java \\\n+gnu/gcj/xlib/Font.java \\\n+gnu/gcj/xlib/GC.java \\\n+gnu/gcj/xlib/Pixmap.java \\\n+gnu/gcj/xlib/Screen.java \\\n+gnu/gcj/xlib/Visual.java \\\n+gnu/gcj/xlib/WMSizeHints.java \\\n+gnu/gcj/xlib/Window.java \\\n+gnu/gcj/xlib/WindowAttributes.java \\\n+gnu/gcj/xlib/XAnyEvent.java \\\n+gnu/gcj/xlib/XButtonEvent.java \\\n+gnu/gcj/xlib/XColor.java \\\n+gnu/gcj/xlib/XConfigureEvent.java \\\n+gnu/gcj/xlib/XConnectException.java \\\n+gnu/gcj/xlib/XEvent.java \\\n+gnu/gcj/xlib/XException.java \\\n+gnu/gcj/xlib/XExposeEvent.java \\\n+gnu/gcj/xlib/XID.java \\\n+gnu/gcj/xlib/XImage.java \\\n+gnu/gcj/xlib/XUnmapEvent.java \\\n+gnu/awt/xlib/XCanvasPeer.java \\\n+gnu/awt/xlib/XEventLoop.java \\\n+gnu/awt/xlib/XEventQueue.java \\\n+gnu/awt/xlib/XFontMetrics.java \\\n+gnu/awt/xlib/XFramePeer.java \\\n+gnu/awt/xlib/XGraphics.java \\\n+gnu/awt/xlib/XGraphicsConfiguration.java \\\n+gnu/awt/xlib/XPanelPeer.java \\\n+gnu/awt/xlib/XToolkit.java\n+\n+x_nat_source_files = \\\n+gnu/gcj/xlib/natClip.cc \\\n+gnu/gcj/xlib/natColormap.cc \\\n+gnu/gcj/xlib/natDisplay.cc \\\n+gnu/gcj/xlib/natDrawable.cc \\\n+gnu/gcj/xlib/natFont.cc \\\n+gnu/gcj/xlib/natGC.cc \\\n+gnu/gcj/xlib/natPixmap.cc \\\n+gnu/gcj/xlib/natScreen.cc \\\n+gnu/gcj/xlib/natVisual.cc \\\n+gnu/gcj/xlib/natWMSizeHints.cc \\\n+gnu/gcj/xlib/natWindow.cc \\\n+gnu/gcj/xlib/natWindowAttributes.cc \\\n+gnu/gcj/xlib/natXAnyEvent.cc \\\n+gnu/gcj/xlib/natXButtonEvent.cc \\\n+gnu/gcj/xlib/natXColor.cc \\\n+gnu/gcj/xlib/natXConfigureEvent.cc \\\n+gnu/gcj/xlib/natXException.cc \\\n+gnu/gcj/xlib/natXExposeEvent.cc \\\n+gnu/gcj/xlib/natXImage.cc \\\n+gnu/gcj/xlib/natXUnmapEvent.cc\n+\n ## ################################################################\n \n ##\n@@ -1182,7 +1270,7 @@ java/util/zip/natInflater.cc\n ## compile the C++ sources, but we can't make the .o files depend on\n ## the headers, because in that case we'll force a complete rebuild of\n ## the C++ code whenever any .java file is touched.\n-all-recursive: $(nat_headers)\n+all-recursive: $(nat_headers) $(x_nat_headers)\n \n ## ################################################################\n "}, {"sha": "536d29683eb171e0e89e60ef6c1e679f820f01b9", "filename": "libjava/Makefile.in", "status": "modified", "additions": 168, "deletions": 49, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -119,40 +119,29 @@ here = @here@\n libgcj_basedir = @libgcj_basedir@\n \n AUTOMAKE_OPTIONS = foreign no-installinfo\n-@TESTSUBDIR_TRUE@SUBDIRS = \\\n-@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = \\\n-@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = \\\n-@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = \\\n-@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = \\\n-@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n-\n-toolexeclib_LTLIBRARIES = libgcj.la\n+@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@NO_X_TRUE@cond_x_ltlibrary = \n+@NO_X_FALSE@cond_x_ltlibrary = @NO_X_FALSE@libgcjx.la\n+\n+toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.zip\n \n-@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.a\n-@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.c\n+@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = @NEEDS_DATA_START_TRUE@libgcjdata.a\n+@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = @NEEDS_DATA_START_TRUE@libgcjdata.c\n \n-@NATIVE_TRUE@bin_PROGRAMS = \\\n-@NATIVE_TRUE@jv-convert gij\n+@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@zip\n-@CANADIAN_FALSE@ZIP = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = \\\n-@CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@zip\n+@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/zip/zip$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n \n GCJCOMPILE = $(LIBTOOL) --mode=compile $(GCJ) -fassume-compiled -fclasspath=$(here) -L$(here) $(JC1FLAGS) -MD -MT $@ -MF $(@:.lo=.d) -c\n GCJLINK = $(LIBTOOL) --mode=link $(GCJ) -L$(here) $(JC1FLAGS) $(LDFLAGS) -o $@\n@@ -165,12 +154,10 @@ EH_COMMON_INCLUDE = @EH_COMMON_INCLUDE@\n WARNINGS = -W -Wall\n AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fasynchronous-exceptions \\\n \t-fdollars-in-identifiers \\\n-\t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ $(WARNINGS) -D_GNU_SOURCE\n+\t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n \n-@USING_GCC_TRUE@AM_CFLAGS = \\\n-@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = \\\n-@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = -g @LIBGCJ_JAVAFLAGS@\n@@ -183,10 +170,12 @@ INCLUDES = -I$(top_srcdir) -Iinclude -I$(top_srcdir)/include \\\n \n \n nat_files = $(nat_source_files:.cc=.lo)\n+x_nat_files = $(x_nat_source_files:.cc=.lo)\n c_files = $(c_source_files:.c=.lo)\n javao_files = $(java_source_files:.java=.lo) \\\n \t$(built_java_source_files:.java=.lo)\n \n+x_javao_files = $(x_java_source_files:.java=.lo)\n \n libffi_files = `$(AR) t ../libffi/.libs/libffi.a 2>/dev/null | sed 's/\\.o/\\.lo/g' | sed 's/^/..\\/libffi\\//g'`\n \n@@ -208,7 +197,17 @@ libgcj_la_LDFLAGS = -lsupc++ -rpath $(toolexeclibdir) \\\n \n libgcj_la_LINK = $(LIBLINK)\n \n-MOSTLYCLEANFILES = $(javao_files) $(nat_files) $(nat_headers) $(c_files)\n+libgcjx_la_SOURCES = $(x_nat_source_files)\n+EXTRA_libgcjx_la_SOURCES = $(x_java_source_files)\n+libgcjx_la_DEPENDENCIES = libgcj.zip $(x_javao_files)\n+libgcjx_la_LIBADD = $(x_javao_files)\n+libgcjx_la_LDFLAGS = @X_PRE_LIBS@ @X_LIBS@ -lX11 @X_EXTRA_LIBS@ \\\n+        -lsupc++ -rpath $(toolexeclibdir) \\\n+        -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+\n+libgcjx_la_LINK = $(LIBLINK)\n+\n+MOSTLYCLEANFILES = $(javao_files) $(nat_files) $(nat_headers) $(c_files) $(x_javao_files) $(x_nat_files) $(x_nat_headers)\n CLEANFILES = tmp-list libgcj.zip\n \n SUFFIXES = .class .java .h\n@@ -219,12 +218,13 @@ nat_headers = $(ordinary_java_source_files:.java=.h) \\\n \tjava/io/ObjectInputStream$$GetField.h\n \n \n+x_nat_headers = $(x_java_source_files:.java=.h)\n+\n extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -281,6 +281,16 @@ gnu/gcj/convert/UnicodeToBytes.java\n special_java_source_files = java/lang/Class.java java/lang/Object.java\n \n awt_java_source_files = \\\n+gnu/awt/LightweightRedirector.java \\\n+gnu/awt/j2d/AbstractGraphicsState.java \\\n+gnu/awt/j2d/DirectRasterGraphics.java \\\n+gnu/awt/j2d/Graphics2DImpl.java \\\n+gnu/awt/j2d/IntegerGraphicsState.java \\\n+gnu/awt/j2d/MappedRaster.java \\\n+gnu/gcj/awt/BitMaskExtent.java \\\n+gnu/gcj/awt/Buffers.java \\\n+gnu/gcj/awt/ComponentDataBlitOp.java \\\n+gnu/gcj/awt/GLightweightPeer.java \\\n gnu/java/beans/editors/ColorEditor.java\t\\\n gnu/java/beans/editors/FontEditor.java \\\n gnu/java/beans/editors/NativeBooleanEditor.java\t\\\n@@ -296,10 +306,6 @@ gnu/java/beans/BeanInfoEmbryo.java \\\n gnu/java/beans/EmptyBeanInfo.java \\\n gnu/java/beans/ExplicitBeanInfo.java \\\n gnu/java/beans/IntrospectionIncubator.java \\\n-gnu/gcj/awt/BitMaskExtent.java \\\n-gnu/gcj/awt/Buffers.java \\\n-gnu/gcj/awt/ComponentDataBlitOp.java \\\n-gnu/gcj/awt/GLightweightPeer.java \\\n java/applet/Applet.java \\\n java/applet/AppletStub.java \\\n java/applet/AppletContext.java \\\n@@ -953,6 +959,64 @@ java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n \n \n+x_java_source_files = \\\n+gnu/gcj/xlib/Clip.java \\\n+gnu/gcj/xlib/Colormap.java \\\n+gnu/gcj/xlib/Display.java \\\n+gnu/gcj/xlib/Drawable.java \\\n+gnu/gcj/xlib/Font.java \\\n+gnu/gcj/xlib/GC.java \\\n+gnu/gcj/xlib/Pixmap.java \\\n+gnu/gcj/xlib/Screen.java \\\n+gnu/gcj/xlib/Visual.java \\\n+gnu/gcj/xlib/WMSizeHints.java \\\n+gnu/gcj/xlib/Window.java \\\n+gnu/gcj/xlib/WindowAttributes.java \\\n+gnu/gcj/xlib/XAnyEvent.java \\\n+gnu/gcj/xlib/XButtonEvent.java \\\n+gnu/gcj/xlib/XColor.java \\\n+gnu/gcj/xlib/XConfigureEvent.java \\\n+gnu/gcj/xlib/XConnectException.java \\\n+gnu/gcj/xlib/XEvent.java \\\n+gnu/gcj/xlib/XException.java \\\n+gnu/gcj/xlib/XExposeEvent.java \\\n+gnu/gcj/xlib/XID.java \\\n+gnu/gcj/xlib/XImage.java \\\n+gnu/gcj/xlib/XUnmapEvent.java \\\n+gnu/awt/xlib/XCanvasPeer.java \\\n+gnu/awt/xlib/XEventLoop.java \\\n+gnu/awt/xlib/XEventQueue.java \\\n+gnu/awt/xlib/XFontMetrics.java \\\n+gnu/awt/xlib/XFramePeer.java \\\n+gnu/awt/xlib/XGraphics.java \\\n+gnu/awt/xlib/XGraphicsConfiguration.java \\\n+gnu/awt/xlib/XPanelPeer.java \\\n+gnu/awt/xlib/XToolkit.java\n+\n+\n+x_nat_source_files = \\\n+gnu/gcj/xlib/natClip.cc \\\n+gnu/gcj/xlib/natColormap.cc \\\n+gnu/gcj/xlib/natDisplay.cc \\\n+gnu/gcj/xlib/natDrawable.cc \\\n+gnu/gcj/xlib/natFont.cc \\\n+gnu/gcj/xlib/natGC.cc \\\n+gnu/gcj/xlib/natPixmap.cc \\\n+gnu/gcj/xlib/natScreen.cc \\\n+gnu/gcj/xlib/natVisual.cc \\\n+gnu/gcj/xlib/natWMSizeHints.cc \\\n+gnu/gcj/xlib/natWindow.cc \\\n+gnu/gcj/xlib/natWindowAttributes.cc \\\n+gnu/gcj/xlib/natXAnyEvent.cc \\\n+gnu/gcj/xlib/natXButtonEvent.cc \\\n+gnu/gcj/xlib/natXColor.cc \\\n+gnu/gcj/xlib/natXConfigureEvent.cc \\\n+gnu/gcj/xlib/natXException.cc \\\n+gnu/gcj/xlib/natXExposeEvent.cc \\\n+gnu/gcj/xlib/natXImage.cc \\\n+gnu/gcj/xlib/natXUnmapEvent.cc\n+\n+\n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n # friends when we are called from the top level Makefile.\n@@ -1014,6 +1078,10 @@ DEFS = @DEFS@ -I. -I$(srcdir) -I./include\n CPPFLAGS = @CPPFLAGS@\n LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n+X_CFLAGS = @X_CFLAGS@\n+X_LIBS = @X_LIBS@\n+X_EXTRA_LIBS = @X_EXTRA_LIBS@\n+X_PRE_LIBS = @X_PRE_LIBS@\n libgcjdata_a_LIBADD = \n @NEEDS_DATA_START_TRUE@libgcjdata_a_OBJECTS =  libgcjdata.$(OBJEXT)\n LTLIBRARIES =  $(toolexeclib_LTLIBRARIES)\n@@ -1040,6 +1108,17 @@ java/net/natInetAddress.lo java/net/natPlainDatagramSocketImpl.lo \\\n java/net/natPlainSocketImpl.lo java/text/natCollator.lo \\\n java/util/natGregorianCalendar.lo java/util/zip/natDeflater.lo \\\n java/util/zip/natInflater.lo\n+libgcjx_la_OBJECTS =  gnu/gcj/xlib/natClip.lo \\\n+gnu/gcj/xlib/natColormap.lo gnu/gcj/xlib/natDisplay.lo \\\n+gnu/gcj/xlib/natDrawable.lo gnu/gcj/xlib/natFont.lo \\\n+gnu/gcj/xlib/natGC.lo gnu/gcj/xlib/natPixmap.lo \\\n+gnu/gcj/xlib/natScreen.lo gnu/gcj/xlib/natVisual.lo \\\n+gnu/gcj/xlib/natWMSizeHints.lo gnu/gcj/xlib/natWindow.lo \\\n+gnu/gcj/xlib/natWindowAttributes.lo gnu/gcj/xlib/natXAnyEvent.lo \\\n+gnu/gcj/xlib/natXButtonEvent.lo gnu/gcj/xlib/natXColor.lo \\\n+gnu/gcj/xlib/natXConfigureEvent.lo gnu/gcj/xlib/natXException.lo \\\n+gnu/gcj/xlib/natXExposeEvent.lo gnu/gcj/xlib/natXImage.lo \\\n+gnu/gcj/xlib/natXUnmapEvent.lo\n @NATIVE_TRUE@bin_PROGRAMS =  jv-convert$(EXEEXT) gij$(EXEEXT)\n @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS =  \\\n @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS$(EXEEXT)\n@@ -1076,6 +1155,17 @@ DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/$(srcdir)/$(CONVERT_DIR)/make-trie.P .deps/boehm.P \\\n .deps/defineclass.P .deps/exception.P .deps/gij.P \\\n+.deps/gnu/awt/LightweightRedirector.P \\\n+.deps/gnu/awt/j2d/AbstractGraphicsState.P \\\n+.deps/gnu/awt/j2d/DirectRasterGraphics.P \\\n+.deps/gnu/awt/j2d/Graphics2DImpl.P \\\n+.deps/gnu/awt/j2d/IntegerGraphicsState.P \\\n+.deps/gnu/awt/j2d/MappedRaster.P .deps/gnu/awt/xlib/XCanvasPeer.P \\\n+.deps/gnu/awt/xlib/XEventLoop.P .deps/gnu/awt/xlib/XEventQueue.P \\\n+.deps/gnu/awt/xlib/XFontMetrics.P .deps/gnu/awt/xlib/XFramePeer.P \\\n+.deps/gnu/awt/xlib/XGraphics.P \\\n+.deps/gnu/awt/xlib/XGraphicsConfiguration.P \\\n+.deps/gnu/awt/xlib/XPanelPeer.P .deps/gnu/awt/xlib/XToolkit.P \\\n .deps/gnu/gcj/RawData.P .deps/gnu/gcj/awt/BitMaskExtent.P \\\n .deps/gnu/gcj/awt/Buffers.P .deps/gnu/gcj/awt/ComponentDataBlitOp.P \\\n .deps/gnu/gcj/awt/GLightweightPeer.P \\\n@@ -1119,7 +1209,29 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/text/LocaleData_en_US.P \\\n .deps/gnu/gcj/text/SentenceBreakIterator.P \\\n .deps/gnu/gcj/text/WordBreakIterator.P \\\n-.deps/gnu/gcj/util/EnumerationChain.P \\\n+.deps/gnu/gcj/util/EnumerationChain.P .deps/gnu/gcj/xlib/Clip.P \\\n+.deps/gnu/gcj/xlib/Colormap.P .deps/gnu/gcj/xlib/Display.P \\\n+.deps/gnu/gcj/xlib/Drawable.P .deps/gnu/gcj/xlib/Font.P \\\n+.deps/gnu/gcj/xlib/GC.P .deps/gnu/gcj/xlib/Pixmap.P \\\n+.deps/gnu/gcj/xlib/Screen.P .deps/gnu/gcj/xlib/Visual.P \\\n+.deps/gnu/gcj/xlib/WMSizeHints.P .deps/gnu/gcj/xlib/Window.P \\\n+.deps/gnu/gcj/xlib/WindowAttributes.P .deps/gnu/gcj/xlib/XAnyEvent.P \\\n+.deps/gnu/gcj/xlib/XButtonEvent.P .deps/gnu/gcj/xlib/XColor.P \\\n+.deps/gnu/gcj/xlib/XConfigureEvent.P \\\n+.deps/gnu/gcj/xlib/XConnectException.P .deps/gnu/gcj/xlib/XEvent.P \\\n+.deps/gnu/gcj/xlib/XException.P .deps/gnu/gcj/xlib/XExposeEvent.P \\\n+.deps/gnu/gcj/xlib/XID.P .deps/gnu/gcj/xlib/XImage.P \\\n+.deps/gnu/gcj/xlib/XUnmapEvent.P .deps/gnu/gcj/xlib/natClip.P \\\n+.deps/gnu/gcj/xlib/natColormap.P .deps/gnu/gcj/xlib/natDisplay.P \\\n+.deps/gnu/gcj/xlib/natDrawable.P .deps/gnu/gcj/xlib/natFont.P \\\n+.deps/gnu/gcj/xlib/natGC.P .deps/gnu/gcj/xlib/natPixmap.P \\\n+.deps/gnu/gcj/xlib/natScreen.P .deps/gnu/gcj/xlib/natVisual.P \\\n+.deps/gnu/gcj/xlib/natWMSizeHints.P .deps/gnu/gcj/xlib/natWindow.P \\\n+.deps/gnu/gcj/xlib/natWindowAttributes.P \\\n+.deps/gnu/gcj/xlib/natXAnyEvent.P .deps/gnu/gcj/xlib/natXButtonEvent.P \\\n+.deps/gnu/gcj/xlib/natXColor.P .deps/gnu/gcj/xlib/natXConfigureEvent.P \\\n+.deps/gnu/gcj/xlib/natXException.P .deps/gnu/gcj/xlib/natXExposeEvent.P \\\n+.deps/gnu/gcj/xlib/natXImage.P .deps/gnu/gcj/xlib/natXUnmapEvent.P \\\n .deps/gnu/java/beans/BeanInfoEmbryo.P \\\n .deps/gnu/java/beans/EmptyBeanInfo.P \\\n .deps/gnu/java/beans/ExplicitBeanInfo.P \\\n@@ -1544,8 +1656,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/zip/natInflater.P .deps/jni.P .deps/libgcjdata.P \\\n .deps/name-finder.P .deps/no-threads.P .deps/nogc.P \\\n .deps/posix-threads.P .deps/posix.P .deps/prims.P .deps/resolve.P\n-SOURCES = $(libgcjdata_a_SOURCES) $(libgcj_la_SOURCES) $(EXTRA_libgcj_la_SOURCES) $(jv_convert_SOURCES) $(EXTRA_jv_convert_SOURCES) $(gij_SOURCES) $(gen_from_JIS_SOURCES) $(EXTRA_gen_from_JIS_SOURCES)\n-OBJECTS = $(libgcjdata_a_OBJECTS) $(libgcj_la_OBJECTS) $(jv_convert_OBJECTS) $(gij_OBJECTS) $(gen_from_JIS_OBJECTS)\n+SOURCES = $(libgcjdata_a_SOURCES) $(libgcj_la_SOURCES) $(EXTRA_libgcj_la_SOURCES) $(libgcjx_la_SOURCES) $(EXTRA_libgcjx_la_SOURCES) $(jv_convert_SOURCES) $(EXTRA_jv_convert_SOURCES) $(gij_SOURCES) $(gen_from_JIS_SOURCES) $(EXTRA_gen_from_JIS_SOURCES)\n+OBJECTS = $(libgcjdata_a_OBJECTS) $(libgcj_la_OBJECTS) $(libgcjx_la_OBJECTS) $(jv_convert_OBJECTS) $(gij_OBJECTS) $(gen_from_JIS_OBJECTS)\n \n all: all-redirect\n .SUFFIXES:\n@@ -1672,6 +1784,9 @@ uninstall-toolexeclibLTLIBRARIES:\n libgcj.la: $(libgcj_la_OBJECTS) $(libgcj_la_DEPENDENCIES)\n \t$(libgcj_la_LINK) -rpath $(toolexeclibdir) $(libgcj_la_LDFLAGS) $(libgcj_la_OBJECTS) $(libgcj_la_LIBADD) $(LIBS)\n \n+libgcjx.la: $(libgcjx_la_OBJECTS) $(libgcjx_la_DEPENDENCIES)\n+\t$(libgcjx_la_LINK) -rpath $(toolexeclibdir) $(libgcjx_la_LDFLAGS) $(libgcjx_la_OBJECTS) $(libgcjx_la_LIBADD) $(LIBS)\n+\n mostlyclean-binPROGRAMS:\n \n clean-binPROGRAMS:\n@@ -1916,7 +2031,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n@@ -2104,6 +2219,8 @@ mostlyclean distclean maintainer-clean\n \n $(java_source_files:.java=.class): libgcj.zip\n \n+$(x_java_source_files:.java=.class): libgcj.zip\n+\n $(built_java_source_files:.java=.class): $(built_java_source_files)\n \t@javac=\"$(JAVAC)\"; \\\n \tfor f in $?; do \\\n@@ -2112,7 +2229,7 @@ $(built_java_source_files:.java=.class): $(built_java_source_files)\n \t  -d $(here) $$f; \\\n \tdone\n \n-libgcj.zip: $(java_source_files)\n+libgcj.zip: $(java_source_files) $(x_java_source_files)\n \t@: $(shell echo Creating list of files to compile...) $(shell rm -f tmp-list || :) $(shell touch tmp-list) $(foreach source,$(subst $(srcdir)/,,$?),$(shell echo $(source) >> tmp-list))\n \t$(MAKE) $(built_java_source_files:.java=.class)\n \t@javac=\"$(JAVAC)\"; dir=`/bin/pwd`; cd $(srcdir); \\\n@@ -2121,7 +2238,9 @@ libgcj.zip: $(java_source_files)\n \t    $$javac $(JCFLAGS) -classpath $(here):`/bin/pwd` -d $(here) $$f; \\\n \tdone\n \t-@rm -f tmp-list libgcj.zip\n-\t$(ZIP) -r libgcj java gnu -n .class -i '*.class' -i '*/'\n+\tfind java gnu -type d -o -type f -name '*.class' | \\\n+\t  sed -e '/\\/\\./d' -e '/\\/xlib/d' | \\\n+\t  $(ZIP) libgcj -@ -n .class\n \n clean-local:\n \tfind . -name '*.class' -print | xargs rm -f\n@@ -2132,7 +2251,7 @@ clean-local:\n .java.lo:\n \t$(GCJCOMPILE) -o $@ $<\n \n-$(nat_files): %.lo: %.cc\n+$(nat_files) $(x_nat_files): %.lo: %.cc\n \t@echo '$(LTCXXCOMPILE) -c -o $@ $<'; \\\n \t$(LTCXXCOMPILE) -Wp,-MD,.deps/$(*F).pp -c -o $@ $<\n \t@-sed -e 's/^\\([^:]*\\)\\.o[ \t]*:/\\1.lo \\1.o :/' \\\n@@ -2147,7 +2266,7 @@ $(c_files): %.lo: %.c\n \n $(c_files): java/lang/fdlibm.h java/lang/ieeefp.h java/lang/mprec.h\n \n-$(javao_files): %.lo: %.java\n+$(javao_files) $(x_javao_files): %.lo: %.java\n \t$(GCJCOMPILE) -o $@ $<\n \n .class.h:\n@@ -2295,7 +2414,7 @@ $(CONVERT_DIR)/make-trie.o: $(srcdir)/$(CONVERT_DIR)/make-trie.c\n \n -include deps.mk\n \n-all-recursive: $(nat_headers)\n+all-recursive: $(nat_headers) $(x_nat_headers)\n \n # Multilib support.\n .PHONY: all-multi mostlyclean-multi clean-multi distclean-multi \\"}, {"sha": "a0effe75743b9271781e45b8aab8d97013faea3d", "filename": "libjava/configure", "status": "modified", "additions": 1091, "deletions": 249, "changes": 1340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -56,6 +56,8 @@ ac_help=\"$ac_help\n   --enable-java-gc=TYPE   choose garbage collector [boehm]\"\n ac_help=\"$ac_help\n   --enable-threads=TYPE   choose threading package\"\n+ac_help=\"$ac_help\n+  --with-x                use the X Window System\"\n \n # Initialize some variables set by options.\n # The variables have the same names as the options, with\n@@ -73,7 +75,6 @@ program_suffix=NONE\n program_transform_name=s,x,x,\n silent=\n site=\n-sitefile=\n srcdir=\n target=NONE\n verbose=\n@@ -188,7 +189,6 @@ Configuration:\n   --help                  print this message\n   --no-create             do not create output files\n   --quiet, --silent       do not print \\`checking...' messages\n-  --site-file=FILE        use FILE as the site file\n   --version               print the version of autoconf that created configure\n Directory and file names:\n   --prefix=PREFIX         install architecture-independent files in PREFIX\n@@ -359,11 +359,6 @@ EOF\n   -site=* | --site=* | --sit=*)\n     site=\"$ac_optarg\" ;;\n \n-  -site-file | --site-file | --site-fil | --site-fi | --site-f)\n-    ac_prev=sitefile ;;\n-  -site-file=* | --site-file=* | --site-fil=* | --site-fi=* | --site-f=*)\n-    sitefile=\"$ac_optarg\" ;;\n-\n   -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n     ac_prev=srcdir ;;\n   -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n@@ -529,16 +524,12 @@ fi\n srcdir=`echo \"${srcdir}\" | sed 's%\\([^/]\\)/*$%\\1%'`\n \n # Prefer explicitly selected file to automatically selected ones.\n-if test -z \"$sitefile\"; then\n-  if test -z \"$CONFIG_SITE\"; then\n-    if test \"x$prefix\" != xNONE; then\n-      CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n-    else\n-      CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n-    fi\n+if test -z \"$CONFIG_SITE\"; then\n+  if test \"x$prefix\" != xNONE; then\n+    CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n+  else\n+    CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n   fi\n-else\n-  CONFIG_SITE=\"$sitefile\"\n fi\n for ac_site_file in $CONFIG_SITE; do\n   if test -r \"$ac_site_file\"; then\n@@ -626,7 +617,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:630: checking host system type\" >&5\n+echo \"configure:621: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -647,7 +638,7 @@ host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$host\" 1>&6\n \n echo $ac_n \"checking target system type\"\"... $ac_c\" 1>&6\n-echo \"configure:651: checking target system type\" >&5\n+echo \"configure:642: checking target system type\" >&5\n \n target_alias=$target\n case \"$target_alias\" in\n@@ -665,7 +656,7 @@ target_os=`echo $target | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$target\" 1>&6\n \n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:669: checking build system type\" >&5\n+echo \"configure:660: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -713,7 +704,7 @@ fi\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:717: checking for a BSD compatible install\" >&5\n+echo \"configure:708: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -766,7 +757,7 @@ test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'\n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n echo $ac_n \"checking whether build environment is sane\"\"... $ac_c\" 1>&6\n-echo \"configure:770: checking whether build environment is sane\" >&5\n+echo \"configure:761: checking whether build environment is sane\" >&5\n # Just in case\n sleep 1\n echo timestamp > conftestfile\n@@ -823,7 +814,7 @@ test \"$program_suffix\" != NONE &&\n test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n \n echo $ac_n \"checking whether ${MAKE-make} sets \\${MAKE}\"\"... $ac_c\" 1>&6\n-echo \"configure:827: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n+echo \"configure:818: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n set dummy ${MAKE-make}; ac_make=`echo \"$2\" | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -856,12 +847,12 @@ else\n fi\n \n echo $ac_n \"checking for Cygwin environment\"\"... $ac_c\" 1>&6\n-echo \"configure:860: checking for Cygwin environment\" >&5\n+echo \"configure:851: checking for Cygwin environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_cygwin'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 865 \"configure\"\n+#line 856 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n@@ -872,7 +863,7 @@ int main() {\n return __CYGWIN__;\n ; return 0; }\n EOF\n-if { (eval echo configure:876: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:867: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_cygwin=yes\n else\n@@ -889,19 +880,19 @@ echo \"$ac_t\"\"$ac_cv_cygwin\" 1>&6\n CYGWIN=\n test \"$ac_cv_cygwin\" = yes && CYGWIN=yes\n echo $ac_n \"checking for mingw32 environment\"\"... $ac_c\" 1>&6\n-echo \"configure:893: checking for mingw32 environment\" >&5\n+echo \"configure:884: checking for mingw32 environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_mingw32'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 898 \"configure\"\n+#line 889 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n return __MINGW32__;\n ; return 0; }\n EOF\n-if { (eval echo configure:905: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:896: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_mingw32=yes\n else\n@@ -949,7 +940,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:953: checking host system type\" >&5\n+echo \"configure:944: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -976,7 +967,7 @@ echo \"$ac_t\"\"$host\" 1>&6\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:980: checking for $ac_word\" >&5\n+echo \"configure:971: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1006,7 +997,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1010: checking for $ac_word\" >&5\n+echo \"configure:1001: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1057,7 +1048,7 @@ fi\n       # Extract the first word of \"cl\", so it can be a program name with args.\n set dummy cl; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1061: checking for $ac_word\" >&5\n+echo \"configure:1052: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1090,7 +1081,7 @@ fi\n \n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1094: checking whether we are using GNU C\" >&5\n+echo \"configure:1085: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1099,7 +1090,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1103: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1094: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -1118,7 +1109,7 @@ ac_test_CFLAGS=\"${CFLAGS+set}\"\n ac_save_CFLAGS=\"$CFLAGS\"\n CFLAGS=\n echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1122: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:1113: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1154,7 +1145,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1158: checking for $ac_word\" >&5\n+echo \"configure:1149: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1187,7 +1178,7 @@ test -n \"$CXX\" || CXX=\"gcc\"\n \n \n echo $ac_n \"checking whether we are using GNU C++\"\"... $ac_c\" 1>&6\n-echo \"configure:1191: checking whether we are using GNU C++\" >&5\n+echo \"configure:1182: checking whether we are using GNU C++\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gxx'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1196,7 +1187,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1200: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1191: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gxx=yes\n else\n   ac_cv_prog_gxx=no\n@@ -1215,7 +1206,7 @@ ac_test_CXXFLAGS=\"${CXXFLAGS+set}\"\n ac_save_CXXFLAGS=\"$CXXFLAGS\"\n CXXFLAGS=\n echo $ac_n \"checking whether ${CXX-g++} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1219: checking whether ${CXX-g++} accepts -g\" >&5\n+echo \"configure:1210: checking whether ${CXX-g++} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1268,7 +1259,7 @@ EOF\n \n missing_dir=`cd $ac_aux_dir && pwd`\n echo $ac_n \"checking for working aclocal\"\"... $ac_c\" 1>&6\n-echo \"configure:1272: checking for working aclocal\" >&5\n+echo \"configure:1263: checking for working aclocal\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1281,7 +1272,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoconf\"\"... $ac_c\" 1>&6\n-echo \"configure:1285: checking for working autoconf\" >&5\n+echo \"configure:1276: checking for working autoconf\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1294,7 +1285,7 @@ else\n fi\n \n echo $ac_n \"checking for working automake\"\"... $ac_c\" 1>&6\n-echo \"configure:1298: checking for working automake\" >&5\n+echo \"configure:1289: checking for working automake\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1307,7 +1298,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoheader\"\"... $ac_c\" 1>&6\n-echo \"configure:1311: checking for working autoheader\" >&5\n+echo \"configure:1302: checking for working autoheader\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1320,7 +1311,7 @@ else\n fi\n \n echo $ac_n \"checking for working makeinfo\"\"... $ac_c\" 1>&6\n-echo \"configure:1324: checking for working makeinfo\" >&5\n+echo \"configure:1315: checking for working makeinfo\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1339,7 +1330,7 @@ fi\n # LIBGCJ_CONFIGURE, which doesn't work because that means that it will\n # be run before AC_CANONICAL_HOST.\n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:1343: checking build system type\" >&5\n+echo \"configure:1334: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -1360,7 +1351,7 @@ echo \"$ac_t\"\"$build\" 1>&6\n # Extract the first word of \"${ac_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1364: checking for $ac_word\" >&5\n+echo \"configure:1355: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1392,7 +1383,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1396: checking for $ac_word\" >&5\n+echo \"configure:1387: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1424,7 +1415,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1428: checking for $ac_word\" >&5\n+echo \"configure:1419: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1456,7 +1447,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1460: checking for $ac_word\" >&5\n+echo \"configure:1451: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1501,7 +1492,7 @@ fi\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:1505: checking for a BSD compatible install\" >&5\n+echo \"configure:1496: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1555,7 +1546,7 @@ test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:1559: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:1550: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -1589,7 +1580,7 @@ if false; then\n   \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1593: checking for executable suffix\" >&5\n+echo \"configure:1584: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1599,10 +1590,10 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:1603: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:1594: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n-      *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n+      *.c | *.o | *.obj) ;;\n       *) ac_cv_exeext=`echo $file | sed -e s/conftest//` ;;\n       esac\n     done\n@@ -1752,7 +1743,7 @@ ac_prog=ld\n if test \"$ac_cv_prog_gcc\" = yes; then\n   # Check if gcc -print-prog-name=ld gives a path.\n   echo $ac_n \"checking for ld used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:1756: checking for ld used by GCC\" >&5\n+echo \"configure:1747: checking for ld used by GCC\" >&5\n   case $host in\n   *-*-mingw*)\n     # gcc leaves a trailing carriage return which upsets mingw\n@@ -1782,10 +1773,10 @@ echo \"configure:1756: checking for ld used by GCC\" >&5\n   esac\n elif test \"$with_gnu_ld\" = yes; then\n   echo $ac_n \"checking for GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1786: checking for GNU ld\" >&5\n+echo \"configure:1777: checking for GNU ld\" >&5\n else\n   echo $ac_n \"checking for non-GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1789: checking for non-GNU ld\" >&5\n+echo \"configure:1780: checking for non-GNU ld\" >&5\n fi\n if eval \"test \\\"`echo '$''{'ac_cv_path_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1820,7 +1811,7 @@ else\n fi\n test -z \"$LD\" && { echo \"configure: error: no acceptable ld found in \\$PATH\" 1>&2; exit 1; }\n echo $ac_n \"checking if the linker ($LD) is GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1824: checking if the linker ($LD) is GNU ld\" >&5\n+echo \"configure:1815: checking if the linker ($LD) is GNU ld\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gnu_ld'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1837,7 +1828,7 @@ with_gnu_ld=$ac_cv_prog_gnu_ld\n \n \n echo $ac_n \"checking for $LD option to reload object files\"\"... $ac_c\" 1>&6\n-echo \"configure:1841: checking for $LD option to reload object files\" >&5\n+echo \"configure:1832: checking for $LD option to reload object files\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_ld_reload_flag'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1849,7 +1840,7 @@ reload_flag=$lt_cv_ld_reload_flag\n test -n \"$reload_flag\" && reload_flag=\" $reload_flag\"\n \n echo $ac_n \"checking for BSD-compatible nm\"\"... $ac_c\" 1>&6\n-echo \"configure:1853: checking for BSD-compatible nm\" >&5\n+echo \"configure:1844: checking for BSD-compatible nm\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1887,7 +1878,7 @@ NM=\"$ac_cv_path_NM\"\n echo \"$ac_t\"\"$NM\" 1>&6\n \n echo $ac_n \"checking whether ln -s works\"\"... $ac_c\" 1>&6\n-echo \"configure:1891: checking whether ln -s works\" >&5\n+echo \"configure:1882: checking whether ln -s works\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LN_S'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1908,7 +1899,7 @@ else\n fi\n \n echo $ac_n \"checking how to recognise dependant libraries\"\"... $ac_c\" 1>&6\n-echo \"configure:1912: checking how to recognise dependant libraries\" >&5\n+echo \"configure:1903: checking how to recognise dependant libraries\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_deplibs_check_method'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2051,13 +2042,13 @@ file_magic_cmd=$lt_cv_file_magic_cmd\n deplibs_check_method=$lt_cv_deplibs_check_method\n \n echo $ac_n \"checking for object suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:2055: checking for object suffix\" >&5\n+echo \"configure:2046: checking for object suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_objext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   rm -f conftest*\n echo 'int i = 1;' > conftest.$ac_ext\n-if { (eval echo configure:2061: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2052: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   for ac_file in conftest.*; do\n     case $ac_file in\n     *.c) ;;\n@@ -2081,7 +2072,7 @@ case \"$deplibs_check_method\" in\n file_magic*)\n   if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n     echo $ac_n \"checking for ${ac_tool_prefix}file\"\"... $ac_c\" 1>&6\n-echo \"configure:2085: checking for ${ac_tool_prefix}file\" >&5\n+echo \"configure:2076: checking for ${ac_tool_prefix}file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2143,7 +2134,7 @@ fi\n if test -z \"$lt_cv_path_MAGIC_CMD\"; then\n   if test -n \"$ac_tool_prefix\"; then\n     echo $ac_n \"checking for file\"\"... $ac_c\" 1>&6\n-echo \"configure:2147: checking for file\" >&5\n+echo \"configure:2138: checking for file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2214,7 +2205,7 @@ esac\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2218: checking for $ac_word\" >&5\n+echo \"configure:2209: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2246,7 +2237,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2250: checking for $ac_word\" >&5\n+echo \"configure:2241: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2281,7 +2272,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}strip\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2285: checking for $ac_word\" >&5\n+echo \"configure:2276: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2313,7 +2304,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"strip\", so it can be a program name with args.\n set dummy strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2317: checking for $ac_word\" >&5\n+echo \"configure:2308: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2380,8 +2371,8 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case \"$host\" in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 2384 \"configure\"' > conftest.$ac_ext\n-  if { (eval echo configure:2385: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  echo '#line 2375 \"configure\"' > conftest.$ac_ext\n+  if { (eval echo configure:2376: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case \"`/usr/bin/file conftest.o`\" in\n     *32-bit*)\n       LD=\"${LD-ld} -32\"\n@@ -2402,7 +2393,7 @@ case \"$host\" in\n   SAVE_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"$CFLAGS -belf\"\n   echo $ac_n \"checking whether the C compiler needs -belf\"\"... $ac_c\" 1>&6\n-echo \"configure:2406: checking whether the C compiler needs -belf\" >&5\n+echo \"configure:2397: checking whether the C compiler needs -belf\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2415,14 +2406,14 @@ ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$a\n cross_compiling=$ac_cv_prog_cc_cross\n \n      cat > conftest.$ac_ext <<EOF\n-#line 2419 \"configure\"\n+#line 2410 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2426: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2417: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   lt_cv_cc_needs_belf=yes\n else\n@@ -2452,7 +2443,7 @@ echo \"$ac_t\"\"$lt_cv_cc_needs_belf\" 1>&6\n esac\n \n echo $ac_n \"checking how to run the C++ preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2456: checking how to run the C++ preprocessor\" >&5\n+echo \"configure:2447: checking how to run the C++ preprocessor\" >&5\n if test -z \"$CXXCPP\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXXCPP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -2465,12 +2456,12 @@ ac_link='${CXX-g++} -o conftest${ac_exeext} $CXXFLAGS $CPPFLAGS $LDFLAGS conftes\n cross_compiling=$ac_cv_prog_cxx_cross\n   CXXCPP=\"${CXX-g++} -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2469 \"configure\"\n+#line 2460 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2474: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2465: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2710,18 +2701,18 @@ if test \"$ac_cv_prog_gnu_ld\" = yes; then\n fi   \n \n echo $ac_n \"checking for data_start\"\"... $ac_c\" 1>&6\n-echo \"configure:2714: checking for data_start\" >&5\n+echo \"configure:2705: checking for data_start\" >&5\n LIBDATASTARTSPEC=\n NEEDS_DATA_START=\n cat > conftest.$ac_ext <<EOF\n-#line 2718 \"configure\"\n+#line 2709 \"configure\"\n #include \"confdefs.h\"\n extern int data_start;\n int main() {\n return ((int) &data_start);\n ; return 0; }\n EOF\n-if { (eval echo configure:2725: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2716: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   echo \"$ac_t\"\"found it\" 1>&6\n else\n@@ -2791,7 +2782,7 @@ EOF\n esac\n \n echo $ac_n \"checking how to run the C preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2795: checking how to run the C preprocessor\" >&5\n+echo \"configure:2786: checking how to run the C preprocessor\" >&5\n # On Suns, sometimes $CPP names a directory.\n if test -n \"$CPP\" && test -d \"$CPP\"; then\n   CPP=\n@@ -2806,13 +2797,13 @@ else\n   # On the NeXT, cc -E runs the code through the compiler's parser,\n   # not just through cpp.\n   cat > conftest.$ac_ext <<EOF\n-#line 2810 \"configure\"\n+#line 2801 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2816: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2807: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2823,13 +2814,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -E -traditional-cpp\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2827 \"configure\"\n+#line 2818 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2833: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2824: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2840,13 +2831,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -nologo -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2844 \"configure\"\n+#line 2835 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2850: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2841: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2871,7 +2862,7 @@ fi\n echo \"$ac_t\"\"$CPP\" 1>&6\n \n cat > conftest.$ac_ext <<EOF\n-#line 2875 \"configure\"\n+#line 2866 \"configure\"\n #include \"confdefs.h\"\n #include <stdint.h>\n EOF\n@@ -2886,7 +2877,7 @@ fi\n rm -f conftest*\n \n cat > conftest.$ac_ext <<EOF\n-#line 2890 \"configure\"\n+#line 2881 \"configure\"\n #include \"confdefs.h\"\n #include <inttypes.h>\n EOF\n@@ -2901,7 +2892,7 @@ fi\n rm -f conftest*\n \n cat > conftest.$ac_ext <<EOF\n-#line 2905 \"configure\"\n+#line 2896 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n EOF\n@@ -2916,7 +2907,7 @@ fi\n rm -f conftest*\n \n cat > conftest.$ac_ext <<EOF\n-#line 2920 \"configure\"\n+#line 2911 \"configure\"\n #include \"confdefs.h\"\n #include <sys/config.h>\n EOF\n@@ -2933,7 +2924,7 @@ rm -f conftest*\n \n \n cat > conftest.$ac_ext <<EOF\n-#line 2937 \"configure\"\n+#line 2928 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n EOF\n@@ -2948,7 +2939,7 @@ fi\n rm -f conftest*\n \n cat > conftest.$ac_ext <<EOF\n-#line 2952 \"configure\"\n+#line 2943 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n EOF\n@@ -2991,7 +2982,7 @@ ZLIBTESTSPEC=\n libsubdir=.libs\n \n echo $ac_n \"checking for garbage collector to use\"\"... $ac_c\" 1>&6\n-echo \"configure:2995: checking for garbage collector to use\" >&5\n+echo \"configure:2986: checking for garbage collector to use\" >&5\n # Check whether --enable-java-gc or --disable-java-gc was given.\n if test \"${enable_java_gc+set}\" = set; then\n   enableval=\"$enable_java_gc\"\n@@ -3047,7 +3038,7 @@ esac\n \n \n echo $ac_n \"checking for threads package to use\"\"... $ac_c\" 1>&6\n-echo \"configure:3051: checking for threads package to use\" >&5\n+echo \"configure:3042: checking for threads package to use\" >&5\n # Check whether --enable-threads or --disable-threads was given.\n if test \"${enable_threads+set}\" = set; then\n   enableval=\"$enable_threads\"\n@@ -3241,12 +3232,12 @@ else\n    for ac_func in strerror ioctl select fstat open fsync sleep\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3245: checking for $ac_func\" >&5\n+echo \"configure:3236: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3250 \"configure\"\n+#line 3241 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3269,7 +3260,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3273: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3264: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3296,12 +3287,12 @@ done\n    for ac_func in gmtime_r localtime_r readdir_r getpwuid_r getcwd\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3300: checking for $ac_func\" >&5\n+echo \"configure:3291: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3305 \"configure\"\n+#line 3296 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3324,7 +3315,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3328: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3319: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3351,12 +3342,12 @@ done\n    for ac_func in access stat mkdir rename rmdir unlink realpath\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3355: checking for $ac_func\" >&5\n+echo \"configure:3346: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3360 \"configure\"\n+#line 3351 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3379,7 +3370,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3383: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3374: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3406,12 +3397,12 @@ done\n    for ac_func in iconv nl_langinfo\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3410: checking for $ac_func\" >&5\n+echo \"configure:3401: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3415 \"configure\"\n+#line 3406 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3434,7 +3425,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3438: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3429: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3461,12 +3452,12 @@ done\n    for ac_func in inet_aton inet_addr\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3465: checking for $ac_func\" >&5\n+echo \"configure:3456: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3470 \"configure\"\n+#line 3461 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3489,7 +3480,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3493: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3484: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3516,12 +3507,12 @@ done\n    for ac_func in inet_pton uname inet_ntoa\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3520: checking for $ac_func\" >&5\n+echo \"configure:3511: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3525 \"configure\"\n+#line 3516 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3544,7 +3535,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3548: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3539: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3571,12 +3562,12 @@ done\n    for ac_func in backtrace fork execvp pipe\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3575: checking for $ac_func\" >&5\n+echo \"configure:3566: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3580 \"configure\"\n+#line 3571 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3599,7 +3590,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3603: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3594: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3627,17 +3618,17 @@ done\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:3631: checking for $ac_hdr\" >&5\n+echo \"configure:3622: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3636 \"configure\"\n+#line 3627 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:3641: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:3632: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -3664,15 +3655,15 @@ fi\n done\n  \n    echo $ac_n \"checking for dladdr in -ldl\"\"... $ac_c\" 1>&6\n-echo \"configure:3668: checking for dladdr in -ldl\" >&5\n+echo \"configure:3659: checking for dladdr in -ldl\" >&5\n ac_lib_var=`echo dl'_'dladdr | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-ldl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 3676 \"configure\"\n+#line 3667 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -3683,7 +3674,7 @@ int main() {\n dladdr()\n ; return 0; }\n EOF\n-if { (eval echo configure:3687: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3678: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -3712,7 +3703,7 @@ do\n \n ac_safe=`echo \"$ac_file\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_file\"\"... $ac_c\" 1>&6\n-echo \"configure:3716: checking for $ac_file\" >&5\n+echo \"configure:3707: checking for $ac_file\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_file_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3747,12 +3738,12 @@ done\n    for ac_func in gethostbyname_r\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3751: checking for $ac_func\" >&5\n+echo \"configure:3742: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3756 \"configure\"\n+#line 3747 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3775,7 +3766,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3779: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3770: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3802,7 +3793,7 @@ EOF\n      # We look for the one that returns `int'.\n      # Hopefully this check is robust enough.\n      cat > conftest.$ac_ext <<EOF\n-#line 3806 \"configure\"\n+#line 3797 \"configure\"\n #include \"confdefs.h\"\n #include <netdb.h>\n EOF\n@@ -3822,7 +3813,7 @@ rm -f conftest*\n      *\" -D_REENTRANT \"*) ;;\n      *)\n \t\techo $ac_n \"checking whether gethostbyname_r declaration requires -D_REENTRANT\"\"... $ac_c\" 1>&6\n-echo \"configure:3826: checking whether gethostbyname_r declaration requires -D_REENTRANT\" >&5\n+echo \"configure:3817: checking whether gethostbyname_r declaration requires -D_REENTRANT\" >&5\n if eval \"test \\\"`echo '$''{'libjava_cv_gethostbyname_r_needs_reentrant'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3835,14 +3826,14 @@ ac_link='${CXX-g++} -o conftest${ac_exeext} $CXXFLAGS $CPPFLAGS $LDFLAGS conftes\n cross_compiling=$ac_cv_prog_cxx_cross\n \n \t  cat > conftest.$ac_ext <<EOF\n-#line 3839 \"configure\"\n+#line 3830 \"configure\"\n #include \"confdefs.h\"\n #include <netdb.h>\n int main() {\n gethostbyname_r(\"\", 0, 0);\n ; return 0; }\n EOF\n-if { (eval echo configure:3846: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3837: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   libjava_cv_gethostbyname_r_needs_reentrant=no\n else\n@@ -3852,14 +3843,14 @@ else\n   \t\tCPPFLAGS_SAVE=\"$CPPFLAGS\"\n \t\tCPPFLAGS=\"$CPPFLAGS -D_REENTRANT\"\n \t\tcat > conftest.$ac_ext <<EOF\n-#line 3856 \"configure\"\n+#line 3847 \"configure\"\n #include \"confdefs.h\"\n #include <netdb.h>\n int main() {\n gethostbyname_r(\"\", 0, 0);\n ; return 0; }\n EOF\n-if { (eval echo configure:3863: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3854: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   libjava_cv_gethostbyname_r_needs_reentrant=yes\n else\n@@ -3894,12 +3885,12 @@ EOF\n      esac\n \n      echo $ac_n \"checking for struct hostent_data\"\"... $ac_c\" 1>&6\n-echo \"configure:3898: checking for struct hostent_data\" >&5\n+echo \"configure:3889: checking for struct hostent_data\" >&5\n if eval \"test \\\"`echo '$''{'libjava_cv_struct_hostent_data'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   \tcat > conftest.$ac_ext <<EOF\n-#line 3903 \"configure\"\n+#line 3894 \"configure\"\n #include \"confdefs.h\"\n \n #if GETHOSTBYNAME_R_NEEDS_REENTRANT && !defined(_REENTRANT)\n@@ -3910,7 +3901,7 @@ int main() {\n struct hostent_data data;\n ; return 0; }\n EOF\n-if { (eval echo configure:3914: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3905: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   libjava_cv_struct_hostent_data=yes\n else\n@@ -3939,12 +3930,12 @@ done\n    for ac_func in gethostbyaddr_r\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3943: checking for $ac_func\" >&5\n+echo \"configure:3934: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3948 \"configure\"\n+#line 3939 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3967,7 +3958,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3971: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3962: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3994,7 +3985,7 @@ EOF\n      # We look for the one that returns `int'.\n      # Hopefully this check is robust enough.\n      cat > conftest.$ac_ext <<EOF\n-#line 3998 \"configure\"\n+#line 3989 \"configure\"\n #include \"confdefs.h\"\n #include <netdb.h>\n EOF\n@@ -4018,12 +4009,12 @@ done\n    for ac_func in gethostname\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:4022: checking for $ac_func\" >&5\n+echo \"configure:4013: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4027 \"configure\"\n+#line 4018 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -4046,7 +4037,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4050: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4041: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -4070,7 +4061,7 @@ EOF\n EOF\n \n      cat > conftest.$ac_ext <<EOF\n-#line 4074 \"configure\"\n+#line 4065 \"configure\"\n #include \"confdefs.h\"\n #include <unistd.h>\n EOF\n@@ -4101,12 +4092,12 @@ done\n       for ac_func in pthread_mutexattr_settype pthread_mutexattr_setkind_np\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:4105: checking for $ac_func\" >&5\n+echo \"configure:4096: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4110 \"configure\"\n+#line 4101 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -4129,7 +4120,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4133: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4124: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -4159,12 +4150,12 @@ done\n       for ac_func in sched_yield\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:4163: checking for $ac_func\" >&5\n+echo \"configure:4154: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4168 \"configure\"\n+#line 4159 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -4187,7 +4178,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4191: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4182: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -4209,15 +4200,15 @@ EOF\n else\n   echo \"$ac_t\"\"no\" 1>&6\n echo $ac_n \"checking for sched_yield in -lrt\"\"... $ac_c\" 1>&6\n-echo \"configure:4213: checking for sched_yield in -lrt\" >&5\n+echo \"configure:4204: checking for sched_yield in -lrt\" >&5\n ac_lib_var=`echo rt'_'sched_yield | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lrt  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4221 \"configure\"\n+#line 4212 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -4228,7 +4219,7 @@ int main() {\n sched_yield()\n ; return 0; }\n EOF\n-if { (eval echo configure:4232: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4223: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4254,15 +4245,15 @@ else\n   echo \"$ac_t\"\"no\" 1>&6\n \n \t  echo $ac_n \"checking for sched_yield in -lposix4\"\"... $ac_c\" 1>&6\n-echo \"configure:4258: checking for sched_yield in -lposix4\" >&5\n+echo \"configure:4249: checking for sched_yield in -lposix4\" >&5\n ac_lib_var=`echo posix4'_'sched_yield | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lposix4  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4266 \"configure\"\n+#line 4257 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -4273,7 +4264,7 @@ int main() {\n sched_yield()\n ; return 0; }\n EOF\n-if { (eval echo configure:4277: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4268: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4309,7 +4300,7 @@ done\n       # We can save a little space at runtime if the mutex has m_count\n       # or __m_count.  This is a nice hack for Linux.\n       cat > conftest.$ac_ext <<EOF\n-#line 4313 \"configure\"\n+#line 4304 \"configure\"\n #include \"confdefs.h\"\n #include <pthread.h>\n int main() {\n@@ -4318,7 +4309,7 @@ int main() {\n         \n ; return 0; }\n EOF\n-if { (eval echo configure:4322: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:4313: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define PTHREAD_MUTEX_HAVE_M_COUNT 1\n@@ -4330,7 +4321,7 @@ else\n   rm -rf conftest*\n   \n \tcat > conftest.$ac_ext <<EOF\n-#line 4334 \"configure\"\n+#line 4325 \"configure\"\n #include \"confdefs.h\"\n #include <pthread.h>\n int main() {\n@@ -4339,7 +4330,7 @@ int main() {\n \t  \n ; return 0; }\n EOF\n-if { (eval echo configure:4343: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:4334: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define PTHREAD_MUTEX_HAVE___M_COUNT 1\n@@ -4359,12 +4350,12 @@ rm -f conftest*\n    for ac_func in gettimeofday time ftime\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:4363: checking for $ac_func\" >&5\n+echo \"configure:4354: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4368 \"configure\"\n+#line 4359 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -4387,7 +4378,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4391: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4382: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -4418,12 +4409,12 @@ done\n    for ac_func in memmove\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:4422: checking for $ac_func\" >&5\n+echo \"configure:4413: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4427 \"configure\"\n+#line 4418 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -4446,7 +4437,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4450: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4441: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -4476,12 +4467,12 @@ done\n    for ac_func in memcpy\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:4480: checking for $ac_func\" >&5\n+echo \"configure:4471: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4485 \"configure\"\n+#line 4476 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -4504,7 +4495,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4508: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4499: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -4552,20 +4543,20 @@ done\n    #--------------------------------------------------------------------\n \n    echo $ac_n \"checking for socket libraries\"\"... $ac_c\" 1>&6\n-echo \"configure:4556: checking for socket libraries\" >&5\n+echo \"configure:4547: checking for socket libraries\" >&5\n if eval \"test \\\"`echo '$''{'gcj_cv_lib_sockets'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   gcj_cv_lib_sockets=\n      gcj_checkBoth=0\n      unset ac_cv_func_connect\n      echo $ac_n \"checking for connect\"\"... $ac_c\" 1>&6\n-echo \"configure:4564: checking for connect\" >&5\n+echo \"configure:4555: checking for connect\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_connect'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4569 \"configure\"\n+#line 4560 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char connect(); below.  */\n@@ -4588,7 +4579,7 @@ connect();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4592: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4583: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_connect=yes\"\n else\n@@ -4611,22 +4602,22 @@ fi\n      if test \"$gcj_checkSocket\" = 1; then\n \t unset ac_cv_func_connect\n \t echo $ac_n \"checking for main in -lsocket\"\"... $ac_c\" 1>&6\n-echo \"configure:4615: checking for main in -lsocket\" >&5\n+echo \"configure:4606: checking for main in -lsocket\" >&5\n ac_lib_var=`echo socket'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lsocket  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4623 \"configure\"\n+#line 4614 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:4630: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4621: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4653,12 +4644,12 @@ fi\n \t LIBS=\"$LIBS -lsocket -lnsl\"\n \t unset ac_cv_func_accept\n \t echo $ac_n \"checking for accept\"\"... $ac_c\" 1>&6\n-echo \"configure:4657: checking for accept\" >&5\n+echo \"configure:4648: checking for accept\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_accept'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4662 \"configure\"\n+#line 4653 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char accept(); below.  */\n@@ -4681,7 +4672,7 @@ accept();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4685: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4676: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_accept=yes\"\n else\n@@ -4708,12 +4699,12 @@ fi\n      gcj_oldLibs=$LIBS\n      LIBS=\"$LIBS $gcj_cv_lib_sockets\"\n      echo $ac_n \"checking for gethostbyname\"\"... $ac_c\" 1>&6\n-echo \"configure:4712: checking for gethostbyname\" >&5\n+echo \"configure:4703: checking for gethostbyname\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 4717 \"configure\"\n+#line 4708 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char gethostbyname(); below.  */\n@@ -4736,7 +4727,7 @@ gethostbyname();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:4740: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4731: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_gethostbyname=yes\"\n else\n@@ -4754,22 +4745,22 @@ if eval \"test \\\"`echo '$ac_cv_func_'gethostbyname`\\\" = yes\"; then\n else\n   echo \"$ac_t\"\"no\" 1>&6\n echo $ac_n \"checking for main in -lnsl\"\"... $ac_c\" 1>&6\n-echo \"configure:4758: checking for main in -lnsl\" >&5\n+echo \"configure:4749: checking for main in -lnsl\" >&5\n ac_lib_var=`echo nsl'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lnsl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4766 \"configure\"\n+#line 4757 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:4773: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4764: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4801,15 +4792,15 @@ echo \"$ac_t\"\"$gcj_cv_lib_sockets\" 1>&6\n \n    if test \"$with_system_zlib\" = yes; then\n       echo $ac_n \"checking for deflate in -lz\"\"... $ac_c\" 1>&6\n-echo \"configure:4805: checking for deflate in -lz\" >&5\n+echo \"configure:4796: checking for deflate in -lz\" >&5\n ac_lib_var=`echo z'_'deflate | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-lz  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4813 \"configure\"\n+#line 4804 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -4820,7 +4811,7 @@ int main() {\n deflate()\n ; return 0; }\n EOF\n-if { (eval echo configure:4824: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4815: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4850,22 +4841,22 @@ fi\n    # requires -ldl.\n    if test \"$GC\" = boehm; then\n       echo $ac_n \"checking for main in -ldl\"\"... $ac_c\" 1>&6\n-echo \"configure:4854: checking for main in -ldl\" >&5\n+echo \"configure:4845: checking for main in -ldl\" >&5\n ac_lib_var=`echo dl'_'main | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-ldl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 4862 \"configure\"\n+#line 4853 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n main()\n ; return 0; }\n EOF\n-if { (eval echo configure:4869: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:4860: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -4912,7 +4903,7 @@ GCJ=\"$GCJ -I$srcdir\"\n   # Extract the first word of \"${ac_tool_prefix}gcj\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}gcj; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4916: checking for $ac_word\" >&5\n+echo \"configure:4907: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GCJ'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4944,7 +4935,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"gcj\", so it can be a program name with args.\n set dummy gcj; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4948: checking for $ac_word\" >&5\n+echo \"configure:4939: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GCJ'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5004,15 +4995,15 @@ exec 5>>./config.log\n \n \n echo $ac_n \"checking size of void *\"\"... $ac_c\" 1>&6\n-echo \"configure:5008: checking size of void *\" >&5\n+echo \"configure:4999: checking size of void *\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_void_p'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n     { echo \"configure: error: can not run test program while cross compiling\" 1>&2; exit 1; }\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5016 \"configure\"\n+#line 5007 \"configure\"\n #include \"confdefs.h\"\n #include <stdio.h>\n main()\n@@ -5023,7 +5014,7 @@ main()\n   exit(0);\n }\n EOF\n-if { (eval echo configure:5027: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:5018: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_sizeof_void_p=`cat conftestval`\n else\n@@ -5121,7 +5112,7 @@ EOF\n # See if gcj supports -fuse-divide-subroutine.  gcc 2.95 does not, and\n # we want to continue to support that version.\n echo $ac_n \"checking whether gcj supports -fuse-divide-subroutine\"\"... $ac_c\" 1>&6\n-echo \"configure:5125: checking whether gcj supports -fuse-divide-subroutine\" >&5\n+echo \"configure:5116: checking whether gcj supports -fuse-divide-subroutine\" >&5\n cat > conftest.java << 'END'\n public class conftest { }\n END\n@@ -5138,18 +5129,18 @@ echo \"$ac_t\"\"$use_fuse\" 1>&6\n \n \n echo $ac_n \"checking for g++ -ffloat-store bug\"\"... $ac_c\" 1>&6\n-echo \"configure:5142: checking for g++ -ffloat-store bug\" >&5\n+echo \"configure:5133: checking for g++ -ffloat-store bug\" >&5\n save_CFLAGS=\"$CFLAGS\"\n CFLAGS=\"-x c++ -O2 -ffloat-store\"\n cat > conftest.$ac_ext <<EOF\n-#line 5146 \"configure\"\n+#line 5137 \"configure\"\n #include \"confdefs.h\"\n #include <math.h>\n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:5153: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:5144: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   echo \"$ac_t\"\"no\" 1>&6\n else\n@@ -5169,17 +5160,17 @@ for ac_hdr in unistd.h bstring.h sys/time.h sys/types.h fcntl.h sys/ioctl.h sys/\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:5173: checking for $ac_hdr\" >&5\n+echo \"configure:5164: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5178 \"configure\"\n+#line 5169 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:5183: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:5174: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -5209,17 +5200,17 @@ for ac_hdr in dirent.h\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:5213: checking for $ac_hdr\" >&5\n+echo \"configure:5204: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5218 \"configure\"\n+#line 5209 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:5223: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:5214: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -5247,20 +5238,20 @@ done\n \n \n echo $ac_n \"checking for ANSI C header files\"\"... $ac_c\" 1>&6\n-echo \"configure:5251: checking for ANSI C header files\" >&5\n+echo \"configure:5242: checking for ANSI C header files\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_stdc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5256 \"configure\"\n+#line 5247 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n #include <stdarg.h>\n #include <string.h>\n #include <float.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:5264: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:5255: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -5277,7 +5268,7 @@ rm -f conftest*\n if test $ac_cv_header_stdc = yes; then\n   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 5281 \"configure\"\n+#line 5272 \"configure\"\n #include \"confdefs.h\"\n #include <string.h>\n EOF\n@@ -5295,7 +5286,7 @@ fi\n if test $ac_cv_header_stdc = yes; then\n   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 5299 \"configure\"\n+#line 5290 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n@@ -5316,7 +5307,7 @@ if test \"$cross_compiling\" = yes; then\n   :\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5320 \"configure\"\n+#line 5311 \"configure\"\n #include \"confdefs.h\"\n #include <ctype.h>\n #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')\n@@ -5327,7 +5318,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);\n exit (0); }\n \n EOF\n-if { (eval echo configure:5331: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:5322: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   :\n else\n@@ -5351,12 +5342,12 @@ EOF\n fi\n \n echo $ac_n \"checking for ssize_t\"\"... $ac_c\" 1>&6\n-echo \"configure:5355: checking for ssize_t\" >&5\n+echo \"configure:5346: checking for ssize_t\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_type_ssize_t'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5360 \"configure\"\n+#line 5351 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #if STDC_HEADERS\n@@ -5385,9 +5376,9 @@ fi\n \n \n echo $ac_n \"checking for in_addr_t\"\"... $ac_c\" 1>&6\n-echo \"configure:5389: checking for in_addr_t\" >&5\n+echo \"configure:5380: checking for in_addr_t\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 5391 \"configure\"\n+#line 5382 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #if STDC_HEADERS\n@@ -5401,7 +5392,7 @@ int main() {\n in_addr_t foo;\n ; return 0; }\n EOF\n-if { (eval echo configure:5405: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:5396: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_IN_ADDR_T 1\n@@ -5417,16 +5408,16 @@ fi\n rm -f conftest*\n \n echo $ac_n \"checking whether struct ip_mreq is in netinet/in.h\"\"... $ac_c\" 1>&6\n-echo \"configure:5421: checking whether struct ip_mreq is in netinet/in.h\" >&5\n+echo \"configure:5412: checking whether struct ip_mreq is in netinet/in.h\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 5423 \"configure\"\n+#line 5414 \"configure\"\n #include \"confdefs.h\"\n #include <netinet/in.h>\n int main() {\n struct ip_mreq mreq;\n ; return 0; }\n EOF\n-if { (eval echo configure:5430: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:5421: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_STRUCT_IP_MREQ 1\n@@ -5442,16 +5433,16 @@ fi\n rm -f conftest*\n \n echo $ac_n \"checking whether struct sockaddr_in6 is in netinet/in.h\"\"... $ac_c\" 1>&6\n-echo \"configure:5446: checking whether struct sockaddr_in6 is in netinet/in.h\" >&5\n+echo \"configure:5437: checking whether struct sockaddr_in6 is in netinet/in.h\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 5448 \"configure\"\n+#line 5439 \"configure\"\n #include \"confdefs.h\"\n #include <netinet/in.h>\n int main() {\n struct sockaddr_in6 addr6;\n ; return 0; }\n EOF\n-if { (eval echo configure:5455: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:5446: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_INET6 1\n@@ -5467,17 +5458,17 @@ fi\n rm -f conftest*\n \n echo $ac_n \"checking for socklen_t in sys/socket.h\"\"... $ac_c\" 1>&6\n-echo \"configure:5471: checking for socklen_t in sys/socket.h\" >&5\n+echo \"configure:5462: checking for socklen_t in sys/socket.h\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 5473 \"configure\"\n+#line 5464 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/socket.h>\n int main() {\n socklen_t x = 5;\n ; return 0; }\n EOF\n-if { (eval echo configure:5481: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:5472: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_SOCKLEN_T 1\n@@ -5493,16 +5484,16 @@ fi\n rm -f conftest*\n \n echo $ac_n \"checking for tm_gmtoff in struct tm\"\"... $ac_c\" 1>&6\n-echo \"configure:5497: checking for tm_gmtoff in struct tm\" >&5\n+echo \"configure:5488: checking for tm_gmtoff in struct tm\" >&5\n cat > conftest.$ac_ext <<EOF\n-#line 5499 \"configure\"\n+#line 5490 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n int main() {\n struct tm tim; tim.tm_gmtoff = 0;\n ; return 0; }\n EOF\n-if { (eval echo configure:5506: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:5497: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define STRUCT_TM_HAS_GMTOFF 1\n@@ -5515,16 +5506,16 @@ else\n   rm -rf conftest*\n   echo \"$ac_t\"\"no\" 1>&6\n    echo $ac_n \"checking for global timezone variable\"\"... $ac_c\" 1>&6\n-echo \"configure:5519: checking for global timezone variable\" >&5\n+echo \"configure:5510: checking for global timezone variable\" >&5\n             cat > conftest.$ac_ext <<EOF\n-#line 5521 \"configure\"\n+#line 5512 \"configure\"\n #include \"confdefs.h\"\n #include <time.h>\n int main() {\n long z2 = timezone;\n ; return 0; }\n EOF\n-if { (eval echo configure:5528: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:5519: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<\\EOF\n #define HAVE_TIMEZONE 1\n@@ -5544,19 +5535,19 @@ rm -f conftest*\n # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works\n # for constant arguments.  Useless!\n echo $ac_n \"checking for working alloca.h\"\"... $ac_c\" 1>&6\n-echo \"configure:5548: checking for working alloca.h\" >&5\n+echo \"configure:5539: checking for working alloca.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_alloca_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5553 \"configure\"\n+#line 5544 \"configure\"\n #include \"confdefs.h\"\n #include <alloca.h>\n int main() {\n-char *p = alloca(2 * sizeof(int));\n+void *p = alloca(2 * sizeof(int));\n ; return 0; }\n EOF\n-if { (eval echo configure:5560: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:5551: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_header_alloca_h=yes\n else\n@@ -5577,12 +5568,12 @@ EOF\n fi\n \n echo $ac_n \"checking for alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:5581: checking for alloca\" >&5\n+echo \"configure:5572: checking for alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_alloca_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5586 \"configure\"\n+#line 5577 \"configure\"\n #include \"confdefs.h\"\n \n #ifdef __GNUC__\n@@ -5610,7 +5601,7 @@ int main() {\n char *p = (char *) alloca(1);\n ; return 0; }\n EOF\n-if { (eval echo configure:5614: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:5605: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_func_alloca_works=yes\n else\n@@ -5642,12 +5633,12 @@ EOF\n \n \n echo $ac_n \"checking whether alloca needs Cray hooks\"\"... $ac_c\" 1>&6\n-echo \"configure:5646: checking whether alloca needs Cray hooks\" >&5\n+echo \"configure:5637: checking whether alloca needs Cray hooks\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_os_cray'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5651 \"configure\"\n+#line 5642 \"configure\"\n #include \"confdefs.h\"\n #if defined(CRAY) && ! defined(CRAY2)\n webecray\n@@ -5672,12 +5663,12 @@ echo \"$ac_t\"\"$ac_cv_os_cray\" 1>&6\n if test $ac_cv_os_cray = yes; then\n for ac_func in _getb67 GETB67 getb67; do\n   echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:5676: checking for $ac_func\" >&5\n+echo \"configure:5667: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5681 \"configure\"\n+#line 5672 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -5700,7 +5691,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:5704: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:5695: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -5727,15 +5718,15 @@ done\n fi\n \n echo $ac_n \"checking stack direction for C alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:5731: checking stack direction for C alloca\" >&5\n+echo \"configure:5722: checking stack direction for C alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_stack_direction'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_c_stack_direction=0\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 5739 \"configure\"\n+#line 5730 \"configure\"\n #include \"confdefs.h\"\n find_stack_direction ()\n {\n@@ -5754,7 +5745,7 @@ main ()\n   exit (find_stack_direction() < 0);\n }\n EOF\n-if { (eval echo configure:5758: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:5749: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_stack_direction=1\n else\n@@ -5781,7 +5772,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:5785: checking for $ac_word\" >&5\n+echo \"configure:5776: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_PERL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -5845,6 +5836,851 @@ else\n   multilib_arg=\n fi\n \n+# If we find X, set shell vars x_includes and x_libraries to the\n+# paths, otherwise set no_x=yes.\n+# Uses ac_ vars as temps to allow command line to override cache and checks.\n+# --without-x overrides everything else, but does not touch the cache.\n+echo $ac_n \"checking for X\"\"... $ac_c\" 1>&6\n+echo \"configure:5845: checking for X\" >&5\n+\n+# Check whether --with-x or --without-x was given.\n+if test \"${with_x+set}\" = set; then\n+  withval=\"$with_x\"\n+  :\n+fi\n+\n+# $have_x is `yes', `no', `disabled', or empty when we do not yet know.\n+if test \"x$with_x\" = xno; then\n+  # The user explicitly disabled X.\n+  have_x=disabled\n+else\n+  if test \"x$x_includes\" != xNONE && test \"x$x_libraries\" != xNONE; then\n+    # Both variables are already set.\n+    have_x=yes\n+  else\n+if eval \"test \\\"`echo '$''{'ac_cv_have_x'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  # One or both of the vars are not set, and there is no cached value.\n+ac_x_includes=NO ac_x_libraries=NO\n+rm -fr conftestdir\n+if mkdir conftestdir; then\n+  cd conftestdir\n+  # Make sure to not put \"make\" in the Imakefile rules, since we grep it out.\n+  cat > Imakefile <<'EOF'\n+acfindx:\n+\t@echo 'ac_im_incroot=\"${INCROOT}\"; ac_im_usrlibdir=\"${USRLIBDIR}\"; ac_im_libdir=\"${LIBDIR}\"'\n+EOF\n+  if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then\n+    # GNU make sometimes prints \"make[1]: Entering...\", which would confuse us.\n+    eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`\n+    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.\n+    for ac_extension in a so sl; do\n+      if test ! -f $ac_im_usrlibdir/libX11.$ac_extension &&\n+        test -f $ac_im_libdir/libX11.$ac_extension; then\n+        ac_im_usrlibdir=$ac_im_libdir; break\n+      fi\n+    done\n+    # Screen out bogus values from the imake configuration.  They are\n+    # bogus both because they are the default anyway, and because\n+    # using them would break gcc on systems where it needs fixed includes.\n+    case \"$ac_im_incroot\" in\n+\t/usr/include) ;;\n+\t*) test -f \"$ac_im_incroot/X11/Xos.h\" && ac_x_includes=\"$ac_im_incroot\" ;;\n+    esac\n+    case \"$ac_im_usrlibdir\" in\n+\t/usr/lib | /lib) ;;\n+\t*) test -d \"$ac_im_usrlibdir\" && ac_x_libraries=\"$ac_im_usrlibdir\" ;;\n+    esac\n+  fi\n+  cd ..\n+  rm -fr conftestdir\n+fi\n+\n+if test \"$ac_x_includes\" = NO; then\n+  # Guess where to find include files, by looking for this one X11 .h file.\n+  test -z \"$x_direct_test_include\" && x_direct_test_include=X11/Intrinsic.h\n+\n+  # First, try using that file with no special directory specified.\n+cat > conftest.$ac_ext <<EOF\n+#line 5907 \"configure\"\n+#include \"confdefs.h\"\n+#include <$x_direct_test_include>\n+EOF\n+ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n+{ (eval echo configure:5912: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n+if test -z \"$ac_err\"; then\n+  rm -rf conftest*\n+  # We can compile using X headers with no special include directory.\n+ac_x_includes=\n+else\n+  echo \"$ac_err\" >&5\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  # Look for the header file in a standard set of common directories.\n+# Check X11 before X11Rn because it is often a symlink to the current release.\n+  for ac_dir in               \\\n+    /usr/X11/include          \\\n+    /usr/X11R6/include        \\\n+    /usr/X11R5/include        \\\n+    /usr/X11R4/include        \\\n+                              \\\n+    /usr/include/X11          \\\n+    /usr/include/X11R6        \\\n+    /usr/include/X11R5        \\\n+    /usr/include/X11R4        \\\n+                              \\\n+    /usr/local/X11/include    \\\n+    /usr/local/X11R6/include  \\\n+    /usr/local/X11R5/include  \\\n+    /usr/local/X11R4/include  \\\n+                              \\\n+    /usr/local/include/X11    \\\n+    /usr/local/include/X11R6  \\\n+    /usr/local/include/X11R5  \\\n+    /usr/local/include/X11R4  \\\n+                              \\\n+    /usr/X386/include         \\\n+    /usr/x386/include         \\\n+    /usr/XFree86/include/X11  \\\n+                              \\\n+    /usr/include              \\\n+    /usr/local/include        \\\n+    /usr/unsupported/include  \\\n+    /usr/athena/include       \\\n+    /usr/local/x11r5/include  \\\n+    /usr/lpp/Xamples/include  \\\n+                              \\\n+    /usr/openwin/include      \\\n+    /usr/openwin/share/include \\\n+    ; \\\n+  do\n+    if test -r \"$ac_dir/$x_direct_test_include\"; then\n+      ac_x_includes=$ac_dir\n+      break\n+    fi\n+  done\n+fi\n+rm -f conftest*\n+fi # $ac_x_includes = NO\n+\n+if test \"$ac_x_libraries\" = NO; then\n+  # Check for the libraries.\n+\n+  test -z \"$x_direct_test_library\" && x_direct_test_library=Xt\n+  test -z \"$x_direct_test_function\" && x_direct_test_function=XtMalloc\n+\n+  # See if we find them without any special options.\n+  # Don't add to $LIBS permanently.\n+  ac_save_LIBS=\"$LIBS\"\n+  LIBS=\"-l$x_direct_test_library $LIBS\"\n+cat > conftest.$ac_ext <<EOF\n+#line 5981 \"configure\"\n+#include \"confdefs.h\"\n+\n+int main() {\n+${x_direct_test_function}()\n+; return 0; }\n+EOF\n+if { (eval echo configure:5988: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  LIBS=\"$ac_save_LIBS\"\n+# We can link X programs with no special library path.\n+ac_x_libraries=\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  LIBS=\"$ac_save_LIBS\"\n+# First see if replacing the include by lib works.\n+# Check X11 before X11Rn because it is often a symlink to the current release.\n+for ac_dir in `echo \"$ac_x_includes\" | sed s/include/lib/` \\\n+    /usr/X11/lib          \\\n+    /usr/X11R6/lib        \\\n+    /usr/X11R5/lib        \\\n+    /usr/X11R4/lib        \\\n+                          \\\n+    /usr/lib/X11          \\\n+    /usr/lib/X11R6        \\\n+    /usr/lib/X11R5        \\\n+    /usr/lib/X11R4        \\\n+                          \\\n+    /usr/local/X11/lib    \\\n+    /usr/local/X11R6/lib  \\\n+    /usr/local/X11R5/lib  \\\n+    /usr/local/X11R4/lib  \\\n+                          \\\n+    /usr/local/lib/X11    \\\n+    /usr/local/lib/X11R6  \\\n+    /usr/local/lib/X11R5  \\\n+    /usr/local/lib/X11R4  \\\n+                          \\\n+    /usr/X386/lib         \\\n+    /usr/x386/lib         \\\n+    /usr/XFree86/lib/X11  \\\n+                          \\\n+    /usr/lib              \\\n+    /usr/local/lib        \\\n+    /usr/unsupported/lib  \\\n+    /usr/athena/lib       \\\n+    /usr/local/x11r5/lib  \\\n+    /usr/lpp/Xamples/lib  \\\n+    /lib/usr/lib/X11\t  \\\n+                          \\\n+    /usr/openwin/lib      \\\n+    /usr/openwin/share/lib \\\n+    ; \\\n+do\n+  for ac_extension in a so sl; do\n+    if test -r $ac_dir/lib${x_direct_test_library}.$ac_extension; then\n+      ac_x_libraries=$ac_dir\n+      break 2\n+    fi\n+  done\n+done\n+fi\n+rm -f conftest*\n+fi # $ac_x_libraries = NO\n+\n+if test \"$ac_x_includes\" = NO || test \"$ac_x_libraries\" = NO; then\n+  # Didn't find X anywhere.  Cache the known absence of X.\n+  ac_cv_have_x=\"have_x=no\"\n+else\n+  # Record where we found X for the cache.\n+  ac_cv_have_x=\"have_x=yes \\\n+\t        ac_x_includes=$ac_x_includes ac_x_libraries=$ac_x_libraries\"\n+fi\n+fi\n+  fi\n+  eval \"$ac_cv_have_x\"\n+fi # $with_x != no\n+\n+if test \"$have_x\" != yes; then\n+  echo \"$ac_t\"\"$have_x\" 1>&6\n+  no_x=yes\n+else\n+  # If each of the values was on the command line, it overrides each guess.\n+  test \"x$x_includes\" = xNONE && x_includes=$ac_x_includes\n+  test \"x$x_libraries\" = xNONE && x_libraries=$ac_x_libraries\n+  # Update the cache value to reflect the command line values.\n+  ac_cv_have_x=\"have_x=yes \\\n+\t\tac_x_includes=$x_includes ac_x_libraries=$x_libraries\"\n+  echo \"$ac_t\"\"libraries $x_libraries, headers $x_includes\" 1>&6\n+fi\n+\n+if test \"$no_x\" = yes; then\n+  # Not all programs may use this symbol, but it does not hurt to define it.\n+  cat >> confdefs.h <<\\EOF\n+#define X_DISPLAY_MISSING 1\n+EOF\n+\n+  X_CFLAGS= X_PRE_LIBS= X_LIBS= X_EXTRA_LIBS=\n+else\n+  if test -n \"$x_includes\"; then\n+    X_CFLAGS=\"$X_CFLAGS -I$x_includes\"\n+  fi\n+\n+  # It would also be nice to do this for all -L options, not just this one.\n+  if test -n \"$x_libraries\"; then\n+    X_LIBS=\"$X_LIBS -L$x_libraries\"\n+    # For Solaris; some versions of Sun CC require a space after -R and\n+    # others require no space.  Words are not sufficient . . . .\n+    case \"`(uname -sr) 2>/dev/null`\" in\n+    \"SunOS 5\"*)\n+      echo $ac_n \"checking whether -R must be followed by a space\"\"... $ac_c\" 1>&6\n+echo \"configure:6094: checking whether -R must be followed by a space\" >&5\n+      ac_xsave_LIBS=\"$LIBS\"; LIBS=\"$LIBS -R$x_libraries\"\n+      cat > conftest.$ac_ext <<EOF\n+#line 6097 \"configure\"\n+#include \"confdefs.h\"\n+\n+int main() {\n+\n+; return 0; }\n+EOF\n+if { (eval echo configure:6104: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  ac_R_nospace=yes\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  ac_R_nospace=no\n+fi\n+rm -f conftest*\n+      if test $ac_R_nospace = yes; then\n+\techo \"$ac_t\"\"no\" 1>&6\n+\tX_LIBS=\"$X_LIBS -R$x_libraries\"\n+      else\n+\tLIBS=\"$ac_xsave_LIBS -R $x_libraries\"\n+\tcat > conftest.$ac_ext <<EOF\n+#line 6120 \"configure\"\n+#include \"confdefs.h\"\n+\n+int main() {\n+\n+; return 0; }\n+EOF\n+if { (eval echo configure:6127: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  ac_R_space=yes\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  ac_R_space=no\n+fi\n+rm -f conftest*\n+\tif test $ac_R_space = yes; then\n+\t  echo \"$ac_t\"\"yes\" 1>&6\n+\t  X_LIBS=\"$X_LIBS -R $x_libraries\"\n+\telse\n+\t  echo \"$ac_t\"\"neither works\" 1>&6\n+\tfi\n+      fi\n+      LIBS=\"$ac_xsave_LIBS\"\n+    esac\n+  fi\n+\n+  # Check for system-dependent libraries X programs must link with.\n+  # Do this before checking for the system-independent R6 libraries\n+  # (-lICE), since we may need -lsocket or whatever for X linking.\n+\n+  if test \"$ISC\" = yes; then\n+    X_EXTRA_LIBS=\"$X_EXTRA_LIBS -lnsl_s -linet\"\n+  else\n+    # Martyn.Johnson@cl.cam.ac.uk says this is needed for Ultrix, if the X\n+    # libraries were built with DECnet support.  And karl@cs.umb.edu says\n+    # the Alpha needs dnet_stub (dnet does not exist).\n+    echo $ac_n \"checking for dnet_ntoa in -ldnet\"\"... $ac_c\" 1>&6\n+echo \"configure:6159: checking for dnet_ntoa in -ldnet\" >&5\n+ac_lib_var=`echo dnet'_'dnet_ntoa | sed 'y%./+-%__p_%'`\n+if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  ac_save_LIBS=\"$LIBS\"\n+LIBS=\"-ldnet  $LIBS\"\n+cat > conftest.$ac_ext <<EOF\n+#line 6167 \"configure\"\n+#include \"confdefs.h\"\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char dnet_ntoa();\n+\n+int main() {\n+dnet_ntoa()\n+; return 0; }\n+EOF\n+if { (eval echo configure:6178: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=no\"\n+fi\n+rm -f conftest*\n+LIBS=\"$ac_save_LIBS\"\n+\n+fi\n+if eval \"test \\\"`echo '$ac_cv_lib_'$ac_lib_var`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  X_EXTRA_LIBS=\"$X_EXTRA_LIBS -ldnet\"\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+    if test $ac_cv_lib_dnet_dnet_ntoa = no; then\n+      echo $ac_n \"checking for dnet_ntoa in -ldnet_stub\"\"... $ac_c\" 1>&6\n+echo \"configure:6200: checking for dnet_ntoa in -ldnet_stub\" >&5\n+ac_lib_var=`echo dnet_stub'_'dnet_ntoa | sed 'y%./+-%__p_%'`\n+if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  ac_save_LIBS=\"$LIBS\"\n+LIBS=\"-ldnet_stub  $LIBS\"\n+cat > conftest.$ac_ext <<EOF\n+#line 6208 \"configure\"\n+#include \"confdefs.h\"\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char dnet_ntoa();\n+\n+int main() {\n+dnet_ntoa()\n+; return 0; }\n+EOF\n+if { (eval echo configure:6219: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=no\"\n+fi\n+rm -f conftest*\n+LIBS=\"$ac_save_LIBS\"\n+\n+fi\n+if eval \"test \\\"`echo '$ac_cv_lib_'$ac_lib_var`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  X_EXTRA_LIBS=\"$X_EXTRA_LIBS -ldnet_stub\"\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+    fi\n+\n+    # msh@cis.ufl.edu says -lnsl (and -lsocket) are needed for his 386/AT,\n+    # to get the SysV transport functions.\n+    # chad@anasazi.com says the Pyramis MIS-ES running DC/OSx (SVR4)\n+    # needs -lnsl.\n+    # The nsl library prevents programs from opening the X display\n+    # on Irix 5.2, according to dickey@clark.net.\n+    echo $ac_n \"checking for gethostbyname\"\"... $ac_c\" 1>&6\n+echo \"configure:6248: checking for gethostbyname\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 6253 \"configure\"\n+#include \"confdefs.h\"\n+/* System header to define __stub macros and hopefully few prototypes,\n+    which can conflict with char gethostbyname(); below.  */\n+#include <assert.h>\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char gethostbyname();\n+\n+int main() {\n+\n+/* The GNU C library defines this for functions which it implements\n+    to always fail with ENOSYS.  Some functions are actually named\n+    something starting with __ and the normal name is an alias.  */\n+#if defined (__stub_gethostbyname) || defined (__stub___gethostbyname)\n+choke me\n+#else\n+gethostbyname();\n+#endif\n+\n+; return 0; }\n+EOF\n+if { (eval echo configure:6276: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_func_gethostbyname=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_func_gethostbyname=no\"\n+fi\n+rm -f conftest*\n+fi\n+\n+if eval \"test \\\"`echo '$ac_cv_func_'gethostbyname`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  :\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+    if test $ac_cv_func_gethostbyname = no; then\n+      echo $ac_n \"checking for gethostbyname in -lnsl\"\"... $ac_c\" 1>&6\n+echo \"configure:6297: checking for gethostbyname in -lnsl\" >&5\n+ac_lib_var=`echo nsl'_'gethostbyname | sed 'y%./+-%__p_%'`\n+if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  ac_save_LIBS=\"$LIBS\"\n+LIBS=\"-lnsl  $LIBS\"\n+cat > conftest.$ac_ext <<EOF\n+#line 6305 \"configure\"\n+#include \"confdefs.h\"\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char gethostbyname();\n+\n+int main() {\n+gethostbyname()\n+; return 0; }\n+EOF\n+if { (eval echo configure:6316: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=no\"\n+fi\n+rm -f conftest*\n+LIBS=\"$ac_save_LIBS\"\n+\n+fi\n+if eval \"test \\\"`echo '$ac_cv_lib_'$ac_lib_var`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  X_EXTRA_LIBS=\"$X_EXTRA_LIBS -lnsl\"\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+    fi\n+\n+    # lieder@skyler.mavd.honeywell.com says without -lsocket,\n+    # socket/setsockopt and other routines are undefined under SCO ODT\n+    # 2.0.  But -lsocket is broken on IRIX 5.2 (and is not necessary\n+    # on later versions), says simon@lia.di.epfl.ch: it contains\n+    # gethostby* variants that don't use the nameserver (or something).\n+    # -lsocket must be given before -lnsl if both are needed.\n+    # We assume that if connect needs -lnsl, so does gethostbyname.\n+    echo $ac_n \"checking for connect\"\"... $ac_c\" 1>&6\n+echo \"configure:6346: checking for connect\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_connect'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 6351 \"configure\"\n+#include \"confdefs.h\"\n+/* System header to define __stub macros and hopefully few prototypes,\n+    which can conflict with char connect(); below.  */\n+#include <assert.h>\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char connect();\n+\n+int main() {\n+\n+/* The GNU C library defines this for functions which it implements\n+    to always fail with ENOSYS.  Some functions are actually named\n+    something starting with __ and the normal name is an alias.  */\n+#if defined (__stub_connect) || defined (__stub___connect)\n+choke me\n+#else\n+connect();\n+#endif\n+\n+; return 0; }\n+EOF\n+if { (eval echo configure:6374: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_func_connect=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_func_connect=no\"\n+fi\n+rm -f conftest*\n+fi\n+\n+if eval \"test \\\"`echo '$ac_cv_func_'connect`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  :\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+    if test $ac_cv_func_connect = no; then\n+      echo $ac_n \"checking for connect in -lsocket\"\"... $ac_c\" 1>&6\n+echo \"configure:6395: checking for connect in -lsocket\" >&5\n+ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`\n+if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  ac_save_LIBS=\"$LIBS\"\n+LIBS=\"-lsocket $X_EXTRA_LIBS $LIBS\"\n+cat > conftest.$ac_ext <<EOF\n+#line 6403 \"configure\"\n+#include \"confdefs.h\"\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char connect();\n+\n+int main() {\n+connect()\n+; return 0; }\n+EOF\n+if { (eval echo configure:6414: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=no\"\n+fi\n+rm -f conftest*\n+LIBS=\"$ac_save_LIBS\"\n+\n+fi\n+if eval \"test \\\"`echo '$ac_cv_lib_'$ac_lib_var`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  X_EXTRA_LIBS=\"-lsocket $X_EXTRA_LIBS\"\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+    fi\n+\n+    # gomez@mi.uni-erlangen.de says -lposix is necessary on A/UX.\n+    echo $ac_n \"checking for remove\"\"... $ac_c\" 1>&6\n+echo \"configure:6438: checking for remove\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_remove'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 6443 \"configure\"\n+#include \"confdefs.h\"\n+/* System header to define __stub macros and hopefully few prototypes,\n+    which can conflict with char remove(); below.  */\n+#include <assert.h>\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char remove();\n+\n+int main() {\n+\n+/* The GNU C library defines this for functions which it implements\n+    to always fail with ENOSYS.  Some functions are actually named\n+    something starting with __ and the normal name is an alias.  */\n+#if defined (__stub_remove) || defined (__stub___remove)\n+choke me\n+#else\n+remove();\n+#endif\n+\n+; return 0; }\n+EOF\n+if { (eval echo configure:6466: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_func_remove=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_func_remove=no\"\n+fi\n+rm -f conftest*\n+fi\n+\n+if eval \"test \\\"`echo '$ac_cv_func_'remove`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  :\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+    if test $ac_cv_func_remove = no; then\n+      echo $ac_n \"checking for remove in -lposix\"\"... $ac_c\" 1>&6\n+echo \"configure:6487: checking for remove in -lposix\" >&5\n+ac_lib_var=`echo posix'_'remove | sed 'y%./+-%__p_%'`\n+if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  ac_save_LIBS=\"$LIBS\"\n+LIBS=\"-lposix  $LIBS\"\n+cat > conftest.$ac_ext <<EOF\n+#line 6495 \"configure\"\n+#include \"confdefs.h\"\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char remove();\n+\n+int main() {\n+remove()\n+; return 0; }\n+EOF\n+if { (eval echo configure:6506: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=no\"\n+fi\n+rm -f conftest*\n+LIBS=\"$ac_save_LIBS\"\n+\n+fi\n+if eval \"test \\\"`echo '$ac_cv_lib_'$ac_lib_var`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  X_EXTRA_LIBS=\"$X_EXTRA_LIBS -lposix\"\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+    fi\n+\n+    # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.\n+    echo $ac_n \"checking for shmat\"\"... $ac_c\" 1>&6\n+echo \"configure:6530: checking for shmat\" >&5\n+if eval \"test \\\"`echo '$''{'ac_cv_func_shmat'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  cat > conftest.$ac_ext <<EOF\n+#line 6535 \"configure\"\n+#include \"confdefs.h\"\n+/* System header to define __stub macros and hopefully few prototypes,\n+    which can conflict with char shmat(); below.  */\n+#include <assert.h>\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char shmat();\n+\n+int main() {\n+\n+/* The GNU C library defines this for functions which it implements\n+    to always fail with ENOSYS.  Some functions are actually named\n+    something starting with __ and the normal name is an alias.  */\n+#if defined (__stub_shmat) || defined (__stub___shmat)\n+choke me\n+#else\n+shmat();\n+#endif\n+\n+; return 0; }\n+EOF\n+if { (eval echo configure:6558: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_func_shmat=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_func_shmat=no\"\n+fi\n+rm -f conftest*\n+fi\n+\n+if eval \"test \\\"`echo '$ac_cv_func_'shmat`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  :\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+    if test $ac_cv_func_shmat = no; then\n+      echo $ac_n \"checking for shmat in -lipc\"\"... $ac_c\" 1>&6\n+echo \"configure:6579: checking for shmat in -lipc\" >&5\n+ac_lib_var=`echo ipc'_'shmat | sed 'y%./+-%__p_%'`\n+if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  ac_save_LIBS=\"$LIBS\"\n+LIBS=\"-lipc  $LIBS\"\n+cat > conftest.$ac_ext <<EOF\n+#line 6587 \"configure\"\n+#include \"confdefs.h\"\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char shmat();\n+\n+int main() {\n+shmat()\n+; return 0; }\n+EOF\n+if { (eval echo configure:6598: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=no\"\n+fi\n+rm -f conftest*\n+LIBS=\"$ac_save_LIBS\"\n+\n+fi\n+if eval \"test \\\"`echo '$ac_cv_lib_'$ac_lib_var`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  X_EXTRA_LIBS=\"$X_EXTRA_LIBS -lipc\"\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+    fi\n+  fi\n+\n+  # Check for libraries that X11R6 Xt/Xaw programs need.\n+  ac_save_LDFLAGS=\"$LDFLAGS\"\n+  test -n \"$x_libraries\" && LDFLAGS=\"$LDFLAGS -L$x_libraries\"\n+  # SM needs ICE to (dynamically) link under SunOS 4.x (so we have to\n+  # check for ICE first), but we must link in the order -lSM -lICE or\n+  # we get undefined symbols.  So assume we have SM if we have ICE.\n+  # These have to be linked with before -lX11, unlike the other\n+  # libraries we check for below, so use a different variable.\n+  #  --interran@uluru.Stanford.EDU, kb@cs.umb.edu.\n+  echo $ac_n \"checking for IceConnectionNumber in -lICE\"\"... $ac_c\" 1>&6\n+echo \"configure:6631: checking for IceConnectionNumber in -lICE\" >&5\n+ac_lib_var=`echo ICE'_'IceConnectionNumber | sed 'y%./+-%__p_%'`\n+if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n+  echo $ac_n \"(cached) $ac_c\" 1>&6\n+else\n+  ac_save_LIBS=\"$LIBS\"\n+LIBS=\"-lICE $X_EXTRA_LIBS $LIBS\"\n+cat > conftest.$ac_ext <<EOF\n+#line 6639 \"configure\"\n+#include \"confdefs.h\"\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+/* We use char because int might match the return type of a gcc2\n+    builtin and then its argument prototype would still apply.  */\n+char IceConnectionNumber();\n+\n+int main() {\n+IceConnectionNumber()\n+; return 0; }\n+EOF\n+if { (eval echo configure:6650: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=yes\"\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  eval \"ac_cv_lib_$ac_lib_var=no\"\n+fi\n+rm -f conftest*\n+LIBS=\"$ac_save_LIBS\"\n+\n+fi\n+if eval \"test \\\"`echo '$ac_cv_lib_'$ac_lib_var`\\\" = yes\"; then\n+  echo \"$ac_t\"\"yes\" 1>&6\n+  X_PRE_LIBS=\"$X_PRE_LIBS -lSM -lICE\"\n+else\n+  echo \"$ac_t\"\"no\" 1>&6\n+fi\n+\n+  LDFLAGS=\"$ac_save_LDFLAGS\"\n+\n+fi\n+\n+\n+\n+\n+if test \"$no_x\" = yes; then\n+  NO_X_TRUE=\n+  NO_X_FALSE='#'\n+else\n+  NO_X_TRUE='#'\n+  NO_X_FALSE=\n+fi\n+\n here=`pwd`\n \n \n@@ -6076,6 +6912,12 @@ s%@AM_RUNTESTFLAGS@%$AM_RUNTESTFLAGS%g\n s%@ALLOCA@%$ALLOCA%g\n s%@PERL@%$PERL%g\n s%@SYSDEP_SOURCES@%$SYSDEP_SOURCES%g\n+s%@X_CFLAGS@%$X_CFLAGS%g\n+s%@X_PRE_LIBS@%$X_PRE_LIBS%g\n+s%@X_LIBS@%$X_LIBS%g\n+s%@X_EXTRA_LIBS@%$X_EXTRA_LIBS%g\n+s%@NO_X_TRUE@%$NO_X_TRUE%g\n+s%@NO_X_FALSE@%$NO_X_FALSE%g\n s%@here@%$here%g\n \n CEOF"}, {"sha": "81f0d09ef2382bb081324d102a23f611db89daff", "filename": "libjava/configure.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -762,6 +762,10 @@ else\n   multilib_arg=\n fi\n \n+AC_PATH_XTRA\n+\n+AM_CONDITIONAL(NO_X, test \"$no_x\" = yes)\n+\n here=`pwd`\n AC_SUBST(here)\n "}, {"sha": "a0ea7bcff4bbba4ebc6994e0057d69d80f6b5688", "filename": "libjava/gnu/awt/LightweightRedirector.java", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2FLightweightRedirector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2FLightweightRedirector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2FLightweightRedirector.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,183 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt;\n+\n+import java.awt.AWTEvent;\n+import java.awt.AWTError;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.InputEvent;\n+\n+/**\n+ * Encapsulates the logic required to dispatch events to the correct\n+ * component in a component tree that may contain lightweight\n+ * components. Toolkits typically only identify heavyweight components\n+ * as the source of events. This class redirects the events to the\n+ * appropriate lightweight children of the heavyweight component.\n+ */\n+public class LightweightRedirector\n+{\n+  final static int LAST_BUTTON_NUMBER = 3;\n+\n+  /* We sacrifice one array element to allow the button number to \n+     match the index of this array. */\n+  Component[] releaseTargets = new Component[LAST_BUTTON_NUMBER+1];\n+\n+  /** \n+   *\n+   * Modifies or replaces the given event with an event that has been\n+   * properly redirected.  State of button presses are kept so that\n+   * button releases can be redirected to the same component as the\n+   * button press.  It is required that all events are sent through\n+   * this method in chronological order.\n+   */\n+  public AWTEvent redirect(AWTEvent event)\n+  {\n+    if (event instanceof MouseEvent)\n+      return redirectMouse((MouseEvent) event);\n+\n+    /* In case we don't know how to redirect the event, simply return\n+       the event unchanged. */\n+    return event;\n+  }\n+\n+  MouseEvent redirectMouse(MouseEvent event)\n+  {\n+    int button = getButtonNumber(event);\n+    int id = event.getID();\n+\n+    Component heavySource = (Component) event.getSource();\n+    Component source = heavySource;\n+    int x = event.getX();\n+    int y = event.getY();\n+\n+    if (id == MouseEvent.MOUSE_RELEASED)\n+      {\n+\tComponent target = releaseTargets[button];\n+\n+\tif (target != null)\n+\t  {\n+\t    releaseTargets[button] = null;\n+\t    source = target;\n+\n+\t    Component child = source;\n+\t    while (child != heavySource)\n+\t      {\n+\t\tx -= child.getX();\n+\t\ty -= child.getY();\n+\t\tchild = child.getParent();\n+\t\tif (child == null)\n+\t\t  System.err.println(\"warning, orphaned release target\");\n+\t      }\n+\t  }\n+      }\n+    else\n+      {\n+\t/* Find real component, and adjust source, x and y\n+\t   accordingly. */\n+\t\n+\twhile (true)\n+\t  {\n+\t    Component parent = source;\n+\t    \n+\t    Component child = parent.getComponentAt(x, y);\n+\t    \n+\t    if (parent == child)\n+\t      break;\n+\t    \n+\t    // maybe ignoring would be better?\n+\t    if (child == null)\n+\t      {\n+\t\tString msg = \"delivered event not within component. \" +\n+\t\t  \"Heavyweight source was \" + heavySource + \". \" +\n+\t\t  \"Component was \" + parent;\n+\t\tthrow new AWTError(msg);\n+\t      }\n+\t    if (child.isLightweight())\n+\t      {\n+\t\t// descend down to child\n+\t\tsource = child;\n+\t\tx -= child.getX();\n+\t\ty -= child.getY();\n+\t      }\n+\t    else\n+\t      {\n+\t\tSystem.err.println(\"warning: event delivered to wrong \" +\n+\t\t\t\t   \"heavyweight component. Was \" +\n+\t\t\t\t   \"delivered to \" + source + \". \" +\n+\t\t\t\t   \"Should have been delivered to \" +\n+\t\t\t\t   child + \". Maybe the native window \" +\n+\t\t\t\t   \"system is bubbling events up the \" +\n+\t\t\t\t   \"containment hierarchy.\");\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t\n+\t/* ensure that the release event is delivered to the same\n+\t   component as the press event. For most toolkits this is\n+\t   only necessary for lightweight components, since the\n+\t   underlying windowing system takes care of its heavyweight\n+\t   components. */\n+\tif (id == MouseEvent.MOUSE_PRESSED)\n+\t  releaseTargets[button] = source;\n+      }\n+    \n+    \n+    if (source == heavySource)\n+      return event; // no change in event\n+    \n+    // print warning for heavyweights\n+    /* this warning can safely be removed if a toolkit that\n+       needs heavyweight redirection support is ever created. */\n+    if (!source.isLightweight())\n+      System.err.println(\"warning: redirecting to heavyweight\");\n+    \n+    MouseEvent redirected = new MouseEvent(source, event.getID(),\n+\t\t\t\t\t   event.getWhen(),\n+\t\t\t\t\t   event.getModifiers(),\n+\t\t\t\t\t   x, y,\n+\t\t\t\t\t   event.getClickCount(),\n+\t\t\t\t\t   event.isPopupTrigger());\n+    \n+    return redirected;\n+  }\n+  \n+  /**\n+   * Identifies the button number for an input event.\n+   * \n+   * @returns the button number, or 0 if no button modifier was set\n+   * for the event.\n+   */\n+  int getButtonNumber(InputEvent event)\n+  {\n+    int modifiers = event.getModifiers();\n+    \n+    modifiers &=\n+      InputEvent.BUTTON1_MASK |\n+      InputEvent.BUTTON2_MASK |\n+      InputEvent.BUTTON3_MASK;\n+    \n+    switch (modifiers)\n+      {\n+      case InputEvent.BUTTON1_MASK:\n+\treturn 1;\n+      case InputEvent.BUTTON2_MASK:\n+\treturn 2;\n+      case InputEvent.BUTTON3_MASK:\n+\treturn 3;\n+      case 0:\n+\treturn 0;\n+\n+      default:\n+\tSystem.err.println(\"FIXME: multibutton event\");\n+\treturn 0;\n+      }\n+  }\n+}"}, {"sha": "e3b3ec61599c53bab16807609be0f8193040b48a", "filename": "libjava/gnu/awt/j2d/AbstractGraphicsState.java", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fj2d%2FAbstractGraphicsState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fj2d%2FAbstractGraphicsState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fj2d%2FAbstractGraphicsState.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,128 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.j2d;\n+\n+import java.awt.Color;\n+import java.awt.Image;\n+import java.awt.Shape;\n+import java.awt.Rectangle;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.image.ImageObserver;\n+\n+/**\n+ * Base class for graphics state objects (State pattern, GOF book)\n+ * that represents the current pipeline configuration. The Graphics2D\n+ * object forwards most of the requests to the state object. The\n+ * Graphics2D object itself only administers properties that are not\n+ * specific for a certain state.\n+ */\n+public abstract class AbstractGraphicsState implements Cloneable\n+{\n+  Graphics2DImpl frontend;\n+\n+  public void setFrontend(Graphics2DImpl frontend)\n+  {\n+    this.frontend = frontend;\n+  }\n+  \n+  public void dispose()\n+  {\n+    frontend = null;\n+  }\n+\n+  // -------- Graphics methods:\n+  \n+  public abstract void setColor(Color color);\n+\n+  public abstract void setPaintMode();\n+\n+  public abstract void setXORMode(Color altColor);\n+\n+  public abstract void setFont(Font font);\n+\n+  public abstract FontMetrics getFontMetrics(Font font);\n+\n+  public abstract void setClip(Shape clip);\n+\n+  public abstract Shape getClip();\n+  public abstract Rectangle getClipBounds();\n+\n+  public abstract void copyArea(int x, int y, \n+\t\t\t\tint width, int height,\n+\t\t\t\tint dx, int dy);\n+\n+  public abstract void drawLine(int x1, int y1,\n+\t\t\t\tint x2, int y2);\n+  \n+  public abstract void fillRect(int x, int y,\n+\t\t\t\tint width, int height);\n+  \n+  public abstract void clearRect(int x, int y,\n+\t\t\t\t int width, int height);\n+  \n+  public abstract void drawRoundRect(int x, int y,\n+\t\t\t\t     int width, int height,\n+\t\t\t\t     int arcWidth, int arcHeight);\n+  \n+  public abstract void fillRoundRect(int x, int y,\n+\t\t\t\t     int width, int height,\n+\t\t\t\t     int arcWidth, int arcHeight);\n+  \n+  public abstract void drawOval(int x, int y,\n+\t\t\t\tint width, int height);\n+  \n+  public abstract void fillOval(int x, int y,\n+\t\t\t\tint width, int height);\n+  \n+  public abstract void drawArc(int x, int y,\n+\t\t\t       int width, int height,\n+\t\t\t       int startAngle, int arcAngle);\n+  \n+  public abstract void fillArc(int x, int y,\n+\t\t\t       int width, int height,\n+\t\t\t       int startAngle, int arcAngle);\n+  \n+  public abstract void drawPolyline(int[] xPoints, int[] yPoints,int nPoints);\n+\n+  public abstract void drawPolygon(int[] xPoints, int[] yPoints, int nPoints);\n+    \n+  public abstract void fillPolygon(int[] xPoints, int[] yPoints, int nPoints);\n+\n+  public abstract boolean drawImage(Image image, int x, int y,\n+\t\t\t\t    ImageObserver observer);\n+    \n+\n+  // -------- Graphics2D methods:\n+\n+  public abstract void draw(Shape shape);\n+\n+  public abstract void fill(Shape shape);\n+    \n+  public abstract boolean hit(Rectangle rect, Shape text, boolean onStroke);\n+  \n+  public abstract void drawString(String text, int x, int y);\n+  \n+  public abstract void drawString(String text, float x, float y);\n+  \n+  public abstract void translate(int x, int y);\n+  \n+  public abstract void translate(double tx, double ty);\n+  \n+  public abstract void rotate(double theta);\n+  \n+  public abstract void rotate(double theta, double x, double y);\n+  \n+  public abstract void scale(double scaleX, double scaleY);\n+  \n+  public abstract void shear(double shearX, double shearY);\n+}"}, {"sha": "6bbdbd1d23ec84766e9882db5e724e6cc3f22b4a", "filename": "libjava/gnu/awt/j2d/DirectRasterGraphics.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fj2d%2FDirectRasterGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fj2d%2FDirectRasterGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fj2d%2FDirectRasterGraphics.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,82 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.j2d;\n+\n+import java.awt.Color;\n+import java.awt.Image;\n+import java.awt.Shape;\n+import java.awt.Rectangle;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.image.Raster;\n+import java.awt.image.ImageObserver;\n+\n+/**\n+ * Interface for a simple pixel based backend graphics object that\n+ * does not handle translation/transforms, curves, nor advanced\n+ * compositing.\n+ */\n+public interface DirectRasterGraphics extends Cloneable\n+{\n+  public void dispose();\n+  \n+  public void setColor(Color color);\n+  \n+  public void setPaintMode();\n+  \n+  public void setXORMode(Color altColor);\n+  \n+  public void setFont(Font font);\n+  \n+  public FontMetrics getFontMetrics(Font font);\n+  \n+  // supports rects, multi-rects and polygons\n+  public void setClip(Shape clip);\n+  \n+  public void copyArea(int x, int y, int width, int height,\n+\t\t       int dx, int dy);\n+  \n+  public void drawLine(int x1, int y1, int x2, int y2);\n+  \n+  public void drawRect(int x, int y, int width, int height);\n+  \n+  public void fillRect(int x, int y, int width, int height);\n+  \n+  public void drawArc(int x, int y, int width, int height,\n+\t\t      int startAngle, int arcAngle);\n+  \n+  public void fillArc(int x, int y, int width, int height,\n+\t\t      int startAngle, int arcAngle);\n+  \n+  public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints);\n+  \n+  public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints);\n+  \n+  public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints);\n+  \n+  public void drawString(String str, int x, int y);\n+  \n+  public boolean drawImage(Image image, int x, int y,\n+\t\t\t   ImageObserver observer);\n+\n+  /**\n+   * Map the data for screen pixels in the requested bounds to a\n+   * raster object.  This gives read/write access to the screen\n+   * pixels, allowing neat alpha and composite tricks.\n+   */\n+  public MappedRaster mapRaster(Rectangle bounds);\n+  \n+  /**\n+   * Detach previously mapped pixel data from a raster object.\n+   */\n+  public void unmapRaster(MappedRaster mappedRaster);\n+}"}, {"sha": "7c08295c027152e74f770f38fe4139b6e9d19308", "filename": "libjava/gnu/awt/j2d/Graphics2DImpl.java", "status": "added", "additions": 454, "deletions": 0, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fj2d%2FGraphics2DImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fj2d%2FGraphics2DImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fj2d%2FGraphics2DImpl.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,454 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.j2d;\n+\n+import java.awt.Color;\n+import java.awt.Image;\n+import java.awt.Shape;\n+import java.awt.Rectangle;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Paint;\n+import java.awt.RenderingHints;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.ImageObserver;\n+\n+/**\n+ * Delegates almost all work to a state object, that allows us to\n+ * hot-swap rendering strategies based on state changes inflicted on\n+ * this Graphics object. This class keeps track of properties that are\n+ * not affected by the state, (such as clip shape,\n+ * foreground/background color, font, etc.).\n+ *\n+ * <p>The far front-end of the rendering pipeline consists of the\n+ * Graphics2D API. In the far back-end, lies the native graphics\n+ * libraries. In most cases the native graphics libraries only have\n+ * direct support for a subset of the properties of Graphics2D. To\n+ * make up missing features in the native graphics libraries, the\n+ * pipeline between the front-end and the back-end need to translate\n+ * drawing request to primitive operations that are supported by the\n+ * back-end. E.g. for X11, drawing a straight line will translate to\n+ * an XDrawLine, drawing a bezier curve will trigger flattening of the\n+ * curve and will result in a call to XDrawLines.\n+ *\n+ * <p>This is the basic strategy for the rendering pipeline: Whenever\n+ * a graphics property change occurs, that causes the current pipeline\n+ * to be insufficient, amend or replace parts of the pipeline so that\n+ * the pipeline will once again be able to translate requests to the\n+ * set of primitives supported by the native graphics library.\n+ *\n+ * <p>Most graphics libraries share common subsets of\n+ * functionality. To be able to reuse pieces of the rendering pipeline\n+ * for several backends, we define interfaces that describe subsets of\n+ * characteristics supported by the backends. A wrapper for the native\n+ * library can implement several interfaces to describe its range of\n+ * functionality.\n+ *\n+ * <p>Typically, most painting is done with a graphics object with\n+ * simple properties. Unless one is using a complex Look & Feel, the\n+ * painting of Swing components will never require affine transforms,\n+ * alpha blending, non-rectangular clipping, etc. When graphics\n+ * objects are created, they start off in a state where all the\n+ * properties are simple. Most graphics objects experience only\n+ * trivial property changes, and never leave this simple state. It is\n+ * therefore wise to ensure that the rendering pipeline for this\n+ * initial state is lean and as much as possible plugs directly into\n+ * the backend.\n+ *\n+ * <p>The initial state for graphics object of most raster displays\n+ * would call for two levels of indirection:\n+ *\n+ * <pre>\n+ * Graphics2D object ---> IntegerGraphicsState ---> DirectRasterGraphics\n+ * </pre>\n+ */\n+public class Graphics2DImpl extends Graphics2D implements Cloneable\n+{\n+  GraphicsConfiguration config;\n+\n+  AbstractGraphicsState state;\n+    \n+  Color fg;\n+  Color bg;\n+\n+  Font font;\n+  \n+  public Graphics2DImpl(GraphicsConfiguration config)\n+  {\n+    this.config = config;\n+  }\n+  \n+  public void setState(AbstractGraphicsState state)\n+  {\n+    this.state = state;\n+    this.state.setFrontend(this);\n+  }\n+    \n+  public Object clone()\n+  {\n+    Graphics2DImpl gfxCopy = (Graphics2DImpl) super.clone();\n+    AbstractGraphicsState stateCopy =\n+      (AbstractGraphicsState) state.clone();\n+    gfxCopy.setState(stateCopy);\n+    \n+    return gfxCopy;\n+  }\n+\n+\n+  // -------- Graphics methods:\n+\n+  public Graphics create()\n+  {\n+    Graphics2DImpl gfxCopy = (Graphics2DImpl) clone();\n+    return gfxCopy;\n+  }\n+\n+  public Color getColor()\n+  {\n+    return fg;\n+  }\n+  \n+  public void setColor(Color color)\n+  {\n+    fg = color;\n+    state.setColor(color);\n+  }\n+\n+  public void setPaintMode()\n+  {\n+    state.setPaintMode();\n+  }\n+\n+  public void setXORMode(Color altColor)\n+  {\n+    state.setXORMode(altColor);\n+  }\n+\n+  public Font getFont()\n+  {\n+    return font;\n+  }\n+\n+  public void setFont(Font font)\n+  {\n+    this.font = font;\n+    state.setFont(font);\n+  }\n+    \n+  public FontMetrics getFontMetrics(Font font)\n+  {\n+    return state.getFontMetrics(font);\n+  }\n+\n+  public Rectangle getClipBounds()\n+  {\n+    return state.getClipBounds();\n+  }\n+    \n+  public void clipRect(int x, int y, int width, int height)\n+  {\n+    Shape clip = state.getClip();\n+    if (clip instanceof Rectangle)\n+      {\n+\tRectangle clipRect = (Rectangle) clip;\n+\tclip = clipRect.intersection(new Rectangle(x, y, width, height));\n+\tsetClip(clip);\n+\treturn;\n+      }\n+\t\n+    String msg =\n+      \"intersecting current clip shape \" + clip + \" with new rectangle \" +\n+      \"has not been implemented yet\";\n+    throw new UnsupportedOperationException(msg);\n+  }\n+\n+  public void setClip(int x, int y, int width, int height)\n+  {\n+    Rectangle clip = new Rectangle(x, y, width, height);\n+    setClip(clip);\n+  }\n+\n+  public Shape getClip()\n+  {\n+    return state.getClip();\n+  }\n+\n+  public void setClip(Shape clip)\n+  {\n+    state.setClip(clip);\n+  }\n+\n+  public void copyArea(int x, int y, int width, int height,\n+\t\t       int dx, int dy)\n+  {\n+    state.copyArea(x, y, width, height, dx, dy);\n+  }\n+\n+  public void drawLine(int x1, int y1, int x2, int y2)\n+  {\n+    state.drawLine(x1, y1, x2, y2);\n+  }\n+    \n+  public void fillRect(int x, int y, int width, int height)\n+  {\n+    state.fillRect(x, y, width, height);\n+  }\n+    \n+  public void clearRect(int x, int y, int width, int height)\n+  {\n+    state.clearRect(x, y, width, height);\n+  }\n+  \n+  public void drawRoundRect(int x, int y, int width, int height,\n+\t\t\t    int arcWidth, int arcHeight)\n+  {\n+    state.drawRoundRect(x, y, width, height, arcWidth, arcHeight);\n+  }\n+    \n+  public void fillRoundRect(int x, int y, int width, int height,\n+\t\t\t    int arcWidth, int arcHeight)\n+  {\n+    state.fillRoundRect(x, y, width, height, arcWidth, arcHeight);\n+  }\n+\n+  public void drawOval(int x, int y, int width, int height)\n+  {\n+    state.drawOval(x, y, width, height);\n+  }\n+\n+  public void fillOval(int x, int y, int width, int height)\n+  {\n+    state.fillOval(x, y, width, height);\n+  }\n+\n+  public void drawArc(int x, int y, int width, int height,\n+\t\t      int startAngle, int arcAngle)\n+  {\n+    state.drawArc(x, y, width, height, startAngle, arcAngle);\n+  }\n+\n+  public void fillArc(int x, int y, int width, int height,\n+\t\t      int startAngle, int arcAngle)\n+  {\n+    state.fillArc(x, y, width, height, startAngle, arcAngle);\n+  }\n+\n+  public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    state.drawPolyline(xPoints, yPoints, nPoints);\n+  }\n+  \n+  public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    state.drawPolygon(xPoints, yPoints, nPoints);\n+  }\n+    \n+  public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    state.fillPolygon(xPoints, yPoints, nPoints);\n+  }\n+    \n+  public boolean drawImage(Image image, int x, int y,\n+\t\t\t   ImageObserver observer)\n+  {\n+    return state.drawImage(image, x, y, observer);\n+  }\n+\n+  public boolean drawImage(Image img, int x, int y,\n+\t\t\t   int width, int height,\n+\t\t\t   ImageObserver observer)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public boolean drawImage(Image img, int x, int y, Color bgcolor,\n+\t\t\t   ImageObserver observer)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public boolean drawImage(Image img, int x, int y,\n+\t\t\t   int width, int height, Color bgcolor,\n+\t\t\t   ImageObserver observer)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public boolean drawImage(Image img,\n+\t\t\t   int dx1, int dy1, int dx2, int dy2,\n+\t\t\t   int sx1, int sy1, int sx2, int sy2,\n+\t\t\t   ImageObserver observer)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public boolean drawImage(Image img,\n+\t\t\t   int dx1, int dy1, int dx2, int dy2,\n+\t\t\t   int sx1, int sy1, int sx2, int sy2,\n+\t\t\t   Color bgcolor, ImageObserver observer)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public void dispose()\n+  {\n+    AbstractGraphicsState lState = state;\n+    \n+    state = null;\n+    config = null;\n+    font = null;\n+    fg = null;\n+    bg = null;\n+    \n+    if (lState != null)\n+      lState.dispose();\n+  }\n+    \n+\n+\n+  // -------- Graphics2D methods:\n+    \n+  public void draw(Shape shape)\n+  {\n+    state.draw(shape);\n+  }\n+  \n+  public boolean drawImage(Image image, AffineTransform xform,\n+\t\t\t   ImageObserver obs)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+\n+  public void drawString(String text, int x, int y)\n+  {\n+    state.drawString(text, x, y);\n+  }\n+\n+  public void drawString(String text, float x, float y)\n+  {\n+    state.drawString(text, x, y);\n+  }\n+\n+  public void fill(Shape shape)\n+  {\n+    state.fill(shape);\n+  }\n+\n+  public boolean hit(Rectangle rect, Shape text, boolean onStroke)\n+  {\n+    return state.hit(rect, text, onStroke);\n+  }\n+    \n+  public GraphicsConfiguration getDeviceConfiguration()\n+  {\n+    return config;\n+  }\n+\n+  public void setPaint(Paint paint)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public void setRenderingHint(RenderingHints.Key hintKey,\n+\t\t\t       Object hintValue)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public Object getRenderingHint(RenderingHints.Key hintKey)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public RenderingHints getRenderingHints()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+    \n+  public void translate(int x, int y)\n+  {\n+    state.translate(x, y);\n+  }\n+  \n+  public void translate(double tx, double ty)\n+  {\n+    state.translate(tx, ty);\n+  }\n+    \n+  public void rotate(double theta)\n+  {\n+    state.rotate(theta);\n+  }\n+\n+  public void rotate(double theta, double x, double y)\n+  {\n+    state.rotate(theta, x, y);\n+  }\n+  \n+  public void scale(double scaleX, double scaleY)\n+  {\n+    state.scale(scaleX, scaleY);\n+  }\n+  \n+  public void shear(double shearX, double shearY)\n+  {\n+    state.shear(shearX, shearY);\n+  }\n+\n+  public void transform(AffineTransform Tx)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public void setTransform(AffineTransform Tx)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+    \n+  public AffineTransform getTransform()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public Paint getPaint()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+    \n+  public void setBackground(Color color)\n+  {\n+    bg = color;\n+  }\n+\n+  public Color getBackground()\n+  {\n+    return bg;\n+  }\n+\n+  public void clip(Shape shape)\n+  {\n+    Shape clip = state.getClip();\n+    \n+    if ((shape instanceof Rectangle) && (clip instanceof Rectangle))\n+      {\n+\tclip = ((Rectangle) clip).intersection((Rectangle) shape);\n+\tstate.setClip(clip);\n+\treturn;\n+      }\n+\t\n+    String msg =\n+      \"intersecting current clip shape \" + clip + \" with new shape \" + shape +\n+      \"has not been implemented yet\";\n+    throw new UnsupportedOperationException(msg);\n+  }\n+}"}, {"sha": "923720e06ae34e64a949d173dda495c7978ff777", "filename": "libjava/gnu/awt/j2d/IntegerGraphicsState.java", "status": "added", "additions": 409, "deletions": 0, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fj2d%2FIntegerGraphicsState.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fj2d%2FIntegerGraphicsState.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fj2d%2FIntegerGraphicsState.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,409 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.j2d;\n+\n+import java.awt.Color;\n+import java.awt.Image;\n+import java.awt.Shape;\n+import java.awt.Rectangle;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+import java.awt.image.ColorModel;\n+\n+/**\n+ * IntegerGraphicsState is one of several graphics state\n+ * implementations.  This graphics state is used when the graphics\n+ * object has simple properties, (coordinate translation only, no\n+ * transform) and the backend supports integer coordinates (pixel\n+ * based). For primitive paint operations, this object translates the\n+ * coordinates and forwards the request to the backend. For requests\n+ * to draw arbitrary shapes and paths, this object translates the\n+ * requests to primitive drawing operations supported by the\n+ * backend. IntegerGraphicsState is meant to support the most common\n+ * state of an graphics object. The degree of functionality is roughly\n+ * equivalent with the old java.awt.Graphics API.\n+ */\n+public class IntegerGraphicsState extends AbstractGraphicsState\n+{\n+  int tx;\n+  int ty;\n+  \n+  DirectRasterGraphics directGfx;\n+  Shape clip;\n+  \n+  public IntegerGraphicsState(DirectRasterGraphics directGfx)\n+  {\n+    this.directGfx = directGfx;\n+  }\n+  \n+  public Object clone()\n+  {\n+    IntegerGraphicsState clone = (IntegerGraphicsState) super.clone();\n+    clone.directGfx = (DirectRasterGraphics) directGfx.clone();\n+    \n+    return clone;\n+  }\n+\n+  public void dispose()\n+  {\n+    DirectRasterGraphics lDeviceGfx = directGfx;\n+    \n+    directGfx = null;\n+    \n+    if (lDeviceGfx != null)\n+      lDeviceGfx.dispose();\n+    \n+    super.dispose();\n+  }\n+  \n+\n+  // -------- Graphics methods:\n+  \n+  public void setColor(Color color)\n+  {\n+    directGfx.setColor(color);\n+  }\n+  \n+  public void setPaintMode()\n+  {\n+    directGfx.setPaintMode();\n+  }\n+\n+  public void setXORMode(Color altColor)\n+  {\n+    directGfx.setXORMode(altColor);\n+  }\n+  \n+  public void setFont(Font font)\n+  {\n+    directGfx.setFont(font);\n+  }\n+  \n+  public FontMetrics getFontMetrics(Font font)\n+  {\n+    return directGfx.getFontMetrics(font);\n+  }\n+\n+  public void setClip(Shape clip)\n+  {\n+    if (clip instanceof Rectangle)\n+      {\n+\tRectangle clipRect = (Rectangle) clip.clone();\n+\tclipRect.x += tx;\n+\tclipRect.y += ty;\n+\t\n+\tthis.clip = clipRect;\n+\t\n+\tdirectGfx.setClip(clipRect);\n+\treturn;\n+      }\n+    \n+    String msg =\n+      \"translating clip shape \" + clip + \" into device \" +\n+      \"coordinate space has not been implemented yet\";\n+    \n+    throw new UnsupportedOperationException(msg);\n+  }\n+\n+  public Shape getClip()\n+  {\n+    if (clip instanceof Rectangle)\n+      {\n+\tRectangle clipRect = (Rectangle) clip;\n+\tclipRect.x -= tx;\n+\tclipRect.y -= ty;\n+\treturn clipRect;\n+      }\n+\n+    String msg =\n+      \"translating clip shape \" + clip + \" into user \" +\n+      \"coordinate space has not been implemented yet\";\n+    \n+    throw new UnsupportedOperationException(msg);\n+  }\n+\n+  public Rectangle getClipBounds()\n+  {\n+    Rectangle clipRect = clip.getBounds();\n+    \n+    clipRect.x -= tx;\n+    clipRect.y -= ty;\n+    return clipRect;\n+  }\n+\n+  public void copyArea(int x, int y, \n+\t\t       int width, int height,\n+\t\t       int dx, int dy)\n+  {\n+    directGfx.copyArea(x+tx, y+ty, width, height, dx, dy);\n+  }\n+\n+  public void drawLine(int x1, int y1,\n+\t\t       int x2, int y2)\n+  {\n+    directGfx.drawLine(x1+tx, y1+ty, x2+tx, y2+ty);\n+  }\n+    \n+  public void fillRect(int x, int y,\n+\t\t       int width, int height)\n+  {\n+    directGfx.fillRect(x+tx, y+ty, width, height);\n+  }\n+    \n+  public void clearRect(int x, int y,\n+\t\t\tint width, int height)\n+  {\n+    directGfx.setColor(frontend.getBackground());\n+    directGfx.fillRect(x+tx, y+ty, width, height);\n+    directGfx.setColor(frontend.getColor());\n+  }\n+\n+  public void drawRoundRect(int x, int y,\n+\t\t\t    int width, int height,\n+\t\t\t    int arcWidth, int arcHeight)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public void fillRoundRect(int x, int y,\n+\t\t\t    int width, int height,\n+\t\t\t    int arcWidth, int arcHeight)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public void drawOval(int x, int y,\n+\t\t       int width, int height)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public void fillOval(int x, int y,\n+\t\t       int width, int height)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public void drawArc(int x, int y,\n+\t\t      int width, int height,\n+\t\t      int startAngle, int arcAngle)\n+  {\n+    directGfx.drawArc(x+tx, y+ty, width, height, startAngle, arcAngle);\n+  }    \n+\n+  public void fillArc(int x, int y,\n+\t\t      int width, int height,\n+\t\t      int startAngle, int arcAngle)\n+  {\n+    directGfx.fillArc(x+tx, y+ty, width, height, startAngle, arcAngle);\n+  }\n+  \n+  public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    if ((tx == 0) || (ty == 0))\n+      {\n+\tdirectGfx.drawPolyline(xPoints, yPoints, nPoints);\n+\treturn;\n+      }\n+\t    \n+    throw new UnsupportedOperationException(\"translate not implemented\");\n+  }\n+\n+  public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    if ((tx == 0) || (ty == 0))\n+      {\n+\tdirectGfx.drawPolygon(xPoints, yPoints, nPoints);\n+\treturn;\n+      }\n+\n+    throw new UnsupportedOperationException(\"translate not implemented\");\n+  }\n+  \n+  public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints)\n+  {\n+    if ((tx == 0) || (ty == 0))\n+      {\n+\tdirectGfx.fillPolygon(xPoints, yPoints, nPoints);\n+\treturn;\n+      }\n+    \n+    throw new UnsupportedOperationException(\"translate not implemented\");\n+  }\n+\n+  public boolean drawImage(Image image, int x, int y,\n+\t\t\t   ImageObserver observer)\n+  {\n+    x += tx;\n+    y += ty;\n+    \n+    if (image instanceof BufferedImage)\n+      {\n+\tBufferedImage bImage = (BufferedImage) image;\n+\tObject config =\n+\t  bImage.getProperty(\"java.awt.GraphicsConfiguration\");\n+\t\n+\tif (config == frontend.config)\n+\t  return directGfx.drawImage(image, x, y, observer);\n+\t\n+\tint width = image.getWidth(null);\n+\tint height = image.getHeight(null);\t\n+\t\n+\tRectangle bounds = new Rectangle(x, y, width, height);\n+\t\n+\tMappedRaster mr = directGfx.mapRaster(bounds);\n+\t\n+\t// manipulate raster here...\n+\tColorModel colorModel = mr.getColorModel();\n+\tWritableRaster raster = mr.getRaster();\n+\t\n+\tint xEnd = x + width;\n+\tint yEnd = y + height;\n+\t\n+\t// FIXME: Use the following code only as a fallback. It's SLOW!\n+\n+\tObject rgbElem = null;\n+\tfor (int yy=0; yy<height; yy++)\n+\t  {\n+\t    for (int xx=0; xx<width; xx++)\n+\t      {\n+\t\tint srgb = bImage.getRGB(xx, yy);\n+\t\tint sa = ((srgb >>> 24) & 0xff) + 1;\n+\t\tint sr = ((srgb >>> 16) & 0xff) + 1;\n+\t\tint sg = ((srgb >>> 8) & 0xff) + 1;\n+\t\tint sb = (srgb & 0xff) + 1;\n+\t\t\n+\t\trgbElem = raster.getDataElements(xx+x, yy+y, rgbElem);\n+\t\tint drgb = colorModel.getRGB(rgbElem);\n+\t\tint dr = ((drgb >>> 16) & 0xff) + 1;\n+\t\tint dg = ((drgb >>> 8) & 0xff) + 1;\n+\t\tint db = (drgb & 0xff) + 1;\t\t    \n+\t\tint da = 256 - sa;\n+\t\t\n+\t\tdr = ((sr*sa + dr*da) >>> 8) - 1;\n+\t\tdg = ((sg*sa + dg*da) >>> 8) - 1;\n+\t\tdb = ((sb*sa + db*da) >>> 8) - 1;\n+\t\t\n+\t\tdrgb = (dr<<16) | (dg<<8) | db;\n+\t\t\n+\t\trgbElem = colorModel.getDataElements(drgb, rgbElem);\n+\t\t\n+\t\traster.setDataElements(xx+x, yy+y, rgbElem);\n+\t      }\n+\t  }\n+\tdirectGfx.unmapRaster(mr);\n+\treturn true;\n+\t\n+      }\n+    throw new UnsupportedOperationException(\"drawing image \" + image +\n+\t\t\t\t\t    \"not implemented\");\n+  }\n+  \n+\n+  // -------- Graphics2D methods:\n+  \n+  public void draw(Shape shape)\n+  {\n+    if (shape instanceof Rectangle)\n+      {\n+\tRectangle rect = (Rectangle) shape;\n+\tdirectGfx.drawRect(rect.x+tx, rect.y+ty, rect.width, rect.height);\n+\treturn;\n+      } \n+    \n+    throw new UnsupportedOperationException(\"shape not implemented\");\n+  }\n+\n+  public void fill(Shape shape)\n+  {\n+    if (shape instanceof Rectangle)\n+      {\n+\tRectangle rect = (Rectangle) shape;\n+\tdirectGfx.fillRect(rect.x+tx, rect.y+ty, rect.width, rect.height);\n+\treturn;\n+      }\n+    \n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+    \n+  public boolean hit(Rectangle rect, Shape text,\n+\t\t     boolean onStroke)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  public void drawString(String text, int x, int y)\n+  {\n+    directGfx.drawString(text, x+tx, y+ty);\n+  }\n+\n+  public void drawString(String text, float x, float y)\n+  {\n+    drawString(text, (int) x, (int) y);\n+  }\n+  \n+  public void translate(int x, int y)\n+  {\n+    tx += x;\n+    ty += y;\n+  }\n+    \n+  public void translate(double tx, double ty)\n+  {\n+    if ((tx == 0) && (ty == 0))\n+      return;\n+    \n+    needAffineTransform();\n+  }\n+\n+  public void rotate(double theta)\n+  {\n+    if (theta == 0)\n+      return;\n+    \n+    needAffineTransform();\n+  }\n+\n+  public void rotate(double theta, double x, double y)\n+  {\n+    if (theta == 0)\n+      return;\n+    \n+    needAffineTransform();\n+  }\n+\n+  public void scale(double scaleX, double scaleY)\n+  {\n+    if ((scaleX == 1) && (scaleY == 1))\n+      return;\n+\n+    needAffineTransform();\n+  }\n+  \n+  public void shear(double shearX, double shearY)\n+  {\n+    if ((shearX == 0) && (shearY == 0))\n+      return;\n+    \n+    needAffineTransform();\n+  }   \n+  \n+  private void needAffineTransform()\n+  {\n+    throw new UnsupportedOperationException(\"state with affine \" +\n+\t\t\t\t\t    \"transform not implemented\");\n+  }\n+}"}, {"sha": "eb41eecf9ad70fb54d0fff2e27e949dc4bce315d", "filename": "libjava/gnu/awt/j2d/MappedRaster.java", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fj2d%2FMappedRaster.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fj2d%2FMappedRaster.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fj2d%2FMappedRaster.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.j2d;\n+\n+import java.awt.image.WritableRaster;\n+import java.awt.image.ColorModel;\n+\n+/* The raster and associated properties of a mapped screen region.\n+ * The compositing capabilities of backends are often insufficient.\n+ * The backend may not support alpha blending, or may not support some\n+ * other special compositing rule.  This means that compositing must\n+ * sometimes be done within the rendering pipeline.  The general\n+ * compositing operation consists of combining new color and alpha\n+ * values with existing color values on the drawing surface, to find\n+ * the new color values for the drawing surface. The way the values\n+ * are combined, determines what kind of compositing operation that is\n+ * performed.  The default compositing operation is alpha compositing.\n+ *\n+ * <p>In order to perform alpha compositing and other compositing\n+ * operations, we need access to the color values of the imagery that\n+ * has already been drawn on the drawing surface.  The\n+ * DirectRasterGraphics interface must therefore contain methods that\n+ * makes it possible to gain access to the pixel values of the drawing\n+ * surface.  The methods are modeled after the POSIX mmap() and\n+ * munmap() functions.  But, instead of mapping and unmapping portions\n+ * of data from a file descriptor to memory, the methods in\n+ * DirectRasterGraphics maps and unmaps portions of the drawing\n+ * surface to data arrays within writable raster objects.  A call to\n+ * mapRaster() will return a writable raster object, encapsulating the\n+ * image data of the drawing surface in the requested domain. The data\n+ * encapsulated by this raster object can be modified using the\n+ * WritableRaster API, or the data buffers can be retrieved from the\n+ * raster, so that the data arrays can be manipulated directly.  When\n+ * the raster image has been modified as desired, the data can be\n+ * resynchronized with the drawing surface by calling mapRaster().\n+ *\n+ * <p>As with mmap() and munmap() the methods may work by direct\n+ * manipulation of shared memory, (i.e. the raster object directly\n+ * wraps the actual image data of the drawing surface), or may make a\n+ * private copy that is resynched when the raster is unmapped. The\n+ * backend may choose to implement either mechanism, and the pipeline\n+ * code should not care what mechanism is actually used.  This design\n+ * allows us to make full use of speedups such as X shared memory\n+ * extentions when available.\n+ */\n+public class MappedRaster\n+{\n+  WritableRaster raster;\n+  ColorModel cm;\n+  \n+  public MappedRaster(WritableRaster raster, ColorModel cm)\n+  {\n+    this.raster = raster;\n+    this.cm = cm;\n+  }\n+\n+  public final WritableRaster getRaster()\n+  {\n+    return raster;\n+  }\n+\n+  public final ColorModel getColorModel()\n+  {\n+    return cm;\n+  }\n+}"}, {"sha": "5674f5bf2ad6da03578f576cb95b2027624283e7", "filename": "libjava/gnu/awt/xlib/XCanvasPeer.java", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXCanvasPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXCanvasPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXCanvasPeer.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,388 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.xlib;\n+\n+import java.awt.Dimension;\n+import java.awt.Component;\n+import java.awt.EventQueue;\n+import java.awt.Rectangle;\n+import java.awt.Color;\n+import java.awt.Container;\n+import java.awt.Image;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.Toolkit;\n+import java.awt.AWTEvent;\n+import java.awt.Cursor;\n+import java.awt.Shape;\n+\n+import java.awt.peer.*;\n+import java.awt.image.*;\n+\n+import java.awt.event.MouseListener;\n+import java.awt.event.PaintEvent;\n+\n+import java.util.EventListener;\n+\n+import gnu.gcj.xlib.WMSizeHints;\n+import gnu.gcj.xlib.Window;\n+import gnu.gcj.xlib.WindowAttributes;\n+import gnu.gcj.xlib.Display;\n+import gnu.gcj.xlib.Visual;\n+import gnu.gcj.xlib.Screen;\n+import gnu.gcj.xlib.XImage;\n+\n+import gnu.awt.j2d.*;\n+\n+public class XCanvasPeer implements CanvasPeer\n+{\n+  static final Dimension MIN_SIZE = new Dimension(1, 1);\n+  \n+  public // temporary\n+  \n+  Window window;\n+  Window parent;\n+\n+  Component component;\n+  XGraphicsConfiguration config;\n+  \n+  public XCanvasPeer(Component component)\n+  {\n+    this.component = component;\n+    \n+    // Set up graphics configuration (ie. screen + visual):\n+\n+    config = (XGraphicsConfiguration)\n+      component.getGraphicsConfiguration();\n+\n+    if (config == null)\n+      {\n+\t// This will usually only happen for toplevel windows\n+\tconfig = getXToolkit().getDefaultXGraphicsConfiguration();\n+      } \n+\n+    Rectangle bounds = component.getBounds();\n+    parent = locateParentWindow(bounds);\n+\t\n+    // Windows in X must atleast be of size 1x1\n+    boolean boundsChanged = false;\n+    if (bounds.width < 1)\n+      {\n+\tboundsChanged = true;\n+\tbounds.width = 1;\n+      }\n+    if (bounds.height < 1)\n+      {\n+\tboundsChanged = true;\n+\tbounds.height = 1;\n+      }\n+\t\n+    /* don't worry about this calling back to us, since the real\n+       component object has not yet received a reference to this peer\n+       object. */\n+    component.setBounds(bounds);\n+\t    \n+    WindowAttributes attributes = new WindowAttributes();\n+\n+    /* Set background color */\n+    Color bg = component.getBackground();\n+    if (bg != null)\n+      {\n+\tint[] components =\n+\t{\n+\t  bg.getRed(),\n+\t  bg.getGreen(),\n+\t  bg.getBlue(),\n+\t  0xff\n+\t};\n+\n+\tColorModel cm = config.getColorModel();\n+\tlong pixel = cm.getDataElement(components, 0);\n+\tattributes.setBackground(pixel);\n+      }\n+\t\n+    /* Set exposure mask so that we get exposure events\n+       that can be translated into paint() calls. */\n+    long eventMask = WindowAttributes.MASK_EXPOSURE;\n+\n+    /* It would be nice to set up all other required events here, but\n+       it is not possible to do so before after all the children of\n+       this component has been realized.  The reason is that it is not\n+       determined whether a component is lightweight before after the\n+       addNotify() method has been called.  Thus, it is not possible\n+       for parent component to determine what events it needs to\n+       furnish for lightweight children.  Instead, we currently rely\n+       on the component calling our setEventMask() method after the\n+       correct event mask has been determined. */\n+\n+    attributes.setEventMask(eventMask);\n+\t\n+\t    \n+    // TODO: set more window attributes?\n+\n+    /* don't allow event queue to process events from the newly\n+       created window before this peer has been registered as client\n+       data. */\n+    synchronized (getXToolkit().eventLoop)\n+      {\n+\twindow = new gnu.gcj.xlib.Window(parent, bounds, attributes);\n+\twindow.setClientData(this); /* make it possible to find back\n+\t\t\t\t       to this peer object. Used by\n+\t\t\t\t       XEventQueue. */\n+      }\n+    \n+    initWindowProperties();\n+\n+    if (component.isVisible())\n+      EventQueue.invokeLater(new DoMap(window));\n+  }\n+\n+  /**\n+   * Override this in subclasses to implement other ways of obtaining\n+   * parent windows.  Toplevel windows will typically have a different\n+   * implementation.\n+   */\n+  gnu.gcj.xlib.Window locateParentWindow(Rectangle bounds)\n+  {\n+    Container parent = component.getParent();\n+    while (parent.isLightweight())\n+      {\n+\tbounds.x += parent.getX();\n+\tbounds.y += parent.getY();\n+\tparent = parent.getParent();\n+\t// a null pointer here is a genuine error\n+      }\n+    \n+    XCanvasPeer parentPeer = (XCanvasPeer) parent.getPeer();\n+    if (parentPeer == null)\n+      throw new NullPointerException(\"Parent has no peer. This should \" +\n+\t\t\t\t     \"not be possible, since the \" +\n+\t\t\t\t     \"calls leading here should come \" +\n+\t\t\t\t     \"from parent, after it has \" +\n+\t\t\t\t     \"set the parent peer.\");\n+    return parentPeer.window;\n+  }\n+    \n+\n+  /** \n+   * Template method to allow subclasses to apply properties to X11\n+   * window right after creation.\n+   */\n+  void initWindowProperties()\n+  {\n+  }\n+    \n+  XToolkit getXToolkit()\n+  {\n+    return XToolkit.INSTANCE;\n+  }\n+\n+  protected void ensureFlush()\n+  {\n+    getXToolkit().flushIfIdle();\n+  }\n+\n+  public Component getComponent()\n+  {\n+    return component;\n+  }\n+  \n+  long getBasicEventMask()\n+  {\n+    return WindowAttributes.MASK_EXPOSURE;\n+  }\n+    \n+  // -------- java.awt.peer.ComponentPeer implementation\n+\n+  public int checkImage(Image img, int width, int height, ImageObserver o)\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+  public Image createImage(ImageProducer prod)\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+  public Image createImage(int width, int height)\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+  public void dispose()\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+\n+  public GraphicsConfiguration getGraphicsConfiguration()\n+  {\n+    return config;\n+  }\n+\n+  public FontMetrics getFontMetrics(Font f)\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+\n+  public Graphics getGraphics()\n+  {\n+    DirectRasterGraphics gfxDevice = new XGraphics(window, config);\n+    IntegerGraphicsState igState = new IntegerGraphicsState(gfxDevice);\n+    Graphics2DImpl gfx2d = new Graphics2DImpl(config);\n+\n+    gfx2d.setState(igState);\n+    gfx2d.setColor(component.getBackground());\n+    return gfx2d;\n+  }\n+    \n+  public Point getLocationOnScreen()\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+\n+  public Dimension getMinimumSize ()\n+  {\n+    return MIN_SIZE;\n+  }\n+\n+  public Dimension getPreferredSize ()\n+  {\n+    return component.getSize();\n+  }\n+    \n+  public Toolkit getToolkit()\n+  {\n+    return getXToolkit();\n+  }\n+\n+  public void handleEvent(AWTEvent event)\n+  {\n+  }\n+\n+  public boolean isFocusTraversable()\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+\n+  public void paint(Graphics gfx)\n+  {\n+    // do nothing by default\n+  }\n+    \n+  public boolean prepareImage(Image img, int width, int height,\n+\t\t\t      ImageObserver o)\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+\n+  public void print(Graphics graphics)\n+  {\n+    paint(graphics);\n+  }\n+\n+  public void repaint(long tm, int x, int y, int w, int h)\n+  {\n+    /* TODO?\n+\n+       X allows intelligent X servers to do smart\n+       refreshing. Perhaps involve X in repainting of components,\n+       rather that keeping it all within the local event queue. */\n+    \n+    PaintEvent updateEvent = new PaintEvent(component,\n+\t\t\t\t\t    PaintEvent.UPDATE,\n+\t\t\t\t\t    new Rectangle(x, y, w, h));\n+    getXToolkit().queue.postEvent(updateEvent);\n+  }\n+    \n+  public void requestFocus()\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+\n+  public void setBackground(Color color)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  public void setBounds(int x, int y, int width, int height)\n+  {\n+    width  = Math.max(width,  1);\n+    height = Math.max(height, 1);\n+    window.setBounds(x, y, width, height);\n+    ensureFlush();\t    \n+  }\n+    \n+  public void setCursor(Cursor cursor)\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+\n+  public void setEnabled(boolean enabled)\n+  {\n+    throw new UnsupportedOperationException(\"FIXME, not implemented\");\n+  }\n+\n+  public void setEventMask(long eventMask)\n+  {\n+    WindowAttributes attributes = new WindowAttributes();\n+\n+    long xEventMask = getBasicEventMask();\n+\t\n+    if ((eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0)\n+      {\n+\txEventMask |=\n+\t  WindowAttributes.MASK_BUTTON_PRESS |\n+\t  WindowAttributes.MASK_BUTTON_RELEASE;\n+      }\n+\t    \n+    attributes.setEventMask(xEventMask);\n+    window.setAttributes(attributes);\n+    ensureFlush();\n+  }\n+\n+  public void setFont(Font font)\n+  {\n+    /* default canvas peer does keep track of font, since it won't\n+       write anything. */\n+  }\n+\n+  public void setForeground(Color color)\n+  {\n+    /* default canvas peer does keep track of foreground, since it won't\n+       paint anything. */\n+  }\n+\t\n+  public void setVisible(boolean visible)\n+  {\n+    if (visible)\n+      {\n+\twindow.map();\n+\tensureFlush();\t    \n+      }\n+    else\n+      {\n+\tthrow new UnsupportedOperationException(\"unmap not implemented\");\n+      }\n+  }\n+\t\n+  static class DoMap implements Runnable \n+  {\n+    Window window;\n+    public DoMap(Window w) \n+    {\n+      this.window = w;\n+    }\n+    \n+    public void run() \n+    {\n+      window.map();\n+    }\n+  }\n+}\n+"}, {"sha": "4d2932089397d86dcdd4ade37110489f4a37d7f8", "filename": "libjava/gnu/awt/xlib/XEventLoop.java", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventLoop.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventLoop.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventLoop.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,268 @@\n+package gnu.awt.xlib;\n+\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+import java.awt.*;\n+\n+import gnu.awt.LightweightRedirector;\n+import gnu.gcj.xlib.Display;\n+import gnu.gcj.xlib.XAnyEvent;\n+import gnu.gcj.xlib.XExposeEvent;\n+import gnu.gcj.xlib.XButtonEvent;\n+import gnu.gcj.xlib.XConfigureEvent;\n+import java.awt.event.PaintEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+import java.util.Vector;\n+\n+public class XEventLoop implements Runnable\n+{\n+  Display display;\n+  EventQueue queue;\n+  XAnyEvent anyEvent;\n+  Thread eventLoopThread;\n+\n+  LightweightRedirector lightweightRedirector = new LightweightRedirector();\n+    \n+  public XEventLoop(Display display, EventQueue queue)\n+  {\n+    this.display = display;\n+    this.queue = queue;\n+    \n+    anyEvent = new XAnyEvent(display);\n+    eventLoopThread = new Thread(this, \"AWT thread for XEventLoop\");\n+    eventLoopThread.start();\n+  }\n+\n+  public void run()\n+  {\n+    while (true) \n+      postNextEvent();\n+  }\n+\n+  void postNextEvent()\n+  {\n+    try\n+      {\n+\tAWTEvent evt = getNextEvent();\n+\tqueue.postEvent(evt);\n+\t\n+      }\n+    catch (InterruptedException ie)\n+      {\n+\t// FIXME: what now?\n+\tSystem.err.println(ie);\n+      }\n+  }\n+    \n+  /** get next event. Will block until events become available. */\n+ \n+  public AWTEvent getNextEvent()\n+  {\n+    // ASSERT:\n+    if (isIdle())\n+      throw new Error(\"should not be idle\");\n+    \n+    AWTEvent event = null;\n+    while (event == null)\n+      {\n+\tloadNextEvent();\n+\tevent = createEvent();\n+      }\n+\n+    event = lightweightRedirector.redirect(event);\n+\n+    return event;\n+  }\n+\n+  void loadNextEvent()\n+  {\n+    try\n+      {\n+\tsetIdle(true);\n+\t\n+\t/* The code below will result in an XFlush(). However,\n+\t   while we are waiting for events after calling XFlush(),\n+\t   new X requests issued on other threads will not\n+\t   automatically be flushed. This can lead to a deadlock\n+\t   since XFlush() will not be called before after the\n+\t   processing of the next event, and new events arriving\n+\t   might be dependent on the delivery of the X\n+\t   requests. \n+\t   \n+\t   Code that issues X requests should therefore call\n+\t   flushIfIdle() after they're done, to ensure that the\n+\t   requests are delivered in a timely manner.  XFlush is not\n+\t   run if event processing is underway, since we are assured\n+\t   that the event loop execution will return to this point,\n+\t   where requests are flushed again, before waiting for new\n+\t   events.\n+\n+\t   Alternatively, do the work on the AWT thread, since the\n+\t   XEventQueue knows how to flush the display when it runs out\n+\t   of events. */\n+\t\n+\t//display.flush(); // implicit?\n+\tanyEvent.loadNext();\n+      }\n+    catch (RuntimeException re)\n+      {\n+\tSystem.err.println(\"Exception thrown on event thread:\" + re);\n+      }\n+    finally\n+      {\n+\tsetIdle(false);\n+      }\n+  }\n+    \n+  /**\n+   * @returns an AWT event created based on the current XEvent.\n+   * Returns null if the current XEvent does not map to any perticular\n+   * AWT event.\n+   */\n+    \n+  AWTEvent createEvent()\n+  {\n+    /* avoid attempting to get client data before client data has\n+       been set. */\n+    Object peer;\n+    synchronized (this)\n+      {\n+\tpeer = anyEvent.getWindow().getClientData();\n+      }\n+\t    \n+    Component source = null;\n+\n+    // Try to identify source component\n+\t\n+    if (peer instanceof XCanvasPeer)\n+      {\n+\tsource = ((XCanvasPeer) peer).getComponent();\n+      }\n+\t\n+    if (source == null)\n+      {\n+\tString msg = \"unable to locate source for event (\" +\n+\t  anyEvent + \")\";\n+\tthrow new RuntimeException(msg);\n+      }\n+\n+    /* if a mapping from anyEvent to AWTEvent is possible, construct a\n+       new AWTEvent and return it. */\n+\t\n+    int type = anyEvent.getType();\n+    switch (type)\n+      {\n+      case XAnyEvent.TYPE_EXPOSE:\n+\treturn createPaintEvent(source);\n+      case XAnyEvent.TYPE_BUTTON_PRESS:\n+      case XAnyEvent.TYPE_BUTTON_RELEASE:\n+\treturn createMouseEvent(type, source);\n+      case XAnyEvent.TYPE_UNMAP_NOTIFY:\n+      case XAnyEvent.TYPE_MAP_NOTIFY:\n+      case XAnyEvent.TYPE_REPARENT_NOTIFY:\n+\treturn null; // ignore for now\n+      case XAnyEvent.TYPE_CONFIGURE_NOTIFY:\n+\tconfigureNotify(peer);\n+\treturn null;\n+\n+      default:\n+\tString msg = \"Do no know how to handle event (\" + anyEvent + \")\";\n+\tthrow new RuntimeException(msg);\n+      }\n+  }\n+    \n+  AWTEvent createPaintEvent(Component src)\n+  {\n+    XExposeEvent expose = new XExposeEvent(anyEvent);\n+    PaintEvent pe = new PaintEvent(src, PaintEvent.PAINT,\n+\t\t\t\t   expose.getBounds());\n+    return pe;\n+  }\n+    \n+  AWTEvent createMouseEvent(int type, Component src)\n+  {    \n+    XButtonEvent buttonEvt = new XButtonEvent(anyEvent);\n+    \n+    int modifiers = 0; //buttonToModifierMap[buttonEvt.button];\n+    \n+    /* Warning: this makes assumptions on the contents of\n+       X.h... Button1 = 1, Button2 = 2, etc... */\n+    switch (buttonEvt.button)\n+      {\n+      case 1:\n+\tmodifiers = InputEvent.BUTTON1_MASK;\n+\tbreak;\n+      case 2:\n+\tmodifiers = InputEvent.BUTTON2_MASK;\n+\tbreak;\n+      case 3:\n+\tmodifiers = InputEvent.BUTTON2_MASK;\n+\tbreak;\n+      }\n+    \n+    int state = buttonEvt.state;\n+    \n+    // remap bits from state to modifiers:\n+    \n+    if ((state & XButtonEvent.MASK_SHIFT) != 0)\n+      modifiers |= InputEvent.SHIFT_MASK;\n+\t\n+\t\n+    if ((state & XButtonEvent.MASK_CONTROL) != 0)\n+      modifiers |= InputEvent.CTRL_MASK;\n+\t\n+    \n+    /* FIXME: we need additional X code to properly map MODn states to\n+       input modifiers */\n+\t\n+    int clickCount = 1; // FIXME... Can't get this from X.\n+    boolean popupTrigger = false; // FIXME: look up policy somewhere\n+\t\n+    int x = buttonEvt.x;\n+    int y = buttonEvt.y;\n+\n+    int id = (type == XAnyEvent.TYPE_BUTTON_PRESS) ?\n+      MouseEvent.MOUSE_PRESSED :\n+      MouseEvent.MOUSE_RELEASED;\n+\t\n+    MouseEvent me = new MouseEvent(src,\n+\t\t\t\t   id,\n+\t\t\t\t   buttonEvt.time, modifiers,\n+\t\t\t\t   buttonEvt.x, buttonEvt.y,\n+\t\t\t\t   clickCount, popupTrigger);\n+    return me;\n+  }\n+\n+  void configureNotify(Object peerObj)\n+  {\n+    XConfigureEvent configEvent = new XConfigureEvent(anyEvent);\n+    XFramePeer peer = (XFramePeer)  peerObj;\n+    \n+    peer.configureNotify(configEvent);\n+  }\n+    \n+  public void flushIfIdle()\n+  {\n+    if (isIdle())\n+      display.flush();\n+  }\n+  \n+  volatile boolean idle = false;\n+\n+  final synchronized void setIdle(boolean idle)\n+  {\n+    this.idle = idle;\n+  }\n+\n+  final synchronized boolean isIdle()\n+  {\n+    return idle;\n+  }\n+}"}, {"sha": "ea2ad186060584f58455c793a541cce34a48ea3f", "filename": "libjava/gnu/awt/xlib/XEventQueue.java", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventQueue.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventQueue.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXEventQueue.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,34 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.xlib;\n+\n+import java.awt.*;\n+\n+import gnu.gcj.xlib.Display;\n+\n+/**\n+ * The only difference here from a standard EventQueue is that the X\n+ * display connection is flushed before waiting for more events.\n+ */\n+public class XEventQueue extends EventQueue\n+{\n+  Display display;\n+  \n+  public XEventQueue(Display display)\n+  {\n+    this.display = display;\n+  }\n+  \n+  public AWTEvent getNextEvent() throws InterruptedException\n+  {\n+    if ((peekEvent() == null) && (display != null))\n+      display.flush();\n+    return super.getNextEvent();\n+  }\n+}"}, {"sha": "4e45a1f8250bbb312a61213a897b26486b6ddee2", "filename": "libjava/gnu/awt/xlib/XFontMetrics.java", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXFontMetrics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXFontMetrics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXFontMetrics.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,47 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.xlib;\n+\n+import java.awt.FontMetrics;\n+\n+public class XFontMetrics extends FontMetrics\n+{\n+  gnu.gcj.xlib.Font xfont;\n+  \n+  public XFontMetrics(gnu.gcj.xlib.Font xfont, java.awt.Font awtFont)\n+  {\n+    super(awtFont);\n+    this.xfont = xfont;\n+  }\n+\n+  public int getAscent()\n+  {\n+    return xfont.getAscent();\n+  }\n+\n+  public int getDescent()\n+  {\n+    return xfont.getDescent();\n+  }\n+\n+  public int getMaxAscent()\n+  {\n+    return xfont.getMaxAscent();\n+  }\n+ \n+  public int getMaxDescent()\n+  {\n+    return xfont.getMaxDescent();\n+  }\n+\n+  public int stringWidth(String str)\n+  {\n+    return xfont.getStringWidth(str);\n+  }\n+}"}, {"sha": "0f55088d023a5a07d448978876d0109368d16029", "filename": "libjava/gnu/awt/xlib/XFramePeer.java", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXFramePeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXFramePeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXFramePeer.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,174 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.xlib;\n+\n+import java.awt.*;\n+import java.awt.peer.*;\n+import java.awt.image.*;\n+import gnu.gcj.xlib.WMSizeHints;\n+import gnu.gcj.xlib.WindowAttributes;\n+import gnu.gcj.xlib.Display;\n+import gnu.gcj.xlib.Visual;\n+import gnu.gcj.xlib.Screen;\n+import gnu.gcj.xlib.XConfigureEvent;\n+\n+/** FIXME: a lot of the code here should be moved down to XWindowPeer. */\n+\n+public class XFramePeer extends XCanvasPeer implements FramePeer\n+{\n+\n+  public XFramePeer(Frame frame)\n+  {\n+    super(frame);\n+    \n+    // Set some defaults for a toplevel component:\n+    if (frame.getFont() == null)\n+      frame.setFont(new Font(\"helvetica\", Font.PLAIN, 12));\n+\n+    if (frame.getBackground() == null)\n+      frame.setBackground(Color.lightGray);\n+\n+    if (frame.getForeground() == null)\n+      frame.setForeground(Color.black);\n+  }\n+\n+  /** Find parent window for toplevel window, ie. root window of\n+      selected screen. Bounds are not changed. */\n+  gnu.gcj.xlib.Window locateParentWindow(Rectangle bounds)\n+  {\n+    Screen screen = config.getVisual().getScreen();\n+    return screen.getRootWindow();\n+  }\n+\t\n+  void initWindowProperties()\n+  {\n+    Frame frame = (Frame) component;\n+    setResizable(frame.isResizable());\n+    String title = frame.getTitle();\n+    if (!title.equals(\"\")) setTitle(title);\n+  }\n+\n+  long getBasicEventMask()\n+  {\n+    return super.getBasicEventMask() |\n+      WindowAttributes.MASK_STRUCTURE_NOTIFY;\n+  }\n+\n+  void configureNotify(XConfigureEvent configEvent)\n+  {\n+    component.setBounds(configEvent.getBounds());\n+    \n+    /* FIXME: Validation should probably not be done here.  The best\n+       strategy is probably to validate on the AWT thread in response\n+       to an ComponentEvent.  This will make it possible to coalesce\n+       resize validations. */\n+    component.validate();\n+  }\n+\n+  /* Overridden to ignore request to set bounds if the request occurs\n+     on the X event loop thread.  It is assumed that all requests that\n+     occur on the X event loop thread are results of XConfigureNotify\n+     events, in which case the X window already has the desired\n+     bounds.  */\n+  public void setBounds(int x, int y, int width, int height)\n+  {\n+    if (Thread.currentThread() == getXToolkit().eventLoop.eventLoopThread)\n+      return;\n+    \n+    super.setBounds(x, y, width, height);\n+  }\n+ \n+  // Implementing ContainerPeer:\n+\n+  static final Insets INSETS_0_PROTOTYPE = new Insets(0, 0, 0, 0);\n+\n+  public Insets getInsets()\n+  {\n+    return (Insets) INSETS_0_PROTOTYPE.clone();\n+  }\n+\n+  public void beginValidate()\n+  {\n+  }\n+\n+  public void endValidate()\n+  {\n+    // reassert sizing hints\n+    Frame frame = (Frame) component;\n+    setResizable(frame.isResizable());\n+  }\n+    \n+\n+  // Implementing WindowPeer:\n+\n+  public void toBack()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\t\n+  }\n+  \n+  public void toFront()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\t\n+  }\n+\n+\n+  // Implementing FramePeer:\n+\n+  public void setIconImage(Image image)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\t\n+  }\n+  \n+  public void setMenuBar(MenuBar mb)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\t\n+  }\n+\n+\n+  public void setTitle(String title)\n+  {\n+    synchronized (window.getDisplay())\n+      {\n+\t// Oh, what a nice implementation :-)\n+\twindow.setProperty(\"WM_NAME\", \"STRING\", title);\n+\t\n+\tensureFlush();\n+      }\n+  }\n+\n+  public void setResizable(boolean resizable)\n+  {\n+    Frame frame = (Frame) component;\n+    \n+    WMSizeHints sizeHints = new WMSizeHints();\n+    if (resizable)\n+      {\n+\tDimension minSize = frame.getMinimumSize();\n+\tsizeHints.setMinSize(minSize.width, minSize.height);\n+\t\n+\tDimension maxSize = frame.getMaximumSize();\n+\t\n+\tif ((maxSize.width < Short.MAX_VALUE) ||\n+\t    (maxSize.height < Short.MAX_VALUE))\n+\t  {\n+\t    maxSize.width  = Math.min(maxSize.width,  Short.MAX_VALUE);\n+\t    maxSize.height = Math.min(maxSize.height, Short.MAX_VALUE);\n+\t    sizeHints.setMaxSize(maxSize.width, maxSize.height);\n+\t  }\n+      }\n+    else\n+      {\n+\t// lock resizing to current bounds\n+\tDimension size = frame.getSize();\n+\tsizeHints.setMinSize(size.width, size.height);\n+\tsizeHints.setMaxSize(size.width, size.height);\n+      }\n+    sizeHints.applyNormalHints(window);\n+  }\n+}"}, {"sha": "27b07a2369a631481171cf88ef8d7292c2078b92", "filename": "libjava/gnu/awt/xlib/XGraphics.java", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphics.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,279 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.xlib;\n+\n+import java.awt.*;\n+import java.awt.image.WritableRaster;\n+import java.awt.image.Raster;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.BufferedImage;\n+import gnu.gcj.xlib.GC;\n+import gnu.gcj.xlib.XImage;\n+import gnu.gcj.xlib.Drawable;\n+import gnu.gcj.xlib.Window;\n+import gnu.gcj.xlib.Drawable;\n+import gnu.gcj.xlib.Visual;\n+import gnu.awt.j2d.DirectRasterGraphics;\n+import gnu.awt.j2d.MappedRaster;\n+\n+public class XGraphics implements Cloneable, DirectRasterGraphics\n+{\n+  static class XRaster extends MappedRaster\n+  {\n+    XImage ximage;\n+    \n+    public XRaster(WritableRaster raster, XImage ximage, ColorModel cm)\n+    {\n+      super(raster, cm);\n+      this.ximage = ximage;\n+    }\n+  }\n+  \n+  GC context;\n+  XGraphicsConfiguration config;\n+  Rectangle clipBounds;\n+    \n+  XFontMetrics metrics;\n+\n+\n+  public Object clone()\n+  {\n+    XGraphics gfxCopy = (XGraphics) super.clone();\n+    gfxCopy.context = context.create();\n+    \n+    return gfxCopy;\n+  }\n+\n+  public void dispose()\n+  {\n+    GC lContext = context;\n+    context = null;\n+    config = null;\n+    clipBounds = null;\n+    \n+    if (lContext != null)\n+      {\n+\tlContext.dispose();\n+      }\t    \n+  }\n+\n+  public XGraphics(Drawable drawable, XGraphicsConfiguration config)\n+  {\n+    context = new GC(drawable);\n+    this.config = config;\n+  }  \n+  \n+  public void setColor(Color color)\n+  {\n+    context.setForeground(config.getPixel(color));\n+  }\n+\n+  public void setPaintMode()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  public void setXORMode(Color c1)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+    \n+  public void setFont(Font font)\n+  {\n+    if ((metrics != null) && font.equals(metrics.getFont())) return;\n+\n+    metrics = config.getXFontMetrics(font);\n+    context.setFont(metrics.xfont);\n+  }\n+    \n+  public FontMetrics getFontMetrics(Font font)\n+  {\n+    if ((metrics != null) && font.equals(metrics.getFont()))\n+      return metrics;\n+    \n+    return config.getXFontMetrics(font);\n+  }\n+    \n+  public void setClip(int x, int y, int width, int height)\n+  {\n+    Rectangle[] rects = { new Rectangle(x, y, width, height) };\n+    context.setClipRectangles(rects);\n+  }\n+    \n+  public void setClip(Shape clip)\n+  {\n+    /* TODO: create a special RectangleUnion shape that can be\n+       used to draw advantage of the GCs ability to set multiple\n+       rectangles. \n+    */\n+\n+    /* FIXME: creating all these objects is wasteful and can be\n+       costly in the long run, since this code is run at every\n+       expose. */\n+    Rectangle newClipBounds = clip.getBounds();\n+    \n+    if ((clipBounds != null) && !clipBounds.contains(newClipBounds))\n+      {\n+\tSystem.err.println(\"warning: old clip (\"+ clipBounds +\") does \" +\n+\t\t\t   \"not fully contain new clip (\" +\n+\t\t\t   newClipBounds + \")\");\n+      }\n+    clipBounds = newClipBounds;\n+    Rectangle[] rects = { clipBounds };\n+    context.setClipRectangles(rects);\n+  }\n+    \n+  public void copyArea(int x, int y, int width, int height, int\n+\t\t       dx, int dy)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+    \n+  public void drawLine(int x1, int y1, int x2, int y2)\n+  {\n+    context.drawLine(x1, y1, x2, y2);\n+  }\n+    \n+  public void drawRect(int x, int y, int width, int height)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+    \n+  public void fillRect(int x, int y, int width, int height)\n+  {\n+    context.fillRectangle(x, y, width, height);\n+  }\n+    \n+  public void drawArc(int x, int y, int width, int height, int\n+\t\t      startAngle, int arcAngle)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+    \n+  public void fillArc(int x, int y, int width, int height, int\n+\t\t      startAngle, int arcAngle)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+    \n+  public void drawPolyline(int[] xPoints, int[] yPoints, int\n+\t\t\t   nPoints)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+    \n+  public void drawPolygon(int[] xPoints, int[] yPoints, int\n+\t\t\t  nPoints)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+    \n+  public void fillPolygon(int[] xPoints, int[] yPoints, int\n+\t\t\t  nPoints)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  public void drawString(String str, int x, int y)\n+  {\n+    context.drawString(str, x, y);\n+  }\n+\n+  public boolean drawImage(Image img, int x, int y,\n+\t\t\t   ImageObserver observer)\n+  {\n+    if (clipBounds == null)\n+      return false; // ***FIXME***\n+\n+    if (!(img instanceof BufferedImage))\n+      {\n+\tthrow new AWTError(\"unknown image class\");\n+      }\n+\t\n+    BufferedImage bimg = (BufferedImage) img;\n+\n+    XImage ximg = (XImage) bimg.getProperty(\"gnu.gcj.xlib.XImage\");\n+    if (ximg == null)\n+      {\n+\tSystem.err.println(\"FIXME: skipping null XImage, should \" +\n+\t\t\t   \"really do on the spot conversion\");\n+\treturn false;\n+      }\n+\n+    /*\n+      +------------------\n+      |    clip\n+      |     +---------+\n+      | img |         |\n+      |  +--+-------+ |\n+      |  |  |       | | \n+      |  |  |       | |\n+      |  |  +-------+-+\n+      |  |          |\n+      |  +----------+\n+    */\n+\n+    int iLeft   = Math.max(x, clipBounds.x);\n+    int iTop    = Math.max(y, clipBounds.y);\n+    int iRight  = Math.min(x + bimg.getWidth(),\n+\t\t\t   clipBounds.x + clipBounds.width);\n+    int iBottom = Math.min(y + bimg.getHeight(),\n+\t\t\t   clipBounds.y + clipBounds.height);\n+    \n+    int srcX = iLeft - x;\n+    int srcY = iTop  - y;\n+    \n+    int width  = iRight  - iLeft;\n+    int height = iBottom - iTop;\n+    \n+    if ((width > 0) && (height > 0))\n+      context.putImage(ximg, srcX, srcY, iLeft, iTop, width, height);\n+\n+    return true;\n+  }\n+\n+  public MappedRaster mapRaster(Rectangle bounds)\n+  {\n+    Visual visual = config.getVisual();\n+    XImage ximage = new XImage(visual, bounds.width, bounds.height,\n+\t\t\t       false // do not auto allocate memory\n+\t\t\t       );\n+\n+    WritableRaster raster =\n+      config.createRasterForXImage(ximage,\n+\t\t\t\t   new Point(bounds.x, bounds.y));\n+    \n+    DataBuffer dataB = raster.getDataBuffer();\n+    XGraphicsConfiguration.attachData(ximage, dataB, 0);\n+\n+    Drawable drawable = context.getDrawable();\n+\n+    // TODO: restrict to clipping\n+\n+    Rectangle mBounds = drawable.copyIntoXImage(ximage, bounds, 0, 0);\n+\t\n+    return new XRaster(raster, ximage, config.imageCM);\n+  }\n+    \n+    \n+  public void unmapRaster(MappedRaster mappedRaster)\n+  {\n+    XRaster xraster = (XRaster) mappedRaster;\n+    XImage ximage = xraster.ximage;\n+    Raster raster = xraster.getRaster();\n+    int x = raster.getMinX();\n+    int y = raster.getMinY();\n+    int width = raster.getWidth();\n+    int height = raster.getHeight();\n+    \n+    context.putImage(ximage, 0, 0, x, y, width, height);\n+  }\n+}"}, {"sha": "af2663ba58bca18d91b22270d7de71ef59e9463b", "filename": "libjava/gnu/awt/xlib/XGraphicsConfiguration.java", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphicsConfiguration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphicsConfiguration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXGraphicsConfiguration.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,367 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.xlib;\n+\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Rectangle;\n+import java.awt.Graphics2D;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.Color;\n+import java.awt.color.ColorSpace;\n+import java.awt.image.*;\n+import java.awt.geom.AffineTransform;\n+import gnu.gcj.xlib.GC;\n+import gnu.gcj.xlib.Drawable;\n+import gnu.gcj.xlib.Window;\n+import gnu.gcj.xlib.XImage;\n+import gnu.gcj.xlib.Visual;\n+import gnu.gcj.xlib.Colormap;\n+import gnu.gcj.xlib.XColor;\n+import gnu.gcj.xlib.Screen;\n+import gnu.gcj.xlib.Display;\n+import gnu.gcj.awt.Buffers;\n+import java.util.Hashtable;\n+\n+public class XGraphicsConfiguration extends GraphicsConfiguration\n+{\n+  //public abstract GraphicsDevice getDevice();\n+  \n+  Visual visual;\n+  int format;\n+  Colormap colormap;\n+  ColorModel imageCM;\n+  ColorModel pixelCM;\n+  \n+  public XGraphicsConfiguration(Visual visual)\n+  {\n+    this.visual = visual;\n+  }\n+\n+  public BufferedImage createCompatibleImage(int width, int height)\n+  {\n+    XImage ximg = new XImage(visual, width, height,\n+\t\t\t     false // do not auto allocate memory\n+\t\t\t     );\n+\n+    Point origin = new Point(0, 0);\n+    WritableRaster raster = createRasterForXImage(ximg, origin);\n+\n+    /* This is not a good way of doing this. Multiple toolkits may\n+       want to share the BufferedImage. */\n+    Hashtable props = new Hashtable();\n+    props.put(\"gnu.gcj.xlib.XImage\", ximg);\n+    props.put(\"java.awt.GraphicsConfiguration\", this);\n+    \n+    BufferedImage bimg = new BufferedImage(imageCM,raster, false, props);\n+\n+    DataBuffer dataB = raster.getDataBuffer();\n+    attachData(ximg, dataB, 0);\n+    return bimg;\n+  }\n+\n+  WritableRaster createRasterForXImage(XImage ximage, Point origin)\n+  {\n+    if (imageCM == null) prepareColorModel(ximage);\n+    \n+    /*\n+      This will not work, since it creates a sample model that\n+      does not necessarily match the format of the XImage.\n+      \n+      WritableRaster raster =\n+      imageCM.createCompatibleWritableRaster(width, height); */\n+    \n+    // Create a sample model matching the XImage:\n+\n+    SampleModel imageSM = null;\n+\n+    int width = ximage.getWidth();\n+    int height = ximage.getHeight();\n+    int bitsPerPixel = ximage.getBitsPerPixel();\n+    int dataType =\n+      Buffers.smallestAppropriateTransferType(bitsPerPixel);\n+    int bitsPerDataElement = DataBuffer.getDataTypeSize(dataType);\n+    int scanlineStride = ximage.getBytesPerLine()*8/bitsPerDataElement;\n+    \n+    if (imageCM instanceof IndexColorModel)\n+      {\n+\tint[] bandOffsets = {0};\n+\timageSM = new ComponentSampleModel(dataType,\n+\t\t\t\t\t   width, height,\n+\t\t\t\t\t   1, // pixel stride\n+\t\t\t\t\t   scanlineStride,\n+\t\t\t\t\t   bandOffsets);\n+      }\n+    else if (imageCM instanceof PackedColorModel)\n+      {\n+\tPackedColorModel pcm = (PackedColorModel) imageCM;\n+\tint[] masks = pcm.getMasks();\n+\t\n+\timageSM = new SinglePixelPackedSampleModel(dataType,\n+\t\t\t\t\t\t   width, height,\n+\t\t\t\t\t\t   scanlineStride,\n+\t\t\t\t\t\t   masks);\n+      }\n+\n+    if (imageSM == null)\n+      {\n+\tthrow new UnsupportedOperationException(\"creating sample model \" +\n+\t\t\t\t\t\t\"for \" + imageCM +\n+\t\t\t\t\t\t\" not implemented\");\n+      }\n+\n+    WritableRaster raster = Raster.createWritableRaster(imageSM, origin);\n+    return raster;\n+  }\n+\n+\n+\n+  /**\n+   * Attach a the memory of a data buffer to an XImage\n+   * structure. [This method is not gnu.awt.xlib specific, and should\n+   * maybe be moved to a different location.]\n+   *\n+   * @param offset Offset to data. The given offset does not include\n+   * data buffer offset, which will also be added.  */\n+  static void attachData(XImage ximage, DataBuffer dataB, int offset)\n+  {\n+    offset += dataB.getOffset();\n+    switch (dataB.getDataType())\n+      {\n+      case DataBuffer.TYPE_BYTE:\n+\tximage.setData(((DataBufferByte) dataB).getData(), offset);\n+\tbreak;\n+      case DataBuffer.TYPE_USHORT:\n+\tximage.setData(((DataBufferUShort) dataB).getData(), offset);\n+\tbreak;\n+      case DataBuffer.TYPE_INT:\n+\tximage.setData(((DataBufferInt) dataB).getData(), offset);\n+\tbreak;\n+      default:\n+\tthrow\n+\t  new UnsupportedOperationException(\"Do not know how to \" +\n+\t\t\t\t\t    \"set data for data \" +\n+\t\t\t\t\t    \"type \" +\n+\t\t\t\t\t    dataB.getDataType());\n+      }\n+  }\n+    \n+  void prepareColorModel(XImage ximage)\n+  {\n+    format = ximage.getFormat();\n+    int bitsPerPixel = ximage.getBitsPerPixel();\n+    switch (format) {\n+    case XImage.ZPIXMAP_FORMAT:\n+      calcZPixmapModels(bitsPerPixel);\n+      break;\n+      \n+    default:\n+      throw new UnsupportedOperationException(\"unimplemented format\");\n+    }\n+  }\n+\n+  void calcZPixmapModels(int bitsPerPixel)\n+  {\n+    switch (visual.getVisualClass())\n+      {\n+      case Visual.VC_TRUE_COLOR:\n+\tcalcDecomposedRGBModels(bitsPerPixel);\n+\tbreak;\n+      case Visual.VC_PSEUDO_COLOR:\n+\tcalcPseudoColorModels(bitsPerPixel);\n+\tbreak;\n+      default:\n+\tString msg = \"unimplemented visual class\";\n+\tthrow new UnsupportedOperationException(msg);\n+      }\n+  }\n+    \n+  void calcDecomposedRGBModels(int bitsPerPixel)\n+  {\n+    int dataType = Buffers.smallestAppropriateTransferType(bitsPerPixel);\n+    \n+    \n+    if (DataBuffer.getDataTypeSize(dataType) == bitsPerPixel)\n+      {\t\n+\tColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+\t\n+\timageCM = new DirectColorModel(cs,\n+\t\t\t\t       visual.getDepth(),\n+\t\t\t\t       visual.getRedMask(),\n+\t\t\t\t       visual.getGreenMask(),\n+\t\t\t\t       visual.getBlueMask(),\n+\t\t\t\t       0, // no alpha\n+\t\t\t\t       false,\n+\t\t\t\t       dataType);\n+      }\n+    else\n+      {\n+\tthrow new\n+\t  UnsupportedOperationException(\"unimplemented bits per pixel\");\n+      }\n+    }\n+    \n+  void calcPseudoColorModels(int bitsPerPixel)\n+  {\n+    if (colormap == null)\n+      colormap = visual.getScreen().getDefaultColormap();\n+    \n+    XColor[] colArray = colormap.getXColors();\n+\t\n+    int numCol = colArray.length;\n+    byte[] rmap = new byte[numCol];\n+    byte[] gmap = new byte[numCol];\n+    byte[] bmap = new byte[numCol];\n+    byte[] amap = new byte[numCol];\n+    \n+    for (int i=0; i < numCol; i++)\n+      {\n+\tXColor color = colArray[i];\n+\tif (color.getFlags() == Colormap.FLAG_SHARED)\n+\t  {\n+\t    rmap[i] = (byte) (color.getRed()   >> 8);\n+\t    gmap[i] = (byte) (color.getGreen() >> 8);\n+\t    bmap[i] = (byte) (color.getBlue()  >> 8);\n+\t    amap[i] = (byte) 0xff;\n+\t  } // else, leave default zero values...\n+      }\n+\n+    imageCM = new IndexColorModel(visual.getDepth(), numCol,\n+\t\t\t\t  rmap, gmap, bmap, amap);\n+  }\n+\n+  public BufferedImage createCompatibleImage(int width,\n+\t\t\t\t\t     int height,\n+\t\t\t\t\t     int transparency)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+    \n+  /**\n+   * FIXME: I'm not sure which color model that should be returned here.\n+   */\n+  public ColorModel getColorModel()\n+  {\n+    if (pixelCM == null)\n+      preparePixelCM();\n+    return pixelCM;\n+  }\n+\n+  void preparePixelCM()\n+  {\n+    switch (visual.getVisualClass())\n+      {\n+      case Visual.VC_TRUE_COLOR:\n+\tpixelCM = new DirectColorModel(visual.getDepth(),\n+\t\t\t\t       visual.getRedMask(),\n+\t\t\t\t       visual.getGreenMask(),\n+\t\t\t\t       visual.getBlueMask());\n+\tbreak;\n+      case Visual.VC_PSEUDO_COLOR:\n+\n+\tif (colormap == null)\n+\t  colormap = visual.getScreen().getDefaultColormap();\n+\t\n+\tXColor[] colArray = colormap.getXColors();\n+\t\n+\tint numCol = colArray.length;\n+\tbyte[] rmap = new byte[numCol];\n+\tbyte[] gmap = new byte[numCol];\n+\tbyte[] bmap = new byte[numCol];\n+\tbyte[] amap = new byte[numCol];\n+\t\n+\tfor (int i=0; i < numCol; i++)\n+\t  {\n+\t    XColor color = colArray[i];\n+\t    if (color.getFlags() == Colormap.FLAG_SHARED) {\n+\t      rmap[i] = (byte) (color.getRed()   >> 8);\n+\t      gmap[i] = (byte) (color.getGreen() >> 8);\n+\t      bmap[i] = (byte) (color.getBlue()  >> 8);\n+\t      amap[i] = (byte) 0xff;\n+\t    } // else, leave default zero values...\n+\n+\t  }\n+\n+\tpixelCM = new IndexColorModel(visual.getDepth(), numCol,\n+\t\t\t\t      rmap, gmap, bmap, amap);\n+\tbreak;\n+      default:\n+\tthrow new UnsupportedOperationException(\"not implemented\");\n+      }\n+  }\n+  \n+  public ColorModel getColorModel(int transparency)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+    \n+  public AffineTransform getDefaultTransform()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  public AffineTransform getNormalizingTransform()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+ \n+  public Rectangle getBounds()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented\");\n+  }\n+\n+  Visual getVisual()\n+  {\n+    return visual;\n+  }\n+    \n+  /* FIXME: This should be moved to XGraphicsDevice... */\n+  XFontMetrics getXFontMetrics(java.awt.Font awtFont)\n+  {\n+    // FIXME: do caching...\n+    \n+    String family       = \"*\";\n+    String name         = awtFont.getName();\n+    String weight       = awtFont.isBold() ? \"bold\" : \"medium\";\n+    String slant        = awtFont.isItalic() ? \"i\" : \"r\";\n+    String addStyle     = \"*\";\n+    String pixelSize    = \"*\";\n+    String pointSize    = awtFont.getSize() + \"0\";\n+    String xres         = \"*\";\n+    String yres         = \"*\";\n+    String spacing      = \"*\";\n+    String averageWidth = \"*\";\n+    String charset      = \"*\";\n+    \n+    String logicalFontDescription =\n+      family    + \"-\" + name         + \"-\" + weight    + \"-\" +\n+      slant     + \"-\" + addStyle     + \"-\" + pixelSize + \"-\" +\n+      pointSize + \"-\" + xres         + \"-\" + yres      + \"-\" +\n+      spacing   + \"-\" + averageWidth + \"-\" + charset;\n+    \n+    Display display = visual.getScreen().getDisplay();\n+    gnu.gcj.xlib.Font xfont =\n+      new gnu.gcj.xlib.Font(display, logicalFontDescription);\n+    return new XFontMetrics(xfont, awtFont);\n+  }\n+\n+  int getPixel(Color color)\n+  {\n+    int[] components =\n+        {\n+\t  color.getRed(),\n+\t  color.getGreen(),\n+\t  color.getBlue(),\n+\t  0xff\n+\t};\n+\t\n+    ColorModel cm = getColorModel();\n+    return cm.getDataElement(components, 0);\n+  }\n+}"}, {"sha": "c4ff3f17b71e8e1d58190b12e3033030c90f49b5", "filename": "libjava/gnu/awt/xlib/XPanelPeer.java", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXPanelPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXPanelPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXPanelPeer.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,52 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.xlib;\n+\n+import java.awt.*;\n+import java.awt.peer.*;\n+import java.awt.image.*;\n+import gnu.gcj.xlib.WMSizeHints;\n+import gnu.gcj.xlib.WindowAttributes;\n+import gnu.gcj.xlib.Display;\n+import gnu.gcj.xlib.Visual;\n+import gnu.gcj.xlib.Screen;\n+\n+public class XPanelPeer extends XCanvasPeer implements PanelPeer\n+{\n+\n+  public XPanelPeer(Panel panel)\n+  {\n+    super(panel);\n+  }\n+\n+  // no reason to override yet\n+  //void initWindowProperties();\n+  //gnu.gcj.xlib.Window getParentWindow();\n+  \n+\n+  // Implementing ContainerPeer:\n+  \n+  // Default is no insets...\n+  static final Insets INSETS_0_PROTOTYPE = new Insets(0, 0, 0, 0);\n+\n+  public Insets getInsets()\n+  {\n+    return (Insets) INSETS_0_PROTOTYPE.clone();\n+  }\n+\n+  public void beginValidate()\n+  {\n+    // NOP\n+  }\n+  \n+  public void endValidate()\n+  {\n+    // NOP\n+  }\n+}"}, {"sha": "e400b05e64803242a8a12e678f4478abf28fd3c9", "filename": "libjava/gnu/awt/xlib/XToolkit.java", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fawt%2Fxlib%2FXToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fawt%2Fxlib%2FXToolkit.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,333 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.awt.xlib;\n+\n+import java.awt.*;\n+import java.awt.peer.*;\n+import java.awt.image.ImageProducer;\n+import java.awt.image.ImageObserver;\n+import java.net.*;\n+import java.awt.datatransfer.Clipboard;\n+\n+import gnu.gcj.xlib.Display;\n+import gnu.gcj.xlib.Screen;\n+import gnu.gcj.xlib.Visual;\n+\n+public class XToolkit extends Toolkit\n+{\n+  static XToolkit INSTANCE;\n+  \n+  Display display;\n+\n+  EventQueue queue;\n+  XEventLoop eventLoop;\n+\n+  XGraphicsConfiguration defaultConfig;\n+\n+  public XToolkit()\n+  {\n+    INSTANCE = this;\n+    display = new Display();\n+    synchronized (display)\n+      {\n+\tqueue = new XEventQueue(display);\n+\teventLoop = new XEventLoop(display, queue);\n+      }\n+  }\n+\n+  public void flushIfIdle()\n+  {\n+    eventLoop.flushIfIdle();\n+  }\n+\n+  protected ButtonPeer createButton(Button frontend)\n+  {\n+    // FIXME: Stubbed out, needs Swing:\n+    /*\n+    XCanvasPeer realPeer = new XCanvasPeer(frontend);\n+    SButtonPeer sbPeer = new SButtonPeer(frontend, realPeer);\n+    return sbPeer;\n+    */\n+    return null;\n+  }\n+    \n+  protected TextFieldPeer createTextField(TextField frontend)\n+  {\n+    return null; // FIXME\n+  }\n+    \n+  protected LabelPeer createLabel(Label frontend) \n+  {\n+    return null; // FIXME\n+  }\n+    \n+  protected ListPeer createList(List frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected CheckboxPeer createCheckbox(Checkbox frontend) \n+  {\n+    return null; // FIXME\n+  }\n+    \n+  protected ScrollbarPeer createScrollbar(Scrollbar frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected ScrollPanePeer createScrollPane(ScrollPane frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected TextAreaPeer createTextArea(TextArea frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected ChoicePeer createChoice(Choice frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected FramePeer createFrame(Frame frontend) {\n+    return new XFramePeer(frontend);\n+  }\n+\n+  protected CanvasPeer createCanvas(Canvas frontend) {\n+    XCanvasPeer peer = new XCanvasPeer(frontend);\n+    return peer;\n+  }\n+  \n+  protected PanelPeer createPanel(Panel frontend) {\n+    return new XPanelPeer(frontend);\n+  }\n+\n+  protected WindowPeer createWindow(Window frontend) \n+  {\n+    return null; // FIXME\n+  }\n+    \n+  protected DialogPeer createDialog(Dialog frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected MenuBarPeer createMenuBar(MenuBar frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected MenuPeer createMenu(Menu frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected PopupMenuPeer createPopupMenu(PopupMenu frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected MenuItemPeer createMenuItem(MenuItem frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected FileDialogPeer createFileDialog(FileDialog frontend) \n+  {\n+    return null; // FIXME\n+  }\n+  \n+  protected CheckboxMenuItemPeer\n+      createCheckboxMenuItem(CheckboxMenuItem frontend) \n+  {\n+    return null; // FIXME\n+  }\n+\n+  protected java.awt.peer.FontPeer getFontPeer(String name, int style) \n+  {\n+    return null;\n+  }\n+\n+  public Dimension getScreenSize()\n+  { \n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public int getScreenResolution()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public java.awt.image.ColorModel getColorModel()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public String[] getFontList()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public FontMetrics getFontMetrics(Font font)\n+  {\n+    return defaultConfig.getXFontMetrics(font);\n+  }\n+\n+  public void sync()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+    \n+  public Image getImage(String filename)\n+  {\n+    return createImage(filename);\n+  }\n+  \n+  public Image getImage(URL url)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public Image createImage(String filename)\n+  {\n+    // FIXME: Stubbed out. We need a proper image I/O API.\n+\n+    /*\n+    BufferedImage jpeg;\n+    FileInputStream fis = openFile(filename);\n+    if (fis == null)\n+      return null;\n+    \n+    BasicRasterImageConsumer consumer = new BasicRasterImageConsumer();\n+    JPEGImageDecoder jid = new JPEGImageDecoder(fis);\n+\n+    jid.startProduction(consumer);\n+    jpeg = consumer.getImage();\n+    \n+    int w = jpeg.getWidth();\n+    int h = jpeg.getHeight();\n+    \n+    BufferedImage img =\n+      getDefaultXGraphicsConfiguration().createCompatibleImage(w, h);\n+    \n+    Renderers renderers = Renderers.getInstance();\n+    \n+    RasterOp renderer = renderers.createRenderer(jpeg.getColorModel(),\n+\t\t\t\t\t\t jpeg.getSampleModel(),\n+\t\t\t\t\t\t img.getColorModel(),\n+\t\t\t\t\t\t img.getSampleModel());\n+\t\n+    if (renderer == null)\n+      {\n+\tthrow new UnsupportedOperationException(\"couldn't find renderer\");\n+      }\n+\n+    renderer.filter(jpeg.getRaster(), img.getRaster());\n+    \n+    return img;\n+    */\n+\n+    return null;\n+  }\n+\n+  public Image createImage(URL url)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public boolean prepareImage(Image image,\n+\t\t\t      int width,\n+\t\t\t      int height,\n+\t\t\t      ImageObserver observer)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public int checkImage(Image image,\n+\t\t\tint width,\n+\t\t\tint height,\n+\t\t\tImageObserver observer)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+  \n+  public Image createImage(ImageProducer producer)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public Image createImage(byte[] imagedata,\n+\t\t\t   int imageoffset,\n+\t\t\t   int imagelength)\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  /*\n+    public PrintJob getPrintJob(Frame frame,\n+\t\t\t\tString jobtitle,\n+\t\t\t\tProperties props);\n+  */\n+\n+  public void beep()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+\n+  public Clipboard getSystemClipboard() \n+  {\n+    return null; // FIXME\n+  }\n+    \n+  protected EventQueue getSystemEventQueueImpl()\n+  {\n+    return queue;\n+  }\n+    \n+  XGraphicsConfiguration getDefaultXGraphicsConfiguration()\n+  {\n+    if (defaultConfig == null)\n+      {\n+\tScreen screen = display.getDefaultScreen();\n+\tVisual visual = screen.getRootVisual();\n+\tdefaultConfig = new XGraphicsConfiguration(visual);\n+\n+\t// ASSERT:\n+\tif (!defaultConfig.getVisual().getScreen().equals(screen))\n+\t  {\n+\t    String msg = \"screen of graphics configuration is not \" +\n+\t      \"default screen\";\n+\t    throw new Error(msg);\n+\t  }\n+      }\n+    \n+    return defaultConfig;\n+  }\n+\n+\n+    /*\n+    public DragSourceContextPeer\n+\tcreateDragSourceContextPeer(DragGestureEvent dge)\n+\tthrows InvalidDnDOperationException;\n+\n+    public DragGestureRecognizer\n+\tcreateDragGestureRecognizer(Class abstractRecognizerClass,\n+\t\t\t\t    DragSource ds, Component c,\n+\t\t\t\t    int srcActions, DragGestureListener dgl) {\n+\tthrow new UnsupportedOperationException(\"not implemented\");\n+    }\n+    */\n+\n+    \n+    /*\n+    public Map mapInputMethodHighlight(InputMethodHighlight highlight);\n+    */\n+}"}, {"sha": "28bb02a8e2173dcda01da002c0f760e4ea362af1", "filename": "libjava/gnu/gcj/xlib/Clip.java", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FClip.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FClip.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FClip.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,35 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+import java.awt.Rectangle;\n+\n+/**\n+ * Describes a clip that is used to constrain drawing using a GC\n+ * within a specific region. Currently it supports clip regions\n+ * consisting of the union of multiple rectangles. Other clip forms\n+ * may be implented later. This class is used internally by the GC\n+ * class, and wraps a native XRectVector[].\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+final class Clip\n+{\n+  public Clip(Rectangle[] rects)\n+  {\n+    init(rects);\n+  }\n+\n+  private native void init(Rectangle[] rects);\n+\n+  public native void finalize();\n+\n+  RawData xrects;\n+}"}, {"sha": "538782e7e76cc99a1744a49adeb901276b3f0dc5", "filename": "libjava/gnu/gcj/xlib/Colormap.java", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FColormap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FColormap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FColormap.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,84 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+\n+/**\n+ * An X11 color map resource.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public final class Colormap extends XID\n+{\n+  Screen screen;\n+  \n+  public static final byte FLAG_SHARED = 1;\n+  public static final byte FLAG_NOT_SHARED = 2;\n+  \n+  public Colormap(Screen screen, int xid)\n+  {\n+    super(screen.getDisplay(), xid);\n+    this.screen = screen;\n+  }\n+  \n+  /**\n+   * Allocate color pixel.\n+   *\n+   * @param color The color to be allocated.  If allocation is\n+   * successful, this object will be modified to reflect the actual\n+   * color that was allocated.\n+   *\n+   * @return the pixel value of the allocated color.\n+   */\n+  public native long allocateColorPixel(XColor color);\n+\n+  /**\n+   * Allocate a color consisting of the given RGB-triplet.\n+   *\n+   * @return a color object describing the allocated color.\n+   */\n+  public XColor allocateColor(int r, int g, int b)\n+  {\n+    XColor color = new XColor(r, g, b);\n+    allocateColorPixel(color);\n+    \n+    return color;\n+  }\n+\n+  /**\n+   * Get an array of all colors that currently resides in shared (read\n+   * only) color-cells in this color map.\n+   */\n+  public native XColor[] getSharedColors();\n+\n+\n+  /**\n+   * Get all colors currently residing in this color map.  Colors that\n+   * are shared (read only) are marked as such by the color flags.\n+   * The indexes of the returned array will correspond to the\n+   * colorcells of the color map.  Given a color <code>XColor\n+   * color</code> from a given color-cell, the expression\n+   * <code>color.getFlags() == Colormap.FLAG_SHARED</code> will check\n+   * whether the color-cell is shared.\n+   */\n+  public native XColor[] getXColors();\n+\n+  /**\n+   * Convenience method used by native code to create fully\n+   * initialized arrays of XColor objects.\n+   */\n+  private XColor[] newXColorArray(int n)\n+  {\n+    XColor[] array = new XColor[n];\n+    for (int i=0; i<n; i++)\n+      array[i] = new XColor();\n+    return array;\n+  }\n+}"}, {"sha": "50ff1291b71b2a8282cf3d5cab5cf1434d37df08", "filename": "libjava/gnu/gcj/xlib/Display.java", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FDisplay.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FDisplay.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FDisplay.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,105 @@\n+/* Copyright (C) 1999, 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import java.util.Dictionary;\n+import java.util.Hashtable;\n+import java.util.Vector;\n+import java.util.Enumeration;\n+\n+import gnu.gcj.RawData;\n+\n+/**\n+ * A connection to an X11 display.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+\n+public class Display\n+{\n+  static\n+  {\n+    staticInit();\n+  }\n+\n+  public Display()\n+  {\n+    init();\n+  }\n+    \n+  private static native void staticInit();\n+  private native void init();\n+  protected native void finalize();\n+\n+  RawData display = null;\n+\n+  /* TODO?: Rather than storing such data here, we might consider\n+     using the context manager facilities provided by Xlib... */\n+  private Dictionary xids = new Hashtable();\n+\n+  protected final void addXID(int xid, XID window)\n+  {\n+    xids.put(new Integer(xid), window);\n+  }\n+  \n+  protected final void removeXID(int xid)\n+  {\n+    xids.remove(new Integer(xid));\n+  }\n+\n+  public final Window getDefaultRootWindow()\n+  {\n+    int rootXID = getDefaultRootWindowXID();\n+    return getWindow(rootXID);\n+  }\n+\n+  public final XID getXID(int xid)\n+  {\n+    return (XID) xids.get(new Integer(xid));\n+  }\n+\n+  public final Window getWindow(int xid)\n+  {\n+    Window window = (Window) getXID(xid);\n+    if (window == null)\n+      {\n+\twindow = new Window(this, xid);\n+\taddXID(xid, window);\n+      }\n+    return window;\n+  }\n+\n+  public final Screen getDefaultScreen()\n+  {\n+    /* Screens objects are not cached since they are lightweight.\n+       We just create a new object when requested. */\n+    return new Screen(this, getDefaultScreenNumber());\n+  }\n+\n+  public final native int getDefaultScreenNumber();\n+\n+  private final native int getDefaultRootWindowXID();\n+    \n+  private Dictionary atoms = new Hashtable();\n+\n+  public final int getAtom(String name)\n+  {\n+    Integer atomInt = (Integer) atoms.get(name);\n+    if (atomInt == null)\n+      return internAtom(name);\n+    return atomInt.intValue();\n+  }\n+\n+  // TODO?: cache reverse lookup too?\n+  public final native String getAtomName(int atom);\n+\n+  private final native int internAtom(String name);\n+\n+  public native void flush();\n+}"}, {"sha": "56527927b1bb2a1fa26adc536e01cf7f94e7080a", "filename": "libjava/gnu/gcj/xlib/Drawable.java", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FDrawable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FDrawable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FDrawable.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,82 @@\n+/* Copyright (C) 1999, 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import java.awt.Rectangle;\n+\n+/** An X11 drawable.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class Drawable extends XID\n+{\n+  public Drawable(Display display, int xid)\n+  {\n+    super(display, xid);\n+  }\n+\n+  /**\n+   * Gets as much as possible of the image data within the requested\n+   * region. Data from obscured parts of windows may not be\n+   * retrievable.\n+   *  \n+   * @param dest where to place the image data.\n+   * \n+   * @return the actual region of image data that was retrieved.\n+   */\n+  public Rectangle copyIntoXImage(XImage dest, Rectangle bounds,\n+\t\t\t\t  int destX, int destY)\n+  {\n+    Rectangle newBounds = null;\n+    int tries = 5;\n+    while (!bounds.isEmpty())\n+      {\n+\tif (copyIntoXImageImpl(dest, bounds.x, bounds.y,\n+\t\t\t       bounds.width, bounds.height,\n+\t\t\t       destX, destY))\n+\t  return bounds;\n+\t    \n+\t// failed, likely due to wrong bounds...\n+\t\n+\tnewBounds = getBounds(newBounds);\n+\t\n+\tbounds = newBounds.intersection(bounds);\n+\t\n+\ttries--;\n+\t\n+\tif (tries < 0)\n+\tthrow new RuntimeException(\"copyIntoXImage is buggy\");\n+\t\n+      }\n+    \n+    return bounds; // always empty\n+  }\n+\n+\n+\n+  /**\n+   * Performs an XGetSubImage. This method will fail if the X server\n+   * does not possess the requested image data. This might occur when\n+   * requesting the image date of a window that is partially obscured.\n+   *\n+   * @param desitantionImage where to place the image data\n+   *\n+   * @return false if method was unable to read the requested region.\n+   */\n+  private native boolean copyIntoXImageImpl(XImage destinationImage,\n+\t\t\t\t\t    int x, int y,\n+\t\t\t\t\t    int width, int height,\n+\t\t\t\t\t    int destX, int destY);\n+\n+  public native Rectangle getBounds(Rectangle rv);\n+  \n+  private static final String MSG_XGETSUBIMAGE_FAILED =\n+    \"XGetSubImage() failed.\";\n+    \n+}"}, {"sha": "cd2fff9630d86511f971a1d1871a319a7a702e28", "filename": "libjava/gnu/gcj/xlib/Font.java", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FFont.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FFont.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FFont.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,51 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+\n+/**\n+ * An X11 Font, implemented as a wrapper around an X11 Font XID and\n+ * the associated Xlib XFontStruct structure.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public final class Font extends XID\n+{\n+\n+  /**\n+   * @param lfdNamePattern a font name pattern following the\n+   * <em>X Logical Font Description Conventions</em>.\n+   */\n+  public Font(Display display, String lfdNamePattern)\n+  {\n+    this(display, loadFont(display, lfdNamePattern));\n+  }\n+\n+  Font(Display display, RawData struct)\n+  {\n+    super(display, getXIDFromStruct(struct));\n+    structure = struct;\n+  }\n+\n+  static native RawData loadFont(Display display, String lfdNamePattern);\n+\n+  static native int getXIDFromStruct(RawData structure);\n+\n+  public native int getAscent();\n+  public native int getDescent();\n+  public native int getMaxAscent();\n+  public native int getMaxDescent();\n+\n+  public native int getStringWidth(String str);\n+\n+  protected native void finalize();\n+\n+  RawData structure;\n+}"}, {"sha": "6b33715cf6cd7e2d718fca6071f5226f01953c67", "filename": "libjava/gnu/gcj/xlib/GC.java", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FGC.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FGC.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FGC.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,113 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+import java.awt.Rectangle;\n+\n+/**\n+ * An X11 graphics context.  Unlike a traditional X11 graphics\n+ * context, the target drawable is part of the GC state.\n+ *\n+ * Implementation notes: There is no need to do coalescing of changes\n+ * since Xlib will do this for us.  The implementation relies on the\n+ * Xlib GC cache and will not try to be clever.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class GC implements Cloneable\n+{\n+  \n+  public GC(Drawable target)\n+  {\n+    this.target = target;\n+    initStructure(null);\n+  }\n+\n+  public Object clone()\n+  {\n+    GC gcClone = (GC) super.clone();\n+    gcClone.structure = null;\n+    gcClone.initStructure(this);\n+    gcClone.updateClip();\n+    return gcClone;\n+  }\n+\n+  private native void initStructure(GC copyFrom);\n+\n+  public GC create()\n+  {\n+    return (GC) clone();\n+  }\n+\n+  public void finalize()\n+  {\n+    disposeImpl();\n+  }\n+\n+  public void dispose()\n+  {\n+    disposeImpl();\n+  }\n+\n+  public synchronized native void disposeImpl();\n+\n+  public native void setForeground(long pixel);\n+  public native void setFont(gnu.gcj.xlib.Font font);\n+\n+  /**\n+   * Set the clip region for the graphics operations performed by the\n+   * GC.\n+   *\n+   * This is one of the few costly operations of this class.  It is\n+   * suggested that the clip is only set or changed if really\n+   * necessary.  Higher level APIs can make such optimizations\n+   * transparent.\n+   *\n+   * @param rectangles the union of these rectangles describe the clip\n+   * region.\n+   */\n+  public void setClipRectangles(Rectangle[] rectangles)\n+  {\n+    clip = new Clip(rectangles);\n+    updateClip();\n+  }\n+\n+  public native void drawString(String text, int x, int y);\n+  public native void drawLine(int x1, int y1, int x2, int y2);\n+  public native void drawRectangle(int x, int y, int w, int h);\n+\n+  public native void fillRectangle(int x, int y, int w, int h);\n+\n+  /** \n+   * \n+   * Clear area using the background pixel or pixmap of the drawable.\n+   * Note that this operation does not adhere to the current clip.\n+   */\n+  public native void clearArea(int x, int y, int w, int h,\n+\t\t\t       boolean exposures);\n+\n+\n+  public native void putImage(XImage image,\n+\t\t\t      int srcX, int srcY,\n+\t\t\t      int destX, int destY,\n+\t\t\t      int width, int height);\n+\n+  public Drawable getDrawable()\n+  {\n+    return target;\n+  }\n+\n+  private native void updateClip();\n+\n+  private Drawable target;\n+  private RawData structure;\n+  private Clip clip;\n+}\n+"}, {"sha": "a81f55c87617231a214e1d5b77760331533156b9", "filename": "libjava/gnu/gcj/xlib/Pixmap.java", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FPixmap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FPixmap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FPixmap.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+/**\n+ * An X11 Pixmap. A pixmap is an offscreen drawable that resides on\n+ * the X server. A pixmap is bound to the screen it was created for.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class Pixmap extends Drawable\n+{\n+  public Pixmap(XImage image, Screen screen)\n+  {\n+    this(screen.getRootWindow(),\n+\t image.getWidth(), image.getHeight(),\n+\t image.getDepth());\n+    \n+    /* FIXME: don't create a new GC all the time.  This might actually\n+    not be as bad as initially believed.  The GC cache of Xlib makes\n+    this opertation less costly. */\n+    GC gc = new GC(this);\n+    \n+    gc.putImage(image, 0, 0, 0, 0, image.getWidth(), image.getHeight());\n+  }\n+\n+  public Pixmap(Drawable sameScreenAs, int width, int height, int depth)\n+  {\n+    super(sameScreenAs.getDisplay(), \n+\t  createXID(sameScreenAs, width, height, depth));\n+  }\n+\n+  protected static native int createXID(Drawable sameScreenAs,\n+\t\t\t\t\tint width, int height, int depth);\n+\n+  protected native void finalize();\n+}"}, {"sha": "675ed1b9bd0650f4301b799a39133490947d9113", "filename": "libjava/gnu/gcj/xlib/Screen.java", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FScreen.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FScreen.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FScreen.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,86 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+\n+/**\n+ * A flyweight class that denotes an X11 screen.  Display and screen\n+ * number is the only data kept by this class.  The real screen\n+ * structure is stored in the display.  There may exist several\n+ * objects denoting the same screen.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public final class Screen\n+{\n+  static final int UNKNOWN = -1;\n+\n+  Display display;\n+  int screenNumber = UNKNOWN;\n+  RawData structure;\n+  \n+  Screen(Display display, RawData screenStructure)\n+  {\n+    structure = screenStructure;\n+    this.display = display;\n+  }\n+\n+  public Screen(Display display)\n+  {\n+    this(display, display.getDefaultScreenNumber());\n+  }\n+\n+  public Screen(Display display, int screenNumber)\n+  {\n+    this.display = display;\n+    this.screenNumber = screenNumber;\n+    initStructure();\n+  }\n+\n+  public final Display getDisplay()\n+  {\n+    return display;\n+  }\n+\n+  public Window getRootWindow()\n+  {\n+    int rootXID = getRootWindowXID();\n+    return display.getWindow(rootXID);\n+  }\n+\n+  public Visual getRootVisual()\n+  {\n+    RawData visualStructure = getRootVisualStructure();\n+    int depth = getRootDepth();\n+    return new Visual(visualStructure, this, depth);\n+  }\n+\n+  private native RawData getRootVisualStructure();\n+\n+  public native int getRootDepth();\n+  public native int getRootWindowXID();\n+  public native int getDefaultColormapXID();\n+\n+  native void initStructure();\n+\n+  public Colormap getDefaultColormap()\n+  {\n+    return new Colormap(this, getDefaultColormapXID());\n+  }\n+  \n+  public final int getScreenNumber()\n+  {\n+    if (screenNumber == UNKNOWN)\n+      screenNumber = findScreenNumber();\n+    return screenNumber;\n+  }\n+\n+  public native int findScreenNumber();\n+}"}, {"sha": "46fd3ee9936dea0d9e216e04b0aacb1eba2d0503", "filename": "libjava/gnu/gcj/xlib/Visual.java", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FVisual.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FVisual.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FVisual.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,152 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+\n+/** \n+ * A visual determines how a color is encoded into a pixel/bitfield\n+ * value.  It does not determine how the pixel/bitfield value is\n+ * encoded into the image data.\n+ * \n+ * <p>This class encapsulates all three Xlib representations of a\n+ * visual.\n+ * \n+ * <ul>\n+ * \n+ * <li>int: visual id.\n+ * \n+ * <li>Visual: opaque data structure used by a lot of Xlib functions.\n+ * \n+ * <li>VisualInfo: transparent data structure that binds the visual to\n+ * a certain screen and depth.\n+ * \n+ * </ul>\n+ * \n+ * <p>Implementation note: This class does not examine nor manipulate\n+ * the Visual structure, since the X manual says the structure is\n+ * opaque, and that XVisualInfo should be used instead.</p>\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public final class Visual\n+{\n+  public static final int VC_STATIC_GRAY  = 0,\n+\t                  VC_GRAY_SCALE   = 1,\n+                          VC_STATIC_COLOR = 2,\n+                          VC_PSEUDO_COLOR = 3,\n+                      \t  VC_TRUE_COLOR   = 4,\n+                          VC_DIRECT_COLOR = 5;\n+  \n+  protected static final int MASK_ID            = 1 << 0,\n+                             MASK_SCREEN        = 1 << 1,\n+                             MASK_DEPTH         = 1 << 2,\n+                             MASK_CLASS         = 1 << 3,\n+                             MASK_RED           = 1 << 4,\n+                             MASK_GREEN         = 1 << 5,\n+                             MASK_BLUE          = 1 << 6,\n+                             MASK_COLORMAP_SIZE = 1 << 7,\n+                             MASK_BITS_PER_RGB  = 1 << 8;\n+\n+  protected static final int MASK_ALL = MASK_ID\n+      | MASK_SCREEN\n+      | MASK_DEPTH\n+      | MASK_CLASS\n+      | MASK_RED\n+      | MASK_GREEN\n+      | MASK_BLUE\n+      | MASK_COLORMAP_SIZE\n+      | MASK_BITS_PER_RGB;\n+\n+  private static final int MASK_VISUAL_STRUCTURE = 1 << 31;\n+\n+  Display display;\n+  RawData xVisualInfo;\n+  int infoMask;\n+  Screen screen;\n+\n+  Visual(RawData structure, Screen screen, int depth )\n+  {\n+    this.display = screen.getDisplay();\n+    this.screen = screen;\n+    init(structure, depth);\n+  }\n+\n+  Visual(Display display, RawData structure, int depth )\n+  {\n+    this.display = display;\n+    init(structure, depth);\n+  }\n+\n+  protected native void init(RawData structure, int depth);\n+\n+  protected native void finalize();\n+\n+  /**\n+   *\n+   * Returns the a reference to the visual structure.  This method has\n+   * package accessibility since the data visual structure is only\n+   * useful for direct Xlib calls.\n+   *\n+   * @return a pointer to the visual structure.\n+   */\n+  native RawData getVisualStructure();\n+\n+    \n+  // These methods only make sense if the visual is decomposed:\n+\n+  public native int getRedMask();\n+  public native int getGreenMask();\n+  public native int getBlueMask();\n+\n+  public native int getScreenNumber();\n+  public native int getDepth();\n+\n+  public Screen getScreen()\n+  {\n+    if (screen == null)\n+      screen = new Screen(display, getScreenNumber());\n+    return screen;\n+  }\n+\n+  public native int getVisualClass();\n+\n+  public boolean hasRGBSubfields()\n+  {\n+    switch (getVisualClass())\n+      {\n+      case VC_TRUE_COLOR:\n+      case VC_DIRECT_COLOR:\n+\treturn true;\n+      default:\n+\treturn false;\n+      }\n+  }\n+\n+  protected native void ensureXVisualInfo(int requiredMask);\n+\n+\n+  public String toString()\n+  {\n+    int missingInfo = ~infoMask;\n+    boolean hasSubfieldInfo =\n+      (missingInfo & (MASK_CLASS|MASK_RED|MASK_GREEN|MASK_BLUE)) == 0;\n+\n+    boolean hasDepth = (missingInfo & MASK_DEPTH) == 0;\n+\t\n+    return getClass().getName() + \"[\" +\n+      (hasDepth ? \"depth=\" + getDepth() : \"\") +\n+      (hasRGBSubfields() ?\n+       (\", redMask=\" + Integer.toHexString(getRedMask()) +\n+\t\", greenMask=\" + Integer.toHexString(getGreenMask()) +\n+\t\", blueMask=\" + Integer.toHexString(getBlueMask())) :\n+       \", no-subfields\") + \", class=\" + getVisualClass() +\n+      \"]\";\n+  }\n+}"}, {"sha": "29344eee1ebe6d0b2bd398911fe92b86ba21668a", "filename": "libjava/gnu/gcj/xlib/WMSizeHints.java", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FWMSizeHints.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FWMSizeHints.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FWMSizeHints.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+\n+/** \n+ * Size hints for an X11 window in its normal state. This class wraps\n+ * the Xlib XSizeHints stucture.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class WMSizeHints implements Cloneable\n+{\n+  public WMSizeHints()\n+  {\n+    init(null);\n+  }\n+\n+  private native void init(WMSizeHints copyFrom);\n+  protected native void finalize();\n+\n+  public Object clone() {\n+    WMSizeHints hints = (WMSizeHints) super.clone();\n+    // In case of an exception before the stucture is copied.\n+    hints.structure = null;\n+\n+    hints.init(this);\n+    return hints;\n+  }\n+\n+  public native void applyNormalHints(Window window);\n+\n+  public native void setMinSize(int width, int height);\n+  public native void setMaxSize(int width, int height);\n+  \n+  RawData structure;\n+}"}, {"sha": "ae3dbfd688bc2b5c132ed14ab861940794949b6f", "filename": "libjava/gnu/gcj/xlib/Window.java", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FWindow.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,104 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+import java.awt.Rectangle;\n+\n+/**\n+ * An X11 window.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class Window extends Drawable\n+{\n+  // Must correspond with X.h definitions:\n+  public static final int COPY_FROM_PARENT = 0;\n+  public static final int INPUT_OUTPUT     = 1;\n+  public static final int INPUT_ONLY       = 2;\n+\n+  public Window(Window parent, Rectangle bounds,\n+\t\tWindowAttributes attributes)\n+  {\n+    this(parent, bounds, attributes, null);\n+  }\n+  \n+  public Window(Window parent, Rectangle bounds,\n+\t\tWindowAttributes attributes, Visual visual)\n+  {\n+    this(parent, bounds, 0, attributes, COPY_FROM_PARENT, visual);\n+  }\n+\n+  public Window(Window parent, Rectangle bounds, int borderWidth,\n+\t\tWindowAttributes attributes, int windowIOClass,\n+\t\tVisual visual)\n+  {\n+    this(parent.display,\n+\t parent.createChildXID(bounds, borderWidth, attributes, \n+\t\t\t       windowIOClass, visual));\n+    this.owned = true;\n+  }\n+\n+  protected Window(Display display, int xid)\n+  {\n+    super(display, xid);\n+    display.addXID(xid, this);\n+  }\n+\n+  protected void finalize()\n+  {\n+    display.removeXID(xid);\n+    if (owned)\n+      {\n+\tdestroy();\n+\towned = false;\n+      }\n+  }\n+\n+  protected native void destroy();\n+\n+  protected native int createChildXID(Rectangle bounds,\n+\t\t\t\t      int borderWidth,\n+\t\t\t\t      WindowAttributes attributes,\n+\t\t\t\t      int windowIOClass, \n+\t\t\t\t      Visual visual);\n+\n+  public native void setAttributes(WindowAttributes attributes);\n+\n+  public native void map();\n+  public native void unmap();\n+  \n+  protected boolean owned = false;\n+\n+  public native void setProperty(int nameAtom, int typeAtom, byte[] data);\n+  \n+  public void setProperty(int nameAtom, int typeAtom, String data)\n+  {\n+    int length = data.length();\n+    byte[] byteData = new byte[length];\n+    \n+    for (int i=0; i<length; i++)\n+      byteData[i] = (byte) data.charAt(i);\n+\n+    setProperty(nameAtom, typeAtom, byteData);\n+  }\n+\n+  public native void setWMProtocols(int[] atoms);\n+  public native int[] getWMProtocols();\n+\n+  public void setProperty(String nameAtom, String typeAtom, String data)\n+  {\n+    int xaName = display.getAtom(nameAtom);\n+    int xaType = display.getAtom(typeAtom);\n+    \n+    setProperty(xaName, xaType, data);\n+  }\n+\n+  public native void setBounds(int x, int y, int width, int height);\n+}"}, {"sha": "72a3bb87de8b9bedcb70738521791ef7f08a09f0", "filename": "libjava/gnu/gcj/xlib/WindowAttributes.java", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FWindowAttributes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FWindowAttributes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FWindowAttributes.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,106 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+import gnu.gcj.RawData;\n+\n+/**\n+ * \n+ * Collection of attributes that can be applied to or read from an\n+ * X11 window.\n+ *\n+ * <p>TODO: Split this class into two classes. One for the structure\n+ * XSetWindowAttributes and one for the XWindowAttributes.  However\n+ * they should still share this common base class.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no> */\n+public class WindowAttributes\n+{\n+  // Must match definitions in X.h:\n+  public final static long MASK_BUTTON_PRESS     = 1L<< 2,\n+                           MASK_BUTTON_RELEASE   = 1L<< 3,\n+                           MASK_EXPOSURE         = 1L<<15,\n+                           MASK_STRUCTURE_NOTIFY = 1L<<17;\n+\n+  public WindowAttributes()\n+  {\n+    init(null);\n+  }\n+  \n+  public WindowAttributes(Window from)\n+  {\n+    initFromWindow(from);\n+  }\n+\n+  private native void initFromWindow(Window from);\n+  private native void init(WindowAttributes copyFrom);\n+  protected native void finalize();\n+    \n+  public Object clone()\n+  {\n+    WindowAttributes attributes = (WindowAttributes) super.clone();\n+    // In case of an exception before the stucture is copied.\n+    attributes.in  = 0;\n+    attributes.out = 0;\n+    \n+    // FIXME: do anything else?\n+\t\n+    attributes.init(this);\n+    return attributes;\n+  }\n+\n+  public native void setBackground(long pixel);\n+  public native void setBackground(Pixmap pixmap);\n+  public native void setEventMask(long eventMask);\n+\n+  public void setVisual(Visual visual)\n+  {\n+    this.visual = visual;\n+  }\n+\n+  /**\n+   * Retrieve the visual. \n+   *\n+   * @return the visual that is or should be used by a window.  null\n+   * means CopyFormParent. \n+   */\n+  public native Visual getVisual();\n+\n+  Display display;\n+\n+  /**\n+   * Reference to XWindowAttribute structure containing attributes\n+   * read from a window.\n+   */\n+  RawData in = 0;\n+\n+  /**\n+   * Reference to XSetWindowAttribute structure containing attributes\n+   * to be applied to a window.\n+   */\n+  RawData out = 0;\n+\n+  long mask;\n+\n+  /** null means CopyFromParent during window creation. */\n+  Visual visual = null;\n+\n+  public native void apply(Window window);\n+\n+  final RawData getXSetWindowAttributesStructure()\n+  {\n+    if (out == null)\n+      initOut();\n+    return out;\n+  }\n+  \n+  void initOut()\n+  {\n+    throw new UnsupportedOperationException(\"not implemented yet\");\n+  }\n+}"}, {"sha": "e7a4a02b987f6c4defbe6bfc8c8147a8ff82e1f4", "filename": "libjava/gnu/gcj/xlib/XAnyEvent.java", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXAnyEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXAnyEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXAnyEvent.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,75 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+\n+/** \n+ * Mutable event structure that can contain any data from any event\n+ * type.  Events can be constructed or loaded from the event queue.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public final class XAnyEvent\n+{\n+  // Must match the definitions in X.h:\n+  public static final int TYPE_BUTTON_PRESS     =  4,\n+                          TYPE_BUTTON_RELEASE   =  5,\n+\t                  TYPE_EXPOSE           = 12,\n+\t                  TYPE_UNMAP_NOTIFY     = 18,\n+\t                  TYPE_MAP_NOTIFY       = 19,\n+\t                  TYPE_REPARENT_NOTIFY  = 21,\n+\t                  TYPE_CONFIGURE_NOTIFY = 22,\n+\t                  TYPE_CLIENT_MESSAGE   = 33;\n+    \n+  // Must match the definitions in X.h:\n+  public final static long MASK_SUBSTRUCTURE_NOTIFY   = 1L<<19,\n+\t                   MASK_SUBSTRUCTURE_REDIRECT = 1L<<20;\n+\n+  XAnyEvent(Display display)\n+  {\n+    this.display = display;\n+    init();\n+  }\n+\n+  private native void init();\n+  protected native void finalize();\n+\n+  /**\n+   * Load next event into the event structure.\n+   */\n+  public native void loadNext();\n+\n+  public native int getType();\n+  public native void setType(int type);\n+\n+  public native Window getWindow();\n+  public native void setWindow(Window window);\n+  \n+  /**\n+   * @returns the number of the last request processed by the server.\n+   */\n+  public native long getSerial();\n+\n+  public native void send(Window destination, boolean propagate,\n+\t\t\t  long mask);\n+\n+  RawData structure;\n+  Display display;\n+\n+  public String toString()\n+  {\n+    if (structure == null)\n+      return getClass().getName() + \"[no-structure]\";\n+\n+    return getClass().getName() +\n+      \"[type=\" + getType() +\n+      \",window=\" + getWindow() + \"]\";\n+  }\n+}"}, {"sha": "032830b2c596987e2b83740586d40e35a050e9d1", "filename": "libjava/gnu/gcj/xlib/XButtonEvent.java", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXButtonEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXButtonEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXButtonEvent.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,53 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+/**\n+ * Interprets data from an Xlib XButtonEvent into members of java\n+ * primitive types.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class XButtonEvent extends XEvent\n+{\n+\n+  // Must match the definition in X.h:\n+  public static final int MASK_SHIFT   = 1<<0,\n+                          MASK_LOCK    = 1<<1,\n+                          MASK_CONTROL = 1<<2,\n+                          MASK_MOD1    = 1<<3,\n+                          MASK_MOD2    = 1<<4,\n+                          MASK_MOD3    = 1<<5,\n+                          MASK_MOD4    = 1<<6,\n+                          MASK_MOD5    = 1<<7;\n+ \n+  public XButtonEvent(XAnyEvent event)\n+  {\n+    super(event);\n+\n+    // FIXME: Avoid double checking?\n+    if ((event.getType() != XAnyEvent.TYPE_BUTTON_PRESS) &&\n+\t(event.getType() != XAnyEvent.TYPE_BUTTON_RELEASE))\n+      {\n+\tthrow new IllegalArgumentException(\"Wrong event type\");\n+      }\n+    init();\n+  }\n+\n+  native void init();\n+  \n+  public long time;\n+  public int  x;\n+  public int  y;\n+  public int  state;\n+  public int  button;\n+}\n+\n+\n+"}, {"sha": "7abcc1713f12b3b46d5d4153b6e06f86564be6c9", "filename": "libjava/gnu/gcj/xlib/XColor.java", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXColor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXColor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXColor.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,42 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+\n+/**\n+ * A color or color-cell on the X server.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public final class XColor\n+{\n+  public XColor(int r, int g, int b)\n+  {\n+    this();\n+    setRGB(r, g, b);\n+  }\n+\n+  public XColor()\n+  {\n+    init();\n+  }\n+\n+  private native void init();\n+  protected native void finalize();\n+\n+  public final native void setRGB(int r, int g, int b);\n+  public final native int getRed();\n+  public final native int getGreen();\n+  public final native int getBlue();\n+  public final native byte getFlags();\n+  public final native long getPixelValue();\n+  \n+  RawData structure = 0;\n+}"}, {"sha": "0d069ea03dbacedeb8a158733bbd72e302f7370b", "filename": "libjava/gnu/gcj/xlib/XConfigureEvent.java", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXConfigureEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXConfigureEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXConfigureEvent.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import java.awt.Rectangle;\n+\n+/**\n+ * Interprets and retrieves data from an Xlib XConfigureEvent.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class XConfigureEvent extends XEvent\n+{\n+  public XConfigureEvent(XAnyEvent event)\n+  {\n+    super(event);\n+    // FIXME: Avoid double checking?\n+    if (event.getType() != XAnyEvent.TYPE_CONFIGURE_NOTIFY)\n+      throw new IllegalArgumentException(\"Wrong event type\");\n+  }\n+  \n+  public native Rectangle getBounds();\n+}\n+\n+\n+"}, {"sha": "829da660c1dfa15f6d519d446916ec6fe99cfe2d", "filename": "libjava/gnu/gcj/xlib/XConnectException.java", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXConnectException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXConnectException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXConnectException.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,30 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Indicates that something went wrong with the connection to an X11\n+ * display.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class XConnectException extends IOException\n+{\n+  public XConnectException()\n+  {\n+    super();\n+  }\n+\n+  public XConnectException(String message)\n+  {\n+    super(message);\n+  }\n+}"}, {"sha": "75f602a82d272dc69b63b2e1c6e1d323abe634bc", "filename": "libjava/gnu/gcj/xlib/XEvent.java", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXEvent.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+\n+/**\n+ * Base class for interpreters of specific X event types.  For methods\n+ * concerning all X events, see XAnyEvent.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class XEvent\n+{\n+  public XEvent(XAnyEvent event)\n+  {\n+    this.event = event;\n+  }\n+  \n+  public XEvent(int type, Display display)\n+  {\n+    this(new XAnyEvent(display));\n+    event.setType(type);\n+  }\n+\n+  XAnyEvent event;\n+\n+  public XAnyEvent getXAnyEvent()\n+  {\n+    return event;\n+  }\n+\n+  public String toString()\n+  {\n+    if (event == null)\n+      return super.toString();\n+    return event.toString();\n+  }\n+}"}, {"sha": "73b10a1c631074b3e60208b79e287cbc2a4de3b9", "filename": "libjava/gnu/gcj/xlib/XException.java", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXException.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,27 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+/**\n+ * Runtime exception that occured during an Xlib opertation. \n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class XException extends RuntimeException\n+{  \n+  public XException() {}\n+  public XException(String msg) { super(msg); }\n+  \n+  public XException(Display display, int status)\n+  {\n+    super(toString(display, status));\n+  }\n+  \n+  static native String toString(Display display, int status);\n+}"}, {"sha": "2c29cf131e369630325cd2ef3bd945c1ea3af3dc", "filename": "libjava/gnu/gcj/xlib/XExposeEvent.java", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXExposeEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXExposeEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXExposeEvent.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,33 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import java.awt.Rectangle;\n+\n+/**\n+ * Interprets data from an Xlib XExposeEvent.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class XExposeEvent extends XEvent\n+{\n+  public XExposeEvent(XAnyEvent event)\n+  {\n+    super(event);\n+\n+    // FIXME: Avoid double checking?\n+    if (event.getType() != XAnyEvent.TYPE_EXPOSE)\n+      throw new IllegalArgumentException(\"Wrong event type\");\n+  }\n+\n+  public native Rectangle getBounds();\n+}\n+\n+\n+"}, {"sha": "f7bb9cfc994648f71366d92a65d90fd7f8c318db", "filename": "libjava/gnu/gcj/xlib/XID.java", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXID.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXID.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXID.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,58 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+/**\n+ * Common base class for all resources that are stored on the server\n+ * and refered to on the client side using XIDs.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class XID\n+{\n+  public XID(Display display, int xid)\n+  {\n+    this.display = display;\n+    this.xid = xid;\n+  }\n+\n+  public final int getXID()\n+  {\n+    return xid;\n+  }\n+\n+  public final Display getDisplay()\n+  {\n+    return display;\n+  }\n+\n+  protected Display display;\n+  protected int xid;\n+\n+  private Object clientData;\n+  public final Object getClientData()\n+  {\n+    return clientData;\n+  }\n+  public final void setClientData(Object clientData)\n+  {\n+    this.clientData = clientData;\n+  }\n+\n+  protected String params()\n+  {\n+    return \"display=\" + display + \",xid=\" + Integer.toHexString(xid);\n+  }\n+  \n+  public String toString()\n+  {\n+    return getClass().getName() +\n+      \"[\" + params() + \"]\";\n+  }\n+}"}, {"sha": "25a80059a09a2e40f3b8dab041d1cefba8c89f8c", "filename": "libjava/gnu/gcj/xlib/XImage.java", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXImage.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXImage.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXImage.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,226 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+import gnu.gcj.RawData;\n+\n+/** \n+ * Structure containing image data that resides on the client side.\n+ * The format, depth and offset attributes of an XImage determines how\n+ * bitfields are encoded in a raster image. However, it does not\n+ * determine how a color is encoded into a bitfield. I.e. the XImage\n+ * pixel values in a specific structure, but does not determine what\n+ * colors that will be used to represent these pixel values on the\n+ * screen.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class XImage\n+{\n+  /** This object reference points to the data, hindering garbage\n+      collection of the data. */\n+  Object dataRef;\n+\n+  // Must match definitions in X.h:\n+  public static final int XYBITMAP_FORMAT = 0,\n+                          XYPIXMAP_FORMAT = 1,\n+                          ZPIXMAP_FORMAT  = 2;\n+  \n+  // Must match definitions in X.h:\n+  public static final int LEAST_SIGNIFICANT_B_FIRST_ORDER  = 0,\n+                          MOST_SIGNIFICANT_B_FIRST_ORDER   = 1;\n+  \n+  public XImage(Visual visual, int depth, int format, int xoffset,\n+\t\tint width, int height, int bitmapPad,\n+\t\tint bytesPerLine)\n+  {\n+    this(visual, depth, format, xoffset, width, height, bitmapPad,\n+\t bytesPerLine,\n+\t 0 // bitsPerPixel\n+\t );\n+  }\n+\n+  public XImage(Visual visual, int depth, int format, int xoffset,\n+\t\tint width, int height, int bitmapPad,\n+\t\tint bytesPerLine, int bitsPerPixel)\n+  {\n+    if (visual == null) throw new \n+      NullPointerException(\"a visual must be specified\");\n+\t\n+    init(visual, depth, format, xoffset, width, height,\n+\t bitmapPad, bytesPerLine, bitsPerPixel);\n+  }\n+\n+  public native void init(Visual visual, int depth, int format, int xoffset,\n+\t\t\t  int width, int height, int bitmapPad,\n+\t\t\t  int bytesPerLine, int bitsPerPixel);\n+  \n+  private native void init(Visual visual, int width, int height);\n+\n+    \n+  public XImage(Visual visual, int width, int height)\n+  {\n+    this(visual, width, height,\n+\t true // Automatically allocate memory\n+\t );\n+  }\n+\n+  /** \n+   * Create a new XImage.\n+   *\n+   * @param allocate specifies whether to automatically allocate\n+   * memory for the image.  It is possible to create the data array\n+   * elsewhere, so that we can for instance use a DataBufferUShort as\n+   * data.  Ie. not limit ourself to byte arrays.  This is done by\n+   * passing false and calling a setData() method manually after\n+   * creation.\n+   */\n+  public XImage(Visual visual, int width, int height, boolean allocate)\n+  {\n+    if (visual == null)\n+      throw new NullPointerException(\"a visual must be specified\");\n+    \n+    init(visual, width, height);\n+\n+    if (allocate)\n+      {\n+\t/* Now that Xlib has figured out the appropriate bytes per\n+\t   line, we can allocate memory for the image.  */\n+\t// FIXME: What about formats with several layers/bands?\n+\tbyte[] data = new byte[getBytesPerLine()*height];\n+\n+\tsetData(data, 0);\n+      }\n+  }\n+\n+  /**\n+   * Attach image data to this XImage.\n+   *\n+   * @param offset the index of the first actual data element in the array.\n+   */\n+  public void setData(byte[] data, int offset)\n+  {\n+    dataRef = data;\n+    internalSetData(data, offset);\n+  }\n+\n+  /**\n+   * Attach image data to this XImage. \n+   *\n+   * @param offset the index of the first actual data element in the\n+   *  array.  Note: this is short offset, not a byte offset.\n+   */\n+  public void setData(short[] data, int offset)\n+  {\n+    dataRef = data;\n+    internalSetData(data, offset);\n+  }\n+\n+  /**\n+   * Attach image data to this XImage\n+   * \n+   * @param offset the index of the first actual data element in the array.\n+   * Note: this is not a byte offset.\n+   */\n+  public void setData(int[] data, int offset)\n+  {\n+    dataRef = data;\n+    internalSetData(data, offset);\n+  }\n+  \n+  private native void internalSetData(byte[] data, int offset);\n+  private native void internalSetData(short[] data, int offset);\n+  private native void internalSetData(int[] data, int offset);\n+    \n+  protected native void finalize();\n+\n+  boolean ownsData = false;\n+  RawData structure = 0;\n+\n+  public final native int getWidth();\n+  public final native int getHeight();\n+  public final native int getDepth();\n+  public final native int getFormat();\n+\n+  public final boolean isZPixmapFormat()\n+  {\n+    return getFormat() == ZPIXMAP_FORMAT;\n+  } \n+\n+\n+  /** \n+   * Get the xoffset. The xoffset avoids the need of shifting the\n+   * scanlines into place.\n+   */\n+  public final native int getXOffset();\n+\n+  public native final int getBytesPerLine();\n+  public native final int getBitsPerPixel();\n+\n+  public native final int getImageByteOrder();\n+  public native final int getBitmapBitOrder();\n+  public native final int getBitmapUnit();\n+  public native final int getBitmapPad();\n+\n+\n+  // True/Direct Color specific:\n+  public native int getRedMask();\n+  public native int getGreenMask();\n+  public native int getBlueMask();\n+\n+\n+  /**\n+   * Set a pixel value at a given position in the image. This method\n+   * is slow. Don't use it, except as a fall-back.\n+   */\n+  public native final void setPixel(int x, int y, int pixel);\n+\n+  public String toString()\n+  {\n+    String format;\n+    switch(getFormat())\n+      {\n+      case ZPIXMAP_FORMAT:\n+\tformat = \"ZPixmapFormat\";\n+      }\n+    \n+    String imageByteOrder;\n+    switch(getImageByteOrder())\n+      {\n+      case LEAST_SIGNIFICANT_B_FIRST_ORDER:\n+\timageByteOrder = \"leastSignificantByteFirst\";\n+\tbreak;\n+      case MOST_SIGNIFICANT_B_FIRST_ORDER:\n+\timageByteOrder = \"mostSignificantByteFirst\";\n+      }\n+    \n+    String bitmapBitOrder;\n+    switch(getBitmapBitOrder())\n+      {\n+      case LEAST_SIGNIFICANT_B_FIRST_ORDER:\n+\tbitmapBitOrder = \"leastSignificantBitFirst\";\n+\tbreak;\n+      case MOST_SIGNIFICANT_B_FIRST_ORDER:\n+\tbitmapBitOrder = \"mostSignificantBitFirst\";\n+      }\n+    \n+    return getClass().getName() + \"[\" + format +\n+      \", width=\" + getWidth() +\n+      \", height=\" + getHeight() +\n+      \", bytesPerLine=\" + getBytesPerLine() +\n+      \", xoffset=\" + getXOffset() +\n+      \", depth=\" + getDepth() +\n+      \", bitsPerPixel=\" + getBitsPerPixel() +\n+      \", bitmapUnit=\" + getBitmapUnit() +\n+      \", bitmapPad=\" + getBitmapPad() +\n+      \", byteOrder=\" + imageByteOrder +\n+      \", bitOrder=\" + bitmapBitOrder +\n+      \"]\";\n+  }\n+}"}, {"sha": "803bdba775a5582474d4138a5a98fc1db748fd69", "filename": "libjava/gnu/gcj/xlib/XUnmapEvent.java", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXUnmapEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FXUnmapEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FXUnmapEvent.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,33 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.xlib;\n+\n+/**\n+ * Interprets data from an Xlib XUnmapEvent.\n+ *\n+ * @author Rolf W. Rasmussen <rolfwr@ii.uib.no>\n+ */\n+public class XUnmapEvent extends XEvent\n+{\n+  public XUnmapEvent(Display display, Window eventWindow,\n+\t\t     Window unmappedWindow,\n+\t\t     boolean fromConfigure)\n+  {\n+    super(XAnyEvent.TYPE_UNMAP_NOTIFY, display);\n+    getXAnyEvent().setWindow(eventWindow);\n+    setUnmappedWindow(unmappedWindow);\n+    setFromConfigure(fromConfigure);\n+  }\n+\n+  public native void setUnmappedWindow(Window unmappedWindow);\n+  public native void setFromConfigure(boolean fromConfigure);\n+}\n+\n+\n+"}, {"sha": "51426c832972ed5d46b3f731471b8eaf242af823", "filename": "libjava/gnu/gcj/xlib/natClip.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatClip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatClip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatClip.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,52 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Needed to avoid linking in libstdc++\n+#ifndef __STL_USE_EXCEPTIONS\n+#   include <java/lang/OutOfMemoryError.h>\n+#   define __THROW_BAD_ALLOC throw new java::lang::OutOfMemoryError()\n+#endif \n+\n+#include <vector>\n+\n+#include <X11/Xlib.h>\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+#include <java/awt/Rectangle.h>\n+\n+#include \"gnu/gcj/xlib/Clip.h\"\n+\n+typedef java::awt::Rectangle AWTRect;\n+typedef JArray<AWTRect*> AWTRectArray;\n+typedef std::vector<XRectangle> XRectVector;\n+\n+void gnu::gcj::xlib::Clip::init(AWTRectArray* rectangles)\n+{\n+  // Prepare rectangles:\n+  \n+  int numRect = JvGetArrayLength(rectangles);\n+  XRectVector* xrectvector = new XRectVector(numRect);\n+  \n+  for (int i=0; i<numRect; i++)\n+    {\n+      AWTRect* awtrect = elements(rectangles)[i];\n+      XRectangle& xrect = (*xrectvector)[i];\n+      \n+      xrect.x      = awtrect->x;\n+      xrect.y      = awtrect->y;\n+      xrect.width  = awtrect->width;\n+      xrect.height = awtrect->height;\n+    }\n+\n+  xrects = reinterpret_cast<gnu::gcj::RawData*>(xrectvector);\n+}\n+\n+void gnu::gcj::xlib::Clip::finalize()\n+{\n+  delete xrects; xrects = 0;\n+}"}, {"sha": "83c897e8a17bffdc3def4d5857e4a3962fe6a2d0", "filename": "libjava/gnu/gcj/xlib/natColormap.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatColormap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatColormap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatColormap.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,147 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Needed to avoid linking in libstdc++\n+#ifndef __STL_USE_EXCEPTIONS\n+#   include <java/lang/OutOfMemoryError.h>\n+#   define __THROW_BAD_ALLOC throw new java::lang::OutOfMemoryError()\n+#endif\n+\n+#include <vector>\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <java/lang/RuntimeException.h>\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Screen.h>\n+#include <gnu/gcj/xlib/Colormap.h>\n+#include <gnu/gcj/xlib/XColor.h>\n+#include <gnu/gcj/RawData.h>\n+\n+jlong gnu::gcj::xlib::Colormap::allocateColorPixel(XColor* color)\n+{\n+  ::Display* dpy = (::Display*) (screen->getDisplay()->display);\n+  ::XColor* col = (::XColor*) (color->structure);\n+  Status result = XAllocColor(dpy, xid, col);\n+  if (result == 0)\n+    throw new java::lang::RuntimeException(\n+      JvNewStringLatin1(\"Unable to allocate color pixel.\"));\n+\n+  return col->pixel;\n+}\n+\n+typedef JArray<gnu::gcj::xlib::XColor*>* xcolorarray;\n+\n+xcolorarray gnu::gcj::xlib::Colormap::getSharedColors()\n+{\n+  ::Display* dpy = (::Display*) (screen->getDisplay()->display);\n+  unsigned int nCells = CellsOfScreen(ScreenOfDisplay(dpy, screen->screenNumber));\n+\n+  typedef ::XColor xcolor;\n+  std::vector<xcolor> colors(nCells);\n+  for (unsigned int i=0; i<nCells; i++)\n+    colors[i].pixel = i;\n+  ::XColor* cols = colors.get_allocator().address(colors.front());\n+  XQueryColors(dpy, xid, cols,\n+\t       nCells);\n+\n+  int nShared = 0;\n+  for (unsigned int i=0; i<nCells; i++)\n+    {\n+      ::XColor color = colors[i];\n+\n+      if (!XAllocColor(dpy, xid, &color))\n+\tcontinue;\n+\n+      /* FIXME: In some cases this algorithm may identify a free\n+\t color cell as a shared one. */\n+      if (color.pixel != i)\n+\t{\n+\t  // Oops, the color wasn't shared. Free it.\n+\t  XFreeColors(dpy, xid, &(color.pixel), 1, 0);\n+\t  colors[i].flags = FLAG_NOT_SHARED;\n+\t  continue;\n+\t}\n+      \n+      // FIXME: Shared or free?\n+      \n+      nShared++;\n+      colors[i].flags = FLAG_SHARED;\n+    }\n+  \n+  JArray<XColor*>* shared = newXColorArray(nShared);\n+  int si=0;\n+  for (unsigned int i=0; i<nCells; i++)\n+    {\n+      if (colors[i].flags != FLAG_SHARED)\n+\tcontinue;\n+      \n+      XColor* col = elements(shared)[si++];\n+      gnu::gcj::RawData* colorData = col->structure;\n+      ::XColor* colStruct = reinterpret_cast<xcolor*>(colorData);\n+      *colStruct = colors[i];\n+    }\n+\n+  return shared;\n+}\n+\n+xcolorarray gnu::gcj::xlib::Colormap::getXColors()\n+{\n+  ::Display* dpy = (::Display*) (screen->getDisplay()->display);\n+  unsigned int nCells =\n+    CellsOfScreen(ScreenOfDisplay(dpy, screen->screenNumber));\n+  \n+  typedef ::XColor xcolor;\n+  std::vector<xcolor> colors(nCells);\n+  \n+  JArray<XColor*>* colArray = newXColorArray(nCells);\n+  \n+  for (unsigned int i=0; i<nCells; i++)\n+    colors[i].pixel = i;\n+  \n+  XQueryColors(dpy, xid, &(colors.front()), nCells);\n+\n+  /* TODO: The current problem with this code is that it relies on\n+     (color.pixel == i) as an indicator that the color is\n+     shared. However, (color.pixel == i), may also occur simply\n+     because color cell i simply was the next free in the list of\n+     unallocated color cells.  IDEA: run through the list both\n+     backwards and forwards, and only pick out the colorcells that\n+     have been identified as shared during both passes.  Reversing the\n+     traversal direction might prevent i from corresponding to the\n+     next free colorcell, atleast in one of the passes. */\n+  for (unsigned int i=0; i<nCells; i++)\n+    {\n+      ::XColor color = colors[i];\n+      \n+      char flag = FLAG_NOT_SHARED;\n+      if (XAllocColor(dpy, xid, &color))\n+\t{\n+\t  if (color.pixel == i)\n+\t    {\n+\t      flag = FLAG_SHARED;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Oops, the color wasn't shared. Free it.\n+\t      XFreeColors(dpy, xid, &(color.pixel), 1, 0);\n+\t    }\n+\t}\n+      \n+      // Copy color data into object in array\n+      XColor* col = elements(colArray)[i];\n+      gnu::gcj::RawData* colorData = col->structure;\n+      ::XColor* colStruct = reinterpret_cast<xcolor*>(colorData);\n+      *colStruct = colors[i];\n+      colStruct->flags = flag;\n+    }\n+  \n+  return colArray;\n+}\n+"}, {"sha": "fadf4fb26962f254b4d73cfb4cf8c0b63573a761", "filename": "libjava/gnu/gcj/xlib/natDisplay.cc", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatDisplay.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatDisplay.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatDisplay.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,132 @@\n+/* Copyright (C) 1999, 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xproto.h>\n+#include <X11/Xlib.h>\n+#include <stdio.h>\n+\n+#include <java/lang/System.h>\n+#include <java/lang/RuntimeException.h>\n+#include <java/io/PrintStream.h>\n+#include <gcj/cni.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/XConnectException.h>\n+#include <gnu/gcj/xlib/XException.h>\n+\n+void gnu::gcj::xlib::Display::init()\n+{\n+  ::Display* openedDisplay = XOpenDisplay(0); // default display\n+  \n+  if (openedDisplay == 0) {\n+    jstring msg = JvNewStringLatin1(\"Unable to open display\");\n+    throw new gnu::gcj::xlib::XConnectException(msg);\n+  }\n+  \n+  display = reinterpret_cast<gnu::gcj::RawData*>(openedDisplay); \n+}\n+\n+void gnu::gcj::xlib::Display::finalize()\n+{\n+  if (display == 0) return;\n+  ::Display* dpy = (::Display*) display;\n+  XCloseDisplay(dpy);\n+}\n+\n+jint gnu::gcj::xlib::Display::getDefaultScreenNumber()\n+{\n+  ::Display* dpy = (::Display*) display;\n+  return DefaultScreen(dpy);\n+}\n+\n+jint gnu::gcj::xlib::Display::getDefaultRootWindowXID()\n+{\n+  ::Display* dpy = (::Display*) display;\n+  return DefaultRootWindow(dpy);\n+}\n+\n+jint gnu::gcj::xlib::Display::internAtom(jstring name)\n+{\n+  ::Display* dpy = (::Display*) display;\n+  int len = JvGetStringUTFLength(name);\n+  char cName[len+1];\n+  JvGetStringUTFRegion(name, 0, name->length(), cName);\n+  cName[len] = '\\0';\n+  bool onlyIfExists = false;\n+  return XInternAtom(dpy, cName, onlyIfExists);\n+}\n+\n+jstring gnu::gcj::xlib::Display::getAtomName(jint atom)\n+{\n+  ::Display* dpy = (::Display*) display;\n+  char* cName = XGetAtomName(dpy, atom);\n+  jstring name = JvNewStringLatin1(cName);\n+  XFree(cName);\n+  return name;\n+}\n+\n+static int handleXError(Display* dpy, XErrorEvent* xee)\n+{\n+  const int ERROR_TEXT_LENGTH = 256;\n+  char errorText[ERROR_TEXT_LENGTH];\n+  XGetErrorText(dpy, xee->error_code, errorText, ERROR_TEXT_LENGTH);\n+  int requestCode = xee->request_code;\n+  \n+  if (requestCode == X_GetImage)\n+    {\n+      /* The current implementation of Drawable.copyIntoXImage()\n+\t will generate harmless X_GetImage errors if the initially\n+\t requested area is not completly within the drawable. Until\n+\t we find a better solution, simply ignore these errors. */\n+      return 0;\n+    }\n+\n+  java::lang::System::err->print(JvNewStringLatin1(\"X error: \"));\n+  java::lang::System::err->print(JvNewStringLatin1(errorText));\n+  java::lang::System::err->print(JvNewStringLatin1(\", serial=\"));\n+  java::lang::System::err->print((jlong) xee->serial);\n+  java::lang::System::err->print(JvNewStringLatin1(\", requestCode=\"));\n+  java::lang::System::err->print((jint) requestCode);\n+  \n+  if (requestCode < 128)\n+    {\n+      char number[8];\n+      snprintf(number, 8, \"%d\", requestCode);\n+      number[7] = '\\0';\n+\n+      XGetErrorDatabaseText(dpy, \"XRequest\", number,\n+\t\t\t    \"\", errorText, ERROR_TEXT_LENGTH);\n+      java::lang::System::err->print(JvNewStringLatin1(\" (\"));\n+      java::lang::System::err->print(JvNewStringLatin1(errorText));\n+      java::lang::System::err->print(JvNewStringLatin1(\")\"));\n+    }\n+\n+  java::lang::System::err->print(JvNewStringLatin1(\", minorCode=\"));\n+  java::lang::System::err->print((jint) xee->minor_code);\n+  java::lang::System::err->print(JvNewStringLatin1(\", XID=\"));\n+  java::lang::System::err->println((jlong) xee->resourceid);\n+  \n+  return 0;\n+}\n+\n+void gnu::gcj::xlib::Display::staticInit()\n+{\n+  if (XInitThreads() == 0)\n+    {\n+      char msg[] = \"threads is not supported on this platform\";\n+      throw new java::lang::RuntimeException(JvNewStringLatin1(msg));\n+    }\n+  \n+  XSetErrorHandler(&handleXError);\n+}\n+\n+void gnu::gcj::xlib::Display::flush() \n+{\n+  ::Display* dpy = (::Display*) display;\n+  XFlush(dpy);\n+}"}, {"sha": "c6e253a549b03a163cafdbe47d10ce1f61788b87", "filename": "libjava/gnu/gcj/xlib/natDrawable.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatDrawable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatDrawable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatDrawable.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,79 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+\n+#include <gnu/gcj/xlib/XException.h>\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Drawable.h>\n+#include <gnu/gcj/xlib/XImage.h>\n+\n+#include <java/awt/Rectangle.h>\n+\n+jboolean gnu::gcj::xlib::Drawable::copyIntoXImageImpl(XImage* image,\n+\t\t\t\t\t\t      jint x, jint y,\n+\t\t\t\t\t\t      jint width, jint height,\n+\t\t\t\t\t\t      jint destX, jint destY)\n+{\n+  ::Display* dpy = (::Display*) (getDisplay()->display);\n+  ::XImage* ximage = (::XImage*) image->structure;\n+  int format = image->getFormat();\n+  int xid = getXID();\n+\n+  ::XImage* result = XGetSubImage(dpy, xid,\n+\t\t\t\t  x, y, width, height,\n+\t\t\t\t  ~0, // plane mask\n+\t\t\t\t  format,\n+\t\t\t\t  ximage,\n+\t\t\t\t  destX, destY);\n+  if (result == 0)\n+    return false;\n+    \n+  if (result != ximage)\n+    throw new XException(MSG_XGETSUBIMAGE_FAILED);\n+\n+  return true;\n+}\n+\n+java::awt::Rectangle*\n+gnu::gcj::xlib::Drawable::getBounds(java::awt::Rectangle* rv)\n+{\n+  ::Display* dpy = (::Display*) (getDisplay()->display);\n+\n+  ::Window root;\n+  int x, y;\n+  unsigned int w, h, bw, depth;\n+\n+  Status status = XGetGeometry(dpy, getXID(), &root,\n+\t\t\t       &x, &y, &w, &h,\n+\t\t\t       &bw, &depth);\n+  \n+  switch (status)\n+    {\n+    case BadDrawable:\n+      JvThrow(new XException(display, status));\n+    default:\n+      ; // All OK, NOP.\n+    }\n+ \n+  if (rv == 0)\n+    {\n+      rv = new java::awt::Rectangle(x, y, w, h);\n+    }\n+  else\n+    {\n+      rv->x = x;\n+      rv->y = y;\n+      rv->width = w;\n+      rv->height = h;\n+    }\n+  return rv;\n+}"}, {"sha": "7e6b3f709c38c7959d711c082746bdcaabcdb429", "filename": "libjava/gnu/gcj/xlib/natFont.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatFont.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatFont.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatFont.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,95 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+#include <java/lang/String.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Font.h>\n+#include <gnu/gcj/xlib/XException.h>\n+\n+gnu::gcj::RawData* gnu::gcj::xlib::Font::loadFont(Display* display,\n+\t\t\t\t\t\t  jstring lfdNamePattern)\n+{\n+  ::Display* dpy = (::Display*) display->display;\n+  int len = JvGetStringUTFLength(lfdNamePattern);\n+  char cName[len+1];\n+  JvGetStringUTFRegion(lfdNamePattern, 0, lfdNamePattern->length(),\n+\t\t       cName);\n+  cName[len] = '\\0';\n+\n+  XFontStruct* fontStruct = XLoadQueryFont(dpy, cName);\n+  if (fontStruct == 0)\n+    {\n+      JvThrow(new XException(JvNewStringLatin1(\"font not found\")));\n+    }\n+\n+  return reinterpret_cast<gnu::gcj::RawData*>(fontStruct);\n+}\n+\n+jint gnu::gcj::xlib::Font::getXIDFromStruct(gnu::gcj::RawData* structure)\n+{\n+  XFontStruct* fontStruct = (XFontStruct*) structure;\n+  return fontStruct->fid;\n+}\n+\n+jint gnu::gcj::xlib::Font::getMaxAscent()\n+{\n+  XFontStruct* fontStruct = (XFontStruct*) structure;\n+  return fontStruct->max_bounds.ascent;\n+}\n+\n+jint gnu::gcj::xlib::Font::getMaxDescent()\n+{\n+  XFontStruct* fontStruct = (XFontStruct*) structure;\n+  return fontStruct->max_bounds.descent;\n+}\n+\n+jint gnu::gcj::xlib::Font::getAscent()\n+{\n+  XFontStruct* fontStruct = (XFontStruct*) structure;\n+  return fontStruct->ascent;\n+}\n+\n+jint gnu::gcj::xlib::Font::getDescent()\n+{\n+  XFontStruct* fontStruct = (XFontStruct*) structure;\n+  return fontStruct->ascent;\n+}\n+\n+jint gnu::gcj::xlib::Font::getStringWidth(java::lang::String* text)\n+{\n+  XFontStruct* fontStruct = (XFontStruct*) structure;\n+  \n+  // FIXME: make proper unicode conversion\n+  int len = JvGetStringUTFLength(text);\n+  char ctxt[len+1];\n+  JvGetStringUTFRegion(text, 0, text->length(), ctxt);\n+  ctxt[len] = '\\0';\n+  int width = XTextWidth(fontStruct, ctxt, len);\n+  return width;\n+}\n+\n+void gnu::gcj::xlib::Font::finalize()\n+{\n+  if (structure != 0)\n+    {\n+      ::Display* dpy = (::Display*) display->display;\n+      XFontStruct* fontStruct = (XFontStruct*) structure;\n+      int result = XFreeFont(dpy, fontStruct);\n+\n+      if (result == BadFont) \n+\tthrow new XException(display, result);\n+      \n+      structure = 0; xid = 0;\n+    }\n+}\n+"}, {"sha": "66de35f868b22245106a1bdc4cc5d22e1d47b159", "filename": "libjava/gnu/gcj/xlib/natGC.cc", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatGC.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatGC.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatGC.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,207 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <vector>\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+#include <java/lang/String.h>\n+#include <java/awt/Rectangle.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/XID.h>\n+#include <gnu/gcj/xlib/Drawable.h>\n+#include <gnu/gcj/xlib/Font.h>\n+#include <gnu/gcj/xlib/XImage.h>\n+#include <gnu/gcj/xlib/XException.h>\n+#include <gnu/gcj/xlib/Clip.h>\n+#include <gnu/gcj/xlib/GC.h>\n+#include <gnu/gcj/xlib/XException.h>\n+\n+typedef java::awt::Rectangle AWTRect;\n+typedef JArray<AWTRect*> AWTRectArray;\n+typedef std::vector<XRectangle> XRectVector;\n+\n+void gnu::gcj::xlib::GC::initStructure(GC* copyFrom)\n+{\n+  Display* display = target->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Drawable drawableXID = target->getXID();\n+    \n+  ::GC gc = XCreateGC(dpy, drawableXID, 0, 0);\n+  \n+  if (gc == 0) \n+    throw new XException(JvNewStringLatin1(\"GC creation failed\"));\n+\n+  if (copyFrom != 0)\n+    {\n+      ::GC fromGC = (::GC) copyFrom->structure;\n+      XCopyGC(dpy, fromGC, ~0, gc);\n+      // no fast fail\n+    }\n+\n+  structure = reinterpret_cast<gnu::gcj::RawData*>(gc);\n+}\n+\n+void gnu::gcj::xlib::GC::disposeImpl()\n+{\n+  gnu::gcj::RawData* lStructure = structure;\n+  Drawable* lTargetType = target;\n+\n+  if ((lStructure == 0) || (lTargetType == 0))\n+    return;\n+    \n+  structure = 0;\n+  target = 0;\n+\t\n+  Display* display = lTargetType->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::GC gc = (::GC) lStructure;\n+\t\n+  XFreeGC(dpy, gc);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::GC::setForeground(jlong pixel)\n+{\n+  Display* display = target->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::GC gc = (::GC) structure;\n+  XSetForeground(dpy, gc, pixel);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::GC::setFont(Font* font)\n+{\n+  Display* display = target->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::GC gc = (::GC) structure;\n+  XSetFont(dpy, gc, font->getXID());\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::GC::drawString(jstring text, jint x, jint y)\n+{\n+  Display* display = target->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Drawable drawableXID = target->getXID();\n+  ::GC gc = (::GC) structure;\n+  \n+  /*\n+    FIXME: do something along the lines of the following instead:\n+\n+    jint length = text->length();\n+    jchar* txt = JvGetStringChars(text);\n+\n+    XChar2b xwchars[length];\n+    \n+    // FIXME: Add convertion and caching\n+\n+    for (int i=0; i<length; i++)\n+      {\n+\tXChar2b* xc = &(xwchars[i]);\n+\tjchar jc = txt[i];\n+\txc->byte1 = jc & 0xff;\n+\txc->byte2 = jc >> 8;\n+      }\n+\n+     XDrawString16(dpy, drawableXID, gc, x, y, xwchars, length);\n+    */\n+  \n+  // FIXME, temporary code:\n+  int len = JvGetStringUTFLength(text);\n+  char ctxt[len+1];\n+  JvGetStringUTFRegion(text, 0, text->length(), ctxt);\n+  ctxt[len] = '\\0';\n+  XDrawString(dpy, drawableXID, gc, x, y, ctxt, len);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::GC::drawLine(jint x1, jint y1, jint x2, jint y2)\n+{\n+  Display* display = target->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Drawable drawableXID = target->getXID();\n+  ::GC gc = (::GC) structure;\n+  XDrawLine(dpy, drawableXID, gc, x1, y1, x2, y2);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::GC::drawRectangle(jint x, jint y, jint w, jint h)\n+{\n+  Display* display = target->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Drawable drawableXID = target->getXID();\n+  ::GC gc = (::GC) structure;\n+  XDrawRectangle(dpy, drawableXID, gc, x, y, w, h);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::GC::fillRectangle(jint x, jint y, jint w, jint h)\n+{\n+  Display* display = target->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Drawable drawableXID = target->getXID();\n+  ::GC gc = (::GC) structure;\n+  XFillRectangle(dpy, drawableXID, gc, x, y, w, h);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::GC::clearArea(jint x, jint y, jint w, jint h,\n+\t\t\t\t   jboolean exposures)\n+{\n+  Display* display = target->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Drawable drawableXID = target->getXID();\n+  \n+  XClearArea(dpy, drawableXID, x, y, w, h,\n+\t     exposures ? True : False);\n+  // no fast fail\n+}\n+\n+\n+void gnu::gcj::xlib::GC::putImage(XImage* image,\n+\t\t\t\t  jint srcX, jint srcY,\n+\t\t\t\t  jint destX, jint destY,\n+\t\t\t\t  jint width, jint height)\n+{\n+  Display* display = target->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Drawable drawableXID = target->getXID();\n+  ::GC gc = (::GC) structure;\n+  ::XImage* ximage = (::XImage*) (image->structure);\n+  \n+  XPutImage(dpy, drawableXID, gc, ximage,\n+\t    srcX, srcY,\n+\t    destX, destY,\n+\t    width, height);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::GC::updateClip()\n+{\n+  if (clip == 0)\n+    return;\n+  \n+  Display* display = target->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::GC gc = (::GC) structure;\n+  \n+  XRectVector* xrectvector = (XRectVector*) (clip->xrects);\n+  int numRect = xrectvector->size();\n+  \n+  int originX = 0;\n+  int originY = 0;\n+  int ordering = Unsorted;\n+  XSetClipRectangles(dpy, gc, originX, originY,\n+\t\t     &(xrectvector->front()), numRect,\n+\t\t     ordering);\n+  // no fast fail\n+}"}, {"sha": "459f5bf3b286a9b9570e05eae3d241ef71131f1a", "filename": "libjava/gnu/gcj/xlib/natPixmap.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatPixmap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatPixmap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatPixmap.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,39 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+#include <X11/Xutil.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+\n+#include <java/lang/OutOfMemoryError.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Screen.h>\n+#include <gnu/gcj/xlib/Visual.h>\n+#include <gnu/gcj/xlib/Drawable.h>\n+#include <gnu/gcj/xlib/XImage.h>\n+#include <gnu/gcj/xlib/Pixmap.h>\n+\n+jint gnu::gcj::xlib::Pixmap::createXID(Drawable* drawable,\n+\t\t\t\t       jint width, jint height,\n+\t\t\t\t       jint depth)\n+{\n+  Display* display = drawable->getDisplay();\n+  ::Display* dpy = (::Display*) (display->display);\n+  jint xid = drawable->getXID();\n+  \n+  return XCreatePixmap(dpy, xid, width, height, depth);\n+}\n+\n+void gnu::gcj::xlib::Pixmap::finalize()\n+{\n+  ::Display* dpy = (::Display*) (getDisplay()->display);\n+  XFreePixmap(dpy, getXID());\n+}"}, {"sha": "9459c1f42ec22ac5cfd9866e59da465c0b3a1317", "filename": "libjava/gnu/gcj/xlib/natScreen.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatScreen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatScreen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatScreen.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,53 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Screen.h>\n+\n+void gnu::gcj::xlib::Screen::initStructure()\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Screen* screen = ScreenOfDisplay(dpy, screenNumber);\n+  \n+  structure = reinterpret_cast<gnu::gcj::RawData*>(screen);\n+}\n+\n+\n+jint gnu::gcj::xlib::Screen::getRootDepth()\n+{\n+  ::Screen* screen = (::Screen*) structure;\n+  return screen->root_depth;\n+}\n+\n+jint gnu::gcj::xlib::Screen::getRootWindowXID()\n+{\n+  ::Screen* screen = (::Screen*) structure;\n+  return RootWindowOfScreen(screen);\n+}\n+\n+jint gnu::gcj::xlib::Screen::getDefaultColormapXID()\n+{\n+  ::Screen* screen = (::Screen*) structure;\n+  return DefaultColormapOfScreen(screen);\n+}\n+\n+jint gnu::gcj::xlib::Screen::findScreenNumber()\n+{\n+  ::Screen* screen = (::Screen*) structure;\n+  return XScreenNumberOfScreen(screen);\n+}\n+\n+gnu::gcj::RawData* gnu::gcj::xlib::Screen::getRootVisualStructure()\n+{\n+  ::Screen* screen = (::Screen*) structure;\n+  ::Visual* visual = DefaultVisualOfScreen(screen);\n+  return reinterpret_cast<gnu::gcj::RawData*>(visual);\n+}"}, {"sha": "56e03b5abc95d3aabbd4e1390fa7840e8877b9e1", "filename": "libjava/gnu/gcj/xlib/natVisual.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatVisual.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatVisual.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatVisual.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,146 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+#include <X11/Xutil.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/xlib/Visual.h>\n+#include <gnu/gcj/xlib/Screen.h>\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/XException.h>\n+#include <gnu/gcj/RawData.h>\n+\n+using namespace gnu::gcj;\n+\n+void gnu::gcj::xlib::Visual::init(RawData* visual, jint depth)\n+{\n+  XVisualInfo* info = new XVisualInfo;\n+  xVisualInfo = reinterpret_cast<gnu::gcj::RawData*>(info);\n+  infoMask = 0;\n+    \n+  if (visual != 0)\n+    {\n+      ::Visual* visualStructure = (::Visual*) visual;\n+      info->visual = visualStructure;\n+      info->visualid = XVisualIDFromVisual(visualStructure);\n+      infoMask |= MASK_ID | MASK_VISUAL_STRUCTURE;\n+    }\n+\n+  if (depth  != 0)\n+    {\n+      info->depth = depth;\n+      infoMask |= MASK_DEPTH;\n+    }\n+}\n+\n+void gnu::gcj::xlib::Visual::finalize()\n+{\n+  if (xVisualInfo != 0)\n+    {\n+      delete xVisualInfo;\n+      xVisualInfo = 0;\n+    }\n+}\n+\n+RawData* gnu::gcj::xlib::Visual::getVisualStructure()\n+{\n+    ensureXVisualInfo(MASK_ALL); // Make sure structure is set\n+    XVisualInfo* info = (XVisualInfo*) xVisualInfo;\n+    return reinterpret_cast<gnu::gcj::RawData*>(info->visual);\n+}\n+\n+jint gnu::gcj::xlib::Visual::getRedMask()\n+{\n+  ensureXVisualInfo(MASK_RED);\n+  XVisualInfo* info = (XVisualInfo*) xVisualInfo;\n+  return info->red_mask;\n+}\n+\n+jint gnu::gcj::xlib::Visual::getGreenMask()\n+{\n+  ensureXVisualInfo(MASK_GREEN);\n+  XVisualInfo* info = (XVisualInfo*) xVisualInfo;\n+  return info->green_mask;\n+}\n+\n+jint gnu::gcj::xlib::Visual::getBlueMask()\n+{\n+  ensureXVisualInfo(MASK_BLUE);\n+  XVisualInfo* info = (XVisualInfo*) xVisualInfo;\n+  return info->blue_mask;\n+}\n+\n+jint gnu::gcj::xlib::Visual::getScreenNumber()\n+{\n+  if (screen != 0)\n+    return screen->getScreenNumber();\n+\n+  ensureXVisualInfo(MASK_SCREEN);\n+  XVisualInfo* info = (XVisualInfo*) xVisualInfo;\n+  return info->screen;\n+}\n+\n+jint gnu::gcj::xlib::Visual::getDepth()\n+{\n+  ensureXVisualInfo(MASK_DEPTH);\n+  \n+  XVisualInfo* info = (XVisualInfo*) xVisualInfo;\n+  return info->depth;\n+}\n+\n+jint gnu::gcj::xlib::Visual::getVisualClass()\n+{\n+  ensureXVisualInfo(MASK_CLASS);\n+  ::XVisualInfo* info = (::XVisualInfo*) xVisualInfo;\n+  return info->c_class;\n+}\n+\n+void gnu::gcj::xlib::Visual::ensureXVisualInfo(jint requiredMask)\n+{\n+  int missingInformation = ~infoMask;\n+  if ((missingInformation & requiredMask) == 0)\n+    return;\n+  \n+  // We need more info...\n+\n+  XVisualInfo* info = (XVisualInfo*) xVisualInfo;\n+\n+  // Store everything we know into template\n+  if (screen != 0)\n+    {\n+      info->screen = screen->getScreenNumber();\n+      infoMask |= MASK_SCREEN;\n+    }\n+  \n+  // Aquire info using the current info as template for matching\n+  ::Display* dpy = (::Display*) display->display;\n+  int visualInfoCount;\n+\n+  long mask = infoMask & MASK_ALL & (~MASK_VISUAL_STRUCTURE);\n+  XVisualInfo* matches = XGetVisualInfo(dpy, mask,\n+\t\t\t\t\t  info, &visualInfoCount);\n+  if (matches != 0)\n+    {\n+      (*info) = matches[0];\n+\n+      // redundant?\n+      xVisualInfo = reinterpret_cast<gnu::gcj::RawData*>(info);\n+\n+      infoMask = ~0; // ALL\n+      XFree(matches);\n+    } \n+  else \n+    {\n+      char msg[] = \n+\t\"XGetVisualInfo failed to find any matching visuals. The template \"\n+\t\"describes a combination of properties that does not exist on \"\n+\t\"this X server.\";\n+      throw new XException(JvNewStringLatin1(msg));\n+    }\n+}"}, {"sha": "f38ea387fa3d12c365db3ce4edbbc3cfe4bb3997", "filename": "libjava/gnu/gcj/xlib/natWMSizeHints.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWMSizeHints.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWMSizeHints.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWMSizeHints.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,75 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+#include <X11/Xutil.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+#include <java/lang/OutOfMemoryError.h>\n+\n+#include <gnu/gcj/xlib/Window.h>\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/WMSizeHints.h>\n+\n+void gnu::gcj::xlib::WMSizeHints::init(WMSizeHints* copyFrom)\n+{\n+  XSizeHints* hints = XAllocSizeHints();\n+  if (hints == 0)\n+    {\n+      jstring errorMessage = JvNewStringLatin1(\"XAllocSizeHints failed\");\n+      JvThrow(new java::lang::OutOfMemoryError(errorMessage));\n+    }\n+\n+  if (copyFrom != 0)\n+    {\n+      XSizeHints* from = (XSizeHints*) copyFrom->structure;\n+      (*hints) = (*from);\n+    } \n+  else\n+    {\n+      // Is this necessary?\n+      hints->flags = 0;\n+    }\n+  structure = reinterpret_cast<gnu::gcj::RawData*>(hints);\n+}\n+\n+void gnu::gcj::xlib::WMSizeHints::finalize()\n+{\n+  delete structure;\n+}\n+\n+void gnu::gcj::xlib::WMSizeHints::applyNormalHints(gnu::gcj::xlib::Window* window)\n+{\n+  Display* display = window->display;\n+  ::Display* dpy = (::Display*) display->display;\n+  ::Window win = window->getXID();\n+  XSizeHints* hints = (XSizeHints*) structure;\n+  \n+  XSetWMNormalHints(dpy, win, hints);\n+  /* FIXME, alternative?\n+     // X11 source reports XSetWMNormalHints() as an old routine. (?)\n+     XSetWMSizeHints(dpy, win, hints, display->getAtom(\"WM_NORMAL_HINTS\"));\n+  */\n+}\n+\n+void gnu::gcj::xlib::WMSizeHints::setMinSize(jint width, jint height)\n+{\n+  XSizeHints* hints = (XSizeHints*) structure;\n+  hints->min_width = width;\n+  hints->min_height = height;\n+  hints->flags = hints->flags | PMinSize;\n+}\n+\n+void gnu::gcj::xlib::WMSizeHints::setMaxSize(jint width, jint height)\n+{\n+  XSizeHints* hints = (XSizeHints*) structure;\n+  hints->max_width = width;\n+  hints->max_height = height;\n+  hints->flags = hints->flags | PMaxSize;\n+}"}, {"sha": "6600795574f5809b8a0cf300051f67c6b12500d8", "filename": "libjava/gnu/gcj/xlib/natWindow.cc", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWindow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWindow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWindow.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,171 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Needed to avoid linking in libstdc++\n+#ifndef __STL_USE_EXCEPTIONS\n+#   include <java/lang/OutOfMemoryError.h>\n+#   define __THROW_BAD_ALLOC throw new java::lang::OutOfMemoryError()\n+#endif\n+\n+#include <vector>\n+\n+#include <X11/Xlib.h>\n+#include <gcj/cni.h>\n+#include <java/awt/Rectangle.h>\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Window.h>\n+#include <gnu/gcj/xlib/WindowAttributes.h>\n+#include <gnu/gcj/xlib/Visual.h>\n+#include <gnu/gcj/xlib/XException.h>\n+\n+jint gnu::gcj::xlib::Window::createChildXID(java::awt::Rectangle* bounds,\n+\t\t\t\t\tjint borderWidth,\n+\t\t\t\t\tWindowAttributes* attributes,\n+\t\t\t\t\tjint windowIOClass, \n+\t\t\t\t\tVisual* visual)\n+{\n+  ::Window parentXID = xid;\n+  \n+  int x      = bounds->x;\n+  int y      = bounds->y;\n+  int width  = bounds->width;\n+  int height = bounds->height;\n+  \n+  long mask = attributes->mask;\n+  XSetWindowAttributes* attr = (XSetWindowAttributes*)\n+    attributes->getXSetWindowAttributesStructure();\n+  \n+  ::Visual* vis = CopyFromParent;\n+  int depth = CopyFromParent;\n+  if (visual != 0)\n+    {\n+      vis = (::Visual*) visual->getVisualStructure();\n+      depth = visual->getDepth();\n+    }\n+\n+  ::Window childXID = XCreateWindow((::Display*) (display->display),\n+\t\t\t\t    parentXID,\n+\t\t\t\t    x, y, width, height,\n+\t\t\t\t    borderWidth, depth, windowIOClass,\n+\t\t\t\t    vis,\n+\t\t\t\t    mask, attr);\n+  // no fast fail\n+  return childXID;\n+}\n+\n+void gnu::gcj::xlib::Window::destroy()\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Window window = xid;\n+  XDestroyWindow(dpy, window);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::Window::setAttributes(WindowAttributes* attributes)\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Window window = xid;\n+  ::XSetWindowAttributes* attr = (::XSetWindowAttributes*)\n+      attributes->getXSetWindowAttributesStructure();\n+\n+  XChangeWindowAttributes(dpy, window, attributes->mask, attr);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::Window::map()\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Window window = xid;\n+  XMapWindow(dpy, window);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::Window::unmap()\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  ::Window window = xid;\n+  XUnmapWindow(dpy, window);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::Window::setProperty(jint nameAtom, jint typeAtom, \n+\t\t\t\t\t jbyteArray data)\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  int format = 8;\n+  int mode = PropModeReplace;\n+  unsigned char* pData = (unsigned char*) elements(data);\n+  int len = data->length;\n+  \n+  XChangeProperty(dpy, xid, nameAtom, typeAtom, format, mode,\n+\t\t  pData, len);\n+  // no fast fail\n+}\n+\n+void gnu::gcj::xlib::Window::setWMProtocols(jintArray atoms)\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  \n+  size_t length = atoms->length;\n+  jint* atomsBegin = elements(atoms);\n+  jint* atomsEnd   = atomsBegin + length;\n+  \n+  // Avoid confusion between Xlib.h and Atom.java \"Atom\" types.\n+  typedef ::Atom XLibAtom;\n+  \n+  std::vector<XLibAtom> atomVector(atomsBegin, atomsEnd);\n+  XLibAtom* atomsArray = &(atomVector.front());\n+  \n+  XSetWMProtocols(dpy, xid, atomsArray, length);\n+  // no fail fast\n+}\n+\n+jintArray gnu::gcj::xlib::Window::getWMProtocols()\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  \n+  ::Atom* protocolsReturn;\n+  int countReturn;\n+  \n+  Status success = XGetWMProtocols(dpy, xid, &protocolsReturn,\n+\t\t\t\t   &countReturn);\n+  \n+  if (!success)\n+    throw new XException(JvNewStringLatin1(\"cannot get \"\n+\t\t\t\t\t   \"WM protocols \"));\n+  \n+  jintArray atoms;\n+  try\n+    {\n+      ::Atom* protocolsBegin = protocolsReturn;\n+      ::Atom* protocolsEnd = protocolsBegin + countReturn;\n+      \n+      atoms = JvNewIntArray(countReturn);\n+      jint* atomsBegin = elements(atoms);\n+      \n+      std::copy(protocolsBegin, protocolsEnd, atomsBegin);\n+      \n+    }\n+  catch (...)\n+    {\n+      XFree(protocolsReturn);\n+      throw;\n+    }\n+  XFree(protocolsReturn);\n+  \n+  return atoms;\n+}\n+\n+void gnu::gcj::xlib::Window::setBounds(jint x, jint y,\n+\t\t\t\t       jint width, jint height)\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  \n+  XMoveResizeWindow(dpy, xid, x, y, width, height);\n+  // no fast fail\n+}"}, {"sha": "5281acbab5235ebbf8ab1df023beb77408a85e6e", "filename": "libjava/gnu/gcj/xlib/natWindowAttributes.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWindowAttributes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWindowAttributes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatWindowAttributes.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,109 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Window.h>\n+#include <gnu/gcj/xlib/WindowAttributes.h>\n+#include <gnu/gcj/xlib/Pixmap.h>\n+#include <gnu/gcj/xlib/XException.h>\n+#include <gnu/gcj/xlib/Screen.h>\n+#include <gnu/gcj/xlib/Visual.h>\n+\n+\n+void gnu::gcj::xlib::WindowAttributes::initFromWindow(Window* from)\n+{\n+  display = from->getDisplay();\n+  ::Display* dpy = (::Display*) display->display;\n+  ::Window win = from->getXID();\n+  \n+  XWindowAttributes* attributesIn  = new XWindowAttributes;\n+  in = reinterpret_cast<gnu::gcj::RawData*>(attributesIn);\n+\n+  Status status = XGetWindowAttributes(dpy, win, attributesIn);\n+  if ((status == BadDrawable) | (status == BadWindow))\n+    JvThrow(new XException(display, status));\n+}\n+\n+\n+void gnu::gcj::xlib::WindowAttributes::init(WindowAttributes* copyFrom)\n+{\n+  XSetWindowAttributes* attributes = new XSetWindowAttributes;\n+\n+  if (copyFrom != 0)\n+    {\n+      XSetWindowAttributes* from = \n+\t(XSetWindowAttributes*) copyFrom->out;\n+      (*attributes) = (*from);\n+    } \n+  \n+  out = reinterpret_cast<gnu::gcj::RawData*>(attributes);\n+}\n+\n+void gnu::gcj::xlib::WindowAttributes::finalize()\n+{\n+  delete in; in = 0;\n+  delete out; out = 0;\n+}\n+\n+void gnu::gcj::xlib::WindowAttributes::setBackground(jlong pixel)\n+{\n+  XSetWindowAttributes* attributes = (XSetWindowAttributes*) out;\n+  \n+  attributes->background_pixel = pixel;\n+  mask = mask | CWBackPixel;\n+}\n+\n+void gnu::gcj::xlib::WindowAttributes::setBackground(Pixmap* pixmap)\n+{\n+  XSetWindowAttributes* attributes = (XSetWindowAttributes*) out;\n+\n+  attributes->background_pixmap = pixmap->getXID();\n+  mask = mask | CWBackPixmap;\n+}\n+\n+void gnu::gcj::xlib::WindowAttributes::setEventMask(jlong eventMask)\n+{\n+  XSetWindowAttributes* attributes = (XSetWindowAttributes*) out;\n+\n+  attributes->event_mask = eventMask;\n+  mask = mask | CWEventMask;\n+}\n+\n+gnu::gcj::xlib::Visual* gnu::gcj::xlib::WindowAttributes::getVisual()\n+{\n+  if (in == 0)\n+    return 0;\n+\n+  XWindowAttributes* attributesIn = (XWindowAttributes*) in;\n+\n+  gnu::gcj::RawData* screenRef =\n+    reinterpret_cast<gnu::gcj::RawData*>(attributesIn->screen);\n+\n+  Screen* screen = new Screen(display, screenRef);\n+\n+  gnu::gcj::RawData* visualRef =\n+    reinterpret_cast<gnu::gcj::RawData*>(attributesIn->visual);\n+\n+  return new gnu::gcj::xlib::Visual(visualRef, screen, attributesIn->depth);\n+}\n+\n+\n+void gnu::gcj::xlib::WindowAttributes::apply(Window* window)\n+{\n+  ::Display* dpy = (::Display*) window->getDisplay()->display;\n+  ::Window win = window->getXID();\n+  XSetWindowAttributes* attributes = (XSetWindowAttributes*) out;\n+  \n+  XChangeWindowAttributes(dpy, win, mask, attributes);\n+}\n+"}, {"sha": "439f204b37374e4d1ea79743ad3c1b0539496ac8", "filename": "libjava/gnu/gcj/xlib/natXAnyEvent.cc", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXAnyEvent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXAnyEvent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXAnyEvent.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,99 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+\n+#include <java/lang/RuntimeException.h>\n+\n+#include <java/lang/System.h>\n+#include <java/io/PrintStream.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Window.h>\n+#include <gnu/gcj/xlib/XAnyEvent.h>\n+#include <gnu/gcj/xlib/XExposeEvent.h>\n+#include <gnu/gcj/xlib/XException.h>\n+\n+void gnu::gcj::xlib::XAnyEvent::init()\n+{\n+  ::XEvent* event = new ::XEvent;\n+  structure = reinterpret_cast<gnu::gcj::RawData*>(event);\n+}\n+\n+void gnu::gcj::xlib::XAnyEvent::finalize()\n+{\n+  delete structure;\n+  structure = 0;\n+}\n+\n+void gnu::gcj::xlib::XAnyEvent::loadNext()\n+{\n+  ::Display* dpy = (::Display*) display->display;\n+  ::XEvent* evt = (::XEvent*) structure;\n+  XNextEvent(dpy, evt);\n+  // What does XNextEvent return?\n+}\n+\n+jint gnu::gcj::xlib::XAnyEvent::getType()\n+{\n+  ::XEvent* event = (::XEvent*) structure;\n+  return event->type;\n+}\n+\n+void gnu::gcj::xlib::XAnyEvent::setType(jint type)\n+{\n+  ::XEvent* event = (::XEvent*) structure;\n+  event->type = type;\n+}\n+\n+gnu::gcj::xlib::Window* gnu::gcj::xlib::XAnyEvent::getWindow()\n+{\n+  ::XEvent* event = (::XEvent*) structure;\n+  return display->getWindow(event->xany.window);\n+}\n+\n+void gnu::gcj::xlib::XAnyEvent::setWindow(gnu::gcj::xlib::Window* window)\n+{\n+  ::XEvent* event = (::XEvent*) structure;\n+  event->xany.window = window->getXID();\n+}\n+\n+jlong gnu::gcj::xlib::XAnyEvent::getSerial()\n+{\n+  ::XEvent* event = (::XEvent*) structure;\n+  return event->xany.serial;\n+}\n+\n+void gnu::gcj::xlib::XAnyEvent::send(gnu::gcj::xlib::Window* destination,\n+\t\t\t\t     jboolean propagate, jlong mask)\n+{\n+  ::Display* dpy = (::Display*) display->display;\n+  ::XEvent* event = (::XEvent*) structure;\n+\n+  Status status = \n+    XSendEvent(dpy, destination->getXID(), propagate ? True : False,\n+\t       mask, event);\n+\n+  switch (status)\n+    {\n+    case 0:\n+      throw new XException(JvNewStringLatin1(\"conversion to wire \"\n+\t\t\t\t\t     \"protocol failed\"));\n+    case BadWindow:\n+    case BadValue:\n+      throw new XException(display, status);\n+\n+    default:\n+      /* All other return values indicate success.  Ie. (status ==\n+\t 1) indicates success, not BadRequest. */\n+      ; // NOP\n+    }\n+}"}, {"sha": "fa02df833d0c21b9a72f745a85dc3ea706ae92ca", "filename": "libjava/gnu/gcj/xlib/natXButtonEvent.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXButtonEvent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXButtonEvent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXButtonEvent.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,30 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Window.h>\n+#include <gnu/gcj/xlib/XAnyEvent.h>\n+#include <gnu/gcj/xlib/XEvent.h>\n+#include <gnu/gcj/xlib/XButtonEvent.h>\n+\n+void gnu::gcj::xlib::XButtonEvent::init()\n+{\n+  ::XButtonEvent* evt = (::XButtonEvent*) event->structure;\n+  \n+  time = evt->time;\n+  x = evt->x;\n+  y = evt->y;\n+  state = evt->state;\n+  button = evt->button;\n+}\n+"}, {"sha": "4e76cf91f58aeca27d4f219c553993d88039c661", "filename": "libjava/gnu/gcj/xlib/natXColor.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXColor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXColor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXColor.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,61 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+#include <gnu/gcj/xlib/XColor.h>\n+\n+void gnu::gcj::xlib::XColor::init()\n+{\n+  structure = reinterpret_cast<gnu::gcj::RawData*>(new ::XColor);\n+}\n+\n+void gnu::gcj::xlib::XColor::finalize()\n+{\n+  delete structure;\n+}\n+\n+void gnu::gcj::xlib::XColor::setRGB(jint r, jint g, jint b)\n+{\n+  ::XColor* color = (::XColor*) structure;\n+  color->red   = r;\n+  color->green = g;\n+  color->blue  = b;\n+}\n+\n+jint gnu::gcj::xlib::XColor::getRed()\n+{\n+  ::XColor* color = (::XColor*) structure;\n+  return color->red;\n+}\n+\n+jint gnu::gcj::xlib::XColor::getGreen()\n+{\n+  ::XColor* color = (::XColor*) structure;\n+  return color->green;\n+}\n+\n+jint gnu::gcj::xlib::XColor::getBlue()\n+{\n+  ::XColor* color = (::XColor*) structure;\n+  return color->blue;\n+}\n+\n+jbyte gnu::gcj::xlib::XColor::getFlags()\n+{\n+  ::XColor* color = (::XColor*) structure;\n+  return color->flags;\n+}\n+\n+jlong gnu::gcj::xlib::XColor::getPixelValue()\n+{\n+  ::XColor* color = (::XColor*) structure;\n+  return color->pixel;\n+}"}, {"sha": "a65c0b35134f9728547b5d9be86d5bcd2d5b48dc", "filename": "libjava/gnu/gcj/xlib/natXConfigureEvent.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXConfigureEvent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXConfigureEvent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXConfigureEvent.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,31 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Window.h>\n+#include <gnu/gcj/xlib/XAnyEvent.h>\n+#include <gnu/gcj/xlib/XEvent.h>\n+#include <gnu/gcj/xlib/XConfigureEvent.h>\n+#include <java/awt/Rectangle.h>\n+\n+using java::awt::Rectangle;\n+\n+java::awt::Rectangle* gnu::gcj::xlib::XConfigureEvent::getBounds()\n+{\n+  ::XConfigureEvent* evt = (::XConfigureEvent*) event->structure;\n+  Rectangle* rectangle = new Rectangle(evt->x, evt->y,\n+\t\t\t\t       evt->width, evt->height);\n+\t\t\t\t\t \n+  return rectangle;\n+}\n+"}, {"sha": "4bf7197fb8a0f0116c7aa35b07421f493e2b6c14", "filename": "libjava/gnu/gcj/xlib/natXException.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXException.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXException.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXException.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,24 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/XException.h>\n+\n+jstring gnu::gcj::xlib::XException::toString(Display* display, jint status)\n+{\n+  ::Display* dpy = (::Display*) (display->display);\n+  \n+  const int ERROR_TEXT_LENGTH = 256;\n+  char errorText[ERROR_TEXT_LENGTH];\n+  \n+  XGetErrorText(dpy, status, errorText, ERROR_TEXT_LENGTH);\n+  return JvNewStringLatin1(errorText);\n+}"}, {"sha": "6dad170e43284b2de40c39d0f26a9c09c8849c2d", "filename": "libjava/gnu/gcj/xlib/natXExposeEvent.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXExposeEvent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXExposeEvent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXExposeEvent.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,31 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Window.h>\n+#include <gnu/gcj/xlib/XAnyEvent.h>\n+#include <gnu/gcj/xlib/XEvent.h>\n+#include <gnu/gcj/xlib/XExposeEvent.h>\n+#include <java/awt/Rectangle.h>\n+\n+using java::awt::Rectangle;\n+\n+java::awt::Rectangle* gnu::gcj::xlib::XExposeEvent::getBounds()\n+{\n+  ::XExposeEvent* evt = (::XExposeEvent*) event->structure;\n+  Rectangle* rectangle = new Rectangle(evt->x, evt->y,\n+\t\t\t\t       evt->width, evt->height);\n+\t\t\t\t\t \n+  return rectangle;\n+}\n+"}, {"sha": "a527e8e665bc5564537cc6814df8f5d05b7bca24", "filename": "libjava/gnu/gcj/xlib/natXImage.cc", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXImage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXImage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXImage.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,220 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+#include <X11/Xutil.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+\n+#include <java/lang/OutOfMemoryError.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Screen.h>\n+#include <gnu/gcj/xlib/Visual.h>\n+#include <gnu/gcj/xlib/XImage.h>\n+#include <java/lang/System.h>\n+#include <java/io/PrintStream.h>\n+\n+void gnu::gcj::xlib::XImage::init(Visual* visual, jint depth,\n+\t\t\t\t  jint format, jint xoffset,\n+\t\t\t\t  jint width, jint height,\n+\t\t\t\t  jint bitmapPad, jint bytesPerLine,\n+\t\t\t\t  jint bitsPerPixel)\n+{\n+  ::Display* dpy = (::Display*) visual->display->display;\n+  ::Visual* vis = (::Visual*) visual->getVisualStructure();\n+\n+  char* data = 0; // no preallocated data\n+  ::XImage* ximage = XCreateImage(dpy, vis, depth, format, xoffset,\n+\t\t\t\t  data,\n+\t\t\t\t  width, height, \n+\t\t\t\t  bitmapPad,\n+\t\t\t\t  bytesPerLine\n+\t\t\t\t  );\n+  if (ximage == 0)\n+    {\n+      jstring errorMessage = JvNewStringLatin1(\"XCreateImage failed\");\n+      JvThrow(new java::lang::OutOfMemoryError(errorMessage));\n+    }\n+    \n+  bool reinitialize = false;\n+    \n+  if ((bitsPerPixel != 0) && (ximage->bits_per_pixel != bitsPerPixel))\n+    {\n+      ximage->bits_per_pixel = bitsPerPixel;\n+      reinitialize = true;\n+    }\n+    \n+  // FIXME: make autoconf test?\n+  jshort endianTestShort[] = { 1 };\n+  jbyte* endianTestByte = reinterpret_cast<jbyte*>(endianTestShort);\n+    \n+  jint byteOrder;\n+  if (endianTestByte[0] == 1)\n+    {\n+      // little endian machine\n+      byteOrder = LEAST_SIGNIFICANT_B_FIRST_ORDER;\n+    }\n+  else\n+    {\n+      // big endian machine\n+      byteOrder = MOST_SIGNIFICANT_B_FIRST_ORDER;\n+    }\n+  /* NB: This doesn't consider those weird machines out there with\n+     middle-endian byte order. */\n+    \n+  if (byteOrder != ximage->byte_order)\n+    {\n+      ximage->byte_order = byteOrder;\n+      reinitialize = true;\n+    }\n+    \n+  if (reinitialize)\n+    XInitImage(ximage);\n+    \n+  structure = reinterpret_cast<gnu::gcj::RawData*>(ximage);\n+  // Notice that no image data has been allocated at this point\n+}\n+\n+void gnu::gcj::xlib::XImage::init(Visual* visual, \n+\t\t\t\t  jint width,\n+\t\t\t\t  jint height)\n+{\n+  int depth = visual->getDepth();\n+    \n+  int format = ZPixmap; // Chunky, not planar.\n+  int offset = 0;\n+  int bitmapPad = 32; // FIXME, don't hardcode this\n+  int bytesPerLine = 0; // Let the server figure it out\n+\n+  init(visual, depth, format, offset, width, height, bitmapPad,\n+       bytesPerLine, 0);\n+}\n+\n+void gnu::gcj::xlib::XImage::internalSetData(jbyteArray data, jint offset)\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  ximage->data = reinterpret_cast<char*>(elements(data)+offset);\n+}\n+\n+void gnu::gcj::xlib::XImage::internalSetData(jshortArray data, jint offset)\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  ximage->data = reinterpret_cast<char*>(elements(data)+offset);\n+}\n+\n+void gnu::gcj::xlib::XImage::internalSetData(jintArray data, jint offset)\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  ximage->data = reinterpret_cast<char*>(elements(data)+offset);\n+}\n+\n+void gnu::gcj::xlib::XImage::finalize()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  if (ownsData)\n+    delete ximage->data;\n+  \n+  ximage->data = 0; // Never allow XLib to free the data allocation.\n+  dataRef = 0;\n+  XDestroyImage(ximage);\n+}\n+\n+jint gnu::gcj::xlib::XImage::getWidth()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->width;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getHeight()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->height;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getDepth()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->depth;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getFormat()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->format;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getXOffset()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->xoffset;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getImageByteOrder()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->byte_order;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getBitmapBitOrder()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->bitmap_bit_order;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getBitmapUnit()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->bitmap_unit;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getBitmapPad()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->bitmap_pad;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getBytesPerLine()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->bytes_per_line;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getBitsPerPixel()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->bits_per_pixel;\n+}\n+\n+\n+// True/Direct Color specific:\n+\n+jint gnu::gcj::xlib::XImage::getRedMask()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->red_mask;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getGreenMask()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->green_mask;\n+}\n+\n+jint gnu::gcj::xlib::XImage::getBlueMask()\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  return ximage->blue_mask;\n+}\n+\n+void gnu::gcj::xlib::XImage::setPixel(jint x, jint y, jint pixel)\n+{\n+  ::XImage* ximage = (::XImage*) structure;\n+  XPutPixel(ximage, x, y, pixel);\n+}"}, {"sha": "d91a7787283a14784c16c857eb17289f23bc8ed3", "filename": "libjava/gnu/gcj/xlib/natXUnmapEvent.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXUnmapEvent.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXUnmapEvent.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fxlib%2FnatXUnmapEvent.cc?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -0,0 +1,32 @@\n+/* Copyright (C) 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <X11/Xlib.h>\n+\n+#include <gcj/cni.h>\n+#include <gnu/gcj/RawData.h>\n+\n+#include <gnu/gcj/xlib/Display.h>\n+#include <gnu/gcj/xlib/Window.h>\n+#include <gnu/gcj/xlib/XAnyEvent.h>\n+#include <gnu/gcj/xlib/XEvent.h>\n+#include <gnu/gcj/xlib/XUnmapEvent.h>\n+\n+void gnu::gcj::xlib::XUnmapEvent::setUnmappedWindow(gnu::gcj::xlib::Window*\n+\t\t\t\t\t\t    unmappedWindow)\n+{\n+  ::XUnmapEvent* evt = (::XUnmapEvent*) event->structure;\n+  evt->window = unmappedWindow->getXID();\n+}\n+\n+void gnu::gcj::xlib::XUnmapEvent::setFromConfigure(jboolean fromConfigure)\n+{\n+  ::XUnmapEvent* evt = (::XUnmapEvent*) event->structure;\n+  evt->from_configure = fromConfigure ? True : False;\n+}\n+"}, {"sha": "1887fcfecc6a420ea21d8f9cfae31d288f0fddc3", "filename": "libjava/java/awt/EventDispatchThread.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fjava%2Fawt%2FEventDispatchThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2622c79d2d51f6bf9122a3b5f458daa50c0baf19/libjava%2Fjava%2Fawt%2FEventDispatchThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FEventDispatchThread.java?ref=2622c79d2d51f6bf9122a3b5f458daa50c0baf19", "patch": "@@ -24,6 +24,7 @@ class EventDispatchThread extends Thread\n     setName(\"AWT-EventQueue-\" + dispatchThreadNum++);\n     this.queue = queue;\n     setPriority(NORM_PRIORITY + 1);\n+    start();\n   }\n \n   public void run()"}]}