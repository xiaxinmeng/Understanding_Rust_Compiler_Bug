{"sha": "2082e02f4146963ac678935af25c65430210f350", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA4MmUwMmY0MTQ2OTYzYWM2Nzg5MzVhZjI1YzY1NDMwMjEwZjM1MA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-06-24T02:20:12Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-06-24T02:20:12Z"}, "message": "builtins.c (expand_builtin): Use expand_builtin_pow to expand calls for pow...\n\n\n\t* builtins.c (expand_builtin): Use expand_builtin_pow to expand\n\tcalls for pow, powf, powl and their __builtin_ variants.\n\t(expand_builtin_pow): If the second argument is a constant\n\tinteger and compiling with -ffast-math, use expand_powi to\n\tgenerate RTL if powi_cost is less than POWI_MAX_MULTS.\n\t(powi_cost): New function to return the number of multiplications\n\tnecessary to evaluate an Nth power, for integer constant N.\n\t(expand_powi): New function to expand the RTL for evaluating\n\tthe Nth power of a floating point value, for integer constant N.\n\n\t* doc/tm.texi (POWI_MAX_MULTS): Document new target macro.\n\n\t* gcc.dg/builtins-24.c: New test case.\n\nFrom-SVN: r68401", "tree": {"sha": "e544613227ec08f4df55e0c085a0efa4b3b4352b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e544613227ec08f4df55e0c085a0efa4b3b4352b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2082e02f4146963ac678935af25c65430210f350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2082e02f4146963ac678935af25c65430210f350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2082e02f4146963ac678935af25c65430210f350", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2082e02f4146963ac678935af25c65430210f350/comments", "author": null, "committer": null, "parents": [{"sha": "e4048ffc3f1f29dbde9393a895bac67aa6e62948", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4048ffc3f1f29dbde9393a895bac67aa6e62948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4048ffc3f1f29dbde9393a895bac67aa6e62948"}], "stats": {"total": 318, "additions": 318, "deletions": 0}, "files": [{"sha": "e2de16881f01c3143e74e8938beba4a316bc4146", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2082e02f4146963ac678935af25c65430210f350/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2082e02f4146963ac678935af25c65430210f350/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2082e02f4146963ac678935af25c65430210f350", "patch": "@@ -1,3 +1,17 @@\n+2003-06-23  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (expand_builtin): Use expand_builtin_pow to expand\n+\tcalls for pow, powf, powl and their __builtin_ variants.\n+\t(expand_builtin_pow): If the second argument is a constant\n+\tinteger and compiling with -ffast-math, use expand_powi to\n+\tgenerate RTL if powi_cost is less than POWI_MAX_MULTS.\n+\t(powi_cost): New function to return the number of multiplications\n+\tnecessary to evaluate an Nth power, for integer constant N.\n+\t(expand_powi): New function to expand the RTL for evaluating\n+\tthe Nth power of a floating point value, for integer constant N.\n+\n+\t* doc/tm.texi (POWI_MAX_MULTS): Document new target macro.\n+\n Mon Jun 23 23:07:35 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_nodes_queue): Declare."}, {"sha": "97c3372f2dbeb532567540174a8acf8b2cf6b4f0", "filename": "gcc/builtins.c", "status": "modified", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2082e02f4146963ac678935af25c65430210f350/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2082e02f4146963ac678935af25c65430210f350/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2082e02f4146963ac678935af25c65430210f350", "patch": "@@ -1937,6 +1937,253 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   return target;\n }\n \n+/* To evaluate powi(x,n), the floating point value x raised to the\n+   constant integer exponent n, we use a hybrid algorithm that\n+   combines the \"window method\" with look-up tables.  For an\n+   introduction to exponentiation algorithms and \"addition chains\",\n+   see section 4.6.3, \"Evaluation of Powers\" of Donald E. Knuth,\n+   \"Seminumerical Algorithms\", Vol. 2, \"The Art of Computer Programming\",\n+   3rd Edition, 1998, and Daniel M. Gordon, \"A Survey of Fast Exponentiation\n+   Methods\", Journal of Algorithms, Vol. 27, pp. 129-146, 1998.  */\n+\n+/* Provide a default value for POWI_MAX_MULTS, the maximum number of\n+   multiplications to inline before calling the system library's pow\n+   function.  powi(x,n) requires at worst 2*bits(n)-2 multiplications,\n+   so this default never requires calling pow, powf or powl.  */\n+ \n+#ifndef POWI_MAX_MULTS\n+#define POWI_MAX_MULTS  (2*HOST_BITS_PER_WIDE_INT-2)\n+#endif\n+\n+/* The size of the \"optimal power tree\" lookup table.  All\n+   exponents less than this value are simply looked up in the\n+   powi_table below.  This threshold is also used to size the\n+   cache of pseudo registers that hold intermediate results.  */\n+#define POWI_TABLE_SIZE 256\n+\n+/* The size, in bits of the window, used in the \"window method\"\n+   exponentiation algorithm.  This is equivalent to a radix of\n+   (1<<POWI_WINDOW_SIZE) in the corresponding \"m-ary method\".  */\n+#define POWI_WINDOW_SIZE 3\n+\n+/* The following table is an efficient representation of an\n+   \"optimal power tree\".  For each value, i, the corresponding\n+   value, j, in the table states than an optimal evaluation\n+   sequence for calculating pow(x,i) can be found by evaluating\n+   pow(x,j)*pow(x,i-j).  An optimal power tree for the first\n+   100 integers is given in Knuth's \"Seminumerical algorithms\".  */\n+\n+static const unsigned char powi_table[POWI_TABLE_SIZE] =\n+  {\n+      0,   1,   1,   2,   2,   3,   3,   4,  /*   0 -   7 */\n+      4,   6,   5,   6,   6,  10,   7,   9,  /*   8 -  15 */\n+      8,  16,   9,  16,  10,  12,  11,  13,  /*  16 -  23 */\n+     12,  17,  13,  18,  14,  24,  15,  26,  /*  24 -  31 */\n+     16,  17,  17,  19,  18,  33,  19,  26,  /*  32 -  39 */\n+     20,  25,  21,  40,  22,  27,  23,  44,  /*  40 -  47 */\n+     24,  32,  25,  34,  26,  29,  27,  44,  /*  48 -  55 */\n+     28,  31,  29,  34,  30,  60,  31,  36,  /*  56 -  63 */\n+     32,  64,  33,  34,  34,  46,  35,  37,  /*  64 -  71 */\n+     36,  65,  37,  50,  38,  48,  39,  69,  /*  72 -  79 */\n+     40,  49,  41,  43,  42,  51,  43,  58,  /*  80 -  87 */\n+     44,  64,  45,  47,  46,  59,  47,  76,  /*  88 -  95 */\n+     48,  65,  49,  66,  50,  67,  51,  66,  /*  96 - 103 */\n+     52,  70,  53,  74,  54, 104,  55,  74,  /* 104 - 111 */\n+     56,  64,  57,  69,  58,  78,  59,  68,  /* 112 - 119 */\n+     60,  61,  61,  80,  62,  75,  63,  68,  /* 120 - 127 */\n+     64,  65,  65, 128,  66, 129,  67,  90,  /* 128 - 135 */\n+     68,  73,  69, 131,  70,  94,  71,  88,  /* 136 - 143 */\n+     72, 128,  73,  98,  74, 132,  75, 121,  /* 144 - 151 */\n+     76, 102,  77, 124,  78, 132,  79, 106,  /* 152 - 159 */\n+     80,  97,  81, 160,  82,  99,  83, 134,  /* 160 - 167 */\n+     84,  86,  85,  95,  86, 160,  87, 100,  /* 168 - 175 */\n+     88, 113,  89,  98,  90, 107,  91, 122,  /* 176 - 183 */\n+     92, 111,  93, 102,  94, 126,  95, 150,  /* 184 - 191 */\n+     96, 128,  97, 130,  98, 133,  99, 195,  /* 192 - 199 */\n+    100, 128, 101, 123, 102, 164, 103, 138,  /* 200 - 207 */\n+    104, 145, 105, 146, 106, 109, 107, 149,  /* 208 - 215 */\n+    108, 200, 109, 146, 110, 170, 111, 157,  /* 216 - 223 */\n+    112, 128, 113, 130, 114, 182, 115, 132,  /* 224 - 231 */\n+    116, 200, 117, 132, 118, 158, 119, 206,  /* 232 - 239 */\n+    120, 240, 121, 162, 122, 147, 123, 152,  /* 240 - 247 */\n+    124, 166, 125, 214, 126, 138, 127, 153,  /* 248 - 255 */\n+  };\n+\n+\n+/* Return the number of multiplications required to calculate\n+   powi(x,n) where n is less than POWI_TABLE_SIZE.  This is a\n+   subroutine of powi_cost.  CACHE is an array indicating\n+   which exponents have already been calculated.  */\n+\n+static int\n+powi_lookup_cost (unsigned HOST_WIDE_INT n, bool *cache)\n+{\n+  /* If we've already calculated this exponent, then this evaluation\n+     doesn't require any additional multiplications.  */\n+  if (cache[n])\n+    return 0;\n+\n+  cache[n] = true;\n+  return powi_lookup_cost (n - powi_table[n], cache)\n+\t + powi_lookup_cost (powi_table[n], cache) + 1;\n+}\n+\n+/* Return the number of multiplications required to calculate\n+   powi(x,n) for an arbitrary x, given the exponent N.  This\n+   function needs to be kept in sync with expand_powi below.  */\n+\n+static int\n+powi_cost (HOST_WIDE_INT n)\n+{\n+  bool cache[POWI_TABLE_SIZE];\n+  unsigned HOST_WIDE_INT digit;\n+  unsigned HOST_WIDE_INT val;\n+  int result;\n+\n+  if (n == 0)\n+    return 0;\n+\n+  /* Ignore the reciprocal when calculating the cost.  */\n+  val = (n < 0) ? -n : n;\n+\n+  /* Initialize the exponent cache.  */\n+  memset (cache, 0, POWI_TABLE_SIZE * sizeof (bool));\n+  cache[1] = true;\n+\n+  result = 0;\n+\n+  while (val >= POWI_TABLE_SIZE)\n+    {\n+      if (val & 1)\n+\t{\n+\t  digit = val & ((1 << POWI_WINDOW_SIZE) - 1);\n+\t  result += powi_lookup_cost (digit, cache)\n+\t\t    + POWI_WINDOW_SIZE + 1;\n+\t  val >>= POWI_WINDOW_SIZE;\n+\t}\n+      else\n+\t{\n+\t  val >>= 1;\n+\t  result++;\n+\t}\n+    }\n+  \n+  return result + powi_lookup_cost (n, cache);\n+}\n+\n+/* Recursive subroutine of expand_powi.  This function takes the array,\n+   CACHE, of already calculated exponents and an exponent N and returns\n+   an RTX that corresponds to CACHE[1]**N, as calculated in mode MODE.  */\n+\n+static rtx\n+expand_powi_1 (enum machine_mode mode, unsigned HOST_WIDE_INT n, rtx *cache)\n+{\n+  unsigned HOST_WIDE_INT digit;\n+  rtx target, result;\n+  rtx op0, op1;\n+\n+  if (n < POWI_TABLE_SIZE)\n+    {\n+      if (cache[n])\n+        return cache[n];\n+\n+      target = gen_reg_rtx (mode);\n+      cache[n] = target;\n+\n+      op0 = expand_powi_1 (mode, n - powi_table[n], cache);\n+      op1 = expand_powi_1 (mode, powi_table[n], cache);\n+    }\n+  else if (n & 1)\n+    {\n+      target = gen_reg_rtx (mode);\n+      digit = n & ((1 << POWI_WINDOW_SIZE) - 1);\n+      op0 = expand_powi_1 (mode, n - digit, cache);\n+      op1 = expand_powi_1 (mode, digit, cache);\n+    }\n+  else\n+    {\n+      target = gen_reg_rtx (mode);\n+      op0 = expand_powi_1 (mode, n >> 1, cache);\n+      op1 = op0;\n+    }\n+\n+  result = expand_mult (mode, op0, op1, target, 0);\n+  if (result != target)\n+    emit_move_insn (target, result);\n+  return target;\n+}\n+\n+/* Expand the RTL to evaluate powi(x,n) in mode MODE.  X is the\n+   floating point operand in mode MODE, and N is the exponent.  This\n+   function needs to be kept in sync with powi_cost above.  */\n+   \n+static rtx\n+expand_powi (rtx x, enum machine_mode mode, HOST_WIDE_INT n)\n+{\n+  unsigned HOST_WIDE_INT val;\n+  rtx cache[POWI_TABLE_SIZE];\n+  rtx result;\n+\n+  if (n == 0)\n+    return CONST1_RTX (mode);\n+\n+  val = (n < 0) ? -n : n;\n+\n+  memset (cache, 0, sizeof(cache));\n+  cache[1] = x;\n+\n+  result = expand_powi_1 (mode, (n < 0) ? -n : n, cache);\n+\n+  /* If the original exponent was negative, reciprocate the result.  */\n+  if (n < 0)\n+    result = expand_binop (mode, sdiv_optab, CONST1_RTX (mode),\n+\t\t\t   result, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\n+  return result;\n+}\n+\n+/* Expand a call to the pow built-in mathematical function.  Return 0 if\n+   a normal call should be emitted rather than expanding the function\n+   in-line.  EXP is the expression that is a call to the builtin\n+   function; if convenient, the result should be placed in TARGET.  */\n+\n+static rtx\n+expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg0, arg1;\n+\n+  if (! validate_arglist (arglist, REAL_TYPE, REAL_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg0 = TREE_VALUE (arglist);\n+  arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  if (flag_unsafe_math_optimizations\n+      && ! flag_errno_math\n+      && ! optimize_size\n+      && TREE_CODE (arg1) == REAL_CST\n+      && ! TREE_CONSTANT_OVERFLOW (arg1))\n+    {\n+      REAL_VALUE_TYPE cint;\n+      REAL_VALUE_TYPE c;\n+      HOST_WIDE_INT n;\n+\n+      c = TREE_REAL_CST (arg1);\n+      n = real_to_integer (&c);\n+      real_from_integer (&cint, VOIDmode, n, n < 0 ? -1 : 0, 0);\n+      if (real_identical (&c, &cint)\n+\t  && powi_cost (n) <= POWI_MAX_MULTS)\n+\t{\n+          enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n+          rtx op = expand_expr (arg0, subtarget, VOIDmode, 0);\n+          op = force_reg (mode, op);\n+          return expand_powi (op, mode, n);\n+\t}\n+    }\n+  return expand_builtin_mathfn_2 (exp, target, NULL_RTX);\n+}\n+\n /* Expand expression EXP which is a call to the strlen builtin.  Return 0\n    if we failed the caller should emit a normal call, otherwise\n    try to get the result in TARGET, if convenient.  */\n@@ -4588,6 +4835,13 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_POW:\n     case BUILT_IN_POWF:\n     case BUILT_IN_POWL:\n+      if (! flag_unsafe_math_optimizations)\n+\tbreak;\n+      target = expand_builtin_pow (exp, target, subtarget);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_ATAN2:\n     case BUILT_IN_ATAN2F:\n     case BUILT_IN_ATAN2L:"}, {"sha": "d5d112ccb281ec585c5b8f00950bee77efa79b3f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2082e02f4146963ac678935af25c65430210f350/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2082e02f4146963ac678935af25c65430210f350/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=2082e02f4146963ac678935af25c65430210f350", "patch": "@@ -9155,3 +9155,14 @@ true when @var{after_prologue_epilogue_gen} is false, you still are likely\n to have to make special provisions in @code{INITIAL_ELIMINATION_OFFSET}\n to reserve space for caller-saved target registers.\n @end deftypefn\n+\n+@defmac POWI_MAX_MULTS\n+If defined, this macro is interpreted as a signed integer C expression \n+that specifies the maximum number of floating point multiplications\n+that should be emitted when expanding exponentiation by an integer\n+constant inline.  When this value is defined, exponentiation requiring\n+more than this number of multiplications is implemented by calling the\n+system library's @code{pow}, @code{powf} or @code{powl} routines.\n+The default value places no upper bound on the multiplication count.\n+@end defmac\n+"}, {"sha": "5b58274d0d160a63acfe2465b4eb52b7e8f6894d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2082e02f4146963ac678935af25c65430210f350/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2082e02f4146963ac678935af25c65430210f350/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2082e02f4146963ac678935af25c65430210f350", "patch": "@@ -1,3 +1,7 @@\n+2003-06-23  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/builtins-24.c: New test case.\n+\n 2003-06-23  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/opt/operator1.C: New test."}, {"sha": "41ec1889f5fa406bfdce8d160dd71c77cad8591c", "filename": "gcc/testsuite/gcc.dg/builtins-24.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2082e02f4146963ac678935af25c65430210f350/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2082e02f4146963ac678935af25c65430210f350/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-24.c?ref=2082e02f4146963ac678935af25c65430210f350", "patch": "@@ -0,0 +1,35 @@\n+/* Copyright (C) 2003 Free Software Foundation.\n+\n+   Check that the RTL expansion of floating point exponentiation by\n+   a constant integer doesn't break anything and produces the expected\n+   results.\n+\n+   Written by Roger Sayle, 20th June 2003.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+extern double pow(double,double);\n+extern void abort(void);\n+\n+double foo (double x)\n+{\n+  return pow (x, 6);\n+}\n+\n+double bar (double x)\n+{\n+  return pow (x, -4);\n+}\n+\n+int main()\n+{\n+  if (foo (2.0) != 64.0)\n+    abort ();\n+\n+  if (bar (2.0) != 0.0625)\n+    abort ();\n+\n+  return 0;\n+}\n+"}]}