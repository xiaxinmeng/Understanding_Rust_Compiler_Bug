{"sha": "3f8334a56feab6b165fb642ba5260510660e2e5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y4MzM0YTU2ZmVhYjZiMTY1ZmI2NDJiYTUyNjA1MTA2NjBlMmU1Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T20:40:04Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T20:40:04Z"}, "message": "[AArch64] Generate permute patterns using rtx builders\n\nThis patch replaces switch statements that call specific generator\nfunctions with code that constructs the rtl pattern directly.\nThis seemed to scale better to SVE and also seems less error-prone.\n\nAs a side-effect, the patch fixes the REV handling for diff==1,\nvmode==E_V4HFmode and adds missing support for diff==3,\nvmode==E_V4HFmode.\n\nTo compensate for the lack of switches that check for specific modes,\nthe patch makes aarch64_expand_vec_perm_const_1 reject permutes on\nsingle-element vectors (specifically V1DImode).\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_evpc_trn, aarch64_evpc_uzp)\n\t(aarch64_evpc_zip, aarch64_evpc_ext, aarch64_evpc_rev)\n\t(aarch64_evpc_dup): Generate rtl direcly, rather than using\n\tnamed expanders.\n\t(aarch64_expand_vec_perm_const_1): Explicitly check for permutes\n\tof a single element.\n\t* config/aarch64/iterators.md: Add a comment above the permute\n\tunspecs to say that they are generated directly by\n\taarch64_expand_vec_perm_const.\n\t* config/aarch64/aarch64-simd.md: Likewise the permute instructions.\n\nReviewed-by: James Greenhalgh <james.greenhalgh@arm.com>\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254324", "tree": {"sha": "fc034f2531812c72a463efa1c043ab74401fead0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc034f2531812c72a463efa1c043ab74401fead0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f8334a56feab6b165fb642ba5260510660e2e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f8334a56feab6b165fb642ba5260510660e2e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f8334a56feab6b165fb642ba5260510660e2e5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f8334a56feab6b165fb642ba5260510660e2e5f/comments", "author": null, "committer": null, "parents": [{"sha": "c6108cbd510e2d60cf53d1eb8a5bf24a12fcf441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6108cbd510e2d60cf53d1eb8a5bf24a12fcf441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6108cbd510e2d60cf53d1eb8a5bf24a12fcf441"}], "stats": {"total": 274, "additions": 57, "deletions": 217}, "files": [{"sha": "dcf18607805898fd5521f445028276fdf063ba4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f8334a56feab6b165fb642ba5260510660e2e5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f8334a56feab6b165fb642ba5260510660e2e5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f8334a56feab6b165fb642ba5260510660e2e5f", "patch": "@@ -1,3 +1,18 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_evpc_trn, aarch64_evpc_uzp)\n+\t(aarch64_evpc_zip, aarch64_evpc_ext, aarch64_evpc_rev)\n+\t(aarch64_evpc_dup): Generate rtl direcly, rather than using\n+\tnamed expanders.\n+\t(aarch64_expand_vec_perm_const_1): Explicitly check for permutes\n+\tof a single element.\n+\t* config/aarch64/iterators.md: Add a comment above the permute\n+\tunspecs to say that they are generated directly by\n+\taarch64_expand_vec_perm_const.\n+\t* config/aarch64/aarch64-simd.md: Likewise the permute instructions.\n+\n 2017-11-01  Nathan Sidwell  <nathan@acm.org>\n \n \t* tree-dump.c (dequeue_and_dump): Use HAS_DECL_ASSEMBLER_NAME_P."}, {"sha": "a3600b3d64738c7459b6eb91820082b902097ee6", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f8334a56feab6b165fb642ba5260510660e2e5f/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f8334a56feab6b165fb642ba5260510660e2e5f/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=3f8334a56feab6b165fb642ba5260510660e2e5f", "patch": "@@ -5369,6 +5369,9 @@\n [(set_attr \"type\" \"multiple\")]\n )\n \n+;; This instruction's pattern is generated directly by\n+;; aarch64_expand_vec_perm_const, so any changes to the pattern would\n+;; need corresponding changes there.\n (define_insn \"aarch64_<PERMUTE:perm_insn><PERMUTE:perm_hilo><mode>\"\n   [(set (match_operand:VALL_F16 0 \"register_operand\" \"=w\")\n \t(unspec:VALL_F16 [(match_operand:VALL_F16 1 \"register_operand\" \"w\")\n@@ -5379,7 +5382,10 @@\n   [(set_attr \"type\" \"neon_permute<q>\")]\n )\n \n-;; Note immediate (third) operand is lane index not byte index.\n+;; This instruction's pattern is generated directly by\n+;; aarch64_expand_vec_perm_const, so any changes to the pattern would\n+;; need corresponding changes there.  Note that the immediate (third)\n+;; operand is a lane index not a byte index.\n (define_insn \"aarch64_ext<mode>\"\n   [(set (match_operand:VALL_F16 0 \"register_operand\" \"=w\")\n         (unspec:VALL_F16 [(match_operand:VALL_F16 1 \"register_operand\" \"w\")\n@@ -5395,6 +5401,9 @@\n   [(set_attr \"type\" \"neon_ext<q>\")]\n )\n \n+;; This instruction's pattern is generated directly by\n+;; aarch64_expand_vec_perm_const, so any changes to the pattern would\n+;; need corresponding changes there.\n (define_insn \"aarch64_rev<REVERSE:rev_op><mode>\"\n   [(set (match_operand:VALL_F16 0 \"register_operand\" \"=w\")\n \t(unspec:VALL_F16 [(match_operand:VALL_F16 1 \"register_operand\" \"w\")]"}, {"sha": "69425b7a95ca2199a2de5f47b9261169a7e6397d", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 26, "deletions": 215, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f8334a56feab6b165fb642ba5260510660e2e5f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f8334a56feab6b165fb642ba5260510660e2e5f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=3f8334a56feab6b165fb642ba5260510660e2e5f", "patch": "@@ -13263,7 +13263,6 @@ aarch64_evpc_trn (struct expand_vec_perm_d *d)\n {\n   unsigned int i, odd, mask, nelt = d->perm.length ();\n   rtx out, in0, in1, x;\n-  rtx (*gen) (rtx, rtx, rtx);\n   machine_mode vmode = d->vmode;\n \n   if (GET_MODE_UNIT_SIZE (vmode) > 8)\n@@ -13300,48 +13299,8 @@ aarch64_evpc_trn (struct expand_vec_perm_d *d)\n     }\n   out = d->target;\n \n-  if (odd)\n-    {\n-      switch (vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_aarch64_trn2v16qi; break;\n-\tcase E_V8QImode: gen = gen_aarch64_trn2v8qi; break;\n-\tcase E_V8HImode: gen = gen_aarch64_trn2v8hi; break;\n-\tcase E_V4HImode: gen = gen_aarch64_trn2v4hi; break;\n-\tcase E_V4SImode: gen = gen_aarch64_trn2v4si; break;\n-\tcase E_V2SImode: gen = gen_aarch64_trn2v2si; break;\n-\tcase E_V2DImode: gen = gen_aarch64_trn2v2di; break;\n-\tcase E_V4HFmode: gen = gen_aarch64_trn2v4hf; break;\n-\tcase E_V8HFmode: gen = gen_aarch64_trn2v8hf; break;\n-\tcase E_V4SFmode: gen = gen_aarch64_trn2v4sf; break;\n-\tcase E_V2SFmode: gen = gen_aarch64_trn2v2sf; break;\n-\tcase E_V2DFmode: gen = gen_aarch64_trn2v2df; break;\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-  else\n-    {\n-      switch (vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_aarch64_trn1v16qi; break;\n-\tcase E_V8QImode: gen = gen_aarch64_trn1v8qi; break;\n-\tcase E_V8HImode: gen = gen_aarch64_trn1v8hi; break;\n-\tcase E_V4HImode: gen = gen_aarch64_trn1v4hi; break;\n-\tcase E_V4SImode: gen = gen_aarch64_trn1v4si; break;\n-\tcase E_V2SImode: gen = gen_aarch64_trn1v2si; break;\n-\tcase E_V2DImode: gen = gen_aarch64_trn1v2di; break;\n-\tcase E_V4HFmode: gen = gen_aarch64_trn1v4hf; break;\n-\tcase E_V8HFmode: gen = gen_aarch64_trn1v8hf; break;\n-\tcase E_V4SFmode: gen = gen_aarch64_trn1v4sf; break;\n-\tcase E_V2SFmode: gen = gen_aarch64_trn1v2sf; break;\n-\tcase E_V2DFmode: gen = gen_aarch64_trn1v2df; break;\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-\n-  emit_insn (gen (out, in0, in1));\n+  emit_set_insn (out, gen_rtx_UNSPEC (vmode, gen_rtvec (2, in0, in1),\n+\t\t\t\t      odd ? UNSPEC_TRN2 : UNSPEC_TRN1));\n   return true;\n }\n \n@@ -13351,7 +13310,6 @@ aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n {\n   unsigned int i, odd, mask, nelt = d->perm.length ();\n   rtx out, in0, in1, x;\n-  rtx (*gen) (rtx, rtx, rtx);\n   machine_mode vmode = d->vmode;\n \n   if (GET_MODE_UNIT_SIZE (vmode) > 8)\n@@ -13387,48 +13345,8 @@ aarch64_evpc_uzp (struct expand_vec_perm_d *d)\n     }\n   out = d->target;\n \n-  if (odd)\n-    {\n-      switch (vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_aarch64_uzp2v16qi; break;\n-\tcase E_V8QImode: gen = gen_aarch64_uzp2v8qi; break;\n-\tcase E_V8HImode: gen = gen_aarch64_uzp2v8hi; break;\n-\tcase E_V4HImode: gen = gen_aarch64_uzp2v4hi; break;\n-\tcase E_V4SImode: gen = gen_aarch64_uzp2v4si; break;\n-\tcase E_V2SImode: gen = gen_aarch64_uzp2v2si; break;\n-\tcase E_V2DImode: gen = gen_aarch64_uzp2v2di; break;\n-\tcase E_V4HFmode: gen = gen_aarch64_uzp2v4hf; break;\n-\tcase E_V8HFmode: gen = gen_aarch64_uzp2v8hf; break;\n-\tcase E_V4SFmode: gen = gen_aarch64_uzp2v4sf; break;\n-\tcase E_V2SFmode: gen = gen_aarch64_uzp2v2sf; break;\n-\tcase E_V2DFmode: gen = gen_aarch64_uzp2v2df; break;\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-  else\n-    {\n-      switch (vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_aarch64_uzp1v16qi; break;\n-\tcase E_V8QImode: gen = gen_aarch64_uzp1v8qi; break;\n-\tcase E_V8HImode: gen = gen_aarch64_uzp1v8hi; break;\n-\tcase E_V4HImode: gen = gen_aarch64_uzp1v4hi; break;\n-\tcase E_V4SImode: gen = gen_aarch64_uzp1v4si; break;\n-\tcase E_V2SImode: gen = gen_aarch64_uzp1v2si; break;\n-\tcase E_V2DImode: gen = gen_aarch64_uzp1v2di; break;\n-\tcase E_V4HFmode: gen = gen_aarch64_uzp1v4hf; break;\n-\tcase E_V8HFmode: gen = gen_aarch64_uzp1v8hf; break;\n-\tcase E_V4SFmode: gen = gen_aarch64_uzp1v4sf; break;\n-\tcase E_V2SFmode: gen = gen_aarch64_uzp1v2sf; break;\n-\tcase E_V2DFmode: gen = gen_aarch64_uzp1v2df; break;\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-\n-  emit_insn (gen (out, in0, in1));\n+  emit_set_insn (out, gen_rtx_UNSPEC (vmode, gen_rtvec (2, in0, in1),\n+\t\t\t\t      odd ? UNSPEC_UZP2 : UNSPEC_UZP1));\n   return true;\n }\n \n@@ -13438,7 +13356,6 @@ aarch64_evpc_zip (struct expand_vec_perm_d *d)\n {\n   unsigned int i, high, mask, nelt = d->perm.length ();\n   rtx out, in0, in1, x;\n-  rtx (*gen) (rtx, rtx, rtx);\n   machine_mode vmode = d->vmode;\n \n   if (GET_MODE_UNIT_SIZE (vmode) > 8)\n@@ -13479,48 +13396,8 @@ aarch64_evpc_zip (struct expand_vec_perm_d *d)\n     }\n   out = d->target;\n \n-  if (high)\n-    {\n-      switch (vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_aarch64_zip2v16qi; break;\n-\tcase E_V8QImode: gen = gen_aarch64_zip2v8qi; break;\n-\tcase E_V8HImode: gen = gen_aarch64_zip2v8hi; break;\n-\tcase E_V4HImode: gen = gen_aarch64_zip2v4hi; break;\n-\tcase E_V4SImode: gen = gen_aarch64_zip2v4si; break;\n-\tcase E_V2SImode: gen = gen_aarch64_zip2v2si; break;\n-\tcase E_V2DImode: gen = gen_aarch64_zip2v2di; break;\n-\tcase E_V4HFmode: gen = gen_aarch64_zip2v4hf; break;\n-\tcase E_V8HFmode: gen = gen_aarch64_zip2v8hf; break;\n-\tcase E_V4SFmode: gen = gen_aarch64_zip2v4sf; break;\n-\tcase E_V2SFmode: gen = gen_aarch64_zip2v2sf; break;\n-\tcase E_V2DFmode: gen = gen_aarch64_zip2v2df; break;\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-  else\n-    {\n-      switch (vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_aarch64_zip1v16qi; break;\n-\tcase E_V8QImode: gen = gen_aarch64_zip1v8qi; break;\n-\tcase E_V8HImode: gen = gen_aarch64_zip1v8hi; break;\n-\tcase E_V4HImode: gen = gen_aarch64_zip1v4hi; break;\n-\tcase E_V4SImode: gen = gen_aarch64_zip1v4si; break;\n-\tcase E_V2SImode: gen = gen_aarch64_zip1v2si; break;\n-\tcase E_V2DImode: gen = gen_aarch64_zip1v2di; break;\n-\tcase E_V4HFmode: gen = gen_aarch64_zip1v4hf; break;\n-\tcase E_V8HFmode: gen = gen_aarch64_zip1v8hf; break;\n-\tcase E_V4SFmode: gen = gen_aarch64_zip1v4sf; break;\n-\tcase E_V2SFmode: gen = gen_aarch64_zip1v2sf; break;\n-\tcase E_V2DFmode: gen = gen_aarch64_zip1v2df; break;\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-\n-  emit_insn (gen (out, in0, in1));\n+  emit_set_insn (out, gen_rtx_UNSPEC (vmode, gen_rtvec (2, in0, in1),\n+\t\t\t\t      high ? UNSPEC_ZIP2 : UNSPEC_ZIP1));\n   return true;\n }\n \n@@ -13530,7 +13407,6 @@ static bool\n aarch64_evpc_ext (struct expand_vec_perm_d *d)\n {\n   unsigned int i, nelt = d->perm.length ();\n-  rtx (*gen) (rtx, rtx, rtx, rtx);\n   rtx offset;\n \n   unsigned int location = d->perm[0]; /* Always < nelt.  */\n@@ -13548,24 +13424,6 @@ aarch64_evpc_ext (struct expand_vec_perm_d *d)\n         return false;\n     }\n \n-  switch (d->vmode)\n-    {\n-    case E_V16QImode: gen = gen_aarch64_extv16qi; break;\n-    case E_V8QImode: gen = gen_aarch64_extv8qi; break;\n-    case E_V4HImode: gen = gen_aarch64_extv4hi; break;\n-    case E_V8HImode: gen = gen_aarch64_extv8hi; break;\n-    case E_V2SImode: gen = gen_aarch64_extv2si; break;\n-    case E_V4SImode: gen = gen_aarch64_extv4si; break;\n-    case E_V4HFmode: gen = gen_aarch64_extv4hf; break;\n-    case E_V8HFmode: gen = gen_aarch64_extv8hf; break;\n-    case E_V2SFmode: gen = gen_aarch64_extv2sf; break;\n-    case E_V4SFmode: gen = gen_aarch64_extv4sf; break;\n-    case E_V2DImode: gen = gen_aarch64_extv2di; break;\n-    case E_V2DFmode: gen = gen_aarch64_extv2df; break;\n-    default:\n-      return false;\n-    }\n-\n   /* Success! */\n   if (d->testing_p)\n     return true;\n@@ -13584,7 +13442,10 @@ aarch64_evpc_ext (struct expand_vec_perm_d *d)\n     }\n \n   offset = GEN_INT (location);\n-  emit_insn (gen (d->target, d->op0, d->op1, offset));\n+  emit_set_insn (d->target,\n+\t\t gen_rtx_UNSPEC (d->vmode,\n+\t\t\t\t gen_rtvec (3, d->op0, d->op1, offset),\n+\t\t\t\t UNSPEC_EXT));\n   return true;\n }\n \n@@ -13593,55 +13454,21 @@ aarch64_evpc_ext (struct expand_vec_perm_d *d)\n static bool\n aarch64_evpc_rev (struct expand_vec_perm_d *d)\n {\n-  unsigned int i, j, diff, nelt = d->perm.length ();\n-  rtx (*gen) (rtx, rtx);\n+  unsigned int i, j, diff, size, unspec, nelt = d->perm.length ();\n \n   if (!d->one_vector_p)\n     return false;\n \n   diff = d->perm[0];\n-  switch (diff)\n-    {\n-    case 7:\n-      switch (d->vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_aarch64_rev64v16qi; break;\n-\tcase E_V8QImode: gen = gen_aarch64_rev64v8qi;  break;\n-\tdefault:\n-\t  return false;\n-\t}\n-      break;\n-    case 3:\n-      switch (d->vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_aarch64_rev32v16qi; break;\n-\tcase E_V8QImode: gen = gen_aarch64_rev32v8qi;  break;\n-\tcase E_V8HImode: gen = gen_aarch64_rev64v8hi;  break;\n-\tcase E_V4HImode: gen = gen_aarch64_rev64v4hi;  break;\n-\tdefault:\n-\t  return false;\n-\t}\n-      break;\n-    case 1:\n-      switch (d->vmode)\n-\t{\n-\tcase E_V16QImode: gen = gen_aarch64_rev16v16qi; break;\n-\tcase E_V8QImode: gen = gen_aarch64_rev16v8qi;  break;\n-\tcase E_V8HImode: gen = gen_aarch64_rev32v8hi;  break;\n-\tcase E_V4HImode: gen = gen_aarch64_rev32v4hi;  break;\n-\tcase E_V4SImode: gen = gen_aarch64_rev64v4si;  break;\n-\tcase E_V2SImode: gen = gen_aarch64_rev64v2si;  break;\n-\tcase E_V4SFmode: gen = gen_aarch64_rev64v4sf;  break;\n-\tcase E_V2SFmode: gen = gen_aarch64_rev64v2sf;  break;\n-\tcase E_V8HFmode: gen = gen_aarch64_rev64v8hf;  break;\n-\tcase E_V4HFmode: gen = gen_aarch64_rev64v4hf;  break;\n-\tdefault:\n-\t  return false;\n-\t}\n-      break;\n-    default:\n-      return false;\n-    }\n+  size = (diff + 1) * GET_MODE_UNIT_SIZE (d->vmode);\n+  if (size == 8)\n+    unspec = UNSPEC_REV64;\n+  else if (size == 4)\n+    unspec = UNSPEC_REV32;\n+  else if (size == 2)\n+    unspec = UNSPEC_REV16;\n+  else\n+    return false;\n \n   for (i = 0; i < nelt ; i += diff + 1)\n     for (j = 0; j <= diff; j += 1)\n@@ -13660,14 +13487,14 @@ aarch64_evpc_rev (struct expand_vec_perm_d *d)\n   if (d->testing_p)\n     return true;\n \n-  emit_insn (gen (d->target, d->op0));\n+  emit_set_insn (d->target, gen_rtx_UNSPEC (d->vmode, gen_rtvec (1, d->op0),\n+\t\t\t\t\t    unspec));\n   return true;\n }\n \n static bool\n aarch64_evpc_dup (struct expand_vec_perm_d *d)\n {\n-  rtx (*gen) (rtx, rtx, rtx);\n   rtx out = d->target;\n   rtx in0;\n   machine_mode vmode = d->vmode;\n@@ -13689,25 +13516,9 @@ aarch64_evpc_dup (struct expand_vec_perm_d *d)\n   in0 = d->op0;\n   lane = GEN_INT (elt); /* The pattern corrects for big-endian.  */\n \n-  switch (vmode)\n-    {\n-    case E_V16QImode: gen = gen_aarch64_dup_lanev16qi; break;\n-    case E_V8QImode: gen = gen_aarch64_dup_lanev8qi; break;\n-    case E_V8HImode: gen = gen_aarch64_dup_lanev8hi; break;\n-    case E_V4HImode: gen = gen_aarch64_dup_lanev4hi; break;\n-    case E_V4SImode: gen = gen_aarch64_dup_lanev4si; break;\n-    case E_V2SImode: gen = gen_aarch64_dup_lanev2si; break;\n-    case E_V2DImode: gen = gen_aarch64_dup_lanev2di; break;\n-    case E_V8HFmode: gen = gen_aarch64_dup_lanev8hf; break;\n-    case E_V4HFmode: gen = gen_aarch64_dup_lanev4hf; break;\n-    case E_V4SFmode: gen = gen_aarch64_dup_lanev4sf; break;\n-    case E_V2SFmode: gen = gen_aarch64_dup_lanev2sf; break;\n-    case E_V2DFmode: gen = gen_aarch64_dup_lanev2df; break;\n-    default:\n-      return false;\n-    }\n-\n-  emit_insn (gen (out, in0, lane));\n+  rtx parallel = gen_rtx_PARALLEL (vmode, gen_rtvec (1, lane));\n+  rtx select = gen_rtx_VEC_SELECT (GET_MODE_INNER (vmode), in0, parallel);\n+  emit_set_insn (out, gen_rtx_VEC_DUPLICATE (vmode, select));\n   return true;\n }\n \n@@ -13760,7 +13571,7 @@ aarch64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n       std::swap (d->op0, d->op1);\n     }\n \n-  if (TARGET_SIMD)\n+  if (TARGET_SIMD && nelt > 1)\n     {\n       if (aarch64_evpc_rev (d))\n \treturn true;"}, {"sha": "46aa6fde6b6f32b572476ca9206ba742486c068d", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f8334a56feab6b165fb642ba5260510660e2e5f/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f8334a56feab6b165fb642ba5260510660e2e5f/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=3f8334a56feab6b165fb642ba5260510660e2e5f", "patch": "@@ -322,16 +322,21 @@\n     UNSPEC_TBL\t\t; Used in vector permute patterns.\n     UNSPEC_TBX\t\t; Used in vector permute patterns.\n     UNSPEC_CONCAT\t; Used in vector permute patterns.\n+\n+    ;; The following permute unspecs are generated directly by\n+    ;; aarch64_expand_vec_perm_const, so any changes to the underlying\n+    ;; instructions would need a corresponding change there.\n     UNSPEC_ZIP1\t\t; Used in vector permute patterns.\n     UNSPEC_ZIP2\t\t; Used in vector permute patterns.\n     UNSPEC_UZP1\t\t; Used in vector permute patterns.\n     UNSPEC_UZP2\t\t; Used in vector permute patterns.\n     UNSPEC_TRN1\t\t; Used in vector permute patterns.\n     UNSPEC_TRN2\t\t; Used in vector permute patterns.\n-    UNSPEC_EXT\t\t; Used in aarch64-simd.md.\n+    UNSPEC_EXT\t\t; Used in vector permute patterns.\n     UNSPEC_REV64\t; Used in vector reverse patterns (permute).\n     UNSPEC_REV32\t; Used in vector reverse patterns (permute).\n     UNSPEC_REV16\t; Used in vector reverse patterns (permute).\n+\n     UNSPEC_AESE\t\t; Used in aarch64-simd.md.\n     UNSPEC_AESD         ; Used in aarch64-simd.md.\n     UNSPEC_AESMC        ; Used in aarch64-simd.md."}]}