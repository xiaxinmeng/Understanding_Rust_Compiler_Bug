{"sha": "049746c29128f9db517609685aab00f030374f8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ5NzQ2YzI5MTI4ZjlkYjUxNzYwOTY4NWFhYjAwZjAzMDM3NGY4ZQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2002-05-29T16:13:24Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2002-05-29T16:13:24Z"}, "message": "re PR target/6838 (cris-elf ICE (gcc 3.1))\n\n\tPR target/6838\n\t* config/cris/cris.md: Fix typos and thinkos in comments.\n\t(\"*mov_sideqi_biap_mem\"): Remove '*' in constraint for operand 4,\n\tsecond alternative.\n\t(\"*mov_sidehi_biap_mem\", \"*mov_sidesi_biap_mem\"): Ditto.\n\t(\"*mov_sideqi_mem\"): Similar, but for operand 3.\n\t(\"*mov_sidehi_mem\", \"*mov_sidesi_mem\"): Ditto.\n\t(splitter for mov_sideqi_mem, mov_sidehi_mem, mov_sidesi_mem):\n\tRemove spurious mode specifier on operand 2.\n\nFrom-SVN: r53999", "tree": {"sha": "46288a584db2ce01189d65b5bdfe5fdf82563c22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46288a584db2ce01189d65b5bdfe5fdf82563c22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/049746c29128f9db517609685aab00f030374f8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/049746c29128f9db517609685aab00f030374f8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/049746c29128f9db517609685aab00f030374f8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/049746c29128f9db517609685aab00f030374f8e/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a3bb17d717a43115ae0723afcb79617b8dc907f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a3bb17d717a43115ae0723afcb79617b8dc907f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a3bb17d717a43115ae0723afcb79617b8dc907f"}], "stats": {"total": 77, "additions": 47, "deletions": 30}, "files": [{"sha": "5c6455038e7187d442160032770e301ff14f320b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/049746c29128f9db517609685aab00f030374f8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/049746c29128f9db517609685aab00f030374f8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=049746c29128f9db517609685aab00f030374f8e", "patch": "@@ -1,3 +1,15 @@\n+2002-05-29  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tPR target/6838\n+\t* config/cris/cris.md: Fix typos and thinkos in comments.\n+\t(\"*mov_sideqi_biap_mem\"): Remove '*' in constraint for operand 4,\n+\tsecond alternative.\n+\t(\"*mov_sidehi_biap_mem\", \"*mov_sidesi_biap_mem\"): Ditto.\n+\t(\"*mov_sideqi_mem\"): Similar, but for operand 3.\n+\t(\"*mov_sidehi_mem\", \"*mov_sidesi_mem\"): Ditto.\n+\t(splitter for mov_sideqi_mem, mov_sidehi_mem, mov_sidesi_mem):\n+\tRemove spurious mode specifier on operand 2.\n+\n 2002-05-29  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300-protos.h: Remove the prototype for"}, {"sha": "0a7eb48628ebde0bbd23ad3e3286fa4899bbfedb", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/049746c29128f9db517609685aab00f030374f8e/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/049746c29128f9db517609685aab00f030374f8e/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=049746c29128f9db517609685aab00f030374f8e", "patch": "@@ -1,5 +1,5 @@\n ;; GCC machine description for CRIS cpu cores.\n-;; Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+;; Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n ;; Contributed by Axis Communications.\n \n ;; This file is part of GCC.\n@@ -385,7 +385,7 @@\n      prefer to split up constants early, like this.  The testcase in\n      gcc.c-torture/execute/961213-1.c shows that CSE2 gets confused by the\n      resulting subreg sets when using the construct from mcore (as of FSF\n-     CVS, version -r 1.5), and it believe that the high part (the last one\n+     CVS, version -r 1.5), and it believes that the high part (the last one\n      emitted) is the final value.  This construct from romp seems more\n      robust, especially considering the head comments from\n      emit_no_conflict_block.  */\n@@ -561,17 +561,22 @@\n \f\n ;; Other way around; move to memory.\n \n-;; For all side-effect patterns, it seems to be the case that the\n-;; predicate isn't consulted after combine.  For sake of stability, we\n-;; recognize and split the cases where dangerous register combinations are\n-;; spotted: where a register is set in the side-effect, and used in the\n-;; main insn.  We don't handle the case where the set in the main insn\n-;; overlaps the set in the side-effect; that would be too big a bug to\n-;; paper over.  We handle just the case where the set in the side-effect\n-;; overlaps the input operand of the main insn (i.e. just moves to memory).\n+;; Note that the condition (which for side-effect patterns is usually a\n+;; call to cris_side_effect_mode_ok), isn't consulted for register\n+;; allocation preferences -- constraints is the method for that.  The\n+;; drawback is that we can't exclude register allocation to cause\n+;; \"move.s rw,[rx=ry+rz.S]\" when rw==rx without also excluding rx==ry or\n+;; rx==rz if we use an earlyclobber modifier for the constraint for rx.\n+;; Instead of that, we recognize and split the cases where dangerous\n+;; register combinations are spotted: where a register is set in the\n+;; side-effect, and used in the main insn.  We don't handle the case where\n+;; the set in the main insn overlaps the set in the side-effect; that case\n+;; must be handled in gcc.  We handle just the case where the set in the\n+;; side-effect overlaps the input operand of the main insn (i.e. just\n+;; moves to memory).\n \n ;;\n-;; move.s rx,[ry=rx+rw.S]\n+;; move.s rz,[ry=rx+rw.S]\n ;; FIXME: These could have anonymous mode for operand 3.\n \n ;; QImode\n@@ -582,7 +587,7 @@\n \t\t\t  (match_operand:SI 1 \"const_int_operand\" \"n,n,n\"))\n \t\t (match_operand:SI 2 \"register_operand\" \"r,r,r\")))\n \t(match_operand:QI 3 \"register_operand\" \"r,r,r\"))\n-   (set (match_operand:SI 4 \"register_operand\" \"=*2,!*3,r\")\n+   (set (match_operand:SI 4 \"register_operand\" \"=*2,!3,r\")\n \t(plus:SI (mult:SI (match_dup 0)\n \t\t\t  (match_dup 1))\n \t\t (match_dup 2)))]\n@@ -600,7 +605,7 @@\n \t\t\t  (match_operand:SI 1 \"const_int_operand\" \"n,n,n\"))\n \t\t (match_operand:SI 2 \"register_operand\" \"r,r,r\")))\n \t(match_operand:HI 3 \"register_operand\" \"r,r,r\"))\n-   (set (match_operand:SI 4 \"register_operand\" \"=*2,!*3,r\")\n+   (set (match_operand:SI 4 \"register_operand\" \"=*2,!3,r\")\n \t(plus:SI (mult:SI (match_dup 0)\n \t\t\t  (match_dup 1))\n \t\t (match_dup 2)))]\n@@ -618,7 +623,7 @@\n \t\t\t  (match_operand:SI 1 \"const_int_operand\" \"n,n,n\"))\n \t\t (match_operand:SI 2 \"register_operand\" \"r,r,r\")))\n \t(match_operand:SI 3 \"register_operand\" \"r,r,r\"))\n-   (set (match_operand:SI 4 \"register_operand\" \"=*2,!*3,r\")\n+   (set (match_operand:SI 4 \"register_operand\" \"=*2,!3,r\")\n \t(plus:SI (mult:SI (match_dup 0)\n \t\t\t  (match_dup 1))\n \t\t (match_dup 2)))]\n@@ -628,10 +633,10 @@\n    #\n    move.%s3 %3,[%4=%2+%0%T1]\")\n \n-;; Split for the case above where the predicate isn't honored; only the\n-;; constraint, and we end up with the set in the side-effect gets the same\n-;; register as the input register.  Arguably a GCC bug, but we'll spot it\n-;; rarely enough that we need to catch it ourselves to be safe.\n+;; Split for the case above where we're out of luck with register\n+;; allocation (again, the condition isn't checked for that), and we end up\n+;; with the set in the side-effect getting the same register as the input\n+;; register.\n \n (define_split\n   [(parallel\n@@ -668,7 +673,7 @@\n \t (plus:SI (match_operand:SI 0 \"cris_bdap_operand\" \"%r,r,r,r\")\n \t\t  (match_operand:SI 1 \"cris_bdap_operand\" \"r>Ri,r>Ri,r,>Ri\")))\n \t(match_operand:QI 2 \"register_operand\" \"r,r,r,r\"))\n-   (set (match_operand:SI 3 \"register_operand\" \"=*0,!*2,r,r\")\n+   (set (match_operand:SI 3 \"register_operand\" \"=*0,!2,r,r\")\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 1)))]\n   \"cris_side_effect_mode_ok (PLUS, operands, 3, 0, 1, -1, 2)\"\n@@ -693,7 +698,7 @@\n \t (plus:SI (match_operand:SI 0 \"cris_bdap_operand\" \"%r,r,r,r\")\n \t\t  (match_operand:SI 1 \"cris_bdap_operand\" \"r>Ri,r>Ri,r,>Ri\")))\n \t(match_operand:HI 2 \"register_operand\" \"r,r,r,r\"))\n-   (set (match_operand:SI 3 \"register_operand\" \"=*0,!*2,r,r\")\n+   (set (match_operand:SI 3 \"register_operand\" \"=*0,!2,r,r\")\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 1)))]\n   \"cris_side_effect_mode_ok (PLUS, operands, 3, 0, 1, -1, 2)\"\n@@ -718,7 +723,7 @@\n \t (plus:SI (match_operand:SI 0 \"cris_bdap_operand\" \"%r,r,r,r\")\n \t\t  (match_operand:SI 1 \"cris_bdap_operand\" \"r>Ri,r>Ri,r,>Ri\")))\n \t(match_operand:SI 2 \"register_operand\" \"r,r,r,r\"))\n-   (set (match_operand:SI 3 \"register_operand\" \"=*0,!*2,r,r\")\n+   (set (match_operand:SI 3 \"register_operand\" \"=*0,!2,r,r\")\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 1)))]\n   \"cris_side_effect_mode_ok (PLUS, operands, 3, 0, 1, -1, 2)\"\n@@ -737,15 +742,15 @@\n }\")\n \n ;; Like the biap case, a split where the set in the side-effect gets the\n-;; same register as the input register to the main insn due to gcc not\n-;; always checking the predicate.\n+;; same register as the input register to the main insn, since the\n+;; condition isn't checked at register allocation.\n \n (define_split\n   [(parallel\n     [(set (mem (plus:SI\n \t\t(match_operand:SI 0 \"cris_bdap_operand\" \"\")\n \t\t(match_operand:SI 1 \"cris_bdap_operand\" \"\")))\n-\t  (match_operand:SI 2 \"register_operand\" \"\"))\n+\t  (match_operand 2 \"register_operand\" \"\"))\n      (set (match_operand:SI 3 \"register_operand\" \"\")\n \t  (plus:SI (match_dup 0) (match_dup 1)))])]\n   \"reload_completed && reg_overlap_mentioned_p (operands[3], operands[2])\"\n@@ -4272,7 +4277,7 @@\n    (set (match_dup 5) (match_dup 2))]\n   \"operands[5] = gen_rtx_MEM (GET_MODE (operands[2]), operands[3]);\")\n \n-;; clear.d ry,[rx=rx+rz.S2]\n+;; clear.d [rx=rx+rz.S2]\n \n (define_split\n   [(parallel\n@@ -4292,7 +4297,7 @@\n    (set (mem:SI (match_dup 3)) (const_int 0))]\n   \"\")\n \n-;; clear.w ry,[rx=rx+rz.S2]\n+;; clear.w [rx=rx+rz.S2]\n \n (define_split\n   [(parallel\n@@ -4312,7 +4317,7 @@\n    (set (mem:HI (match_dup 3)) (const_int 0))]\n   \"\")\n \n-;; clear.b ry,[rx=rx+rz.S2]\n+;; clear.b [rx=rx+rz.S2]\n \n (define_split\n   [(parallel\n@@ -4332,7 +4337,7 @@\n    (set (mem:QI (match_dup 3)) (const_int 0))]\n   \"\")\n \n-;; clear.d ry,[rx=rx+i]\n+;; clear.d [rx=rx+i]\n \n (define_split\n   [(parallel\n@@ -4349,7 +4354,7 @@\n    (set (mem:SI (match_dup 2)) (const_int 0))]\n   \"\")\n \n-;; clear.w ry,[rx=rx+i]\n+;; clear.w [rx=rx+i]\n \n (define_split\n   [(parallel\n@@ -4366,7 +4371,7 @@\n    (set (mem:HI (match_dup 2)) (const_int 0))]\n   \"\")\n \n-;; clear.b ry,[rx=rx+i]\n+;; clear.b [rx=rx+i]\n \n (define_split\n   [(parallel"}]}