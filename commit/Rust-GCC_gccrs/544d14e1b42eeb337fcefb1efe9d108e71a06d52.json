{"sha": "544d14e1b42eeb337fcefb1efe9d108e71a06d52", "node_id": "C_kwDOANBUbNoAKDU0NGQxNGUxYjQyZWViMzM3ZmNlZmIxZWZlOWQxMDhlNzFhMDZkNTI", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-09-23T10:18:22Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-10-06T09:22:49Z"}, "message": "ada: Implementation of support for storage models in gigi\n\nIt is based on a new LOAD_EXPR node in GENERIC that is later turned into\na bona-fide temporary during gimplification.\n\ngcc/ada/\n\n\t* gcc-interface/ada-tree.def (LOAD_EXPR): New expression code.\n\t* gcc-interface/gigi.h (build_storage_model_load): Declare.\n\t(build_storage_model_store): Likewise.\n\t(instantiate_load_in_expr): Likewise.\n\t(INSTANTIATE_LOAD_IN_EXPR): New macro.\n\t(instantiate_load_in_array_ref): Declare.\n\t* gcc-interface/decl.cc (gnat_to_gnu_entity) <E_Record_Type>: Set a\n\tfake discriminant number on the fields of the template type.\n\t(gnat_to_gnu_field): Use integer for DECL_DISCRIMINANT_NUMBER.\n\t* gcc-interface/misc.cc (gnat_init_ts): Mark LOAD_EXPR as typed.\n\t* gcc-interface/trans.cc (fold_constant_decl_in_expr) <ARRAY_REF>:\n\tAlso preserve the 4th operand.\n\t(Attribute_to_gnu): Deal with LOAD_EXPR of unconstrained array type.\n\t<Attr_Size>: Call INSTANTIATE_LOAD_IN_EXPR for a storage model.\n\t<Attr_Length>: Likewise.\n\t<Attr_Bit_Position>: Likewise.\n\t(get_storage_model): New function.\n\t(get_storage_model_access): Likewise.\n\t(storage_model_access_required_p): Likewise.\n\t(Call_to_gnu): Add GNAT_STORAGE_MODEL parameter and deal with it.\n\tAlso deal with actual parameters that have a storage model.\n\t(gnat_to_gnu) <N_Object_Declaratio>: Adjust call to Call_to_gnu.\n\t<N_Explicit_Dereference>: Deal with a storage model access.\n\t<N_Indexed_Component>: Likewise.\n\t<N_Slice>: Likewise.\n\t<N_Selected_Component>: Likewise.\n\t<N_Assignment_Statement>: Adjust call to Call_to_gnu.  Deal with a\n\tstorage model access either on the LHS, on the RHS or on both.\n\t<N_Function_Cal>: Adjust call to Call_to_gnu.\n\t<N_Free_Statement>: Deal with a pool that is a storage model.\n\tReplace test for UNCONSTRAINED_ARRAY_REF with test on the type.\n\t(gnat_gimplify_expr) <CALL_EXPR>: Tidy up.\n\t<LOAD_EXPR>: New case.\n\t<UNCONSTRAINED_ARRAY_REF>: Move down.\n\t* gcc-interface/utils.cc (maybe_unconstrained_array): Deal with a\n\tLOAD_EXPR by recursing on its first operand.\n\t* gcc-interface/utils2.cc (build_allocator): Deal with a pool that\n\tis a storage model.\n\t(build_storage_model_copy): New function.\n\t(build_storage_model_load): Likewise.\n\t(build_storage_model_store): Likewise.\n\t(instantiate_load_in_expr): Likewise.\n\t(instantiate_load_in_array_ref): Likewise.\n\t(gnat_rewrite_reference) <ARRAY_REF>: Also preserve the 4th operand.\n\t(get_inner_constant_reference) <ARRAY_REF>: Remove useless test.\n\t(gnat_invariant_expr) <ARRAY_REF>: Rewrite test.", "tree": {"sha": "bd0c716d39a7a07baa17c0edafe236a405387eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd0c716d39a7a07baa17c0edafe236a405387eca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/544d14e1b42eeb337fcefb1efe9d108e71a06d52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544d14e1b42eeb337fcefb1efe9d108e71a06d52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544d14e1b42eeb337fcefb1efe9d108e71a06d52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544d14e1b42eeb337fcefb1efe9d108e71a06d52/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c62d9b7b44b10ff272d11bcc430538ab07ef8f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c62d9b7b44b10ff272d11bcc430538ab07ef8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c62d9b7b44b10ff272d11bcc430538ab07ef8f6"}], "stats": {"total": 666, "additions": 605, "deletions": 61}, "files": [{"sha": "7fc95cb74c58970a54ba88f428ff4cb8c53d4c71", "filename": "gcc/ada/gcc-interface/ada-tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.def?ref=544d14e1b42eeb337fcefb1efe9d108e71a06d52", "patch": "@@ -35,6 +35,10 @@ DEFTREECODE (UNCONSTRAINED_ARRAY_TYPE, \"unconstrained_array_type\", tcc_type, 0)\n DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\",\n \t     tcc_reference, 1)\n \n+/* Same as SAVE_EXPR, but operand 1 contains the statement used to initialize\n+   the temporary instead of using the value of operand 0 directly.  */\n+DEFTREECODE (LOAD_EXPR, \"load_expr\", tcc_expression, 2)\n+\n /* An expression that returns an RTL suitable for its type.  Operand 0\n    is an expression to be evaluated for side effects only.  */\n DEFTREECODE (NULL_EXPR, \"null_expr\", tcc_expression, 1)"}, {"sha": "f8c76982de5a68d6b22483dbe866496e2c1e7bc6", "filename": "gcc/ada/gcc-interface/decl.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.cc?ref=544d14e1b42eeb337fcefb1efe9d108e71a06d52", "patch": "@@ -2279,6 +2279,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t\t      gnu_index_type,\n \t\t\t\t\t      gnu_template_type, NULL_TREE,\n \t\t\t\t\t      NULL_TREE, 0, 0);\n+\t    /* Mark the field specifically for INSTANTIATE_LOAD_IN_EXPR.  */\n+\t    DECL_DISCRIMINANT_NUMBER (gnu_lb_field) = integer_minus_one_node;\n \t    Sloc_to_locus (Sloc (gnat_entity),\n \t\t\t   &DECL_SOURCE_LOCATION (gnu_lb_field));\n \n@@ -2287,6 +2289,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t\t\t      gnu_index_type,\n \t\t\t\t\t      gnu_template_type, NULL_TREE,\n \t\t\t\t\t      NULL_TREE, 0, 0);\n+\t    /* Mark the field specifically for INSTANTIATE_LOAD_IN_EXPR.  */\n+\t    DECL_DISCRIMINANT_NUMBER (gnu_hb_field) = integer_minus_one_node;\n \t    Sloc_to_locus (Sloc (gnat_entity),\n \t\t\t   &DECL_SOURCE_LOCATION (gnu_hb_field));\n \n@@ -7694,7 +7698,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   if (Ekind (gnat_field) == E_Discriminant)\n     {\n       DECL_DISCRIMINANT_NUMBER (gnu_field)\n-\t= UI_To_gnu (Discriminant_Number (gnat_field), sizetype);\n+\t= UI_To_gnu (Discriminant_Number (gnat_field), integer_type_node);\n       DECL_INVARIANT_P (gnu_field)\n \t= No (Discriminant_Default_Value (gnat_field));\n       DECL_NONADDRESSABLE_P (gnu_field) = 0;"}, {"sha": "82e2403a7d69fc2ae958c2e15cb8227f10ee4437", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=544d14e1b42eeb337fcefb1efe9d108e71a06d52", "patch": "@@ -912,6 +912,34 @@ extern tree build_allocator (tree type, tree init, tree result_type,\n                              Entity_Id gnat_proc, Entity_Id gnat_pool,\n                              Node_Id gnat_node, bool);\n \n+/* Build a load of SRC using the storage model of GNAT_SMO.  */\n+extern tree build_storage_model_load (Entity_Id gnat_smo, tree src);\n+\n+/* Build a load of SRC into DEST using the storage model of GNAT_SMO.\n+   If SIZE is specified, use it, otherwise use the size of SRC.  */\n+extern tree build_storage_model_load (Entity_Id gnat_smo, tree dest, tree src,\n+\t\t\t\t      tree size = NULL_TREE);\n+\n+/* Build a store of SRC into DEST using the storage model of GNAT_SMO.\n+   If SIZE is specified, use it, otherwise use the size of DEST.  */\n+extern tree build_storage_model_store (Entity_Id gnat_smo, tree dest, tree src,\n+\t\t\t\t       tree size = NULL_TREE);\n+\n+/* Given a tree EXP, instantiate occurrences of LOAD_EXPR in it and associate\n+   them with the storage model of GNAT_SMO.  */\n+extern tree instantiate_load_in_expr (tree exp, Entity_Id gnat_smo);\n+\n+/* This macro calls the above function but short-circuits the common\n+   case of a constant to save time and also checks for NULL.  */\n+\n+#define INSTANTIATE_LOAD_IN_EXPR(EXP, GNAT_SMO) \\\n+  ((EXP) == NULL_TREE || TREE_CONSTANT (EXP) ? (EXP)\t\\\n+   : instantiate_load_in_expr (EXP, GNAT_SMO))\n+\n+/* Given an array or slice reference, instantiate occurrences of LOAD_EXPR in\n+   it and associate them with the storage model of GNAT_SMO.  */\n+extern void instantiate_load_in_array_ref (tree ref, Entity_Id gnat_smo);\n+\n /* Indicate that we need to take the address of T and that it therefore\n    should not be allocated in a register.  Returns true if successful.  */\n extern bool gnat_mark_addressable (tree t);"}, {"sha": "e1b5a43c4f43215488ecffc3a2981eea6d30e4f9", "filename": "gcc/ada/gcc-interface/misc.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Fmisc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Fmisc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.cc?ref=544d14e1b42eeb337fcefb1efe9d108e71a06d52", "patch": "@@ -1309,6 +1309,7 @@ gnat_init_ts (void)\n   MARK_TS_COMMON (UNCONSTRAINED_ARRAY_TYPE);\n \n   MARK_TS_TYPED (UNCONSTRAINED_ARRAY_REF);\n+  MARK_TS_TYPED (LOAD_EXPR);\n   MARK_TS_TYPED (NULL_EXPR);\n   MARK_TS_TYPED (PLUS_NOMOD_EXPR);\n   MARK_TS_TYPED (MINUS_NOMOD_EXPR);"}, {"sha": "d0ff741585e289a42ea49cfadcf90dd794fce1ad", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 283, "deletions": 43, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=544d14e1b42eeb337fcefb1efe9d108e71a06d52", "patch": "@@ -1033,7 +1033,7 @@ fold_constant_decl_in_expr (tree exp)\n \treturn exp;\n \n       return fold (build4 (code, TREE_TYPE (exp), op0, TREE_OPERAND (exp, 1),\n-\t\t\t   TREE_OPERAND (exp, 2), NULL_TREE));\n+\t\t\t   TREE_OPERAND (exp, 2), TREE_OPERAND (exp, 3)));\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n@@ -1671,6 +1671,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n   tree gnu_type = TREE_TYPE (gnu_prefix);\n   tree gnu_expr, gnu_result_type, gnu_result = error_mark_node;\n   bool prefix_unused = false;\n+  Entity_Id gnat_smo;\n \n   /* If the input is a NULL_EXPR, make a new one.  */\n   if (TREE_CODE (gnu_prefix) == NULL_EXPR)\n@@ -1680,6 +1681,14 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       return build1 (NULL_EXPR, gnu_result_type, TREE_OPERAND (gnu_prefix, 0));\n     }\n \n+  /* If the input is a LOAD_EXPR of an unconstrained array type, the second\n+     operand contains the storage model object.  */\n+  if (TREE_CODE (gnu_prefix) == LOAD_EXPR\n+      && TREE_CODE (gnu_type) == UNCONSTRAINED_ARRAY_TYPE)\n+    gnat_smo = tree_to_shwi (TREE_OPERAND (gnu_prefix, 1));\n+  else\n+    gnat_smo = Empty;\n+\n   switch (attribute)\n     {\n     case Attr_Pred:\n@@ -1960,7 +1969,11 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       /* Deal with a self-referential size by qualifying the size with the\n \t object or returning the maximum size for a type.  */\n       if (TREE_CODE (gnu_prefix) != TYPE_DECL)\n-\tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n+\t{\n+\t  gnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n+\t  if (Present (gnat_smo))\n+\t    gnu_result = INSTANTIATE_LOAD_IN_EXPR (gnu_result, gnat_smo);\n+\t}\n       else if (CONTAINS_PLACEHOLDER_P (gnu_result))\n \tgnu_result = max_size (gnu_result, true);\n \n@@ -2191,6 +2204,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t   handling.  Note that these attributes could not have been used on\n \t   an unconstrained array type.  */\n \tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n+\tif (Present (gnat_smo))\n+\t  gnu_result = INSTANTIATE_LOAD_IN_EXPR (gnu_result, gnat_smo);\n \n \t/* Cache the expression we have just computed.  Since we want to do it\n \t   at run time, we force the use of a SAVE_EXPR and let the gimplifier\n@@ -2351,6 +2366,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t/* If this has a PLACEHOLDER_EXPR, qualify it by the object we are\n \t   handling.  */\n \tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n+\tif (Present (gnat_smo))\n+\t  gnu_result = INSTANTIATE_LOAD_IN_EXPR (gnu_result, gnat_smo);\n \tbreak;\n       }\n \n@@ -4356,6 +4373,49 @@ simple_atomic_access_required_p (Node_Id gnat_node, bool *sync)\n   return type == SIMPLE_ATOMIC;\n }\n \n+/* Return the storage model specified by GNAT_NODE, or else Empty.  */\n+\n+static Entity_Id\n+get_storage_model (Node_Id gnat_node)\n+{\n+  if (Nkind (gnat_node) == N_Explicit_Dereference\n+      && Has_Designated_Storage_Model_Aspect (Etype (Prefix (gnat_node))))\n+    return Storage_Model_Object (Etype (Prefix (gnat_node)));\n+  else\n+    return Empty;\n+}\n+\n+/* Compute whether GNAT_NODE requires storage model access and set GNAT_SMO to\n+   the storage model object to be used for it if it does, or else Empty.  */\n+\n+static void\n+get_storage_model_access (Node_Id gnat_node, Entity_Id *gnat_smo)\n+{\n+  const Node_Id gnat_parent = Parent (gnat_node);\n+\n+  /* If we are the prefix of the parent, then the access is above us.  */\n+  if (node_is_component (gnat_parent) && Prefix (gnat_parent) == gnat_node)\n+    {\n+      *gnat_smo = Empty;\n+      return;\n+    }\n+\n+  while (node_is_component (gnat_node))\n+    gnat_node = Prefix (gnat_node);\n+\n+  *gnat_smo = get_storage_model (gnat_node);\n+}\n+\n+/* Return true if GNAT_NODE requires storage model access and, if so, set\n+   GNAT_SMO to the storage model object to be used for it.  */\n+\n+static bool\n+storage_model_access_required_p (Node_Id gnat_node, Entity_Id *gnat_smo)\n+{\n+  get_storage_model_access (gnat_node, gnat_smo);\n+  return Present (*gnat_smo);\n+}\n+\n /* Create a temporary variable with PREFIX and TYPE, and return it.  */\n \n static tree\n@@ -4471,11 +4531,14 @@ elaborate_profile (Entity_Id first_formal, Entity_Id result_type)\n    N_Assignment_Statement and the result is to be placed into that object.\n    ATOMIC_ACCESS is the type of atomic access to be used for the assignment\n    to GNU_TARGET.  If, in addition, ATOMIC_SYNC is true, then the assignment\n-   to GNU_TARGET requires atomic synchronization.  */\n+   to GNU_TARGET requires atomic synchronization.  GNAT_STORAGE_MODEL is the\n+   storage model object to be used for the assignment to GNU_TARGET or Empty\n+   if there is none.  */\n \n static tree\n Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n-\t     atomic_acces_t atomic_access, bool atomic_sync)\n+\t     atomic_acces_t atomic_access, bool atomic_sync,\n+\t     Entity_Id gnat_storage_model)\n {\n   const bool function_call = (Nkind (gnat_node) == N_Function_Call);\n   const bool returning_value = (function_call && !gnu_target);\n@@ -4507,6 +4570,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   Node_Id gnat_actual;\n   atomic_acces_t aa_type;\n   bool aa_sync;\n+  Entity_Id gnat_smo;\n \n   /* The only way we can make a call via an access type is if GNAT_NAME is an\n      explicit dereference.  In that case, get the list of formal args from the\n@@ -4624,7 +4688,9 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  unconstrained record type with default discriminant, because the\n \t  return may copy more data than the bit-field can contain.\n \n-       5. There is no target and we have misaligned In Out or Out parameters\n+       5. There is a target which needs to be accessed with a storage model.\n+\n+       6. There is no target and we have misaligned In Out or Out parameters\n \t  passed by reference, because we need to preserve the return value\n \t  before copying back the parameters.  However, in this case, we'll\n \t  defer creating the temporary, see below.\n@@ -4654,7 +4720,10 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      && DECL_BIT_FIELD (TREE_OPERAND (gnu_target, 1))\n \t      && DECL_SIZE (TREE_OPERAND (gnu_target, 1))\n \t\t != TYPE_SIZE (TREE_TYPE (gnu_target))\n-\t      && type_is_padding_self_referential (gnu_result_type))))\n+\t      && type_is_padding_self_referential (gnu_result_type))\n+\t  || (gnu_target\n+\t      && Present (gnat_storage_model)\n+\t      && Present (Storage_Model_Copy_To (gnat_storage_model)))))\n     {\n       gnu_retval = create_temporary (\"R\", gnu_result_type);\n       DECL_RETURN_VALUE_P (gnu_retval) = 1;\n@@ -4725,12 +4794,19 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      = build_compound_expr (TREE_TYPE (gnu_name), init, gnu_name);\n \t}\n \n-      /* If we are passing a non-addressable parameter by reference, pass the\n-\t address of a copy.  In the In Out or Out case, set up to copy back\n-\t out after the call.  */\n+      get_storage_model_access (gnat_actual, &gnat_smo);\n+\n+      /* If we are passing a non-addressable actual parameter by reference,\n+\t pass the address of a copy.  Likewise if it needs to be accessed with\n+\t a storage model.  In the In Out or Out case, set up to copy back out\n+\t after the call.  */\n       if (is_by_ref_formal_parm\n \t  && (gnu_name_type = gnat_to_gnu_type (Etype (gnat_name)))\n-\t  && !addressable_p (gnu_name, gnu_name_type))\n+\t  && (!addressable_p (gnu_name, gnu_name_type)\n+\t      || (Present (gnat_smo)\n+\t\t  && (Present (Storage_Model_Copy_From (gnat_smo))\n+\t\t      || (!in_param\n+\t\t\t  && Present (Storage_Model_Copy_To (gnat_smo)))))))\n \t{\n \t  tree gnu_orig = gnu_name, gnu_temp, gnu_stmt;\n \n@@ -4801,20 +4877,40 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t    }\n \n \t  /* Create an explicit temporary holding the copy.  */\n+\t  tree gnu_temp_type;\n+\t  if (Nkind (gnat_actual) == N_Explicit_Dereference\n+\t      && Present (Actual_Designated_Subtype (gnat_actual)))\n+\t    gnu_temp_type\n+\t      = gnat_to_gnu_type (Actual_Designated_Subtype (gnat_actual));\n+\t  else\n+\t    gnu_temp_type = TREE_TYPE (gnu_name);\n+\n \t  /* Do not initialize it for the _Init parameter of an initialization\n \t     procedure since no data is meant to be passed in.  */\n \t  if (Ekind (gnat_formal) == E_Out_Parameter\n \t      && Is_Entity_Name (gnat_subprog)\n \t      && Is_Init_Proc (Entity (gnat_subprog)))\n-\t    gnu_name = gnu_temp = create_temporary (\"A\", TREE_TYPE (gnu_name));\n+\t    gnu_name = gnu_temp = create_temporary (\"A\", gnu_temp_type);\n \n \t  /* Initialize it on the fly like for an implicit temporary in the\n \t     other cases, as we don't necessarily have a statement list.  */\n \t  else\n \t    {\n-\t      gnu_temp = create_init_temporary (\"A\", gnu_name, &gnu_stmt,\n-\t\t\t\t\t\tgnat_actual);\n-\t      gnu_name = build_compound_expr (TREE_TYPE (gnu_name), gnu_stmt,\n+\t      if (Present (gnat_smo)\n+\t\t  && Present (Storage_Model_Copy_From (gnat_smo)))\n+\t\t{\n+\t\t  gnu_temp = create_temporary (\"A\", gnu_temp_type);\n+\t\t  gnu_stmt\n+\t\t    = build_storage_model_load (gnat_smo, gnu_temp,\n+\t\t\t\t\t\tgnu_name,\n+\t\t\t\t\t\tTYPE_SIZE_UNIT (gnu_temp_type));\n+\t\t  set_expr_location_from_node (gnu_stmt, gnat_actual);\n+\t\t}\n+\t      else\n+\t\tgnu_temp = create_init_temporary (\"A\", gnu_name, &gnu_stmt,\n+\t\t\t\t\t\t  gnat_actual);\n+\n+\t      gnu_name = build_compound_expr (gnu_temp_type, gnu_stmt,\n \t\t\t\t\t      gnu_temp);\n \t    }\n \n@@ -4830,8 +4926,16 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t\t     (TREE_OPERAND (TREE_OPERAND (gnu_orig, 1), 1)))\n \t\tgnu_orig = TREE_OPERAND (gnu_orig, 2);\n \n-\t      gnu_stmt\n-\t\t= build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_orig, gnu_temp);\n+\t      if (Present (gnat_smo)\n+\t\t  && Present (Storage_Model_Copy_To (gnat_smo)))\n+\t\tgnu_stmt\n+\t\t  = build_storage_model_store (gnat_smo, gnu_orig,\n+\t\t\t\t\t       gnu_temp,\n+\t\t\t\t\t       TYPE_SIZE_UNIT (gnu_temp_type));\n+\t      else\n+\t\tgnu_stmt\n+\t\t  = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_orig,\n+\t\t\t\t     gnu_temp);\n \t      set_expr_location_from_node (gnu_stmt, gnat_node);\n \n \t      append_to_statement_list (gnu_stmt, &gnu_after_list);\n@@ -4842,12 +4946,19 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       tree gnu_actual = gnu_name;\n \n       /* If atomic access is required for an In or In Out actual parameter,\n-\t build the atomic load.  */\n+\t build the atomic load.  Or else, if storage model access is required,\n+\t build the special load.  */\n       if (is_true_formal_parm\n \t  && !is_by_ref_formal_parm\n-\t  && Ekind (gnat_formal) != E_Out_Parameter\n-\t  && simple_atomic_access_required_p (gnat_actual, &aa_sync))\n-\tgnu_actual = build_atomic_load (gnu_actual, aa_sync);\n+\t  && Ekind (gnat_formal) != E_Out_Parameter)\n+\t{\n+\t  if (simple_atomic_access_required_p (gnat_actual, &aa_sync))\n+\t    gnu_actual = build_atomic_load (gnu_actual, aa_sync);\n+\n+\t  else if (Present (gnat_smo)\n+\t\t   && Present (Storage_Model_Copy_From (gnat_smo)))\n+\t    gnu_actual = build_storage_model_load (gnat_smo, gnu_actual);\n+\t}\n \n       /* If this was a procedure call, we may not have removed any padding.\n \t So do it here for the part we will use as an input, if any.  */\n@@ -5211,6 +5322,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      }\n \n \t    get_atomic_access (gnat_actual, &aa_type, &aa_sync);\n+\t    get_storage_model_access (gnat_actual, &gnat_smo);\n \n \t    /* If an outer atomic access is required for an actual parameter,\n \t       build the load-modify-store sequence.  */\n@@ -5224,6 +5336,13 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      gnu_result\n \t\t= build_atomic_store (gnu_actual, gnu_result, aa_sync);\n \n+\t    /* Or else, if a storage model access is required, build the special\n+\t       store.  */\n+\t    else if (Present (gnat_smo)\n+\t\t     && Present (Storage_Model_Copy_To (gnat_smo)))\n+\t      gnu_result\n+\t\t= build_storage_model_store (gnat_smo, gnu_actual, gnu_result);\n+\n \t    /* Otherwise build a regular assignment.  */\n \t    else\n \t      gnu_result = build_binary_op (MODIFY_EXPR, NULL_TREE,\n@@ -5298,6 +5417,11 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t      = build_load_modify_store (gnu_target, gnu_call, gnat_node);\n \t  else if (atomic_access == SIMPLE_ATOMIC)\n \t    gnu_call = build_atomic_store (gnu_target, gnu_call, atomic_sync);\n+\t  else if (Present (gnat_storage_model)\n+\t\t   && Present (Storage_Model_Copy_To (gnat_storage_model)))\n+\t    gnu_call\n+\t      = build_storage_model_store (gnat_storage_model, gnu_target,\n+\t\t\t\t\t   gnu_call);\n \t  else\n \t    gnu_call\n \t      = build_binary_op (op_code, NULL_TREE, gnu_target, gnu_call);\n@@ -6104,6 +6228,7 @@ gnat_to_gnu (Node_Id gnat_node)\n   atomic_acces_t aa_type;\n   bool went_into_elab_proc;\n   bool aa_sync;\n+  Entity_Id gnat_smo;\n \n   /* Save node number for error message and set location information.  */\n   if (Sloc (gnat_node) > No_Location)\n@@ -6376,7 +6501,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gnu_result\n \t    = Call_to_gnu (Prefix (Expression (gnat_node)),\n \t\t\t   &gnu_result_type, gnu_result,\n-\t\t\t   NOT_ATOMIC, false);\n+\t\t\t   NOT_ATOMIC, false, Empty);\n \t  break;\n \t}\n \n@@ -6522,15 +6647,25 @@ gnat_to_gnu (Node_Id gnat_node)\n       if (simple_atomic_access_required_p (gnat_node, &aa_sync)\n \t  && !present_in_lhs_or_actual_p (gnat_node))\n \tgnu_result = build_atomic_load (gnu_result, aa_sync);\n+\n+      /* If storage model access is required on the RHS, build the load.  */\n+      else if (storage_model_access_required_p (gnat_node, &gnat_smo)\n+\t       && Present (Storage_Model_Copy_From (gnat_smo))\n+\t       && !present_in_lhs_or_actual_p (gnat_node))\n+\tgnu_result = build_storage_model_load (gnat_smo, gnu_result);\n       break;\n \n     case N_Indexed_Component:\n       {\n-\ttree gnu_array_object = gnat_to_gnu ((Prefix (gnat_node)));\n+\tconst Entity_Id gnat_array_object = Prefix (gnat_node);\n+\ttree gnu_array_object = gnat_to_gnu (gnat_array_object);\n \ttree gnu_type;\n \tint ndim, i;\n \tNode_Id *gnat_expr_array;\n \n+\t/* Get the storage model of the array.  */\n+\tgnat_smo = get_storage_model (gnat_array_object);\n+\n \tgnu_array_object = maybe_padded_object (gnu_array_object);\n \tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n \n@@ -6582,6 +6717,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t    gnu_result\n \t      = build_binary_op (ARRAY_REF, NULL_TREE, gnu_result, gnu_expr);\n+\n+\t    if (Present (gnat_smo))\n+\t      instantiate_load_in_array_ref (gnu_result, gnat_smo);\n \t  }\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n@@ -6590,18 +6728,28 @@ gnat_to_gnu (Node_Id gnat_node)\n \tif (simple_atomic_access_required_p (gnat_node, &aa_sync)\n \t    && !present_in_lhs_or_actual_p (gnat_node))\n \t  gnu_result = build_atomic_load (gnu_result, aa_sync);\n+\n+\t/* If storage model access is required on the RHS, build the load.  */\n+\telse if (storage_model_access_required_p (gnat_node, &gnat_smo)\n+\t\t && Present (Storage_Model_Copy_From (gnat_smo))\n+\t\t && !present_in_lhs_or_actual_p (gnat_node))\n+\t  gnu_result = build_storage_model_load (gnat_smo, gnu_result);\n       }\n       break;\n \n     case N_Slice:\n       {\n-\ttree gnu_array_object = gnat_to_gnu (Prefix (gnat_node));\n+\tconst Entity_Id gnat_array_object = Prefix (gnat_node);\n+\ttree gnu_array_object = gnat_to_gnu (gnat_array_object);\n \n-\tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\t/* Get the storage model of the array.  */\n+\tgnat_smo = get_storage_model (gnat_array_object);\n \n \tgnu_array_object = maybe_padded_object (gnu_array_object);\n \tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n \n+\tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\n \tgnu_expr = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n \tgnu_expr = maybe_character_value (gnu_expr);\n \n@@ -6614,6 +6762,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \tgnu_result = build_binary_op (ARRAY_RANGE_REF, gnu_result_type,\n \t\t\t\t      gnu_array_object, gnu_expr);\n+\n+\tif (Present (gnat_smo))\n+\t  instantiate_load_in_array_ref (gnu_result, gnat_smo);\n+\n+\t/* If storage model access is required on the RHS, build the load.  */\n+\tif (storage_model_access_required_p (gnat_node, &gnat_smo)\n+\t    && Present (Storage_Model_Copy_From (gnat_smo))\n+\t    && !present_in_lhs_or_actual_p (gnat_node))\n+\t  gnu_result = build_storage_model_load (gnat_smo, gnu_result);\n       }\n       break;\n \n@@ -6691,6 +6848,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \tif (simple_atomic_access_required_p (gnat_node, &aa_sync)\n \t    && !present_in_lhs_or_actual_p (gnat_node))\n \t  gnu_result = build_atomic_load (gnu_result, aa_sync);\n+\n+\t/* If storage model access is required on the RHS, build the load.  */\n+\telse if (storage_model_access_required_p (gnat_node, &gnat_smo)\n+\t\t && Present (Storage_Model_Copy_From (gnat_smo))\n+\t\t && !present_in_lhs_or_actual_p (gnat_node))\n+\t  gnu_result = build_storage_model_load (gnat_smo, gnu_result);\n       }\n       break;\n \n@@ -7224,9 +7387,10 @@ gnat_to_gnu (Node_Id gnat_node)\n       else if (Nkind (Expression (gnat_node)) == N_Function_Call)\n \t{\n \t  get_atomic_access (Name (gnat_node), &aa_type, &aa_sync);\n+\t  get_storage_model_access (Name (gnat_node), &gnat_smo);\n \t  gnu_result\n \t    = Call_to_gnu (Expression (gnat_node), &gnu_result_type, gnu_lhs,\n-\t\t\t   aa_type, aa_sync);\n+\t\t\t   aa_type, aa_sync, gnat_smo);\n \t}\n \n       /* Otherwise we need to build the assignment statement manually.  */\n@@ -7264,6 +7428,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  gigi_checking_assert (!Do_Range_Check (gnat_expr));\n \n \t  get_atomic_access (Name (gnat_node), &aa_type, &aa_sync);\n+\t  get_storage_model_access (Name (gnat_node), &gnat_smo);\n \n \t  /* If an outer atomic access is required on the LHS, build the load-\n \t     modify-store sequence.  */\n@@ -7275,6 +7440,43 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  else if (aa_type == SIMPLE_ATOMIC)\n \t    gnu_result = build_atomic_store (gnu_lhs, gnu_rhs, aa_sync);\n \n+\t  /* Or else, if a storage model access is required, build the special\n+\t     store.  */\n+\t  else if (Present (gnat_smo)\n+\t\t   && Present (Storage_Model_Copy_To (gnat_smo)))\n+\t    {\n+\t      tree t = remove_conversions (gnu_rhs, false);\n+\n+\t      /* If a storage model load is present on the RHS then instantiate\n+\t\t the temporary associated with it now, lest it be of variable\n+\t\t size and thus could not be instantiated by gimplification.  */\n+\t      if (TREE_CODE (t) == LOAD_EXPR)\n+\t\t{\n+\t\t  t = TREE_OPERAND (t, 1);\n+\t\t  gcc_assert (TREE_CODE (t) == CALL_EXPR);\n+\n+\t\t  tree elem\n+\t\t    = build_nonstandard_integer_type (BITS_PER_UNIT, 1);\n+\t\t  tree size = fold_convert (sizetype, CALL_EXPR_ARG (t, 3));\n+\t\t  tree index = build_index_type (size);\n+\t\t  tree temp\n+\t\t    = create_temporary (\"L\", build_array_type (elem, index));\n+\t\t  tree arg = CALL_EXPR_ARG (t, 1);\n+\t\t  CALL_EXPR_ARG (t, 1)\n+\t\t    = build_unary_op (ADDR_EXPR, TREE_TYPE (arg), temp);\n+\n+\t\t  start_stmt_group ();\n+\t\t  add_stmt (t);\n+\t\t  t = build_storage_model_store (gnat_smo, gnu_lhs, temp);\n+\t\t  add_stmt (t);\n+\t\t  gnu_result = end_stmt_group ();\n+\t\t}\n+\n+\t      else\n+\t\tgnu_result\n+\t\t  = build_storage_model_store (gnat_smo, gnu_lhs, gnu_rhs);\n+\t    }\n+\n \t  /* Or else, use memset when the conditions are met.  This has already\n \t     been validated by Aggr_Assignment_OK_For_Backend in the front-end\n \t     and the RHS is thus guaranteed to be of the appropriate form.  */\n@@ -7307,10 +7509,27 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t\t\t\t gnat_node);\n \t    }\n \n-\t  /* Otherwise build a regular assignment.  */\n \t  else\n-\t    gnu_result\n-\t      = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n+\t    {\n+\t      tree t = remove_conversions (gnu_rhs, false);\n+\n+\t      /* If a storage model load is present on the RHS, then elide the\n+\t\t temporary associated with it.  */\n+\t      if (TREE_CODE (t) == LOAD_EXPR)\n+\t\t{\n+\t\t  gnu_result = TREE_OPERAND (t, 1);\n+\t\t  gcc_assert (TREE_CODE (gnu_result) == CALL_EXPR);\n+\n+\t\t  tree arg = CALL_EXPR_ARG (gnu_result, 1);\n+\t\t  CALL_EXPR_ARG (gnu_result, 1)\n+\t\t    = build_unary_op (ADDR_EXPR, TREE_TYPE (arg), gnu_lhs);\n+\t\t}\n+\n+\t      /* Otherwise build a regular assignment.  */\n+\t      else\n+\t\tgnu_result\n+\t\t  = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n+\t    }\n \n \t  /* If the assignment type is a regular array and the two sides are\n \t     not completely disjoint, play safe and use memmove.  But don't do\n@@ -7624,7 +7843,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n       gnu_result = Call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE,\n-\t\t\t\tNOT_ATOMIC, false);\n+\t\t\t\tNOT_ATOMIC, false, Empty);\n       break;\n \n     /************************/\n@@ -8023,10 +8242,14 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       if (!type_annotate_only)\n \t{\n-\t  tree gnu_ptr, gnu_ptr_type, gnu_obj_type, gnu_actual_obj_type;\n-\n \t  const Entity_Id gnat_desig_type\n \t    = Designated_Type (Underlying_Type (Etype (gnat_temp)));\n+\t  const Entity_Id gnat_pool = Storage_Pool (gnat_node);\n+\t  const bool pool_is_storage_model\n+\t    = Present (gnat_pool)\n+\t      && Has_Storage_Model_Type_Aspect (Etype (gnat_pool))\n+\t      && Present (Storage_Model_Copy_From (gnat_pool));\n+\t  tree gnu_ptr, gnu_ptr_type, gnu_obj_type, gnu_actual_obj_type;\n \n \t  /* Make sure the designated type is complete before dereferencing,\n \t     in case it is a Taft Amendment type.  */\n@@ -8087,12 +8310,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t  tree gnu_size = TYPE_SIZE_UNIT (gnu_actual_obj_type);\n \t  gnu_size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_size, gnu_ptr);\n+\t  if (pool_is_storage_model)\n+\t    gnu_size = INSTANTIATE_LOAD_IN_EXPR (gnu_size, gnat_pool);\n \n \t  gnu_result\n \t      = build_call_alloc_dealloc (gnu_ptr, gnu_size, gnu_obj_type,\n \t\t\t\t\t  Procedure_To_Call (gnat_node),\n-\t\t\t\t\t  Storage_Pool (gnat_node),\n-\t\t\t\t\t  gnat_node);\n+\t\t\t\t\t  gnat_pool, gnat_node);\n \t}\n       break;\n \n@@ -8300,7 +8524,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   && return_type_with_variable_size_p (TREE_TYPE (gnu_result)))\n     ;\n \n-  else if (TREE_CODE (gnu_result) == UNCONSTRAINED_ARRAY_REF\n+  else if (TREE_CODE (TREE_TYPE (gnu_result)) == UNCONSTRAINED_ARRAY_TYPE\n \t   && Present (Parent (gnat_node))\n \t   && Nkind (Parent (gnat_node)) == N_Attribute_Reference\n \t   && lvalue_required_for_attribute_p (Parent (gnat_node)))\n@@ -8739,7 +8963,7 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t avoid blocking concatenation in the caller when it is inlined.  */\n       for (int i = 0; i < call_expr_nargs (expr); i++)\n \t{\n-\t  tree arg = *(CALL_EXPR_ARGP (expr) + i);\n+\t  tree arg = CALL_EXPR_ARG (expr, i);\n \n \t  if (TREE_CODE (arg) == CONSTRUCTOR\n \t      && TREE_CONSTANT (arg)\n@@ -8751,7 +8975,7 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t      if (TREE_CODE (t) == ADDR_EXPR)\n \t\tt = TREE_OPERAND (t, 0);\n \t      if (TREE_CODE (t) != STRING_CST)\n-\t\t*(CALL_EXPR_ARGP (expr) + i) = tree_output_constant_def (arg);\n+\t\tCALL_EXPR_ARG (expr, i) = tree_output_constant_def (arg);\n \t    }\n \t}\n       break;\n@@ -8816,11 +9040,21 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \tTREE_NO_WARNING (expr) = TREE_NO_WARNING (op);\n       break;\n \n-    case UNCONSTRAINED_ARRAY_REF:\n-      /* We should only do this if we are just elaborating for side effects,\n-\t but we can't know that yet.  */\n-      *expr_p = TREE_OPERAND (*expr_p, 0);\n-      return GS_OK;\n+    case LOAD_EXPR:\n+      {\n+\ttree new_var = create_tmp_var (type, \"L\");\n+\tTREE_ADDRESSABLE (new_var) = 1;\n+\n+\ttree init = TREE_OPERAND (expr, 1);\n+\tgcc_assert (TREE_CODE (init) == CALL_EXPR);\n+\ttree arg = CALL_EXPR_ARG (init, 1);\n+\tCALL_EXPR_ARG (init, 1)\n+\t  = build_unary_op (ADDR_EXPR, TREE_TYPE (arg), new_var);\n+\tgimplify_and_add (init, pre_p);\n+\n+\t*expr_p = new_var;\n+\treturn GS_OK;\n+      }\n \n     case VIEW_CONVERT_EXPR:\n       op = TREE_OPERAND (expr, 0);\n@@ -8832,17 +9066,23 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \t  && AGGREGATE_TYPE_P (TREE_TYPE (op))\n \t  && !AGGREGATE_TYPE_P (type))\n \t{\n-\t  tree mod, new_var = create_tmp_var_raw (TREE_TYPE (op), \"C\");\n+\t  tree new_var = create_tmp_var_raw (TREE_TYPE (op), \"C\");\n \t  gimple_add_tmp_var (new_var);\n \n-\t  mod = build2 (INIT_EXPR, TREE_TYPE (new_var), new_var, op);\n+\t  tree mod = build2 (INIT_EXPR, TREE_TYPE (new_var), new_var, op);\n \t  gimplify_and_add (mod, pre_p);\n \n \t  TREE_OPERAND (expr, 0) = new_var;\n \t  return GS_OK;\n \t}\n       break;\n \n+    case UNCONSTRAINED_ARRAY_REF:\n+      /* We should only do this if we are just elaborating for side effects,\n+\t but we can't know that yet.  */\n+      *expr_p = TREE_OPERAND (expr, 0);\n+      return GS_OK;\n+\n     default:\n       break;\n     }"}, {"sha": "5942de150b9b3cdcbba4b44d7ca969b4d729b456", "filename": "gcc/ada/gcc-interface/utils.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Futils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Futils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.cc?ref=544d14e1b42eeb337fcefb1efe9d108e71a06d52", "patch": "@@ -5256,6 +5256,13 @@ maybe_unconstrained_array (tree exp)\n \t    }\n \t}\n \n+      else if (code == LOAD_EXPR)\n+\t{\n+\t  const Entity_Id gnat_smo = tree_to_shwi (TREE_OPERAND (exp, 1));\n+\t  tree t = maybe_unconstrained_array (TREE_OPERAND (exp, 0));\n+\t  exp = build_storage_model_load (gnat_smo, t);\n+\t}\n+\n       else if (code == NULL_EXPR)\n \texp = build1 (NULL_EXPR,\n \t\t      TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (type)))),"}, {"sha": "ef81f8dd56a036345bd598f461c0db4c169cc591", "filename": "gcc/ada/gcc-interface/utils2.cc", "status": "modified", "additions": 277, "deletions": 17, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544d14e1b42eeb337fcefb1efe9d108e71a06d52/gcc%2Fada%2Fgcc-interface%2Futils2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.cc?ref=544d14e1b42eeb337fcefb1efe9d108e71a06d52", "patch": "@@ -2401,6 +2401,10 @@ tree\n build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n                  Entity_Id gnat_pool, Node_Id gnat_node, bool ignore_init_type)\n {\n+  const bool pool_is_storage_model\n+    = Present (gnat_pool)\n+      && Has_Storage_Model_Type_Aspect (Etype (gnat_pool))\n+      && Present (Storage_Model_Copy_To (gnat_pool));\n   tree size, storage, storage_deref, storage_init;\n \n   /* If the initializer, if present, is a NULL_EXPR, just return a new one.  */\n@@ -2433,6 +2437,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t\t\t\t\t  get_identifier (\"ALLOC\"), false);\n       tree template_type = TREE_TYPE (TYPE_FIELDS (storage_type));\n       tree storage_ptr_type = build_pointer_type (storage_type);\n+      tree lhs, rhs;\n \n       size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (storage_type),\n \t\t\t\t\t     init);\n@@ -2459,17 +2464,21 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \t\t\t\t  build_template (template_type, type, init));\n \t  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (storage_type)),\n \t\t\t\t  init);\n-\t  storage_init\n-\t    = build_binary_op (INIT_EXPR, NULL_TREE, storage_deref,\n-\t\t\t       gnat_build_constructor (storage_type, v));\n+\n+\t  lhs = storage_deref;\n+\t  rhs = gnat_build_constructor (storage_type, v);\n \t}\n       else\n-\tstorage_init\n-\t  = build_binary_op (INIT_EXPR, NULL_TREE,\n-\t\t\t     build_component_ref (storage_deref,\n-\t\t\t\t\t\t  TYPE_FIELDS (storage_type),\n-\t\t\t\t\t\t  false),\n-\t\t\t     build_template (template_type, type, NULL_TREE));\n+\t{\n+\t  lhs = build_component_ref (storage_deref, TYPE_FIELDS (storage_type),\n+\t\t\t\t     false);\n+\t  rhs = build_template (template_type, type, NULL_TREE);\n+\t}\n+\n+      if (pool_is_storage_model)\n+\tstorage_init = build_storage_model_store (gnat_pool, lhs, rhs);\n+      else\n+\tstorage_init = build_binary_op (INIT_EXPR, NULL_TREE, lhs, rhs);\n \n       return build2 (COMPOUND_EXPR, result_type,\n \t\t     storage_init, convert (result_type, storage));\n@@ -2509,14 +2518,263 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n       storage = gnat_protect_expr (storage);\n       storage_deref = build_unary_op (INDIRECT_REF, NULL_TREE, storage);\n       TREE_THIS_NOTRAP (storage_deref) = 1;\n-      storage_init\n-\t= build_binary_op (INIT_EXPR, NULL_TREE, storage_deref, init);\n+      if (pool_is_storage_model)\n+\tstorage_init\n+\t  = build_storage_model_store (gnat_pool, storage_deref, init);\n+      else\n+\tstorage_init\n+\t  = build_binary_op (INIT_EXPR, NULL_TREE, storage_deref, init);\n       return build2 (COMPOUND_EXPR, result_type, storage_init, storage);\n     }\n \n   return storage;\n }\n \n+/* Build a call to a copy procedure of a storage model given by an object.\n+   DEST, SRC and SIZE are as for a call to memcpy.  GNAT_SMO is the entity\n+   for the storage model object and COPY_TO says which procedure to use.  */\n+\n+static tree\n+build_storage_model_copy (Entity_Id gnat_smo, tree dest, tree src, tree size,\n+\t\t\t  bool copy_to)\n+{\n+  const Entity_Id gnat_copy_proc\n+    = copy_to\n+      ? Storage_Model_Copy_To (gnat_smo)\n+      : Storage_Model_Copy_From (gnat_smo);\n+  tree gnu_copy_proc = gnat_to_gnu (gnat_copy_proc);\n+  tree gnu_param_type_list = TYPE_ARG_TYPES (TREE_TYPE (gnu_copy_proc));\n+  tree t1 = TREE_VALUE (gnu_param_type_list);\n+  tree t2 = TREE_VALUE (TREE_CHAIN (gnu_param_type_list));\n+  tree t3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (gnu_param_type_list)));\n+  tree t4\n+    = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (gnu_param_type_list))));\n+\n+  return\n+    build_call_n_expr (gnu_copy_proc,\n+\t\t       4,\n+\t\t       build_unary_op (ADDR_EXPR, t1, gnat_to_gnu (gnat_smo)),\n+\t\t       build_unary_op (ADDR_EXPR, t2, dest),\n+\t\t       build_unary_op (ADDR_EXPR, t3, src),\n+\t\t       convert (t4, size));\n+}\n+\n+/* Build a load of SRC using the storage model of GNAT_SMO.  */\n+\n+tree\n+build_storage_model_load (Entity_Id gnat_smo, tree src)\n+{\n+  tree ret = build2 (LOAD_EXPR, TREE_TYPE (src), src, NULL_TREE);\n+\n+  /* Unconstrained array references have no size so we need to store the\n+     storage object model for future processing by the machinery.  */\n+  if (TREE_CODE (src) == UNCONSTRAINED_ARRAY_REF)\n+    TREE_OPERAND (ret, 1) = build_int_cst (integer_type_node, gnat_smo);\n+  else\n+    TREE_OPERAND (ret, 1) = build_storage_model_load (gnat_smo, src, src);\n+\n+  return ret;\n+}\n+\n+/* Build a load of SRC into DEST using the storage model of GNAT_SMO.\n+   If SIZE is specified, use it, otherwise use the size of SRC.  */\n+\n+tree\n+build_storage_model_load (Entity_Id gnat_smo, tree dest, tree src, tree size)\n+{\n+  gcc_assert (TREE_CODE (src) != LOAD_EXPR);\n+\n+  if (!size)\n+    {\n+      size = TYPE_SIZE_UNIT (TREE_TYPE (src));\n+      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, src);\n+      size = INSTANTIATE_LOAD_IN_EXPR (size, gnat_smo);\n+    }\n+\n+  return build_storage_model_copy (gnat_smo, dest, src, size, false);\n+}\n+\n+/* Build a store of SRC into DEST using the storage model of GNAT_SMO.\n+   If SIZE is specified, use it, otherwise use the size of DEST.  */\n+\n+tree\n+build_storage_model_store (Entity_Id gnat_smo, tree dest, tree src, tree size)\n+{\n+  gcc_assert (TREE_CODE (src) != LOAD_EXPR);\n+\n+  if (!size)\n+    {\n+      size = TYPE_SIZE_UNIT (TREE_TYPE (dest));\n+      size = SUBSTITUTE_PLACEHOLDER_IN_EXPR (size, dest);\n+      size = INSTANTIATE_LOAD_IN_EXPR (size, gnat_smo);\n+    }\n+\n+  return build_storage_model_copy (gnat_smo, dest, src, size, true);\n+}\n+\n+/* Given a tree EXP, instantiate occurrences of LOAD_EXPR in it and associate\n+   them with the storage model of GNAT_SMO.  */\n+\n+tree\n+instantiate_load_in_expr (tree exp, Entity_Id gnat_smo)\n+{\n+  const enum tree_code code = TREE_CODE (exp);\n+  tree type = TREE_TYPE (exp);\n+  tree op0, op1, op2, op3;\n+  tree new_tree;\n+\n+  /* We handle TREE_LIST and COMPONENT_REF separately.  */\n+  if (code == TREE_LIST)\n+    {\n+      op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_CHAIN (exp), gnat_smo);\n+      op1 = INSTANTIATE_LOAD_IN_EXPR (TREE_VALUE (exp), gnat_smo);\n+      if (op0 == TREE_CHAIN (exp) && op1 == TREE_VALUE (exp))\n+\treturn exp;\n+\n+      return tree_cons (TREE_PURPOSE (exp), op1, op0);\n+    }\n+  else if (code == COMPONENT_REF)\n+    {\n+      /* The field.  */\n+      op1 = TREE_OPERAND (exp, 1);\n+\n+      /* If it is a discriminant or equivalent, a LOAD_EXPR is needed.  */\n+      if (DECL_DISCRIMINANT_NUMBER (op1))\n+\treturn build_storage_model_load (gnat_smo, exp);\n+\n+      op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 0), gnat_smo);\n+      if (op0 == TREE_OPERAND (exp, 0))\n+\treturn exp;\n+\n+      new_tree = fold_build3 (COMPONENT_REF, type, op0, op1, NULL_TREE);\n+   }\n+  else\n+    switch (TREE_CODE_CLASS (code))\n+      {\n+      case tcc_constant:\n+      case tcc_declaration:\n+\t  return exp;\n+\n+      case tcc_expression:\n+\tif (code == LOAD_EXPR)\n+\t  return exp;\n+\n+\t/* Fall through.  */\n+\n+      case tcc_exceptional:\n+      case tcc_unary:\n+      case tcc_binary:\n+      case tcc_comparison:\n+      case tcc_reference:\n+\tswitch (TREE_CODE_LENGTH (code))\n+\t  {\n+\t  case 0:\n+\t    return exp;\n+\n+\t  case 1:\n+\t    op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 0), gnat_smo);\n+\t    if (op0 == TREE_OPERAND (exp, 0))\n+\t      return exp;\n+\n+\t    new_tree = fold_build1 (code, type, op0);\n+\t    break;\n+\n+\t  case 2:\n+\t    op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 0), gnat_smo);\n+\t    op1 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 1), gnat_smo);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n+\t      return exp;\n+\n+\t    new_tree = fold_build2 (code, type, op0, op1);\n+\t    break;\n+\n+\t  case 3:\n+\t    op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 0), gnat_smo);\n+\t    op1 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 1), gnat_smo);\n+\t    op2 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 2), gnat_smo);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0)\n+\t\t&& op1 == TREE_OPERAND (exp, 1)\n+\t\t&& op2 == TREE_OPERAND (exp, 2))\n+\t      return exp;\n+\n+\t    new_tree = fold_build3 (code, type, op0, op1, op2);\n+\t    break;\n+\n+\t  case 4:\n+\t    op0 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 0), gnat_smo);\n+\t    op1 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 1), gnat_smo);\n+\t    op2 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 2), gnat_smo);\n+\t    op3 = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (exp, 3), gnat_smo);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0)\n+\t\t&& op1 == TREE_OPERAND (exp, 1)\n+\t\t&& op2 == TREE_OPERAND (exp, 2)\n+\t\t&& op3 == TREE_OPERAND (exp, 3))\n+\t      return exp;\n+\n+\t    new_tree = fold (build4 (code, type, op0, op1, op2, op3));\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tbreak;\n+\n+      case tcc_vl_exp:\n+\t{\n+\t  gcc_assert (code == CALL_EXPR);\n+\n+\t  const int n = call_expr_nargs (exp);\n+\t  gcc_assert (n > 0);\n+\t  tree *argarray = XALLOCAVEC (tree, n);\n+\t  for (int i = 0; i < n; i++)\n+\t    argarray[i]\n+\t      = INSTANTIATE_LOAD_IN_EXPR (CALL_EXPR_ARG (exp, i), gnat_smo);\n+\n+\t  for (int i = 0; i < n; i++)\n+\t    if (argarray[i] != CALL_EXPR_ARG (exp, i))\n+\t      return build_call_array (type, CALL_EXPR_FN (exp), n, argarray);\n+\n+\t  return exp;\n+\t}\n+\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  TREE_READONLY (new_tree) |= TREE_READONLY (exp);\n+\n+  if (code == INDIRECT_REF || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n+    TREE_THIS_NOTRAP (new_tree) |= TREE_THIS_NOTRAP (exp);\n+\n+  return new_tree;\n+}\n+\n+/* Given an array or slice reference, instantiate occurrences of LOAD_EXPR in\n+   it and associate them with the storage model of GNAT_SMO.  */\n+\n+void\n+instantiate_load_in_array_ref (tree ref, Entity_Id gnat_smo)\n+{\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (ref, 0)));\n+  tree elem_type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (ref, 0)));\n+\n+  TREE_OPERAND (ref, 2)\n+    = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_MIN_VALUE (domain_type), ref);\n+  TREE_OPERAND (ref, 2)\n+    = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (ref, 2), gnat_smo);\n+\n+  TREE_OPERAND (ref, 3)\n+    = size_binop (EXACT_DIV_EXPR,\n+\t\t  SUBSTITUTE_PLACEHOLDER_IN_EXPR (TYPE_SIZE_UNIT (elem_type),\n+\t\t\t\t\t\t  ref),\n+\t\t  size_int (TYPE_ALIGN_UNIT (elem_type)));\n+  TREE_OPERAND (ref, 3)\n+    = INSTANTIATE_LOAD_IN_EXPR (TREE_OPERAND (ref, 3), gnat_smo);\n+}\n+\n /* Indicate that we need to take the address of T and that it therefore\n    should not be allocated in a register.  Return true if successful.  */\n \n@@ -2816,7 +3074,7 @@ gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, tree *init)\n \t\t  gnat_rewrite_reference (TREE_OPERAND (ref, 0), func, data,\n \t\t\t\t\t  init),\n \t\t  func (TREE_OPERAND (ref, 1), data),\n-\t\t  TREE_OPERAND (ref, 2), NULL_TREE);\n+\t\t  TREE_OPERAND (ref, 2), TREE_OPERAND (ref, 3));\n       break;\n \n     case COMPOUND_EXPR:\n@@ -2901,9 +3159,6 @@ get_inner_constant_reference (tree exp)\n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n \t  {\n-\t    if (TREE_OPERAND (exp, 2))\n-\t      return NULL_TREE;\n-\n \t    tree array_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t    if (!TREE_CONSTANT (TREE_OPERAND (exp, 1))\n \t        || !TREE_CONSTANT (TYPE_MIN_VALUE (TYPE_DOMAIN (array_type)))\n@@ -3044,8 +3299,13 @@ gnat_invariant_expr (tree expr)\n \n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n-\t  if (!TREE_CONSTANT (TREE_OPERAND (t, 1)) || TREE_OPERAND (t, 2))\n-\t    return NULL_TREE;\n+\t  {\n+\t    tree array_type = TREE_TYPE (TREE_OPERAND (t, 0));\n+\t    if (!TREE_CONSTANT (TREE_OPERAND (t, 1))\n+\t        || !TREE_CONSTANT (TYPE_MIN_VALUE (TYPE_DOMAIN (array_type)))\n+\t        || !TREE_CONSTANT (TYPE_SIZE_UNIT (TREE_TYPE (array_type))))\n+\t      return NULL_TREE;\n+\t  }\n \t  break;\n \n \tcase BIT_FIELD_REF:"}]}