{"sha": "d7fb38e9ac62b51cf64ac901c8424c8cffc17907", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdmYjM4ZTlhYzYyYjUxY2Y2NGFjOTAxYzg0MjRjOGNmZmMxNzkwNw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-12-01T14:12:37Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-12-01T14:12:37Z"}, "message": "PR 25708 Avoid seeking when parsing strings and when peeking.\n\n2011-12-01  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/25708\n\t* module.c (parse_string): Read string into resizable array\n\tinstead of parsing twice and seeking.\n\t(peek_atom): New implementation avoiding seeks.\n\t(require_atom): Save and set column and line explicitly for error\n\thandling.\n\nFrom-SVN: r181879", "tree": {"sha": "5e86a010eb82092208c029451a0de36d2a425501", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e86a010eb82092208c029451a0de36d2a425501"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7fb38e9ac62b51cf64ac901c8424c8cffc17907", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7fb38e9ac62b51cf64ac901c8424c8cffc17907", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7fb38e9ac62b51cf64ac901c8424c8cffc17907", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7fb38e9ac62b51cf64ac901c8424c8cffc17907/comments", "author": null, "committer": null, "parents": [{"sha": "c136d69611a4b67e4e80657f1f9f0a7c4ef2d3f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c136d69611a4b67e4e80657f1f9f0a7c4ef2d3f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c136d69611a4b67e4e80657f1f9f0a7c4ef2d3f1"}], "stats": {"total": 165, "additions": 122, "deletions": 43}, "files": [{"sha": "9c62697d29eb7e7d31069d9e5eabdff6ac0382c2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7fb38e9ac62b51cf64ac901c8424c8cffc17907/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7fb38e9ac62b51cf64ac901c8424c8cffc17907/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d7fb38e9ac62b51cf64ac901c8424c8cffc17907", "patch": "@@ -1,3 +1,12 @@\n+2011-12-01  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/25708\n+\t* module.c (parse_string): Read string into resizable array\n+\tinstead of parsing twice and seeking.\n+\t(peek_atom): New implementation avoiding seeks.\n+\t(require_atom): Save and set column and line explicitly for error\n+\thandling.\n+\n 2011-12-01  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* misc.c (gfc_open_file): Don't call stat."}, {"sha": "f9774d491b86ed75864e4f5c617f3deb039af9e0", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 113, "deletions": 43, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7fb38e9ac62b51cf64ac901c8424c8cffc17907/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7fb38e9ac62b51cf64ac901c8424c8cffc17907/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=d7fb38e9ac62b51cf64ac901c8424c8cffc17907", "patch": "@@ -1069,51 +1069,37 @@ module_unget_char (void)\n static void\n parse_string (void)\n {\n-  module_locus start;\n-  int len, c;\n-  char *p;\n-\n-  get_module_locus (&start);\n+  int c;\n+  size_t cursz = 30;\n+  size_t len = 0;\n \n-  len = 0;\n+  atom_string = XNEWVEC (char, cursz);\n \n-  /* See how long the string is.  */\n   for ( ; ; )\n     {\n       c = module_char ();\n-      if (c == EOF)\n-\tbad_module (\"Unexpected end of module in string constant\");\n \n-      if (c != '\\'')\n+      if (c == '\\'')\n \t{\n-\t  len++;\n-\t  continue;\n+\t  int c2 = module_char ();\n+\t  if (c2 != '\\'')\n+\t    {\n+\t      module_unget_char ();\n+\t      break;\n+\t    }\n \t}\n \n-      c = module_char ();\n-      if (c == '\\'')\n+      if (len >= cursz)\n \t{\n-\t  len++;\n-\t  continue;\n+\t  cursz *= 2;\n+\t  atom_string = XRESIZEVEC (char, atom_string, cursz);\n \t}\n-\n-      break;\n+      atom_string[len] = c;\n+      len++;\n     }\n \n-  set_module_locus (&start);\n-\n-  atom_string = p = XCNEWVEC (char, len + 1);\n-\n-  for (; len > 0; len--)\n-    {\n-      c = module_char ();\n-      if (c == '\\'')\n-\tmodule_char ();\t\t/* Guaranteed to be another \\'.  */\n-      *p++ = c;\n-    }\n-\n-  module_char ();\t\t/* Terminating \\'.  */\n-  *p = '\\0';\t\t\t/* C-style string for debug purposes.  */\n+  atom_string = XRESIZEVEC (char, atom_string, len + 1);\n+  atom_string[len] = '\\0'; \t/* C-style string for debug purposes.  */\n }\n \n \n@@ -1279,17 +1265,99 @@ parse_atom (void)\n static atom_type\n peek_atom (void)\n {\n-  module_locus m;\n-  atom_type a;\n+  int c;\n+\n+  do\n+    {\n+      c = module_char ();\n+    }\n+  while (c == ' ' || c == '\\r' || c == '\\n');\n+\n+  switch (c)\n+    {\n+    case '(':\n+      module_unget_char ();\n+      return ATOM_LPAREN;\n \n-  get_module_locus (&m);\n+    case ')':\n+      module_unget_char ();\n+      return ATOM_RPAREN;\n \n-  a = parse_atom ();\n-  if (a == ATOM_STRING)\n-    free (atom_string);\n+    case '\\'':\n+      module_unget_char ();\n+      return ATOM_STRING;\n+\n+    case '0':\n+    case '1':\n+    case '2':\n+    case '3':\n+    case '4':\n+    case '5':\n+    case '6':\n+    case '7':\n+    case '8':\n+    case '9':\n+      module_unget_char ();\n+      return ATOM_INTEGER;\n+\n+    case 'a':\n+    case 'b':\n+    case 'c':\n+    case 'd':\n+    case 'e':\n+    case 'f':\n+    case 'g':\n+    case 'h':\n+    case 'i':\n+    case 'j':\n+    case 'k':\n+    case 'l':\n+    case 'm':\n+    case 'n':\n+    case 'o':\n+    case 'p':\n+    case 'q':\n+    case 'r':\n+    case 's':\n+    case 't':\n+    case 'u':\n+    case 'v':\n+    case 'w':\n+    case 'x':\n+    case 'y':\n+    case 'z':\n+    case 'A':\n+    case 'B':\n+    case 'C':\n+    case 'D':\n+    case 'E':\n+    case 'F':\n+    case 'G':\n+    case 'H':\n+    case 'I':\n+    case 'J':\n+    case 'K':\n+    case 'L':\n+    case 'M':\n+    case 'N':\n+    case 'O':\n+    case 'P':\n+    case 'Q':\n+    case 'R':\n+    case 'S':\n+    case 'T':\n+    case 'U':\n+    case 'V':\n+    case 'W':\n+    case 'X':\n+    case 'Y':\n+    case 'Z':\n+      module_unget_char ();\n+      return ATOM_NAME;\n \n-  set_module_locus (&m);\n-  return a;\n+    default:\n+      bad_module (\"Bad name\");\n+    }\n }\n \n \n@@ -1299,11 +1367,12 @@ peek_atom (void)\n static void\n require_atom (atom_type type)\n {\n-  module_locus m;\n   atom_type t;\n   const char *p;\n+  int column, line;\n \n-  get_module_locus (&m);\n+  column = module_column;\n+  line = module_line;\n \n   t = parse_atom ();\n   if (t != type)\n@@ -1329,7 +1398,8 @@ require_atom (atom_type type)\n \t  gfc_internal_error (\"require_atom(): bad atom type required\");\n \t}\n \n-      set_module_locus (&m);\n+      module_column = column;\n+      module_line = line;\n       bad_module (p);\n     }\n }"}]}