{"sha": "41dbbb3789850dfea98dd8984f69806284f87b6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFkYmJiMzc4OTg1MGRmZWE5OGRkODk4NGY2OTgwNjI4NGY4N2I2ZQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2015-01-15T20:11:12Z"}, "committer": {"name": "Thomas Schwinge", "email": "tschwinge@gcc.gnu.org", "date": "2015-01-15T20:11:12Z"}, "message": "Merge current set of OpenACC changes from gomp-4_0-branch.\n\n\tcontrib/\n\t* gcc_update (files_and_dependencies): Update rules for new\n\tlibgomp/plugin/Makefrag.am and libgomp/plugin/configfrag.ac files.\n\tgcc/\n\t* builtin-types.def (BT_FN_VOID_INT_INT_VAR)\n\t(BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR)\n\t(BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR):\n\tNew function types.\n\t* builtins.c: Include \"gomp-constants.h\".\n\t(expand_builtin_acc_on_device): New function.\n\t(expand_builtin, is_inexpensive_builtin): Handle\n\tBUILT_IN_ACC_ON_DEVICE.\n\t* builtins.def (DEF_GOACC_BUILTIN, DEF_GOACC_BUILTIN_COMPILER):\n\tNew macros.\n\t* cgraph.c (cgraph_node::create): Consider flag_openacc next to\n\tflag_openmp.\n\t* config.gcc <nvptx-*> (tm_file): Add nvptx/offload.h.\n\t<*-intelmic-* | *-intelmicemul-*> (tm_file): Add\n\ti386/intelmic-offload.h.\n\t* gcc.c (LINK_COMMAND_SPEC, GOMP_SELF_SPECS): For -fopenacc, link\n\tto libgomp and its dependencies.\n\t* config/arc/arc.h (LINK_COMMAND_SPEC): Likewise.\n\t* config/darwin.h (LINK_COMMAND_SPEC_A): Likewise.\n\t* config/i386/mingw32.h (GOMP_SELF_SPECS): Likewise.\n\t* config/ia64/hpux.h (LIB_SPEC): Likewise.\n\t* config/pa/pa-hpux11.h (LIB_SPEC): Likewise.\n\t* config/pa/pa64-hpux.h (LIB_SPEC): Likewise.\n\t* doc/generic.texi: Update for OpenACC changes.\n\t* doc/gimple.texi: Likewise.\n\t* doc/invoke.texi: Likewise.\n\t* doc/sourcebuild.texi: Likewise.\n\t* gimple-pretty-print.c (dump_gimple_omp_for): Handle\n\tGF_OMP_FOR_KIND_OACC_LOOP.\n\t(dump_gimple_omp_target): Handle GF_OMP_TARGET_KIND_OACC_KERNELS,\n\tGF_OMP_TARGET_KIND_OACC_PARALLEL, GF_OMP_TARGET_KIND_OACC_DATA,\n\tGF_OMP_TARGET_KIND_OACC_UPDATE,\n\tGF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA.\n\tDump more data.\n\t* gimple.c: Update comments for OpenACC changes.\n\t* gimple.def: Likewise.\n\t* gimple.h: Likewise.\n\t(enum gf_mask): Add GF_OMP_FOR_KIND_OACC_LOOP,\n\tGF_OMP_TARGET_KIND_OACC_PARALLEL, GF_OMP_TARGET_KIND_OACC_KERNELS,\n\tGF_OMP_TARGET_KIND_OACC_DATA, GF_OMP_TARGET_KIND_OACC_UPDATE,\n\tGF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA.\n\t(gimple_omp_for_cond, gimple_omp_for_set_cond): Sort in the\n\tappropriate place.\n\t(is_gimple_omp_oacc, is_gimple_omp_offloaded): New functions.\n\t* gimplify.c: Include \"gomp-constants.h\".\n\tUpdate comments for OpenACC changes.\n\t(is_gimple_stmt): Handle OACC_PARALLEL, OACC_KERNELS, OACC_DATA,\n\tOACC_HOST_DATA, OACC_DECLARE, OACC_UPDATE, OACC_ENTER_DATA,\n\tOACC_EXIT_DATA, OACC_CACHE, OACC_LOOP.\n\t(gimplify_scan_omp_clauses, gimplify_adjust_omp_clauses): Handle\n\tOMP_CLAUSE__CACHE_, OMP_CLAUSE_ASYNC, OMP_CLAUSE_WAIT,\n\tOMP_CLAUSE_NUM_GANGS, OMP_CLAUSE_NUM_WORKERS,\n\tOMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_GANG, OMP_CLAUSE_WORKER,\n\tOMP_CLAUSE_VECTOR, OMP_CLAUSE_DEVICE_RESIDENT,\n\tOMP_CLAUSE_USE_DEVICE, OMP_CLAUSE_INDEPENDENT, OMP_CLAUSE_AUTO,\n\tOMP_CLAUSE_SEQ.\n\t(gimplify_adjust_omp_clauses_1, gimplify_adjust_omp_clauses): Use\n\tGOMP_MAP_* instead of OMP_CLAUSE_MAP_*.  Use\n\tOMP_CLAUSE_SET_MAP_KIND.\n\t(gimplify_oacc_cache): New function.\n\t(gimplify_omp_for): Handle OACC_LOOP.\n\t(gimplify_omp_workshare): Handle OACC_KERNELS, OACC_PARALLEL,\n\tOACC_DATA.\n\t(gimplify_omp_target_update): Handle OACC_ENTER_DATA,\n\tOACC_EXIT_DATA, OACC_UPDATE.\n\t(gimplify_expr): Handle OACC_LOOP, OACC_CACHE, OACC_HOST_DATA,\n\tOACC_DECLARE, OACC_KERNELS, OACC_PARALLEL, OACC_DATA,\n\tOACC_ENTER_DATA, OACC_EXIT_DATA, OACC_UPDATE.\n\t(gimplify_body): Consider flag_openacc next to flag_openmp.\n\t* lto-streamer-out.c: Include \"gomp-constants.h\".\n\t* omp-builtins.def (BUILT_IN_ACC_GET_DEVICE_TYPE)\n\t(BUILT_IN_GOACC_DATA_START, BUILT_IN_GOACC_DATA_END)\n\t(BUILT_IN_GOACC_ENTER_EXIT_DATA, BUILT_IN_GOACC_PARALLEL)\n\t(BUILT_IN_GOACC_UPDATE, BUILT_IN_GOACC_WAIT)\n\t(BUILT_IN_GOACC_GET_THREAD_NUM, BUILT_IN_GOACC_GET_NUM_THREADS)\n\t(BUILT_IN_ACC_ON_DEVICE): New builtins.\n\t* omp-low.c: Include \"gomp-constants.h\".\n\tUpdate comments for OpenACC changes.\n\t(struct omp_context): Add reduction_map, gwv_below, gwv_this\n\tmembers.\n\t(extract_omp_for_data, use_pointer_for_field, install_var_field)\n\t(new_omp_context, delete_omp_context, scan_sharing_clauses)\n\t(create_omp_child_function, scan_omp_for, scan_omp_target)\n\t(check_omp_nesting_restrictions, lower_reduction_clauses)\n\t(build_omp_regions_1, diagnose_sb_0, make_gimple_omp_edges):\n\tUpdate for OpenACC changes.\n\t(scan_sharing_clauses): Handle OMP_CLAUSE_NUM_GANGS:\n\tOMP_CLAUSE_NUM_WORKERS: OMP_CLAUSE_VECTOR_LENGTH,\n\tOMP_CLAUSE_ASYNC, OMP_CLAUSE_WAIT, OMP_CLAUSE_GANG,\n\tOMP_CLAUSE_WORKER, OMP_CLAUSE_VECTOR, OMP_CLAUSE_DEVICE_RESIDENT,\n\tOMP_CLAUSE_USE_DEVICE, OMP_CLAUSE__CACHE_, OMP_CLAUSE_INDEPENDENT,\n\tOMP_CLAUSE_AUTO, OMP_CLAUSE_SEQ.  Use GOMP_MAP_* instead of\n\tOMP_CLAUSE_MAP_*.\n\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk):\n\tHandle GF_OMP_FOR_KIND_OACC_LOOP.\n\t(expand_omp_target, lower_omp_target): Handle\n\tGF_OMP_TARGET_KIND_OACC_PARALLEL, GF_OMP_TARGET_KIND_OACC_KERNELS,\n\tGF_OMP_TARGET_KIND_OACC_UPDATE,\n\tGF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA,\n\tGF_OMP_TARGET_KIND_OACC_DATA.\n\t(pass_expand_omp::execute, execute_lower_omp)\n\t(pass_diagnose_omp_blocks::gate): Consider flag_openacc next to\n\tflag_openmp.\n\t(offload_symbol_decl): New variable.\n\t(oacc_get_reduction_array_id, oacc_max_threads)\n\t(get_offload_symbol_decl, get_base_type, lookup_oacc_reduction)\n\t(maybe_lookup_oacc_reduction, enclosing_target_ctx)\n\t(oacc_loop_or_target_p, oacc_lower_reduction_var_helper)\n\t(oacc_gimple_assign, oacc_initialize_reduction_data)\n\t(oacc_finalize_reduction_data, oacc_process_reduction_data): New\n\tfunctions.\n\t(is_targetreg_ctx): Remove function.\n\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE__CACHE_,\n\tOMP_CLAUSE_DEVICE_RESIDENT, OMP_CLAUSE_USE_DEVICE,\n\tOMP_CLAUSE_GANG, OMP_CLAUSE_ASYNC, OMP_CLAUSE_WAIT,\n\tOMP_CLAUSE_AUTO, OMP_CLAUSE_SEQ, OMP_CLAUSE_INDEPENDENT,\n\tOMP_CLAUSE_WORKER, OMP_CLAUSE_VECTOR, OMP_CLAUSE_NUM_GANGS,\n\tOMP_CLAUSE_NUM_WORKERS, OMP_CLAUSE_VECTOR_LENGTH.\n\t* tree.c (omp_clause_code_name, walk_tree_1): Update accordingly.\n\t* tree.h (OMP_CLAUSE_GANG_EXPR, OMP_CLAUSE_GANG_STATIC_EXPR)\n\t(OMP_CLAUSE_ASYNC_EXPR, OMP_CLAUSE_WAIT_EXPR)\n\t(OMP_CLAUSE_VECTOR_EXPR, OMP_CLAUSE_WORKER_EXPR)\n\t(OMP_CLAUSE_NUM_GANGS_EXPR, OMP_CLAUSE_NUM_WORKERS_EXPR)\n\t(OMP_CLAUSE_VECTOR_LENGTH_EXPR): New macros.\n\t* tree-core.h: Update comments for OpenACC changes.\n\t(enum omp_clause_map_kind): Remove.\n\t(struct tree_omp_clause): Change type of map_kind member from enum\n\tomp_clause_map_kind to unsigned char.\n\t* tree-inline.c: Update comments for OpenACC changes.\n\t* tree-nested.c: Likewise.  Include \"gomp-constants.h\".\n\t(convert_nonlocal_reference_stmt, convert_local_reference_stmt)\n\t(convert_tramp_reference_stmt, convert_gimple_call): Update for\n\tOpenACC changes.  Use GOMP_MAP_* instead of OMP_CLAUSE_MAP_*.  Use\n\tOMP_CLAUSE_SET_MAP_KIND.\n\t* tree-pretty-print.c: Include \"gomp-constants.h\".\n\t(dump_omp_clause): Handle OMP_CLAUSE_DEVICE_RESIDENT,\n\tOMP_CLAUSE_USE_DEVICE, OMP_CLAUSE__CACHE_, OMP_CLAUSE_GANG,\n\tOMP_CLAUSE_ASYNC, OMP_CLAUSE_AUTO, OMP_CLAUSE_SEQ,\n\tOMP_CLAUSE_WAIT, OMP_CLAUSE_WORKER, OMP_CLAUSE_VECTOR,\n\tOMP_CLAUSE_NUM_GANGS, OMP_CLAUSE_NUM_WORKERS,\n\tOMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_INDEPENDENT.  Use GOMP_MAP_*\n\tinstead of OMP_CLAUSE_MAP_*.\n\t(dump_generic_node): Handle OACC_PARALLEL, OACC_KERNELS,\n\tOACC_DATA, OACC_HOST_DATA, OACC_DECLARE, OACC_UPDATE,\n\tOACC_ENTER_DATA, OACC_EXIT_DATA, OACC_CACHE, OACC_LOOP.\n\t* tree-streamer-in.c: Include \"gomp-constants.h\".\n\t(unpack_ts_omp_clause_value_fields) Use GOMP_MAP_* instead of\n\tOMP_CLAUSE_MAP_*.  Use OMP_CLAUSE_SET_MAP_KIND.\n\t* tree-streamer-out.c: Include \"gomp-constants.h\".\n\t(pack_ts_omp_clause_value_fields): Use GOMP_MAP_* instead of\n\tOMP_CLAUSE_MAP_*.\n\t* tree.def (OACC_PARALLEL, OACC_KERNELS, OACC_DATA)\n\t(OACC_HOST_DATA, OACC_LOOP, OACC_CACHE, OACC_DECLARE)\n\t(OACC_ENTER_DATA, OACC_EXIT_DATA, OACC_UPDATE): New tree codes.\n\t* tree.c (omp_clause_num_ops): Update accordingly.\n\t* tree.h (OMP_BODY, OMP_CLAUSES, OMP_LOOP_CHECK, OMP_CLAUSE_SIZE):\n\tLikewise.\n\t(OACC_PARALLEL_BODY, OACC_PARALLEL_CLAUSES, OACC_KERNELS_BODY)\n\t(OACC_KERNELS_CLAUSES, OACC_DATA_BODY, OACC_DATA_CLAUSES)\n\t(OACC_HOST_DATA_BODY, OACC_HOST_DATA_CLAUSES, OACC_CACHE_CLAUSES)\n\t(OACC_DECLARE_CLAUSES, OACC_ENTER_DATA_CLAUSES)\n\t(OACC_EXIT_DATA_CLAUSES, OACC_UPDATE_CLAUSES)\n\t(OACC_KERNELS_COMBINED, OACC_PARALLEL_COMBINED): New macros.\n\t* tree.h (OMP_CLAUSE_MAP_KIND): Cast it to enum gomp_map_kind.\n\t(OMP_CLAUSE_SET_MAP_KIND): New macro.\n\t* varpool.c (varpool_node::get_create): Consider flag_openacc next\n\tto flag_openmp.\n\t* config/i386/intelmic-offload.h: New file.\n\t* config/nvptx/offload.h: Likewise.\n\tgcc/ada/\n\t* gcc-interface/utils.c (DEF_FUNCTION_TYPE_VAR_8)\n\t(DEF_FUNCTION_TYPE_VAR_12): New macros.\n\tgcc/c-family/\n\t* c.opt (fopenacc): New option.\n\t* c-cppbuiltin.c (c_cpp_builtins): Conditionally define _OPENACC.\n\t* c-common.c (DEF_FUNCTION_TYPE_VAR_8, DEF_FUNCTION_TYPE_VAR_12):\n\tNew macros.\n\t* c-common.h (c_finish_oacc_wait): New prototype.\n\t* c-omp.c: Include \"omp-low.h\" and \"gomp-constants.h\".\n\t(c_finish_oacc_wait): New function.\n\t* c-pragma.c (oacc_pragmas): New variable.\n\t(c_pp_lookup_pragma, init_pragma): Handle it.\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OACC_CACHE,\n\tPRAGMA_OACC_DATA, PRAGMA_OACC_ENTER_DATA, PRAGMA_OACC_EXIT_DATA,\n\tPRAGMA_OACC_KERNELS, PRAGMA_OACC_LOOP, PRAGMA_OACC_PARALLEL,\n\tPRAGMA_OACC_UPDATE, PRAGMA_OACC_WAIT.\n\t(enum pragma_omp_clause): Add PRAGMA_OACC_CLAUSE_ASYNC,\n\tPRAGMA_OACC_CLAUSE_AUTO, PRAGMA_OACC_CLAUSE_COLLAPSE,\n\tPRAGMA_OACC_CLAUSE_COPY, PRAGMA_OACC_CLAUSE_COPYIN,\n\tPRAGMA_OACC_CLAUSE_COPYOUT, PRAGMA_OACC_CLAUSE_CREATE,\n\tPRAGMA_OACC_CLAUSE_DELETE, PRAGMA_OACC_CLAUSE_DEVICE,\n\tPRAGMA_OACC_CLAUSE_DEVICEPTR, PRAGMA_OACC_CLAUSE_FIRSTPRIVATE,\n\tPRAGMA_OACC_CLAUSE_GANG, PRAGMA_OACC_CLAUSE_HOST,\n\tPRAGMA_OACC_CLAUSE_IF, PRAGMA_OACC_CLAUSE_NUM_GANGS,\n\tPRAGMA_OACC_CLAUSE_NUM_WORKERS, PRAGMA_OACC_CLAUSE_PRESENT,\n\tPRAGMA_OACC_CLAUSE_PRESENT_OR_COPY,\n\tPRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN,\n\tPRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT,\n\tPRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE, PRAGMA_OACC_CLAUSE_PRIVATE,\n\tPRAGMA_OACC_CLAUSE_REDUCTION, PRAGMA_OACC_CLAUSE_SELF,\n\tPRAGMA_OACC_CLAUSE_SEQ, PRAGMA_OACC_CLAUSE_VECTOR,\n\tPRAGMA_OACC_CLAUSE_VECTOR_LENGTH, PRAGMA_OACC_CLAUSE_WAIT,\n\tPRAGMA_OACC_CLAUSE_WORKER.\n\tgcc/c/\n\t* c-parser.c: Include \"gomp-constants.h\".\n\t(c_parser_omp_clause_map): Use enum gomp_map_kind instead of enum\n\tomp_clause_map_kind.  Use GOMP_MAP_* instead of OMP_CLAUSE_MAP_*.\n\tUse OMP_CLAUSE_SET_MAP_KIND.\n\t(c_parser_pragma): Handle PRAGMA_OACC_ENTER_DATA,\n\tPRAGMA_OACC_EXIT_DATA, PRAGMA_OACC_UPDATE.\n\t(c_parser_omp_construct): Handle PRAGMA_OACC_CACHE,\n\tPRAGMA_OACC_DATA, PRAGMA_OACC_KERNELS, PRAGMA_OACC_LOOP,\n\tPRAGMA_OACC_PARALLEL, PRAGMA_OACC_WAIT.\n\t(c_parser_omp_clause_name): Handle \"auto\", \"async\", \"copy\",\n\t\"copyout\", \"create\", \"delete\", \"deviceptr\", \"gang\", \"host\",\n\t\"num_gangs\", \"num_workers\", \"present\", \"present_or_copy\", \"pcopy\",\n\t\"present_or_copyin\", \"pcopyin\", \"present_or_copyout\", \"pcopyout\",\n\t\"present_or_create\", \"pcreate\", \"seq\", \"self\", \"vector\",\n\t\"vector_length\", \"wait\", \"worker\".\n\t(OACC_DATA_CLAUSE_MASK, OACC_KERNELS_CLAUSE_MASK)\n\t(OACC_ENTER_DATA_CLAUSE_MASK, OACC_EXIT_DATA_CLAUSE_MASK)\n\t(OACC_LOOP_CLAUSE_MASK, OACC_PARALLEL_CLAUSE_MASK)\n\t(OACC_UPDATE_CLAUSE_MASK, OACC_WAIT_CLAUSE_MASK): New macros.\n\t(c_parser_omp_variable_list): Handle OMP_CLAUSE__CACHE_.\n\t(c_parser_oacc_wait_list, c_parser_oacc_data_clause)\n\t(c_parser_oacc_data_clause_deviceptr)\n\t(c_parser_omp_clause_num_gangs, c_parser_omp_clause_num_workers)\n\t(c_parser_oacc_clause_async, c_parser_oacc_clause_wait)\n\t(c_parser_omp_clause_vector_length, c_parser_oacc_all_clauses)\n\t(c_parser_oacc_cache, c_parser_oacc_data, c_parser_oacc_kernels)\n\t(c_parser_oacc_enter_exit_data, c_parser_oacc_loop)\n\t(c_parser_oacc_parallel, c_parser_oacc_update)\n\t(c_parser_oacc_wait): New functions.\n\t* c-tree.h (c_finish_oacc_parallel, c_finish_oacc_kernels)\n\t(c_finish_oacc_data): New prototypes.\n\t* c-typeck.c: Include \"gomp-constants.h\".\n\t(handle_omp_array_sections): Handle GOMP_MAP_FORCE_DEVICEPTR.  Use\n\tGOMP_MAP_* instead of OMP_CLAUSE_MAP_*.  Use\n\tOMP_CLAUSE_SET_MAP_KIND.\n\t(c_finish_oacc_parallel, c_finish_oacc_kernels)\n\t(c_finish_oacc_data): New functions.\n\t(c_finish_omp_clauses): Handle OMP_CLAUSE__CACHE_,\n\tOMP_CLAUSE_NUM_GANGS, OMP_CLAUSE_NUM_WORKERS,\n\tOMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_ASYNC, OMP_CLAUSE_WAIT,\n\tOMP_CLAUSE_AUTO, OMP_CLAUSE_SEQ, OMP_CLAUSE_GANG,\n\tOMP_CLAUSE_WORKER, OMP_CLAUSE_VECTOR, and OMP_CLAUSE_MAP's\n\tGOMP_MAP_FORCE_DEVICEPTR.\n\tgcc/cp/\n\t* parser.c: Include \"gomp-constants.h\".\n\t(cp_parser_omp_clause_map): Use enum gomp_map_kind instead of enum\n\tomp_clause_map_kind.  Use GOMP_MAP_* instead of OMP_CLAUSE_MAP_*.\n\tUse OMP_CLAUSE_SET_MAP_KIND.\n\t(cp_parser_omp_construct, cp_parser_pragma): Handle\n\tPRAGMA_OACC_CACHE, PRAGMA_OACC_DATA, PRAGMA_OACC_ENTER_DATA,\n\tPRAGMA_OACC_EXIT_DATA, PRAGMA_OACC_KERNELS, PRAGMA_OACC_PARALLEL,\n\tPRAGMA_OACC_LOOP, PRAGMA_OACC_UPDATE, PRAGMA_OACC_WAIT.\n\t(cp_parser_omp_clause_name): Handle \"async\", \"copy\", \"copyout\",\n\t\"create\", \"delete\", \"deviceptr\", \"host\", \"num_gangs\",\n\t\"num_workers\", \"present\", \"present_or_copy\", \"pcopy\",\n\t\"present_or_copyin\", \"pcopyin\", \"present_or_copyout\", \"pcopyout\",\n\t\"present_or_create\", \"pcreate\", \"vector_length\", \"wait\".\n\t(OACC_DATA_CLAUSE_MASK, OACC_ENTER_DATA_CLAUSE_MASK)\n\t(OACC_EXIT_DATA_CLAUSE_MASK, OACC_KERNELS_CLAUSE_MASK)\n\t(OACC_LOOP_CLAUSE_MASK, OACC_PARALLEL_CLAUSE_MASK)\n\t(OACC_UPDATE_CLAUSE_MASK, OACC_WAIT_CLAUSE_MASK): New macros.\n\t(cp_parser_omp_var_list_no_open): Handle OMP_CLAUSE__CACHE_.\n\t(cp_parser_oacc_data_clause, cp_parser_oacc_data_clause_deviceptr)\n\t(cp_parser_oacc_clause_vector_length, cp_parser_oacc_wait_list)\n\t(cp_parser_oacc_clause_wait, cp_parser_omp_clause_num_gangs)\n\t(cp_parser_omp_clause_num_workers, cp_parser_oacc_clause_async)\n\t(cp_parser_oacc_all_clauses, cp_parser_oacc_cache)\n\t(cp_parser_oacc_data, cp_parser_oacc_enter_exit_data)\n\t(cp_parser_oacc_kernels, cp_parser_oacc_loop)\n\t(cp_parser_oacc_parallel, cp_parser_oacc_update)\n\t(cp_parser_oacc_wait): New functions.\n\t* cp-tree.h (finish_oacc_data, finish_oacc_kernels)\n\t(finish_oacc_parallel): New prototypes.\n\t* semantics.c: Include \"gomp-constants.h\".\n\t(handle_omp_array_sections): Handle GOMP_MAP_FORCE_DEVICEPTR.  Use\n\tGOMP_MAP_* instead of OMP_CLAUSE_MAP_*.  Use\n\tOMP_CLAUSE_SET_MAP_KIND.\n\t(finish_omp_clauses): Handle OMP_CLAUSE_ASYNC,\n\tOMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_WAIT, OMP_CLAUSE__CACHE_.\n\tUse GOMP_MAP_* instead of OMP_CLAUSE_MAP_*.\n\t(finish_oacc_data, finish_oacc_kernels, finish_oacc_parallel): New\n\tfunctions.\n\tgcc/fortran/\n\t* lang.opt (fopenacc): New option.\n\t* cpp.c (cpp_define_builtins): Conditionally define _OPENACC.\n\t* dump-parse-tree.c (show_omp_node): Split part of it into...\n\t(show_omp_clauses): ... this new function.\n\t(show_omp_node, show_code_node): Handle EXEC_OACC_PARALLEL_LOOP,\n\tEXEC_OACC_PARALLEL, EXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS,\n\tEXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,\n\tEXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,\n\tEXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.\n\t(show_namespace): Update for OpenACC.\n\t* f95-lang.c (DEF_FUNCTION_TYPE_VAR_2, DEF_FUNCTION_TYPE_VAR_8)\n\t(DEF_FUNCTION_TYPE_VAR_12, DEF_GOACC_BUILTIN)\n\t(DEF_GOACC_BUILTIN_COMPILER): New macros.\n\t* types.def (BT_FN_VOID_INT_INT_VAR)\n\t(BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR)\n\t(BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR):\n\tNew function types.\n\t* gfortran.h (gfc_statement): Add ST_OACC_PARALLEL_LOOP,\n\tST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL, ST_OACC_END_PARALLEL,\n\tST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_DATA,\n\tST_OACC_END_DATA, ST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA,\n\tST_OACC_LOOP, ST_OACC_END_LOOP, ST_OACC_DECLARE, ST_OACC_UPDATE,\n\tST_OACC_WAIT, ST_OACC_CACHE, ST_OACC_KERNELS_LOOP,\n\tST_OACC_END_KERNELS_LOOP, ST_OACC_ENTER_DATA, ST_OACC_EXIT_DATA,\n\tST_OACC_ROUTINE.\n\t(struct gfc_expr_list): New data type.\n\t(gfc_get_expr_list): New macro.\n\t(gfc_omp_map_op): Add OMP_MAP_FORCE_ALLOC, OMP_MAP_FORCE_DEALLOC,\n\tOMP_MAP_FORCE_TO, OMP_MAP_FORCE_FROM, OMP_MAP_FORCE_TOFROM,\n\tOMP_MAP_FORCE_PRESENT, OMP_MAP_FORCE_DEVICEPTR.\n\t(OMP_LIST_FIRST, OMP_LIST_DEVICE_RESIDENT, OMP_LIST_USE_DEVICE)\n\t(OMP_LIST_CACHE): New enumerators.\n\t(struct gfc_omp_clauses): Add async_expr, gang_expr, worker_expr,\n\tvector_expr, num_gangs_expr, num_workers_expr, vector_length_expr,\n\twait_list, tile_list, async, gang, worker, vector, seq,\n\tindependent, wait, par_auto, gang_static, and loc members.\n\t(struct gfc_namespace): Add oacc_declare_clauses member.\n\t(gfc_exec_op): Add EXEC_OACC_KERNELS_LOOP,\n\tEXEC_OACC_PARALLEL_LOOP, EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS,\n\tEXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,\n\tEXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,\n\tEXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.\n\t(gfc_free_expr_list, gfc_resolve_oacc_directive)\n\t(gfc_resolve_oacc_declare, gfc_resolve_oacc_parallel_loop_blocks)\n\t(gfc_resolve_oacc_blocks): New prototypes.\n\t* match.c (match_exit_cycle): Handle EXEC_OACC_LOOP and\n\tEXEC_OACC_PARALLEL_LOOP.\n\t* match.h (gfc_match_oacc_cache, gfc_match_oacc_wait)\n\t(gfc_match_oacc_update, gfc_match_oacc_declare)\n\t(gfc_match_oacc_loop, gfc_match_oacc_host_data)\n\t(gfc_match_oacc_data, gfc_match_oacc_kernels)\n\t(gfc_match_oacc_kernels_loop, gfc_match_oacc_parallel)\n\t(gfc_match_oacc_parallel_loop, gfc_match_oacc_enter_data)\n\t(gfc_match_oacc_exit_data, gfc_match_oacc_routine): New\n\tprototypes.\n\t* openmp.c: Include \"diagnostic.h\" and \"gomp-constants.h\".\n\t(gfc_free_omp_clauses): Update for members added to struct\n\tgfc_omp_clauses.\n\t(gfc_match_omp_clauses): Change mask paramter to uint64_t.  Add\n\topenacc parameter.\n\t(resolve_omp_clauses): Add openacc parameter.  Update for OpenACC.\n\t(struct fortran_omp_context): Add is_openmp member.\n\t(gfc_resolve_omp_parallel_blocks): Initialize it.\n\t(gfc_resolve_do_iterator): Update for OpenACC.\n\t(gfc_resolve_omp_directive): Call\n\tresolve_omp_directive_inside_oacc_region.\n\t(OMP_CLAUSE_PRIVATE, OMP_CLAUSE_FIRSTPRIVATE)\n\t(OMP_CLAUSE_LASTPRIVATE, OMP_CLAUSE_COPYPRIVATE)\n\t(OMP_CLAUSE_SHARED, OMP_CLAUSE_COPYIN, OMP_CLAUSE_REDUCTION)\n\t(OMP_CLAUSE_IF, OMP_CLAUSE_NUM_THREADS, OMP_CLAUSE_SCHEDULE)\n\t(OMP_CLAUSE_DEFAULT, OMP_CLAUSE_ORDERED, OMP_CLAUSE_COLLAPSE)\n\t(OMP_CLAUSE_UNTIED, OMP_CLAUSE_FINAL, OMP_CLAUSE_MERGEABLE)\n\t(OMP_CLAUSE_ALIGNED, OMP_CLAUSE_DEPEND, OMP_CLAUSE_INBRANCH)\n\t(OMP_CLAUSE_LINEAR, OMP_CLAUSE_NOTINBRANCH, OMP_CLAUSE_PROC_BIND)\n\t(OMP_CLAUSE_SAFELEN, OMP_CLAUSE_SIMDLEN, OMP_CLAUSE_UNIFORM)\n\t(OMP_CLAUSE_DEVICE, OMP_CLAUSE_MAP, OMP_CLAUSE_TO)\n\t(OMP_CLAUSE_FROM, OMP_CLAUSE_NUM_TEAMS, OMP_CLAUSE_THREAD_LIMIT)\n\t(OMP_CLAUSE_DIST_SCHEDULE): Use uint64_t.\n\t(OMP_CLAUSE_ASYNC, OMP_CLAUSE_NUM_GANGS, OMP_CLAUSE_NUM_WORKERS)\n\t(OMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_COPY, OMP_CLAUSE_COPYOUT)\n\t(OMP_CLAUSE_CREATE, OMP_CLAUSE_PRESENT)\n\t(OMP_CLAUSE_PRESENT_OR_COPY, OMP_CLAUSE_PRESENT_OR_COPYIN)\n\t(OMP_CLAUSE_PRESENT_OR_COPYOUT, OMP_CLAUSE_PRESENT_OR_CREATE)\n\t(OMP_CLAUSE_DEVICEPTR, OMP_CLAUSE_GANG, OMP_CLAUSE_WORKER)\n\t(OMP_CLAUSE_VECTOR, OMP_CLAUSE_SEQ, OMP_CLAUSE_INDEPENDENT)\n\t(OMP_CLAUSE_USE_DEVICE, OMP_CLAUSE_DEVICE_RESIDENT)\n\t(OMP_CLAUSE_HOST_SELF, OMP_CLAUSE_OACC_DEVICE, OMP_CLAUSE_WAIT)\n\t(OMP_CLAUSE_DELETE, OMP_CLAUSE_AUTO, OMP_CLAUSE_TILE): New macros.\n\t(gfc_match_omp_clauses): Handle those.\n\t(OACC_PARALLEL_CLAUSES, OACC_KERNELS_CLAUSES, OACC_DATA_CLAUSES)\n\t(OACC_LOOP_CLAUSES, OACC_PARALLEL_LOOP_CLAUSES)\n\t(OACC_KERNELS_LOOP_CLAUSES, OACC_HOST_DATA_CLAUSES)\n\t(OACC_DECLARE_CLAUSES, OACC_UPDATE_CLAUSES)\n\t(OACC_ENTER_DATA_CLAUSES, OACC_EXIT_DATA_CLAUSES)\n\t(OACC_WAIT_CLAUSES): New macros.\n\t(gfc_free_expr_list, match_oacc_expr_list, match_oacc_clause_gang)\n\t(gfc_match_omp_map_clause, gfc_match_oacc_parallel_loop)\n\t(gfc_match_oacc_parallel, gfc_match_oacc_kernels_loop)\n\t(gfc_match_oacc_kernels, gfc_match_oacc_data)\n\t(gfc_match_oacc_host_data, gfc_match_oacc_loop)\n\t(gfc_match_oacc_declare, gfc_match_oacc_update)\n\t(gfc_match_oacc_enter_data, gfc_match_oacc_exit_data)\n\t(gfc_match_oacc_wait, gfc_match_oacc_cache)\n\t(gfc_match_oacc_routine, oacc_is_loop)\n\t(resolve_oacc_scalar_int_expr, resolve_oacc_positive_int_expr)\n\t(check_symbol_not_pointer, check_array_not_assumed)\n\t(resolve_oacc_data_clauses, resolve_oacc_deviceptr_clause)\n\t(oacc_compatible_clauses, oacc_is_parallel, oacc_is_kernels)\n\t(omp_code_to_statement, oacc_code_to_statement)\n\t(resolve_oacc_directive_inside_omp_region)\n\t(resolve_omp_directive_inside_oacc_region)\n\t(resolve_oacc_nested_loops, resolve_oacc_params_in_parallel)\n\t(resolve_oacc_loop_blocks, gfc_resolve_oacc_blocks)\n\t(resolve_oacc_loop, resolve_oacc_cache, gfc_resolve_oacc_declare)\n\t(gfc_resolve_oacc_directive): New functions.\n\t* parse.c (next_free): Update for OpenACC.  Move some code into...\n\t(verify_token_free): ... this new function.\n\t(next_fixed): Update for OpenACC.  Move some code into...\n\t(verify_token_fixed): ... this new function.\n\t(case_executable): Add ST_OACC_UPDATE, ST_OACC_WAIT,\n\tST_OACC_CACHE, ST_OACC_ENTER_DATA, and ST_OACC_EXIT_DATA.\n\t(case_exec_markers): Add ST_OACC_PARALLEL_LOOP, ST_OACC_PARALLEL,\n\tST_OACC_KERNELS, ST_OACC_DATA, ST_OACC_HOST_DATA, ST_OACC_LOOP,\n\tST_OACC_KERNELS_LOOP.\n\t(case_decl): Add ST_OACC_ROUTINE.\n\t(push_state, parse_critical_block, parse_progunit): Update for\n\tOpenACC.\n\t(gfc_ascii_statement): Handle ST_OACC_PARALLEL_LOOP,\n\tST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL, ST_OACC_END_PARALLEL,\n\tST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_KERNELS_LOOP,\n\tST_OACC_END_KERNELS_LOOP, ST_OACC_DATA, ST_OACC_END_DATA,\n\tST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA, ST_OACC_LOOP,\n\tST_OACC_END_LOOP, ST_OACC_DECLARE, ST_OACC_UPDATE, ST_OACC_WAIT,\n\tST_OACC_CACHE, ST_OACC_ENTER_DATA, ST_OACC_EXIT_DATA,\n\tST_OACC_ROUTINE.\n\t(verify_st_order, parse_spec): Handle ST_OACC_DECLARE.\n\t(parse_executable): Handle ST_OACC_PARALLEL_LOOP,\n\tST_OACC_KERNELS_LOOP, ST_OACC_LOOP, ST_OACC_PARALLEL,\n\tST_OACC_KERNELS, ST_OACC_DATA, ST_OACC_HOST_DATA.\n\t(decode_oacc_directive, parse_oacc_structured_block)\n\t(parse_oacc_loop, is_oacc): New functions.\n\t* parse.h (struct gfc_state_data): Add oacc_declare_clauses\n\tmember.\n\t(is_oacc): New prototype.\n\t* resolve.c (gfc_resolve_blocks, gfc_resolve_code): Handle\n\tEXEC_OACC_PARALLEL_LOOP, EXEC_OACC_PARALLEL,\n\tEXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS, EXEC_OACC_DATA,\n\tEXEC_OACC_HOST_DATA, EXEC_OACC_LOOP, EXEC_OACC_UPDATE,\n\tEXEC_OACC_WAIT, EXEC_OACC_CACHE, EXEC_OACC_ENTER_DATA,\n\tEXEC_OACC_EXIT_DATA.\n\t(resolve_codes): Call gfc_resolve_oacc_declare.\n\t* scanner.c (openacc_flag, openacc_locus): New variables.\n\t(skip_free_comments): Update for OpenACC.  Move some code into...\n\t(skip_omp_attribute): ... this new function.\n\t(skip_oacc_attribute): New function.\n\t(skip_fixed_comments, gfc_next_char_literal): Update for OpenACC.\n\t* st.c (gfc_free_statement): Handle EXEC_OACC_PARALLEL_LOOP,\n\tEXEC_OACC_PARALLEL, EXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS,\n\tEXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,\n\tEXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,\n\tEXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.\n\t* trans-decl.c (gfc_generate_function_code): Update for OpenACC.\n\t* trans-openmp.c: Include \"gomp-constants.h\".\n\t(gfc_omp_finish_clause, gfc_trans_omp_clauses): Use GOMP_MAP_*\n\tinstead of OMP_CLAUSE_MAP_*.  Use OMP_CLAUSE_SET_MAP_KIND.\n\t(gfc_trans_omp_clauses): Handle OMP_LIST_USE_DEVICE,\n\tOMP_LIST_DEVICE_RESIDENT, OMP_LIST_CACHE, and OMP_MAP_FORCE_ALLOC,\n\tOMP_MAP_FORCE_DEALLOC, OMP_MAP_FORCE_TO, OMP_MAP_FORCE_FROM,\n\tOMP_MAP_FORCE_TOFROM, OMP_MAP_FORCE_PRESENT,\n\tOMP_MAP_FORCE_DEVICEPTR, and gfc_omp_clauses' async, seq,\n\tindependent, wait_list, num_gangs_expr, num_workers_expr,\n\tvector_length_expr, vector, vector_expr, worker, worker_expr,\n\tgang, gang_expr members.\n\t(gfc_trans_omp_do): Handle EXEC_OACC_LOOP.\n\t(gfc_convert_expr_to_tree, gfc_trans_oacc_construct)\n\t(gfc_trans_oacc_executable_directive)\n\t(gfc_trans_oacc_wait_directive, gfc_trans_oacc_combined_directive)\n\t(gfc_trans_oacc_declare, gfc_trans_oacc_directive): New functions.\n\t* trans-stmt.c (gfc_trans_block_construct): Update for OpenACC.\n\t* trans-stmt.h (gfc_trans_oacc_directive, gfc_trans_oacc_declare):\n\tNew prototypes.\n\t* trans.c (tranc_code): Handle EXEC_OACC_CACHE, EXEC_OACC_WAIT,\n\tEXEC_OACC_UPDATE, EXEC_OACC_LOOP, EXEC_OACC_HOST_DATA,\n\tEXEC_OACC_DATA, EXEC_OACC_KERNELS, EXEC_OACC_KERNELS_LOOP,\n\tEXEC_OACC_PARALLEL, EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_ENTER_DATA,\n\tEXEC_OACC_EXIT_DATA.\n\t* gfortran.texi: Update for OpenACC.\n\t* intrinsic.texi: Likewise.\n\t* invoke.texi: Likewise.\n\tgcc/lto/\n\t* lto-lang.c (DEF_FUNCTION_TYPE_VAR_8, DEF_FUNCTION_TYPE_VAR_12):\n\tNew macros.\n\t* lto.c: Include \"gomp-constants.h\".\n\tgcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_fopenacc): New\n\tprocedure.\n\t* g++.dg/goacc-gomp/goacc-gomp.exp: New file.\n\t* g++.dg/goacc/goacc.exp: Likewise.\n\t* gcc.dg/goacc-gomp/goacc-gomp.exp: Likewise.\n\t* gcc.dg/goacc/goacc.exp: Likewise.\n\t* gfortran.dg/goacc/goacc.exp: Likewise.\n\t* c-c++-common/cpp/openacc-define-1.c: New file.\n\t* c-c++-common/cpp/openacc-define-2.c: Likewise.\n\t* c-c++-common/cpp/openacc-define-3.c: Likewise.\n\t* c-c++-common/goacc-gomp/nesting-1.c: Likewise.\n\t* c-c++-common/goacc-gomp/nesting-fail-1.c: Likewise.\n\t* c-c++-common/goacc/acc_on_device-2-off.c: Likewise.\n\t* c-c++-common/goacc/acc_on_device-2.c: Likewise.\n\t* c-c++-common/goacc/asyncwait-1.c: Likewise.\n\t* c-c++-common/goacc/cache-1.c: Likewise.\n\t* c-c++-common/goacc/clauses-fail.c: Likewise.\n\t* c-c++-common/goacc/collapse-1.c: Likewise.\n\t* c-c++-common/goacc/data-1.c: Likewise.\n\t* c-c++-common/goacc/data-2.c: Likewise.\n\t* c-c++-common/goacc/data-clause-duplicate-1.c: Likewise.\n\t* c-c++-common/goacc/deviceptr-1.c: Likewise.\n\t* c-c++-common/goacc/deviceptr-2.c: Likewise.\n\t* c-c++-common/goacc/deviceptr-3.c: Likewise.\n\t* c-c++-common/goacc/if-clause-1.c: Likewise.\n\t* c-c++-common/goacc/if-clause-2.c: Likewise.\n\t* c-c++-common/goacc/kernels-1.c: Likewise.\n\t* c-c++-common/goacc/loop-1.c: Likewise.\n\t* c-c++-common/goacc/loop-private-1.c: Likewise.\n\t* c-c++-common/goacc/nesting-1.c: Likewise.\n\t* c-c++-common/goacc/nesting-data-1.c: Likewise.\n\t* c-c++-common/goacc/nesting-fail-1.c: Likewise.\n\t* c-c++-common/goacc/parallel-1.c: Likewise.\n\t* c-c++-common/goacc/pcopy.c: Likewise.\n\t* c-c++-common/goacc/pcopyin.c: Likewise.\n\t* c-c++-common/goacc/pcopyout.c: Likewise.\n\t* c-c++-common/goacc/pcreate.c: Likewise.\n\t* c-c++-common/goacc/pragma_context.c: Likewise.\n\t* c-c++-common/goacc/present-1.c: Likewise.\n\t* c-c++-common/goacc/reduction-1.c: Likewise.\n\t* c-c++-common/goacc/reduction-2.c: Likewise.\n\t* c-c++-common/goacc/reduction-3.c: Likewise.\n\t* c-c++-common/goacc/reduction-4.c: Likewise.\n\t* c-c++-common/goacc/sb-1.c: Likewise.\n\t* c-c++-common/goacc/sb-2.c: Likewise.\n\t* c-c++-common/goacc/sb-3.c: Likewise.\n\t* c-c++-common/goacc/update-1.c: Likewise.\n\t* gcc.dg/goacc/acc_on_device-1.c: Likewise.\n\t* gfortran.dg/goacc/acc_on_device-1.f95: Likewise.\n\t* gfortran.dg/goacc/acc_on_device-2-off.f95: Likewise.\n\t* gfortran.dg/goacc/acc_on_device-2.f95: Likewise.\n\t* gfortran.dg/goacc/assumed.f95: Likewise.\n\t* gfortran.dg/goacc/asyncwait-1.f95: Likewise.\n\t* gfortran.dg/goacc/asyncwait-2.f95: Likewise.\n\t* gfortran.dg/goacc/asyncwait-3.f95: Likewise.\n\t* gfortran.dg/goacc/asyncwait-4.f95: Likewise.\n\t* gfortran.dg/goacc/branch.f95: Likewise.\n\t* gfortran.dg/goacc/cache-1.f95: Likewise.\n\t* gfortran.dg/goacc/coarray.f95: Likewise.\n\t* gfortran.dg/goacc/continuation-free-form.f95: Likewise.\n\t* gfortran.dg/goacc/cray.f95: Likewise.\n\t* gfortran.dg/goacc/critical.f95: Likewise.\n\t* gfortran.dg/goacc/data-clauses.f95: Likewise.\n\t* gfortran.dg/goacc/data-tree.f95: Likewise.\n\t* gfortran.dg/goacc/declare-1.f95: Likewise.\n\t* gfortran.dg/goacc/enter-exit-data.f95: Likewise.\n\t* gfortran.dg/goacc/fixed-1.f: Likewise.\n\t* gfortran.dg/goacc/fixed-2.f: Likewise.\n\t* gfortran.dg/goacc/fixed-3.f: Likewise.\n\t* gfortran.dg/goacc/fixed-4.f: Likewise.\n\t* gfortran.dg/goacc/host_data-tree.f95: Likewise.\n\t* gfortran.dg/goacc/if.f95: Likewise.\n\t* gfortran.dg/goacc/kernels-tree.f95: Likewise.\n\t* gfortran.dg/goacc/list.f95: Likewise.\n\t* gfortran.dg/goacc/literal.f95: Likewise.\n\t* gfortran.dg/goacc/loop-1.f95: Likewise.\n\t* gfortran.dg/goacc/loop-2.f95: Likewise.\n\t* gfortran.dg/goacc/loop-3.f95: Likewise.\n\t* gfortran.dg/goacc/loop-tree-1.f90: Likewise.\n\t* gfortran.dg/goacc/omp.f95: Likewise.\n\t* gfortran.dg/goacc/parallel-kernels-clauses.f95: Likewise.\n\t* gfortran.dg/goacc/parallel-kernels-regions.f95: Likewise.\n\t* gfortran.dg/goacc/parallel-tree.f95: Likewise.\n\t* gfortran.dg/goacc/parameter.f95: Likewise.\n\t* gfortran.dg/goacc/private-1.f95: Likewise.\n\t* gfortran.dg/goacc/private-2.f95: Likewise.\n\t* gfortran.dg/goacc/private-3.f95: Likewise.\n\t* gfortran.dg/goacc/pure-elemental-procedures.f95: Likewise.\n\t* gfortran.dg/goacc/reduction-2.f95: Likewise.\n\t* gfortran.dg/goacc/reduction.f95: Likewise.\n\t* gfortran.dg/goacc/routine-1.f90: Likewise.\n\t* gfortran.dg/goacc/routine-2.f90: Likewise.\n\t* gfortran.dg/goacc/sentinel-free-form.f95: Likewise.\n\t* gfortran.dg/goacc/several-directives.f95: Likewise.\n\t* gfortran.dg/goacc/sie.f95: Likewise.\n\t* gfortran.dg/goacc/subarrays.f95: Likewise.\n\t* gfortran.dg/gomp/map-1.f90: Likewise.\n\t* gfortran.dg/openacc-define-1.f90: Likewise.\n\t* gfortran.dg/openacc-define-2.f90: Likewise.\n\t* gfortran.dg/openacc-define-3.f90: Likewise.\n\t* g++.dg/gomp/block-1.C: Update for changed compiler output.\n\t* g++.dg/gomp/block-2.C: Likewise.\n\t* g++.dg/gomp/block-3.C: Likewise.\n\t* g++.dg/gomp/block-5.C: Likewise.\n\t* g++.dg/gomp/target-1.C: Likewise.\n\t* g++.dg/gomp/target-2.C: Likewise.\n\t* g++.dg/gomp/taskgroup-1.C: Likewise.\n\t* g++.dg/gomp/teams-1.C: Likewise.\n\t* gcc.dg/cilk-plus/jump-openmp.c: Likewise.\n\t* gcc.dg/cilk-plus/jump.c: Likewise.\n\t* gcc.dg/gomp/block-1.c: Likewise.\n\t* gcc.dg/gomp/block-10.c: Likewise.\n\t* gcc.dg/gomp/block-2.c: Likewise.\n\t* gcc.dg/gomp/block-3.c: Likewise.\n\t* gcc.dg/gomp/block-4.c: Likewise.\n\t* gcc.dg/gomp/block-5.c: Likewise.\n\t* gcc.dg/gomp/block-6.c: Likewise.\n\t* gcc.dg/gomp/block-7.c: Likewise.\n\t* gcc.dg/gomp/block-8.c: Likewise.\n\t* gcc.dg/gomp/block-9.c: Likewise.\n\t* gcc.dg/gomp/target-1.c: Likewise.\n\t* gcc.dg/gomp/target-2.c: Likewise.\n\t* gcc.dg/gomp/taskgroup-1.c: Likewise.\n\t* gcc.dg/gomp/teams-1.c: Likewise.\n\tinclude/\n\t* gomp-constants.h: New file.\n\tlibgomp/\n\t* Makefile.am (search_path): Add $(top_srcdir)/../include.\n\t(libgomp_la_SOURCES): Add splay-tree.c, libgomp-plugin.c,\n\toacc-parallel.c, oacc-host.c, oacc-init.c, oacc-mem.c,\n\toacc-async.c, oacc-plugin.c, oacc-cuda.c.\n\t[USE_FORTRAN] (libgomp_la_SOURCES): Add openacc.f90.\n\tInclude $(top_srcdir)/plugin/Makefrag.am.\n\t(nodist_libsubinclude_HEADERS): Add openacc.h.\n\t[USE_FORTRAN] (nodist_finclude_HEADERS): Add openacc_lib.h,\n\topenacc.f90, openacc.mod, openacc_kinds.mod.\n\t(omp_lib.mod): Generalize into...\n\t(%.mod): ... this new rule.\n\t(openacc_kinds.mod, openacc.mod): New rules.\n\t* plugin/configfrag.ac: New file.\n\t* configure.ac: Move plugin/offloading support into it.  Include\n\tit.  Instantiate testsuite/libgomp-test-support.pt.exp.\n\t* plugin/Makefrag.am: New file.\n\t* testsuite/Makefile.am (OFFLOAD_TARGETS)\n\t(OFFLOAD_ADDITIONAL_OPTIONS, OFFLOAD_ADDITIONAL_LIB_PATHS): Don't\n\texport.\n\t(libgomp-test-support.exp): New rule.\n\t(all-local): Depend on it.\n\t* Makefile.in: Regenerate.\n\t* testsuite/Makefile.in: Regenerate.\n\t* config.h.in: Likewise.\n\t* configure: Likewise.\n\t* configure.tgt: Harden shell syntax.\n\t* env.c: Include \"oacc-int.h\".\n\t(parse_acc_device_type): New function.\n\t(gomp_debug_var, goacc_device_type, goacc_device_num): New\n\tvariables.\n\t(initialize_env): Initialize those.  Call\n\tgoacc_runtime_initialize.\n\t* error.c (gomp_vdebug, gomp_debug, gomp_vfatal): New functions.\n\t(gomp_fatal): Call gomp_vfatal.\n\t* libgomp.h: Include \"libgomp-plugin.h\" and <stdarg.h>.\n\t(gomp_debug_var, goacc_device_type, goacc_device_num, gomp_vdebug)\n\t(gomp_debug, gomp_verror, gomp_vfatal, gomp_init_targets_once)\n\t(splay_tree_node, splay_tree, splay_tree_key)\n\t(struct target_mem_desc, struct splay_tree_key_s)\n\t(struct gomp_memory_mapping, struct acc_dispatch_t)\n\t(struct gomp_device_descr, gomp_acc_insert_pointer)\n\t(gomp_acc_remove_pointer, target_mem_desc, gomp_copy_from_async)\n\t(gomp_unmap_vars, gomp_init_device, gomp_init_tables)\n\t(gomp_free_memmap, gomp_fini_device): New declarations.\n\t(gomp_vdebug, gomp_debug): New macros.\n\tInclude \"splay-tree.h\".\n\t* libgomp.map (OACC_2.0): New symbol version.  Use for\n\tacc_get_num_devices, acc_get_num_devices_h_, acc_set_device_type,\n\tacc_set_device_type_h_, acc_get_device_type,\n\tacc_get_device_type_h_, acc_set_device_num, acc_set_device_num_h_,\n\tacc_get_device_num, acc_get_device_num_h_, acc_async_test,\n\tacc_async_test_h_, acc_async_test_all, acc_async_test_all_h_,\n\tacc_wait, acc_wait_h_, acc_wait_async, acc_wait_async_h_,\n\tacc_wait_all, acc_wait_all_h_, acc_wait_all_async,\n\tacc_wait_all_async_h_, acc_init, acc_init_h_, acc_shutdown,\n\tacc_shutdown_h_, acc_on_device, acc_on_device_h_, acc_malloc,\n\tacc_free, acc_copyin, acc_copyin_32_h_, acc_copyin_64_h_,\n\tacc_copyin_array_h_, acc_present_or_copyin,\n\tacc_present_or_copyin_32_h_, acc_present_or_copyin_64_h_,\n\tacc_present_or_copyin_array_h_, acc_create, acc_create_32_h_,\n\tacc_create_64_h_, acc_create_array_h_, acc_present_or_create,\n\tacc_present_or_create_32_h_, acc_present_or_create_64_h_,\n\tacc_present_or_create_array_h_, acc_copyout, acc_copyout_32_h_,\n\tacc_copyout_64_h_, acc_copyout_array_h_, acc_delete,\n\tacc_delete_32_h_, acc_delete_64_h_, acc_delete_array_h_,\n\tacc_update_device, acc_update_device_32_h_,\n\tacc_update_device_64_h_, acc_update_device_array_h_,\n\tacc_update_self, acc_update_self_32_h_, acc_update_self_64_h_,\n\tacc_update_self_array_h_, acc_map_data, acc_unmap_data,\n\tacc_deviceptr, acc_hostptr, acc_is_present, acc_is_present_32_h_,\n\tacc_is_present_64_h_, acc_is_present_array_h_,\n\tacc_memcpy_to_device, acc_memcpy_from_device,\n\tacc_get_current_cuda_device, acc_get_current_cuda_context,\n\tacc_get_cuda_stream, acc_set_cuda_stream.\n\t(GOACC_2.0): New symbol version.  Use for GOACC_data_end,\n\tGOACC_data_start, GOACC_enter_exit_data, GOACC_parallel,\n\tGOACC_update, GOACC_wait, GOACC_get_thread_num,\n\tGOACC_get_num_threads.\n\t(GOMP_PLUGIN_1.0): New symbol version.  Use for\n\tGOMP_PLUGIN_malloc, GOMP_PLUGIN_malloc_cleared,\n\tGOMP_PLUGIN_realloc, GOMP_PLUGIN_debug, GOMP_PLUGIN_error,\n\tGOMP_PLUGIN_fatal, GOMP_PLUGIN_async_unmap_vars,\n\tGOMP_PLUGIN_acc_thread.\n\t* libgomp.texi: Update for OpenACC changes, and GOMP_DEBUG\n\tenvironment variable.\n\t* libgomp_g.h (GOACC_data_start, GOACC_data_end)\n\t(GOACC_enter_exit_data, GOACC_parallel, GOACC_update, GOACC_wait)\n\t(GOACC_get_num_threads, GOACC_get_thread_num): New declarations.\n\t* splay-tree.h (splay_tree_lookup, splay_tree_insert)\n\t(splay_tree_remove): New declarations.\n\t(rotate_left, rotate_right, splay_tree_splay, splay_tree_insert)\n\t(splay_tree_remove, splay_tree_lookup): Move into...\n\t* splay-tree.c: ... this new file.\n\t* target.c: Include \"oacc-plugin.h\", \"oacc-int.h\", <assert.h>.\n\t(splay_tree_node, splay_tree, splay_tree_key)\n\t(struct target_mem_desc, struct splay_tree_key_s)\n\t(struct gomp_device_descr): Don't declare.\n\t(num_devices_openmp): New variable.\n\t(gomp_get_num_devices ): Use it.\n\t(gomp_init_targets_once): New function.\n\t(gomp_get_num_devices ): Use it.\n\t(get_kind, gomp_copy_from_async, gomp_free_memmap)\n\t(gomp_fini_device, gomp_register_image_for_device): New functions.\n\t(gomp_map_vars): Add devaddrs parameter.\n\t(gomp_update): Add mm parameter.\n\t(gomp_init_device): Move most of it into...\n\t(gomp_init_tables): ... this new function.\n\t(gomp_register_images_for_device): Remove function.\n\t(splay_compare, gomp_map_vars, gomp_unmap_vars, gomp_init_device):\n\tMake them hidden instead of static.\n\t(gomp_map_vars_existing, gomp_map_vars, gomp_unmap_vars)\n\t(gomp_update, gomp_init_device, GOMP_target, GOMP_target_data)\n\t(GOMP_target_end_data, GOMP_target_update)\n\t(gomp_load_plugin_for_device, gomp_target_init): Update for\n\tOpenACC changes.\n\t* oacc-async.c: New file.\n\t* oacc-cuda.c: Likewise.\n\t* oacc-host.c: Likewise.\n\t* oacc-init.c: Likewise.\n\t* oacc-int.h: Likewise.\n\t* oacc-mem.c: Likewise.\n\t* oacc-parallel.c: Likewise.\n\t* oacc-plugin.c: Likewise.\n\t* oacc-plugin.h: Likewise.\n\t* oacc-ptx.h: Likewise.\n\t* openacc.f90: Likewise.\n\t* openacc.h: Likewise.\n\t* openacc_lib.h: Likewise.\n\t* plugin/plugin-host.c: Likewise.\n\t* plugin/plugin-nvptx.c: Likewise.\n\t* libgomp-plugin.c: Likewise.\n\t* libgomp-plugin.h: Likewise.\n\t* libgomp_target.h: Remove file after merging content into the\n\tformer file.  Update all users.\n\t* testsuite/lib/libgomp.exp: Load libgomp-test-support.exp.\n\t(offload_targets_s, offload_targets_s_openacc): New variables.\n\t(check_effective_target_openacc_nvidia_accel_present)\n\t(check_effective_target_openacc_nvidia_accel_selected): New\n\tprocedures.\n\t(libgomp_init): Update for OpenACC changes.\n\t* testsuite/libgomp-test-support.exp.in: New file.\n\t* testsuite/libgomp.oacc-c++/c++.exp: Likewise.\n\t* testsuite/libgomp.oacc-c/c.exp: Likewise.\n\t* testsuite/libgomp.oacc-fortran/fortran.exp: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/abort-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/abort-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/abort-3.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/abort-4.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_on_device-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/asyncwait-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/cache-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/clauses-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/clauses-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/collapse-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/collapse-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/collapse-3.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/collapse-4.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/context-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/context-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/context-3.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/context-4.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-3.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-already-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-already-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-already-3.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-already-4.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-already-5.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-already-6.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-already-7.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/data-already-8.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/deviceptr-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/if-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/kernels-empty.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-10.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-11.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-12.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-13.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-14.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-15.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-16.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-17.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-18.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-19.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-20.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-21.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-22.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-23.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-24.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-25.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-26.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-27.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-28.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-29.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-3.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-30.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-31.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-32.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-33.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-34.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-35.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-36.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-37.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-38.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-39.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-4.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-40.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-41.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-42.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-43.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-44.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-45.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-46.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-47.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-48.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-49.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-5.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-50.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-51.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-52.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-53.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-54.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-55.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-56.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-57.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-58.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-59.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-6.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-60.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-61.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-62.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-63.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-64.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-65.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-66.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-67.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-68.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-69.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-7.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-70.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-71.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-72.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-73.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-74.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-75.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-76.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-77.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-78.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-79.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-80.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-81.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-82.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-83.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-84.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-85.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-86.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-87.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-88.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-89.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-9.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-90.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-91.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/lib-92.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/nested-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/nested-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/offset-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/parallel-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/parallel-empty.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/pointer-align-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/present-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/present-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/reduction-1.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/reduction-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/reduction-3.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/reduction-4.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/reduction-5.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/reduction-initial-1.c:\n\tLikewise.\n\t* testsuite/libgomp.oacc-c-c++-common/subr.h: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/subr.ptx: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/timer.h: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/update-1-2.c: Likewise.\n\t* testsuite/libgomp.oacc-c-c++-common/update-1.c: Likewise.\n\t* testsuite/libgomp.oacc-fortran/abort-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/abort-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/acc_on_device-1-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/acc_on_device-1-2.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/acc_on_device-1-3.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/asyncwait-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/asyncwait-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/asyncwait-3.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/collapse-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/collapse-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/collapse-3.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/collapse-4.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/collapse-5.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/collapse-6.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/collapse-7.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/collapse-8.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-3.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-4-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-4.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-already-1.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-already-2.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-already-3.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-already-4.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-already-5.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-already-6.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-already-7.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/data-already-8.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/lib-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/lib-10.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/lib-2.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/lib-3.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/lib-4.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/lib-5.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/lib-6.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/lib-7.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/lib-8.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/map-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/openacc_version-1.f: Likewise.\n\t* testsuite/libgomp.oacc-fortran/openacc_version-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/pointer-align-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/pset-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/reduction-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/reduction-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/reduction-3.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/reduction-4.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/reduction-5.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/reduction-6.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/routine-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/routine-2.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/routine-3.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/routine-4.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/subarrays-1.f90: Likewise.\n\t* testsuite/libgomp.oacc-fortran/subarrays-2.f90: Likewise.\n\tliboffloadmic/\n\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_get_name)\n\t(GOMP_OFFLOAD_get_caps, GOMP_OFFLOAD_fini_device): New functions.\n\nCo-Authored-By: Bernd Schmidt <bernds@codesourcery.com>\nCo-Authored-By: Cesar Philippidis <cesar@codesourcery.com>\nCo-Authored-By: Dmitry Bocharnikov <dmitry.b@samsung.com>\nCo-Authored-By: Evgeny Gavrin <e.gavrin@samsung.com>\nCo-Authored-By: Ilmir Usmanov <i.usmanov@samsung.com>\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\nCo-Authored-By: James Norris <jnorris@codesourcery.com>\nCo-Authored-By: Julian Brown <julian@codesourcery.com>\nCo-Authored-By: Nathan Sidwell <nathan@codesourcery.com>\nCo-Authored-By: Tobias Burnus <burnus@net-b.de>\nCo-Authored-By: Tom de Vries <tom@codesourcery.com>\n\nFrom-SVN: r219682", "tree": {"sha": "97a0bb274cc7583206397ba37ab5c0bbe01cb04d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97a0bb274cc7583206397ba37ab5c0bbe01cb04d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41dbbb3789850dfea98dd8984f69806284f87b6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41dbbb3789850dfea98dd8984f69806284f87b6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41dbbb3789850dfea98dd8984f69806284f87b6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41dbbb3789850dfea98dd8984f69806284f87b6e/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "96a87981994da859c17259d8c4dccb6602476b0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96a87981994da859c17259d8c4dccb6602476b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96a87981994da859c17259d8c4dccb6602476b0e"}], "stats": {"total": 39121, "additions": 37653, "deletions": 1468}, "files": [{"sha": "f062ea9073801fc1c1e54bb64816d034cd0e004e", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,8 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* gcc_update (files_and_dependencies): Update rules for new\n+\tlibgomp/plugin/Makefrag.am and libgomp/plugin/configfrag.ac files.\n+\n 2015-01-12  Yury Gribov  <y.gribov@samsung.com>\n \n \t* check_GNU_style.sh: Support patches coming from stdin."}, {"sha": "5ba3a057bf426cec451fb26f1d11f05fad268af2", "filename": "contrib/gcc_update", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -139,8 +139,10 @@ libcpp/aclocal.m4: libcpp/configure.ac\n libcpp/Makefile.in: libcpp/configure.ac libcpp/aclocal.m4\n libcpp/configure: libcpp/configure.ac libcpp/aclocal.m4\n libgomp/aclocal.m4: libgomp/configure.ac libgomp/acinclude.m4\n+libgomp/Makefile.am: libgomp/plugin/Makefrag.am\n libgomp/Makefile.in: libgomp/Makefile.am libgomp/aclocal.m4\n libgomp/testsuite/Makefile.in: libgomp/testsuite/Makefile.am libgomp/aclocal.m4\n+libgomp/configure.ac: libgomp/plugin/configfrag.ac\n libgomp/configure: libgomp/configure.ac libgomp/aclocal.m4\n libgomp/config.h.in: libgomp/configure.ac libgomp/aclocal.m4\n libitm/aclocal.m4: libitm/configure.ac libitm/acinclude.m4"}, {"sha": "3a27df9923fd597e09847f4604cbe1a97a64ef4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,183 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\t    Ilmir Usmanov  <i.usmanov@samsung.com>\n+\t    Dmitry Bocharnikov  <dmitry.b@samsung.com>\n+\t    Evgeny Gavrin  <e.gavrin@samsung.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* builtin-types.def (BT_FN_VOID_INT_INT_VAR)\n+\t(BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR)\n+\t(BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR):\n+\tNew function types.\n+\t* builtins.c: Include \"gomp-constants.h\".\n+\t(expand_builtin_acc_on_device): New function.\n+\t(expand_builtin, is_inexpensive_builtin): Handle\n+\tBUILT_IN_ACC_ON_DEVICE.\n+\t* builtins.def (DEF_GOACC_BUILTIN, DEF_GOACC_BUILTIN_COMPILER):\n+\tNew macros.\n+\t* cgraph.c (cgraph_node::create): Consider flag_openacc next to\n+\tflag_openmp.\n+\t* config.gcc <nvptx-*> (tm_file): Add nvptx/offload.h.\n+\t<*-intelmic-* | *-intelmicemul-*> (tm_file): Add\n+\ti386/intelmic-offload.h.\n+\t* gcc.c (LINK_COMMAND_SPEC, GOMP_SELF_SPECS): For -fopenacc, link\n+\tto libgomp and its dependencies.\n+\t* config/arc/arc.h (LINK_COMMAND_SPEC): Likewise.\n+\t* config/darwin.h (LINK_COMMAND_SPEC_A): Likewise.\n+\t* config/i386/mingw32.h (GOMP_SELF_SPECS): Likewise.\n+\t* config/ia64/hpux.h (LIB_SPEC): Likewise.\n+\t* config/pa/pa-hpux11.h (LIB_SPEC): Likewise.\n+\t* config/pa/pa64-hpux.h (LIB_SPEC): Likewise.\n+\t* doc/generic.texi: Update for OpenACC changes.\n+\t* doc/gimple.texi: Likewise.\n+\t* doc/invoke.texi: Likewise.\n+\t* doc/sourcebuild.texi: Likewise.\n+\t* gimple-pretty-print.c (dump_gimple_omp_for): Handle\n+\tGF_OMP_FOR_KIND_OACC_LOOP.\n+\t(dump_gimple_omp_target): Handle GF_OMP_TARGET_KIND_OACC_KERNELS,\n+\tGF_OMP_TARGET_KIND_OACC_PARALLEL, GF_OMP_TARGET_KIND_OACC_DATA,\n+\tGF_OMP_TARGET_KIND_OACC_UPDATE,\n+\tGF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA.\n+\tDump more data.\n+\t* gimple.c: Update comments for OpenACC changes.\n+\t* gimple.def: Likewise.\n+\t* gimple.h: Likewise.\n+\t(enum gf_mask): Add GF_OMP_FOR_KIND_OACC_LOOP,\n+\tGF_OMP_TARGET_KIND_OACC_PARALLEL, GF_OMP_TARGET_KIND_OACC_KERNELS,\n+\tGF_OMP_TARGET_KIND_OACC_DATA, GF_OMP_TARGET_KIND_OACC_UPDATE,\n+\tGF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA.\n+\t(gimple_omp_for_cond, gimple_omp_for_set_cond): Sort in the\n+\tappropriate place.\n+\t(is_gimple_omp_oacc, is_gimple_omp_offloaded): New functions.\n+\t* gimplify.c: Include \"gomp-constants.h\".\n+\tUpdate comments for OpenACC changes.\n+\t(is_gimple_stmt): Handle OACC_PARALLEL, OACC_KERNELS, OACC_DATA,\n+\tOACC_HOST_DATA, OACC_DECLARE, OACC_UPDATE, OACC_ENTER_DATA,\n+\tOACC_EXIT_DATA, OACC_CACHE, OACC_LOOP.\n+\t(gimplify_scan_omp_clauses, gimplify_adjust_omp_clauses): Handle\n+\tOMP_CLAUSE__CACHE_, OMP_CLAUSE_ASYNC, OMP_CLAUSE_WAIT,\n+\tOMP_CLAUSE_NUM_GANGS, OMP_CLAUSE_NUM_WORKERS,\n+\tOMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_GANG, OMP_CLAUSE_WORKER,\n+\tOMP_CLAUSE_VECTOR, OMP_CLAUSE_DEVICE_RESIDENT,\n+\tOMP_CLAUSE_USE_DEVICE, OMP_CLAUSE_INDEPENDENT, OMP_CLAUSE_AUTO,\n+\tOMP_CLAUSE_SEQ.\n+\t(gimplify_adjust_omp_clauses_1, gimplify_adjust_omp_clauses): Use\n+\tGOMP_MAP_* instead of OMP_CLAUSE_MAP_*.  Use\n+\tOMP_CLAUSE_SET_MAP_KIND.\n+\t(gimplify_oacc_cache): New function.\n+\t(gimplify_omp_for): Handle OACC_LOOP.\n+\t(gimplify_omp_workshare): Handle OACC_KERNELS, OACC_PARALLEL,\n+\tOACC_DATA.\n+\t(gimplify_omp_target_update): Handle OACC_ENTER_DATA,\n+\tOACC_EXIT_DATA, OACC_UPDATE.\n+\t(gimplify_expr): Handle OACC_LOOP, OACC_CACHE, OACC_HOST_DATA,\n+\tOACC_DECLARE, OACC_KERNELS, OACC_PARALLEL, OACC_DATA,\n+\tOACC_ENTER_DATA, OACC_EXIT_DATA, OACC_UPDATE.\n+\t(gimplify_body): Consider flag_openacc next to flag_openmp.\n+\t* lto-streamer-out.c: Include \"gomp-constants.h\".\n+\t* omp-builtins.def (BUILT_IN_ACC_GET_DEVICE_TYPE)\n+\t(BUILT_IN_GOACC_DATA_START, BUILT_IN_GOACC_DATA_END)\n+\t(BUILT_IN_GOACC_ENTER_EXIT_DATA, BUILT_IN_GOACC_PARALLEL)\n+\t(BUILT_IN_GOACC_UPDATE, BUILT_IN_GOACC_WAIT)\n+\t(BUILT_IN_GOACC_GET_THREAD_NUM, BUILT_IN_GOACC_GET_NUM_THREADS)\n+\t(BUILT_IN_ACC_ON_DEVICE): New builtins.\n+\t* omp-low.c: Include \"gomp-constants.h\".\n+\tUpdate comments for OpenACC changes.\n+\t(struct omp_context): Add reduction_map, gwv_below, gwv_this\n+\tmembers.\n+\t(extract_omp_for_data, use_pointer_for_field, install_var_field)\n+\t(new_omp_context, delete_omp_context, scan_sharing_clauses)\n+\t(create_omp_child_function, scan_omp_for, scan_omp_target)\n+\t(check_omp_nesting_restrictions, lower_reduction_clauses)\n+\t(build_omp_regions_1, diagnose_sb_0, make_gimple_omp_edges):\n+\tUpdate for OpenACC changes.\n+\t(scan_sharing_clauses): Handle OMP_CLAUSE_NUM_GANGS:\n+\tOMP_CLAUSE_NUM_WORKERS: OMP_CLAUSE_VECTOR_LENGTH,\n+\tOMP_CLAUSE_ASYNC, OMP_CLAUSE_WAIT, OMP_CLAUSE_GANG,\n+\tOMP_CLAUSE_WORKER, OMP_CLAUSE_VECTOR, OMP_CLAUSE_DEVICE_RESIDENT,\n+\tOMP_CLAUSE_USE_DEVICE, OMP_CLAUSE__CACHE_, OMP_CLAUSE_INDEPENDENT,\n+\tOMP_CLAUSE_AUTO, OMP_CLAUSE_SEQ.  Use GOMP_MAP_* instead of\n+\tOMP_CLAUSE_MAP_*.\n+\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk):\n+\tHandle GF_OMP_FOR_KIND_OACC_LOOP.\n+\t(expand_omp_target, lower_omp_target): Handle\n+\tGF_OMP_TARGET_KIND_OACC_PARALLEL, GF_OMP_TARGET_KIND_OACC_KERNELS,\n+\tGF_OMP_TARGET_KIND_OACC_UPDATE,\n+\tGF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA,\n+\tGF_OMP_TARGET_KIND_OACC_DATA.\n+\t(pass_expand_omp::execute, execute_lower_omp)\n+\t(pass_diagnose_omp_blocks::gate): Consider flag_openacc next to\n+\tflag_openmp.\n+\t(offload_symbol_decl): New variable.\n+\t(oacc_get_reduction_array_id, oacc_max_threads)\n+\t(get_offload_symbol_decl, get_base_type, lookup_oacc_reduction)\n+\t(maybe_lookup_oacc_reduction, enclosing_target_ctx)\n+\t(oacc_loop_or_target_p, oacc_lower_reduction_var_helper)\n+\t(oacc_gimple_assign, oacc_initialize_reduction_data)\n+\t(oacc_finalize_reduction_data, oacc_process_reduction_data): New\n+\tfunctions.\n+\t(is_targetreg_ctx): Remove function.\n+\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE__CACHE_,\n+\tOMP_CLAUSE_DEVICE_RESIDENT, OMP_CLAUSE_USE_DEVICE,\n+\tOMP_CLAUSE_GANG, OMP_CLAUSE_ASYNC, OMP_CLAUSE_WAIT,\n+\tOMP_CLAUSE_AUTO, OMP_CLAUSE_SEQ, OMP_CLAUSE_INDEPENDENT,\n+\tOMP_CLAUSE_WORKER, OMP_CLAUSE_VECTOR, OMP_CLAUSE_NUM_GANGS,\n+\tOMP_CLAUSE_NUM_WORKERS, OMP_CLAUSE_VECTOR_LENGTH.\n+\t* tree.c (omp_clause_code_name, walk_tree_1): Update accordingly.\n+\t* tree.h (OMP_CLAUSE_GANG_EXPR, OMP_CLAUSE_GANG_STATIC_EXPR)\n+\t(OMP_CLAUSE_ASYNC_EXPR, OMP_CLAUSE_WAIT_EXPR)\n+\t(OMP_CLAUSE_VECTOR_EXPR, OMP_CLAUSE_WORKER_EXPR)\n+\t(OMP_CLAUSE_NUM_GANGS_EXPR, OMP_CLAUSE_NUM_WORKERS_EXPR)\n+\t(OMP_CLAUSE_VECTOR_LENGTH_EXPR): New macros.\n+\t* tree-core.h: Update comments for OpenACC changes.\n+\t(enum omp_clause_map_kind): Remove.\n+\t(struct tree_omp_clause): Change type of map_kind member from enum\n+\tomp_clause_map_kind to unsigned char.\n+\t* tree-inline.c: Update comments for OpenACC changes.\n+\t* tree-nested.c: Likewise.  Include \"gomp-constants.h\".\n+\t(convert_nonlocal_reference_stmt, convert_local_reference_stmt)\n+\t(convert_tramp_reference_stmt, convert_gimple_call): Update for\n+\tOpenACC changes.  Use GOMP_MAP_* instead of OMP_CLAUSE_MAP_*.  Use\n+\tOMP_CLAUSE_SET_MAP_KIND.\n+\t* tree-pretty-print.c: Include \"gomp-constants.h\".\n+\t(dump_omp_clause): Handle OMP_CLAUSE_DEVICE_RESIDENT,\n+\tOMP_CLAUSE_USE_DEVICE, OMP_CLAUSE__CACHE_, OMP_CLAUSE_GANG,\n+\tOMP_CLAUSE_ASYNC, OMP_CLAUSE_AUTO, OMP_CLAUSE_SEQ,\n+\tOMP_CLAUSE_WAIT, OMP_CLAUSE_WORKER, OMP_CLAUSE_VECTOR,\n+\tOMP_CLAUSE_NUM_GANGS, OMP_CLAUSE_NUM_WORKERS,\n+\tOMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_INDEPENDENT.  Use GOMP_MAP_*\n+\tinstead of OMP_CLAUSE_MAP_*.\n+\t(dump_generic_node): Handle OACC_PARALLEL, OACC_KERNELS,\n+\tOACC_DATA, OACC_HOST_DATA, OACC_DECLARE, OACC_UPDATE,\n+\tOACC_ENTER_DATA, OACC_EXIT_DATA, OACC_CACHE, OACC_LOOP.\n+\t* tree-streamer-in.c: Include \"gomp-constants.h\".\n+\t(unpack_ts_omp_clause_value_fields) Use GOMP_MAP_* instead of\n+\tOMP_CLAUSE_MAP_*.  Use OMP_CLAUSE_SET_MAP_KIND.\n+\t* tree-streamer-out.c: Include \"gomp-constants.h\".\n+\t(pack_ts_omp_clause_value_fields): Use GOMP_MAP_* instead of\n+\tOMP_CLAUSE_MAP_*.\n+\t* tree.def (OACC_PARALLEL, OACC_KERNELS, OACC_DATA)\n+\t(OACC_HOST_DATA, OACC_LOOP, OACC_CACHE, OACC_DECLARE)\n+\t(OACC_ENTER_DATA, OACC_EXIT_DATA, OACC_UPDATE): New tree codes.\n+\t* tree.c (omp_clause_num_ops): Update accordingly.\n+\t* tree.h (OMP_BODY, OMP_CLAUSES, OMP_LOOP_CHECK, OMP_CLAUSE_SIZE):\n+\tLikewise.\n+\t(OACC_PARALLEL_BODY, OACC_PARALLEL_CLAUSES, OACC_KERNELS_BODY)\n+\t(OACC_KERNELS_CLAUSES, OACC_DATA_BODY, OACC_DATA_CLAUSES)\n+\t(OACC_HOST_DATA_BODY, OACC_HOST_DATA_CLAUSES, OACC_CACHE_CLAUSES)\n+\t(OACC_DECLARE_CLAUSES, OACC_ENTER_DATA_CLAUSES)\n+\t(OACC_EXIT_DATA_CLAUSES, OACC_UPDATE_CLAUSES)\n+\t(OACC_KERNELS_COMBINED, OACC_PARALLEL_COMBINED): New macros.\n+\t* tree.h (OMP_CLAUSE_MAP_KIND): Cast it to enum gomp_map_kind.\n+\t(OMP_CLAUSE_SET_MAP_KIND): New macro.\n+\t* varpool.c (varpool_node::get_create): Consider flag_openacc next\n+\tto flag_openmp.\n+\t* config/i386/intelmic-offload.h: New file.\n+\t* config/nvptx/offload.h: Likewise.\n+\n 2015-01-15  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \t* explow.h: Remove duplicate contents."}, {"sha": "c130f7d22d439ae60a092c4b3b3159daf347618c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,8 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* gcc-interface/utils.c (DEF_FUNCTION_TYPE_VAR_8)\n+\t(DEF_FUNCTION_TYPE_VAR_12): New macros.\n+\n 2015-01-09  Michael Collison  <michael.collison@linaro.org>\n \n \t* gcc-interface/cuintp.c: Include hash-set.h, machmode.h,"}, {"sha": "477e39bf14c56aea308a5ad5f90db88b50b03b43", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -5339,6 +5339,12 @@ enum c_builtin_type\n #define DEF_FUNCTION_TYPE_VAR_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n #define DEF_FUNCTION_TYPE_VAR_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n   NAME,\n+#define DEF_FUNCTION_TYPE_VAR_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\tARG6, ARG7, ARG8)\t\t\t\\\n+  NAME,\n+#define DEF_FUNCTION_TYPE_VAR_12(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\t ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) \\\n+  NAME,\n #define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n #include \"builtin-types.def\"\n #undef DEF_PRIMITIVE_TYPE\n@@ -5357,6 +5363,8 @@ enum c_builtin_type\n #undef DEF_FUNCTION_TYPE_VAR_3\n #undef DEF_FUNCTION_TYPE_VAR_4\n #undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_FUNCTION_TYPE_VAR_8\n+#undef DEF_FUNCTION_TYPE_VAR_12\n #undef DEF_POINTER_TYPE\n   BT_LAST\n };\n@@ -5462,6 +5470,14 @@ install_builtin_function_types (void)\n   def_fn_type (ENUM, RETURN, 1, 4, ARG1, ARG2, ARG3, ARG4);\n #define DEF_FUNCTION_TYPE_VAR_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n   def_fn_type (ENUM, RETURN, 1, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n+#define DEF_FUNCTION_TYPE_VAR_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\tARG6, ARG7, ARG8)\t\t\t\\\n+  def_fn_type (ENUM, RETURN, 1, 5, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8);\n+#define DEF_FUNCTION_TYPE_VAR_12(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\t ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) \\\n+  def_fn_type (ENUM, RETURN, 1, 5, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,\t\\\n+\t       ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);\n #define DEF_POINTER_TYPE(ENUM, TYPE) \\\n   builtin_types[(int) ENUM] = build_pointer_type (builtin_types[(int) TYPE]);\n \n@@ -5483,6 +5499,8 @@ install_builtin_function_types (void)\n #undef DEF_FUNCTION_TYPE_VAR_3\n #undef DEF_FUNCTION_TYPE_VAR_4\n #undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_FUNCTION_TYPE_VAR_8\n+#undef DEF_FUNCTION_TYPE_VAR_12\n #undef DEF_POINTER_TYPE\n   builtin_types[(int) BT_LAST] = NULL_TREE;\n }"}, {"sha": "3412677ef92ab0221ea2154b5780e0979f2d7250", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -568,6 +568,8 @@ DEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_INT_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_INT, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_VAR_2 (BT_FN_PTR_CONST_PTR_SIZE_VAR, BT_PTR,\n \t\t\t BT_CONST_PTR, BT_SIZE)\n+DEF_FUNCTION_TYPE_VAR_2 (BT_FN_VOID_INT_INT_VAR, BT_VOID,\n+\t\t\t BT_INT, BT_INT)\n \n DEF_FUNCTION_TYPE_VAR_3 (BT_FN_INT_STRING_SIZE_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_STRING, BT_SIZE, BT_CONST_STRING)\n@@ -586,6 +588,15 @@ DEF_FUNCTION_TYPE_VAR_5 (BT_FN_INT_STRING_SIZE_INT_SIZE_CONST_STRING_VAR,\n DEF_FUNCTION_TYPE_VAR_5 (BT_FN_INT_INT_INT_INT_INT_INT_VAR,\n \t\t\t BT_INT, BT_INT, BT_INT, BT_INT, BT_INT, BT_INT)\n \n+DEF_FUNCTION_TYPE_VAR_8 (BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR,\n+\t\t\t BT_VOID, BT_INT, BT_PTR, BT_SIZE, BT_PTR, BT_PTR,\n+\t\t\t BT_PTR, BT_INT, BT_INT)\n+\n+DEF_FUNCTION_TYPE_VAR_12 (BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR,\n+\t\t\t  BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_PTR, BT_SIZE,\n+\t\t\t  BT_PTR, BT_PTR, BT_PTR, BT_INT, BT_INT, BT_INT,\n+\t\t\t  BT_INT, BT_INT)\n+\n DEF_POINTER_TYPE (BT_PTR_FN_VOID_VAR, BT_FN_VOID_VAR)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_FN_VOID_VAR_PTR_SIZE,\n \t\t     BT_PTR, BT_PTR_FN_VOID_VAR, BT_PTR, BT_SIZE)"}, {"sha": "9a6a11b2ce6de82db4bec4b615975d7623d6f2a1", "filename": "gcc/builtins.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -84,6 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"tree-chkp.h\"\n #include \"rtl-chkp.h\"\n+#include \"gomp-constants.h\"\n \n \n static tree do_mpc_arg1 (tree, tree, int (*)(mpc_ptr, mpc_srcptr, mpc_rnd_t));\n@@ -5903,6 +5904,47 @@ expand_stack_save (void)\n   return ret;\n }\n \n+\n+/* Expand OpenACC acc_on_device.\n+\n+   This has to happen late (that is, not in early folding; expand_builtin_*,\n+   rather than fold_builtin_*), as we have to act differently for host and\n+   acceleration device (ACCEL_COMPILER conditional).  */\n+\n+static rtx\n+expand_builtin_acc_on_device (tree exp, rtx target)\n+{\n+  if (!validate_arglist (exp, INTEGER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  tree arg = CALL_EXPR_ARG (exp, 0);\n+\n+  /* Return (arg == v1 || arg == v2) ? 1 : 0.  */\n+  machine_mode v_mode = TYPE_MODE (TREE_TYPE (arg));\n+  rtx v = expand_normal (arg), v1, v2;\n+#ifdef ACCEL_COMPILER\n+  v1 = GEN_INT (GOMP_DEVICE_NOT_HOST);\n+  v2 = GEN_INT (ACCEL_COMPILER_acc_device);\n+#else\n+  v1 = GEN_INT (GOMP_DEVICE_NONE);\n+  v2 = GEN_INT (GOMP_DEVICE_HOST);\n+#endif\n+  machine_mode target_mode = TYPE_MODE (integer_type_node);\n+  if (!REG_P (target) || GET_MODE (target) != target_mode)\n+    target = gen_reg_rtx (target_mode);\n+  emit_move_insn (target, const1_rtx);\n+  rtx_code_label *done_label = gen_label_rtx ();\n+  do_compare_rtx_and_jump (v, v1, EQ, false, v_mode, NULL_RTX,\n+\t\t\t   NULL_RTX, done_label, PROB_EVEN);\n+  do_compare_rtx_and_jump (v, v2, EQ, false, v_mode, NULL_RTX,\n+\t\t\t   NULL_RTX, done_label, PROB_EVEN);\n+  emit_move_insn (target, const0_rtx);\n+  emit_label (done_label);\n+\n+  return target;\n+}\n+\n+\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n    (and in mode MODE if that's convenient).\n@@ -7041,6 +7083,12 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       error (\"Your target platform does not support -fcheck-pointer-bounds\");\n       break;\n \n+    case BUILT_IN_ACC_ON_DEVICE:\n+      target = expand_builtin_acc_on_device (exp, target);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     default:\t/* just do library call, if unknown builtin */\n       break;\n     }\n@@ -12478,6 +12526,7 @@ is_inexpensive_builtin (tree decl)\n       case BUILT_IN_LABS:\n       case BUILT_IN_LLABS:\n       case BUILT_IN_PREFETCH:\n+      case BUILT_IN_ACC_ON_DEVICE:\n \treturn true;\n \n       default:"}, {"sha": "e3153bf8cfd0504f08b45014074e3363ef067b5c", "filename": "gcc/builtins.def", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -146,10 +146,20 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, BT_LAST, BT_LAST, false, false, \\\n \t       false, ATTR_LAST, false, false)\n \n-/* Builtin used by the implementation of GNU OpenMP.  None of these are\n-   actually implemented in the compiler; they're all in libgomp.  */\n+/* Builtin used by the implementation of OpenACC and OpenMP.  Few of these are\n+   actually implemented in the compiler; most are in libgomp.  */\n /* These builtins also need to be enabled in offloading compilers invoked from\n    mkoffload; for that purpose, we're checking the -foffload-abi flag here.  */\n+#undef DEF_GOACC_BUILTIN\n+#define DEF_GOACC_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+\t       false, true, true, ATTRS, false, \\\n+\t       (flag_openacc \\\n+\t\t|| flag_offload_abi != OFFLOAD_ABI_UNSET))\n+#undef DEF_GOACC_BUILTIN_COMPILER\n+#define DEF_GOACC_BUILTIN_COMPILER(ENUM, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+\t       flag_openacc, true, true, ATTRS, false, true)\n #undef DEF_GOMP_BUILTIN\n #define DEF_GOMP_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n@@ -897,7 +907,7 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n /* Synchronization Primitives.  */\n #include \"sync-builtins.def\"\n \n-/* OpenMP builtins.  */\n+/* Offloading and Multi Processing builtins.  */\n #include \"omp-builtins.def\"\n \n /* Cilk keywords builtins.  */"}, {"sha": "e0ad21506adbd5d91493e1e01b315ad6f2c7c0a4", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,41 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Bernd Schmidt  <bernds@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Ilmir Usmanov  <i.usmanov@samsung.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c.opt (fopenacc): New option.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Conditionally define _OPENACC.\n+\t* c-common.c (DEF_FUNCTION_TYPE_VAR_8, DEF_FUNCTION_TYPE_VAR_12):\n+\tNew macros.\n+\t* c-common.h (c_finish_oacc_wait): New prototype.\n+\t* c-omp.c: Include \"omp-low.h\" and \"gomp-constants.h\".\n+\t(c_finish_oacc_wait): New function.\n+\t* c-pragma.c (oacc_pragmas): New variable.\n+\t(c_pp_lookup_pragma, init_pragma): Handle it.\n+\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OACC_CACHE,\n+\tPRAGMA_OACC_DATA, PRAGMA_OACC_ENTER_DATA, PRAGMA_OACC_EXIT_DATA,\n+\tPRAGMA_OACC_KERNELS, PRAGMA_OACC_LOOP, PRAGMA_OACC_PARALLEL,\n+\tPRAGMA_OACC_UPDATE, PRAGMA_OACC_WAIT.\n+\t(enum pragma_omp_clause): Add PRAGMA_OACC_CLAUSE_ASYNC,\n+\tPRAGMA_OACC_CLAUSE_AUTO, PRAGMA_OACC_CLAUSE_COLLAPSE,\n+\tPRAGMA_OACC_CLAUSE_COPY, PRAGMA_OACC_CLAUSE_COPYIN,\n+\tPRAGMA_OACC_CLAUSE_COPYOUT, PRAGMA_OACC_CLAUSE_CREATE,\n+\tPRAGMA_OACC_CLAUSE_DELETE, PRAGMA_OACC_CLAUSE_DEVICE,\n+\tPRAGMA_OACC_CLAUSE_DEVICEPTR, PRAGMA_OACC_CLAUSE_FIRSTPRIVATE,\n+\tPRAGMA_OACC_CLAUSE_GANG, PRAGMA_OACC_CLAUSE_HOST,\n+\tPRAGMA_OACC_CLAUSE_IF, PRAGMA_OACC_CLAUSE_NUM_GANGS,\n+\tPRAGMA_OACC_CLAUSE_NUM_WORKERS, PRAGMA_OACC_CLAUSE_PRESENT,\n+\tPRAGMA_OACC_CLAUSE_PRESENT_OR_COPY,\n+\tPRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN,\n+\tPRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT,\n+\tPRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE, PRAGMA_OACC_CLAUSE_PRIVATE,\n+\tPRAGMA_OACC_CLAUSE_REDUCTION, PRAGMA_OACC_CLAUSE_SELF,\n+\tPRAGMA_OACC_CLAUSE_SEQ, PRAGMA_OACC_CLAUSE_VECTOR,\n+\tPRAGMA_OACC_CLAUSE_VECTOR_LENGTH, PRAGMA_OACC_CLAUSE_WAIT,\n+\tPRAGMA_OACC_CLAUSE_WORKER.\n+\n 2015-01-14  Marcos Diaz <marcos.diaz@tallertechnologies.com>\n \n \t* c-cppbuiltin.c (c_cpp_builtins): New cpp define __SSP_EXPLICIT__"}, {"sha": "eb132c537feed823f0013bda992b2cd539c2507b", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -5234,6 +5234,11 @@ enum c_builtin_type\n #define DEF_FUNCTION_TYPE_VAR_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n #define DEF_FUNCTION_TYPE_VAR_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n   NAME,\n+#define DEF_FUNCTION_TYPE_VAR_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\tARG6, ARG7, ARG8) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_12(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\t ARG6, ARG7, ARG8, ARG9, ARG10, ARG11,       \\\n+\t\t\t\t ARG12) NAME,\n #define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n #include \"builtin-types.def\"\n #undef DEF_PRIMITIVE_TYPE\n@@ -5252,6 +5257,8 @@ enum c_builtin_type\n #undef DEF_FUNCTION_TYPE_VAR_3\n #undef DEF_FUNCTION_TYPE_VAR_4\n #undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_FUNCTION_TYPE_VAR_8\n+#undef DEF_FUNCTION_TYPE_VAR_12\n #undef DEF_POINTER_TYPE\n   BT_LAST\n };\n@@ -5344,6 +5351,14 @@ c_define_builtins (tree va_list_ref_type_node, tree va_list_arg_type_node)\n   def_fn_type (ENUM, RETURN, 1, 4, ARG1, ARG2, ARG3, ARG4);\n #define DEF_FUNCTION_TYPE_VAR_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n   def_fn_type (ENUM, RETURN, 1, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n+#define DEF_FUNCTION_TYPE_VAR_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\tARG6, ARG7, ARG8)\t\t\t    \\\n+  def_fn_type (ENUM, RETURN, 1, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,      \\\n+\t       ARG7, ARG8);\n+#define DEF_FUNCTION_TYPE_VAR_12(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\t ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) \\\n+  def_fn_type (ENUM, RETURN, 1, 12, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,      \\\n+\t       ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);\n #define DEF_POINTER_TYPE(ENUM, TYPE) \\\n   builtin_types[(int) ENUM] = build_pointer_type (builtin_types[(int) TYPE]);\n \n@@ -5365,6 +5380,8 @@ c_define_builtins (tree va_list_ref_type_node, tree va_list_arg_type_node)\n #undef DEF_FUNCTION_TYPE_VAR_3\n #undef DEF_FUNCTION_TYPE_VAR_4\n #undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_FUNCTION_TYPE_VAR_8\n+#undef DEF_FUNCTION_TYPE_VAR_12\n #undef DEF_POINTER_TYPE\n   builtin_types[(int) BT_LAST] = NULL_TREE;\n "}, {"sha": "5b2c5ab9c71856b56ec6534d733c428037182d6c", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1248,6 +1248,7 @@ extern void c_finish_omp_taskwait (location_t);\n extern void c_finish_omp_taskyield (location_t);\n extern tree c_finish_omp_for (location_t, enum tree_code, tree, tree, tree,\n \t\t\t      tree, tree, tree);\n+extern tree c_finish_oacc_wait (location_t, tree, tree);\n extern void c_omp_split_clauses (location_t, enum tree_code, omp_clause_mask,\n \t\t\t\t tree, tree *);\n extern tree c_omp_declare_simd_clauses_to_numbers (tree, tree);"}, {"sha": "19365920a86e2d23454fb1986ab599f0be362595", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1221,6 +1221,9 @@ c_cpp_builtins (cpp_reader *pfile)\n   else if (flag_stack_protect == 1)\n     cpp_define (pfile, \"__SSP__=1\");\n \n+  if (flag_openacc)\n+    cpp_define (pfile, \"_OPENACC=201306\");\n+\n   if (flag_openmp)\n     cpp_define (pfile, \"_OPENMP=201307\");\n "}, {"sha": "87150459f81405d839f8485afabf19d261e6d2ea", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,4 +1,4 @@\n-/* This file contains routines to construct GNU OpenMP constructs,\n+/* This file contains routines to construct OpenACC and OpenMP constructs,\n    called from parsing in the C and C++ front ends.\n \n    Copyright (C) 2005-2015 Free Software Foundation, Inc.\n@@ -39,8 +39,48 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-pragma.h\"\n #include \"gimple-expr.h\"\n #include \"langhooks.h\"\n+#include \"omp-low.h\"\n+#include \"gomp-constants.h\"\n \n \n+/* Complete a #pragma oacc wait construct.  LOC is the location of\n+   the #pragma.  */\n+\n+tree\n+c_finish_oacc_wait (location_t loc, tree parms, tree clauses)\n+{\n+  const int nparms = list_length (parms);\n+  tree stmt, t;\n+  vec<tree, va_gc> *args;\n+\n+  vec_alloc (args, nparms + 2);\n+  stmt = builtin_decl_explicit (BUILT_IN_GOACC_WAIT);\n+\n+  if (find_omp_clause (clauses, OMP_CLAUSE_ASYNC))\n+    t = OMP_CLAUSE_ASYNC_EXPR (clauses);\n+  else\n+    t = build_int_cst (integer_type_node, GOMP_ASYNC_SYNC);\n+\n+  args->quick_push (t);\n+  args->quick_push (build_int_cst (integer_type_node, nparms));\n+\n+  for (t = parms; t; t = TREE_CHAIN (t))\n+    {\n+      if (TREE_CODE (OMP_CLAUSE_WAIT_EXPR (t)) == INTEGER_CST)\n+\targs->quick_push (build_int_cst (integer_type_node,\n+\t\t\tTREE_INT_CST_LOW (OMP_CLAUSE_WAIT_EXPR (t))));\n+      else\n+\targs->quick_push (OMP_CLAUSE_WAIT_EXPR (t));\n+    }\n+\n+  stmt = build_call_expr_loc_vec (loc, stmt, args);\n+  add_stmt (stmt);\n+\n+  vec_free (args);\n+\n+  return stmt;\n+}\n+\n /* Complete a #pragma omp master construct.  STMT is the structured-block\n    that follows the pragma.  LOC is the l*/\n \n@@ -303,7 +343,7 @@ c_finish_omp_flush (location_t loc)\n }\n \n \n-/* Check and canonicalize #pragma omp for increment expression.\n+/* Check and canonicalize OMP_FOR increment expression.\n    Helper function for c_finish_omp_for.  */\n \n static tree\n@@ -391,7 +431,7 @@ c_omp_for_incr_canonicalize_ptr (location_t loc, tree decl, tree incr)\n   return incr;\n }\n \n-/* Validate and emit code for the OpenMP directive #pragma omp for.\n+/* Validate and generate OMP_FOR.\n    DECLV is a vector of iteration variables, for each collapsed loop.\n    INITV, CONDV and INCRV are vectors containing initialization\n    expressions, controlling predicates and increment expressions."}, {"sha": "718a310cf50158b3daf9ea9bc0defd43200339c5", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1190,6 +1190,17 @@ typedef struct\n static vec<pragma_ns_name> registered_pp_pragmas;\n \n struct omp_pragma_def { const char *name; unsigned int id; };\n+static const struct omp_pragma_def oacc_pragmas[] = {\n+  { \"cache\", PRAGMA_OACC_CACHE },\n+  { \"data\", PRAGMA_OACC_DATA },\n+  { \"enter\", PRAGMA_OACC_ENTER_DATA },\n+  { \"exit\", PRAGMA_OACC_EXIT_DATA },\n+  { \"kernels\", PRAGMA_OACC_KERNELS },\n+  { \"loop\", PRAGMA_OACC_LOOP },\n+  { \"parallel\", PRAGMA_OACC_PARALLEL },\n+  { \"update\", PRAGMA_OACC_UPDATE },\n+  { \"wait\", PRAGMA_OACC_WAIT }\n+};\n static const struct omp_pragma_def omp_pragmas[] = {\n   { \"atomic\", PRAGMA_OMP_ATOMIC },\n   { \"barrier\", PRAGMA_OMP_BARRIER },\n@@ -1222,11 +1233,20 @@ static const struct omp_pragma_def omp_pragmas_simd[] = {\n void\n c_pp_lookup_pragma (unsigned int id, const char **space, const char **name)\n {\n+  const int n_oacc_pragmas = sizeof (oacc_pragmas) / sizeof (*oacc_pragmas);\n   const int n_omp_pragmas = sizeof (omp_pragmas) / sizeof (*omp_pragmas);\n   const int n_omp_pragmas_simd = sizeof (omp_pragmas_simd)\n \t\t\t\t / sizeof (*omp_pragmas);\n   int i;\n \n+  for (i = 0; i < n_oacc_pragmas; ++i)\n+    if (oacc_pragmas[i].id == id)\n+      {\n+\t*space = \"acc\";\n+\t*name = oacc_pragmas[i].name;\n+\treturn;\n+      }\n+\n   for (i = 0; i < n_omp_pragmas; ++i)\n     if (omp_pragmas[i].id == id)\n       {\n@@ -1393,6 +1413,17 @@ c_invoke_pragma_handler (unsigned int id)\n void\n init_pragma (void)\n {\n+  if (flag_openacc)\n+    {\n+      const int n_oacc_pragmas\n+\t= sizeof (oacc_pragmas) / sizeof (*oacc_pragmas);\n+      int i;\n+\n+      for (i = 0; i < n_oacc_pragmas; ++i)\n+\tcpp_register_deferred_pragma (parse_in, \"acc\", oacc_pragmas[i].name,\n+\t\t\t\t      oacc_pragmas[i].id, true, true);\n+    }\n+\n   if (flag_openmp)\n     {\n       const int n_omp_pragmas = sizeof (omp_pragmas) / sizeof (*omp_pragmas);"}, {"sha": "eff94c114835d9dd346c78fa8b6ce06a9bbb798f", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -27,6 +27,15 @@ along with GCC; see the file COPYING3.  If not see\n typedef enum pragma_kind {\n   PRAGMA_NONE = 0,\n \n+  PRAGMA_OACC_CACHE,\n+  PRAGMA_OACC_DATA,\n+  PRAGMA_OACC_ENTER_DATA,\n+  PRAGMA_OACC_EXIT_DATA,\n+  PRAGMA_OACC_KERNELS,\n+  PRAGMA_OACC_LOOP,\n+  PRAGMA_OACC_PARALLEL,\n+  PRAGMA_OACC_UPDATE,\n+  PRAGMA_OACC_WAIT,\n   PRAGMA_OMP_ATOMIC,\n   PRAGMA_OMP_BARRIER,\n   PRAGMA_OMP_CANCEL,\n@@ -65,7 +74,7 @@ typedef enum pragma_kind {\n } pragma_kind;\n \n \n-/* All clauses defined by OpenMP 2.5, 3.0, 3.1 and 4.0.\n+/* All clauses defined by OpenACC 2.0, and OpenMP 2.5, 3.0, 3.1, and 4.0.\n    Used internally by both C and C++ parsers.  */\n typedef enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_NONE = 0,\n@@ -118,7 +127,38 @@ typedef enum pragma_omp_clause {\n   PRAGMA_CILK_CLAUSE_FIRSTPRIVATE = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE,\n   PRAGMA_CILK_CLAUSE_LASTPRIVATE = PRAGMA_OMP_CLAUSE_LASTPRIVATE,\n   PRAGMA_CILK_CLAUSE_REDUCTION = PRAGMA_OMP_CLAUSE_REDUCTION,\n-  PRAGMA_CILK_CLAUSE_UNIFORM = PRAGMA_OMP_CLAUSE_UNIFORM\n+  PRAGMA_CILK_CLAUSE_UNIFORM = PRAGMA_OMP_CLAUSE_UNIFORM,\n+\n+  /* Clauses for OpenACC.  */\n+  PRAGMA_OACC_CLAUSE_ASYNC = PRAGMA_CILK_CLAUSE_VECTORLENGTH + 1,\n+  PRAGMA_OACC_CLAUSE_AUTO,\n+  PRAGMA_OACC_CLAUSE_COPY,\n+  PRAGMA_OACC_CLAUSE_COPYOUT,\n+  PRAGMA_OACC_CLAUSE_CREATE,\n+  PRAGMA_OACC_CLAUSE_DELETE,\n+  PRAGMA_OACC_CLAUSE_DEVICEPTR,\n+  PRAGMA_OACC_CLAUSE_GANG,\n+  PRAGMA_OACC_CLAUSE_HOST,\n+  PRAGMA_OACC_CLAUSE_NUM_GANGS,\n+  PRAGMA_OACC_CLAUSE_NUM_WORKERS,\n+  PRAGMA_OACC_CLAUSE_PRESENT,\n+  PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY,\n+  PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN,\n+  PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT,\n+  PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE,\n+  PRAGMA_OACC_CLAUSE_SELF,\n+  PRAGMA_OACC_CLAUSE_SEQ,\n+  PRAGMA_OACC_CLAUSE_VECTOR,\n+  PRAGMA_OACC_CLAUSE_VECTOR_LENGTH,\n+  PRAGMA_OACC_CLAUSE_WAIT,\n+  PRAGMA_OACC_CLAUSE_WORKER,\n+  PRAGMA_OACC_CLAUSE_COLLAPSE = PRAGMA_OMP_CLAUSE_COLLAPSE,\n+  PRAGMA_OACC_CLAUSE_COPYIN = PRAGMA_OMP_CLAUSE_COPYIN,\n+  PRAGMA_OACC_CLAUSE_DEVICE = PRAGMA_OMP_CLAUSE_DEVICE,\n+  PRAGMA_OACC_CLAUSE_FIRSTPRIVATE = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE,\n+  PRAGMA_OACC_CLAUSE_IF = PRAGMA_OMP_CLAUSE_IF,\n+  PRAGMA_OACC_CLAUSE_PRIVATE = PRAGMA_OMP_CLAUSE_PRIVATE,\n+  PRAGMA_OACC_CLAUSE_REDUCTION = PRAGMA_OMP_CLAUSE_REDUCTION\n } pragma_omp_clause;\n \n extern struct cpp_reader* parse_in;"}, {"sha": "62b6c68576d94d3cc59457be5f526a28169ecac3", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1283,6 +1283,10 @@ fobjc-std=objc1\n ObjC ObjC++ Var(flag_objc1_only)\n Conform to the Objective-C 1.0 language as implemented in GCC 4.0\n \n+fopenacc\n+C ObjC C++ ObjC++ Var(flag_openacc)\n+Enable OpenACC\n+\n fopenmp\n C ObjC C++ ObjC++ Var(flag_openmp)\n Enable OpenMP (implies -frecursive in Fortran)"}, {"sha": "46524098eef9db3206a5a0d2ffeda4a8f613e400", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,54 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\t    Ilmir Usmanov  <i.usmanov@samsung.com>\n+\n+\t* c-parser.c: Include \"gomp-constants.h\".\n+\t(c_parser_omp_clause_map): Use enum gomp_map_kind instead of enum\n+\tomp_clause_map_kind.  Use GOMP_MAP_* instead of OMP_CLAUSE_MAP_*.\n+\tUse OMP_CLAUSE_SET_MAP_KIND.\n+\t(c_parser_pragma): Handle PRAGMA_OACC_ENTER_DATA,\n+\tPRAGMA_OACC_EXIT_DATA, PRAGMA_OACC_UPDATE.\n+\t(c_parser_omp_construct): Handle PRAGMA_OACC_CACHE,\n+\tPRAGMA_OACC_DATA, PRAGMA_OACC_KERNELS, PRAGMA_OACC_LOOP,\n+\tPRAGMA_OACC_PARALLEL, PRAGMA_OACC_WAIT.\n+\t(c_parser_omp_clause_name): Handle \"auto\", \"async\", \"copy\",\n+\t\"copyout\", \"create\", \"delete\", \"deviceptr\", \"gang\", \"host\",\n+\t\"num_gangs\", \"num_workers\", \"present\", \"present_or_copy\", \"pcopy\",\n+\t\"present_or_copyin\", \"pcopyin\", \"present_or_copyout\", \"pcopyout\",\n+\t\"present_or_create\", \"pcreate\", \"seq\", \"self\", \"vector\",\n+\t\"vector_length\", \"wait\", \"worker\".\n+\t(OACC_DATA_CLAUSE_MASK, OACC_KERNELS_CLAUSE_MASK)\n+\t(OACC_ENTER_DATA_CLAUSE_MASK, OACC_EXIT_DATA_CLAUSE_MASK)\n+\t(OACC_LOOP_CLAUSE_MASK, OACC_PARALLEL_CLAUSE_MASK)\n+\t(OACC_UPDATE_CLAUSE_MASK, OACC_WAIT_CLAUSE_MASK): New macros.\n+\t(c_parser_omp_variable_list): Handle OMP_CLAUSE__CACHE_.\n+\t(c_parser_oacc_wait_list, c_parser_oacc_data_clause)\n+\t(c_parser_oacc_data_clause_deviceptr)\n+\t(c_parser_omp_clause_num_gangs, c_parser_omp_clause_num_workers)\n+\t(c_parser_oacc_clause_async, c_parser_oacc_clause_wait)\n+\t(c_parser_omp_clause_vector_length, c_parser_oacc_all_clauses)\n+\t(c_parser_oacc_cache, c_parser_oacc_data, c_parser_oacc_kernels)\n+\t(c_parser_oacc_enter_exit_data, c_parser_oacc_loop)\n+\t(c_parser_oacc_parallel, c_parser_oacc_update)\n+\t(c_parser_oacc_wait): New functions.\n+\t* c-tree.h (c_finish_oacc_parallel, c_finish_oacc_kernels)\n+\t(c_finish_oacc_data): New prototypes.\n+\t* c-typeck.c: Include \"gomp-constants.h\".\n+\t(handle_omp_array_sections): Handle GOMP_MAP_FORCE_DEVICEPTR.  Use\n+\tGOMP_MAP_* instead of OMP_CLAUSE_MAP_*.  Use\n+\tOMP_CLAUSE_SET_MAP_KIND.\n+\t(c_finish_oacc_parallel, c_finish_oacc_kernels)\n+\t(c_finish_oacc_data): New functions.\n+\t(c_finish_omp_clauses): Handle OMP_CLAUSE__CACHE_,\n+\tOMP_CLAUSE_NUM_GANGS, OMP_CLAUSE_NUM_WORKERS,\n+\tOMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_ASYNC, OMP_CLAUSE_WAIT,\n+\tOMP_CLAUSE_AUTO, OMP_CLAUSE_SEQ, OMP_CLAUSE_GANG,\n+\tOMP_CLAUSE_WORKER, OMP_CLAUSE_VECTOR, and OMP_CLAUSE_MAP's\n+\tGOMP_MAP_FORCE_DEVICEPTR.\n+\n 2015-01-09  Michael Collison  <michael.collison@linaro.org>\n \n \t* c-array-notation.c: Include hash-set.h, machmode.h,"}, {"sha": "665ee42cf2ddc07f1aa27a50221d2668757d17b8", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 1028, "deletions": 30, "changes": 1058, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -81,6 +81,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"omp-low.h\"\n #include \"builtins.h\"\n+#include \"gomp-constants.h\"\n \n \f\n /* Initialization routine for this file.  */\n@@ -1249,10 +1250,15 @@ static vec<tree, va_gc> *c_parser_expr_list (c_parser *, bool, bool,\n \t\t\t\t\t     vec<tree, va_gc> **, location_t *,\n \t\t\t\t\t     tree *, vec<location_t> *,\n \t\t\t\t\t     unsigned int * = NULL);\n+static void c_parser_oacc_enter_exit_data (c_parser *, bool);\n+static void c_parser_oacc_update (c_parser *);\n+static tree c_parser_oacc_loop (location_t, c_parser *, char *);\n static void c_parser_omp_construct (c_parser *);\n static void c_parser_omp_threadprivate (c_parser *);\n static void c_parser_omp_barrier (c_parser *);\n static void c_parser_omp_flush (c_parser *);\n+static tree c_parser_omp_for_loop (location_t, c_parser *, enum tree_code,\n+\t\t\t\t   tree, tree *);\n static void c_parser_omp_taskwait (c_parser *);\n static void c_parser_omp_taskyield (c_parser *);\n static void c_parser_omp_cancel (c_parser *);\n@@ -4492,6 +4498,14 @@ c_parser_initval (c_parser *parser, struct c_expr *after,\n    Although they are erroneous if the labels declared aren't defined,\n    is it useful for the syntax to be this way?\n \n+   OpenACC:\n+\n+   block-item:\n+     openacc-directive\n+\n+   openacc-directive:\n+     update-directive\n+\n    OpenMP:\n \n    block-item:\n@@ -4838,6 +4852,29 @@ c_parser_label (c_parser *parser)\n      @throw expression ;\n      @throw ;\n \n+   OpenACC:\n+\n+   statement:\n+     openacc-construct\n+\n+   openacc-construct:\n+     parallel-construct\n+     kernels-construct\n+     data-construct\n+     loop-construct\n+\n+   parallel-construct:\n+     parallel-directive structured-block\n+\n+   kernels-construct:\n+     kernels-directive structured-block\n+\n+   data-construct:\n+     data-directive structured-block\n+\n+   loop-construct:\n+     loop-directive structured-block\n+\n    OpenMP:\n \n    statement:\n@@ -9570,6 +9607,25 @@ c_parser_pragma (c_parser *parser, enum pragma_context context)\n \n   switch (id)\n     {\n+    case PRAGMA_OACC_ENTER_DATA:\n+      c_parser_oacc_enter_exit_data (parser, true);\n+      return false;\n+\n+    case PRAGMA_OACC_EXIT_DATA:\n+      c_parser_oacc_enter_exit_data (parser, false);\n+      return false;\n+\n+    case PRAGMA_OACC_UPDATE:\n+      if (context != pragma_compound)\n+\t{\n+\t  if (context == pragma_stmt)\n+\t    c_parser_error (parser, \"%<#pragma acc update%> may only be \"\n+\t\t\t    \"used in compound statements\");\n+\t  goto bad_stmt;\n+\t}\n+      c_parser_oacc_update (parser);\n+      return false;\n+\n     case PRAGMA_OMP_BARRIER:\n       if (context != pragma_compound)\n \t{\n@@ -9772,7 +9828,7 @@ c_parser_pragma_pch_preprocess (c_parser *parser)\n     c_common_pch_pragma (parse_in, TREE_STRING_POINTER (name));\n }\n \f\n-/* OpenMP 2.5 / 3.0 / 3.1 / 4.0 parsing routines.  */\n+/* OpenACC and OpenMP parsing routines.  */\n \n /* Returns name of the next clause.\n    If the clause is not recognized PRAGMA_OMP_CLAUSE_NONE is returned and\n@@ -9784,7 +9840,9 @@ c_parser_omp_clause_name (c_parser *parser)\n {\n   pragma_omp_clause result = PRAGMA_OMP_CLAUSE_NONE;\n \n-  if (c_parser_next_token_is_keyword (parser, RID_IF))\n+  if (c_parser_next_token_is_keyword (parser, RID_AUTO))\n+    result = PRAGMA_OACC_CLAUSE_AUTO;\n+  else if (c_parser_next_token_is_keyword (parser, RID_IF))\n     result = PRAGMA_OMP_CLAUSE_IF;\n   else if (c_parser_next_token_is_keyword (parser, RID_DEFAULT))\n     result = PRAGMA_OMP_CLAUSE_DEFAULT;\n@@ -9799,20 +9857,32 @@ c_parser_omp_clause_name (c_parser *parser)\n \tcase 'a':\n \t  if (!strcmp (\"aligned\", p))\n \t    result = PRAGMA_OMP_CLAUSE_ALIGNED;\n+\t  else if (!strcmp (\"async\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_ASYNC;\n \t  break;\n \tcase 'c':\n \t  if (!strcmp (\"collapse\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COLLAPSE;\n+\t  else if (!strcmp (\"copy\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_COPY;\n \t  else if (!strcmp (\"copyin\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COPYIN;\n+\t  else if (!strcmp (\"copyout\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_COPYOUT;\n           else if (!strcmp (\"copyprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;\n+\t  else if (!strcmp (\"create\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_CREATE;\n \t  break;\n \tcase 'd':\n-\t  if (!strcmp (\"depend\", p))\n+\t  if (!strcmp (\"delete\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_DELETE;\n+\t  else if (!strcmp (\"depend\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEPEND;\n \t  else if (!strcmp (\"device\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEVICE;\n+\t  else if (!strcmp (\"deviceptr\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_DEVICEPTR;\n \t  else if (!strcmp (\"dist_schedule\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DIST_SCHEDULE;\n \t  break;\n@@ -9824,6 +9894,14 @@ c_parser_omp_clause_name (c_parser *parser)\n \t  else if (!strcmp (\"from\", p))\n \t    result = PRAGMA_OMP_CLAUSE_FROM;\n \t  break;\n+\tcase 'g':\n+\t  if (!strcmp (\"gang\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_GANG;\n+\t  break;\n+\tcase 'h':\n+\t  if (!strcmp (\"host\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_HOST;\n+\t  break;\n \tcase 'i':\n \t  if (!strcmp (\"inbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_INBRANCH;\n@@ -9847,10 +9925,14 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_NOTINBRANCH;\n \t  else if (!strcmp (\"nowait\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOWAIT;\n+\t  else if (!strcmp (\"num_gangs\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_NUM_GANGS;\n \t  else if (!strcmp (\"num_teams\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NUM_TEAMS;\n \t  else if (!strcmp (\"num_threads\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NUM_THREADS;\n+\t  else if (!strcmp (\"num_workers\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_NUM_WORKERS;\n \t  else if (flag_cilkplus && !strcmp (\"nomask\", p))\n \t    result = PRAGMA_CILK_CLAUSE_NOMASK;\n \t  break;\n@@ -9861,6 +9943,20 @@ c_parser_omp_clause_name (c_parser *parser)\n \tcase 'p':\n \t  if (!strcmp (\"parallel\", p))\n \t    result = PRAGMA_OMP_CLAUSE_PARALLEL;\n+\t  else if (!strcmp (\"present\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_PRESENT;\n+\t  else if (!strcmp (\"present_or_copy\", p)\n+\t\t   || !strcmp (\"pcopy\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY;\n+\t  else if (!strcmp (\"present_or_copyin\", p)\n+\t\t   || !strcmp (\"pcopyin\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN;\n+\t  else if (!strcmp (\"present_or_copyout\", p)\n+\t\t   || !strcmp (\"pcopyout\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT;\n+\t  else if (!strcmp (\"present_or_create\", p)\n+\t\t   || !strcmp (\"pcreate\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE;\n \t  else if (!strcmp (\"private\", p))\n \t    result = PRAGMA_OMP_CLAUSE_PRIVATE;\n \t  else if (!strcmp (\"proc_bind\", p))\n@@ -9877,10 +9973,14 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_SCHEDULE;\n \t  else if (!strcmp (\"sections\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SECTIONS;\n+\t  else if (!strcmp (\"seq\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_SEQ;\n \t  else if (!strcmp (\"shared\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SHARED;\n \t  else if (!strcmp (\"simdlen\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SIMDLEN;\n+\t  else if (!strcmp (\"self\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_SELF;\n \t  break;\n \tcase 't':\n \t  if (!strcmp (\"taskgroup\", p))\n@@ -9897,9 +9997,19 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_UNTIED;\n \t  break;\n \tcase 'v':\n-\t  if (flag_cilkplus && !strcmp (\"vectorlength\", p))\n+\t  if (!strcmp (\"vector\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_VECTOR;\n+\t  else if (!strcmp (\"vector_length\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_VECTOR_LENGTH;\n+\t  else if (flag_cilkplus && !strcmp (\"vectorlength\", p))\n \t    result = PRAGMA_CILK_CLAUSE_VECTORLENGTH;\n \t  break;\n+\tcase 'w':\n+\t  if (!strcmp (\"wait\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_WAIT;\n+\t  else if (!strcmp (\"worker\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_WORKER;\n+\t  break;\n \t}\n     }\n \n@@ -9926,7 +10036,57 @@ check_no_duplicate_clause (tree clauses, enum omp_clause_code code,\n       }\n }\n \n-/* OpenMP 2.5:\n+/* OpenACC 2.0\n+   Parse wait clause or wait directive parameters.  */\n+\n+static tree\n+c_parser_oacc_wait_list (c_parser *parser, location_t clause_loc, tree list)\n+{\n+  vec<tree, va_gc> *args;\n+  tree t, args_tree;\n+\n+  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    return list;\n+\n+  args = c_parser_expr_list (parser, false, true, NULL, NULL, NULL, NULL);\n+\n+  if (args->length () == 0)\n+    {\n+      c_parser_error (parser, \"expected integer expression before ')'\");\n+      release_tree_vector (args);\n+      return list;\n+    }\n+\n+  args_tree = build_tree_list_vec (args);\n+\n+  for (t = args_tree; t; t = TREE_CHAIN (t))\n+    {\n+      tree targ = TREE_VALUE (t);\n+\n+      if (targ != error_mark_node)\n+\t{\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (targ)))\n+\t    {\n+\t      c_parser_error (parser, \"expression must be integral\");\n+\t      targ = error_mark_node;\n+\t    }\n+\t  else\n+\t    {\n+\t      tree c = build_omp_clause (clause_loc, OMP_CLAUSE_WAIT);\n+\n+\t      OMP_CLAUSE_DECL (c) = targ;\n+\t      OMP_CLAUSE_CHAIN (c) = list;\n+\t      list = c;\n+\t    }\n+\t}\n+    }\n+\n+  release_tree_vector (args);\n+  c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  return list;\n+}\n+\n+/* OpenACC 2.0, OpenMP 2.5:\n    variable-list:\n      identifier\n      variable-list , identifier\n@@ -9967,6 +10127,14 @@ c_parser_omp_variable_list (c_parser *parser,\n \t{\n \t  switch (kind)\n \t    {\n+\t    case OMP_CLAUSE__CACHE_:\n+\t      if (c_parser_peek_token (parser)->type != CPP_OPEN_SQUARE)\n+\t\t{\n+\t\t  c_parser_error (parser, \"expected %<[%>\");\n+\t\t  t = error_mark_node;\n+\t\t  break;\n+\t\t}\n+\t      /* FALL THROUGH.  */\n \t    case OMP_CLAUSE_MAP:\n \t    case OMP_CLAUSE_FROM:\n \t    case OMP_CLAUSE_TO:\n@@ -10005,6 +10173,26 @@ c_parser_omp_variable_list (c_parser *parser,\n \t\t      t = error_mark_node;\n \t\t      break;\n \t\t    }\n+\n+\t\t  if (kind == OMP_CLAUSE__CACHE_)\n+\t\t    {\n+\t\t      if (TREE_CODE (low_bound) != INTEGER_CST\n+\t\t\t  && !TREE_READONLY (low_bound))\n+\t\t\t{\n+\t\t\t  error_at (clause_loc,\n+\t\t\t\t\t\"%qD is not a constant\", low_bound);\n+\t\t\t  t = error_mark_node;\n+\t\t\t}\n+\n+\t\t      if (TREE_CODE (length) != INTEGER_CST\n+\t\t\t  && !TREE_READONLY (length))\n+\t\t\t{\n+\t\t\t  error_at (clause_loc,\n+\t\t\t\t\t\"%qD is not a constant\", length);\n+\t\t\t  t = error_mark_node;\n+\t\t\t}\n+\t\t    }\n+\n \t\t  t = tree_cons (low_bound, length, t);\n \t\t}\n \t      break;\n@@ -10033,7 +10221,7 @@ c_parser_omp_variable_list (c_parser *parser,\n }\n \n /* Similarly, but expect leading and trailing parenthesis.  This is a very\n-   common case for omp clauses.  */\n+   common case for OpenACC and OpenMP clauses.  */\n \n static tree\n c_parser_omp_var_list_parens (c_parser *parser, enum omp_clause_code kind,\n@@ -10050,7 +10238,119 @@ c_parser_omp_var_list_parens (c_parser *parser, enum omp_clause_code kind,\n   return list;\n }\n \n-/* OpenMP 3.0:\n+/* OpenACC 2.0:\n+   copy ( variable-list )\n+   copyin ( variable-list )\n+   copyout ( variable-list )\n+   create ( variable-list )\n+   delete ( variable-list )\n+   present ( variable-list )\n+   present_or_copy ( variable-list )\n+     pcopy ( variable-list )\n+   present_or_copyin ( variable-list )\n+     pcopyin ( variable-list )\n+   present_or_copyout ( variable-list )\n+     pcopyout ( variable-list )\n+   present_or_create ( variable-list )\n+     pcreate ( variable-list ) */\n+\n+static tree\n+c_parser_oacc_data_clause (c_parser *parser, pragma_omp_clause c_kind,\n+\t\t\t   tree list)\n+{\n+  enum gomp_map_kind kind;\n+  switch (c_kind)\n+    {\n+    case PRAGMA_OACC_CLAUSE_COPY:\n+      kind = GOMP_MAP_FORCE_TOFROM;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_COPYIN:\n+      kind = GOMP_MAP_FORCE_TO;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_COPYOUT:\n+      kind = GOMP_MAP_FORCE_FROM;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_CREATE:\n+      kind = GOMP_MAP_FORCE_ALLOC;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_DELETE:\n+      kind = GOMP_MAP_FORCE_DEALLOC;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_DEVICE:\n+      kind = GOMP_MAP_FORCE_TO;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_HOST:\n+    case PRAGMA_OACC_CLAUSE_SELF:\n+      kind = GOMP_MAP_FORCE_FROM;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_PRESENT:\n+      kind = GOMP_MAP_FORCE_PRESENT;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY:\n+      kind = GOMP_MAP_TOFROM;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN:\n+      kind = GOMP_MAP_TO;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT:\n+      kind = GOMP_MAP_FROM;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE:\n+      kind = GOMP_MAP_ALLOC;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  tree nl, c;\n+  nl = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_MAP, list);\n+\n+  for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n+    OMP_CLAUSE_SET_MAP_KIND (c, kind);\n+\n+  return nl;\n+}\n+\n+/* OpenACC 2.0:\n+   deviceptr ( variable-list ) */\n+\n+static tree\n+c_parser_oacc_data_clause_deviceptr (c_parser *parser, tree list)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  tree vars, t;\n+\n+  /* Can't use OMP_CLAUSE_MAP here (that is, can't use the generic\n+     c_parser_oacc_data_clause), as for PRAGMA_OACC_CLAUSE_DEVICEPTR,\n+     variable-list must only allow for pointer variables.  */\n+  vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);\n+  for (t = vars; t && t; t = TREE_CHAIN (t))\n+    {\n+      tree v = TREE_PURPOSE (t);\n+\n+      /* FIXME diagnostics: Ideally we should keep individual\n+\t locations for all the variables in the var list to make the\n+\t following errors more precise.  Perhaps\n+\t c_parser_omp_var_list_parens() should construct a list of\n+\t locations to go along with the var list.  */\n+\n+      if (TREE_CODE (v) != VAR_DECL)\n+\terror_at (loc, \"%qD is not a variable\", v);\n+      else if (TREE_TYPE (v) == error_mark_node)\n+\t;\n+      else if (!POINTER_TYPE_P (TREE_TYPE (v)))\n+\terror_at (loc, \"%qD is not a pointer variable\", v);\n+\n+      tree u = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (u, GOMP_MAP_FORCE_DEVICEPTR);\n+      OMP_CLAUSE_DECL (u) = v;\n+      OMP_CLAUSE_CHAIN (u) = list;\n+      list = u;\n+    }\n+\n+  return list;\n+}\n+\n+/* OpenACC 2.0, OpenMP 3.0:\n    collapse ( constant-expression ) */\n \n static tree\n@@ -10193,7 +10493,7 @@ c_parser_omp_clause_final (c_parser *parser, tree list)\n   return list;\n }\n \n-/* OpenMP 2.5:\n+/* OpenACC, OpenMP 2.5:\n    if ( expression ) */\n \n static tree\n@@ -10261,6 +10561,51 @@ c_parser_omp_clause_nowait (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n   return c;\n }\n \n+/* OpenACC:\n+   num_gangs ( expression ) */\n+\n+static tree\n+c_parser_omp_clause_num_gangs (c_parser *parser, tree list)\n+{\n+  location_t num_gangs_loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      tree c, t = c_parser_expression (parser).value;\n+      mark_exp_read (t);\n+      t = c_fully_fold (t, false, NULL);\n+\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  c_parser_error (parser, \"expected integer expression\");\n+\t  return list;\n+\t}\n+\n+      /* Attempt to statically determine when the number isn't positive.  */\n+      c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,\n+\t\t       build_int_cst (TREE_TYPE (t), 0));\n+      if (CAN_HAVE_LOCATION_P (c))\n+\tSET_EXPR_LOCATION (c, expr_loc);\n+      if (c == boolean_true_node)\n+\t{\n+\t  warning_at (expr_loc, 0,\n+\t\t      \"%<num_gangs%> value must be positive\");\n+\t  t = integer_one_node;\n+\t}\n+\n+      check_no_duplicate_clause (list, OMP_CLAUSE_NUM_GANGS, \"num_gangs\");\n+\n+      c = build_omp_clause (num_gangs_loc, OMP_CLAUSE_NUM_GANGS);\n+      OMP_CLAUSE_NUM_GANGS_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+\n+  return list;\n+}\n+\n /* OpenMP 2.5:\n    num_threads ( expression ) */\n \n@@ -10306,6 +10651,100 @@ c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n   return list;\n }\n \n+/* OpenACC:\n+   num_workers ( expression ) */\n+\n+static tree\n+c_parser_omp_clause_num_workers (c_parser *parser, tree list)\n+{\n+  location_t num_workers_loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      tree c, t = c_parser_expression (parser).value;\n+      mark_exp_read (t);\n+      t = c_fully_fold (t, false, NULL);\n+\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  c_parser_error (parser, \"expected integer expression\");\n+\t  return list;\n+\t}\n+\n+      /* Attempt to statically determine when the number isn't positive.  */\n+      c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,\n+\t\t       build_int_cst (TREE_TYPE (t), 0));\n+      if (CAN_HAVE_LOCATION_P (c))\n+\tSET_EXPR_LOCATION (c, expr_loc);\n+      if (c == boolean_true_node)\n+\t{\n+\t  warning_at (expr_loc, 0,\n+\t\t      \"%<num_workers%> value must be positive\");\n+\t  t = integer_one_node;\n+\t}\n+\n+      check_no_duplicate_clause (list, OMP_CLAUSE_NUM_WORKERS, \"num_workers\");\n+\n+      c = build_omp_clause (num_workers_loc, OMP_CLAUSE_NUM_WORKERS);\n+      OMP_CLAUSE_NUM_WORKERS_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+\n+  return list;\n+}\n+\n+/* OpenACC:\n+   async [( int-expr )] */\n+\n+static tree\n+c_parser_oacc_clause_async (c_parser *parser, tree list)\n+{\n+  tree c, t;\n+  location_t loc = c_parser_peek_token (parser)->location;\n+\n+  t = build_int_cst (integer_type_node, GOMP_ASYNC_NOVAL);\n+\n+  if (c_parser_peek_token (parser)->type == CPP_OPEN_PAREN)\n+    {\n+      c_parser_consume_token (parser);\n+\n+      t = c_parser_expression (parser).value;\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\tc_parser_error (parser, \"expected integer expression\");\n+      else if (t == error_mark_node\n+\t  || !c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+\treturn list;\n+    }\n+  else\n+    t = c_fully_fold (t, false, NULL);\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_ASYNC, \"async\");\n+\n+  c = build_omp_clause (loc, OMP_CLAUSE_ASYNC);\n+  OMP_CLAUSE_ASYNC_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  list = c;\n+\n+  return list;\n+}\n+\n+/* OpenACC:\n+   wait ( int-expr-list ) */\n+\n+static tree\n+c_parser_oacc_clause_wait (c_parser *parser, tree list)\n+{\n+  location_t clause_loc = c_parser_peek_token (parser)->location;\n+\n+  if (c_parser_peek_token (parser)->type == CPP_OPEN_PAREN)\n+    list = c_parser_oacc_wait_list (parser, clause_loc, list);\n+\n+  return list;\n+}\n+\n /* OpenMP 2.5:\n    ordered */\n \n@@ -10557,23 +10996,68 @@ c_parser_omp_clause_untied (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n   return c;\n }\n \n-/* OpenMP 4.0:\n-   inbranch\n-   notinbranch */\n+/* OpenACC:\n+   vector_length ( expression ) */\n \n static tree\n-c_parser_omp_clause_branch (c_parser *parser ATTRIBUTE_UNUSED,\n-\t\t\t    enum omp_clause_code code, tree list)\n+c_parser_omp_clause_vector_length (c_parser *parser, tree list)\n {\n-  check_no_duplicate_clause (list, code, omp_clause_code_name[code]);\n+  location_t vector_length_loc = c_parser_peek_token (parser)->location;\n+  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+    {\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      tree c, t = c_parser_expression (parser).value;\n+      mark_exp_read (t);\n+      t = c_fully_fold (t, false, NULL);\n \n-  tree c = build_omp_clause (c_parser_peek_token (parser)->location, code);\n-  OMP_CLAUSE_CHAIN (c) = list;\n+      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n \n-  return c;\n-}\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  c_parser_error (parser, \"expected integer expression\");\n+\t  return list;\n+\t}\n \n-/* OpenMP 4.0:\n+      /* Attempt to statically determine when the number isn't positive.  */\n+      c = fold_build2_loc (expr_loc, LE_EXPR, boolean_type_node, t,\n+\t\t       build_int_cst (TREE_TYPE (t), 0));\n+      if (CAN_HAVE_LOCATION_P (c))\n+\tSET_EXPR_LOCATION (c, expr_loc);\n+      if (c == boolean_true_node)\n+\t{\n+\t  warning_at (expr_loc, 0,\n+\t\t      \"%<vector_length%> value must be positive\");\n+\t  t = integer_one_node;\n+\t}\n+\n+      check_no_duplicate_clause (list, OMP_CLAUSE_VECTOR_LENGTH, \"vector_length\");\n+\n+      c = build_omp_clause (vector_length_loc, OMP_CLAUSE_VECTOR_LENGTH);\n+      OMP_CLAUSE_VECTOR_LENGTH_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+\n+  return list;\n+}\n+\n+/* OpenMP 4.0:\n+   inbranch\n+   notinbranch */\n+\n+static tree\n+c_parser_omp_clause_branch (c_parser *parser ATTRIBUTE_UNUSED,\n+\t\t\t    enum omp_clause_code code, tree list)\n+{\n+  check_no_duplicate_clause (list, code, omp_clause_code_name[code]);\n+\n+  tree c = build_omp_clause (c_parser_peek_token (parser)->location, code);\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n+/* OpenMP 4.0:\n    parallel\n    for\n    sections\n@@ -10898,7 +11382,7 @@ static tree\n c_parser_omp_clause_map (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n-  enum omp_clause_map_kind kind = OMP_CLAUSE_MAP_TOFROM;\n+  enum gomp_map_kind kind = GOMP_MAP_TOFROM;\n   tree nl, c;\n \n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n@@ -10909,13 +11393,13 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n     {\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n       if (strcmp (\"alloc\", p) == 0)\n-\tkind = OMP_CLAUSE_MAP_ALLOC;\n+\tkind = GOMP_MAP_ALLOC;\n       else if (strcmp (\"to\", p) == 0)\n-\tkind = OMP_CLAUSE_MAP_TO;\n+\tkind = GOMP_MAP_TO;\n       else if (strcmp (\"from\", p) == 0)\n-\tkind = OMP_CLAUSE_MAP_FROM;\n+\tkind = GOMP_MAP_FROM;\n       else if (strcmp (\"tofrom\", p) == 0)\n-\tkind = OMP_CLAUSE_MAP_TOFROM;\n+\tkind = GOMP_MAP_TOFROM;\n       else\n \t{\n \t  c_parser_error (parser, \"invalid map kind\");\n@@ -10930,7 +11414,7 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n   nl = c_parser_omp_variable_list (parser, clause_loc, OMP_CLAUSE_MAP, list);\n \n   for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n-    OMP_CLAUSE_MAP_KIND (c) = kind;\n+    OMP_CLAUSE_SET_MAP_KIND (c, kind);\n \n   c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n   return nl;\n@@ -11093,9 +11577,154 @@ c_parser_omp_clause_uniform (c_parser *parser, tree list)\n   return list;\n }\n \n+/* Parse all OpenACC clauses.  The set clauses allowed by the directive\n+   is a bitmask in MASK.  Return the list of clauses found.  */\n+\n+static tree\n+c_parser_oacc_all_clauses (c_parser *parser, omp_clause_mask mask,\n+\t\t\t   const char *where, bool finish_p = true)\n+{\n+  tree clauses = NULL;\n+  bool first = true;\n+\n+  while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n+    {\n+      location_t here;\n+      pragma_omp_clause c_kind;\n+      const char *c_name;\n+      tree prev = clauses;\n+\n+      if (!first && c_parser_next_token_is (parser, CPP_COMMA))\n+\tc_parser_consume_token (parser);\n+\n+      here = c_parser_peek_token (parser)->location;\n+      c_kind = c_parser_omp_clause_name (parser);\n+\n+      switch (c_kind)\n+\t{\n+\tcase PRAGMA_OACC_CLAUSE_ASYNC:\n+\t  clauses = c_parser_oacc_clause_async (parser, clauses);\n+\t  c_name = \"async\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_COLLAPSE:\n+\t  clauses = c_parser_omp_clause_collapse (parser, clauses);\n+\t  c_name = \"collapse\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_COPY:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"copy\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_COPYIN:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"copyin\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_COPYOUT:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"copyout\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_CREATE:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"create\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_DELETE:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"delete\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_DEVICE:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"device\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_DEVICEPTR:\n+\t  clauses = c_parser_oacc_data_clause_deviceptr (parser, clauses);\n+\t  c_name = \"deviceptr\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_FIRSTPRIVATE:\n+\t  clauses = c_parser_omp_clause_firstprivate (parser, clauses);\n+\t  c_name = \"firstprivate\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_HOST:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"host\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_IF:\n+\t  clauses = c_parser_omp_clause_if (parser, clauses);\n+\t  c_name = \"if\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_NUM_GANGS:\n+\t  clauses = c_parser_omp_clause_num_gangs (parser, clauses);\n+\t  c_name = \"num_gangs\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_NUM_WORKERS:\n+\t  clauses = c_parser_omp_clause_num_workers (parser, clauses);\n+\t  c_name = \"num_workers\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRESENT:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"present\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"present_or_copy\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"present_or_copyin\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"present_or_copyout\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"present_or_create\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRIVATE:\n+\t  clauses = c_parser_omp_clause_private (parser, clauses);\n+\t  c_name = \"private\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_REDUCTION:\n+\t  clauses = c_parser_omp_clause_reduction (parser, clauses);\n+\t  c_name = \"reduction\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_SELF:\n+\t  clauses = c_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"self\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_VECTOR_LENGTH:\n+\t  clauses = c_parser_omp_clause_vector_length (parser, clauses);\n+\t  c_name = \"vector_length\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_WAIT:\n+\t  clauses = c_parser_oacc_clause_wait (parser, clauses);\n+\t  c_name = \"wait\";\n+\t  break;\n+\tdefault:\n+\t  c_parser_error (parser, \"expected %<#pragma acc%> clause\");\n+\t  goto saw_error;\n+\t}\n+\n+      first = false;\n+\n+      if (((mask >> c_kind) & 1) == 0 && !parser->error)\n+\t{\n+\t  /* Remove the invalid clause(s) from the list to avoid\n+\t     confusing the rest of the compiler.  */\n+\t  clauses = prev;\n+\t  error_at (here, \"%qs is not valid for %qs\", c_name, where);\n+\t}\n+    }\n+\n+ saw_error:\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  if (finish_p)\n+    return c_finish_omp_clauses (clauses);\n+\n+  return clauses;\n+}\n+\n /* Parse all OpenMP clauses.  The set clauses allowed by the directive\n-   is a bitmask in MASK.  Return the list of clauses found; the result\n-   of clause default goes in *pdefault.  */\n+   is a bitmask in MASK.  Return the list of clauses found.  */\n \n static tree\n c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n@@ -11323,7 +11952,7 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n   return clauses;\n }\n \n-/* OpenMP 2.5:\n+/* OpenACC 2.0, OpenMP 2.5:\n    structured-block:\n      statement\n \n@@ -11339,6 +11968,351 @@ c_parser_omp_structured_block (c_parser *parser)\n   return pop_stmt_list (stmt);\n }\n \n+/* OpenACC 2.0:\n+   # pragma acc cache (variable-list) new-line\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+static tree\n+c_parser_oacc_cache (location_t loc, c_parser *parser)\n+{\n+  tree stmt, clauses;\n+\n+  clauses = c_parser_omp_var_list_parens (parser, OMP_CLAUSE__CACHE_, NULL);\n+  clauses = c_finish_omp_clauses (clauses);\n+\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  stmt = make_node (OACC_CACHE);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OACC_CACHE_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, loc);\n+  add_stmt (stmt);\n+\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc data oacc-data-clause[optseq] new-line\n+     structured-block\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+#define OACC_DATA_CLAUSE_MASK\t\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DEVICEPTR)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE) )\n+\n+static tree\n+c_parser_oacc_data (location_t loc, c_parser *parser)\n+{\n+  tree stmt, clauses, block;\n+\n+  clauses = c_parser_oacc_all_clauses (parser, OACC_DATA_CLAUSE_MASK,\n+\t\t\t\t       \"#pragma acc data\");\n+\n+  block = c_begin_omp_parallel ();\n+  add_stmt (c_parser_omp_structured_block (parser));\n+\n+  stmt = c_finish_oacc_data (loc, clauses, block);\n+\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc kernels oacc-kernels-clause[optseq] new-line\n+     structured-block\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+#define OACC_KERNELS_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DEVICEPTR)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT) )\n+\n+static tree\n+c_parser_oacc_kernels (location_t loc, c_parser *parser, char *p_name)\n+{\n+  tree stmt, clauses = NULL_TREE, block;\n+\n+  strcat (p_name, \" kernels\");\n+\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      if (strcmp (p, \"loop\") == 0)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  block = c_begin_omp_parallel ();\n+\t  c_parser_oacc_loop (loc, parser, p_name);\n+\t  stmt = c_finish_oacc_kernels (loc, clauses, block);\n+\t  OACC_KERNELS_COMBINED (stmt) = 1;\n+\t  return stmt;\n+\t}\n+    }\n+\n+  clauses =  c_parser_oacc_all_clauses (parser, OACC_KERNELS_CLAUSE_MASK,\n+\t\t\t\t\tp_name);\n+\n+  block = c_begin_omp_parallel ();\n+  add_stmt (c_parser_omp_structured_block (parser));\n+\n+  stmt = c_finish_oacc_kernels (loc, clauses, block);\n+\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc enter data oacc-enter-data-clause[optseq] new-line\n+\n+   or\n+\n+   # pragma acc exit data oacc-exit-data-clause[optseq] new-line\n+\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+#define OACC_ENTER_DATA_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT) )\n+\n+#define OACC_EXIT_DATA_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DELETE) \t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT) )\n+\n+static void\n+c_parser_oacc_enter_exit_data (c_parser *parser, bool enter)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  tree clauses, stmt;\n+\n+  c_parser_consume_pragma (parser);\n+\n+  if (!c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      c_parser_error (parser, enter\n+\t\t      ? \"expected %<data%> in %<#pragma acc enter data%>\"\n+\t\t      : \"expected %<data%> in %<#pragma acc exit data%>\");\n+      c_parser_skip_to_pragma_eol (parser);\n+      return;\n+    }\n+\n+  const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+  if (strcmp (p, \"data\") != 0)\n+    {\n+      c_parser_error (parser, \"invalid pragma\");\n+      c_parser_skip_to_pragma_eol (parser);\n+      return;\n+    }\n+\n+  c_parser_consume_token (parser);\n+\n+  if (enter)\n+    clauses = c_parser_oacc_all_clauses (parser, OACC_ENTER_DATA_CLAUSE_MASK,\n+\t\t\t\t\t \"#pragma acc enter data\");\n+  else\n+    clauses = c_parser_oacc_all_clauses (parser, OACC_EXIT_DATA_CLAUSE_MASK,\n+\t\t\t\t\t \"#pragma acc exit data\");\n+\n+  if (find_omp_clause (clauses, OMP_CLAUSE_MAP) == NULL_TREE)\n+    {\n+      error_at (loc, enter\n+\t\t? \"%<#pragma acc enter data%> has no data movement clause\"\n+\t\t: \"%<#pragma acc exit data%> has no data movement clause\");\n+      return;\n+    }\n+\n+  stmt = enter ? make_node (OACC_ENTER_DATA) : make_node (OACC_EXIT_DATA);;\n+  TREE_TYPE (stmt) = void_type_node;\n+  if (enter)\n+    OACC_ENTER_DATA_CLAUSES (stmt) = clauses;\n+  else\n+    OACC_EXIT_DATA_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, loc);\n+  add_stmt (stmt);\n+}\n+\n+\n+/* OpenACC 2.0:\n+\n+   # pragma acc loop oacc-loop-clause[optseq] new-line\n+     structured-block\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+#define OACC_LOOP_CLAUSE_MASK\t\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COLLAPSE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_REDUCTION) )\n+\n+static tree\n+c_parser_oacc_loop (location_t loc, c_parser *parser, char *p_name)\n+{\n+  tree stmt, clauses, block;\n+\n+  strcat (p_name, \" loop\");\n+\n+  clauses = c_parser_oacc_all_clauses (parser, OACC_LOOP_CLAUSE_MASK, p_name);\n+\n+  block = c_begin_compound_stmt (true);\n+  stmt = c_parser_omp_for_loop (loc, parser, OACC_LOOP, clauses, NULL);\n+  block = c_end_compound_stmt (loc, block, true);\n+  add_stmt (block);\n+\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc parallel oacc-parallel-clause[optseq] new-line\n+     structured-block\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+#define OACC_PARALLEL_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DEVICEPTR)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_NUM_GANGS)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_NUM_WORKERS)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_REDUCTION)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_VECTOR_LENGTH)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT) )\n+\n+static tree\n+c_parser_oacc_parallel (location_t loc, c_parser *parser, char *p_name)\n+{\n+  tree stmt, clauses = NULL_TREE, block;\n+\n+  strcat (p_name, \" parallel\");\n+\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      if (strcmp (p, \"loop\") == 0)\n+\t{\n+\t  c_parser_consume_token (parser);\n+\t  block = c_begin_omp_parallel ();\n+\t  c_parser_oacc_loop (loc, parser, p_name);\n+\t  stmt = c_finish_oacc_parallel (loc, clauses, block);\n+\t  OACC_PARALLEL_COMBINED (stmt) = 1;\n+\t  return stmt;\n+\t}\n+    }\n+\n+  clauses =  c_parser_oacc_all_clauses (parser, OACC_PARALLEL_CLAUSE_MASK,\n+\t\t\t\t\tp_name);\n+\n+  block = c_begin_omp_parallel ();\n+  add_stmt (c_parser_omp_structured_block (parser));\n+\n+  stmt = c_finish_oacc_parallel (loc, clauses, block);\n+\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc update oacc-update-clause[optseq] new-line\n+*/\n+\n+#define OACC_UPDATE_CLAUSE_MASK\t\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DEVICE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_HOST)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_SELF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT) )\n+\n+static void\n+c_parser_oacc_update (c_parser *parser)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+\n+  c_parser_consume_pragma (parser);\n+\n+  tree clauses = c_parser_oacc_all_clauses (parser, OACC_UPDATE_CLAUSE_MASK,\n+\t\t\t\t\t    \"#pragma acc update\");\n+  if (find_omp_clause (clauses, OMP_CLAUSE_MAP) == NULL_TREE)\n+    {\n+      error_at (loc,\n+\t\t\"%<#pragma acc update%> must contain at least one \"\n+\t\t\"%<device%> or %<host/self%> clause\");\n+      return;\n+    }\n+\n+  if (parser->error)\n+    return;\n+\n+  tree stmt = make_node (OACC_UPDATE);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OACC_UPDATE_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, loc);\n+  add_stmt (stmt);\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc wait [(intseq)] oacc-wait-clause[optseq] new-line\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+#define OACC_WAIT_CLAUSE_MASK\t\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC) )\n+\n+static tree\n+c_parser_oacc_wait (location_t loc, c_parser *parser, char *p_name)\n+{\n+  tree clauses, list = NULL_TREE, stmt = NULL_TREE;\n+\n+  if (c_parser_peek_token (parser)->type == CPP_OPEN_PAREN)\n+    list = c_parser_oacc_wait_list (parser, loc, list);\n+\n+  strcpy (p_name, \" wait\");\n+  clauses = c_parser_oacc_all_clauses (parser, OACC_WAIT_CLAUSE_MASK, p_name);\n+  stmt = c_finish_oacc_wait (loc, list, clauses);\n+\n+  return stmt;\n+}\n+\n /* OpenMP 2.5:\n    # pragma omp atomic new-line\n      expression-stmt\n@@ -11815,10 +12789,11 @@ c_parser_omp_flush (c_parser *parser)\n   c_finish_omp_flush (loc);\n }\n \n-/* Parse the restricted form of the for statement allowed by OpenMP.\n+/* Parse the restricted form of loop statements allowed by OpenACC and OpenMP.\n    The real trick here is to determine the loop control variable early\n    so that we can push a new decl if necessary to make it private.\n-   LOC is the location of the OMP in \"#pragma omp\".  */\n+   LOC is the location of the \"acc\" or \"omp\" in \"#pragma acc\" or \"#pragma omp\",\n+   respectively.  */\n \n static tree\n c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n@@ -13660,6 +14635,29 @@ c_parser_omp_construct (c_parser *parser)\n \n   switch (p_kind)\n     {\n+    case PRAGMA_OACC_CACHE:\n+      strcpy (p_name, \"#pragma acc\");\n+      stmt = c_parser_oacc_cache (loc, parser);\n+      break;\n+    case PRAGMA_OACC_DATA:\n+      stmt = c_parser_oacc_data (loc, parser);\n+      break;\n+    case PRAGMA_OACC_KERNELS:\n+      strcpy (p_name, \"#pragma acc\");\n+      stmt = c_parser_oacc_kernels (loc, parser, p_name);\n+      break;\n+    case PRAGMA_OACC_LOOP:\n+      strcpy (p_name, \"#pragma acc\");\n+      stmt = c_parser_oacc_loop (loc, parser, p_name);\n+      break;\n+    case PRAGMA_OACC_PARALLEL:\n+      strcpy (p_name, \"#pragma acc\");\n+      stmt = c_parser_oacc_parallel (loc, parser, p_name);\n+      break;\n+    case PRAGMA_OACC_WAIT:\n+      strcpy (p_name, \"#pragma wait\");\n+      stmt = c_parser_oacc_wait (loc, parser, p_name);\n+      break;\n     case PRAGMA_OMP_ATOMIC:\n       c_parser_omp_atomic (loc, parser);\n       return;"}, {"sha": "c879bc77a2517578fd01bf28ef3a11a3f89befee", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -640,6 +640,9 @@ extern tree c_finish_bc_stmt (location_t, tree *, bool);\n extern tree c_finish_goto_label (location_t, tree);\n extern tree c_finish_goto_ptr (location_t, tree);\n extern tree c_expr_to_decl (tree, bool *, bool *);\n+extern tree c_finish_oacc_parallel (location_t, tree, tree);\n+extern tree c_finish_oacc_kernels (location_t, tree, tree);\n+extern tree c_finish_oacc_data (location_t, tree, tree);\n extern tree c_begin_omp_parallel (void);\n extern tree c_finish_omp_parallel (location_t, tree, tree);\n extern tree c_begin_omp_task (void);"}, {"sha": "f39dfdd9aaee50c935964212ce616c0a856b90e2", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -68,6 +68,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-ubsan.h\"\n #include \"cilk.h\"\n #include \"wide-int.h\"\n+#include \"gomp-constants.h\"\n \n /* Possible cases of implicit bad conversions.  Used to select\n    diagnostic messages in convert_for_assignment.  */\n@@ -11352,6 +11353,63 @@ c_expr_to_decl (tree expr, bool *tc ATTRIBUTE_UNUSED, bool *se)\n     return expr;\n }\n \f\n+/* Generate OACC_PARALLEL, with CLAUSES and BLOCK as its compound\n+   statement.  LOC is the location of the OACC_PARALLEL.  */\n+\n+tree\n+c_finish_oacc_parallel (location_t loc, tree clauses, tree block)\n+{\n+  tree stmt;\n+\n+  block = c_end_compound_stmt (loc, block, true);\n+\n+  stmt = make_node (OACC_PARALLEL);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OACC_PARALLEL_CLAUSES (stmt) = clauses;\n+  OACC_PARALLEL_BODY (stmt) = block;\n+  SET_EXPR_LOCATION (stmt, loc);\n+\n+  return add_stmt (stmt);\n+}\n+\n+/* Generate OACC_KERNELS, with CLAUSES and BLOCK as its compound\n+   statement.  LOC is the location of the OACC_KERNELS.  */\n+\n+tree\n+c_finish_oacc_kernels (location_t loc, tree clauses, tree block)\n+{\n+  tree stmt;\n+\n+  block = c_end_compound_stmt (loc, block, true);\n+\n+  stmt = make_node (OACC_KERNELS);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OACC_KERNELS_CLAUSES (stmt) = clauses;\n+  OACC_KERNELS_BODY (stmt) = block;\n+  SET_EXPR_LOCATION (stmt, loc);\n+\n+  return add_stmt (stmt);\n+}\n+\n+/* Generate OACC_DATA, with CLAUSES and BLOCK as its compound\n+   statement.  LOC is the location of the OACC_DATA.  */\n+\n+tree\n+c_finish_oacc_data (location_t loc, tree clauses, tree block)\n+{\n+  tree stmt;\n+\n+  block = c_end_compound_stmt (loc, block, true);\n+\n+  stmt = make_node (OACC_DATA);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OACC_DATA_CLAUSES (stmt) = clauses;\n+  OACC_DATA_BODY (stmt) = block;\n+  SET_EXPR_LOCATION (stmt, loc);\n+\n+  return add_stmt (stmt);\n+}\n+\n /* Like c_begin_compound_stmt, except force the retention of the BLOCK.  */\n \n tree\n@@ -11883,8 +11941,9 @@ handle_omp_array_sections (tree c)\n       OMP_CLAUSE_SIZE (c) = size;\n       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n \treturn false;\n+      gcc_assert (OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FORCE_DEVICEPTR);\n       tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n-      OMP_CLAUSE_MAP_KIND (c2) = OMP_CLAUSE_MAP_POINTER;\n+      OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n       if (!c_mark_addressable (t))\n \treturn false;\n       OMP_CLAUSE_DECL (c2) = t;\n@@ -11946,7 +12005,7 @@ c_find_omp_placeholder_r (tree *tp, int *, void *data)\n   return NULL_TREE;\n }\n \n-/* For all elements of CLAUSES, validate them vs OpenMP constraints.\n+/* For all elements of CLAUSES, validate them against their constraints.\n    Remove any elements from the list that are invalid.  */\n \n tree\n@@ -12268,6 +12327,7 @@ c_finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_MAP:\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_FROM:\n+\tcase OMP_CLAUSE__CACHE_:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) == TREE_LIST)\n \t    {\n@@ -12306,7 +12366,9 @@ c_finish_omp_clauses (tree clauses)\n \t  else if (!c_mark_addressable (t))\n \t    remove = true;\n \t  else if (!(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t     && OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER)\n+\t\t     && (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n+\t\t\t || (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t     == GOMP_MAP_FORCE_DEVICEPTR)))\n \t\t   && !lang_hooks.types.omp_mappable_type (TREE_TYPE (t)))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n@@ -12375,6 +12437,16 @@ c_finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_TASKGROUP:\n \tcase OMP_CLAUSE_PROC_BIND:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n+\tcase OMP_CLAUSE_NUM_GANGS:\n+\tcase OMP_CLAUSE_NUM_WORKERS:\n+\tcase OMP_CLAUSE_VECTOR_LENGTH:\n+\tcase OMP_CLAUSE_ASYNC:\n+\tcase OMP_CLAUSE_WAIT:\n+\tcase OMP_CLAUSE_AUTO:\n+\tcase OMP_CLAUSE_SEQ:\n+\tcase OMP_CLAUSE_GANG:\n+\tcase OMP_CLAUSE_WORKER:\n+\tcase OMP_CLAUSE_VECTOR:\n \t  pc = &OMP_CLAUSE_CHAIN (c);\n \t  continue;\n "}, {"sha": "b28966e518545f794392074321532cbf17c1ecb1", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -512,7 +512,7 @@ cgraph_node::create (tree decl)\n \n   node->decl = decl;\n \n-  if (flag_openmp\n+  if ((flag_openacc || flag_openmp)\n       && lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (decl)))\n     {\n       node->offloadable = 1;"}, {"sha": "bf67bebfe86d41ba9ac8242c13dfd082be4b18de", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -2233,6 +2233,7 @@ nios2-*-*)\n nvptx-*)\n \ttm_file=\"${tm_file} newlib-stdint.h\"\n \ttmake_file=\"nvptx/t-nvptx\"\n+\ttm_file=\"${tm_file} nvptx/offload.h\"\n \t;;\n pdp11-*-*)\n \ttm_file=\"${tm_file} newlib-stdint.h\"\n@@ -2965,6 +2966,7 @@ esac\n case ${target} in\n *-intelmic-* | *-intelmicemul-*)\n \ttmake_file=\"${tmake_file} i386/t-intelmic\"\n+\ttm_file=\"${tm_file} i386/intelmic-offload.h\"\n \t;;\n esac\n "}, {"sha": "3be5c93af269242cd0e23908cdb26f2e1fca7502", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -173,7 +173,7 @@ along with GCC; see the file COPYING3.  If not see\n     %(linker) %l \" LINK_PIE_SPEC \"%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\\\n     %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\\\n     %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\\\n-    %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)}\\\n+    %{fopenacc|fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)}\\\n     %(mflib)\\\n     %{fprofile-arcs|fprofile-generate|coverage:-lgcov}\\\n     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\\"}, {"sha": "b61dbb5eb94eac62d0084297b86f13e7d0c4e476", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -177,7 +177,7 @@ extern GTY(()) int darwin_ms_struct;\n     %{o*}%{!o:-o a.out} \\\n     %{!nostdlib:%{!nostartfiles:%S}} \\\n     %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} \\\n-    %{fopenmp|ftree-parallelize-loops=*: \\\n+    %{fopenacc|fopenmp|ftree-parallelize-loops=*: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libgomp.a%s; : -lgomp } } \\\n     %{fgnu-tm: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libitm.a%s; : -litm } } \\"}, {"sha": "edc3f92ea010b5480f6aad6dc3a146bd98e7e9af", "filename": "gcc/config/i386/intelmic-mkoffload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -22,13 +22,13 @@\n \n #include \"config.h\"\n #include <libgen.h>\n+#include \"libgomp-plugin.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"obstack.h\"\n #include \"intl.h\"\n #include \"diagnostic.h\"\n #include \"collect-utils.h\"\n-#include <libgomp_target.h>\n \n const char tool_name[] = \"intelmic mkoffload\";\n "}, {"sha": "4fb4b65aa9153a007b5541365ce5dadc10154492", "filename": "gcc/config/i386/intelmic-offload.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fi386%2Fintelmic-offload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fi386%2Fintelmic-offload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fintelmic-offload.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,35 @@\n+/* Support for Intel MIC offloading.\n+\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef INTELMIC_OFFLOAD_H\n+#define INTELMIC_OFFLOAD_H\n+\n+/* Support for OpenACC acc_on_device.  */\n+\n+#include \"gomp-constants.h\"\n+\n+#define ACCEL_COMPILER_acc_device GOMP_DEVICE_INTEL_MIC\n+\n+#endif"}, {"sha": "d7b92e88714ec2f6d5f4f0babf58b193beff80ec", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -199,7 +199,7 @@ do {\t\t\t\t\t\t         \\\n \n /* mingw32 uses the  -mthreads option to enable thread support.  */\n #undef GOMP_SELF_SPECS\n-#define GOMP_SELF_SPECS \"%{fopenmp|ftree-parallelize-loops=*: \" \\\n+#define GOMP_SELF_SPECS \"%{fopenacc|fopenmp|ftree-parallelize-loops=*: \" \\\n \t\t\t\"-mthreads -pthread}\"\n #undef GTM_SELF_SPECS\n #define GTM_SELF_SPECS \"%{fgnu-tm:-mthreads -pthread}\""}, {"sha": "a497e444b210b80e5764acbaeeb61f84f1ad18c6", "filename": "gcc/config/ia64/hpux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fia64%2Fhpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fia64%2Fhpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fhpux.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -92,7 +92,7 @@ do {\t\t\t\t\t\t\t\\\n #undef  LIB_SPEC\n #define LIB_SPEC \\\n   \"%{!shared: \\\n-     %{mt|pthread:%{fopenmp|ftree-parallelize-loops=*:-lrt} -lpthread} \\\n+     %{mt|pthread:%{fopenacc|fopenmp|ftree-parallelize-loops=*:-lrt} -lpthread} \\\n      %{p:%{!mlp64:-L/usr/lib/hpux32/libp} \\\n \t %{mlp64:-L/usr/lib/hpux64/libp} -lprof} \\\n      %{pg:%{!mlp64:-L/usr/lib/hpux32/libp} \\"}, {"sha": "02c5e8b961aa1807ba27c961dbdd6aaca69610a4", "filename": "gcc/config/nvptx/offload.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fnvptx%2Foffload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fnvptx%2Foffload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Foffload.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,35 @@\n+/* Support for Nvidia PTX offloading.\n+\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_NVPTX_OFFLOAD_H\n+#define GCC_NVPTX_OFFLOAD_H\n+\n+/* Support for OpenACC acc_on_device.  */\n+\n+#include \"gomp-constants.h\"\n+\n+#define ACCEL_COMPILER_acc_device GOMP_TARGET_NVIDIA_PTX\n+\n+#endif"}, {"sha": "40d49a000fcc3ca18e0d6e135b90f92770b01e6b", "filename": "gcc/config/pa/pa-hpux11.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fpa%2Fpa-hpux11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fpa%2Fpa-hpux11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux11.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -122,8 +122,8 @@ along with GCC; see the file COPYING3.  If not see\n #undef LIB_SPEC\n #define LIB_SPEC \\\n   \"%{!shared:\\\n-     %{fopenmp|ftree-parallelize-loops=*:%{static:-a archive_shared} -lrt\\\n-       %{static:-a archive}}\\\n+     %{fopenacc|fopenmp|ftree-parallelize-loops=*:\\\n+       %{static:-a archive_shared} -lrt %{static:-a archive}}\\\n      %{mt|pthread:-lpthread} -lc\\\n      %{static:%{!nolibdld:-a archive_shared -ldld -a archive -lc}\\\n        %{!mt:%{!pthread:-a shared -lc -a archive}}}}\\"}, {"sha": "0af5c1703bc13cedac8991d6a347ea72225dedf0", "filename": "gcc/config/pa/pa64-hpux.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-hpux.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -58,45 +58,45 @@ along with GCC; see the file COPYING3.  If not see\n #if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & MASK_GNU_LD)\n #define LIB_SPEC \\\n   \"%{!shared:\\\n-     %{!p:%{!pg:%{fopenmp|ftree-parallelize-loops=*:%{static:-a shared} -lrt\\\n-                  %{static:-a archive}}\\\n+     %{!p:%{!pg:%{fopenacc|fopenmp|ftree-parallelize-loops=*:\\\n+                  %{static:-a shared} -lrt %{static:-a archive}}\\\n \t    %{mt|pthread:-lpthread} -lc\\\n \t    %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\\\n \t\t%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\\\n      %{p:%{!pg:%{static:%{!mhp-ld:-a shared}%{mhp-ld:-a archive_shared}}\\\n \t   -lprof %{static:-a archive}\\\n-\t   %{fopenmp|ftree-parallelize-loops=*:%{static:-a shared} -lrt\\\n-             %{static:-a archive}}\\\n+\t   %{fopenacc|fopenmp|ftree-parallelize-loops=*:\\\n+             %{static:-a shared} -lrt %{static:-a archive}}\\\n \t   %{mt|pthread:-lpthread} -lc\\\n \t   %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\\\n \t\t%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\\\n      %{pg:%{static:%{!mhp-ld:-a shared}%{mhp-ld:-a archive_shared}}\\\n        -lgprof %{static:-a archive}\\\n-       %{fopenmp|ftree-parallelize-loops=*:%{static:-a shared} -lrt\\\n-         %{static:-a archive}}\\\n+       %{fopenacc|fopenmp|ftree-parallelize-loops=*:\\\n+         %{static:-a shared} -lrt %{static:-a archive}}\\\n        %{mt|pthread:-lpthread} -lc\\\n        %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\\\n \t\t%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\\\n    %{shared:%{mt|pthread:-lpthread}}\"\n #else\n #define LIB_SPEC \\\n   \"%{!shared:\\\n-     %{!p:%{!pg:%{fopenmp|ftree-parallelize-loops=*:%{static:-a shared} -lrt\\\n-                  %{static:-a archive}}\\\n+     %{!p:%{!pg:%{fopenacc|fopenmp|ftree-parallelize-loops=*:\\\n+                  %{static:-a shared} -lrt %{static:-a archive}}\\\n \t    %{mt|pthread:-lpthread} -lc\\\n \t    %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\\\n \t\t%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\\\n      %{p:%{!pg:%{static:%{mgnu-ld:-a shared}%{!mgnu-ld:-a archive_shared}}\\\n \t   -lprof %{static:-a archive}\\\n-\t   %{fopenmp|ftree-parallelize-loops=*:%{static:-a shared} -lrt\\\n-             %{static:-a archive}}\\\n+\t   %{fopenacc|fopenmp|ftree-parallelize-loops=*:\\\n+             %{static:-a shared} -lrt %{static:-a archive}}\\\n \t   %{mt|pthread:-lpthread} -lc\\\n \t   %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\\\n \t\t%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\\\n      %{pg:%{static:%{mgnu-ld:-a shared}%{!mgnu-ld:-a archive_shared}}\\\n        -lgprof %{static:-a archive}\\\n-       %{fopenmp|ftree-parallelize-loops=*:%{static:-a shared} -lrt\\\n-         %{static:-a archive}}\\\n+       %{fopenacc|fopenmp|ftree-parallelize-loops=*:\\\n+         %{static:-a shared} -lrt %{static:-a archive}}\\\n        %{mt|pthread:-lpthread} -lc\\\n        %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\\\n \t\t%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\\"}, {"sha": "543f4d9a4d96eaf8974b2a39223426396964cfa9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,48 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Ilmir Usmanov  <i.usmanov@samsung.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* parser.c: Include \"gomp-constants.h\".\n+\t(cp_parser_omp_clause_map): Use enum gomp_map_kind instead of enum\n+\tomp_clause_map_kind.  Use GOMP_MAP_* instead of OMP_CLAUSE_MAP_*.\n+\tUse OMP_CLAUSE_SET_MAP_KIND.\n+\t(cp_parser_omp_construct, cp_parser_pragma): Handle\n+\tPRAGMA_OACC_CACHE, PRAGMA_OACC_DATA, PRAGMA_OACC_ENTER_DATA,\n+\tPRAGMA_OACC_EXIT_DATA, PRAGMA_OACC_KERNELS, PRAGMA_OACC_PARALLEL,\n+\tPRAGMA_OACC_LOOP, PRAGMA_OACC_UPDATE, PRAGMA_OACC_WAIT.\n+\t(cp_parser_omp_clause_name): Handle \"async\", \"copy\", \"copyout\",\n+\t\"create\", \"delete\", \"deviceptr\", \"host\", \"num_gangs\",\n+\t\"num_workers\", \"present\", \"present_or_copy\", \"pcopy\",\n+\t\"present_or_copyin\", \"pcopyin\", \"present_or_copyout\", \"pcopyout\",\n+\t\"present_or_create\", \"pcreate\", \"vector_length\", \"wait\".\n+\t(OACC_DATA_CLAUSE_MASK, OACC_ENTER_DATA_CLAUSE_MASK)\n+\t(OACC_EXIT_DATA_CLAUSE_MASK, OACC_KERNELS_CLAUSE_MASK)\n+\t(OACC_LOOP_CLAUSE_MASK, OACC_PARALLEL_CLAUSE_MASK)\n+\t(OACC_UPDATE_CLAUSE_MASK, OACC_WAIT_CLAUSE_MASK): New macros.\n+\t(cp_parser_omp_var_list_no_open): Handle OMP_CLAUSE__CACHE_.\n+\t(cp_parser_oacc_data_clause, cp_parser_oacc_data_clause_deviceptr)\n+\t(cp_parser_oacc_clause_vector_length, cp_parser_oacc_wait_list)\n+\t(cp_parser_oacc_clause_wait, cp_parser_omp_clause_num_gangs)\n+\t(cp_parser_omp_clause_num_workers, cp_parser_oacc_clause_async)\n+\t(cp_parser_oacc_all_clauses, cp_parser_oacc_cache)\n+\t(cp_parser_oacc_data, cp_parser_oacc_enter_exit_data)\n+\t(cp_parser_oacc_kernels, cp_parser_oacc_loop)\n+\t(cp_parser_oacc_parallel, cp_parser_oacc_update)\n+\t(cp_parser_oacc_wait): New functions.\n+\t* cp-tree.h (finish_oacc_data, finish_oacc_kernels)\n+\t(finish_oacc_parallel): New prototypes.\n+\t* semantics.c: Include \"gomp-constants.h\".\n+\t(handle_omp_array_sections): Handle GOMP_MAP_FORCE_DEVICEPTR.  Use\n+\tGOMP_MAP_* instead of OMP_CLAUSE_MAP_*.  Use\n+\tOMP_CLAUSE_SET_MAP_KIND.\n+\t(finish_omp_clauses): Handle OMP_CLAUSE_ASYNC,\n+\tOMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_WAIT, OMP_CLAUSE__CACHE_.\n+\tUse GOMP_MAP_* instead of OMP_CLAUSE_MAP_*.\n+\t(finish_oacc_data, finish_oacc_kernels, finish_oacc_parallel): New\n+\tfunctions.\n+\n 2015-01-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58671"}, {"sha": "10c63fd1b4dc2e13c631725ed79a64fb771782d6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -5990,6 +5990,9 @@ extern tree finish_omp_clauses\t\t\t(tree);\n extern void finish_omp_threadprivate\t\t(tree);\n extern tree begin_omp_structured_block\t\t(void);\n extern tree finish_omp_structured_block\t\t(tree);\n+extern tree finish_oacc_data\t\t\t(tree, tree);\n+extern tree finish_oacc_kernels\t\t\t(tree, tree);\n+extern tree finish_oacc_parallel\t\t(tree, tree);\n extern tree begin_omp_parallel\t\t\t(void);\n extern tree finish_omp_parallel\t\t\t(tree, tree);\n extern tree begin_omp_task\t\t\t(void);"}, {"sha": "bfa3d81bf74f6e8df3338c85671f0c696651ba0c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 873, "deletions": 7, "changes": 880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -60,6 +60,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"parser.h\"\n #include \"type-utils.h\"\n #include \"omp-low.h\"\n+#include \"gomp-constants.h\"\n \n \f\n /* The lexer.  */\n@@ -27542,6 +27543,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n     result = PRAGMA_OMP_CLAUSE_IF;\n   else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_DEFAULT))\n     result = PRAGMA_OMP_CLAUSE_DEFAULT;\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_DELETE))\n+    result = PRAGMA_OACC_CLAUSE_DELETE;\n   else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_PRIVATE))\n     result = PRAGMA_OMP_CLAUSE_PRIVATE;\n   else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n@@ -27556,20 +27559,30 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \tcase 'a':\n \t  if (!strcmp (\"aligned\", p))\n \t    result = PRAGMA_OMP_CLAUSE_ALIGNED;\n+\t  else if (!strcmp (\"async\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_ASYNC;\n \t  break;\n \tcase 'c':\n \t  if (!strcmp (\"collapse\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COLLAPSE;\n+\t  else if (!strcmp (\"copy\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_COPY;\n \t  else if (!strcmp (\"copyin\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COPYIN;\n+\t  else if (!strcmp (\"copyout\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_COPYOUT;\n \t  else if (!strcmp (\"copyprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;\n+\t  else if (!strcmp (\"create\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_CREATE;\n \t  break;\n \tcase 'd':\n \t  if (!strcmp (\"depend\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEPEND;\n \t  else if (!strcmp (\"device\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DEVICE;\n+\t  else if (!strcmp (\"deviceptr\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_DEVICEPTR;\n \t  else if (!strcmp (\"dist_schedule\", p))\n \t    result = PRAGMA_OMP_CLAUSE_DIST_SCHEDULE;\n \t  break;\n@@ -27581,6 +27594,10 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t  else if (!strcmp (\"from\", p))\n \t    result = PRAGMA_OMP_CLAUSE_FROM;\n \t  break;\n+\tcase 'h':\n+\t  if (!strcmp (\"host\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_HOST;\n+\t  break;\n \tcase 'i':\n \t  if (!strcmp (\"inbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_INBRANCH;\n@@ -27606,10 +27623,14 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_NOWAIT;\n \t  else if (flag_cilkplus && !strcmp (\"nomask\", p))\n \t    result = PRAGMA_CILK_CLAUSE_NOMASK;\n+\t  else if (!strcmp (\"num_gangs\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_NUM_GANGS;\n \t  else if (!strcmp (\"num_teams\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NUM_TEAMS;\n \t  else if (!strcmp (\"num_threads\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NUM_THREADS;\n+\t  else if (!strcmp (\"num_workers\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_NUM_WORKERS;\n \t  break;\n \tcase 'o':\n \t  if (!strcmp (\"ordered\", p))\n@@ -27618,6 +27639,20 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \tcase 'p':\n \t  if (!strcmp (\"parallel\", p))\n \t    result = PRAGMA_OMP_CLAUSE_PARALLEL;\n+\t  else if (!strcmp (\"present\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_PRESENT;\n+\t  else if (!strcmp (\"present_or_copy\", p)\n+\t\t   || !strcmp (\"pcopy\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY;\n+\t  else if (!strcmp (\"present_or_copyin\", p)\n+\t\t   || !strcmp (\"pcopyin\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN;\n+\t  else if (!strcmp (\"present_or_copyout\", p)\n+\t\t   || !strcmp (\"pcopyout\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT;\n+\t  else if (!strcmp (\"present_or_create\", p)\n+\t\t   || !strcmp (\"pcreate\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE;\n \t  else if (!strcmp (\"proc_bind\", p))\n \t    result = PRAGMA_OMP_CLAUSE_PROC_BIND;\n \t  break;\n@@ -27632,6 +27667,8 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_SCHEDULE;\n \t  else if (!strcmp (\"sections\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SECTIONS;\n+\t  else if (!strcmp (\"self\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_SELF;\n \t  else if (!strcmp (\"shared\", p))\n \t    result = PRAGMA_OMP_CLAUSE_SHARED;\n \t  else if (!strcmp (\"simdlen\", p))\n@@ -27652,9 +27689,15 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_UNTIED;\n \t  break;\n \tcase 'v':\n-\t  if (flag_cilkplus && !strcmp (\"vectorlength\", p))\n+\t  if (!strcmp (\"vector_length\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_VECTOR_LENGTH;\n+\t  else if (flag_cilkplus && !strcmp (\"vectorlength\", p))\n \t    result = PRAGMA_CILK_CLAUSE_VECTORLENGTH;\n \t  break;\n+\tcase 'w':\n+\t  if (!strcmp (\"wait\", p))\n+\t    result = PRAGMA_OACC_CLAUSE_WAIT;\n+\t  break;\n \t}\n     }\n \n@@ -27730,6 +27773,14 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t{\n \t  switch (kind)\n \t    {\n+\t    case OMP_CLAUSE__CACHE_:\n+\t      if (cp_lexer_peek_token (parser->lexer)->type != CPP_OPEN_SQUARE)\n+\t\t{\n+\t\t  error_at (token->location, \"expected %<[%>\");\n+\t\t  decl = error_mark_node;\n+\t\t  break;\n+\t\t}\n+\t      /* FALL THROUGH.  */\n \t    case OMP_CLAUSE_MAP:\n \t    case OMP_CLAUSE_FROM:\n \t    case OMP_CLAUSE_TO:\n@@ -27760,6 +27811,26 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE,\n \t\t\t\t\t  RT_CLOSE_SQUARE))\n \t\t    goto skip_comma;\n+\n+\t\t  if (kind == OMP_CLAUSE__CACHE_)\n+\t\t    {\n+\t\t      if (TREE_CODE (low_bound) != INTEGER_CST\n+\t\t\t  && !TREE_READONLY (low_bound))\n+\t\t\t{\n+\t\t\t  error_at (token->location,\n+\t\t\t\t\t\"%qD is not a constant\", low_bound);\n+\t\t\t  decl = error_mark_node;\n+\t\t\t}\n+\n+\t\t      if (TREE_CODE (length) != INTEGER_CST\n+\t\t\t  && !TREE_READONLY (length))\n+\t\t\t{\n+\t\t\t  error_at (token->location,\n+\t\t\t\t\t\"%qD is not a constant\", length);\n+\t\t\t  decl = error_mark_node;\n+\t\t\t}\n+\t\t    }\n+\n \t\t  decl = tree_cons (low_bound, length, decl);\n \t\t}\n \t      break;\n@@ -27822,6 +27893,222 @@ cp_parser_omp_var_list (cp_parser *parser, enum omp_clause_code kind, tree list)\n   return list;\n }\n \n+/* OpenACC 2.0:\n+   copy ( variable-list )\n+   copyin ( variable-list )\n+   copyout ( variable-list )\n+   create ( variable-list )\n+   delete ( variable-list )\n+   present ( variable-list )\n+   present_or_copy ( variable-list )\n+     pcopy ( variable-list )\n+   present_or_copyin ( variable-list )\n+     pcopyin ( variable-list )\n+   present_or_copyout ( variable-list )\n+     pcopyout ( variable-list )\n+   present_or_create ( variable-list )\n+     pcreate ( variable-list ) */\n+\n+static tree\n+cp_parser_oacc_data_clause (cp_parser *parser, pragma_omp_clause c_kind,\n+\t\t\t    tree list)\n+{\n+  enum gomp_map_kind kind;\n+  switch (c_kind)\n+    {\n+    case PRAGMA_OACC_CLAUSE_COPY:\n+      kind = GOMP_MAP_FORCE_TOFROM;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_COPYIN:\n+      kind = GOMP_MAP_FORCE_TO;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_COPYOUT:\n+      kind = GOMP_MAP_FORCE_FROM;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_CREATE:\n+      kind = GOMP_MAP_FORCE_ALLOC;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_DELETE:\n+      kind = GOMP_MAP_FORCE_DEALLOC;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_DEVICE:\n+      kind = GOMP_MAP_FORCE_TO;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_HOST:\n+    case PRAGMA_OACC_CLAUSE_SELF:\n+      kind = GOMP_MAP_FORCE_FROM;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_PRESENT:\n+      kind = GOMP_MAP_FORCE_PRESENT;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY:\n+      kind = GOMP_MAP_TOFROM;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN:\n+      kind = GOMP_MAP_TO;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT:\n+      kind = GOMP_MAP_FROM;\n+      break;\n+    case PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE:\n+      kind = GOMP_MAP_ALLOC;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  tree nl, c;\n+  nl = cp_parser_omp_var_list (parser, OMP_CLAUSE_MAP, list);\n+\n+  for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n+    OMP_CLAUSE_SET_MAP_KIND (c, kind);\n+\n+  return nl;\n+}\n+\n+/* OpenACC 2.0:\n+   deviceptr ( variable-list ) */\n+\n+static tree\n+cp_parser_oacc_data_clause_deviceptr (cp_parser *parser, tree list)\n+{\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+  tree vars, t;\n+\n+  /* Can't use OMP_CLAUSE_MAP here (that is, can't use the generic\n+     cp_parser_oacc_data_clause), as for PRAGMA_OACC_CLAUSE_DEVICEPTR,\n+     variable-list must only allow for pointer variables.  */\n+  vars = cp_parser_omp_var_list (parser, OMP_CLAUSE_ERROR, NULL);\n+  for (t = vars; t; t = TREE_CHAIN (t))\n+    {\n+      tree v = TREE_PURPOSE (t);\n+\n+      /* FIXME diagnostics: Ideally we should keep individual\n+\t locations for all the variables in the var list to make the\n+\t following errors more precise.  Perhaps\n+\t c_parser_omp_var_list_parens should construct a list of\n+\t locations to go along with the var list.  */\n+\n+      if (TREE_CODE (v) != VAR_DECL)\n+\terror_at (loc, \"%qD is not a variable\", v);\n+      else if (TREE_TYPE (v) == error_mark_node)\n+\t;\n+      else if (!POINTER_TYPE_P (TREE_TYPE (v)))\n+\terror_at (loc, \"%qD is not a pointer variable\", v);\n+\n+      tree u = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (u, GOMP_MAP_FORCE_DEVICEPTR);\n+      OMP_CLAUSE_DECL (u) = v;\n+      OMP_CLAUSE_CHAIN (u) = list;\n+      list = u;\n+    }\n+\n+  return list;\n+}\n+\n+/* OpenACC:\n+   vector_length ( expression ) */\n+\n+static tree\n+cp_parser_oacc_clause_vector_length (cp_parser *parser, tree list)\n+{\n+  tree t, c;\n+  location_t location = cp_lexer_peek_token (parser->lexer)->location;\n+  bool error = false;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return list;\n+\n+  t = cp_parser_condition (parser);\n+  if (t == error_mark_node || !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+    {\n+      error_at (location, \"expected positive integer expression\");\n+      error = true;\n+    }\n+\n+  if (error || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    {\n+      cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+      return list;\n+    }\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_VECTOR_LENGTH, \"vector_length\",\n+\t\t\t     location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_VECTOR_LENGTH);\n+  OMP_CLAUSE_VECTOR_LENGTH_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  list = c;\n+\n+  return list;\n+}\n+\n+/* OpenACC 2.0\n+   Parse wait clause or directive parameters.  */\n+\n+static tree\n+cp_parser_oacc_wait_list (cp_parser *parser, location_t clause_loc, tree list)\n+{\n+  vec<tree, va_gc> *args;\n+  tree t, args_tree;\n+\n+  args = cp_parser_parenthesized_expression_list (parser, non_attr,\n+\t\t\t\t\t\t  /*cast_p=*/false,\n+\t\t\t\t\t\t  /*allow_expansion_p=*/true,\n+\t\t\t\t\t\t  /*non_constant_p=*/NULL);\n+\n+  if (args == NULL || args->length () == 0)\n+    {\n+      cp_parser_error (parser, \"expected integer expression before ')'\");\n+      if (args != NULL)\n+\trelease_tree_vector (args);\n+      return list;\n+    }\n+\n+  args_tree = build_tree_list_vec (args);\n+\n+  release_tree_vector (args);\n+\n+  for (t = args_tree; t; t = TREE_CHAIN (t))\n+    {\n+      tree targ = TREE_VALUE (t);\n+\n+      if (targ != error_mark_node)\n+\t{\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (targ)))\n+\t    error (\"%<wait%> expression must be integral\");\n+\t  else\n+\t    {\n+\t      tree c = build_omp_clause (clause_loc, OMP_CLAUSE_WAIT);\n+\n+\t      mark_rvalue_use (targ);\n+\t      OMP_CLAUSE_DECL (c) = targ;\n+\t      OMP_CLAUSE_CHAIN (c) = list;\n+\t      list = c;\n+\t    }\n+\t}\n+    }\n+\n+  return list;\n+}\n+\n+/* OpenACC:\n+   wait ( int-expr-list ) */\n+\n+static tree\n+cp_parser_oacc_clause_wait (cp_parser *parser, tree list)\n+{\n+  location_t location = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  if (cp_lexer_peek_token (parser->lexer)->type != CPP_OPEN_PAREN)\n+    return list;\n+\n+  list = cp_parser_oacc_wait_list (parser, location, list);\n+\n+  return list;\n+}\n+\n /* OpenMP 3.0:\n    collapse ( constant-expression ) */\n \n@@ -28010,6 +28297,42 @@ cp_parser_omp_clause_nowait (cp_parser * /*parser*/,\n   return c;\n }\n \n+/* OpenACC:\n+   num_gangs ( expression ) */\n+\n+static tree\n+cp_parser_omp_clause_num_gangs (cp_parser *parser, tree list)\n+{\n+  tree t, c;\n+  location_t location = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return list;\n+\n+  t = cp_parser_condition (parser);\n+\n+  if (t == error_mark_node\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+    {\n+      error_at (location, \"expected positive integer expression\");\n+      return list;\n+    }\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_NUM_GANGS, \"num_gangs\", location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_NUM_GANGS);\n+  OMP_CLAUSE_NUM_GANGS_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  list = c;\n+\n+  return list;\n+}\n+\n /* OpenMP 2.5:\n    num_threads ( expression ) */\n \n@@ -28040,6 +28363,43 @@ cp_parser_omp_clause_num_threads (cp_parser *parser, tree list,\n   return c;\n }\n \n+/* OpenACC:\n+   num_workers ( expression ) */\n+\n+static tree\n+cp_parser_omp_clause_num_workers (cp_parser *parser, tree list)\n+{\n+  tree t, c;\n+  location_t location = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+    return list;\n+\n+  t = cp_parser_condition (parser);\n+\n+  if (t == error_mark_node\n+      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+    {\n+      error_at (location, \"expected positive integer expression\");\n+      return list;\n+    }\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_NUM_WORKERS, \"num_gangs\",\n+\t\t\t\t\t\t\t\tlocation);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_NUM_WORKERS);\n+  OMP_CLAUSE_NUM_WORKERS_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  list = c;\n+\n+  return list;\n+}\n+\n /* OpenMP 2.5:\n    ordered */\n \n@@ -28562,7 +28922,7 @@ static tree\n cp_parser_omp_clause_map (cp_parser *parser, tree list)\n {\n   tree nlist, c;\n-  enum omp_clause_map_kind kind = OMP_CLAUSE_MAP_TOFROM;\n+  enum gomp_map_kind kind = GOMP_MAP_TOFROM;\n \n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n@@ -28574,13 +28934,13 @@ cp_parser_omp_clause_map (cp_parser *parser, tree list)\n       const char *p = IDENTIFIER_POINTER (id);\n \n       if (strcmp (\"alloc\", p) == 0)\n-\tkind = OMP_CLAUSE_MAP_ALLOC;\n+\tkind = GOMP_MAP_ALLOC;\n       else if (strcmp (\"to\", p) == 0)\n-\tkind = OMP_CLAUSE_MAP_TO;\n+\tkind = GOMP_MAP_TO;\n       else if (strcmp (\"from\", p) == 0)\n-\tkind = OMP_CLAUSE_MAP_FROM;\n+\tkind = GOMP_MAP_FROM;\n       else if (strcmp (\"tofrom\", p) == 0)\n-\tkind = OMP_CLAUSE_MAP_TOFROM;\n+\tkind = GOMP_MAP_TOFROM;\n       else\n \t{\n \t  cp_parser_error (parser, \"invalid map kind\");\n@@ -28597,7 +28957,7 @@ cp_parser_omp_clause_map (cp_parser *parser, tree list)\n \t\t\t\t\t  NULL);\n \n   for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n-    OMP_CLAUSE_MAP_KIND (c) = kind;\n+    OMP_CLAUSE_SET_MAP_KIND (c, kind);\n \n   return nlist;\n }\n@@ -28734,6 +29094,178 @@ cp_parser_omp_clause_proc_bind (cp_parser *parser, tree list,\n   return list;\n }\n \n+/* OpenACC:\n+   async [( int-expr )] */\n+\n+static tree\n+cp_parser_oacc_clause_async (cp_parser *parser, tree list)\n+{\n+  tree c, t;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  t = build_int_cst (integer_type_node, GOMP_ASYNC_NOVAL);\n+\n+  if (cp_lexer_peek_token (parser->lexer)->type == CPP_OPEN_PAREN)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      t = cp_parser_expression (parser);\n+      if (t == error_mark_node\n+\t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t\t/*or_comma=*/false,\n+\t\t\t\t\t\t/*consume_paren=*/true);\n+    }\n+\n+  check_no_duplicate_clause (list, OMP_CLAUSE_ASYNC, \"async\", loc);\n+\n+  c = build_omp_clause (loc, OMP_CLAUSE_ASYNC);\n+  OMP_CLAUSE_ASYNC_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+  list = c;\n+\n+  return list;\n+}\n+\n+/* Parse all OpenACC clauses.  The set clauses allowed by the directive\n+   is a bitmask in MASK.  Return the list of clauses found.  */\n+\n+static tree\n+cp_parser_oacc_all_clauses (cp_parser *parser, omp_clause_mask mask,\n+\t\t\t   const char *where, cp_token *pragma_tok,\n+\t\t\t   bool finish_p = true)\n+{\n+  tree clauses = NULL;\n+  bool first = true;\n+\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n+    {\n+      location_t here;\n+      pragma_omp_clause c_kind;\n+      const char *c_name;\n+      tree prev = clauses;\n+\n+      if (!first && cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+\n+      here = cp_lexer_peek_token (parser->lexer)->location;\n+      c_kind = cp_parser_omp_clause_name (parser);\n+\n+      switch (c_kind)\n+\t{\n+\tcase PRAGMA_OACC_CLAUSE_ASYNC:\n+\t  clauses = cp_parser_oacc_clause_async (parser, clauses);\n+\t  c_name = \"async\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_COLLAPSE:\n+\t  clauses = cp_parser_omp_clause_collapse (parser, clauses, here);\n+\t  c_name = \"collapse\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_COPY:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"copy\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_COPYIN:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"copyin\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_COPYOUT:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"copyout\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_CREATE:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"create\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_DELETE:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"delete\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_DEVICE:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"device\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_DEVICEPTR:\n+\t  clauses = cp_parser_oacc_data_clause_deviceptr (parser, clauses);\n+\t  c_name = \"deviceptr\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_HOST:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"host\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_IF:\n+\t  clauses = cp_parser_omp_clause_if (parser, clauses, here);\n+\t  c_name = \"if\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_NUM_GANGS:\n+\t  clauses = cp_parser_omp_clause_num_gangs (parser, clauses);\n+\t  c_name = \"num_gangs\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_NUM_WORKERS:\n+\t  clauses = cp_parser_omp_clause_num_workers (parser, clauses);\n+\t  c_name = \"num_workers\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRESENT:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"present\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"present_or_copy\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"present_or_copyin\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"present_or_copyout\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"present_or_create\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_REDUCTION:\n+\t  clauses = cp_parser_omp_clause_reduction (parser, clauses);\n+\t  c_name = \"reduction\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_SELF:\n+\t  clauses = cp_parser_oacc_data_clause (parser, c_kind, clauses);\n+\t  c_name = \"self\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_VECTOR_LENGTH:\n+\t  clauses = cp_parser_oacc_clause_vector_length (parser, clauses);\n+\t  c_name = \"vector_length\";\n+\t  break;\n+\tcase PRAGMA_OACC_CLAUSE_WAIT:\n+\t  clauses = cp_parser_oacc_clause_wait (parser, clauses);\n+\t  c_name = \"wait\";\n+\t  break;\n+\tdefault:\n+\t  cp_parser_error (parser, \"expected %<#pragma acc%> clause\");\n+\t  goto saw_error;\n+\t}\n+\n+      first = false;\n+\n+      if (((mask >> c_kind) & 1) == 0)\n+\t{\n+\t  /* Remove the invalid clause(s) from the list to avoid\n+\t     confusing the rest of the compiler.  */\n+\t  clauses = prev;\n+\t  error_at (here, \"%qs is not valid for %qs\", c_name, where);\n+\t}\n+    }\n+\n+ saw_error:\n+  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+\n+  if (finish_p)\n+    return finish_omp_clauses (clauses);\n+\n+  return clauses;\n+}\n+\n /* Parse all OpenMP clauses.  The set clauses allowed by the directive\n    is a bitmask in MASK.  Return the list of clauses found; the result\n    of clause default goes in *pdefault.  */\n@@ -30953,6 +31485,304 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n   return true;\n }\n \n+/* OpenACC 2.0:\n+   # pragma acc cache (variable-list) new-line\n+*/\n+\n+static tree\n+cp_parser_oacc_cache (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree stmt, clauses;\n+\n+  clauses = cp_parser_omp_var_list (parser, OMP_CLAUSE__CACHE_, NULL_TREE);\n+  clauses = finish_omp_clauses (clauses);\n+\n+  cp_parser_require_pragma_eol (parser, cp_lexer_peek_token (parser->lexer));\n+\n+  stmt = make_node (OACC_CACHE);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OACC_CACHE_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, pragma_tok->location);\n+  add_stmt (stmt);\n+\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc data oacc-data-clause[optseq] new-line\n+     structured-block  */\n+\n+#define OACC_DATA_CLAUSE_MASK\t\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DEVICEPTR)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE))\n+\n+static tree\n+cp_parser_oacc_data (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree stmt, clauses, block;\n+  unsigned int save;\n+\n+  clauses = cp_parser_oacc_all_clauses (parser, OACC_DATA_CLAUSE_MASK,\n+\t\t\t\t\t\"#pragma acc data\", pragma_tok);\n+\n+  block = begin_omp_parallel ();\n+  save = cp_parser_begin_omp_structured_block (parser);\n+  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_end_omp_structured_block (parser, save);\n+  stmt = finish_oacc_data (clauses, block);\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc enter data oacc-enter-data-clause[optseq] new-line\n+\n+   or\n+\n+   # pragma acc exit data oacc-exit-data-clause[optseq] new-line\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+#define OACC_ENTER_DATA_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT) )\n+\n+#define OACC_EXIT_DATA_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DELETE) \t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT) )\n+\n+static tree\n+cp_parser_oacc_enter_exit_data (cp_parser *parser, cp_token *pragma_tok,\n+\t\t\t\tbool enter)\n+{\n+  tree stmt, clauses;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA_EOL)\n+     || cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+    {\n+      cp_parser_error (parser, enter\n+\t\t       ? \"expected %<data%> in %<#pragma acc enter data%>\"\n+\t\t       : \"expected %<data%> in %<#pragma acc exit data%>\");\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return NULL_TREE;\n+    }\n+\n+  const char *p =\n+    IDENTIFIER_POINTER (cp_lexer_peek_token (parser->lexer)->u.value);\n+  if (strcmp (p, \"data\") != 0)\n+    {\n+      cp_parser_error (parser, \"invalid pragma\");\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return NULL_TREE;\n+    }\n+\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  if (enter)\n+    clauses = cp_parser_oacc_all_clauses (parser, OACC_ENTER_DATA_CLAUSE_MASK,\n+\t\t\t\t\t \"#pragma acc enter data\", pragma_tok);\n+  else\n+    clauses = cp_parser_oacc_all_clauses (parser, OACC_EXIT_DATA_CLAUSE_MASK,\n+\t\t\t\t\t \"#pragma acc exit data\", pragma_tok);\n+\n+  if (find_omp_clause (clauses, OMP_CLAUSE_MAP) == NULL_TREE)\n+    {\n+      error_at (pragma_tok->location,\n+\t\t\"%<#pragma acc enter data%> has no data movement clause\");\n+      return NULL_TREE;\n+    }\n+\n+  stmt = enter ? make_node (OACC_ENTER_DATA) : make_node (OACC_EXIT_DATA);\n+  TREE_TYPE (stmt) = void_type_node;\n+  if (enter)\n+    OACC_ENTER_DATA_CLAUSES (stmt) = clauses;\n+  else\n+    OACC_EXIT_DATA_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, pragma_tok->location);\n+  add_stmt (stmt);\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc kernels oacc-kernels-clause[optseq] new-line\n+     structured-block  */\n+\n+#define OACC_KERNELS_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DEVICEPTR)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT))\n+\n+static tree\n+cp_parser_oacc_kernels (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree stmt, clauses, block;\n+  unsigned int save;\n+\n+  clauses = cp_parser_oacc_all_clauses (parser, OACC_KERNELS_CLAUSE_MASK,\n+\t\t\t\t\t\"#pragma acc kernels\", pragma_tok);\n+\n+  block = begin_omp_parallel ();\n+  save = cp_parser_begin_omp_structured_block (parser);\n+  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_end_omp_structured_block (parser, save);\n+  stmt = finish_oacc_kernels (clauses, block);\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc loop oacc-loop-clause[optseq] new-line\n+     structured-block  */\n+\n+#define OACC_LOOP_CLAUSE_MASK\t\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COLLAPSE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_REDUCTION))\n+\n+static tree\n+cp_parser_oacc_loop (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree stmt, clauses, block;\n+  int save;\n+\n+  clauses = cp_parser_oacc_all_clauses (parser, OACC_LOOP_CLAUSE_MASK,\n+\t\t\t\t\t\"#pragma acc loop\", pragma_tok);\n+\n+  block = begin_omp_structured_block ();\n+  save = cp_parser_begin_omp_structured_block (parser);\n+  stmt = cp_parser_omp_for_loop (parser, OACC_LOOP, clauses, NULL);\n+  cp_parser_end_omp_structured_block (parser, save);\n+  add_stmt (finish_omp_structured_block (block));\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc parallel oacc-parallel-clause[optseq] new-line\n+     structured-block  */\n+\n+#define OACC_PARALLEL_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPY)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYIN)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_COPYOUT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_CREATE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DEVICEPTR)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_NUM_GANGS)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_NUM_WORKERS)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPY)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYIN)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_COPYOUT)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_PRESENT_OR_CREATE)   \\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_REDUCTION)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_VECTOR_LENGTH)       \\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT))\n+\n+static tree\n+cp_parser_oacc_parallel (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree stmt, clauses, block;\n+  unsigned int save;\n+\n+  clauses = cp_parser_oacc_all_clauses (parser, OACC_PARALLEL_CLAUSE_MASK,\n+\t\t\t\t\t \"#pragma acc parallel\", pragma_tok);\n+\n+  block = begin_omp_parallel ();\n+  save = cp_parser_begin_omp_structured_block (parser);\n+  cp_parser_statement (parser, NULL_TREE, false, NULL);\n+  cp_parser_end_omp_structured_block (parser, save);\n+  stmt = finish_oacc_parallel (clauses, block);\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc update oacc-update-clause[optseq] new-line\n+*/\n+\n+#define OACC_UPDATE_CLAUSE_MASK\t\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_DEVICE)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_HOST)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_IF)\t\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_SELF)\t\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_WAIT))\n+\n+static tree\n+cp_parser_oacc_update (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree stmt, clauses;\n+\n+  clauses = cp_parser_oacc_all_clauses (parser, OACC_UPDATE_CLAUSE_MASK,\n+\t\t\t\t\t \"#pragma acc update\", pragma_tok);\n+\n+  if (find_omp_clause (clauses, OMP_CLAUSE_MAP) == NULL_TREE)\n+    {\n+      error_at (pragma_tok->location,\n+\t\t\"%<#pragma acc update%> must contain at least one \"\n+\t\t\"%<device%> or %<host/self%> clause\");\n+      return NULL_TREE;\n+    }\n+\n+  stmt = make_node (OACC_UPDATE);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OACC_UPDATE_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, pragma_tok->location);\n+  add_stmt (stmt);\n+  return stmt;\n+}\n+\n+/* OpenACC 2.0:\n+   # pragma acc wait [(intseq)] oacc-wait-clause[optseq] new-line\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+#define OACC_WAIT_CLAUSE_MASK\t\t\t\t\t\\\n+\t( (OMP_CLAUSE_MASK_1 << PRAGMA_OACC_CLAUSE_ASYNC))\n+\n+static tree\n+cp_parser_oacc_wait (cp_parser *parser, cp_token *pragma_tok)\n+{\n+  tree clauses, list = NULL_TREE, stmt = NULL_TREE;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  if (cp_lexer_peek_token (parser->lexer)->type == CPP_OPEN_PAREN)\n+    list = cp_parser_oacc_wait_list (parser, loc, list);\n+\n+  clauses = cp_parser_oacc_all_clauses (parser, OACC_WAIT_CLAUSE_MASK,\n+\t\t\t\t\t\"#pragma acc wait\", pragma_tok);\n+\n+  stmt = c_finish_oacc_wait (loc, list, clauses);\n+\n+  return stmt;\n+}\n+\n /* OpenMP 4.0:\n    # pragma omp declare simd declare-simd-clauses[optseq] new-line  */\n \n@@ -31627,6 +32457,33 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n \n   switch (pragma_tok->pragma_kind)\n     {\n+    case PRAGMA_OACC_CACHE:\n+      stmt = cp_parser_oacc_cache (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OACC_DATA:\n+      stmt = cp_parser_oacc_data (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OACC_ENTER_DATA:\n+      stmt = cp_parser_oacc_enter_exit_data (parser, pragma_tok, true);\n+      break;\n+    case PRAGMA_OACC_EXIT_DATA:\n+      stmt = cp_parser_oacc_enter_exit_data (parser, pragma_tok, false);\n+      break;\n+    case PRAGMA_OACC_KERNELS:\n+      stmt = cp_parser_oacc_kernels (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OACC_LOOP:\n+      stmt = cp_parser_oacc_loop (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OACC_PARALLEL:\n+      stmt = cp_parser_oacc_parallel (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OACC_UPDATE:\n+      stmt = cp_parser_oacc_update (parser, pragma_tok);\n+      break;\n+    case PRAGMA_OACC_WAIT:\n+      stmt = cp_parser_oacc_wait (parser, pragma_tok);\n+      break;\n     case PRAGMA_OMP_ATOMIC:\n       cp_parser_omp_atomic (parser, pragma_tok);\n       return;\n@@ -32169,6 +33026,15 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n       cp_parser_omp_declare (parser, pragma_tok, context);\n       return false;\n \n+    case PRAGMA_OACC_CACHE:\n+    case PRAGMA_OACC_DATA:\n+    case PRAGMA_OACC_ENTER_DATA:\n+    case PRAGMA_OACC_EXIT_DATA:\n+    case PRAGMA_OACC_KERNELS:\n+    case PRAGMA_OACC_PARALLEL:\n+    case PRAGMA_OACC_LOOP:\n+    case PRAGMA_OACC_UPDATE:\n+    case PRAGMA_OACC_WAIT:\n     case PRAGMA_OMP_ATOMIC:\n     case PRAGMA_OMP_CRITICAL:\n     case PRAGMA_OMP_DISTRIBUTE:"}, {"sha": "915048daf0a81e4ee9ca8ca673c61689013b34a9", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 98, "deletions": 4, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -66,6 +66,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-low.h\"\n #include \"builtins.h\"\n #include \"convert.h\"\n+#include \"gomp-constants.h\"\n \n /* There routines provide a modular interface to perform many parsing\n    operations.  They may therefore be used during actual parsing, or\n@@ -4670,7 +4671,7 @@ handle_omp_array_sections (tree c)\n \t    return false;\n \t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t      OMP_CLAUSE_MAP);\n-\t  OMP_CLAUSE_MAP_KIND (c2) = OMP_CLAUSE_MAP_POINTER;\n+\t  OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_POINTER);\n \t  if (!cxx_mark_addressable (t))\n \t    return false;\n \t  OMP_CLAUSE_DECL (c2) = t;\n@@ -4694,7 +4695,7 @@ handle_omp_array_sections (tree c)\n \t    {\n \t      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t  OMP_CLAUSE_MAP);\n-\t      OMP_CLAUSE_MAP_KIND (c3) = OMP_CLAUSE_MAP_POINTER;\n+\t      OMP_CLAUSE_SET_MAP_KIND (c3, GOMP_MAP_POINTER);\n \t      OMP_CLAUSE_DECL (c3) = ptr;\n \t      OMP_CLAUSE_DECL (c2) = convert_from_reference (ptr);\n \t      OMP_CLAUSE_SIZE (c3) = size_zero_node;\n@@ -5571,6 +5572,44 @@ finish_omp_clauses (tree clauses)\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_ASYNC:\n+\t  t = OMP_CLAUSE_ASYNC_EXPR (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error (\"%<async%> expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\tt = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t      OMP_CLAUSE_ASYNC_EXPR (c) = t;\n+\t    }\n+\t  break;\n+\n+\tcase OMP_CLAUSE_VECTOR_LENGTH:\n+\t  t = OMP_CLAUSE_VECTOR_LENGTH_EXPR (c);\n+\t  t = maybe_convert_cond (t);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!processing_template_decl)\n+\t    t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t  OMP_CLAUSE_VECTOR_LENGTH_EXPR (c) = t;\n+\t  break;\n+\n+\tcase OMP_CLAUSE_WAIT:\n+\t  t = OMP_CLAUSE_WAIT_EXPR (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!processing_template_decl)\n+\t    t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t  OMP_CLAUSE_WAIT_EXPR (c) = t;\n+\t  break;\n+\n \tcase OMP_CLAUSE_THREAD_LIMIT:\n \t  t = OMP_CLAUSE_THREAD_LIMIT_EXPR (c);\n \t  if (t == error_mark_node)\n@@ -5721,6 +5760,7 @@ finish_omp_clauses (tree clauses)\n \tcase OMP_CLAUSE_MAP:\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_FROM:\n+\tcase OMP_CLAUSE__CACHE_:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) == TREE_LIST)\n \t    {\n@@ -5749,7 +5789,7 @@ finish_omp_clauses (tree clauses)\n \t      if (processing_template_decl)\n \t\tbreak;\n \t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t  && OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER)\n+\t\t  && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER)\n \t\tbreak;\n \t      if (DECL_P (t))\n \t\terror (\"%qD is not a variable in %qs clause\", t,\n@@ -5770,7 +5810,7 @@ finish_omp_clauses (tree clauses)\n \t\t   && !cxx_mark_addressable (t))\n \t    remove = true;\n \t  else if (!(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t     && OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER)\n+\t\t     && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER)\n \t\t   && !type_dependent_expression_p (t)\n \t\t   && !cp_omp_mappable_type ((TREE_CODE (TREE_TYPE (t))\n \t\t\t\t\t      == REFERENCE_TYPE)\n@@ -6088,6 +6128,60 @@ finish_omp_structured_block (tree block)\n   return do_poplevel (block);\n }\n \n+/* Generate OACC_DATA, with CLAUSES and BLOCK as its compound\n+   statement.  LOC is the location of the OACC_DATA.  */\n+\n+tree\n+finish_oacc_data (tree clauses, tree block)\n+{\n+  tree stmt;\n+\n+  block = finish_omp_structured_block (block);\n+\n+  stmt = make_node (OACC_DATA);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OACC_DATA_CLAUSES (stmt) = clauses;\n+  OACC_DATA_BODY (stmt) = block;\n+\n+  return add_stmt (stmt);\n+}\n+\n+/* Generate OACC_KERNELS, with CLAUSES and BLOCK as its compound\n+   statement.  LOC is the location of the OACC_KERNELS.  */\n+\n+tree\n+finish_oacc_kernels (tree clauses, tree block)\n+{\n+  tree stmt;\n+\n+  block = finish_omp_structured_block (block);\n+\n+  stmt = make_node (OACC_KERNELS);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OACC_KERNELS_CLAUSES (stmt) = clauses;\n+  OACC_KERNELS_BODY (stmt) = block;\n+\n+  return add_stmt (stmt);\n+}\n+\n+/* Generate OACC_PARALLEL, with CLAUSES and BLOCK as its compound\n+   statement.  LOC is the location of the OACC_PARALLEL.  */\n+\n+tree\n+finish_oacc_parallel (tree clauses, tree block)\n+{\n+  tree stmt;\n+\n+  block = finish_omp_structured_block (block);\n+\n+  stmt = make_node (OACC_PARALLEL);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OACC_PARALLEL_CLAUSES (stmt) = clauses;\n+  OACC_PARALLEL_BODY (stmt) = block;\n+\n+  return add_stmt (stmt);\n+}\n+\n /* Similarly, except force the retention of the BLOCK.  */\n \n tree"}, {"sha": "bbafad9f931e68cc1afe389532fb68c8366384a7", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1819,6 +1819,7 @@ There are also several varieties of complex statements.\n * Jumps::\n * Cleanups::\n * OpenMP::\n+* OpenACC::\n @end menu\n \n @node Basic Statements\n@@ -2093,8 +2094,8 @@ variables.\n \n @item OMP_FOR\n \n-Represents @code{#pragma omp for [clause1 @dots{} clauseN]}.  It\n-has 5 operands:\n+Represents @code{#pragma omp for [clause1 @dots{} clauseN]}.  It has\n+six operands:\n \n Operand @code{OMP_FOR_BODY} contains the loop body.\n \n@@ -2184,10 +2185,9 @@ building code (@code{omp-low.c}).\n @item OMP_CONTINUE\n \n Similarly, this instruction does not represent an OpenMP\n-directive, it is used by @code{OMP_FOR} and\n+directive, it is used by @code{OMP_FOR} (and similar codes) as well as\n @code{OMP_SECTIONS} to mark the place where the code needs to\n-loop to the next iteration (in the case of @code{OMP_FOR}) or\n-the next section (in the case of @code{OMP_SECTIONS}).\n+loop to the next iteration, or the next section, respectively.\n \n In some cases, @code{OMP_CONTINUE} is placed right before\n @code{OMP_RETURN}.  But if there are cleanups that need to\n@@ -2233,6 +2233,67 @@ compilation.\n \n @end table\n \n+@node OpenACC\n+@subsection OpenACC\n+@tindex OACC_CACHE\n+@tindex OACC_DATA\n+@tindex OACC_DECLARE\n+@tindex OACC_ENTER_DATA\n+@tindex OACC_EXIT_DATA\n+@tindex OACC_HOST_DATA\n+@tindex OACC_KERNELS\n+@tindex OACC_LOOP\n+@tindex OACC_PARALLEL\n+@tindex OACC_UPDATE\n+\n+All the statements starting with @code{OACC_} represent directives and\n+clauses used by the OpenACC API @w{@uref{http://www.openacc.org/}}.\n+\n+@table @code\n+@item OACC_CACHE\n+\n+Represents @code{#pragma acc cache (var @dots{})}.\n+\n+@item OACC_DATA\n+\n+Represents @code{#pragma acc data [clause1 @dots{} clauseN]}.\n+\n+@item OACC_DECLARE\n+\n+Represents @code{#pragma acc declare [clause1 @dots{} clauseN]}.\n+\n+@item OACC_ENTER_DATA\n+\n+Represents @code{#pragma acc enter data [clause1 @dots{} clauseN]}.\n+\n+@item OACC_EXIT_DATA\n+\n+Represents @code{#pragma acc exit data [clause1 @dots{} clauseN]}.\n+\n+@item OACC_HOST_DATA\n+\n+Represents @code{#pragma acc host_data [clause1 @dots{} clauseN]}.\n+\n+@item OACC_KERNELS\n+\n+Represents @code{#pragma acc kernels [clause1 @dots{} clauseN]}.\n+\n+@item OACC_LOOP\n+\n+Represents @code{#pragma acc loop [clause1 @dots{} clauseN]}.\n+\n+See the description of the @code{OMP_FOR} code.\n+\n+@item OACC_PARALLEL\n+\n+Represents @code{#pragma acc parallel [clause1 @dots{} clauseN]}.\n+\n+@item OACC_UPDATE\n+\n+Represents @code{#pragma acc update [clause1 @dots{} clauseN]}.\n+\n+@end table\n+\n @c ---------------------------------------------------------------------\n @c Functions\n @c ---------------------------------------------------------------------"}, {"sha": "543de90c35c9ee5a4d637975254ba8489c963b93", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1828,9 +1828,8 @@ Set @code{NAME} to be the name associated with @code{OMP} critical statement @co\n tree clauses, tree index, tree initial, tree final, tree incr, @\n gimple_seq pre_body, enum tree_code omp_for_cond)\n Build a @code{GIMPLE_OMP_FOR} statement. @code{BODY} is sequence of statements\n-inside the for loop.  @code{CLAUSES}, are any of the @code{OMP} loop\n-construct's clauses: private, firstprivate,  lastprivate,\n-reductions, ordered, schedule, and nowait.  @code{PRE_BODY} is the\n+inside the for loop.  @code{CLAUSES}, are any of the loop\n+construct's clauses.  @code{PRE_BODY} is the\n sequence of statements that are loop invariant.  @code{INDEX} is the\n index variable.  @code{INITIAL} is the initial value of @code{INDEX}.  @code{FINAL} is\n final value of @code{INDEX}.  OMP_FOR_COND is the predicate used to"}, {"sha": "510201acb2400ce349fd474f5e0525e54f1837e0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -168,8 +168,8 @@ in the following sections.\n @gccoptlist{-ansi  -std=@var{standard}  -fgnu89-inline @gol\n -aux-info @var{filename} -fallow-parameterless-variadic-functions @gol\n -fno-asm  -fno-builtin  -fno-builtin-@var{function} @gol\n--fhosted  -ffreestanding -fopenmp -fopenmp-simd -fms-extensions @gol\n--fplan9-extensions -trigraphs  -traditional  -traditional-cpp @gol\n+-fhosted  -ffreestanding -fopenacc -fopenmp -fopenmp-simd @gol\n+-fms-extensions -fplan9-extensions -trigraphs -traditional -traditional-cpp @gol\n -fallow-single-precision  -fcond-mismatch -flax-vector-conversions @gol\n -fsigned-bitfields  -fsigned-char @gol\n -funsigned-bitfields  -funsigned-char}\n@@ -1885,6 +1885,20 @@ This is equivalent to @option{-fno-hosted}.\n @xref{Standards,,Language Standards Supported by GCC}, for details of\n freestanding and hosted environments.\n \n+@item -fopenacc\n+@opindex fopenacc\n+@cindex OpenACC accelerator programming\n+Enable handling of OpenACC directives @code{#pragma acc} in C/C++ and\n+@code{!$acc} in Fortran.  When @option{-fopenacc} is specified, the\n+compiler generates accelerated code according to the OpenACC Application\n+Programming Interface v2.0 @w{@uref{http://www.openacc.org/}}.  This option\n+implies @option{-pthread}, and thus is only supported on targets that\n+have support for @option{-pthread}.\n+\n+Note that this is an experimental feature, incomplete, and subject to\n+change in future versions of GCC.  See\n+@w{@uref{https://gcc.gnu.org/wiki/OpenACC}} for more information.\n+\n @item -fopenmp\n @opindex fopenmp\n @cindex OpenMP parallel"}, {"sha": "738e55832ae113073ee8149115ba5a866d273c10", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1836,6 +1836,9 @@ Target supports Graphite optimizations.\n @item fixed_point\n Target supports fixed-point extension to C.\n \n+@item fopenacc\n+Target supports OpenACC via @option{-fopenacc}.\n+\n @item fopenmp\n Target supports OpenMP via @option{-fopenmp}.\n "}, {"sha": "d8b72a2d54255ba1cec3205599187c85bcd1975d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,199 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Ilmir Usmanov  <i.usmanov@samsung.com>\n+\t    Tobias Burnus  <burnus@net-b.de>\n+\n+\t* lang.opt (fopenacc): New option.\n+\t* cpp.c (cpp_define_builtins): Conditionally define _OPENACC.\n+\t* dump-parse-tree.c (show_omp_node): Split part of it into...\n+\t(show_omp_clauses): ... this new function.\n+\t(show_omp_node, show_code_node): Handle EXEC_OACC_PARALLEL_LOOP,\n+\tEXEC_OACC_PARALLEL, EXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS,\n+\tEXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,\n+\tEXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,\n+\tEXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.\n+\t(show_namespace): Update for OpenACC.\n+\t* f95-lang.c (DEF_FUNCTION_TYPE_VAR_2, DEF_FUNCTION_TYPE_VAR_8)\n+\t(DEF_FUNCTION_TYPE_VAR_12, DEF_GOACC_BUILTIN)\n+\t(DEF_GOACC_BUILTIN_COMPILER): New macros.\n+\t* types.def (BT_FN_VOID_INT_INT_VAR)\n+\t(BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR)\n+\t(BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR):\n+\tNew function types.\n+\t* gfortran.h (gfc_statement): Add ST_OACC_PARALLEL_LOOP,\n+\tST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL, ST_OACC_END_PARALLEL,\n+\tST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_DATA,\n+\tST_OACC_END_DATA, ST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA,\n+\tST_OACC_LOOP, ST_OACC_END_LOOP, ST_OACC_DECLARE, ST_OACC_UPDATE,\n+\tST_OACC_WAIT, ST_OACC_CACHE, ST_OACC_KERNELS_LOOP,\n+\tST_OACC_END_KERNELS_LOOP, ST_OACC_ENTER_DATA, ST_OACC_EXIT_DATA,\n+\tST_OACC_ROUTINE.\n+\t(struct gfc_expr_list): New data type.\n+\t(gfc_get_expr_list): New macro.\n+\t(gfc_omp_map_op): Add OMP_MAP_FORCE_ALLOC, OMP_MAP_FORCE_DEALLOC,\n+\tOMP_MAP_FORCE_TO, OMP_MAP_FORCE_FROM, OMP_MAP_FORCE_TOFROM,\n+\tOMP_MAP_FORCE_PRESENT, OMP_MAP_FORCE_DEVICEPTR.\n+\t(OMP_LIST_FIRST, OMP_LIST_DEVICE_RESIDENT, OMP_LIST_USE_DEVICE)\n+\t(OMP_LIST_CACHE): New enumerators.\n+\t(struct gfc_omp_clauses): Add async_expr, gang_expr, worker_expr,\n+\tvector_expr, num_gangs_expr, num_workers_expr, vector_length_expr,\n+\twait_list, tile_list, async, gang, worker, vector, seq,\n+\tindependent, wait, par_auto, gang_static, and loc members.\n+\t(struct gfc_namespace): Add oacc_declare_clauses member.\n+\t(gfc_exec_op): Add EXEC_OACC_KERNELS_LOOP,\n+\tEXEC_OACC_PARALLEL_LOOP, EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS,\n+\tEXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,\n+\tEXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,\n+\tEXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.\n+\t(gfc_free_expr_list, gfc_resolve_oacc_directive)\n+\t(gfc_resolve_oacc_declare, gfc_resolve_oacc_parallel_loop_blocks)\n+\t(gfc_resolve_oacc_blocks): New prototypes.\n+\t* match.c (match_exit_cycle): Handle EXEC_OACC_LOOP and\n+\tEXEC_OACC_PARALLEL_LOOP.\n+\t* match.h (gfc_match_oacc_cache, gfc_match_oacc_wait)\n+\t(gfc_match_oacc_update, gfc_match_oacc_declare)\n+\t(gfc_match_oacc_loop, gfc_match_oacc_host_data)\n+\t(gfc_match_oacc_data, gfc_match_oacc_kernels)\n+\t(gfc_match_oacc_kernels_loop, gfc_match_oacc_parallel)\n+\t(gfc_match_oacc_parallel_loop, gfc_match_oacc_enter_data)\n+\t(gfc_match_oacc_exit_data, gfc_match_oacc_routine): New\n+\tprototypes.\n+\t* openmp.c: Include \"diagnostic.h\" and \"gomp-constants.h\".\n+\t(gfc_free_omp_clauses): Update for members added to struct\n+\tgfc_omp_clauses.\n+\t(gfc_match_omp_clauses): Change mask paramter to uint64_t.  Add\n+\topenacc parameter.\n+\t(resolve_omp_clauses): Add openacc parameter.  Update for OpenACC.\n+\t(struct fortran_omp_context): Add is_openmp member.\n+\t(gfc_resolve_omp_parallel_blocks): Initialize it.\n+\t(gfc_resolve_do_iterator): Update for OpenACC.\n+\t(gfc_resolve_omp_directive): Call\n+\tresolve_omp_directive_inside_oacc_region.\n+\t(OMP_CLAUSE_PRIVATE, OMP_CLAUSE_FIRSTPRIVATE)\n+\t(OMP_CLAUSE_LASTPRIVATE, OMP_CLAUSE_COPYPRIVATE)\n+\t(OMP_CLAUSE_SHARED, OMP_CLAUSE_COPYIN, OMP_CLAUSE_REDUCTION)\n+\t(OMP_CLAUSE_IF, OMP_CLAUSE_NUM_THREADS, OMP_CLAUSE_SCHEDULE)\n+\t(OMP_CLAUSE_DEFAULT, OMP_CLAUSE_ORDERED, OMP_CLAUSE_COLLAPSE)\n+\t(OMP_CLAUSE_UNTIED, OMP_CLAUSE_FINAL, OMP_CLAUSE_MERGEABLE)\n+\t(OMP_CLAUSE_ALIGNED, OMP_CLAUSE_DEPEND, OMP_CLAUSE_INBRANCH)\n+\t(OMP_CLAUSE_LINEAR, OMP_CLAUSE_NOTINBRANCH, OMP_CLAUSE_PROC_BIND)\n+\t(OMP_CLAUSE_SAFELEN, OMP_CLAUSE_SIMDLEN, OMP_CLAUSE_UNIFORM)\n+\t(OMP_CLAUSE_DEVICE, OMP_CLAUSE_MAP, OMP_CLAUSE_TO)\n+\t(OMP_CLAUSE_FROM, OMP_CLAUSE_NUM_TEAMS, OMP_CLAUSE_THREAD_LIMIT)\n+\t(OMP_CLAUSE_DIST_SCHEDULE): Use uint64_t.\n+\t(OMP_CLAUSE_ASYNC, OMP_CLAUSE_NUM_GANGS, OMP_CLAUSE_NUM_WORKERS)\n+\t(OMP_CLAUSE_VECTOR_LENGTH, OMP_CLAUSE_COPY, OMP_CLAUSE_COPYOUT)\n+\t(OMP_CLAUSE_CREATE, OMP_CLAUSE_PRESENT)\n+\t(OMP_CLAUSE_PRESENT_OR_COPY, OMP_CLAUSE_PRESENT_OR_COPYIN)\n+\t(OMP_CLAUSE_PRESENT_OR_COPYOUT, OMP_CLAUSE_PRESENT_OR_CREATE)\n+\t(OMP_CLAUSE_DEVICEPTR, OMP_CLAUSE_GANG, OMP_CLAUSE_WORKER)\n+\t(OMP_CLAUSE_VECTOR, OMP_CLAUSE_SEQ, OMP_CLAUSE_INDEPENDENT)\n+\t(OMP_CLAUSE_USE_DEVICE, OMP_CLAUSE_DEVICE_RESIDENT)\n+\t(OMP_CLAUSE_HOST_SELF, OMP_CLAUSE_OACC_DEVICE, OMP_CLAUSE_WAIT)\n+\t(OMP_CLAUSE_DELETE, OMP_CLAUSE_AUTO, OMP_CLAUSE_TILE): New macros.\n+\t(gfc_match_omp_clauses): Handle those.\n+\t(OACC_PARALLEL_CLAUSES, OACC_KERNELS_CLAUSES, OACC_DATA_CLAUSES)\n+\t(OACC_LOOP_CLAUSES, OACC_PARALLEL_LOOP_CLAUSES)\n+\t(OACC_KERNELS_LOOP_CLAUSES, OACC_HOST_DATA_CLAUSES)\n+\t(OACC_DECLARE_CLAUSES, OACC_UPDATE_CLAUSES)\n+\t(OACC_ENTER_DATA_CLAUSES, OACC_EXIT_DATA_CLAUSES)\n+\t(OACC_WAIT_CLAUSES): New macros.\n+\t(gfc_free_expr_list, match_oacc_expr_list, match_oacc_clause_gang)\n+\t(gfc_match_omp_map_clause, gfc_match_oacc_parallel_loop)\n+\t(gfc_match_oacc_parallel, gfc_match_oacc_kernels_loop)\n+\t(gfc_match_oacc_kernels, gfc_match_oacc_data)\n+\t(gfc_match_oacc_host_data, gfc_match_oacc_loop)\n+\t(gfc_match_oacc_declare, gfc_match_oacc_update)\n+\t(gfc_match_oacc_enter_data, gfc_match_oacc_exit_data)\n+\t(gfc_match_oacc_wait, gfc_match_oacc_cache)\n+\t(gfc_match_oacc_routine, oacc_is_loop)\n+\t(resolve_oacc_scalar_int_expr, resolve_oacc_positive_int_expr)\n+\t(check_symbol_not_pointer, check_array_not_assumed)\n+\t(resolve_oacc_data_clauses, resolve_oacc_deviceptr_clause)\n+\t(oacc_compatible_clauses, oacc_is_parallel, oacc_is_kernels)\n+\t(omp_code_to_statement, oacc_code_to_statement)\n+\t(resolve_oacc_directive_inside_omp_region)\n+\t(resolve_omp_directive_inside_oacc_region)\n+\t(resolve_oacc_nested_loops, resolve_oacc_params_in_parallel)\n+\t(resolve_oacc_loop_blocks, gfc_resolve_oacc_blocks)\n+\t(resolve_oacc_loop, resolve_oacc_cache, gfc_resolve_oacc_declare)\n+\t(gfc_resolve_oacc_directive): New functions.\n+\t* parse.c (next_free): Update for OpenACC.  Move some code into...\n+\t(verify_token_free): ... this new function.\n+\t(next_fixed): Update for OpenACC.  Move some code into...\n+\t(verify_token_fixed): ... this new function.\n+\t(case_executable): Add ST_OACC_UPDATE, ST_OACC_WAIT,\n+\tST_OACC_CACHE, ST_OACC_ENTER_DATA, and ST_OACC_EXIT_DATA.\n+\t(case_exec_markers): Add ST_OACC_PARALLEL_LOOP, ST_OACC_PARALLEL,\n+\tST_OACC_KERNELS, ST_OACC_DATA, ST_OACC_HOST_DATA, ST_OACC_LOOP,\n+\tST_OACC_KERNELS_LOOP.\n+\t(case_decl): Add ST_OACC_ROUTINE.\n+\t(push_state, parse_critical_block, parse_progunit): Update for\n+\tOpenACC.\n+\t(gfc_ascii_statement): Handle ST_OACC_PARALLEL_LOOP,\n+\tST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL, ST_OACC_END_PARALLEL,\n+\tST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_KERNELS_LOOP,\n+\tST_OACC_END_KERNELS_LOOP, ST_OACC_DATA, ST_OACC_END_DATA,\n+\tST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA, ST_OACC_LOOP,\n+\tST_OACC_END_LOOP, ST_OACC_DECLARE, ST_OACC_UPDATE, ST_OACC_WAIT,\n+\tST_OACC_CACHE, ST_OACC_ENTER_DATA, ST_OACC_EXIT_DATA,\n+\tST_OACC_ROUTINE.\n+\t(verify_st_order, parse_spec): Handle ST_OACC_DECLARE.\n+\t(parse_executable): Handle ST_OACC_PARALLEL_LOOP,\n+\tST_OACC_KERNELS_LOOP, ST_OACC_LOOP, ST_OACC_PARALLEL,\n+\tST_OACC_KERNELS, ST_OACC_DATA, ST_OACC_HOST_DATA.\n+\t(decode_oacc_directive, parse_oacc_structured_block)\n+\t(parse_oacc_loop, is_oacc): New functions.\n+\t* parse.h (struct gfc_state_data): Add oacc_declare_clauses\n+\tmember.\n+\t(is_oacc): New prototype.\n+\t* resolve.c (gfc_resolve_blocks, gfc_resolve_code): Handle\n+\tEXEC_OACC_PARALLEL_LOOP, EXEC_OACC_PARALLEL,\n+\tEXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS, EXEC_OACC_DATA,\n+\tEXEC_OACC_HOST_DATA, EXEC_OACC_LOOP, EXEC_OACC_UPDATE,\n+\tEXEC_OACC_WAIT, EXEC_OACC_CACHE, EXEC_OACC_ENTER_DATA,\n+\tEXEC_OACC_EXIT_DATA.\n+\t(resolve_codes): Call gfc_resolve_oacc_declare.\n+\t* scanner.c (openacc_flag, openacc_locus): New variables.\n+\t(skip_free_comments): Update for OpenACC.  Move some code into...\n+\t(skip_omp_attribute): ... this new function.\n+\t(skip_oacc_attribute): New function.\n+\t(skip_fixed_comments, gfc_next_char_literal): Update for OpenACC.\n+\t* st.c (gfc_free_statement): Handle EXEC_OACC_PARALLEL_LOOP,\n+\tEXEC_OACC_PARALLEL, EXEC_OACC_KERNELS_LOOP, EXEC_OACC_KERNELS,\n+\tEXEC_OACC_DATA, EXEC_OACC_HOST_DATA, EXEC_OACC_LOOP,\n+\tEXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,\n+\tEXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA.\n+\t* trans-decl.c (gfc_generate_function_code): Update for OpenACC.\n+\t* trans-openmp.c: Include \"gomp-constants.h\".\n+\t(gfc_omp_finish_clause, gfc_trans_omp_clauses): Use GOMP_MAP_*\n+\tinstead of OMP_CLAUSE_MAP_*.  Use OMP_CLAUSE_SET_MAP_KIND.\n+\t(gfc_trans_omp_clauses): Handle OMP_LIST_USE_DEVICE,\n+\tOMP_LIST_DEVICE_RESIDENT, OMP_LIST_CACHE, and OMP_MAP_FORCE_ALLOC,\n+\tOMP_MAP_FORCE_DEALLOC, OMP_MAP_FORCE_TO, OMP_MAP_FORCE_FROM,\n+\tOMP_MAP_FORCE_TOFROM, OMP_MAP_FORCE_PRESENT,\n+\tOMP_MAP_FORCE_DEVICEPTR, and gfc_omp_clauses' async, seq,\n+\tindependent, wait_list, num_gangs_expr, num_workers_expr,\n+\tvector_length_expr, vector, vector_expr, worker, worker_expr,\n+\tgang, gang_expr members.\n+\t(gfc_trans_omp_do): Handle EXEC_OACC_LOOP.\n+\t(gfc_convert_expr_to_tree, gfc_trans_oacc_construct)\n+\t(gfc_trans_oacc_executable_directive)\n+\t(gfc_trans_oacc_wait_directive, gfc_trans_oacc_combined_directive)\n+\t(gfc_trans_oacc_declare, gfc_trans_oacc_directive): New functions.\n+\t* trans-stmt.c (gfc_trans_block_construct): Update for OpenACC.\n+\t* trans-stmt.h (gfc_trans_oacc_directive, gfc_trans_oacc_declare):\n+\tNew prototypes.\n+\t* trans.c (tranc_code): Handle EXEC_OACC_CACHE, EXEC_OACC_WAIT,\n+\tEXEC_OACC_UPDATE, EXEC_OACC_LOOP, EXEC_OACC_HOST_DATA,\n+\tEXEC_OACC_DATA, EXEC_OACC_KERNELS, EXEC_OACC_KERNELS_LOOP,\n+\tEXEC_OACC_PARALLEL, EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_ENTER_DATA,\n+\tEXEC_OACC_EXIT_DATA.\n+\t* gfortran.texi: Update for OpenACC.\n+\t* intrinsic.texi: Likewise.\n+\t* invoke.texi: Likewise.\n+\n 2015-01-15  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/58023"}, {"sha": "e239f21b5657d4d137459a62020d13cc2cdac792", "filename": "gcc/fortran/cpp.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -179,6 +179,9 @@ cpp_define_builtins (cpp_reader *pfile)\n   cpp_define (pfile, \"__GFORTRAN__=1\");\n   cpp_define (pfile, \"_LANGUAGE_FORTRAN=1\");\n \n+  if (flag_openacc)\n+    cpp_define (pfile, \"_OPENACC=201306\");\n+\n   if (flag_openmp)\n     cpp_define (pfile, \"_OPENMP=201307\");\n "}, {"sha": "83ecbaa3d823696c800840f287c88b03ccc7d1de", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 312, "deletions": 166, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1072,17 +1072,288 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n     }\n }\n \n-/* Show a single OpenMP directive node and everything underneath it\n+\n+/* Show OpenMP or OpenACC clauses.  */\n+\n+static void\n+show_omp_clauses (gfc_omp_clauses *omp_clauses)\n+{\n+  int list_type;\n+\n+  switch (omp_clauses->cancel)\n+    {\n+    case OMP_CANCEL_UNKNOWN:\n+      break;\n+    case OMP_CANCEL_PARALLEL:\n+      fputs (\" PARALLEL\", dumpfile);\n+      break;\n+    case OMP_CANCEL_SECTIONS:\n+      fputs (\" SECTIONS\", dumpfile);\n+      break;\n+    case OMP_CANCEL_DO:\n+      fputs (\" DO\", dumpfile);\n+      break;\n+    case OMP_CANCEL_TASKGROUP:\n+      fputs (\" TASKGROUP\", dumpfile);\n+      break;\n+    }\n+  if (omp_clauses->if_expr)\n+    {\n+      fputs (\" IF(\", dumpfile);\n+      show_expr (omp_clauses->if_expr);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->final_expr)\n+    {\n+      fputs (\" FINAL(\", dumpfile);\n+      show_expr (omp_clauses->final_expr);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->num_threads)\n+    {\n+      fputs (\" NUM_THREADS(\", dumpfile);\n+      show_expr (omp_clauses->num_threads);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->async)\n+    {\n+      fputs (\" ASYNC\", dumpfile);\n+      if (omp_clauses->async_expr)\n+\t{\n+\t  fputc ('(', dumpfile);\n+\t  show_expr (omp_clauses->async_expr);\n+\t  fputc (')', dumpfile);\n+\t}\n+    }\n+  if (omp_clauses->num_gangs_expr)\n+    {\n+      fputs (\" NUM_GANGS(\", dumpfile);\n+      show_expr (omp_clauses->num_gangs_expr);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->num_workers_expr)\n+    {\n+      fputs (\" NUM_WORKERS(\", dumpfile);\n+      show_expr (omp_clauses->num_workers_expr);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->vector_length_expr)\n+    {\n+      fputs (\" VECTOR_LENGTH(\", dumpfile);\n+      show_expr (omp_clauses->vector_length_expr);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->gang)\n+    {\n+      fputs (\" GANG\", dumpfile);\n+      if (omp_clauses->gang_expr)\n+\t{\n+\t  fputc ('(', dumpfile);\n+\t  show_expr (omp_clauses->gang_expr);\n+\t  fputc (')', dumpfile);\n+\t}\n+    }\n+  if (omp_clauses->worker)\n+    {\n+      fputs (\" WORKER\", dumpfile);\n+      if (omp_clauses->worker_expr)\n+\t{\n+\t  fputc ('(', dumpfile);\n+\t  show_expr (omp_clauses->worker_expr);\n+\t  fputc (')', dumpfile);\n+\t}\n+    }\n+  if (omp_clauses->vector)\n+    {\n+      fputs (\" VECTOR\", dumpfile);\n+      if (omp_clauses->vector_expr)\n+\t{\n+\t  fputc ('(', dumpfile);\n+\t  show_expr (omp_clauses->vector_expr);\n+\t  fputc (')', dumpfile);\n+\t}\n+    }\n+  if (omp_clauses->sched_kind != OMP_SCHED_NONE)\n+    {\n+      const char *type;\n+      switch (omp_clauses->sched_kind)\n+\t{\n+\tcase OMP_SCHED_STATIC: type = \"STATIC\"; break;\n+\tcase OMP_SCHED_DYNAMIC: type = \"DYNAMIC\"; break;\n+\tcase OMP_SCHED_GUIDED: type = \"GUIDED\"; break;\n+\tcase OMP_SCHED_RUNTIME: type = \"RUNTIME\"; break;\n+\tcase OMP_SCHED_AUTO: type = \"AUTO\"; break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      fprintf (dumpfile, \" SCHEDULE (%s\", type);\n+      if (omp_clauses->chunk_size)\n+\t{\n+\t  fputc (',', dumpfile);\n+\t  show_expr (omp_clauses->chunk_size);\n+\t}\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->default_sharing != OMP_DEFAULT_UNKNOWN)\n+    {\n+      const char *type;\n+      switch (omp_clauses->default_sharing)\n+\t{\n+\tcase OMP_DEFAULT_NONE: type = \"NONE\"; break;\n+\tcase OMP_DEFAULT_PRIVATE: type = \"PRIVATE\"; break;\n+\tcase OMP_DEFAULT_SHARED: type = \"SHARED\"; break;\n+\tcase OMP_DEFAULT_FIRSTPRIVATE: type = \"FIRSTPRIVATE\"; break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      fprintf (dumpfile, \" DEFAULT(%s)\", type);\n+    }\n+  if (omp_clauses->tile_list)\n+    {\n+      gfc_expr_list *list;\n+      fputs (\" TILE(\", dumpfile);\n+      for (list = omp_clauses->tile_list; list; list = list->next)\n+\t{\n+\t  show_expr (list->expr);\n+\t  if (list->next) \n+\t    fputs (\", \", dumpfile);\n+\t}\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->wait_list)\n+    {\n+      gfc_expr_list *list;\n+      fputs (\" WAIT(\", dumpfile);\n+      for (list = omp_clauses->wait_list; list; list = list->next)\n+\t{\n+\t  show_expr (list->expr);\n+\t  if (list->next) \n+\t    fputs (\", \", dumpfile);\n+\t}\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->seq)\n+    fputs (\" SEQ\", dumpfile);\n+  if (omp_clauses->independent)\n+    fputs (\" INDEPENDENT\", dumpfile);\n+  if (omp_clauses->ordered)\n+    fputs (\" ORDERED\", dumpfile);\n+  if (omp_clauses->untied)\n+    fputs (\" UNTIED\", dumpfile);\n+  if (omp_clauses->mergeable)\n+    fputs (\" MERGEABLE\", dumpfile);\n+  if (omp_clauses->collapse)\n+    fprintf (dumpfile, \" COLLAPSE(%d)\", omp_clauses->collapse);\n+  for (list_type = 0; list_type < OMP_LIST_NUM; list_type++)\n+    if (omp_clauses->lists[list_type] != NULL\n+\t&& list_type != OMP_LIST_COPYPRIVATE)\n+      {\n+\tconst char *type = NULL;\n+\tswitch (list_type)\n+\t  {\n+\t  case OMP_LIST_USE_DEVICE: type = \"USE_DEVICE\"; break;\n+\t  case OMP_LIST_DEVICE_RESIDENT: type = \"USE_DEVICE\"; break;\n+\t  case OMP_LIST_CACHE: type = \"\"; break;\n+\t  case OMP_LIST_PRIVATE: type = \"PRIVATE\"; break;\n+\t  case OMP_LIST_FIRSTPRIVATE: type = \"FIRSTPRIVATE\"; break;\n+\t  case OMP_LIST_LASTPRIVATE: type = \"LASTPRIVATE\"; break;\n+\t  case OMP_LIST_SHARED: type = \"SHARED\"; break;\n+\t  case OMP_LIST_COPYIN: type = \"COPYIN\"; break;\n+\t  case OMP_LIST_UNIFORM: type = \"UNIFORM\"; break;\n+\t  case OMP_LIST_ALIGNED: type = \"ALIGNED\"; break;\n+\t  case OMP_LIST_LINEAR: type = \"LINEAR\"; break;\n+\t  case OMP_LIST_REDUCTION: type = \"REDUCTION\"; break;\n+\t  case OMP_LIST_DEPEND: type = \"DEPEND\"; break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tfprintf (dumpfile, \" %s(\", type);\n+\tshow_omp_namelist (list_type, omp_clauses->lists[list_type]);\n+\tfputc (')', dumpfile);\n+      }\n+  if (omp_clauses->safelen_expr)\n+    {\n+      fputs (\" SAFELEN(\", dumpfile);\n+      show_expr (omp_clauses->safelen_expr);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->simdlen_expr)\n+    {\n+      fputs (\" SIMDLEN(\", dumpfile);\n+      show_expr (omp_clauses->simdlen_expr);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->inbranch)\n+    fputs (\" INBRANCH\", dumpfile);\n+  if (omp_clauses->notinbranch)\n+    fputs (\" NOTINBRANCH\", dumpfile);\n+  if (omp_clauses->proc_bind != OMP_PROC_BIND_UNKNOWN)\n+    {\n+      const char *type;\n+      switch (omp_clauses->proc_bind)\n+\t{\n+\tcase OMP_PROC_BIND_MASTER: type = \"MASTER\"; break;\n+\tcase OMP_PROC_BIND_SPREAD: type = \"SPREAD\"; break;\n+\tcase OMP_PROC_BIND_CLOSE: type = \"CLOSE\"; break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      fprintf (dumpfile, \" PROC_BIND(%s)\", type);\n+    }\n+  if (omp_clauses->num_teams)\n+    {\n+      fputs (\" NUM_TEAMS(\", dumpfile);\n+      show_expr (omp_clauses->num_teams);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->device)\n+    {\n+      fputs (\" DEVICE(\", dumpfile);\n+      show_expr (omp_clauses->device);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->thread_limit)\n+    {\n+      fputs (\" THREAD_LIMIT(\", dumpfile);\n+      show_expr (omp_clauses->thread_limit);\n+      fputc (')', dumpfile);\n+    }\n+  if (omp_clauses->dist_sched_kind != OMP_SCHED_NONE)\n+    {\n+      fprintf (dumpfile, \" DIST_SCHEDULE (static\");\n+      if (omp_clauses->dist_chunk_size)\n+\t{\n+\t  fputc (',', dumpfile);\n+\t  show_expr (omp_clauses->dist_chunk_size);\n+\t}\n+      fputc (')', dumpfile);\n+    }\n+}\n+\n+/* Show a single OpenMP or OpenACC directive node and everything underneath it\n    if necessary.  */\n \n static void\n show_omp_node (int level, gfc_code *c)\n {\n   gfc_omp_clauses *omp_clauses = NULL;\n   const char *name = NULL;\n+  bool is_oacc = false;\n \n   switch (c->op)\n     {\n+    case EXEC_OACC_PARALLEL_LOOP: name = \"PARALLEL LOOP\"; is_oacc = true; break;\n+    case EXEC_OACC_PARALLEL: name = \"PARALLEL\"; is_oacc = true; break;\n+    case EXEC_OACC_KERNELS_LOOP: name = \"KERNELS LOOP\"; is_oacc = true; break;\n+    case EXEC_OACC_KERNELS: name = \"KERNELS\"; is_oacc = true; break;\n+    case EXEC_OACC_DATA: name = \"DATA\"; is_oacc = true; break;\n+    case EXEC_OACC_HOST_DATA: name = \"HOST_DATA\"; is_oacc = true; break;\n+    case EXEC_OACC_LOOP: name = \"LOOP\"; is_oacc = true; break;\n+    case EXEC_OACC_UPDATE: name = \"UPDATE\"; is_oacc = true; break;\n+    case EXEC_OACC_WAIT: name = \"WAIT\"; is_oacc = true; break;\n+    case EXEC_OACC_CACHE: name = \"CACHE\"; is_oacc = true; break;\n+    case EXEC_OACC_ENTER_DATA: name = \"ENTER DATA\"; is_oacc = true; break;\n+    case EXEC_OACC_EXIT_DATA: name = \"EXIT DATA\"; is_oacc = true; break;\n     case EXEC_OMP_ATOMIC: name = \"ATOMIC\"; break;\n     case EXEC_OMP_BARRIER: name = \"BARRIER\"; break;\n     case EXEC_OMP_CANCEL: name = \"CANCEL\"; break;\n@@ -1109,9 +1380,21 @@ show_omp_node (int level, gfc_code *c)\n     default:\n       gcc_unreachable ();\n     }\n-  fprintf (dumpfile, \"!$OMP %s\", name);\n+  fprintf (dumpfile, \"!$%s %s\", is_oacc ? \"ACC\" : \"OMP\", name);\n   switch (c->op)\n     {\n+    case EXEC_OACC_PARALLEL_LOOP:\n+    case EXEC_OACC_PARALLEL:\n+    case EXEC_OACC_KERNELS_LOOP:\n+    case EXEC_OACC_KERNELS:\n+    case EXEC_OACC_DATA:\n+    case EXEC_OACC_HOST_DATA:\n+    case EXEC_OACC_LOOP:\n+    case EXEC_OACC_UPDATE:\n+    case EXEC_OACC_WAIT:\n+    case EXEC_OACC_CACHE:\n+    case EXEC_OACC_ENTER_DATA:\n+    case EXEC_OACC_EXIT_DATA:\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:\n     case EXEC_OMP_DO:\n@@ -1148,170 +1431,13 @@ show_omp_node (int level, gfc_code *c)\n       break;\n     }\n   if (omp_clauses)\n-    {\n-      int list_type;\n-\n-      switch (omp_clauses->cancel)\n-\t{\n-\tcase OMP_CANCEL_UNKNOWN:\n-\t  break;\n-\tcase OMP_CANCEL_PARALLEL:\n-\t  fputs (\" PARALLEL\", dumpfile);\n-\t  break;\n-\tcase OMP_CANCEL_SECTIONS:\n-\t  fputs (\" SECTIONS\", dumpfile);\n-\t  break;\n-\tcase OMP_CANCEL_DO:\n-\t  fputs (\" DO\", dumpfile);\n-\t  break;\n-\tcase OMP_CANCEL_TASKGROUP:\n-\t  fputs (\" TASKGROUP\", dumpfile);\n-\t  break;\n-\t}\n-      if (omp_clauses->if_expr)\n-\t{\n-\t  fputs (\" IF(\", dumpfile);\n-\t  show_expr (omp_clauses->if_expr);\n-\t  fputc (')', dumpfile);\n-\t}\n-      if (omp_clauses->final_expr)\n-\t{\n-\t  fputs (\" FINAL(\", dumpfile);\n-\t  show_expr (omp_clauses->final_expr);\n-\t  fputc (')', dumpfile);\n-\t}\n-      if (omp_clauses->num_threads)\n-\t{\n-\t  fputs (\" NUM_THREADS(\", dumpfile);\n-\t  show_expr (omp_clauses->num_threads);\n-\t  fputc (')', dumpfile);\n-\t}\n-      if (omp_clauses->sched_kind != OMP_SCHED_NONE)\n-\t{\n-\t  const char *type;\n-\t  switch (omp_clauses->sched_kind)\n-\t    {\n-\t    case OMP_SCHED_STATIC: type = \"STATIC\"; break;\n-\t    case OMP_SCHED_DYNAMIC: type = \"DYNAMIC\"; break;\n-\t    case OMP_SCHED_GUIDED: type = \"GUIDED\"; break;\n-\t    case OMP_SCHED_RUNTIME: type = \"RUNTIME\"; break;\n-\t    case OMP_SCHED_AUTO: type = \"AUTO\"; break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  fprintf (dumpfile, \" SCHEDULE (%s\", type);\n-\t  if (omp_clauses->chunk_size)\n-\t    {\n-\t      fputc (',', dumpfile);\n-\t      show_expr (omp_clauses->chunk_size);\n-\t    }\n-\t  fputc (')', dumpfile);\n-\t}\n-      if (omp_clauses->default_sharing != OMP_DEFAULT_UNKNOWN)\n-\t{\n-\t  const char *type;\n-\t  switch (omp_clauses->default_sharing)\n-\t    {\n-\t    case OMP_DEFAULT_NONE: type = \"NONE\"; break;\n-\t    case OMP_DEFAULT_PRIVATE: type = \"PRIVATE\"; break;\n-\t    case OMP_DEFAULT_SHARED: type = \"SHARED\"; break;\n-\t    case OMP_DEFAULT_FIRSTPRIVATE: type = \"FIRSTPRIVATE\"; break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  fprintf (dumpfile, \" DEFAULT(%s)\", type);\n-\t}\n-      if (omp_clauses->ordered)\n-\tfputs (\" ORDERED\", dumpfile);\n-      if (omp_clauses->untied)\n-\tfputs (\" UNTIED\", dumpfile);\n-      if (omp_clauses->mergeable)\n-\tfputs (\" MERGEABLE\", dumpfile);\n-      if (omp_clauses->collapse)\n-\tfprintf (dumpfile, \" COLLAPSE(%d)\", omp_clauses->collapse);\n-      for (list_type = 0; list_type < OMP_LIST_NUM; list_type++)\n-\tif (omp_clauses->lists[list_type] != NULL\n-\t    && list_type != OMP_LIST_COPYPRIVATE)\n-\t  {\n-\t    const char *type = NULL;\n-\t    switch (list_type)\n-\t      {\n-\t      case OMP_LIST_PRIVATE: type = \"PRIVATE\"; break;\n-\t      case OMP_LIST_FIRSTPRIVATE: type = \"FIRSTPRIVATE\"; break;\n-\t      case OMP_LIST_LASTPRIVATE: type = \"LASTPRIVATE\"; break;\n-\t      case OMP_LIST_SHARED: type = \"SHARED\"; break;\n-\t      case OMP_LIST_COPYIN: type = \"COPYIN\"; break;\n-\t      case OMP_LIST_UNIFORM: type = \"UNIFORM\"; break;\n-\t      case OMP_LIST_ALIGNED: type = \"ALIGNED\"; break;\n-\t      case OMP_LIST_LINEAR: type = \"LINEAR\"; break;\n-\t      case OMP_LIST_REDUCTION: type = \"REDUCTION\"; break;\n-\t      case OMP_LIST_DEPEND: type = \"DEPEND\"; break;\n-\t      default:\n-\t\tgcc_unreachable ();\n-\t      }\n-\t    fprintf (dumpfile, \" %s(\", type);\n-\t    show_omp_namelist (list_type, omp_clauses->lists[list_type]);\n-\t    fputc (')', dumpfile);\n-\t  }\n-      if (omp_clauses->safelen_expr)\n-\t{\n-\t  fputs (\" SAFELEN(\", dumpfile);\n-\t  show_expr (omp_clauses->safelen_expr);\n-\t  fputc (')', dumpfile);\n-\t}\n-      if (omp_clauses->simdlen_expr)\n-\t{\n-\t  fputs (\" SIMDLEN(\", dumpfile);\n-\t  show_expr (omp_clauses->simdlen_expr);\n-\t  fputc (')', dumpfile);\n-\t}\n-      if (omp_clauses->inbranch)\n-\tfputs (\" INBRANCH\", dumpfile);\n-      if (omp_clauses->notinbranch)\n-\tfputs (\" NOTINBRANCH\", dumpfile);\n-      if (omp_clauses->proc_bind != OMP_PROC_BIND_UNKNOWN)\n-\t{\n-\t  const char *type;\n-\t  switch (omp_clauses->proc_bind)\n-\t    {\n-\t    case OMP_PROC_BIND_MASTER: type = \"MASTER\"; break;\n-\t    case OMP_PROC_BIND_SPREAD: type = \"SPREAD\"; break;\n-\t    case OMP_PROC_BIND_CLOSE: type = \"CLOSE\"; break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t  fprintf (dumpfile, \" PROC_BIND(%s)\", type);\n-\t}\n-      if (omp_clauses->num_teams)\n-\t{\n-\t  fputs (\" NUM_TEAMS(\", dumpfile);\n-\t  show_expr (omp_clauses->num_teams);\n-\t  fputc (')', dumpfile);\n-\t}\n-      if (omp_clauses->device)\n-\t{\n-\t  fputs (\" DEVICE(\", dumpfile);\n-\t  show_expr (omp_clauses->device);\n-\t  fputc (')', dumpfile);\n-\t}\n-      if (omp_clauses->thread_limit)\n-\t{\n-\t  fputs (\" THREAD_LIMIT(\", dumpfile);\n-\t  show_expr (omp_clauses->thread_limit);\n-\t  fputc (')', dumpfile);\n-\t}\n-      if (omp_clauses->dist_sched_kind != OMP_SCHED_NONE)\n-\t{\n-\t  fprintf (dumpfile, \" DIST_SCHEDULE (static\");\n-\t  if (omp_clauses->dist_chunk_size)\n-\t    {\n-\t      fputc (',', dumpfile);\n-\t      show_expr (omp_clauses->dist_chunk_size);\n-\t    }\n-\t  fputc (')', dumpfile);\n-\t}\n-    }\n+    show_omp_clauses (omp_clauses);\n   fputc ('\\n', dumpfile);\n+\n+  /* OpenACC executable directives don't have associated blocks.  */\n+  if (c->op == EXEC_OACC_CACHE || c->op == EXEC_OACC_UPDATE\n+      || c->op == EXEC_OACC_ENTER_DATA || c->op == EXEC_OACC_EXIT_DATA)\n+    return;\n   if (c->op == EXEC_OMP_SECTIONS || c->op == EXEC_OMP_PARALLEL_SECTIONS)\n     {\n       gfc_code *d = c->block;\n@@ -1331,7 +1457,7 @@ show_omp_node (int level, gfc_code *c)\n     return;\n   fputc ('\\n', dumpfile);\n   code_indent (level, 0);\n-  fprintf (dumpfile, \"!$OMP END %s\", name);\n+  fprintf (dumpfile, \"!$%s END %s\", is_oacc ? \"ACC\" : \"OMP\", name);\n   if (omp_clauses != NULL)\n     {\n       if (omp_clauses->lists[OMP_LIST_COPYPRIVATE])\n@@ -2311,6 +2437,18 @@ show_code_node (int level, gfc_code *c)\n \tfprintf (dumpfile, \" EOR=%d\", dt->eor->value);\n       break;\n \n+    case EXEC_OACC_PARALLEL_LOOP:\n+    case EXEC_OACC_PARALLEL:\n+    case EXEC_OACC_KERNELS_LOOP:\n+    case EXEC_OACC_KERNELS:\n+    case EXEC_OACC_DATA:\n+    case EXEC_OACC_HOST_DATA:\n+    case EXEC_OACC_LOOP:\n+    case EXEC_OACC_UPDATE:\n+    case EXEC_OACC_WAIT:\n+    case EXEC_OACC_CACHE:\n+    case EXEC_OACC_ENTER_DATA:\n+    case EXEC_OACC_EXIT_DATA:\n     case EXEC_OMP_ATOMIC:\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:\n@@ -2432,6 +2570,14 @@ show_namespace (gfc_namespace *ns)\n   for (eq = ns->equiv; eq; eq = eq->next)\n     show_equiv (eq);\n \n+  if (ns->oacc_declare_clauses)\n+    {\n+      /* Dump !$ACC DECLARE clauses.  */\n+      show_indent ();\n+      fprintf (dumpfile, \"!$ACC DECLARE\");\n+      show_omp_clauses (ns->oacc_declare_clauses);\n+    }\n+\n   fputc ('\\n', dumpfile);\n   show_indent ();\n   fputs (\"code:\", dumpfile);"}, {"sha": "449f01aa8cf73750a45a7e18e94ff3ce9d59d61a", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -672,6 +672,11 @@ gfc_init_builtin_functions (void)\n #define DEF_FUNCTION_TYPE_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n \t\t\t    ARG6, ARG7, ARG8) NAME,\n #define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_2(NAME, RETURN, ARG1, ARG2) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\tARG6, ARG7, ARG8) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_12(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\t ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) NAME,\n #define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n #include \"types.def\"\n #undef DEF_PRIMITIVE_TYPE\n@@ -685,6 +690,9 @@ gfc_init_builtin_functions (void)\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n #undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_2\n+#undef DEF_FUNCTION_TYPE_VAR_8\n+#undef DEF_FUNCTION_TYPE_VAR_12\n #undef DEF_POINTER_TYPE\n     BT_LAST\n   };\n@@ -1119,6 +1127,42 @@ gfc_init_builtin_functions (void)\n   builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n     = build_varargs_function_type_list (builtin_types[(int) RETURN],    \\\n                                         NULL_TREE);\n+#define DEF_FUNCTION_TYPE_VAR_2(ENUM, RETURN, ARG1, ARG2)\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_varargs_function_type_list (builtin_types[(int) RETURN],   \t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG1],     \t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG2],     \t\\\n+\t\t\t\t\tNULL_TREE);\n+#define DEF_FUNCTION_TYPE_VAR_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\tARG6, ARG7, ARG8)\t\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_varargs_function_type_list (builtin_types[(int) RETURN],   \t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG1],     \t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG2],     \t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG3],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG4],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG5],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG6],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG7],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG8],\t\\\n+\t\t\t\t\tNULL_TREE);\n+#define DEF_FUNCTION_TYPE_VAR_12(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\t ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) \\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_varargs_function_type_list (builtin_types[(int) RETURN],   \t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG1],     \t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG2],     \t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG3],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG4],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG5],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG6],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG7],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG8],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG9],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG10],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG11],\t\\\n+\t\t\t\t\tbuiltin_types[(int) ARG12],\t\\\n+\t\t\t\t\tNULL_TREE);\n #define DEF_POINTER_TYPE(ENUM, TYPE)\t\t\t\\\n   builtin_types[(int) ENUM]\t\t\t\t\\\n     = build_pointer_type (builtin_types[(int) TYPE]);\n@@ -1134,6 +1178,9 @@ gfc_init_builtin_functions (void)\n #undef DEF_FUNCTION_TYPE_7\n #undef DEF_FUNCTION_TYPE_8\n #undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_FUNCTION_TYPE_VAR_2\n+#undef DEF_FUNCTION_TYPE_VAR_8\n+#undef DEF_FUNCTION_TYPE_VAR_12\n #undef DEF_POINTER_TYPE\n   builtin_types[(int) BT_LAST] = NULL_TREE;\n \n@@ -1145,13 +1192,36 @@ gfc_init_builtin_functions (void)\n #include \"../sync-builtins.def\"\n #undef DEF_SYNC_BUILTIN\n \n+  if (flag_openacc)\n+    {\n+#undef DEF_GOACC_BUILTIN\n+#define DEF_GOACC_BUILTIN(code, name, type, attr) \\\n+      gfc_define_builtin (\"__builtin_\" name, builtin_types[type], \\\n+\t\t\t  code, name, attr);\n+#undef DEF_GOACC_BUILTIN_COMPILER\n+#define DEF_GOACC_BUILTIN_COMPILER(code, name, type, attr) \\\n+      gfc_define_builtin (name, builtin_types[type], code, name, attr);\n+#undef DEF_GOMP_BUILTIN\n+#define DEF_GOMP_BUILTIN(code, name, type, attr) /* ignore */\n+#include \"../omp-builtins.def\"\n+#undef DEF_GOACC_BUILTIN\n+#undef DEF_GOACC_BUILTIN_COMPILER\n+#undef DEF_GOMP_BUILTIN\n+    }\n+\n   if (flag_openmp || flag_openmp_simd || flag_tree_parallelize_loops)\n     {\n+#undef DEF_GOACC_BUILTIN\n+#define DEF_GOACC_BUILTIN(code, name, type, attr) /* ignore */\n+#undef DEF_GOACC_BUILTIN_COMPILER\n+#define DEF_GOACC_BUILTIN_COMPILER(code, name, type, attr)  /* ignore */\n #undef DEF_GOMP_BUILTIN\n #define DEF_GOMP_BUILTIN(code, name, type, attr) \\\n       gfc_define_builtin (\"__builtin_\" name, builtin_types[type], \\\n \t\t\t  code, name, attr);\n #include \"../omp-builtins.def\"\n+#undef DEF_GOACC_BUILTIN\n+#undef DEF_GOACC_BUILTIN_COMPILER\n #undef DEF_GOMP_BUILTIN\n     }\n "}, {"sha": "4e2089534a620e950493fb9523d92cd9b06607a0", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -216,6 +216,12 @@ typedef enum\n   ST_WRITE, ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,\n   ST_SIMPLE_IF, ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT,\n   ST_ENUM, ST_ENUMERATOR, ST_END_ENUM, ST_SELECT_TYPE, ST_TYPE_IS, ST_CLASS_IS,\n+  ST_OACC_PARALLEL_LOOP, ST_OACC_END_PARALLEL_LOOP, ST_OACC_PARALLEL,\n+  ST_OACC_END_PARALLEL, ST_OACC_KERNELS, ST_OACC_END_KERNELS, ST_OACC_DATA,\n+  ST_OACC_END_DATA, ST_OACC_HOST_DATA, ST_OACC_END_HOST_DATA, ST_OACC_LOOP,\n+  ST_OACC_END_LOOP, ST_OACC_DECLARE, ST_OACC_UPDATE, ST_OACC_WAIT,\n+  ST_OACC_CACHE, ST_OACC_KERNELS_LOOP, ST_OACC_END_KERNELS_LOOP,\n+  ST_OACC_ENTER_DATA, ST_OACC_EXIT_DATA, ST_OACC_ROUTINE,\n   ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL, ST_OMP_END_ATOMIC,\n   ST_OMP_END_CRITICAL, ST_OMP_END_DO, ST_OMP_END_MASTER, ST_OMP_END_ORDERED,\n   ST_OMP_END_PARALLEL, ST_OMP_END_PARALLEL_DO, ST_OMP_END_PARALLEL_SECTIONS,\n@@ -1067,6 +1073,16 @@ gfc_namelist;\n \n #define gfc_get_namelist() XCNEW (gfc_namelist)\n \n+/* Likewise to gfc_namelist, but contains expressions.  */\n+typedef struct gfc_expr_list\n+{\n+  struct gfc_expr *expr;\n+  struct gfc_expr_list *next;\n+}\n+gfc_expr_list;\n+\n+#define gfc_get_expr_list() XCNEW (gfc_expr_list)\n+\n typedef enum\n {\n   OMP_REDUCTION_NONE = -1,\n@@ -1099,7 +1115,14 @@ typedef enum\n   OMP_MAP_ALLOC,\n   OMP_MAP_TO,\n   OMP_MAP_FROM,\n-  OMP_MAP_TOFROM\n+  OMP_MAP_TOFROM,\n+  OMP_MAP_FORCE_ALLOC,\n+  OMP_MAP_FORCE_DEALLOC,\n+  OMP_MAP_FORCE_TO,\n+  OMP_MAP_FORCE_FROM,\n+  OMP_MAP_FORCE_TOFROM,\n+  OMP_MAP_FORCE_PRESENT,\n+  OMP_MAP_FORCE_DEVICEPTR\n }\n gfc_omp_map_op;\n \n@@ -1125,7 +1148,8 @@ gfc_omp_namelist;\n \n enum\n {\n-  OMP_LIST_PRIVATE,\n+  OMP_LIST_FIRST,\n+  OMP_LIST_PRIVATE = OMP_LIST_FIRST,\n   OMP_LIST_FIRSTPRIVATE,\n   OMP_LIST_LASTPRIVATE,\n   OMP_LIST_COPYPRIVATE,\n@@ -1139,6 +1163,9 @@ enum\n   OMP_LIST_TO,\n   OMP_LIST_FROM,\n   OMP_LIST_REDUCTION,\n+  OMP_LIST_DEVICE_RESIDENT,\n+  OMP_LIST_USE_DEVICE,\n+  OMP_LIST_CACHE,\n   OMP_LIST_NUM\n };\n \n@@ -1202,6 +1229,21 @@ typedef struct gfc_omp_clauses\n   struct gfc_expr *thread_limit;\n   enum gfc_omp_sched_kind dist_sched_kind;\n   struct gfc_expr *dist_chunk_size;\n+\n+  /* OpenACC. */\n+  struct gfc_expr *async_expr;\n+  struct gfc_expr *gang_expr;\n+  struct gfc_expr *worker_expr;\n+  struct gfc_expr *vector_expr;\n+  struct gfc_expr *num_gangs_expr;\n+  struct gfc_expr *num_workers_expr;\n+  struct gfc_expr *vector_length_expr;\n+  gfc_expr_list *wait_list;\n+  gfc_expr_list *tile_list;\n+  unsigned async:1, gang:1, worker:1, vector:1, seq:1, independent:1;\n+  unsigned wait:1, par_auto:1, gang_static:1;\n+  locus loc;\n+\n }\n gfc_omp_clauses;\n \n@@ -1609,6 +1651,9 @@ typedef struct gfc_namespace\n      this namespace.  */\n   struct gfc_data *data, *old_data;\n \n+  /* !$ACC DECLARE clauses.  */\n+  gfc_omp_clauses *oacc_declare_clauses;\n+\n   gfc_charlen *cl_list, *old_cl_list;\n \n   gfc_dt_list *derived_types;\n@@ -2276,6 +2321,10 @@ typedef enum\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n   EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,\n   EXEC_LOCK, EXEC_UNLOCK,\n+  EXEC_OACC_KERNELS_LOOP, EXEC_OACC_PARALLEL_LOOP,\n+  EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS, EXEC_OACC_DATA, EXEC_OACC_HOST_DATA,\n+  EXEC_OACC_LOOP, EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,\n+  EXEC_OACC_ENTER_DATA, EXEC_OACC_EXIT_DATA,\n   EXEC_OMP_CRITICAL, EXEC_OMP_DO, EXEC_OMP_FLUSH, EXEC_OMP_MASTER,\n   EXEC_OMP_ORDERED, EXEC_OMP_PARALLEL, EXEC_OMP_PARALLEL_DO,\n   EXEC_OMP_PARALLEL_SECTIONS, EXEC_OMP_PARALLEL_WORKSHARE,\n@@ -2877,6 +2926,11 @@ void gfc_resolve_omp_declare_simd (gfc_namespace *);\n void gfc_resolve_omp_udrs (gfc_symtree *);\n void gfc_omp_save_and_clear_state (struct gfc_omp_saved_state *);\n void gfc_omp_restore_state (struct gfc_omp_saved_state *);\n+void gfc_free_expr_list (gfc_expr_list *);\n+void gfc_resolve_oacc_directive (gfc_code *, gfc_namespace *);\n+void gfc_resolve_oacc_declare (gfc_namespace *);\n+void gfc_resolve_oacc_parallel_loop_blocks (gfc_code *, gfc_namespace *);\n+void gfc_resolve_oacc_blocks (gfc_code *, gfc_namespace *);\n \n /* expr.c */\n void gfc_free_actual_arglist (gfc_actual_arglist *);"}, {"sha": "300b8b8440cd21fe3b611372b469d7ad2ef060af", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -477,6 +477,10 @@ used on real-world programs.  In particular, the supported extensions\n include OpenMP, Cray-style pointers, and several Fortran 2003 and Fortran\n 2008 features, including TR 15581.  However, it is still under\n development and has a few remaining rough edges.\n+There also is initial support for OpenACC.\n+Note that this is an experimental feature, incomplete, and subject to\n+change in future versions of GCC.  See\n+@uref{https://gcc.gnu.org/wiki/OpenACC} for more information.\n \n At present, the GNU Fortran compiler passes the\n @uref{http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html, \n@@ -533,6 +537,11 @@ The current status of the support is can be found in the\n \n Additionally, the GNU Fortran compilers supports the OpenMP specification\n (version 4.0, @url{http://openmp.org/@/wp/@/openmp-specifications/}).\n+There also is initial support for the OpenACC specification (targeting\n+version 2.0, @uref{http://www.openacc.org/}).\n+Note that this is an experimental feature, incomplete, and subject to\n+change in future versions of GCC.  See\n+@uref{https://gcc.gnu.org/wiki/OpenACC} for more information.\n \n @node Varying Length Character Strings\n @subsection Varying Length Character Strings\n@@ -963,7 +972,8 @@ module.\n @cindex statement, @code{ISO_FORTRAN_ENV}\n @code{USE} statement with @code{INTRINSIC} and @code{NON_INTRINSIC}\n attribute; supported intrinsic modules: @code{ISO_FORTRAN_ENV},\n-@code{ISO_C_BINDING}, @code{OMP_LIB} and @code{OMP_LIB_KINDS}.\n+@code{ISO_C_BINDING}, @code{OMP_LIB} and @code{OMP_LIB_KINDS},\n+and @code{OPENACC}.\n \n @item\n Renaming of operators in the @code{USE} statement.\n@@ -1375,6 +1385,7 @@ without warning.\n * Cray pointers::\n * CONVERT specifier::\n * OpenMP::\n+* OpenACC::\n * Argument list functions::\n @end menu\n \n@@ -1949,6 +1960,37 @@ to the command line.  However, this is not supported by @command{gcc} and\n thus not recommended.\n @end itemize\n \n+@node OpenACC\n+@subsection OpenACC\n+@cindex OpenACC\n+\n+OpenACC is an application programming interface (API) that supports\n+offloading of code to accelerator devices.  It consists of a set of\n+compiler directives, library routines, and environment variables that\n+influence run-time behavior.\n+\n+GNU Fortran strives to be compatible to the\n+@uref{http://www.openacc.org/, OpenACC Application Programming\n+Interface v2.0}.\n+\n+To enable the processing of the OpenACC directive @code{!$acc} in\n+free-form source code; the @code{c$acc}, @code{*$acc} and @code{!$acc}\n+directives in fixed form; the @code{!$} conditional compilation\n+sentinels in free form; and the @code{c$}, @code{*$} and @code{!$}\n+sentinels in fixed form, @command{gfortran} needs to be invoked with\n+the @option{-fopenacc}.  This also arranges for automatic linking of\n+the GNU Offloading and Multi Processing Runtime Library\n+@ref{Top,,libgomp,libgomp,GNU Offloading and Multi Processing Runtime\n+Library}.\n+\n+The OpenACC Fortran runtime library routines are provided both in a\n+form of a Fortran 90 module named @code{openacc} and in a form of a\n+Fortran @code{include} file named @file{openacc_lib.h}.\n+\n+Note that this is an experimental feature, incomplete, and subject to\n+change in future versions of GCC.  See\n+@uref{https://gcc.gnu.org/wiki/OpenACC} for more information.\n+\n @node Argument list functions\n @subsection Argument list functions @code{%VAL}, @code{%REF} and @code{%LOC}\n @cindex argument list functions"}, {"sha": "06bce150903c70586dd46caa7c59b81d1bd55a97", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -13774,6 +13774,7 @@ Fortran 95 elemental function: @ref{IEOR}\n * ISO_C_BINDING::\n * IEEE modules::\n * OpenMP Modules OMP_LIB and OMP_LIB_KINDS::\n+* OpenACC Module OPENACC::\n @end menu\n \n @node ISO_FORTRAN_ENV\n@@ -14018,6 +14019,7 @@ with the following options: @code{-fno-unsafe-math-optimizations\n -frounding-math -fsignaling-nans}.\n \n \n+\n @node OpenMP Modules OMP_LIB and OMP_LIB_KINDS\n @section OpenMP Modules @code{OMP_LIB} and @code{OMP_LIB_KINDS}\n @table @asis\n@@ -14074,3 +14076,30 @@ kind @code{omp_proc_bind_kind}:\n @item @code{omp_proc_bind_close}\n @item @code{omp_proc_bind_spread}\n @end table\n+\n+\n+\n+@node OpenACC Module OPENACC\n+@section OpenACC Module @code{OPENACC}\n+@table @asis\n+@item @emph{Standard}:\n+OpenACC Application Programming Interface v2.0\n+@end table\n+\n+\n+The OpenACC Fortran runtime library routines are provided both in a\n+form of a Fortran 90 module, named @code{OPENACC}, and in form of a\n+Fortran @code{include} file named @file{openacc_lib.h}.  The\n+procedures provided by @code{OPENACC} can be found in the\n+@ref{Top,,Introduction,libgomp,GNU Offloading and Multi Processing\n+Runtime Library} manual, the named constants defined in the modules\n+are listed below.\n+\n+For details refer to the actual\n+@uref{http://www.openacc.org/,\n+OpenACC Application Programming Interface v2.0}.\n+\n+@code{OPENACC} provides the scalar default-integer\n+named constant @code{openacc_version} with a value of the form\n+@var{yyyymm}, where @code{yyyy} is the year and @var{mm} the month\n+of the OpenACC version; for OpenACC v2.0 the value is @code{201306}."}, {"sha": "9228c78232f8108c8ad83451d23b605120664550", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -120,7 +120,7 @@ by type.  Explanations are in the following sections.\n -ffixed-line-length-none -ffree-form -ffree-line-length-@var{n} @gol\n -ffree-line-length-none -fimplicit-none -finteger-4-integer-8 @gol\n -fmax-identifier-length -fmodule-private -fno-fixed-form -fno-range-check @gol\n--fopenmp -freal-4-real-10 -freal-4-real-16 -freal-4-real-8 @gol\n+-fopenacc -fopenmp -freal-4-real-10 -freal-4-real-16 -freal-4-real-8 @gol\n -freal-8-real-10 -freal-8-real-16 -freal-8-real-4 -std=@var{std}\n }\n \n@@ -302,6 +302,20 @@ Specify that no implicit typing is allowed, unless overridden by explicit\n Enable the Cray pointer extension, which provides C-like pointer\n functionality.\n \n+@item -fopenacc\n+@opindex @code{fopenacc}\n+@cindex OpenACC\n+Enable the OpenACC extensions.  This includes OpenACC @code{!$acc}\n+directives in free form and @code{c$acc}, @code{*$acc} and\n+@code{!$acc} directives in fixed form, @code{!$} conditional\n+compilation sentinels in free form and @code{c$}, @code{*$} and\n+@code{!$} sentinels in fixed form, and when linking arranges for the\n+OpenACC runtime library to be linked in.\n+\n+Note that this is an experimental feature, incomplete, and subject to\n+change in future versions of GCC.  See\n+@w{@uref{https://gcc.gnu.org/wiki/OpenACC}} for more information.\n+\n @item -fopenmp\n @opindex @code{fopenmp}\n @cindex OpenMP"}, {"sha": "a7a4ed644f5a766fd7e361f56478d4823a2db8df", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -566,6 +566,10 @@ fmodule-private\n Fortran Var(flag_module_private)\n Set default accessibility of module entities to PRIVATE.\n \n+fopenacc\n+Fortran\n+; Documented in C\n+\n fopenmp\n Fortran\n ; Documented in C"}, {"sha": "8234c2772433503772c996ad02a76556f3aef952", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -2501,7 +2501,9 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n \n   if (o != NULL)\n     {\n-      gfc_error (\"%s statement at %C leaving OpenMP structured block\",\n+      gfc_error (is_oacc (p)\n+\t\t ? \"%s statement at %C leaving OpenACC structured block\"\n+\t\t : \"%s statement at %C leaving OpenMP structured block\",\n \t\t gfc_ascii_statement (st));\n       return MATCH_ERROR;\n     }\n@@ -2511,6 +2513,33 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n   if (cnt > 0\n       && o != NULL\n       && o->state == COMP_OMP_STRUCTURED_BLOCK\n+      && (o->head->op == EXEC_OACC_LOOP\n+\t  || o->head->op == EXEC_OACC_PARALLEL_LOOP))\n+    {\n+      int collapse = 1;\n+      gcc_assert (o->head->next != NULL\n+\t\t  && (o->head->next->op == EXEC_DO\n+\t\t      || o->head->next->op == EXEC_DO_WHILE)\n+\t\t  && o->previous != NULL\n+\t\t  && o->previous->tail->op == o->head->op);\n+      if (o->previous->tail->ext.omp_clauses != NULL\n+\t  && o->previous->tail->ext.omp_clauses->collapse > 1)\n+\tcollapse = o->previous->tail->ext.omp_clauses->collapse;\n+      if (st == ST_EXIT && cnt <= collapse)\n+\t{\n+\t  gfc_error (\"EXIT statement at %C terminating !$ACC LOOP loop\");\n+\t  return MATCH_ERROR;\n+\t}\n+      if (st == ST_CYCLE && cnt < collapse)\n+\t{\n+\t  gfc_error (\"CYCLE statement at %C to non-innermost collapsed\"\n+\t\t     \" !$ACC LOOP loop\");\n+\t  return MATCH_ERROR;\n+\t}\n+    }\n+  if (cnt > 0\n+      && o != NULL\n+      && (o->state == COMP_OMP_STRUCTURED_BLOCK)\n       && (o->head->op == EXEC_OMP_DO\n \t  || o->head->op == EXEC_OMP_PARALLEL_DO\n \t  || o->head->op == EXEC_OMP_SIMD"}, {"sha": "96d3ec11f3c70bd8a381db4dee27215da9277621", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -122,6 +122,22 @@ gfc_common_head *gfc_get_common (const char *, int);\n \n /* openmp.c.  */\n \n+/* OpenACC directive matchers.  */\n+match gfc_match_oacc_cache (void);\n+match gfc_match_oacc_wait (void);\n+match gfc_match_oacc_update (void);\n+match gfc_match_oacc_declare (void);\n+match gfc_match_oacc_loop (void);\n+match gfc_match_oacc_host_data (void);\n+match gfc_match_oacc_data (void);\n+match gfc_match_oacc_kernels (void);\n+match gfc_match_oacc_kernels_loop (void);\n+match gfc_match_oacc_parallel (void);\n+match gfc_match_oacc_parallel_loop (void);\n+match gfc_match_oacc_enter_data (void);\n+match gfc_match_oacc_exit_data (void);\n+match gfc_match_oacc_routine (void);\n+\n /* OpenMP directive matchers.  */\n match gfc_match_omp_eos (void);\n match gfc_match_omp_atomic (void);"}, {"sha": "005739bf7c7da9642f5b57ecb39166ce8b90e334", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 1429, "deletions": 92, "changes": 1521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -27,6 +27,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"match.h\"\n #include \"parse.h\"\n #include \"hash-set.h\"\n+#include \"diagnostic.h\"\n+#include \"gomp-constants.h\"\n \n /* Match an end of OpenMP directive.  End of OpenMP directive is optional\n    whitespace, followed by '\\n' or comment '!'.  */\n@@ -76,11 +78,33 @@ gfc_free_omp_clauses (gfc_omp_clauses *c)\n   gfc_free_expr (c->device);\n   gfc_free_expr (c->thread_limit);\n   gfc_free_expr (c->dist_chunk_size);\n+  gfc_free_expr (c->async_expr);\n+  gfc_free_expr (c->gang_expr);\n+  gfc_free_expr (c->worker_expr);\n+  gfc_free_expr (c->vector_expr);\n+  gfc_free_expr (c->num_gangs_expr);\n+  gfc_free_expr (c->num_workers_expr);\n+  gfc_free_expr (c->vector_length_expr);\n   for (i = 0; i < OMP_LIST_NUM; i++)\n     gfc_free_omp_namelist (c->lists[i]);\n+  gfc_free_expr_list (c->wait_list);\n+  gfc_free_expr_list (c->tile_list);\n   free (c);\n }\n \n+/* Free expression list. */\n+void\n+gfc_free_expr_list (gfc_expr_list *list)\n+{\n+  gfc_expr_list *n;\n+\n+  for (; list; list = n)\n+    {\n+      n = list->next;\n+      free (list);\n+    }\n+}\n+\n /* Free an !$omp declare simd construct list.  */\n \n void\n@@ -287,45 +311,175 @@ gfc_match_omp_variable_list (const char *str, gfc_omp_namelist **list,\n   return MATCH_ERROR;\n }\n \n-#define OMP_CLAUSE_PRIVATE\t(1U << 0)\n-#define OMP_CLAUSE_FIRSTPRIVATE\t(1U << 1)\n-#define OMP_CLAUSE_LASTPRIVATE\t(1U << 2)\n-#define OMP_CLAUSE_COPYPRIVATE\t(1U << 3)\n-#define OMP_CLAUSE_SHARED\t(1U << 4)\n-#define OMP_CLAUSE_COPYIN\t(1U << 5)\n-#define OMP_CLAUSE_REDUCTION\t(1U << 6)\n-#define OMP_CLAUSE_IF\t\t(1U << 7)\n-#define OMP_CLAUSE_NUM_THREADS\t(1U << 8)\n-#define OMP_CLAUSE_SCHEDULE\t(1U << 9)\n-#define OMP_CLAUSE_DEFAULT\t(1U << 10)\n-#define OMP_CLAUSE_ORDERED\t(1U << 11)\n-#define OMP_CLAUSE_COLLAPSE\t(1U << 12)\n-#define OMP_CLAUSE_UNTIED\t(1U << 13)\n-#define OMP_CLAUSE_FINAL\t(1U << 14)\n-#define OMP_CLAUSE_MERGEABLE\t(1U << 15)\n-#define OMP_CLAUSE_ALIGNED\t(1U << 16)\n-#define OMP_CLAUSE_DEPEND\t(1U << 17)\n-#define OMP_CLAUSE_INBRANCH\t(1U << 18)\n-#define OMP_CLAUSE_LINEAR\t(1U << 19)\n-#define OMP_CLAUSE_NOTINBRANCH\t(1U << 20)\n-#define OMP_CLAUSE_PROC_BIND\t(1U << 21)\n-#define OMP_CLAUSE_SAFELEN\t(1U << 22)\n-#define OMP_CLAUSE_SIMDLEN\t(1U << 23)\n-#define OMP_CLAUSE_UNIFORM\t(1U << 24)\n-#define OMP_CLAUSE_DEVICE\t(1U << 25)\n-#define OMP_CLAUSE_MAP\t\t(1U << 26)\n-#define OMP_CLAUSE_TO\t\t(1U << 27)\n-#define OMP_CLAUSE_FROM\t\t(1U << 28)\n-#define OMP_CLAUSE_NUM_TEAMS\t(1U << 29)\n-#define OMP_CLAUSE_THREAD_LIMIT\t(1U << 30)\n-#define OMP_CLAUSE_DIST_SCHEDULE\t(1U << 31)\n-\n-/* Match OpenMP directive clauses. MASK is a bitmask of\n+static match\n+match_oacc_expr_list (const char *str, gfc_expr_list **list,\n+\t\t      bool allow_asterisk)\n+{\n+  gfc_expr_list *head, *tail, *p;\n+  locus old_loc;\n+  gfc_expr *expr;\n+  match m;\n+\n+  head = tail = NULL;\n+\n+  old_loc = gfc_current_locus;\n+\n+  m = gfc_match (str);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  for (;;)\n+    {\n+      m = gfc_match_expr (&expr);\n+      if (m == MATCH_YES || allow_asterisk)\n+\t{\n+\t  p = gfc_get_expr_list ();\n+\t  if (head == NULL)\n+\t    head = tail = p;\n+\t  else\n+\t    {\n+\t      tail->next = p;\n+\t      tail = tail->next;\n+\t    }\n+\t  if (m == MATCH_YES)\n+\t    tail->expr = expr;\n+\t  else if (gfc_match (\" *\") != MATCH_YES)\n+\t    goto syntax;\n+\t  goto next_item;\n+\t}\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      goto syntax;\n+\n+    next_item:\n+      if (gfc_match_char (')') == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  while (*list)\n+    list = &(*list)->next;\n+\n+  *list = head;\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in OpenACC expression list at %C\");\n+\n+cleanup:\n+  gfc_free_expr_list (head);\n+  gfc_current_locus = old_loc;\n+  return MATCH_ERROR;\n+}\n+\n+static match\n+match_oacc_clause_gang (gfc_omp_clauses *cp)\n+{\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    return MATCH_NO;\n+  if (gfc_match (\" num :\") == MATCH_YES)\n+    {\n+      cp->gang_static = false;\n+      return gfc_match (\" %e )\", &cp->gang_expr);\n+    }\n+  if (gfc_match (\" static :\") == MATCH_YES)\n+    {\n+      cp->gang_static = true;\n+      if (gfc_match (\" * )\") != MATCH_YES)\n+\treturn gfc_match (\" %e )\", &cp->gang_expr);\n+      return MATCH_YES;\n+    }\n+  return gfc_match (\" %e )\", &cp->gang_expr);\n+}\n+\n+#define OMP_CLAUSE_PRIVATE\t\t((uint64_t) 1 << 0)\n+#define OMP_CLAUSE_FIRSTPRIVATE\t\t((uint64_t) 1 << 1)\n+#define OMP_CLAUSE_LASTPRIVATE\t\t((uint64_t) 1 << 2)\n+#define OMP_CLAUSE_COPYPRIVATE\t\t((uint64_t) 1 << 3)\n+#define OMP_CLAUSE_SHARED\t\t((uint64_t) 1 << 4)\n+#define OMP_CLAUSE_COPYIN\t\t((uint64_t) 1 << 5)\n+#define OMP_CLAUSE_REDUCTION\t\t((uint64_t) 1 << 6)\n+#define OMP_CLAUSE_IF\t\t\t((uint64_t) 1 << 7)\n+#define OMP_CLAUSE_NUM_THREADS\t\t((uint64_t) 1 << 8)\n+#define OMP_CLAUSE_SCHEDULE\t\t((uint64_t) 1 << 9)\n+#define OMP_CLAUSE_DEFAULT\t\t((uint64_t) 1 << 10)\n+#define OMP_CLAUSE_ORDERED\t\t((uint64_t) 1 << 11)\n+#define OMP_CLAUSE_COLLAPSE\t\t((uint64_t) 1 << 12)\n+#define OMP_CLAUSE_UNTIED\t\t((uint64_t) 1 << 13)\n+#define OMP_CLAUSE_FINAL\t\t((uint64_t) 1 << 14)\n+#define OMP_CLAUSE_MERGEABLE\t\t((uint64_t) 1 << 15)\n+#define OMP_CLAUSE_ALIGNED\t\t((uint64_t) 1 << 16)\n+#define OMP_CLAUSE_DEPEND\t\t((uint64_t) 1 << 17)\n+#define OMP_CLAUSE_INBRANCH\t\t((uint64_t) 1 << 18)\n+#define OMP_CLAUSE_LINEAR\t\t((uint64_t) 1 << 19)\n+#define OMP_CLAUSE_NOTINBRANCH\t\t((uint64_t) 1 << 20)\n+#define OMP_CLAUSE_PROC_BIND\t\t((uint64_t) 1 << 21)\n+#define OMP_CLAUSE_SAFELEN\t\t((uint64_t) 1 << 22)\n+#define OMP_CLAUSE_SIMDLEN\t\t((uint64_t) 1 << 23)\n+#define OMP_CLAUSE_UNIFORM\t\t((uint64_t) 1 << 24)\n+#define OMP_CLAUSE_DEVICE\t\t((uint64_t) 1 << 25)\n+#define OMP_CLAUSE_MAP\t\t\t((uint64_t) 1 << 26)\n+#define OMP_CLAUSE_TO\t\t\t((uint64_t) 1 << 27)\n+#define OMP_CLAUSE_FROM\t\t\t((uint64_t) 1 << 28)\n+#define OMP_CLAUSE_NUM_TEAMS\t\t((uint64_t) 1 << 29)\n+#define OMP_CLAUSE_THREAD_LIMIT\t\t((uint64_t) 1 << 30)\n+#define OMP_CLAUSE_DIST_SCHEDULE\t((uint64_t) 1 << 31)\n+\n+/* OpenACC 2.0 clauses. */\n+#define OMP_CLAUSE_ASYNC\t\t((uint64_t) 1 << 32)\n+#define OMP_CLAUSE_NUM_GANGS\t\t((uint64_t) 1 << 33)\n+#define OMP_CLAUSE_NUM_WORKERS\t\t((uint64_t) 1 << 34)\n+#define OMP_CLAUSE_VECTOR_LENGTH\t((uint64_t) 1 << 35)\n+#define OMP_CLAUSE_COPY\t\t\t((uint64_t) 1 << 36)\n+#define OMP_CLAUSE_COPYOUT\t\t((uint64_t) 1 << 37)\n+#define OMP_CLAUSE_CREATE\t\t((uint64_t) 1 << 38)\n+#define OMP_CLAUSE_PRESENT\t\t((uint64_t) 1 << 39)\n+#define OMP_CLAUSE_PRESENT_OR_COPY\t((uint64_t) 1 << 40)\n+#define OMP_CLAUSE_PRESENT_OR_COPYIN\t((uint64_t) 1 << 41)\n+#define OMP_CLAUSE_PRESENT_OR_COPYOUT\t((uint64_t) 1 << 42)\n+#define OMP_CLAUSE_PRESENT_OR_CREATE\t((uint64_t) 1 << 43)\n+#define OMP_CLAUSE_DEVICEPTR\t\t((uint64_t) 1 << 44)\n+#define OMP_CLAUSE_GANG\t\t\t((uint64_t) 1 << 45)\n+#define OMP_CLAUSE_WORKER\t\t((uint64_t) 1 << 46)\n+#define OMP_CLAUSE_VECTOR\t\t((uint64_t) 1 << 47)\n+#define OMP_CLAUSE_SEQ\t\t\t((uint64_t) 1 << 48)\n+#define OMP_CLAUSE_INDEPENDENT\t\t((uint64_t) 1 << 49)\n+#define OMP_CLAUSE_USE_DEVICE\t\t((uint64_t) 1 << 50)\n+#define OMP_CLAUSE_DEVICE_RESIDENT\t((uint64_t) 1 << 51)\n+#define OMP_CLAUSE_HOST_SELF\t\t((uint64_t) 1 << 52)\n+#define OMP_CLAUSE_OACC_DEVICE\t\t((uint64_t) 1 << 53)\n+#define OMP_CLAUSE_WAIT\t\t\t((uint64_t) 1 << 54)\n+#define OMP_CLAUSE_DELETE\t\t((uint64_t) 1 << 55)\n+#define OMP_CLAUSE_AUTO\t\t\t((uint64_t) 1 << 56)\n+#define OMP_CLAUSE_TILE\t\t\t((uint64_t) 1 << 57)\n+\n+/* Helper function for OpenACC and OpenMP clauses involving memory\n+   mapping.  */\n+\n+static bool\n+gfc_match_omp_map_clause (gfc_omp_namelist **list, gfc_omp_map_op map_op)\n+{\n+  gfc_omp_namelist **head = NULL;\n+  if (gfc_match_omp_variable_list (\"\", list, false, NULL, &head, true)\n+      == MATCH_YES)\n+    {\n+      gfc_omp_namelist *n;\n+      for (n = *head; n; n = n->next)\n+\tn->u.map_op = map_op;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Match OpenMP and OpenACC directive clauses. MASK is a bitmask of\n    clauses that are allowed for a particular directive.  */\n \n static match\n-gfc_match_omp_clauses (gfc_omp_clauses **cp, unsigned int mask,\n-\t\t       bool first = true, bool needs_space = true)\n+gfc_match_omp_clauses (gfc_omp_clauses **cp, uint64_t mask,\n+\t\t       bool first = true, bool needs_space = true,\n+\t\t       bool openacc = false)\n {\n   gfc_omp_clauses *c = gfc_get_omp_clauses ();\n   locus old_loc;\n@@ -339,6 +493,56 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, unsigned int mask,\n       needs_space = false;\n       first = false;\n       gfc_gobble_whitespace ();\n+      if ((mask & OMP_CLAUSE_ASYNC) && !c->async)\n+\tif (gfc_match (\"async\") == MATCH_YES)\n+\t  {\n+\t    c->async = true;\n+\t    needs_space = false;\n+\t    if (gfc_match (\" ( %e )\", &c->async_expr) != MATCH_YES)\n+\t      {\n+\t\tc->async_expr = gfc_get_constant_expr (BT_INTEGER,\n+\t\t\t\t\t\t       gfc_default_integer_kind,\n+\t\t\t\t\t\t      &gfc_current_locus);\n+\t\tmpz_set_si (c->async_expr->value.integer, GOMP_ASYNC_NOVAL);\n+\t      }\n+\t    continue;\n+\t  }\n+      if ((mask & OMP_CLAUSE_GANG) && !c->gang)\n+\tif (gfc_match (\"gang\") == MATCH_YES)\n+\t  {\n+\t    c->gang = true;\n+\t    if (match_oacc_clause_gang(c) == MATCH_YES)\n+\t      needs_space = false;\n+\t    else\n+\t      needs_space = true;\n+\t    continue;\n+\t  }\n+      if ((mask & OMP_CLAUSE_WORKER) && !c->worker)\n+\tif (gfc_match (\"worker\") == MATCH_YES)\n+\t  {\n+\t    c->worker = true;\n+\t    if (gfc_match (\" ( num : %e )\", &c->worker_expr) == MATCH_YES\n+\t        || gfc_match (\" ( %e )\", &c->worker_expr) == MATCH_YES)\n+\t      needs_space = false;\n+\t    else\n+\t      needs_space = true;\n+\t    continue;\n+\t  }\n+      if ((mask & OMP_CLAUSE_VECTOR_LENGTH) && c->vector_length_expr == NULL\n+\t  && gfc_match (\"vector_length ( %e )\", &c->vector_length_expr)\n+\t  == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_VECTOR) && !c->vector)\n+\tif (gfc_match (\"vector\") == MATCH_YES)\n+\t  {\n+\t    c->vector = true;\n+\t    if (gfc_match (\" ( length : %e )\", &c->vector_expr) == MATCH_YES\n+\t        || gfc_match (\" ( %e )\", &c->vector_expr) == MATCH_YES)\n+\t      needs_space = false;\n+\t    else\n+\t      needs_space = true;\n+\t    continue;\n+\t  }\n       if ((mask & OMP_CLAUSE_IF) && c->if_expr == NULL\n \t  && gfc_match (\"if ( %e )\", &c->if_expr) == MATCH_YES)\n \tcontinue;\n@@ -376,11 +580,159 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, unsigned int mask,\n \t\t\t\t\t  &c->lists[OMP_LIST_SHARED], true)\n \t     == MATCH_YES)\n \tcontinue;\n-      if ((mask & OMP_CLAUSE_COPYIN)\n-\t  && gfc_match_omp_variable_list (\"copyin (\",\n-\t\t\t\t\t  &c->lists[OMP_LIST_COPYIN], true)\n+      if (mask & OMP_CLAUSE_COPYIN)\n+\t{\n+\t  if (openacc)\n+\t    {\n+\t      if (gfc_match (\"copyin ( \") == MATCH_YES\n+\t\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t\t       OMP_MAP_FORCE_TO))\n+\t\tcontinue;\n+\t    }\n+\t  else if (gfc_match_omp_variable_list (\"copyin (\",\n+\t\t\t\t\t\t&c->lists[OMP_LIST_COPYIN],\n+\t\t\t\t\t\ttrue) == MATCH_YES)\n+\t    continue;\n+\t}\n+      if ((mask & OMP_CLAUSE_NUM_GANGS) && c->num_gangs_expr == NULL\n+\t  && gfc_match (\"num_gangs ( %e )\", &c->num_gangs_expr) == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_NUM_WORKERS) && c->num_workers_expr == NULL\n+\t  && gfc_match (\"num_workers ( %e )\", &c->num_workers_expr)\n+\t  == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_COPY)\n+\t  && gfc_match (\"copy ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_FORCE_TOFROM))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_COPYOUT)\n+\t  && gfc_match (\"copyout ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_FORCE_FROM))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_CREATE)\n+\t  && gfc_match (\"create ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_FORCE_ALLOC))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_DELETE)\n+\t  && gfc_match (\"delete ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_FORCE_DEALLOC))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_PRESENT)\n+\t  && gfc_match (\"present ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_FORCE_PRESENT))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_PRESENT_OR_COPY)\n+\t  && gfc_match (\"present_or_copy ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_TOFROM))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_PRESENT_OR_COPY)\n+\t  && gfc_match (\"pcopy ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_TOFROM))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_PRESENT_OR_COPYIN)\n+\t  && gfc_match (\"present_or_copyin ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_TO))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_PRESENT_OR_COPYIN)\n+\t  && gfc_match (\"pcopyin ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_TO))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_PRESENT_OR_COPYOUT)\n+\t  && gfc_match (\"present_or_copyout ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_FROM))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_PRESENT_OR_COPYOUT)\n+\t  && gfc_match (\"pcopyout ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_FROM))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_PRESENT_OR_CREATE)\n+\t  && gfc_match (\"present_or_create ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_ALLOC))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_PRESENT_OR_CREATE)\n+\t  && gfc_match (\"pcreate ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_ALLOC))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_DEVICEPTR)\n+\t  && gfc_match (\"deviceptr ( \") == MATCH_YES)\n+\t{\n+\t  gfc_omp_namelist **list = &c->lists[OMP_LIST_MAP];\n+\t  gfc_omp_namelist **head = NULL;\n+\t  if (gfc_match_omp_variable_list (\"\", list, true, NULL, &head, false)\n+\t      == MATCH_YES)\n+\t    {\n+\t      gfc_omp_namelist *n;\n+\t      for (n = *head; n; n = n->next)\n+\t\tn->u.map_op = OMP_MAP_FORCE_DEVICEPTR;\n+\t      continue;\n+\t    }\n+\t}\n+      if ((mask & OMP_CLAUSE_USE_DEVICE)\n+\t  && gfc_match_omp_variable_list (\"use_device (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_USE_DEVICE], true)\n+\t     == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_DEVICE_RESIDENT)\n+\t  && gfc_match_omp_variable_list (\"device_resident (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_DEVICE_RESIDENT],\n+\t\t\t\t\t  true)\n \t     == MATCH_YES)\n \tcontinue;\n+      if ((mask & OMP_CLAUSE_OACC_DEVICE)\n+\t  && gfc_match (\"device ( \") == MATCH_YES\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_FORCE_TO))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_HOST_SELF)\n+\t  && (gfc_match (\"host ( \") == MATCH_YES\n+\t      || gfc_match (\"self ( \") == MATCH_YES)\n+\t  && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t       OMP_MAP_FORCE_FROM))\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_TILE)\n+\t  && match_oacc_expr_list (\"tile (\", &c->tile_list, true) == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_SEQ) && !c->seq\n+\t  && gfc_match (\"seq\") == MATCH_YES)\n+\t{\n+\t  c->seq = true;\n+\t  needs_space = true;\n+\t  continue;\n+\t}\n+      if ((mask & OMP_CLAUSE_INDEPENDENT) && !c->independent\n+\t  && gfc_match (\"independent\") == MATCH_YES)\n+\t{\n+\t  c->independent = true;\n+\t  needs_space = true;\n+\t  continue;\n+\t}\n+      if ((mask & OMP_CLAUSE_AUTO) && !c->par_auto\n+\t        && gfc_match (\"auto\") == MATCH_YES)\n+\t{\n+\t  c->par_auto = true;\n+\t  needs_space = true;\n+\t  continue;\n+\t}\n+      if ((mask & OMP_CLAUSE_WAIT) && !c->wait\n+\t        && gfc_match (\"wait\") == MATCH_YES)\n+\t{\n+\t  c->wait = true;\n+\t  match_oacc_expr_list (\" (\", &c->wait_list, false);\n+\t  continue;\n+\t}\n       old_loc = gfc_current_locus;\n       if ((mask & OMP_CLAUSE_REDUCTION)\n \t  && gfc_match (\"reduction ( \") == MATCH_YES)\n@@ -785,6 +1137,352 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, unsigned int mask,\n   return MATCH_YES;\n }\n \n+\n+#define OACC_PARALLEL_CLAUSES \\\n+  (OMP_CLAUSE_IF | OMP_CLAUSE_ASYNC | OMP_CLAUSE_NUM_GANGS                    \\\n+   | OMP_CLAUSE_NUM_WORKERS | OMP_CLAUSE_VECTOR_LENGTH | OMP_CLAUSE_REDUCTION \\\n+   | OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT                 \\\n+   | OMP_CLAUSE_CREATE | OMP_CLAUSE_PRESENT | OMP_CLAUSE_PRESENT_OR_COPY      \\\n+   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT             \\\n+   | OMP_CLAUSE_PRESENT_OR_CREATE | OMP_CLAUSE_DEVICEPTR | OMP_CLAUSE_PRIVATE \\\n+   | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_WAIT)\n+#define OACC_KERNELS_CLAUSES \\\n+  (OMP_CLAUSE_IF | OMP_CLAUSE_ASYNC | OMP_CLAUSE_DEVICEPTR                    \\\n+   | OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT                 \\\n+   | OMP_CLAUSE_CREATE | OMP_CLAUSE_PRESENT | OMP_CLAUSE_PRESENT_OR_COPY      \\\n+   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT             \\\n+   | OMP_CLAUSE_PRESENT_OR_CREATE | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_WAIT)\n+#define OACC_DATA_CLAUSES \\\n+  (OMP_CLAUSE_IF | OMP_CLAUSE_DEVICEPTR  | OMP_CLAUSE_COPY                    \\\n+   | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT | OMP_CLAUSE_CREATE               \\\n+   | OMP_CLAUSE_PRESENT | OMP_CLAUSE_PRESENT_OR_COPY                          \\\n+   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT             \\\n+   | OMP_CLAUSE_PRESENT_OR_CREATE)\n+#define OACC_LOOP_CLAUSES \\\n+  (OMP_CLAUSE_COLLAPSE | OMP_CLAUSE_GANG | OMP_CLAUSE_WORKER     \\\n+   | OMP_CLAUSE_VECTOR | OMP_CLAUSE_SEQ | OMP_CLAUSE_INDEPENDENT \\\n+   | OMP_CLAUSE_PRIVATE | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_AUTO \\\n+   | OMP_CLAUSE_TILE)\n+#define OACC_PARALLEL_LOOP_CLAUSES \\\n+  (OACC_LOOP_CLAUSES | OACC_PARALLEL_CLAUSES)\n+#define OACC_KERNELS_LOOP_CLAUSES \\\n+  (OACC_LOOP_CLAUSES | OACC_KERNELS_CLAUSES)\n+#define OACC_HOST_DATA_CLAUSES OMP_CLAUSE_USE_DEVICE\n+#define OACC_DECLARE_CLAUSES \\\n+  (OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT                   \\\n+   | OMP_CLAUSE_CREATE | OMP_CLAUSE_DEVICEPTR | OMP_CLAUSE_DEVICE_RESIDENT    \\\n+   | OMP_CLAUSE_PRESENT | OMP_CLAUSE_PRESENT_OR_COPY                          \\\n+   | OMP_CLAUSE_PRESENT_OR_COPYIN | OMP_CLAUSE_PRESENT_OR_COPYOUT             \\\n+   | OMP_CLAUSE_PRESENT_OR_CREATE)\n+#define OACC_UPDATE_CLAUSES \\\n+  (OMP_CLAUSE_IF | OMP_CLAUSE_ASYNC | OMP_CLAUSE_HOST_SELF \\\n+   | OMP_CLAUSE_OACC_DEVICE | OMP_CLAUSE_WAIT)\n+#define OACC_ENTER_DATA_CLAUSES \\\n+  (OMP_CLAUSE_IF | OMP_CLAUSE_ASYNC | OMP_CLAUSE_WAIT | OMP_CLAUSE_COPYIN    \\\n+   | OMP_CLAUSE_CREATE | OMP_CLAUSE_PRESENT_OR_COPYIN                          \\\n+   | OMP_CLAUSE_PRESENT_OR_CREATE)\n+#define OACC_EXIT_DATA_CLAUSES \\\n+  (OMP_CLAUSE_IF | OMP_CLAUSE_ASYNC | OMP_CLAUSE_WAIT | OMP_CLAUSE_COPYOUT \\\n+   | OMP_CLAUSE_DELETE)\n+#define OACC_WAIT_CLAUSES \\\n+  (OMP_CLAUSE_ASYNC)\n+\n+\n+match\n+gfc_match_oacc_parallel_loop (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_PARALLEL_LOOP_CLAUSES, false, false,\n+\t\t\t     true) != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OACC_PARALLEL_LOOP;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_parallel (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_PARALLEL_CLAUSES, false, false, true)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OACC_PARALLEL;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_kernels_loop (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_KERNELS_LOOP_CLAUSES, false, false,\n+\t\t\t     true) != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OACC_KERNELS_LOOP;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_kernels (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_KERNELS_CLAUSES, false, false, true)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OACC_KERNELS;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_data (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_DATA_CLAUSES, false, false, true)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OACC_DATA;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_host_data (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_HOST_DATA_CLAUSES, false, false, true)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OACC_HOST_DATA;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_loop (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_LOOP_CLAUSES, false, false, true)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OACC_LOOP;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_declare (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_DECLARE_CLAUSES, false, false, true)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.ext.omp_clauses = c;\n+  new_st.ext.omp_clauses->loc = gfc_current_locus;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_update (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_UPDATE_CLAUSES, false, false, true)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OACC_UPDATE;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_enter_data (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_ENTER_DATA_CLAUSES, false, false, true)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OACC_ENTER_DATA;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_exit_data (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OACC_EXIT_DATA_CLAUSES, false, false, true)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  new_st.op = EXEC_OACC_EXIT_DATA;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_wait (void)\n+{\n+  gfc_omp_clauses *c = gfc_get_omp_clauses ();\n+  gfc_expr_list *wait_list = NULL, *el;\n+\n+  match_oacc_expr_list (\" (\", &wait_list, true);\n+  gfc_match_omp_clauses (&c, OACC_WAIT_CLAUSES, false, false, true);\n+\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk in !$ACC WAIT at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (wait_list)\n+    for (el = wait_list; el; el = el->next)\n+      {\n+\tif (el->expr == NULL)\n+\t  {\n+\t    gfc_error (\"Invalid argument to $!ACC WAIT at %L\",\n+\t\t       &wait_list->expr->where);\n+\t    return MATCH_ERROR;\n+\t  }\n+\n+\tif (!gfc_resolve_expr (el->expr)\n+\t    || el->expr->ts.type != BT_INTEGER || el->expr->rank != 0\n+\t    || el->expr->expr_type != EXPR_CONSTANT)\n+\t  {\n+\t    gfc_error (\"WAIT clause at %L requires a scalar INTEGER expression\",\n+\t\t       &el->expr->where);\n+\n+\t    return MATCH_ERROR;\n+\t  }\n+      }\n+  c->wait_list = wait_list;\n+  new_st.op = EXEC_OACC_WAIT;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_cache (void)\n+{\n+  gfc_omp_clauses *c = gfc_get_omp_clauses ();\n+  match m = gfc_match_omp_variable_list (\" (\",\n+\t\t\t\t\t &c->lists[OMP_LIST_CACHE], true);\n+  if (m != MATCH_YES)\n+    {\n+      gfc_free_omp_clauses(c);\n+      return m;\n+    }\n+\n+  if (gfc_current_state() != COMP_DO \n+      && gfc_current_state() != COMP_DO_CONCURRENT)\n+    {\n+      gfc_error (\"ACC CACHE directive must be inside of loop %C\");\n+      gfc_free_omp_clauses(c);\n+      return MATCH_ERROR;\n+    }\n+\n+  new_st.op = EXEC_OACC_CACHE;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_oacc_routine (void)\n+{\n+  locus old_loc;\n+  gfc_symbol *sym;\n+  match m;\n+\n+  old_loc = gfc_current_locus;\n+\n+  m = gfc_match (\" (\");\n+\n+  if (gfc_current_ns->proc_name\n+      && gfc_current_ns->proc_name->attr.if_source == IFSRC_IFBODY\n+      && m == MATCH_YES)\n+    {\n+      gfc_error (\"Only the !$ACC ROUTINE form without \"\n+\t\t \"list is allowed in interface block at %C\");\n+      goto cleanup;\n+    }\n+\n+  if (m == MATCH_NO\n+      && gfc_current_ns->proc_name\n+      && gfc_match_omp_eos () == MATCH_YES)\n+    {\n+      if (!gfc_add_omp_declare_target (&gfc_current_ns->proc_name->attr,\n+\t\t\t\t       gfc_current_ns->proc_name->name,\n+\t\t\t\t       &old_loc))\n+\tgoto cleanup;\n+      return MATCH_YES;\n+    }\n+\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  /* Scan for a function name.  */\n+  m = gfc_match_symbol (&sym, 0);\n+\n+  if (m != MATCH_YES)\n+    {\n+      gfc_error (\"Syntax error in !$ACC ROUTINE ( NAME ) at %C\");\n+      gfc_current_locus = old_loc;\n+      return MATCH_ERROR;\n+    }\n+\n+  if (!sym->attr.external && !sym->attr.function && !sym->attr.subroutine)\n+    {\n+      gfc_error (\"Syntax error in !$ACC ROUTINE ( NAME ) at %C, invalid\"\n+\t\t \" function name '%s'\", sym->name);\n+      gfc_current_locus = old_loc;\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_match_char (')') != MATCH_YES)\n+    {\n+      gfc_error (\"Syntax error in !$ACC ROUTINE ( NAME ) at %C, expecting\"\n+\t\t \" ')' after NAME\");\n+      gfc_current_locus = old_loc;\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after !$ACC ROUTINE at %C\");\n+      goto cleanup;\n+    }\n+  return MATCH_YES;\n+\n+cleanup:\n+  gfc_current_locus = old_loc;\n+  return MATCH_ERROR;\n+}\n+\n+\n #define OMP_PARALLEL_CLAUSES \\\n   (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n    | OMP_CLAUSE_COPYIN | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_IF\t\t\\\n@@ -1916,6 +2614,129 @@ gfc_match_omp_end_single (void)\n }\n \n \n+static bool\n+oacc_is_loop (gfc_code *code)\n+{\n+  return code->op == EXEC_OACC_PARALLEL_LOOP\n+\t || code->op == EXEC_OACC_KERNELS_LOOP\n+\t || code->op == EXEC_OACC_LOOP;\n+}\n+\n+static void\n+resolve_oacc_scalar_int_expr (gfc_expr *expr, const char *clause)\n+{\n+  if (!gfc_resolve_expr (expr)\n+      || expr->ts.type != BT_INTEGER || expr->rank != 0)\n+    gfc_error (\"%s clause at %L requires a scalar INTEGER expression\",\n+\t\t     clause, &expr->where);\n+}\n+\n+\n+static void\n+resolve_oacc_positive_int_expr (gfc_expr *expr, const char *clause)\n+{\n+  resolve_oacc_scalar_int_expr (expr, clause);\n+  if (expr->expr_type == EXPR_CONSTANT && expr->ts.type == BT_INTEGER\n+      && mpz_sgn(expr->value.integer) <= 0)\n+    gfc_warning (\"INTEGER expression of %s clause at %L must be positive\",\n+\t\t     clause, &expr->where);\n+}\n+\n+/* Emits error when symbol is pointer, cray pointer or cray pointee\n+   of derived of polymorphic type.  */\n+\n+static void\n+check_symbol_not_pointer (gfc_symbol *sym, locus loc, const char *name)\n+{\n+  if (sym->ts.type == BT_DERIVED && sym->attr.pointer)\n+    gfc_error (\"POINTER object '%s' of derived type in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if (sym->ts.type == BT_DERIVED && sym->attr.cray_pointer)\n+    gfc_error (\"Cray pointer object of derived type '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if (sym->ts.type == BT_DERIVED && sym->attr.cray_pointee)\n+    gfc_error (\"Cray pointee object of derived type '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+\n+  if ((sym->ts.type == BT_ASSUMED && sym->attr.pointer)\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+\t  && CLASS_DATA (sym)->attr.pointer))\n+    gfc_error (\"POINTER object '%s' of polymorphic type in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if ((sym->ts.type == BT_ASSUMED && sym->attr.cray_pointer)\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+\t  && CLASS_DATA (sym)->attr.cray_pointer))\n+    gfc_error (\"Cray pointer object of polymorphic type '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if ((sym->ts.type == BT_ASSUMED && sym->attr.cray_pointee)\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+\t  && CLASS_DATA (sym)->attr.cray_pointee))\n+    gfc_error (\"Cray pointee object of polymorphic type '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+}\n+\n+/* Emits error when symbol represents assumed size/rank array.  */\n+\n+static void\n+check_array_not_assumed (gfc_symbol *sym, locus loc, const char *name)\n+{\n+  if (sym->as && sym->as->type == AS_ASSUMED_SIZE)\n+    gfc_error (\"Assumed size array '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if (sym->as && sym->as->type == AS_ASSUMED_RANK)\n+    gfc_error (\"Assumed rank array '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if (sym->as && sym->as->type == AS_DEFERRED && sym->attr.pointer\n+      && !sym->attr.contiguous)\n+    gfc_error (\"Noncontiguous deferred shape array '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+}\n+\n+static void\n+resolve_oacc_data_clauses (gfc_symbol *sym, locus loc, const char *name)\n+{\n+  if (sym->ts.type == BT_DERIVED && sym->attr.allocatable)\n+    gfc_error (\"ALLOCATABLE object '%s' of derived type in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if ((sym->ts.type == BT_ASSUMED && sym->attr.allocatable)\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+\t  && CLASS_DATA (sym)->attr.allocatable))\n+    gfc_error (\"ALLOCATABLE object '%s' of polymorphic type \"\n+\t       \"in %s clause at %L\", sym->name, name, &loc);\n+  check_symbol_not_pointer (sym, loc, name);\n+  check_array_not_assumed (sym, loc, name);\n+}\n+\n+static void\n+resolve_oacc_deviceptr_clause (gfc_symbol *sym, locus loc, const char *name)\n+{\n+  if (sym->attr.pointer\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+\t  && CLASS_DATA (sym)->attr.class_pointer))\n+    gfc_error (\"POINTER object '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if (sym->attr.cray_pointer\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+\t  && CLASS_DATA (sym)->attr.cray_pointer))\n+    gfc_error (\"Cray pointer object '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if (sym->attr.cray_pointee\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+\t  && CLASS_DATA (sym)->attr.cray_pointee))\n+    gfc_error (\"Cray pointee object '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if (sym->attr.allocatable\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n+\t  && CLASS_DATA (sym)->attr.allocatable))\n+    gfc_error (\"ALLOCATABLE object '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  if (sym->attr.value)\n+    gfc_error (\"VALUE object '%s' in %s clause at %L\",\n+\t       sym->name, name, &loc);\n+  check_array_not_assumed (sym, loc, name);\n+}\n+\n+\n struct resolve_omp_udr_callback_data\n {\n   gfc_symbol *sym1, *sym2;\n@@ -2013,19 +2834,45 @@ resolve_omp_udr_clause (gfc_omp_namelist *n, gfc_namespace *ns,\n   return copy;\n }\n \n+/* Returns true if clause in list 'list' is compatible with any of\n+   of the clauses in lists [0..list-1].  E.g., a reduction variable may\n+   appear in both reduction and private clauses, so this function\n+   will return true in this case.  */\n+\n+static bool\n+oacc_compatible_clauses (gfc_omp_clauses *clauses, int list,\n+\t\t\t   gfc_symbol *sym, bool openacc)\n+{\n+  gfc_omp_namelist *n;\n+\n+  if (!openacc)\n+    return false;\n+\n+  if (list != OMP_LIST_REDUCTION)\n+    return false;\n+\n+  for (n = clauses->lists[OMP_LIST_FIRST]; n; n = n->next)\n+    if (n->sym == sym)\n+      return true;\n+\n+  return false;\n+}\n \n /* OpenMP directive resolving routines.  */\n \n static void\n resolve_omp_clauses (gfc_code *code, locus *where,\n-\t\t     gfc_omp_clauses *omp_clauses, gfc_namespace *ns)\n+\t\t     gfc_omp_clauses *omp_clauses, gfc_namespace *ns,\n+\t\t     bool openacc = false)\n {\n   gfc_omp_namelist *n;\n+  gfc_expr_list *el;\n   int list;\n   static const char *clause_names[]\n     = { \"PRIVATE\", \"FIRSTPRIVATE\", \"LASTPRIVATE\", \"COPYPRIVATE\", \"SHARED\",\n \t\"COPYIN\", \"UNIFORM\", \"ALIGNED\", \"LINEAR\", \"DEPEND\", \"MAP\",\n-\t\"TO\", \"FROM\", \"REDUCTION\" };\n+\t\"TO\", \"FROM\", \"REDUCTION\", \"DEVICE_RESIDENT\", \"USE_DEVICE\",\n+\t\"CACHE\" };\n \n   if (omp_clauses == NULL)\n     return;\n@@ -2115,12 +2962,13 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t&& list != OMP_LIST_LASTPRIVATE\n \t&& list != OMP_LIST_ALIGNED\n \t&& list != OMP_LIST_DEPEND\n-\t&& list != OMP_LIST_MAP\n+\t&& (list != OMP_LIST_MAP || openacc)\n \t&& list != OMP_LIST_FROM\n \t&& list != OMP_LIST_TO)\n       for (n = omp_clauses->lists[list]; n; n = n->next)\n \t{\n-\t  if (n->sym->mark)\n+\t  if (n->sym->mark && !oacc_compatible_clauses (omp_clauses, list,\n+\t\t\t\t\t\t\tn->sym, openacc))\n \t    gfc_error (\"Symbol %qs present on multiple clauses at %L\",\n \t\t       n->sym->name, where);\n \t  else\n@@ -2262,53 +3110,64 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t  case OMP_LIST_TO:\n \t  case OMP_LIST_FROM:\n \t    for (; n != NULL; n = n->next)\n-\t      if (n->expr)\n-\t\t{\n-\t\t  if (!gfc_resolve_expr (n->expr)\n-\t\t      || n->expr->expr_type != EXPR_VARIABLE\n-\t\t      || n->expr->ref == NULL\n-\t\t      || n->expr->ref->next\n-\t\t      || n->expr->ref->type != REF_ARRAY)\n-\t\t    gfc_error (\"%qs in %s clause at %L is not a proper \"\n-\t\t\t       \"array section\", n->sym->name, name, where);\n-\t\t  else if (n->expr->ref->u.ar.codimen)\n-\t\t    gfc_error (\"Coarrays not supported in %s clause at %L\",\n-\t\t\t       name, where);\n-\t\t  else\n-\t\t    {\n-\t\t      int i;\n-\t\t      gfc_array_ref *ar = &n->expr->ref->u.ar;\n-\t\t      for (i = 0; i < ar->dimen; i++)\n-\t\t\tif (ar->stride[i])\n-\t\t\t  {\n-\t\t\t    gfc_error (\"Stride should not be specified for \"\n-\t\t\t\t       \"array section in %s clause at %L\",\n-\t\t\t\t       name, where);\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t\telse if (ar->dimen_type[i] != DIMEN_ELEMENT\n-\t\t\t\t && ar->dimen_type[i] != DIMEN_RANGE)\n-\t\t\t  {\n-\t\t\t    gfc_error (\"%qs in %s clause at %L is not a \"\n-\t\t\t\t       \"proper array section\",\n-\t\t\t\t       n->sym->name, name, where);\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t\telse if (list == OMP_LIST_DEPEND\n-\t\t\t\t && ar->start[i]\n-\t\t\t\t && ar->start[i]->expr_type == EXPR_CONSTANT\n-\t\t\t\t && ar->end[i]\n-\t\t\t\t && ar->end[i]->expr_type == EXPR_CONSTANT\n-\t\t\t\t && mpz_cmp (ar->start[i]->value.integer,\n-\t\t\t\t\t     ar->end[i]->value.integer) > 0)\n-\t\t\t  {\n-\t\t\t    gfc_error (\"%qs in DEPEND clause at %L is a zero \"\n-\t\t\t\t       \"size array section\", n->sym->name,\n-\t\t\t\t       where);\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t    }\n-\t\t}\n+\t      {\n+\t\tif (n->expr)\n+\t\t  {\n+\t\t    if (!gfc_resolve_expr (n->expr)\n+\t\t\t|| n->expr->expr_type != EXPR_VARIABLE\n+\t\t\t|| n->expr->ref == NULL\n+\t\t\t|| n->expr->ref->next\n+\t\t\t|| n->expr->ref->type != REF_ARRAY)\n+\t\t      gfc_error (\"%qs in %s clause at %L is not a proper \"\n+\t\t\t\t \"array section\", n->sym->name, name, where);\n+\t\t    else if (n->expr->ref->u.ar.codimen)\n+\t\t      gfc_error (\"Coarrays not supported in %s clause at %L\",\n+\t\t\t\t name, where);\n+\t\t    else\n+\t\t      {\n+\t\t\tint i;\n+\t\t\tgfc_array_ref *ar = &n->expr->ref->u.ar;\n+\t\t\tfor (i = 0; i < ar->dimen; i++)\n+\t\t\t  if (ar->stride[i])\n+\t\t\t    {\n+\t\t\t      gfc_error (\"Stride should not be specified for \"\n+\t\t\t\t\t \"array section in %s clause at %L\",\n+\t\t\t\t\t name, where);\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t  else if (ar->dimen_type[i] != DIMEN_ELEMENT\n+\t\t\t\t   && ar->dimen_type[i] != DIMEN_RANGE)\n+\t\t\t    {\n+\t\t\t      gfc_error (\"%qs in %s clause at %L is not a \"\n+\t\t\t\t\t \"proper array section\",\n+\t\t\t\t\t n->sym->name, name, where);\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t  else if (list == OMP_LIST_DEPEND\n+\t\t\t\t   && ar->start[i]\n+\t\t\t\t   && ar->start[i]->expr_type == EXPR_CONSTANT\n+\t\t\t\t   && ar->end[i]\n+\t\t\t\t   && ar->end[i]->expr_type == EXPR_CONSTANT\n+\t\t\t\t   && mpz_cmp (ar->start[i]->value.integer,\n+\t\t\t\t\t       ar->end[i]->value.integer) > 0)\n+\t\t\t    {\n+\t\t\t      gfc_error (\"%qs in DEPEND clause at %L is a \"\n+\t\t\t\t\t \"zero size array section\",\n+\t\t\t\t\t n->sym->name, where);\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t      }\n+\t\t  }\n+\t\telse if (openacc)\n+\t\t  {\n+\t\t    if (list == OMP_LIST_MAP\n+\t\t\t&& n->u.map_op == OMP_MAP_FORCE_DEVICEPTR)\n+\t\t      resolve_oacc_deviceptr_clause (n->sym, *where, name);\n+\t\t    else\n+\t\t      resolve_oacc_data_clauses (n->sym, *where, name);\n+\t\t  }\n+\t      }\n+\n \t    if (list != OMP_LIST_DEPEND)\n \t      for (n = omp_clauses->lists[list]; n != NULL; n = n->next)\n \t\t{\n@@ -2346,7 +3205,10 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t      gfc_error (\"Cray pointer %qs in %s clause at %L\",\n \t\t\t\t n->sym->name, name, where);\n \t\t  }\n-\t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n+\t\tif (code\n+\t\t    && (oacc_is_loop (code) || code->op == EXEC_OACC_PARALLEL))\n+\t\t  check_array_not_assumed (n->sym, *where, name);\n+\t\telse if (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n \t\t  gfc_error (\"Assumed size array %qs in %s clause at %L\",\n \t\t\t     n->sym->name, name, where);\n \t\tif (n->sym->attr.in_namelist && list != OMP_LIST_REDUCTION)\n@@ -2366,6 +3228,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t    default:\n \t\t      break;\n \t\t    }\n+\n \t\tswitch (list)\n \t\t  {\n \t\t  case OMP_LIST_REDUCTION:\n@@ -2499,6 +3362,30 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t     to be done here for OMP_LIST_PRIVATE.  */\n \t\t  case OMP_LIST_PRIVATE:\n \t\t    gcc_assert (code && code->op != EXEC_NOP);\n+\t\t    break;\n+\t\t  case OMP_LIST_USE_DEVICE:\n+\t\t      if (n->sym->attr.allocatable\n+\t\t\t  || (n->sym->ts.type == BT_CLASS && CLASS_DATA (n->sym)\n+\t\t\t      && CLASS_DATA (n->sym)->attr.allocatable))\n+\t\t\tgfc_error (\"ALLOCATABLE object '%s' in %s clause at %L\",\n+\t\t\t\t   n->sym->name, name, where);\n+\t\t      if (n->sym->attr.pointer\n+\t\t\t  || (n->sym->ts.type == BT_CLASS && CLASS_DATA (n->sym)\n+\t\t\t      && CLASS_DATA (n->sym)->attr.class_pointer))\n+\t\t\tgfc_error (\"POINTER object '%s' in %s clause at %L\",\n+\t\t\t\t   n->sym->name, name, where);\n+\t\t      if (n->sym->attr.cray_pointer)\n+\t\t\tgfc_error (\"Cray pointer object '%s' in %s clause at %L\",\n+\t\t\t\t   n->sym->name, name, where);\n+\t\t      if (n->sym->attr.cray_pointee)\n+\t\t\tgfc_error (\"Cray pointee object '%s' in %s clause at %L\",\n+\t\t\t\t   n->sym->name, name, where);\n+\t\t      /* FALLTHRU */\n+\t\t  case OMP_LIST_DEVICE_RESIDENT:\n+\t\t  case OMP_LIST_CACHE:\n+\t\t    check_symbol_not_pointer (n->sym, *where, name);\n+\t\t    check_array_not_assumed (n->sym, *where, name);\n+\t\t    break;\n \t\t  default:\n \t\t    break;\n \t\t  }\n@@ -2554,6 +3441,25 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \tgfc_error (\"THREAD_LIMIT clause at %L requires a scalar \"\n \t\t   \"INTEGER expression\", &expr->where);\n     }\n+  if (omp_clauses->async)\n+    if (omp_clauses->async_expr)\n+      resolve_oacc_scalar_int_expr (omp_clauses->async_expr, \"ASYNC\");\n+  if (omp_clauses->num_gangs_expr)\n+    resolve_oacc_positive_int_expr (omp_clauses->num_gangs_expr, \"NUM_GANGS\");\n+  if (omp_clauses->num_workers_expr)\n+    resolve_oacc_positive_int_expr (omp_clauses->num_workers_expr, \"NUM_WORKERS\");\n+  if (omp_clauses->vector_length_expr)\n+    resolve_oacc_positive_int_expr (omp_clauses->vector_length_expr, \"VECTOR_LENGTH\");\n+  if (omp_clauses->gang_expr)\n+    resolve_oacc_positive_int_expr (omp_clauses->gang_expr, \"GANG\");\n+  if (omp_clauses->worker_expr)\n+    resolve_oacc_positive_int_expr (omp_clauses->worker_expr, \"WORKER\");\n+  if (omp_clauses->vector_expr)\n+    resolve_oacc_positive_int_expr (omp_clauses->vector_expr, \"VECTOR\");\n+  if (omp_clauses->wait)\n+    if (omp_clauses->wait_list)\n+      for (el = omp_clauses->wait_list; el; el = el->next)\n+\tresolve_oacc_scalar_int_expr (el->expr, \"WAIT\");\n }\n \n \n@@ -3021,6 +3927,7 @@ struct fortran_omp_context\n   hash_set<gfc_symbol *> *sharing_clauses;\n   hash_set<gfc_symbol *> *private_iterators;\n   struct fortran_omp_context *previous;\n+  bool is_openmp;\n } *omp_current_ctx;\n static gfc_code *omp_current_do_code;\n static int omp_current_do_collapse;\n@@ -3065,6 +3972,7 @@ gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n   ctx.sharing_clauses = new hash_set<gfc_symbol *>;\n   ctx.private_iterators = new hash_set<gfc_symbol *>;\n   ctx.previous = omp_current_ctx;\n+  ctx.is_openmp = true;\n   omp_current_ctx = &ctx;\n \n   for (list = 0; list < OMP_LIST_NUM; list++)\n@@ -3159,7 +4067,12 @@ gfc_resolve_do_iterator (gfc_code *code, gfc_symbol *sym)\n   if (omp_current_ctx == NULL)\n     return;\n \n-  if (omp_current_ctx->sharing_clauses->contains (sym))\n+  /* An openacc context may represent a data clause.  Abort if so.  */\n+  if (!omp_current_ctx->is_openmp && !oacc_is_loop (omp_current_ctx->code))\n+    return;\n+\n+  if (omp_current_ctx->is_openmp\n+      && omp_current_ctx->sharing_clauses->contains (sym))\n     return;\n \n   if (! omp_current_ctx->private_iterators->add (sym))\n@@ -3340,13 +4253,437 @@ resolve_omp_do (gfc_code *code)\n     }\n }\n \n+static bool\n+oacc_is_parallel (gfc_code *code)\n+{\n+  return code->op == EXEC_OACC_PARALLEL || code->op == EXEC_OACC_PARALLEL_LOOP;\n+}\n+\n+static bool\n+oacc_is_kernels (gfc_code *code)\n+{\n+  return code->op == EXEC_OACC_KERNELS || code->op == EXEC_OACC_KERNELS_LOOP;\n+}\n+\n+static gfc_statement\n+omp_code_to_statement (gfc_code *code)\n+{\n+  switch (code->op)\n+    {\n+    case EXEC_OMP_PARALLEL:\n+      return ST_OMP_PARALLEL;\n+    case EXEC_OMP_PARALLEL_SECTIONS:\n+      return ST_OMP_PARALLEL_SECTIONS;\n+    case EXEC_OMP_SECTIONS:\n+      return ST_OMP_SECTIONS;\n+    case EXEC_OMP_ORDERED:\n+      return ST_OMP_ORDERED;\n+    case EXEC_OMP_CRITICAL:\n+      return ST_OMP_CRITICAL;\n+    case EXEC_OMP_MASTER:\n+      return ST_OMP_MASTER;\n+    case EXEC_OMP_SINGLE:\n+      return ST_OMP_SINGLE;\n+    case EXEC_OMP_TASK:\n+      return ST_OMP_TASK;\n+    case EXEC_OMP_WORKSHARE:\n+      return ST_OMP_WORKSHARE;\n+    case EXEC_OMP_PARALLEL_WORKSHARE:\n+      return ST_OMP_PARALLEL_WORKSHARE;\n+    case EXEC_OMP_DO:\n+      return ST_OMP_DO;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static gfc_statement\n+oacc_code_to_statement (gfc_code *code)\n+{\n+  switch (code->op)\n+    {\n+    case EXEC_OACC_PARALLEL:\n+      return ST_OACC_PARALLEL;\n+    case EXEC_OACC_KERNELS:\n+      return ST_OACC_KERNELS;\n+    case EXEC_OACC_DATA:\n+      return ST_OACC_DATA;\n+    case EXEC_OACC_HOST_DATA:\n+      return ST_OACC_HOST_DATA;\n+    case EXEC_OACC_PARALLEL_LOOP:\n+      return ST_OACC_PARALLEL_LOOP;\n+    case EXEC_OACC_KERNELS_LOOP:\n+      return ST_OACC_KERNELS_LOOP;\n+    case EXEC_OACC_LOOP:\n+      return ST_OACC_LOOP;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static void\n+resolve_oacc_directive_inside_omp_region (gfc_code *code)\n+{\n+  if (omp_current_ctx != NULL && omp_current_ctx->is_openmp)\n+    {\n+      gfc_statement st = omp_code_to_statement (omp_current_ctx->code);\n+      gfc_statement oacc_st = oacc_code_to_statement (code);\n+      gfc_error (\"The %s directive cannot be specified within \"\n+\t\t \"a %s region at %L\", gfc_ascii_statement (oacc_st), \n+\t\t gfc_ascii_statement (st), &code->loc);\n+    }\n+}\n+\n+static void\n+resolve_omp_directive_inside_oacc_region (gfc_code *code)\n+{\n+  if (omp_current_ctx != NULL && !omp_current_ctx->is_openmp)\n+    {\n+      gfc_statement st = oacc_code_to_statement (omp_current_ctx->code);\n+      gfc_statement omp_st = omp_code_to_statement (code);\n+      gfc_error (\"The %s directive cannot be specified within \"\n+\t\t \"a %s region at %L\", gfc_ascii_statement (omp_st), \n+\t\t gfc_ascii_statement (st), &code->loc);\n+    }\n+}\n+\n+\n+static void\n+resolve_oacc_nested_loops (gfc_code *code, gfc_code* do_code, int collapse,\n+\t\t\t  const char *clause)\n+{\n+  gfc_symbol *dovar;\n+  gfc_code *c;\n+  int i;\n+\n+  for (i = 1; i <= collapse; i++)\n+    {\n+      if (do_code->op == EXEC_DO_WHILE)\n+\t{\n+\t  gfc_error (\"!$ACC LOOP cannot be a DO WHILE or DO without loop control \"\n+\t\t     \"at %L\", &do_code->loc);\n+\t  break;\n+\t}\n+      gcc_assert (do_code->op == EXEC_DO || do_code->op == EXEC_DO_CONCURRENT);\n+      if (do_code->ext.iterator->var->ts.type != BT_INTEGER)\n+\tgfc_error (\"!$ACC LOOP iteration variable must be of type integer at %L\",\n+\t\t   &do_code->loc);\n+      dovar = do_code->ext.iterator->var->symtree->n.sym;\n+      if (i > 1)\n+\t{\n+\t  gfc_code *do_code2 = code->block->next;\n+\t  int j;\n+\n+\t  for (j = 1; j < i; j++)\n+\t    {\n+\t      gfc_symbol *ivar = do_code2->ext.iterator->var->symtree->n.sym;\n+\t      if (dovar == ivar\n+\t\t  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->start)\n+\t\t  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->end)\n+\t\t  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->step))\n+\t\t{\n+\t\t  gfc_error (\"!$ACC LOOP %s loops don't form rectangular iteration space at %L\",\n+\t\t\t     clause, &do_code->loc);\n+\t\t  break;\n+\t\t}\n+\t      if (j < i)\n+\t\tbreak;\n+\t      do_code2 = do_code2->block->next;\n+\t    }\n+\t}\n+      if (i == collapse)\n+\tbreak;\n+      for (c = do_code->next; c; c = c->next)\n+\tif (c->op != EXEC_NOP && c->op != EXEC_CONTINUE)\n+\t  {\n+\t    gfc_error (\"%s !$ACC LOOP loops not perfectly nested at %L\",\n+\t\t       clause, &c->loc);\n+\t    break;\n+\t  }\n+      if (c)\n+\tbreak;\n+      do_code = do_code->block;\n+      if (do_code->op != EXEC_DO && do_code->op != EXEC_DO_WHILE\n+\t  && do_code->op != EXEC_DO_CONCURRENT)\n+\t{\n+\t  gfc_error (\"not enough DO loops for %s !$ACC LOOP at %L\",\n+\t\t     clause, &code->loc);\n+\t  break;\n+\t}\n+      do_code = do_code->next;\n+      if (do_code == NULL\n+\t  || (do_code->op != EXEC_DO && do_code->op != EXEC_DO_WHILE\n+\t      && do_code->op != EXEC_DO_CONCURRENT))\n+\t{\n+\t  gfc_error (\"not enough DO loops for %s !$ACC LOOP at %L\",\n+\t\t     clause, &code->loc);\n+\t  break;\n+\t}\n+    }\n+}\n+\n+\n+static void\n+resolve_oacc_params_in_parallel (gfc_code *code, const char *clause)\n+{\n+  fortran_omp_context *c;\n+\n+  if (oacc_is_parallel (code))\n+    gfc_error (\"!$ACC LOOP %s in PARALLEL region doesn't allow \"\n+\t       \"non-static arguments at %L\", clause, &code->loc);\n+  for (c = omp_current_ctx; c; c = c->previous)\n+    {\n+      if (oacc_is_loop (c->code))\n+\tbreak;\n+      if (oacc_is_parallel (c->code))\n+\tgfc_error (\"!$ACC LOOP %s in PARALLEL region doesn't allow \"\n+\t\t   \"non-static arguments at %L\", clause, &code->loc);\n+    }\n+}\n+\n+\n+static void\n+resolve_oacc_loop_blocks (gfc_code *code)\n+{\n+  fortran_omp_context *c;\n+\n+  if (!oacc_is_loop (code))\n+    return;\n+\n+  if (code->op == EXEC_OACC_LOOP)\n+    for (c = omp_current_ctx; c; c = c->previous)\n+      {\n+\tif (oacc_is_loop (c->code))\n+\t  {\n+\t    if (code->ext.omp_clauses->gang)\n+\t      {\n+\t\tif (c->code->ext.omp_clauses->gang)\n+\t\t  gfc_error (\"Loop parallelized across gangs is not allowed \"\n+\t\t\t     \"inside another loop parallelized across gangs at %L\",\n+\t\t\t     &code->loc);\n+\t\tif (c->code->ext.omp_clauses->worker)\n+\t\t  gfc_error (\"Loop parallelized across gangs is not allowed \"\n+\t\t\t     \"inside loop parallelized across workers at %L\",\n+\t\t\t     &code->loc);\n+\t\tif (c->code->ext.omp_clauses->vector)\n+\t\t  gfc_error (\"Loop parallelized across gangs is not allowed \"\n+\t\t\t     \"inside loop parallelized across workers at %L\",\n+\t\t\t     &code->loc);\n+\t      }\n+\t    if (code->ext.omp_clauses->worker)\n+\t      {\n+\t\tif (c->code->ext.omp_clauses->worker)\n+\t\t  gfc_error (\"Loop parallelized across workers is not allowed \"\n+\t\t\t     \"inside another loop parallelized across workers at %L\",\n+\t\t\t     &code->loc);\n+\t\tif (c->code->ext.omp_clauses->vector)\n+\t\t  gfc_error (\"Loop parallelized across workers is not allowed \"\n+\t\t\t     \"inside another loop parallelized across vectors at %L\",\n+\t\t\t     &code->loc);\n+\t      }\n+\t    if (code->ext.omp_clauses->vector)\n+\t      if (c->code->ext.omp_clauses->vector)\n+\t\tgfc_error (\"Loop parallelized across vectors is not allowed \"\n+\t\t\t   \"inside another loop parallelized across vectors at %L\",\n+\t\t\t   &code->loc);\n+\t  }\n+\n+\tif (oacc_is_parallel (c->code) || oacc_is_kernels (c->code))\n+\t  break;\n+      }\n+\n+  if (code->ext.omp_clauses->seq)\n+    {\n+      if (code->ext.omp_clauses->independent)\n+\tgfc_error (\"Clause SEQ conflicts with INDEPENDENT at %L\", &code->loc);\n+      if (code->ext.omp_clauses->gang)\n+\tgfc_error (\"Clause SEQ conflicts with GANG at %L\", &code->loc);\n+      if (code->ext.omp_clauses->worker)\n+\tgfc_error (\"Clause SEQ conflicts with WORKER at %L\", &code->loc);\n+      if (code->ext.omp_clauses->vector)\n+\tgfc_error (\"Clause SEQ conflicts with VECTOR at %L\", &code->loc);\n+      if (code->ext.omp_clauses->par_auto)\n+\tgfc_error (\"Clause SEQ conflicts with AUTO at %L\", &code->loc);\n+    }\n+  if (code->ext.omp_clauses->par_auto)\n+    {\n+      if (code->ext.omp_clauses->gang)\n+\tgfc_error (\"Clause AUTO conflicts with GANG at %L\", &code->loc);\n+      if (code->ext.omp_clauses->worker)\n+\tgfc_error (\"Clause AUTO conflicts with WORKER at %L\", &code->loc);\n+      if (code->ext.omp_clauses->vector)\n+\tgfc_error (\"Clause AUTO conflicts with VECTOR at %L\", &code->loc);\n+    }\n+  if (!code->ext.omp_clauses->tile_list)\n+    {\n+      if (code->ext.omp_clauses->gang)\n+\t{\n+\t  if (code->ext.omp_clauses->worker)\n+\t    gfc_error (\"Clause GANG conflicts with WORKER at %L\", &code->loc);\n+\t  if (code->ext.omp_clauses->vector)\n+\t    gfc_error (\"Clause GANG conflicts with VECTOR at %L\", &code->loc);\n+\t}\n+      if (code->ext.omp_clauses->worker)\n+\tif (code->ext.omp_clauses->vector)\n+\t  gfc_error (\"Clause WORKER conflicts with VECTOR at %L\", &code->loc);\n+    }\n+  else if (code->ext.omp_clauses->gang\n+\t   && code->ext.omp_clauses->worker\n+\t   && code->ext.omp_clauses->vector)\n+    gfc_error (\"Tiled loop cannot be parallelized across gangs, workers and \"\n+\t       \"vectors at the same time at %L\", &code->loc);\n+\n+  if (code->ext.omp_clauses->gang\n+      && code->ext.omp_clauses->gang_expr\n+      && !code->ext.omp_clauses->gang_static)\n+    resolve_oacc_params_in_parallel (code, \"GANG\");\n+\n+  if (code->ext.omp_clauses->worker\n+      && code->ext.omp_clauses->worker_expr)\n+    resolve_oacc_params_in_parallel (code, \"WORKER\");\n+\n+  if (code->ext.omp_clauses->tile_list)\n+    {\n+      gfc_expr_list *el;\n+      int num = 0;\n+      for (el = code->ext.omp_clauses->tile_list; el; el = el->next)\n+\t{\n+\t  num++;\n+\t  if (el->expr == NULL)\n+\t    continue;\n+\t  resolve_oacc_positive_int_expr (el->expr, \"TILE\");\n+\t  if (el->expr->expr_type != EXPR_CONSTANT)\n+\t    gfc_error (\"TILE requires constant expression at %L\", &code->loc);\n+\t}\n+      resolve_oacc_nested_loops (code, code->block->next, num, \"tiled\");\n+    }\n+}\n+\n+\n+void\n+gfc_resolve_oacc_blocks (gfc_code *code, gfc_namespace *ns)\n+{\n+  fortran_omp_context ctx;\n+\n+  resolve_oacc_loop_blocks (code);\n+\n+  ctx.code = code;\n+  ctx.sharing_clauses = NULL;\n+  ctx.private_iterators = new hash_set<gfc_symbol *>;\n+  ctx.previous = omp_current_ctx;\n+  ctx.is_openmp = false;\n+  omp_current_ctx = &ctx;\n+\n+  gfc_resolve_blocks (code->block, ns);\n+\n+  omp_current_ctx = ctx.previous;\n+  delete ctx.private_iterators;\n+}\n+\n+\n+static void\n+resolve_oacc_loop (gfc_code *code)\n+{\n+  gfc_code *do_code;\n+  int collapse;\n+\n+  if (code->ext.omp_clauses)\n+    resolve_omp_clauses (code, &code->loc, code->ext.omp_clauses, NULL, true);\n+\n+  do_code = code->block->next;\n+  collapse = code->ext.omp_clauses->collapse;\n+\n+  if (collapse <= 0)\n+    collapse = 1;\n+  resolve_oacc_nested_loops (code, do_code, collapse, \"collapsed\");\n+}\n+\n+\n+static void\n+resolve_oacc_cache (gfc_code *code ATTRIBUTE_UNUSED)\n+{\n+  sorry (\"Sorry, !$ACC cache unimplemented yet\");\n+}\n+\n+\n+void\n+gfc_resolve_oacc_declare (gfc_namespace *ns)\n+{\n+  int list;\n+  gfc_omp_namelist *n;\n+  locus loc;\n+\n+  if (ns->oacc_declare_clauses == NULL)\n+    return;\n+\n+  loc = ns->oacc_declare_clauses->loc;\n+\n+  for (list = OMP_LIST_DEVICE_RESIDENT;\n+       list <= OMP_LIST_DEVICE_RESIDENT; list++)\n+    for (n = ns->oacc_declare_clauses->lists[list]; n; n = n->next)\n+      {\n+\tn->sym->mark = 0;\n+\tif (n->sym->attr.flavor == FL_PARAMETER)\n+\t  gfc_error (\"PARAMETER object '%s' is not allowed at %L\", n->sym->name, &loc);\n+      }\n+\n+  for (list = OMP_LIST_DEVICE_RESIDENT;\n+       list <= OMP_LIST_DEVICE_RESIDENT; list++)\n+    for (n = ns->oacc_declare_clauses->lists[list]; n; n = n->next)\n+      {\n+\tif (n->sym->mark)\n+\t  gfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\t\t     n->sym->name, &loc);\n+\telse\n+\t  n->sym->mark = 1;\n+      }\n+\n+  for (n = ns->oacc_declare_clauses->lists[OMP_LIST_DEVICE_RESIDENT]; n;\n+       n = n->next)\n+    check_array_not_assumed (n->sym, loc, \"DEVICE_RESIDENT\");\n+}\n+\n+\n+void\n+gfc_resolve_oacc_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n+{\n+  resolve_oacc_directive_inside_omp_region (code);\n+\n+  switch (code->op)\n+    {\n+    case EXEC_OACC_PARALLEL:\n+    case EXEC_OACC_KERNELS:\n+    case EXEC_OACC_DATA:\n+    case EXEC_OACC_HOST_DATA:\n+    case EXEC_OACC_UPDATE:\n+    case EXEC_OACC_ENTER_DATA:\n+    case EXEC_OACC_EXIT_DATA:\n+    case EXEC_OACC_WAIT:\n+      resolve_omp_clauses (code, &code->loc, code->ext.omp_clauses, NULL,\n+\t\t\t   true);\n+      break;\n+    case EXEC_OACC_PARALLEL_LOOP:\n+    case EXEC_OACC_KERNELS_LOOP:\n+    case EXEC_OACC_LOOP:\n+      resolve_oacc_loop (code);\n+      break;\n+    case EXEC_OACC_CACHE:\n+      resolve_oacc_cache (code);\n+      break;\n+    default:\n+      break;\n+    }\n+}\n+\n \n /* Resolve OpenMP directive clauses and check various requirements\n    of each directive.  */\n \n void\n gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n {\n+  resolve_omp_directive_inside_oacc_region (code);\n+\n   if (code->op != EXEC_OMP_ATOMIC)\n     gfc_maybe_initialize_eh ();\n "}, {"sha": "fd7d4ebc39fa43c10869383f4e06e3c61164f675", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 448, "deletions": 29, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -584,6 +584,93 @@ decode_statement (void)\n \tundo_new_statement ();\t\t\t\t  \t\\\n     } while (0);\n \n+static gfc_statement\n+decode_oacc_directive (void)\n+{\n+  locus old_locus;\n+  char c;\n+\n+  gfc_enforce_clean_symbol_state ();\n+\n+  gfc_clear_error ();   /* Clear any pending errors.  */\n+  gfc_clear_warning (); /* Clear any pending warnings.  */\n+\n+  if (gfc_pure (NULL))\n+    {\n+      gfc_error_now (\"OpenACC directives at %C may not appear in PURE \"\n+\t\t     \"procedures\");\n+      gfc_error_recovery ();\n+      return ST_NONE;\n+    }\n+\n+  gfc_unset_implicit_pure (NULL);\n+\n+  old_locus = gfc_current_locus;\n+\n+  /* General OpenACC directive matching: Instead of testing every possible\n+     statement, we eliminate most possibilities by peeking at the\n+     first character.  */\n+\n+  c = gfc_peek_ascii_char ();\n+\n+  switch (c)\n+    {\n+    case 'c':\n+      match (\"cache\", gfc_match_oacc_cache, ST_OACC_CACHE);\n+      break;\n+    case 'd':\n+      match (\"data\", gfc_match_oacc_data, ST_OACC_DATA);\n+      match (\"declare\", gfc_match_oacc_declare, ST_OACC_DECLARE);\n+      break;\n+    case 'e':\n+      match (\"end data\", gfc_match_omp_eos, ST_OACC_END_DATA);\n+      match (\"end host_data\", gfc_match_omp_eos, ST_OACC_END_HOST_DATA);\n+      match (\"end kernels loop\", gfc_match_omp_eos, ST_OACC_END_KERNELS_LOOP);\n+      match (\"end kernels\", gfc_match_omp_eos, ST_OACC_END_KERNELS);\n+      match (\"end loop\", gfc_match_omp_eos, ST_OACC_END_LOOP);\n+      match (\"end parallel loop\", gfc_match_omp_eos, ST_OACC_END_PARALLEL_LOOP);\n+      match (\"end parallel\", gfc_match_omp_eos, ST_OACC_END_PARALLEL);\n+      match (\"enter data\", gfc_match_oacc_enter_data, ST_OACC_ENTER_DATA);\n+      match (\"exit data\", gfc_match_oacc_exit_data, ST_OACC_EXIT_DATA);\n+      break;\n+    case 'h':\n+      match (\"host_data\", gfc_match_oacc_host_data, ST_OACC_HOST_DATA);\n+      break;\n+    case 'p':\n+      match (\"parallel loop\", gfc_match_oacc_parallel_loop, ST_OACC_PARALLEL_LOOP);\n+      match (\"parallel\", gfc_match_oacc_parallel, ST_OACC_PARALLEL);\n+      break;\n+    case 'k':\n+      match (\"kernels loop\", gfc_match_oacc_kernels_loop, ST_OACC_KERNELS_LOOP);\n+      match (\"kernels\", gfc_match_oacc_kernels, ST_OACC_KERNELS);\n+      break;\n+    case 'l':\n+      match (\"loop\", gfc_match_oacc_loop, ST_OACC_LOOP);\n+      break;\n+    case 'r':\n+      match (\"routine\", gfc_match_oacc_routine, ST_OACC_ROUTINE);\n+      break;\n+    case 'u':\n+      match (\"update\", gfc_match_oacc_update, ST_OACC_UPDATE);\n+      break;\n+    case 'w':\n+      match (\"wait\", gfc_match_oacc_wait, ST_OACC_WAIT);\n+      break;\n+    }\n+\n+  /* Directive not found or stored an error message.\n+     Check and give up.  */\n+\n+  if (gfc_error_check () == 0)\n+    gfc_error_now (\"Unclassifiable OpenACC directive at %C\");\n+\n+  reject_statement ();\n+\n+  gfc_error_recovery ();\n+\n+  return ST_NONE;\n+}\n+\n static gfc_statement\n decode_omp_directive (void)\n {\n@@ -811,6 +898,23 @@ decode_gcc_attribute (void)\n \n #undef match\n \n+/* Assert next length characters to be equal to token in free form.  */\n+\n+static void \n+verify_token_free (const char* token, int length, bool last_was_use_stmt)\n+{\n+  int i;\n+  char c;\n+\n+  c = gfc_next_ascii_char ();\n+  for (i = 0; i < length; i++, c = gfc_next_ascii_char ())\n+    gcc_assert (c == token[i]);\n+\n+  gcc_assert (gfc_is_whitespace(c));\n+  gfc_gobble_whitespace ();\n+  if (last_was_use_stmt)\n+    use_modules ();\n+}\n \n /* Get the next statement in free form source.  */\n \n@@ -880,7 +984,7 @@ next_free (void)\n   else if (c == '!')\n     {\n       /* Comments have already been skipped by the time we get here,\n-\t except for GCC attributes and OpenMP directives.  */\n+\t except for GCC attributes and OpenMP/OpenACC directives.  */\n \n       gfc_next_ascii_char (); /* Eat up the exclamation sign.  */\n       c = gfc_peek_ascii_char ();\n@@ -897,21 +1001,39 @@ next_free (void)\n \t  return decode_gcc_attribute ();\n \n \t}\n-      else if (c == '$' && (flag_openmp || flag_openmp_simd))\n+      else if (c == '$')\n \t{\n-\t  int i;\n-\n-\t  c = gfc_next_ascii_char ();\n-\t  for (i = 0; i < 4; i++, c = gfc_next_ascii_char ())\n-\t    gcc_assert (c == \"$omp\"[i]);\n+\t  /* Since both OpenMP and OpenACC directives starts with \n+\t     !$ character sequence, we must check all flags combinations */\n+\t  if ((flag_openmp || flag_openmp_simd)\n+\t      && !flag_openacc)\n+\t    {\n+\t      verify_token_free (\"$omp\", 4, last_was_use_stmt);\n+\t      return decode_omp_directive ();\n+\t    }\n+\t  else if ((flag_openmp || flag_openmp_simd)\n+\t\t   && flag_openacc)\n+\t    {\n+\t      gfc_next_ascii_char (); /* Eat up dollar character */\n+\t      c = gfc_peek_ascii_char ();\n \n-\t  gcc_assert (c == ' ' || c == '\\t');\n-\t  gfc_gobble_whitespace ();\n-\t  if (last_was_use_stmt)\n-\t    use_modules ();\n-\t  return decode_omp_directive ();\n+\t      if (c == 'o')\n+\t\t{\n+\t\t  verify_token_free (\"omp\", 3, last_was_use_stmt);\n+\t\t  return decode_omp_directive ();\n+\t\t}\n+\t      else if (c == 'a')\n+\t\t{\n+\t\t  verify_token_free (\"acc\", 3, last_was_use_stmt);\n+\t\t  return decode_oacc_directive ();\n+\t\t}\n+\t    }\n+\t  else if (flag_openacc)\n+\t    {\n+\t      verify_token_free (\"$acc\", 4, last_was_use_stmt);\n+\t      return decode_oacc_directive ();\n+\t    }\n \t}\n-\n       gcc_unreachable (); \n     }\n  \n@@ -927,6 +1049,28 @@ next_free (void)\n   return decode_statement ();\n }\n \n+/* Assert next length characters to be equal to token in fixed form.  */\n+\n+static bool\n+verify_token_fixed (const char *token, int length, bool last_was_use_stmt)\n+{\n+  int i;\n+  char c = gfc_next_char_literal (NONSTRING);\n+\n+  for (i = 0; i < length; i++, c = gfc_next_char_literal (NONSTRING))\n+    gcc_assert ((char) gfc_wide_tolower (c) == token[i]);\n+\n+  if (c != ' ' && c != '0')\n+    {\n+      gfc_buffer_error (false);\n+      gfc_error (\"Bad continuation line at %C\");\n+      return false;\n+    }\n+  if (last_was_use_stmt)\n+    use_modules ();\n+\n+  return true;\n+}\n \n /* Get the next statement in fixed-form source.  */\n \n@@ -986,21 +1130,38 @@ next_fixed (void)\n \n \t      return decode_gcc_attribute ();\n \t    }\n-\t  else if (c == '$'\n-\t\t   && (flag_openmp || flag_openmp_simd))\n+\t  else if (c == '$')\n \t    {\n-\t      for (i = 0; i < 4; i++, c = gfc_next_char_literal (NONSTRING))\n-\t\tgcc_assert ((char) gfc_wide_tolower (c) == \"$omp\"[i]);\n-\n-\t      if (c != ' ' && c != '0')\n+\t      if ((flag_openmp || flag_openmp_simd)\n+\t\t  && !flag_openacc)\n \t\t{\n-\t\t  gfc_buffer_error (false);\n-\t\t  gfc_error (\"Bad continuation line at %C\");\n-\t\t  return ST_NONE;\n+\t\t  if (!verify_token_fixed (\"omp\", 3, last_was_use_stmt))\n+\t\t    return ST_NONE;\n+\t\t  return decode_omp_directive ();\n+\t\t}\n+\t      else if ((flag_openmp || flag_openmp_simd)\n+\t\t       && flag_openacc)\n+\t\t{\n+\t\t  c = gfc_next_char_literal(NONSTRING);\n+\t\t  if (c == 'o' || c == 'O')\n+\t\t    {\n+\t\t      if (!verify_token_fixed (\"mp\", 2, last_was_use_stmt))\n+\t\t\treturn ST_NONE;\n+\t\t      return decode_omp_directive ();\n+\t\t    }\n+\t\t  else if (c == 'a' || c == 'A')\n+\t\t    {\n+\t\t      if (!verify_token_fixed (\"cc\", 2, last_was_use_stmt))\n+\t\t\treturn ST_NONE;\n+\t\t      return decode_oacc_directive ();\n+\t\t    }\n+\t\t}\n+\t      else if (flag_openacc)\n+\t\t{\n+\t\t  if (!verify_token_fixed (\"acc\", 3, last_was_use_stmt))\n+\t\t    return ST_NONE;\n+\t\t  return decode_oacc_directive ();\n \t\t}\n-\t      if (last_was_use_stmt)\n-\t\tuse_modules ();\n-\t      return decode_omp_directive ();\n \t    }\n \t  /* FALLTHROUGH */\n \n@@ -1161,7 +1322,9 @@ next_statement (void)\n   case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_OMP_TASKYIELD: \\\n   case ST_OMP_CANCEL: case ST_OMP_CANCELLATION_POINT: \\\n   case ST_OMP_TARGET_UPDATE: case ST_ERROR_STOP: case ST_SYNC_ALL: \\\n-  case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK\n+  case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK: \\\n+  case ST_OACC_UPDATE: case ST_OACC_WAIT: case ST_OACC_CACHE: \\\n+  case ST_OACC_ENTER_DATA: case ST_OACC_EXIT_DATA\n \n /* Statements that mark other executable statements.  */\n \n@@ -1186,15 +1349,17 @@ next_statement (void)\n   case ST_OMP_TEAMS_DISTRIBUTE_PARALLEL_DO_SIMD: case ST_OMP_DISTRIBUTE: \\\n   case ST_OMP_DISTRIBUTE_SIMD: case ST_OMP_DISTRIBUTE_PARALLEL_DO: \\\n   case ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD: \\\n-  case ST_CRITICAL\n+  case ST_CRITICAL: \\\n+  case ST_OACC_PARALLEL_LOOP: case ST_OACC_PARALLEL: case ST_OACC_KERNELS: \\\n+  case ST_OACC_DATA: case ST_OACC_HOST_DATA: case ST_OACC_LOOP: case ST_OACC_KERNELS_LOOP\n \n /* Declaration statements */\n \n #define case_decl case ST_ATTR_DECL: case ST_COMMON: case ST_DATA_DECL: \\\n   case ST_EQUIVALENCE: case ST_NAMELIST: case ST_STATEMENT_FUNCTION: \\\n   case ST_TYPE: case ST_INTERFACE: case ST_OMP_THREADPRIVATE: \\\n   case ST_PROCEDURE: case ST_OMP_DECLARE_SIMD: case ST_OMP_DECLARE_REDUCTION: \\\n-  case ST_OMP_DECLARE_TARGET\n+  case ST_OMP_DECLARE_TARGET: case ST_OACC_ROUTINE\n \n /* Block end statements.  Errors associated with interchanging these\n    are detected in gfc_match_end().  */\n@@ -1214,6 +1379,8 @@ push_state (gfc_state_data *p, gfc_compile_state new_state, gfc_symbol *sym)\n   p->sym = sym;\n   p->head = p->tail = NULL;\n   p->do_variable = NULL;\n+  if (p->state != COMP_DO && p->state != COMP_DO_CONCURRENT)\n+    p->ext.oacc_declare_clauses = NULL;\n \n   /* If this the state of a construct like BLOCK, DO or IF, the corresponding\n      construct statement was accepted right before pushing the state.  Thus,\n@@ -1679,6 +1846,69 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_END_ENUM:\n       p = \"END ENUM\";\n       break;\n+    case ST_OACC_PARALLEL_LOOP:\n+      p = \"!$ACC PARALLEL LOOP\";\n+      break;\n+    case ST_OACC_END_PARALLEL_LOOP:\n+      p = \"!$ACC END PARALLEL LOOP\";\n+      break;\n+    case ST_OACC_PARALLEL:\n+      p = \"!$ACC PARALLEL\";\n+      break;\n+    case ST_OACC_END_PARALLEL:\n+      p = \"!$ACC END PARALLEL\";\n+      break;\n+    case ST_OACC_KERNELS:\n+      p = \"!$ACC KERNELS\";\n+      break;\n+    case ST_OACC_END_KERNELS:\n+      p = \"!$ACC END KERNELS\";\n+      break;\n+    case ST_OACC_KERNELS_LOOP:\n+      p = \"!$ACC KERNELS LOOP\";\n+      break;\n+    case ST_OACC_END_KERNELS_LOOP:\n+      p = \"!$ACC END KERNELS LOOP\";\n+      break;\n+    case ST_OACC_DATA:\n+      p = \"!$ACC DATA\";\n+      break;\n+    case ST_OACC_END_DATA:\n+      p = \"!$ACC END DATA\";\n+      break;\n+    case ST_OACC_HOST_DATA:\n+      p = \"!$ACC HOST_DATA\";\n+      break;\n+    case ST_OACC_END_HOST_DATA:\n+      p = \"!$ACC END HOST_DATA\";\n+      break;\n+    case ST_OACC_LOOP:\n+      p = \"!$ACC LOOP\";\n+      break;\n+    case ST_OACC_END_LOOP:\n+      p = \"!$ACC END LOOP\";\n+      break;\n+    case ST_OACC_DECLARE:\n+      p = \"!$ACC DECLARE\";\n+      break;\n+    case ST_OACC_UPDATE:\n+      p = \"!$ACC UPDATE\";\n+      break;\n+    case ST_OACC_WAIT:\n+      p = \"!$ACC WAIT\";\n+      break;\n+    case ST_OACC_CACHE:\n+      p = \"!$ACC CACHE\";\n+      break;\n+    case ST_OACC_ENTER_DATA:\n+      p = \"!$ACC ENTER DATA\";\n+      break;\n+    case ST_OACC_EXIT_DATA:\n+      p = \"!$ACC EXIT DATA\";\n+      break;\n+    case ST_OACC_ROUTINE:\n+      p = \"!$ACC ROUTINE\";\n+      break;\n     case ST_OMP_ATOMIC:\n       p = \"!$OMP ATOMIC\";\n       break;\n@@ -2180,6 +2410,7 @@ verify_st_order (st_state *p, gfc_statement st, bool silent)\n     case ST_PUBLIC:\n     case ST_PRIVATE:\n     case ST_DERIVED_DECL:\n+    case ST_OACC_DECLARE:\n     case_decl:\n       if (p->state >= ORDER_EXEC)\n \tgoto order;\n@@ -3081,6 +3312,19 @@ parse_spec (gfc_statement st)\n       st = next_statement ();\n       goto loop;\n \n+    case ST_OACC_DECLARE:\n+      if (!verify_st_order(&ss, st, false))\n+\t{\n+\t  reject_statement ();\n+\t  st = next_statement ();\n+\t  goto loop;\n+\t}\n+      if (gfc_state_stack->ext.oacc_declare_clauses == NULL)\n+\tgfc_state_stack->ext.oacc_declare_clauses = new_st.ext.omp_clauses;\n+      accept_statement (st);\n+      st = next_statement ();\n+      goto loop;\n+\n     default:\n       break;\n     }\n@@ -3571,9 +3815,15 @@ static void\n parse_critical_block (void)\n {\n   gfc_code *top, *d;\n-  gfc_state_data s;\n+  gfc_state_data s, *sd;\n   gfc_statement st;\n \n+  for (sd = gfc_state_stack; sd; sd = sd->previous) \n+    if (sd->state == COMP_OMP_STRUCTURED_BLOCK)\n+      gfc_error_now (is_oacc (sd)\n+\t\t     ? \"CRITICAL block inside of OpenACC region at %C\"\n+\t\t     : \"CRITICAL block inside of OpenMP region at %C\");\n+\n   s.ext.end_do_label = new_st.label1;\n \n   accept_statement (ST_CRITICAL);\n@@ -3988,6 +4238,128 @@ parse_omp_atomic (void)\n }\n \n \n+/* Parse the statements of an OpenACC structured block.  */\n+\n+static void\n+parse_oacc_structured_block (gfc_statement acc_st)\n+{\n+  gfc_statement st, acc_end_st;\n+  gfc_code *cp, *np;\n+  gfc_state_data s, *sd;\n+\n+  for (sd = gfc_state_stack; sd; sd = sd->previous) \n+    if (sd->state == COMP_CRITICAL)\n+      gfc_error_now (\"OpenACC directive inside of CRITICAL block at %C\");\n+\n+  accept_statement (acc_st);\n+\n+  cp = gfc_state_stack->tail;\n+  push_state (&s, COMP_OMP_STRUCTURED_BLOCK, NULL);\n+  np = new_level (cp);\n+  np->op = cp->op;\n+  np->block = NULL;\n+  switch (acc_st)\n+    {\n+    case ST_OACC_PARALLEL:\n+      acc_end_st = ST_OACC_END_PARALLEL;\n+      break;\n+    case ST_OACC_KERNELS:\n+      acc_end_st = ST_OACC_END_KERNELS;\n+      break;\n+    case ST_OACC_DATA:\n+      acc_end_st = ST_OACC_END_DATA;\n+      break;\n+    case ST_OACC_HOST_DATA:\n+      acc_end_st = ST_OACC_END_HOST_DATA;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  do\n+    {\n+      st = parse_executable (ST_NONE);\n+      if (st == ST_NONE)\n+\tunexpected_eof ();\n+      else if (st != acc_end_st)\n+\tgfc_error (\"Expecting %s at %C\", gfc_ascii_statement (acc_end_st));\n+\treject_statement ();\n+    }\n+  while (st != acc_end_st);\n+\n+  gcc_assert (new_st.op == EXEC_NOP);\n+\n+  gfc_clear_new_st ();\n+  gfc_commit_symbols ();\n+  gfc_warning_check ();\n+  pop_state ();\n+}\n+\n+/* Parse the statements of OpenACC loop/parallel loop/kernels loop.  */\n+\n+static gfc_statement\n+parse_oacc_loop (gfc_statement acc_st)\n+{\n+  gfc_statement st;\n+  gfc_code *cp, *np;\n+  gfc_state_data s, *sd;\n+\n+  for (sd = gfc_state_stack; sd; sd = sd->previous) \n+    if (sd->state == COMP_CRITICAL)\n+      gfc_error_now (\"OpenACC directive inside of CRITICAL block at %C\");\n+\n+  accept_statement (acc_st);\n+\n+  cp = gfc_state_stack->tail;\n+  push_state (&s, COMP_OMP_STRUCTURED_BLOCK, NULL);\n+  np = new_level (cp);\n+  np->op = cp->op;\n+  np->block = NULL;\n+\n+  for (;;)\n+    {\n+      st = next_statement ();\n+      if (st == ST_NONE)\n+\tunexpected_eof ();\n+      else if (st == ST_DO)\n+\tbreak;\n+      else\n+\t{\n+\t  gfc_error (\"Expected DO loop at %C\");\n+\t  reject_statement ();\n+\t}\n+    }\n+\n+  parse_do_block ();\n+  if (gfc_statement_label != NULL\n+      && gfc_state_stack->previous != NULL\n+      && gfc_state_stack->previous->state == COMP_DO\n+      && gfc_state_stack->previous->ext.end_do_label == gfc_statement_label)\n+    {\n+      pop_state ();\n+      return ST_IMPLIED_ENDDO;\n+    }\n+\n+  check_do_closure ();\n+  pop_state ();\n+\n+  st = next_statement ();\n+  if (st == ST_OACC_END_LOOP)\n+    gfc_warning (\"Redundant !$ACC END LOOP at %C\");\n+  if ((acc_st == ST_OACC_PARALLEL_LOOP && st == ST_OACC_END_PARALLEL_LOOP) ||\n+      (acc_st == ST_OACC_KERNELS_LOOP && st == ST_OACC_END_KERNELS_LOOP) ||\n+      (acc_st == ST_OACC_LOOP && st == ST_OACC_END_LOOP))\n+    {\n+      gcc_assert (new_st.op == EXEC_NOP);\n+      gfc_clear_new_st ();\n+      gfc_commit_symbols ();\n+      gfc_warning_check ();\n+      st = next_statement ();\n+    }\n+  return st;\n+}\n+\n+\n /* Parse the statements of an OpenMP structured block.  */\n \n static void\n@@ -4307,6 +4679,21 @@ parse_executable (gfc_statement st)\n \t  parse_forall_block ();\n \t  break;\n \n+\tcase ST_OACC_PARALLEL_LOOP:\n+\tcase ST_OACC_KERNELS_LOOP:\n+\tcase ST_OACC_LOOP:\n+\t  st = parse_oacc_loop (st);\n+\t  if (st == ST_IMPLIED_ENDDO)\n+\t    return st;\n+\t  continue;\n+\n+\tcase ST_OACC_PARALLEL:\n+\tcase ST_OACC_KERNELS:\n+\tcase ST_OACC_DATA:\n+\tcase ST_OACC_HOST_DATA:\n+\t  parse_oacc_structured_block (st);\n+\t  break;\n+\n \tcase ST_OMP_PARALLEL:\n \tcase ST_OMP_PARALLEL_SECTIONS:\n \tcase ST_OMP_SECTIONS:\n@@ -4637,6 +5024,13 @@ parse_progunit (gfc_statement st)\n \n done:\n   gfc_current_ns->code = gfc_state_stack->head;\n+  if (gfc_state_stack->state == COMP_PROGRAM\n+      || gfc_state_stack->state == COMP_MODULE \n+      || gfc_state_stack->state == COMP_SUBROUTINE \n+      || gfc_state_stack->state == COMP_FUNCTION\n+      || gfc_state_stack->state == COMP_BLOCK)\n+    gfc_current_ns->oacc_declare_clauses \n+      = gfc_state_stack->ext.oacc_declare_clauses;\n }\n \n \n@@ -5155,3 +5549,28 @@ gfc_parse_file (void)\n   gfc_done_2 ();\n   return true;\n }\n+\n+/* Return true if this state data represents an OpenACC region.  */\n+bool\n+is_oacc (gfc_state_data *sd)\n+{\n+  switch (sd->construct->op)\n+    {\n+    case EXEC_OACC_PARALLEL_LOOP:\n+    case EXEC_OACC_PARALLEL:\n+    case EXEC_OACC_KERNELS_LOOP:\n+    case EXEC_OACC_KERNELS:\n+    case EXEC_OACC_DATA:\n+    case EXEC_OACC_HOST_DATA:\n+    case EXEC_OACC_LOOP:\n+    case EXEC_OACC_UPDATE:\n+    case EXEC_OACC_WAIT:\n+    case EXEC_OACC_CACHE:\n+    case EXEC_OACC_ENTER_DATA:\n+    case EXEC_OACC_EXIT_DATA:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "8a1613f5322146caaf5de5a332d7fc33ad0cf560", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -49,6 +49,7 @@ typedef struct gfc_state_data\n   union\n   {\n     gfc_st_label *end_do_label;\n+    gfc_omp_clauses *oacc_declare_clauses;\n   }\n   ext;\n }\n@@ -68,4 +69,5 @@ match gfc_match_enumerator_def (void);\n void gfc_free_enum_history (void);\n extern bool gfc_matching_function;\n match gfc_match_prefix (gfc_typespec *);\n+bool is_oacc (gfc_state_data *);\n #endif  /* GFC_PARSE_H  */"}, {"sha": "88f35ffb065a90a41b29856526b0a07443a944bc", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -9126,6 +9126,18 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_WAIT:\n \t  break;\n \n+\tcase EXEC_OACC_PARALLEL_LOOP:\n+\tcase EXEC_OACC_PARALLEL:\n+\tcase EXEC_OACC_KERNELS_LOOP:\n+\tcase EXEC_OACC_KERNELS:\n+\tcase EXEC_OACC_DATA:\n+\tcase EXEC_OACC_HOST_DATA:\n+\tcase EXEC_OACC_LOOP:\n+\tcase EXEC_OACC_UPDATE:\n+\tcase EXEC_OACC_WAIT:\n+\tcase EXEC_OACC_CACHE:\n+\tcase EXEC_OACC_ENTER_DATA:\n+\tcase EXEC_OACC_EXIT_DATA:\n \tcase EXEC_OMP_ATOMIC:\n \tcase EXEC_OMP_CRITICAL:\n \tcase EXEC_OMP_DISTRIBUTE:\n@@ -9941,6 +9953,15 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  omp_workshare_save = -1;\n \t  switch (code->op)\n \t    {\n+\t    case EXEC_OACC_PARALLEL_LOOP:\n+\t    case EXEC_OACC_PARALLEL:\n+\t    case EXEC_OACC_KERNELS_LOOP:\n+\t    case EXEC_OACC_KERNELS:\n+\t    case EXEC_OACC_DATA:\n+\t    case EXEC_OACC_HOST_DATA:\n+\t    case EXEC_OACC_LOOP:\n+\t      gfc_resolve_oacc_blocks (code, ns);\n+\t      break;\n \t    case EXEC_OMP_PARALLEL_WORKSHARE:\n \t      omp_workshare_save = omp_workshare_flag;\n \t      omp_workshare_flag = 1;\n@@ -10293,6 +10314,21 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t\t       \"expression\", &code->expr1->where);\n \t  break;\n \n+\tcase EXEC_OACC_PARALLEL_LOOP:\n+\tcase EXEC_OACC_PARALLEL:\n+\tcase EXEC_OACC_KERNELS_LOOP:\n+\tcase EXEC_OACC_KERNELS:\n+\tcase EXEC_OACC_DATA:\n+\tcase EXEC_OACC_HOST_DATA:\n+\tcase EXEC_OACC_LOOP:\n+\tcase EXEC_OACC_UPDATE:\n+\tcase EXEC_OACC_WAIT:\n+\tcase EXEC_OACC_CACHE:\n+\tcase EXEC_OACC_ENTER_DATA:\n+\tcase EXEC_OACC_EXIT_DATA:\n+\t  gfc_resolve_oacc_directive (code, ns);\n+\t  break;\n+\n \tcase EXEC_OMP_ATOMIC:\n \tcase EXEC_OMP_BARRIER:\n \tcase EXEC_OMP_CANCEL:\n@@ -14931,6 +14967,7 @@ resolve_codes (gfc_namespace *ns)\n   old_obstack = labels_obstack;\n   bitmap_obstack_initialize (&labels_obstack);\n \n+  gfc_resolve_oacc_declare (ns);\n   gfc_resolve_code (ns->code, ns);\n \n   bitmap_obstack_release (&labels_obstack);"}, {"sha": "4a71cb20dcf5b03db547afa62dfd4f15d5c13d66", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 301, "deletions": 64, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -55,9 +55,12 @@ gfc_directorylist *include_dirs, *intrinsic_modules_dirs;\n \n static gfc_file *file_head, *current_file;\n \n-static int continue_flag, end_flag, openmp_flag, gcc_attribute_flag;\n+static int continue_flag, end_flag, gcc_attribute_flag;\n+/* If !$omp/!$acc occurred in current comment line.  */\n+static int openmp_flag, openacc_flag;\n static int continue_count, continue_line;\n static locus openmp_locus;\n+static locus openacc_locus;\n static locus gcc_attribute_locus;\n \n gfc_source_form gfc_current_form;\n@@ -707,11 +710,89 @@ skip_gcc_attribute (locus start)\n   return r;\n }\n \n+/* Return true if CC was matched.  */\n+static bool\n+skip_oacc_attribute (locus start, locus old_loc, bool continue_flag)\n+{\n+  bool r = false;\n+  char c;\n+\n+  if ((c = next_char ()) == 'c' || c == 'C')\n+    if ((c = next_char ()) == 'c' || c == 'C')\n+      r = true;\n+\n+  if (r)\n+   {\n+      if ((c = next_char ()) == ' ' || c == '\\t'\n+\t  || continue_flag)\n+\t{\n+\t  while (gfc_is_whitespace (c))\n+\t    c = next_char ();\n+\t  if (c != '\\n' && c != '!')\n+\t    {\n+\t      openacc_flag = 1;\n+\t      openacc_locus = old_loc;\n+\t      gfc_current_locus = start;\n+\t    }\n+\t  else \n+\t    r = false;\n+\t}\n+      else\n+\t{\n+\t  gfc_warning_now (\"!$ACC at %C starts a commented \"\n+\t\t\t   \"line as it neither is followed \"\n+\t\t\t   \"by a space nor is a \"\n+\t\t\t   \"continuation line\");\n+\t  r = false;\n+\t}\n+   }\n+\n+  return r;\n+}\n+\n+/* Return true if MP was matched.  */\n+static bool\n+skip_omp_attribute (locus start, locus old_loc, bool continue_flag)\n+{\n+  bool r = false;\n+  char c;\n+\n+  if ((c = next_char ()) == 'm' || c == 'M')\n+    if ((c = next_char ()) == 'p' || c == 'P')\n+      r = true;\n+\n+  if (r)\n+   {\n+      if ((c = next_char ()) == ' ' || c == '\\t'\n+\t  || continue_flag)\n+\t{\n+\t  while (gfc_is_whitespace (c))\n+\t    c = next_char ();\n+\t  if (c != '\\n' && c != '!')\n+\t    {\n+\t      openmp_flag = 1;\n+\t      openmp_locus = old_loc;\n+\t      gfc_current_locus = start;\n+\t    }\n+\t  else \n+\t    r = false;\n+\t}\n+      else\n+\t{\n+\t  gfc_warning_now (\"!$OMP at %C starts a commented \"\n+\t\t\t   \"line as it neither is followed \"\n+\t\t\t   \"by a space nor is a \"\n+\t\t\t   \"continuation line\");\n+\t  r = false;\n+\t}\n+   }\n \n+  return r;\n+}\n \n /* Comment lines are null lines, lines containing only blanks or lines\n    on which the first nonblank line is a '!'.\n-   Return true if !$ openmp conditional compilation sentinel was\n+   Return true if !$ openmp or openacc conditional compilation sentinel was\n    seen.  */\n \n static bool\n@@ -744,55 +825,98 @@ skip_free_comments (void)\n \t  if (at_bol && skip_gcc_attribute (start))\n \t    return false;\n \n-\t  /* If -fopenmp, we need to handle here 2 things:\n-\t     1) don't treat !$omp as comments, but directives\n-\t     2) handle OpenMP conditional compilation, where\n+\t  /* If -fopenmp/-fopenacc, we need to handle here 2 things:\n+\t     1) don't treat !$omp/!$acc as comments, but directives\n+\t     2) handle OpenMP/OpenACC conditional compilation, where\n \t\t!$ should be treated as 2 spaces (for initial lines\n \t\tonly if followed by space).  */\n-\t  if ((flag_openmp || flag_openmp_simd) && at_bol)\n-\t    {\n-\t      locus old_loc = gfc_current_locus;\n-\t      if (next_char () == '$')\n-\t\t{\n-\t\t  c = next_char ();\n-\t\t  if (c == 'o' || c == 'O')\n-\t\t    {\n-\t\t      if (((c = next_char ()) == 'm' || c == 'M')\n-\t\t\t  && ((c = next_char ()) == 'p' || c == 'P'))\n+\t  if (at_bol)\n+\t  {\n+\t    if ((flag_openmp || flag_openmp_simd)\n+\t\t&& flag_openacc)\n+\t      {\n+\t\tlocus old_loc = gfc_current_locus;\n+\t\tif (next_char () == '$')\n+\t\t  {\n+\t\t    c = next_char ();\n+\t\t    if (c == 'o' || c == 'O')\n+\t\t      {\n+\t\t\tif (skip_omp_attribute (start, old_loc, continue_flag))\n+\t\t\t  return false;\n+\t\t\tgfc_current_locus = old_loc;\n+\t\t\tnext_char ();\n+\t\t\tc = next_char ();\n+\t\t      }\n+\t\t    else if (c == 'a' || c == 'A')\n+\t\t      {\n+\t\t\tif (skip_oacc_attribute (start, old_loc, continue_flag))\n+\t\t\t  return false;\n+\t\t\tgfc_current_locus = old_loc;\n+\t\t\tnext_char ();\n+\t\t\tc = next_char ();\n+\t\t      }\n+\t\t    if (continue_flag || c == ' ' || c == '\\t')\n+\t\t      {\n+\t\t\tgfc_current_locus = old_loc;\n+\t\t\tnext_char ();\n+\t\t\topenmp_flag = openacc_flag = 0;\n+\t\t\treturn true;\n+\t\t      }\n+\t\t  }\n+\t\tgfc_current_locus = old_loc;\n+\t      }\n+\t    else if ((flag_openmp || flag_openmp_simd)\n+\t\t     && !flag_openacc)\n+\t      {\n+\t\tlocus old_loc = gfc_current_locus;\n+\t\tif (next_char () == '$')\n+\t\t  {\n+\t\t    c = next_char ();\n+\t\t    if (c == 'o' || c == 'O')\n+\t\t      {\n+\t\t\tif (skip_omp_attribute (start, old_loc, continue_flag))\n+\t\t\t  return false;\n+\t\t\tgfc_current_locus = old_loc;\n+\t\t\tnext_char ();\n+\t\t\tc = next_char ();\n+\t\t      }\n+\t\t    if (continue_flag || c == ' ' || c == '\\t')\n+\t\t      {\n+\t\t\tgfc_current_locus = old_loc;\n+\t\t\tnext_char ();\n+\t\t\topenmp_flag = 0;\n+\t\t\treturn true;\n+\t\t      }\n+\t\t  }\n+\t\tgfc_current_locus = old_loc;\n+\t      }\n+\t    else if (flag_openacc\n+\t\t     && !(flag_openmp || flag_openmp_simd))\n+\t      {\n+\t\tlocus old_loc = gfc_current_locus;\n+\t\tif (next_char () == '$')\n+\t\t  {\n+\t\t    c = next_char ();\n+\t\t      if (c == 'a' || c == 'A')\n \t\t\t{\n-\t\t\t  if ((c = next_char ()) == ' ' || c == '\\t'\n-\t\t\t      || continue_flag)\n-\t\t\t    {\n-\t\t\t      while (gfc_is_whitespace (c))\n-\t\t\t\tc = next_char ();\n-\t\t\t      if (c != '\\n' && c != '!')\n-\t\t\t\t{\n-\t\t\t\t  openmp_flag = 1;\n-\t\t\t\t  openmp_locus = old_loc;\n-\t\t\t\t  gfc_current_locus = start;\n-\t\t\t\t  return false;\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    gfc_warning_now (\"!$OMP at %C starts a commented \"\n-\t\t\t\t\t     \"line as it neither is followed \"\n-\t\t\t\t\t     \"by a space nor is a \"\n-\t\t\t\t\t     \"continuation line\");\n+\t\t\t  if (skip_oacc_attribute (start, old_loc, \n+\t\t\t\t\t\t   continue_flag))\n+\t\t\t    return false;\n+\t\t\t  gfc_current_locus = old_loc;\n+\t\t\t  next_char();\n+\t\t\t  c = next_char();\n \t\t\t}\n-\t\t      gfc_current_locus = old_loc;\n-\t\t      next_char ();\n-\t\t      c = next_char ();\n-\t\t    }\n-\t\t  if (continue_flag || c == ' ' || c == '\\t')\n-\t\t    {\n-\t\t      gfc_current_locus = old_loc;\n-\t\t      next_char ();\n-\t\t      openmp_flag = 0;\n-\t\t      return true;\n-\t\t    }\n-\t\t}\n-\t      gfc_current_locus = old_loc;\n-\t    }\n+\t\t      if (continue_flag || c == ' ' || c == '\\t')\n+\t\t\t{\n+\t\t\t  gfc_current_locus = old_loc;\n+\t\t\t  next_char();\n+\t\t\t  openacc_flag = 0;\n+\t\t\t  return true;\n+\t\t\t}\n+\t\t  }\n+\t\tgfc_current_locus = old_loc;\n+\t      }\n+\t  }\n \t  skip_comment_line ();\n \t  continue;\n \t}\n@@ -803,6 +927,9 @@ skip_free_comments (void)\n   if (openmp_flag && at_bol)\n     openmp_flag = 0;\n \n+  if (openacc_flag && at_bol)\n+    openacc_flag = 0;\n+\n   gcc_attribute_flag = 0;\n   gfc_current_locus = start;\n   return false;\n@@ -865,9 +992,10 @@ skip_fixed_comments (void)\n \t      return;\n \t    }\n \n-\t  /* If -fopenmp, we need to handle here 2 things:\n-\t     1) don't treat !$omp|c$omp|*$omp as comments, but directives\n-\t     2) handle OpenMP conditional compilation, where\n+\t  /* If -fopenmp/-fopenacc, we need to handle here 2 things:\n+\t     1) don't treat !$omp/!$acc|c$omp/c$acc|*$omp / *$acc as comments, \n+\t\tbut directives\n+\t     2) handle OpenMP/OpenACC conditional compilation, where\n \t\t!$|c$|*$ should be treated as 2 spaces if the characters\n \t\tin columns 3 to 6 are valid fixed form label columns\n \t\tcharacters.  */\n@@ -934,6 +1062,67 @@ skip_fixed_comments (void)\n \t\t}\n \t      gfc_current_locus = start;\n \t    }\n+\n+\t  if (flag_openacc)\n+\t    {\n+\t      if (next_char () == '$')\n+\t\t{\n+\t\t  c = next_char ();\n+\t\t  if (c == 'a' || c == 'A')\n+\t\t    {\n+\t\t      if (((c = next_char ()) == 'c' || c == 'C')\n+\t\t\t  && ((c = next_char ()) == 'c' || c == 'C'))\n+\t\t\t{\n+\t\t\t  c = next_char ();\n+\t\t\t  if (c != '\\n'\n+\t\t\t      && ((openacc_flag && continue_flag)\n+\t\t\t\t  || c == ' ' || c == '\\t' || c == '0'))\n+\t\t\t    {\n+\t\t\t      do\n+\t\t\t\tc = next_char ();\n+\t\t\t      while (gfc_is_whitespace (c));\n+\t\t\t      if (c != '\\n' && c != '!')\n+\t\t\t\t{\n+\t\t\t\t  /* Canonicalize to *$acc. */\n+\t\t\t\t  *start.nextc = '*';\n+\t\t\t\t  openacc_flag = 1;\n+\t\t\t\t  gfc_current_locus = start;\n+\t\t\t\t  return;\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      int digit_seen = 0;\n+\n+\t\t      for (col = 3; col < 6; col++, c = next_char ())\n+\t\t\tif (c == ' ')\n+\t\t\t  continue;\n+\t\t\telse if (c == '\\t')\n+\t\t\t  {\n+\t\t\t    col = 6;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\telse if (c < '0' || c > '9')\n+\t\t\t  break;\n+\t\t\telse\n+\t\t\t  digit_seen = 1;\n+\n+\t\t      if (col == 6 && c != '\\n'\n+\t\t\t  && ((continue_flag && !digit_seen)\n+\t\t\t      || c == ' ' || c == '\\t' || c == '0'))\n+\t\t\t{\n+\t\t\t  gfc_current_locus = start;\n+\t\t\t  start.nextc[0] = ' ';\n+\t\t\t  start.nextc[1] = ' ';\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      gfc_current_locus = start;\n+\t    }\n+\n \t  skip_comment_line ();\n \t  continue;\n \t}\n@@ -976,6 +1165,7 @@ skip_fixed_comments (void)\n     }\n \n   openmp_flag = 0;\n+  openacc_flag = 0;\n   gcc_attribute_flag = 0;\n   gfc_current_locus = start;\n }\n@@ -1004,10 +1194,11 @@ gfc_char_t\n gfc_next_char_literal (gfc_instring in_string)\n {\n   locus old_loc;\n-  int i, prev_openmp_flag;\n+  int i, prev_openmp_flag, prev_openacc_flag;\n   gfc_char_t c;\n \n   continue_flag = 0;\n+  prev_openacc_flag = prev_openmp_flag = 0;\n \n restart:\n   c = next_char ();\n@@ -1033,6 +1224,11 @@ gfc_next_char_literal (gfc_instring in_string)\n \t\t sizeof (gfc_current_locus)) == 0)\n \t    goto done;\n \n+\t  if (openacc_flag\n+\t      && memcmp (&gfc_current_locus, &openacc_locus,\n+\t         sizeof (gfc_current_locus)) == 0)\n+\t    goto done;\n+\n \t  /* This line can't be continued */\n \t  do\n \t    {\n@@ -1088,7 +1284,11 @@ gfc_next_char_literal (gfc_instring in_string)\n \t  goto done;\n \t}\n \n-      prev_openmp_flag = openmp_flag;\n+      if (flag_openmp)\n+\tprev_openmp_flag = openmp_flag;\n+      if (flag_openacc)\n+\tprev_openacc_flag = openacc_flag;\n+\n       continue_flag = 1;\n       if (c == '!')\n \tskip_comment_line ();\n@@ -1118,13 +1318,23 @@ gfc_next_char_literal (gfc_instring in_string)\n \t  && continue_line < gfc_linebuf_linenum (gfc_current_locus.lb))\n \tcontinue_line = gfc_linebuf_linenum (gfc_current_locus.lb);\n \n-      if (prev_openmp_flag != openmp_flag)\n-\t{\n-\t  gfc_current_locus = old_loc;\n-\t  openmp_flag = prev_openmp_flag;\n-\t  c = '&';\n-\t  goto done;\n-\t}\n+      if (flag_openmp)\n+\tif (prev_openmp_flag != openmp_flag)\n+\t  {\n+\t    gfc_current_locus = old_loc;\n+\t    openmp_flag = prev_openmp_flag;\n+\t    c = '&';\n+\t    goto done;\n+\t  }\n+\n+      if (flag_openacc)\n+\tif (prev_openacc_flag != openacc_flag)\n+\t  {\n+\t    gfc_current_locus = old_loc;\n+\t    openacc_flag = prev_openacc_flag;\n+\t    c = '&';\n+\t    goto done;\n+\t  }\n \n       /* Now that we have a non-comment line, probe ahead for the\n \t first non-whitespace character.  If it is another '&', then\n@@ -1148,6 +1358,17 @@ gfc_next_char_literal (gfc_instring in_string)\n \t  while (gfc_is_whitespace (c))\n \t    c = next_char ();\n \t}\n+      if (openacc_flag)\n+\t{\n+\t  for (i = 0; i < 5; i++, c = next_char ())\n+\t    {\n+\t      gcc_assert (gfc_wide_tolower (c) == (unsigned char) \"!$acc\"[i]);\n+\t      if (i == 4)\n+\t\told_loc = gfc_current_locus;\n+\t    }\n+\t  while (gfc_is_whitespace (c))\n+\t    c = next_char ();\n+\t}\n \n       if (c != '&')\n \t{\n@@ -1161,7 +1382,7 @@ gfc_next_char_literal (gfc_instring in_string)\n \t    }\n \t  /* Both !$omp and !$ -fopenmp continuation lines have & on the\n \t     continuation line only optionally.  */\n-\t  else if (openmp_flag || openmp_cond_flag)\n+\t  else if (openmp_flag || openacc_flag || openmp_cond_flag)\n \t    gfc_current_locus.nextc--;\n \t  else\n \t    {\n@@ -1199,34 +1420,50 @@ gfc_next_char_literal (gfc_instring in_string)\n \t\t\t   \"Line truncated at %L\", &gfc_current_locus);\n \t}\n \n-      prev_openmp_flag = openmp_flag;\n+      if (flag_openmp)\n+\tprev_openmp_flag = openmp_flag;\n+      if (flag_openacc)\n+\tprev_openacc_flag = openacc_flag;\n+\n       continue_flag = 1;\n       old_loc = gfc_current_locus;\n \n       gfc_advance_line ();\n       skip_fixed_comments ();\n \n       /* See if this line is a continuation line.  */\n-      if (openmp_flag != prev_openmp_flag)\n+      if (flag_openmp && openmp_flag != prev_openmp_flag)\n \t{\n \t  openmp_flag = prev_openmp_flag;\n \t  goto not_continuation;\n \t}\n+      if (flag_openacc && openacc_flag != prev_openacc_flag)\n+\t{\n+\t  openacc_flag = prev_openacc_flag;\n+\t  goto not_continuation;\n+\t}\n \n-      if (!openmp_flag)\n+      if (!openmp_flag && !openacc_flag)\n \tfor (i = 0; i < 5; i++)\n \t  {\n \t    c = next_char ();\n \t    if (c != ' ')\n \t      goto not_continuation;\n \t  }\n-      else\n+      else if (openmp_flag)\n \tfor (i = 0; i < 5; i++)\n \t  {\n \t    c = next_char ();\n \t    if (gfc_wide_tolower (c) != (unsigned char) \"*$omp\"[i])\n \t      goto not_continuation;\n \t  }\n+      else if (openacc_flag)\n+\tfor (i = 0; i < 5; i++)\n+\t  {\n+\t    c = next_char ();\n+\t    if (gfc_wide_tolower (c) != (unsigned char) \"*$acc\"[i])\n+\t      goto not_continuation;\n+\t  }\n \n       c = next_char ();\n       if (c == '0' || c == ' ' || c == '\\n')"}, {"sha": "116af15d87efe062c21576802c12caeb9eba7b5f", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -185,6 +185,18 @@ gfc_free_statement (gfc_code *p)\n       gfc_free_forall_iterator (p->ext.forall_iterator);\n       break;\n \n+    case EXEC_OACC_PARALLEL_LOOP:\n+    case EXEC_OACC_PARALLEL:\n+    case EXEC_OACC_KERNELS_LOOP:\n+    case EXEC_OACC_KERNELS:\n+    case EXEC_OACC_DATA:\n+    case EXEC_OACC_HOST_DATA:\n+    case EXEC_OACC_LOOP:\n+    case EXEC_OACC_UPDATE:\n+    case EXEC_OACC_WAIT:\n+    case EXEC_OACC_CACHE:\n+    case EXEC_OACC_ENTER_DATA:\n+    case EXEC_OACC_EXIT_DATA:\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:\n     case EXEC_OMP_DISTRIBUTE:"}, {"sha": "cad9b5be3ba4a923d5b78f3ee54324ab7a1bcd0f", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -5804,6 +5804,13 @@ gfc_generate_function_code (gfc_namespace * ns)\n   if ((gfc_option.rtcheck & GFC_RTCHECK_BOUNDS) && !sym->attr.is_bind_c)\n     add_argument_checking (&body, sym);\n \n+  /* Generate !$ACC DECLARE directive. */\n+  if (ns->oacc_declare_clauses)\n+    {\n+      tree tmp = gfc_trans_oacc_declare (&body, ns);\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n   tmp = gfc_trans_code (ns->code);\n   gfc_add_expr_to_block (&body, tmp);\n "}, {"sha": "fe47a966108acf8faaee77f48e20964a188e384b", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 379, "deletions": 17, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-const.h\"\n #include \"arith.h\"\n #include \"omp-low.h\"\n+#include \"gomp-constants.h\"\n \n int ompws_flags;\n \n@@ -1045,7 +1046,7 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n \treturn;\n       tree orig_decl = decl;\n       c4 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n-      OMP_CLAUSE_MAP_KIND (c4) = OMP_CLAUSE_MAP_POINTER;\n+      OMP_CLAUSE_SET_MAP_KIND (c4, GOMP_MAP_POINTER);\n       OMP_CLAUSE_DECL (c4) = decl;\n       OMP_CLAUSE_SIZE (c4) = size_int (0);\n       decl = build_fold_indirect_ref (decl);\n@@ -1056,7 +1057,7 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n \t      || GFC_DECL_GET_SCALAR_ALLOCATABLE (orig_decl)))\n \t{\n \t  c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n-\t  OMP_CLAUSE_MAP_KIND (c3) = OMP_CLAUSE_MAP_POINTER;\n+\t  OMP_CLAUSE_SET_MAP_KIND (c3, GOMP_MAP_POINTER);\n \t  OMP_CLAUSE_DECL (c3) = unshare_expr (decl);\n \t  OMP_CLAUSE_SIZE (c3) = size_int (0);\n \t  decl = build_fold_indirect_ref (decl);\n@@ -1073,11 +1074,11 @@ gfc_omp_finish_clause (tree c, gimple_seq *pre_p)\n       ptr = build_fold_indirect_ref (ptr);\n       OMP_CLAUSE_DECL (c) = ptr;\n       c2 = build_omp_clause (input_location, OMP_CLAUSE_MAP);\n-      OMP_CLAUSE_MAP_KIND (c2) = OMP_CLAUSE_MAP_TO_PSET;\n+      OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_TO_PSET);\n       OMP_CLAUSE_DECL (c2) = decl;\n       OMP_CLAUSE_SIZE (c2) = TYPE_SIZE_UNIT (type);\n       c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n-      OMP_CLAUSE_MAP_KIND (c3) = OMP_CLAUSE_MAP_POINTER;\n+      OMP_CLAUSE_SET_MAP_KIND (c3, GOMP_MAP_POINTER);\n       OMP_CLAUSE_DECL (c3) = gfc_conv_descriptor_data_get (decl);\n       OMP_CLAUSE_SIZE (c3) = size_int (0);\n       tree size = create_tmp_var (gfc_array_index_type);\n@@ -1718,6 +1719,21 @@ gfc_trans_omp_reduction_list (gfc_omp_namelist *namelist, tree list,\n   return list;\n }\n \n+static inline tree\n+gfc_convert_expr_to_tree (stmtblock_t *block, gfc_expr *expr)\n+{\n+  gfc_se se;\n+  tree result;\n+\n+  gfc_init_se (&se, NULL );\n+  gfc_conv_expr (&se, expr);\n+  gfc_add_block_to_block (block, &se.pre);\n+  result = gfc_evaluate_now (se.expr, block);\n+  gfc_add_block_to_block (block, &se.post);\n+\n+  return result;\n+}\n+\n static tree\n gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t       locus where, bool declare_simd = false)\n@@ -1761,7 +1777,17 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t  goto add_clause;\n \tcase OMP_LIST_UNIFORM:\n \t  clause_code = OMP_CLAUSE_UNIFORM;\n-\t  /* FALLTHROUGH */\n+\t  goto add_clause;\n+\tcase OMP_LIST_USE_DEVICE:\n+\t  clause_code = OMP_CLAUSE_USE_DEVICE;\n+\t  goto add_clause;\n+\tcase OMP_LIST_DEVICE_RESIDENT:\n+\t  clause_code = OMP_CLAUSE_DEVICE_RESIDENT;\n+\t  goto add_clause;\n+\tcase OMP_LIST_CACHE:\n+\t  clause_code = OMP_CLAUSE__CACHE_;\n+\t  goto add_clause;\n+\n \tadd_clause:\n \t  omp_clauses\n \t    = gfc_trans_omp_variable_list (clause_code, n, omp_clauses,\n@@ -1928,7 +1954,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t      tree orig_decl = decl;\n \t\t      node4 = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_MAP_KIND (node4) = OMP_CLAUSE_MAP_POINTER;\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (node4, GOMP_MAP_POINTER);\n \t\t      OMP_CLAUSE_DECL (node4) = decl;\n \t\t      OMP_CLAUSE_SIZE (node4) = size_int (0);\n \t\t      decl = build_fold_indirect_ref (decl);\n@@ -1938,7 +1964,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t{\n \t\t\t  node3 = build_omp_clause (input_location,\n \t\t\t\t\t\t    OMP_CLAUSE_MAP);\n-\t\t\t  OMP_CLAUSE_MAP_KIND (node3) = OMP_CLAUSE_MAP_POINTER;\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_POINTER);\n \t\t\t  OMP_CLAUSE_DECL (node3) = decl;\n \t\t\t  OMP_CLAUSE_SIZE (node3) = size_int (0);\n \t\t\t  decl = build_fold_indirect_ref (decl);\n@@ -1954,12 +1980,12 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t      OMP_CLAUSE_DECL (node) = ptr;\n \t\t      node2 = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_MAP_KIND (node2) = OMP_CLAUSE_MAP_TO_PSET;\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (node2, GOMP_MAP_TO_PSET);\n \t\t      OMP_CLAUSE_DECL (node2) = decl;\n \t\t      OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n \t\t      node3 = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_MAP_KIND (node3) = OMP_CLAUSE_MAP_POINTER;\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_POINTER);\n \t\t      OMP_CLAUSE_DECL (node3)\n \t\t\t= gfc_conv_descriptor_data_get (decl);\n \t\t      OMP_CLAUSE_SIZE (node3) = size_int (0);\n@@ -2045,7 +2071,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t    {\n \t\t      node4 = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_MAP_KIND (node4) = OMP_CLAUSE_MAP_POINTER;\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (node4, GOMP_MAP_POINTER);\n \t\t      OMP_CLAUSE_DECL (node4) = decl;\n \t\t      OMP_CLAUSE_SIZE (node4) = size_int (0);\n \t\t      decl = build_fold_indirect_ref (decl);\n@@ -2057,12 +2083,12 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t      ptr2 = gfc_conv_descriptor_data_get (decl);\n \t\t      node2 = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_MAP_KIND (node2) = OMP_CLAUSE_MAP_TO_PSET;\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (node2, GOMP_MAP_TO_PSET);\n \t\t      OMP_CLAUSE_DECL (node2) = decl;\n \t\t      OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n \t\t      node3 = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_MAP_KIND (node3) = OMP_CLAUSE_MAP_POINTER;\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_POINTER);\n \t\t      OMP_CLAUSE_DECL (node3)\n \t\t\t= gfc_conv_descriptor_data_get (decl);\n \t\t    }\n@@ -2077,7 +2103,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t}\n \t\t      node3 = build_omp_clause (input_location,\n \t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_MAP_KIND (node3) = OMP_CLAUSE_MAP_POINTER;\n+\t\t      OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_POINTER);\n \t\t      OMP_CLAUSE_DECL (node3) = decl;\n \t\t    }\n \t\t  ptr2 = fold_convert (sizetype, ptr2);\n@@ -2087,16 +2113,37 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t      switch (n->u.map_op)\n \t\t{\n \t\tcase OMP_MAP_ALLOC:\n-\t\t  OMP_CLAUSE_MAP_KIND (node) = OMP_CLAUSE_MAP_ALLOC;\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ALLOC);\n \t\t  break;\n \t\tcase OMP_MAP_TO:\n-\t\t  OMP_CLAUSE_MAP_KIND (node) = OMP_CLAUSE_MAP_TO;\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_TO);\n \t\t  break;\n \t\tcase OMP_MAP_FROM:\n-\t\t  OMP_CLAUSE_MAP_KIND (node) = OMP_CLAUSE_MAP_FROM;\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FROM);\n \t\t  break;\n \t\tcase OMP_MAP_TOFROM:\n-\t\t  OMP_CLAUSE_MAP_KIND (node) = OMP_CLAUSE_MAP_TOFROM;\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_TOFROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_ALLOC:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_ALLOC);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_DEALLOC:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_DEALLOC);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_TO:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_TO);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_FROM:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_FROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_TOFROM:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_TOFROM);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_PRESENT:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_PRESENT);\n+\t\t  break;\n+\t\tcase OMP_MAP_FORCE_DEVICEPTR:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_DEVICEPTR);\n \t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n@@ -2463,6 +2510,111 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n+  if (clauses->async)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_ASYNC);\n+      if (clauses->async_expr)\n+\tOMP_CLAUSE_ASYNC_EXPR (c)\n+\t  = gfc_convert_expr_to_tree (block, clauses->async_expr);\n+      else\n+\tOMP_CLAUSE_ASYNC_EXPR (c) = NULL;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+  if (clauses->seq)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_ORDERED);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+  if (clauses->independent)\n+    {\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_INDEPENDENT);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+  if (clauses->wait_list)\n+    {\n+      gfc_expr_list *el;\n+\n+      for (el = clauses->wait_list; el; el = el->next)\n+\t{\n+\t  c = build_omp_clause (where.lb->location, OMP_CLAUSE_WAIT);\n+\t  OMP_CLAUSE_DECL (c) = gfc_convert_expr_to_tree (block, el->expr);\n+\t  OMP_CLAUSE_CHAIN (c) = omp_clauses;\n+\t  omp_clauses = c;\n+\t}\n+    }\n+  if (clauses->num_gangs_expr)\n+    {\n+      tree num_gangs_var\n+\t= gfc_convert_expr_to_tree (block, clauses->num_gangs_expr);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_NUM_GANGS);\n+      OMP_CLAUSE_NUM_GANGS_EXPR (c) = num_gangs_var;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+  if (clauses->num_workers_expr)\n+    {\n+      tree num_workers_var\n+\t= gfc_convert_expr_to_tree (block, clauses->num_workers_expr);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_NUM_WORKERS);\n+      OMP_CLAUSE_NUM_WORKERS_EXPR (c) = num_workers_var;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+  if (clauses->vector_length_expr)\n+    {\n+      tree vector_length_var\n+\t= gfc_convert_expr_to_tree (block, clauses->vector_length_expr);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_VECTOR_LENGTH);\n+      OMP_CLAUSE_VECTOR_LENGTH_EXPR (c) = vector_length_var;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+  if (clauses->vector)\n+    {\n+      if (clauses->vector_expr)\n+\t{\n+\t  tree vector_var\n+\t    = gfc_convert_expr_to_tree (block, clauses->vector_expr);\n+\t  c = build_omp_clause (where.lb->location, OMP_CLAUSE_VECTOR);\n+\t  OMP_CLAUSE_VECTOR_EXPR (c) = vector_var;\n+\t  omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+\t}\n+      else\n+\t{\n+\t  c = build_omp_clause (where.lb->location, OMP_CLAUSE_VECTOR);\n+\t  omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+\t}\n+    }\n+  if (clauses->worker)\n+    {\n+      if (clauses->worker_expr)\n+\t{\n+\t  tree worker_var\n+\t    = gfc_convert_expr_to_tree (block, clauses->worker_expr);\n+\t  c = build_omp_clause (where.lb->location, OMP_CLAUSE_WORKER);\n+\t  OMP_CLAUSE_WORKER_EXPR (c) = worker_var;\n+\t  omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+\t}\n+      else\n+\t{\n+\t  c = build_omp_clause (where.lb->location, OMP_CLAUSE_WORKER);\n+\t  omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+\t}\n+    }\n+  if (clauses->gang)\n+    {\n+      if (clauses->gang_expr)\n+\t{\n+\t  tree gang_var\n+\t    = gfc_convert_expr_to_tree (block, clauses->gang_expr);\n+\t  c = build_omp_clause (where.lb->location, OMP_CLAUSE_GANG);\n+\t  OMP_CLAUSE_GANG_EXPR (c) = gang_var;\n+\t  omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+\t}\n+      else\n+\t{\n+\t  c = build_omp_clause (where.lb->location, OMP_CLAUSE_GANG);\n+\t  omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+\t}\n+    }\n+\n   return nreverse (omp_clauses);\n }\n \n@@ -2490,6 +2642,115 @@ gfc_trans_omp_code (gfc_code *code, bool force_empty)\n   return stmt;\n }\n \n+/* Trans OpenACC directives. */\n+/* parallel, kernels, data and host_data. */\n+static tree\n+gfc_trans_oacc_construct (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree stmt, oacc_clauses;\n+  enum tree_code construct_code;\n+\n+  switch (code->op)\n+    {\n+      case EXEC_OACC_PARALLEL:\n+\tconstruct_code = OACC_PARALLEL;\n+\tbreak;\n+      case EXEC_OACC_KERNELS:\n+\tconstruct_code = OACC_KERNELS;\n+\tbreak;\n+      case EXEC_OACC_DATA:\n+\tconstruct_code = OACC_DATA;\n+\tbreak;\n+      case EXEC_OACC_HOST_DATA:\n+\tconstruct_code = OACC_HOST_DATA;\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+  gfc_start_block (&block);\n+  oacc_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n+\t\t\t\t\tcode->loc);\n+  stmt = gfc_trans_omp_code (code->block->next, true);\n+  stmt = build2_loc (input_location, construct_code, void_type_node, stmt,\n+\t\t     oacc_clauses);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+/* update, enter_data, exit_data, cache. */\n+static tree \n+gfc_trans_oacc_executable_directive (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree stmt, oacc_clauses;\n+  enum tree_code construct_code;\n+\n+  switch (code->op)\n+    {\n+      case EXEC_OACC_UPDATE:\n+\tconstruct_code = OACC_UPDATE;\n+\tbreak;\n+      case EXEC_OACC_ENTER_DATA:\n+\tconstruct_code = OACC_ENTER_DATA;\n+\tbreak;\n+      case EXEC_OACC_EXIT_DATA:\n+\tconstruct_code = OACC_EXIT_DATA;\n+\tbreak;\n+      case EXEC_OACC_CACHE:\n+\tconstruct_code = OACC_CACHE;\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+  gfc_start_block (&block);\n+  oacc_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n+\t\t\t\t\tcode->loc);\n+  stmt = build1_loc (input_location, construct_code, void_type_node, \n+\t\t     oacc_clauses);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_oacc_wait_directive (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree stmt, t;\n+  vec<tree, va_gc> *args;\n+  int nparms = 0;\n+  gfc_expr_list *el;\n+  gfc_omp_clauses *clauses = code->ext.omp_clauses;\n+  location_t loc = input_location;\n+\n+  for (el = clauses->wait_list; el; el = el->next)\n+    nparms++;\n+\n+  vec_alloc (args, nparms + 2);\n+  stmt = builtin_decl_explicit (BUILT_IN_GOACC_WAIT);\n+\n+  gfc_start_block (&block);\n+\n+  if (clauses->async_expr)\n+    t = gfc_convert_expr_to_tree (&block, clauses->async_expr);\n+  else\n+    t = build_int_cst (integer_type_node, -2);\n+\n+  args->quick_push (t);\n+  args->quick_push (build_int_cst (integer_type_node, nparms));\n+\n+  for (el = clauses->wait_list; el; el = el->next)\n+    args->quick_push (gfc_convert_expr_to_tree (&block, el->expr));\n+\n+  stmt = build_call_expr_loc_vec (loc, stmt, args);\n+  gfc_add_expr_to_block (&block, stmt);\n+\n+  vec_free (args);\n+\n+  return gfc_finish_block (&block);\n+}\n \n static tree gfc_trans_omp_sections (gfc_code *, gfc_omp_clauses *);\n static tree gfc_trans_omp_workshare (gfc_code *, gfc_omp_clauses *);\n@@ -3115,6 +3376,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n     case EXEC_OMP_SIMD: stmt = make_node (OMP_SIMD); break;\n     case EXEC_OMP_DO: stmt = make_node (OMP_FOR); break;\n     case EXEC_OMP_DISTRIBUTE: stmt = make_node (OMP_DISTRIBUTE); break;\n+    case EXEC_OACC_LOOP: stmt = make_node (OACC_LOOP); break;\n     default: gcc_unreachable ();\n     }\n \n@@ -3129,6 +3391,68 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n   return gfc_finish_block (&block);\n }\n \n+/* parallel loop and kernels loop. */\n+static tree\n+gfc_trans_oacc_combined_directive (gfc_code *code)\n+{\n+  stmtblock_t block, *pblock = NULL;\n+  gfc_omp_clauses construct_clauses, loop_clauses;\n+  tree stmt, oacc_clauses = NULL_TREE;\n+  enum tree_code construct_code;\n+\n+  switch (code->op)\n+    {\n+      case EXEC_OACC_PARALLEL_LOOP:\n+\tconstruct_code = OACC_PARALLEL;\n+\tbreak;\n+      case EXEC_OACC_KERNELS_LOOP:\n+\tconstruct_code = OACC_KERNELS;\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+\n+  gfc_start_block (&block);\n+\n+  memset (&loop_clauses, 0, sizeof (loop_clauses));\n+  if (code->ext.omp_clauses != NULL)\n+    {\n+      memcpy (&construct_clauses, code->ext.omp_clauses,\n+\t      sizeof (construct_clauses));\n+      loop_clauses.collapse = construct_clauses.collapse;\n+      loop_clauses.gang = construct_clauses.gang;\n+      loop_clauses.vector = construct_clauses.vector;\n+      loop_clauses.worker = construct_clauses.worker;\n+      loop_clauses.seq = construct_clauses.seq;\n+      loop_clauses.independent = construct_clauses.independent;\n+      construct_clauses.collapse = 0;\n+      construct_clauses.gang = false;\n+      construct_clauses.vector = false;\n+      construct_clauses.worker = false;\n+      construct_clauses.seq = false;\n+      construct_clauses.independent = false;\n+      oacc_clauses = gfc_trans_omp_clauses (&block, &construct_clauses,\n+\t\t\t\t\t    code->loc);\n+    }\n+  if (!loop_clauses.seq)\n+    pblock = &block;\n+  else\n+    pushlevel ();\n+  stmt = gfc_trans_omp_do (code, code->op, pblock, &loop_clauses, NULL);\n+  if (TREE_CODE (stmt) != BIND_EXPR)\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n+  else\n+    poplevel (0, 0);\n+  stmt = build2_loc (input_location, construct_code, void_type_node, stmt,\n+\t\t     oacc_clauses);\n+  if (code->op == EXEC_OACC_KERNELS_LOOP)\n+    OACC_KERNELS_COMBINED (stmt) = 1;\n+  else\n+    OACC_PARALLEL_COMBINED (stmt) = 1;\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n static tree\n gfc_trans_omp_flush (void)\n {\n@@ -4018,6 +4342,44 @@ gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n   return stmt;\n }\n \n+tree\n+gfc_trans_oacc_declare (stmtblock_t *block, gfc_namespace *ns)\n+{\n+  tree oacc_clauses;\n+  oacc_clauses = gfc_trans_omp_clauses (block, ns->oacc_declare_clauses,\n+\t\t\t\t\tns->oacc_declare_clauses->loc);\n+  return build1_loc (ns->oacc_declare_clauses->loc.lb->location,\n+\t\t     OACC_DECLARE, void_type_node, oacc_clauses);\n+}\n+\n+tree\n+gfc_trans_oacc_directive (gfc_code *code)\n+{\n+  switch (code->op)\n+    {\n+    case EXEC_OACC_PARALLEL_LOOP:\n+    case EXEC_OACC_KERNELS_LOOP:\n+      return gfc_trans_oacc_combined_directive (code);\n+    case EXEC_OACC_PARALLEL:\n+    case EXEC_OACC_KERNELS:\n+    case EXEC_OACC_DATA:\n+    case EXEC_OACC_HOST_DATA:\n+      return gfc_trans_oacc_construct (code);\n+    case EXEC_OACC_LOOP:\n+      return gfc_trans_omp_do (code, code->op, NULL, code->ext.omp_clauses,\n+\t\t\t       NULL);\n+    case EXEC_OACC_UPDATE:\n+    case EXEC_OACC_CACHE:\n+    case EXEC_OACC_ENTER_DATA:\n+    case EXEC_OACC_EXIT_DATA:\n+      return gfc_trans_oacc_executable_directive (code);\n+    case EXEC_OACC_WAIT:\n+      return gfc_trans_oacc_wait_directive (code);\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n tree\n gfc_trans_omp_directive (gfc_code *code)\n {"}, {"sha": "1a4099cadbaabb08f104a6481e1b9d93b6b3a06d", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1378,6 +1378,14 @@ gfc_trans_block_construct (gfc_code* code)\n   gfc_init_block (&body);\n   exit_label = gfc_build_label_decl (NULL_TREE);\n   code->exit_label = exit_label;\n+\n+  /* Generate !$ACC DECLARE directive. */\n+  if (ns->oacc_declare_clauses)\n+    {\n+      tree tmp = gfc_trans_oacc_declare (&body, ns);\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n   gfc_add_expr_to_block (&body, gfc_trans_code (ns->code));\n   gfc_add_expr_to_block (&body, build1_v (LABEL_EXPR, exit_label));\n "}, {"sha": "2f2a0b3f5b5085670fd00a2bd35100223dbd4731", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -65,6 +65,10 @@ tree gfc_trans_deallocate_array (tree);\n tree gfc_trans_omp_directive (gfc_code *);\n void gfc_trans_omp_declare_simd (gfc_namespace *);\n \n+/* trans-openacc.c */\n+tree gfc_trans_oacc_directive (gfc_code *);\n+tree gfc_trans_oacc_declare (stmtblock_t *block, gfc_namespace *);\n+\n /* trans-io.c */\n tree gfc_trans_open (gfc_code *);\n tree gfc_trans_close (gfc_code *);"}, {"sha": "b749783fcaa53499b0d9b21fa3eda25d335db787", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1900,6 +1900,21 @@ trans_code (gfc_code * code, tree cond)\n \t  res = gfc_trans_omp_directive (code);\n \t  break;\n \n+\tcase EXEC_OACC_CACHE:\n+\tcase EXEC_OACC_WAIT:\n+\tcase EXEC_OACC_UPDATE:\n+\tcase EXEC_OACC_LOOP:\n+\tcase EXEC_OACC_HOST_DATA:\n+\tcase EXEC_OACC_DATA:\n+\tcase EXEC_OACC_KERNELS:\n+\tcase EXEC_OACC_KERNELS_LOOP:\n+\tcase EXEC_OACC_PARALLEL:\n+\tcase EXEC_OACC_PARALLEL_LOOP:\n+\tcase EXEC_OACC_ENTER_DATA:\n+\tcase EXEC_OACC_EXIT_DATA:\n+\t  res = gfc_trans_oacc_directive (code);\n+\t  break;\n+\n \tdefault:\n \t  gfc_internal_error (\"gfc_trans_code(): Bad statement code\");\n \t}"}, {"sha": "fdae28db7aa8437df312539598bc802f93d5f62e", "filename": "gcc/fortran/types.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -82,6 +82,7 @@ DEF_FUNCTION_TYPE_0 (BT_FN_VOID, BT_VOID)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTR, BT_VOID, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTRPTR, BT_VOID, BT_PTR_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VPTR, BT_VOID, BT_VOLATILE_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_INT_INT, BT_INT, BT_INT)\n DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_1 (BT_FN_PTR_PTR, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_1 (BT_FN_VOID_INT, BT_VOID, BT_INT)\n@@ -209,3 +210,14 @@ DEF_FUNCTION_TYPE_8 (BT_FN_VOID_OMPFN_PTR_OMPCPYFN_LONG_LONG_BOOL_UINT_PTR,\n \t\t     BT_BOOL, BT_UINT, BT_PTR)\n \n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\n+\n+DEF_FUNCTION_TYPE_VAR_2 (BT_FN_VOID_INT_INT_VAR, BT_VOID, BT_INT, BT_INT)\n+\n+DEF_FUNCTION_TYPE_VAR_8 (BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR,\n+\t\t\t BT_VOID, BT_INT, BT_PTR, BT_SIZE, BT_PTR, BT_PTR,\n+\t\t\t BT_PTR, BT_INT, BT_INT)\n+\n+DEF_FUNCTION_TYPE_VAR_12 (BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR,\n+\t\t\t  BT_VOID, BT_INT, BT_PTR_FN_VOID_PTR, BT_PTR, BT_SIZE,\n+\t\t\t  BT_PTR, BT_PTR, BT_PTR, BT_INT, BT_INT, BT_INT,\n+\t\t\t  BT_INT, BT_INT)"}, {"sha": "52d0521f764d637861a0b92d61176e882e5f9570", "filename": "gcc/gcc.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -829,7 +829,7 @@ proper position among the other output files.  */\n    \"%X %{o*} %{e*} %{N} %{n} %{r}\\\n     %{s} %{t} %{u*} %{z} %{Z} %{!nostdlib:%{!nostartfiles:%S}} \" VTABLE_VERIFICATION_SPEC \" \\\n     %{static:} %{L*} %(mfwrap) %(link_libgcc) \" SANITIZER_EARLY_SPEC \" %o\\\n-    %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)}\\\n+    %{fopenacc|fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)}\\\n     %{fcilkplus:%:include(libcilkrts.spec)%(link_cilkrts)}\\\n     %{fgnu-tm:%:include(libitm.spec)%(link_itm)}\\\n     %(mflib) \" STACK_SPLIT_SPEC \"\\\n@@ -990,7 +990,8 @@ static const char *const multilib_defaults_raw[] = MULTILIB_DEFAULTS;\n /* Linking to libgomp implies pthreads.  This is particularly important\n    for targets that use different start files and suchlike.  */\n #ifndef GOMP_SELF_SPECS\n-#define GOMP_SELF_SPECS \"%{fopenmp|ftree-parallelize-loops=*: -pthread}\"\n+#define GOMP_SELF_SPECS \"%{fopenacc|fopenmp|ftree-parallelize-loops=*: \" \\\n+  \"-pthread}\"\n #endif\n \n /* Likewise for -fgnu-tm.  */"}, {"sha": "2f9671f163bc1c0e95780e34b31cc26d18ac3414", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1151,18 +1151,21 @@ dump_gimple_omp_for (pretty_printer *buffer, gomp_for *gs, int spc, int flags)\n \tcase GF_OMP_FOR_KIND_FOR:\n \t  kind = \"\";\n \t  break;\n-\tcase GF_OMP_FOR_KIND_SIMD:\n-\t  kind = \" simd\";\n-\t  break;\n-\tcase GF_OMP_FOR_KIND_CILKSIMD:\n-\t  kind = \" cilksimd\";\n-\t  break;\n \tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n \t  kind = \" distribute\";\n \t  break;\n \tcase GF_OMP_FOR_KIND_CILKFOR:\n \t  kind = \" _Cilk_for\";\n \t  break;\n+\tcase GF_OMP_FOR_KIND_OACC_LOOP:\n+\t  kind = \" oacc_loop\";\n+\t  break;\n+\tcase GF_OMP_FOR_KIND_SIMD:\n+\t  kind = \" simd\";\n+\t  break;\n+\tcase GF_OMP_FOR_KIND_CILKSIMD:\n+\t  kind = \" cilksimd\";\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -1188,17 +1191,20 @@ dump_gimple_omp_for (pretty_printer *buffer, gomp_for *gs, int spc, int flags)\n \tcase GF_OMP_FOR_KIND_FOR:\n \t  pp_string (buffer, \"#pragma omp for\");\n \t  break;\n+\tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n+\t  pp_string (buffer, \"#pragma omp distribute\");\n+\t  break;\n+\tcase GF_OMP_FOR_KIND_CILKFOR:\n+\t  break;\n+\tcase GF_OMP_FOR_KIND_OACC_LOOP:\n+\t  pp_string (buffer, \"#pragma acc loop\");\n+\t  break;\n \tcase GF_OMP_FOR_KIND_SIMD:\n \t  pp_string (buffer, \"#pragma omp simd\");\n \t  break;\n \tcase GF_OMP_FOR_KIND_CILKSIMD:\n \t  pp_string (buffer, \"#pragma simd\");\n \t  break;\n-\tcase GF_OMP_FOR_KIND_DISTRIBUTE:\n-\t  pp_string (buffer, \"#pragma omp distribute\");\n-\t  break;\n-\tcase GF_OMP_FOR_KIND_CILKFOR:\n-\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -1344,6 +1350,21 @@ dump_gimple_omp_target (pretty_printer *buffer, gomp_target *gs,\n     case GF_OMP_TARGET_KIND_UPDATE:\n       kind = \" update\";\n       break;\n+    case GF_OMP_TARGET_KIND_OACC_KERNELS:\n+      kind = \" oacc_kernels\";\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL:\n+      kind = \" oacc_parallel\";\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_DATA:\n+      kind = \" oacc_data\";\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_UPDATE:\n+      kind = \" oacc_update\";\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:\n+      kind = \" oacc_enter_exit_data\";\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -1352,7 +1373,9 @@ dump_gimple_omp_target (pretty_printer *buffer, gomp_target *gs,\n       dump_gimple_fmt (buffer, spc, flags, \"%G%s <%+BODY <%S>%nCLAUSES <\", gs,\n \t\t       kind, gimple_omp_body (gs));\n       dump_omp_clauses (buffer, gimple_omp_target_clauses (gs), spc, flags);\n-      dump_gimple_fmt (buffer, spc, flags, \" >\");\n+      dump_gimple_fmt (buffer, spc, flags, \" >, %T, %T%n>\",\n+\t\t       gimple_omp_target_child_fn (gs),\n+\t\t       gimple_omp_target_data_arg (gs));\n     }\n   else\n     {\n@@ -1364,16 +1387,28 @@ dump_gimple_omp_target (pretty_printer *buffer, gomp_target *gs,\n \t  pp_string (buffer, \" [child fn: \");\n \t  dump_generic_node (buffer, gimple_omp_target_child_fn (gs),\n \t\t\t     spc, flags, false);\n-\t  pp_right_bracket (buffer);\n+\t  pp_string (buffer, \" (\");\n+\t  if (gimple_omp_target_data_arg (gs))\n+\t    dump_generic_node (buffer, gimple_omp_target_data_arg (gs),\n+\t\t\t       spc, flags, false);\n+\t  else\n+\t    pp_string (buffer, \"???\");\n+\t  pp_string (buffer, \")]\");\n \t}\n-      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+      gimple_seq body = gimple_omp_body (gs);\n+      if (body && gimple_code (gimple_seq_first_stmt (body)) != GIMPLE_BIND)\n \t{\n \t  newline_and_indent (buffer, spc + 2);\n-\t  pp_character (buffer, '{');\n+\t  pp_left_brace (buffer);\n \t  pp_newline (buffer);\n-\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  dump_gimple_seq (buffer, body, spc + 4, flags);\n \t  newline_and_indent (buffer, spc + 2);\n-\t  pp_character (buffer, '}');\n+\t  pp_right_brace (buffer);\n+\t}\n+      else if (body)\n+\t{\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, body, spc + 2, flags);\n \t}\n     }\n }"}, {"sha": "caa1cbd2d0923fa352df612acff09b1f8d9deac9", "filename": "gcc/gimple.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -872,8 +872,7 @@ gimple_build_omp_critical (gimple_seq body, tree name)\n \n    BODY is sequence of statements inside the for loop.\n    KIND is the `for' variant.\n-   CLAUSES, are any of the OMP loop construct's clauses: private, firstprivate,\n-   lastprivate, reductions, ordered, schedule, and nowait.\n+   CLAUSES, are any of the construct's clauses.\n    COLLAPSE is the collapse count.\n    PRE_BODY is the sequence of statements that are loop invariant.  */\n \n@@ -1088,7 +1087,8 @@ gimple_build_omp_single (gimple_seq body, tree clauses)\n /* Build a GIMPLE_OMP_TARGET statement.\n \n    BODY is the sequence of statements that will be executed.\n-   CLAUSES are any of the OMP target construct's clauses.  */\n+   KIND is the kind of the region.\n+   CLAUSES are any of the construct's clauses.  */\n \n gomp_target *\n gimple_build_omp_target (gimple_seq body, int kind, tree clauses)"}, {"sha": "96602df91fcc9a47ff213e82f85ce694e0505e6c", "filename": "gcc/gimple.def", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -243,6 +243,9 @@ DEFGSCODE(GIMPLE_OMP_CRITICAL, \"gimple_omp_critical\", GSS_OMP_CRITICAL)\n    for (INDEX = INITIAL; INDEX COND FINAL; INDEX {+=,-=} INCR)\n    BODY\n \n+   Likewise for:\n+   #pragma acc loop [clause1 ... clauseN]\n+\n    BODY is the loop body.\n \n    CLAUSES is the list of clauses.\n@@ -269,7 +272,7 @@ DEFGSCODE(GIMPLE_OMP_CRITICAL, \"gimple_omp_critical\", GSS_OMP_CRITICAL)\n    INITIAL, FINAL and INCR are required to be loop invariant integer\n    expressions that are evaluated without any synchronization.\n    The evaluation order, frequency of evaluation and side-effects are\n-   unspecified by the standard.  */\n+   unspecified by the standards.  */\n DEFGSCODE(GIMPLE_OMP_FOR, \"gimple_omp_for\", GSS_OMP_FOR)\n \n /* GIMPLE_OMP_MASTER <BODY> represents #pragma omp master.\n@@ -354,11 +357,12 @@ DEFGSCODE(GIMPLE_OMP_SECTIONS_SWITCH, \"gimple_omp_sections_switch\", GSS_BASE)\n DEFGSCODE(GIMPLE_OMP_SINGLE, \"gimple_omp_single\", GSS_OMP_SINGLE_LAYOUT)\n \n /* GIMPLE_OMP_TARGET <BODY, CLAUSES, CHILD_FN> represents\n+   #pragma acc {kernels,parallel,data,enter data,exit data,update}\n    #pragma omp target {,data,update}\n-   BODY is the sequence of statements inside the target construct\n-   (NULL for target update).\n+   BODY is the sequence of statements inside the construct\n+   (NULL for some variants).\n    CLAUSES is an OMP_CLAUSE chain holding the associated clauses.\n-   CHILD_FN is set when outlining the body of the target region.\n+   CHILD_FN is set when outlining the body of the offloaded region.\n    All the statements in BODY are moved into this newly created\n    function when converting OMP constructs into low-GIMPLE.\n    DATA_ARG is a vec of 3 local variables in the parent function"}, {"sha": "769bad01181253ec794da89100c428db45c1a19a", "filename": "gcc/gimple.h", "status": "modified", "additions": 122, "deletions": 55, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -89,20 +89,26 @@ enum gf_mask {\n     GF_CALL_CTRL_ALTERING       = 1 << 7,\n     GF_CALL_WITH_BOUNDS \t= 1 << 8,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n-    GF_OMP_FOR_KIND_MASK\t= 7 << 0,\n+    GF_OMP_FOR_KIND_MASK\t= (1 << 3) - 1,\n     GF_OMP_FOR_KIND_FOR\t\t= 0,\n     GF_OMP_FOR_KIND_DISTRIBUTE\t= 1,\n     GF_OMP_FOR_KIND_CILKFOR     = 2,\n+    GF_OMP_FOR_KIND_OACC_LOOP\t= 3,\n     /* Flag for SIMD variants of OMP_FOR kinds.  */\n     GF_OMP_FOR_SIMD\t\t= 1 << 2,\n     GF_OMP_FOR_KIND_SIMD\t= GF_OMP_FOR_SIMD | 0,\n     GF_OMP_FOR_KIND_CILKSIMD\t= GF_OMP_FOR_SIMD | 1,\n     GF_OMP_FOR_COMBINED\t\t= 1 << 3,\n     GF_OMP_FOR_COMBINED_INTO\t= 1 << 4,\n-    GF_OMP_TARGET_KIND_MASK\t= (1 << 2) - 1,\n+    GF_OMP_TARGET_KIND_MASK\t= (1 << 3) - 1,\n     GF_OMP_TARGET_KIND_REGION\t= 0,\n     GF_OMP_TARGET_KIND_DATA\t= 1,\n     GF_OMP_TARGET_KIND_UPDATE\t= 2,\n+    GF_OMP_TARGET_KIND_OACC_PARALLEL = 3,\n+    GF_OMP_TARGET_KIND_OACC_KERNELS = 4,\n+    GF_OMP_TARGET_KIND_OACC_DATA = 5,\n+    GF_OMP_TARGET_KIND_OACC_UPDATE = 6,\n+    GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA = 7,\n \n     /* True on an GIMPLE_OMP_RETURN statement if the return does not require\n        a thread synchronization via some sort of barrier.  The exact barrier\n@@ -291,7 +297,7 @@ struct GTY((tag(\"GSS_CALL\")))\n };\n \n \n-/* OpenMP statements (#pragma omp).  */\n+/* OMP statements.  */\n \n struct GTY((tag(\"GSS_OMP\")))\n   gimple_statement_omp : public gimple_statement_base\n@@ -552,7 +558,8 @@ struct GTY((tag(\"GSS_OMP_FOR\")))\n };\n \n \n-/* GIMPLE_OMP_PARALLEL, GIMPLE_OMP_TARGET */\n+/* GIMPLE_OMP_PARALLEL, GIMPLE_OMP_TARGET, GIMPLE_OMP_TASK */\n+\n struct GTY((tag(\"GSS_OMP_PARALLEL_LAYOUT\")))\n   gimple_statement_omp_parallel_layout : public gimple_statement_omp\n {\n@@ -580,7 +587,6 @@ struct GTY((tag(\"GSS_OMP_PARALLEL_LAYOUT\")))\n \t || stmt->code == GIMPLE_OMP_TASK.  */\n };\n \n-\n /* GIMPLE_OMP_PARALLEL */\n struct GTY((tag(\"GSS_OMP_PARALLEL_LAYOUT\")))\n   gomp_parallel : public gimple_statement_omp_taskreg\n@@ -589,6 +595,7 @@ struct GTY((tag(\"GSS_OMP_PARALLEL_LAYOUT\")))\n          stmt->code == GIMPLE_OMP_PARALLEL.  */\n };\n \n+/* GIMPLE_OMP_TARGET */\n struct GTY((tag(\"GSS_OMP_PARALLEL_LAYOUT\")))\n   gomp_target : public gimple_statement_omp_parallel_layout\n {\n@@ -4409,7 +4416,7 @@ gimple_omp_critical_set_name (gomp_critical *crit_stmt, tree name)\n }\n \n \n-/* Return the kind of OMP for statemement.  */\n+/* Return the kind of the OMP_FOR statemement G.  */\n \n static inline int\n gimple_omp_for_kind (const_gimple g)\n@@ -4419,7 +4426,7 @@ gimple_omp_for_kind (const_gimple g)\n }\n \n \n-/* Set the OMP for kind.  */\n+/* Set the kind of the OMP_FOR statement G.  */\n \n static inline void\n gimple_omp_for_set_kind (gomp_for *g, int kind)\n@@ -4429,7 +4436,7 @@ gimple_omp_for_set_kind (gomp_for *g, int kind)\n }\n \n \n-/* Return true if OMP for statement G has the\n+/* Return true if OMP_FOR statement G has the\n    GF_OMP_FOR_COMBINED flag set.  */\n \n static inline bool\n@@ -4440,8 +4447,8 @@ gimple_omp_for_combined_p (const_gimple g)\n }\n \n \n-/* Set the GF_OMP_FOR_COMBINED field in G depending on the boolean\n-   value of COMBINED_P.  */\n+/* Set the GF_OMP_FOR_COMBINED field in the OMP_FOR statement G depending on\n+   the boolean value of COMBINED_P.  */\n \n static inline void\n gimple_omp_for_set_combined_p (gomp_for *g, bool combined_p)\n@@ -4453,7 +4460,7 @@ gimple_omp_for_set_combined_p (gomp_for *g, bool combined_p)\n }\n \n \n-/* Return true if OMP for statement G has the\n+/* Return true if the OMP_FOR statement G has the\n    GF_OMP_FOR_COMBINED_INTO flag set.  */\n \n static inline bool\n@@ -4464,8 +4471,8 @@ gimple_omp_for_combined_into_p (const_gimple g)\n }\n \n \n-/* Set the GF_OMP_FOR_COMBINED_INTO field in G depending on the boolean\n-   value of COMBINED_P.  */\n+/* Set the GF_OMP_FOR_COMBINED_INTO field in the OMP_FOR statement G depending\n+   on the boolean value of COMBINED_P.  */\n \n static inline void\n gimple_omp_for_set_combined_into_p (gomp_for *g, bool combined_p)\n@@ -4477,7 +4484,7 @@ gimple_omp_for_set_combined_into_p (gomp_for *g, bool combined_p)\n }\n \n \n-/* Return the clauses associated with OMP_FOR GS.  */\n+/* Return the clauses associated with the OMP_FOR statement GS.  */\n \n static inline tree\n gimple_omp_for_clauses (const_gimple gs)\n@@ -4487,7 +4494,8 @@ gimple_omp_for_clauses (const_gimple gs)\n }\n \n \n-/* Return a pointer to the OMP_FOR GS.  */\n+/* Return a pointer to the clauses associated with the OMP_FOR statement\n+   GS.  */\n \n static inline tree *\n gimple_omp_for_clauses_ptr (gimple gs)\n@@ -4497,7 +4505,8 @@ gimple_omp_for_clauses_ptr (gimple gs)\n }\n \n \n-/* Set CLAUSES to be the list of clauses associated with OMP_FOR GS.  */\n+/* Set CLAUSES to be the list of clauses associated with the OMP_FOR statement\n+   GS.  */\n \n static inline void\n gimple_omp_for_set_clauses (gimple gs, tree clauses)\n@@ -4507,7 +4516,7 @@ gimple_omp_for_set_clauses (gimple gs, tree clauses)\n }\n \n \n-/* Get the collapse count of OMP_FOR GS.  */\n+/* Get the collapse count of the OMP_FOR statement GS.  */\n \n static inline size_t\n gimple_omp_for_collapse (gimple gs)\n@@ -4517,7 +4526,30 @@ gimple_omp_for_collapse (gimple gs)\n }\n \n \n-/* Return the index variable for OMP_FOR GS.  */\n+/* Return the condition code associated with the OMP_FOR statement GS.  */\n+\n+static inline enum tree_code\n+gimple_omp_for_cond (const_gimple gs, size_t i)\n+{\n+  const gomp_for *omp_for_stmt = as_a <const gomp_for *> (gs);\n+  gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n+  return omp_for_stmt->iter[i].cond;\n+}\n+\n+\n+/* Set COND to be the condition code for the OMP_FOR statement GS.  */\n+\n+static inline void\n+gimple_omp_for_set_cond (gimple gs, size_t i, enum tree_code cond)\n+{\n+  gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n+  gcc_gimple_checking_assert (TREE_CODE_CLASS (cond) == tcc_comparison\n+\t\t\t      && i < omp_for_stmt->collapse);\n+  omp_for_stmt->iter[i].cond = cond;\n+}\n+\n+\n+/* Return the index variable for the OMP_FOR statement GS.  */\n \n static inline tree\n gimple_omp_for_index (const_gimple gs, size_t i)\n@@ -4528,7 +4560,7 @@ gimple_omp_for_index (const_gimple gs, size_t i)\n }\n \n \n-/* Return a pointer to the index variable for OMP_FOR GS.  */\n+/* Return a pointer to the index variable for the OMP_FOR statement GS.  */\n \n static inline tree *\n gimple_omp_for_index_ptr (gimple gs, size_t i)\n@@ -4539,7 +4571,7 @@ gimple_omp_for_index_ptr (gimple gs, size_t i)\n }\n \n \n-/* Set INDEX to be the index variable for OMP_FOR GS.  */\n+/* Set INDEX to be the index variable for the OMP_FOR statement GS.  */\n \n static inline void\n gimple_omp_for_set_index (gimple gs, size_t i, tree index)\n@@ -4550,7 +4582,7 @@ gimple_omp_for_set_index (gimple gs, size_t i, tree index)\n }\n \n \n-/* Return the initial value for OMP_FOR GS.  */\n+/* Return the initial value for the OMP_FOR statement GS.  */\n \n static inline tree\n gimple_omp_for_initial (const_gimple gs, size_t i)\n@@ -4561,7 +4593,7 @@ gimple_omp_for_initial (const_gimple gs, size_t i)\n }\n \n \n-/* Return a pointer to the initial value for OMP_FOR GS.  */\n+/* Return a pointer to the initial value for the OMP_FOR statement GS.  */\n \n static inline tree *\n gimple_omp_for_initial_ptr (gimple gs, size_t i)\n@@ -4572,7 +4604,7 @@ gimple_omp_for_initial_ptr (gimple gs, size_t i)\n }\n \n \n-/* Set INITIAL to be the initial value for OMP_FOR GS.  */\n+/* Set INITIAL to be the initial value for the OMP_FOR statement GS.  */\n \n static inline void\n gimple_omp_for_set_initial (gimple gs, size_t i, tree initial)\n@@ -4583,7 +4615,7 @@ gimple_omp_for_set_initial (gimple gs, size_t i, tree initial)\n }\n \n \n-/* Return the final value for OMP_FOR GS.  */\n+/* Return the final value for the OMP_FOR statement GS.  */\n \n static inline tree\n gimple_omp_for_final (const_gimple gs, size_t i)\n@@ -4594,7 +4626,7 @@ gimple_omp_for_final (const_gimple gs, size_t i)\n }\n \n \n-/* Return a pointer to the final value for OMP_FOR GS.  */\n+/* Return a pointer to the final value for the OMP_FOR statement GS.  */\n \n static inline tree *\n gimple_omp_for_final_ptr (gimple gs, size_t i)\n@@ -4605,7 +4637,7 @@ gimple_omp_for_final_ptr (gimple gs, size_t i)\n }\n \n \n-/* Set FINAL to be the final value for OMP_FOR GS.  */\n+/* Set FINAL to be the final value for the OMP_FOR statement GS.  */\n \n static inline void\n gimple_omp_for_set_final (gimple gs, size_t i, tree final)\n@@ -4616,7 +4648,7 @@ gimple_omp_for_set_final (gimple gs, size_t i, tree final)\n }\n \n \n-/* Return the increment value for OMP_FOR GS.  */\n+/* Return the increment value for the OMP_FOR statement GS.  */\n \n static inline tree\n gimple_omp_for_incr (const_gimple gs, size_t i)\n@@ -4627,7 +4659,7 @@ gimple_omp_for_incr (const_gimple gs, size_t i)\n }\n \n \n-/* Return a pointer to the increment value for OMP_FOR GS.  */\n+/* Return a pointer to the increment value for the OMP_FOR statement GS.  */\n \n static inline tree *\n gimple_omp_for_incr_ptr (gimple gs, size_t i)\n@@ -4638,7 +4670,7 @@ gimple_omp_for_incr_ptr (gimple gs, size_t i)\n }\n \n \n-/* Set INCR to be the increment value for OMP_FOR GS.  */\n+/* Set INCR to be the increment value for the OMP_FOR statement GS.  */\n \n static inline void\n gimple_omp_for_set_incr (gimple gs, size_t i, tree incr)\n@@ -5109,7 +5141,7 @@ gimple_omp_target_set_clauses (gomp_target *omp_target_stmt,\n }\n \n \n-/* Return the kind of OMP target statemement.  */\n+/* Return the kind of the OMP_TARGET G.  */\n \n static inline int\n gimple_omp_target_kind (const_gimple g)\n@@ -5119,7 +5151,7 @@ gimple_omp_target_kind (const_gimple g)\n }\n \n \n-/* Set the OMP target kind.  */\n+/* Set the kind of the OMP_TARGET G.  */\n \n static inline void\n gimple_omp_target_set_kind (gomp_target *g, int kind)\n@@ -5279,29 +5311,6 @@ gimple_omp_sections_set_control (gimple gs, tree control)\n }\n \n \n-/* Set COND to be the condition code for OMP_FOR GS.  */\n-\n-static inline void\n-gimple_omp_for_set_cond (gimple gs, size_t i, enum tree_code cond)\n-{\n-  gomp_for *omp_for_stmt = as_a <gomp_for *> (gs);\n-  gcc_gimple_checking_assert (TREE_CODE_CLASS (cond) == tcc_comparison\n-\t\t\t      && i < omp_for_stmt->collapse);\n-  omp_for_stmt->iter[i].cond = cond;\n-}\n-\n-\n-/* Return the condition code associated with OMP_FOR GS.  */\n-\n-static inline enum tree_code\n-gimple_omp_for_cond (const_gimple gs, size_t i)\n-{\n-  const gomp_for *omp_for_stmt = as_a <const gomp_for *> (gs);\n-  gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n-  return omp_for_stmt->iter[i].cond;\n-}\n-\n-\n /* Set the value being stored in an atomic store.  */\n \n static inline void\n@@ -5547,7 +5556,7 @@ gimple_return_set_retbnd (gimple gs, tree retval)\n }\n \n \n-/* Returns true when the gimple statement STMT is any of the OpenMP types.  */\n+/* Returns true when the gimple statement STMT is any of the OMP types.  */\n \n #define CASE_GIMPLE_OMP\t\t\t\t\\\n     case GIMPLE_OMP_PARALLEL:\t\t\t\\\n@@ -5580,6 +5589,64 @@ is_gimple_omp (const_gimple stmt)\n     }\n }\n \n+/* Return true if the OMP gimple statement STMT is any of the OpenACC types\n+   specifically.  */\n+\n+static inline bool\n+is_gimple_omp_oacc (const_gimple stmt)\n+{\n+  gcc_assert (is_gimple_omp (stmt));\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_OMP_FOR:\n+      switch (gimple_omp_for_kind (stmt))\n+\t{\n+\tcase GF_OMP_FOR_KIND_OACC_LOOP:\n+\t  return true;\n+\tdefault:\n+\t  return false;\n+\t}\n+    case GIMPLE_OMP_TARGET:\n+      switch (gimple_omp_target_kind (stmt))\n+\t{\n+\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL:\n+\tcase GF_OMP_TARGET_KIND_OACC_KERNELS:\n+\tcase GF_OMP_TARGET_KIND_OACC_DATA:\n+\tcase GF_OMP_TARGET_KIND_OACC_UPDATE:\n+\tcase GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:\n+\t  return true;\n+\tdefault:\n+\t  return false;\n+\t}\n+    default:\n+      return false;\n+    }\n+}\n+\n+\n+/* Return true if the OMP gimple statement STMT is offloaded.  */\n+\n+static inline bool\n+is_gimple_omp_offloaded (const_gimple stmt)\n+{\n+  gcc_assert (is_gimple_omp (stmt));\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_OMP_TARGET:\n+      switch (gimple_omp_target_kind (stmt))\n+\t{\n+\tcase GF_OMP_TARGET_KIND_REGION:\n+\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL:\n+\tcase GF_OMP_TARGET_KIND_OACC_KERNELS:\n+\t  return true;\n+\tdefault:\n+\t  return false;\n+\t}\n+    default:\n+      return false;\n+    }\n+}\n+\n \n /* Returns TRUE if statement G is a GIMPLE_NOP.  */\n "}, {"sha": "3a34f9224dc319ef9380f84b0dfbb5a5fc575e8a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 218, "deletions": 36, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -86,6 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-low.h\"\n #include \"gimple-low.h\"\n #include \"cilk.h\"\n+#include \"gomp-constants.h\"\n \n #include \"langhooks-def.h\"\t/* FIXME: for lhd_set_decl_assembler_name */\n #include \"tree-pass.h\"\t\t/* FIXME: only for PROP_gimple_any */\n@@ -106,7 +107,10 @@ enum gimplify_omp_var_data\n   GOVD_PRIVATE_OUTER_REF = 1024,\n   GOVD_LINEAR = 2048,\n   GOVD_ALIGNED = 4096,\n+\n+  /* Flag for GOVD_MAP: don't copy back.  */\n   GOVD_MAP_TO_ONLY = 8192,\n+\n   GOVD_DATA_SHARE_CLASS = (GOVD_SHARED | GOVD_PRIVATE | GOVD_FIRSTPRIVATE\n \t\t\t   | GOVD_LASTPRIVATE | GOVD_REDUCTION | GOVD_LINEAR\n \t\t\t   | GOVD_LOCAL)\n@@ -122,7 +126,9 @@ enum omp_region_type\n   ORT_TASK = 4,\n   ORT_UNTIED_TASK = 5,\n   ORT_TEAMS = 8,\n+  /* Data region.  */\n   ORT_TARGET_DATA = 16,\n+  /* Data region with offloading.  */\n   ORT_TARGET = 32\n };\n \n@@ -1560,9 +1566,10 @@ gimplify_case_label_expr (tree *expr_p, gimple_seq *pre_p)\n   struct gimplify_ctx *ctxp;\n   glabel *label_stmt;\n \n-  /* Invalid OpenMP programs can play Duff's Device type games with\n+  /* Invalid programs can play Duff's Device type games with, for example,\n      #pragma omp parallel.  At least in the C front end, we don't\n-     detect such invalid branches until after gimplification.  */\n+     detect such invalid branches until after gimplification, in the\n+     diagnose_omp_blocks pass.  */\n   for (ctxp = gimplify_ctxp; ; ctxp = ctxp->prev_context)\n     if (ctxp->case_labels.exists ())\n       break;\n@@ -1791,7 +1798,7 @@ gimplify_var_or_parm_decl (tree *expr_p)\n       return GS_ERROR;\n     }\n \n-  /* When within an OpenMP context, notice uses of variables.  */\n+  /* When within an OMP context, notice uses of variables.  */\n   if (gimplify_omp_ctxp && omp_notice_variable (gimplify_omp_ctxp, decl, true))\n     return GS_ALL_DONE;\n \n@@ -2260,7 +2267,7 @@ gimplify_arg (tree *arg_p, gimple_seq *pre_p, location_t call_location)\n   return gimplify_expr (arg_p, pre_p, NULL, test, fb);\n }\n \n-/* Don't fold STMT inside ORT_TARGET, because it can break code by adding decl\n+/* Don't fold inside offloading regions: it can break code by adding decl\n    references that weren't in the source.  We'll do it during omplower pass\n    instead.  */\n \n@@ -4451,11 +4458,21 @@ is_gimple_stmt (tree t)\n     case CATCH_EXPR:\n     case ASM_EXPR:\n     case STATEMENT_LIST:\n+    case OACC_PARALLEL:\n+    case OACC_KERNELS:\n+    case OACC_DATA:\n+    case OACC_HOST_DATA:\n+    case OACC_DECLARE:\n+    case OACC_UPDATE:\n+    case OACC_ENTER_DATA:\n+    case OACC_EXIT_DATA:\n+    case OACC_CACHE:\n     case OMP_PARALLEL:\n     case OMP_FOR:\n     case OMP_SIMD:\n     case CILK_SIMD:\n     case OMP_DISTRIBUTE:\n+    case OACC_LOOP:\n     case OMP_SECTIONS:\n     case OMP_SECTION:\n     case OMP_SINGLE:\n@@ -5582,7 +5599,7 @@ omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *ctx, tree type)\n   lang_hooks.types.omp_firstprivatize_type_sizes (ctx, type);\n }\n \n-/* Add an entry for DECL in the OpenMP context CTX with FLAGS.  */\n+/* Add an entry for DECL in the OMP context CTX with FLAGS.  */\n \n static void\n omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n@@ -5627,9 +5644,12 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n \t copy into or out of the context.  */\n       if (!(flags & GOVD_LOCAL))\n \t{\n-\t  nflags = flags & GOVD_MAP\n-\t\t   ? GOVD_MAP | GOVD_MAP_TO_ONLY | GOVD_EXPLICIT\n-\t\t   : flags & GOVD_PRIVATE ? GOVD_PRIVATE : GOVD_FIRSTPRIVATE;\n+\t  if (flags & GOVD_MAP)\n+\t    nflags = GOVD_MAP | GOVD_MAP_TO_ONLY | GOVD_EXPLICIT;\n+\t  else if (flags & GOVD_PRIVATE)\n+\t    nflags = GOVD_PRIVATE;\n+\t  else\n+\t    nflags = GOVD_FIRSTPRIVATE;\n \t  nflags |= flags & GOVD_SEEN;\n \t  t = DECL_VALUE_EXPR (decl);\n \t  gcc_assert (TREE_CODE (t) == INDIRECT_REF);\n@@ -5683,7 +5703,7 @@ omp_add_variable (struct gimplify_omp_ctx *ctx, tree decl, unsigned int flags)\n     splay_tree_insert (ctx->variables, (splay_tree_key)decl, flags);\n }\n \n-/* Notice a threadprivate variable DECL used in OpenMP context CTX.\n+/* Notice a threadprivate variable DECL used in OMP context CTX.\n    This just prints out diagnostics about threadprivate variable uses\n    in untied tasks.  If DECL2 is non-NULL, prevent this warning\n    on that variable.  */\n@@ -5725,7 +5745,7 @@ omp_notice_threadprivate_variable (struct gimplify_omp_ctx *ctx, tree decl,\n   return false;\n }\n \n-/* Record the fact that DECL was used within the OpenMP context CTX.\n+/* Record the fact that DECL was used within the OMP context CTX.\n    IN_CODE is true when real code uses DECL, and false when we should\n    merely emit default(none) errors.  Return true if DECL is going to\n    be remapped and thus DECL shouldn't be gimplified into its\n@@ -6006,7 +6026,7 @@ omp_check_private (struct gimplify_omp_ctx *ctx, tree decl, bool copyprivate)\n   return false;\n }\n \n-/* Scan the OpenMP clauses in *LIST_P, installing mappings into a new\n+/* Scan the OMP clauses in *LIST_P, installing mappings into a new\n    and previous omp contexts.  */\n \n static void\n@@ -6117,6 +6137,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_FROM:\n+\tcase OMP_CLAUSE__CACHE_:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (error_operand_p (decl))\n \t    {\n@@ -6282,15 +6303,35 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_DIST_SCHEDULE:\n \tcase OMP_CLAUSE_DEVICE:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n+\tcase OMP_CLAUSE_ASYNC:\n+\tcase OMP_CLAUSE_WAIT:\n+\tcase OMP_CLAUSE_NUM_GANGS:\n+\tcase OMP_CLAUSE_NUM_WORKERS:\n+\tcase OMP_CLAUSE_VECTOR_LENGTH:\n+\tcase OMP_CLAUSE_GANG:\n+\tcase OMP_CLAUSE_WORKER:\n+\tcase OMP_CLAUSE_VECTOR:\n \t  if (gimplify_expr (&OMP_CLAUSE_OPERAND (c, 0), pre_p, NULL,\n \t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n \t    remove = true;\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_GANG\n+\t      && gimplify_expr (&OMP_CLAUSE_OPERAND (c, 1), pre_p, NULL,\n+\t\t\t\tis_gimple_val, fb_rvalue) == GS_ERROR)\n+\t    remove = true;\n+\t  break;\n+\n+\tcase OMP_CLAUSE_DEVICE_RESIDENT:\n+\tcase OMP_CLAUSE_USE_DEVICE:\n+\tcase OMP_CLAUSE_INDEPENDENT:\n+\t  remove = true;\n \t  break;\n \n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_UNTIED:\n \tcase OMP_CLAUSE_COLLAPSE:\n+\tcase OMP_CLAUSE_AUTO:\n+\tcase OMP_CLAUSE_SEQ:\n \tcase OMP_CLAUSE_MERGEABLE:\n \tcase OMP_CLAUSE_PROC_BIND:\n \tcase OMP_CLAUSE_SAFELEN:\n@@ -6411,9 +6452,10 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n     OMP_CLAUSE_PRIVATE_OUTER_REF (clause) = 1;\n   else if (code == OMP_CLAUSE_MAP)\n     {\n-      OMP_CLAUSE_MAP_KIND (clause) = flags & GOVD_MAP_TO_ONLY\n-\t\t\t\t     ? OMP_CLAUSE_MAP_TO\n-\t\t\t\t     : OMP_CLAUSE_MAP_TOFROM;\n+      OMP_CLAUSE_SET_MAP_KIND (clause,\n+\t\t\t       flags & GOVD_MAP_TO_ONLY\n+\t\t\t       ? GOMP_MAP_TO\n+\t\t\t       : GOMP_MAP_TOFROM);\n       if (DECL_SIZE (decl)\n \t  && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n \t{\n@@ -6434,7 +6476,7 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n \t\t\t\t      OMP_CLAUSE_MAP);\n \t  OMP_CLAUSE_DECL (nc) = decl;\n \t  OMP_CLAUSE_SIZE (nc) = size_zero_node;\n-\t  OMP_CLAUSE_MAP_KIND (nc) = OMP_CLAUSE_MAP_POINTER;\n+\t  OMP_CLAUSE_SET_MAP_KIND (nc, GOMP_MAP_POINTER);\n \t  OMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (clause);\n \t  OMP_CLAUSE_CHAIN (clause) = nc;\n \t}\n@@ -6584,8 +6626,13 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n \t    remove = true;\n \t  else if (DECL_SIZE (decl)\n \t\t   && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST\n-\t\t   && OMP_CLAUSE_MAP_KIND (c) != OMP_CLAUSE_MAP_POINTER)\n+\t\t   && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_POINTER)\n \t    {\n+\t      /* For GOMP_MAP_FORCE_DEVICEPTR, we'll never enter here, because\n+\t\t for these, TREE_CODE (DECL_SIZE (decl)) will always be\n+\t\t INTEGER_CST.  */\n+\t      gcc_assert (OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_FORCE_DEVICEPTR);\n+\n \t      tree decl2 = DECL_VALUE_EXPR (decl);\n \t      gcc_assert (TREE_CODE (decl2) == INDIRECT_REF);\n \t      decl2 = TREE_OPERAND (decl2, 0);\n@@ -6603,7 +6650,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n \t\t\t\t\t  OMP_CLAUSE_MAP);\n \t      OMP_CLAUSE_DECL (nc) = decl;\n \t      OMP_CLAUSE_SIZE (nc) = size_zero_node;\n-\t      OMP_CLAUSE_MAP_KIND (nc) = OMP_CLAUSE_MAP_POINTER;\n+\t      OMP_CLAUSE_SET_MAP_KIND (nc, GOMP_MAP_POINTER);\n \t      OMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (c);\n \t      OMP_CLAUSE_CHAIN (c) = nc;\n \t      c = nc;\n@@ -6614,6 +6661,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n \n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_FROM:\n+\tcase OMP_CLAUSE__CACHE_:\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (!DECL_P (decl))\n \t    break;\n@@ -6659,6 +6707,19 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n \tcase OMP_CLAUSE_SAFELEN:\n \tcase OMP_CLAUSE_DEPEND:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n+\tcase OMP_CLAUSE_ASYNC:\n+\tcase OMP_CLAUSE_WAIT:\n+\tcase OMP_CLAUSE_DEVICE_RESIDENT:\n+\tcase OMP_CLAUSE_USE_DEVICE:\n+\tcase OMP_CLAUSE_INDEPENDENT:\n+\tcase OMP_CLAUSE_NUM_GANGS:\n+\tcase OMP_CLAUSE_NUM_WORKERS:\n+\tcase OMP_CLAUSE_VECTOR_LENGTH:\n+\tcase OMP_CLAUSE_GANG:\n+\tcase OMP_CLAUSE_WORKER:\n+\tcase OMP_CLAUSE_VECTOR:\n+\tcase OMP_CLAUSE_AUTO:\n+\tcase OMP_CLAUSE_SEQ:\n \t  break;\n \n \tdefault:\n@@ -6681,6 +6742,21 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, tree *list_p)\n   delete_omp_context (ctx);\n }\n \n+/* Gimplify OACC_CACHE.  */\n+\n+static void\n+gimplify_oacc_cache (tree *expr_p, gimple_seq *pre_p)\n+{\n+  tree expr = *expr_p;\n+\n+  gimplify_scan_omp_clauses (&OACC_CACHE_CLAUSES (expr), pre_p, ORT_WORKSHARE);\n+  gimplify_adjust_omp_clauses (pre_p, &OACC_CACHE_CLAUSES (expr));\n+\n+  /* TODO: Do something sensible with this information.  */\n+\n+  *expr_p = NULL_TREE;\n+}\n+\n /* Gimplify the contents of an OMP_PARALLEL statement.  This involves\n    gimplification of the body, as well as scanning the body for used\n    variables.  We need to do this scan now, because variable-sized\n@@ -6795,8 +6871,22 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n   orig_for_stmt = for_stmt = *expr_p;\n \n-  simd = (TREE_CODE (for_stmt) == OMP_SIMD\n-\t  || TREE_CODE (for_stmt) == CILK_SIMD);\n+  switch (TREE_CODE (for_stmt))\n+    {\n+    case OMP_FOR:\n+    case CILK_FOR:\n+    case OMP_DISTRIBUTE:\n+    case OACC_LOOP:\n+      simd = false;\n+      break;\n+    case OMP_SIMD:\n+    case CILK_SIMD:\n+      simd = true;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n   gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p,\n \t\t\t     simd ? ORT_SIMD : ORT_WORKSHARE);\n   if (TREE_CODE (for_stmt) == OMP_DISTRIBUTE)\n@@ -6832,6 +6922,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n   if (OMP_FOR_INIT (for_stmt) == NULL_TREE)\n     {\n+      gcc_assert (TREE_CODE (for_stmt) != OACC_LOOP);\n       for_stmt = walk_tree (&OMP_FOR_BODY (for_stmt), find_combined_omp_for,\n \t\t\t    NULL, NULL);\n       gcc_assert (for_stmt != NULL_TREE);\n@@ -7133,6 +7224,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n     case CILK_SIMD: kind = GF_OMP_FOR_KIND_CILKSIMD; break;\n     case CILK_FOR: kind = GF_OMP_FOR_KIND_CILKFOR; break;\n     case OMP_DISTRIBUTE: kind = GF_OMP_FOR_KIND_DISTRIBUTE; break;\n+    case OACC_LOOP: kind = GF_OMP_FOR_KIND_OACC_LOOP; break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -7173,26 +7265,28 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   return GS_ALL_DONE;\n }\n \n-/* Gimplify the gross structure of other OpenMP constructs.\n-   In particular, OMP_SECTIONS, OMP_SINGLE, OMP_TARGET, OMP_TARGET_DATA\n-   and OMP_TEAMS.  */\n+/* Gimplify the gross structure of several OMP constructs.  */\n \n static void\n gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n {\n   tree expr = *expr_p;\n   gimple stmt;\n   gimple_seq body = NULL;\n-  enum omp_region_type ort = ORT_WORKSHARE;\n+  enum omp_region_type ort;\n \n   switch (TREE_CODE (expr))\n     {\n     case OMP_SECTIONS:\n     case OMP_SINGLE:\n+      ort = ORT_WORKSHARE;\n       break;\n+    case OACC_KERNELS:\n+    case OACC_PARALLEL:\n     case OMP_TARGET:\n       ort = ORT_TARGET;\n       break;\n+    case OACC_DATA:\n     case OMP_TARGET_DATA:\n       ort = ORT_TARGET_DATA;\n       break;\n@@ -7213,9 +7307,21 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n \tpop_gimplify_context (NULL);\n       if (ort == ORT_TARGET_DATA)\n \t{\n-\t  gimple_seq cleanup = NULL;\n-\t  tree fn = builtin_decl_explicit (BUILT_IN_GOMP_TARGET_END_DATA);\n+\t  enum built_in_function end_ix;\n+\t  switch (TREE_CODE (expr))\n+\t    {\n+\t    case OACC_DATA:\n+\t      end_ix = BUILT_IN_GOACC_DATA_END;\n+\t      break;\n+\t    case OMP_TARGET_DATA:\n+\t      end_ix = BUILT_IN_GOMP_TARGET_END_DATA;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  tree fn = builtin_decl_explicit (end_ix);\n \t  g = gimple_build_call (fn, 0);\n+\t  gimple_seq cleanup = NULL;\n \t  gimple_seq_add_stmt (&cleanup, g);\n \t  g = gimple_build_try (body, cleanup, GIMPLE_TRY_FINALLY);\n \t  body = NULL;\n@@ -7228,6 +7334,18 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n \n   switch (TREE_CODE (expr))\n     {\n+    case OACC_DATA:\n+      stmt = gimple_build_omp_target (body, GF_OMP_TARGET_KIND_OACC_DATA,\n+\t\t\t\t      OMP_CLAUSES (expr));\n+      break;\n+    case OACC_KERNELS:\n+      stmt = gimple_build_omp_target (body, GF_OMP_TARGET_KIND_OACC_KERNELS,\n+\t\t\t\t      OMP_CLAUSES (expr));\n+      break;\n+    case OACC_PARALLEL:\n+      stmt = gimple_build_omp_target (body, GF_OMP_TARGET_KIND_OACC_PARALLEL,\n+\t\t\t\t      OMP_CLAUSES (expr));\n+      break;\n     case OMP_SECTIONS:\n       stmt = gimple_build_omp_sections (body, OMP_CLAUSES (expr));\n       break;\n@@ -7253,19 +7371,40 @@ gimplify_omp_workshare (tree *expr_p, gimple_seq *pre_p)\n   *expr_p = NULL_TREE;\n }\n \n-/* Gimplify the gross structure of OpenMP target update construct.  */\n+/* Gimplify the gross structure of OpenACC enter/exit data, update, and OpenMP\n+   target update constructs.  */\n \n static void\n gimplify_omp_target_update (tree *expr_p, gimple_seq *pre_p)\n {\n-  tree expr = *expr_p;\n+  tree expr = *expr_p, clauses;\n+  int kind;\n   gomp_target *stmt;\n \n-  gimplify_scan_omp_clauses (&OMP_TARGET_UPDATE_CLAUSES (expr), pre_p,\n-\t\t\t     ORT_WORKSHARE);\n-  gimplify_adjust_omp_clauses (pre_p, &OMP_TARGET_UPDATE_CLAUSES (expr));\n-  stmt = gimple_build_omp_target (NULL, GF_OMP_TARGET_KIND_UPDATE,\n-\t\t\t\t  OMP_TARGET_UPDATE_CLAUSES (expr));\n+  switch (TREE_CODE (expr))\n+    {\n+    case OACC_ENTER_DATA:\n+      clauses = OACC_ENTER_DATA_CLAUSES (expr);\n+      kind = GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA;\n+      break;\n+    case OACC_EXIT_DATA:\n+      clauses = OACC_EXIT_DATA_CLAUSES (expr);\n+      kind = GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA;\n+      break;\n+    case OACC_UPDATE:\n+      clauses = OACC_UPDATE_CLAUSES (expr);\n+      kind = GF_OMP_TARGET_KIND_OACC_UPDATE;\n+      break;\n+    case OMP_TARGET_UPDATE:\n+      clauses = OMP_TARGET_UPDATE_CLAUSES (expr);\n+      kind = GF_OMP_TARGET_KIND_UPDATE;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  gimplify_scan_omp_clauses (&clauses, pre_p, ORT_WORKSHARE);\n+  gimplify_adjust_omp_clauses (pre_p, &clauses);\n+  stmt = gimple_build_omp_target (NULL, kind, clauses);\n \n   gimplify_seq_add_stmt (pre_p, stmt);\n   *expr_p = NULL_TREE;\n@@ -7445,7 +7584,7 @@ gimplify_transaction (tree *expr_p, gimple_seq *pre_p)\n   int subcode = 0;\n \n   /* Wrap the transaction body in a BIND_EXPR so we have a context\n-     where to put decls for OpenMP.  */\n+     where to put decls for OMP.  */\n   if (TREE_CODE (tbody) != BIND_EXPR)\n     {\n       tree bind = build3 (BIND_EXPR, void_type_node, NULL, tbody, NULL);\n@@ -8182,7 +8321,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  break;\n \n \tcase RESULT_DECL:\n-\t  /* When within an OpenMP context, notice uses of variables.  */\n+\t  /* When within an OMP context, notice uses of variables.  */\n \t  if (gimplify_omp_ctxp)\n \t    omp_notice_variable (gimplify_omp_ctxp, *expr_p, true);\n \t  ret = GS_ALL_DONE;\n@@ -8208,9 +8347,38 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \tcase CILK_SIMD:\n \tcase CILK_FOR:\n \tcase OMP_DISTRIBUTE:\n+\tcase OACC_LOOP:\n \t  ret = gimplify_omp_for (expr_p, pre_p);\n \t  break;\n \n+\tcase OACC_CACHE:\n+\t  gimplify_oacc_cache (expr_p, pre_p);\n+\t  ret = GS_ALL_DONE;\n+\t  break;\n+\n+\tcase OACC_HOST_DATA:\n+\tcase OACC_DECLARE:\n+\t  sorry (\"directive not yet implemented\");\n+\t  ret = GS_ALL_DONE;\n+\t  break;\n+\n+\tcase OACC_KERNELS:\n+\t  if (OACC_KERNELS_COMBINED (*expr_p))\n+\t    sorry (\"directive not yet implemented\");\n+\t  else\n+\t    gimplify_omp_workshare (expr_p, pre_p);\n+\t  ret = GS_ALL_DONE;\n+\t  break;\n+\n+\tcase OACC_PARALLEL:\n+\t  if (OACC_PARALLEL_COMBINED (*expr_p))\n+\t    sorry (\"directive not yet implemented\");\n+\t  else\n+\t    gimplify_omp_workshare (expr_p, pre_p);\n+\t  ret = GS_ALL_DONE;\n+\t  break;\n+\n+\tcase OACC_DATA:\n \tcase OMP_SECTIONS:\n \tcase OMP_SINGLE:\n \tcase OMP_TARGET:\n@@ -8220,6 +8388,9 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  ret = GS_ALL_DONE;\n \t  break;\n \n+\tcase OACC_ENTER_DATA:\n+\tcase OACC_EXIT_DATA:\n+\tcase OACC_UPDATE:\n \tcase OMP_TARGET_UPDATE:\n \t  gimplify_omp_target_update (expr_p, pre_p);\n \t  ret = GS_ALL_DONE;\n@@ -8601,8 +8772,18 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t  && code != LOOP_EXPR\n \t\t  && code != SWITCH_EXPR\n \t\t  && code != TRY_FINALLY_EXPR\n+\t\t  && code != OACC_PARALLEL\n+\t\t  && code != OACC_KERNELS\n+\t\t  && code != OACC_DATA\n+\t\t  && code != OACC_HOST_DATA\n+\t\t  && code != OACC_DECLARE\n+\t\t  && code != OACC_UPDATE\n+\t\t  && code != OACC_ENTER_DATA\n+\t\t  && code != OACC_EXIT_DATA\n+\t\t  && code != OACC_CACHE\n \t\t  && code != OMP_CRITICAL\n \t\t  && code != OMP_FOR\n+\t\t  && code != OACC_LOOP\n \t\t  && code != OMP_MASTER\n \t\t  && code != OMP_TASKGROUP\n \t\t  && code != OMP_ORDERED\n@@ -8829,7 +9010,7 @@ gimplify_body (tree fndecl, bool do_parms)\n   gcc_assert (gimplify_ctxp == NULL);\n   push_gimplify_context ();\n \n-  if (flag_openmp)\n+  if (flag_openacc || flag_openmp)\n     {\n       gcc_assert (gimplify_omp_ctxp == NULL);\n       if (lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (fndecl)))\n@@ -8913,7 +9094,8 @@ gimplify_body (tree fndecl, bool do_parms)\n       nonlocal_vlas = NULL;\n     }\n \n-  if ((flag_openmp || flag_openmp_simd) && gimplify_omp_ctxp)\n+  if ((flag_openacc || flag_openmp || flag_openmp_simd)\n+      && gimplify_omp_ctxp)\n     {\n       delete_omp_context (gimplify_omp_ctxp);\n       gimplify_omp_ctxp = NULL;"}, {"sha": "cced43b97131de2245837731d0911fd4f9110b76", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -82,6 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"streamer-hooks.h\"\n #include \"cfgloop.h\"\n #include \"builtins.h\"\n+#include \"gomp-constants.h\"\n \n \n static void lto_write_tree (struct output_block*, tree, bool);"}, {"sha": "9b98edd63787fbab0112ed27ec99d9b799b13c98", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,10 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\n+\t* lto-lang.c (DEF_FUNCTION_TYPE_VAR_8, DEF_FUNCTION_TYPE_VAR_12):\n+\tNew macros.\n+\t* lto.c: Include \"gomp-constants.h\".\n+\n 2015-01-14  Ilya Verbin  <ilya.verbin@intel.com>\n \n \t* lto-partition.c (lto_promote_cross_file_statics): Remove argument"}, {"sha": "aa474e07d85779dfc811596e97012c30772a0386", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -177,6 +177,11 @@ enum lto_builtin_type\n #define DEF_FUNCTION_TYPE_VAR_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n #define DEF_FUNCTION_TYPE_VAR_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG6) \\\n   NAME,\n+#define DEF_FUNCTION_TYPE_VAR_8(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\tARG6, ARG7, ARG8) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_12(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\t ARG6, ARG7, ARG8, ARG9, ARG10, ARG11,       \\\n+\t\t\t\t ARG12) NAME,\n #define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n #include \"builtin-types.def\"\n #undef DEF_PRIMITIVE_TYPE\n@@ -195,6 +200,8 @@ enum lto_builtin_type\n #undef DEF_FUNCTION_TYPE_VAR_3\n #undef DEF_FUNCTION_TYPE_VAR_4\n #undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_FUNCTION_TYPE_VAR_8\n+#undef DEF_FUNCTION_TYPE_VAR_12\n #undef DEF_POINTER_TYPE\n   BT_LAST\n };\n@@ -679,6 +686,14 @@ lto_define_builtins (tree va_list_ref_type_node ATTRIBUTE_UNUSED,\n   def_fn_type (ENUM, RETURN, 1, 4, ARG1, ARG2, ARG3, ARG4);\n #define DEF_FUNCTION_TYPE_VAR_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) \\\n   def_fn_type (ENUM, RETURN, 1, 5, ARG1, ARG2, ARG3, ARG4, ARG5);\n+#define DEF_FUNCTION_TYPE_VAR_8(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\tARG6, ARG7, ARG8)\t\t\t    \\\n+  def_fn_type (ENUM, RETURN, 1, 8, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,      \\\n+\t       ARG7, ARG8);\n+#define DEF_FUNCTION_TYPE_VAR_12(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t\t ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) \\\n+  def_fn_type (ENUM, RETURN, 1, 12, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6,      \\\n+\t       ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);\n #define DEF_POINTER_TYPE(ENUM, TYPE) \\\n   builtin_types[(int) ENUM] = build_pointer_type (builtin_types[(int) TYPE]);\n \n@@ -700,6 +715,8 @@ lto_define_builtins (tree va_list_ref_type_node ATTRIBUTE_UNUSED,\n #undef DEF_FUNCTION_TYPE_VAR_3\n #undef DEF_FUNCTION_TYPE_VAR_4\n #undef DEF_FUNCTION_TYPE_VAR_5\n+#undef DEF_FUNCTION_TYPE_VAR_8\n+#undef DEF_FUNCTION_TYPE_VAR_12\n #undef DEF_POINTER_TYPE\n   builtin_types[(int) BT_LAST] = NULL_TREE;\n "}, {"sha": "15d3f1040bb5d5a4ece3a144ac4e14c9cd0f8f5d", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -77,6 +77,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-inline.h\"\n #include \"params.h\"\n #include \"ipa-utils.h\"\n+#include \"gomp-constants.h\"\n \n \n /* Number of parallel tasks to run, -1 if we want to use GNU Make jobserver.  */"}, {"sha": "6aea7b7a97fd34a557bb532c50c4823c239ce545", "filename": "gcc/omp-builtins.def", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,5 +1,5 @@\n /* This file contains the definitions and documentation for the\n-   OpenMP builtins used in the GNU compiler.\n+   Offloading and Multi Processing builtins used in the GNU compiler.\n    Copyright (C) 2005-2015 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -20,10 +20,41 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Before including this file, you should define a macro:\n \n+     DEF_GOACC_BUILTIN (ENUM, NAME, TYPE, ATTRS)\n+     DEF_GOACC_BUILTIN_COMPILER (ENUM, NAME, TYPE, ATTRS)\n      DEF_GOMP_BUILTIN (ENUM, NAME, TYPE, ATTRS)\n \n    See builtins.def for details.  */\n \n+/* The reason why they aren't in gcc/builtins.def is that the Fortran front end\n+   doesn't source those.  */\n+\n+DEF_GOACC_BUILTIN (BUILT_IN_ACC_GET_DEVICE_TYPE, \"acc_get_device_type\",\n+\t\t   BT_FN_INT, ATTR_NOTHROW_LIST)\n+DEF_GOACC_BUILTIN (BUILT_IN_GOACC_DATA_START, \"GOACC_data_start\",\n+\t\t   BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR, ATTR_NOTHROW_LIST)\n+DEF_GOACC_BUILTIN (BUILT_IN_GOACC_DATA_END, \"GOACC_data_end\",\n+\t\t   BT_FN_VOID, ATTR_NOTHROW_LIST)\n+DEF_GOACC_BUILTIN (BUILT_IN_GOACC_ENTER_EXIT_DATA, \"GOACC_enter_exit_data\",\n+\t\t   BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR,\n+\t\t   ATTR_NOTHROW_LIST)\n+DEF_GOACC_BUILTIN (BUILT_IN_GOACC_PARALLEL, \"GOACC_parallel\",\n+\t\t   BT_FN_VOID_INT_OMPFN_PTR_SIZE_PTR_PTR_PTR_INT_INT_INT_INT_INT_VAR,\n+\t\t   ATTR_NOTHROW_LIST)\n+DEF_GOACC_BUILTIN (BUILT_IN_GOACC_UPDATE, \"GOACC_update\",\n+\t\t   BT_FN_VOID_INT_PTR_SIZE_PTR_PTR_PTR_INT_INT_VAR,\n+\t\t   ATTR_NOTHROW_LIST)\n+DEF_GOACC_BUILTIN (BUILT_IN_GOACC_WAIT, \"GOACC_wait\",\n+\t\t   BT_FN_VOID_INT_INT_VAR,\n+\t\t   ATTR_NOTHROW_LIST)\n+DEF_GOACC_BUILTIN (BUILT_IN_GOACC_GET_THREAD_NUM, \"GOACC_get_thread_num\",\n+\t\t   BT_FN_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_GOACC_BUILTIN (BUILT_IN_GOACC_GET_NUM_THREADS, \"GOACC_get_num_threads\",\n+\t\t   BT_FN_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n+\n+DEF_GOACC_BUILTIN_COMPILER (BUILT_IN_ACC_ON_DEVICE, \"acc_on_device\",\n+\t\t\t    BT_FN_INT_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n+\n DEF_GOMP_BUILTIN (BUILT_IN_OMP_GET_THREAD_NUM, \"omp_get_thread_num\",\n \t\t  BT_FN_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_OMP_GET_NUM_THREADS, \"omp_get_num_threads\","}, {"sha": "b7bf338b70288fa4ac9cb6df7f26252e6cf14ac8", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1370, "deletions": 230, "changes": 1600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,6 +1,7 @@\n-/* Lowering pass for OpenMP directives.  Converts OpenMP directives\n-   into explicit calls to the runtime library (libgomp) and data\n-   marshalling to implement data sharing and copying clauses.\n+/* Lowering pass for OMP directives.  Converts OMP directives into explicit\n+   calls to the runtime library (libgomp), data marshalling to implement data\n+   sharing and copying clauses, offloading to accelerators, and more.\n+\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n    Copyright (C) 2005-2015 Free Software Foundation, Inc.\n@@ -106,20 +107,21 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cilk.h\"\n #include \"context.h\"\n #include \"lto-section-names.h\"\n+#include \"gomp-constants.h\"\n \n \n-/* Lowering of OpenMP parallel and workshare constructs proceeds in two\n+/* Lowering of OMP parallel and workshare constructs proceeds in two\n    phases.  The first phase scans the function looking for OMP statements\n    and then for variables that must be replaced to satisfy data sharing\n    clauses.  The second phase expands code for the constructs, as well as\n    re-gimplifying things when variables have been replaced with complex\n    expressions.\n \n    Final code generation is done by pass_expand_omp.  The flowgraph is\n-   scanned for parallel regions which are then moved to a new\n-   function, to be invoked by the thread library.  */\n+   scanned for regions which are then moved to a new\n+   function, to be invoked by the thread library, or offloaded.  */\n \n-/* Parallel region information.  Every parallel and workshare\n+/* OMP region information.  Every parallel and workshare\n    directive is enclosed between two markers, the OMP_* directive\n    and a corresponding OMP_RETURN statement.  */\n \n@@ -158,6 +160,12 @@ struct omp_region\n   bool is_combined_parallel;\n };\n \n+/* Levels of parallelism as defined by OpenACC.  Increasing numbers\n+   correspond to deeper loop nesting levels.  */\n+#define MASK_GANG 1\n+#define MASK_WORKER 2\n+#define MASK_VECTOR 4\n+\n /* Context structure.  Used to store information about each parallel\n    directive in the code.  */\n \n@@ -192,6 +200,11 @@ typedef struct omp_context\n      construct.  In the case of a parallel, this is in the child function.  */\n   tree block_vars;\n \n+  /* A map of reduction pointer variables.  For accelerators, each\n+     reduction variable is replaced with an array.  Each thread, in turn,\n+     is assigned to a slot on that array.  */\n+  splay_tree reduction_map;\n+\n   /* Label to which GOMP_cancel{,llation_point} and explicit and implicit\n      barriers should jump to during omplower pass.  */\n   tree cancel_label;\n@@ -210,8 +223,18 @@ typedef struct omp_context\n \n   /* True if this construct can be cancelled.  */\n   bool cancellable;\n+\n+  /* For OpenACC loops, a mask of gang, worker and vector used at\n+     levels below this one.  */\n+  int gwv_below;\n+  /* For OpenACC loops, a mask of gang, worker and vector used at\n+     this level and above.  For parallel and kernels clauses, a mask\n+     indicating which of num_gangs/num_workers/num_vectors was used.  */\n+  int gwv_this;\n } omp_context;\n \n+/* A structure holding the elements of:\n+   for (V = N1; V cond N2; V += STEP) [...] */\n \n struct omp_for_data_loop\n {\n@@ -254,9 +277,93 @@ static tree scan_omp_1_op (tree *, int *, void *);\n       *handled_ops_p = false; \\\n       break;\n \n+/* Helper function to get the name of the array containing the partial\n+   reductions for OpenACC reductions.  */\n+static const char *\n+oacc_get_reduction_array_id (tree node)\n+{\n+  const char *id = IDENTIFIER_POINTER (DECL_NAME (node));\n+  int len = strlen (\"OACC\") + strlen (id);\n+  char *temp_name = XALLOCAVEC (char, len + 1);\n+  snprintf (temp_name, len + 1, \"OACC%s\", id);\n+  return IDENTIFIER_POINTER (get_identifier (temp_name));\n+}\n+\n+/* Determine the number of threads OpenACC threads used to determine the\n+   size of the array of partial reductions.  Currently, this is num_gangs\n+   * vector_length.  This value may be different than GOACC_GET_NUM_THREADS,\n+   because it is independed of the device used.  */\n+\n+static tree\n+oacc_max_threads (omp_context *ctx)\n+{\n+  tree nthreads, vector_length, gangs, clauses;\n+\n+  gangs = fold_convert (sizetype, integer_one_node);\n+  vector_length = gangs;\n+\n+  /* The reduction clause may be nested inside a loop directive.\n+     Scan for the innermost vector_length clause.  */\n+  for (omp_context *oc = ctx; oc; oc = oc->outer)\n+    {\n+      if (gimple_code (oc->stmt) != GIMPLE_OMP_TARGET\n+\t  || (gimple_omp_target_kind (oc->stmt)\n+\t      != GF_OMP_TARGET_KIND_OACC_PARALLEL))\n+\tcontinue;\n+\n+      clauses = gimple_omp_target_clauses (oc->stmt);\n+\n+      vector_length = find_omp_clause (clauses, OMP_CLAUSE_VECTOR_LENGTH);\n+      if (vector_length)\n+\tvector_length = fold_convert_loc (OMP_CLAUSE_LOCATION (vector_length),\n+\t\t\t\t\t  sizetype,\n+\t\t\t\t\t  OMP_CLAUSE_VECTOR_LENGTH_EXPR\n+\t\t\t\t\t  (vector_length));\n+      else\n+\tvector_length = fold_convert (sizetype, integer_one_node);\n+\n+      gangs = find_omp_clause (clauses, OMP_CLAUSE_NUM_GANGS);\n+      if (gangs)\n+        gangs = fold_convert_loc (OMP_CLAUSE_LOCATION (gangs), sizetype,\n+\t\t\t\t  OMP_CLAUSE_NUM_GANGS_EXPR (gangs));\n+      else\n+\tgangs = fold_convert (sizetype, integer_one_node);\n+\n+      break;\n+    }\n+\n+  nthreads = fold_build2 (MULT_EXPR, sizetype, gangs, vector_length);\n+\n+  return nthreads;\n+}\n+\n /* Holds offload tables with decls.  */\n vec<tree, va_gc> *offload_funcs, *offload_vars;\n \n+/* Holds a decl for __OFFLOAD_TABLE__.  */\n+static GTY(()) tree offload_symbol_decl;\n+\n+/* Get the __OFFLOAD_TABLE__ symbol.  */\n+static tree\n+get_offload_symbol_decl (void)\n+{\n+  if (!offload_symbol_decl)\n+    {\n+      tree decl = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t      get_identifier (\"__OFFLOAD_TABLE__\"),\n+\t\t\t      ptr_type_node);\n+      TREE_ADDRESSABLE (decl) = 1;\n+      TREE_PUBLIC (decl) = 1;\n+      DECL_EXTERNAL (decl) = 1;\n+      DECL_WEAK (decl) = 1;\n+      DECL_ATTRIBUTES (decl)\n+\t= tree_cons (get_identifier (\"weak\"),\n+\t\t     NULL_TREE, DECL_ATTRIBUTES (decl));\n+      offload_symbol_decl = decl;\n+    }\n+  return offload_symbol_decl;\n+}\n+\n /* Convenience function for calling scan_omp_1_op on tree operands.  */\n \n static inline tree\n@@ -275,7 +382,7 @@ static void lower_omp (gimple_seq *, omp_context *);\n static tree lookup_decl_in_outer_ctx (tree, omp_context *);\n static tree maybe_lookup_decl_in_outer_ctx (tree, omp_context *);\n \n-/* Find an OpenMP clause of type KIND within CLAUSES.  */\n+/* Find an OMP clause of type KIND within CLAUSES.  */\n \n tree\n find_omp_clause (tree clauses, enum omp_clause_code kind)\n@@ -296,16 +403,6 @@ is_parallel_ctx (omp_context *ctx)\n }\n \n \n-/* Return true if CTX is for an omp target region.  */\n-\n-static inline bool\n-is_targetreg_ctx (omp_context *ctx)\n-{\n-  return gimple_code (ctx->stmt) == GIMPLE_OMP_TARGET\n-\t && gimple_omp_target_kind (ctx->stmt) == GF_OMP_TARGET_KIND_REGION;\n-}\n-\n-\n /* Return true if CTX is for an omp task.  */\n \n static inline bool\n@@ -630,6 +727,15 @@ extract_omp_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n       fd->loop.step = build_int_cst (TREE_TYPE (fd->loop.v), 1);\n       fd->loop.cond_code = LT_EXPR;\n     }\n+\n+  /* For OpenACC loops, force a chunk size of one, as this avoids the default\n+    scheduling where several subsequent iterations are being executed by the\n+    same thread.  */\n+  if (gimple_omp_for_kind (for_stmt) == GF_OMP_FOR_KIND_OACC_LOOP)\n+    {\n+      gcc_assert (fd->chunk_size == NULL_TREE);\n+      fd->chunk_size = build_int_cst (TREE_TYPE (fd->loop.v), 1);\n+    }\n }\n \n \n@@ -858,7 +964,18 @@ is_reference (tree decl)\n   return lang_hooks.decls.omp_privatize_by_reference (decl);\n }\n \n-/* Lookup variables in the decl or field splay trees.  The \"maybe\" form\n+/* Return the type of a decl.  If the decl is reference type,\n+   return its base type.  */\n+static inline tree\n+get_base_type (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+  if (is_reference (decl))\n+    type = TREE_TYPE (type);\n+  return type;\n+}\n+\n+/* Lookup variables.  The \"maybe\" form\n    allows for the variable form to not have been entered, otherwise we\n    assert that the variable must have been entered.  */\n \n@@ -902,6 +1019,23 @@ maybe_lookup_field (tree var, omp_context *ctx)\n   return n ? (tree) n->value : NULL_TREE;\n }\n \n+static inline tree\n+lookup_oacc_reduction (const char *id, omp_context *ctx)\n+{\n+  splay_tree_node n;\n+  n = splay_tree_lookup (ctx->reduction_map, (splay_tree_key) id);\n+  return (tree) n->value;\n+}\n+\n+static inline tree\n+maybe_lookup_oacc_reduction (tree var, omp_context *ctx)\n+{\n+  splay_tree_node n = NULL;\n+  if (ctx->reduction_map)\n+    n = splay_tree_lookup (ctx->reduction_map, (splay_tree_key) var);\n+  return n ? (tree) n->value : NULL_TREE;\n+}\n+\n /* Return true if DECL should be copied by pointer.  SHARED_CTX is\n    the parallel context if DECL is to be shared.  */\n \n@@ -915,6 +1049,8 @@ use_pointer_for_field (tree decl, omp_context *shared_ctx)\n      when we know the value is not accessible from an outer scope.  */\n   if (shared_ctx)\n     {\n+      gcc_assert (!is_gimple_omp_oacc (shared_ctx->stmt));\n+\n       /* ??? Trivially accessible from anywhere.  But why would we even\n \t be passing an address in this case?  Should we simply assert\n \t this to be false, or should we have a cleanup pass that removes\n@@ -1119,6 +1255,8 @@ install_var_field (tree var, bool by_ref, int mask, omp_context *ctx)\n \t      || !splay_tree_lookup (ctx->field_map, (splay_tree_key) var));\n   gcc_assert ((mask & 2) == 0 || !ctx->sfield_map\n \t      || !splay_tree_lookup (ctx->sfield_map, (splay_tree_key) var));\n+  gcc_assert ((mask & 3) == 3\n+\t      || !is_gimple_omp_oacc (ctx->stmt));\n \n   type = TREE_TYPE (var);\n   if (mask & 4)\n@@ -1395,6 +1533,7 @@ new_omp_context (gimple stmt, omp_context *outer_ctx)\n       ctx->cb = outer_ctx->cb;\n       ctx->cb.block = NULL;\n       ctx->depth = outer_ctx->depth + 1;\n+      ctx->reduction_map = outer_ctx->reduction_map;\n     }\n   else\n     {\n@@ -1465,6 +1604,11 @@ delete_omp_context (splay_tree_value value)\n     splay_tree_delete (ctx->field_map);\n   if (ctx->sfield_map)\n     splay_tree_delete (ctx->sfield_map);\n+  if (ctx->reduction_map\n+      /* Shared over several omp_contexts.  */\n+      && (ctx->outer == NULL\n+\t  || ctx->reduction_map != ctx->outer->reduction_map))\n+    splay_tree_delete (ctx->reduction_map);\n \n   /* We hijacked DECL_ABSTRACT_ORIGIN earlier.  We need to clear it before\n      it produces corrupt debug information.  */\n@@ -1603,6 +1747,12 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  /* FALLTHRU */\n \n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  if (is_gimple_omp_oacc (ctx->stmt))\n+\t    {\n+\t      sorry (\"clause not supported yet\");\n+\t      break;\n+\t    }\n+\t  /* FALLTHRU */\n \tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_LINEAR:\n \t  decl = OMP_CLAUSE_DECL (c);\n@@ -1630,6 +1780,27 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\tinstall_var_field (decl, by_ref, 3, ctx);\n \t    }\n \t  install_var_local (decl, ctx);\n+\t  if (is_gimple_omp_oacc (ctx->stmt)\n+\t      && OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t    {\n+\t      /* Create a decl for the reduction array.  */\n+\t      tree var = OMP_CLAUSE_DECL (c);\n+\t      tree type = get_base_type (var);\n+\t      tree ptype = build_pointer_type (type);\n+\t      tree array = create_tmp_var (ptype,\n+\t\t\t\t\t   oacc_get_reduction_array_id (var));\n+\t      omp_context *c = (ctx->field_map ? ctx : ctx->outer);\n+\t      install_var_field (array, true, 3, c);\n+\t      install_var_local (array, c);\n+\n+\t      /* Insert it into the current context.  */\n+\t      splay_tree_insert (ctx->reduction_map, (splay_tree_key)\n+\t\t\t\t oacc_get_reduction_array_id (var),\n+\t\t\t\t (splay_tree_value) array);\n+\t      splay_tree_insert (ctx->reduction_map,\n+\t\t\t\t (splay_tree_key) array,\n+\t\t\t\t (splay_tree_value) array);\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE__LOOPTEMP_:\n@@ -1660,6 +1831,9 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_DIST_SCHEDULE:\n \tcase OMP_CLAUSE_DEPEND:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n+\tcase OMP_CLAUSE_NUM_GANGS:\n+\tcase OMP_CLAUSE_NUM_WORKERS:\n+\tcase OMP_CLAUSE_VECTOR_LENGTH:\n \t  if (ctx->outer)\n \t    scan_omp_op (&OMP_CLAUSE_OPERAND (c, 0), ctx->outer);\n \t  break;\n@@ -1679,12 +1853,11 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t      && varpool_node::get_create (decl)->offloadable)\n \t    break;\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t      && OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER)\n+\t      && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER)\n \t    {\n-\t      /* Ignore OMP_CLAUSE_MAP_POINTER kind for arrays in\n-\t\t #pragma omp target data, there is nothing to map for\n-\t\t those.  */\n-\t      if (gimple_omp_target_kind (ctx->stmt) == GF_OMP_TARGET_KIND_DATA\n+\t      /* Ignore GOMP_MAP_POINTER kind for arrays in regions that are\n+\t\t not offloaded; there is nothing to map for those.  */\n+\t      if (!is_gimple_omp_offloaded (ctx->stmt)\n \t\t  && !POINTER_TYPE_P (TREE_TYPE (decl)))\n \t\tbreak;\n \t    }\n@@ -1704,14 +1877,13 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t      else\n \t\t{\n \t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t      && OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER\n+\t\t      && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n \t\t      && !OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION (c)\n \t\t      && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t\t    install_var_field (decl, true, 7, ctx);\n \t\t  else\n \t\t    install_var_field (decl, true, 3, ctx);\n-\t\t  if (gimple_omp_target_kind (ctx->stmt)\n-\t\t      == GF_OMP_TARGET_KIND_REGION)\n+\t\t  if (is_gimple_omp_offloaded (ctx->stmt))\n \t\t    install_var_local (decl, ctx);\n \t\t}\n \t    }\n@@ -1723,7 +1895,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\t  && nc != NULL_TREE\n \t\t  && OMP_CLAUSE_CODE (nc) == OMP_CLAUSE_MAP\n \t\t  && OMP_CLAUSE_DECL (nc) == base\n-\t\t  && OMP_CLAUSE_MAP_KIND (nc) == OMP_CLAUSE_MAP_POINTER\n+\t\t  && OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_POINTER\n \t\t  && integer_zerop (OMP_CLAUSE_SIZE (nc)))\n \t\t{\n \t\t  OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION (c) = 1;\n@@ -1756,6 +1928,11 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_MERGEABLE:\n \tcase OMP_CLAUSE_PROC_BIND:\n \tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_ASYNC:\n+\tcase OMP_CLAUSE_WAIT:\n+\tcase OMP_CLAUSE_GANG:\n+\tcase OMP_CLAUSE_WORKER:\n+\tcase OMP_CLAUSE_VECTOR:\n \t  break;\n \n \tcase OMP_CLAUSE_ALIGNED:\n@@ -1765,6 +1942,15 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t    install_var_local (decl, ctx);\n \t  break;\n \n+\tcase OMP_CLAUSE_DEVICE_RESIDENT:\n+\tcase OMP_CLAUSE_USE_DEVICE:\n+\tcase OMP_CLAUSE__CACHE_:\n+\tcase OMP_CLAUSE_INDEPENDENT:\n+\tcase OMP_CLAUSE_AUTO:\n+\tcase OMP_CLAUSE_SEQ:\n+\t  sorry (\"Clause not supported yet\");\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -1783,8 +1969,14 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t    break;\n \t  /* FALLTHRU */\n \n-\tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n+\t  if (is_gimple_omp_oacc (ctx->stmt))\n+\t    {\n+\t      sorry (\"clause not supported yet\");\n+\t      break;\n+\t    }\n+\t  /* FALLTHRU */\n+\tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_LINEAR:\n \t  decl = OMP_CLAUSE_DECL (c);\n@@ -1811,7 +2003,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  break;\n \n \tcase OMP_CLAUSE_MAP:\n-\t  if (gimple_omp_target_kind (ctx->stmt) == GF_OMP_TARGET_KIND_DATA)\n+\t  if (!is_gimple_omp_offloaded (ctx->stmt))\n \t    break;\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (DECL_P (decl)\n@@ -1820,7 +2012,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t    break;\n \t  if (DECL_P (decl))\n \t    {\n-\t      if (OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER\n+\t      if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n \t\t  && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n \t\t  && !COMPLETE_TYPE_P (TREE_TYPE (decl)))\n \t\t{\n@@ -1867,13 +2059,32 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_FROM:\n \tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n+\tcase OMP_CLAUSE_ASYNC:\n+\tcase OMP_CLAUSE_WAIT:\n+\tcase OMP_CLAUSE_NUM_GANGS:\n+\tcase OMP_CLAUSE_NUM_WORKERS:\n+\tcase OMP_CLAUSE_VECTOR_LENGTH:\n+\tcase OMP_CLAUSE_GANG:\n+\tcase OMP_CLAUSE_WORKER:\n+\tcase OMP_CLAUSE_VECTOR:\n+\t  break;\n+\n+\tcase OMP_CLAUSE_DEVICE_RESIDENT:\n+\tcase OMP_CLAUSE_USE_DEVICE:\n+\tcase OMP_CLAUSE__CACHE_:\n+\tcase OMP_CLAUSE_INDEPENDENT:\n+\tcase OMP_CLAUSE_AUTO:\n+\tcase OMP_CLAUSE_SEQ:\n+\t  sorry (\"Clause not supported yet\");\n \t  break;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n     }\n \n+  gcc_checking_assert (!scan_array_reductions\n+\t\t       || !is_gimple_omp_oacc (ctx->stmt));\n   if (scan_array_reductions)\n     for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n       if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n@@ -1956,6 +2167,8 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n \n   decl = build_decl (gimple_location (ctx->stmt), FUNCTION_DECL, name, type);\n \n+  gcc_checking_assert (!is_gimple_omp_oacc (ctx->stmt)\n+\t\t       || !task_copy);\n   if (!task_copy)\n     ctx->cb.dst_fn = decl;\n   else\n@@ -1976,7 +2189,7 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n     {\n       omp_context *octx;\n       for (octx = ctx; octx; octx = octx->outer)\n-\tif (is_targetreg_ctx (octx))\n+\tif (is_gimple_omp_offloaded (octx->stmt))\n \t  {\n \t    cgraph_node::get_create (decl)->offloadable = 1;\n #ifdef ENABLE_OFFLOADING\n@@ -2311,17 +2524,84 @@ finish_taskreg_scan (omp_context *ctx)\n }\n \n \n-/* Scan an OpenMP loop directive.  */\n+static omp_context *\n+enclosing_target_ctx (omp_context *ctx)\n+{\n+  while (ctx != NULL\n+\t && gimple_code (ctx->stmt) != GIMPLE_OMP_TARGET)\n+    ctx = ctx->outer;\n+  gcc_assert (ctx != NULL);\n+  return ctx;\n+}\n+\n+static bool\n+oacc_loop_or_target_p (gimple stmt)\n+{\n+  enum gimple_code outer_type = gimple_code (stmt);\n+  return ((outer_type == GIMPLE_OMP_TARGET\n+\t   && ((gimple_omp_target_kind (stmt)\n+\t\t== GF_OMP_TARGET_KIND_OACC_PARALLEL)\n+\t       || (gimple_omp_target_kind (stmt)\n+\t\t   == GF_OMP_TARGET_KIND_OACC_KERNELS)))\n+\t  || (outer_type == GIMPLE_OMP_FOR\n+\t      && gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_OACC_LOOP));\n+}\n+\n+/* Scan a GIMPLE_OMP_FOR.  */\n \n static void\n scan_omp_for (gomp_for *stmt, omp_context *outer_ctx)\n {\n+  enum gimple_code outer_type = GIMPLE_ERROR_MARK;\n   omp_context *ctx;\n   size_t i;\n+  tree clauses = gimple_omp_for_clauses (stmt);\n+\n+  if (outer_ctx)\n+    outer_type = gimple_code (outer_ctx->stmt);\n \n   ctx = new_omp_context (stmt, outer_ctx);\n \n-  scan_sharing_clauses (gimple_omp_for_clauses (stmt), ctx);\n+  if (is_gimple_omp_oacc (stmt))\n+    {\n+      if (outer_ctx && outer_type == GIMPLE_OMP_FOR)\n+\tctx->gwv_this = outer_ctx->gwv_this;\n+      for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+\t{\n+\t  int val;\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_GANG)\n+\t    val = MASK_GANG;\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_WORKER)\n+\t    val = MASK_WORKER;\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_VECTOR)\n+\t    val = MASK_VECTOR;\n+\t  else\n+\t    continue;\n+\t  ctx->gwv_this |= val;\n+\t  if (!outer_ctx)\n+\t    {\n+\t      /* Skip; not nested inside a region.  */\n+\t      continue;\n+\t    }\n+\t  if (!oacc_loop_or_target_p (outer_ctx->stmt))\n+\t    {\n+\t      /* Skip; not nested inside an OpenACC region.  */\n+\t      continue;\n+\t    }\n+\t  if (outer_type == GIMPLE_OMP_FOR)\n+\t    outer_ctx->gwv_below |= val;\n+\t  if (OMP_CLAUSE_OPERAND (c, 0) != NULL_TREE)\n+\t    {\n+\t      omp_context *enclosing = enclosing_target_ctx (outer_ctx);\n+\t      if (gimple_omp_target_kind (enclosing->stmt)\n+\t\t  == GF_OMP_TARGET_KIND_OACC_PARALLEL)\n+\t\terror_at (gimple_location (stmt),\n+\t\t\t  \"no arguments allowed to gang, worker and vector clauses inside parallel\");\n+\t    }\n+\t}\n+    }\n+\n+  scan_sharing_clauses (clauses, ctx);\n \n   scan_omp (gimple_omp_for_pre_body_ptr (stmt), ctx);\n   for (i = 0; i < gimple_omp_for_collapse (stmt); i++)\n@@ -2332,6 +2612,19 @@ scan_omp_for (gomp_for *stmt, omp_context *outer_ctx)\n       scan_omp_op (gimple_omp_for_incr_ptr (stmt, i), ctx);\n     }\n   scan_omp (gimple_omp_body_ptr (stmt), ctx);\n+\n+  if (is_gimple_omp_oacc (stmt))\n+    {\n+      if (ctx->gwv_this & ctx->gwv_below)\n+\terror_at (gimple_location (stmt),\n+\t\t  \"gang, worker and vector may occur only once in a loop nest\");\n+      else if (ctx->gwv_below != 0\n+\t       && ctx->gwv_this > ctx->gwv_below)\n+\terror_at (gimple_location (stmt),\n+\t\t  \"gang, worker and vector must occur in this order in a loop nest\");\n+      if (outer_ctx && outer_type == GIMPLE_OMP_FOR)\n+\touter_ctx->gwv_below |= ctx->gwv_below;\n+    }\n }\n \n /* Scan an OpenMP sections directive.  */\n@@ -2371,14 +2664,15 @@ scan_omp_single (gomp_single *stmt, omp_context *outer_ctx)\n     layout_type (ctx->record_type);\n }\n \n-/* Scan an OpenMP target{, data, update} directive.  */\n+/* Scan a GIMPLE_OMP_TARGET.  */\n \n static void\n scan_omp_target (gomp_target *stmt, omp_context *outer_ctx)\n {\n   omp_context *ctx;\n   tree name;\n-  int kind = gimple_omp_target_kind (stmt);\n+  bool offloaded = is_gimple_omp_offloaded (stmt);\n+  tree clauses = gimple_omp_target_clauses (stmt);\n \n   ctx = new_omp_context (stmt, outer_ctx);\n   ctx->field_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n@@ -2390,13 +2684,30 @@ scan_omp_target (gomp_target *stmt, omp_context *outer_ctx)\n   DECL_ARTIFICIAL (name) = 1;\n   DECL_NAMELESS (name) = 1;\n   TYPE_NAME (ctx->record_type) = name;\n-  if (kind == GF_OMP_TARGET_KIND_REGION)\n+  if (offloaded)\n     {\n+      if (is_gimple_omp_oacc (stmt))\n+\tctx->reduction_map = splay_tree_new (splay_tree_compare_pointers,\n+\t\t\t\t\t     0, 0);\n+\n       create_omp_child_function (ctx, false);\n       gimple_omp_target_set_child_fn (stmt, ctx->cb.dst_fn);\n     }\n \n-  scan_sharing_clauses (gimple_omp_target_clauses (stmt), ctx);\n+  if (is_gimple_omp_oacc (stmt))\n+    {\n+      for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+\t{\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_NUM_GANGS)\n+\t    ctx->gwv_this |= MASK_GANG;\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_NUM_WORKERS)\n+\t    ctx->gwv_this |= MASK_WORKER;\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_VECTOR_LENGTH)\n+\t    ctx->gwv_this |= MASK_VECTOR;\n+\t}\n+    }\n+\n+  scan_sharing_clauses (clauses, ctx);\n   scan_omp (gimple_omp_body_ptr (stmt), ctx);\n \n   if (TYPE_FIELDS (ctx->record_type) == NULL)\n@@ -2414,7 +2725,7 @@ scan_omp_target (gomp_target *stmt, omp_context *outer_ctx)\n \tgcc_assert (DECL_ALIGN (field) == align);\n #endif\n       layout_type (ctx->record_type);\n-      if (kind == GF_OMP_TARGET_KIND_REGION)\n+      if (offloaded)\n \tfixup_child_record_type (ctx);\n     }\n }\n@@ -2429,10 +2740,25 @@ scan_omp_teams (gomp_teams *stmt, omp_context *outer_ctx)\n   scan_omp (gimple_omp_body_ptr (stmt), ctx);\n }\n \n-/* Check OpenMP nesting restrictions.  */\n+/* Check nesting restrictions.  */\n static bool\n check_omp_nesting_restrictions (gimple stmt, omp_context *ctx)\n {\n+  /* No nesting of non-OpenACC STMT (that is, an OpenMP one, or a GOMP builtin)\n+     inside an OpenACC CTX.  */\n+  if (!(is_gimple_omp (stmt)\n+\t&& is_gimple_omp_oacc (stmt)))\n+    {\n+      for (omp_context *ctx_ = ctx; ctx_ != NULL; ctx_ = ctx_->outer)\n+\tif (is_gimple_omp (ctx_->stmt)\n+\t    && is_gimple_omp_oacc (ctx_->stmt))\n+\t  {\n+\t    error_at (gimple_location (stmt),\n+\t\t      \"non-OpenACC construct inside of OpenACC region\");\n+\t    return false;\n+\t  }\n+    }\n+\n   if (ctx != NULL)\n     {\n       if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n@@ -2693,19 +3019,74 @@ check_omp_nesting_restrictions (gimple stmt, omp_context *ctx)\n       break;\n     case GIMPLE_OMP_TARGET:\n       for (; ctx != NULL; ctx = ctx->outer)\n-\tif (is_targetreg_ctx (ctx))\n-\t  {\n-\t    const char *name;\n-\t    switch (gimple_omp_target_kind (stmt))\n-\t      {\n-\t      case GF_OMP_TARGET_KIND_REGION: name = \"target\"; break;\n-\t      case GF_OMP_TARGET_KIND_DATA: name = \"target data\"; break;\n-\t      case GF_OMP_TARGET_KIND_UPDATE: name = \"target update\"; break;\n-\t      default: gcc_unreachable ();\n-\t      }\n-\t    warning_at (gimple_location (stmt), 0,\n-\t\t\t\"%s construct inside of target region\", name);\n-\t  }\n+\t{\n+\t  if (gimple_code (ctx->stmt) != GIMPLE_OMP_TARGET)\n+\t    {\n+\t      if (is_gimple_omp (stmt)\n+\t\t  && is_gimple_omp_oacc (stmt)\n+\t\t  && is_gimple_omp (ctx->stmt))\n+\t\t{\n+\t\t  error_at (gimple_location (stmt),\n+\t\t\t    \"OpenACC construct inside of non-OpenACC region\");\n+\t\t  return false;\n+\t\t}\n+\t      continue;\n+\t    }\n+\n+\t  const char *stmt_name, *ctx_stmt_name;\n+\t  switch (gimple_omp_target_kind (stmt))\n+\t    {\n+\t    case GF_OMP_TARGET_KIND_REGION: stmt_name = \"target\"; break;\n+\t    case GF_OMP_TARGET_KIND_DATA: stmt_name = \"target data\"; break;\n+\t    case GF_OMP_TARGET_KIND_UPDATE: stmt_name = \"target update\"; break;\n+\t    case GF_OMP_TARGET_KIND_OACC_PARALLEL: stmt_name = \"parallel\"; break;\n+\t    case GF_OMP_TARGET_KIND_OACC_KERNELS: stmt_name = \"kernels\"; break;\n+\t    case GF_OMP_TARGET_KIND_OACC_DATA: stmt_name = \"data\"; break;\n+\t    case GF_OMP_TARGET_KIND_OACC_UPDATE: stmt_name = \"update\"; break;\n+\t    case GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA: stmt_name = \"enter/exit data\"; break;\n+\t    default: gcc_unreachable ();\n+\t    }\n+\t  switch (gimple_omp_target_kind (ctx->stmt))\n+\t    {\n+\t    case GF_OMP_TARGET_KIND_REGION: ctx_stmt_name = \"target\"; break;\n+\t    case GF_OMP_TARGET_KIND_DATA: ctx_stmt_name = \"target data\"; break;\n+\t    case GF_OMP_TARGET_KIND_OACC_PARALLEL: ctx_stmt_name = \"parallel\"; break;\n+\t    case GF_OMP_TARGET_KIND_OACC_KERNELS: ctx_stmt_name = \"kernels\"; break;\n+\t    case GF_OMP_TARGET_KIND_OACC_DATA: ctx_stmt_name = \"data\"; break;\n+\t    default: gcc_unreachable ();\n+\t    }\n+\n+\t  /* OpenACC/OpenMP mismatch?  */\n+\t  if (is_gimple_omp_oacc (stmt)\n+\t      != is_gimple_omp_oacc (ctx->stmt))\n+\t    {\n+\t      error_at (gimple_location (stmt),\n+\t\t\t\"%s %s construct inside of %s %s region\",\n+\t\t\t(is_gimple_omp_oacc (stmt)\n+\t\t\t ? \"OpenACC\" : \"OpenMP\"), stmt_name,\n+\t\t\t(is_gimple_omp_oacc (ctx->stmt)\n+\t\t\t ? \"OpenACC\" : \"OpenMP\"), ctx_stmt_name);\n+\t      return false;\n+\t    }\n+\t  if (is_gimple_omp_offloaded (ctx->stmt))\n+\t    {\n+\t      /* No GIMPLE_OMP_TARGET inside offloaded OpenACC CTX.  */\n+\t      if (is_gimple_omp_oacc (ctx->stmt))\n+\t\t{\n+\t\t  error_at (gimple_location (stmt),\n+\t\t\t    \"%s construct inside of %s region\",\n+\t\t\t    stmt_name, ctx_stmt_name);\n+\t\t  return false;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gcc_checking_assert (!is_gimple_omp_oacc (stmt));\n+\t\t  warning_at (gimple_location (stmt), 0,\n+\t\t\t      \"%s construct inside of %s region\",\n+\t\t\t      stmt_name, ctx_stmt_name);\n+\t\t}\n+\t    }\n+\t}\n       break;\n     default:\n       break;\n@@ -2717,7 +3098,7 @@ check_omp_nesting_restrictions (gimple stmt, omp_context *ctx)\n /* Helper function scan_omp.\n \n    Callback for walk_tree or operators in walk_gimple_stmt used to\n-   scan for OpenMP directives in TP.  */\n+   scan for OMP directives in TP.  */\n \n static tree\n scan_omp_1_op (tree *tp, int *walk_subtrees, void *data)\n@@ -2780,7 +3161,7 @@ setjmp_or_longjmp_p (const_tree fndecl)\n \n /* Helper function for scan_omp.\n \n-   Callback for walk_gimple_stmt used to scan for OpenMP directives in\n+   Callback for walk_gimple_stmt used to scan for OMP directives in\n    the current statement in GSI.  */\n \n static tree\n@@ -2793,7 +3174,7 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   if (gimple_has_location (stmt))\n     input_location = gimple_location (stmt);\n \n-  /* Check the OpenMP nesting restrictions.  */\n+  /* Check the nesting restrictions.  */\n   bool remove = false;\n   if (is_gimple_omp (stmt))\n     remove = !check_omp_nesting_restrictions (stmt, ctx);\n@@ -2901,7 +3282,7 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n \n /* Scan all the statements starting at the current statement.  CTX\n-   contains context information about the OpenMP directives and\n+   contains context information about the OMP directives and\n    clauses found during the scan.  */\n \n static void\n@@ -4086,6 +4467,57 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n     gimple_seq_add_stmt (stmt_list, gimple_build_label (label));\n }\n \n+static void\n+oacc_lower_reduction_var_helper (gimple_seq *stmt_seqp, omp_context *ctx,\n+\t\t\t\t tree tid, tree var, tree new_var)\n+{\n+  /* The atomic add at the end of the sum creates unnecessary\n+     write contention on accelerators.  To work around this,\n+     create an array to store the partial reductions. Later, in\n+     lower_omp_for (for openacc), the values of array will be\n+     combined.  */\n+\n+  tree t = NULL_TREE, array, x;\n+  tree type = get_base_type (var);\n+  gimple stmt;\n+\n+  /* Now insert the partial reductions into the array.  */\n+\n+  /* Find the reduction array.  */\n+\n+  tree ptype = build_pointer_type (type);\n+\n+  t = lookup_oacc_reduction (oacc_get_reduction_array_id (var), ctx);\n+  t = build_receiver_ref (t, false, ctx->outer);\n+\n+  array = create_tmp_var (ptype);\n+  gimplify_assign (array, t, stmt_seqp);\n+\n+  tree ptr = create_tmp_var (TREE_TYPE (array));\n+\n+  /* Find the reduction array.  */\n+\n+  /* testing a unary conversion.  */\n+  tree offset = create_tmp_var (sizetype);\n+  gimplify_assign (offset, TYPE_SIZE_UNIT (type),\n+\t\t   stmt_seqp);\n+  t = create_tmp_var (sizetype);\n+  gimplify_assign (t, unshare_expr (fold_build1 (NOP_EXPR, sizetype, tid)),\n+\t\t   stmt_seqp);\n+  stmt = gimple_build_assign (offset, MULT_EXPR, offset, t);\n+  gimple_seq_add_stmt (stmt_seqp, stmt);\n+\n+  /* Offset expression.  Does the POINTER_PLUS_EXPR take care\n+     of adding sizeof(var) to the array?  */\n+  ptr = create_tmp_var (ptype);\n+  stmt = gimple_build_assign (unshare_expr (ptr), POINTER_PLUS_EXPR, array,\n+\t\t\t      offset);\n+  gimple_seq_add_stmt (stmt_seqp, stmt);\n+\n+  /* Move the local sum to gfc$sum[i].  */\n+  x = unshare_expr (build_simple_mem_ref (ptr));\n+  stmt = gimplify_assign (x, new_var, stmt_seqp);\n+}\n \n /* Generate code to implement the REDUCTION clauses.  */\n \n@@ -4094,7 +4526,7 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n {\n   gimple_seq sub_seq = NULL;\n   gimple stmt;\n-  tree x, c;\n+  tree x, c, tid = NULL_TREE;\n   int count = 0;\n \n   /* SIMD reductions are handled in lower_rec_input_clauses.  */\n@@ -4119,6 +4551,17 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n   if (count == 0)\n     return;\n \n+  /* Initialize thread info for OpenACC.  */\n+  if (is_gimple_omp_oacc (ctx->stmt))\n+    {\n+      /* Get the current thread id.  */\n+      tree call = builtin_decl_explicit (BUILT_IN_GOACC_GET_THREAD_NUM);\n+      tid = create_tmp_var (TREE_TYPE (TREE_TYPE (call)));\n+      gimple stmt = gimple_build_call (call, 0);\n+      gimple_call_set_lhs (stmt, tid);\n+      gimple_seq_add_stmt (stmt_seqp, stmt);\n+    }\n+\n   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n     {\n       tree var, ref, new_var;\n@@ -4140,7 +4583,13 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n       if (code == MINUS_EXPR)\n         code = PLUS_EXPR;\n \n-      if (count == 1)\n+      if (is_gimple_omp_oacc (ctx->stmt))\n+\t{\n+\t  gcc_checking_assert (!OMP_CLAUSE_REDUCTION_PLACEHOLDER (c));\n+\n+\t  oacc_lower_reduction_var_helper (stmt_seqp, ctx, tid, var, new_var);\n+\t}\n+      else if (count == 1)\n \t{\n \t  tree addr = build_fold_addr_expr_loc (clause_loc, ref);\n \n@@ -4151,8 +4600,7 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \t  gimplify_and_add (x, stmt_seqp);\n \t  return;\n \t}\n-\n-      if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n+      else if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n \t{\n \t  tree placeholder = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);\n \n@@ -4175,6 +4623,9 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n \t}\n     }\n \n+  if (is_gimple_omp_oacc (ctx->stmt))\n+    return;\n+\n   stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_GOMP_ATOMIC_START),\n \t\t\t    0);\n   gimple_seq_add_stmt (stmt_seqp, stmt);\n@@ -6065,12 +6516,14 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   basic_block fin_bb;\n   gimple_stmt_iterator gsi;\n   edge ep;\n-  enum built_in_function get_num_threads = BUILT_IN_OMP_GET_NUM_THREADS;\n-  enum built_in_function get_thread_num = BUILT_IN_OMP_GET_THREAD_NUM;\n   bool broken_loop = region->cont == NULL;\n   tree *counts = NULL;\n   tree n1, n2, step;\n \n+  gcc_checking_assert ((gimple_omp_for_kind (fd->for_stmt)\n+\t\t\t!= GF_OMP_FOR_KIND_OACC_LOOP)\n+\t\t       || !inner_stmt);\n+\n   itype = type = TREE_TYPE (fd->loop.v);\n   if (POINTER_TYPE_P (type))\n     itype = signed_type_for (type);\n@@ -6094,12 +6547,6 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   gsi = gsi_last_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n-  if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_DISTRIBUTE)\n-    {\n-      get_num_threads = BUILT_IN_OMP_GET_NUM_TEAMS;\n-      get_thread_num = BUILT_IN_OMP_GET_TEAM_NUM;\n-    }\n-\n   if (fd->collapse > 1)\n     {\n       int first_zero_iter = -1;\n@@ -6158,14 +6605,30 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       gsi = gsi_last_bb (entry_bb);\n     }\n \n-  t = build_call_expr (builtin_decl_explicit (get_num_threads), 0);\n-  t = fold_convert (itype, t);\n-  nthreads = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+  switch (gimple_omp_for_kind (fd->for_stmt))\n+    {\n+    case GF_OMP_FOR_KIND_FOR:\n+      nthreads = builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS);\n+      threadid = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n+      break;\n+    case GF_OMP_FOR_KIND_DISTRIBUTE:\n+      nthreads = builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_TEAMS);\n+      threadid = builtin_decl_explicit (BUILT_IN_OMP_GET_TEAM_NUM);\n+      break;\n+    case GF_OMP_FOR_KIND_OACC_LOOP:\n+      nthreads = builtin_decl_explicit (BUILT_IN_GOACC_GET_NUM_THREADS);\n+      threadid = builtin_decl_explicit (BUILT_IN_GOACC_GET_THREAD_NUM);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  nthreads = build_call_expr (nthreads, 0);\n+  nthreads = fold_convert (itype, nthreads);\n+  nthreads = force_gimple_operand_gsi (&gsi, nthreads, true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n-\n-  t = build_call_expr (builtin_decl_explicit (get_thread_num), 0);\n-  t = fold_convert (itype, t);\n-  threadid = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+  threadid = build_call_expr (threadid, 0);\n+  threadid = fold_convert (itype, threadid);\n+  threadid = force_gimple_operand_gsi (&gsi, threadid, true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n \n   n1 = fd->loop.n1;\n@@ -6339,7 +6802,10 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   if (!gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     {\n       t = gimple_omp_return_lhs (gsi_stmt (gsi));\n-      gsi_insert_after (&gsi, build_omp_barrier (t), GSI_SAME_STMT);\n+      if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_OACC_LOOP)\n+\tgcc_checking_assert (t == NULL_TREE);\n+      else\n+\tgsi_insert_after (&gsi, build_omp_barrier (t), GSI_SAME_STMT);\n     }\n   gsi_remove (&gsi, true);\n \n@@ -6440,12 +6906,14 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   basic_block trip_update_bb = NULL, cont_bb, collapse_bb = NULL, fin_bb;\n   gimple_stmt_iterator gsi;\n   edge se;\n-  enum built_in_function get_num_threads = BUILT_IN_OMP_GET_NUM_THREADS;\n-  enum built_in_function get_thread_num = BUILT_IN_OMP_GET_THREAD_NUM;\n   bool broken_loop = region->cont == NULL;\n   tree *counts = NULL;\n   tree n1, n2, step;\n \n+  gcc_checking_assert ((gimple_omp_for_kind (fd->for_stmt)\n+\t\t\t!= GF_OMP_FOR_KIND_OACC_LOOP)\n+\t\t       || !inner_stmt);\n+\n   itype = type = TREE_TYPE (fd->loop.v);\n   if (POINTER_TYPE_P (type))\n     itype = signed_type_for (type);\n@@ -6473,12 +6941,6 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   gsi = gsi_last_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n-  if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_DISTRIBUTE)\n-    {\n-      get_num_threads = BUILT_IN_OMP_GET_NUM_TEAMS;\n-      get_thread_num = BUILT_IN_OMP_GET_TEAM_NUM;\n-    }\n-\n   if (fd->collapse > 1)\n     {\n       int first_zero_iter = -1;\n@@ -6537,14 +6999,30 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       gsi = gsi_last_bb (entry_bb);\n     }\n \n-  t = build_call_expr (builtin_decl_explicit (get_num_threads), 0);\n-  t = fold_convert (itype, t);\n-  nthreads = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+  switch (gimple_omp_for_kind (fd->for_stmt))\n+    {\n+    case GF_OMP_FOR_KIND_FOR:\n+      nthreads = builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_THREADS);\n+      threadid = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n+      break;\n+    case GF_OMP_FOR_KIND_DISTRIBUTE:\n+      nthreads = builtin_decl_explicit (BUILT_IN_OMP_GET_NUM_TEAMS);\n+      threadid = builtin_decl_explicit (BUILT_IN_OMP_GET_TEAM_NUM);\n+      break;\n+    case GF_OMP_FOR_KIND_OACC_LOOP:\n+      nthreads = builtin_decl_explicit (BUILT_IN_GOACC_GET_NUM_THREADS);\n+      threadid = builtin_decl_explicit (BUILT_IN_GOACC_GET_THREAD_NUM);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  nthreads = build_call_expr (nthreads, 0);\n+  nthreads = fold_convert (itype, nthreads);\n+  nthreads = force_gimple_operand_gsi (&gsi, nthreads, true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n-\n-  t = build_call_expr (builtin_decl_explicit (get_thread_num), 0);\n-  t = fold_convert (itype, t);\n-  threadid = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE,\n+  threadid = build_call_expr (threadid, 0);\n+  threadid = fold_convert (itype, threadid);\n+  threadid = force_gimple_operand_gsi (&gsi, threadid, true, NULL_TREE,\n \t\t\t\t       true, GSI_SAME_STMT);\n \n   n1 = fd->loop.n1;\n@@ -6735,7 +7213,10 @@ expand_omp_for_static_chunk (struct omp_region *region,\n   if (!gimple_omp_return_nowait_p (gsi_stmt (gsi)))\n     {\n       t = gimple_omp_return_lhs (gsi_stmt (gsi));\n-      gsi_insert_after (&gsi, build_omp_barrier (t), GSI_SAME_STMT);\n+      if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_OACC_LOOP)\n+\tgcc_checking_assert (t == NULL_TREE);\n+      else\n+\tgsi_insert_after (&gsi, build_omp_barrier (t), GSI_SAME_STMT);\n     }\n   gsi_remove (&gsi, true);\n \n@@ -7350,7 +7831,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n }\n \n \n-/* Expand the OpenMP loop defined by REGION.  */\n+/* Expand the OMP loop defined by REGION.  */\n \n static void\n expand_omp_for (struct omp_region *region, gimple inner_stmt)\n@@ -8290,56 +8771,83 @@ expand_omp_atomic (struct omp_region *region)\n }\n \n \n-/* Expand the OpenMP target{, data, update} directive starting at REGION.  */\n+/* Expand the GIMPLE_OMP_TARGET starting at REGION.  */\n \n static void\n expand_omp_target (struct omp_region *region)\n {\n   basic_block entry_bb, exit_bb, new_bb;\n-  struct function *child_cfun = NULL;\n-  tree child_fn = NULL_TREE, block, t;\n+  struct function *child_cfun;\n+  tree child_fn, block, t;\n   gimple_stmt_iterator gsi;\n   gomp_target *entry_stmt;\n   gimple stmt;\n   edge e;\n+  bool offloaded, data_region;\n \n   entry_stmt = as_a <gomp_target *> (last_stmt (region->entry));\n   new_bb = region->entry;\n-  int kind = gimple_omp_target_kind (entry_stmt);\n-  if (kind == GF_OMP_TARGET_KIND_REGION)\n+\n+  offloaded = is_gimple_omp_offloaded (entry_stmt);\n+  switch (gimple_omp_target_kind (entry_stmt))\n+    {\n+    case GF_OMP_TARGET_KIND_REGION:\n+    case GF_OMP_TARGET_KIND_UPDATE:\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL:\n+    case GF_OMP_TARGET_KIND_OACC_KERNELS:\n+    case GF_OMP_TARGET_KIND_OACC_UPDATE:\n+    case GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:\n+      data_region = false;\n+      break;\n+    case GF_OMP_TARGET_KIND_DATA:\n+    case GF_OMP_TARGET_KIND_OACC_DATA:\n+      data_region = true;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  child_fn = NULL_TREE;\n+  child_cfun = NULL;\n+  if (offloaded)\n     {\n       child_fn = gimple_omp_target_child_fn (entry_stmt);\n       child_cfun = DECL_STRUCT_FUNCTION (child_fn);\n     }\n \n+  /* Supported by expand_omp_taskreg, but not here.  */\n+  if (child_cfun != NULL)\n+    gcc_checking_assert (!child_cfun->cfg);\n+  gcc_checking_assert (!gimple_in_ssa_p (cfun));\n+\n   entry_bb = region->entry;\n   exit_bb = region->exit;\n \n-  if (kind == GF_OMP_TARGET_KIND_REGION)\n+  if (offloaded)\n     {\n       unsigned srcidx, dstidx, num;\n \n-      /* If the target region needs data sent from the parent\n+      /* If the offloading region needs data sent from the parent\n \t function, then the very first statement (except possible\n-\t tree profile counter updates) of the parallel body\n+\t tree profile counter updates) of the offloading body\n \t is a copy assignment .OMP_DATA_I = &.OMP_DATA_O.  Since\n \t &.OMP_DATA_O is passed as an argument to the child function,\n \t we need to replace it with the argument as seen by the child\n \t function.\n \n \t In most cases, this will end up being the identity assignment\n-\t .OMP_DATA_I = .OMP_DATA_I.  However, if the parallel body had\n+\t .OMP_DATA_I = .OMP_DATA_I.  However, if the offloading body had\n \t a function call that has been inlined, the original PARM_DECL\n \t .OMP_DATA_I may have been converted into a different local\n \t variable.  In which case, we need to keep the assignment.  */\n-      if (gimple_omp_target_data_arg (entry_stmt))\n+      tree data_arg = gimple_omp_target_data_arg (entry_stmt);\n+      if (data_arg)\n \t{\n \t  basic_block entry_succ_bb = single_succ (entry_bb);\n \t  gimple_stmt_iterator gsi;\n \t  tree arg;\n \t  gimple tgtcopy_stmt = NULL;\n-\t  tree sender\n-\t    = TREE_VEC_ELT (gimple_omp_target_data_arg (entry_stmt), 0);\n+\t  tree sender = TREE_VEC_ELT (data_arg, 0);\n \n \t  for (gsi = gsi_start_bb (entry_succ_bb); ; gsi_next (&gsi))\n \t    {\n@@ -8374,7 +8882,7 @@ expand_omp_target (struct omp_region *region)\n       /* Declare local variables needed in CHILD_CFUN.  */\n       block = DECL_INITIAL (child_fn);\n       BLOCK_VARS (block) = vec2chain (child_cfun->local_decls);\n-      /* The gimplifier could record temporaries in target block\n+      /* The gimplifier could record temporaries in the offloading block\n \t rather than in containing function's local_decls chain,\n \t which would mean cgraph missed finalizing them.  Do it now.  */\n       for (t = BLOCK_VARS (block); t; t = DECL_CHAIN (t))\n@@ -8391,13 +8899,12 @@ expand_omp_target (struct omp_region *region)\n       for (t = DECL_ARGUMENTS (child_fn); t; t = DECL_CHAIN (t))\n \tDECL_CONTEXT (t) = child_fn;\n \n-      /* Split ENTRY_BB at GIMPLE_OMP_TARGET,\n+      /* Split ENTRY_BB at GIMPLE_*,\n \t so that it can be moved to the child function.  */\n       gsi = gsi_last_bb (entry_bb);\n       stmt = gsi_stmt (gsi);\n-      gcc_assert (stmt && gimple_code (stmt) == GIMPLE_OMP_TARGET\n-\t\t  && gimple_omp_target_kind (stmt)\n-\t\t     == GF_OMP_TARGET_KIND_REGION);\n+      gcc_assert (stmt\n+\t\t  && gimple_code (stmt) == gimple_code (entry_stmt));\n       gsi_remove (&gsi, true);\n       e = split_block (entry_bb, stmt);\n       entry_bb = e->dest;\n@@ -8414,7 +8921,7 @@ expand_omp_target (struct omp_region *region)\n \t  gsi_remove (&gsi, true);\n \t}\n \n-      /* Move the target region into CHILD_CFUN.  */\n+      /* Move the offloading region into CHILD_CFUN.  */\n \n       block = gimple_block (entry_stmt);\n \n@@ -8478,25 +8985,46 @@ expand_omp_target (struct omp_region *region)\n       pop_cfun ();\n     }\n \n-  /* Emit a library call to launch the target region, or do data\n+  /* Emit a library call to launch the offloading region, or do data\n      transfers.  */\n   tree t1, t2, t3, t4, device, cond, c, clauses;\n   enum built_in_function start_ix;\n   location_t clause_loc;\n \n-  clauses = gimple_omp_target_clauses (entry_stmt);\n+  switch (gimple_omp_target_kind (entry_stmt))\n+    {\n+    case GF_OMP_TARGET_KIND_REGION:\n+      start_ix = BUILT_IN_GOMP_TARGET;\n+      break;\n+    case GF_OMP_TARGET_KIND_DATA:\n+      start_ix = BUILT_IN_GOMP_TARGET_DATA;\n+      break;\n+    case GF_OMP_TARGET_KIND_UPDATE:\n+      start_ix = BUILT_IN_GOMP_TARGET_UPDATE;\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL:\n+    case GF_OMP_TARGET_KIND_OACC_KERNELS:\n+      start_ix = BUILT_IN_GOACC_PARALLEL;\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_DATA:\n+      start_ix = BUILT_IN_GOACC_DATA_START;\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_UPDATE:\n+      start_ix = BUILT_IN_GOACC_UPDATE;\n+      break;\n+    case GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:\n+      start_ix = BUILT_IN_GOACC_ENTER_EXIT_DATA;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n \n-  if (kind == GF_OMP_TARGET_KIND_REGION)\n-    start_ix = BUILT_IN_GOMP_TARGET;\n-  else if (kind == GF_OMP_TARGET_KIND_DATA)\n-    start_ix = BUILT_IN_GOMP_TARGET_DATA;\n-  else\n-    start_ix = BUILT_IN_GOMP_TARGET_UPDATE;\n+  clauses = gimple_omp_target_clauses (entry_stmt);\n \n-  /* By default, the value of DEVICE is -1 (let runtime library choose)\n-     and there is no conditional.  */\n+  /* By default, the value of DEVICE is GOMP_DEVICE_ICV (let runtime\n+     library choose) and there is no conditional.  */\n   cond = NULL_TREE;\n-  device = build_int_cst (integer_type_node, -1);\n+  device = build_int_cst (integer_type_node, GOMP_DEVICE_ICV);\n \n   c = find_omp_clause (clauses, OMP_CLAUSE_IF);\n   if (c)\n@@ -8505,6 +9033,12 @@ expand_omp_target (struct omp_region *region)\n   c = find_omp_clause (clauses, OMP_CLAUSE_DEVICE);\n   if (c)\n     {\n+      /* Even if we pass it to all library function calls, it is currently only\n+\t defined/used for the OpenMP target ones.  */\n+      gcc_checking_assert (start_ix == BUILT_IN_GOMP_TARGET\n+\t\t\t   || start_ix == BUILT_IN_GOMP_TARGET_DATA\n+\t\t\t   || start_ix == BUILT_IN_GOMP_TARGET_UPDATE);\n+\n       device = OMP_CLAUSE_DEVICE_ID (c);\n       clause_loc = OMP_CLAUSE_LOCATION (c);\n     }\n@@ -8515,7 +9049,7 @@ expand_omp_target (struct omp_region *region)\n   device = fold_convert_loc (clause_loc, integer_type_node, device);\n \n   /* If we found the clause 'if (cond)', build\n-     (cond ? device : -2).  */\n+     (cond ? device : GOMP_DEVICE_HOST_FALLBACK).  */\n   if (cond)\n     {\n       cond = gimple_boolify (cond);\n@@ -8525,14 +9059,14 @@ expand_omp_target (struct omp_region *region)\n       tree tmp_var;\n \n       tmp_var = create_tmp_var (TREE_TYPE (device));\n-      if (kind != GF_OMP_TARGET_KIND_REGION)\n+      if (offloaded)\n+\te = split_block (new_bb, NULL);\n+      else\n \t{\n \t  gsi = gsi_last_bb (new_bb);\n \t  gsi_prev (&gsi);\n \t  e = split_block (new_bb, gsi_stmt (gsi));\n \t}\n-      else\n-\te = split_block (new_bb, NULL);\n       cond_bb = e->src;\n       new_bb = e->dest;\n       remove_edge (e);\n@@ -8552,7 +9086,8 @@ expand_omp_target (struct omp_region *region)\n \n       gsi = gsi_start_bb (else_bb);\n       stmt = gimple_build_assign (tmp_var,\n-\t\t\t\t  build_int_cst (integer_type_node, -2));\n+\t\t\t\t  build_int_cst (integer_type_node,\n+\t\t\t\t\t\t GOMP_DEVICE_HOST_FALLBACK));\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n       make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n@@ -8584,28 +9119,124 @@ expand_omp_target (struct omp_region *region)\n     }\n \n   gimple g;\n-  /* FIXME: This will be address of\n-     extern char __OPENMP_TARGET__[] __attribute__((visibility (\"hidden\")))\n-     symbol, as soon as the linker plugin is able to create it for us.  */\n-  tree openmp_target = build_zero_cst (ptr_type_node);\n-  if (kind == GF_OMP_TARGET_KIND_REGION)\n-    {\n-      tree fnaddr = build_fold_addr_expr (child_fn);\n-      g = gimple_build_call (builtin_decl_explicit (start_ix), 7,\n-\t\t\t     device, fnaddr, openmp_target, t1, t2, t3, t4);\n+  tree offload_table = get_offload_symbol_decl ();\n+  vec<tree> *args;\n+  /* The maximum number used by any start_ix, without varargs.  */\n+  unsigned int argcnt = 12;\n+\n+  vec_alloc (args, argcnt);\n+  args->quick_push (device);\n+  if (offloaded)\n+    args->quick_push (build_fold_addr_expr (child_fn));\n+  args->quick_push (build_fold_addr_expr (offload_table));\n+  args->quick_push (t1);\n+  args->quick_push (t2);\n+  args->quick_push (t3);\n+  args->quick_push (t4);\n+  switch (start_ix)\n+    {\n+    case BUILT_IN_GOACC_DATA_START:\n+    case BUILT_IN_GOMP_TARGET:\n+    case BUILT_IN_GOMP_TARGET_DATA:\n+    case BUILT_IN_GOMP_TARGET_UPDATE:\n+      break;\n+    case BUILT_IN_GOACC_PARALLEL:\n+      {\n+\ttree t_num_gangs, t_num_workers, t_vector_length;\n+\n+\t/* Default values for num_gangs, num_workers, and vector_length.  */\n+\tt_num_gangs = t_num_workers = t_vector_length\n+\t  = fold_convert_loc (gimple_location (entry_stmt),\n+\t\t\t      integer_type_node, integer_one_node);\n+\t/* ..., but if present, use the value specified by the respective\n+\t   clause, making sure that are of the correct type.  */\n+\tc = find_omp_clause (clauses, OMP_CLAUSE_NUM_GANGS);\n+\tif (c)\n+\t  t_num_gangs = fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t  integer_type_node,\n+\t\t\t\t\t  OMP_CLAUSE_NUM_GANGS_EXPR (c));\n+\tc = find_omp_clause (clauses, OMP_CLAUSE_NUM_WORKERS);\n+\tif (c)\n+\t  t_num_workers = fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t    integer_type_node,\n+\t\t\t\t\t    OMP_CLAUSE_NUM_WORKERS_EXPR (c));\n+\tc = find_omp_clause (clauses, OMP_CLAUSE_VECTOR_LENGTH);\n+\tif (c)\n+\t  t_vector_length = fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t      integer_type_node,\n+\t\t\t\t\t      OMP_CLAUSE_VECTOR_LENGTH_EXPR (c));\n+\targs->quick_push (t_num_gangs);\n+\targs->quick_push (t_num_workers);\n+\targs->quick_push (t_vector_length);\n+      }\n+      /* FALLTHRU */\n+    case BUILT_IN_GOACC_ENTER_EXIT_DATA:\n+    case BUILT_IN_GOACC_UPDATE:\n+      {\n+\ttree t_async;\n+\tint t_wait_idx;\n+\n+\t/* Default values for t_async.  */\n+\tt_async = fold_convert_loc (gimple_location (entry_stmt),\n+\t\t\t\t    integer_type_node,\n+\t\t\t\t    build_int_cst (integer_type_node,\n+\t\t\t\t\t\t   GOMP_ASYNC_SYNC));\n+\t/* ..., but if present, use the value specified by the respective\n+\t   clause, making sure that is of the correct type.  */\n+\tc = find_omp_clause (clauses, OMP_CLAUSE_ASYNC);\n+\tif (c)\n+\t  t_async = fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t      integer_type_node,\n+\t\t\t\t      OMP_CLAUSE_ASYNC_EXPR (c));\n+\n+\targs->quick_push (t_async);\n+\t/* Save the index, and... */\n+\tt_wait_idx = args->length ();\n+\t/* ... push a default value.  */\n+\targs->quick_push (fold_convert_loc (gimple_location (entry_stmt),\n+\t\t\t\t\t    integer_type_node,\n+\t\t\t\t\t    integer_zero_node));\n+\tc = find_omp_clause (clauses, OMP_CLAUSE_WAIT);\n+\tif (c)\n+\t  {\n+\t    int n = 0;\n+\n+\t    for (; c; c = OMP_CLAUSE_CHAIN (c))\n+\t      {\n+\t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_WAIT)\n+\t\t  {\n+\t\t    args->safe_push (fold_convert_loc (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t       integer_type_node,\n+\t\t\t\t\t\t       OMP_CLAUSE_WAIT_EXPR (c)));\n+\t\t    n++;\n+\t\t  }\n+\t      }\n+\n+\t    /* Now that we know the number, replace the default value.  */\n+\t    args->ordered_remove (t_wait_idx);\n+\t    args->quick_insert (t_wait_idx,\n+\t\t\t\tfold_convert_loc (gimple_location (entry_stmt),\n+\t\t\t\t\t\t  integer_type_node,\n+\t\t\t\t\t\t  build_int_cst (integer_type_node, n)));\n+\t  }\n+      }\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    g = gimple_build_call (builtin_decl_explicit (start_ix), 6,\n-\t\t\t   device, openmp_target, t1, t2, t3, t4);\n+\n+  g = gimple_build_call_vec (builtin_decl_explicit (start_ix), *args);\n+  args->release ();\n   gimple_set_location (g, gimple_location (entry_stmt));\n   gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-  if (kind != GF_OMP_TARGET_KIND_REGION)\n+  if (!offloaded)\n     {\n       g = gsi_stmt (gsi);\n       gcc_assert (g && gimple_code (g) == GIMPLE_OMP_TARGET);\n       gsi_remove (&gsi, true);\n     }\n-  if (kind == GF_OMP_TARGET_KIND_DATA && region->exit)\n+  if (data_region\n+      && region->exit)\n     {\n       gsi = gsi_last_bb (region->exit);\n       g = gsi_stmt (gsi);\n@@ -8737,7 +9368,6 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,\n \t  region->exit = bb;\n \t  parent = parent->outer;\n \t}\n-\n       else if (code == GIMPLE_OMP_CONTINUE)\n \t{\n \t  gcc_assert (parent);\n@@ -8747,17 +9377,34 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent,\n \t{\n \t  /* GIMPLE_OMP_SECTIONS_SWITCH is part of\n \t     GIMPLE_OMP_SECTIONS, and we do nothing for it.  */\n-\t  ;\n \t}\n-      else if (code == GIMPLE_OMP_TARGET\n-\t       && gimple_omp_target_kind (stmt) == GF_OMP_TARGET_KIND_UPDATE)\n-\tnew_omp_region (bb, code, parent);\n       else\n \t{\n-\t  /* Otherwise, this directive becomes the parent for a new\n-\t     region.  */\n \t  region = new_omp_region (bb, code, parent);\n-\t  parent = region;\n+\t  /* Otherwise...  */\n+\t  if (code == GIMPLE_OMP_TARGET)\n+\t    {\n+\t      switch (gimple_omp_target_kind (stmt))\n+\t\t{\n+\t\tcase GF_OMP_TARGET_KIND_REGION:\n+\t\tcase GF_OMP_TARGET_KIND_DATA:\n+\t\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL:\n+\t\tcase GF_OMP_TARGET_KIND_OACC_KERNELS:\n+\t\tcase GF_OMP_TARGET_KIND_OACC_DATA:\n+\t\t  break;\n+\t\tcase GF_OMP_TARGET_KIND_UPDATE:\n+\t\tcase GF_OMP_TARGET_KIND_OACC_UPDATE:\n+\t\tcase GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:\n+\t\t  /* ..., other than for those stand-alone directives...  */\n+\t\t  region = NULL;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t    }\n+\t  /* ..., this directive becomes the parent for a new region.  */\n+\t  if (region)\n+\t    parent = region;\n \t}\n     }\n \n@@ -8866,11 +9513,12 @@ class pass_expand_omp : public gimple_opt_pass\n   /* opt_pass methods: */\n   virtual unsigned int execute (function *)\n     {\n-      bool gate = ((flag_openmp != 0 || flag_openmp_simd != 0\n-\t\t    || flag_cilkplus != 0) && !seen_error ());\n+      bool gate = ((flag_cilkplus != 0 || flag_openacc != 0 || flag_openmp != 0\n+\t\t    || flag_openmp_simd != 0)\n+\t\t   && !seen_error ());\n \n       /* This pass always runs, to provide PROP_gimple_eomp.\n-\t But there is nothing to do unless -fopenmp is given.  */\n+\t But often, there is nothing to do.  */\n       if (!gate)\n \treturn 0;\n \n@@ -8926,7 +9574,394 @@ make_pass_expand_omp_ssa (gcc::context *ctxt)\n   return new pass_expand_omp_ssa (ctxt);\n }\n \f\n-/* Routines to lower OpenMP directives into OMP-GIMPLE.  */\n+/* Routines to lower OMP directives into OMP-GIMPLE.  */\n+\n+/* Helper function to preform, potentially COMPLEX_TYPE, operation and\n+   convert it to gimple.  */\n+static void\n+oacc_gimple_assign (tree dest, tree_code op, tree src, gimple_seq *seq)\n+{\n+  gimple stmt;\n+\n+  if (TREE_CODE (TREE_TYPE (dest)) != COMPLEX_TYPE)\n+    {\n+      stmt = gimple_build_assign (dest, op, dest, src);\n+      gimple_seq_add_stmt (seq, stmt);\n+      return;\n+    }\n+\n+  tree t = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n+  tree rdest = fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (dest)), dest);\n+  gimplify_assign (t, rdest, seq);\n+  rdest = t;\n+\n+  t = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n+  tree idest = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (dest)), dest);\n+  gimplify_assign (t, idest, seq);\n+  idest = t;\n+\n+  t = create_tmp_var (TREE_TYPE (TREE_TYPE (src)));\n+  tree rsrc = fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (src)), src);\n+  gimplify_assign (t, rsrc, seq);\n+  rsrc = t;\n+\n+  t = create_tmp_var (TREE_TYPE (TREE_TYPE (src)));\n+  tree isrc = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (src)), src);\n+  gimplify_assign (t, isrc, seq);\n+  isrc = t;\n+\n+  tree r = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n+  tree i = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n+  tree result;\n+\n+  if (op == PLUS_EXPR)\n+    {\n+      stmt = gimple_build_assign (r, op, rdest, rsrc);\n+      gimple_seq_add_stmt (seq, stmt);\n+\n+      stmt = gimple_build_assign (i, op, idest, isrc);\n+      gimple_seq_add_stmt (seq, stmt);\n+    }\n+  else if (op == MULT_EXPR)\n+    {\n+      /* Let x = a + ib = dest, y = c + id = src.\n+\t x * y = (ac - bd) + i(ad + bc)  */\n+      tree ac = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n+      tree bd = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n+      tree ad = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n+      tree bc = create_tmp_var (TREE_TYPE (TREE_TYPE (dest)));\n+\n+      stmt = gimple_build_assign (ac, MULT_EXPR, rdest, rsrc);\n+      gimple_seq_add_stmt (seq, stmt);\n+\n+      stmt = gimple_build_assign (bd, MULT_EXPR, idest, isrc);\n+      gimple_seq_add_stmt (seq, stmt);\n+\n+      stmt = gimple_build_assign (r, MINUS_EXPR, ac, bd);\n+      gimple_seq_add_stmt (seq, stmt);\n+\n+      stmt = gimple_build_assign (ad, MULT_EXPR, rdest, isrc);\n+      gimple_seq_add_stmt (seq, stmt);\n+\n+      stmt = gimple_build_assign (bd, MULT_EXPR, idest, rsrc);\n+      gimple_seq_add_stmt (seq, stmt);\n+\n+      stmt = gimple_build_assign (i, PLUS_EXPR, ad, bc);\n+      gimple_seq_add_stmt (seq, stmt);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  result = build2 (COMPLEX_EXPR, TREE_TYPE (dest), r, i);\n+  gimplify_assign (dest, result, seq);\n+}\n+\n+/* Helper function to initialize local data for the reduction arrays.\n+   The reduction arrays need to be placed inside the calling function\n+   for accelerators, or else the host won't be able to preform the final\n+   reduction.  */\n+\n+static void\n+oacc_initialize_reduction_data (tree clauses, tree nthreads,\n+\t\t\t\tgimple_seq *stmt_seqp, omp_context *ctx)\n+{\n+  tree c, t, oc;\n+  gimple stmt;\n+  omp_context *octx;\n+\n+  /* Find the innermost OpenACC parallel context.  */\n+  if (gimple_code (ctx->stmt) == GIMPLE_OMP_TARGET\n+      && (gimple_omp_target_kind (ctx->stmt)\n+\t  == GF_OMP_TARGET_KIND_OACC_PARALLEL))\n+    octx = ctx;\n+  else\n+    octx = ctx->outer;\n+  gcc_checking_assert (gimple_code (octx->stmt) == GIMPLE_OMP_TARGET\n+\t\t       && (gimple_omp_target_kind (octx->stmt)\n+\t\t\t   == GF_OMP_TARGET_KIND_OACC_PARALLEL));\n+\n+  /* Extract the clauses.  */\n+  oc = gimple_omp_target_clauses (octx->stmt);\n+\n+  /* Find the last outer clause.  */\n+  for (; oc && OMP_CLAUSE_CHAIN (oc); oc = OMP_CLAUSE_CHAIN (oc))\n+    ;\n+\n+  /* Allocate arrays for each reduction variable.  */\n+  for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    {\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\tcontinue;\n+\n+      tree var = OMP_CLAUSE_DECL (c);\n+      tree type = get_base_type (var);\n+      tree array = lookup_oacc_reduction (oacc_get_reduction_array_id (var),\n+\t\t\t\t\t  ctx);\n+      tree size, call;\n+\n+      /* Calculate size of the reduction array.  */\n+      t = create_tmp_var (TREE_TYPE (nthreads));\n+      stmt = gimple_build_assign (t, MULT_EXPR, nthreads,\n+\t\t\t\t  fold_convert (TREE_TYPE (nthreads),\n+\t\t\t\t\t\tTYPE_SIZE_UNIT (type)));\n+      gimple_seq_add_stmt (stmt_seqp, stmt);\n+\n+      size = create_tmp_var (sizetype);\n+      gimplify_assign (size, fold_build1 (NOP_EXPR, sizetype, t), stmt_seqp);\n+\n+      /* Now allocate memory for it.  */\n+      call = unshare_expr (builtin_decl_explicit (BUILT_IN_ALLOCA));\n+      stmt = gimple_build_call (call, 1, size);\n+      gimple_call_set_lhs (stmt, array);\n+      gimple_seq_add_stmt (stmt_seqp, stmt);\n+\n+      /* Map this array into the accelerator.  */\n+\n+      /* Add the reduction array to the list of clauses.  */\n+      tree x = array;\n+      t = build_omp_clause (gimple_location (ctx->stmt), OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (t, GOMP_MAP_FORCE_FROM);\n+      OMP_CLAUSE_DECL (t) = x;\n+      OMP_CLAUSE_CHAIN (t) = NULL;\n+      if (oc)\n+\tOMP_CLAUSE_CHAIN (oc) = t;\n+      else\n+\tgimple_omp_target_set_clauses (as_a <gomp_target *> (octx->stmt), t);\n+      OMP_CLAUSE_SIZE (t) = size;\n+      oc = t;\n+    }\n+}\n+\n+/* Helper function to process the array of partial reductions.  Nthreads\n+   indicates the number of threads.  Unfortunately, GOACC_GET_NUM_THREADS\n+   cannot be used here, because nthreads on the host may be different than\n+   on the accelerator. */\n+\n+static void\n+oacc_finalize_reduction_data (tree clauses, tree nthreads,\n+\t\t\t      gimple_seq *stmt_seqp, omp_context *ctx)\n+{\n+  tree c, x, var, array, loop_header, loop_body, loop_exit, type;\n+  gimple stmt;\n+\n+  /* Create for loop.\n+\n+     let var = the original reduction variable\n+     let array = reduction variable array\n+\n+     for (i = 0; i < nthreads; i++)\n+       var op= array[i]\n+ */\n+\n+  loop_header = create_artificial_label (UNKNOWN_LOCATION);\n+  loop_body = create_artificial_label (UNKNOWN_LOCATION);\n+  loop_exit = create_artificial_label (UNKNOWN_LOCATION);\n+\n+  /* Create and initialize an index variable.  */\n+  tree ix = create_tmp_var (sizetype);\n+  gimplify_assign (ix, fold_build1 (NOP_EXPR, sizetype, integer_zero_node),\n+\t\t   stmt_seqp);\n+\n+  /* Insert the loop header label here.  */\n+  gimple_seq_add_stmt (stmt_seqp, gimple_build_label (loop_header));\n+\n+  /* Exit loop if ix >= nthreads.  */\n+  x = create_tmp_var (sizetype);\n+  gimplify_assign (x, fold_build1 (NOP_EXPR, sizetype, nthreads), stmt_seqp);\n+  stmt = gimple_build_cond (GE_EXPR, ix, x, loop_exit, loop_body);\n+  gimple_seq_add_stmt (stmt_seqp, stmt);\n+\n+  /* Insert the loop body label here.  */\n+  gimple_seq_add_stmt (stmt_seqp, gimple_build_label (loop_body));\n+\n+  /* Collapse each reduction array, one element at a time.  */\n+  for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    {\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION)\n+\tcontinue;\n+\n+      tree_code reduction_code = OMP_CLAUSE_REDUCTION_CODE (c);\n+\n+      /* reduction(-:var) sums up the partial results, so it acts\n+\t identically to reduction(+:var).  */\n+      if (reduction_code == MINUS_EXPR)\n+        reduction_code = PLUS_EXPR;\n+\n+      /* Set up reduction variable var.  */\n+      var = OMP_CLAUSE_DECL (c);\n+      type = get_base_type (var);\n+      array = lookup_oacc_reduction (oacc_get_reduction_array_id\n+\t\t\t\t     (OMP_CLAUSE_DECL (c)), ctx);\n+\n+      /* Calculate the array offset.  */\n+      tree offset = create_tmp_var (sizetype);\n+      gimplify_assign (offset, TYPE_SIZE_UNIT (type), stmt_seqp);\n+      stmt = gimple_build_assign (offset, MULT_EXPR, offset, ix);\n+      gimple_seq_add_stmt (stmt_seqp, stmt);\n+\n+      tree ptr = create_tmp_var (TREE_TYPE (array));\n+      stmt = gimple_build_assign (ptr, POINTER_PLUS_EXPR, array, offset);\n+      gimple_seq_add_stmt (stmt_seqp, stmt);\n+\n+      /* Extract array[ix] into mem.  */\n+      tree mem = create_tmp_var (type);\n+      gimplify_assign (mem, build_simple_mem_ref (ptr), stmt_seqp);\n+\n+      /* Find the original reduction variable.  */\n+      if (is_reference (var))\n+\tvar = build_simple_mem_ref (var);\n+\n+      tree t = create_tmp_var (type);\n+\n+      x = lang_hooks.decls.omp_clause_assign_op (c, t, var);\n+      gimplify_and_add (unshare_expr(x), stmt_seqp);\n+\n+      /* var = var op mem */\n+      switch (OMP_CLAUSE_REDUCTION_CODE (c))\n+\t{\n+\tcase TRUTH_ANDIF_EXPR:\n+\tcase TRUTH_ORIF_EXPR:\n+\t  t = fold_build2 (OMP_CLAUSE_REDUCTION_CODE (c), integer_type_node,\n+\t\t\t   t, mem);\n+\t  gimplify_and_add (t, stmt_seqp);\n+\t  break;\n+\tdefault:\n+\t  /* The lhs isn't a gimple_reg when var is COMPLEX_TYPE.  */\n+\t  oacc_gimple_assign (t, OMP_CLAUSE_REDUCTION_CODE (c), mem,\n+\t\t\t      stmt_seqp);\n+\t}\n+\n+      t = fold_build1 (NOP_EXPR, TREE_TYPE (var), t);\n+      x = lang_hooks.decls.omp_clause_assign_op (c, var, t);\n+      gimplify_and_add (unshare_expr(x), stmt_seqp);\n+    }\n+\n+  /* Increment the induction variable.  */\n+  tree one = fold_build1 (NOP_EXPR, sizetype, integer_one_node);\n+  stmt = gimple_build_assign (ix, PLUS_EXPR, ix, one);\n+  gimple_seq_add_stmt (stmt_seqp, stmt);\n+\n+  /* Go back to the top of the loop.  */\n+  gimple_seq_add_stmt (stmt_seqp, gimple_build_goto (loop_header));\n+\n+  /* Place the loop exit label here.  */\n+  gimple_seq_add_stmt (stmt_seqp, gimple_build_label (loop_exit));\n+}\n+\n+/* Scan through all of the gimple stmts searching for an OMP_FOR_EXPR, and\n+   scan that for reductions.  */\n+\n+static void\n+oacc_process_reduction_data (gimple_seq *body, gimple_seq *in_stmt_seqp,\n+\t\t\tgimple_seq *out_stmt_seqp, omp_context *ctx)\n+{\n+  gimple_stmt_iterator gsi;\n+  gimple_seq inner = NULL;\n+\n+  /* A collapse clause may have inserted a new bind block.  */\n+  gsi = gsi_start (*body);\n+  while (!gsi_end_p (gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      if (gbind *bind_stmt = dyn_cast <gbind *> (stmt))\n+\t{\n+\t  inner = gimple_bind_body (bind_stmt);\n+\t  body = &inner;\n+\t  gsi = gsi_start (*body);\n+\t}\n+      else if (dyn_cast <gomp_for *> (stmt))\n+\tbreak;\n+      else\n+\tgsi_next (&gsi);\n+    }\n+\n+  for (gsi = gsi_start (*body); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      tree clauses, nthreads, t, c, acc_device, acc_device_host, call,\n+\tenter, exit;\n+      bool reduction_found = false;\n+\n+      gimple stmt = gsi_stmt (gsi);\n+\n+      switch (gimple_code (stmt))\n+\t{\n+\tcase GIMPLE_OMP_FOR:\n+\t  clauses = gimple_omp_for_clauses (stmt);\n+\n+\t  /* Search for a reduction clause.  */\n+\t  for (c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+\t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION)\n+\t      {\n+\t\treduction_found = true;\n+\t\tbreak;\n+\t      }\n+\n+\t  if (!reduction_found)\n+\t    break;\n+\n+\t  ctx = maybe_lookup_ctx (stmt);\n+\t  t = NULL_TREE;\n+\n+\t  /* Extract the number of threads.  */\n+\t  nthreads = create_tmp_var (sizetype);\n+\t  t = oacc_max_threads (ctx);\n+\t  gimplify_assign (nthreads, t, in_stmt_seqp);\n+\n+\t  /* Determine if this is kernel will be executed on the host.  */\n+\t  call = builtin_decl_explicit (BUILT_IN_ACC_GET_DEVICE_TYPE);\n+\t  acc_device = create_tmp_var (integer_type_node, \".acc_device_type\");\n+\t  stmt = gimple_build_call (call, 0);\n+\t  gimple_call_set_lhs (stmt, acc_device);\n+\t  gimple_seq_add_stmt (in_stmt_seqp, stmt);\n+\n+\t  /* Set nthreads = 1 for ACC_DEVICE_TYPE=host.  */\n+\t  acc_device_host = create_tmp_var (integer_type_node,\n+\t\t\t\t\t    \".acc_device_host\");\n+\t  gimplify_assign (acc_device_host,\n+\t\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t\t  GOMP_DEVICE_HOST),\n+\t\t\t   in_stmt_seqp);\n+\n+\t  enter = create_artificial_label (UNKNOWN_LOCATION);\n+\t  exit = create_artificial_label (UNKNOWN_LOCATION);\n+\n+\t  stmt = gimple_build_cond (EQ_EXPR, acc_device, acc_device_host,\n+\t\t\t\t    enter, exit);\n+\t  gimple_seq_add_stmt (in_stmt_seqp, stmt);\n+\t  gimple_seq_add_stmt (in_stmt_seqp, gimple_build_label (enter));\n+\t  gimplify_assign (nthreads, fold_build1 (NOP_EXPR, sizetype,\n+\t\t\t\t\t\t  integer_one_node),\n+\t\t\t   in_stmt_seqp);\n+\t  gimple_seq_add_stmt (in_stmt_seqp, gimple_build_label (exit));\n+\n+\t  /* Also, set nthreads = 1 for ACC_DEVICE_TYPE=host_nonshm.  */\n+\t  gimplify_assign (acc_device_host,\n+\t\t\t   build_int_cst (integer_type_node,\n+\t\t\t\t\t  GOMP_DEVICE_HOST_NONSHM),\n+\t\t\t   in_stmt_seqp);\n+\n+\t  enter = create_artificial_label (UNKNOWN_LOCATION);\n+\t  exit = create_artificial_label (UNKNOWN_LOCATION);\n+\n+\t  stmt = gimple_build_cond (EQ_EXPR, acc_device, acc_device_host,\n+\t\t\t\t    enter, exit);\n+\t  gimple_seq_add_stmt (in_stmt_seqp, stmt);\n+\t  gimple_seq_add_stmt (in_stmt_seqp, gimple_build_label (enter));\n+\t  gimplify_assign (nthreads, fold_build1 (NOP_EXPR, sizetype,\n+\t\t\t\t\t\t  integer_one_node),\n+\t\t\t   in_stmt_seqp);\n+\t  gimple_seq_add_stmt (in_stmt_seqp, gimple_build_label (exit));\n+\n+\t  oacc_initialize_reduction_data (clauses, nthreads, in_stmt_seqp,\n+\t\t\t\t\t  ctx);\n+\t  oacc_finalize_reduction_data (clauses, nthreads, out_stmt_seqp, ctx);\n+\t  break;\n+\tdefault:\n+\t  // Scan for other directives which support reduction here.\n+\t  break;\n+\t}\n+    }\n+}\n \n /* If ctx is a worksharing context inside of a cancellable parallel\n    region and it isn't nowait, add lhs to its GIMPLE_OMP_RETURN\n@@ -9389,15 +10424,15 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       else\n \tdecl = *n;\n \n-      /* If '#pragma omp critical' is inside target region or\n+      /* If '#pragma omp critical' is inside offloaded region or\n \t inside function marked as offloadable, the symbol must be\n \t marked as offloadable too.  */\n       omp_context *octx;\n       if (cgraph_node::get (current_function_decl)->offloadable)\n \tvarpool_node::get_create (decl)->offloadable = 1;\n       else\n \tfor (octx = ctx->outer; octx; octx = octx->outer)\n-\t  if (is_targetreg_ctx (octx))\n+\t  if (is_gimple_omp_offloaded (octx->stmt))\n \t    {\n \t      varpool_node::get_create (decl)->offloadable = 1;\n \t      break;\n@@ -9499,7 +10534,7 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n }\n \n \n-/* Lower code for an OpenMP loop directive.  */\n+/* Lower code for an OMP loop directive.  */\n \n static void\n lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n@@ -10140,7 +11175,7 @@ lower_omp_taskreg (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     }\n }\n \n-/* Lower the OpenMP target directive in the current statement\n+/* Lower the GIMPLE_OMP_TARGET in the current statement\n    in GSI_P.  CTX holds context information for the directive.  */\n \n static void\n@@ -10149,24 +11184,52 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   tree clauses;\n   tree child_fn, t, c;\n   gomp_target *stmt = as_a <gomp_target *> (gsi_stmt (*gsi_p));\n-  gbind *tgt_bind = NULL, *bind;\n-  gimple_seq tgt_body = NULL, olist, ilist, new_body;\n+  gbind *tgt_bind, *bind;\n+  gimple_seq tgt_body, olist, ilist, orlist, irlist, new_body;\n   location_t loc = gimple_location (stmt);\n-  int kind = gimple_omp_target_kind (stmt);\n+  bool offloaded, data_region;\n   unsigned int map_cnt = 0;\n \n+  offloaded = is_gimple_omp_offloaded (stmt);\n+  switch (gimple_omp_target_kind (stmt))\n+    {\n+    case GF_OMP_TARGET_KIND_REGION:\n+    case GF_OMP_TARGET_KIND_UPDATE:\n+    case GF_OMP_TARGET_KIND_OACC_PARALLEL:\n+    case GF_OMP_TARGET_KIND_OACC_KERNELS:\n+    case GF_OMP_TARGET_KIND_OACC_UPDATE:\n+    case GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:\n+      data_region = false;\n+      break;\n+    case GF_OMP_TARGET_KIND_DATA:\n+    case GF_OMP_TARGET_KIND_OACC_DATA:\n+      data_region = true;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n   clauses = gimple_omp_target_clauses (stmt);\n-  if (kind == GF_OMP_TARGET_KIND_REGION)\n+\n+  tgt_bind = NULL;\n+  tgt_body = NULL;\n+  if (offloaded)\n     {\n       tgt_bind = gimple_seq_first_stmt_as_a_bind (gimple_omp_body (stmt));\n       tgt_body = gimple_bind_body (tgt_bind);\n     }\n-  else if (kind == GF_OMP_TARGET_KIND_DATA)\n+  else if (data_region)\n     tgt_body = gimple_omp_body (stmt);\n   child_fn = ctx->cb.dst_fn;\n \n   push_gimplify_context ();\n \n+  irlist = NULL;\n+  orlist = NULL;\n+  if (offloaded\n+      && is_gimple_omp_oacc (stmt))\n+    oacc_process_reduction_data (&tgt_body, &irlist, &orlist, ctx);\n+\n   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n     switch (OMP_CLAUSE_CODE (c))\n       {\n@@ -10175,6 +11238,31 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       default:\n \tbreak;\n       case OMP_CLAUSE_MAP:\n+#ifdef ENABLE_CHECKING\n+\t/* First check what we're prepared to handle in the following.  */\n+\tswitch (OMP_CLAUSE_MAP_KIND (c))\n+\t  {\n+\t  case GOMP_MAP_ALLOC:\n+\t  case GOMP_MAP_TO:\n+\t  case GOMP_MAP_FROM:\n+\t  case GOMP_MAP_TOFROM:\n+\t  case GOMP_MAP_POINTER:\n+\t  case GOMP_MAP_TO_PSET:\n+\t    break;\n+\t  case GOMP_MAP_FORCE_ALLOC:\n+\t  case GOMP_MAP_FORCE_TO:\n+\t  case GOMP_MAP_FORCE_FROM:\n+\t  case GOMP_MAP_FORCE_TOFROM:\n+\t  case GOMP_MAP_FORCE_PRESENT:\n+\t  case GOMP_MAP_FORCE_DEALLOC:\n+\t  case GOMP_MAP_FORCE_DEVICEPTR:\n+\t    gcc_assert (is_gimple_omp_oacc (stmt));\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+#endif\n+\t  /* FALLTHRU */\n       case OMP_CLAUSE_TO:\n       case OMP_CLAUSE_FROM:\n \tvar = OMP_CLAUSE_DECL (c);\n@@ -10199,12 +11287,11 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \tif (!maybe_lookup_field (var, ctx))\n \t  continue;\n \n-\tif (kind == GF_OMP_TARGET_KIND_REGION)\n+\tif (offloaded)\n \t  {\n \t    x = build_receiver_ref (var, true, ctx);\n \t    tree new_var = lookup_decl (var, ctx);\n-\t    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t&& OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER\n+\t    if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n \t\t&& !OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION (c)\n \t\t&& TREE_CODE (TREE_TYPE (var)) == ARRAY_TYPE)\n \t      x = build_simple_mem_ref (x);\n@@ -10214,16 +11301,16 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \tmap_cnt++;\n       }\n \n-  if (kind == GF_OMP_TARGET_KIND_REGION)\n+  if (offloaded)\n     {\n       target_nesting_level++;\n       lower_omp (&tgt_body, ctx);\n       target_nesting_level--;\n     }\n-  else if (kind == GF_OMP_TARGET_KIND_DATA)\n+  else if (data_region)\n     lower_omp (&tgt_body, ctx);\n \n-  if (kind == GF_OMP_TARGET_KIND_REGION)\n+  if (offloaded)\n     {\n       /* Declare all the variables created by mapping and the variables\n \t declared in the scope of the target body.  */\n@@ -10247,9 +11334,20 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       DECL_NAMELESS (TREE_VEC_ELT (t, 1)) = 1;\n       TREE_ADDRESSABLE (TREE_VEC_ELT (t, 1)) = 1;\n       TREE_STATIC (TREE_VEC_ELT (t, 1)) = 1;\n+      tree tkind_type;\n+      int talign_shift;\n+      if (is_gimple_omp_oacc (stmt))\n+\t{\n+\t  tkind_type = short_unsigned_type_node;\n+\t  talign_shift = 8;\n+\t}\n+      else\n+\t{\n+\t  tkind_type = unsigned_char_type_node;\n+\t  talign_shift = 3;\n+\t}\n       TREE_VEC_ELT (t, 2)\n-\t= create_tmp_var (build_array_type_nelts (unsigned_char_type_node,\n-\t\t\t\t\t\t  map_cnt),\n+\t= create_tmp_var (build_array_type_nelts (tkind_type, map_cnt),\n \t\t\t  \".omp_data_kinds\");\n       DECL_NAMELESS (TREE_VEC_ELT (t, 2)) = 1;\n       TREE_ADDRESSABLE (TREE_VEC_ELT (t, 2)) = 1;\n@@ -10315,12 +11413,18 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t      {\n \t\ttree var = lookup_decl_in_outer_ctx (ovar, ctx);\n \t\ttree x = build_sender_ref (ovar, ctx);\n-\t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n-\t\t    && OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER\n-\t\t    && !OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION (c)\n-\t\t    && TREE_CODE (TREE_TYPE (ovar)) == ARRAY_TYPE)\n+\t\tif (maybe_lookup_oacc_reduction (var, ctx))\n+\t\t  {\n+\t\t    gcc_checking_assert (offloaded\n+\t\t\t\t\t && is_gimple_omp_oacc (stmt));\n+\t\t    gimplify_assign (x, var, &ilist);\n+\t\t  }\n+\t\telse if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n+\t\t\t && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n+\t\t\t && !OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION (c)\n+\t\t\t && TREE_CODE (TREE_TYPE (ovar)) == ARRAY_TYPE)\n \t\t  {\n-\t\t    gcc_assert (kind == GF_OMP_TARGET_KIND_REGION);\n+\t\t    gcc_assert (offloaded);\n \t\t    tree avar\n \t\t      = create_tmp_var (TREE_TYPE (TREE_TYPE (x)));\n \t\t    mark_addressable (avar);\n@@ -10331,16 +11435,19 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t  }\n \t\telse if (is_gimple_reg (var))\n \t\t  {\n-\t\t    gcc_assert (kind == GF_OMP_TARGET_KIND_REGION);\n+\t\t    gcc_assert (offloaded);\n \t\t    tree avar = create_tmp_var (TREE_TYPE (var));\n \t\t    mark_addressable (avar);\n-\t\t    if (OMP_CLAUSE_MAP_KIND (c) != OMP_CLAUSE_MAP_ALLOC\n-\t\t\t&& OMP_CLAUSE_MAP_KIND (c) != OMP_CLAUSE_MAP_FROM)\n+\t\t    enum gomp_map_kind map_kind = OMP_CLAUSE_MAP_KIND (c);\n+\t\t    if (GOMP_MAP_COPY_TO_P (map_kind)\n+\t\t\t|| map_kind == GOMP_MAP_POINTER\n+\t\t\t|| map_kind == GOMP_MAP_TO_PSET\n+\t\t\t|| map_kind == GOMP_MAP_FORCE_DEVICEPTR)\n \t\t      gimplify_assign (avar, var, &ilist);\n \t\t    avar = build_fold_addr_expr (avar);\n \t\t    gimplify_assign (x, avar, &ilist);\n-\t\t    if ((OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_FROM\n-\t\t\t || OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_TOFROM)\n+\t\t    if ((GOMP_MAP_COPY_FROM_P (map_kind)\n+\t\t\t || map_kind == GOMP_MAP_FORCE_DEVICEPTR)\n \t\t\t&& !TYPE_READONLY (TREE_TYPE (var)))\n \t\t      {\n \t\t\tx = build_sender_ref (ovar, ctx);\n@@ -10363,26 +11470,29 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    if (TREE_CODE (s) != INTEGER_CST)\n \t      TREE_STATIC (TREE_VEC_ELT (t, 1)) = 0;\n \n-\t    unsigned char tkind = 0;\n+\t    unsigned HOST_WIDE_INT tkind;\n \t    switch (OMP_CLAUSE_CODE (c))\n \t      {\n \t      case OMP_CLAUSE_MAP:\n \t\ttkind = OMP_CLAUSE_MAP_KIND (c);\n \t\tbreak;\n \t      case OMP_CLAUSE_TO:\n-\t\ttkind = OMP_CLAUSE_MAP_TO;\n+\t\ttkind = GOMP_MAP_TO;\n \t\tbreak;\n \t      case OMP_CLAUSE_FROM:\n-\t\ttkind = OMP_CLAUSE_MAP_FROM;\n+\t\ttkind = GOMP_MAP_FROM;\n \t\tbreak;\n \t      default:\n \t\tgcc_unreachable ();\n \t      }\n+\t    gcc_checking_assert (tkind\n+\t\t\t\t < (HOST_WIDE_INT_C (1U) << talign_shift));\n \t    talign = ceil_log2 (talign);\n-\t    tkind |= talign << 3;\n+\t    tkind |= talign << talign_shift;\n+\t    gcc_checking_assert (tkind\n+\t\t\t\t <= tree_to_uhwi (TYPE_MAX_VALUE (tkind_type)));\n \t    CONSTRUCTOR_APPEND_ELT (vkind, purpose,\n-\t\t\t\t    build_int_cst (unsigned_char_type_node,\n-\t\t\t\t\t\t   tkind));\n+\t\t\t\t    build_int_cstu (tkind_type, tkind));\n \t    if (nc && nc != c)\n \t      c = nc;\n \t  }\n@@ -10420,7 +11530,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   new_body = NULL;\n \n-  if (ctx->record_type && kind == GF_OMP_TARGET_KIND_REGION)\n+  if (offloaded\n+      && ctx->record_type)\n     {\n       t = build_fold_addr_expr_loc (loc, ctx->sender_decl);\n       /* fixup_child_record_type might have changed receiver_decl's type.  */\n@@ -10429,14 +11540,14 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  \t\t   gimple_build_assign (ctx->receiver_decl, t));\n     }\n \n-  if (kind == GF_OMP_TARGET_KIND_REGION)\n+  if (offloaded)\n     {\n       gimple_seq_add_seq (&new_body, tgt_body);\n       new_body = maybe_catch_exception (new_body);\n     }\n-  else if (kind == GF_OMP_TARGET_KIND_DATA)\n+  else if (data_region)\n     new_body = tgt_body;\n-  if (kind != GF_OMP_TARGET_KIND_UPDATE)\n+  if (offloaded || data_region)\n     {\n       gimple_seq_add_stmt (&new_body, gimple_build_omp_return (false));\n       gimple_omp_set_body (stmt, new_body);\n@@ -10446,9 +11557,11 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t    tgt_bind ? gimple_bind_block (tgt_bind)\n \t\t\t\t     : NULL_TREE);\n   gsi_replace (gsi_p, bind, true);\n+  gimple_bind_add_seq (bind, irlist);\n   gimple_bind_add_seq (bind, ilist);\n   gimple_bind_add_stmt (bind, stmt);\n   gimple_bind_add_seq (bind, olist);\n+  gimple_bind_add_seq (bind, orlist);\n \n   pop_gimplify_context (NULL);\n }\n@@ -10520,7 +11633,7 @@ lower_omp_teams (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n /* Callback for lower_omp_1.  Return non-NULL if *tp needs to be\n    regimplified.  If DATA is non-NULL, lower_omp_1 is outside\n-   of OpenMP context, but with task_shared_vars set.  */\n+   of OMP context, but with task_shared_vars set.  */\n \n static tree\n lower_omp_regimplify_p (tree *tp, int *walk_subtrees,\n@@ -10560,7 +11673,7 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n     memset (&wi, '\\0', sizeof (wi));\n \n   /* If we have issued syntax errors, avoid doing any heavy lifting.\n-     Just replace the OpenMP directives with a NOP to avoid\n+     Just replace the OMP directives with a NOP to avoid\n      confusing RTL expansion.  */\n   if (seen_error () && is_gimple_omp (stmt))\n     {\n@@ -10747,8 +11860,8 @@ lower_omp (gimple_seq *body, omp_context *ctx)\n   gimple_stmt_iterator gsi;\n   for (gsi = gsi_start (*body); !gsi_end_p (gsi); gsi_next (&gsi))\n     lower_omp_1 (&gsi, ctx);\n-  /* During gimplification, we have not always invoked fold_stmt\n-     (gimplify.c:maybe_fold_stmt); call it now.  */\n+  /* During gimplification, we haven't folded statments inside offloading\n+     regions (gimplify.c:maybe_fold_stmt); do that now.  */\n   if (target_nesting_level)\n     for (gsi = gsi_start (*body); !gsi_end_p (gsi); gsi_next (&gsi))\n       fold_stmt (&gsi);\n@@ -10765,8 +11878,9 @@ execute_lower_omp (void)\n   omp_context *ctx;\n \n   /* This pass always runs, to provide PROP_gimple_lomp.\n-     But there is nothing to do unless -fopenmp is given.  */\n-  if (flag_openmp == 0 && flag_openmp_simd == 0 && flag_cilkplus == 0)\n+     But often, there is nothing to do.  */\n+  if (flag_cilkplus == 0 && flag_openacc == 0 && flag_openmp == 0\n+      && flag_openmp_simd == 0)\n     return 0;\n \n   all_contexts = splay_tree_new (splay_tree_compare_pointers, 0,\n@@ -10832,7 +11946,7 @@ make_pass_lower_omp (gcc::context *ctxt)\n   return new pass_lower_omp (ctxt);\n }\n \f\n-/* The following is a utility to diagnose OpenMP structured block violations.\n+/* The following is a utility to diagnose structured block violations.\n    It is not part of the \"omplower\" pass, as that's invoked too late.  It\n    should be invoked by the respective front ends after gimplification.  */\n \n@@ -10845,9 +11959,38 @@ static bool\n diagnose_sb_0 (gimple_stmt_iterator *gsi_p,\n     \t       gimple branch_ctx, gimple label_ctx)\n {\n+  gcc_checking_assert (!branch_ctx || is_gimple_omp (branch_ctx));\n+  gcc_checking_assert (!label_ctx || is_gimple_omp (label_ctx));\n+\n   if (label_ctx == branch_ctx)\n     return false;\n \n+  const char* kind = NULL;\n+\n+  if (flag_cilkplus)\n+    {\n+      if ((branch_ctx\n+\t   && gimple_code (branch_ctx) == GIMPLE_OMP_FOR\n+\t   && gimple_omp_for_kind (branch_ctx) == GF_OMP_FOR_KIND_CILKSIMD)\n+\t  || (label_ctx\n+\t      && gimple_code (label_ctx) == GIMPLE_OMP_FOR\n+\t      && gimple_omp_for_kind (label_ctx) == GF_OMP_FOR_KIND_CILKSIMD))\n+\tkind = \"Cilk Plus\";\n+    }\n+  if (flag_openacc)\n+    {\n+      if ((branch_ctx && is_gimple_omp_oacc (branch_ctx))\n+\t  || (label_ctx && is_gimple_omp_oacc (label_ctx)))\n+\t{\n+\t  gcc_checking_assert (kind == NULL);\n+\t  kind = \"OpenACC\";\n+\t}\n+    }\n+  if (kind == NULL)\n+    {\n+      gcc_checking_assert (flag_openmp);\n+      kind = \"OpenMP\";\n+    }\n \n   /*\n      Previously we kept track of the label's entire context in diagnose_sb_[12]\n@@ -10880,45 +12023,25 @@ diagnose_sb_0 (gimple_stmt_iterator *gsi_p,\n     }\n \n   if (exit_p)\n-    error (\"invalid exit from OpenMP structured block\");\n+    error (\"invalid exit from %s structured block\", kind);\n   else\n-    error (\"invalid entry to OpenMP structured block\");\n+    error (\"invalid entry to %s structured block\", kind);\n #endif\n \n-  bool cilkplus_block = false;\n-  if (flag_cilkplus)\n-    {\n-      if ((branch_ctx\n-\t   && gimple_code (branch_ctx) == GIMPLE_OMP_FOR\n-\t   && gimple_omp_for_kind (branch_ctx) == GF_OMP_FOR_KIND_CILKSIMD)\n-\t  || (label_ctx\n-\t      && gimple_code (label_ctx) == GIMPLE_OMP_FOR\n-\t      && gimple_omp_for_kind (label_ctx) == GF_OMP_FOR_KIND_CILKSIMD))\n-\tcilkplus_block = true;\n-    }\n-\n   /* If it's obvious we have an invalid entry, be specific about the error.  */\n   if (branch_ctx == NULL)\n-    {\n-      if (cilkplus_block)\n-\terror (\"invalid entry to Cilk Plus structured block\");\n-      else\n-\terror (\"invalid entry to OpenMP structured block\");\n-    }\n+    error (\"invalid entry to %s structured block\", kind);\n   else\n     {\n       /* Otherwise, be vague and lazy, but efficient.  */\n-      if (cilkplus_block)\n-\terror (\"invalid branch to/from a Cilk Plus structured block\");\n-      else\n-\terror (\"invalid branch to/from an OpenMP structured block\");\n+      error (\"invalid branch to/from %s structured block\", kind);\n     }\n \n   gsi_replace (gsi_p, gimple_build_nop (), false);\n   return true;\n }\n \n-/* Pass 1: Create a minimal tree of OpenMP structured blocks, and record\n+/* Pass 1: Create a minimal tree of structured blocks, and record\n    where each label is found.  */\n \n static tree\n@@ -10931,7 +12054,7 @@ diagnose_sb_1 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n \n   *handled_ops_p = true;\n \n- switch (gimple_code (stmt))\n+  switch (gimple_code (stmt))\n     {\n     WALK_SUBSTMTS;\n \n@@ -11079,8 +12202,8 @@ diagnose_sb_2 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n   return NULL_TREE;\n }\n \n-/* Called from tree-cfg.c::make_edges to create cfg edges for all GIMPLE_OMP\n-   codes.  */\n+/* Called from tree-cfg.c::make_edges to create cfg edges for all relevant\n+   GIMPLE_* codes.  */\n bool\n make_gimple_omp_edges (basic_block bb, struct omp_region **region,\n \t\t       int *region_idx)\n@@ -11109,8 +12232,22 @@ make_gimple_omp_edges (basic_block bb, struct omp_region **region,\n     case GIMPLE_OMP_TARGET:\n       cur_region = new_omp_region (bb, code, cur_region);\n       fallthru = true;\n-      if (gimple_omp_target_kind (last) == GF_OMP_TARGET_KIND_UPDATE)\n-\tcur_region = cur_region->outer;\n+      switch (gimple_omp_target_kind (last))\n+\t{\n+\tcase GF_OMP_TARGET_KIND_REGION:\n+\tcase GF_OMP_TARGET_KIND_DATA:\n+\tcase GF_OMP_TARGET_KIND_OACC_PARALLEL:\n+\tcase GF_OMP_TARGET_KIND_OACC_KERNELS:\n+\tcase GF_OMP_TARGET_KIND_OACC_DATA:\n+\t  break;\n+\tcase GF_OMP_TARGET_KIND_UPDATE:\n+\tcase GF_OMP_TARGET_KIND_OACC_UPDATE:\n+\tcase GF_OMP_TARGET_KIND_OACC_ENTER_EXIT_DATA:\n+\t  cur_region = cur_region->outer;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n       break;\n \n     case GIMPLE_OMP_SECTIONS:\n@@ -11247,7 +12384,10 @@ class pass_diagnose_omp_blocks : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_openmp || flag_cilkplus; }\n+  virtual bool gate (function *)\n+  {\n+    return flag_cilkplus || flag_openacc || flag_openmp;\n+  }\n   virtual unsigned int execute (function *)\n     {\n       return diagnose_omp_structured_block_errors ();\n@@ -12515,7 +13655,7 @@ add_decls_addresses_to_decl_constructor (vec<tree, va_gc> *v_decls,\n \n /* Create new symbols containing (address, size) pairs for global variables,\n    marked with \"omp declare target\" attribute, as well as addresses for the\n-   functions, which are outlined target regions.  */\n+   functions, which are outlined offloading regions.  */\n void\n omp_finish_file (void)\n {"}, {"sha": "885a710173706e32c1aa7e38a86e44eb5f5c5b9f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,133 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Ilmir Usmanov  <i.usmanov@samsung.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_fopenacc): New\n+\tprocedure.\n+\t* g++.dg/goacc-gomp/goacc-gomp.exp: New file.\n+\t* g++.dg/goacc/goacc.exp: Likewise.\n+\t* gcc.dg/goacc-gomp/goacc-gomp.exp: Likewise.\n+\t* gcc.dg/goacc/goacc.exp: Likewise.\n+\t* gfortran.dg/goacc/goacc.exp: Likewise.\n+\t* c-c++-common/cpp/openacc-define-1.c: New file.\n+\t* c-c++-common/cpp/openacc-define-2.c: Likewise.\n+\t* c-c++-common/cpp/openacc-define-3.c: Likewise.\n+\t* c-c++-common/goacc-gomp/nesting-1.c: Likewise.\n+\t* c-c++-common/goacc-gomp/nesting-fail-1.c: Likewise.\n+\t* c-c++-common/goacc/acc_on_device-2-off.c: Likewise.\n+\t* c-c++-common/goacc/acc_on_device-2.c: Likewise.\n+\t* c-c++-common/goacc/asyncwait-1.c: Likewise.\n+\t* c-c++-common/goacc/cache-1.c: Likewise.\n+\t* c-c++-common/goacc/clauses-fail.c: Likewise.\n+\t* c-c++-common/goacc/collapse-1.c: Likewise.\n+\t* c-c++-common/goacc/data-1.c: Likewise.\n+\t* c-c++-common/goacc/data-2.c: Likewise.\n+\t* c-c++-common/goacc/data-clause-duplicate-1.c: Likewise.\n+\t* c-c++-common/goacc/deviceptr-1.c: Likewise.\n+\t* c-c++-common/goacc/deviceptr-2.c: Likewise.\n+\t* c-c++-common/goacc/deviceptr-3.c: Likewise.\n+\t* c-c++-common/goacc/if-clause-1.c: Likewise.\n+\t* c-c++-common/goacc/if-clause-2.c: Likewise.\n+\t* c-c++-common/goacc/kernels-1.c: Likewise.\n+\t* c-c++-common/goacc/loop-1.c: Likewise.\n+\t* c-c++-common/goacc/loop-private-1.c: Likewise.\n+\t* c-c++-common/goacc/nesting-1.c: Likewise.\n+\t* c-c++-common/goacc/nesting-data-1.c: Likewise.\n+\t* c-c++-common/goacc/nesting-fail-1.c: Likewise.\n+\t* c-c++-common/goacc/parallel-1.c: Likewise.\n+\t* c-c++-common/goacc/pcopy.c: Likewise.\n+\t* c-c++-common/goacc/pcopyin.c: Likewise.\n+\t* c-c++-common/goacc/pcopyout.c: Likewise.\n+\t* c-c++-common/goacc/pcreate.c: Likewise.\n+\t* c-c++-common/goacc/pragma_context.c: Likewise.\n+\t* c-c++-common/goacc/present-1.c: Likewise.\n+\t* c-c++-common/goacc/reduction-1.c: Likewise.\n+\t* c-c++-common/goacc/reduction-2.c: Likewise.\n+\t* c-c++-common/goacc/reduction-3.c: Likewise.\n+\t* c-c++-common/goacc/reduction-4.c: Likewise.\n+\t* c-c++-common/goacc/sb-1.c: Likewise.\n+\t* c-c++-common/goacc/sb-2.c: Likewise.\n+\t* c-c++-common/goacc/sb-3.c: Likewise.\n+\t* c-c++-common/goacc/update-1.c: Likewise.\n+\t* gcc.dg/goacc/acc_on_device-1.c: Likewise.\n+\t* gfortran.dg/goacc/acc_on_device-1.f95: Likewise.\n+\t* gfortran.dg/goacc/acc_on_device-2-off.f95: Likewise.\n+\t* gfortran.dg/goacc/acc_on_device-2.f95: Likewise.\n+\t* gfortran.dg/goacc/assumed.f95: Likewise.\n+\t* gfortran.dg/goacc/asyncwait-1.f95: Likewise.\n+\t* gfortran.dg/goacc/asyncwait-2.f95: Likewise.\n+\t* gfortran.dg/goacc/asyncwait-3.f95: Likewise.\n+\t* gfortran.dg/goacc/asyncwait-4.f95: Likewise.\n+\t* gfortran.dg/goacc/branch.f95: Likewise.\n+\t* gfortran.dg/goacc/cache-1.f95: Likewise.\n+\t* gfortran.dg/goacc/coarray.f95: Likewise.\n+\t* gfortran.dg/goacc/continuation-free-form.f95: Likewise.\n+\t* gfortran.dg/goacc/cray.f95: Likewise.\n+\t* gfortran.dg/goacc/critical.f95: Likewise.\n+\t* gfortran.dg/goacc/data-clauses.f95: Likewise.\n+\t* gfortran.dg/goacc/data-tree.f95: Likewise.\n+\t* gfortran.dg/goacc/declare-1.f95: Likewise.\n+\t* gfortran.dg/goacc/enter-exit-data.f95: Likewise.\n+\t* gfortran.dg/goacc/fixed-1.f: Likewise.\n+\t* gfortran.dg/goacc/fixed-2.f: Likewise.\n+\t* gfortran.dg/goacc/fixed-3.f: Likewise.\n+\t* gfortran.dg/goacc/fixed-4.f: Likewise.\n+\t* gfortran.dg/goacc/host_data-tree.f95: Likewise.\n+\t* gfortran.dg/goacc/if.f95: Likewise.\n+\t* gfortran.dg/goacc/kernels-tree.f95: Likewise.\n+\t* gfortran.dg/goacc/list.f95: Likewise.\n+\t* gfortran.dg/goacc/literal.f95: Likewise.\n+\t* gfortran.dg/goacc/loop-1.f95: Likewise.\n+\t* gfortran.dg/goacc/loop-2.f95: Likewise.\n+\t* gfortran.dg/goacc/loop-3.f95: Likewise.\n+\t* gfortran.dg/goacc/loop-tree-1.f90: Likewise.\n+\t* gfortran.dg/goacc/omp.f95: Likewise.\n+\t* gfortran.dg/goacc/parallel-kernels-clauses.f95: Likewise.\n+\t* gfortran.dg/goacc/parallel-kernels-regions.f95: Likewise.\n+\t* gfortran.dg/goacc/parallel-tree.f95: Likewise.\n+\t* gfortran.dg/goacc/parameter.f95: Likewise.\n+\t* gfortran.dg/goacc/private-1.f95: Likewise.\n+\t* gfortran.dg/goacc/private-2.f95: Likewise.\n+\t* gfortran.dg/goacc/private-3.f95: Likewise.\n+\t* gfortran.dg/goacc/pure-elemental-procedures.f95: Likewise.\n+\t* gfortran.dg/goacc/reduction-2.f95: Likewise.\n+\t* gfortran.dg/goacc/reduction.f95: Likewise.\n+\t* gfortran.dg/goacc/routine-1.f90: Likewise.\n+\t* gfortran.dg/goacc/routine-2.f90: Likewise.\n+\t* gfortran.dg/goacc/sentinel-free-form.f95: Likewise.\n+\t* gfortran.dg/goacc/several-directives.f95: Likewise.\n+\t* gfortran.dg/goacc/sie.f95: Likewise.\n+\t* gfortran.dg/goacc/subarrays.f95: Likewise.\n+\t* gfortran.dg/gomp/map-1.f90: Likewise.\n+\t* gfortran.dg/openacc-define-1.f90: Likewise.\n+\t* gfortran.dg/openacc-define-2.f90: Likewise.\n+\t* gfortran.dg/openacc-define-3.f90: Likewise.\n+\t* g++.dg/gomp/block-1.C: Update for changed compiler output.\n+\t* g++.dg/gomp/block-2.C: Likewise.\n+\t* g++.dg/gomp/block-3.C: Likewise.\n+\t* g++.dg/gomp/block-5.C: Likewise.\n+\t* g++.dg/gomp/target-1.C: Likewise.\n+\t* g++.dg/gomp/target-2.C: Likewise.\n+\t* g++.dg/gomp/taskgroup-1.C: Likewise.\n+\t* g++.dg/gomp/teams-1.C: Likewise.\n+\t* gcc.dg/cilk-plus/jump-openmp.c: Likewise.\n+\t* gcc.dg/cilk-plus/jump.c: Likewise.\n+\t* gcc.dg/gomp/block-1.c: Likewise.\n+\t* gcc.dg/gomp/block-10.c: Likewise.\n+\t* gcc.dg/gomp/block-2.c: Likewise.\n+\t* gcc.dg/gomp/block-3.c: Likewise.\n+\t* gcc.dg/gomp/block-4.c: Likewise.\n+\t* gcc.dg/gomp/block-5.c: Likewise.\n+\t* gcc.dg/gomp/block-6.c: Likewise.\n+\t* gcc.dg/gomp/block-7.c: Likewise.\n+\t* gcc.dg/gomp/block-8.c: Likewise.\n+\t* gcc.dg/gomp/block-9.c: Likewise.\n+\t* gcc.dg/gomp/target-1.c: Likewise.\n+\t* gcc.dg/gomp/target-2.c: Likewise.\n+\t* gcc.dg/gomp/taskgroup-1.c: Likewise.\n+\t* gcc.dg/gomp/teams-1.c: Likewise.\n+\n 2015-01-15  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit.dg/test-error-mismatching-types-in-assignment-op.c: New"}, {"sha": "cd37548daffe1173e96546f07d90a66c5f776919", "filename": "gcc/testsuite/c-c++-common/cpp/openacc-define-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenacc-define-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenacc-define-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenacc-define-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do preprocess } */\n+/* { dg-require-effective-target fopenacc } */\n+\n+#ifdef _OPENACC\n+# error _OPENACC defined\n+#endif"}, {"sha": "b007e32bfc27dfcf83ab45ee651fa0f4b144ce26", "filename": "gcc/testsuite/c-c++-common/cpp/openacc-define-2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenacc-define-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenacc-define-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenacc-define-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-options \"-fno-openacc\" } */\n+/* { dg-do preprocess } */\n+/* { dg-require-effective-target fopenacc } */\n+\n+#ifdef _OPENACC\n+# error _OPENACC defined\n+#endif"}, {"sha": "ccedcd907828edd388e9cf122608e3f095fd9efb", "filename": "gcc/testsuite/c-c++-common/cpp/openacc-define-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenacc-define-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenacc-define-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcpp%2Fopenacc-define-3.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-options \"-fopenacc\" } */\n+/* { dg-do preprocess } */\n+/* { dg-require-effective-target fopenacc } */\n+\n+#ifndef _OPENACC\n+# error _OPENACC not defined\n+#endif\n+\n+#if _OPENACC != 201306\n+# error _OPENACC defined to wrong value\n+#endif"}, {"sha": "df45bcf05fcb373f3eeea5dff68335eb72ecd150", "filename": "gcc/testsuite/c-c++-common/goacc-gomp/nesting-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,12 @@\n+void\n+f_omp_parallel (void)\n+{\n+#pragma omp parallel\n+  {\n+    int i;\n+\n+#pragma acc loop\n+    for (i = 0; i < 2; ++i)\n+      ;\n+  }\n+}"}, {"sha": "411fb5f875580515fbff12288953b7dc1ecd9d5c", "filename": "gcc/testsuite/c-c++-common/goacc-gomp/nesting-fail-1.c", "status": "added", "additions": 457, "deletions": 0, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc-gomp%2Fnesting-fail-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,457 @@\n+extern int i;\n+\n+void\n+f_omp (void)\n+{\n+#pragma omp parallel\n+  {\n+#pragma acc parallel /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc kernels /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc data /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc update host(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc enter data copyin(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc exit data delete(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+  }\n+\n+#pragma omp for\n+  for (i = 0; i < 3; i++)\n+    {\n+#pragma acc parallel /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+      ;\n+#pragma acc kernels /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+      ;\n+#pragma acc data /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+      ;\n+#pragma acc update host(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc enter data copyin(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc exit data delete(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc loop /* { dg-error \"may not be closely nested\" } */\n+      for (i = 0; i < 2; ++i)\n+\t;\n+    }\n+\n+#pragma omp sections\n+  {\n+    {\n+#pragma acc parallel /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+      ;\n+    }\n+#pragma omp section\n+    {\n+#pragma acc kernels /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+      ;\n+    }\n+#pragma omp section\n+    {\n+#pragma acc data /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+      ;\n+    }\n+#pragma omp section\n+    {\n+#pragma acc update host(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    }\n+#pragma omp section\n+    {\n+#pragma acc enter data copyin(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    }\n+#pragma omp section\n+    {\n+#pragma acc exit data delete(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    }\n+#pragma omp section\n+    {\n+#pragma acc loop /* { dg-error \"may not be closely nested\" } */\n+      for (i = 0; i < 2; ++i)\n+\t;\n+    }\n+  }\n+\n+#pragma omp single\n+  {\n+#pragma acc parallel /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc kernels /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc data /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc update host(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc enter data copyin(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc exit data delete(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc loop /* { dg-error \"may not be closely nested\" } */\n+    for (i = 0; i < 2; ++i)\n+      ;\n+  }\n+\n+#pragma omp task\n+  {\n+#pragma acc parallel /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc kernels /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc data /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc update host(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc enter data copyin(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc exit data delete(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc loop /* { dg-error \"may not be closely nested\" } */\n+    for (i = 0; i < 2; ++i)\n+      ;\n+  }\n+\n+#pragma omp master\n+  {\n+#pragma acc parallel /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc kernels /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc data /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc update host(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc enter data copyin(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc exit data delete(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc loop /* { dg-error \"may not be closely nested\" } */\n+    for (i = 0; i < 2; ++i)\n+      ;\n+  }\n+\n+#pragma omp critical\n+  {\n+#pragma acc parallel /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc kernels /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc data /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc update host(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc enter data copyin(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc exit data delete(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc loop /* { dg-error \"may not be closely nested\" } */\n+    for (i = 0; i < 2; ++i)\n+      ;\n+  }\n+\n+#pragma omp ordered\n+  {\n+#pragma acc parallel /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc kernels /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc data /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+    ;\n+#pragma acc update host(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc enter data copyin(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc exit data delete(i) /* { dg-error \"OpenACC construct inside of non-OpenACC region\" } */\n+#pragma acc loop /* { dg-error \"may not be closely nested\" } */\n+    for (i = 0; i < 2; ++i)\n+      ;\n+  }\n+\n+#pragma omp target\n+  {\n+#pragma acc parallel /* { dg-error \"OpenACC parallel construct inside of OpenMP target region\" } */\n+    ;\n+#pragma acc kernels /* { dg-error \"OpenACC kernels construct inside of OpenMP target region\" } */\n+    ;\n+#pragma acc data /* { dg-error \"OpenACC data construct inside of OpenMP target region\" } */\n+    ;\n+#pragma acc update host(i) /* { dg-error \"OpenACC update construct inside of OpenMP target region\" } */\n+#pragma acc enter data copyin(i) /* { dg-error \"OpenACC enter/exit data construct inside of OpenMP target region\" } */\n+#pragma acc exit data delete(i) /* { dg-error \"OpenACC enter/exit data construct inside of OpenMP target region\" } */\n+#pragma acc loop\n+    for (i = 0; i < 2; ++i)\n+      ;\n+  }\n+}\n+\n+void\n+f_acc_parallel (void)\n+{\n+#pragma acc parallel\n+  {\n+#pragma omp parallel /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc parallel\n+  {\n+#pragma omp for /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    for (i = 0; i < 3; i++)\n+      ;\n+  }\n+\n+#pragma acc parallel\n+  {\n+#pragma omp sections /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    {\n+      ;\n+    }\n+  }\n+\n+#pragma acc parallel\n+  {\n+#pragma omp single /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc parallel\n+  {\n+#pragma omp task /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc parallel\n+  {\n+#pragma omp master /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc parallel\n+  {\n+#pragma omp critical /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc parallel\n+  {\n+#pragma omp atomic write\n+    i = 0; /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+  }\n+\n+#pragma acc parallel\n+  {\n+#pragma omp ordered /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc parallel\n+  {\n+#pragma omp target /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+#pragma omp target data /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+#pragma omp target update to(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+  }\n+}\n+\n+void\n+f_acc_kernels (void)\n+{\n+#pragma acc kernels\n+  {\n+#pragma omp parallel /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc kernels\n+  {\n+#pragma omp for /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    for (i = 0; i < 3; i++)\n+      ;\n+  }\n+\n+#pragma acc kernels\n+  {\n+#pragma omp sections /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    {\n+      ;\n+    }\n+  }\n+\n+#pragma acc kernels\n+  {\n+#pragma omp single /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc kernels\n+  {\n+#pragma omp task /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc kernels\n+  {\n+#pragma omp master /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc kernels\n+  {\n+#pragma omp critical /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc kernels\n+  {\n+#pragma omp atomic write\n+    i = 0; /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+  }\n+\n+#pragma acc kernels\n+  {\n+#pragma omp ordered /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc kernels\n+  {\n+#pragma omp target /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+#pragma omp target data /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+#pragma omp target update to(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+  }\n+}\n+\n+void\n+f_acc_data (void)\n+{\n+#pragma acc data\n+  {\n+#pragma omp parallel /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc data\n+  {\n+#pragma omp for /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    for (i = 0; i < 3; i++)\n+      ;\n+  }\n+\n+#pragma acc data\n+  {\n+#pragma omp sections /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    {\n+      ;\n+    }\n+  }\n+\n+#pragma acc data\n+  {\n+#pragma omp single /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc data\n+  {\n+#pragma omp task /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc data\n+  {\n+#pragma omp master /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc data\n+  {\n+#pragma omp critical /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc data\n+  {\n+#pragma omp atomic write\n+    i = 0; /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+  }\n+\n+#pragma acc data\n+  {\n+#pragma omp ordered /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+  }\n+\n+#pragma acc data\n+  {\n+#pragma omp target /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+#pragma omp target data /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    ;\n+#pragma omp target update to(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+  }\n+}\n+\n+void\n+f_acc_loop (void)\n+{\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp parallel /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+      ;\n+    }\n+\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp for /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+      for (i = 0; i < 3; i++)\n+\t;\n+    }\n+\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp sections /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+      {\n+\t;\n+      }\n+    }\n+\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp single /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+      ;\n+    }\n+\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp task /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+      ;\n+    }\n+\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp master /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+      ;\n+    }\n+\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp critical /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+      ;\n+    }\n+\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp atomic write\n+      i = 0; /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    }\n+\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp ordered /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+      ;\n+    }\n+\n+#pragma acc loop\n+  for (i = 0; i < 2; ++i)\n+    {\n+#pragma omp target /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+      ;\n+#pragma omp target data /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+      ;\n+#pragma omp target update to(i) /* { dg-error \"non-OpenACC construct inside of OpenACC region\" } */\n+    }\n+}"}, {"sha": "25d21ad29c90acfc49c6919dcd66c4372eb9a001", "filename": "gcc/testsuite/c-c++-common/goacc/acc_on_device-2-off.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Facc_on_device-2-off.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Facc_on_device-2-off.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Facc_on_device-2-off.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,25 @@\n+/* Have to enable optimizations, as otherwise builtins won't be expanded.  */\n+/* { dg-additional-options \"-O -fdump-rtl-expand -fno-openacc\" } */\n+\n+#if __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef enum acc_device_t { acc_device_X = 123 } acc_device_t;\n+extern int acc_on_device (acc_device_t);\n+\n+#if __cplusplus\n+}\n+#endif\n+\n+int\n+f (void)\n+{\n+  const acc_device_t dev = acc_device_X;\n+  return acc_on_device (dev);\n+}\n+\n+/* Without -fopenacc, we're expecting one call.\n+   { dg-final { scan-rtl-dump-times \"\\\\\\(call \\[^\\\\n\\]*\\\\\\\"acc_on_device\" 1 \"expand\" } } */\n+\n+/* { dg-final { cleanup-rtl-dump \"expand\" } } */"}, {"sha": "d5389a99072ccad0f14ed34f3393e499f173c525", "filename": "gcc/testsuite/c-c++-common/goacc/acc_on_device-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Facc_on_device-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Facc_on_device-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Facc_on_device-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,29 @@\n+/* Have to enable optimizations, as otherwise builtins won't be expanded.  */\n+/* { dg-additional-options \"-O -fdump-rtl-expand\" } */\n+\n+#if __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef enum acc_device_t { acc_device_X = 123 } acc_device_t;\n+extern int acc_on_device (acc_device_t);\n+\n+#if __cplusplus\n+}\n+#endif\n+\n+int\n+f (void)\n+{\n+  const acc_device_t dev = acc_device_X;\n+  return acc_on_device (dev);\n+}\n+\n+/* With -fopenacc, we're expecting the builtin to be expanded, so no calls.\n+   TODO: in C++, even under extern \"C\", the use of enum for acc_device_t\n+   perturbs expansion as a builtin, which expects an int parameter.  It's fine\n+   when changing acc_device_t to plain int, but that's not what we're doing in\n+   <openacc.h>.\n+   { dg-final { scan-rtl-dump-times \"\\\\\\(call \\[^\\\\n\\]*\\\\\\\"acc_on_device\" 0 \"expand\" { xfail c++ } } } */\n+\n+/* { dg-final { cleanup-rtl-dump \"expand\" } } */"}, {"sha": "ccc0106832a0bb76d7753f110d43d46634b857ee", "filename": "gcc/testsuite/c-c++-common/goacc/asyncwait-1.c", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fasyncwait-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fasyncwait-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fasyncwait-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,213 @@\n+void\n+f (int N, float *a, float *b)\n+{\n+    int ii;\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1 2) /* { dg-error \"expected '\\\\)' before numeric constant\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,) /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (,1) /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,2,) /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,2 3) /* { dg-error \"expected '\\\\)' before numeric constant\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1,2,,) /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1 /* { dg-error \"expected '\\\\)' before end of line\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (*) /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (a)\n+\t/* { dg-error \"expected integer expression before\" \"\" { target c } 54 } */\n+\t/* { dg-error \"'async' expression must be integral\" \"\" { target c++ } 54 } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async (1.0)\n+\t/* { dg-error \"expected integer expression before\" \"\" { target c } 62 } */\n+\t/* { dg-error \"'async' expression must be integral\" \"\" { target c++ } 62 } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async () /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) async\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (1 2) /* { dg-error \"expected '\\\\)' before numeric constant\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (1,) /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (,1) /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (1,2,) /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (1,2 3) /* { dg-error \"expected '\\\\)' before numeric constant\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (1,2,,) /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (1 /* { dg-error \"expected '\\\\\\)' before end of line\" } */\n+    /* { dg-error \"expected integer expression before '\\\\\\)'\" \"\" { target c++ } 118 } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (1,*) /* { dg-error \"expected (primary-|)expression before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (1,a) /*{ dg-error \"must be integral\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (a) /* { dg-error \"must be integral\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait (1.0) /* { dg-error \"must be integral\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait () /* { dg-error \"expected (integer |)expression (list |)before\" } */\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copy (b[0:N]) wait\n+    {\n+        for (ii = 0; ii < N; ii++)\n+            b[ii] = a[ii];\n+    }\n+\n+#pragma acc wait (1 2) /* { dg-error \"expected '\\\\)' before numeric constant\" } */\n+\n+#pragma acc wait (1,) /* { dg-error \"expected (primary-|)expression before\" } */\n+\n+#pragma acc wait (,1) /* { dg-error \"expected (primary-|)expression before\" } */\n+\n+#pragma acc wait (1,2,) /* { dg-error \"expected (primary-|)expression before\" } */\n+\n+#pragma acc wait (1,2 3) /* { dg-error \"expected '\\\\)' before numeric constant\" } */\n+\n+#pragma acc wait (1,2,,) /* { dg-error \"expected (primary-|)expression before\" } */\n+\n+#pragma acc wait (1 /* { dg-error \"expected '\\\\\\)' before end of line\" } */\n+    /* { dg-error \"expected integer expression before '\\\\\\)'\" \"\" { target c++ } 173 } */\n+\n+#pragma acc wait (1,*) /* { dg-error \"expected (primary-|)expression before\" } */\n+\n+#pragma acc wait (1,a) /* { dg-error \"expression must be integral\" } */\n+\n+#pragma acc wait (a) /* { dg-error \"expression must be integral\" } */\n+\n+#pragma acc wait (1.0) /* { dg-error \"expression must be integral\" } */\n+\n+#pragma acc wait 1 /* { dg-error \"expected '#pragma acc' clause before numeric constant\" } */\n+\n+#pragma acc wait N /* { dg-error \"expected '#pragma acc' clause before 'N'\" } */\n+\n+#pragma acc wait async (1 2) /* { dg-error \"expected '\\\\)' before numeric constant\" } */\n+\n+#pragma acc wait async (1 2) /* { dg-error \"expected '\\\\)' before numeric constant\" } */\n+\n+#pragma acc wait async (1,) /* { dg-error \"expected (primary-|)expression before\" } */\n+\n+#pragma acc wait async (,1) /* { dg-error \"expected (primary-|)expression before\" } */\n+\n+#pragma acc wait async (1,2,) /* { dg-error \"expected (primary-|)expression before\" } */\n+\n+#pragma acc wait async (1,2 3) /* { dg-error \"expected '\\\\)' before numeric constant\" } */\n+\n+#pragma acc wait async (1,2,,) /* { dg-error \"expected (primary-|)expression before\" } */\n+\n+#pragma acc wait async (1 /* { dg-error \"expected '\\\\)' before end of line\" } */\n+\n+#pragma acc wait async (*) /* { dg-error \"expected (primary-|)expression before \" } */\n+\n+#pragma acc wait async (a)\n+    /* { dg-error \"expected integer expression before\" \"\" { target c } 206 } */\n+    /* { dg-error \"expression must be integral\" \"\" { target c++ } 206 } */\n+\n+#pragma acc wait async (1.0)\n+   /* { dg-error \"expected integer expression before\" \"\" { target c } 210 } */\n+   /* { dg-error \"expression must be integral\" \"\" { target c++ } 210 } */\n+}"}, {"sha": "950334102db0d3ffdf12c1fef4cc7b53543bcce5", "filename": "gcc/testsuite/c-c++-common/goacc/cache-1.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcache-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcache-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcache-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,88 @@\n+int\n+main (int argc, char **argv)\n+{\n+#define N   2\n+    int a[N], b[N];\n+    int i;\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        a[i] = 3;\n+        b[i] = 0;\n+    }\n+\n+#pragma acc parallel copyin (a[0:N]) copyout (b[0:N])\n+{\n+    int ii;\n+\n+    for (ii = 0; ii < N; ii++)\n+    {\n+        const int idx = ii;\n+        int n = 1;\n+        const int len = n;\n+\n+#pragma acc cache /* { dg-error \"expected '\\\\\\(' before end of line\" } */\n+\n+#pragma acc cache a[0:N] /* { dg-error \"expected '\\\\\\(' before 'a'\" } */\n+\t/* { dg-bogus \"expected end of line before 'a'\" \"\" { xfail c++ } 26 } */\n+\n+#pragma acc cache (a) /* { dg-error \"expected '\\\\\\['\" } */\n+\n+#pragma acc cache ( /* { dg-error \"expected (identifier|unqualified-id) before end of line\" } */\n+\n+#pragma acc cache () /* { dg-error \"expected (identifier|unqualified-id) before '\\\\\\)' token\" } */\n+\n+#pragma acc cache (,) /* { dg-error \"expected (identifier|unqualified-id) before '(,|\\\\\\))' token\" } */\n+\n+#pragma acc cache (a[0:N] /* { dg-error \"expected '\\\\\\)' before end of line\" } */\n+\n+#pragma acc cache (a[0:N],) /* { dg-error \"expected (identifier|unqualified-id) before '(,|\\\\\\))' token\" \"\" { xfail c } } */\n+\n+#pragma acc cache (a[0:N]) copyin (a[0:N]) /* { dg-error \"expected end of line before 'copyin'\" } */\n+\n+#pragma acc cache () /* { dg-error \"expected (identifier|unqualified-id) before '\\\\\\)' token\" } */\n+\n+#pragma acc cache (a[0:N] b[0:N]) /* { dg-error \"expected '\\\\\\)' before 'b'\" } */\n+\n+#pragma acc cache (a[0:N] b[0:N}) /* { dg-error \"expected '\\\\\\)' before 'b'\" } */\n+\t/* { dg-bogus \"expected end of line before '\\\\\\}' token\" \"\" { xfail c++ } 47 } */\n+\n+#pragma acc cache (a[0:N] /* { dg-error \"expected '\\\\\\)' before end of line\" } */\n+\n+#pragma acc cache (a[ii]) /* { dg-error \"'ii' is not a constant\" } */\n+\n+#pragma acc cache (a[idx:n]) /* { dg-error \"'n' is not a constant\" } */\n+\n+#pragma acc cache (a[0:N]) ( /* { dg-error \"expected end of line before '\\\\(' token\" } */\n+\n+#pragma acc cache (a[0:N]) ii /* { dg-error \"expected end of line before 'ii'\" } */\n+\n+#pragma acc cache (a[0:N] ii) /* { dg-error \"expected '\\\\)' before 'ii'\" } */\n+\n+#pragma acc cache (a[0:N])\n+\n+#pragma acc cache (a[0:N], a[0:N])\n+\n+#pragma acc cache (a[0:N], b[0:N])\n+\n+#pragma acc cache (a[0])\n+\n+#pragma acc cache (a[0], a[1], b[0:N])\n+\n+#pragma acc cache (a[idx])\n+\n+#pragma acc cache (a[idx:len])\n+\n+        b[ii] = a[ii];\n+    }\n+}\n+\n+\n+    for (i = 0; i < N; i++)\n+    {\n+        if (a[i] != b[i])\n+            __builtin_abort ();\n+    }\n+\n+    return 0;\n+}"}, {"sha": "899018026d31b05a96af9fee7b10a71aabe7da65", "filename": "gcc/testsuite/c-c++-common/goacc/clauses-fail.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclauses-fail.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclauses-fail.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fclauses-fail.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,18 @@\n+void\n+f (void)\n+{\n+  int i;\n+\n+#pragma acc parallel one /* { dg-error \"expected '#pragma acc' clause before 'one'\" } */\n+  ;\n+\n+#pragma acc kernels eins /* { dg-error \"expected '#pragma acc' clause before 'eins'\" } */\n+  ;\n+\n+#pragma acc data two /* { dg-error \"expected '#pragma acc' clause before 'two'\" } */\n+  ;\n+\n+#pragma acc loop deux /* { dg-error \"expected '#pragma acc' clause before 'deux'\" } */\n+  for (i = 0; i < 2; ++i)\n+    ;\n+}"}, {"sha": "11b143839839c6ec49cf95571dc8201fc54fffa3", "filename": "gcc/testsuite/c-c++-common/goacc/collapse-1.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcollapse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcollapse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fcollapse-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-skip-if \"not yet\" { c++ } } */\n+\n+int i, j, k;\n+extern int foo (void);\n+\n+void\n+f1 (void)\n+{\n+  #pragma acc parallel\n+  #pragma acc loop collapse (2)\n+  for (i = 0; i < 5; i++)\n+    ;\t\t\t\t\t/* { dg-error \"not enough perfectly nested\" } */\n+  {\n+    for (j = 0; j < 5; j++)\n+      ;\n+  }\n+}\n+\n+void\n+f2 (void)\n+{\n+  #pragma acc parallel\n+  #pragma acc loop collapse (2)\n+  for (i = 0; i < 5; i++)\n+    {\n+      {\n+\t{\n+\t  for (j = 0; j < 5; j++)\n+\t    {\n+\t    }\n+\t}\n+      }\n+    }\n+}\n+\n+void\n+f3 (void)\n+{\n+  #pragma acc parallel\n+  #pragma acc loop collapse (2)\n+  for (i = 0; i < 5; i++)\n+    {\n+      int k = foo ();\t\t\t/* { dg-error \"not enough perfectly nested\" } */\n+      {\n+\t{\n+\t  for (j = 0; j < 5; j++)\n+\t    {\n+\t    }\n+\t}\n+      }\n+    }\n+}\n+\n+void\n+f4 (void)\n+{\n+  #pragma acc parallel\n+  #pragma acc loop collapse (2)\n+  for (i = 0; i < 5; i++)\n+    {\n+      {\n+\tfor (j = 0; j < 5; j++)\n+\t  ;\n+\tfoo ();\t\t\t\t/* { dg-error \"collapsed loops not perfectly nested before\" } */\n+      }\n+    }\n+}\n+\n+void\n+f5 (void)\n+{\n+  #pragma acc parallel\n+  #pragma acc loop collapse (2)\n+  for (i = 0; i < 5; i++)\n+    {\n+      {\n+\tfor (j = 0; j < 5; j++)\n+\t  ;\n+      }\n+      foo ();\t\t\t\t/* { dg-error \"collapsed loops not perfectly nested before\" } */\n+    }\n+}\n+\n+void\n+f6 (void)\n+{\n+  #pragma acc parallel\n+  #pragma acc loop collapse (2)\n+  for (i = 0; i < 5; i++)\n+    {\n+      {\n+\tfor (j = 0; j < 5; j++)\n+\t  ;\n+      }\n+    }\n+  foo ();\n+}"}, {"sha": "8094575de19dc178a3dba9394c49b39818bc780f", "filename": "gcc/testsuite/c-c++-common/goacc/data-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdata-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdata-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdata-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,6 @@\n+void\n+foo (void)\n+{\n+#pragma acc data\n+  ;\n+}"}, {"sha": "a67d8a4d789e81ea8447cac98c2f13bae8ab7d23", "filename": "gcc/testsuite/c-c++-common/goacc/data-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdata-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdata-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdata-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,21 @@\n+void\n+foo (void)\n+{\n+  int a, b[100];\n+  int n;\n+#pragma acc enter data copyin (a, b) async wait\n+#pragma acc enter data create (b[20:30]) async wait\n+#pragma acc enter data (a) /* { dg-error \"expected '#pragma acc' clause before '\\\\\\(' token\" } */\n+#pragma acc enter data create (b(1:10)) /* { dg-error \"expected '\\\\\\)' before '\\\\\\(' token\" } */\n+#pragma acc exit data delete (a) if (0)\n+#pragma acc exit data copyout (b) if (a)\n+#pragma acc exit data delete (b)\n+#pragma acc enter /* { dg-error \"expected 'data' in\" } */\n+#pragma acc exit /* { dg-error \"expected 'data' in\" } */\n+#pragma acc enter data /* { dg-error \"has no data movement clause\" } */\n+#pragma acc exit data /* { dg-error \"has no data movement clause\" } */\n+#pragma acc enter Data /* { dg-error \"invalid pragma before\" } */\n+#pragma acc exit copyout (b) /* { dg-error \"invalid pragma before\" } */\n+}\n+\n+/* { dg-error \"has no data movement clause\" \"\" { target *-*-* } 8 } */"}, {"sha": "7a1cf683f244706db48181a213bd7f593a25e893", "filename": "gcc/testsuite/c-c++-common/goacc/data-clause-duplicate-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdata-clause-duplicate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdata-clause-duplicate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdata-clause-duplicate-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,13 @@\n+void\n+fun (void)\n+{\n+  float *fp;\n+#pragma acc parallel copy(fp[0:2],fp[0:2]) /* { dg-error \"'fp' appears more than once in map clauses\" } */\n+  ;\n+#pragma acc kernels present_or_copyin(fp[3]) present_or_copyout(fp[7:4]) /* { dg-error \"'fp' appears more than once in map clauses\" } */\n+  ;\n+#pragma acc data create(fp[:10]) deviceptr(fp) /* { dg-error \"'fp' appears more than once in map clauses\" } */\n+  ;\n+#pragma acc data create(fp) present(fp) /* { dg-error \"'fp' appears more than once in map clauses\" } */\n+  ;\n+}"}, {"sha": "546fa82958e6ca15114d97081ef3d345ea392e95", "filename": "gcc/testsuite/c-c++-common/goacc/deviceptr-1.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeviceptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeviceptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeviceptr-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-skip-if \"not yet\" { c++ } } */\n+\n+void\n+fun1 (void)\n+{\n+#pragma acc parallel deviceptr(u) /* { dg-error \"'u' undeclared\" } */\n+  ;\n+#pragma acc kernels deviceptr(u[0:4]) /* { dg-error \"expected '\\\\\\)' before '\\\\\\[' token\" } */\n+  ;\n+\n+#pragma acc data deviceptr(fun1) /* { dg-error \"'fun1' is not a variable\" } */\n+  ;\n+#pragma acc parallel deviceptr(fun1[2:5])\n+  /* { dg-error \"'fun1' is not a variable\" \"not a variable\" { target *-*-* } 13 } */\n+  /* { dg-error \"expected '\\\\\\)' before '\\\\\\[' token\" \"array\" { target *-*-* } 13 } */\n+  ;\n+\n+  int i;\n+#pragma acc kernels deviceptr(i) /* { dg-error \"'i' is not a pointer variable\" } */\n+  ;\n+#pragma acc data deviceptr(i[0:4])\n+  /* { dg-error \"'i' is not a pointer variable\" \"not a pointer variable\" { target *-*-* } 21 } */\n+  /* { dg-error \"expected '\\\\\\)' before '\\\\\\[' token\" \"array\" { target *-*-* } 21 } */\n+  ;\n+\n+  float fa[10];\n+#pragma acc parallel deviceptr(fa) /* { dg-error \"'fa' is not a pointer variable\" } */\n+  ;\n+#pragma acc kernels deviceptr(fa[1:5])\n+  /* { dg-error \"'fa' is not a pointer variable\" \"not a pointer variable\" { target *-*-* } 29 } */\n+  /* { dg-error \"expected '\\\\\\)' before '\\\\\\[' token\" \"array\" { target *-*-* } 29 } */\n+  ;\n+\n+  float *fp;\n+#pragma acc data deviceptr(fp)\n+  ;\n+#pragma acc parallel deviceptr(fp[0:4]) /* { dg-error \"expected '\\\\\\)' before '\\\\\\[' token\" } */\n+  ;\n+}\n+\n+void\n+fun2 (void)\n+{\n+  int i;\n+  float *fp;\n+#pragma acc kernels deviceptr(fp,u,fun2,i,fp)\n+  /* { dg-error \"'u' undeclared\" \"u undeclared\" { target *-*-* } 46 } */\n+  /* { dg-error \"'fun2' is not a variable\" \"fun2 not a variable\" { target *-*-* } 46 } */\n+  /* { dg-error \"'i' is not a pointer variable\" \"i not a pointer variable\" { target *-*-* } 46 } */\n+  /* { dg-error \"'fp' appears more than once in map clauses\" \"fp more than once\" { target *-*-* } 46 } */\n+  ;\n+}\n+\n+void\n+fun3 (void)\n+{\n+  float *fp;\n+#pragma acc data deviceptr(fp,fp) /* { dg-error \"'fp' appears more than once in map clauses\" } */\n+  ;\n+#pragma acc parallel deviceptr(fp) deviceptr(fp) /* { dg-error \"'fp' appears more than once in map clauses\" } */\n+  ;\n+#pragma acc kernels copy(fp) deviceptr(fp) /* { dg-error \"'fp' appears more than once in map clauses\" } */\n+  ;\n+}\n+\n+extern struct s s1;\n+extern struct s s2[1]; /* { dg-error \"array type has incomplete element type\" \"\" { target c } } */\n+\n+void\n+fun4 (void)\n+{\n+  struct s *s1_p = &s1;\n+  struct s *s2_p = &s2;\n+\n+#pragma acc parallel deviceptr(s1) /* { dg-error \"'s1' is not a pointer variable\" } */\n+  ;\n+\n+#pragma acc parallel deviceptr(s2)\n+  ;\n+\n+#pragma acc parallel deviceptr(s1_p)\n+  s1_p = 0;\n+\n+#pragma acc parallel deviceptr(s2_p)\n+  s2_p = 0;\n+}"}, {"sha": "ac162b4989bd5f87c4a5636fa2ad5ee12a507fc0", "filename": "gcc/testsuite/c-c++-common/goacc/deviceptr-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeviceptr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeviceptr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeviceptr-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,23 @@\n+void\n+fun1 (void)\n+{\n+  char *a = 0;\n+\n+#pragma acc data deviceptr(a)\n+  ++a;\n+\n+#pragma acc data deviceptr(a)\n+#pragma acc parallel\n+  ++a;\n+\n+#pragma acc data deviceptr(a)\n+#pragma acc parallel deviceptr(a)\n+  ++a;\n+\n+#pragma acc data\n+#pragma acc parallel deviceptr(a)\n+  ++a;\n+\n+#pragma acc parallel deviceptr(a)\n+  ++a;\n+}"}, {"sha": "bab56c3e6523eb0df98366c2e45db09d930647c0", "filename": "gcc/testsuite/c-c++-common/goacc/deviceptr-3.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeviceptr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeviceptr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fdeviceptr-3.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,11 @@\n+float *d_a;\n+\n+void\n+f (float *a)\n+{\n+#pragma acc parallel copyout (a[3:10]) deviceptr (d_a)\n+  d_a[2] += 1.0;\n+\n+#pragma acc parallel deviceptr (d_a) copyout (a[3:10])\n+  d_a[2] += 1.0;\n+}"}, {"sha": "85abf1659e93816bcfd6bd47ccb42ea4e621e827", "filename": "gcc/testsuite/c-c++-common/goacc/if-clause-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fif-clause-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fif-clause-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fif-clause-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-skip-if \"not yet\" { c++ } } */\n+\n+void\n+f (void)\n+{\n+  struct { int i; } *p;\n+#pragma acc data copyout(p) if(1) if(1) /* { dg-error \"too many 'if' clauses\" } */\n+  ;\n+#pragma acc update device(p) if(*p) /* { dg-error \"used struct type value where scalar is required\" } */\n+}"}, {"sha": "5ab8459d732317b9d9fb84cea8ca2d13e6f77374", "filename": "gcc/testsuite/c-c++-common/goacc/if-clause-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fif-clause-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fif-clause-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fif-clause-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,11 @@\n+void\n+f (short c)\n+{\n+#pragma acc parallel if(c)\n+  ;\n+#pragma acc kernels if(c)\n+  ;\n+#pragma acc data if(c)\n+  ;\n+#pragma acc update device(c) if(c)\n+}"}, {"sha": "e91b81c8d04aada8e9a115affdb2adfa53c9c586", "filename": "gcc/testsuite/c-c++-common/goacc/kernels-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fkernels-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,6 @@\n+void\n+foo (void)\n+{\n+#pragma acc kernels\n+  ;\n+}"}, {"sha": "fea40e0ab61cb94b9e20c6bcdbebcd192ed16ece", "filename": "gcc/testsuite/c-c++-common/goacc/loop-1.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,72 @@\n+/* { dg-skip-if \"not yet\" { c++ } } */\n+\n+int test1()\n+{\n+  int i, j, k, b[10];\n+  int a[30];\n+  double d;\n+  float r;\n+  i = 0;\n+  #pragma acc loop\n+  while(1)  /* { dg-error \"for statement expected\" } */\n+    {\n+      if (i > 0) break; \n+      i = i + 1;\n+    }\n+  i = 0;\n+  #pragma acc loop\n+  for(;;)  /* { dg-error \"expected iteration declaration or initialization\" } */\n+    {\n+      if (i > 0) break; /* { dg-error \"break statement used\" } */\n+      i = i + 1;\n+    }\n+  i = 0;\n+  #pragma acc loop\n+  do  /* { dg-error \"for statement expected\" } */\n+    {\n+      i = i + 1;\n+    }\n+  while (i < 4);\n+  #pragma acc loop\n+  while (i < 8)  /* { dg-error \"for statement expected\" } */\n+    {\n+      i = i + 1;\n+    }\n+  #pragma acc loop\n+  for (d = 1; d < 30; d+= 6)  /* { dg-error \"invalid type for iteration variable\" } */\n+    {\n+      i = d;\n+      a[i] = 1;\n+    }\n+  #pragma acc loop\n+  for (i = 1; i < 30; i++ )\n+    if (i == 16) break; /* { dg-error \"break statement used\" } */\n+\n+/* different types of for loop are allowed */\n+  #pragma acc loop\n+  for (i = 1; i < 10; i++)\n+    {\n+    }\n+  #pragma acc loop\n+  for (i = 1; i < 10; i+=2)\n+    {\n+      a[i] = i;\n+    }\n+\n+  /* after loop directive must be loop */\n+  #pragma acc loop\n+    a[1] = 1; /* { dg-error \"for statement expected\" } */\n+    for (i = 1; i < 10; i++)\n+      ;\n+  /* combined directives may be used*/\n+  #pragma acc parallel loop\n+  for(i = 1; i < 10; i++)\n+    {\n+    }\n+  #pragma acc kernels loop\n+  for(i = 1; i < 10; i++)\n+    {\n+    }\n+  return 0;\n+}\n+/* { dg-prune-output \"sorry, unimplemented: directive not yet implemented\" } */"}, {"sha": "a54edb2c05fccdb98d3e55a3dff781fa2f90e9a7", "filename": "gcc/testsuite/c-c++-common/goacc/loop-private-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-private-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-private-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Floop-private-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+\n+void\n+f (int i, int j)\n+{\n+#pragma acc kernels\n+#pragma acc loop collapse(2)\n+  for (i = 0; i < 20; ++i)\n+    for (j = 0; j < 25; ++j)\n+      ;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"#pragma acc loop collapse\\\\(2\\\\) private\\\\(j\\\\) private\\\\(i\\\\)\" 1 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "b4b863fb86073410203662b7263d3d71b7efa078", "filename": "gcc/testsuite/c-c++-common/goacc/nesting-1.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,101 @@\n+extern int i;\n+\n+void\n+f_acc_parallel (void)\n+{\n+#pragma acc parallel\n+  {\n+#pragma acc loop\n+    for (i = 0; i < 2; ++i)\n+      ;\n+  }\n+}\n+\n+\n+void\n+f_acc_kernels (void)\n+{\n+#pragma acc kernels\n+  {\n+#pragma acc loop\n+    for (i = 0; i < 2; ++i)\n+      ;\n+  }\n+}\n+\n+\n+void\n+f_acc_data (void)\n+{\n+#pragma acc data\n+  {\n+#pragma acc parallel\n+    ;\n+\n+#pragma acc parallel\n+    {\n+#pragma acc loop\n+      for (i = 0; i < 2; ++i)\n+\t;\n+    }\n+\n+#pragma acc kernels\n+    ;\n+\n+#pragma acc kernels\n+    {\n+#pragma acc loop\n+      for (i = 0; i < 2; ++i)\n+\t;\n+    }\n+\n+#pragma acc data\n+    ;\n+\n+#pragma acc update host(i)\n+\n+#pragma acc enter data copyin(i)\n+\n+#pragma acc exit data delete(i)\n+\n+#pragma acc loop\n+    for (i = 0; i < 2; ++i)\n+      ;\n+\n+#pragma acc data\n+    {\n+#pragma acc parallel\n+      ;\n+\n+#pragma acc parallel\n+      {\n+#pragma acc loop\n+\tfor (i = 0; i < 2; ++i)\n+\t  ;\n+      }\n+\n+#pragma acc kernels\n+      ;\n+\n+#pragma acc kernels\n+      {\n+#pragma acc loop\n+\tfor (i = 0; i < 2; ++i)\n+\t  ;\n+      }\n+\n+#pragma acc data\n+      ;\n+\n+#pragma acc update host(i)\n+\n+#pragma acc enter data copyin(i)\n+\n+#pragma acc exit data delete(i)\n+\n+#pragma acc loop\n+      for (i = 0; i < 2; ++i)\n+\t;\n+    }\n+  }\n+}"}, {"sha": "fefe6cd16f75d3826e6b943bfa028b04a22182ba", "filename": "gcc/testsuite/c-c++-common/goacc/nesting-data-1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-data-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-data-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-data-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,61 @@\n+void\n+f (void)\n+{\n+  unsigned char c, ca[15], caa[20][30];\n+\n+#pragma acc data copyin(c)\n+  {\n+    c = 5;\n+    ca[3] = c;\n+    caa[3][12] = ca[3] + caa[3][12];\n+\n+#pragma acc data copyin(ca[2:4])\n+    {\n+      c = 6;\n+      ca[4] = c;\n+      caa[3][12] = ca[3] + caa[3][12];\n+    }\n+\n+#pragma acc parallel copyout(ca[3:4])\n+    {\n+      c = 7;\n+      ca[5] = c;\n+      caa[3][12] = ca[3] + caa[3][12];\n+    }\n+\n+#pragma acc kernels copy(ca[4:4])\n+    {\n+      c = 8;\n+      ca[6] = c;\n+      caa[3][12] = ca[3] + caa[3][12];\n+    }\n+\n+#pragma acc data pcopy(ca[5:7])\n+    {\n+      c = 15;\n+      ca[7] = c;\n+      caa[3][12] = ca[3] + caa[3][12];\n+\n+#pragma acc data pcopyin(caa[3:7][0:30])\n+      {\n+\tc = 16;\n+\tca[8] = c;\n+\tcaa[3][12] = ca[3] + caa[3][12];\n+      }\n+\n+#pragma acc parallel pcopyout(caa[3:7][0:30])\n+      {\n+\tc = 17;\n+\tca[9] = c;\n+\tcaa[3][12] = ca[3] + caa[3][12];\n+      }\n+\n+#pragma acc kernels pcopy(caa[3:7][0:30])\n+      {\n+\tc = 18;\n+\tca[10] = c;\n+\tcaa[3][12] = ca[3] + caa[3][12];\n+      }\n+    }\n+  }\n+}"}, {"sha": "8af1c8244f09e4cafc20b396628f18969928dfb4", "filename": "gcc/testsuite/c-c++-common/goacc/nesting-fail-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-fail-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-fail-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fnesting-fail-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,39 @@\n+extern int i;\n+\n+/* While the OpenACC specification does allow for certain kinds of\n+   nesting, we don't support many of these yet.  */\n+void\n+f_acc_parallel (void)\n+{\n+#pragma acc parallel\n+  {\n+#pragma acc parallel /* { dg-bogus \"parallel construct inside of parallel region\" \"not implemented\" { xfail *-*-* } } */\n+    ;\n+#pragma acc kernels /* { dg-bogus \"kernels construct inside of parallel region\" \"not implemented\" { xfail *-*-* } } */\n+    ;\n+#pragma acc data /* { dg-error \"data construct inside of parallel region\" } */\n+    ;\n+#pragma acc update host(i) /* { dg-error \"update construct inside of parallel region\" } */\n+#pragma acc enter data copyin(i) /* { dg-error \"enter/exit data construct inside of parallel region\" } */\n+#pragma acc exit data delete(i) /* { dg-error \"enter/exit data construct inside of parallel region\" } */\n+  }\n+}\n+\n+/* While the OpenACC specification does allow for certain kinds of\n+   nesting, we don't support many of these yet.  */\n+void\n+f_acc_kernels (void)\n+{\n+#pragma acc kernels\n+  {\n+#pragma acc parallel /* { dg-bogus \"parallel construct inside of kernels region\" \"not implemented\" { xfail *-*-* } } */\n+    ;\n+#pragma acc kernels /* { dg-bogus \"kernels construct inside of kernels region\" \"not implemented\" { xfail *-*-* } } */\n+    ;\n+#pragma acc data /* { dg-error \"data construct inside of kernels region\" } */\n+    ;\n+#pragma acc update host(i) /* { dg-error \"update construct inside of kernels region\" } */\n+#pragma acc enter data copyin(i) /* { dg-error \"enter/exit data construct inside of kernels region\" } */\n+#pragma acc exit data delete(i) /* { dg-error \"enter/exit data construct inside of kernels region\" } */\n+  }\n+}"}, {"sha": "a86052667470b95271ff9d3a92d160cf0df6dfb8", "filename": "gcc/testsuite/c-c++-common/goacc/parallel-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fparallel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fparallel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fparallel-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,6 @@\n+void\n+foo (void)\n+{\n+#pragma acc parallel\n+  ;\n+}"}, {"sha": "fd16525517d33d852cf3f77ec8d6a126c2832cdd", "filename": "gcc/testsuite/c-c++-common/goacc/pcopy.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcopy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcopy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcopy.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+\n+void\n+f (char *cp)\n+{\n+#pragma acc parallel pcopy(cp[3:5])\n+  ;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"#pragma acc parallel map\\\\(tofrom:\\\\*\\\\(cp \\\\+ 3\\\\) \\\\\\[len: 5]\\\\) map\\\\(alloc:cp \\\\\\[pointer assign, bias: 3]\\\\)\" 1 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "c009d24101ee4ba3b2730709e29c0f4c99648bd6", "filename": "gcc/testsuite/c-c++-common/goacc/pcopyin.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcopyin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcopyin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcopyin.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+\n+void\n+f (char *cp)\n+{\n+#pragma acc parallel pcopyin(cp[4:6])\n+  ;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"#pragma acc parallel map\\\\(to:\\\\*\\\\(cp \\\\+ 4\\\\) \\\\\\[len: 6]\\\\) map\\\\(alloc:cp \\\\\\[pointer assign, bias: 4]\\\\)\" 1 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "6099effd8f41bc4e56ca80012e8d158412312653", "filename": "gcc/testsuite/c-c++-common/goacc/pcopyout.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcopyout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcopyout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcopyout.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+\n+void\n+f (char *cp)\n+{\n+#pragma acc parallel pcopyout(cp[5:7])\n+  ;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"#pragma acc parallel map\\\\(from:\\\\*\\\\(cp \\\\+ 5\\\\) \\\\\\[len: 7]\\\\) map\\\\(alloc:cp \\\\\\[pointer assign, bias: 5]\\\\)\" 1 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "2f6e836e6fba860cf6b1354b86cb5e01fc9747cc", "filename": "gcc/testsuite/c-c++-common/goacc/pcreate.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcreate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcreate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpcreate.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+\n+void\n+f (char *cp)\n+{\n+#pragma acc parallel pcreate(cp[6:8])\n+  ;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"#pragma acc parallel map\\\\(alloc:\\\\*\\\\(cp \\\\+ 6\\\\) \\\\\\[len: 8]\\\\) map\\\\(alloc:cp \\\\\\[pointer assign, bias: 6]\\\\)\" 1 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "680dc9bba0eca1e6e0238c86d3d610d59cfe1576", "filename": "gcc/testsuite/c-c++-common/goacc/pragma_context.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpragma_context.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpragma_context.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpragma_context.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-skip-if \"not yet\" { c++ } } */\n+\n+// pragma_external\n+#pragma acc update /* { dg-error \"expected declaration specifiers before '#pragma'\" } */\n+\n+// pragma_struct\n+struct s_pragma_struct\n+{\n+#pragma acc update /* { dg-error \"expected declaration specifiers before '#pragma'\" } */\n+};\n+\n+// pragma_param\n+void\n+f_pragma_param (\n+#pragma acc update /* { dg-error \"expected declaration specifiers before '#pragma'\" } */\n+    void)\n+{\n+}\n+\n+// pragma_stmt\n+void\n+f2 (void)\n+{\n+  if (0)\n+#pragma acc update /* { dg-error \"'#pragma acc update' may only be used in compound statements before '#pragma'\" } */\n+}\n+\n+// pragma_compound\n+void\n+f3 (void)\n+{\n+  int i = 0;\n+#pragma acc update device(i)\n+}"}, {"sha": "03ee5921441eb1f0af12d47a7a56cfcf710485bd", "filename": "gcc/testsuite/c-c++-common/goacc/present-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpresent-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpresent-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fpresent-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-additional-options \"-fdump-tree-original\" } */\n+\n+void\n+f (char *cp)\n+{\n+#pragma acc parallel present(cp[7:9])\n+  ;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"#pragma acc parallel map\\\\(force_present:\\\\*\\\\(cp \\\\+ 7\\\\) \\\\\\[len: 9]\\\\) map\\\\(alloc:cp \\\\\\[pointer assign, bias: 7]\\\\)\" 1 \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "0f5008298313194549e86fb2ecef1cf53b9ceb6c", "filename": "gcc/testsuite/c-c++-common/goacc/reduction-1.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,71 @@\n+/* Integer reductions.  */\n+\n+#define vl 32\n+\n+int\n+main(void)\n+{\n+  const int n = 1000;\n+  int i;\n+  int result, array[n];\n+  int lresult;\n+\n+  /* '+' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (+:result)\n+  for (i = 0; i < n; i++)\n+    result += array[i];\n+\n+  /* '*' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (*:result)\n+  for (i = 0; i < n; i++)\n+    result *= array[i];\n+\n+//   result = 0;\n+//   vresult = 0;\n+// \n+//   /* 'max' reductions.  */\n+// #pragma acc parallel vector_length (vl)\n+// #pragma acc loop reduction (+:result)\n+//   for (i = 0; i < n; i++)\n+//       result = result > array[i] ? result : array[i];\n+//\n+//   /* 'min' reductions.  */\n+// #pragma acc parallel vector_length (vl)\n+// #pragma acc loop reduction (+:result)\n+//   for (i = 0; i < n; i++)\n+//       result = result < array[i] ? result : array[i];\n+\n+  /* '&' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (&:result)\n+  for (i = 0; i < n; i++)\n+    result &= array[i];\n+\n+  /* '|' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (|:result)\n+  for (i = 0; i < n; i++)\n+    result |= array[i];\n+\n+  /* '^' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (^:result)\n+  for (i = 0; i < n; i++)\n+    result ^= array[i];\n+\n+  /* '&&' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (&&:lresult)\n+  for (i = 0; i < n; i++)\n+    lresult = lresult && (result > array[i]);\n+\n+  /* '||' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (||:lresult)\n+  for (i = 0; i < n; i++)\n+    lresult = lresult || (result > array[i]);\n+\n+  return 0;\n+}"}, {"sha": "1f95138ff0bb2c7ab5c0cc67f2746cd6baed5c90", "filename": "gcc/testsuite/c-c++-common/goacc/reduction-2.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,50 @@\n+/* float reductions.  */\n+\n+#define vl 32\n+\n+int\n+main(void)\n+{\n+  const int n = 1000;\n+  int i;\n+  float result, array[n];\n+  int lresult;\n+\n+  /* '+' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (+:result)\n+  for (i = 0; i < n; i++)\n+    result += array[i];\n+\n+  /* '*' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (*:result)\n+  for (i = 0; i < n; i++)\n+    result *= array[i];\n+\n+//   /* 'max' reductions.  */\n+// #pragma acc parallel vector_length (vl)\n+// #pragma acc loop reduction (+:result)\n+//   for (i = 0; i < n; i++)\n+//       result = result > array[i] ? result : array[i];\n+// \n+//   /* 'min' reductions.  */\n+// #pragma acc parallel vector_length (vl)\n+// #pragma acc loop reduction (+:result)\n+//   for (i = 0; i < n; i++)\n+//       result = result < array[i] ? result : array[i];\n+\n+  /* '&&' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (&&:lresult)\n+  for (i = 0; i < n; i++)\n+    lresult = lresult && (result > array[i]);\n+\n+  /* '||' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (||:lresult)\n+  for (i = 0; i < n; i++)\n+    lresult = lresult || (result > array[i]);\n+\n+  return 0;\n+}"}, {"sha": "476e375c65421a51b4b5f7f823185b954b7d6122", "filename": "gcc/testsuite/c-c++-common/goacc/reduction-3.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-3.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,50 @@\n+/* double reductions.  */\n+\n+#define vl 32\n+\n+int\n+main(void)\n+{\n+  const int n = 1000;\n+  int i;\n+  double result, array[n];\n+  int lresult;\n+\n+  /* '+' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (+:result)\n+  for (i = 0; i < n; i++)\n+    result += array[i];\n+\n+  /* '*' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (*:result)\n+  for (i = 0; i < n; i++)\n+    result *= array[i];\n+\n+//   /* 'max' reductions.  */\n+// #pragma acc parallel vector_length (vl)\n+// #pragma acc loop reduction (+:result)\n+//   for (i = 0; i < n; i++)\n+//       result = result > array[i] ? result : array[i];\n+// \n+//   /* 'min' reductions.  */\n+// #pragma acc parallel vector_length (vl)\n+// #pragma acc loop reduction (+:result)\n+//   for (i = 0; i < n; i++)\n+//       result = result < array[i] ? result : array[i];\n+\n+  /* '&&' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (&&:lresult)\n+  for (i = 0; i < n; i++)\n+    lresult = lresult && (result > array[i]);\n+\n+  /* '||' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (||:lresult)\n+  for (i = 0; i < n; i++)\n+    lresult = lresult || (result > array[i]);\n+\n+  return 0;\n+}"}, {"sha": "73dde869a9d6945a5bf6de5490e72b29e2480653", "filename": "gcc/testsuite/c-c++-common/goacc/reduction-4.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Freduction-4.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,52 @@\n+/* complex reductions.  */\n+\n+#define vl 32\n+\n+int\n+main(void)\n+{\n+  const int n = 1000;\n+  int i;\n+  __complex__ double result, array[n];\n+  int lresult;\n+\n+  /* '+' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (+:result)\n+  for (i = 0; i < n; i++)\n+    result += array[i];\n+\n+  /* Needs support for complex multiplication.  */\n+\n+//   /* '*' reductions.  */\n+// #pragma acc parallel vector_length (vl)\n+// #pragma acc loop reduction (*:result)\n+//   for (i = 0; i < n; i++)\n+//     result *= array[i];\n+//\n+//   /* 'max' reductions.  */\n+// #pragma acc parallel vector_length (vl)\n+// #pragma acc loop reduction (+:result)\n+//   for (i = 0; i < n; i++)\n+//       result = result > array[i] ? result : array[i];\n+// \n+//   /* 'min' reductions.  */\n+// #pragma acc parallel vector_length (vl)\n+// #pragma acc loop reduction (+:result)\n+//   for (i = 0; i < n; i++)\n+//       result = result < array[i] ? result : array[i];\n+\n+  /* '&&' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (&&:lresult)\n+  for (i = 0; i < n; i++)\n+    lresult = lresult && (__real__(result) > __real__(array[i]));\n+\n+  /* '||' reductions.  */\n+#pragma acc parallel vector_length (vl)\n+#pragma acc loop reduction (||:lresult)\n+  for (i = 0; i < n; i++)\n+    lresult = lresult || (__real__(result) > __real__(array[i]));\n+\n+  return 0;\n+}"}, {"sha": "5e55c9516f21928e5176f7bcaeefd7ad41a1a58d", "filename": "gcc/testsuite/c-c++-common/goacc/sb-1.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fsb-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fsb-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fsb-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,75 @@\n+// { dg-skip-if \"not yet\" { c++ } }\n+\n+void foo()\n+{\n+  int l;\n+\n+  bad1:\n+  #pragma acc parallel\n+    goto bad1; // { dg-error \"invalid branch to/from OpenACC structured block\" }\n+  #pragma acc kernels\n+    goto bad1; // { dg-error \"invalid branch to/from OpenACC structured block\" }\n+  #pragma acc data\n+    goto bad1; // { dg-error \"invalid branch to/from OpenACC structured block\" }\n+  #pragma acc loop\n+    for (l = 0; l < 2; ++l)\n+      goto bad1; // { dg-error \"invalid branch to/from OpenACC structured block\" }\n+\n+  goto bad2_parallel; // { dg-error \"invalid entry to OpenACC structured block\" }\n+  #pragma acc parallel\n+    {\n+      bad2_parallel: ;\n+    }\n+\n+  goto bad2_kernels; // { dg-error \"invalid entry to OpenACC structured block\" }\n+  #pragma acc kernels\n+    {\n+      bad2_kernels: ;\n+    }\n+\n+  goto bad2_data; // { dg-error \"invalid entry to OpenACC structured block\" }\n+  #pragma acc data\n+    {\n+      bad2_data: ;\n+    }\n+\n+  goto bad2_loop; // { dg-error \"invalid entry to OpenACC structured block\" }\n+  #pragma acc loop\n+  for (l = 0; l < 2; ++l)\n+    {\n+      bad2_loop: ;\n+    }\n+\n+  #pragma acc parallel\n+    {\n+      int i;\n+      goto ok1_parallel;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1_parallel: break; }\n+    }\n+\n+  #pragma acc kernels\n+    {\n+      int i;\n+      goto ok1_kernels;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1_kernels: break; }\n+    }\n+\n+  #pragma acc data\n+    {\n+      int i;\n+      goto ok1_data;\n+      for (i = 0; i < 10; ++i)\n+\t{ ok1_data: break; }\n+    }\n+\n+  #pragma acc loop\n+    for (l = 0; l < 2; ++l)\n+      {\n+\tint i;\n+\tgoto ok1_loop;\n+\tfor (i = 0; i < 10; ++i)\n+\t  { ok1_loop: break; }\n+      }\n+}"}, {"sha": "a6760ec73f87643c15f25561022a59bb50c2aeaa", "filename": "gcc/testsuite/c-c++-common/goacc/sb-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fsb-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fsb-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fsb-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,22 @@\n+// { dg-skip-if \"not yet\" { c++ } }\n+\n+void foo(int i)\n+{\n+  switch (i) // { dg-error \"invalid entry to OpenACC structured block\" }\n+  {\n+  #pragma acc parallel\n+    { case 0:; }\n+  }\n+\n+  switch (i) // { dg-error \"invalid entry to OpenACC structured block\" }\n+  {\n+  #pragma acc kernels\n+    { case 0:; }\n+  }\n+\n+  switch (i) // { dg-error \"invalid entry to OpenACC structured block\" }\n+  {\n+  #pragma acc data\n+    { case 0:; }\n+  }\n+}"}, {"sha": "147b7b0e8455bd1cc37aa33cebde8d60d9ca9d72", "filename": "gcc/testsuite/c-c++-common/goacc/sb-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fsb-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fsb-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fsb-3.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,18 @@\n+// { dg-skip-if \"not yet\" { c++ } }\n+\n+void f (void)\n+{\n+  int i, j;\n+#pragma acc loop\n+  for(i = 1; i < 30; i++)\n+    {\n+      if (i == 7) goto out; // { dg-error \"invalid branch to/from OpenACC structured block\" }\n+#pragma acc loop // { dg-error \"work-sharing region may not be closely nested inside of work-sharing, critical, ordered, master or explicit task region\" }\n+      for(j = 5; j < 10; j++)\n+\t{\n+\t  if (i == 6 && j == 7) goto out; // { dg-error \"invalid branch to/from OpenACC structured block\" }\n+\t}\n+    }\n+ out:\n+  ;\n+}"}, {"sha": "97e93794934ffcc2d85a746ec95c070cdfdc62c0", "filename": "gcc/testsuite/c-c++-common/goacc/update-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fupdate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fupdate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Fupdate-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,17 @@\n+void\n+f (void)\n+{\n+#pragma acc update /* { dg-error \"'#pragma acc update' must contain at least one 'device' or 'host/self' clause\" } */\n+\n+  int i = 0;\n+  int a[10];\n+#pragma acc update device(i)\n+#pragma acc update host(i)\n+#pragma acc update self(i)\n+#pragma acc update device(a[1:3])\n+#pragma acc update host(a[1:3])\n+#pragma acc update self(a[1:3])\n+#pragma acc update device(a(1:3)) /* { dg-error \"expected '\\\\\\)' before '\\\\\\(' token\" } */\n+#pragma acc update host(a(1:3)) /* { dg-error \"expected '\\\\\\)' before '\\\\\\(' token\" } */\n+#pragma acc update self(a(1:3)) /* { dg-error \"expected '\\\\\\)' before '\\\\\\(' token\" } */\n+}"}, {"sha": "7e74d2ba0636bbb7be17188fa7b6b3158fbe3da8", "filename": "gcc/testsuite/g++.dg/goacc-gomp/goacc-gomp.exp", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc-gomp%2Fgoacc-gomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc-gomp%2Fgoacc-gomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc-gomp%2Fgoacc-gomp.exp?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,36 @@\n+# Copyright (C) 2006-2015 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Load support procs.\n+load_lib g++-dg.exp\n+\n+if { ![check_effective_target_fopenacc] \\\n+     || ![check_effective_target_fopenmp] } {\n+  return\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+g++-dg-runtest [lsort [concat \\\n+\t[find $srcdir/$subdir *.C] \\\n+\t[find $srcdir/c-c++-common/goacc-gomp *.c]]] \"\" \"-fopenacc -fopenmp\"\n+\n+# All done.\n+dg-finish"}, {"sha": "0e96dfaafa7f321270be58c3f73e74fcc2712852", "filename": "gcc/testsuite/g++.dg/goacc/goacc.exp", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fgoacc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fgoacc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgoacc%2Fgoacc.exp?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,35 @@\n+# Copyright (C) 2006-2015 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Load support procs.\n+load_lib g++-dg.exp\n+\n+if ![check_effective_target_fopenacc] {\n+  return\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+g++-dg-runtest [lsort [concat \\\n+\t[find $srcdir/$subdir *.C] \\\n+\t[find $srcdir/c-c++-common/goacc *.c]]] \"\" \"-fopenacc\"\n+\n+# All done.\n+dg-finish"}, {"sha": "b0704ac7fa2e590eedafcfea3899cbb565720e7b", "filename": "gcc/testsuite/g++.dg/gomp/block-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-1.C?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -22,5 +22,5 @@ void foo()\n     }\n }\n \n-// { dg-message \"error: invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 7 }\n+// { dg-message \"error: invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 7 }\n // { dg-message \"error: invalid entry to OpenMP structured block\" \"\" { target *-*-* } 9 }"}, {"sha": "5336c5a30a1ea0ce8ccd824928b8ac804d76631a", "filename": "gcc/testsuite/g++.dg/gomp/block-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-2.C?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -32,5 +32,5 @@ void foo()\n     continue;\n }\n \n-// { dg-message \"error: invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 14 }\n+// { dg-message \"error: invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 14 }\n // { dg-message \"error: invalid entry to OpenMP structured block\" \"\" { target *-*-* } 16 }"}, {"sha": "23f97268eddc7e11a8b4b63d02fd3a7278912442", "filename": "gcc/testsuite/g++.dg/gomp/block-3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-3.C?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -60,6 +60,6 @@ void foo()\n     }\n }\n \n-// { dg-message \"error: invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 21 }\n-// { dg-message \"error: invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 26 }\n+// { dg-message \"error: invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 21 }\n+// { dg-message \"error: invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 26 }\n // { dg-message \"error: invalid entry to OpenMP structured block\" \"\" { target *-*-* } 31 }"}, {"sha": "d6d28c4b4c34b6c09d0ddce974e7b2b478fba8d6", "filename": "gcc/testsuite/g++.dg/gomp/block-5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-5.C?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -15,4 +15,4 @@ void foo()\n     }\n }\n \n-// { dg-message \"error: invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 7 }\n+// { dg-message \"error: invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 7 }"}, {"sha": "bcdac61ee31b5b5c429ffba26f364a301d6f0d6e", "filename": "gcc/testsuite/g++.dg/gomp/target-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-1.C?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -30,5 +30,5 @@ foo (int x)\n   }\n }\n \n-// { dg-error \"invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 8 }\n+// { dg-error \"invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 8 }\n // { dg-error \"invalid entry to OpenMP structured block\" \"\" { target *-*-* } 10 }"}, {"sha": "273f8d50fefa0766cf80857daea67ef004a8d08e", "filename": "gcc/testsuite/g++.dg/gomp/target-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-2.C?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -30,5 +30,5 @@ foo (int x, int y)\n   }\n }\n \n-// { dg-error \"invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 8 }\n+// { dg-error \"invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 8 }\n // { dg-error \"invalid entry to OpenMP structured block\" \"\" { target *-*-* } 10 }"}, {"sha": "e15d59d947a3622630afaa67df0bba2ca58e094e", "filename": "gcc/testsuite/g++.dg/gomp/taskgroup-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftaskgroup-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftaskgroup-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftaskgroup-1.C?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -30,5 +30,5 @@ foo (int x)\n   }\n }\n \n-// { dg-error \"invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 8 }\n+// { dg-error \"invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 8 }\n // { dg-error \"invalid entry to OpenMP structured block\" \"\" { target *-*-* } 10 }"}, {"sha": "2b00bb614731ae160b47bace9e7a77fb5f52cb19", "filename": "gcc/testsuite/g++.dg/gomp/teams-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fteams-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fteams-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fteams-1.C?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -64,7 +64,7 @@ bar (int x)\n   }\n }\n \n-// { dg-error \"invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 8 }\n+// { dg-error \"invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 8 }\n // { dg-error \"invalid entry to OpenMP structured block\" \"\" { target *-*-* } 10 }\n-// { dg-error \"invalid branch to/from an OpenMP structured block\" \"\" { target *-*-* } 39 }\n+// { dg-error \"invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 39 }\n // { dg-error \"invalid entry to OpenMP structured block\" \"\" { target *-*-* } 41 }"}, {"sha": "6adabf4ae067b7202f31879acb0ac265cf6fb12f", "filename": "gcc/testsuite/gcc.dg/cilk-plus/jump-openmp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump-openmp.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -11,7 +11,7 @@ void foo()\n     {\n       a[i] = b[i];\n       if (c == 5)\n-\treturn; /* { dg-error \"invalid branch to/from a Cilk Plus structured block\" } */\n+\treturn; /* { dg-error \"invalid branch to/from Cilk Plus structured block\" } */\n     }\n }\n \n@@ -31,7 +31,7 @@ void baz()\n {\n   bad1:\n   #pragma omp parallel\n-    goto bad1; /* { dg-error \"invalid branch to/from an OpenMP structured block\" } */\n+    goto bad1; /* { dg-error \"invalid branch to/from OpenMP structured block\" } */\n \n   goto bad2; /* { dg-error \"invalid entry to OpenMP structured block\" } */\n   #pragma omp parallel"}, {"sha": "1ca886a645f2aa4d51b61fdd8fbdf4748ffe394b", "filename": "gcc/testsuite/gcc.dg/cilk-plus/jump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -10,7 +10,7 @@ void foo()\n     {\n       a[i] = b[i];\n       if (c == 5)\n-\treturn;\t /* { dg-error \"invalid branch to.from a Cilk\" } */\n+\treturn; /* { dg-error \"invalid branch to/from Cilk Plus structured block\" } */\n     }\n }\n \n@@ -23,5 +23,5 @@ void bar()\n       a[i] = b[i];\n     }\n   if (c == 6)\n-    goto lab; /* { dg-error \"invalid entry to Cilk Plus\" } */\n+    goto lab; /* { dg-error \"invalid entry to Cilk Plus structured block\" } */\n }"}, {"sha": "50365bdb3096d54142652728e859efc94c134452", "filename": "gcc/testsuite/gcc.dg/goacc-gomp/goacc-gomp.exp", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc-gomp%2Fgoacc-gomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc-gomp%2Fgoacc-gomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc-gomp%2Fgoacc-gomp.exp?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,38 @@\n+# Copyright (C) 2006-2015 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+if { ![check_effective_target_fopenacc] \\\n+     || ![check_effective_target_fopenmp] } {\n+  return\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [concat \\\n+\t[find $srcdir/$subdir *.c] \\\n+\t[find $srcdir/c-c++-common/goacc-gomp *.c]]] \"\" \"-fopenacc -fopenmp\"\n+\n+# All done.\n+dg-finish"}, {"sha": "1a0276e04d2baa80490e3249d4977792684deb83", "filename": "gcc/testsuite/gcc.dg/goacc/acc_on_device-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Facc_on_device-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Facc_on_device-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Facc_on_device-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,20 @@\n+/* Have to enable optimizations, as otherwise builtins won't be expanded.  */\n+/* { dg-additional-options \"-O -fdump-rtl-expand -std=c89 -Wno-implicit-function-declaration\" } */\n+\n+int\n+f (void)\n+{\n+  int r = 0;\n+\n+  r |= acc_on_device ();\n+  r |= acc_on_device (1, 2);\n+  r |= acc_on_device (3.14);\n+  r |= acc_on_device (\"hello\");\n+\n+  return r;\n+}\n+\n+/* Unsuitable to be handled as a builtin, so we're expecting four calls.\n+   { dg-final { scan-rtl-dump-times \"\\\\\\(call \\[^\\\\n\\]*\\\\\\\"acc_on_device\" 4 \"expand\" } } */\n+\n+/* { dg-final { cleanup-rtl-dump \"expand\" } } */"}, {"sha": "dd8c424d683bad2e1221314c274ad6f91e299fa8", "filename": "gcc/testsuite/gcc.dg/goacc/goacc.exp", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Fgoacc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Fgoacc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgoacc%2Fgoacc.exp?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,37 @@\n+# Copyright (C) 2006-2015 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+if ![check_effective_target_fopenacc] {\n+  return\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [concat \\\n+\t[find $srcdir/$subdir *.c] \\\n+\t[find $srcdir/c-c++-common/goacc *.c]]] \"\" \"-fopenacc\"\n+\n+# All done.\n+dg-finish"}, {"sha": "e67e6c3fce59bdd6d752f864728ff189efc0ea2e", "filename": "gcc/testsuite/gcc.dg/gomp/block-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -4,9 +4,9 @@ void foo()\n {\n   bad1:\n   #pragma omp parallel\n-    goto bad1;\t\t\t// { dg-error \"invalid branch\" }\n+    goto bad1; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n \n-  goto bad2;\t\t\t// { dg-error \"invalid entry\" }\n+  goto bad2; // { dg-error \"invalid entry to OpenMP structured block\" }\n   #pragma omp parallel\n     {\n       bad2: ;"}, {"sha": "69ae3c0cf6e6ac4c11f353dddec0c65d8862e33c", "filename": "gcc/testsuite/gcc.dg/gomp/block-10.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-10.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -3,36 +3,36 @@\n void foo(int i)\n {\n   int j;\n-  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  switch (i) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp parallel\n     { case 0:; }\n   }\n-  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  switch (i) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp for\n     for (j = 0; j < 10; ++ j)\n       { case 1:; }\n   }\n-  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  switch (i) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp critical\n     { case 2:; }\n   }\n-  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  switch (i) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp master\n     { case 3:; }\n   }\n-  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  switch (i) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp sections\n     { case 4:;\n     #pragma omp section\n        { case 5:; }\n     }\n   }\n-  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  switch (i) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp ordered\n     { default:; }"}, {"sha": "5c014633b67ae0e394246d4dce78514455678355", "filename": "gcc/testsuite/gcc.dg/gomp/block-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -11,9 +11,9 @@ void foo()\n   bad1:\n   #pragma omp for\n   for (i = 0; i < 10; ++i)\n-    goto bad1;\t\t\t// { dg-error \"invalid branch\" }\n+    goto bad1; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n \n-  goto bad2;\t\t\t// { dg-error \"invalid entry\" }\n+  goto bad2; // { dg-error \"invalid entry to OpenMP structured block\" }\n   #pragma omp for\n   for (i = 0; i < 10; ++i)\n     {"}, {"sha": "0b21cb3923cfc6742e8ba8dfb31e79058b2f5745", "filename": "gcc/testsuite/gcc.dg/gomp/block-3.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-3.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -9,7 +9,7 @@ void foo()\n     {\n       #pragma omp sections\n       {\n-\tcontinue;\t\t// { dg-error \"invalid branch\" }\n+\tcontinue; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n       }\n     }\n \n@@ -18,16 +18,16 @@ void foo()\n     #pragma omp section\n       { bad1: ; }\n     #pragma omp section\n-      goto bad1;\t\t// { dg-error \"invalid branch\" }\n+      goto bad1; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n     }\n \n   #pragma omp sections\n     {\n-      goto bad2;\t\t// { dg-error \"invalid branch\" }\n+      goto bad2; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n     }\n   bad2:;\n \n-  goto bad3;\t\t\t// { dg-error \"invalid entry\" }\n+  goto bad3; // { dg-error \"invalid entry to OpenMP structured block\" }\n   #pragma omp sections\n     {\n       bad3: ;"}, {"sha": "b2ef9b1d60499959fdf12d3212787fd7fe70d540", "filename": "gcc/testsuite/gcc.dg/gomp/block-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-4.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -4,6 +4,6 @@ void foo()\n {\n   #pragma omp critical\n     {\n-      return;\t\t// { dg-error \"invalid branch\" }\n+      return; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n     }\n }"}, {"sha": "7f3b37c8d22c72815bd5bc0ad6118243a081fb2d", "filename": "gcc/testsuite/gcc.dg/gomp/block-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-5.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -4,12 +4,12 @@ void foo()\n {\n   #pragma omp master\n     {\n-      goto bad1;\t// { dg-error \"invalid branch\" }\n+      goto bad1; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n     }\n \n   #pragma omp master\n     {\n     bad1:\n-      return;\t\t// { dg-error \"invalid branch\" }\n+      return; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n     }\n }"}, {"sha": "fc9fdc84672df50ab9264d433c48066133ae3d1f", "filename": "gcc/testsuite/gcc.dg/gomp/block-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-6.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -4,6 +4,6 @@ void foo()\n {\n   #pragma omp ordered\n     {\n-      return;\t\t// { dg-error \"invalid branch\" }\n+      return; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n     }\n }"}, {"sha": "6219e7e46622376c06a91d2415ac3d16b85d9824", "filename": "gcc/testsuite/gcc.dg/gomp/block-7.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -6,15 +6,15 @@ void foo()\n   for (i = 0; i < 10; ++i)\n     {\n       #pragma omp for\n-      for (j = ({ continue; 0; });\t// { dg-error \"invalid branch\" }\n-\t   j < ({ continue; 10; });\t// { dg-error \"invalid branch\" }\n-\t   j += ({ continue; 1; }))\t// { dg-error \"invalid branch\" }\n+      for (j = ({ continue; 0; }); // { dg-error \"invalid branch to/from OpenMP structured block\" }\n+\t   j < ({ continue; 10; }); // { dg-error \"invalid branch to/from OpenMP structured block\" }\n+\t   j += ({ continue; 1; })) // { dg-error \"invalid branch to/from OpenMP structured block\" }\n \tcontinue;\n \n       #pragma omp for\n-      for (j = ({ break; 0; });\t\t// { dg-error \"invalid branch\" }\n-\t   j < ({ break; 10; });\t// { dg-error \"invalid branch\" }\n-\t   j += ({ break; 1; }))\t// { dg-error \"invalid branch\" }\n+      for (j = ({ break; 0; }); // { dg-error \"invalid branch to/from OpenMP structured block\" }\n+\t   j < ({ break; 10; }); // { dg-error \"invalid branch to/from OpenMP structured block\" }\n+\t   j += ({ break; 1; })) // { dg-error \"invalid branch to/from OpenMP structured block\" }\n \tbreak;\t\t\t\t// { dg-error \"break\" }\n     }\n }"}, {"sha": "f41007060e8cd452e9a4aa3e7421e80c7f44aa57", "filename": "gcc/testsuite/gcc.dg/gomp/block-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-8.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -7,5 +7,5 @@ int foo()\n \n   #pragma omp parallel for\n   for (i = 0; i < 10; ++i)\n-    return 0;\t\t\t// { dg-error \"invalid branch\" }\n+    return 0; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n }"}, {"sha": "2fae3deafd5678ba9752cb6d301f2494c5ca5ddc", "filename": "gcc/testsuite/gcc.dg/gomp/block-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-9.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -3,7 +3,7 @@\n void foo(int i)\n {\n   int j;\n-  switch (i)\t\t\t// { dg-error \"invalid entry\" }\n+  switch (i) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp parallel\n     { case 0:; }"}, {"sha": "aaa6a14577995bdc1969b18441dbde47d014814c", "filename": "gcc/testsuite/gcc.dg/gomp/target-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -5,9 +5,9 @@ foo (int x)\n {\n   bad1:\n   #pragma omp target\n-    goto bad1;\t\t\t/* { dg-error \"invalid branch\" } */\n+    goto bad1; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n \n-  goto bad2;\t\t\t/* { dg-error \"invalid entry\" } */\n+  goto bad2; // { dg-error \"invalid entry to OpenMP structured block\" }\n   #pragma omp target\n     {\n       bad2: ;\n@@ -21,7 +21,7 @@ foo (int x)\n \t{ ok1: break; }\n     }\n \n-  switch (x)\t\t\t/* { dg-error \"invalid entry\" } */\n+  switch (x) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp target\n     { case 0:; }"}, {"sha": "3a7afc4892b0dee4020c962bfab9fc3544ac0104", "filename": "gcc/testsuite/gcc.dg/gomp/target-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -5,9 +5,9 @@ foo (int x, int y)\n {\n   bad1:\n   #pragma omp target data map(tofrom: y)\n-    goto bad1;\t\t\t/* { dg-error \"invalid branch\" } */\n+    goto bad1; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n \n-  goto bad2;\t\t\t/* { dg-error \"invalid entry\" } */\n+  goto bad2; // { dg-error \"invalid entry to OpenMP structured block\" }\n   #pragma omp target data map(tofrom: y)\n     {\n       bad2: ;\n@@ -21,7 +21,7 @@ foo (int x, int y)\n \t{ ok1: break; }\n     }\n \n-  switch (x)\t\t\t/* { dg-error \"invalid entry\" } */\n+  switch (x) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp target data map(tofrom: y)\n     { case 0:; }"}, {"sha": "1997e0c158d798ccaf8d28ea1eb805c65845aca3", "filename": "gcc/testsuite/gcc.dg/gomp/taskgroup-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftaskgroup-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftaskgroup-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftaskgroup-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -5,9 +5,9 @@ foo (int x)\n {\n   bad1:\n   #pragma omp taskgroup\n-    goto bad1;\t\t\t/* { dg-error \"invalid branch\" } */\n+    goto bad1; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n \n-  goto bad2;\t\t\t/* { dg-error \"invalid entry\" } */\n+  goto bad2; // { dg-error \"invalid entry to OpenMP structured block\" }\n   #pragma omp taskgroup\n     {\n       bad2: ;\n@@ -21,7 +21,7 @@ foo (int x)\n \t{ ok1: break; }\n     }\n \n-  switch (x)\t\t\t/* { dg-error \"invalid entry\" } */\n+  switch (x) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp taskgroup\n     { case 0:; }"}, {"sha": "ad5b100efc9a897f2972bc6e60f4dfb0ec6a59a3", "filename": "gcc/testsuite/gcc.dg/gomp/teams-1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fteams-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fteams-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fteams-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -5,9 +5,9 @@ foo (int x)\n {\n   bad1:\n   #pragma omp target teams\n-    goto bad1;\t\t\t/* { dg-error \"invalid branch\" } */\n+    goto bad1; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n \n-  goto bad2;\t\t\t/* { dg-error \"invalid entry\" } */\n+  goto bad2; // { dg-error \"invalid entry to OpenMP structured block\" }\n   #pragma omp target teams\n     {\n       bad2: ;\n@@ -21,7 +21,7 @@ foo (int x)\n \t{ ok1: break; }\n     }\n \n-  switch (x)\t\t\t/* { dg-error \"invalid entry\" } */\n+  switch (x) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp target teams\n     { case 0:; }\n@@ -34,9 +34,9 @@ bar (int x)\n   bad1:\n   #pragma omp target\n   #pragma omp teams\n-    goto bad1;\t\t\t/* { dg-error \"invalid branch\" } */\n+    goto bad1; // { dg-error \"invalid branch to/from OpenMP structured block\" }\n \n-  goto bad2;\t\t\t/* { dg-error \"invalid entry\" } */\n+  goto bad2; // { dg-error \"invalid entry to OpenMP structured block\" }\n   #pragma omp target\n   #pragma omp teams\n     {\n@@ -52,7 +52,7 @@ bar (int x)\n \t{ ok1: break; }\n     }\n \n-  switch (x)\t\t\t/* { dg-error \"invalid entry\" } */\n+  switch (x) // { dg-error \"invalid entry to OpenMP structured block\" }\n   {\n   #pragma omp target\n   #pragma omp teams"}, {"sha": "9dfde26f76b98aab358c1abe6e2454ff6823a49c", "filename": "gcc/testsuite/gfortran.dg/goacc/acc_on_device-1.f95", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-1.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,22 @@\n+! Have to enable optimizations, as otherwise builtins won't be expanded.\n+! { dg-additional-options \"-O -fdump-rtl-expand\" }\n+\n+logical function f ()\n+  implicit none\n+\n+  external acc_on_device\n+  logical (4) acc_on_device\n+\n+  f = .false.\n+  f = f .or. acc_on_device ()\n+  f = f .or. acc_on_device (1, 2)\n+  f = f .or. acc_on_device (3.14)\n+  f = f .or. acc_on_device (\"hello\")\n+\n+  return\n+end function f\n+\n+! Unsuitable to be handled as a builtin, so we're expecting four calls.\n+! { dg-final { scan-rtl-dump-times \"\\\\\\(call \\[^\\\\n\\]*\\\\\\\"acc_on_device\" 4 \"expand\" } }\n+\n+! { dg-final { cleanup-rtl-dump \"expand\" } }"}, {"sha": "cf2826475a3f4e0eecc04bd0d900613eaf336812", "filename": "gcc/testsuite/gfortran.dg/goacc/acc_on_device-2-off.f95", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-2-off.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-2-off.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-2-off.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,39 @@\n+! Have to enable optimizations, as otherwise builtins won't be expanded.\n+! { dg-additional-options \"-O -fdump-rtl-expand -fno-openacc\" }\n+\n+module openacc_kinds\n+  implicit none\n+\n+  integer, parameter :: acc_device_kind = 4\n+\n+end module openacc_kinds\n+\n+module openacc\n+  use openacc_kinds\n+  implicit none\n+\n+  integer (acc_device_kind), parameter :: acc_device_host = 2\n+\n+  interface\n+     function acc_on_device (dev)\n+       use openacc_kinds\n+       logical (4) :: acc_on_device\n+       integer (acc_device_kind), intent (in) :: dev\n+     end function acc_on_device\n+  end interface\n+end module openacc\n+\n+logical (4) function f ()\n+  use openacc\n+  implicit none\n+\n+  integer (4), parameter :: dev = 2\n+\n+  f = acc_on_device (dev)\n+  return\n+end function f\n+\n+! Without -fopenacc, we're expecting one call.\n+! { dg-final { scan-rtl-dump-times \"\\\\\\(call \\[^\\\\n\\]*\\\\\\\"acc_on_device\" 1 \"expand\" } }\n+\n+! { dg-final { cleanup-rtl-dump \"expand\" } }"}, {"sha": "7730a60a7dcca6454440e9009fbb7988da363421", "filename": "gcc/testsuite/gfortran.dg/goacc/acc_on_device-2.f95", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Facc_on_device-2.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,40 @@\n+! Have to enable optimizations, as otherwise builtins won't be expanded.\n+! { dg-additional-options \"-O -fdump-rtl-expand\" }\n+\n+module openacc_kinds\n+  implicit none\n+\n+  integer, parameter :: acc_device_kind = 4\n+\n+end module openacc_kinds\n+\n+module openacc\n+  use openacc_kinds\n+  implicit none\n+\n+  integer (acc_device_kind), parameter :: acc_device_host = 2\n+\n+  interface\n+     function acc_on_device (dev)\n+       use openacc_kinds\n+       logical (4) :: acc_on_device\n+       integer (acc_device_kind), intent (in) :: dev\n+     end function acc_on_device\n+  end interface\n+end module openacc\n+\n+logical (4) function f ()\n+  use openacc\n+  implicit none\n+\n+  integer (4), parameter :: dev = 2\n+\n+  f = acc_on_device (dev)\n+  return\n+end function f\n+\n+! With -fopenacc, we're expecting the builtin to be expanded, so no calls.\n+! TODO: not working.\n+! { dg-final { scan-rtl-dump-times \"\\\\\\(call \\[^\\\\n\\]*\\\\\\\"acc_on_device\" 0 \"expand\" { xfail *-*-* } } }\n+\n+! { dg-final { cleanup-rtl-dump \"expand\" } }"}, {"sha": "328724107eb511405b45bb169366e582473138e1", "filename": "gcc/testsuite/gfortran.dg/goacc/assumed.f95", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fassumed.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fassumed.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fassumed.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fmax-errors=100\" } \n+\n+module test\n+contains\n+  subroutine assumed_size(a)\n+    implicit none\n+    integer :: a(*), i\n+    !$acc declare device_resident (a) ! { dg-error \"Assumed size\" }\n+    !$acc data copy (a) ! { dg-error \"Assumed size\" }\n+    !$acc end data\n+    !$acc data deviceptr (a) ! { dg-error \"Assumed size\" }\n+    !$acc end data\n+    !$acc parallel private (a) ! { dg-error \"Assumed size\" }\n+    !$acc end parallel\n+    !$acc host_data use_device (a) ! { dg-error \"Assumed size\" }\n+    !$acc end host_data\n+    !$acc parallel loop reduction(+:a) ! { dg-error \"Assumed size\" }\n+    do i = 1,5\n+    enddo\n+    !$acc end parallel loop\n+    !$acc update device (a) ! { dg-error \"Assumed size\" }\n+    !$acc update host (a) ! { dg-error \"Assumed size\" }\n+    !$acc update self (a) ! { dg-error \"Assumed size\" }\n+  end subroutine assumed_size\n+  subroutine assumed_rank(a)\n+    implicit none\n+    integer, intent(in) :: a(..)\n+    integer :: i\n+    !$acc declare device_resident (a) ! { dg-error \"Assumed rank\" }\n+    !$acc data copy (a) ! { dg-error \"Assumed rank\" }\n+    !$acc end data\n+    !$acc data deviceptr (a) ! { dg-error \"Assumed rank\" }\n+    !$acc end data\n+    !$acc parallel private (a) ! { dg-error \"Assumed rank\" }\n+    !$acc end parallel\n+    !$acc host_data use_device (a) ! { dg-error \"Assumed rank\" }\n+    !$acc end host_data\n+    !$acc parallel loop reduction(+:a) ! { dg-error \"Assumed rank\" }\n+    do i = 1,5\n+    enddo\n+    !$acc end parallel loop\n+    !$acc update device (a) ! { dg-error \"Assumed rank\" }\n+    !$acc update host (a) ! { dg-error \"Assumed rank\" }\n+    !$acc update self (a) ! { dg-error \"Assumed rank\" }\n+  end subroutine assumed_rank\n+end module test"}, {"sha": "d630d388ef74f783678f58602f6d9287e0ad1394", "filename": "gcc/testsuite/gfortran.dg/goacc/asyncwait-1.f95", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-1.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,91 @@\n+! { dg-do compile }\n+\n+program asyncwait\n+  integer, parameter :: N = 64\n+  real, allocatable :: a(:), b(:)\n+  integer i\n+\n+  allocate (a(N))\n+  allocate (b(N))\n+\n+  a(:) = 3.0\n+  b(:) = 0.0\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (1 2) ! { dg-error \"Unclassifiable OpenACC directive\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (1,) ! { dg-error \"Unclassifiable OpenACC directive\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (,1) ! { dg-error \"Invalid character in name\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (1,2,) ! { dg-error \"Unclassifiable OpenACC directive\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (1,2 3) ! { dg-error \"Unclassifiable OpenACC directive\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (1,2,,) ! { dg-error \"Unclassifiable OpenACC directive\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (1  ! { dg-error \"Unclassifiable OpenACC directive\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (*) ! { dg-error \"Invalid character in name at\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (a) ! { dg-error \"ASYNC clause at \\\\\\(1\\\\\\) requires a scalar INTEGER expression\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (N)\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async (1.0) ! { dg-error \"ASYNC clause at \\\\\\(1\\\\\\) requires a scalar INTEGER expression\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async () ! { dg-error \"Invalid character in name at \" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) async\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel\n+end program asyncwait"}, {"sha": "db0ce1f912a555a4b18d4290438189f4bba36e3d", "filename": "gcc/testsuite/gfortran.dg/goacc/asyncwait-2.f95", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-2.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,91 @@\n+! { dg-do compile }\n+\n+program asyncwait\n+  integer, parameter :: N = 64\n+  real, allocatable :: a(:), b(:)\n+  integer i\n+\n+  allocate (a(N))\n+  allocate (b(N))\n+\n+  a(:) = 3.0\n+  b(:) = 0.0\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (1 2) ! { dg-error \"Syntax error in OpenACC expression list\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (1,) ! { dg-error \"Syntax error in OpenACC expression list\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (,1) ! { dg-error \"Syntax error in OpenACC expression list\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (1,2,) ! { dg-error \"Syntax error in OpenACC expression list\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (1,2 3) ! { dg-error \"Syntax error in OpenACC expression list\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (1,2,,) ! { dg-error \"Syntax error in OpenACC expression list\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (1 ! { dg-error \"Syntax error in OpenACC expression list\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (*) ! { dg-error \"Syntax error in OpenACC expression list\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (a) ! { dg-error \"WAIT clause at \\\\\\(1\\\\\\) requires a scalar INTEGER expression\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (N)\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait (1.0) ! { dg-error \"WAIT clause at \\\\\\(1\\\\\\) requires a scalar INTEGER expression\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait () ! { dg-error \"Syntax error in OpenACC expression list\" }\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC END PARALLEL\" }\n+\n+  !$acc parallel copyin (a(1:N)) copy (b(1:N)) wait\n+  do i = 1, N\n+     b(i) = a(i)\n+  end do\n+  !$acc end parallel\n+end program asyncwait"}, {"sha": "32c11def6f76f0c047cc5e8b94475a6a7cf675e5", "filename": "gcc/testsuite/gfortran.dg/goacc/asyncwait-3.f95", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-3.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-3.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-3.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+\n+program asyncwait\n+  integer, parameter :: N = 64\n+  real, allocatable :: a(:), b(:)\n+  integer i\n+\n+  allocate (a(N))\n+  allocate (b(N))\n+\n+  a(:) = 3.0\n+  b(:) = 0.0\n+\n+  !$acc wait (1 2) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait (1,) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait (,1) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait (1, 2, ) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait (1, 2, ,) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait (1 ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait (1, *) ! { dg-error \"Invalid argument to \\\\\\$\\\\\\!ACC WAIT\" }\n+\n+  !$acc wait (1, a) ! { dg-error \"WAIT clause at \\\\\\(1\\\\\\) requires a scalar INTEGER expression\" }\n+\n+  !$acc wait (a) ! { dg-error \"WAIT clause at \\\\\\(1\\\\\\) requires a scalar INTEGER expression\" }\n+\n+  !$acc wait (N) \n+\n+  !$acc wait (1.0) ! { dg-error \"WAIT clause at \\\\\\(1\\\\\\) requires a scalar INTEGER expression\" }\n+\n+  !$acc wait 1 ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait N ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait (1)\n+end program asyncwait"}, {"sha": "cd64ef3d387c157aadc8c60e2bf051bd19a3469d", "filename": "gcc/testsuite/gfortran.dg/goacc/asyncwait-4.f95", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-4.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-4.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fasyncwait-4.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+\n+program asyncwait\n+  integer, parameter :: N = 64\n+  real, allocatable :: a(:), b(:)\n+  integer i\n+\n+  allocate (a(N))\n+  allocate (b(N))\n+\n+  a(:) = 3.0\n+  b(:) = 0.0\n+\n+  !$acc wait async (1 2) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait async (1,) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait async (,1) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait async (1, 2, ) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait async (1, 2, ,) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait async (1 ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait async (1, *) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait async (1, a) ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+\n+  !$acc wait async (a) ! { dg-error \"ASYNC clause at \\\\\\(1\\\\\\) requires a scalar INTEGER expression\" }\n+\n+  !$acc wait async (N)\n+\n+  !$acc wait async (1.0) ! { dg-error \"ASYNC clause at \\\\\\(1\\\\\\) requires a scalar INTEGER expression\" }\n+\n+  !$acc wait async 1 ! { dg-error \"Unexpected junk in \\\\\\!\\\\\\$ACC WAIT at\" }\n+end program asyncwait"}, {"sha": "7eed3e209db11a6dbcd67fc899f9c8bad0533774", "filename": "gcc/testsuite/gfortran.dg/goacc/branch.f95", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fbranch.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fbranch.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fbranch.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do compile } \n+\n+program test\n+  implicit none\n+\n+  integer :: i\n+\n+  if (.true.) then\n+    !$acc parallel \n+  end if ! { dg-error \"Unexpected\" }\n+  !$acc end parallel \n+  end if\n+\n+  if (.true.) then\n+    !$acc kernels \n+  end if ! { dg-error \"Unexpected\" }\n+  !$acc end kernels \n+  end if\n+\n+  !$acc parallel\n+  if (.true.) then\n+    !$acc end parallel ! { dg-error \"Unexpected\" }\n+  end if \n+  !$acc end parallel\n+\n+  !$acc kernels\n+  if (.true.) then\n+    !$acc end kernels ! { dg-error \"Unexpected\" }\n+  end if \n+  !$acc end kernels\n+\n+  !$acc parallel\n+  if (.true.) then\n+  end if\n+  !$acc end parallel\n+\n+  !$acc kernels\n+  if (.true.) then\n+  end if\n+  !$acc end kernels\n+\n+  if (.true.) then\n+    !$acc parallel\n+    !$acc end parallel\n+  end if\n+\n+  if (.true.) then\n+    !$acc kernels\n+    !$acc end kernels\n+  end if\n+\n+\n+end program test \n\\ No newline at end of file"}, {"sha": "746cf02f688f66a28b311d614dad217893d6da8a", "filename": "gcc/testsuite/gfortran.dg/goacc/cache-1.f95", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcache-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcache-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcache-1.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-std=f2008\" }\n+\n+program test\n+  implicit none\n+  integer :: i, d(10)\n+\n+  do concurrent (i=1:5)\n+    !$acc cache (d)\n+  enddo\n+end\n+! { dg-prune-output \"unimplemented\" }"}, {"sha": "4f1224edc2a901d68497b1281d45c18cdc4d21d7", "filename": "gcc/testsuite/gfortran.dg/goacc/coarray.f95", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcoarray.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcoarray.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcoarray.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fcoarray=single\" }\n+\n+! TODO: These cases must fail\n+\n+module test\n+contains\n+  subroutine oacc1(a)\n+    implicit none\n+    integer :: i\n+    integer, codimension[*] :: a\n+    !$acc declare device_resident (a)\n+    !$acc data copy (a)\n+    !$acc end data\n+    !$acc data deviceptr (a)\n+    !$acc end data\n+    !$acc parallel private (a)\n+    !$acc end parallel\n+    !$acc host_data use_device (a)\n+    !$acc end host_data\n+    !$acc parallel loop reduction(+:a)\n+    do i = 1,5\n+    enddo\n+    !$acc end parallel loop\n+    !$acc parallel loop\n+    do i = 1,5\n+      !$acc cache (a)\n+    enddo\n+    !$acc end parallel loop\n+    !$acc update device (a)\n+    !$acc update host (a)\n+    !$acc update self (a)\n+  end subroutine oacc1\n+end module test\n+! { dg-prune-output \"ACC cache unimplemented\" }"}, {"sha": "1c9a3f3352606576a4d9d2e875f62f824ee558e5", "filename": "gcc/testsuite/gfortran.dg/goacc/continuation-free-form.f95", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcontinuation-free-form.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcontinuation-free-form.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcontinuation-free-form.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile } \n+\n+program test\n+  implicit none\n+\n+  integer :: i\n+  real :: x\n+\n+  !$acc parallel &\n+  !$acc loop & ! continuation\n+  !$acc & reduction(+:x)\n+\n+  ! this line must be ignored\n+  !$acc ! kernels\n+  do i = 1,10\n+    x = x + 0.3\n+  enddo\n+  ! continuation must begin with sentinel\n+  !$acc end parallel & ! { dg-error \"Unclassifiable OpenACC directive\" }\n+  ! loop\n+\n+  print *, x\n+end\n\\ No newline at end of file"}, {"sha": "8f2c077beee44c42a0852a851e1de3df01501999", "filename": "gcc/testsuite/gfortran.dg/goacc/cray.f95", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcray.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcray.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcray.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fcray-pointer\" }\n+\n+module test\n+contains\n+  subroutine oacc1\n+    implicit none\n+    integer :: i\n+    real :: pointee\n+    pointer (ptr, pointee)\n+    !$acc declare device_resident (pointee) \n+    !$acc declare device_resident (ptr) \n+    !$acc data copy (pointee) ! { dg-error \"Cray pointee\" }\n+    !$acc end data\n+    !$acc data deviceptr (pointee) ! { dg-error \"Cray pointee\" }\n+    !$acc end data\n+    !$acc parallel private (pointee) ! { dg-error \"Cray pointee\" }\n+    !$acc end parallel\n+    !$acc host_data use_device (pointee) ! { dg-error \"Cray pointee\" }\n+    !$acc end host_data\n+    !$acc parallel loop reduction(+:pointee) ! { dg-error \"Cray pointee\" }\n+    do i = 1,5\n+    enddo\n+    !$acc end parallel loop\n+    !$acc parallel loop\n+    do i = 1,5\n+      ! Subarrays are not implemented yet\n+      !$acc cache (pointee) ! TODO: This must fail, as in openacc-1_0-branch\n+    enddo\n+    !$acc end parallel loop\n+    !$acc update device (pointee) ! { dg-error \"Cray pointee\" }\n+    !$acc update host (pointee) ! { dg-error \"Cray pointee\" }\n+    !$acc update self (pointee) ! { dg-error \"Cray pointee\" }\n+    !$acc data copy (ptr)\n+    !$acc end data\n+    !$acc data deviceptr (ptr) ! { dg-error \"Cray pointer\" }\n+    !$acc end data\n+    !$acc parallel private (ptr)\n+    !$acc end parallel\n+    !$acc host_data use_device (ptr) ! { dg-error \"Cray pointer\" }\n+    !$acc end host_data\n+    !$acc parallel loop reduction(+:ptr) ! { dg-error \"Cray pointer\" }\n+    do i = 1,5\n+    enddo\n+    !$acc end parallel loop\n+    !$acc parallel loop\n+    do i = 1,5\n+      !$acc cache (ptr) ! TODO: This must fail, as in openacc-1_0-branch\n+    enddo\n+    !$acc end parallel loop\n+    !$acc update device (ptr)\n+    !$acc update host (ptr)\n+    !$acc update self (ptr)\n+  end subroutine oacc1\n+end module test\n+! { dg-prune-output \"unimplemented\" }"}, {"sha": "510ea1850527a83d21493b6ae4f40a939295da31", "filename": "gcc/testsuite/gfortran.dg/goacc/critical.f95", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcritical.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcritical.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fcritical.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fcoarray=single\" }\n+\n+module test\n+contains\n+  subroutine oacc1\n+  implicit none\n+  integer :: i, j\n+  j = 0\n+  !$acc parallel \n+  critical ! { dg-error \"CRITICAL block inside of\" }\n+    j = j + 1\n+  end critical\n+  !$acc end parallel\n+  end subroutine oacc1\n+\n+  subroutine oacc2\n+  implicit none\n+  integer :: i, j\n+  j = 0\n+  critical\n+    !$acc parallel ! { dg-error \"OpenACC directive inside of\" }\n+      j = j + 1\n+    !$acc end parallel\n+  end critical\n+  end subroutine oacc2\n+end module test\n\\ No newline at end of file"}, {"sha": "b94214e8b63eeff1d7733d86514c50eb282301a9", "filename": "gcc/testsuite/gfortran.dg/goacc/data-clauses.f95", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdata-clauses.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdata-clauses.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdata-clauses.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,259 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fmax-errors=100\" } \n+\n+module test \n+  implicit none\n+contains\n+\n+  subroutine foo (vi, asa)\n+  integer, value :: vi\n+  integer :: i, ia(10)\n+  complex :: c, ca(10)\n+  real, target:: r\n+  real :: ra(10)\n+  real, pointer :: rp\n+  real, dimension(:), allocatable :: aa\n+  real, dimension(:) :: asa\n+  type t\n+    integer :: i\n+  end type\n+  type(t) :: ti\n+  type(t), allocatable :: tia\n+  type(t), target :: tit\n+  type(t), pointer :: tip\n+  rp => r\n+  tip => tit\n+\n+  !$acc parallel deviceptr (rp) ! { dg-error \"POINTER\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (vi) ! { dg-error \"VALUE\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (aa) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc end parallel\n+\n+  !$acc parallel deviceptr (i, c, r, ia, ca, ra, asa, ti)\n+  !$acc end parallel\n+  !$acc kernels deviceptr (i, c, r, ia, ca, ra, asa, ti)\n+  !$acc end kernels\n+  !$acc data deviceptr (i, c, r, ia, ca, ra, asa, ti)\n+  !$acc end data\n+\n+\n+  !$acc parallel copy (tip) ! { dg-error \"POINTER\" }\n+  !$acc end parallel\n+  !$acc parallel copy (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (i) copy (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel copy (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc kernels copy (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end kernels\n+  !$acc data copy (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end data\n+\n+\n+  !$acc parallel copyin (tip) ! { dg-error \"POINTER\" }\n+  !$acc end parallel\n+  !$acc parallel copyin (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (i) copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copy (i) copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel copyin (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc kernels copyin (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end kernels\n+  !$acc data copyin (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end data\n+\n+\n+  !$acc parallel copyout (tip) ! { dg-error \"POINTER\" }\n+  !$acc end parallel\n+  !$acc parallel copyout (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (i) copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copy (i) copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyin (i) copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel copyout (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc kernels copyout (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end kernels\n+  !$acc data copyout (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end data\n+\n+\n+  !$acc parallel create (tip) ! { dg-error \"POINTER\" }\n+  !$acc end parallel\n+  !$acc parallel create (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (i) create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copy (i) create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyin (i) create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyout (i) create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel create (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc kernels create (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end kernels\n+  !$acc data create (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end data\n+\n+\n+  !$acc parallel present (tip) ! { dg-error \"POINTER\" }\n+  !$acc end parallel\n+  !$acc parallel present (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (i) present (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copy (i) present (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyin (i) present (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyout (i) present (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel create (i) present (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel present (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc kernels present (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end kernels\n+  !$acc data present (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end data\n+\n+\n+  !$acc parallel pcopy (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc parallel pcopyin (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc parallel pcopyout (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc parallel pcreate (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+\n+\n+  !$acc parallel present_or_copy (tip) ! { dg-error \"POINTER\" }\n+  !$acc end parallel\n+  !$acc parallel present_or_copy (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (i) present_or_copy (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copy (i) present_or_copy (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyin (i) present_or_copy (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyout (i) present_or_copy (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel create (i) present_or_copy (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel present (i) present_or_copy (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel present_or_copy (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc kernels present_or_copy (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end kernels\n+  !$acc data present_or_copy (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end data\n+\n+\n+  !$acc parallel present_or_copyin (tip) ! { dg-error \"POINTER\" }\n+  !$acc end parallel\n+  !$acc parallel present_or_copyin (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copy (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyin (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyout (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel create (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel present (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel present_or_copy (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel present_or_copyin (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc kernels present_or_copyin (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end kernels\n+  !$acc data present_or_copyin (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end data\n+\n+\n+  !$acc parallel present_or_copyout (tip) ! { dg-error \"POINTER\" }\n+  !$acc end parallel\n+  !$acc parallel present_or_copyout (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (i) present_or_copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copy (i) present_or_copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyin (i) present_or_copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyout (i) present_or_copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel create (i) present_or_copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel present (i) present_or_copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel present_or_copy (i) present_or_copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel present_or_copyin (i) present_or_copyout (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel present_or_copyout (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc kernels present_or_copyout (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end kernels\n+  !$acc data present_or_copyout (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end data\n+\n+\n+  !$acc parallel present_or_create (tip) ! { dg-error \"POINTER\" }\n+  !$acc end parallel\n+  !$acc parallel present_or_create (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc end parallel\n+  !$acc parallel deviceptr (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copy (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyin (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel copyout (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel create (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel present (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel present_or_copy (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel present_or_copyin (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+  !$acc parallel present_or_copyout (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel present_or_create (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end parallel\n+  !$acc kernels present_or_create (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end kernels\n+  !$acc data present_or_create (i, c, r, ia, ca, ra, asa, rp, ti, vi, aa)\n+  !$acc end data\n+\n+  end subroutine foo\n+end module test\n\\ No newline at end of file"}, {"sha": "32c50fd6b0b77dba3abee117f90f8df1006294be", "filename": "gcc/testsuite/gfortran.dg/goacc/data-tree.f95", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdata-tree.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdata-tree.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdata-tree.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fdump-tree-original\" } \n+\n+program test\n+  implicit none\n+  integer :: q, i, j, k, m, n, o, p, r, s, t, u, v, w\n+  logical :: l\n+\n+  !$acc data if(l) copy(i), copyin(j), copyout(k), create(m) &\n+  !$acc present(o), pcopy(p), pcopyin(r), pcopyout(s), pcreate(t) &\n+  !$acc deviceptr(u)\n+  !$acc end data\n+\n+end program test\n+! { dg-final { scan-tree-dump-times \"pragma acc data\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"if\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"map\\\\(force_tofrom:i\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(force_to:j\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(force_from:k\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(force_alloc:m\\\\)\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"map\\\\(force_present:o\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:p\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(to:r\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(from:s\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:t\\\\)\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"map\\\\(force_deviceptr:u\\\\)\" 1 \"original\" } } \n+! { dg-final { cleanup-tree-dump \"original\" } } "}, {"sha": "03540f13bcf0c846b439c4bbc78bc3acde0fd5c4", "filename": "gcc/testsuite/gfortran.dg/goacc/declare-1.f95", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdeclare-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdeclare-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdeclare-1.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fdump-tree-original\" } \n+\n+program test\n+  implicit none\n+  integer :: i\n+\n+  !$acc declare copy(i)\n+contains\n+  real function foo(n)\n+    integer, value :: n\n+    BLOCK\n+       integer i\n+       !$acc declare copy(i)\n+    END BLOCK\n+  end function foo\n+end program test\n+! { dg-prune-output \"unimplemented\" }\n+! { dg-final { scan-tree-dump-times \"pragma acc declare map\\\\(force_tofrom:i\\\\)\" 2 \"original\" } } \n+! { dg-final { cleanup-tree-dump \"original\" } } "}, {"sha": "8f1715e659d586d5518d6dcc66004bb4314fb82a", "filename": "gcc/testsuite/gfortran.dg/goacc/enter-exit-data.f95", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fenter-exit-data.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fenter-exit-data.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fenter-exit-data.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,88 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fmax-errors=100\" } \n+\n+module test \n+  implicit none\n+contains\n+\n+  subroutine foo (vi)\n+  logical :: l\n+  integer, value :: vi\n+  integer :: i, ia(10), a(10), b(2:8)\n+  complex :: c, ca(10)\n+  real, target:: r\n+  real :: ra(10)\n+  real, pointer :: rp\n+  real, dimension(:), allocatable :: aa\n+  type t\n+  integer :: i\n+  end type\n+  type(t) :: ti\n+  type(t), allocatable :: tia\n+  type(t), target :: tit\n+  type(t), pointer :: tip\n+  rp => r\n+  tip => tit\n+\n+  ! enter data\n+  !$acc enter data\n+  !$acc enter data if (.false.)\n+  !$acc enter data if (l)\n+  !$acc enter data if (.false.) if (l) ! { dg-error \"Unclassifiable\" }\n+  !$acc enter data if (i) ! { dg-error \"LOGICAL\" }\n+  !$acc enter data if (1) ! { dg-error \"LOGICAL\" }\n+  !$acc enter data if (a) ! { dg-error \"LOGICAL\" }\n+  !$acc enter data if (b(5:6)) ! { dg-error \"LOGICAL\" }\n+  !$acc enter data async (l) ! { dg-error \"INTEGER\" }\n+  !$acc enter data async (.true.) ! { dg-error \"INTEGER\" }\n+  !$acc enter data async (1) \n+  !$acc enter data async (i) \n+  !$acc enter data async (a) ! { dg-error \"INTEGER\" }\n+  !$acc enter data async (b(5:6)) ! { dg-error \"INTEGER\" }\n+  !$acc enter data wait (l) ! { dg-error \"INTEGER\" }\n+  !$acc enter data wait (.true.) ! { dg-error \"INTEGER\" }\n+  !$acc enter data wait (i, 1) \n+  !$acc enter data wait (a) ! { dg-error \"INTEGER\" }\n+  !$acc enter data wait (b(5:6)) ! { dg-error \"INTEGER\" }\n+  !$acc enter data copyin (tip) ! { dg-error \"POINTER\" }\n+  !$acc enter data copyin (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc enter data create (tip) ! { dg-error \"POINTER\" }\n+  !$acc enter data create (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc enter data present_or_copyin (tip) ! { dg-error \"POINTER\" }\n+  !$acc enter data present_or_copyin (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc enter data present_or_create (tip) ! { dg-error \"POINTER\" }\n+  !$acc enter data present_or_create (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc enter data copyin (i) create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc enter data copyin (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc enter data create (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n+  !$acc enter data copyin (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc enter data create (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+  !$acc enter data present_or_copyin (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n+\n+  ! exit data\n+  !$acc exit data\n+  !$acc exit data if (.false.)\n+  !$acc exit data if (l)\n+  !$acc exit data if (.false.) if (l) ! { dg-error \"Unclassifiable\" }\n+  !$acc exit data if (i) ! { dg-error \"LOGICAL\" }\n+  !$acc exit data if (1) ! { dg-error \"LOGICAL\" }\n+  !$acc exit data if (a) ! { dg-error \"LOGICAL\" }\n+  !$acc exit data if (b(5:6)) ! { dg-error \"LOGICAL\" }\n+  !$acc exit data async (l) ! { dg-error \"INTEGER\" }\n+  !$acc exit data async (.true.) ! { dg-error \"INTEGER\" }\n+  !$acc exit data async (1) \n+  !$acc exit data async (i) \n+  !$acc exit data async (a) ! { dg-error \"INTEGER\" }\n+  !$acc exit data async (b(5:6)) ! { dg-error \"INTEGER\" }\n+  !$acc exit data wait (l) ! { dg-error \"INTEGER\" }\n+  !$acc exit data wait (.true.) ! { dg-error \"INTEGER\" }\n+  !$acc exit data wait (i, 1) \n+  !$acc exit data wait (a) ! { dg-error \"INTEGER\" }\n+  !$acc exit data wait (b(5:6)) ! { dg-error \"INTEGER\" }\n+  !$acc exit data copyout (tip) ! { dg-error \"POINTER\" }\n+  !$acc exit data copyout (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc exit data delete (tip) ! { dg-error \"POINTER\" }\n+  !$acc exit data delete (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc exit data copyout (i) delete (i) ! { dg-error \"multiple clauses\" }\n+  end subroutine foo\n+end module test"}, {"sha": "6a4541901024422e448f0468e9a085d858fcb67b", "filename": "gcc/testsuite/gfortran.dg/goacc/fixed-1.f", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-1.f?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,12 @@\n+      INTEGER :: ARGC\n+      ARGC = COMMAND_ARGUMENT_COUNT ()\n+\n+!$OMP PARALLEL\n+!$ACC PARALLEL COPYIN(ARGC)\n+      IF (ARGC .NE. 0) THEN\n+         CALL ABORT\n+      END IF\n+!$ACC END PARALLEL\n+!$OMP END PARALLEL\n+\n+      END"}, {"sha": "2c2b0a38e0093ed0452990cc15b6a4eb899007e4", "filename": "gcc/testsuite/gfortran.dg/goacc/fixed-2.f", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-2.f?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fmax-errors=100\" } \n+\n+      INTEGER :: ARGC\n+      ARGC = COMMAND_ARGUMENT_COUNT ()\n+\n+!$OMP xPARALLEL\n+!$ACC xPARALLEL COPYIN(ARGC)\t! { dg-error \"Unclassifiable OpenACC directive\" }\n+      IF (ARGC .NE. 0) THEN\n+         CALL ABORT\n+      END IF\n+!$ACC END PARALLEL \t! { dg-error \"Unexpected\" }\n+!$OMP END PARALLEL\n+\n+      END"}, {"sha": "ede361e8d2e8cdefe5b55261575dfaeaf08b7b86", "filename": "gcc/testsuite/gfortran.dg/goacc/fixed-3.f", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-3.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-3.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-3.f?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,13 @@\n+      IMPLICIT NONE\n+\n+      INTEGER DEV\n+\n+!$ACC PARALLEL\n+      DEV = 0\n+!$ACC END PARALLEL\n+\n+!$ACC PARALLEL\n+      DEV = 0\n+!$ACC END PARALLEL\n+\n+      END"}, {"sha": "120d5a9aa1cde28fc750e7f3ca9a774466804a0c", "filename": "gcc/testsuite/gfortran.dg/goacc/fixed-4.f", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-4.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-4.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffixed-4.f?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,6 @@\n+      IMPLICIT NONE\n+\n+!$ACC PARALLEL\n+!$ACC END PARALLEL\n+\n+      END"}, {"sha": "dcacb31906db732598a1db7aa8a1bbd3d8afbc0a", "filename": "gcc/testsuite/gfortran.dg/goacc/goacc.exp", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fgoacc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fgoacc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fgoacc.exp?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,36 @@\n+# Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gfortran-dg.exp\n+\n+if ![check_effective_target_fopenacc] {\n+  return\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+gfortran-dg-runtest [lsort \\\n+       [find $srcdir/$subdir *.\\[fF\\]{,90,95,03,08} ] ] \"\" \"-fopenacc\"\n+\n+# All done.\n+dg-finish"}, {"sha": "19e741185efedb7d296c944660b5092a6df70e56", "filename": "gcc/testsuite/gfortran.dg/goacc/host_data-tree.f95", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fhost_data-tree.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fhost_data-tree.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fhost_data-tree.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fdump-tree-original\" } \n+\n+program test\n+  implicit none\n+  integer :: i\n+\n+  !$acc host_data use_device(i)\n+  !$acc end host_data\n+end program test\n+! { dg-prune-output \"unimplemented\" }\n+! { dg-final { scan-tree-dump-times \"pragma acc host_data use_device\\\\(i\\\\)\" 1 \"original\" } } \n+! { dg-final { cleanup-tree-dump \"original\" } } "}, {"sha": "a45035d823017afcd75fd4517ec85e008a04e109", "filename": "gcc/testsuite/gfortran.dg/goacc/if.f95", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fif.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fif.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fif.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do compile } \n+\n+program test\n+  implicit none\n+\n+  logical :: x\n+  integer :: i\n+\n+  !$acc parallel if ! { dg-error \"Unclassifiable OpenACC directive\" }\n+  !$acc parallel if () ! { dg-error \"Invalid character\" }\n+  !$acc parallel if (i) ! { dg-error \"scalar LOGICAL expression\" }\n+  !$acc end parallel \n+  !$acc parallel if (1) ! { dg-error \"scalar LOGICAL expression\" }\n+  !$acc end parallel \n+  !$acc kernels if (i) ! { dg-error \"scalar LOGICAL expression\" }\n+  !$acc end kernels \n+  !$acc kernels if ! { dg-error \"Unclassifiable OpenACC directive\" }\n+  !$acc kernels if () ! { dg-error \"Invalid character\" }\n+  !$acc kernels if (1) ! { dg-error \"scalar LOGICAL expression\" }\n+  !$acc end kernels\n+  !$acc data if ! { dg-error \"Unclassifiable OpenACC directive\" }\n+  !$acc data if () ! { dg-error \"Invalid character\" }\n+  !$acc data if (i) ! { dg-error \"scalar LOGICAL expression\" }\n+  !$acc end data \n+  !$acc data if (1) ! { dg-error \"scalar LOGICAL expression\" }\n+  !$acc end data \n+\n+  ! at most one if clause may appear\n+  !$acc parallel if (.false.) if (.false.) { dg-error \"Unclassifiable OpenACC directive\" }\n+  !$acc kernels if (.false.) if (.false.) { dg-error \"Unclassifiable OpenACC directive\" }\n+  !$acc data if (.false.) if (.false.) { dg-error \"Unclassifiable OpenACC directive\" }\n+\n+  !$acc parallel if (x)\n+  !$acc end parallel\n+  !$acc parallel if (.true.)\n+  !$acc end parallel\n+  !$acc parallel if (i.gt.1)\n+  !$acc end parallel\n+  !$acc kernels if (x)\n+  !$acc end kernels\n+  !$acc kernels if (.true.)\n+  !$acc end kernels\n+  !$acc kernels if (i.gt.1)\n+  !$acc end kernels\n+  !$acc data if (x)\n+  !$acc end data\n+  !$acc data if (.true.)\n+  !$acc end data\n+  !$acc data if (i.gt.1)\n+  !$acc end data\n+\n+end program test\n\\ No newline at end of file"}, {"sha": "7585a16de8f97b6e67308fc19612bdcaf7ed9757", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-tree.f95", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-tree.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-tree.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-tree.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fdump-tree-original\" } \n+\n+program test\n+  implicit none\n+  integer :: q, i, j, k, m, n, o, p, r, s, t, u, v, w\n+  logical :: l\n+\n+  !$acc kernels if(l) async copy(i), copyin(j), copyout(k), create(m) &\n+  !$acc present(o), pcopy(p), pcopyin(r), pcopyout(s), pcreate(t) &\n+  !$acc deviceptr(u)\n+  !$acc end kernels\n+\n+end program test\n+! { dg-final { scan-tree-dump-times \"pragma acc kernels\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"if\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"async\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"map\\\\(force_tofrom:i\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(force_to:j\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(force_from:k\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(force_alloc:m\\\\)\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"map\\\\(force_present:o\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:p\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(to:r\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(from:s\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:t\\\\)\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"map\\\\(force_deviceptr:u\\\\)\" 1 \"original\" } } \n+! { dg-final { cleanup-tree-dump \"original\" } } "}, {"sha": "94fdadd86dbfcf8b755e1c1073b4f066dc0f817e", "filename": "gcc/testsuite/gfortran.dg/goacc/list.f95", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Flist.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Flist.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Flist.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,111 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fmax-errors=100\" } \n+\n+program test \n+  implicit none\n+\n+  integer :: i, j, k, l, a(10)\n+  common /b/ j, k\n+  real, pointer :: p1 => NULL()\n+  complex :: c, d(10)\n+\n+  !$acc parallel private(i)\n+  !$acc end parallel\n+\n+  !$acc parallel private(a)\n+  !$acc end parallel\n+\n+  !$acc parallel private(c, d)\n+  !$acc end parallel\n+\n+  !$acc parallel private(i, j, k, l, a)\n+  !$acc end parallel  \n+\n+  !$acc parallel private (i) private (j)\n+  !$acc end parallel\n+\n+  !$acc parallel private ! { dg-error \"Unclassifiable OpenACC directive\" }\n+\n+  !$acc parallel private() ! { dg-error \"Syntax error\" }\n+\n+  !$acc parallel private(a(1:3)) ! { dg-error \"Syntax error\" }\n+\n+  !$acc parallel private(10) ! { dg-error \"Syntax error\" }\n+\n+  !$acc parallel private(/b/, /b/) ! { dg-error \"present on multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel private(i, j, i) ! { dg-error \"present on multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel private(p1) \n+  !$acc end parallel\n+\n+  !$acc parallel firstprivate(i)\n+  !$acc end parallel\n+\n+  !$acc parallel firstprivate(c, d)\n+  !$acc end parallel\n+\n+  !$acc parallel firstprivate(a)\n+  !$acc end parallel\n+\n+  !$acc parallel firstprivate(i, j, k, l, a)\n+  !$acc end parallel  \n+\n+  !$acc parallel firstprivate (i) firstprivate (j)\n+  !$acc end parallel\n+\n+  !$acc parallel firstprivate ! { dg-error \"Unclassifiable OpenACC directive\" }\n+\n+  !$acc parallel firstprivate() ! { dg-error \"Syntax error\" }\n+\n+  !$acc parallel firstprivate(a(1:3)) ! { dg-error \"Syntax error\" }\n+\n+  !$acc parallel firstprivate(10) ! { dg-error \"Syntax error\" }\n+\n+  !$acc parallel firstprivate (/b/, /b/) ! { dg-error \"present on multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel firstprivate (i, j, i) ! { dg-error \"present on multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc parallel firstprivate(p1) \n+  !$acc end parallel\n+\n+  !$acc parallel private (i) firstprivate (i) ! { dg-error \"present on multiple clauses\" }\n+  !$acc end parallel\n+\n+  !$acc host_data use_device(i)\n+  !$acc end host_data\n+\n+  !$acc host_data use_device(c, d)\n+  !$acc end host_data\n+\n+  !$acc host_data use_device(a)\n+  !$acc end host_data\n+\n+  !$acc host_data use_device(i, j, k, l, a)\n+  !$acc end host_data  \n+\n+  !$acc host_data use_device (i) use_device (j)\n+  !$acc end host_data\n+\n+  !$acc host_data use_device ! { dg-error \"Unclassifiable OpenACC directive\" }\n+\n+  !$acc host_data use_device() ! { dg-error \"Syntax error\" }\n+\n+  !$acc host_data use_device(a(1:3)) ! { dg-error \"Syntax error\" }\n+\n+  !$acc host_data use_device(10) ! { dg-error \"Syntax error\" }\n+\n+  !$acc host_data use_device(/b/, /b/) ! { dg-error \"present on multiple clauses\" }\n+  !$acc end host_data\n+\n+  !$acc host_data use_device(i, j, i) ! { dg-error \"present on multiple clauses\" }\n+  !$acc end host_data\n+\n+  !$acc host_data use_device(p1) ! { dg-error \"POINTER\" }\n+  !$acc end host_data\n+\n+end program test\n\\ No newline at end of file"}, {"sha": "e6760d04fa1ba4a7826245acd9b7b314cd376347", "filename": "gcc/testsuite/gfortran.dg/goacc/literal.f95", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fliteral.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fliteral.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fliteral.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do compile } \n+\n+module test\n+contains\n+  subroutine oacc1\n+    implicit none\n+    integer :: i\n+    !$acc declare device_resident (10) ! { dg-error \"Syntax error\" }\n+    !$acc data copy (10) ! { dg-error \"Syntax error\" }\n+    !$acc end data ! { dg-error \"Unexpected\" }\n+    !$acc data deviceptr (10) ! { dg-error \"Syntax error\" }\n+    !$acc end data ! { dg-error \"Unexpected\" }\n+    !$acc data private (10) ! { dg-error \"Unclassifiable\" }\n+    !$acc end data ! { dg-error \"Unexpected\" }\n+    !$acc host_data use_device (10) ! { dg-error \"Syntax error\" }\n+    !$acc end host_data ! { dg-error \"Unexpected\" }\n+    !$acc parallel loop reduction(+:10) ! { dg-error \"Syntax error\" }\n+    do i = 1,5\n+    enddo\n+    !$acc end parallel loop ! { dg-error \"Unexpected\" }\n+    !$acc parallel loop\n+    do i = 1,5\n+      !$acc cache (10) ! { dg-error \"Syntax error\" }\n+    enddo\n+    !$acc end parallel loop\n+    !$acc update device (10) ! { dg-error \"Syntax error\" }\n+    !$acc update host (10) ! { dg-error \"Syntax error\" }\n+    !$acc update self (10) ! { dg-error \"Syntax error\" }\n+  end subroutine oacc1\n+end module test"}, {"sha": "e1b2dfd5d6ef83fe62e450b8e019c0cd34688817", "filename": "gcc/testsuite/gfortran.dg/goacc/loop-1.f95", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-1.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,171 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fmax-errors=100\" } \n+module test\n+  implicit none\n+contains\n+\n+subroutine test1  \n+  integer :: i, j, k, b(10)\n+  integer, dimension (30) :: a\n+  double precision :: d\n+  real :: r\n+  i = 0\n+  !$acc loop\n+  do 100 ! { dg-error \"cannot be a DO WHILE or DO without loop control\" }\n+    if (i .gt. 0) exit ! { dg-error \"EXIT statement\" }\n+  100 i = i + 1\n+  i = 0\n+  !$acc loop\n+  do ! { dg-error \"cannot be a DO WHILE or DO without loop control\" }\n+      if (i .gt. 0) exit ! { dg-error \"EXIT statement\" }\n+       i = i + 1\n+  end do\n+  i = 0\n+  !$acc loop\n+  do 200 while (i .lt. 4) ! { dg-error \"cannot be a DO WHILE or DO without loop control\" }\n+  200 i = i + 1\n+  !$acc loop\n+  do while (i .lt. 8) ! { dg-error \"cannot be a DO WHILE or DO without loop control\" }\n+       i = i + 1\n+  end do\n+  !$acc loop\n+  do 300 d = 1, 30, 6 ! { dg-error \"integer\" }\n+      i = d\n+  300 a(i) = 1\n+  !$acc loop\n+  do d = 1, 30, 5 ! { dg-error \"integer\" }\n+       i = d\n+      a(i) = 2\n+  end do\n+  !$acc loop\n+  do i = 1, 30\n+      if (i .eq. 16) exit ! { dg-error \"EXIT statement\" }\n+  end do\n+  !$acc loop\n+  outer: do i = 1, 30\n+      do j = 5, 10\n+          if (i .eq. 6 .and. j .eq. 7) exit outer ! { dg-error \"EXIT statement\" }\n+      end do\n+  end do outer\n+  last: do i = 1, 30\n+   end do last\n+\n+  ! different types of loop are allowed\n+  !$acc loop \n+  do i = 1,10\n+  end do\n+  !$acc loop\n+  do 400, i = 1,10\n+400   a(i) = i\n+\n+  ! after loop directive must be loop\n+  !$acc loop\n+  a(1) = 1 ! { dg-error \"Expected DO loop\" }\n+  do i = 1,10\n+  enddo\n+  \n+  ! combined directives may be used with/without end \n+  !$acc parallel loop\n+  do i = 1,10\n+  enddo\n+  !$acc parallel loop\n+  do i = 1,10\n+  enddo\n+  !$acc end parallel loop\n+  !$acc kernels loop\n+  do i = 1,10\n+  enddo\n+  !$acc kernels loop\n+  do i = 1,10\n+  enddo\n+  !$acc end kernels loop\n+\n+  !$acc kernels loop reduction(max:i) \n+  do i = 1,10\n+  enddo\n+  !$acc kernels \n+  !$acc loop reduction(max:i) \n+  do i = 1,10\n+  enddo\n+  !$acc end kernels\n+\n+  !$acc parallel loop collapse(0) ! { dg-error \"constant positive integer\" }\n+  do i = 1,10\n+  enddo\n+\n+  !$acc parallel loop collapse(-1) ! { dg-error \"constant positive integer\" }\n+  do i = 1,10\n+  enddo\n+\n+  !$acc parallel loop collapse(i) ! { dg-error \"Constant expression required\" }\n+  do i = 1,10\n+  enddo\n+\n+  !$acc parallel loop collapse(4) ! { dg-error \"not enough DO loops for collapsed\" }\n+    do i = 1, 3\n+        do j = 4, 6\n+          do k = 5, 7\n+              a(i+j-k) = i + j + k\n+          end do\n+        end do\n+    end do\n+    !$acc parallel loop collapse(2)\n+    do i = 1, 5, 2\n+        do j = i + 1, 7, i  ! { dg-error \"collapsed loops don.t form rectangular iteration space\" }\n+        end do\n+    end do\n+    !$acc parallel loop collapse(2)\n+    do i = 1, 3\n+        do j = 4, 6  \n+        end do\n+    end do\n+    !$acc parallel loop collapse(2)\n+    do i = 1, 3\n+        do j = 4, 6\n+        end do\n+        k = 4\n+    end do\n+    !$acc parallel loop collapse(3-1)\n+    do i = 1, 3\n+        do j = 4, 6\n+        end do\n+        k = 4\n+    end do\n+    !$acc parallel loop collapse(1+1)\n+    do i = 1, 3\n+        do j = 4, 6\n+        end do\n+        k = 4\n+    end do\n+    !$acc parallel loop collapse(2)\n+    do i = 1, 3\n+        do      ! { dg-error \"cannot be a DO WHILE or DO without loop control\" }\n+        end do\n+    end do\n+    !$acc parallel loop collapse(2)\n+    do i = 1, 3\n+        do r = 4, 6    ! { dg-error \"integer\" }\n+        end do\n+    end do\n+\n+    ! Both seq and independent are not allowed\n+  !$acc loop independent seq ! { dg-error \"SEQ conflicts with INDEPENDENT\" }\n+  do i = 1,10\n+  enddo\n+\n+\n+  !$acc cache (a) ! { dg-error \"inside of loop\" }\n+\n+  do i = 1,10\n+    !$acc cache(a)\n+  enddo\n+\n+  do i = 1,10\n+    a(i) = i\n+    !$acc cache(a) \n+  enddo\n+\n+end subroutine test1\n+end module test\n+! { dg-prune-output \"Deleted\" }\n+! { dg-prune-output \"ACC cache unimplemented\" }"}, {"sha": "f85691eb8e3417d6ba521ac0e1c96564f36d08b4", "filename": "gcc/testsuite/gfortran.dg/goacc/loop-2.f95", "status": "added", "additions": 649, "deletions": 0, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-2.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,649 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fmax-errors=100\" } \n+\n+! TODO: nested kernels are allowed in 2.0\n+\n+program test\n+  implicit none\n+  integer :: i, j\n+\n+  !$acc kernels\n+    !$acc loop auto\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang(5)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang(num:5)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang(static:5)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang(static:*)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang\n+    DO i = 1,10\n+      !$acc loop vector \n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop worker \n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop gang ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+    ENDDO\n+    !$acc loop seq gang ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+\n+    !$acc loop worker\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker(5)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker(num:5)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker\n+    DO i = 1,10\n+      !$acc loop vector \n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop worker ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop gang ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+    ENDDO\n+    !$acc loop seq worker ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang worker ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+\n+    !$acc loop vector\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector(5)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector(length:5)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector\n+    DO i = 1,10\n+      !$acc loop vector ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop worker ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop gang ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+    ENDDO\n+    !$acc loop seq vector ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang vector ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker vector ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+\n+    !$acc loop auto\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop seq auto ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang auto ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker auto ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector auto ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+\n+    !$acc loop tile ! { dg-error \"Unclassifiable\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile() ! { dg-error \"Syntax error\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile(1) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile(2) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile(6-2) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile(6+2) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile(*, 1) \n+    DO i = 1,10\n+      DO j = 1,10\n+      ENDDO\n+    ENDDO\n+    !$acc loop tile(-1) ! { dg-warning \"must be positive\" }\n+    do i = 1,10\n+    enddo\n+    !$acc loop tile(i) ! { dg-error \"constant expression\" }\n+    do i = 1,10\n+    enddo\n+    !$acc loop tile(2, 2, 1) ! { dg-error \"not enough DO loops for tiled\" }\n+      do i = 1, 3\n+          do j = 4, 6\n+          end do\n+      end do    \n+      !$acc loop tile(2, 2)\n+      do i = 1, 5, 2\n+          do j = i + 1, 7, i  ! { dg-error \"tiled loops don.t form rectangular iteration space\" }\n+          end do\n+      end do\n+    !$acc loop vector tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector gang tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector worker tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang worker tile(*) \n+    DO i = 1,10\n+    ENDDO\n+  !$acc end kernels\n+\n+\n+  !$acc parallel\n+    !$acc loop auto\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang(5) ! { dg-error \"non-static\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang(num:5) ! { dg-error \"non-static\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang(static:5)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang(static:*)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang\n+    DO i = 1,10\n+      !$acc loop vector \n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop worker \n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop gang ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+    ENDDO\n+    !$acc loop seq gang ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+\n+    !$acc loop worker\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker(5) ! { dg-error \"non-static\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker(num:5) ! { dg-error \"non-static\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker\n+    DO i = 1,10\n+      !$acc loop vector \n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop worker ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop gang ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+    ENDDO\n+    !$acc loop seq worker ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang worker ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+\n+    !$acc loop vector\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector(5)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector(length:5)\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector\n+    DO i = 1,10\n+      !$acc loop vector ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop worker ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+      !$acc loop gang ! { dg-error \"not allowed\" }\n+      DO j = 1,10\n+      ENDDO\n+    ENDDO\n+    !$acc loop seq vector ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang vector ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker vector ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+\n+    !$acc loop auto\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop seq auto ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang auto ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker auto ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector auto ! { dg-error \"conflicts with\" }\n+    DO i = 1,10\n+    ENDDO\n+\n+    !$acc loop tile ! { dg-error \"Unclassifiable\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile() ! { dg-error \"Syntax error\" }\n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile(1) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop tile(2) \n+    DO i = 1,10\n+      DO j = 1,10\n+      ENDDO\n+    ENDDO\n+    !$acc loop tile(-1) ! { dg-warning \"must be positive\" }\n+    do i = 1,10\n+    enddo\n+    !$acc loop tile(i) ! { dg-error \"constant expression\" }\n+    do i = 1,10\n+    enddo\n+    !$acc loop tile(2, 2, 1) ! { dg-error \"not enough DO loops for tiled\" }\n+      do i = 1, 3\n+          do j = 4, 6\n+          end do\n+      end do    \n+      !$acc loop tile(2, 2)\n+      do i = 1, 5, 2\n+          do j = i + 1, 7, i  ! { dg-error \"tiled loops don.t form rectangular iteration space\" }\n+          end do\n+      end do\n+    !$acc loop vector tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop worker tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector gang tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop vector worker tile(*) \n+    DO i = 1,10\n+    ENDDO\n+    !$acc loop gang worker tile(*) \n+    DO i = 1,10\n+    ENDDO\n+  !$acc end parallel\n+\n+  !$acc kernels loop auto\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang(5)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang(num:5)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang(static:5)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang(static:*)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang\n+  DO i = 1,10\n+    !$acc kernels loop gang \n+    DO j = 1,10\n+    ENDDO\n+  ENDDO\n+  !$acc kernels loop seq gang ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+\n+  !$acc kernels loop worker\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop worker(5)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop worker(num:5)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop worker\n+  DO i = 1,10\n+    !$acc kernels loop worker \n+    DO j = 1,10\n+    ENDDO\n+    !$acc kernels loop gang \n+    DO j = 1,10\n+    ENDDO\n+  ENDDO\n+  !$acc kernels loop seq worker ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang worker ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+\n+  !$acc kernels loop vector\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop vector(5)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop vector(length:5)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop vector\n+  DO i = 1,10\n+    !$acc kernels loop vector \n+    DO j = 1,10\n+    ENDDO\n+    !$acc kernels loop worker \n+    DO j = 1,10\n+    ENDDO\n+    !$acc kernels loop gang \n+    DO j = 1,10\n+    ENDDO\n+  ENDDO\n+  !$acc kernels loop seq vector ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang vector ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop worker vector ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+\n+  !$acc kernels loop auto\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop seq auto ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang auto ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop worker auto ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop vector auto ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+\n+  !$acc kernels loop tile ! { dg-error \"Unclassifiable\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop tile() ! { dg-error \"Syntax error\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop tile(1) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop tile(*, 1) \n+  DO i = 1,10\n+    DO j = 1,10\n+    ENDDO\n+  ENDDO\n+  !$acc kernels loop tile(-1) ! { dg-warning \"must be positive\" }\n+  do i = 1,10\n+  enddo\n+  !$acc kernels loop tile(i) ! { dg-error \"constant expression\" }\n+  do i = 1,10\n+  enddo\n+  !$acc kernels loop tile(2, 2, 1) ! { dg-error \"not enough DO loops for tiled\" }\n+    do i = 1, 3\n+        do j = 4, 6\n+        end do\n+    end do    \n+    !$acc kernels loop tile(2, 2)\n+    do i = 1, 5, 2\n+        do j = i + 1, 7, i  ! { dg-error \"tiled loops don.t form rectangular iteration space\" }\n+        end do\n+    end do\n+  !$acc kernels loop vector tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop worker tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop vector gang tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop vector worker tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc kernels loop gang worker tile(*) \n+  DO i = 1,10\n+  ENDDO\n+\n+  !$acc parallel loop auto\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang(5) ! { dg-error \"non-static\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang(num:5) ! { dg-error \"non-static\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang(static:5)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang(static:*)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang\n+  DO i = 1,10\n+    !$acc parallel loop gang \n+    DO j = 1,10\n+    ENDDO\n+  ENDDO\n+  !$acc parallel loop seq gang ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+\n+  !$acc parallel loop worker\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop worker(5) ! { dg-error \"non-static\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop worker(num:5) ! { dg-error \"non-static\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop worker\n+  DO i = 1,10\n+    !$acc parallel loop worker \n+    DO j = 1,10\n+    ENDDO\n+    !$acc parallel loop gang \n+    DO j = 1,10\n+    ENDDO\n+  ENDDO\n+  !$acc parallel loop seq worker ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang worker ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+\n+  !$acc parallel loop vector\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop vector(5)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop vector(length:5)\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop vector\n+  DO i = 1,10\n+    !$acc parallel loop vector \n+    DO j = 1,10\n+    ENDDO\n+    !$acc parallel loop worker \n+    DO j = 1,10\n+    ENDDO\n+    !$acc parallel loop gang \n+    DO j = 1,10\n+    ENDDO\n+  ENDDO\n+  !$acc parallel loop seq vector ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang vector ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop worker vector ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+\n+  !$acc parallel loop auto\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop seq auto ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang auto ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop worker auto ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop vector auto ! { dg-error \"conflicts with\" }\n+  DO i = 1,10\n+  ENDDO\n+\n+  !$acc parallel loop tile ! { dg-error \"Unclassifiable\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop tile() ! { dg-error \"Syntax error\" }\n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop tile(1) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop tile(*, 1) \n+  DO i = 1,10\n+    DO j = 1,10\n+    ENDDO\n+  ENDDO\n+  !$acc parallel loop tile(-1) ! { dg-warning \"must be positive\" }\n+  do i = 1,10\n+  enddo\n+  !$acc parallel loop tile(i) ! { dg-error \"constant expression\" }\n+  do i = 1,10\n+  enddo\n+  !$acc parallel loop tile(2, 2, 1) ! { dg-error \"not enough DO loops for tiled\" }\n+    do i = 1, 3\n+        do j = 4, 6\n+        end do\n+    end do    \n+    !$acc parallel loop tile(2, 2)\n+    do i = 1, 5, 2\n+        do j = i + 1, 7, i  ! { dg-error \"tiled loops don.t form rectangular iteration space\" }\n+        end do\n+    end do\n+  !$acc parallel loop vector tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop worker tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop vector gang tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop vector worker tile(*) \n+  DO i = 1,10\n+  ENDDO\n+  !$acc parallel loop gang worker tile(*) \n+  DO i = 1,10\n+  ENDDO\n+end\n\\ No newline at end of file"}, {"sha": "2a866c7923486764d26795e6922ddc7bc7cd2557", "filename": "gcc/testsuite/gfortran.dg/goacc/loop-3.f95", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-3.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-3.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-3.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-std=f2008\" }\n+\n+subroutine test1\n+  implicit none\n+  integer :: i, j\n+  \n+  ! !$acc end loop not required by spec\n+  !$acc loop\n+  do i = 1,5\n+  enddo\n+  !$acc end loop ! { dg-warning \"Redundant\" }\n+\n+  !$acc loop\n+  do i = 1,5\n+  enddo\n+  j = 1\n+  !$acc end loop ! { dg-error \"Unexpected\" }\n+\n+  !$acc parallel\n+  !$acc loop\n+  do i = 1,5\n+  enddo\n+  !$acc end parallel\n+  !$acc end loop ! { dg-error \"Unexpected\" }\n+  \n+  ! OpenACC supports Fortran 2008 do concurrent statement\n+  !$acc loop\n+  do concurrent (i = 1:5)\n+  end do\n+\n+  !$acc loop\n+  outer_loop: do i = 1, 5\n+    inner_loop: do j = 1,5\n+      if (i .eq. j) cycle outer_loop\n+      if (i .ne. j) exit outer_loop ! { dg-error \"EXIT statement\" }\n+    end do inner_loop\n+  end do outer_loop \n+\n+  outer_loop1: do i = 1, 5\n+    !$acc loop\n+    inner_loop1: do j = 1,5\n+      if (i .eq. j) cycle outer_loop1 ! { dg-error \"CYCLE statement\" }\n+    end do inner_loop1\n+  end do outer_loop1\n+\n+  !$acc loop collapse(2)\n+  outer_loop2: do i = 1, 5\n+    inner_loop2: do j = 1,5\n+      if (i .eq. j) cycle outer_loop2 ! { dg-error \"CYCLE statement\" }\n+      if (i .ne. j) exit outer_loop2 ! { dg-error \"EXIT statement\" }\n+    end do inner_loop2\n+  end do outer_loop2 \n+end subroutine test1\n+"}, {"sha": "966e75bcde35d7e89e6e895d5ee75d6f1ec004fb", "filename": "gcc/testsuite/gfortran.dg/goacc/loop-tree-1.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-tree-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-tree-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Floop-tree-1.f90?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fdump-tree-original -std=f2008\" } \n+\n+! test for tree-dump-original and spaces-commas\n+\n+program test\n+  implicit none\n+  integer :: i, j, k, m, sum\n+  REAL :: a(64), b(64), c(64)\n+\n+  !$acc kernels \n+  !$acc loop collapse(2)\n+  DO i = 1,10\n+    DO j = 1,10\n+    ENDDO\n+  ENDDO\n+\n+  !$acc loop independent gang (3)\n+  DO i = 1,10\n+    !$acc loop worker(3) ! { dg-error \"work-sharing region may not be closely nested inside of work-sharing, critical, ordered, master or explicit task region\" }\n+    DO j = 1,10\n+      !$acc loop vector(5)\n+      DO k = 1,10\n+      ENDDO\n+    ENDDO\n+  ENDDO\n+  !$acc end kernels\n+\n+  sum = 0\n+  !$acc parallel\n+  !$acc loop private(m) reduction(+:sum)\n+  DO i = 1,10\n+    sum = sum + 1\n+  ENDDO\n+  !$acc end parallel\n+\n+end program test\n+! { dg-final { scan-tree-dump-times \"pragma acc loop\" 5 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"collapse\\\\(2\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"independent\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"gang\\\\(num: 3\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"worker\\\\(3\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"vector\\\\(5\\\\)\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"private\\\\(m\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"reduction\\\\(\\\\+:sum\\\\)\" 1 \"original\" } } \n+! { dg-final { cleanup-tree-dump \"original\" } } "}, {"sha": "24f639ff54a25d7c79b42ae0f5aa3e5c48bb524a", "filename": "gcc/testsuite/gfortran.dg/goacc/omp.f95", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fomp.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fomp.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fomp.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fopenmp\" } \n+\n+module test\n+contains\n+  subroutine ichi\n+    implicit none\n+    integer :: i\n+    !$acc parallel\n+    !$omp do ! { dg-error \"cannot be specified\" }\n+    do i = 1,5\n+    enddo\n+    !$acc end parallel\n+  end subroutine ichi\n+\n+  subroutine ni\n+    implicit none\n+    integer :: i\n+    !$omp parallel\n+    !$acc loop ! { dg-error \"cannot be specified\" }\n+    do i = 1,5\n+    enddo\n+    !$omp end parallel\n+  end subroutine ni\n+\n+  subroutine san\n+    implicit none\n+    integer :: i\n+    !$omp do\n+    !$acc loop ! { dg-error \"Unexpected\" }\n+    do i = 1,5\n+    enddo\n+   end subroutine san\n+\n+   subroutine yon\n+     implicit none\n+     integer :: i\n+     !$acc loop\n+     !$omp do ! { dg-error \"Expected DO loop\" }\n+     do i = 1,5\n+     enddo\n+   end subroutine yon\n+\n+   subroutine go\n+     implicit none\n+     integer :: i, j\n+\n+     !$omp parallel\n+     do i = 1,5\n+       !$acc kernels ! { dg-error \"cannot be specified\" }\n+       do j = 1,5\n+       enddo\n+       !$acc end kernels\n+     enddo\n+     !$omp end parallel\n+   end subroutine go\n+\n+   subroutine roku\n+     implicit none\n+\n+     !$acc data\n+     !$omp parallel ! { dg-error \"cannot be specified\" }\n+     !$omp end parallel\n+     !$acc end data\n+   end subroutine roku\n+end module test\n\\ No newline at end of file"}, {"sha": "c37208c7e6f598b7c25d677af37bc292aa6a6b50", "filename": "gcc/testsuite/gfortran.dg/goacc/parallel-kernels-clauses.f95", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparallel-kernels-clauses.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparallel-kernels-clauses.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparallel-kernels-clauses.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,96 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fmax-errors=100\" } \n+\n+! test clauses added in OpenACC ver 2.0\n+\n+program test\n+  implicit none\n+  integer :: i, a(10), b(5:7)\n+  integer, parameter :: acc_async_noval = -1 \n+  integer, parameter :: acc_async_sync = -2\n+  logical :: l\n+\n+  ! async\n+  !$acc kernels async(i)\n+  !$acc end kernels\n+  !$acc parallel async(i)\n+  !$acc end parallel\n+\n+  !$acc kernels async(0, 1) { dg-error \"Unclassifiable\" }\n+  !$acc parallel async(0, 1) { dg-error \"Unclassifiable\" }\n+\n+  !$acc kernels async\n+  !$acc end kernels\n+  !$acc parallel async\n+  !$acc end parallel\n+\n+  !$acc kernels async(acc_async_noval)\n+  !$acc end kernels\n+  !$acc parallel async(acc_async_noval)\n+  !$acc end parallel\n+\n+  !$acc kernels async(acc_async_sync)\n+  !$acc end kernels\n+  !$acc parallel async(acc_async_sync)\n+  !$acc end parallel\n+\n+  !$acc kernels async() { dg-error \"Invalid character\" }\n+  !$acc parallel async() { dg-error \"Invalid character\" }\n+\n+  !$acc kernels async(\"a\") { dg-error \"Unclassifiable\" }\n+  !$acc parallel async(\"a\") { dg-error \"Unclassifiable\" }\n+\n+  !$acc kernels async(.true.) { dg-error \"Unclassifiable\" }\n+  !$acc parallel async(.true.) { dg-error \"Unclassifiable\" }\n+\n+  ! default(none)\n+  !$acc kernels default(none)\n+  !$acc end kernels\n+  !$acc parallel default(none)\n+  !$acc end parallel\n+\n+  !$acc kernels default (none)\n+  !$acc end kernels\n+  !$acc parallel default (none)\n+  !$acc end parallel\n+\n+  !$acc kernels default ( none )\n+  !$acc end kernels\n+  !$acc parallel default ( none )\n+  !$acc end parallel\n+\n+  !$acc kernels default { dg-error \"Unclassifiable\" }\n+  !$acc parallel default { dg-error \"Unclassifiable\" }\n+\n+  !$acc kernels default() { dg-error \"Unclassifiable\" }\n+  !$acc parallel default() { dg-error \"Unclassifiable\" }\n+\n+  !$acc kernels default(i) { dg-error \"Unclassifiable\" }\n+  !$acc parallel default(i) { dg-error \"Unclassifiable\" }\n+\n+  !$acc kernels default(1) { dg-error \"Unclassifiable\" }\n+  !$acc parallel default(1) { dg-error \"Unclassifiable\" }\n+\n+  ! Wait\n+  !$acc kernels wait (l) ! { dg-error \"INTEGER\" }\n+  !$acc end kernels\n+  !$acc kernels wait (.true.) ! { dg-error \"INTEGER\" }\n+  !$acc end kernels\n+  !$acc kernels wait (i, 1) \n+  !$acc end kernels\n+  !$acc kernels wait (a) ! { dg-error \"INTEGER\" }\n+  !$acc end kernels\n+  !$acc kernels wait (b(5:6)) ! { dg-error \"INTEGER\" }\n+  !$acc end kernels\n+\n+  !$acc parallel wait (l) ! { dg-error \"INTEGER\" }\n+  !$acc end parallel\n+  !$acc parallel wait (.true.) ! { dg-error \"INTEGER\" }\n+  !$acc end parallel\n+  !$acc parallel wait (i, 1) \n+  !$acc end parallel\n+  !$acc parallel wait (a) ! { dg-error \"INTEGER\" }\n+  !$acc end parallel\n+  !$acc parallel wait (b(5:6)) ! { dg-error \"INTEGER\" }\n+  !$acc end parallel\n+end"}, {"sha": "8b8e989399514d7dc134fb8af00e6fc4c5d032fa", "filename": "gcc/testsuite/gfortran.dg/goacc/parallel-kernels-regions.f95", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparallel-kernels-regions.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparallel-kernels-regions.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparallel-kernels-regions.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do compile } \n+\n+! OpenACC 2.0 allows nested parallel/kernels regions, but this is not yet\n+! supported.\n+\n+program test\n+  implicit none\n+\n+  integer :: i\n+\n+  !$acc parallel\n+    !$acc kernels ! { dg-bogus \"kernels construct inside of parallel region\" \"not implemented\" { xfail *-*-* } }\n+    !$acc end kernels\n+  !$acc end parallel\n+\n+  !$acc parallel\n+    !$acc parallel ! { dg-bogus \"parallel construct inside of parallel region\" \"not implemented\" { xfail *-*-* } }\n+    !$acc end parallel\n+  !$acc end parallel\n+\n+  !$acc parallel\n+    !$acc parallel ! { dg-bogus \"parallel construct inside of parallel region\" \"not implemented\" { xfail *-*-* } }\n+    !$acc end parallel\n+    !$acc kernels ! { dg-bogus \"kernels construct inside of parallel region\" \"not implemented\" { xfail *-*-* } }\n+    !$acc end kernels\n+  !$acc end parallel\n+\n+  !$acc kernels\n+    !$acc kernels ! { dg-bogus \"kernels construct inside of kernels region\" \"not implemented\" { xfail *-*-* } }\n+    !$acc end kernels\n+  !$acc end kernels\n+\n+  !$acc kernels\n+    !$acc parallel ! { dg-bogus \"parallel construct inside of kernels region\" \"not implemented\" { xfail *-*-* } }\n+    !$acc end parallel\n+  !$acc end kernels\n+\n+  !$acc kernels\n+    !$acc parallel ! { dg-bogus \"parallel construct inside of kernels region\" \"not implemented\" { xfail *-*-* } }\n+    !$acc end parallel\n+    !$acc kernels ! { dg-bogus \"kernels construct inside of kernels region\" \"not implemented\" { xfail *-*-* } }\n+    !$acc end kernels\n+  !$acc end kernels\n+\n+  !$acc parallel\n+    !$acc data ! { dg-error \"data construct inside of parallel region\" }\n+    !$acc end data\n+  !$acc end parallel\n+\n+  !$acc kernels\n+    !$acc data ! { dg-error \"data construct inside of kernels region\" }\n+    !$acc end data\n+  !$acc end kernels\n+  \n+end program test"}, {"sha": "48061b112fea0b09d698a6299bc3f349c469b069", "filename": "gcc/testsuite/gfortran.dg/goacc/parallel-tree.f95", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparallel-tree.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparallel-tree.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparallel-tree.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fdump-tree-original\" } \n+\n+! test for tree-dump-original and spaces-commas\n+\n+program test\n+  implicit none\n+  integer :: q, i, j, k, m, n, o, p, r, s, t, u, v, w\n+  logical :: l\n+\n+  !$acc parallel if(l) async num_gangs(i) num_workers(i) vector_length(i) &\n+  !$acc reduction(max:q), copy(i), copyin(j), copyout(k), create(m) &\n+  !$acc present(o), pcopy(p), pcopyin(r), pcopyout(s), pcreate(t) &\n+  !$acc deviceptr(u), private(v), firstprivate(w)\n+  !$acc end parallel\n+\n+end program test\n+! { dg-final { scan-tree-dump-times \"pragma acc parallel\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"if\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"async\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"num_gangs\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"num_workers\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"vector_length\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"reduction\\\\(max:q\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(force_tofrom:i\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(force_to:j\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(force_from:k\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(force_alloc:m\\\\)\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"map\\\\(force_present:o\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(tofrom:p\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(to:r\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(from:s\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"map\\\\(alloc:t\\\\)\" 1 \"original\" } } \n+\n+! { dg-final { scan-tree-dump-times \"map\\\\(force_deviceptr:u\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"private\\\\(v\\\\)\" 1 \"original\" } } \n+! { dg-final { scan-tree-dump-times \"firstprivate\\\\(w\\\\)\" 1 \"original\" } } \n+! { dg-final { cleanup-tree-dump \"original\" } } "}, {"sha": "1364181b33c943b1970b2e934e9c2de4471c39b6", "filename": "gcc/testsuite/gfortran.dg/goacc/parameter.f95", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparameter.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparameter.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fparameter.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do compile } \n+\n+module test\n+contains\n+  subroutine oacc1\n+    implicit none\n+    integer :: i\n+    integer, parameter :: a = 1\n+    !$acc declare device_resident (a) ! { dg-error \"PARAMETER\" }\n+    !$acc data copy (a) ! { dg-error \"not a variable\" }\n+    !$acc end data\n+    !$acc data deviceptr (a) ! { dg-error \"not a variable\" }\n+    !$acc end data\n+    !$acc parallel private (a) ! { dg-error \"not a variable\" }\n+    !$acc end parallel\n+    !$acc host_data use_device (a) ! { dg-error \"not a variable\" }\n+    !$acc end host_data\n+    !$acc parallel loop reduction(+:a) ! { dg-error \"not a variable\" }\n+    do i = 1,5\n+    enddo\n+    !$acc end parallel loop\n+    !$acc parallel loop\n+    do i = 1,5\n+      !$acc cache (a) ! TODO: This must fail, as in openacc-1_0-branch\n+    enddo\n+    !$acc end parallel loop\n+    !$acc update device (a) ! { dg-error \"not a variable\" }\n+    !$acc update host (a) ! { dg-error \"not a variable\" }\n+    !$acc update self (a) ! { dg-error \"not a variable\" }\n+  end subroutine oacc1\n+end module test\n+! { dg-prune-output \"unimplemented\" }"}, {"sha": "23ce95ad8d24341d4493711364e307fa28520137", "filename": "gcc/testsuite/gfortran.dg/goacc/private-1.f95", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivate-1.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivate-1.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivate-1.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-omplower\" }\n+\n+! test for implicit private clauses in do loops\n+\n+program test\n+  implicit none\n+  integer :: i, j, k\n+\n+  !$acc parallel\n+  !$acc loop\n+  do i = 1, 100\n+  end do\n+  !$acc end parallel\n+\n+  !$acc parallel\n+  !$acc loop\n+  do i = 1, 100\n+     do j = 1, 100\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  !$acc parallel\n+  !$acc loop\n+  do i = 1, 100\n+     do j = 1, 100\n+        do k = 1, 100\n+        end do\n+     end do\n+  end do\n+  !$acc end parallel\n+end program test\n+! { dg-final { scan-tree-dump-times \"pragma omp target oacc_parallel\" 3 \"omplower\" } }\n+! { dg-final { scan-tree-dump-times \"private\\\\(i\\\\)\" 3 \"omplower\" } }\n+! { dg-final { scan-tree-dump-times \"private\\\\(j\\\\)\" 2 \"omplower\" } }\n+! { dg-final { scan-tree-dump-times \"private\\\\(k\\\\)\" 1 \"omplower\" } }"}, {"sha": "4b038f2b5f20f34bf0396bb658d0d83d80eb86c1", "filename": "gcc/testsuite/gfortran.dg/goacc/private-2.f95", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivate-2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivate-2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivate-2.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+\n+! test for implicit private clauses in do loops\n+\n+program test\n+  implicit none\n+  integer :: i, j, k, a(10)\n+\n+  !$acc parallel\n+  !$acc loop\n+  do i = 1, 100\n+  end do\n+  !$acc end parallel\n+\n+  !$acc parallel\n+  !$acc loop\n+  do i = 1, 100\n+     do j = 1, 100\n+     end do\n+  end do\n+  !$acc end parallel\n+\n+  !$acc data copy(a)\n+\n+  if(mod(1,10) .eq. 0) write(*,'(i5)') i\n+\n+  do i = 1, 100\n+    !$acc parallel\n+    !$acc loop\n+     do j = 1, 100\n+        do k = 1, 100\n+        end do\n+     end do\n+    !$acc end parallel\n+  end do\n+\n+  !$acc end data\n+\n+end program test"}, {"sha": "aa12a56f110a96de90f5f2052169fa540c55a962", "filename": "gcc/testsuite/gfortran.dg/goacc/private-3.f95", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivate-3.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivate-3.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivate-3.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+\n+! test for private variables in a reduction clause\n+\n+program test\n+  implicit none\n+  integer, parameter :: n = 100\n+  integer :: i, k\n+\n+!  FIXME: This causes an ICE in the gimplifier.\n+!  !$acc parallel private (k) reduction (+:k)\n+!  do i = 1, n\n+!     k = k + 1\n+!  end do\n+!  !$acc end parallel\n+\n+  !$acc parallel private (k)\n+  !$acc loop reduction (+:k)\n+  do i = 1, n\n+     k = k + 1\n+  end do\n+  !$acc end parallel\n+end program test"}, {"sha": "726e8e98b22e7947576fbcdda52cd9378208a042", "filename": "gcc/testsuite/gfortran.dg/goacc/pure-elemental-procedures.f95", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fpure-elemental-procedures.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fpure-elemental-procedures.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fpure-elemental-procedures.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,78 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-std=f2008 -fcoarray=single\" }\n+\n+module test\n+  implicit none\n+contains\n+  elemental subroutine test1\n+    !$acc parallel ! { dg-error \"may not appear in PURE procedures\" }\n+  end subroutine test1\n+\n+  pure subroutine test2\n+    !$acc parallel ! { dg-error \"may not appear in PURE procedures\" }\n+  end subroutine test2\n+\n+  ! Implicit pure\n+  elemental real function test3(x)\n+    real, intent(in) :: x\n+    !$acc parallel ! { dg-error \"may not appear in PURE procedures\" }\n+    test3 = x*x\n+  end function test3\n+\n+  pure real function test4(x)\n+    real, intent(in) :: x\n+    !$acc parallel ! { dg-error \"may not appear in PURE procedures\" }\n+    test4 = x\n+  end function test4\n+\n+  subroutine test5\n+    real :: x = 0.0\n+    integer :: i\n+    !$acc parallel loop collapse(1) reduction(+:x)\n+    do i = 1,10\n+      x = x + 0.3\n+    enddo\n+    print *, x\n+  end subroutine test5\n+\n+  real function test6(x)\n+    real :: x\n+    integer :: i\n+    !$acc parallel loop collapse(1) reduction(+:x)\n+    do i = 1,10\n+      x = x + 0.3\n+    enddo\n+    test6 = x\n+  end function test6\n+\n+  impure elemental real function test7(x)\n+    real, intent(in) :: x\n+    !$acc parallel \n+    test7 = x\n+    !$acc end parallel\n+  end function test7\n+\n+  subroutine test8\n+    real :: x = 0.0\n+    integer :: i\n+    !$acc parallel loop collapse(1) reduction(+:x)\n+    do i = 1,10\n+      critical ! { dg-error \"CRITICAL block inside of\" }\n+        x = x + 0.3\n+      end critical\n+    enddo\n+    print *, x\n+  end subroutine test8\n+\n+  real function test9(n)\n+    integer, value :: n\n+    BLOCK\n+      integer i\n+      real sum\n+      !$acc loop reduction(+:sum)\n+      do i=1, n\n+        sum = sum + sin(real(i))\n+      end do\n+    END BLOCK\n+  end function test9\n+end module test\n\\ No newline at end of file"}, {"sha": "ffcec70c7ac2961dc7db6a9dd939c8d65ebdba11", "filename": "gcc/testsuite/gfortran.dg/goacc/reduction-2.f95", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Freduction-2.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Freduction-2.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Freduction-2.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+\n+program reduction\n+  integer, parameter    :: n = 40, c = 10\n+  integer               :: i, sum\n+\n+  call redsub (sum, n, c)\n+end program reduction\n+\n+subroutine redsub(sum, n, c)\n+  integer :: sum, n, c\n+\n+  sum = 0\n+\n+  !$acc parallel vector_length(n) copyin (n, c)\n+  !$acc loop reduction(+:sum)\n+  do i = 1, n\n+     sum = sum + c\n+  end do\n+  !$acc end parallel\n+end subroutine redsub"}, {"sha": "833230ade80b50a38f4fd8be7fee5c34dd33ce11", "filename": "gcc/testsuite/gfortran.dg/goacc/reduction.f95", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Freduction.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Freduction.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Freduction.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,138 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fmax-errors=100\" } \n+\n+subroutine foo (ia1)\n+integer :: i1, i2, i3\n+integer, dimension (*) :: ia1\n+integer, dimension (10) :: ia2\n+real :: r1\n+real, dimension (5) :: ra1\n+double precision :: d1\n+double precision, dimension (4) :: da1\n+complex :: c1\n+complex, dimension (7) :: ca1\n+logical :: l1\n+logical, dimension (3) :: la1\n+character (5) :: a1\n+type t\n+  integer :: i\n+end type\n+type(t) :: t1\n+type(t), dimension (2) :: ta1\n+real, pointer :: p1 => NULL()\n+integer, allocatable :: aa1 (:,:)\n+save i2\n+common /blk/ i1\n+\n+!$acc parallel reduction (+:ia2)\n+!$acc end parallel\n+!$acc parallel reduction (+:ra1)\n+!$acc end parallel\n+!$acc parallel reduction (+:ca1)\n+!$acc end parallel\n+!$acc parallel reduction (+:da1)\n+!$acc end parallel\n+!$acc parallel reduction (.and.:la1)\n+!$acc end parallel\n+!$acc parallel reduction (+:i3, r1, d1, c1)\n+!$acc end parallel\n+!$acc parallel reduction (*:i3, r1, d1, c1)\n+!$acc end parallel\n+!$acc parallel reduction (-:i3, r1, d1, c1)\n+!$acc end parallel\n+!$acc parallel reduction (.and.:l1)\n+!$acc end parallel\n+!$acc parallel reduction (.or.:l1)\n+!$acc end parallel\n+!$acc parallel reduction (.eqv.:l1)\n+!$acc end parallel\n+!$acc parallel reduction (.neqv.:l1)\n+!$acc end parallel\n+!$acc parallel reduction (min:i3, r1, d1)\n+!$acc end parallel\n+!$acc parallel reduction (max:i3, r1, d1)\n+!$acc end parallel\n+!$acc parallel reduction (iand:i3)\n+!$acc end parallel\n+!$acc parallel reduction (ior:i3)\n+!$acc end parallel\n+!$acc parallel reduction (ieor:i3)\n+!$acc end parallel\n+!$acc parallel reduction (+:/blk/)\t! { dg-error \"Syntax error\" }\n+!$acc end parallel\t\t\t! { dg-error \"Unexpected\" }\n+!$acc parallel reduction (*:p1)\t\t! { dg-error \"POINTER object\" }\n+!$acc end parallel\n+!$acc parallel reduction (-:aa1)\n+!$acc end parallel\n+!$acc parallel reduction (*:ia1)\t! { dg-error \"Assumed size\" }\n+!$acc end parallel\n+!$acc parallel reduction (+:l1)\t\t! { dg-error \"OMP DECLARE REDUCTION \\\\+ not found for type LOGICAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (*:la1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\* not found for type LOGICAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (-:a1)\t\t! { dg-error \"OMP DECLARE REDUCTION - not found for type CHARACTER\" }\n+!$acc end parallel\n+!$acc parallel reduction (+:t1)\t\t! { dg-error \"OMP DECLARE REDUCTION \\\\+ not found for type TYPE\" }\n+!$acc end parallel\n+!$acc parallel reduction (*:ta1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\* not found for type TYPE\" }\n+!$acc end parallel\n+!$acc parallel reduction (.and.:i3)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.and\\\\. not found for type INTEGER\" }\n+!$acc end parallel\n+!$acc parallel reduction (.or.:ia2)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.or\\\\. not found for type INTEGER\" }\n+!$acc end parallel\n+!$acc parallel reduction (.eqv.:r1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.eqv\\\\. not found for type REAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (.neqv.:ra1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.neqv\\\\. not found for type REAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (.and.:d1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.and\\\\. not found for type REAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (.or.:da1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.or\\\\. not found for type REAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (.eqv.:c1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.eqv\\\\. not found for type COMPLEX\" }\n+!$acc end parallel\n+!$acc parallel reduction (.neqv.:ca1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.neqv\\\\. not found for type COMPLEX\" }\n+!$acc end parallel\n+!$acc parallel reduction (.and.:a1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.and\\\\. not found for type CHARACTER\" }\n+!$acc end parallel\n+!$acc parallel reduction (.or.:t1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.or\\\\. not found for type TYPE\" }\n+!$acc end parallel\n+!$acc parallel reduction (.eqv.:ta1)\t! { dg-error \"OMP DECLARE REDUCTION \\\\.eqv\\\\. not found for type TYPE\" }\n+!$acc end parallel\n+!$acc parallel reduction (min:c1)\t! { dg-error \"OMP DECLARE REDUCTION min not found for type COMPLEX\" }\n+!$acc end parallel\n+!$acc parallel reduction (max:ca1)\t! { dg-error \"OMP DECLARE REDUCTION max not found for type COMPLEX\" }\n+!$acc end parallel\n+!$acc parallel reduction (max:l1)\t! { dg-error \"OMP DECLARE REDUCTION max not found for type LOGICAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (min:la1)\t! { dg-error \"OMP DECLARE REDUCTION min not found for type LOGICAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (max:a1)\t! { dg-error \"OMP DECLARE REDUCTION max not found for type CHARACTER\" }\n+!$acc end parallel\n+!$acc parallel reduction (min:t1)\t! { dg-error \"OMP DECLARE REDUCTION min not found for type TYPE\" }\n+!$acc end parallel\n+!$acc parallel reduction (max:ta1)\t! { dg-error \"OMP DECLARE REDUCTION max not found for type TYPE\" }\n+!$acc end parallel\n+!$acc parallel reduction (iand:r1)\t! { dg-error \"OMP DECLARE REDUCTION iand not found for type REAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (ior:ra1)\t! { dg-error \"OMP DECLARE REDUCTION ior not found for type REAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (ieor:d1)\t! { dg-error \"OMP DECLARE REDUCTION ieor not found for type REAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (ior:da1)\t! { dg-error \"OMP DECLARE REDUCTION ior not found for type REAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (iand:c1)\t! { dg-error \"OMP DECLARE REDUCTION iand not found for type COMPLEX\" }\n+!$acc end parallel\n+!$acc parallel reduction (ior:ca1)\t! { dg-error \"OMP DECLARE REDUCTION ior not found for type COMPLEX\" }\n+!$acc end parallel\n+!$acc parallel reduction (ieor:l1)\t! { dg-error \"OMP DECLARE REDUCTION ieor not found for type LOGICAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (iand:la1)\t! { dg-error \"OMP DECLARE REDUCTION iand not found for type LOGICAL\" }\n+!$acc end parallel\n+!$acc parallel reduction (ior:a1)\t! { dg-error \"OMP DECLARE REDUCTION ior not found for type CHARACTER\" }\n+!$acc end parallel\n+!$acc parallel reduction (ieor:t1)\t! { dg-error \"OMP DECLARE REDUCTION ieor not found for type TYPE\" }\n+!$acc end parallel\n+!$acc parallel reduction (iand:ta1)\t! { dg-error \"OMP DECLARE REDUCTION iand not found for type TYPE\" }\n+!$acc end parallel\n+\n+end subroutine"}, {"sha": "67c5f11be6a5817714b3cb348dd413cdaff8c790", "filename": "gcc/testsuite/gfortran.dg/goacc/routine-1.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Froutine-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Froutine-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Froutine-1.f90?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+\n+  integer, parameter :: n = 10\n+  integer :: a(n), i\n+  integer, external :: fact\n+  i = 1\n+  !$acc routine (fact)  ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC ROUTINE\" }\n+  !$acc routine ()  ! { dg-error \"Syntax error in \\\\\\!\\\\\\$ACC ROUTINE \\\\\\( NAME \\\\\\)\" }\n+  !$acc parallel\n+  !$acc loop\n+  do i = 1, n\n+     a(i) = fact (i)\n+     call incr (a(i))\n+  end do\n+  !$acc end parallel\n+  do i = 1, n\n+     write (*, \"(I10)\") a(i)\n+  end do\n+end\n+recursive function fact (x) result (res)\n+  integer, intent(in) :: x\n+  integer :: res\n+  res = 1\n+  !$acc routine  ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC ROUTINE\" }\n+  if (x < 1) then\n+     res = 1\n+  else\n+     res = x * fact (x - 1)\n+  end if\n+end function fact\n+subroutine incr (x)\n+  integer, intent(inout) :: x\n+  integer i\n+  i = 0\n+  !$acc routine  ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC ROUTINE\" }\n+  x = x + 1\n+end subroutine incr"}, {"sha": "3be335115816c84928cea90ef5ca45ed2a35f4b4", "filename": "gcc/testsuite/gfortran.dg/goacc/routine-2.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Froutine-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Froutine-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Froutine-2.f90?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+\n+  module m1\n+    contains\n+    recursive function mfact (x) result (res)\n+      integer, intent(in) :: x\n+      integer :: res\n+      integer i\n+      i = 0\n+      !$acc routine  ! { dg-error \"Unexpected \\\\\\!\\\\\\$ACC ROUTINE\" }\n+      if (x < 1) then\n+         res = 1\n+      else\n+         res = x * mfact (x - 1)\n+      end if\n+    end function mfact\n+  end module m1"}, {"sha": "1a3189cb34e63d9cf161594cbf80b585f71a21b2", "filename": "gcc/testsuite/gfortran.dg/goacc/sentinel-free-form.f95", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fsentinel-free-form.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fsentinel-free-form.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fsentinel-free-form.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile } \n+\n+program test\n+  implicit none\n+\n+  integer :: i\n+  real :: x\n+\n+  ! sentinel may only be preceeded by white space\n+  x = 0.0 !$acc parallel ! comment\n+  ! sentinel must appear as a single word\n+  ! $acc parallel ! comment\n+  !$ acc parallel ! { dg-error \"Unclassifiable statement\" }\n+  ! directive lines must have space after sentinel\n+  !$accparallel ! { dg-warning \"followed by a space\" }\n+  do i = 1,10\n+    x = x + 0.3\n+  enddo\n+  !$acc end parallel ! { dg-error \"Unexpected\" }\n+  print *, x\n+end\n\\ No newline at end of file"}, {"sha": "8fb97b53d387e2cc19a67237ccbac3e1c7156984", "filename": "gcc/testsuite/gfortran.dg/goacc/several-directives.f95", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fseveral-directives.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fseveral-directives.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fseveral-directives.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,6 @@\n+! { dg-do compile } \n+\n+program test\n+  ! only one directive-name may appear in directive\n+  !$acc parallel kernels ! { dg-error \"Unclassifiable OpenACC directive\" }\n+end\n\\ No newline at end of file"}, {"sha": "2d66026b4c59ee72a640b7636251496f0eda12ef", "filename": "gcc/testsuite/gfortran.dg/goacc/sie.f95", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fsie.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fsie.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fsie.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,252 @@\n+! { dg-do compile } \n+! { dg-additional-options \"-fmax-errors=100\" } \n+\n+! tests async, num_gangs, num_workers, vector_length, gang, worker, vector clauses\n+\n+program test\n+  implicit none\n+\n+  integer :: i\n+\n+  !$acc parallel async\n+  !$acc end parallel\n+\n+  !$acc parallel async(3)\n+  !$acc end parallel\n+\n+  !$acc parallel async(i)\n+  !$acc end parallel\n+\n+  !$acc parallel async(i+1)\n+  !$acc end parallel\n+\n+  !$acc parallel async(-1) \n+  !$acc end parallel\n+\n+  !$acc parallel async(0) \n+  !$acc end parallel\n+\n+  !$acc parallel async() ! { dg-error \"Invalid character in name\" }\n+\n+  !$acc parallel async(1.5) ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+  !$acc parallel async(.true.) ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+  !$acc parallel async(\"1\") ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+  !$acc kernels async\n+  !$acc end kernels\n+\n+  !$acc kernels async(3)\n+  !$acc end kernels\n+\n+  !$acc kernels async(i)\n+  !$acc end kernels\n+\n+  !$acc kernels async(i+1)\n+  !$acc end kernels\n+\n+  !$acc kernels async(-1) \n+  !$acc end kernels\n+\n+  !$acc kernels async(0) \n+  !$acc end kernels\n+\n+  !$acc kernels async() ! { dg-error \"Invalid character in name\" }\n+\n+  !$acc kernels async(1.5) ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end kernels\n+\n+  !$acc kernels async(.true.) ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end kernels\n+\n+  !$acc kernels async(\"1\") ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end kernels\n+\n+\n+  !$acc parallel num_gangs ! { dg-error \"Unclassifiable OpenACC directive\" }\n+\n+  !$acc parallel num_gangs(3)\n+  !$acc end parallel\n+\n+  !$acc parallel num_gangs(i)\n+  !$acc end parallel\n+\n+  !$acc parallel num_gangs(i+1)\n+  !$acc end parallel\n+\n+  !$acc parallel num_gangs(-1) ! { dg-warning \"must be positive\" }\n+  !$acc end parallel\n+\n+  !$acc parallel num_gangs(0) ! { dg-warning \"must be positive\" }\n+  !$acc end parallel\n+\n+  !$acc parallel num_gangs() ! { dg-error \"Invalid character in name\" }\n+\n+  !$acc parallel num_gangs(1.5) ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+  !$acc parallel num_gangs(.true.) ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+  !$acc parallel num_gangs(\"1\") ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+\n+  !$acc parallel num_workers ! { dg-error \"Unclassifiable OpenACC directive\" }\n+\n+  !$acc parallel num_workers(3)\n+  !$acc end parallel\n+\n+  !$acc parallel num_workers(i)\n+  !$acc end parallel\n+\n+  !$acc parallel num_workers(i+1)\n+  !$acc end parallel\n+\n+  !$acc parallel num_workers(-1) ! { dg-warning \"must be positive\" }\n+  !$acc end parallel\n+\n+  !$acc parallel num_workers(0) ! { dg-warning \"must be positive\" }\n+  !$acc end parallel\n+\n+  !$acc parallel num_workers() ! { dg-error \"Invalid character in name\" }\n+\n+  !$acc parallel num_workers(1.5) ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+  !$acc parallel num_workers(.true.) ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+  !$acc parallel num_workers(\"1\") ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+\n+  !$acc parallel vector_length ! { dg-error \"Unclassifiable OpenACC directive\" }\n+\n+  !$acc parallel vector_length(3)\n+  !$acc end parallel\n+\n+  !$acc parallel vector_length(i)\n+  !$acc end parallel\n+\n+  !$acc parallel vector_length(i+1)\n+  !$acc end parallel\n+\n+  !$acc parallel vector_length(-1) ! { dg-warning \"must be positive\" }\n+  !$acc end parallel\n+\n+  !$acc parallel vector_length(0) ! { dg-warning \"must be positive\" }\n+  !$acc end parallel\n+\n+  !$acc parallel vector_length() ! { dg-error \"Invalid character in name\" }\n+\n+  !$acc parallel vector_length(1.5) ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+  !$acc parallel vector_length(.true.) ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+  !$acc parallel vector_length(\"1\") ! { dg-error \"scalar INTEGER expression\" }\n+  !$acc end parallel\n+\n+\n+  !$acc loop gang\n+  do i = 1,10\n+  enddo\n+  !$acc loop gang(3)\n+  do i = 1,10\n+  enddo\n+  !$acc loop gang(i)\n+  do i = 1,10\n+  enddo\n+  !$acc loop gang(i+1)\n+  do i = 1,10\n+  enddo\n+  !$acc loop gang(-1) ! { dg-warning \"must be positive\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop gang(0) ! { dg-warning \"must be positive\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop gang() ! { dg-error \"Invalid character in name\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop gang(1.5) ! { dg-error \"scalar INTEGER expression\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop gang(.true.) ! { dg-error \"scalar INTEGER expression\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop gang(\"1\") ! { dg-error \"scalar INTEGER expression\" }\n+  do i = 1,10\n+  enddo\n+\n+\n+  !$acc loop worker\n+  do i = 1,10\n+  enddo\n+  !$acc loop worker(3)\n+  do i = 1,10\n+  enddo\n+  !$acc loop worker(i)\n+  do i = 1,10\n+  enddo\n+  !$acc loop worker(i+1)\n+  do i = 1,10\n+  enddo\n+  !$acc loop worker(-1) ! { dg-warning \"must be positive\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop worker(0) ! { dg-warning \"must be positive\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop worker() ! { dg-error \"Invalid character in name\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop worker(1.5) ! { dg-error \"scalar INTEGER expression\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop worker(.true.) ! { dg-error \"scalar INTEGER expression\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop worker(\"1\") ! { dg-error \"scalar INTEGER expression\" }\n+  do i = 1,10\n+  enddo\n+\n+\n+  !$acc loop vector\n+  do i = 1,10\n+  enddo\n+  !$acc loop vector(3)\n+  do i = 1,10\n+  enddo\n+  !$acc loop vector(i)\n+  do i = 1,10\n+  enddo\n+  !$acc loop vector(i+1)\n+  do i = 1,10\n+  enddo\n+  !$acc loop vector(-1) ! { dg-warning \"must be positive\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop vector(0) ! { dg-warning \"must be positive\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop vector() ! { dg-error \"Invalid character in name\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop vector(1.5) ! { dg-error \"scalar INTEGER expression\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop vector(.true.) ! { dg-error \"scalar INTEGER expression\" }\n+  do i = 1,10\n+  enddo\n+  !$acc loop vector(\"1\") ! { dg-error \"scalar INTEGER expression\" }\n+  do i = 1,10\n+  enddo\n+\n+end program test\n\\ No newline at end of file"}, {"sha": "4b3ef42d1759231bf3d3cb61519dc7bb88ffb306", "filename": "gcc/testsuite/gfortran.dg/goacc/subarrays.f95", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fsubarrays.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fsubarrays.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fsubarrays.f95?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+program test\n+  implicit none\n+  integer :: a(10), b(10, 10), c(3:7), i\n+\n+  !$acc parallel copy(a(1:5))\n+  !$acc end parallel\n+  !$acc parallel copy(a(1 + 0 : 5 + 2))\n+  !$acc end parallel\n+  !$acc parallel copy(a(:3))\n+  !$acc end parallel\n+  !$acc parallel copy(a(3:))\n+  !$acc end parallel\n+  !$acc parallel copy(a(:))\n+  !$acc end parallel\n+  !$acc parallel copy(a(2:3,2:3))\n+  ! { dg-error \"Rank mismatch\" \"\" { target *-*-* } 16 }\n+  ! { dg-error \"'a' in MAP clause\" \"\" { target *-*-* } 16 }\n+  !$acc end parallel\n+  !$acc parallel copy (a(:11)) ! { dg-warning \"Upper array reference\" }\n+  !$acc end parallel\n+  !$acc parallel copy (a(i:))\n+  !$acc end parallel\n+\n+  !$acc parallel copy (a(:b))\n+  ! { dg-error \"Array index\" \"\" { target *-*-* } 25 }\n+  ! { dg-error \"'a' in MAP clause\" \"\" { target *-*-* } 25 }\n+  !$acc end parallel\n+\n+  !$acc parallel copy (b(1:3,2:4))\n+  !$acc end parallel\n+  !$acc parallel copy (b(2:3))\n+  ! { dg-error \"Rank mismatch\" \"\" { target *-*-* } 32 }\n+  ! { dg-error \"'b' in MAP clause\" \"\" { target *-*-* } 32 }\n+  !$acc end parallel\n+  !$acc parallel copy (b(1:, 4:6))\n+  !$acc end parallel\n+\n+  !$acc parallel copy (c(2:)) ! { dg-warning \"Lower array reference\" }\n+  !$acc end parallel\n+end program test"}, {"sha": "e4b8b862afdcff9fb9e559f88b855aa8ad50646e", "filename": "gcc/testsuite/gfortran.dg/gomp/map-1.f90", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fmap-1.f90?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,110 @@\n+subroutine test(aas)\n+  implicit none\n+\n+  integer :: i, j(10), k(10, 10), aas(*)\n+  integer, save :: tp\n+  !$omp threadprivate(tp)\n+  integer, parameter :: p = 1\n+\n+  type t\n+    integer :: i, j(10)\n+  end type t\n+\n+  type(t) :: tt\n+\n+  !$omp target map(i)\n+  !$omp end target\n+\n+  !$omp target map(j)\n+  !$omp end target\n+\n+  !$omp target map(p) ! { dg-error \"Object 'p' is not a variable\" }\n+  !$omp end target\n+\n+  !$omp target map(j(1))\n+  !$omp end target\n+\n+  !$omp target map(j(i))\n+  !$omp end target\n+\n+  !$omp target map(j(i:))\n+  !$omp end target\n+\n+  !$omp target map(j(:i))\n+  !$omp end target\n+\n+  !$omp target map(j(i:i+1))\n+  !$omp end target\n+\n+  !$omp target map(j(11)) ! { dg-warning \"out of bounds\" }\n+  !$omp end target\n+\n+  !$omp target map(j(:11)) ! { dg-warning \"out of bounds\" }\n+  !$omp end target\n+\n+  !$omp target map(j(0:)) ! { dg-warning \"out of bounds\" }\n+  !$omp end target\n+\n+  !$omp target map(j(5:4))\n+  !$omp end target\n+\n+  !$omp target map(j(5:))\n+  !$omp end target\n+\n+  !$omp target map(j(:5))\n+  !$omp end target\n+\n+  !$omp target map(j(:))\n+  !$omp end target\n+\n+  !$omp target map(j(1:9:2)) ! { dg-error \"Stride should not be specified for array section in MAP clause\" }\n+  !$omp end target\n+\n+  !$omp target map(aas(5:))\n+  !$omp end target\n+  ! { dg-error \"Rightmost upper bound of assumed size array section not specified\" \"\" { target *-*-* } 63 }\n+  ! { dg-error \"'aas' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 63 }\n+\n+  !$omp target map(aas(:))\n+  !$omp end target\n+  ! { dg-error \"Rightmost upper bound of assumed size array section not specified\" \"\" { target *-*-* } 68 }\n+  ! { dg-error \"'aas' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 68 }\n+\n+  !$omp target map(aas) ! { dg-error \"The upper bound in the last dimension must appear\" \"\" { xfail *-*-* } }\n+  !$omp end target\n+\n+  !$omp target map(aas(5:7))\n+  !$omp end target\n+\n+  !$omp target map(aas(:7))\n+  !$omp end target\n+\n+  !$omp target map(k(5:))\n+  !$omp end target\n+  ! { dg-error \"Rank mismatch in array reference\" \"\" { target *-*-* } 82 }\n+  ! { dg-error \"'k' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 82 }\n+\n+  !$omp target map(k(5:,:,3))\n+  !$omp end target\n+  ! { dg-error \"Rank mismatch in array reference\" \"\" { target *-*-* } 87 }\n+  ! { dg-error \"'k' in MAP clause at \\\\\\(1\\\\\\) is not a proper array section\" \"\" { target *-*-* } 87 }\n+\n+  !$omp target map(tt)\n+  !$omp end target\n+\n+  !$omp target map(tt%i) ! { dg-error \"Syntax error in OpenMP variable list\" }\n+  !$omp end target ! { dg-error \"Unexpected !\\\\\\$OMP END TARGET statement\" }\n+\n+  !$omp target map(tt%j) ! { dg-error \"Syntax error in OpenMP variable list\" }\n+  !$omp end target ! { dg-error \"Unexpected !\\\\\\$OMP END TARGET statement\" }\n+\n+  ! broken test\n+  !$omp target map(tt%j(1)) ! { dg-error \"Syntax error in OpenMP variable list\" }\n+  !$omp end target ! { dg-error \"Unexpected !\\\\\\$OMP END TARGET statement\" }\n+\n+  !$omp target map(tt%j(1:)) ! { dg-error \"Syntax error in OpenMP variable list\" }\n+  !$omp end target ! { dg-error \"Unexpected !\\\\\\$OMP END TARGET statement\" }\n+\n+  !$omp target map(tp) ! { dg-error \"THREADPRIVATE object 'tp' in MAP clause\" }\n+  !$omp end target\n+end subroutine test"}, {"sha": "42f40734a1e39d5de47afb689498a719b1ad8c2c", "filename": "gcc/testsuite/gfortran.dg/openacc-define-1.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenacc-define-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenacc-define-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenacc-define-1.f90?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,7 @@\n+! { dg-options \"-cpp\" }\n+! { dg-do preprocess }\n+! { dg-require-effective-target fopenacc }\n+\n+#ifdef _OPENACC\n+# error _OPENACC defined\n+#endif"}, {"sha": "8ad1bd5539271daf7673a9e5d266975f23c10588", "filename": "gcc/testsuite/gfortran.dg/openacc-define-2.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenacc-define-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenacc-define-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenacc-define-2.f90?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,7 @@\n+! { dg-options \"-cpp -fno-openacc\" }\n+! { dg-do preprocess }\n+! { dg-require-effective-target fopenacc }\n+\n+#ifdef _OPENACC\n+# error _OPENACC defined\n+#endif"}, {"sha": "b6c296e6b9821b15525208ac9d6d9d7e8b874a30", "filename": "gcc/testsuite/gfortran.dg/openacc-define-3.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenacc-define-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenacc-define-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fopenacc-define-3.f90?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,11 @@\n+! { dg-options \"-cpp -fopenacc\" }\n+! { dg-do preprocess }\n+! { dg-require-effective-target fopenacc }\n+\n+#ifndef _OPENACC\n+# error _OPENACC not defined\n+#endif\n+\n+#if _OPENACC != 201306\n+# error _OPENACC defined to wrong value\n+#endif"}, {"sha": "e51d07d8d7ca5da2b0c5224a09e504a9e8c7fb75", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -788,6 +788,15 @@ proc check_effective_target_fgraphite {} {\n     } \"-O1 -fgraphite\"]\n }\n \n+# Return 1 if compilation with -fopenacc is error-free for trivial\n+# code, 0 otherwise.\n+\n+proc check_effective_target_fopenacc {} {\n+    return [check_no_compiler_messages fopenacc object {\n+\tvoid foo (void) { }\n+    } \"-fopenacc\"]\n+}\n+\n # Return 1 if compilation with -fopenmp is error-free for trivial\n # code, 0 otherwise.\n "}, {"sha": "735ce5cf30779e61e8fe1cdc11c823a4654d1487", "filename": "gcc/tree-core.h", "status": "modified", "additions": 62, "deletions": 26, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -208,19 +208,19 @@ enum omp_clause_code {\n      (c_parser_omp_variable_list).  */\n   OMP_CLAUSE_ERROR = 0,\n \n-  /* OpenMP clause: private (variable_list).  */\n+  /* OpenACC/OpenMP clause: private (variable_list).  */\n   OMP_CLAUSE_PRIVATE,\n \n   /* OpenMP clause: shared (variable_list).  */\n   OMP_CLAUSE_SHARED,\n \n-  /* OpenMP clause: firstprivate (variable_list).  */\n+  /* OpenACC/OpenMP clause: firstprivate (variable_list).  */\n   OMP_CLAUSE_FIRSTPRIVATE,\n \n   /* OpenMP clause: lastprivate (variable_list).  */\n   OMP_CLAUSE_LASTPRIVATE,\n \n-  /* OpenMP clause: reduction (operator:variable_list).\n+  /* OpenACC/OpenMP clause: reduction (operator:variable_list).\n      OMP_CLAUSE_REDUCTION_CODE: The tree_code of the operator.\n      Operand 1: OMP_CLAUSE_REDUCTION_INIT: Stmt-list to initialize the var.\n      Operand 2: OMP_CLAUSE_REDUCTION_MERGE: Stmt-list to merge private var\n@@ -253,13 +253,48 @@ enum omp_clause_code {\n   /* OpenMP clause: to (variable-list).  */\n   OMP_CLAUSE_TO,\n \n-  /* OpenMP clause: map ({alloc:,to:,from:,tofrom:,}variable-list).  */\n+  /* OpenACC clauses: {copy, copyin, copyout, create, delete, deviceptr,\n+     device, host (self), present, present_or_copy (pcopy), present_or_copyin\n+     (pcopyin), present_or_copyout (pcopyout), present_or_create (pcreate)}\n+     (variable-list).\n+\n+     OpenMP clause: map ({alloc:,to:,from:,tofrom:,}variable-list).  */\n   OMP_CLAUSE_MAP,\n \n+  /* Internal structure to hold OpenACC cache directive's variable-list.\n+     #pragma acc cache (variable-list).  */\n+  OMP_CLAUSE__CACHE_,\n+\n+  /* OpenACC clause: device_resident (variable_list).  */\n+  OMP_CLAUSE_DEVICE_RESIDENT,\n+\n+  /* OpenACC clause: use_device (variable_list).  */\n+  OMP_CLAUSE_USE_DEVICE,\n+\n+  /* OpenACC clause: gang [(gang-argument-list)].\n+     Where\n+      gang-argument-list: [gang-argument-list, ] gang-argument\n+      gang-argument: [num:] integer-expression\n+                   | static: size-expression\n+      size-expression: * | integer-expression.  */\n+  OMP_CLAUSE_GANG,\n+\n+  /* OpenACC clause: async [(integer-expression)].  */\n+  OMP_CLAUSE_ASYNC,\n+\n+  /* OpenACC clause: wait [(integer-expression-list)].  */\n+  OMP_CLAUSE_WAIT,\n+\n+  /* OpenACC clause: auto.  */\n+  OMP_CLAUSE_AUTO,\n+\n+  /* OpenACC clause: seq.  */\n+  OMP_CLAUSE_SEQ,\n+\n   /* Internal clause: temporary for combined loops expansion.  */\n   OMP_CLAUSE__LOOPTEMP_,\n \n-  /* OpenMP clause: if (scalar-expression).  */\n+  /* OpenACC/OpenMP clause: if (scalar-expression).  */\n   OMP_CLAUSE_IF,\n \n   /* OpenMP clause: num_threads (integer-expression).  */\n@@ -277,7 +312,7 @@ enum omp_clause_code {\n   /* OpenMP clause: default.  */\n   OMP_CLAUSE_DEFAULT,\n \n-  /* OpenMP clause: collapse (constant-integer-expression).  */\n+  /* OpenACC/OpenMP clause: collapse (constant-integer-expression).  */\n   OMP_CLAUSE_COLLAPSE,\n \n   /* OpenMP clause: untied.  */\n@@ -333,7 +368,25 @@ enum omp_clause_code {\n \n   /* Internally used only clause, holding _Cilk_for # of iterations\n      on OMP_PARALLEL.  */\n-  OMP_CLAUSE__CILK_FOR_COUNT_\n+  OMP_CLAUSE__CILK_FOR_COUNT_,\n+\n+  /* OpenACC clause: independent.  */\n+  OMP_CLAUSE_INDEPENDENT,\n+\n+  /* OpenACC clause: worker [( [num:] integer-expression)].  */\n+  OMP_CLAUSE_WORKER,\n+\n+  /* OpenACC clause: vector [( [length:] integer-expression)].  */\n+  OMP_CLAUSE_VECTOR,\n+\n+  /* OpenACC clause: num_gangs (integer-expression).  */\n+  OMP_CLAUSE_NUM_GANGS,\n+\n+  /* OpenACC clause: num_workers (integer-expression).  */\n+  OMP_CLAUSE_NUM_WORKERS,\n+\n+  /* OpenACC clause: vector_length (integer-expression).  */\n+  OMP_CLAUSE_VECTOR_LENGTH\n };\n \n #undef DEFTREESTRUCT\n@@ -1172,24 +1225,6 @@ enum omp_clause_depend_kind\n   OMP_CLAUSE_DEPEND_LAST\n };\n \n-enum omp_clause_map_kind\n-{\n-  OMP_CLAUSE_MAP_ALLOC,\n-  OMP_CLAUSE_MAP_TO,\n-  OMP_CLAUSE_MAP_FROM,\n-  OMP_CLAUSE_MAP_TOFROM,\n-  /* The following kind is an internal only map kind, used for pointer based\n-     array sections.  OMP_CLAUSE_SIZE for these is not the pointer size,\n-     which is implicitly POINTER_SIZE_UNITS, but the bias.  */\n-  OMP_CLAUSE_MAP_POINTER,\n-  /* Also internal, behaves like OMP_CLAUS_MAP_TO, but additionally any\n-     OMP_CLAUSE_MAP_POINTER records consecutive after it which have addresses\n-     falling into that range will not be ignored if OMP_CLAUSE_MAP_TO_PSET\n-     wasn't mapped already.  */\n-  OMP_CLAUSE_MAP_TO_PSET,\n-  OMP_CLAUSE_MAP_LAST\n-};\n-\n enum omp_clause_proc_bind_kind\n {\n   /* Numbers should match omp_proc_bind_t enum in omp.h.  */\n@@ -1261,7 +1296,8 @@ struct GTY(()) tree_omp_clause {\n     enum omp_clause_default_kind   default_kind;\n     enum omp_clause_schedule_kind  schedule_kind;\n     enum omp_clause_depend_kind    depend_kind;\n-    enum omp_clause_map_kind       map_kind;\n+    /* See include/gomp-constants.h for enum gomp_map_kind's values.  */\n+    unsigned char\t\t   map_kind;\n     enum omp_clause_proc_bind_kind proc_bind_kind;\n     enum tree_code                 reduction_code;\n   } GTY ((skip)) subcode;"}, {"sha": "5443ab5bc32bd077b3084c910ae0a569ad1a6f8b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -4194,7 +4194,7 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n       return (estimate_num_insns_seq (gimple_try_eval (stmt), weights)\n               + estimate_num_insns_seq (gimple_try_cleanup (stmt), weights));\n \n-    /* OpenMP directives are generally very expensive.  */\n+    /* OMP directives are generally very expensive.  */\n \n     case GIMPLE_OMP_RETURN:\n     case GIMPLE_OMP_SECTIONS_SWITCH:"}, {"sha": "f2e6d3acfd72239b4472c05a528fee21123e1412", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -73,6 +73,7 @@\n #include \"expr.h\"\t/* FIXME: For STACK_SAVEAREA_MODE and SAVE_NONLOCAL.  */\n #include \"langhooks.h\"\n #include \"gimple-low.h\"\n+#include \"gomp-constants.h\"\n \n \n /* The object of this pass is to lower the representation of a set of nested\n@@ -850,7 +851,7 @@ static void note_nonlocal_vla_type (struct nesting_info *info, tree type);\n /* A subroutine of convert_nonlocal_reference_op.  Create a local variable\n    in the nested function with DECL_VALUE_EXPR set to reference the true\n    variable in the parent function.  This is used both for debug info\n-   and in OpenMP lowering.  */\n+   and in OMP lowering.  */\n \n static tree\n get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n@@ -1399,7 +1400,7 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_OMP_TARGET:\n-      if (gimple_omp_target_kind (stmt) != GF_OMP_TARGET_KIND_REGION)\n+      if (!is_gimple_omp_offloaded (stmt))\n \t{\n \t  save_suppress = info->suppress_expansion;\n \t  convert_nonlocal_omp_clauses (gimple_omp_target_clauses_ptr (stmt),\n@@ -1418,7 +1419,7 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t  decl = get_chain_decl (info);\n \t  c = build_omp_clause (gimple_location (stmt), OMP_CLAUSE_MAP);\n \t  OMP_CLAUSE_DECL (c) = decl;\n-\t  OMP_CLAUSE_MAP_KIND (c) = OMP_CLAUSE_MAP_TO;\n+\t  OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_TO);\n \t  OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n \t  OMP_CLAUSE_CHAIN (c) = gimple_omp_target_clauses (stmt);\n \t  gimple_omp_target_set_clauses (as_a <gomp_target *> (stmt), c);\n@@ -1503,7 +1504,7 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n /* A subroutine of convert_local_reference.  Create a local variable\n    in the parent function with DECL_VALUE_EXPR set to reference the\n-   field in FRAME.  This is used both for debug info and in OpenMP\n+   field in FRAME.  This is used both for debug info and in OMP\n    lowering.  */\n \n static tree\n@@ -1968,7 +1969,7 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_OMP_TARGET:\n-      if (gimple_omp_target_kind (stmt) != GF_OMP_TARGET_KIND_REGION)\n+      if (!is_gimple_omp_offloaded (stmt))\n \t{\n \t  save_suppress = info->suppress_expansion;\n \t  convert_local_omp_clauses (gimple_omp_target_clauses_ptr (stmt), wi);\n@@ -1984,7 +1985,7 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t  (void) get_frame_type (info);\n \t  c = build_omp_clause (gimple_location (stmt), OMP_CLAUSE_MAP);\n \t  OMP_CLAUSE_DECL (c) = info->frame_decl;\n-\t  OMP_CLAUSE_MAP_KIND (c) = OMP_CLAUSE_MAP_TOFROM;\n+\t  OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_TOFROM);\n \t  OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (info->frame_decl);\n \t  OMP_CLAUSE_CHAIN (c) = gimple_omp_target_clauses (stmt);\n \t  gimple_omp_target_set_clauses (as_a <gomp_target *> (stmt), c);\n@@ -2301,7 +2302,7 @@ convert_tramp_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       }\n \n     case GIMPLE_OMP_TARGET:\n-      if (gimple_omp_target_kind (stmt) != GF_OMP_TARGET_KIND_REGION)\n+      if (!is_gimple_omp_offloaded (stmt))\n \t{\n \t  *handled_ops_p = false;\n \t  return NULL_TREE;\n@@ -2400,7 +2401,7 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       break;\n \n     case GIMPLE_OMP_TARGET:\n-      if (gimple_omp_target_kind (stmt) != GF_OMP_TARGET_KIND_REGION)\n+      if (!is_gimple_omp_offloaded (stmt))\n \t{\n \t  walk_body (convert_gimple_call, NULL, info, gimple_omp_body_ptr (stmt));\n \t  break;\n@@ -2425,8 +2426,7 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t    {\n \t      c = build_omp_clause (gimple_location (stmt), OMP_CLAUSE_MAP);\n \t      OMP_CLAUSE_DECL (c) = decl;\n-\t      OMP_CLAUSE_MAP_KIND (c)\n-\t\t= i ? OMP_CLAUSE_MAP_TO : OMP_CLAUSE_MAP_TOFROM;\n+\t      OMP_CLAUSE_SET_MAP_KIND (c, i ? GOMP_MAP_TO : GOMP_MAP_TOFROM);\n \t      OMP_CLAUSE_SIZE (c) = DECL_SIZE_UNIT (decl);\n \t      OMP_CLAUSE_CHAIN (c) = gimple_omp_target_clauses (stmt);\n \t      gimple_omp_target_set_clauses (as_a <gomp_target *> (stmt),"}, {"sha": "d7c049f1f443b94f76a8f3d1a88b6b263970f237", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 187, "deletions": 8, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -65,6 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n #include \"wide-int-print.h\"\n #include \"internal-fn.h\"\n+#include \"gomp-constants.h\"\n \n /* Local functions, macros and variables.  */\n static const char *op_symbol (const_tree);\n@@ -350,6 +351,12 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n     case OMP_CLAUSE__LOOPTEMP_:\n       name = \"_looptemp_\";\n       goto print_remap;\n+    case OMP_CLAUSE_DEVICE_RESIDENT:\n+      name = \"device_resident\";\n+      goto print_remap;\n+    case OMP_CLAUSE_USE_DEVICE:\n+      name = \"use_device\";\n+      goto print_remap;\n   print_remap:\n       pp_string (pp, name);\n       pp_left_paren (pp);\n@@ -528,20 +535,41 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n       pp_string (pp, \"map(\");\n       switch (OMP_CLAUSE_MAP_KIND (clause))\n \t{\n-\tcase OMP_CLAUSE_MAP_ALLOC:\n-\tcase OMP_CLAUSE_MAP_POINTER:\n+\tcase GOMP_MAP_ALLOC:\n+\tcase GOMP_MAP_POINTER:\n \t  pp_string (pp, \"alloc\");\n \t  break;\n-\tcase OMP_CLAUSE_MAP_TO:\n-\tcase OMP_CLAUSE_MAP_TO_PSET:\n+\tcase GOMP_MAP_TO:\n+\tcase GOMP_MAP_TO_PSET:\n \t  pp_string (pp, \"to\");\n \t  break;\n-\tcase OMP_CLAUSE_MAP_FROM:\n+\tcase GOMP_MAP_FROM:\n \t  pp_string (pp, \"from\");\n \t  break;\n-\tcase OMP_CLAUSE_MAP_TOFROM:\n+\tcase GOMP_MAP_TOFROM:\n \t  pp_string (pp, \"tofrom\");\n \t  break;\n+\tcase GOMP_MAP_FORCE_ALLOC:\n+\t  pp_string (pp, \"force_alloc\");\n+\t  break;\n+\tcase GOMP_MAP_FORCE_TO:\n+\t  pp_string (pp, \"force_to\");\n+\t  break;\n+\tcase GOMP_MAP_FORCE_FROM:\n+\t  pp_string (pp, \"force_from\");\n+\t  break;\n+\tcase GOMP_MAP_FORCE_TOFROM:\n+\t  pp_string (pp, \"force_tofrom\");\n+\t  break;\n+\tcase GOMP_MAP_FORCE_PRESENT:\n+\t  pp_string (pp, \"force_present\");\n+\t  break;\n+\tcase GOMP_MAP_FORCE_DEALLOC:\n+\t  pp_string (pp, \"force_dealloc\");\n+\t  break;\n+\tcase GOMP_MAP_FORCE_DEVICEPTR:\n+\t  pp_string (pp, \"force_deviceptr\");\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -552,10 +580,10 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n       if (OMP_CLAUSE_SIZE (clause))\n \t{\n \t  if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n-\t      && OMP_CLAUSE_MAP_KIND (clause) == OMP_CLAUSE_MAP_POINTER)\n+\t      && OMP_CLAUSE_MAP_KIND (clause) == GOMP_MAP_POINTER)\n \t    pp_string (pp, \" [pointer assign, bias: \");\n \t  else if (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_MAP\n-\t\t   && OMP_CLAUSE_MAP_KIND (clause) == OMP_CLAUSE_MAP_TO_PSET)\n+\t\t   && OMP_CLAUSE_MAP_KIND (clause) == GOMP_MAP_TO_PSET)\n \t    pp_string (pp, \" [pointer set, len: \");\n \t  else\n \t    pp_string (pp, \" [len: \");\n@@ -578,6 +606,12 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n \t\t\t spc, flags, false);\n       goto print_clause_size;\n \n+    case OMP_CLAUSE__CACHE_:\n+      pp_string (pp, \"(\");\n+      dump_generic_node (pp, OMP_CLAUSE_DECL (clause),\n+\t\t\t spc, flags, false);\n+      goto print_clause_size;\n+\n     case OMP_CLAUSE_NUM_TEAMS:\n       pp_string (pp, \"num_teams(\");\n       dump_generic_node (pp, OMP_CLAUSE_NUM_TEAMS_EXPR (clause),\n@@ -651,6 +685,99 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n       pp_right_paren (pp);\n       break;\n \n+    case OMP_CLAUSE_GANG:\n+      pp_string (pp, \"gang\");\n+      if (OMP_CLAUSE_GANG_EXPR (clause) != NULL_TREE)\n+\t{\n+\t  pp_string (pp, \"(num: \");\n+\t  dump_generic_node (pp, OMP_CLAUSE_GANG_EXPR (clause),\n+\t\t\t     spc, flags, false);\n+\t}\n+      if (OMP_CLAUSE_GANG_STATIC_EXPR (clause) != NULL_TREE)\n+\t{\n+\t  if (OMP_CLAUSE_GANG_EXPR (clause) == NULL_TREE)\n+\t    pp_left_paren (pp);\n+\t  else\n+\t    pp_space (pp);\n+\t  pp_string (pp, \"static:\");\n+\t  if (OMP_CLAUSE_GANG_STATIC_EXPR (clause)\n+\t      == integer_minus_one_node)\n+\t    pp_character (pp, '*');\n+\t  else\n+\t    dump_generic_node (pp, OMP_CLAUSE_GANG_STATIC_EXPR (clause),\n+\t\t\t       spc, flags, false);\n+\t}\n+      if (OMP_CLAUSE_GANG_EXPR (clause) != NULL_TREE\n+\t  || OMP_CLAUSE_GANG_STATIC_EXPR (clause) != NULL_TREE)\n+\tpp_right_paren (pp);\n+      break;\n+\n+    case OMP_CLAUSE_ASYNC:\n+      pp_string (pp, \"async\");\n+      if (OMP_CLAUSE_ASYNC_EXPR (clause))\n+        {\n+          pp_character(pp, '(');\n+          dump_generic_node (pp, OMP_CLAUSE_ASYNC_EXPR (clause),\n+                             spc, flags, false);\n+          pp_character(pp, ')');\n+        }\n+      break;\n+\n+    case OMP_CLAUSE_AUTO:\n+    case OMP_CLAUSE_SEQ:\n+      pp_string (pp, omp_clause_code_name[OMP_CLAUSE_CODE (clause)]);\n+      break;\n+\n+    case OMP_CLAUSE_WAIT:\n+      pp_string (pp, \"wait(\");\n+      dump_generic_node (pp, OMP_CLAUSE_WAIT_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_character(pp, ')');\n+      break;\n+\n+    case OMP_CLAUSE_WORKER:\n+      pp_string (pp, \"worker\");\n+      if (OMP_CLAUSE_WORKER_EXPR (clause) != NULL_TREE)\n+\t{\n+\t  pp_left_paren (pp);\n+\t  dump_generic_node (pp, OMP_CLAUSE_WORKER_EXPR (clause),\n+\t\t\t     spc, flags, false);\n+\t  pp_right_paren (pp);\n+\t}\n+      break;\n+\n+    case OMP_CLAUSE_VECTOR:\n+      pp_string (pp, \"vector\");\n+      if (OMP_CLAUSE_VECTOR_EXPR (clause) != NULL_TREE)\n+\t{\n+\t  pp_left_paren (pp);\n+\t  dump_generic_node (pp, OMP_CLAUSE_VECTOR_EXPR (clause),\n+\t\t\t     spc, flags, false);\n+\t  pp_right_paren (pp);\n+\t}\n+      break;\n+\n+    case OMP_CLAUSE_NUM_GANGS:\n+      pp_string (pp, \"num_gangs(\");\n+      dump_generic_node (pp, OMP_CLAUSE_NUM_GANGS_EXPR (clause),\n+                         spc, flags, false);\n+      pp_character (pp, ')');\n+      break;\n+\n+    case OMP_CLAUSE_NUM_WORKERS:\n+      pp_string (pp, \"num_workers(\");\n+      dump_generic_node (pp, OMP_CLAUSE_NUM_WORKERS_EXPR (clause),\n+                         spc, flags, false);\n+      pp_character (pp, ')');\n+      break;\n+\n+    case OMP_CLAUSE_VECTOR_LENGTH:\n+      pp_string (pp, \"vector_length(\");\n+      dump_generic_node (pp, OMP_CLAUSE_VECTOR_LENGTH_EXPR (clause),\n+                         spc, flags, false);\n+      pp_character (pp, ')');\n+      break;\n+\n     case OMP_CLAUSE_INBRANCH:\n       pp_string (pp, \"inbranch\");\n       break;\n@@ -669,6 +796,9 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, int flags)\n     case OMP_CLAUSE_TASKGROUP:\n       pp_string (pp, \"taskgroup\");\n       break;\n+    case OMP_CLAUSE_INDEPENDENT:\n+      pp_string (pp, \"independent\");\n+      break;\n \n     default:\n       /* Should never happen.  */\n@@ -2433,6 +2563,51 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, int flags,\n       pp_string (pp, \" > \");\n       break;\n \n+    case OACC_PARALLEL:\n+      pp_string (pp, \"#pragma acc parallel\");\n+      dump_omp_clauses (pp, OACC_PARALLEL_CLAUSES (node), spc, flags);\n+      goto dump_omp_body;\n+\n+    case OACC_KERNELS:\n+      pp_string (pp, \"#pragma acc kernels\");\n+      dump_omp_clauses (pp, OACC_KERNELS_CLAUSES (node), spc, flags);\n+      goto dump_omp_body;\n+\n+    case OACC_DATA:\n+      pp_string (pp, \"#pragma acc data\");\n+      dump_omp_clauses (pp, OACC_DATA_CLAUSES (node), spc, flags);\n+      goto dump_omp_body;\n+\n+    case OACC_HOST_DATA:\n+      pp_string (pp, \"#pragma acc host_data\");\n+      dump_omp_clauses (pp, OACC_HOST_DATA_CLAUSES (node), spc, flags);\n+      goto dump_omp_body;\n+\n+    case OACC_DECLARE:\n+      pp_string (pp, \"#pragma acc declare\");\n+      dump_omp_clauses (pp, OACC_DECLARE_CLAUSES (node), spc, flags);\n+      break;\n+\n+    case OACC_UPDATE:\n+      pp_string (pp, \"#pragma acc update\");\n+      dump_omp_clauses (pp, OACC_UPDATE_CLAUSES (node), spc, flags);\n+      break;\n+\n+    case OACC_ENTER_DATA:\n+      pp_string (pp, \"#pragma acc enter data\");\n+      dump_omp_clauses (pp, OACC_ENTER_DATA_CLAUSES (node), spc, flags);\n+      break;\n+\n+    case OACC_EXIT_DATA:\n+      pp_string (pp, \"#pragma acc exit data\");\n+      dump_omp_clauses (pp, OACC_EXIT_DATA_CLAUSES (node), spc, flags);\n+      break;\n+\n+    case OACC_CACHE:\n+      pp_string (pp, \"#pragma acc cache\");\n+      dump_omp_clauses (pp, OACC_CACHE_CLAUSES (node), spc, flags);\n+      break;\n+\n     case OMP_PARALLEL:\n       pp_string (pp, \"#pragma omp parallel\");\n       dump_omp_clauses (pp, OMP_PARALLEL_CLAUSES (node), spc, flags);\n@@ -2477,6 +2652,10 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, int flags,\n       pp_string (pp, \"#pragma omp distribute\");\n       goto dump_omp_loop;\n \n+    case OACC_LOOP:\n+      pp_string (pp, \"#pragma acc loop\");\n+      goto dump_omp_loop;\n+\n     case OMP_TEAMS:\n       pp_string (pp, \"#pragma omp teams\");\n       dump_omp_clauses (pp, OMP_TEAMS_CLAUSES (node), spc, flags);"}, {"sha": "67d33ed1fbce75d6ecb8d368f3743ea22563c8e5", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -59,6 +59,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-streamer.h\"\n #include \"builtins.h\"\n #include \"ipa-chkp.h\"\n+#include \"gomp-constants.h\"\n+\n \n /* Read a STRING_CST from the string table in DATA_IN using input\n    block IB.  */\n@@ -435,8 +437,8 @@ unpack_ts_omp_clause_value_fields (struct data_in *data_in,\n \t= bp_unpack_enum (bp, omp_clause_depend_kind, OMP_CLAUSE_DEPEND_LAST);\n       break;\n     case OMP_CLAUSE_MAP:\n-      OMP_CLAUSE_MAP_KIND (expr)\n-\t= bp_unpack_enum (bp, omp_clause_map_kind, OMP_CLAUSE_MAP_LAST);\n+      OMP_CLAUSE_SET_MAP_KIND (expr, bp_unpack_enum (bp, gomp_map_kind,\n+\t\t\t\t\t\t     GOMP_MAP_LAST));\n       break;\n     case OMP_CLAUSE_PROC_BIND:\n       OMP_CLAUSE_PROC_BIND_KIND (expr)"}, {"sha": "3669680ae9369764cae764523653a93be1dac127", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -55,6 +55,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-streamer.h\"\n #include \"data-streamer.h\"\n #include \"streamer-hooks.h\"\n+#include \"gomp-constants.h\"\n+\n \n /* Output the STRING constant to the string\n    table in OB.  Then put the index onto the INDEX_STREAM.  */\n@@ -395,7 +397,7 @@ pack_ts_omp_clause_value_fields (struct output_block *ob,\n \t\t    OMP_CLAUSE_DEPEND_KIND (expr));\n       break;\n     case OMP_CLAUSE_MAP:\n-      bp_pack_enum (bp, omp_clause_map_kind, OMP_CLAUSE_MAP_LAST,\n+      bp_pack_enum (bp, gomp_map_kind, GOMP_MAP_LAST,\n \t\t    OMP_CLAUSE_MAP_KIND (expr));\n       break;\n     case OMP_CLAUSE_PROC_BIND:"}, {"sha": "e1d069d8dc06e539ad4df3f775e5ce107ea13521", "filename": "gcc/tree.c", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -329,6 +329,14 @@ unsigned const char omp_clause_num_ops[] =\n   2, /* OMP_CLAUSE_FROM  */\n   2, /* OMP_CLAUSE_TO  */\n   2, /* OMP_CLAUSE_MAP  */\n+  2, /* OMP_CLAUSE__CACHE_  */\n+  1, /* OMP_CLAUSE_DEVICE_RESIDENT  */\n+  1, /* OMP_CLAUSE_USE_DEVICE  */\n+  2, /* OMP_CLAUSE_GANG  */\n+  1, /* OMP_CLAUSE_ASYNC  */\n+  1, /* OMP_CLAUSE_WAIT  */\n+  0, /* OMP_CLAUSE_AUTO  */\n+  0, /* OMP_CLAUSE_SEQ  */\n   1, /* OMP_CLAUSE__LOOPTEMP_  */\n   1, /* OMP_CLAUSE_IF  */\n   1, /* OMP_CLAUSE_NUM_THREADS  */\n@@ -355,6 +363,12 @@ unsigned const char omp_clause_num_ops[] =\n   0, /* OMP_CLAUSE_TASKGROUP  */\n   1, /* OMP_CLAUSE__SIMDUID_  */\n   1, /* OMP_CLAUSE__CILK_FOR_COUNT_  */\n+  0, /* OMP_CLAUSE_INDEPENDENT  */\n+  1, /* OMP_CLAUSE_WORKER  */\n+  1, /* OMP_CLAUSE_VECTOR  */\n+  1, /* OMP_CLAUSE_NUM_GANGS  */\n+  1, /* OMP_CLAUSE_NUM_WORKERS  */\n+  1, /* OMP_CLAUSE_VECTOR_LENGTH  */\n };\n \n const char * const omp_clause_code_name[] =\n@@ -374,6 +388,14 @@ const char * const omp_clause_code_name[] =\n   \"from\",\n   \"to\",\n   \"map\",\n+  \"_cache_\",\n+  \"device_resident\",\n+  \"use_device\",\n+  \"gang\",\n+  \"async\",\n+  \"wait\",\n+  \"auto\",\n+  \"seq\",\n   \"_looptemp_\",\n   \"if\",\n   \"num_threads\",\n@@ -399,7 +421,13 @@ const char * const omp_clause_code_name[] =\n   \"sections\",\n   \"taskgroup\",\n   \"_simduid_\",\n-  \"_Cilk_for_count_\"\n+  \"_Cilk_for_count_\",\n+  \"independent\",\n+  \"worker\",\n+  \"vector\",\n+  \"num_gangs\",\n+  \"num_workers\",\n+  \"vector_length\"\n };\n \n \n@@ -11167,6 +11195,19 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n     case OMP_CLAUSE:\n       switch (OMP_CLAUSE_CODE (*tp))\n \t{\n+\tcase OMP_CLAUSE_GANG:\n+\t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 1));\n+\t  /* FALLTHRU */\n+\n+\tcase OMP_CLAUSE_DEVICE_RESIDENT:\n+\tcase OMP_CLAUSE_USE_DEVICE:\n+\tcase OMP_CLAUSE_ASYNC:\n+\tcase OMP_CLAUSE_WAIT:\n+\tcase OMP_CLAUSE_WORKER:\n+\tcase OMP_CLAUSE_VECTOR:\n+\tcase OMP_CLAUSE_NUM_GANGS:\n+\tcase OMP_CLAUSE_NUM_WORKERS:\n+\tcase OMP_CLAUSE_VECTOR_LENGTH:\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_SHARED:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n@@ -11190,6 +11231,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 0));\n \t  /* FALLTHRU */\n \n+\tcase OMP_CLAUSE_INDEPENDENT:\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_DEFAULT:\n@@ -11202,6 +11244,8 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_PARALLEL:\n \tcase OMP_CLAUSE_SECTIONS:\n \tcase OMP_CLAUSE_TASKGROUP:\n+\tcase OMP_CLAUSE_AUTO:\n+\tcase OMP_CLAUSE_SEQ:\n \t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));\n \n \tcase OMP_CLAUSE_LASTPRIVATE:\n@@ -11227,6 +11271,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_FROM:\n \tcase OMP_CLAUSE_TO:\n \tcase OMP_CLAUSE_MAP:\n+\tcase OMP_CLAUSE__CACHE_:\n \t  WALK_SUBTREE (OMP_CLAUSE_DECL (*tp));\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 1));\n \t  WALK_SUBTREE_TAIL (OMP_CLAUSE_CHAIN (*tp));"}, {"sha": "b4b41642a6d6b65fd78e487e30fe54787b8ccef4", "filename": "gcc/tree.def", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1030,8 +1030,33 @@ DEFTREECODE (TARGET_MEM_REF, \"target_mem_ref\", tcc_reference, 5)\n    chain of component references offsetting p by c.  */\n DEFTREECODE (MEM_REF, \"mem_ref\", tcc_reference, 2)\n \n-/* The ordering of the codes between OMP_PARALLEL and OMP_CRITICAL is\n-   exposed to TREE_RANGE_CHECK.  */\n+/* OpenACC and OpenMP.  As it is exposed in TREE_RANGE_CHECK invocations, do\n+   not change the ordering of these codes.  */\n+\n+/* OpenACC - #pragma acc parallel [clause1 ... clauseN]\n+   Operand 0: OACC_PARALLEL_BODY: Code to be executed in parallel.\n+   Operand 1: OACC_PARALLEL_CLAUSES: List of clauses.  */\n+\n+DEFTREECODE (OACC_PARALLEL, \"oacc_parallel\", tcc_statement, 2)\n+\n+/* OpenACC - #pragma acc kernels [clause1 ... clauseN]\n+   Operand 0: OACC_KERNELS_BODY: Sequence of kernels.\n+   Operand 1: OACC_KERNELS_CLAUSES: List of clauses.  */\n+\n+DEFTREECODE (OACC_KERNELS, \"oacc_kernels\", tcc_statement, 2)\n+\n+/* OpenACC - #pragma acc data [clause1 ... clauseN]\n+   Operand 0: OACC_DATA_BODY: Data construct body.\n+   Operand 1: OACC_DATA_CLAUSES: List of clauses.  */\n+\n+DEFTREECODE (OACC_DATA, \"oacc_data\", tcc_statement, 2)\n+\n+/* OpenACC - #pragma acc host_data [clause1 ... clauseN]\n+   Operand 0: OACC_HOST_DATA_BODY: Host_data construct body.\n+   Operand 1: OACC_HOST_DATA_CLAUSES: List of clauses.  */\n+\n+DEFTREECODE (OACC_HOST_DATA, \"oacc_host_data\", tcc_statement, 2)\n+\n /* OpenMP - #pragma omp parallel [clause1 ... clauseN]\n    Operand 0: OMP_PARALLEL_BODY: Code to be executed by all threads.\n    Operand 1: OMP_PARALLEL_CLAUSES: List of clauses.  */\n@@ -1062,7 +1087,7 @@ DEFTREECODE (OMP_TASK, \"omp_task\", tcc_statement, 2)\n    private.  N1, N2 and INCR are required to be loop invariant integer\n    expressions that are evaluated without any synchronization.\n    The evaluation order, frequency of evaluation and side-effects are\n-   unspecified by the standard.  */\n+   unspecified by the standards.  */\n DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 6)\n \n /* OpenMP - #pragma omp simd [clause1 ... clauseN]\n@@ -1081,6 +1106,10 @@ DEFTREECODE (CILK_FOR, \"cilk_for\", tcc_statement, 6)\n    Operands like for OMP_FOR.  */\n DEFTREECODE (OMP_DISTRIBUTE, \"omp_distribute\", tcc_statement, 6)\n \n+/* OpenMP - #pragma acc loop [clause1 ... clauseN]\n+   Operands like for OMP_FOR.  */\n+DEFTREECODE (OACC_LOOP, \"oacc_loop\", tcc_statement, 6)\n+\n /* OpenMP - #pragma omp teams [clause1 ... clauseN]\n    Operand 0: OMP_TEAMS_BODY: Teams body.\n    Operand 1: OMP_TEAMS_CLAUSES: List of clauses.  */\n@@ -1127,6 +1156,27 @@ DEFTREECODE (OMP_ORDERED, \"omp_ordered\", tcc_statement, 1)\n    Operand 1: OMP_CRITICAL_NAME: Identifier for critical section.  */\n DEFTREECODE (OMP_CRITICAL, \"omp_critical\", tcc_statement, 2)\n \n+/* OpenACC - #pragma acc cache (variable1 ... variableN)\n+   Operand 0: OACC_CACHE_CLAUSES: List of variables (transformed into\n+\tOMP_CLAUSE__CACHE_ clauses).  */\n+DEFTREECODE (OACC_CACHE, \"oacc_cache\", tcc_statement, 1)\n+\n+/* OpenACC - #pragma acc declare [clause1 ... clauseN]\n+   Operand 0: OACC_DECLARE_CLAUSES: List of clauses.  */\n+DEFTREECODE (OACC_DECLARE, \"oacc_declare\", tcc_statement, 1)\n+\n+/* OpenACC - #pragma acc enter data [clause1 ... clauseN]\n+   Operand 0: OACC_ENTER_DATA_CLAUSES: List of clauses.  */\n+DEFTREECODE (OACC_ENTER_DATA, \"oacc_enter_data\", tcc_statement, 1)\n+\n+/* OpenACC - #pragma acc exit data [clause1 ... clauseN]\n+   Operand 0: OACC_EXIT_DATA_CLAUSES: List of clauses.  */\n+DEFTREECODE (OACC_EXIT_DATA, \"oacc_exit_data\", tcc_statement, 1)\n+\n+/* OpenACC - #pragma acc update [clause1 ... clauseN]\n+   Operand 0: OACC_UPDATE_CLAUSES: List of clauses.  */\n+DEFTREECODE (OACC_UPDATE, \"oacc_update\", tcc_statement, 1)\n+\n /* OpenMP - #pragma omp target update [clause1 ... clauseN]\n    Operand 0: OMP_TARGET_UPDATE_CLAUSES: List of clauses.  */\n DEFTREECODE (OMP_TARGET_UPDATE, \"omp_target_update\", tcc_statement, 1)"}, {"sha": "4f83b38103bc66ca523bee203eeb70c7cc29ef33", "filename": "gcc/tree.h", "status": "modified", "additions": 84, "deletions": 8, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1195,12 +1195,47 @@ extern void protected_set_expr_location (tree, location_t);\n #define TRANSACTION_EXPR_RELAXED(NODE) \\\n   (TRANSACTION_EXPR_CHECK (NODE)->base.public_flag)\n \n-/* OpenMP directive and clause accessors.  */\n+/* OpenMP and OpenACC directive and clause accessors.  */\n \n #define OMP_BODY(NODE) \\\n-  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OMP_PARALLEL, OMP_CRITICAL), 0)\n+  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_CRITICAL), 0)\n #define OMP_CLAUSES(NODE) \\\n-  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OMP_PARALLEL, OMP_SINGLE), 1)\n+  TREE_OPERAND (TREE_RANGE_CHECK (NODE, OACC_PARALLEL, OMP_SINGLE), 1)\n+\n+#define OACC_PARALLEL_BODY(NODE) \\\n+  TREE_OPERAND (OACC_PARALLEL_CHECK (NODE), 0)\n+#define OACC_PARALLEL_CLAUSES(NODE) \\\n+  TREE_OPERAND (OACC_PARALLEL_CHECK (NODE), 1)\n+\n+#define OACC_KERNELS_BODY(NODE) \\\n+  TREE_OPERAND (OACC_KERNELS_CHECK(NODE), 0)\n+#define OACC_KERNELS_CLAUSES(NODE) \\\n+  TREE_OPERAND (OACC_KERNELS_CHECK(NODE), 1)\n+\n+#define OACC_DATA_BODY(NODE) \\\n+  TREE_OPERAND (OACC_DATA_CHECK (NODE), 0)\n+#define OACC_DATA_CLAUSES(NODE) \\\n+  TREE_OPERAND (OACC_DATA_CHECK (NODE), 1)\n+\n+#define OACC_HOST_DATA_BODY(NODE) \\\n+  TREE_OPERAND (OACC_HOST_DATA_CHECK (NODE), 0)\n+#define OACC_HOST_DATA_CLAUSES(NODE) \\\n+  TREE_OPERAND (OACC_HOST_DATA_CHECK (NODE), 1)\n+\n+#define OACC_CACHE_CLAUSES(NODE) \\\n+  TREE_OPERAND (OACC_CACHE_CHECK (NODE), 0)\n+\n+#define OACC_DECLARE_CLAUSES(NODE) \\\n+  TREE_OPERAND (OACC_DECLARE_CHECK (NODE), 0)\n+\n+#define OACC_ENTER_DATA_CLAUSES(NODE) \\\n+  TREE_OPERAND (OACC_ENTER_DATA_CHECK (NODE), 0)\n+\n+#define OACC_EXIT_DATA_CLAUSES(NODE) \\\n+  TREE_OPERAND (OACC_EXIT_DATA_CHECK (NODE), 0)\n+\n+#define OACC_UPDATE_CLAUSES(NODE) \\\n+  TREE_OPERAND (OACC_UPDATE_CHECK (NODE), 0)\n \n #define OMP_PARALLEL_BODY(NODE)    TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 0)\n #define OMP_PARALLEL_CLAUSES(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 1)\n@@ -1212,7 +1247,7 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_TASKREG_BODY(NODE)    TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 0)\n #define OMP_TASKREG_CLAUSES(NODE) TREE_OPERAND (OMP_TASKREG_CHECK (NODE), 1)\n \n-#define OMP_LOOP_CHECK(NODE) TREE_RANGE_CHECK (NODE, OMP_FOR, OMP_DISTRIBUTE)\n+#define OMP_LOOP_CHECK(NODE) TREE_RANGE_CHECK (NODE, OMP_FOR, OACC_LOOP)\n #define OMP_FOR_BODY(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 0)\n #define OMP_FOR_CLAUSES(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 1)\n #define OMP_FOR_INIT(NODE)\t   TREE_OPERAND (OMP_LOOP_CHECK (NODE), 2)\n@@ -1254,7 +1289,7 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_SIZE(NODE)\t\t\t\t\t\t\\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),\t\\\n \t\t\t\t\t      OMP_CLAUSE_FROM,\t\t\\\n-\t\t\t\t\t      OMP_CLAUSE_MAP), 1)\n+\t\t\t\t\t      OMP_CLAUSE__CACHE_), 1)\n \n #define OMP_CLAUSE_CHAIN(NODE)     TREE_CHAIN (OMP_CLAUSE_CHECK (NODE))\n #define OMP_CLAUSE_DECL(NODE)      \t\t\t\t\t\\\n@@ -1271,6 +1306,15 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_SECTION_LAST(NODE) \\\n   (OMP_SECTION_CHECK (NODE)->base.private_flag)\n \n+/* True on an OACC_KERNELS statement if is represents combined kernels loop\n+   directive.  */\n+#define OACC_KERNELS_COMBINED(NODE) \\\n+  (OACC_KERNELS_CHECK (NODE)->base.private_flag)\n+\n+/* Like OACC_KERNELS_COMBINED, but for parallel loop directive.  */\n+#define OACC_PARALLEL_COMBINED(NODE) \\\n+  (OACC_PARALLEL_CHECK (NODE)->base.private_flag)\n+\n /* True on an OMP_PARALLEL statement if it represents an explicit\n    combined parallel work-sharing constructs.  */\n #define OMP_PARALLEL_COMBINED(NODE) \\\n@@ -1313,15 +1357,47 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_SCHEDULE_CHUNK_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_SCHEDULE), 0)\n \n+/* OpenACC clause expressions  */\n+#define OMP_CLAUSE_GANG_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND ( \\\n+    OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_GANG), 0)\n+#define OMP_CLAUSE_GANG_STATIC_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND ( \\\n+    OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_GANG), 1)\n+#define OMP_CLAUSE_ASYNC_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND ( \\\n+    OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_ASYNC), 0)\n+#define OMP_CLAUSE_WAIT_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND ( \\\n+    OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_WAIT), 0)\n+#define OMP_CLAUSE_VECTOR_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND ( \\\n+    OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_VECTOR), 0)\n+#define OMP_CLAUSE_WORKER_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND ( \\\n+    OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_WORKER), 0)\n+#define OMP_CLAUSE_NUM_GANGS_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND ( \\\n+    OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_GANGS), 0)\n+#define OMP_CLAUSE_NUM_WORKERS_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND ( \\\n+    OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_WORKERS), 0)\n+#define OMP_CLAUSE_VECTOR_LENGTH_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND ( \\\n+    OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_VECTOR_LENGTH), 0)\n+\n #define OMP_CLAUSE_DEPEND_KIND(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_DEPEND)->omp_clause.subcode.depend_kind)\n \n #define OMP_CLAUSE_MAP_KIND(NODE) \\\n-  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->omp_clause.subcode.map_kind)\n+  ((enum gomp_map_kind) OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->omp_clause.subcode.map_kind)\n+#define OMP_CLAUSE_SET_MAP_KIND(NODE, MAP_KIND) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->omp_clause.subcode.map_kind \\\n+   = (unsigned char) (MAP_KIND))\n \n /* Nonzero if this map clause is for array (rather than pointer) based array\n-   section with zero bias.  Both the non-decl OMP_CLAUSE_MAP and\n-   correspoidng OMP_CLAUSE_MAP_POINTER clause are marked with this flag.  */\n+   section with zero bias.  Both the non-decl OMP_CLAUSE_MAP and corresponding\n+   OMP_CLAUSE_MAP with GOMP_MAP_POINTER are marked with this flag.  */\n #define OMP_CLAUSE_MAP_ZERO_BIAS_ARRAY_SECTION(NODE) \\\n   (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_MAP)->base.public_flag)\n "}, {"sha": "9c8f1ebd426ea9c44c3b02d7dbd5145c24eb4823", "filename": "gcc/varpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -173,7 +173,7 @@ varpool_node::get_create (tree decl)\n   node = varpool_node::create_empty ();\n   node->decl = decl;\n \n-  if (flag_openmp\n+  if ((flag_openacc || flag_openmp)\n       && lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (decl)))\n     {\n       node->offloadable = 1;"}, {"sha": "0917d9443bc0fe51613aa360357d41d8535fdfe1", "filename": "include/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,9 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\n+\t* gomp-constants.h: New file.\n+\n 2015-12-14  Jan-Benedict Glaw  <jbglaw@lug-owl.de>\n \n \t* libiberty.h: Merge Copyright year update from Binutils."}, {"sha": "e3d2820d76361722b0008412f16b435559c79c96", "filename": "include/gomp-constants.h", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -0,0 +1,116 @@\n+/* Communication between GCC and libgomp.\n+\n+   Copyright (C) 2014-2015 Free Software Foundation, Inc.\n+\n+   Contributed by Mentor Embedded.\n+\n+   This file is part of the GNU Offloading and Multi Processing Library\n+   (libgomp).\n+\n+   Libgomp is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libgomp is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GOMP_CONSTANTS_H\n+#define GOMP_CONSTANTS_H 1\n+\n+/* Memory mapping types.  */\n+\n+/* One byte.  */\n+#define GOMP_MAP_LAST\t\t\t(1 << 8)\n+\n+#define GOMP_MAP_FLAG_TO\t\t(1 << 0)\n+#define GOMP_MAP_FLAG_FROM\t\t(1 << 1)\n+/* Special map kinds, enumerated starting here.  */\n+#define GOMP_MAP_FLAG_SPECIAL_0\t\t(1 << 2)\n+#define GOMP_MAP_FLAG_SPECIAL_1\t\t(1 << 3)\n+#define GOMP_MAP_FLAG_SPECIAL\t\t(GOMP_MAP_FLAG_SPECIAL_1 \\\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_0)\n+/* Flag to force a specific behavior (or else, trigger a run-time error).  */\n+#define GOMP_MAP_FLAG_FORCE\t\t(1 << 7)\n+\n+enum gomp_map_kind\n+  {\n+    /* If not already present, allocate.  */\n+    GOMP_MAP_ALLOC =\t\t\t0,\n+    /* ..., and copy to device.  */\n+    GOMP_MAP_TO =\t\t\t(GOMP_MAP_ALLOC | GOMP_MAP_FLAG_TO),\n+    /* ..., and copy from device.  */\n+    GOMP_MAP_FROM =\t\t\t(GOMP_MAP_ALLOC | GOMP_MAP_FLAG_FROM),\n+    /* ..., and copy to and from device.  */\n+    GOMP_MAP_TOFROM =\t\t\t(GOMP_MAP_TO | GOMP_MAP_FROM),\n+    /* The following kind is an internal only map kind, used for pointer based\n+       array sections.  OMP_CLAUSE_SIZE for these is not the pointer size,\n+       which is implicitly POINTER_SIZE_UNITS, but the bias.  */\n+    GOMP_MAP_POINTER =\t\t\t(GOMP_MAP_FLAG_SPECIAL_0 | 0),\n+    /* Also internal, behaves like GOMP_MAP_TO, but additionally any\n+       GOMP_MAP_POINTER records consecutive after it which have addresses\n+       falling into that range will not be ignored if GOMP_MAP_TO_PSET wasn't\n+       mapped already.  */\n+    GOMP_MAP_TO_PSET =\t\t\t(GOMP_MAP_FLAG_SPECIAL_0 | 1),\n+    /* Must already be present.  */\n+    GOMP_MAP_FORCE_PRESENT =\t\t(GOMP_MAP_FLAG_SPECIAL_0 | 2),\n+    /* Deallocate a mapping, without copying from device.  */\n+    GOMP_MAP_FORCE_DEALLOC =\t\t(GOMP_MAP_FLAG_SPECIAL_0 | 3),\n+    /* Is a device pointer.  OMP_CLAUSE_SIZE for these is unused; is implicitly\n+       POINTER_SIZE_UNITS.  */\n+    GOMP_MAP_FORCE_DEVICEPTR =\t\t(GOMP_MAP_FLAG_SPECIAL_1 | 0),\n+    /* Allocate.  */\n+    GOMP_MAP_FORCE_ALLOC =\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_ALLOC),\n+    /* ..., and copy to device.  */\n+    GOMP_MAP_FORCE_TO =\t\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_TO),\n+    /* ..., and copy from device.  */\n+    GOMP_MAP_FORCE_FROM =\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_FROM),\n+    /* ..., and copy to and from device.  */\n+    GOMP_MAP_FORCE_TOFROM =\t\t(GOMP_MAP_FLAG_FORCE | GOMP_MAP_TOFROM)\n+  };\n+\n+#define GOMP_MAP_COPY_TO_P(X) \\\n+  (!((X) & GOMP_MAP_FLAG_SPECIAL) \\\n+   && ((X) & GOMP_MAP_FLAG_TO))\n+\n+#define GOMP_MAP_COPY_FROM_P(X) \\\n+  (!((X) & GOMP_MAP_FLAG_SPECIAL) \\\n+   && ((X) & GOMP_MAP_FLAG_FROM))\n+\n+#define GOMP_MAP_POINTER_P(X) \\\n+  ((X) == GOMP_MAP_POINTER)\n+\n+\n+/* Asynchronous behavior.  Keep in sync with\n+   libgomp/{openacc.h,openacc.f90,openacc_lib.h}:acc_async_t.  */\n+\n+#define GOMP_ASYNC_NOVAL\t\t-1\n+#define GOMP_ASYNC_SYNC\t\t\t-2\n+\n+\n+/* Device codes.  Keep in sync with\n+   libgomp/{openacc.h,openacc.f90,openacc_lib.h}:acc_device_t as well as\n+   libgomp/libgomp_target.h.  */\n+#define GOMP_DEVICE_NONE\t\t0\n+#define GOMP_DEVICE_DEFAULT\t\t1\n+#define GOMP_DEVICE_HOST\t\t2\n+#define GOMP_DEVICE_HOST_NONSHM\t\t3\n+#define GOMP_DEVICE_NOT_HOST\t\t4\n+#define GOMP_DEVICE_NVIDIA_PTX\t\t5\n+#define GOMP_DEVICE_INTEL_MIC\t\t6\n+\n+#define GOMP_DEVICE_ICV\t\t\t-1\n+#define GOMP_DEVICE_HOST_FALLBACK\t-2\n+\n+#endif"}, {"sha": "9b003cbb027f5f54884bb9710e6e12fe7ea26103", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -1,3 +1,354 @@\n+2015-01-15  Thomas Schwinge  <thomas@codesourcery.com>\n+\t    James Norris  <jnorris@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Cesar Philippidis  <cesar@codesourcery.com>\n+\t    Nathan Sidwell  <nathan@codesourcery.com>\n+\t    Tobias Burnus  <burnus@net-b.de>\n+\n+\t* Makefile.am (search_path): Add $(top_srcdir)/../include.\n+\t(libgomp_la_SOURCES): Add splay-tree.c, libgomp-plugin.c,\n+\toacc-parallel.c, oacc-host.c, oacc-init.c, oacc-mem.c,\n+\toacc-async.c, oacc-plugin.c, oacc-cuda.c.\n+\t[USE_FORTRAN] (libgomp_la_SOURCES): Add openacc.f90.\n+\tInclude $(top_srcdir)/plugin/Makefrag.am.\n+\t(nodist_libsubinclude_HEADERS): Add openacc.h.\n+\t[USE_FORTRAN] (nodist_finclude_HEADERS): Add openacc_lib.h,\n+\topenacc.f90, openacc.mod, openacc_kinds.mod.\n+\t(omp_lib.mod): Generalize into...\n+\t(%.mod): ... this new rule.\n+\t(openacc_kinds.mod, openacc.mod): New rules.\n+\t* plugin/configfrag.ac: New file.\n+\t* configure.ac: Move plugin/offloading support into it.  Include\n+\tit.  Instantiate testsuite/libgomp-test-support.pt.exp.\n+\t* plugin/Makefrag.am: New file.\n+\t* testsuite/Makefile.am (OFFLOAD_TARGETS)\n+\t(OFFLOAD_ADDITIONAL_OPTIONS, OFFLOAD_ADDITIONAL_LIB_PATHS): Don't\n+\texport.\n+\t(libgomp-test-support.exp): New rule.\n+\t(all-local): Depend on it.\n+\t* Makefile.in: Regenerate.\n+\t* testsuite/Makefile.in: Regenerate.\n+\t* config.h.in: Likewise.\n+\t* configure: Likewise.\n+\t* configure.tgt: Harden shell syntax.\n+\t* env.c: Include \"oacc-int.h\".\n+\t(parse_acc_device_type): New function.\n+\t(gomp_debug_var, goacc_device_type, goacc_device_num): New\n+\tvariables.\n+\t(initialize_env): Initialize those.  Call\n+\tgoacc_runtime_initialize.\n+\t* error.c (gomp_vdebug, gomp_debug, gomp_vfatal): New functions.\n+\t(gomp_fatal): Call gomp_vfatal.\n+\t* libgomp.h: Include \"libgomp-plugin.h\" and <stdarg.h>.\n+\t(gomp_debug_var, goacc_device_type, goacc_device_num, gomp_vdebug)\n+\t(gomp_debug, gomp_verror, gomp_vfatal, gomp_init_targets_once)\n+\t(splay_tree_node, splay_tree, splay_tree_key)\n+\t(struct target_mem_desc, struct splay_tree_key_s)\n+\t(struct gomp_memory_mapping, struct acc_dispatch_t)\n+\t(struct gomp_device_descr, gomp_acc_insert_pointer)\n+\t(gomp_acc_remove_pointer, target_mem_desc, gomp_copy_from_async)\n+\t(gomp_unmap_vars, gomp_init_device, gomp_init_tables)\n+\t(gomp_free_memmap, gomp_fini_device): New declarations.\n+\t(gomp_vdebug, gomp_debug): New macros.\n+\tInclude \"splay-tree.h\".\n+\t* libgomp.map (OACC_2.0): New symbol version.  Use for\n+\tacc_get_num_devices, acc_get_num_devices_h_, acc_set_device_type,\n+\tacc_set_device_type_h_, acc_get_device_type,\n+\tacc_get_device_type_h_, acc_set_device_num, acc_set_device_num_h_,\n+\tacc_get_device_num, acc_get_device_num_h_, acc_async_test,\n+\tacc_async_test_h_, acc_async_test_all, acc_async_test_all_h_,\n+\tacc_wait, acc_wait_h_, acc_wait_async, acc_wait_async_h_,\n+\tacc_wait_all, acc_wait_all_h_, acc_wait_all_async,\n+\tacc_wait_all_async_h_, acc_init, acc_init_h_, acc_shutdown,\n+\tacc_shutdown_h_, acc_on_device, acc_on_device_h_, acc_malloc,\n+\tacc_free, acc_copyin, acc_copyin_32_h_, acc_copyin_64_h_,\n+\tacc_copyin_array_h_, acc_present_or_copyin,\n+\tacc_present_or_copyin_32_h_, acc_present_or_copyin_64_h_,\n+\tacc_present_or_copyin_array_h_, acc_create, acc_create_32_h_,\n+\tacc_create_64_h_, acc_create_array_h_, acc_present_or_create,\n+\tacc_present_or_create_32_h_, acc_present_or_create_64_h_,\n+\tacc_present_or_create_array_h_, acc_copyout, acc_copyout_32_h_,\n+\tacc_copyout_64_h_, acc_copyout_array_h_, acc_delete,\n+\tacc_delete_32_h_, acc_delete_64_h_, acc_delete_array_h_,\n+\tacc_update_device, acc_update_device_32_h_,\n+\tacc_update_device_64_h_, acc_update_device_array_h_,\n+\tacc_update_self, acc_update_self_32_h_, acc_update_self_64_h_,\n+\tacc_update_self_array_h_, acc_map_data, acc_unmap_data,\n+\tacc_deviceptr, acc_hostptr, acc_is_present, acc_is_present_32_h_,\n+\tacc_is_present_64_h_, acc_is_present_array_h_,\n+\tacc_memcpy_to_device, acc_memcpy_from_device,\n+\tacc_get_current_cuda_device, acc_get_current_cuda_context,\n+\tacc_get_cuda_stream, acc_set_cuda_stream.\n+\t(GOACC_2.0): New symbol version.  Use for GOACC_data_end,\n+\tGOACC_data_start, GOACC_enter_exit_data, GOACC_parallel,\n+\tGOACC_update, GOACC_wait, GOACC_get_thread_num,\n+\tGOACC_get_num_threads.\n+\t(GOMP_PLUGIN_1.0): New symbol version.  Use for\n+\tGOMP_PLUGIN_malloc, GOMP_PLUGIN_malloc_cleared,\n+\tGOMP_PLUGIN_realloc, GOMP_PLUGIN_debug, GOMP_PLUGIN_error,\n+\tGOMP_PLUGIN_fatal, GOMP_PLUGIN_async_unmap_vars,\n+\tGOMP_PLUGIN_acc_thread.\n+\t* libgomp.texi: Update for OpenACC changes, and GOMP_DEBUG\n+\tenvironment variable.\n+\t* libgomp_g.h (GOACC_data_start, GOACC_data_end)\n+\t(GOACC_enter_exit_data, GOACC_parallel, GOACC_update, GOACC_wait)\n+\t(GOACC_get_num_threads, GOACC_get_thread_num): New declarations.\n+\t* splay-tree.h (splay_tree_lookup, splay_tree_insert)\n+\t(splay_tree_remove): New declarations.\n+\t(rotate_left, rotate_right, splay_tree_splay, splay_tree_insert)\n+\t(splay_tree_remove, splay_tree_lookup): Move into...\n+\t* splay-tree.c: ... this new file.\n+\t* target.c: Include \"oacc-plugin.h\", \"oacc-int.h\", <assert.h>.\n+\t(splay_tree_node, splay_tree, splay_tree_key)\n+\t(struct target_mem_desc, struct splay_tree_key_s)\n+\t(struct gomp_device_descr): Don't declare.\n+\t(num_devices_openmp): New variable.\n+\t(gomp_get_num_devices ): Use it.\n+\t(gomp_init_targets_once): New function.\n+\t(gomp_get_num_devices ): Use it.\n+\t(get_kind, gomp_copy_from_async, gomp_free_memmap)\n+\t(gomp_fini_device, gomp_register_image_for_device): New functions.\n+\t(gomp_map_vars): Add devaddrs parameter.\n+\t(gomp_update): Add mm parameter.\n+\t(gomp_init_device): Move most of it into...\n+\t(gomp_init_tables): ... this new function.\n+\t(gomp_register_images_for_device): Remove function.\n+\t(splay_compare, gomp_map_vars, gomp_unmap_vars, gomp_init_device):\n+\tMake them hidden instead of static.\n+\t(gomp_map_vars_existing, gomp_map_vars, gomp_unmap_vars)\n+\t(gomp_update, gomp_init_device, GOMP_target, GOMP_target_data)\n+\t(GOMP_target_end_data, GOMP_target_update)\n+\t(gomp_load_plugin_for_device, gomp_target_init): Update for\n+\tOpenACC changes.\n+\t* oacc-async.c: New file.\n+\t* oacc-cuda.c: Likewise.\n+\t* oacc-host.c: Likewise.\n+\t* oacc-init.c: Likewise.\n+\t* oacc-int.h: Likewise.\n+\t* oacc-mem.c: Likewise.\n+\t* oacc-parallel.c: Likewise.\n+\t* oacc-plugin.c: Likewise.\n+\t* oacc-plugin.h: Likewise.\n+\t* oacc-ptx.h: Likewise.\n+\t* openacc.f90: Likewise.\n+\t* openacc.h: Likewise.\n+\t* openacc_lib.h: Likewise.\n+\t* plugin/plugin-host.c: Likewise.\n+\t* plugin/plugin-nvptx.c: Likewise.\n+\t* libgomp-plugin.c: Likewise.\n+\t* libgomp-plugin.h: Likewise.\n+\t* libgomp_target.h: Remove file after merging content into the\n+\tformer file.  Update all users.\n+\t* testsuite/lib/libgomp.exp: Load libgomp-test-support.exp.\n+\t(offload_targets_s, offload_targets_s_openacc): New variables.\n+\t(check_effective_target_openacc_nvidia_accel_present)\n+\t(check_effective_target_openacc_nvidia_accel_selected): New\n+\tprocedures.\n+\t(libgomp_init): Update for OpenACC changes.\n+\t* testsuite/libgomp-test-support.exp.in: New file.\n+\t* testsuite/libgomp.oacc-c++/c++.exp: Likewise.\n+\t* testsuite/libgomp.oacc-c/c.exp: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/fortran.exp: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/abort-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/abort-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/abort-3.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/abort-4.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/acc_on_device-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/asyncwait-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/cache-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/clauses-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/clauses-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/collapse-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/collapse-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/collapse-3.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/collapse-4.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/context-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/context-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/context-3.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/context-4.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-3.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-already-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-already-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-already-3.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-already-4.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-already-5.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-already-6.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-already-7.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/data-already-8.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/deviceptr-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/if-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/kernels-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/kernels-empty.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-10.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-11.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-12.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-13.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-14.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-15.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-16.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-17.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-18.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-19.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-20.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-21.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-22.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-23.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-24.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-25.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-26.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-27.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-28.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-29.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-3.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-30.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-31.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-32.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-33.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-34.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-35.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-36.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-37.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-38.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-39.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-4.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-40.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-41.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-42.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-43.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-44.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-45.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-46.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-47.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-48.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-49.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-5.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-50.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-51.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-52.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-53.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-54.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-55.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-56.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-57.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-58.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-59.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-6.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-60.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-61.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-62.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-63.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-64.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-65.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-66.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-67.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-68.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-69.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-7.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-70.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-71.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-72.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-73.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-74.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-75.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-76.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-77.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-78.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-79.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-80.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-81.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-82.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-83.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-84.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-85.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-86.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-87.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-88.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-89.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-9.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-90.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-91.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/lib-92.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/nested-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/nested-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/offset-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/parallel-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/parallel-empty.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/pointer-align-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/present-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/present-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/reduction-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/reduction-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/reduction-3.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/reduction-4.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/reduction-5.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/reduction-initial-1.c:\n+\tLikewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/subr.h: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/subr.ptx: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/timer.h: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/update-1-2.c: Likewise.\n+\t* testsuite/libgomp.oacc-c-c++-common/update-1.c: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/abort-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/abort-2.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/acc_on_device-1-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/acc_on_device-1-2.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/acc_on_device-1-3.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/asyncwait-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/asyncwait-2.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/asyncwait-3.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/collapse-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/collapse-2.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/collapse-3.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/collapse-4.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/collapse-5.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/collapse-6.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/collapse-7.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/collapse-8.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-2.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-3.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-4-2.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-4.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-already-1.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-already-2.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-already-3.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-already-4.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-already-5.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-already-6.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-already-7.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/data-already-8.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/lib-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/lib-10.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/lib-2.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/lib-3.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/lib-4.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/lib-5.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/lib-6.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/lib-7.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/lib-8.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/map-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/openacc_version-1.f: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/openacc_version-2.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/pointer-align-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/pset-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/reduction-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/reduction-2.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/reduction-3.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/reduction-4.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/reduction-5.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/reduction-6.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/routine-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/routine-2.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/routine-3.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/routine-4.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/subarrays-1.f90: Likewise.\n+\t* testsuite/libgomp.oacc-fortran/subarrays-2.f90: Likewise.\n+\n 2015-01-10  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Julian Brown  <julian@codesourcery.com>\n \t    David Malcolm  <dmalcolm@redhat.com>"}, {"sha": "5411278b0184676c803e74ca0beb85399af28230", "filename": "libgomp/Makefile.am", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.am?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "patch": "@@ -7,7 +7,8 @@ SUBDIRS = testsuite\n gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n \n config_path = @config_path@\n-search_path = $(addprefix $(top_srcdir)/config/, $(config_path)) $(top_srcdir)\n+search_path = $(addprefix $(top_srcdir)/config/, $(config_path)) $(top_srcdir) \\\n+\t      $(top_srcdir)/../include\n \n fincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/finclude\n libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n@@ -60,12 +61,21 @@ libgomp_la_LINK = $(LINK) $(libgomp_la_LDFLAGS)\n libgomp_la_SOURCES = alloc.c barrier.c critical.c env.c error.c iter.c \\\n \titer_ull.c loop.c loop_ull.c ordered.c parallel.c sections.c single.c \\\n \ttask.c team.c work.c lock.c mutex.c proc.c sem.c bar.c ptrlock.c \\\n-\ttime.c fortran.c affinity.c target.c\n+\ttime.c fortran.c affinity.c target.c splay-tree.c libgomp-plugin.c \\\n+\toacc-parallel.c oacc-host.c oacc-init.c oacc-mem.c oacc-async.c \\\n+\toacc-plugin.c oacc-cuda.c\n+\n+include $(top_srcdir)/plugin/Makefrag.am\n+\n+if USE_FORTRAN\n+libgomp_la_SOURCES += openacc.f90\n+endif\n \n nodist_noinst_HEADERS = libgomp_f.h\n-nodist_libsubinclude_HEADERS = omp.h\n+nodist_libsubinclude_HEADERS = omp.h openacc.h\n if USE_FORTRAN\n-nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod\n+nodist_finclude_HEADERS = omp_lib.h omp_lib.f90 omp_lib.mod omp_lib_kinds.mod \\\n+\topenacc_lib.h openacc.f90 openacc.mod openacc_kinds.mod\n endif\n \n LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n@@ -75,7 +85,11 @@ LINK = $(LIBTOOL) --tag CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link \\\n \n omp_lib_kinds.mod: omp_lib.mod\n \t:\n-omp_lib.mod: omp_lib.f90\n+openacc_kinds.mod: openacc.mod\n+\t:\n+openacc.mod: openacc.lo\n+\t:\n+%.mod: %.f90\n \t$(FC) $(FCFLAGS) -fsyntax-only $<\n fortran.lo: libgomp_f.h\n fortran.o: libgomp_f.h"}, {"sha": "b61b108e36cbda428733a7b8251a2830e00a8696", "filename": "libgomp/Makefile.in", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FMakefile.in?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "02547b16341a0597cf7d82a0f91fd9757ce68511", "filename": "libgomp/config.h.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig.h.in?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "081870728e7727cc33e3b6a7e630f389670b393d", "filename": "libgomp/configure", "status": "modified", "additions": 207, "deletions": 42, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "4687b01d5ccf4c9fb97ca58fc969b84102e31c1e", "filename": "libgomp/configure.ac", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.ac?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "2ef49264e5460263f8083cae43aafd085d5134c8", "filename": "libgomp/configure.tgt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfigure.tgt?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "6b5e963c4ea300fa12c7d0a73f6903746e6a0b83", "filename": "libgomp/env.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "094c24a38c0c078fb0f3a1e1ad19f4de57d866d2", "filename": "libgomp/error.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ferror.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "ffb22e938622288cd65715460ed8cbd1beeffc3d", "filename": "libgomp/libgomp-plugin.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "d9cbff5fe71c731e1944fc116a7a823e630b6f3b", "filename": "libgomp/libgomp-plugin.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "3089401c47f9d9111fcf4af31e3efc8fe143c542", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 212, "deletions": 5, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "f44174e83b2b071b156fec50fe0a32d570c7c49a", "filename": "libgomp/libgomp.map", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.map?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "6c7f1aed641208148a337a531863f954da12cddb", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "c1e4e6367ab2d12b0fbacb92bd026a09d0b90029", "filename": "libgomp/libgomp_g.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp_g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Flibgomp_g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp_g.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "08b7c5e1945781adabad04fc9ad594315b031e0e", "filename": "libgomp/oacc-async.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-async.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-async.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-async.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "c8ef376e3a2310824f3b028de451788b37bd69af", "filename": "libgomp/oacc-cuda.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-cuda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-cuda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-cuda.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "6aeb1e765d5e5562ac58bc4aa12c09043c5f5899", "filename": "libgomp/oacc-host.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "166eb553a6c07ec91db821d7c4f6b94dec86f683", "filename": "libgomp/oacc-init.c", "status": "added", "additions": 636, "deletions": 0, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "85619c8d10ad72d1b17bb28a07a890ed2a10d615", "filename": "libgomp/oacc-int.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-int.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "0096d5142977269a8e68f73de85a5fff16e47b94", "filename": "libgomp/oacc-mem.c", "status": "added", "additions": 585, "deletions": 0, "changes": 585, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "6d5386b1f942d7383c9c1f0c721467c0d8a6e41f", "filename": "libgomp/oacc-parallel.c", "status": "added", "additions": 490, "deletions": 0, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "44cd6d68e331cf48945f139fa0a9836eee38c3dd", "filename": "libgomp/oacc-plugin.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-plugin.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "c60eb9c5ddd175f71f4bb30aa7a67d775d1c0e35", "filename": "libgomp/oacc-plugin.h", "status": "renamed", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-plugin.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e", "previous_filename": "libgomp/libgomp_target.h"}, {"sha": "13ff86fb4af34a6b6793028aa81650424ac3cd57", "filename": "libgomp/oacc-ptx.h", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-ptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Foacc-ptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-ptx.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "04d80886a987af39b654a560f0a27daee7a84431", "filename": "libgomp/openacc.f90", "status": "added", "additions": 956, "deletions": 0, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fopenacc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fopenacc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc.f90?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "334324114f1eacc14de06dad6302408865fd9e45", "filename": "libgomp/openacc.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fopenacc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fopenacc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "28659a1e0b03fe7872a748a13b930ba270931097", "filename": "libgomp/openacc_lib.h", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fopenacc_lib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fopenacc_lib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc_lib.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "167485f52c190c92239bd9935ed8b0f9575cef34", "filename": "libgomp/plugin/Makefrag.am", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fplugin%2FMakefrag.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fplugin%2FMakefrag.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2FMakefrag.am?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "254c68853cb392ac0da4389f54185b3339266b81", "filename": "libgomp/plugin/configfrag.ac", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fplugin%2Fconfigfrag.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fplugin%2Fconfigfrag.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fconfigfrag.ac?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "ebf7f11caf77d54de127ee0458825df2ecd6db7e", "filename": "libgomp/plugin/plugin-host.c", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fplugin%2Fplugin-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fplugin%2Fplugin-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-host.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "483cb7559e83ed62a1731075710bfff6258a256f", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "added", "additions": 1791, "deletions": 0, "changes": 1791, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "030ca8f6c450fc6ac0dbeda746ce29c85fc965e4", "filename": "libgomp/splay-tree.c", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsplay-tree.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "085021cf3d642b6a0987e4d9080b55af149f6ce0", "filename": "libgomp/splay-tree.h", "status": "modified", "additions": 7, "deletions": 173, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fsplay-tree.h?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "83ad51108d0158f7f58f82749957fc05c9428bd6", "filename": "libgomp/target.c", "status": "modified", "additions": 434, "deletions": 200, "changes": 634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "66a9d947e044278ec2ee0b2894c89c1ef51cc991", "filename": "libgomp/testsuite/Makefile.am", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2FMakefile.am?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "352fc3fec7c110f66e8b8207c99cda577fa89987", "filename": "libgomp/testsuite/Makefile.in", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2FMakefile.in?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "5a6eec12352d51f88ea563cce874fb520c7efcc7", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 72, "deletions": 5, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "764bec06c29edc5fd2d932e9dc9ffe5c713d7baf", "filename": "libgomp/testsuite/libgomp-test-support.exp.in", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp-test-support.exp.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp-test-support.exp.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp-test-support.exp.in?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "f486f9b97ba8a91986a0096e638c987dcf38f0b5", "filename": "libgomp/testsuite/libgomp.oacc-c++/c++.exp", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c%2B%2B%2Fc%2B%2B.exp?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "f88b9e3c7f5d339d02270bfe2300cc8081542468", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/abort-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "debb81e78f838baa375f4cbe2b9e04e4f76f5efd", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/abort-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "be7aaa865519eb0c49a8b9209318297e477469d5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/abort-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-3.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "c29ca3fb1182684372b8d4ebca6775b9117fec34", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/abort-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fabort-4.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "81ea47689a9660b86dc1e132098770f1efb4eefd", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_on_device-1.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_on_device-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_on_device-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_on_device-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "22cef6db29ff4bcf40d18bf4471bf2fec1810493", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/asyncwait-1.c", "status": "added", "additions": 466, "deletions": 0, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fasyncwait-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fasyncwait-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fasyncwait-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "3f1f0bb3764d4ddf205edefd26f4088bf91a6a39", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/cache-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcache-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcache-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcache-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "51c0cf58a908d843c1ba612d53322b674c15010d", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/clauses-1.c", "status": "added", "additions": 623, "deletions": 0, "changes": 623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "8dc45cb6287ef13b002625b6a202ce9ffe1cc659", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/clauses-2.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fclauses-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "80fed6ca550bcabb20a8cdc564f82d6b9129e013", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "44a77f7665ddb5f131901b5a62d83bd44d2bfbc1", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "a5be7287d22fe39322179c5c83014586eff2a230", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-3.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-3.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "52dd4353246e3f334f16f0f5e23ab31ac764f167", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/collapse-4.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcollapse-4.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "dabc7063c68b9fc5da33dc70cb311f342cca7443", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/context-1.c", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "6a52f746dcb977a7165176b943ba600156a8d5ad", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/context-2.c", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "ccd276cd98f89554cf6761e9b55c20976d3ef500", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/context-3.c", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-3.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "71365e8ed32e84f7b3887de9d63fe8faa378db0b", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/context-4.c", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fcontext-4.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "e7564cc12b27d576b5382fb31bdc3f13f7cd8c02", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-1.c", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "f867a66e5b7f259135bd721c5860976941deeb40", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-2.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "747109f61363e0a81b939a8544ea636dbdc8a2f3", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-3.c", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-3.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "83c0a42c512a6e4b0561ed1c0f29a4a9bc079f75", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-already-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "137d8ce09da5245635fc13d09fc8e601d6c13f45", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-already-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "b993b78c5ac5906a68bfbcc04483439ae765b15f", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-already-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-3.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "82523f42f1ae813e748da3013bf88fc458ae8fbc", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-already-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-4.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "4961fe544068bef2d92507c4a52ebeadf0a23b81", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-already-5.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-5.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "77b56a93281eb5f0486b7ab9258303198d53a673", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-already-6.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-6.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "b08417bd6ac59c379cbc51684d7b50ad97815cad", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-already-7.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-7.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "a50f7de3a65b2f67691b4dbdb35d761b7e76b190", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/data-already-8.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdata-already-8.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "e271a3770a17efbccf46c895c750faf4d7448ce1", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/deviceptr-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeviceptr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeviceptr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fdeviceptr-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "184b3554bf573f22dd9255d8031e2f3a679b8071", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/if-1.c", "status": "added", "additions": 613, "deletions": 0, "changes": 613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fif-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "3acfdf55ef6f92019f6b5e1ca7caa97487afbdc6", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-1.c", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "a68a7cdb032985a3f069f7c0c35a105b0145a2be", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/kernels-empty.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-empty.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-empty.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fkernels-empty.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "17129d8bebdc256b60fe8538f969ba2a6acff3ef", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-1.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "cf1af8c142fb53cd44a9d19617eaae04c1ff2f18", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-10.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-10.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "eccdb8cbacf057a06e2941181ca6591181064231", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-11.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-11.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "b46f59028b7cba39560e5d12989b26ba24464b7a", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-12.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-12.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "7098ef3549c294b1fddf5fde039b817b4882e31e", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-13.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-13.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "a9632f786ee8389f94cab3a42657bb534426ddf5", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-14.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-14.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "4f6a731be1dc41387aab94be2e59f53d7c0558f4", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-15.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-15.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "9d277ac39f7ba11c7777fb2fb42a45e64be83f49", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-16.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-16.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "5ff894cb33abff78ddf1d76e698182d104136f64", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-17.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-17.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "2bc32637d36b259128044586d89c89c3316478e1", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-18.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-18.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "3581616d754d5089df98d1aafe04b300aab3455c", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-19.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-19.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "9a4501f0e00995df93640699ba06462c2ea3c256", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-2.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "b379a8f7add94323b8ecef0839cd1b04e3f8e576", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-20.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-20.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "3a67400a62015394a88652be55ba2e2d6087e610", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-21.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-21.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "2b86da8058004d65b6fe5640db25890dd15cd2a1", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-22.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-22.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "38f236dcea904f38b1f6d9415e14c11af0f2c6dd", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-23.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-23.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "d7de8e34f4cedfae0a336b4f25ad0f3013207fbf", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-24.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-24.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}, {"sha": "11458283b2cff46bca9fdc21f766074e4a0d1146", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/lib-25.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41dbbb3789850dfea98dd8984f69806284f87b6e/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Flib-25.c?ref=41dbbb3789850dfea98dd8984f69806284f87b6e"}]}