{"sha": "47c84870c65386096ccbc8b2aa5abc0ed3bd7d75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdjODQ4NzBjNjUzODYwOTZjY2JjOGIyYWE1YWJjMGVkM2JkN2Q3NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-04-25T00:23:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-04-25T00:23:10Z"}, "message": "except.c (reachable_handlers): Step out one level from a RESX.\n\n        * except.c (reachable_handlers): Step out one level from a RESX.\n\n        * except.c (struct eh_region): Rename 'last' to 'resume'.\n        (mark_eh_region, duplicate_eh_region_1): Adjust.\n        (expand_eh_region_end_cleanup): Remember the jump, not the barrier.\n        (build_post_landing_pads): Likewise.\n        (expand_end_catch, expand_eh_region_end_allowed): Don't set it.\n        (expand_eh_region_end_must_not_throw): Likewise.\n        (connect_post_landing_pads): Thread (only) regions with non-deleted\n        resume insns.\n\n        * except.c (expand_eh_region_end_cleanup): Save the EH return data\n        registers around the cleanup.\n        (get_exception_filter): New fn.\n        (finish_eh_generation): Use it.\n\nFrom-SVN: r41528", "tree": {"sha": "d82d77b522a5b8ca49b1c63739dd140b9d6f38dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d82d77b522a5b8ca49b1c63739dd140b9d6f38dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47c84870c65386096ccbc8b2aa5abc0ed3bd7d75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c84870c65386096ccbc8b2aa5abc0ed3bd7d75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47c84870c65386096ccbc8b2aa5abc0ed3bd7d75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c84870c65386096ccbc8b2aa5abc0ed3bd7d75/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11fe225ab2dbce69a345f63f4e608ab837a07703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11fe225ab2dbce69a345f63f4e608ab837a07703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11fe225ab2dbce69a345f63f4e608ab837a07703"}], "stats": {"total": 148, "additions": 90, "deletions": 58}, "files": [{"sha": "7177a7d3950e341d6dfbc434fea768c96de1ff0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c84870c65386096ccbc8b2aa5abc0ed3bd7d75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c84870c65386096ccbc8b2aa5abc0ed3bd7d75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47c84870c65386096ccbc8b2aa5abc0ed3bd7d75", "patch": "@@ -1,3 +1,21 @@\n+2001-04-24  Jason Merrill  <jason_merrill@redhat.com>\n+\n+\t* except.c (reachable_handlers): Step out one level from a RESX.\n+\n+\t* except.c (struct eh_region): Rename 'last' to 'resume'.\n+\t(mark_eh_region, duplicate_eh_region_1): Adjust.\n+\t(expand_eh_region_end_cleanup): Remember the jump, not the barrier.\n+\t(build_post_landing_pads): Likewise.\n+\t(expand_end_catch, expand_eh_region_end_allowed): Don't set it.\n+\t(expand_eh_region_end_must_not_throw): Likewise.\n+\t(connect_post_landing_pads): Thread (only) regions with non-deleted\n+\tresume insns.\n+\n+\t* except.c (expand_eh_region_end_cleanup): Save the EH return data\n+\tregisters around the cleanup.\n+\t(get_exception_filter): New fn.\n+\t(finish_eh_generation): Use it.\n+\n 2001-04-24  Nathan Sidwell <nathan@codesourcery.com>\n \n \t* c-semantics.c (add_scope_stmt): Don't call"}, {"sha": "790f2ce4ec50166842076e766017a219723f4c04", "filename": "gcc/except.c", "status": "modified", "additions": 72, "deletions": 58, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c84870c65386096ccbc8b2aa5abc0ed3bd7d75/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c84870c65386096ccbc8b2aa5abc0ed3bd7d75/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=47c84870c65386096ccbc8b2aa5abc0ed3bd7d75", "patch": "@@ -181,14 +181,18 @@ struct eh_region\n     } fixup;\n   } u;\n \n-  /* The region of code generated, or contained within, the region.  */\n-  rtx label, last;\n+  /* Entry point for this region's handler before landing pads are built.  */\n+  rtx label;\n \n-  /* Entry point for this region from the runtime eh library.  */\n+  /* Entry point for this region's handler from the runtime eh library.  */\n   rtx landing_pad;\n \n-  /* Entry point for this region from an inner region.  */\n+  /* Entry point for this region's handler from an inner region.  */\n   rtx post_landing_pad;\n+\n+  /* The RESX insn for handing off control to the next outermost handler,\n+     if appropriate.  */\n+  rtx resume;\n };\n \n /* Used to save exception status for each function.  */\n@@ -251,6 +255,8 @@ static tree lookup_type_for_runtime\t\tPARAMS ((tree));\n \n static struct eh_region *expand_eh_region_end\tPARAMS ((void));\n \n+static rtx get_exception_filter\t\t\tPARAMS ((void));\n+\n static void collect_eh_region_array\t\tPARAMS ((void));\n static void resolve_fixup_regions\t\tPARAMS ((void));\n static void remove_fixup_regions\t\tPARAMS ((void));\n@@ -497,7 +503,7 @@ mark_eh_region (region)\n     }\n \n   ggc_mark_rtx (region->label);\n-  ggc_mark_rtx (region->last);\n+  ggc_mark_rtx (region->resume);\n   ggc_mark_rtx (region->landing_pad);\n   ggc_mark_rtx (region->post_landing_pad);\n }\n@@ -711,6 +717,7 @@ expand_eh_region_end_cleanup (handler)\n {\n   struct eh_region *region;\n   rtx around_label;\n+  rtx data_save[2];\n \n   if (! doing_eh (0))\n     return;\n@@ -728,19 +735,28 @@ expand_eh_region_end_cleanup (handler)\n   if (protect_cleanup_actions)\n     expand_eh_region_start ();\n \n+  /* In case this cleanup involves an inline destructor with a try block in\n+     it, we need to save the EH return data registers around it.  */\n+  data_save[0] = gen_reg_rtx (Pmode);\n+  emit_move_insn (data_save[0], get_exception_pointer ());\n+  data_save[1] = gen_reg_rtx (Pmode);\n+  emit_move_insn (data_save[1], get_exception_filter ());\n+\n   expand_expr (handler, const0_rtx, VOIDmode, 0);\n \n+  emit_move_insn (cfun->eh->exc_ptr, data_save[0]);\n+  emit_move_insn (cfun->eh->filter, data_save[1]);\n+\n   if (protect_cleanup_actions)\n     expand_eh_region_end_must_not_throw (protect_cleanup_actions);\n \n   /* We delay the generation of the _Unwind_Resume until we generate\n      landing pads.  We emit a marker here so as to get good control\n      flow data in the meantime.  */\n-  emit_jump_insn (gen_rtx_RESX (VOIDmode, region->region_number));\n+  region->resume\n+    = emit_jump_insn (gen_rtx_RESX (VOIDmode, region->region_number));\n   emit_barrier ();\n \n-  region->last = get_last_insn ();\n-\n   emit_label (around_label);\n }\n \n@@ -812,8 +828,6 @@ expand_end_catch ()\n   try_region = cfun->eh->try_region;\n \n   emit_jump (try_region->u.try.continue_label);\n-\n-  catch_region->last = get_last_insn ();\n }\n \n /* End a sequence of catch handlers for a try block.  */\n@@ -864,8 +878,6 @@ expand_eh_region_end_allowed (allowed, failure)\n   emit_label (region->label);\n   expand_expr (failure, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  region->last = get_last_insn ();\n-\n   emit_label (around_label);\n }\n \n@@ -901,8 +913,6 @@ expand_eh_region_end_must_not_throw (failure)\n   emit_label (region->label);\n   expand_expr (failure, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  region->last = get_last_insn ();\n-\n   emit_label (around_label);\n }\n \n@@ -948,7 +958,7 @@ expand_eh_region_end_fixup (handler)\n   fixup->u.fixup.cleanup_exp = handler;\n }\n \n-/* Return a tree expression for a pointer to the exception object\n+/* Return an rtl expression for a pointer to the exception object\n    within a handler.  */\n \n rtx\n@@ -963,6 +973,20 @@ get_exception_pointer ()\n   return exc_ptr;\n }\n \n+/* Return an rtl expression for the exception dispatch filter\n+   within a handler.  */\n+\n+static rtx\n+get_exception_filter ()\n+{\n+  rtx filter = cfun->eh->filter;\n+  if (! filter)\n+    {\n+      filter = gen_reg_rtx (Pmode);\n+      cfun->eh->filter = filter;\n+    }\n+  return filter;\n+}\n \f\n /* Begin a region that will contain entries created with\n    add_partial_entry.  */\n@@ -1323,10 +1347,10 @@ duplicate_eh_region_1 (o, map)\n \n   if (o->label)\n     n->label = get_label_from_map (map, CODE_LABEL_NUMBER (o->label));\n-  if (o->last)\n+  if (o->resume)\n     {\n-      n->last = map->insn_map[INSN_UID (o->last)];\n-      if (n->last == NULL)\n+      n->resume = map->insn_map[INSN_UID (o->resume)];\n+      if (n->resume == NULL)\n \tabort ();\n     }\n \n@@ -1719,10 +1743,17 @@ build_post_landing_pads ()\n \t      }\n \t  }\n \n+\t  /* We delay the generation of the _Unwind_Resume until we generate\n+\t     landing pads.  We emit a marker here so as to get good control\n+\t     flow data in the meantime.  */\n+\t  region->resume\n+\t    = emit_jump_insn (gen_rtx_RESX (VOIDmode, region->region_number));\n+\t  emit_barrier ();\n+\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n-\t  region->last = emit_insns_before (seq, region->u.try.catch->label);\n+\t  emit_insns_before (seq, region->u.try.catch->label);\n \t  break;\n \n \tcase ERT_ALLOWED_EXCEPTIONS:\n@@ -1737,10 +1768,17 @@ build_post_landing_pads ()\n \t\t\t\t   EQ, NULL_RTX, word_mode, 0, 0,\n \t\t\t\t   region->label);\n \n+\t  /* We delay the generation of the _Unwind_Resume until we generate\n+\t     landing pads.  We emit a marker here so as to get good control\n+\t     flow data in the meantime.  */\n+\t  region->resume\n+\t    = emit_jump_insn (gen_rtx_RESX (VOIDmode, region->region_number));\n+\t  emit_barrier ();\n+\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n-\t  region->last = emit_insns_before (seq, region->label);\n+\t  emit_insns_before (seq, region->label);\n \t  break;\n \n \tcase ERT_CLEANUP:\n@@ -1759,6 +1797,9 @@ build_post_landing_pads ()\n     }\n }\n \n+/* Replace RESX patterns with jumps to the next handler if any, or calls to\n+   _Unwind_Resume otherwise.  */\n+\n static void\n connect_post_landing_pads ()\n {\n@@ -1768,44 +1809,15 @@ connect_post_landing_pads ()\n     {\n       struct eh_region *region = cfun->eh->region_array[i];\n       struct eh_region *outer;\n-      rtx before = NULL_RTX, after = NULL_RTX, seq;\n+      rtx seq;\n \n       /* Mind we don't process a region more than once.  */\n       if (!region || region->region_number != i)\n \tcontinue;\n \n-      switch (region->type)\n-\t{\n-\tcase ERT_CLEANUP:\n-\t  after = region->last;\n-\t  if (GET_CODE (after) == BARRIER\n-\t      && GET_CODE (PREV_INSN (after)) == JUMP_INSN\n-\t      && GET_CODE (PATTERN (PREV_INSN (after))) == RESX)\n-\t    {\n-\t      before = PREV_INSN (after);\n-\t      after = NULL_RTX;\n-\t    }\n-\t  break;\n-\n-\tcase ERT_TRY:\n-\t  after = region->last;\n-\t  break;\n-\n-\tcase ERT_ALLOWED_EXCEPTIONS:\n-\t  before = region->label;\n-\t  break;\n-\n-\tcase ERT_MUST_NOT_THROW:\n-\tcase ERT_CATCH:\n-\tcase ERT_THROW:\n-\t  continue;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n-      /* If there's no fallthru, no need to add branches.  */\n-      if (after && GET_CODE (after) == BARRIER)\n+      /* If there is no RESX, or it has been deleted by flow, there's\n+\t nothing to fix up.  */\n+      if (! region->resume || INSN_DELETED_P (region->resume))\n \tcontinue;\n \n       /* Search for another landing pad in this function.  */\n@@ -1823,10 +1835,9 @@ connect_post_landing_pads ()\n \n       seq = get_insns ();\n       end_sequence ();\n-      if (before)\n-\temit_insns_before (seq, before);\n-      else\n-        emit_insns_after (seq, after);\n+      emit_insns_before (seq, region->resume);\n+\n+      /* Leave the RESX to be deleted by flow.  */\n     }\n }\n \n@@ -2329,7 +2340,7 @@ finish_eh_generation ()\n   /* These registers are used by the landing pads.  Make sure they\n      have been generated.  */\n   get_exception_pointer ();\n-  cfun->eh->filter = gen_reg_rtx (word_mode);\n+  get_exception_filter ();\n \n   /* Construct the landing pads.  */\n \n@@ -2709,6 +2720,9 @@ reachable_handlers (insn)\n       type_thrown = region->u.throw.type;\n       region = region->outer;\n     }\n+  else if (GET_CODE (insn) == JUMP_INSN\n+\t   && GET_CODE (PATTERN (insn)) == RESX)\n+    region = region->outer;\n \n   for (; region; region = region->outer)\n     if (reachable_next_level (region, type_thrown, &info) >= RNL_CAUGHT)"}]}