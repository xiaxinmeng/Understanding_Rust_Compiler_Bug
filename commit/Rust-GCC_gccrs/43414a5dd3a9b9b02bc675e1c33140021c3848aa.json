{"sha": "43414a5dd3a9b9b02bc675e1c33140021c3848aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM0MTRhNWRkM2E5YjliMDJiYzY3NWUxYzMzMTQwMDIxYzM4NDhhYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-02-18T05:56:46Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-02-18T05:56:46Z"}, "message": "libgo: Update to final Go 1.6 release.\n\n    \n    Reviewed-on: https://go-review.googlesource.com/19592\n\nFrom-SVN: r233515", "tree": {"sha": "66790d16b1ce811193f21d132f271823d10b20f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66790d16b1ce811193f21d132f271823d10b20f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43414a5dd3a9b9b02bc675e1c33140021c3848aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43414a5dd3a9b9b02bc675e1c33140021c3848aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43414a5dd3a9b9b02bc675e1c33140021c3848aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43414a5dd3a9b9b02bc675e1c33140021c3848aa/comments", "author": null, "committer": null, "parents": [{"sha": "fa837fb670c502e7fbcb3f48aa1932b55704521c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa837fb670c502e7fbcb3f48aa1932b55704521c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa837fb670c502e7fbcb3f48aa1932b55704521c"}], "stats": {"total": 1494, "additions": 1341, "deletions": 153}, "files": [{"sha": "038e4346660a0bbc37c912159454f95defb790ae", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -1,4 +1,4 @@\n-22278c6e8ce3982b09111183bc6addf0184bef1f\n+1c3747d20789c73447ff71cbc739f7423c4bdf67\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "3cb26c37c07deaa51b4b97629fb7909397854b22", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -1,4 +1,4 @@\n-036b8fd40b60830ca1d152f17148e52b96d8aa6c\n+7bc40ffb05d8813bf9b41a331b45d37216f9e747\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "0be00434da52a0f8ec972e3ee0a5abf702a117d9", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -1 +1 @@\n-go1.6rc1\n\\ No newline at end of file\n+go1.6\n\\ No newline at end of file"}, {"sha": "10e81728757d3933736b8cc52cff24c0b880f0bb", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -330,7 +330,17 @@ func readDirectoryHeader(f *File, r io.Reader) error {\n \t\t}\n \t}\n \n-\tif needUSize || needCSize || needHeaderOffset {\n+\t// Assume that uncompressed size 2\u00b3\u00b2-1 could plausibly happen in\n+\t// an old zip32 file that was sharding inputs into the largest chunks\n+\t// possible (or is just malicious; search the web for 42.zip).\n+\t// If needUSize is true still, it means we didn't see a zip64 extension.\n+\t// As long as the compressed size is not also 2\u00b3\u00b2-1 (implausible)\n+\t// and the header is not also 2\u00b3\u00b2-1 (equally implausible),\n+\t// accept the uncompressed size 2\u00b3\u00b2-1 as valid.\n+\t// If nothing else, this keeps archive/zip working with 42.zip.\n+\t_ = needUSize\n+\n+\tif needCSize || needHeaderOffset {\n \t\treturn ErrFormat\n \t}\n "}, {"sha": "72cf5d9cf42f09fc89c8a567cc9c5803603ba5b5", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 225, "deletions": 10, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -27,12 +27,24 @@ type ZipTest struct {\n }\n \n type ZipTestFile struct {\n-\tName       string\n-\tContent    []byte // if blank, will attempt to compare against File\n+\tName  string\n+\tMode  os.FileMode\n+\tMtime string // optional, modified time in format \"mm-dd-yy hh:mm:ss\"\n+\n+\t// Information describing expected zip file content.\n+\t// First, reading the entire content should produce the error ContentErr.\n+\t// Second, if ContentErr==nil, the content should match Content.\n+\t// If content is large, an alternative to setting Content is to set File,\n+\t// which names a file in the testdata/ directory containing the\n+\t// uncompressed expected content.\n+\t// If content is very large, an alternative to setting Content or File\n+\t// is to set Size, which will then be checked against the header-reported size\n+\t// but will bypass the decompressing of the actual data.\n+\t// This last option is used for testing very large (multi-GB) compressed files.\n \tContentErr error\n-\tFile       string // name of file to compare to (relative to testdata/)\n-\tMtime      string // modified time in format \"mm-dd-yy hh:mm:ss\"\n-\tMode       os.FileMode\n+\tContent    []byte\n+\tFile       string\n+\tSize       uint64\n }\n \n // Caution: The Mtime values found for the test files should correspond to\n@@ -248,6 +260,19 @@ var tests = []ZipTest{\n \t\t\t},\n \t\t},\n \t},\n+\t// Largest possible non-zip64 file, with no zip64 header.\n+\t{\n+\t\tName:   \"big.zip\",\n+\t\tSource: returnBigZipBytes,\n+\t\tFile: []ZipTestFile{\n+\t\t\t{\n+\t\t\t\tName:    \"big.file\",\n+\t\t\t\tContent: nil,\n+\t\t\t\tSize:    1<<32 - 1,\n+\t\t\t\tMode:    0666,\n+\t\t\t},\n+\t\t},\n+\t},\n }\n \n var crossPlatform = []ZipTestFile{\n@@ -356,13 +381,31 @@ func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \n \ttestFileMode(t, zt.Name, f, ft.Mode)\n \n-\tvar b bytes.Buffer\n+\tsize := uint64(f.UncompressedSize)\n+\tif size == uint32max {\n+\t\tsize = f.UncompressedSize64\n+\t} else if size != f.UncompressedSize64 {\n+\t\tt.Errorf(\"%v: UncompressedSize=%#x does not match UncompressedSize64=%#x\", f.Name, size, f.UncompressedSize64)\n+\t}\n+\n \tr, err := f.Open()\n \tif err != nil {\n \t\tt.Errorf(\"%s: %v\", zt.Name, err)\n \t\treturn\n \t}\n \n+\t// For very large files, just check that the size is correct.\n+\t// The content is expected to be all zeros.\n+\t// Don't bother uncompressing: too big.\n+\tif ft.Content == nil && ft.File == \"\" && ft.Size > 0 {\n+\t\tif size != ft.Size {\n+\t\t\tt.Errorf(\"%v: uncompressed size %#x, want %#x\", size, ft.Size)\n+\t\t}\n+\t\tr.Close()\n+\t\treturn\n+\t}\n+\n+\tvar b bytes.Buffer\n \t_, err = io.Copy(&b, r)\n \tif err != ft.ContentErr {\n \t\tt.Errorf(\"%s: copying contents: %v (want %v)\", zt.Name, err, ft.ContentErr)\n@@ -372,10 +415,6 @@ func readTestFile(t *testing.T, zt ZipTest, ft ZipTestFile, f *File) {\n \t}\n \tr.Close()\n \n-\tsize := uint64(f.UncompressedSize)\n-\tif size == uint32max {\n-\t\tsize = f.UncompressedSize64\n-\t}\n \tif g := uint64(b.Len()); g != size {\n \t\tt.Errorf(\"%v: read %v bytes but f.UncompressedSize == %v\", f.Name, g, size)\n \t}\n@@ -510,6 +549,182 @@ func returnRecursiveZip() (r io.ReaderAt, size int64) {\n \treturn bytes.NewReader(b), int64(len(b))\n }\n \n+// biggestZipBytes returns the bytes of a zip file biggest.zip\n+// that contains a zip file bigger.zip that contains a zip file\n+// big.zip that contains big.file, which contains 2\u00b3\u00b2-1 zeros.\n+// The big.zip file is interesting because it has no zip64 header,\n+// much like the innermost zip files in the well-known 42.zip.\n+//\n+// biggest.zip was generated by changing isZip64 to use > uint32max\n+// instead of >= uint32max and then running this program:\n+//\n+//\tpackage main\n+//\n+//\timport (\n+//\t\t\"archive/zip\"\n+//\t\t\"bytes\"\n+//\t\t\"io\"\n+//\t\t\"io/ioutil\"\n+//\t\t\"log\"\n+//\t)\n+//\n+//\ttype zeros struct{}\n+//\n+//\tfunc (zeros) Read(b []byte) (int, error) {\n+//\t\tfor i := range b {\n+//\t\t\tb[i] = 0\n+//\t\t}\n+//\t\treturn len(b), nil\n+//\t}\n+//\n+//\tfunc main() {\n+//\t\tbigZip := makeZip(\"big.file\", io.LimitReader(zeros{}, 1<<32-1))\n+//\t\tif err := ioutil.WriteFile(\"/tmp/big.zip\", bigZip, 0666); err != nil {\n+//\t\t\tlog.Fatal(err)\n+//\t\t}\n+//\n+//\t\tbiggerZip := makeZip(\"big.zip\", bytes.NewReader(bigZip))\n+//\t\tif err := ioutil.WriteFile(\"/tmp/bigger.zip\", biggerZip, 0666); err != nil {\n+//\t\t\tlog.Fatal(err)\n+//\t\t}\n+//\n+//\t\tbiggestZip := makeZip(\"bigger.zip\", bytes.NewReader(biggerZip))\n+//\t\tif err := ioutil.WriteFile(\"/tmp/biggest.zip\", biggestZip, 0666); err != nil {\n+//\t\t\tlog.Fatal(err)\n+//\t\t}\n+//\t}\n+//\n+//\tfunc makeZip(name string, r io.Reader) []byte {\n+//\t\tvar buf bytes.Buffer\n+//\t\tw := zip.NewWriter(&buf)\n+//\t\twf, err := w.Create(name)\n+//\t\tif err != nil {\n+//\t\t\tlog.Fatal(err)\n+//\t\t}\n+//\t\tif _, err = io.Copy(wf, r); err != nil {\n+//\t\t\tlog.Fatal(err)\n+//\t\t}\n+//\t\tif err := w.Close(); err != nil {\n+//\t\t\tlog.Fatal(err)\n+//\t\t}\n+//\t\treturn buf.Bytes()\n+//\t}\n+//\n+// The 4 GB of zeros compresses to 4 MB, which compresses to 20 kB,\n+// which compresses to 1252 bytes (in the hex dump below).\n+//\n+// It's here in hex for the same reason as rZipBytes above: to avoid\n+// problems with on-disk virus scanners or other zip processors.\n+//\n+func biggestZipBytes() []byte {\n+\ts := `\n+0000000 50 4b 03 04 14 00 08 00 08 00 00 00 00 00 00 00\n+0000010 00 00 00 00 00 00 00 00 00 00 0a 00 00 00 62 69\n+0000020 67 67 65 72 2e 7a 69 70 ec dc 6b 4c 53 67 18 07\n+0000030 f0 16 c5 ca 65 2e cb b8 94 20 61 1f 44 33 c7 cd\n+0000040 c0 86 4a b5 c0 62 8a 61 05 c6 cd 91 b2 54 8c 1b\n+0000050 63 8b 03 9c 1b 95 52 5a e3 a0 19 6c b2 05 59 44\n+0000060 64 9d 73 83 71 11 46 61 14 b9 1d 14 09 4a c3 60\n+0000070 2e 4c 6e a5 60 45 02 62 81 95 b6 94 9e 9e 77 e7\n+0000080 d0 43 b6 f8 71 df 96 3c e7 a4 69 ce bf cf e9 79\n+0000090 ce ef 79 3f bf f1 31 db b6 bb 31 76 92 e7 f3 07\n+00000a0 8b fc 9c ca cc 08 cc cb cc 5e d2 1c 88 d9 7e bb\n+00000b0 4f bb 3a 3f 75 f1 5d 7f 8f c2 68 67 77 8f 25 ff\n+00000c0 84 e2 93 2d ef a4 95 3d 71 4e 2c b9 b0 87 c3 be\n+00000d0 3d f8 a7 60 24 61 c5 ef ae 9e c8 6c 6d 4e 69 c8\n+00000e0 67 65 34 f8 37 76 2d 76 5c 54 f3 95 65 49 c7 0f\n+00000f0 18 71 4b 7e 5b 6a d1 79 47 61 41 b0 4e 2a 74 45\n+0000100 43 58 12 b2 5a a5 c6 7d 68 55 88 d4 98 75 18 6d\n+0000110 08 d1 1f 8f 5a 9e 96 ee 45 cf a4 84 4e 4b e8 50\n+0000120 a7 13 d9 06 de 52 81 97 36 b2 d7 b8 fc 2b 5f 55\n+0000130 23 1f 32 59 cf 30 27 fb e2 8a b9 de 45 dd 63 9c\n+0000140 4b b5 8b 96 4c 7a 62 62 cc a1 a7 cf fa f1 fe dd\n+0000150 54 62 11 bf 36 78 b3 c7 b1 b5 f2 61 4d 4e dd 66\n+0000160 32 2e e6 70 34 5f f4 c9 e6 6c 43 6f da 6b c6 c3\n+0000170 09 2c ce 09 57 7f d2 7e b4 23 ba 7c 1b 99 bc 22\n+0000180 3e f1 de 91 2f e3 9c 1b 82 cc c2 84 39 aa e6 de\n+0000190 b4 69 fc cc cb 72 a6 61 45 f0 d3 1d 26 19 7c 8d\n+00001a0 29 c8 66 02 be 77 6a f9 3d 34 79 17 19 c8 96 24\n+00001b0 a3 ac e4 dd 3b 1a 8e c6 fe 96 38 6b bf 67 5a 23\n+00001c0 f4 16 f4 e6 8a b4 fc c2 cd bf 95 66 1d bb 35 aa\n+00001d0 92 7d 66 d8 08 8d a5 1f 54 2a af 09 cf 61 ff d2\n+00001e0 85 9d 8f b6 d7 88 07 4a 86 03 db 64 f3 d9 92 73\n+00001f0 df ec a7 fc 23 4c 8d 83 79 63 2a d9 fd 8d b3 c8\n+0000200 8f 7e d4 19 85 e6 8d 1c 76 f0 8b 58 32 fd 9a d6\n+0000210 85 e2 48 ad c3 d5 60 6f 7e 22 dd ef 09 49 7c 7f\n+0000220 3a 45 c3 71 b7 df f3 4c 63 fb b5 d9 31 5f 6e d6\n+0000230 24 1d a4 4a fe 32 a7 5c 16 48 5c 3e 08 6b 8a d3\n+0000240 25 1d a2 12 a5 59 24 ea 20 5f 52 6d ad 94 db 6b\n+0000250 94 b9 5d eb 4b a7 5c 44 bb 1e f2 3c 6b cf 52 c9\n+0000260 e9 e5 ba 06 b9 c4 e5 0a d0 00 0d d0 00 0d d0 00\n+0000270 0d d0 00 0d d0 00 0d d0 00 0d d0 00 0d d0 00 0d\n+0000280 d0 00 0d d0 00 0d d0 00 0d d0 00 0d d0 00 0d d0\n+0000290 00 0d d0 00 0d d0 00 0d d0 00 0d d0 00 0d d0 00\n+00002a0 0d d0 00 cd ff 9e 46 86 fa a7 7d 3a 43 d7 8e 10\n+00002b0 52 e9 be e6 6e cf eb 9e 85 4d 65 ce cc 30 c1 44\n+00002c0 c0 4e af bc 9c 6c 4b a0 d7 54 ff 1d d5 5c 89 fb\n+00002d0 b5 34 7e c4 c2 9e f5 a0 f6 5b 7e 6e ca 73 c7 ef\n+00002e0 5d be de f9 e8 81 eb a5 0a a5 63 54 2c d7 1c d1\n+00002f0 89 17 85 f8 16 94 f2 8a b2 a3 f5 b6 6d df 75 cd\n+0000300 90 dd 64 bd 5d 55 4e f2 55 19 1b b7 cc ef 1b ea\n+0000310 2e 05 9c f4 aa 1e a8 cd a6 82 c7 59 0f 5e 9d e0\n+0000320 bb fc 6c d6 99 23 eb 36 ad c6 c5 e1 d8 e1 e2 3e\n+0000330 d9 90 5a f7 91 5d 6f bc 33 6d 98 47 d2 7c 2e 2f\n+0000340 99 a4 25 72 85 49 2c be 0b 5b af 8f e5 6e 81 a6\n+0000350 a3 5a 6f 39 53 3a ab 7a 8b 1e 26 f7 46 6c 7d 26\n+0000360 53 b3 22 31 94 d3 83 f2 18 4d f5 92 33 27 53 97\n+0000370 0f d3 e6 55 9c a6 c5 31 87 6f d3 f3 ae 39 6f 56\n+0000380 10 7b ab 7e d0 b4 ca f2 b8 05 be 3f 0e 6e 5a 75\n+0000390 ab 0c f5 37 0e ba 8e 75 71 7a aa ed 7a dd 6a 63\n+00003a0 be 9b a0 97 27 6a 6f e7 d3 8b c4 7c ec d3 91 56\n+00003b0 d9 ac 5e bf 16 42 2f 00 1f 93 a2 23 87 bd e2 59\n+00003c0 a0 de 1a 66 c8 62 eb 55 8f 91 17 b4 61 42 7a 50\n+00003d0 40 03 34 40 03 34 40 03 34 40 03 34 40 03 34 40\n+00003e0 03 34 40 03 34 40 03 34 40 03 34 40 03 34 40 03\n+00003f0 34 40 03 34 40 03 34 ff 85 86 90 8b ea 67 90 0d\n+0000400 e1 42 1b d2 61 d6 79 ec fd 3e 44 28 a4 51 6c 5c\n+0000410 fc d2 72 ca ba 82 18 46 16 61 cd 93 a9 0f d1 24\n+0000420 17 99 e2 2c 71 16 84 0c c8 7a 13 0f 9a 5e c5 f0\n+0000430 79 64 e2 12 4d c8 82 a1 81 19 2d aa 44 6d 87 54\n+0000440 84 71 c1 f6 d4 ca 25 8c 77 b9 08 c7 c8 5e 10 8a\n+0000450 8f 61 ed 8c ba 30 1f 79 9a c7 60 34 2b b9 8c f8\n+0000460 18 a6 83 1b e3 9f ad 79 fe fd 1b 8b f1 fc 41 6f\n+0000470 d4 13 1f e3 b8 83 ba 64 92 e7 eb e4 77 05 8f ba\n+0000480 fa 3b 00 00 ff ff 50 4b 07 08 a6 18 b1 91 5e 04\n+0000490 00 00 e4 47 00 00 50 4b 01 02 14 00 14 00 08 00\n+00004a0 08 00 00 00 00 00 a6 18 b1 91 5e 04 00 00 e4 47\n+00004b0 00 00 0a 00 00 00 00 00 00 00 00 00 00 00 00 00\n+00004c0 00 00 00 00 62 69 67 67 65 72 2e 7a 69 70 50 4b\n+00004d0 05 06 00 00 00 00 01 00 01 00 38 00 00 00 96 04\n+00004e0 00 00 00 00`\n+\ts = regexp.MustCompile(`[0-9a-f]{7}`).ReplaceAllString(s, \"\")\n+\ts = regexp.MustCompile(`\\s+`).ReplaceAllString(s, \"\")\n+\tb, err := hex.DecodeString(s)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn b\n+}\n+\n+func returnBigZipBytes() (r io.ReaderAt, size int64) {\n+\tb := biggestZipBytes()\n+\tfor i := 0; i < 2; i++ {\n+\t\tr, err := NewReader(bytes.NewReader(b), int64(len(b)))\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\tf, err := r.File[0].Open()\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t\tb, err = ioutil.ReadAll(f)\n+\t\tif err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\treturn bytes.NewReader(b), int64(len(b))\n+}\n+\n func TestIssue8186(t *testing.T) {\n \t// Directory headers & data found in the TOC of a JAR file.\n \tdirEnts := []string{"}, {"sha": "c81bd40864a3c74bc36a8f40f00893bc9dd9b74b", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -93,7 +93,8 @@ and test commands:\n \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n \t-msan\n \t\tenable interoperation with memory sanitizer.\n-\t\tSupported only on linux/amd64.\n+\t\tSupported only on linux/amd64,\n+\t\tand only with Clang/LLVM as the host C compiler.\n \t-v\n \t\tprint the names of packages as they are compiled.\n \t-work"}, {"sha": "4382cf72ed7f3346e9ab7db189410f5d76eabd17", "filename": "libgo/go/cmd/go/build.go", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -72,7 +72,8 @@ and test commands:\n \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n \t-msan\n \t\tenable interoperation with memory sanitizer.\n-\t\tSupported only on linux/amd64.\n+\t\tSupported only on linux/amd64,\n+\t\tand only with Clang/LLVM as the host C compiler.\n \t-v\n \t\tprint the names of packages as they are compiled.\n \t-work\n@@ -674,6 +675,7 @@ var (\n \tgoarch    string\n \tgoos      string\n \texeSuffix string\n+\tgopath    []string\n )\n \n func init() {\n@@ -682,6 +684,7 @@ func init() {\n \tif goos == \"windows\" {\n \t\texeSuffix = \".exe\"\n \t}\n+\tgopath = filepath.SplitList(buildContext.GOPATH)\n }\n \n // A builder holds global state about a build.\n@@ -1694,6 +1697,22 @@ func (b *builder) includeArgs(flag string, all []*action) []string {\n \tinc = append(inc, flag, b.work)\n \n \t// Finally, look in the installed package directories for each action.\n+\t// First add the package dirs corresponding to GOPATH entries\n+\t// in the original GOPATH order.\n+\tneed := map[string]*build.Package{}\n+\tfor _, a1 := range all {\n+\t\tif a1.p != nil && a1.pkgdir == a1.p.build.PkgRoot {\n+\t\t\tneed[a1.p.build.Root] = a1.p.build\n+\t\t}\n+\t}\n+\tfor _, root := range gopath {\n+\t\tif p := need[root]; p != nil && !incMap[p.PkgRoot] {\n+\t\t\tincMap[p.PkgRoot] = true\n+\t\t\tinc = append(inc, flag, p.PkgTargetRoot)\n+\t\t}\n+\t}\n+\n+\t// Then add anything that's left.\n \tfor _, a1 := range all {\n \t\tif a1.p == nil {\n \t\t\tcontinue"}, {"sha": "39e0f3e56d58b25a6dc4365bf41650fb47e4a70d", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 210, "deletions": 9, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"go/build\"\n \t\"go/format\"\n+\t\"internal/race\"\n \t\"internal/testenv\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -69,7 +70,11 @@ func TestMain(m *testing.M) {\n \tflag.Parse()\n \n \tif canRun {\n-\t\tout, err := exec.Command(\"go\", \"build\", \"-tags\", \"testgo\", \"-o\", \"testgo\"+exeSuffix).CombinedOutput()\n+\t\targs := []string{\"build\", \"-tags\", \"testgo\", \"-o\", \"testgo\" + exeSuffix}\n+\t\tif race.Enabled {\n+\t\t\targs = append(args, \"-race\")\n+\t\t}\n+\t\tout, err := exec.Command(\"go\", args...).CombinedOutput()\n \t\tif err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"building testgo failed: %v\\n%s\", err, out)\n \t\t\tos.Exit(2)\n@@ -657,6 +662,9 @@ func TestGoBuildDashAInDevBranch(t *testing.T) {\n \ttg.setenv(\"TESTGO_IS_GO_RELEASE\", \"0\")\n \ttg.run(\"build\", \"-v\", \"-a\", \"math\")\n \ttg.grepStderr(\"runtime\", \"testgo build -a math in dev branch DID NOT build runtime, but should have\")\n+\n+\t// Everything is out of date. Rebuild to leave things in a better state.\n+\ttg.run(\"install\", \"std\")\n }\n \n func TestGoBuildDashAInReleaseBranch(t *testing.T) {\n@@ -672,11 +680,80 @@ func TestGoBuildDashAInReleaseBranch(t *testing.T) {\n \ttg.grepStderr(\"runtime\", \"testgo build -a math in release branch DID NOT build runtime, but should have\")\n \n \t// Now runtime.a is updated (newer mtime), so everything would look stale if not for being a release.\n-\t//\n \ttg.run(\"build\", \"-v\", \"net/http\")\n \ttg.grepStderrNot(\"strconv\", \"testgo build -v net/http in release branch with newer runtime.a DID build strconv but should not have\")\n \ttg.grepStderrNot(\"golang.org/x/net/http2/hpack\", \"testgo build -v net/http in release branch with newer runtime.a DID build .../golang.org/x/net/http2/hpack but should not have\")\n \ttg.grepStderrNot(\"net/http\", \"testgo build -v net/http in release branch with newer runtime.a DID build net/http but should not have\")\n+\n+\t// Everything is out of date. Rebuild to leave things in a better state.\n+\ttg.run(\"install\", \"std\")\n+}\n+\n+func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"don't rebuild the standard library in short mode\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\taddNL := func(name string) (restore func()) {\n+\t\tdata, err := ioutil.ReadFile(name)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\told := data\n+\t\tdata = append(data, '\\n')\n+\t\tif err := ioutil.WriteFile(name, append(data, '\\n'), 0666); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\ttg.sleep()\n+\t\treturn func() {\n+\t\t\tif err := ioutil.WriteFile(name, old, 0666); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\ttg.setenv(\"TESTGO_IS_GO_RELEASE\", \"1\")\n+\n+\ttg.tempFile(\"d1/src/p1/p1.go\", `package p1`)\n+\ttg.setenv(\"GOPATH\", tg.path(\"d1\"))\n+\ttg.run(\"install\", \"-a\", \"p1\")\n+\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale, incorrectly\")\n+\ttg.sleep()\n+\n+\t// Changing mtime and content of runtime/internal/sys/sys.go\n+\t// should have no effect: we're in a release, which doesn't rebuild\n+\t// for general mtime or content changes.\n+\tsys := runtime.GOROOT() + \"/src/runtime/internal/sys/sys.go\"\n+\trestore := addNL(sys)\n+\tdefer restore()\n+\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale, incorrectly, after updating runtime/internal/sys/sys.go\")\n+\trestore()\n+\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale, incorrectly, after restoring runtime/internal/sys/sys.go\")\n+\n+\t// But changing runtime/internal/sys/zversion.go should have an effect:\n+\t// that's how we tell when we flip from one release to another.\n+\tzversion := runtime.GOROOT() + \"/src/runtime/internal/sys/zversion.go\"\n+\trestore = addNL(zversion)\n+\tdefer restore()\n+\ttg.wantStale(\"p1\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing to new release\")\n+\trestore()\n+\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale, incorrectly, after changing back to old release\")\n+\taddNL(zversion)\n+\ttg.wantStale(\"p1\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing again to new release\")\n+\ttg.run(\"install\", \"p1\")\n+\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale after building with new release\")\n+\n+\t// Restore to \"old\" release.\n+\trestore()\n+\ttg.wantStale(\"p1\", \"./testgo list claims p1 is NOT stale, incorrectly, after changing to old release after new build\")\n+\ttg.run(\"install\", \"p1\")\n+\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale after building with old release\")\n+\n+\t// Everything is out of date. Rebuild to leave things in a better state.\n+\ttg.run(\"install\", \"std\")\n }\n \n func TestGoListStandard(t *testing.T) {\n@@ -756,8 +833,8 @@ func TestGoInstallRebuildsStalePackagesInOtherGOPATH(t *testing.T) {\n \tsep := string(filepath.ListSeparator)\n \ttg.setenv(\"GOPATH\", tg.path(\"d1\")+sep+tg.path(\"d2\"))\n \ttg.run(\"install\", \"p1\")\n-\ttg.wantNotStale(\"p1\", \"./testgo list mypkg claims p1 is stale, incorrectly\")\n-\ttg.wantNotStale(\"p2\", \"./testgo list mypkg claims p2 is stale, incorrectly\")\n+\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale, incorrectly\")\n+\ttg.wantNotStale(\"p2\", \"./testgo list claims p2 is stale, incorrectly\")\n \ttg.sleep()\n \tif f, err := os.OpenFile(tg.path(\"d2/src/p2/p2.go\"), os.O_WRONLY|os.O_APPEND, 0); err != nil {\n \t\tt.Fatal(err)\n@@ -766,12 +843,12 @@ func TestGoInstallRebuildsStalePackagesInOtherGOPATH(t *testing.T) {\n \t} else {\n \t\ttg.must(f.Close())\n \t}\n-\ttg.wantStale(\"p2\", \"./testgo list mypkg claims p2 is NOT stale, incorrectly\")\n-\ttg.wantStale(\"p1\", \"./testgo list mypkg claims p1 is NOT stale, incorrectly\")\n+\ttg.wantStale(\"p2\", \"./testgo list claims p2 is NOT stale, incorrectly\")\n+\ttg.wantStale(\"p1\", \"./testgo list claims p1 is NOT stale, incorrectly\")\n \n \ttg.run(\"install\", \"p1\")\n-\ttg.wantNotStale(\"p2\", \"./testgo list mypkg claims p2 is stale after reinstall, incorrectly\")\n-\ttg.wantNotStale(\"p1\", \"./testgo list mypkg claims p1 is stale after reinstall, incorrectly\")\n+\ttg.wantNotStale(\"p2\", \"./testgo list claims p2 is stale after reinstall, incorrectly\")\n+\ttg.wantNotStale(\"p1\", \"./testgo list claims p1 is stale after reinstall, incorrectly\")\n }\n \n func TestGoInstallDetectsRemovedFiles(t *testing.T) {\n@@ -1621,7 +1698,7 @@ func TestGoTestDashOWritesBinary(t *testing.T) {\n }\n \n // Issue 4568.\n-func TestSymlinksDoNotConfuseGoList(t *testing.T) {\n+func TestSymlinksList(t *testing.T) {\n \tswitch runtime.GOOS {\n \tcase \"plan9\", \"windows\":\n \t\tt.Skipf(\"skipping symlink test on %s\", runtime.GOOS)\n@@ -1640,6 +1717,58 @@ func TestSymlinksDoNotConfuseGoList(t *testing.T) {\n \t}\n }\n \n+// Issue 14054.\n+func TestSymlinksVendor(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Skipf(\"skipping symlink test on %s\", runtime.GOOS)\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GO15VENDOREXPERIMENT\", \"1\")\n+\ttg.tempDir(\"gopath/src/dir1/vendor/v\")\n+\ttg.tempFile(\"gopath/src/dir1/p.go\", \"package main\\nimport _ `v`\\nfunc main(){}\")\n+\ttg.tempFile(\"gopath/src/dir1/vendor/v/v.go\", \"package v\")\n+\ttg.must(os.Symlink(tg.path(\"gopath/src/dir1\"), tg.path(\"symdir1\")))\n+\ttg.setenv(\"GOPATH\", tg.path(\"gopath\"))\n+\ttg.cd(tg.path(\"symdir1\"))\n+\ttg.run(\"list\", \"-f\", \"{{.Root}}\", \".\")\n+\tif strings.TrimSpace(tg.getStdout()) != tg.path(\"gopath\") {\n+\t\tt.Error(\"list confused by symlinks\")\n+\t}\n+\n+\t// All of these should succeed, not die in vendor-handling code.\n+\ttg.run(\"run\", \"p.go\")\n+\ttg.run(\"build\")\n+\ttg.run(\"install\")\n+}\n+\n+func TestSymlinksInternal(t *testing.T) {\n+\tswitch runtime.GOOS {\n+\tcase \"plan9\", \"windows\":\n+\t\tt.Skipf(\"skipping symlink test on %s\", runtime.GOOS)\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.tempDir(\"gopath/src/dir1/internal/v\")\n+\ttg.tempFile(\"gopath/src/dir1/p.go\", \"package main\\nimport _ `dir1/internal/v`\\nfunc main(){}\")\n+\ttg.tempFile(\"gopath/src/dir1/internal/v/v.go\", \"package v\")\n+\ttg.must(os.Symlink(tg.path(\"gopath/src/dir1\"), tg.path(\"symdir1\")))\n+\ttg.setenv(\"GOPATH\", tg.path(\"gopath\"))\n+\ttg.cd(tg.path(\"symdir1\"))\n+\ttg.run(\"list\", \"-f\", \"{{.Root}}\", \".\")\n+\tif strings.TrimSpace(tg.getStdout()) != tg.path(\"gopath\") {\n+\t\tt.Error(\"list confused by symlinks\")\n+\t}\n+\n+\t// All of these should succeed, not die in internal-handling code.\n+\ttg.run(\"run\", \"p.go\")\n+\ttg.run(\"build\")\n+\ttg.run(\"install\")\n+}\n+\n // Issue 4515.\n func TestInstallWithTags(t *testing.T) {\n \ttg := testgo(t)\n@@ -2441,6 +2570,59 @@ func TestGoInstallShadowedGOPATH(t *testing.T) {\n \ttg.grepStderr(\"no install location for.*gopath2.src.test: hidden by .*gopath1.src.test\", \"missing error\")\n }\n \n+func TestGoBuildGOPATHOrder(t *testing.T) {\n+\t// golang.org/issue/14176#issuecomment-179895769\n+\t// golang.org/issue/14192\n+\t// -I arguments to compiler could end up not in GOPATH order,\n+\t// leading to unexpected import resolution in the compiler.\n+\t// This is still not a complete fix (see golang.org/issue/14271 and next test)\n+\t// but it is clearly OK and enough to fix both of the two reported\n+\t// instances of the underlying problem. It will have to do for now.\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\"p1\")+string(filepath.ListSeparator)+tg.path(\"p2\"))\n+\n+\ttg.tempFile(\"p1/src/foo/foo.go\", \"package foo\\n\")\n+\ttg.tempFile(\"p2/src/baz/baz.go\", \"package baz\\n\")\n+\ttg.tempFile(\"p2/pkg/\"+runtime.GOOS+\"_\"+runtime.GOARCH+\"/foo.a\", \"bad\\n\")\n+\ttg.tempFile(\"p1/src/bar/bar.go\", `\n+\t\tpackage bar\n+\t\timport _ \"baz\"\n+\t\timport _ \"foo\"\n+\t`)\n+\n+\ttg.run(\"install\", \"-x\", \"bar\")\n+}\n+\n+func TestGoBuildGOPATHOrderBroken(t *testing.T) {\n+\t// This test is known not to work.\n+\t// See golang.org/issue/14271.\n+\tt.Skip(\"golang.org/issue/14271\")\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\n+\ttg.tempFile(\"p1/src/foo/foo.go\", \"package foo\\n\")\n+\ttg.tempFile(\"p2/src/baz/baz.go\", \"package baz\\n\")\n+\ttg.tempFile(\"p1/pkg/\"+runtime.GOOS+\"_\"+runtime.GOARCH+\"/baz.a\", \"bad\\n\")\n+\ttg.tempFile(\"p2/pkg/\"+runtime.GOOS+\"_\"+runtime.GOARCH+\"/foo.a\", \"bad\\n\")\n+\ttg.tempFile(\"p1/src/bar/bar.go\", `\n+\t\tpackage bar\n+\t\timport _ \"baz\"\n+\t\timport _ \"foo\"\n+\t`)\n+\n+\tcolon := string(filepath.ListSeparator)\n+\ttg.setenv(\"GOPATH\", tg.path(\"p1\")+colon+tg.path(\"p2\"))\n+\ttg.run(\"install\", \"-x\", \"bar\")\n+\n+\ttg.setenv(\"GOPATH\", tg.path(\"p2\")+colon+tg.path(\"p1\"))\n+\ttg.run(\"install\", \"-x\", \"bar\")\n+}\n+\n func TestIssue11709(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2558,3 +2740,22 @@ func TestIssue13655(t *testing.T) {\n \t\ttg.grepStdout(\"runtime/internal/sys\", \"did not find required dependency of \"+pkg+\" on runtime/internal/sys\")\n \t}\n }\n+\n+// For issue 14337.\n+func TestParallelTest(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\tconst testSrc = `package package_test\n+\t\timport (\n+\t\t\t\"testing\"\n+\t\t)\n+\t\tfunc TestTest(t *testing.T) {\n+\t\t}`\n+\ttg.tempFile(\"src/p1/p1_test.go\", strings.Replace(testSrc, \"package_test\", \"p1_test\", 1))\n+\ttg.tempFile(\"src/p2/p2_test.go\", strings.Replace(testSrc, \"package_test\", \"p2_test\", 1))\n+\ttg.tempFile(\"src/p3/p3_test.go\", strings.Replace(testSrc, \"package_test\", \"p3_test\", 1))\n+\ttg.tempFile(\"src/p4/p4_test.go\", strings.Replace(testSrc, \"package_test\", \"p4_test\", 1))\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"test\", \"-p=4\", \"p1\", \"p2\", \"p3\", \"p4\")\n+}"}, {"sha": "f9b979da7fba69a500a6db8d5c836c156485dcee", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -454,7 +454,9 @@ func envForDir(dir string, base []string) []string {\n \n // mergeEnvLists merges the two environment lists such that\n // variables with the same name in \"in\" replace those in \"out\".\n+// This always returns a newly allocated slice.\n func mergeEnvLists(in, out []string) []string {\n+\tout = append([]string(nil), out...)\n NextVar:\n \tfor _, inkv := range in {\n \t\tk := strings.SplitAfterN(inkv, \"=\", 2)[0]\n@@ -524,6 +526,15 @@ func hasFilePathPrefix(s, prefix string) bool {\n \t}\n }\n \n+// expandPath returns the symlink-expanded form of path.\n+func expandPath(p string) string {\n+\tx, err := filepath.EvalSymlinks(p)\n+\tif err == nil {\n+\t\treturn x\n+\t}\n+\treturn p\n+}\n+\n // treeCanMatchPattern(pattern)(name) reports whether\n // name or children of name can possibly match pattern.\n // Pattern is the same limited glob accepted by matchPattern."}, {"sha": "373dade962a981e6699bcfa7213721e3cf8b3255", "filename": "libgo/go/cmd/go/pkg.go", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -419,11 +419,18 @@ func vendoredImportPath(parent *Package, path string) (found string) {\n \tif parent == nil || parent.Root == \"\" || !go15VendorExperiment {\n \t\treturn path\n \t}\n+\n \tdir := filepath.Clean(parent.Dir)\n \troot := filepath.Join(parent.Root, \"src\")\n+\tif !hasFilePathPrefix(dir, root) {\n+\t\t// Look for symlinks before reporting error.\n+\t\tdir = expandPath(dir)\n+\t\troot = expandPath(root)\n+\t}\n \tif !hasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator {\n \t\tfatalf(\"invalid vendoredImportPath: dir=%q root=%q separator=%q\", dir, root, string(filepath.Separator))\n \t}\n+\n \tvpath := \"vendor/\" + path\n \tfor i := len(dir); i >= len(root); i-- {\n \t\tif i < len(dir) && dir[i] != filepath.Separator {\n@@ -537,6 +544,13 @@ func disallowInternal(srcDir string, p *Package, stk *importStack) *Package {\n \t\treturn p\n \t}\n \n+\t// Look for symlinks before reporting error.\n+\tsrcDir = expandPath(srcDir)\n+\tparent = expandPath(parent)\n+\tif hasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n+\t\treturn p\n+\t}\n+\n \t// Internal is present, and srcDir is outside parent's tree. Not allowed.\n \tperr := *p\n \tperr.Error = &PackageError{\n@@ -634,6 +648,13 @@ func disallowVendorVisibility(srcDir string, p *Package, stk *importStack) *Pack\n \t\treturn p\n \t}\n \n+\t// Look for symlinks before reporting error.\n+\tsrcDir = expandPath(srcDir)\n+\tparent = expandPath(parent)\n+\tif hasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {\n+\t\treturn p\n+\t}\n+\n \t// Vendor is present, and srcDir is outside parent's tree. Not allowed.\n \tperr := *p\n \tperr.Error = &PackageError{\n@@ -957,7 +978,7 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif p.Standard && !p1.Standard && p.Error == nil {\n+\t\tif p.Standard && p.Error == nil && !p1.Standard && p1.Error == nil {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack: stk.copy(),\n \t\t\t\tErr:         fmt.Sprintf(\"non-standard import %q in standard package %q\", path, p.ImportPath),\n@@ -1532,11 +1553,14 @@ func computeBuildID(p *Package) {\n \t\tfmt.Fprintf(h, \"file %s\\n\", file)\n \t}\n \n-\t// Include the content of runtime/zversion.go in the hash\n+\t// Include the content of runtime/internal/sys/zversion.go in the hash\n \t// for package runtime. This will give package runtime a\n \t// different build ID in each Go release.\n-\tif p.Standard && p.ImportPath == \"runtime\" {\n-\t\tdata, _ := ioutil.ReadFile(filepath.Join(p.Dir, \"zversion.go\"))\n+\tif p.Standard && p.ImportPath == \"runtime/internal/sys\" {\n+\t\tdata, err := ioutil.ReadFile(filepath.Join(p.Dir, \"zversion.go\"))\n+\t\tif err != nil {\n+\t\t\tfatalf(\"go: %s\", err)\n+\t\t}\n \t\tfmt.Fprintf(h, \"zversion %q\\n\", string(data))\n \t}\n "}, {"sha": "342edee50d9c8688dc52cd37d1e30c95af8b3b19", "filename": "libgo/go/cmd/go/vcs.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvcs.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -122,7 +122,7 @@ var vcsGit = &vcsCmd{\n \tname: \"Git\",\n \tcmd:  \"git\",\n \n-\tcreateCmd:   []string{\"clone {repo} {dir}\", \"-C {dir} submodule update --init --recursive\"},\n+\tcreateCmd:   []string{\"clone {repo} {dir}\", \"-go-internal-cd {dir} submodule update --init --recursive\"},\n \tdownloadCmd: []string{\"pull --ff-only\", \"submodule update --init --recursive\"},\n \n \ttagCmd: []tagCmd{\n@@ -335,6 +335,15 @@ func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool)\n \t\targs[i] = expand(m, arg)\n \t}\n \n+\tif len(args) >= 2 && args[0] == \"-go-internal-cd\" {\n+\t\tif filepath.IsAbs(args[1]) {\n+\t\t\tdir = args[1]\n+\t\t} else {\n+\t\t\tdir = filepath.Join(dir, args[1])\n+\t\t}\n+\t\targs = args[2:]\n+\t}\n+\n \t_, err := exec.LookPath(v.cmd)\n \tif err != nil {\n \t\tfmt.Fprintf(os.Stderr,"}, {"sha": "310814df71c24fb07e3d92da08ad637925cf4529", "filename": "libgo/go/go/constant/value.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -96,7 +96,7 @@ func (x stringVal) String() string {\n \t\t// only the first maxLen-3 runes; then add \"...\".\n \t\ti := 0\n \t\tfor n := 0; n < maxLen-3; n++ {\n-\t\t\t_, size := utf8.DecodeRuneInString(s)\n+\t\t\t_, size := utf8.DecodeRuneInString(s[i:])\n \t\t\ti += size\n \t\t}\n \t\ts = s[:i] + \"...\""}, {"sha": "dbd96c07a310b8795339c9cd7f3ec55d161967d8", "filename": "libgo/go/go/constant/value_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -204,6 +204,7 @@ func eql(x, y Value) bool {\n // String tests\n \n var xxx = strings.Repeat(\"x\", 68)\n+var issue14262 = `\"\u0628\u0645\u0648\u062c\u0628 \u0627\u0644\u0634\u0631\u0648\u0637 \u0627\u0644\u062a\u0627\u0644\u064a\u0629 \u0646\u0633\u0628 \u0627\u0644\u0645\u0635\u0646\u0641 \u2014 \u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u0623\u0646 \u062a\u0646\u0633\u0628 \u0627\u0644\u0639\u0645\u0644 \u0628\u0627\u0644\u0637\u0631\u064a\u0642\u0629 \u0627\u0644\u062a\u064a \u062a\u062d\u062f\u062f\u0647\u0627 \u0627\u0644\u0645\u0624\u0644\u0641 \u0623\u0648 \u0627\u0644\u0645\u0631\u062e\u0635 (\u0648\u0644\u0643\u0646 \u0644\u064a\u0633 \u0628\u0623\u064a \u062d\u0627\u0644 \u0645\u0646 \u0627\u0644\u0623\u062d\u0648\u0627\u0644 \u0623\u0646 \u062a\u0648\u062d\u064a \u0648\u062a\u0642\u062a\u0631\u062d \u0628\u062a\u062d\u0648\u0644 \u0623\u0648 \u0627\u0633\u062a\u062e\u062f\u0627\u0645\u0643 \u0644\u0644\u0639\u0645\u0644).  \u0627\u0644\u0645\u0634\u0627\u0631\u0643\u0629 \u0639\u0644\u0649 \u0642\u062f\u0645 \u0627\u0644\u0645\u0633\u0627\u0648\u0627\u0629 \u2014 \u0625\u0630\u0627 \u0643\u0646\u062a \u064a\u0639\u062f\u0644 \u060c \u0648\u0627\u0644\u062a\u063a\u064a\u064a\u0631 \u060c \u0623\u0648 \u0627\u0644\u0627\u0633\u062a\u0641\u0627\u062f\u0629 \u0645\u0646 \u0647\u0630\u0627 \u0627\u0644\u0639\u0645\u0644 \u060c \u0642\u062f \u064a\u0646\u062a\u062c \u0639\u0646 \u062a\u0648\u0632\u064a\u0639 \u0627\u0644\u0639\u0645\u0644 \u0625\u0644\u0627 \u0641\u064a \u0638\u0644 \u062a\u0634\u0627\u0628\u0647 \u0627\u0648 \u062a\u0637\u0627\u0628\u0642 \u0641\u0649 \u0648\u0627\u062d\u062f \u0644\u0647\u0630\u0627 \u0627\u0644\u062a\u0631\u062e\u064a\u0635.\"`\n \n var stringTests = []struct {\n \tinput, short, exact string\n@@ -225,6 +226,7 @@ var stringTests = []struct {\n \t{`\"` + xxx + `xx\"`, `\"` + xxx + `xx\"`, `\"` + xxx + `xx\"`},\n \t{`\"` + xxx + `xxx\"`, `\"` + xxx + `...`, `\"` + xxx + `xxx\"`},\n \t{`\"` + xxx + xxx + `xxx\"`, `\"` + xxx + `...`, `\"` + xxx + xxx + `xxx\"`},\n+\t{issue14262, `\"\u0628\u0645\u0648\u062c\u0628 \u0627\u0644\u0634\u0631\u0648\u0637 \u0627\u0644\u062a\u0627\u0644\u064a\u0629 \u0646\u0633\u0628 \u0627\u0644\u0645\u0635\u0646\u0641 \u2014 \u064a\u062c\u0628 \u0639\u0644\u064a\u0643 \u0623\u0646 \u062a\u0646\u0633\u0628 \u0627\u0644\u0639\u0645\u0644 \u0628\u0627\u0644\u0637\u0631\u064a\u0642\u0629 \u0627\u0644...`, issue14262},\n \n \t// Int\n \t{\"0\", \"0\", \"0\"},"}, {"sha": "d70ec083c33309beb4394d1edbc62843930716f3", "filename": "libgo/go/go/internal/gcimporter/gcimporter.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fgcimporter.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -31,7 +31,8 @@ var pkgExts = [...]string{\".a\", \".o\"}\n \n // FindPkg returns the filename and unique package id for an import\n // path based on package information provided by build.Import (using\n-// the build.Default build.Context).\n+// the build.Default build.Context). A relative srcDir is interpreted\n+// relative to the current working directory.\n // If no file was found, an empty filename is returned.\n //\n func FindPkg(path, srcDir string) (filename, id string) {\n@@ -44,6 +45,9 @@ func FindPkg(path, srcDir string) (filename, id string) {\n \tdefault:\n \t\t// \"x\" -> \"$GOPATH/pkg/$GOOS_$GOARCH/x.ext\", \"x\"\n \t\t// Don't require the source files to be present.\n+\t\tif abs, err := filepath.Abs(srcDir); err == nil { // see issue 14282\n+\t\t\tsrcDir = abs\n+\t\t}\n \t\tbp, _ := build.Import(path, srcDir, build.FindOnly|build.AllowBinary)\n \t\tif bp.PkgObj == \"\" {\n \t\t\treturn"}, {"sha": "f7c4a173785b531a21a54e93d6e09f1611e03c76", "filename": "libgo/go/go/types/expr.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -184,7 +184,8 @@ func roundFloat64(x constant.Value) constant.Value {\n // provided (only needed for int/uint sizes).\n //\n // If rounded != nil, *rounded is set to the rounded value of x for\n-// representable floating-point values; it is left alone otherwise.\n+// representable floating-point and complex values, and to an Int\n+// value for integer values; it is left alone otherwise.\n // It is ok to provide the addressof the first argument for rounded.\n func representableConst(x constant.Value, conf *Config, typ *Basic, rounded *constant.Value) bool {\n \tif x.Kind() == constant.Unknown {\n@@ -197,6 +198,9 @@ func representableConst(x constant.Value, conf *Config, typ *Basic, rounded *con\n \t\tif x.Kind() != constant.Int {\n \t\t\treturn false\n \t\t}\n+\t\tif rounded != nil {\n+\t\t\t*rounded = x\n+\t\t}\n \t\tif x, ok := constant.Int64Val(x); ok {\n \t\t\tswitch typ.kind {\n \t\t\tcase Int:\n@@ -808,8 +812,6 @@ func (check *Checker) binary(x *operand, e *ast.BinaryExpr, lhs, rhs ast.Expr, o\n \t\ttyp := x.typ.Underlying().(*Basic)\n \t\t// force integer division of integer operands\n \t\tif op == token.QUO && isInteger(typ) {\n-\t\t\txval = constant.ToInt(xval)\n-\t\t\tyval = constant.ToInt(yval)\n \t\t\top = token.QUO_ASSIGN\n \t\t}\n \t\tx.val = constant.BinaryOp(xval, op, yval)"}, {"sha": "1536df5bf1bebcdc35ce5a2e1282004b050a3027", "filename": "libgo/go/go/types/resolver.go", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -483,11 +483,9 @@ func pkgName(path string) string {\n // (Per the go/build package dependency tests, we cannot import\n // path/filepath and simply use filepath.Dir.)\n func dir(path string) string {\n-\tif i := strings.LastIndexAny(path, \"/\\\\\"); i >= 0 {\n-\t\tpath = path[:i]\n+\tif i := strings.LastIndexAny(path, `/\\`); i > 0 {\n+\t\treturn path[:i]\n \t}\n-\tif path == \"\" {\n-\t\tpath = \".\"\n-\t}\n-\treturn path\n+\t// i <= 0\n+\treturn \".\"\n }"}, {"sha": "aa2473a27739cda8ef315890d260706d4bdf42ab", "filename": "libgo/go/net/http/clientserver_test.go", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fclientserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fclientserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclientserver_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -1001,17 +1001,21 @@ func TestTransportDiscardsUnneededConns(t *testing.T) {\n }\n \n // tests that Transport doesn't retain a pointer to the provided request.\n-func TestTransportGCRequest_h1(t *testing.T) { testTransportGCRequest(t, h1Mode) }\n-func TestTransportGCRequest_h2(t *testing.T) { testTransportGCRequest(t, h2Mode) }\n-func testTransportGCRequest(t *testing.T, h2 bool) {\n+func TestTransportGCRequest_Body_h1(t *testing.T)   { testTransportGCRequest(t, h1Mode, true) }\n+func TestTransportGCRequest_Body_h2(t *testing.T)   { testTransportGCRequest(t, h2Mode, true) }\n+func TestTransportGCRequest_NoBody_h1(t *testing.T) { testTransportGCRequest(t, h1Mode, false) }\n+func TestTransportGCRequest_NoBody_h2(t *testing.T) { testTransportGCRequest(t, h2Mode, false) }\n+func testTransportGCRequest(t *testing.T, h2, body bool) {\n \tif runtime.Compiler == \"gccgo\" {\n \t\tt.Skip(\"skipping on gccgo because conservative GC means that finalizer may never run\")\n \t}\n \n \tdefer afterTest(t)\n \tcst := newClientServerTest(t, h2, HandlerFunc(func(w ResponseWriter, r *Request) {\n \t\tioutil.ReadAll(r.Body)\n-\t\tio.WriteString(w, \"Hello.\")\n+\t\tif body {\n+\t\t\tio.WriteString(w, \"Hello.\")\n+\t\t}\n \t}))\n \tdefer cst.close()\n "}, {"sha": "4e19b3e71f7d33ca7a9b5e3a594efd203931ae1e", "filename": "libgo/go/net/http/h2_bundle.go", "status": "modified", "additions": 168, "deletions": 27, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fh2_bundle.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -1,5 +1,5 @@\n-// Code generated by golang.org/x/tools/cmd/bundle command:\n-//   $ bundle golang.org/x/net/http2 net/http http2\n+// Code generated by golang.org/x/tools/cmd/bundle.\n+//go:generate bundle -o h2_bundle.go -prefix http2 -import golang.org/x/net/http2/hpack=internal/golang.org/x/net/http2/hpack golang.org/x/net/http2\n \n // Package http2 implements the HTTP/2 protocol.\n //\n@@ -2331,6 +2331,10 @@ var http2isTokenTable = [127]bool{\n \t'~':  true,\n }\n \n+type http2connectionStater interface {\n+\tConnectionState() tls.ConnectionState\n+}\n+\n // pipe is a goroutine-safe io.Reader/io.Writer pair.  It's like\n // io.Pipe except there are no PipeReader/PipeWriter halves, and the\n // underlying buffer is an interface. (io.Pipe is always unbuffered)\n@@ -2593,28 +2597,76 @@ func http2ConfigureServer(s *Server, conf *http2Server) error {\n \t\tif http2testHookOnConn != nil {\n \t\t\thttp2testHookOnConn()\n \t\t}\n-\t\tconf.handleConn(hs, c, h)\n+\t\tconf.ServeConn(c, &http2ServeConnOpts{\n+\t\t\tHandler:    h,\n+\t\t\tBaseConfig: hs,\n+\t\t})\n \t}\n \ts.TLSNextProto[http2NextProtoTLS] = protoHandler\n \ts.TLSNextProto[\"h2-14\"] = protoHandler\n \treturn nil\n }\n \n-func (srv *http2Server) handleConn(hs *Server, c net.Conn, h Handler) {\n+// ServeConnOpts are options for the Server.ServeConn method.\n+type http2ServeConnOpts struct {\n+\t// BaseConfig optionally sets the base configuration\n+\t// for values. If nil, defaults are used.\n+\tBaseConfig *Server\n+\n+\t// Handler specifies which handler to use for processing\n+\t// requests. If nil, BaseConfig.Handler is used. If BaseConfig\n+\t// or BaseConfig.Handler is nil, http.DefaultServeMux is used.\n+\tHandler Handler\n+}\n+\n+func (o *http2ServeConnOpts) baseConfig() *Server {\n+\tif o != nil && o.BaseConfig != nil {\n+\t\treturn o.BaseConfig\n+\t}\n+\treturn new(Server)\n+}\n+\n+func (o *http2ServeConnOpts) handler() Handler {\n+\tif o != nil {\n+\t\tif o.Handler != nil {\n+\t\t\treturn o.Handler\n+\t\t}\n+\t\tif o.BaseConfig != nil && o.BaseConfig.Handler != nil {\n+\t\t\treturn o.BaseConfig.Handler\n+\t\t}\n+\t}\n+\treturn DefaultServeMux\n+}\n+\n+// ServeConn serves HTTP/2 requests on the provided connection and\n+// blocks until the connection is no longer readable.\n+//\n+// ServeConn starts speaking HTTP/2 assuming that c has not had any\n+// reads or writes. It writes its initial settings frame and expects\n+// to be able to read the preface and settings frame from the\n+// client. If c has a ConnectionState method like a *tls.Conn, the\n+// ConnectionState is used to verify the TLS ciphersuite and to set\n+// the Request.TLS field in Handlers.\n+//\n+// ServeConn does not support h2c by itself. Any h2c support must be\n+// implemented in terms of providing a suitably-behaving net.Conn.\n+//\n+// The opts parameter is optional. If nil, default values are used.\n+func (s *http2Server) ServeConn(c net.Conn, opts *http2ServeConnOpts) {\n \tsc := &http2serverConn{\n-\t\tsrv:              srv,\n-\t\ths:               hs,\n+\t\tsrv:              s,\n+\t\ths:               opts.baseConfig(),\n \t\tconn:             c,\n \t\tremoteAddrStr:    c.RemoteAddr().String(),\n \t\tbw:               http2newBufferedWriter(c),\n-\t\thandler:          h,\n+\t\thandler:          opts.handler(),\n \t\tstreams:          make(map[uint32]*http2stream),\n \t\treadFrameCh:      make(chan http2readFrameResult),\n \t\twantWriteFrameCh: make(chan http2frameWriteMsg, 8),\n \t\twroteFrameCh:     make(chan http2frameWriteResult, 1),\n \t\tbodyReadCh:       make(chan http2bodyReadMsg),\n \t\tdoneServing:      make(chan struct{}),\n-\t\tadvMaxStreams:    srv.maxConcurrentStreams(),\n+\t\tadvMaxStreams:    s.maxConcurrentStreams(),\n \t\twriteSched: http2writeScheduler{\n \t\t\tmaxFrameSize: http2initialMaxFrameSize,\n \t\t},\n@@ -2630,10 +2682,10 @@ func (srv *http2Server) handleConn(hs *Server, c net.Conn, h Handler) {\n \tsc.hpackDecoder.SetMaxStringLength(sc.maxHeaderStringLen())\n \n \tfr := http2NewFramer(sc.bw, c)\n-\tfr.SetMaxReadFrameSize(srv.maxReadFrameSize())\n+\tfr.SetMaxReadFrameSize(s.maxReadFrameSize())\n \tsc.framer = fr\n \n-\tif tc, ok := c.(*tls.Conn); ok {\n+\tif tc, ok := c.(http2connectionStater); ok {\n \t\tsc.tlsState = new(tls.ConnectionState)\n \t\t*sc.tlsState = tc.ConnectionState()\n \n@@ -2646,7 +2698,7 @@ func (srv *http2Server) handleConn(hs *Server, c net.Conn, h Handler) {\n \n \t\t}\n \n-\t\tif !srv.PermitProhibitedCipherSuites && http2isBadCipher(sc.tlsState.CipherSuite) {\n+\t\tif !s.PermitProhibitedCipherSuites && http2isBadCipher(sc.tlsState.CipherSuite) {\n \n \t\t\tsc.rejectConn(http2ErrCodeInadequateSecurity, fmt.Sprintf(\"Prohibited TLS 1.2 Cipher Suite: %x\", sc.tlsState.CipherSuite))\n \t\t\treturn\n@@ -2851,8 +2903,6 @@ func (sc *http2serverConn) logf(format string, args ...interface{}) {\n \t}\n }\n \n-var http2uintptrType = reflect.TypeOf(uintptr(0))\n-\n // errno returns v's underlying uintptr, else 0.\n //\n // TODO: remove this helper function once http2 can use build\n@@ -4220,7 +4270,9 @@ func (rws *http2responseWriterState) declareTrailer(k string) {\n \n \t\treturn\n \t}\n-\trws.trailers = append(rws.trailers, k)\n+\tif !http2strSliceContains(rws.trailers, k) {\n+\t\trws.trailers = append(rws.trailers, k)\n+\t}\n }\n \n // writeChunk writes chunks from the bufio.Writer. But because\n@@ -4288,6 +4340,10 @@ func (rws *http2responseWriterState) writeChunk(p []byte) (n int, err error) {\n \t\treturn 0, nil\n \t}\n \n+\tif rws.handlerDone {\n+\t\trws.promoteUndeclaredTrailers()\n+\t}\n+\n \tendStream := rws.handlerDone && !rws.hasTrailers()\n \tif len(p) > 0 || endStream {\n \n@@ -4308,6 +4364,53 @@ func (rws *http2responseWriterState) writeChunk(p []byte) (n int, err error) {\n \treturn len(p), nil\n }\n \n+// TrailerPrefix is a magic prefix for ResponseWriter.Header map keys\n+// that, if present, signals that the map entry is actually for\n+// the response trailers, and not the response headers. The prefix\n+// is stripped after the ServeHTTP call finishes and the values are\n+// sent in the trailers.\n+//\n+// This mechanism is intended only for trailers that are not known\n+// prior to the headers being written. If the set of trailers is fixed\n+// or known before the header is written, the normal Go trailers mechanism\n+// is preferred:\n+//    https://golang.org/pkg/net/http/#ResponseWriter\n+//    https://golang.org/pkg/net/http/#example_ResponseWriter_trailers\n+const http2TrailerPrefix = \"Trailer:\"\n+\n+// promoteUndeclaredTrailers permits http.Handlers to set trailers\n+// after the header has already been flushed. Because the Go\n+// ResponseWriter interface has no way to set Trailers (only the\n+// Header), and because we didn't want to expand the ResponseWriter\n+// interface, and because nobody used trailers, and because RFC 2616\n+// says you SHOULD (but not must) predeclare any trailers in the\n+// header, the official ResponseWriter rules said trailers in Go must\n+// be predeclared, and then we reuse the same ResponseWriter.Header()\n+// map to mean both Headers and Trailers.  When it's time to write the\n+// Trailers, we pick out the fields of Headers that were declared as\n+// trailers. That worked for a while, until we found the first major\n+// user of Trailers in the wild: gRPC (using them only over http2),\n+// and gRPC libraries permit setting trailers mid-stream without\n+// predeclarnig them. So: change of plans. We still permit the old\n+// way, but we also permit this hack: if a Header() key begins with\n+// \"Trailer:\", the suffix of that key is a Trailer. Because ':' is an\n+// invalid token byte anyway, there is no ambiguity. (And it's already\n+// filtered out) It's mildly hacky, but not terrible.\n+//\n+// This method runs after the Handler is done and promotes any Header\n+// fields to be trailers.\n+func (rws *http2responseWriterState) promoteUndeclaredTrailers() {\n+\tfor k, vv := range rws.handlerHeader {\n+\t\tif !strings.HasPrefix(k, http2TrailerPrefix) {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttrailerKey := strings.TrimPrefix(k, http2TrailerPrefix)\n+\t\trws.declareTrailer(trailerKey)\n+\t\trws.handlerHeader[CanonicalHeaderKey(trailerKey)] = vv\n+\t}\n+\tsort.Strings(rws.trailers)\n+}\n+\n func (w *http2responseWriter) Flush() {\n \trws := w.rws\n \tif rws == nil {\n@@ -4823,10 +4926,7 @@ func (t *http2Transport) NewClientConn(c net.Conn) (*http2ClientConn, error) {\n \n \tcc.henc = hpack.NewEncoder(&cc.hbuf)\n \n-\ttype connectionStater interface {\n-\t\tConnectionState() tls.ConnectionState\n-\t}\n-\tif cs, ok := c.(connectionStater); ok {\n+\tif cs, ok := c.(http2connectionStater); ok {\n \t\tstate := cs.ConnectionState()\n \t\tcc.tlsState = &state\n \t}\n@@ -4977,7 +5077,27 @@ func (cc *http2ClientConn) responseHeaderTimeout() time.Duration {\n \treturn 0\n }\n \n+// checkConnHeaders checks whether req has any invalid connection-level headers.\n+// per RFC 7540 section 8.1.2.2: Connection-Specific Header Fields.\n+// Certain headers are special-cased as okay but not transmitted later.\n+func http2checkConnHeaders(req *Request) error {\n+\tif v := req.Header.Get(\"Upgrade\"); v != \"\" {\n+\t\treturn errors.New(\"http2: invalid Upgrade request header\")\n+\t}\n+\tif v := req.Header.Get(\"Transfer-Encoding\"); (v != \"\" && v != \"chunked\") || len(req.Header[\"Transfer-Encoding\"]) > 1 {\n+\t\treturn errors.New(\"http2: invalid Transfer-Encoding request header\")\n+\t}\n+\tif v := req.Header.Get(\"Connection\"); (v != \"\" && v != \"close\" && v != \"keep-alive\") || len(req.Header[\"Connection\"]) > 1 {\n+\t\treturn errors.New(\"http2: invalid Connection request header\")\n+\t}\n+\treturn nil\n+}\n+\n func (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error) {\n+\tif err := http2checkConnHeaders(req); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \ttrailers, err := http2commaSeparatedTrailers(req)\n \tif err != nil {\n \t\treturn nil, err\n@@ -5283,10 +5403,14 @@ func (cc *http2ClientConn) encodeHeaders(req *Request, addGzipHeader bool, trail\n \tvar didUA bool\n \tfor k, vv := range req.Header {\n \t\tlowKey := strings.ToLower(k)\n-\t\tif lowKey == \"host\" || lowKey == \"content-length\" {\n+\t\tswitch lowKey {\n+\t\tcase \"host\", \"content-length\":\n+\n \t\t\tcontinue\n-\t\t}\n-\t\tif lowKey == \"user-agent\" {\n+\t\tcase \"connection\", \"proxy-connection\", \"transfer-encoding\", \"upgrade\":\n+\n+\t\t\tcontinue\n+\t\tcase \"user-agent\":\n \n \t\t\tdidUA = true\n \t\t\tif len(vv) < 1 {\n@@ -5394,8 +5518,9 @@ func (cc *http2ClientConn) streamByID(id uint32, andRemove bool) *http2clientStr\n \n // clientConnReadLoop is the state owned by the clientConn's frame-reading readLoop.\n type http2clientConnReadLoop struct {\n-\tcc        *http2ClientConn\n-\tactiveRes map[uint32]*http2clientStream // keyed by streamID\n+\tcc            *http2ClientConn\n+\tactiveRes     map[uint32]*http2clientStream // keyed by streamID\n+\tcloseWhenIdle bool\n \n \thdec *hpack.Decoder\n \n@@ -5452,7 +5577,7 @@ func (rl *http2clientConnReadLoop) cleanup() {\n \n func (rl *http2clientConnReadLoop) run() error {\n \tcc := rl.cc\n-\tcloseWhenIdle := cc.t.disableKeepAlives()\n+\trl.closeWhenIdle = cc.t.disableKeepAlives()\n \tgotReply := false\n \tfor {\n \t\tf, err := cc.fr.ReadFrame()\n@@ -5501,7 +5626,7 @@ func (rl *http2clientConnReadLoop) run() error {\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif closeWhenIdle && gotReply && maybeIdle && len(rl.activeRes) == 0 {\n+\t\tif rl.closeWhenIdle && gotReply && maybeIdle && len(rl.activeRes) == 0 {\n \t\t\tcc.closeIfIdle()\n \t\t}\n \t}\n@@ -5611,10 +5736,10 @@ func (rl *http2clientConnReadLoop) processHeaderBlockFragment(frag []byte, strea\n \t\t\tres.ContentLength = -1\n \t\t\tres.Body = &http2gzipReader{body: res.Body}\n \t\t}\n+\t\trl.activeRes[cs.ID] = cs\n \t}\n \n \tcs.resTrailer = &res.Trailer\n-\trl.activeRes[cs.ID] = cs\n \tcs.resc <- http2resAndError{res: res}\n \trl.nextRes = nil\n \treturn nil\n@@ -5752,6 +5877,9 @@ func (rl *http2clientConnReadLoop) endStream(cs *http2clientStream) {\n \t}\n \tcs.bufPipe.closeWithErrorAndCode(err, code)\n \tdelete(rl.activeRes, cs.ID)\n+\tif cs.req.Close || cs.req.Header.Get(\"Connection\") == \"close\" {\n+\t\trl.closeWhenIdle = true\n+\t}\n }\n \n func (cs *http2clientStream) copyTrailers() {\n@@ -6013,13 +6141,18 @@ func (rt http2erringRoundTripper) RoundTrip(*Request) (*Response, error) { retur\n // call gzip.NewReader on the first call to Read\n type http2gzipReader struct {\n \tbody io.ReadCloser // underlying Response.Body\n-\tzr   io.Reader     // lazily-initialized gzip reader\n+\tzr   *gzip.Reader  // lazily-initialized gzip reader\n+\tzerr error         // sticky error\n }\n \n func (gz *http2gzipReader) Read(p []byte) (n int, err error) {\n+\tif gz.zerr != nil {\n+\t\treturn 0, gz.zerr\n+\t}\n \tif gz.zr == nil {\n \t\tgz.zr, err = gzip.NewReader(gz.body)\n \t\tif err != nil {\n+\t\t\tgz.zerr = err\n \t\t\treturn 0, err\n \t\t}\n \t}\n@@ -6258,8 +6391,16 @@ func http2encodeHeaders(enc *hpack.Encoder, h Header, keys []string) {\n \tfor _, k := range keys {\n \t\tvv := h[k]\n \t\tk = http2lowerHeader(k)\n+\t\tif !http2validHeaderFieldName(k) {\n+\n+\t\t\tcontinue\n+\t\t}\n \t\tisTE := k == \"transfer-encoding\"\n \t\tfor _, v := range vv {\n+\t\t\tif !http2validHeaderFieldValue(v) {\n+\n+\t\t\t\tcontinue\n+\t\t\t}\n \n \t\t\tif isTE && v != \"trailers\" {\n \t\t\t\tcontinue"}, {"sha": "bbe323396f5594bcd9c548ce0c502a2085915458", "filename": "libgo/go/net/http/httptest/server.go", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -202,10 +202,31 @@ func (s *Server) logCloseHangDebugInfo() {\n \n // CloseClientConnections closes any open HTTP connections to the test Server.\n func (s *Server) CloseClientConnections() {\n+\tvar conns int\n+\tch := make(chan bool)\n+\n \ts.mu.Lock()\n-\tdefer s.mu.Unlock()\n \tfor c := range s.conns {\n-\t\ts.closeConn(c)\n+\t\tconns++\n+\t\ts.closeConnChan(c, ch)\n+\t}\n+\ts.mu.Unlock()\n+\n+\t// Wait for outstanding closes to finish.\n+\t//\n+\t// Out of paranoia for making a late change in Go 1.6, we\n+\t// bound how long this can wait, since golang.org/issue/14291\n+\t// isn't fully understood yet. At least this should only be used\n+\t// in tests.\n+\ttimer := time.NewTimer(5 * time.Second)\n+\tdefer timer.Stop()\n+\tfor i := 0; i < conns; i++ {\n+\t\tselect {\n+\t\tcase <-ch:\n+\t\tcase <-timer.C:\n+\t\t\t// Too slow. Give up.\n+\t\t\treturn\n+\t\t}\n \t}\n }\n \n@@ -267,9 +288,13 @@ func (s *Server) wrap() {\n \t}\n }\n \n-// closeConn closes c. Except on plan9, which is special. See comment below.\n+// closeConn closes c.\n // s.mu must be held.\n-func (s *Server) closeConn(c net.Conn) {\n+func (s *Server) closeConn(c net.Conn) { s.closeConnChan(c, nil) }\n+\n+// closeConnChan is like closeConn, but takes an optional channel to receive a value\n+// when the goroutine closing c is done.\n+func (s *Server) closeConnChan(c net.Conn, done chan<- bool) {\n \tif runtime.GOOS == \"plan9\" {\n \t\t// Go's Plan 9 net package isn't great at unblocking reads when\n \t\t// their underlying TCP connections are closed.  Don't trust\n@@ -278,7 +303,21 @@ func (s *Server) closeConn(c net.Conn) {\n \t\t// resources if the syscall doesn't end up returning. Oh well.\n \t\ts.forgetConn(c)\n \t}\n-\tgo c.Close()\n+\n+\t// Somewhere in the chaos of https://golang.org/cl/15151 we found that\n+\t// some types of conns were blocking in Close too long (or deadlocking?)\n+\t// and we had to call Close in a goroutine. I (bradfitz) forget what\n+\t// that was at this point, but I suspect it was *tls.Conns, which\n+\t// were later fixed in https://golang.org/cl/18572, so this goroutine\n+\t// is _probably_ unnecessary now. But it's too late in Go 1.6 too remove\n+\t// it with confidence.\n+\t// TODO(bradfitz): try to remove it for Go 1.7. (golang.org/issue/14291)\n+\tgo func() {\n+\t\tc.Close()\n+\t\tif done != nil {\n+\t\t\tdone <- true\n+\t\t}\n+\t}()\n }\n \n // forgetConn removes c from the set of tracked conns and decrements it from the"}, {"sha": "c9606f24198d1cf7b5af67b6495494572b483fd4", "filename": "libgo/go/net/http/httptest/server_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttptest%2Fserver_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -84,3 +84,17 @@ func TestServerCloseBlocking(t *testing.T) {\n \n \tts.Close() // test we don't hang here forever.\n }\n+\n+// Issue 14290\n+func TestServerCloseClientConnections(t *testing.T) {\n+\tvar s *Server\n+\ts = NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\ts.CloseClientConnections()\n+\t}))\n+\tdefer s.Close()\n+\tres, err := http.Get(s.URL)\n+\tif err == nil {\n+\t\tres.Body.Close()\n+\t\tt.Fatal(\"Unexpected response: %#v\", res)\n+\t}\n+}"}, {"sha": "54411caeca8f90472cf0aa220d53bf906bee0f79", "filename": "libgo/go/net/http/httputil/reverseproxy.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -106,11 +106,12 @@ func copyHeader(dst, src http.Header) {\n // http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html\n var hopHeaders = []string{\n \t\"Connection\",\n+\t\"Proxy-Connection\", // non-standard but still sent by libcurl and rejected by e.g. google\n \t\"Keep-Alive\",\n \t\"Proxy-Authenticate\",\n \t\"Proxy-Authorization\",\n-\t\"Te\", // canonicalized version of \"TE\"\n-\t\"Trailers\",\n+\t\"Te\",      // canonicalized version of \"TE\"\n+\t\"Trailer\", // not Trailers per URL above; http://www.rfc-editor.org/errata_search.php?eid=4522\n \t\"Transfer-Encoding\",\n \t\"Upgrade\",\n }"}, {"sha": "0849427b85cce40f6e7a262d0db2806c2bb8f209", "filename": "libgo/go/net/http/httputil/reverseproxy_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -45,9 +45,13 @@ func TestReverseProxy(t *testing.T) {\n \t\tif c := r.Header.Get(\"Upgrade\"); c != \"\" {\n \t\t\tt.Errorf(\"handler got Upgrade header value %q\", c)\n \t\t}\n+\t\tif c := r.Header.Get(\"Proxy-Connection\"); c != \"\" {\n+\t\t\tt.Errorf(\"handler got Proxy-Connection header value %q\", c)\n+\t\t}\n \t\tif g, e := r.Host, \"some-name\"; g != e {\n \t\t\tt.Errorf(\"backend got Host header %q, want %q\", g, e)\n \t\t}\n+\t\tw.Header().Set(\"Trailers\", \"not a special header field name\")\n \t\tw.Header().Set(\"Trailer\", \"X-Trailer\")\n \t\tw.Header().Set(\"X-Foo\", \"bar\")\n \t\tw.Header().Set(\"Upgrade\", \"foo\")\n@@ -71,6 +75,7 @@ func TestReverseProxy(t *testing.T) {\n \tgetReq, _ := http.NewRequest(\"GET\", frontend.URL, nil)\n \tgetReq.Host = \"some-name\"\n \tgetReq.Header.Set(\"Connection\", \"close\")\n+\tgetReq.Header.Set(\"Proxy-Connection\", \"should be deleted\")\n \tgetReq.Header.Set(\"Upgrade\", \"foo\")\n \tgetReq.Close = true\n \tres, err := http.DefaultClient.Do(getReq)\n@@ -86,6 +91,9 @@ func TestReverseProxy(t *testing.T) {\n \tif c := res.Header.Get(fakeHopHeader); c != \"\" {\n \t\tt.Errorf(\"got %s header value %q\", fakeHopHeader, c)\n \t}\n+\tif g, e := res.Header.Get(\"Trailers\"), \"not a special header field name\"; g != e {\n+\t\tt.Errorf(\"header Trailers = %q; want %q\", g, e)\n+\t}\n \tif g, e := len(res.Header[\"X-Multi-Value\"]), 2; g != e {\n \t\tt.Errorf(\"got %d X-Multi-Value header values; expected %d\", g, e)\n \t}"}, {"sha": "8cdab02af5a057ca0382fcb17034a4086547a421", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -99,30 +99,37 @@ type Request struct {\n \tProtoMajor int    // 1\n \tProtoMinor int    // 0\n \n-\t// A header maps request lines to their values.\n-\t// If the header says\n+\t// Header contains the request header fields either received\n+\t// by the server or to be sent by the client.\n \t//\n+\t// If a server received a request with header lines,\n+\t//\n+\t//\tHost: example.com\n \t//\taccept-encoding: gzip, deflate\n \t//\tAccept-Language: en-us\n-\t//\tConnection: keep-alive\n+\t//\tfOO: Bar\n+\t//\tfoo: two\n \t//\n \t// then\n \t//\n \t//\tHeader = map[string][]string{\n \t//\t\t\"Accept-Encoding\": {\"gzip, deflate\"},\n \t//\t\t\"Accept-Language\": {\"en-us\"},\n-\t//\t\t\"Connection\": {\"keep-alive\"},\n+\t//\t\t\"Foo\": {\"Bar\", \"two\"},\n \t//\t}\n \t//\n-\t// HTTP defines that header names are case-insensitive.\n-\t// The request parser implements this by canonicalizing the\n-\t// name, making the first character and any characters\n-\t// following a hyphen uppercase and the rest lowercase.\n+\t// For incoming requests, the Host header is promoted to the\n+\t// Request.Host field and removed from the Header map.\n \t//\n-\t// For client requests certain headers are automatically\n-\t// added and may override values in Header.\n+\t// HTTP defines that header names are case-insensitive. The\n+\t// request parser implements this by using CanonicalHeaderKey,\n+\t// making the first character and any characters following a\n+\t// hyphen uppercase and the rest lowercase.\n \t//\n-\t// See the documentation for the Request.Write method.\n+\t// For client requests, certain headers such as Content-Length\n+\t// and Connection are automatically written when needed and\n+\t// values in Header may be ignored. See the documentation\n+\t// for the Request.Write method.\n \tHeader Header\n \n \t// Body is the request's body.\n@@ -152,8 +159,15 @@ type Request struct {\n \tTransferEncoding []string\n \n \t// Close indicates whether to close the connection after\n-\t// replying to this request (for servers) or after sending\n-\t// the request (for clients).\n+\t// replying to this request (for servers) or after sending this\n+\t// request and reading its response (for clients).\n+\t//\n+\t// For server requests, the HTTP server handles this automatically\n+\t// and this field is not needed by Handlers.\n+\t//\n+\t// For client requests, setting this field prevents re-use of\n+\t// TCP connections between requests to the same hosts, as if\n+\t// Transport.DisableKeepAlives were set.\n \tClose bool\n \n \t// For server requests Host specifies the host on which the"}, {"sha": "384b453ce0ad5860a2fc67ff01537c700145c325", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -1039,12 +1039,30 @@ func TestAutomaticHTTP2_Serve(t *testing.T) {\n }\n \n func TestAutomaticHTTP2_ListenAndServe(t *testing.T) {\n-\tdefer afterTest(t)\n-\tdefer SetTestHookServerServe(nil)\n \tcert, err := tls.X509KeyPair(internal.LocalhostCert, internal.LocalhostKey)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n+\ttestAutomaticHTTP2_ListenAndServe(t, &tls.Config{\n+\t\tCertificates: []tls.Certificate{cert},\n+\t})\n+}\n+\n+func TestAutomaticHTTP2_ListenAndServe_GetCertificate(t *testing.T) {\n+\tcert, err := tls.X509KeyPair(internal.LocalhostCert, internal.LocalhostKey)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\ttestAutomaticHTTP2_ListenAndServe(t, &tls.Config{\n+\t\tGetCertificate: func(clientHello *tls.ClientHelloInfo) (*tls.Certificate, error) {\n+\t\t\treturn &cert, nil\n+\t\t},\n+\t})\n+}\n+\n+func testAutomaticHTTP2_ListenAndServe(t *testing.T, tlsConf *tls.Config) {\n+\tdefer afterTest(t)\n+\tdefer SetTestHookServerServe(nil)\n \tvar ok bool\n \tvar s *Server\n \tconst maxTries = 5\n@@ -1060,10 +1078,8 @@ Try:\n \t\t\tlnc <- ln\n \t\t})\n \t\ts = &Server{\n-\t\t\tAddr: addr,\n-\t\t\tTLSConfig: &tls.Config{\n-\t\t\t\tCertificates: []tls.Certificate{cert},\n-\t\t\t},\n+\t\t\tAddr:      addr,\n+\t\t\tTLSConfig: tlsConf,\n \t\t}\n \t\terrc := make(chan error, 1)\n \t\tgo func() { errc <- s.ListenAndServeTLS(\"\", \"\") }()\n@@ -2416,7 +2432,7 @@ func TestCloseNotifierPipelined(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"error dialing: %v\", err)\n \t}\n-\tdiec := make(chan bool, 2)\n+\tdiec := make(chan bool, 1)\n \tgo func() {\n \t\tconst req = \"GET / HTTP/1.1\\r\\nConnection: keep-alive\\r\\nHost: foo\\r\\n\\r\\n\"\n \t\t_, err = io.WriteString(conn, req+req) // two requests\n@@ -2426,13 +2442,23 @@ func TestCloseNotifierPipelined(t *testing.T) {\n \t\t<-diec\n \t\tconn.Close()\n \t}()\n+\treqs := 0\n+\tcloses := 0\n For:\n \tfor {\n \t\tselect {\n \t\tcase <-gotReq:\n-\t\t\tdiec <- true\n+\t\t\treqs++\n+\t\t\tif reqs > 2 {\n+\t\t\t\tt.Fatal(\"too many requests\")\n+\t\t\t} else if reqs > 1 {\n+\t\t\t\tdiec <- true\n+\t\t\t}\n \t\tcase <-sawClose:\n-\t\t\tbreak For\n+\t\t\tcloses++\n+\t\t\tif closes > 1 {\n+\t\t\t\tbreak For\n+\t\t\t}\n \t\tcase <-time.After(5 * time.Second):\n \t\t\tts.CloseClientConnections()\n \t\t\tt.Fatal(\"timeout\")"}, {"sha": "5e3b6084ae3879be3b14ca5d3dfaddce652256b4", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -2233,10 +2233,11 @@ func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error {\n // Accepted connections are configured to enable TCP keep-alives.\n //\n // Filenames containing a certificate and matching private key for the\n-// server must be provided if the Server's TLSConfig.Certificates is\n-// not populated. If the certificate is signed by a certificate\n-// authority, the certFile should be the concatenation of the server's\n-// certificate, any intermediates, and the CA's certificate.\n+// server must be provided if neither the Server's TLSConfig.Certificates\n+// nor TLSConfig.GetCertificate are populated. If the certificate is\n+// signed by a certificate authority, the certFile should be the\n+// concatenation of the server's certificate, any intermediates, and\n+// the CA's certificate.\n //\n // If srv.Addr is blank, \":https\" is used.\n //\n@@ -2258,7 +2259,8 @@ func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error {\n \t\tconfig.NextProtos = append(config.NextProtos, \"http/1.1\")\n \t}\n \n-\tif len(config.Certificates) == 0 || certFile != \"\" || keyFile != \"\" {\n+\tconfigHasCert := len(config.Certificates) > 0 || config.GetCertificate != nil\n+\tif !configHasCert || certFile != \"\" || keyFile != \"\" {\n \t\tvar err error\n \t\tconfig.Certificates = make([]tls.Certificate, 1)\n \t\tconfig.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile)"}, {"sha": "baf71d5e85e2facf97294f64fa41dfdbdcc4c0b3", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -163,6 +163,22 @@ func (t *Transport) onceSetNextProtoDefaults() {\n \t\treturn\n \t}\n \tif t.TLSNextProto != nil {\n+\t\t// This is the documented way to disable http2 on a\n+\t\t// Transport.\n+\t\treturn\n+\t}\n+\tif t.TLSClientConfig != nil {\n+\t\t// Be conservative for now (for Go 1.6) at least and\n+\t\t// don't automatically enable http2 if they've\n+\t\t// specified a custom TLS config. Let them opt-in\n+\t\t// themselves via http2.ConfigureTransport so we don't\n+\t\t// surprise them by modifying their tls.Config.\n+\t\t// Issue 14275.\n+\t\treturn\n+\t}\n+\tif t.ExpectContinueTimeout != 0 {\n+\t\t// Unsupported in http2, so disable http2 for now.\n+\t\t// Issue 13851.\n \t\treturn\n \t}\n \tt2, err := http2configureTransport(t)"}, {"sha": "0c901b30a44771528860e54926b0fe683a66a5ac", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -2208,9 +2208,8 @@ func TestTransportTLSHandshakeTimeout(t *testing.T) {\n // Trying to repro golang.org/issue/3514\n func TestTLSServerClosesConnection(t *testing.T) {\n \tdefer afterTest(t)\n-\tif runtime.GOOS == \"windows\" {\n-\t\tt.Skip(\"skipping flaky test on Windows; golang.org/issue/7634\")\n-\t}\n+\tsetFlaky(t, 7634)\n+\n \tclosedc := make(chan bool, 1)\n \tts := httptest.NewTLSServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n \t\tif strings.Contains(r.URL.Path, \"/keep-alive-then-die\") {\n@@ -2886,23 +2885,34 @@ func TestTransportPrefersResponseOverWriteError(t *testing.T) {\n }\n \n func TestTransportAutomaticHTTP2(t *testing.T) {\n-\ttr := &Transport{}\n-\t_, err := tr.RoundTrip(new(Request))\n-\tif err == nil {\n-\t\tt.Error(\"expected error from RoundTrip\")\n-\t}\n-\tif tr.TLSNextProto[\"h2\"] == nil {\n-\t\tt.Errorf(\"HTTP/2 not registered.\")\n-\t}\n+\ttestTransportAutoHTTP(t, &Transport{}, true)\n+}\n+\n+func TestTransportAutomaticHTTP2_TLSNextProto(t *testing.T) {\n+\ttestTransportAutoHTTP(t, &Transport{\n+\t\tTLSNextProto: make(map[string]func(string, *tls.Conn) RoundTripper),\n+\t}, false)\n+}\n+\n+func TestTransportAutomaticHTTP2_TLSConfig(t *testing.T) {\n+\ttestTransportAutoHTTP(t, &Transport{\n+\t\tTLSClientConfig: new(tls.Config),\n+\t}, false)\n+}\n+\n+func TestTransportAutomaticHTTP2_ExpectContinueTimeout(t *testing.T) {\n+\ttestTransportAutoHTTP(t, &Transport{\n+\t\tExpectContinueTimeout: 1 * time.Second,\n+\t}, false)\n+}\n \n-\t// Now with TLSNextProto set:\n-\ttr = &Transport{TLSNextProto: make(map[string]func(string, *tls.Conn) RoundTripper)}\n-\t_, err = tr.RoundTrip(new(Request))\n+func testTransportAutoHTTP(t *testing.T, tr *Transport, wantH2 bool) {\n+\t_, err := tr.RoundTrip(new(Request))\n \tif err == nil {\n \t\tt.Error(\"expected error from RoundTrip\")\n \t}\n-\tif tr.TLSNextProto[\"h2\"] != nil {\n-\t\tt.Errorf(\"HTTP/2 registered, despite non-nil TLSNextProto field\")\n+\tif reg := tr.TLSNextProto[\"h2\"] != nil; reg != wantH2 {\n+\t\tt.Errorf(\"HTTP/2 registered = %v; want %v\", reg, wantH2)\n \t}\n }\n "}, {"sha": "cd62b4373ebb1aafc66728432e19d808ba32672c", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"os\"\n \t\"runtime\"\n \t\"testing\"\n+\t\"time\"\n )\n \n func TestCloseRead(t *testing.T) {\n@@ -209,6 +210,7 @@ func TestListenerClose(t *testing.T) {\n \t\t\tdefer os.Remove(ln.Addr().String())\n \t\t}\n \n+\t\tdst := ln.Addr().String()\n \t\tif err := ln.Close(); err != nil {\n \t\t\tif perr := parseCloseError(err); perr != nil {\n \t\t\t\tt.Error(perr)\n@@ -222,9 +224,24 @@ func TestListenerClose(t *testing.T) {\n \t\t}\n \n \t\tif network == \"tcp\" {\n-\t\t\tcc, err := Dial(\"tcp\", ln.Addr().String())\n+\t\t\t// We will have two TCP FSMs inside the\n+\t\t\t// kernel here. There's no guarantee that a\n+\t\t\t// signal comes from the far end FSM will be\n+\t\t\t// delivered immediately to the near end FSM,\n+\t\t\t// especially on the platforms that allow\n+\t\t\t// multiple consumer threads to pull pending\n+\t\t\t// established connections at the same time by\n+\t\t\t// enabling SO_REUSEPORT option such as Linux,\n+\t\t\t// DragonFly BSD. So we need to give some time\n+\t\t\t// quantum to the kernel.\n+\t\t\t//\n+\t\t\t// Note that net.inet.tcp.reuseport_ext=1 by\n+\t\t\t// default on DragonFly BSD.\n+\t\t\ttime.Sleep(time.Millisecond)\n+\n+\t\t\tcc, err := Dial(\"tcp\", dst)\n \t\t\tif err == nil {\n-\t\t\t\tt.Error(\"Dial to closed TCP listener succeeeded.\")\n+\t\t\t\tt.Error(\"Dial to closed TCP listener succeeded.\")\n \t\t\t\tcc.Close()\n \t\t\t}\n \t\t}\n@@ -272,6 +289,9 @@ func TestListenCloseListen(t *testing.T) {\n \t\t}\n \t\taddr := ln.Addr().String()\n \t\tif err := ln.Close(); err != nil {\n+\t\t\tif perr := parseCloseError(err); perr != nil {\n+\t\t\t\tt.Error(perr)\n+\t\t\t}\n \t\t\tt.Fatal(err)\n \t\t}\n \t\tln, err = Listen(\"tcp\", addr)"}, {"sha": "869a28a8a4e56d1e34df58567ac17846e888b9f9", "filename": "libgo/go/os/doc.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fos%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fos%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdoc.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -7,9 +7,13 @@ package os\n import \"time\"\n \n // FindProcess looks for a running process by its pid.\n+//\n // The Process it returns can be used to obtain information\n // about the underlying operating system process.\n-func FindProcess(pid int) (p *Process, err error) {\n+//\n+// On Unix systems, FindProcess always succeeds and returns a Process\n+// for the given pid, regardless of whether the process exists.\n+func FindProcess(pid int) (*Process, error) {\n \treturn findProcess(pid)\n }\n "}, {"sha": "c0396bdde51b84ad4eecd410345d84bd2b4e47e9", "filename": "libgo/go/runtime/cgo_mmap.go", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fcgo_mmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fcgo_mmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgo_mmap.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -15,12 +15,19 @@ import \"unsafe\"\n //go:linkname _cgo_mmap _cgo_mmap\n var _cgo_mmap unsafe.Pointer\n \n-func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) (ret unsafe.Pointer) {\n+func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) unsafe.Pointer {\n \tif _cgo_mmap != nil {\n+\t\t// Make ret a uintptr so that writing to it in the\n+\t\t// function literal does not trigger a write barrier.\n+\t\t// A write barrier here could break because of the way\n+\t\t// that mmap uses the same value both as a pointer and\n+\t\t// an errno value.\n+\t\t// TODO: Fix mmap to return two values.\n+\t\tvar ret uintptr\n \t\tsystemstack(func() {\n \t\t\tret = callCgoMmap(addr, n, prot, flags, fd, off)\n \t\t})\n-\t\treturn\n+\t\treturn unsafe.Pointer(ret)\n \t}\n \treturn sysMmap(addr, n, prot, flags, fd, off)\n }\n@@ -31,4 +38,4 @@ func sysMmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32)\n // cgoMmap calls the mmap function in the runtime/cgo package on the\n // callCgoMmap calls the mmap function in the runtime/cgo package\n // using the GCC calling convention.  It is implemented in assembly.\n-func callCgoMmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) unsafe.Pointer\n+func callCgoMmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) uintptr"}, {"sha": "aebce1506d17e389e34ebcad0551327cfb331a61", "filename": "libgo/go/runtime/cgocheck.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fcgocheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fcgocheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgocheck.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -135,9 +135,6 @@ func cgoCheckTypedBlock(typ *_type, src unsafe.Pointer, off, size uintptr) {\n \thbits := heapBitsForAddr(uintptr(src))\n \tfor i := uintptr(0); i < off+size; i += sys.PtrSize {\n \t\tbits := hbits.bits()\n-\t\tif bits != 0 {\n-\t\t\tprintln(i, bits)\n-\t\t}\n \t\tif i >= off && bits&bitPointer != 0 {\n \t\t\tv := *(*unsafe.Pointer)(add(src, i))\n \t\t\tif cgoIsGoPointer(v) {"}, {"sha": "5f0e77b0dc33590536cefd39264eb5255eeaa09d", "filename": "libgo/go/runtime/crash_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fcrash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -317,3 +317,22 @@ func TestNetpollDeadlock(t *testing.T) {\n \t\tt.Fatalf(\"output does not start with %q:\\n%s\", want, output)\n \t}\n }\n+\n+func TestPanicTraceback(t *testing.T) {\n+\toutput := runTestProg(t, \"testprog\", \"PanicTraceback\")\n+\twant := \"panic: hello\"\n+\tif !strings.HasPrefix(output, want) {\n+\t\tt.Fatalf(\"output does not start with %q:\\n%s\", want, output)\n+\t}\n+\n+\t// Check functions in the traceback.\n+\tfns := []string{\"panic\", \"main.pt1.func1\", \"panic\", \"main.pt2.func1\", \"panic\", \"main.pt2\", \"main.pt1\"}\n+\tfor _, fn := range fns {\n+\t\tre := regexp.MustCompile(`(?m)^` + regexp.QuoteMeta(fn) + `\\(.*\\n`)\n+\t\tidx := re.FindStringIndex(output)\n+\t\tif idx == nil {\n+\t\t\tt.Fatalf(\"expected %q function in traceback:\\n%s\", fn, output)\n+\t\t}\n+\t\toutput = output[idx[1]:]\n+\t}\n+}"}, {"sha": "771b303f6ee39aee0025469353f698d497f736c1", "filename": "libgo/go/runtime/crash_unix_test.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcrash_unix_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"runtime\"\n+\t\"strings\"\n \t\"syscall\"\n \t\"testing\"\n )\n@@ -52,6 +53,18 @@ func TestCrashDumpsAllThreads(t *testing.T) {\n \tcmd = exec.Command(filepath.Join(dir, \"a.exe\"))\n \tcmd = testEnv(cmd)\n \tcmd.Env = append(cmd.Env, \"GOTRACEBACK=crash\")\n+\n+\t// Set GOGC=off. Because of golang.org/issue/10958, the tight\n+\t// loops in the test program are not preemptible. If GC kicks\n+\t// in, it may lock up and prevent main from saying it's ready.\n+\tnewEnv := []string{}\n+\tfor _, s := range cmd.Env {\n+\t\tif !strings.HasPrefix(s, \"GOGC=\") {\n+\t\t\tnewEnv = append(newEnv, s)\n+\t\t}\n+\t}\n+\tcmd.Env = append(newEnv, \"GOGC=off\")\n+\n \tvar outbuf bytes.Buffer\n \tcmd.Stdout = &outbuf\n \tcmd.Stderr = &outbuf\n@@ -137,8 +150,8 @@ func loop(i int, c chan bool) {\n func TestSignalExitStatus(t *testing.T) {\n \ttestenv.MustHaveGoBuild(t)\n \tswitch runtime.GOOS {\n-\tcase \"netbsd\":\n-\t\tt.Skip(\"skipping on NetBSD; see https://golang.org/issue/14063\")\n+\tcase \"netbsd\", \"solaris\":\n+\t\tt.Skipf(\"skipping on %s; see https://golang.org/issue/14063\", runtime.GOOS)\n \t}\n \texe, err := buildTestProg(t, \"testprog\")\n \tif err != nil {"}, {"sha": "4e76600e2070bb8d08b48065f456131998eaebad", "filename": "libgo/go/runtime/export_linux_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fexport_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fexport_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_linux_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -7,3 +7,4 @@\n package runtime\n \n //var NewOSProc0 = newosproc0\n+//var Mincore = mincore"}, {"sha": "07b0a56e09e15cae8d0c966a5cd339fa74442ebe", "filename": "libgo/go/runtime/export_mmap_test.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fexport_mmap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fexport_mmap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_mmap_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+// Export guts for testing.\n+\n+package runtime\n+\n+var Mmap = mmap\n+\n+const ENOMEM = _ENOMEM\n+const MAP_ANON = _MAP_ANON\n+const MAP_PRIVATE = _MAP_PRIVATE"}, {"sha": "18e99366fb3ecce05713ed77bf812fb514b62584", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -351,7 +351,7 @@ func printStackRecord(w io.Writer, stk []uintptr, allFrames bool) {\n \t\t\tname := f.Name()\n \t\t\t// Hide runtime.goexit and any runtime functions at the beginning.\n \t\t\t// This is useful mainly for allocation traces.\n-\t\t\twasPanic = name == \"runtime.panic\"\n+\t\t\twasPanic = name == \"runtime.gopanic\"\n \t\t\tif name == \"runtime.goexit\" || !show && (strings.HasPrefix(name, \"runtime.\") || strings.HasPrefix(name, \"runtime_\")) {\n \t\t\t\tcontinue\n \t\t\t}"}, {"sha": "e384e11eda024d6986e3b13f6f4051701447d340", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -96,7 +96,7 @@ func parseProfile(t *testing.T, bytes []byte, f func(uintptr, []uintptr)) {\n \tif l < 5+3 {\n \t\tt.Logf(\"profile too short: %#x\", val)\n \t\tif badOS[runtime.GOOS] {\n-\t\t\tt.Skipf(\"ignoring failure on %s; see golang.org/issue/6047\", runtime.GOOS)\n+\t\t\tt.Skipf(\"ignoring failure on %s; see golang.org/issue/13841\", runtime.GOOS)\n \t\t\treturn\n \t\t}\n \t\tt.FailNow()\n@@ -171,7 +171,7 @@ func testCPUProfile(t *testing.T, need []string, f func(dur time.Duration)) {\n \t}\n \n \tif badOS[runtime.GOOS] {\n-\t\tt.Skipf(\"ignoring failure on %s; see golang.org/issue/6047\", runtime.GOOS)\n+\t\tt.Skipf(\"ignoring failure on %s; see golang.org/issue/13841\", runtime.GOOS)\n \t\treturn\n \t}\n \t// Ignore the failure if the tests are running in a QEMU-based emulator,\n@@ -421,11 +421,13 @@ func deepStack(depth int) int {\n \treturn deepStack(depth-1) + 1\n }\n \n-// Operating systems that are expected to fail the tests. See issue 6047.\n+// Operating systems that are expected to fail the tests. See issue 13841.\n var badOS = map[string]bool{\n-\t\"darwin\": true,\n-\t\"netbsd\": true,\n-\t\"plan9\":  true,\n+\t\"darwin\":    true,\n+\t\"netbsd\":    true,\n+\t\"plan9\":     true,\n+\t\"dragonfly\": true,\n+\t\"solaris\":   true,\n }\n \n func TestBlockProfile(t *testing.T) {"}, {"sha": "2bd91c1ec03893f3f03857dd0cf6f3659f97de81", "filename": "libgo/go/runtime/runtime-lldb_test.go", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fruntime-lldb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fruntime-lldb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime-lldb_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -0,0 +1,262 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime_test\n+\n+import (\n+\t\"debug/elf\"\n+\t\"debug/macho\"\n+\t\"encoding/binary\"\n+\t\"internal/testenv\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var lldbPath string\n+\n+func checkLldbPython(t *testing.T) {\n+\tcmd := exec.Command(\"lldb\", \"-P\")\n+\tout, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Skipf(\"skipping due to issue running lldb: %v\\n%s\", err, out)\n+\t}\n+\tlldbPath = strings.TrimSpace(string(out))\n+\n+\tcmd = exec.Command(\"/usr/bin/python2.7\", \"-c\", \"import sys;sys.path.append(sys.argv[1]);import lldb; print('go lldb python support')\", lldbPath)\n+\tout, err = cmd.CombinedOutput()\n+\n+\tif err != nil {\n+\t\tt.Skipf(\"skipping due to issue running python: %v\\n%s\", err, out)\n+\t}\n+\tif string(out) != \"go lldb python support\\n\" {\n+\t\tt.Skipf(\"skipping due to lack of python lldb support: %s\", out)\n+\t}\n+\n+\tif runtime.GOOS == \"darwin\" {\n+\t\t// Try to see if we have debugging permissions.\n+\t\tcmd = exec.Command(\"/usr/sbin/DevToolsSecurity\", \"-status\")\n+\t\tout, err = cmd.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Skipf(\"DevToolsSecurity failed: %v\", err)\n+\t\t} else if !strings.Contains(string(out), \"enabled\") {\n+\t\t\tt.Skip(string(out))\n+\t\t}\n+\t\tcmd = exec.Command(\"/usr/bin/groups\")\n+\t\tout, err = cmd.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Skipf(\"groups failed: %v\", err)\n+\t\t} else if !strings.Contains(string(out), \"_developer\") {\n+\t\t\tt.Skip(\"Not in _developer group\")\n+\t\t}\n+\t}\n+}\n+\n+const lldbHelloSource = `\n+package main\n+import \"fmt\"\n+func main() {\n+\tmapvar := make(map[string]string,5)\n+\tmapvar[\"abc\"] = \"def\"\n+\tmapvar[\"ghi\"] = \"jkl\"\n+\tintvar := 42\n+\tptrvar := &intvar\n+\tfmt.Println(\"hi\") // line 10\n+\t_ = ptrvar\n+}\n+`\n+\n+const lldbScriptSource = `\n+import sys\n+sys.path.append(sys.argv[1])\n+import lldb\n+import os\n+\n+TIMEOUT_SECS = 5\n+\n+debugger = lldb.SBDebugger.Create()\n+debugger.SetAsync(True)\n+target = debugger.CreateTargetWithFileAndArch(\"a.exe\", None)\n+if target:\n+  print \"Created target\"\n+  main_bp = target.BreakpointCreateByLocation(\"main.go\", 10)\n+  if main_bp:\n+    print \"Created breakpoint\"\n+  process = target.LaunchSimple(None, None, os.getcwd())\n+  if process:\n+    print \"Process launched\"\n+    listener = debugger.GetListener()\n+    process.broadcaster.AddListener(listener, lldb.SBProcess.eBroadcastBitStateChanged)\n+    while True:\n+      event = lldb.SBEvent()\n+      if listener.WaitForEvent(TIMEOUT_SECS, event):\n+        if lldb.SBProcess.GetRestartedFromEvent(event):\n+          continue\n+        state = process.GetState()\n+        if state in [lldb.eStateUnloaded, lldb.eStateLaunching, lldb.eStateRunning]:\n+          continue\n+      else:\n+        print \"Timeout launching\"\n+      break\n+    if state == lldb.eStateStopped:\n+      for t in process.threads:\n+        if t.GetStopReason() == lldb.eStopReasonBreakpoint:\n+          print \"Hit breakpoint\"\n+          frame = t.GetFrameAtIndex(0)\n+          if frame:\n+            if frame.line_entry:\n+              print \"Stopped at %s:%d\" % (frame.line_entry.file.basename, frame.line_entry.line)\n+            if frame.function:\n+              print \"Stopped in %s\" % (frame.function.name,)\n+            var = frame.FindVariable('intvar')\n+            if var:\n+              print \"intvar = %s\" % (var.GetValue(),)\n+            else:\n+              print \"no intvar\"\n+    else:\n+      print \"Process state\", state\n+    process.Destroy()\n+else:\n+  print \"Failed to create target a.exe\"\n+\n+lldb.SBDebugger.Destroy(debugger)\n+sys.exit()\n+`\n+\n+const expectedLldbOutput = `Created target\n+Created breakpoint\n+Process launched\n+Hit breakpoint\n+Stopped at main.go:10\n+Stopped in main.main\n+intvar = 42\n+`\n+\n+func TestLldbPython(t *testing.T) {\n+\ttestenv.MustHaveGoBuild(t)\n+\tif final := os.Getenv(\"GOROOT_FINAL\"); final != \"\" && runtime.GOROOT() != final {\n+\t\tt.Skip(\"gdb test can fail with GOROOT_FINAL pending\")\n+\t}\n+\n+\tcheckLldbPython(t)\n+\n+\tdir, err := ioutil.TempDir(\"\", \"go-build\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to create temp directory: %v\", err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\n+\tsrc := filepath.Join(dir, \"main.go\")\n+\terr = ioutil.WriteFile(src, []byte(lldbHelloSource), 0644)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to create file: %v\", err)\n+\t}\n+\n+\tcmd := exec.Command(\"go\", \"build\", \"-gcflags\", \"-N -l\", \"-o\", \"a.exe\")\n+\tcmd.Dir = dir\n+\tout, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatalf(\"building source %v\\n%s\", err, out)\n+\t}\n+\n+\tsrc = filepath.Join(dir, \"script.py\")\n+\terr = ioutil.WriteFile(src, []byte(lldbScriptSource), 0755)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to create script: %v\", err)\n+\t}\n+\n+\tcmd = exec.Command(\"/usr/bin/python2.7\", \"script.py\", lldbPath)\n+\tcmd.Dir = dir\n+\tgot, _ := cmd.CombinedOutput()\n+\n+\tif string(got) != expectedLldbOutput {\n+\t\tif strings.Contains(string(got), \"Timeout launching\") {\n+\t\t\tt.Skip(\"Timeout launching\")\n+\t\t}\n+\t\tt.Fatalf(\"Unexpected lldb output:\\n%s\", got)\n+\t}\n+}\n+\n+// Check that aranges are valid even when lldb isn't installed.\n+func TestDwarfAranges(t *testing.T) {\n+\ttestenv.MustHaveGoBuild(t)\n+\tdir, err := ioutil.TempDir(\"\", \"go-build\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to create temp directory: %v\", err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\n+\tsrc := filepath.Join(dir, \"main.go\")\n+\terr = ioutil.WriteFile(src, []byte(lldbHelloSource), 0644)\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to create file: %v\", err)\n+\t}\n+\n+\tcmd := exec.Command(\"go\", \"build\", \"-o\", \"a.exe\")\n+\tcmd.Dir = dir\n+\tout, err := cmd.CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatalf(\"building source %v\\n%s\", err, out)\n+\t}\n+\n+\tfilename := filepath.Join(dir, \"a.exe\")\n+\tif f, err := elf.Open(filename); err == nil {\n+\t\tsect := f.Section(\".debug_aranges\")\n+\t\tif sect == nil {\n+\t\t\tt.Fatal(\"Missing aranges section\")\n+\t\t}\n+\t\tverifyAranges(t, f.ByteOrder, sect.Open())\n+\t} else if f, err := macho.Open(filename); err == nil {\n+\t\tsect := f.Section(\"__debug_aranges\")\n+\t\tif sect == nil {\n+\t\t\tt.Fatal(\"Missing aranges section\")\n+\t\t}\n+\t\tverifyAranges(t, f.ByteOrder, sect.Open())\n+\t} else {\n+\t\tt.Skip(\"Not an elf or macho binary.\")\n+\t}\n+}\n+\n+func verifyAranges(t *testing.T, byteorder binary.ByteOrder, data io.ReadSeeker) {\n+\tvar header struct {\n+\t\tUnitLength  uint32 // does not include the UnitLength field\n+\t\tVersion     uint16\n+\t\tOffset      uint32\n+\t\tAddressSize uint8\n+\t\tSegmentSize uint8\n+\t}\n+\tfor {\n+\t\toffset, err := data.Seek(0, 1)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Seek error: %v\", err)\n+\t\t}\n+\t\tif err = binary.Read(data, byteorder, &header); err == io.EOF {\n+\t\t\treturn\n+\t\t} else if err != nil {\n+\t\t\tt.Fatalf(\"Error reading arange header: %v\", err)\n+\t\t}\n+\t\ttupleSize := int64(header.SegmentSize) + 2*int64(header.AddressSize)\n+\t\tlastTupleOffset := offset + int64(header.UnitLength) + 4 - tupleSize\n+\t\tif lastTupleOffset%tupleSize != 0 {\n+\t\t\tt.Fatalf(\"Invalid arange length %d, (addr %d, seg %d)\", header.UnitLength, header.AddressSize, header.SegmentSize)\n+\t\t}\n+\t\tif _, err = data.Seek(lastTupleOffset, 0); err != nil {\n+\t\t\tt.Fatalf(\"Seek error: %v\", err)\n+\t\t}\n+\t\tbuf := make([]byte, tupleSize)\n+\t\tif n, err := data.Read(buf); err != nil || int64(n) < tupleSize {\n+\t\t\tt.Fatalf(\"Read error: %v\", err)\n+\t\t}\n+\t\tfor _, val := range buf {\n+\t\t\tif val != 0 {\n+\t\t\t\tt.Fatalf(\"Invalid terminator\")\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "3995305052bd176c6afabada01e8da135c7ecab9", "filename": "libgo/go/runtime/runtime_mmap_test.go", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fruntime_mmap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fruntime_mmap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime_mmap_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package runtime_test\n+\n+import (\n+\t\"runtime\"\n+\t\"runtime/internal/sys\"\n+\t\"testing\"\n+)\n+\n+// Test that the error value returned by mmap is positive, as that is\n+// what the code in mem_bsd.go, mem_darwin.go, and mem_linux.go expects.\n+// See the uses of ENOMEM in sysMap in those files.\n+func TestMmapErrorSign(t *testing.T) {\n+\tp := runtime.Mmap(nil, ^uintptr(0)&^(sys.PhysPageSize-1), 0, runtime.MAP_ANON|runtime.MAP_PRIVATE, -1, 0)\n+\n+\t// The runtime.mmap function is nosplit, but t.Errorf is not.\n+\t// Reset the pointer so that we don't get an \"invalid stack\n+\t// pointer\" error from t.Errorf if we call it.\n+\tv := uintptr(p)\n+\tp = nil\n+\n+\tif v != runtime.ENOMEM {\n+\t\tt.Errorf(\"mmap = %v, want %v\", v, runtime.ENOMEM)\n+\t}\n+}"}, {"sha": "a520f56347547852608efebdab88252a2cb73e4e", "filename": "libgo/go/runtime/runtime_test.go", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fruntime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fruntime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -312,13 +312,22 @@ func TestAppendSliceGrowth(t *testing.T) {\n }\n \n func TestGoroutineProfileTrivial(t *testing.T) {\n-\tn1, ok := GoroutineProfile(nil) // should fail, there's at least 1 goroutine\n-\tif n1 < 1 || ok {\n-\t\tt.Fatalf(\"GoroutineProfile(nil) = %d, %v, want >0, false\", n1, ok)\n-\t}\n-\n-\tn2, ok := GoroutineProfile(make([]StackRecord, n1))\n-\tif n2 != n1 || !ok {\n-\t\tt.Fatalf(\"GoroutineProfile(%d) = %d, %v, want %d, true\", n1, n2, ok, n1)\n+\t// Calling GoroutineProfile twice in a row should find the same number of goroutines,\n+\t// but it's possible there are goroutines just about to exit, so we might end up\n+\t// with fewer in the second call. Try a few times; it should converge once those\n+\t// zombies are gone.\n+\tfor i := 0; ; i++ {\n+\t\tn1, ok := GoroutineProfile(nil) // should fail, there's at least 1 goroutine\n+\t\tif n1 < 1 || ok {\n+\t\t\tt.Fatalf(\"GoroutineProfile(nil) = %d, %v, want >0, false\", n1, ok)\n+\t\t}\n+\t\tn2, ok := GoroutineProfile(make([]StackRecord, n1))\n+\t\tif n2 == n1 && ok {\n+\t\t\tbreak\n+\t\t}\n+\t\tt.Logf(\"GoroutineProfile(%d) = %d, %v, want %d, true\", n1, n2, ok, n1)\n+\t\tif i >= 10 {\n+\t\t\tt.Fatalf(\"GoroutineProfile not converging\")\n+\t\t}\n \t}\n }"}, {"sha": "64abd57d28c84a3484c25878a71b26b393592410", "filename": "libgo/go/runtime/string_test.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fstring_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Fstring_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstring_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -225,3 +225,18 @@ func TestRangeStringCast(t *testing.T) {\n \t\tt.Fatalf(\"want 0 allocs, got %v\", n)\n \t}\n }\n+\n+func TestString2Slice(t *testing.T) {\n+\t// Make sure we don't return slices that expose\n+\t// an unzeroed section of stack-allocated temp buf\n+\t// between len and cap.  See issue 14232.\n+\ts := \"foo\u017e\"\n+\tb := ([]byte)(s)\n+\tif cap(b) != 5 {\n+\t\tt.Errorf(\"want cap of 5, got %d\", cap(b))\n+\t}\n+\tr := ([]rune)(s)\n+\tif cap(r) != 4 {\n+\t\tt.Errorf(\"want cap of 4, got %d\", cap(r))\n+\t}\n+}"}, {"sha": "73fbf6224dfc54fdbb66b19579d079c43d5ec9fd", "filename": "libgo/go/runtime/testdata/testprog/deadlock.go", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fdeadlock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fdeadlock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fdeadlock.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -29,7 +29,7 @@ func init() {\n \tregister(\"GoexitInPanic\", GoexitInPanic)\n \tregister(\"PanicAfterGoexit\", PanicAfterGoexit)\n \tregister(\"RecoveredPanicAfterGoexit\", RecoveredPanicAfterGoexit)\n-\n+\tregister(\"PanicTraceback\", PanicTraceback)\n }\n \n func SimpleDeadlock() {\n@@ -171,3 +171,21 @@ func RecoveredPanicAfterGoexit() {\n \t}()\n \truntime.Goexit()\n }\n+\n+func PanicTraceback() {\n+\tpt1()\n+}\n+\n+func pt1() {\n+\tdefer func() {\n+\t\tpanic(\"panic pt1\")\n+\t}()\n+\tpt2()\n+}\n+\n+func pt2() {\n+\tdefer func() {\n+\t\tpanic(\"panic pt2\")\n+\t}()\n+\tpanic(\"hello\")\n+}"}, {"sha": "8ec34fd343bee1332934b676c9b33a598b9c6afa", "filename": "libgo/go/sync/waitgroup_test.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fsync%2Fwaitgroup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fgo%2Fsync%2Fwaitgroup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fwaitgroup_test.go?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -128,13 +128,16 @@ func TestWaitGroupMisuse3(t *testing.T) {\n \t\t}\n \t}()\n \tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(4))\n-\tdone := make(chan interface{}, 1)\n+\tdone := make(chan interface{}, 2)\n \t// The detection is opportunistically, so we want it to panic\n \t// at least in one run out of a million.\n \tfor i := 0; i < 1e6; i++ {\n \t\tvar wg WaitGroup\n \t\twg.Add(1)\n \t\tgo func() {\n+\t\t\tdefer func() {\n+\t\t\t\tdone <- recover()\n+\t\t\t}()\n \t\t\twg.Done()\n \t\t}()\n \t\tgo func() {\n@@ -150,8 +153,10 @@ func TestWaitGroupMisuse3(t *testing.T) {\n \t\t\twg.Wait()\n \t\t}()\n \t\twg.Wait()\n-\t\tif err := <-done; err != nil {\n-\t\t\tpanic(err)\n+\t\tfor j := 0; j < 2; j++ {\n+\t\t\tif err := <-done; err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n \t\t}\n \t}\n \tt.Fatal(\"Should panic\")"}, {"sha": "61591eb975240f1d6fc7b16cf901871b6f780275", "filename": "libgo/runtime/go-string-to-byte-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fruntime%2Fgo-string-to-byte-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43414a5dd3a9b9b02bc675e1c33140021c3848aa/libgo%2Fruntime%2Fgo-string-to-byte-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-string-to-byte-array.c?ref=43414a5dd3a9b9b02bc675e1c33140021c3848aa", "patch": "@@ -23,6 +23,6 @@ __go_string_to_byte_array (String str)\n     __builtin_memset (data + str.len, 0, cap - (uintptr) str.len);\n   ret.__values = (void *) data;\n   ret.__count = str.len;\n-  ret.__capacity = (intgo) cap;\n+  ret.__capacity = str.len;\n   return ret;\n }"}]}