{"sha": "53cc7066b87d1dc7e804721b3afbc1b5cab2a17b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNjYzcwNjZiODdkMWRjN2U4MDQ3MjFiM2FmYmMxYjVjYWIyYTE3Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-05T14:06:45Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-05T14:06:45Z"}, "message": "(__objc_init_class_tables): Surround sarray access with mutex lock/unlock.\n\n(__objc_add_class_to_hash, objc_lookup_class): Likewise.\n(objc_get_class, objc_get_next_class): Likweise.\n(__objc_resolve_class_links, class_pose_as) Likewise.\n\nFrom-SVN: r11441", "tree": {"sha": "260869f00c13ccddf7c9f63ba68a428406ff7f05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/260869f00c13ccddf7c9f63ba68a428406ff7f05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53cc7066b87d1dc7e804721b3afbc1b5cab2a17b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53cc7066b87d1dc7e804721b3afbc1b5cab2a17b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53cc7066b87d1dc7e804721b3afbc1b5cab2a17b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53cc7066b87d1dc7e804721b3afbc1b5cab2a17b/comments", "author": null, "committer": null, "parents": [{"sha": "625fc99df2a41d525eabe892872a1ef30da83a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/625fc99df2a41d525eabe892872a1ef30da83a5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/625fc99df2a41d525eabe892872a1ef30da83a5c"}], "stats": {"total": 37, "additions": 33, "deletions": 4}, "files": [{"sha": "8058d09f928987827d2fd66654bcbd82320a4334", "filename": "gcc/objc/class.c", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53cc7066b87d1dc7e804721b3afbc1b5cab2a17b/gcc%2Fobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53cc7066b87d1dc7e804721b3afbc1b5cab2a17b/gcc%2Fobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fclass.c?ref=53cc7066b87d1dc7e804721b3afbc1b5cab2a17b", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime class related functions\n-   Copyright (C) 1993, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup and Dennis Glatting.\n \n This file is part of GNU CC.\n@@ -27,16 +27,16 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"sarray.h\"\n \n /* The table of classname->class.  Used for objc_lookup_class and friends */\n-static cache_ptr __objc_class_hash = 0;\n+static cache_ptr __objc_class_hash = 0;                 /* !T:MUTEX */\n \n /* This is a hook which is called by objc_get_class and \n    objc_lookup_class if the runtime is not able to find the class.\n    This may e.g. try to load in the class using dynamic loading */\n-Class (*_objc_lookup_class)(const char* name) = 0;\n+Class (*_objc_lookup_class)(const char* name) = 0;      /* !T:SAFE */\n \n \n /* True when class links has been resolved */     \n-BOOL __objc_class_links_resolved = NO;\n+BOOL __objc_class_links_resolved = NO;                  /* !T:UNUSED */\n \n \n /* Initial number of buckets size of class hash table. */\n@@ -49,10 +49,14 @@ void __objc_init_class_tables()\n   if(__objc_class_hash)\n     return;\n \n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n   __objc_class_hash\n     =  hash_new (CLASS_HASH_SIZE,\n \t\t (hash_func_type) hash_string,\n \t\t (compare_func_type) compare_strings);\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n }  \n \n /* This function adds a class to the class hash table, and assigns the \n@@ -62,6 +66,8 @@ __objc_add_class_to_hash(Class class)\n {\n   Class h_class;\n \n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n   /* make sure the table is there */\n   assert(__objc_class_hash);\n \n@@ -82,6 +88,8 @@ __objc_add_class_to_hash(Class class)\n       ++class_number;\n       hash_add (&__objc_class_hash, class->name, class);\n     }\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n }\n \n /* Get the class object for the class named NAME.  If NAME does not\n@@ -91,11 +99,15 @@ Class objc_lookup_class (const char* name)\n {\n   Class class;\n \n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n   /* Make sure the class hash table exists.  */\n   assert (__objc_class_hash);\n \n   class = hash_value_for_key (__objc_class_hash, name);\n \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n   if (class)\n     return class;\n \n@@ -113,11 +125,15 @@ objc_get_class (const char *name)\n {\n   Class class;\n \n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n   /* Make sure the class hash table exists.  */\n   assert (__objc_class_hash);\n \n   class = hash_value_for_key (__objc_class_hash, name);\n \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n   if (class)\n     return class;\n \n@@ -149,11 +165,16 @@ objc_get_meta_class(const char *name)\n Class\n objc_next_class(void **enum_state)\n {\n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n   /* make sure the table is there */\n   assert(__objc_class_hash);\n \n   *(node_ptr*)enum_state = \n     hash_next(__objc_class_hash, *(node_ptr*)enum_state);\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n   if (*(node_ptr*)enum_state)\n     return (*(node_ptr*)enum_state)->value;\n   return (Class)0;\n@@ -169,6 +190,8 @@ void __objc_resolve_class_links()\n \n   assert(object_class);\n \n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n   /* Assign subclass links */\n   for (node = hash_next (__objc_class_hash, NULL); node;\n        node = hash_next (__objc_class_hash, node))\n@@ -234,6 +257,8 @@ void __objc_resolve_class_links()\n             sub_class->class_pointer->super_class = class1->class_pointer;\n         }\n     }\n+\n+  objc_mutex_unlock(__objc_runtime_mutex);\n }\n \n \n@@ -307,6 +332,8 @@ class_pose_as (Class impostor, Class super_class)\n      what the keys of the hashtable is, change all values that are\n      superclass into impostor. */\n \n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n   for (node = hash_next (__objc_class_hash, NULL); node;\n        node = hash_next (__objc_class_hash, node))\n     {\n@@ -317,6 +344,8 @@ class_pose_as (Class impostor, Class super_class)\n \t}\n     }      \n \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+\n   /* next, we update the dispatch tables... */\n   __objc_update_dispatch_table_for_class (CLASSOF (impostor));\n   __objc_update_dispatch_table_for_class (impostor);"}]}