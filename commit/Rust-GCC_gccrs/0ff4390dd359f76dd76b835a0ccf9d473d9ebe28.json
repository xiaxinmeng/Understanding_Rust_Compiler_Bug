{"sha": "0ff4390dd359f76dd76b835a0ccf9d473d9ebe28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZmNDM5MGRkMzU5Zjc2ZGQ3NmI4MzVhMGNjZjlkNDczZDllYmUyOA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2013-01-10T08:15:07Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2013-01-10T08:15:07Z"}, "message": "re PR target/55718 (ICE in gen_reg_rtx, at emit-rtl.c:866)\n\n2013-01-10  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\tPR target/55718\n\t* config/s390/s390.c (s390_symref_operand_p)\n\t(s390_loadrelative_operand_p): Merge the two functions.\n\t(s390_check_qrst_address, print_operand_address): Add parameters\n\tto s390_loadrelative_operand_p invokation.\n\t(s390_check_symref_alignment): Use s390_loadrelative_operand_p.\n\t(s390_reload_larl_operand, s390_secondary_reload): Use\n\ts390_loadrelative_operand_p instead of s390_symref_operand_p.\n\t(legitimize_pic_address): Handle @GOTENT and @PLT + addend.\n\nFrom-SVN: r195078", "tree": {"sha": "fa3c3483c08a426cda18c0b3dce54fc7407e979f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa3c3483c08a426cda18c0b3dce54fc7407e979f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ff4390dd359f76dd76b835a0ccf9d473d9ebe28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff4390dd359f76dd76b835a0ccf9d473d9ebe28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff4390dd359f76dd76b835a0ccf9d473d9ebe28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff4390dd359f76dd76b835a0ccf9d473d9ebe28/comments", "author": null, "committer": null, "parents": [{"sha": "01a3a3242217431b8707735e4d2510a530a28eae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01a3a3242217431b8707735e4d2510a530a28eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01a3a3242217431b8707735e4d2510a530a28eae"}], "stats": {"total": 515, "additions": 270, "deletions": 245}, "files": [{"sha": "9657caff5d42952dc34bc105b4c989f1733a1e1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4390dd359f76dd76b835a0ccf9d473d9ebe28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4390dd359f76dd76b835a0ccf9d473d9ebe28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ff4390dd359f76dd76b835a0ccf9d473d9ebe28", "patch": "@@ -1,3 +1,15 @@\n+2013-01-10  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\tPR target/55718\n+\t* config/s390/s390.c (s390_symref_operand_p)\n+\t(s390_loadrelative_operand_p): Merge the two functions.\n+\t(s390_check_qrst_address, print_operand_address): Add parameters\n+\tto s390_loadrelative_operand_p invokation.\n+\t(s390_check_symref_alignment): Use s390_loadrelative_operand_p.\n+\t(s390_reload_larl_operand, s390_secondary_reload): Use\n+\ts390_loadrelative_operand_p instead of s390_symref_operand_p.\n+\t(legitimize_pic_address): Handle @GOTENT and @PLT + addend.\n+\n 2013-01-09  Mike Stump  <mikestump@comcast.net>\n \n \t* dse.c (record_store): Remove unnecessary assert."}, {"sha": "e068cbf059cffa96121fa325643012afe14e44cb", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 229, "deletions": 245, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4390dd359f76dd76b835a0ccf9d473d9ebe28/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4390dd359f76dd76b835a0ccf9d473d9ebe28/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0ff4390dd359f76dd76b835a0ccf9d473d9ebe28", "patch": "@@ -2148,13 +2148,17 @@ s390_legitimate_address_without_index_p (rtx op)\n }\n \n \n-/* Return true if ADDR is of kind symbol_ref or symbol_ref + const_int\n-   and return these parts in SYMREF and ADDEND.  You can pass NULL in\n-   SYMREF and/or ADDEND if you are not interested in these values.\n-   Literal pool references are *not* considered symbol references.  */\n+/* Return TRUE if ADDR is an operand valid for a load/store relative\n+   instruction.  Be aware that the alignment of the operand needs to\n+   be checked separately.\n+   Valid addresses are single references or a sum of a reference and a\n+   constant integer. Return these parts in SYMREF and ADDEND.  You can\n+   pass NULL in REF and/or ADDEND if you are not interested in these\n+   values.  Literal pool references are *not* considered symbol\n+   references.  */\n \n static bool\n-s390_symref_operand_p (rtx addr, rtx *symref, HOST_WIDE_INT *addend)\n+s390_loadrelative_operand_p (rtx addr, rtx *symref, HOST_WIDE_INT *addend)\n {\n   HOST_WIDE_INT tmpaddend = 0;\n \n@@ -2163,43 +2167,26 @@ s390_symref_operand_p (rtx addr, rtx *symref, HOST_WIDE_INT *addend)\n \n   if (GET_CODE (addr) == PLUS)\n     {\n-      if (GET_CODE (XEXP (addr, 0)) == SYMBOL_REF\n-\t  && !CONSTANT_POOL_ADDRESS_P (XEXP (addr, 0))\n-\t  && CONST_INT_P (XEXP (addr, 1)))\n-\t{\n-\t  tmpaddend = INTVAL (XEXP (addr, 1));\n-\t  addr = XEXP (addr, 0);\n-\t}\n-      else\n+      if (!CONST_INT_P (XEXP (addr, 1)))\n \treturn false;\n-    }\n-  else\n-    if (GET_CODE (addr) != SYMBOL_REF || CONSTANT_POOL_ADDRESS_P (addr))\n-\treturn false;\n-\n-  if (symref)\n-    *symref = addr;\n-  if (addend)\n-    *addend = tmpaddend;\n \n-  return true;\n-}\n-\n-/* Return TRUE if ADDR is an operand valid for a load/store relative\n-   instructions.  Be aware that the alignment of the operand needs to\n-   be checked separately.  */\n-static bool\n-s390_loadrelative_operand_p (rtx addr)\n-{\n-  if (GET_CODE (addr) == CONST)\n-    addr = XEXP (addr, 0);\n+      tmpaddend = INTVAL (XEXP (addr, 1));\n+      addr = XEXP (addr, 0);\n+    }\n \n-  /* Enable load relative for symbol@GOTENT.  */\n-  if (GET_CODE (addr) == UNSPEC\n-      && XINT (addr, 1) == UNSPEC_GOTENT)\n-    return true;\n+  if ((GET_CODE (addr) == SYMBOL_REF && !CONSTANT_POOL_ADDRESS_P (addr))\n+      || (GET_CODE (addr) == UNSPEC\n+\t  && (XINT (addr, 1) == UNSPEC_GOTENT\n+\t      || (TARGET_CPU_ZARCH && XINT (addr, 1) == UNSPEC_PLT))))\n+    {\n+      if (symref)\n+\t*symref = addr;\n+      if (addend)\n+\t*addend = tmpaddend;\n \n-  return s390_symref_operand_p (addr, NULL, NULL);\n+      return true;\n+    }\n+  return false;\n }\n \n /* Return true if the address in OP is valid for constraint letter C\n@@ -2215,7 +2202,7 @@ s390_check_qrst_address (char c, rtx op, bool lit_pool_ok)\n \n   /* This check makes sure that no symbolic address (except literal\n      pool references) are accepted by the R or T constraints.  */\n-  if (s390_loadrelative_operand_p (op))\n+  if (s390_loadrelative_operand_p (op, NULL, NULL))\n     return 0;\n \n   /* Ensure literal pool references are only accepted if LIT_POOL_OK.  */\n@@ -3022,18 +3009,21 @@ s390_check_symref_alignment (rtx addr, HOST_WIDE_INT alignment)\n   HOST_WIDE_INT addend;\n   rtx symref;\n \n-  /* Accept symbol@GOTENT with pointer size alignment.  */\n-  if (GET_CODE (addr) == CONST\n-      && GET_CODE (XEXP (addr, 0)) == UNSPEC\n-      && XINT (XEXP (addr, 0), 1) == UNSPEC_GOTENT\n-      && alignment <= UNITS_PER_LONG)\n-    return true;\n+  if (!s390_loadrelative_operand_p (addr, &symref, &addend))\n+    return false;\n \n-  if (!s390_symref_operand_p (addr, &symref, &addend))\n+  if (addend & (alignment - 1))\n     return false;\n \n-  return (!SYMBOL_REF_NOT_NATURALLY_ALIGNED_P (symref)\n-\t  && !(addend & (alignment - 1)));\n+  if (GET_CODE (symref) == SYMBOL_REF\n+      && !SYMBOL_REF_NOT_NATURALLY_ALIGNED_P (symref))\n+    return true;\n+\n+  if (GET_CODE (symref) == UNSPEC\n+      && alignment <= UNITS_PER_LONG)\n+    return true;\n+\n+  return false;\n }\n \n /* ADDR is moved into REG using larl.  If ADDR isn't a valid larl\n@@ -3046,7 +3036,7 @@ s390_reload_larl_operand (rtx reg, rtx addr, rtx scratch)\n   HOST_WIDE_INT addend;\n   rtx symref;\n \n-  if (!s390_symref_operand_p (addr, &symref, &addend))\n+  if (!s390_loadrelative_operand_p (addr, &symref, &addend))\n     gcc_unreachable ();\n \n   if (!(addend & 1))\n@@ -3132,7 +3122,7 @@ s390_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n       /* On z10 several optimizer steps may generate larl operands with\n \t an odd addend.  */\n       if (in_p\n-\t  && s390_symref_operand_p (x, &symref, &offset)\n+\t  && s390_loadrelative_operand_p (x, &symref, &offset)\n \t  && mode == Pmode\n \t  && !SYMBOL_REF_ALIGN1_P (symref)\n \t  && (offset & 1) == 1)\n@@ -3144,7 +3134,7 @@ s390_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t or if the symref addend of a SI or DI move is not aligned to the\n \t width of the access.  */\n       if (MEM_P (x)\n-\t  && s390_symref_operand_p (XEXP (x, 0), NULL, NULL)\n+\t  && s390_loadrelative_operand_p (XEXP (x, 0), NULL, NULL)\n \t  && (mode == QImode || mode == TImode || FLOAT_MODE_P (mode)\n \t      || (!TARGET_ZARCH && mode == DImode)\n \t      || ((mode == HImode || mode == SImode || mode == DImode)\n@@ -3419,52 +3409,125 @@ rtx\n legitimize_pic_address (rtx orig, rtx reg)\n {\n   rtx addr = orig;\n+  rtx addend = const0_rtx;\n   rtx new_rtx = orig;\n-  rtx base;\n \n   gcc_assert (!TLS_SYMBOLIC_CONST (addr));\n \n-  if (GET_CODE (addr) == LABEL_REF\n-      || (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (addr)))\n+  if (GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n+\n+  if (GET_CODE (addr) == PLUS)\n     {\n-      /* This is a local symbol.  */\n-      if (TARGET_CPU_ZARCH && larl_operand (addr, VOIDmode))\n-        {\n-          /* Access local symbols PC-relative via LARL.\n-             This is the same as in the non-PIC case, so it is\n-             handled automatically ...  */\n-        }\n+      addend = XEXP (addr, 1);\n+      addr = XEXP (addr, 0);\n+    }\n+\n+  if ((GET_CODE (addr) == LABEL_REF\n+       || (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (addr))\n+       || (GET_CODE (addr) == UNSPEC &&\n+\t   (XINT (addr, 1) == UNSPEC_GOTENT\n+\t    || (TARGET_CPU_ZARCH && XINT (addr, 1) == UNSPEC_PLT))))\n+      && GET_CODE (addend) == CONST_INT)\n+    {\n+      /* This can be locally addressed.  */\n+\n+      /* larl_operand requires UNSPECs to be wrapped in a const rtx.  */\n+      rtx const_addr = (GET_CODE (addr) == UNSPEC ?\n+\t\t\tgen_rtx_CONST (Pmode, addr) : addr);\n+\n+      if (TARGET_CPU_ZARCH\n+\t  && larl_operand (const_addr, VOIDmode)\n+\t  && INTVAL (addend) < (HOST_WIDE_INT)1 << 31\n+\t  && INTVAL (addend) >= -((HOST_WIDE_INT)1 << 31))\n+\t{\n+\t  if (INTVAL (addend) & 1)\n+\t    {\n+\t      /* LARL can't handle odd offsets, so emit a pair of LARL\n+\t\t and LA.  */\n+\t      rtx temp = reg? reg : gen_reg_rtx (Pmode);\n+\n+\t      if (!DISP_IN_RANGE (INTVAL (addend)))\n+\t\t{\n+\t\t  HOST_WIDE_INT even = INTVAL (addend) - 1;\n+\t\t  addr = gen_rtx_PLUS (Pmode, addr, GEN_INT (even));\n+\t\t  addr = gen_rtx_CONST (Pmode, addr);\n+\t\t  addend = const1_rtx;\n+\t\t}\n+\n+\t      emit_move_insn (temp, addr);\n+\t      new_rtx = gen_rtx_PLUS (Pmode, temp, addend);\n+\n+\t      if (reg != 0)\n+\t\t{\n+\t\t  s390_load_address (reg, new_rtx);\n+\t\t  new_rtx = reg;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If the offset is even, we can just use LARL.  This\n+\t\t will happen automatically.  */\n+\t    }\n+\t}\n       else\n-        {\n-          /* Access local symbols relative to the GOT.  */\n+\t{\n+\t  /* No larl - Access local symbols relative to the GOT.  */\n \n-          rtx temp = reg? reg : gen_reg_rtx (Pmode);\n+\t  rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n \t  if (reload_in_progress || reload_completed)\n \t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n-          addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTOFF);\n-          addr = gen_rtx_CONST (Pmode, addr);\n-          addr = force_const_mem (Pmode, addr);\n+\t  addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTOFF);\n+\t  if (addend != const0_rtx)\n+\t    addr = gen_rtx_PLUS (Pmode, addr, addend);\n+\t  addr = gen_rtx_CONST (Pmode, addr);\n+\t  addr = force_const_mem (Pmode, addr);\n \t  emit_move_insn (temp, addr);\n \n-          new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n-          if (reg != 0)\n-            {\n-              s390_load_address (reg, new_rtx);\n-              new_rtx = reg;\n-            }\n-        }\n+\t  new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n+\t  if (reg != 0)\n+\t    {\n+\t      s390_load_address (reg, new_rtx);\n+\t      new_rtx = reg;\n+\t    }\n+\t}\n     }\n-  else if (GET_CODE (addr) == SYMBOL_REF)\n+  else if (GET_CODE (addr) == SYMBOL_REF && addend == const0_rtx)\n     {\n+      /* A non-local symbol reference without addend.\n+\n+\t The symbol ref is wrapped into an UNSPEC to make sure the\n+\t proper operand modifier (@GOT or @GOTENT) will be emitted.\n+\t This will tell the linker to put the symbol into the GOT.\n+\n+\t Additionally the code dereferencing the GOT slot is emitted here.\n+\n+\t An addend to the symref needs to be added afterwards.\n+\t legitimize_pic_address calls itself recursively to handle\n+\t that case.  So no need to do it here.  */\n+\n       if (reg == 0)\n         reg = gen_reg_rtx (Pmode);\n \n-      if (flag_pic == 1)\n+      if (TARGET_Z10)\n+\t{\n+\t  /* Use load relative if possible.\n+\t     lgrl <target>, sym@GOTENT  */\n+\t  new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTENT);\n+\t  new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+\t  new_rtx = gen_const_mem (GET_MODE (reg), new_rtx);\n+\n+\t  emit_move_insn (reg, new_rtx);\n+\t  new_rtx = reg;\n+\t}\n+      else if (flag_pic == 1)\n         {\n-          /* Assume GOT offset < 4k.  This is handled the same way\n-             in both 31- and 64-bit code (@GOT).  */\n+          /* Assume GOT offset is a valid displacement operand (< 4k\n+             or < 512k with z990).  This is handled the same way in\n+             both 31- and 64-bit code (@GOT).\n+             lg <target>, sym@GOT(r12)  */\n \n \t  if (reload_in_progress || reload_completed)\n \t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n@@ -3479,7 +3542,9 @@ legitimize_pic_address (rtx orig, rtx reg)\n       else if (TARGET_CPU_ZARCH)\n         {\n           /* If the GOT offset might be >= 4k, we determine the position\n-             of the GOT entry via a PC-relative LARL (@GOTENT).  */\n+             of the GOT entry via a PC-relative LARL (@GOTENT).\n+\t     larl temp, sym@GOTENT\n+             lg   <target>, 0(temp) */\n \n           rtx temp = reg ? reg : gen_reg_rtx (Pmode);\n \n@@ -3488,21 +3553,21 @@ legitimize_pic_address (rtx orig, rtx reg)\n \n           new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTENT);\n           new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+\t  emit_move_insn (temp, new_rtx);\n \n-\t  if (!TARGET_Z10)\n-\t    {\n-\t      emit_move_insn (temp, new_rtx);\n-\t      new_rtx = gen_const_mem (Pmode, temp);\n-\t    }\n-\t  else\n-\t    new_rtx = gen_const_mem (GET_MODE (reg), new_rtx);\n+\t  new_rtx = gen_const_mem (Pmode, temp);\n           emit_move_insn (reg, new_rtx);\n+\n           new_rtx = reg;\n         }\n       else\n         {\n           /* If the GOT offset might be >= 4k, we have to load it\n-             from the literal pool (@GOT).  */\n+             from the literal pool (@GOT).\n+\n+\t     lg temp, lit-litbase(r13)\n+             lg <target>, 0(temp)\n+\t     lit:  .long sym@GOT  */\n \n           rtx temp = reg ? reg : gen_reg_rtx (Pmode);\n \n@@ -3523,175 +3588,94 @@ legitimize_pic_address (rtx orig, rtx reg)\n           new_rtx = reg;\n         }\n     }\n-  else\n+  else if (GET_CODE (addr) == UNSPEC && GET_CODE (addend) == CONST_INT)\n     {\n-      if (GET_CODE (addr) == CONST)\n+      gcc_assert (XVECLEN (addr, 0) == 1);\n+      switch (XINT (addr, 1))\n \t{\n-\t  addr = XEXP (addr, 0);\n-\t  if (GET_CODE (addr) == UNSPEC)\n-\t    {\n-\t      gcc_assert (XVECLEN (addr, 0) == 1);\n-              switch (XINT (addr, 1))\n-                {\n-                  /* If someone moved a GOT-relative UNSPEC\n-                     out of the literal pool, force them back in.  */\n-                  case UNSPEC_GOTOFF:\n-                  case UNSPEC_PLTOFF:\n-                    new_rtx = force_const_mem (Pmode, orig);\n-                    break;\n-\n-                  /* @GOT is OK as is if small.  */\n-\t\t  case UNSPEC_GOT:\n-\t\t    if (flag_pic == 2)\n-\t\t      new_rtx = force_const_mem (Pmode, orig);\n-\t\t    break;\n-\n-                  /* @GOTENT is OK as is.  */\n-                  case UNSPEC_GOTENT:\n-                    break;\n-\n-                  /* @PLT is OK as is on 64-bit, must be converted to\n-                     GOT-relative @PLTOFF on 31-bit.  */\n-                  case UNSPEC_PLT:\n-                    if (!TARGET_CPU_ZARCH)\n-                      {\n-                        rtx temp = reg? reg : gen_reg_rtx (Pmode);\n-\n-\t\t\tif (reload_in_progress || reload_completed)\n-\t\t\t  df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n-\n-                        addr = XVECEXP (addr, 0, 0);\n-                        addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr),\n-\t\t\t\t\t       UNSPEC_PLTOFF);\n-                        addr = gen_rtx_CONST (Pmode, addr);\n-                        addr = force_const_mem (Pmode, addr);\n-\t                emit_move_insn (temp, addr);\n-\n-                        new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n-                        if (reg != 0)\n-                          {\n-                            s390_load_address (reg, new_rtx);\n-                            new_rtx = reg;\n-                          }\n-                      }\n-                    break;\n-\n-                  /* Everything else cannot happen.  */\n-                  default:\n-                    gcc_unreachable ();\n-                }\n-\t    }\n-\t  else\n-\t    gcc_assert (GET_CODE (addr) == PLUS);\n-\t}\n-      if (GET_CODE (addr) == PLUS)\n-\t{\n-\t  rtx op0 = XEXP (addr, 0), op1 = XEXP (addr, 1);\n-\n-\t  gcc_assert (!TLS_SYMBOLIC_CONST (op0));\n-\t  gcc_assert (!TLS_SYMBOLIC_CONST (op1));\n-\n-\t  /* Check first to see if this is a constant offset\n-             from a local symbol reference.  */\n-\t  if ((GET_CODE (op0) == LABEL_REF\n-\t\t|| (GET_CODE (op0) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (op0)))\n-\t      && GET_CODE (op1) == CONST_INT)\n-\t    {\n-              if (TARGET_CPU_ZARCH\n-\t\t  && larl_operand (op0, VOIDmode)\n-\t\t  && INTVAL (op1) < (HOST_WIDE_INT)1 << 31\n-\t\t  && INTVAL (op1) >= -((HOST_WIDE_INT)1 << 31))\n-                {\n-                  if (INTVAL (op1) & 1)\n-                    {\n-                      /* LARL can't handle odd offsets, so emit a\n-                         pair of LARL and LA.  */\n-                      rtx temp = reg? reg : gen_reg_rtx (Pmode);\n-\n-                      if (!DISP_IN_RANGE (INTVAL (op1)))\n-                        {\n-                          HOST_WIDE_INT even = INTVAL (op1) - 1;\n-                          op0 = gen_rtx_PLUS (Pmode, op0, GEN_INT (even));\n-\t\t\t  op0 = gen_rtx_CONST (Pmode, op0);\n-                          op1 = const1_rtx;\n-                        }\n-\n-                      emit_move_insn (temp, op0);\n-                      new_rtx = gen_rtx_PLUS (Pmode, temp, op1);\n-\n-                      if (reg != 0)\n-                        {\n-                          s390_load_address (reg, new_rtx);\n-                          new_rtx = reg;\n-                        }\n-                    }\n-                  else\n-                    {\n-                      /* If the offset is even, we can just use LARL.\n-                         This will happen automatically.  */\n-                    }\n-                }\n-              else\n-                {\n-                  /* Access local symbols relative to the GOT.  */\n-\n-                  rtx temp = reg? reg : gen_reg_rtx (Pmode);\n-\n-\t\t  if (reload_in_progress || reload_completed)\n-\t\t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n-\n-                  addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0),\n-\t\t\t\t\t UNSPEC_GOTOFF);\n-                  addr = gen_rtx_PLUS (Pmode, addr, op1);\n-                  addr = gen_rtx_CONST (Pmode, addr);\n-                  addr = force_const_mem (Pmode, addr);\n-\t\t  emit_move_insn (temp, addr);\n-\n-                  new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n-                  if (reg != 0)\n-                    {\n-                      s390_load_address (reg, new_rtx);\n-                      new_rtx = reg;\n-                    }\n-                }\n-\t    }\n-\n-          /* Now, check whether it is a GOT relative symbol plus offset\n-             that was pulled out of the literal pool.  Force it back in.  */\n+\t  /* These address symbols (or PLT slots) relative to the GOT\n+\t     (not GOT slots!).  In general this will exceed the\n+\t     displacement range so these value belong into the literal\n+\t     pool.  */\n+\tcase UNSPEC_GOTOFF:\n+\tcase UNSPEC_PLTOFF:\n+\t  new_rtx = force_const_mem (Pmode, orig);\n+\t  break;\n \n-\t  else if (GET_CODE (op0) == UNSPEC\n-\t           && GET_CODE (op1) == CONST_INT\n-\t           && XINT (op0, 1) == UNSPEC_GOTOFF)\n-            {\n-\t      gcc_assert (XVECLEN (op0, 0) == 1);\n+\t  /* For -fPIC the GOT size might exceed the displacement\n+\t     range so make sure the value is in the literal pool.  */\n+\tcase UNSPEC_GOT:\n+\t  if (flag_pic == 2)\n+\t    new_rtx = force_const_mem (Pmode, orig);\n+\t  break;\n \n-              new_rtx = force_const_mem (Pmode, orig);\n-            }\n+\t  /* For @GOTENT larl is used.  This is handled like local\n+\t     symbol refs.  */\n+\tcase UNSPEC_GOTENT:\n+\t  gcc_unreachable ();\n+\t  break;\n \n-          /* Otherwise, compute the sum.  */\n-\t  else\n+\t  /* @PLT is OK as is on 64-bit, must be converted to\n+\t     GOT-relative @PLTOFF on 31-bit.  */\n+\tcase UNSPEC_PLT:\n+\t  if (!TARGET_CPU_ZARCH)\n \t    {\n-\t      base = legitimize_pic_address (XEXP (addr, 0), reg);\n-\t      new_rtx  = legitimize_pic_address (XEXP (addr, 1),\n-\t\t\t\t\t     base == reg ? NULL_RTX : reg);\n-\t      if (GET_CODE (new_rtx) == CONST_INT)\n-\t\tnew_rtx = plus_constant (Pmode, base, INTVAL (new_rtx));\n-\t      else\n+\t      rtx temp = reg? reg : gen_reg_rtx (Pmode);\n+\n+\t      if (reload_in_progress || reload_completed)\n+\t\tdf_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n+\n+\t      addr = XVECEXP (addr, 0, 0);\n+\t      addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr),\n+\t\t\t\t     UNSPEC_PLTOFF);\n+\t      if (addend != const0_rtx)\n+\t\taddr = gen_rtx_PLUS (Pmode, addr, addend);\n+\t      addr = gen_rtx_CONST (Pmode, addr);\n+\t      addr = force_const_mem (Pmode, addr);\n+\t      emit_move_insn (temp, addr);\n+\n+\t      new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n+\t      if (reg != 0)\n \t\t{\n-\t\t  if (GET_CODE (new_rtx) == PLUS && CONSTANT_P (XEXP (new_rtx, 1)))\n-\t\t    {\n-\t\t      base = gen_rtx_PLUS (Pmode, base, XEXP (new_rtx, 0));\n-\t\t      new_rtx = XEXP (new_rtx, 1);\n-\t\t    }\n-\t\t  new_rtx = gen_rtx_PLUS (Pmode, base, new_rtx);\n+\t\t  s390_load_address (reg, new_rtx);\n+\t\t  new_rtx = reg;\n \t\t}\n+\t    }\n+\t  else\n+\t    /* On 64 bit larl can be used.  This case is handled like\n+\t       local symbol refs.  */\n+\t    gcc_unreachable ();\n+\t  break;\n \n-\t      if (GET_CODE (new_rtx) == CONST)\n-\t\tnew_rtx = XEXP (new_rtx, 0);\n-              new_rtx = force_operand (new_rtx, 0);\n+\t  /* Everything else cannot happen.  */\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else if (addend != const0_rtx)\n+    {\n+      /* Otherwise, compute the sum.  */\n+\n+      rtx base = legitimize_pic_address (addr, reg);\n+      new_rtx  = legitimize_pic_address (addend,\n+\t\t\t\t\t base == reg ? NULL_RTX : reg);\n+      if (GET_CODE (new_rtx) == CONST_INT)\n+\tnew_rtx = plus_constant (Pmode, base, INTVAL (new_rtx));\n+      else\n+\t{\n+\t  if (GET_CODE (new_rtx) == PLUS && CONSTANT_P (XEXP (new_rtx, 1)))\n+\t    {\n+\t      base = gen_rtx_PLUS (Pmode, base, XEXP (new_rtx, 0));\n+\t      new_rtx = XEXP (new_rtx, 1);\n \t    }\n+\t  new_rtx = gen_rtx_PLUS (Pmode, base, new_rtx);\n \t}\n+\n+      if (GET_CODE (new_rtx) == CONST)\n+\tnew_rtx = XEXP (new_rtx, 0);\n+      new_rtx = force_operand (new_rtx, 0);\n     }\n+\n   return new_rtx;\n }\n \n@@ -5350,7 +5334,7 @@ print_operand_address (FILE *file, rtx addr)\n {\n   struct s390_address ad;\n \n-  if (s390_loadrelative_operand_p (addr))\n+  if (s390_loadrelative_operand_p (addr, NULL, NULL))\n     {\n       if (!TARGET_Z10)\n \t{"}, {"sha": "a82d435229b146ebca850fb118d7c2405f9fb760", "filename": "gcc/testsuite/gcc.target/s390/pr55718.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff4390dd359f76dd76b835a0ccf9d473d9ebe28/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr55718.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff4390dd359f76dd76b835a0ccf9d473d9ebe28/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr55718.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fpr55718.c?ref=0ff4390dd359f76dd76b835a0ccf9d473d9ebe28", "patch": "@@ -0,0 +1,29 @@\n+/* PR target/55717  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=z10 -fPIC\" } */\n+\n+extern char temp[];\n+short ansi_value[256];\n+void terminal_state(void)\n+{\n+  static const char *puc[] = { \"\", \"<\", \"=\", \">\", \"?\", 0};\n+  int i, j, k, l, modes_found;\n+  char buf[256];\n+  k = (int) __builtin_strlen(temp);\n+  for (j = l = 0; j < 255 && j - l < 50; j++)\n+    {\n+      __builtin_sprintf(temp, \"\\033[%s%d$p\", puc[i], j);\n+      if (ansi_value[1])\n+        {\n+          l = j;\n+          buf[k] = '\\0';\n+          put_crlf();\n+          ptextln(buf);\n+          buf[k++] = ' ';\n+          k = (int) __builtin_strlen(temp);\n+        }\n+    }\n+  for (i = j = 0; j < modes_found; j = ++i >> 1)\n+    ;\n+}"}]}