{"sha": "928bc34f5f3653e17357351b394894827aeef424", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI4YmMzNGY1ZjM2NTNlMTczNTczNTFiMzk0ODk0ODI3YWVlZjQyNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-02-14T19:07:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-02-14T19:07:38Z"}, "message": "re PR middle-end/35136 (ICE caused by address calculation with loop variable when optimization is on)\n\n\tPR middle-end/35136\n\t* gimplify.c (force_gimple_operand_bsi): Revert 2008-02-12 change.\n\t(force_gimple_operand): Likewise.\n\t* tree-ssa-loop-ivopts.c (may_be_nonaddressable_p): Add new cases\n\tfor TARGET_MEM_REF and CONVERT_EXPR/NON_LVALUE_EXPR/NOP_EXPR.\n\tAlso recurse on the operand for regular VIEW_CONVERT_EXPRs.\n\t(find_interesting_uses_address): Check addressability and alignment\n\tof the base expression only after substituting bases of IVs into it.\n\nFrom-SVN: r132320", "tree": {"sha": "179f616f6f526bdb6070315bbfbf22e717f577d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/179f616f6f526bdb6070315bbfbf22e717f577d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/928bc34f5f3653e17357351b394894827aeef424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928bc34f5f3653e17357351b394894827aeef424", "html_url": "https://github.com/Rust-GCC/gccrs/commit/928bc34f5f3653e17357351b394894827aeef424", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928bc34f5f3653e17357351b394894827aeef424/comments", "author": null, "committer": null, "parents": [{"sha": "4bcf935d1195ea17f17d5249ef2a502ead734535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bcf935d1195ea17f17d5249ef2a502ead734535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bcf935d1195ea17f17d5249ef2a502ead734535"}], "stats": {"total": 69, "additions": 48, "deletions": 21}, "files": [{"sha": "d3dfe7ad70f2aca694cc883605309a3c95931fd3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928bc34f5f3653e17357351b394894827aeef424/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928bc34f5f3653e17357351b394894827aeef424/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=928bc34f5f3653e17357351b394894827aeef424", "patch": "@@ -1,3 +1,14 @@\n+2008-02-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR middle-end/35136\n+\t* gimplify.c (force_gimple_operand_bsi): Revert 2008-02-12 change.\n+\t(force_gimple_operand): Likewise.\n+\t* tree-ssa-loop-ivopts.c (may_be_nonaddressable_p): Add new cases\n+\tfor TARGET_MEM_REF and CONVERT_EXPR/NON_LVALUE_EXPR/NOP_EXPR.\n+\tAlso recurse on the operand for regular VIEW_CONVERT_EXPRs.\n+\t(find_interesting_uses_address): Check addressability and alignment\n+\tof the base expression only after substituting bases of IVs into it.\n+\n 2008-02-14  Michael Matz  <matz@suse.de>\n \n \tPR target/34930"}, {"sha": "04ed39c533a5c0fc7d69bed92a0524f7c92255b5", "filename": "gcc/gimplify.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928bc34f5f3653e17357351b394894827aeef424/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928bc34f5f3653e17357351b394894827aeef424/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=928bc34f5f3653e17357351b394894827aeef424", "patch": "@@ -6629,14 +6629,6 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n \n   pop_gimplify_context (NULL);\n \n-  if (*stmts && gimple_in_ssa_p (cfun))\n-    {\n-      tree_stmt_iterator tsi;\n-\n-      for (tsi = tsi_start (*stmts); !tsi_end_p (tsi); tsi_next (&tsi))\n-\tmark_symbols_for_renaming (tsi_stmt (tsi));\n-    }\n-\n   return expr;\n }\n \n@@ -6656,6 +6648,14 @@ force_gimple_operand_bsi (block_stmt_iterator *bsi, tree expr,\n   expr = force_gimple_operand (expr, &stmts, simple_p, var);\n   if (stmts)\n     {\n+      if (gimple_in_ssa_p (cfun))\n+\t{\n+\t  tree_stmt_iterator tsi;\n+\n+\t  for (tsi = tsi_start (stmts); !tsi_end_p (tsi); tsi_next (&tsi))\n+\t    mark_symbols_for_renaming (tsi_stmt (tsi));\n+\t}\n+\n       if (before)\n \tbsi_insert_before (bsi, stmts, m);\n       else"}, {"sha": "6ff690dfaa9b44ab208d6195a3f5535a104e81f1", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/928bc34f5f3653e17357351b394894827aeef424/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/928bc34f5f3653e17357351b394894827aeef424/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=928bc34f5f3653e17357351b394894827aeef424", "patch": "@@ -1434,21 +1434,34 @@ may_be_nonaddressable_p (tree expr)\n {\n   switch (TREE_CODE (expr))\n     {\n+    case TARGET_MEM_REF:\n+      /* TARGET_MEM_REFs are translated directly to valid MEMs on the\n+\t target, thus they are always addressable.  */\n+      return false;\n+\n     case COMPONENT_REF:\n       return DECL_NONADDRESSABLE_P (TREE_OPERAND (expr, 1))\n \t     || may_be_nonaddressable_p (TREE_OPERAND (expr, 0));\n \n-    case ARRAY_REF:\n-    case ARRAY_RANGE_REF:\n-      return may_be_nonaddressable_p (TREE_OPERAND (expr, 0));\n-\n     case VIEW_CONVERT_EXPR:\n       /* This kind of view-conversions may wrap non-addressable objects\n \t and make them look addressable.  After some processing the\n \t non-addressability may be uncovered again, causing ADDR_EXPRs\n \t of inappropriate objects to be built.  */\n-      return AGGREGATE_TYPE_P (TREE_TYPE (expr))\n-\t     && !AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0)));\n+      if (AGGREGATE_TYPE_P (TREE_TYPE (expr))\n+\t  && !AGGREGATE_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0))))\n+\treturn true;\n+\n+      /* ... fall through ... */\n+\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      return may_be_nonaddressable_p (TREE_OPERAND (expr, 0));\n+\n+    case CONVERT_EXPR:\n+    case NON_LVALUE_EXPR:\n+    case NOP_EXPR:\n+      return true;\n \n     default:\n       break;\n@@ -1476,13 +1489,6 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n   if (TREE_CODE (base) == BIT_FIELD_REF)\n     goto fail;\n \n-  if (may_be_nonaddressable_p (base))\n-    goto fail;\n-\n-  if (STRICT_ALIGNMENT\n-      && may_be_unaligned_p (base))\n-    goto fail;\n-\n   base = unshare_expr (base);\n \n   if (TREE_CODE (base) == TARGET_MEM_REF)\n@@ -1536,6 +1542,16 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n       gcc_assert (TREE_CODE (base) != ALIGN_INDIRECT_REF);\n       gcc_assert (TREE_CODE (base) != MISALIGNED_INDIRECT_REF);\n \n+      /* Check that the base expression is addressable.  This needs\n+\t to be done after substituting bases of IVs into it.  */\n+      if (may_be_nonaddressable_p (base))\n+\tgoto fail;\n+\n+      /* Moreover, on strict alignment platforms, check that it is\n+\t sufficiently aligned.  */\n+      if (STRICT_ALIGNMENT && may_be_unaligned_p (base))\n+\tgoto fail;\n+\n       base = build_fold_addr_expr (base);\n \n       /* Substituting bases of IVs into the base expression might"}]}