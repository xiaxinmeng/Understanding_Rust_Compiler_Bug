{"sha": "5c5ce6099082b642294091c83461c928bd028ea1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM1Y2U2MDk5MDgyYjY0MjI5NDA5MWM4MzQ2MWM5MjhiZDAyOGVhMQ==", "commit": {"author": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2020-09-21T19:50:36Z"}, "committer": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2020-09-21T19:50:36Z"}, "message": "PR fortran/90903 [part2] - Add runtime checking for the MVBITS intrinsic\n\nImplement inline expansion of the intrinsic elemental subroutine MVBITS\nwith optional runtime checks for valid argument range.\n\ngcc/fortran/ChangeLog:\n\n\t* iresolve.c (gfc_resolve_mvbits): Remove unneeded conversion of\n\tFROMPOS, LEN and TOPOS arguments to fit a C int.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_mvbits): Add inline\n\texpansion of MVBITS intrinsic elemental subroutine and add code\n\tfor runtime argument checking.\n\t(gfc_conv_intrinsic_subroutine): Recognise MVBITS intrinsic, but\n\tdefer handling to gfc_trans_call.\n\t* trans-stmt.c (replace_ss):\n\t(gfc_trans_call): Adjust to handle inline expansion, scalarization\n\tof intrinsic subroutine MVBITS in gfc_conv_intrinsic_mvbits.\n\t* trans.h (gfc_conv_intrinsic_mvbits): Add prototype for\n\tgfc_conv_intrinsic_mvbits.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/check_bits_2.f90: New test.\n\nCo-authored-by: Paul Thomas  <pault@gcc.gnu.org>", "tree": {"sha": "03fa12b75d3c0a820e83d45d9a270a832f3fb347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03fa12b75d3c0a820e83d45d9a270a832f3fb347"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c5ce6099082b642294091c83461c928bd028ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5ce6099082b642294091c83461c928bd028ea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c5ce6099082b642294091c83461c928bd028ea1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c5ce6099082b642294091c83461c928bd028ea1/comments", "author": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "762c16eba6b815090c56564a293cd059aea2e1d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/762c16eba6b815090c56564a293cd059aea2e1d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/762c16eba6b815090c56564a293cd059aea2e1d6"}], "stats": {"total": 271, "additions": 247, "deletions": 24}, "files": [{"sha": "c2a4865f28f32f146b1db78a2b5de1e1bbac67e2", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5ce6099082b642294091c83461c928bd028ea1/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5ce6099082b642294091c83461c928bd028ea1/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=5c5ce6099082b642294091c83461c928bd028ea1", "patch": "@@ -3311,21 +3311,7 @@ gfc_resolve_mvbits (gfc_code *c)\n {\n   static const sym_intent INTENTS[] = {INTENT_IN, INTENT_IN, INTENT_IN,\n \t\t\t\t       INTENT_INOUT, INTENT_IN};\n-\n   const char *name;\n-  gfc_typespec ts;\n-  gfc_clear_ts (&ts);\n-\n-  /* FROMPOS, LEN and TOPOS are restricted to small values.  As such,\n-     they will be converted so that they fit into a C int.  */\n-  ts.type = BT_INTEGER;\n-  ts.kind = gfc_c_int_kind;\n-  if (c->ext.actual->next->expr->ts.kind != gfc_c_int_kind)\n-    gfc_convert_type (c->ext.actual->next->expr, &ts, 2);\n-  if (c->ext.actual->next->next->expr->ts.kind != gfc_c_int_kind)\n-    gfc_convert_type (c->ext.actual->next->next->expr, &ts, 2);\n-  if (c->ext.actual->next->next->next->next->expr->ts.kind != gfc_c_int_kind)\n-    gfc_convert_type (c->ext.actual->next->next->next->next->expr, &ts, 2);\n \n   /* TO and FROM are guaranteed to have the same kind parameter.  */\n   name = gfc_get_string (PREFIX (\"mvbits_i%d\"),"}, {"sha": "3b3bd8629cd39d8260f2e45f2a5beba3f458ba64", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5ce6099082b642294091c83461c928bd028ea1/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5ce6099082b642294091c83461c928bd028ea1/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=5c5ce6099082b642294091c83461c928bd028ea1", "patch": "@@ -11790,6 +11790,169 @@ conv_intrinsic_event_query (gfc_code *code)\n   return gfc_finish_block (&se.pre);\n }\n \n+\n+/* This is a peculiar case because of the need to do dependency checking.\n+   It is called via trans-stmt.c(gfc_trans_call), where it is picked out as\n+   a special case and this function called instead of\n+   gfc_conv_procedure_call.  */\n+void\n+gfc_conv_intrinsic_mvbits (gfc_se *se, gfc_actual_arglist *actual_args,\n+\t\t\t   gfc_loopinfo *loop)\n+{\n+  gfc_actual_arglist *actual;\n+  gfc_se argse[5];\n+  gfc_expr *arg[5];\n+  gfc_ss *lss;\n+  int n;\n+\n+  tree from, frompos, len, to, topos;\n+  tree lenmask, oldbits, newbits, bitsize;\n+  tree type, utype, above, mask1, mask2;\n+\n+  if (loop)\n+    lss = loop->ss;\n+  else\n+    lss = gfc_ss_terminator;\n+\n+  actual = actual_args;\n+  for (n = 0; n < 5; n++, actual = actual->next)\n+    {\n+      arg[n] = actual->expr;\n+      gfc_init_se (&argse[n], NULL);\n+\n+      if (lss != gfc_ss_terminator)\n+\t{\n+\t  gfc_copy_loopinfo_to_se (&argse[n], loop);\n+\t  /* Find the ss for the expression if it is there.  */\n+\t  argse[n].ss = lss;\n+\t  gfc_mark_ss_chain_used (lss, 1);\n+\t}\n+\n+      gfc_conv_expr (&argse[n], arg[n]);\n+\n+      if (loop)\n+\tlss = argse[n].ss;\n+    }\n+\n+  from    = argse[0].expr;\n+  frompos = argse[1].expr;\n+  len     = argse[2].expr;\n+  to      = argse[3].expr;\n+  topos   = argse[4].expr;\n+\n+  /* The type of the result (TO).  */\n+  type    = TREE_TYPE (to);\n+  bitsize = build_int_cst (integer_type_node, TYPE_PRECISION (type));\n+\n+  /* Optionally generate code for runtime argument check.  */\n+  if (gfc_option.rtcheck & GFC_RTCHECK_BITS)\n+    {\n+      tree nbits, below, ccond;\n+      tree fp = fold_convert (long_integer_type_node, frompos);\n+      tree ln = fold_convert (long_integer_type_node, len);\n+      tree tp = fold_convert (long_integer_type_node, topos);\n+      below = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t       logical_type_node, frompos,\n+\t\t\t       build_int_cst (TREE_TYPE (frompos), 0));\n+      above = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t       logical_type_node, frompos,\n+\t\t\t       fold_convert (TREE_TYPE (frompos), bitsize));\n+      ccond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t       logical_type_node, below, above);\n+      gfc_trans_runtime_check (true, false, ccond, &argse[1].pre,\n+\t\t\t       &arg[1]->where,\n+\t\t\t       \"FROMPOS argument (%ld) out of range 0:%d \"\n+\t\t\t       \"in intrinsic MVBITS\", fp, bitsize);\n+      below = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t       logical_type_node, len,\n+\t\t\t       build_int_cst (TREE_TYPE (len), 0));\n+      above = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t       logical_type_node, len,\n+\t\t\t       fold_convert (TREE_TYPE (len), bitsize));\n+      ccond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t       logical_type_node, below, above);\n+      gfc_trans_runtime_check (true, false, ccond, &argse[2].pre,\n+\t\t\t       &arg[2]->where,\n+\t\t\t       \"LEN argument (%ld) out of range 0:%d \"\n+\t\t\t       \"in intrinsic MVBITS\", ln, bitsize);\n+      below = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t       logical_type_node, topos,\n+\t\t\t       build_int_cst (TREE_TYPE (topos), 0));\n+      above = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t       logical_type_node, topos,\n+\t\t\t       fold_convert (TREE_TYPE (topos), bitsize));\n+      ccond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t       logical_type_node, below, above);\n+      gfc_trans_runtime_check (true, false, ccond, &argse[4].pre,\n+\t\t\t       &arg[4]->where,\n+\t\t\t       \"TOPOS argument (%ld) out of range 0:%d \"\n+\t\t\t       \"in intrinsic MVBITS\", tp, bitsize);\n+\n+      /* The tests above ensure that FROMPOS, LEN and TOPOS fit into short\n+\t integers.  Additions below cannot overflow.  */\n+      nbits = fold_convert (long_integer_type_node, bitsize);\n+      above = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t       long_integer_type_node, fp, ln);\n+      ccond = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t       logical_type_node, above, nbits);\n+      gfc_trans_runtime_check (true, false, ccond, &argse[1].pre,\n+\t\t\t       &arg[1]->where,\n+\t\t\t       \"FROMPOS(%ld)+LEN(%ld)>BIT_SIZE(%d) \"\n+\t\t\t       \"in intrinsic MVBITS\", fp, ln, bitsize);\n+      above = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t       long_integer_type_node, tp, ln);\n+      ccond = fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t       logical_type_node, above, nbits);\n+      gfc_trans_runtime_check (true, false, ccond, &argse[4].pre,\n+\t\t\t       &arg[4]->where,\n+\t\t\t       \"TOPOS(%ld)+LEN(%ld)>BIT_SIZE(%d) \"\n+\t\t\t       \"in intrinsic MVBITS\", tp, ln, bitsize);\n+    }\n+\n+  for (n = 0; n < 5; n++)\n+    {\n+      gfc_add_block_to_block (&se->pre, &argse[n].pre);\n+      gfc_add_block_to_block (&se->post, &argse[n].post);\n+    }\n+\n+  /* lenmask = (LEN >= bit_size (TYPE)) ? ~(TYPE)0 : ((TYPE)1 << LEN) - 1  */\n+  above = fold_build2_loc (input_location, GE_EXPR, logical_type_node,\n+\t\t\t   len, fold_convert (TREE_TYPE (len), bitsize));\n+  mask1 = build_int_cst (type, -1);\n+  mask2 = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n+\t\t\t   build_int_cst (type, 1), len);\n+  mask2 = fold_build2_loc (input_location, MINUS_EXPR, type,\n+\t\t\t   mask2, build_int_cst (type, 1));\n+  lenmask = fold_build3_loc (input_location, COND_EXPR, type,\n+\t\t\t     above, mask1, mask2);\n+\n+  /* newbits = (((UTYPE)(FROM) >> FROMPOS) & lenmask) << TOPOS.\n+   * For valid frompos+len <= bit_size(FROM) the conversion to unsigned is\n+   * not strictly necessary; artificial bits from rshift will be masked.  */\n+  utype = unsigned_type_for (type);\n+  newbits = fold_build2_loc (input_location, RSHIFT_EXPR, utype,\n+\t\t\t     fold_convert (utype, from), frompos);\n+  newbits = fold_build2_loc (input_location, BIT_AND_EXPR, type,\n+\t\t\t     fold_convert (type, newbits), lenmask);\n+  newbits = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n+\t\t\t     newbits, topos);\n+\n+  /* oldbits = TO & (~(lenmask << TOPOS)).  */\n+  oldbits = fold_build2_loc (input_location, LSHIFT_EXPR, type,\n+\t\t\t     lenmask, topos);\n+  oldbits = fold_build1_loc (input_location, BIT_NOT_EXPR, type, oldbits);\n+  oldbits = fold_build2_loc (input_location, BIT_AND_EXPR, type, oldbits, to);\n+\n+  /* TO = newbits | oldbits.  */\n+  se->expr = fold_build2_loc (input_location, BIT_IOR_EXPR, type,\n+\t\t\t      oldbits, newbits);\n+\n+  /* Return the assignment.  */\n+  se->expr = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t      void_type_node, to, se->expr);\n+}\n+\n+\n static tree\n conv_intrinsic_move_alloc (gfc_code *code)\n {\n@@ -12119,6 +12282,10 @@ gfc_conv_intrinsic_subroutine (gfc_code *code)\n       res = conv_intrinsic_kill_sub (code);\n       break;\n \n+    case GFC_ISYM_MVBITS:\n+      res = NULL_TREE;\n+      break;\n+\n     case GFC_ISYM_SYSTEM_CLOCK:\n       res = conv_intrinsic_system_clock (code);\n       break;"}, {"sha": "389fec7227e5804a33a186381939920b75d8bbf3", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5ce6099082b642294091c83461c928bd028ea1/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5ce6099082b642294091c83461c928bd028ea1/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=5c5ce6099082b642294091c83461c928bd028ea1", "patch": "@@ -198,6 +198,13 @@ replace_ss (gfc_se *se, gfc_ss *old_ss, gfc_ss *new_ss)\n   *sess = new_ss;\n   new_ss->next = old_ss->next;\n \n+  /* Make sure that trailing references are not lost.  */\n+  if (old_ss->info\n+      && old_ss->info->data.array.ref\n+      && old_ss->info->data.array.ref->next\n+      && !(new_ss->info->data.array.ref\n+\t   && new_ss->info->data.array.ref->next))\n+    new_ss->info->data.array.ref = old_ss->info->data.array.ref;\n \n   for (loopss = &(se->loop->ss); *loopss != gfc_ss_terminator;\n        loopss = &((*loopss)->loop_chain))\n@@ -383,6 +390,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n   tree index = NULL_TREE;\n   tree maskexpr = NULL_TREE;\n   tree tmp;\n+  bool is_intrinsic_mvbits;\n \n   /* A CALL starts a new block because the actual arguments may have to\n      be evaluated first.  */\n@@ -397,17 +405,29 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n \t\t\t\t\t   get_proc_ifc_for_call (code),\n \t\t\t\t\t   GFC_SS_REFERENCE);\n \n+  /* MVBITS is inlined but needs the dependency checking found here.  */\n+  is_intrinsic_mvbits = code->resolved_isym\n+\t\t\t&& code->resolved_isym->id == GFC_ISYM_MVBITS;\n+\n   /* Is not an elemental subroutine call with array valued arguments.  */\n   if (ss == gfc_ss_terminator)\n     {\n \n-      /* Translate the call.  */\n-      has_alternate_specifier\n-\t= gfc_conv_procedure_call (&se, code->resolved_sym, code->ext.actual,\n-\t\t\t\t  code->expr1, NULL);\n+      if (is_intrinsic_mvbits)\n+\t{\n+\t  has_alternate_specifier = 0;\n+\t  gfc_conv_intrinsic_mvbits (&se, code->ext.actual, NULL);\n+\t}\n+      else\n+\t{\n+\t  /* Translate the call.  */\n+\t  has_alternate_specifier =\n+\t    gfc_conv_procedure_call (&se, code->resolved_sym,\n+\t\t\t\t     code->ext.actual, code->expr1, NULL);\n \n-      /* A subroutine without side-effect, by definition, does nothing!  */\n-      TREE_SIDE_EFFECTS (se.expr) = 1;\n+\t  /* A subroutine without side-effect, by definition, does nothing!  */\n+\t  TREE_SIDE_EFFECTS (se.expr) = 1;\n+\t}\n \n       /* Chain the pieces together and return the block.  */\n       if (has_alternate_specifier)\n@@ -490,10 +510,18 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n \t\t\t\t\tTREE_TYPE (maskexpr), maskexpr);\n \t}\n \n-      /* Add the subroutine call to the block.  */\n-      gfc_conv_procedure_call (&loopse, code->resolved_sym,\n-\t\t\t       code->ext.actual, code->expr1,\n-\t\t\t       NULL);\n+      if (is_intrinsic_mvbits)\n+\t{\n+\t  has_alternate_specifier = 0;\n+\t  gfc_conv_intrinsic_mvbits (&loopse, code->ext.actual, &loop);\n+\t}\n+      else\n+\t{\n+\t  /* Add the subroutine call to the block.  */\n+\t  gfc_conv_procedure_call (&loopse, code->resolved_sym,\n+\t\t\t\t   code->ext.actual, code->expr1,\n+\t\t\t\t   NULL);\n+\t}\n \n       if (mask && count1)\n \t{"}, {"sha": "16b4215605e8810fa4f88e3ccdfa72415c5d7a74", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5ce6099082b642294091c83461c928bd028ea1/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5ce6099082b642294091c83461c928bd028ea1/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=5c5ce6099082b642294091c83461c928bd028ea1", "patch": "@@ -818,6 +818,10 @@ bool gfc_omp_private_outer_ref (tree);\n struct gimplify_omp_ctx;\n void gfc_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *, tree);\n \n+/* In trans-intrinsic.c.  */\n+void gfc_conv_intrinsic_mvbits (gfc_se *, gfc_actual_arglist *,\n+\t\t\t\tgfc_loopinfo *);\n+\n /* Runtime library function decls.  */\n extern GTY(()) tree gfor_fndecl_pause_numeric;\n extern GTY(()) tree gfor_fndecl_pause_string;"}, {"sha": "25357a0dde19ba1d94852e7c306712bf7ceaa2cd", "filename": "gcc/testsuite/gfortran.dg/check_bits_2.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c5ce6099082b642294091c83461c928bd028ea1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcheck_bits_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c5ce6099082b642294091c83461c928bd028ea1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcheck_bits_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcheck_bits_2.f90?ref=5c5ce6099082b642294091c83461c928bd028ea1", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=bits -fdump-tree-original\" }\n+! { dg-shouldfail \"Fortran runtime error: FROMPOS(64)+LEN(1)>BIT_SIZE(64) in intrinsic MVBITS\" }\n+! { dg-output \"At line 33 .*\" }\n+!\n+! Verify that the runtime checks for the MVBITS intrinsic functions\n+! do not generate false-positives\n+program check\n+  implicit none\n+  integer, parameter :: bs4 = bit_size (1_4)\n+  integer, parameter :: bs8 = bit_size (1_8)\n+  integer(4), dimension(0:bs4) :: from4, frompos4, len4, to4, topos4\n+  integer(8), dimension(0:bs8) :: from8, frompos8, len8, to8, topos8\n+  integer :: i\n+  from4 = -1\n+  to4 = -1\n+  len4 = [ (i, i=0,bs4) ]\n+  frompos4 = bs4 - len4\n+  topos4 = frompos4\n+  call mvbits (from4, frompos4, len4, to4, topos4)\n+  if (any (to4 /= -1)) stop 1\n+  from8 = -1\n+  to8 = -1\n+  len8 = [ (i, i=0,bs8) ]\n+  frompos8 = bs8 - len8\n+  topos8 = frompos8\n+  call mvbits (from8, frompos8, len8, to8, topos8)\n+  if (any (to8 /= -1)) stop 2\n+  from8 = -1\n+  to8 = -1\n+  len8(0) = 1\n+  ! The following line should fail with a runtime error:\n+  call mvbits (from8, frompos8, len8, to8, topos8)\n+  ! Should never get here with -fcheck=bits\n+  stop 3\n+end\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_runtime_error_at\" 15 \"original\" } }"}]}