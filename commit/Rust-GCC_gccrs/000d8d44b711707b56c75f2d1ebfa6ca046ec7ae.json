{"sha": "000d8d44b711707b56c75f2d1ebfa6ca046ec7ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAwZDhkNDRiNzExNzA3YjU2Yzc1ZjJkMWViZmE2Y2EwNDZlYzdhZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-11-12T02:57:10Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-11-12T02:57:10Z"}, "message": "fold-const.c (int_binop_types_match_p): New function.\n\n\n\t* fold-const.c (int_binop_types_match_p): New function.\n\t(size_binop): Relax constraint that both arguments must both have\n\texactly the same sizetype type.  Instead use int_binop_types_match_p.\n\t(size_diffop): Likewise.\n\n\t(make_range): Use build_int_cst instead of fold_convert.\n\t(fold_cond_expr_with_comparison): Use build_int_cst to construct\n\tinteger constants of the correct type.\n\t(fold_div_compare): Likewise.\n\t(fold_single_bit_test): Likewise.\n\t(fold_binary): Likewise.\n\t* stor-layout.c (layout_type) <VECTOR_TYPE>: Ensure that TYPE_SIZE\n\thas type bitsizetype and TYPE_SIZE_UNIT has type sizetype.\n\nFrom-SVN: r118718", "tree": {"sha": "58a441d6fe7ffeccb38541fe24123167cc9fb14f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58a441d6fe7ffeccb38541fe24123167cc9fb14f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/000d8d44b711707b56c75f2d1ebfa6ca046ec7ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/000d8d44b711707b56c75f2d1ebfa6ca046ec7ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/000d8d44b711707b56c75f2d1ebfa6ca046ec7ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/000d8d44b711707b56c75f2d1ebfa6ca046ec7ae/comments", "author": null, "committer": null, "parents": [{"sha": "afa8f0fb33f62b3e9ea2fad0813372730d18295b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa8f0fb33f62b3e9ea2fad0813372730d18295b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afa8f0fb33f62b3e9ea2fad0813372730d18295b"}], "stats": {"total": 110, "additions": 81, "deletions": 29}, "files": [{"sha": "7a7013d4b5ea0f5c4eb496e499967ae23b543073", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/000d8d44b711707b56c75f2d1ebfa6ca046ec7ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/000d8d44b711707b56c75f2d1ebfa6ca046ec7ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=000d8d44b711707b56c75f2d1ebfa6ca046ec7ae", "patch": "@@ -1,3 +1,19 @@\n+2006-11-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (int_binop_types_match_p): New function.\n+\t(size_binop): Relax constraint that both arguments must both have\n+\texactly the same sizetype type.  Instead use int_binop_types_match_p.\n+\t(size_diffop): Likewise.\n+\n+\t(make_range): Use build_int_cst instead of fold_convert.\n+\t(fold_cond_expr_with_comparison): Use build_int_cst to construct\n+\tinteger constants of the correct type.\n+\t(fold_div_compare): Likewise.\n+\t(fold_single_bit_test): Likewise.\n+\t(fold_binary): Likewise.\n+\t* stor-layout.c (layout_type) <VECTOR_TYPE>: Ensure that TYPE_SIZE\n+\thas type bitsizetype and TYPE_SIZE_UNIT has type sizetype.\n+\n 2006-11-11  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR rtl-opt/28812"}, {"sha": "08e74a292f9b3db16c56fbea7e0a26db68a781a9", "filename": "gcc/fold-const.c", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/000d8d44b711707b56c75f2d1ebfa6ca046ec7ae/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/000d8d44b711707b56c75f2d1ebfa6ca046ec7ae/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=000d8d44b711707b56c75f2d1ebfa6ca046ec7ae", "patch": "@@ -1372,6 +1372,35 @@ associate_trees (tree t1, tree t2, enum tree_code code, tree type)\n \t\t      fold_convert (type, t2));\n }\n \f\n+/* Check whether TYPE1 and TYPE2 are equivalent integer types, suitable\n+   for use in int_const_binop, size_binop and size_diffop.  */\n+\n+static bool\n+int_binop_types_match_p (enum tree_code code, tree type1, tree type2)\n+{\n+  if (TREE_CODE (type1) != INTEGER_TYPE && !POINTER_TYPE_P (type1))\n+    return false;\n+  if (TREE_CODE (type2) != INTEGER_TYPE && !POINTER_TYPE_P (type2))\n+    return false;\n+\n+  switch (code)\n+    {\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+      return true;\n+\n+    default:\n+      break;\n+    }\n+\n+  return TYPE_UNSIGNED (type1) == TYPE_UNSIGNED (type2)\n+\t && TYPE_PRECISION (type1) == TYPE_PRECISION (type2)\n+\t && TYPE_MODE (type1) == TYPE_MODE (type2);\n+}\n+\n+\n /* Combine two integer constants ARG1 and ARG2 under operation CODE\n    to produce a new constant.  Return NULL_TREE if we don't know how\n    to evaluate CODE at compile-time.\n@@ -1733,7 +1762,7 @@ size_int_kind (HOST_WIDE_INT number, enum size_type_kind kind)\n \f\n /* Combine operands OP1 and OP2 with arithmetic operation CODE.  CODE\n    is a tree code.  The type of the result is taken from the operands.\n-   Both must be the same type integer type and it must be a size type.\n+   Both must be equivalent integer types, ala int_binop_types_match_p.\n    If the operands are constant, so is the result.  */\n \n tree\n@@ -1744,8 +1773,8 @@ size_binop (enum tree_code code, tree arg0, tree arg1)\n   if (arg0 == error_mark_node || arg1 == error_mark_node)\n     return error_mark_node;\n \n-  gcc_assert (TREE_CODE (type) == INTEGER_TYPE && TYPE_IS_SIZETYPE (type)\n-\t      && type == TREE_TYPE (arg1));\n+  gcc_assert (int_binop_types_match_p (code, TREE_TYPE (arg0),\n+                                       TREE_TYPE (arg1)));\n \n   /* Handle the special case of two integer constants faster.  */\n   if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n@@ -1776,14 +1805,19 @@ size_diffop (tree arg0, tree arg1)\n   tree type = TREE_TYPE (arg0);\n   tree ctype;\n \n-  gcc_assert (TREE_CODE (type) == INTEGER_TYPE && TYPE_IS_SIZETYPE (type)\n-\t      && type == TREE_TYPE (arg1));\n+  gcc_assert (int_binop_types_match_p (MINUS_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t       TREE_TYPE (arg1)));\n \n   /* If the type is already signed, just do the simple thing.  */\n   if (!TYPE_UNSIGNED (type))\n     return size_binop (MINUS_EXPR, arg0, arg1);\n \n-  ctype = type == bitsizetype ? sbitsizetype : ssizetype;\n+  if (type == sizetype)\n+    ctype = ssizetype;\n+  else if (type == bitsizetype)\n+    ctype = sbitsizetype;\n+  else\n+    ctype = lang_hooks.types.signed_type (type);\n \n   /* If either operand is not a constant, do the conversions to the signed\n      type and subtract.  The hardware will do the right thing with any\n@@ -3978,8 +4012,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\thigh_positive = fold_build2 (RSHIFT_EXPR, arg0_type,\n \t\t\t\t\t     fold_convert (arg0_type,\n \t\t\t\t\t\t\t   high_positive),\n-\t\t\t\t\t     fold_convert (arg0_type,\n-\t\t\t\t\t\t\t   integer_one_node));\n+\t\t\t\t\t     build_int_cst (arg0_type, 1));\n \n \t      /* If the low bound is specified, \"and\" the range with the\n \t\t range for which the original unsigned value will be\n@@ -4625,7 +4658,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t\t\t       OEP_ONLY_CONST)\n \t    && operand_equal_p (arg01,\n \t\t\t\tconst_binop (PLUS_EXPR, arg2,\n-\t\t\t\t\t     integer_one_node, 0),\n+\t\t\t\t\t     build_int_cst (type, 1), 0),\n \t\t\t\tOEP_ONLY_CONST))\n \t  return pedantic_non_lvalue (fold_build2 (MIN_EXPR,\n \t\t\t\t\t\t   type, arg1, arg2));\n@@ -4637,7 +4670,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t\t\t       OEP_ONLY_CONST)\n \t    && operand_equal_p (arg01,\n \t\t\t\tconst_binop (MINUS_EXPR, arg2,\n-\t\t\t\t\t     integer_one_node, 0),\n+\t\t\t\t\t     build_int_cst (type, 1), 0),\n \t\t\t\tOEP_ONLY_CONST))\n \t  return pedantic_non_lvalue (fold_build2 (MIN_EXPR,\n \t\t\t\t\t\t   type, arg1, arg2));\n@@ -4649,7 +4682,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t\t\t       OEP_ONLY_CONST)\n \t    && operand_equal_p (arg01,\n \t\t\t\tconst_binop (MINUS_EXPR, arg2,\n-\t\t\t\t\t     integer_one_node, 0),\n+\t\t\t\t\t     build_int_cst (type, 1), 0),\n \t\t\t\tOEP_ONLY_CONST))\n \t  return pedantic_non_lvalue (fold_build2 (MAX_EXPR,\n \t\t\t\t\t\t   type, arg1, arg2));\n@@ -4661,7 +4694,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t\t\t       OEP_ONLY_CONST)\n \t    && operand_equal_p (arg01,\n \t\t\t\tconst_binop (PLUS_EXPR, arg2,\n-\t\t\t\t\t     integer_one_node, 0),\n+\t\t\t\t\t     build_int_cst (type, 1), 0),\n \t\t\t\tOEP_ONLY_CONST))\n \t  return pedantic_non_lvalue (fold_build2 (MAX_EXPR,\n \t\t\t\t\t\t   type, arg1, arg2));\n@@ -6084,7 +6117,8 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \n   if (unsigned_p)\n     {\n-      tmp = int_const_binop (MINUS_EXPR, arg01, integer_one_node, 0);\n+      tmp = int_const_binop (MINUS_EXPR, arg01,\n+                             build_int_cst (TREE_TYPE (arg01), 1), 0);\n       lo = prod;\n \n       /* Likewise hi = int_const_binop (PLUS_EXPR, prod, tmp, 0).  */\n@@ -6099,7 +6133,8 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n     }\n   else if (tree_int_cst_sgn (arg01) >= 0)\n     {\n-      tmp = int_const_binop (MINUS_EXPR, arg01, integer_one_node, 0);\n+      tmp = int_const_binop (MINUS_EXPR, arg01,\n+\t\t\t     build_int_cst (TREE_TYPE (arg01), 1), 0);\n       switch (tree_int_cst_sgn (arg1))\n \t{\n \tcase -1:\n@@ -6127,7 +6162,8 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n       /* A negative divisor reverses the relational operators.  */\n       code = swap_tree_comparison (code);\n \n-      tmp = int_const_binop (PLUS_EXPR, arg01, integer_one_node, 0);\n+      tmp = int_const_binop (PLUS_EXPR, arg01,\n+\t\t\t     build_int_cst (TREE_TYPE (arg01), 1), 0);\n       switch (tree_int_cst_sgn (arg1))\n \t{\n \tcase -1:\n@@ -6265,7 +6301,7 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n       enum machine_mode operand_mode = TYPE_MODE (type);\n       int ops_unsigned;\n       tree signed_type, unsigned_type, intermediate_type;\n-      tree tem;\n+      tree tem, one;\n \n       /* First, see if we can fold the single bit test into a sign-bit\n \t test.  */\n@@ -6310,13 +6346,13 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n \tinner = build2 (RSHIFT_EXPR, intermediate_type,\n \t\t\tinner, size_int (bitnum));\n \n+      one = build_int_cst (intermediate_type, 1);\n+\n       if (code == EQ_EXPR)\n-\tinner = fold_build2 (BIT_XOR_EXPR, intermediate_type,\n-\t\t\t     inner, integer_one_node);\n+\tinner = fold_build2 (BIT_XOR_EXPR, intermediate_type, inner, one);\n \n       /* Put the AND last so it can combine with more things.  */\n-      inner = build2 (BIT_AND_EXPR, intermediate_type,\n-\t\t      inner, integer_one_node);\n+      inner = build2 (BIT_AND_EXPR, intermediate_type, inner, one);\n \n       /* Make sure to return the proper type.  */\n       inner = fold_convert (result_type, inner);\n@@ -10035,8 +10071,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t  if (integer_pow2p (c) && tree_int_cst_sgn (c) > 0)\n \t    {\n-\t      tree mask = fold_build2 (MINUS_EXPR, TREE_TYPE (arg1),\n-\t\t\t\t       arg1, integer_one_node);\n+\t      tree mask = fold_build2 (MINUS_EXPR, TREE_TYPE (arg1), arg1,\n+\t\t\t\t       build_int_cst (TREE_TYPE (arg1), 1));\n \t      return fold_build2 (BIT_AND_EXPR, type,\n \t\t\t\t  fold_convert (type, arg0),\n \t\t\t\t  fold_convert (type, mask));\n@@ -10148,9 +10184,8 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t RROTATE_EXPR by a new constant.  */\n       if (code == LROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST)\n \t{\n-\t  tree tem = build_int_cst (NULL_TREE,\n+\t  tree tem = build_int_cst (TREE_TYPE (arg1),\n \t\t\t\t    GET_MODE_BITSIZE (TYPE_MODE (type)));\n-\t  tem = fold_convert (TREE_TYPE (arg1), tem);\n \t  tem = const_binop (MINUS_EXPR, tem, arg1, 0);\n \t  return fold_build2 (RROTATE_EXPR, type, arg0, tem);\n \t}\n@@ -10970,10 +11005,12 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      switch (code)\n \t\t{\n \t\tcase GT_EXPR:\n-\t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n+\t\t  arg1 = const_binop (PLUS_EXPR, arg1,\n+\t\t\t\t      build_int_cst (TREE_TYPE (arg1), 1), 0);\n \t\t  return fold_build2 (EQ_EXPR, type, arg0, arg1);\n \t\tcase LE_EXPR:\n-\t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n+\t\t  arg1 = const_binop (PLUS_EXPR, arg1,\n+\t\t\t\t      build_int_cst (TREE_TYPE (arg1), 1), 0);\n \t\t  return fold_build2 (NE_EXPR, type, arg0, arg1);\n \t\tdefault:\n \t\t  break;"}, {"sha": "ccbf9f7f3199ceea25646d0d4e162ad7140ce557", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/000d8d44b711707b56c75f2d1ebfa6ca046ec7ae/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/000d8d44b711707b56c75f2d1ebfa6ca046ec7ae/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=000d8d44b711707b56c75f2d1ebfa6ca046ec7ae", "patch": "@@ -1617,7 +1617,6 @@ layout_type (tree type)\n     case VECTOR_TYPE:\n       {\n \tint nunits = TYPE_VECTOR_SUBPARTS (type);\n-\ttree nunits_tree = build_int_cst (NULL_TREE, nunits);\n \ttree innertype = TREE_TYPE (type);\n \n \tgcc_assert (!(nunits & (nunits - 1)));\n@@ -1655,9 +1654,9 @@ layout_type (tree type)\n         TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n \tTYPE_SIZE_UNIT (type) = int_const_binop (MULT_EXPR,\n \t\t\t\t\t         TYPE_SIZE_UNIT (innertype),\n-\t\t\t\t\t         nunits_tree, 0);\n+\t\t\t\t\t         size_int (nunits), 0);\n \tTYPE_SIZE (type) = int_const_binop (MULT_EXPR, TYPE_SIZE (innertype),\n-\t\t\t\t\t    nunits_tree, 0);\n+\t\t\t\t\t    bitsize_int (nunits), 0);\n \n \t/* Always naturally align vectors.  This prevents ABI changes\n \t   depending on whether or not native vector modes are supported.  */"}]}