{"sha": "e76340be8fecb0b441e3c7040703e63f40b890cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc2MzQwYmU4ZmVjYjBiNDQxZTNjNzA0MDcwM2U2M2Y0MGI4OTBjYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-09-29T23:01:17Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-09-29T23:01:17Z"}, "message": "tree-vrp.c (get_single_symbol): New function.\n\n\t* tree-vrp.c (get_single_symbol): New function.\n\t(build_symbolic_expr): Likewise.\n\t(symbolic_range_based_on_p): New predicate.\n\t(extract_range_from_binary_expr_1): Deal with single-symbolic ranges\n\tfor PLUS and MINUS.  Do not drop symbolic ranges at the end.\n\t(extract_range_from_binary_expr): Try harder for PLUS and MINUS if\n\toperand is symbolic and based on the other operand.\n\nFrom-SVN: r215697", "tree": {"sha": "5b06d0bbf9fbfe3f3c708849252bb65efb953e44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b06d0bbf9fbfe3f3c708849252bb65efb953e44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e76340be8fecb0b441e3c7040703e63f40b890cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e76340be8fecb0b441e3c7040703e63f40b890cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e76340be8fecb0b441e3c7040703e63f40b890cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e76340be8fecb0b441e3c7040703e63f40b890cb/comments", "author": null, "committer": null, "parents": [{"sha": "ff5fdf67462d1b4c883c1c10938c7e719a20c5f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5fdf67462d1b4c883c1c10938c7e719a20c5f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff5fdf67462d1b4c883c1c10938c7e719a20c5f2"}], "stats": {"total": 436, "additions": 378, "deletions": 58}, "files": [{"sha": "adfe96d1f69ca76e3f2ba57df198ae1aeb0daa83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76340be8fecb0b441e3c7040703e63f40b890cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76340be8fecb0b441e3c7040703e63f40b890cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e76340be8fecb0b441e3c7040703e63f40b890cb", "patch": "@@ -1,3 +1,13 @@\n+2014-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-vrp.c (get_single_symbol): New function.\n+\t(build_symbolic_expr): Likewise.\n+\t(symbolic_range_based_on_p): New predicate.\n+\t(extract_range_from_binary_expr_1): Deal with single-symbolic ranges\n+\tfor PLUS and MINUS.  Do not drop symbolic ranges at the end.\n+\t(extract_range_from_binary_expr): Try harder for PLUS and MINUS if\n+\toperand is symbolic and based on the other operand.\n+\n 2014-09-29  Chen Gang  <gang.chen.5i5j@gmail.com>\n \n \t* config/microblaze/microblaze.md (call_internal1): Use VOID"}, {"sha": "4f608cf2103440ac7e6e8ff99e726f950302b644", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76340be8fecb0b441e3c7040703e63f40b890cb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76340be8fecb0b441e3c7040703e63f40b890cb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e76340be8fecb0b441e3c7040703e63f40b890cb", "patch": "@@ -1,3 +1,8 @@\n+2014-09-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/tree-ssa/vrp94.c: New test.\n+\t* gnat.dg/opt40.adb: Likewise.\n+\n 2014-09-29  Bill Schmidt  <wschmidt@vnet.linux.ibm.com>\n \n \t* gcc.dg/vmx/ops.c: Remove calls to vec_splat, vec_vsplth,"}, {"sha": "5cd5329700091fb3ad131d31f3055b2cf15fdf4c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp94.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76340be8fecb0b441e3c7040703e63f40b890cb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp94.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76340be8fecb0b441e3c7040703e63f40b890cb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp94.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp94.c?ref=e76340be8fecb0b441e3c7040703e63f40b890cb", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+extern void abort (void);\n+\n+int\n+foo1 (int x, int y)\n+{\n+  int z;\n+\n+  if (x >= y)\n+    return 1;\n+\n+  z = y - x;\n+  if (z <= 0)\n+    abort ();\n+\n+  return z;\n+}\n+\n+unsigned int\n+foo2 (unsigned int x, unsigned int y)\n+{\n+  unsigned int z;\n+\n+  if (x >= y)\n+    return 1;\n+\n+  z = y - x;\n+  if (z == 0)\n+    abort ();\n+\n+  return z;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d54e9ec360d6443fb1a2166fd849f0dd3f6d6808", "filename": "gcc/testsuite/gnat.dg/opt40.adb", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76340be8fecb0b441e3c7040703e63f40b890cb/gcc%2Ftestsuite%2Fgnat.dg%2Fopt40.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76340be8fecb0b441e3c7040703e63f40b890cb/gcc%2Ftestsuite%2Fgnat.dg%2Fopt40.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt40.adb?ref=e76340be8fecb0b441e3c7040703e63f40b890cb", "patch": "@@ -0,0 +1,17 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+pragma Suppress (Overflow_Check);\n+\n+function Opt40 (X : Integer; Y : Integer) return Positive is\n+   Z : Integer;\n+begin\n+   if X >= Y then\n+      return 1;\n+   end if;\n+   Z := Y - X;\n+   return Z;\n+end;\n+\n+-- { dg-final { scan-tree-dump-not \"gnat_rcheck\" \"optimized\" } }\n+-- { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "011db78d7344e196852c8b61bf6b9e4c7e2572b7", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 309, "deletions": 58, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e76340be8fecb0b441e3c7040703e63f40b890cb/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e76340be8fecb0b441e3c7040703e63f40b890cb/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=e76340be8fecb0b441e3c7040703e63f40b890cb", "patch": "@@ -916,6 +916,98 @@ symbolic_range_p (value_range_t *vr)\n           || !is_gimple_min_invariant (vr->max));\n }\n \n+/* Return the single symbol (an SSA_NAME) contained in T if any, or NULL_TREE\n+   otherwise.  We only handle additive operations and set NEG to true if the\n+   symbol is negated and INV to the invariant part, if any.  */\n+\n+static tree\n+get_single_symbol (tree t, bool *neg, tree *inv)\n+{\n+  bool neg_;\n+  tree inv_;\n+\n+  if (TREE_CODE (t) == PLUS_EXPR\n+      || TREE_CODE (t) == POINTER_PLUS_EXPR\n+      || TREE_CODE (t) == MINUS_EXPR)\n+    {\n+      if (is_gimple_min_invariant (TREE_OPERAND (t, 0)))\n+\t{\n+\t  neg_ = (TREE_CODE (t) == MINUS_EXPR);\n+\t  inv_ = TREE_OPERAND (t, 0);\n+\t  t = TREE_OPERAND (t, 1);\n+\t}\n+      else if (is_gimple_min_invariant (TREE_OPERAND (t, 1)))\n+\t{\n+\t  neg_ = false;\n+\t  inv_ = TREE_OPERAND (t, 1);\n+\t  t = TREE_OPERAND (t, 0);\n+\t}\n+      else\n+        return NULL_TREE;\n+    }\n+  else\n+    {\n+      neg_ = false;\n+      inv_ = NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (t) == NEGATE_EXPR)\n+    {\n+      t = TREE_OPERAND (t, 0);\n+      neg_ = !neg_;\n+    }\n+\n+  if (TREE_CODE (t) != SSA_NAME)\n+    return NULL_TREE;\n+\n+  *neg = neg_;\n+  *inv = inv_;\n+  return t;\n+}\n+\n+/* The reverse operation: build a symbolic expression with TYPE\n+   from symbol SYM, negated according to NEG, and invariant INV.  */\n+\n+static tree\n+build_symbolic_expr (tree type, tree sym, bool neg, tree inv)\n+{\n+  const bool pointer_p = POINTER_TYPE_P (type);\n+  tree t = sym;\n+\n+  if (neg)\n+    t = build1 (NEGATE_EXPR, type, t);\n+\n+  if (integer_zerop (inv))\n+    return t;\n+\n+  return build2 (pointer_p ? POINTER_PLUS_EXPR : PLUS_EXPR, type, t, inv);\n+}\n+\n+/* Return true if value range VR involves exactly one symbol SYM.  */\n+\n+static bool\n+symbolic_range_based_on_p (value_range_t *vr, const_tree sym)\n+{\n+  bool neg, min_has_symbol, max_has_symbol;\n+  tree inv;\n+\n+  if (is_gimple_min_invariant (vr->min))\n+    min_has_symbol = false;\n+  else if (get_single_symbol (vr->min, &neg, &inv) == sym)\n+    min_has_symbol = true;\n+  else\n+    return false;\n+\n+  if (is_gimple_min_invariant (vr->max))\n+    max_has_symbol = false;\n+  else if (get_single_symbol (vr->max, &neg, &inv) == sym)\n+    max_has_symbol = true;\n+  else\n+    return false;\n+\n+  return (min_has_symbol || max_has_symbol);\n+}\n+\n /* Return true if value range VR uses an overflow infinity.  */\n \n static inline bool\n@@ -1199,25 +1291,30 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n      both integers.  */\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (val1))\n \t      == POINTER_TYPE_P (TREE_TYPE (val2)));\n+\n   /* Convert the two values into the same type.  This is needed because\n      sizetype causes sign extension even for unsigned types.  */\n   val2 = fold_convert (TREE_TYPE (val1), val2);\n   STRIP_USELESS_TYPE_CONVERSION (val2);\n \n   if ((TREE_CODE (val1) == SSA_NAME\n+       || (TREE_CODE (val1) == NEGATE_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (val1, 0)) == SSA_NAME)\n        || TREE_CODE (val1) == PLUS_EXPR\n        || TREE_CODE (val1) == MINUS_EXPR)\n       && (TREE_CODE (val2) == SSA_NAME\n+\t  || (TREE_CODE (val2) == NEGATE_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (val2, 0)) == SSA_NAME)\n \t  || TREE_CODE (val2) == PLUS_EXPR\n \t  || TREE_CODE (val2) == MINUS_EXPR))\n     {\n       tree n1, c1, n2, c2;\n       enum tree_code code1, code2;\n \n-      /* If VAL1 and VAL2 are of the form 'NAME [+-] CST' or 'NAME',\n+      /* If VAL1 and VAL2 are of the form '[-]NAME [+-] CST' or 'NAME',\n \t return -1 or +1 accordingly.  If VAL1 and VAL2 don't use the\n \t same name, return -2.  */\n-      if (TREE_CODE (val1) == SSA_NAME)\n+      if (TREE_CODE (val1) == SSA_NAME || TREE_CODE (val1) == NEGATE_EXPR)\n \t{\n \t  code1 = SSA_NAME;\n \t  n1 = val1;\n@@ -1239,7 +1336,7 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n \t    }\n \t}\n \n-      if (TREE_CODE (val2) == SSA_NAME)\n+      if (TREE_CODE (val2) == SSA_NAME || TREE_CODE (val2) == NEGATE_EXPR)\n \t{\n \t  code2 = SSA_NAME;\n \t  n2 = val2;\n@@ -1262,11 +1359,15 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n \t}\n \n       /* Both values must use the same name.  */\n+      if (TREE_CODE (n1) == NEGATE_EXPR && TREE_CODE (n2) == NEGATE_EXPR)\n+\t{\n+\t  n1 = TREE_OPERAND (n1, 0);\n+\t  n2 = TREE_OPERAND (n2, 0);\n+\t}\n       if (n1 != n2)\n \treturn -2;\n \n-      if (code1 == SSA_NAME\n-\t  && code2 == SSA_NAME)\n+      if (code1 == SSA_NAME && code2 == SSA_NAME)\n \t/* NAME == NAME  */\n \treturn 0;\n \n@@ -2209,7 +2310,7 @@ extract_range_from_multiplicative_op_1 (value_range_t *vr,\n }\n \n /* Extract range information from a binary operation CODE based on\n-   the ranges of each of its operands, *VR0 and *VR1 with resulting\n+   the ranges of each of its operands *VR0 and *VR1 with resulting\n    type EXPR_TYPE.  The resulting range is stored in *VR.  */\n \n static void\n@@ -2303,11 +2404,12 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n   type = vr0.type;\n \n   /* Refuse to operate on VARYING ranges, ranges of different kinds\n-     and symbolic ranges.  As an exception, we allow BIT_AND_EXPR\n+     and symbolic ranges.  As an exception, we allow BIT_{AND,IOR}\n      because we may be able to derive a useful range even if one of\n      the operands is VR_VARYING or symbolic range.  Similarly for\n-     divisions.  TODO, we may be able to derive anti-ranges in\n-     some cases.  */\n+     divisions, MIN/MAX and PLUS/MINUS.\n+\n+     TODO, we may be able to derive anti-ranges in some cases.  */\n   if (code != BIT_AND_EXPR\n       && code != BIT_IOR_EXPR\n       && code != TRUNC_DIV_EXPR\n@@ -2318,6 +2420,8 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n       && code != TRUNC_MOD_EXPR\n       && code != MIN_EXPR\n       && code != MAX_EXPR\n+      && code != PLUS_EXPR\n+      && code != MINUS_EXPR\n       && (vr0.type == VR_VARYING\n \t  || vr1.type == VR_VARYING\n \t  || vr0.type != vr1.type\n@@ -2376,50 +2480,115 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n      range and see what we end up with.  */\n   if (code == PLUS_EXPR || code == MINUS_EXPR)\n     {\n-      /* If we have a PLUS_EXPR with two VR_RANGE integer constant\n-         ranges compute the precise range for such case if possible.  */\n-      if (range_int_cst_p (&vr0)\n-\t  && range_int_cst_p (&vr1))\n-\t{\n-\t  signop sgn = TYPE_SIGN (expr_type);\n-\t  unsigned int prec = TYPE_PRECISION (expr_type);\n-\t  wide_int type_min = wi::min_value (TYPE_PRECISION (expr_type), sgn);\n-\t  wide_int type_max = wi::max_value (TYPE_PRECISION (expr_type), sgn);\n-\t  wide_int wmin, wmax;\n+      const bool minus_p = (code == MINUS_EXPR);\n+      tree min_op0 = vr0.min;\n+      tree min_op1 = minus_p ? vr1.max : vr1.min;\n+      tree max_op0 = vr0.max;\n+      tree max_op1 = minus_p ? vr1.min : vr1.max;\n+      tree sym_min_op0 = NULL_TREE;\n+      tree sym_min_op1 = NULL_TREE;\n+      tree sym_max_op0 = NULL_TREE;\n+      tree sym_max_op1 = NULL_TREE;\n+      bool neg_min_op0, neg_min_op1, neg_max_op0, neg_max_op1;\n+\n+      /* If we have a PLUS or MINUS with two VR_RANGEs, either constant or\n+\t single-symbolic ranges, try to compute the precise resulting range,\n+\t but only if we know that this resulting range will also be constant\n+\t or single-symbolic.  */\n+      if (vr0.type == VR_RANGE && vr1.type == VR_RANGE\n+\t  && (TREE_CODE (min_op0) == INTEGER_CST\n+\t      || (sym_min_op0\n+\t\t  = get_single_symbol (min_op0, &neg_min_op0, &min_op0)))\n+\t  && (TREE_CODE (min_op1) == INTEGER_CST\n+\t      || (sym_min_op1\n+\t\t  = get_single_symbol (min_op1, &neg_min_op1, &min_op1)))\n+\t  && (!(sym_min_op0 && sym_min_op1)\n+\t      || (sym_min_op0 == sym_min_op1\n+\t\t  && neg_min_op0 == (minus_p ? neg_min_op1 : !neg_min_op1)))\n+\t  && (TREE_CODE (max_op0) == INTEGER_CST\n+\t      || (sym_max_op0\n+\t\t  = get_single_symbol (max_op0, &neg_max_op0, &max_op0)))\n+\t  && (TREE_CODE (max_op1) == INTEGER_CST\n+\t      || (sym_max_op1\n+\t\t  = get_single_symbol (max_op1, &neg_max_op1, &max_op1)))\n+\t  && (!(sym_max_op0 && sym_max_op1)\n+\t      || (sym_max_op0 == sym_max_op1\n+\t\t  && neg_max_op0 == (minus_p ? neg_max_op1 : !neg_max_op1))))\n+\t{\n+\t  const signop sgn = TYPE_SIGN (expr_type);\n+\t  const unsigned int prec = TYPE_PRECISION (expr_type);\n+\t  wide_int type_min, type_max, wmin, wmax;\n \t  int min_ovf = 0;\n \t  int max_ovf = 0;\n \n-\t  if (code == PLUS_EXPR)\n+\t  /* Get the lower and upper bounds of the type.  */\n+\t  if (TYPE_OVERFLOW_WRAPS (expr_type))\n \t    {\n-\t      wmin = wi::add (vr0.min, vr1.min);\n-\t      wmax = wi::add (vr0.max, vr1.max);\n-\n-\t      /* Check for overflow.  */\n-\t      if (wi::cmp (vr1.min, 0, sgn) != wi::cmp (wmin, vr0.min, sgn))\n-\t\tmin_ovf = wi::cmp (vr0.min, wmin, sgn);\n-\t      if (wi::cmp (vr1.max, 0, sgn) != wi::cmp (wmax, vr0.max, sgn))\n-\t\tmax_ovf = wi::cmp (vr0.max, wmax, sgn);\n+\t      type_min = wi::min_value (prec, sgn);\n+\t      type_max = wi::max_value (prec, sgn);\n \t    }\n-\t  else /* if (code == MINUS_EXPR) */\n+\t  else\n \t    {\n-\t      wmin = wi::sub (vr0.min, vr1.max);\n-\t      wmax = wi::sub (vr0.max, vr1.min);\n+\t      type_min = vrp_val_min (expr_type);\n+\t      type_max = vrp_val_max (expr_type);\n+\t    }\n+\n+\t  /* Combine the lower bounds, if any.  */\n+\t  if (min_op0 && min_op1)\n+\t    {\n+\t      if (minus_p)\n+\t\t{\n+\t\t  wmin = wi::sub (min_op0, min_op1);\n \n-\t      if (wi::cmp (0, vr1.max, sgn) != wi::cmp (wmin, vr0.min, sgn))\n-\t\tmin_ovf = wi::cmp (vr0.min, vr1.max, sgn);\n-\t      if (wi::cmp (0, vr1.min, sgn) != wi::cmp (wmax, vr0.max, sgn))\n-\t\tmax_ovf = wi::cmp (vr0.max, vr1.min, sgn);\n+\t\t  /* Check for overflow.  */\n+\t\t  if (wi::cmp (0, min_op1, sgn)\n+\t\t      != wi::cmp (wmin, min_op0, sgn))\n+\t\t    min_ovf = wi::cmp (min_op0, min_op1, sgn);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  wmin = wi::add (min_op0, min_op1);\n+\n+\t\t  /* Check for overflow.  */\n+\t\t  if (wi::cmp (min_op1, 0, sgn)\n+\t\t      != wi::cmp (wmin, min_op0, sgn))\n+\t\t    min_ovf = wi::cmp (min_op0, wmin, sgn);\n+\t\t}\n \t    }\n+\t  else if (min_op0)\n+\t    wmin = min_op0;\n+\t  else if (min_op1)\n+\t    wmin = minus_p ? wi::neg (min_op1) : min_op1;\n+\t  else\n+\t    wmin = wi::shwi (0, prec);\n \n-\t  /* For non-wrapping arithmetic look at possibly smaller\n-\t     value-ranges of the type.  */\n-\t  if (!TYPE_OVERFLOW_WRAPS (expr_type))\n+\t  /* Combine the upper bounds, if any.  */\n+\t  if (max_op0 && max_op1)\n \t    {\n-\t      if (vrp_val_min (expr_type))\n-\t\ttype_min = vrp_val_min (expr_type);\n-\t      if (vrp_val_max (expr_type))\n-\t\ttype_max = vrp_val_max (expr_type);\n+\t      if (minus_p)\n+\t\t{\n+\t\t  wmax = wi::sub (max_op0, max_op1);\n+\n+\t\t  /* Check for overflow.  */\n+\t\t  if (wi::cmp (0, max_op1, sgn)\n+\t\t      != wi::cmp (wmax, max_op0, sgn))\n+\t\t    max_ovf = wi::cmp (max_op0, max_op1, sgn);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  wmax = wi::add (max_op0, max_op1);\n+\n+\t\t  if (wi::cmp (max_op1, 0, sgn)\n+\t\t      != wi::cmp (wmax, max_op0, sgn))\n+\t\t    max_ovf = wi::cmp (max_op0, wmax, sgn);\n+\t\t}\n \t    }\n+\t  else if (max_op0)\n+\t    wmax = max_op0;\n+\t  else if (max_op1)\n+\t    wmax = minus_p ? wi::neg (max_op1) : max_op1;\n+\t  else\n+\t    wmax = wi::shwi (0, prec);\n \n \t  /* Check for type overflow.  */\n \t  if (min_ovf == 0)\n@@ -2437,6 +2606,15 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t\tmax_ovf = 1;\n \t    }\n \n+\t  /* If we have overflow for the constant part and the resulting\n+\t     range will be symbolic, drop to VR_VARYING.  */\n+\t  if ((min_ovf && sym_min_op0 != sym_min_op1)\n+\t      || (max_ovf && sym_max_op0 != sym_max_op1))\n+\t    {\n+\t      set_value_range_to_varying (vr);\n+\t      return;\n+\t    }\n+\n \t  if (TYPE_OVERFLOW_WRAPS (expr_type))\n \t    {\n \t      /* If overflow wraps, truncate the values and adjust the\n@@ -2450,8 +2628,7 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t\t  min = wide_int_to_tree (expr_type, tmin);\n \t\t  max = wide_int_to_tree (expr_type, tmax);\n \t\t}\n-\t      else if (min_ovf == -1\n-\t\t       && max_ovf == 1)\n+\t      else if (min_ovf == -1 && max_ovf == 1)\n \t\t{\n \t\t  /* Underflow and overflow, drop to VR_VARYING.  */\n \t\t  set_value_range_to_varying (vr);\n@@ -2526,20 +2703,44 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n \t      else\n \t\tmax = wide_int_to_tree (expr_type, wmax);\n \t    }\n+\n \t  if (needs_overflow_infinity (expr_type)\n \t      && supports_overflow_infinity (expr_type))\n \t    {\n-\t      if (is_negative_overflow_infinity (vr0.min)\n-\t\t  || (code == PLUS_EXPR\n-\t\t      ? is_negative_overflow_infinity (vr1.min)\n-\t\t      : is_positive_overflow_infinity (vr1.max)))\n+\t      if ((min_op0 && is_negative_overflow_infinity (min_op0))\n+\t\t  || (min_op1\n+\t\t      && (minus_p\n+\t\t\t  ? is_positive_overflow_infinity (min_op1)\n+\t\t\t  : is_negative_overflow_infinity (min_op1))))\n \t\tmin = negative_overflow_infinity (expr_type);\n-\t      if (is_positive_overflow_infinity (vr0.max)\n-\t\t  || (code == PLUS_EXPR\n-\t\t      ? is_positive_overflow_infinity (vr1.max)\n-\t\t      : is_negative_overflow_infinity (vr1.min)))\n+\t      if ((max_op0 && is_positive_overflow_infinity (max_op0))\n+\t\t  || (max_op1\n+\t\t      && (minus_p\n+\t\t\t  ? is_negative_overflow_infinity (max_op1)\n+\t\t\t  : is_positive_overflow_infinity (max_op1))))\n \t\tmax = positive_overflow_infinity (expr_type);\n \t    }\n+\n+\t  /* If the result lower bound is constant, we're done;\n+\t     otherwise, build the symbolic lower bound.  */\n+\t  if (sym_min_op0 == sym_min_op1)\n+\t    ;\n+\t  else if (sym_min_op0)\n+\t    min = build_symbolic_expr (expr_type, sym_min_op0,\n+\t\t\t\t       neg_min_op0, min);\n+\t  else if (sym_min_op1)\n+\t    min = build_symbolic_expr (expr_type, sym_min_op1,\n+\t\t\t\t       neg_min_op1 ^ minus_p, min);\n+\n+\t  /* Likewise for the upper bound.  */\n+\t  if (sym_max_op0 == sym_max_op1)\n+\t    ;\n+\t  else if (sym_max_op0)\n+\t    max = build_symbolic_expr (expr_type, sym_max_op0,\n+\t\t\t\t       neg_max_op0, max);\n+\t  else if (sym_max_op1)\n+\t    max = build_symbolic_expr (expr_type, sym_max_op1,\n+\t\t\t\t       neg_max_op1 ^ minus_p, max);\n \t}\n       else\n \t{\n@@ -3024,14 +3225,11 @@ extract_range_from_binary_expr_1 (value_range_t *vr,\n     gcc_unreachable ();\n \n   /* If either MIN or MAX overflowed, then set the resulting range to\n-     VARYING.  But we do accept an overflow infinity\n-     representation.  */\n+     VARYING.  But we do accept an overflow infinity representation.  */\n   if (min == NULL_TREE\n-      || !is_gimple_min_invariant (min)\n-      || (TREE_OVERFLOW (min) && !is_overflow_infinity (min))\n+      || (TREE_OVERFLOW_P (min) && !is_overflow_infinity (min))\n       || max == NULL_TREE\n-      || !is_gimple_min_invariant (max)\n-      || (TREE_OVERFLOW (max) && !is_overflow_infinity (max)))\n+      || (TREE_OVERFLOW_P (max) && !is_overflow_infinity (max)))\n     {\n       set_value_range_to_varying (vr);\n       return;\n@@ -3093,6 +3291,59 @@ extract_range_from_binary_expr (value_range_t *vr,\n     set_value_range_to_varying (&vr1);\n \n   extract_range_from_binary_expr_1 (vr, code, expr_type, &vr0, &vr1);\n+\n+  /* Try harder for PLUS and MINUS if the range of one operand is symbolic\n+     and based on the other operand, for example if it was deduced from a\n+     symbolic comparison.  When a bound of the range of the first operand\n+     is invariant, we set the corresponding bound of the new range to INF\n+     in order to avoid recursing on the range of the second operand.  */\n+  if (vr->type == VR_VARYING\n+      && (code == PLUS_EXPR || code == MINUS_EXPR)\n+      && TREE_CODE (op1) == SSA_NAME\n+      && vr0.type == VR_RANGE\n+      && symbolic_range_based_on_p (&vr0, op1))\n+    {\n+      const bool minus_p = (code == MINUS_EXPR);\n+      value_range_t n_vr1 = VR_INITIALIZER;\n+\n+      /* Try with VR0 and [-INF, OP1].  */\n+      if (is_gimple_min_invariant (minus_p ? vr0.max : vr0.min))\n+\tset_value_range (&n_vr1, VR_RANGE, vrp_val_min (expr_type), op1, NULL);\n+\n+      /* Try with VR0 and [OP1, +INF].  */\n+      else if (is_gimple_min_invariant (minus_p ? vr0.min : vr0.max))\n+\tset_value_range (&n_vr1, VR_RANGE, op1, vrp_val_max (expr_type), NULL);\n+\n+      /* Try with VR0 and [OP1, OP1].  */\n+      else\n+\tset_value_range (&n_vr1, VR_RANGE, op1, op1, NULL);\n+\n+      extract_range_from_binary_expr_1 (vr, code, expr_type, &vr0, &n_vr1);\n+    }\n+\n+  if (vr->type == VR_VARYING\n+      && (code == PLUS_EXPR || code == MINUS_EXPR)\n+      && TREE_CODE (op0) == SSA_NAME\n+      && vr1.type == VR_RANGE\n+      && symbolic_range_based_on_p (&vr1, op0))\n+    {\n+      const bool minus_p = (code == MINUS_EXPR);\n+      value_range_t n_vr0 = VR_INITIALIZER;\n+\n+      /* Try with [-INF, OP0] and VR1.  */\n+      if (is_gimple_min_invariant (minus_p ? vr1.max : vr1.min))\n+\tset_value_range (&n_vr0, VR_RANGE, vrp_val_min (expr_type), op0, NULL);\n+\n+      /* Try with [OP0, +INF] and VR1.  */\n+      else if (is_gimple_min_invariant (minus_p ? vr1.min : vr1.max))\n+\tset_value_range (&n_vr0, VR_RANGE, op0, vrp_val_max (expr_type), NULL);\n+\n+      /* Try with [OP0, OP0] and VR1.  */\n+      else\n+\tset_value_range (&n_vr0, VR_RANGE, op0, op0, NULL);\n+\n+      extract_range_from_binary_expr_1 (vr, code, expr_type, &n_vr0, &vr1);\n+    }\n }\n \n /* Extract range information from a unary operation CODE based on"}]}