{"sha": "aa52c1ffad50ffe721a19a816f474c56958b1d3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE1MmMxZmZhZDUwZmZlNzIxYTE5YTgxNmY0NzRjNTY5NThiMWQzYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "2000-02-27T06:54:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-02-27T06:54:04Z"}, "message": "Implement class scope using-declarations for functions.\n\n        * class.c (handle_using_decl): Call add_method for used functions.\n        Use IDENTIFIER_CLASS_VALUE to check for conflicts.\n        (add_method): Used functions are hidden by local functions.\n        (check_bases_and_members): Handle using-decls before finalizing\n        CLASSTYPE_METHOD_VEC.\n        * call.c (add_function_candidate): Add ctype parm; if non-zero,\n        override the type of 'this' accordingly.\n        (add_template_candidate, add_template_candidate_real): Add ctype parm.\n        (convert_class_to_reference, build_user_type_conversion_1,\n        build_new_function_call, build_object_call, build_new_op,\n        build_new_method_call): Pass ctype parm.\n\n        * search.c (lookup_member): Put rval_binfo, not basetype_path, in\n        the baselink.\n        * call.c (convert_class_to_reference, build_user_type_conversion_1,\n        build_new_function_call, build_object_call, build_new_op,\n        build_new_method_call, build_op_delete_call): Don't get basetype_path\n        from a baselink.\n        * typeck.c (build_component_ref): Likewise.\n        * init.c (build_offset_ref): Likewise.\n        (resolve_offset_ref): Don't call enforce_access.\n        Call build_scoped_ref.\n        * typeck2.c (build_scoped_ref): Simplify.  Do nothing if it\n        would cause an error or if -pedantic.\n        * class.c (alter_access): Lose binfo parm.\n\nFrom-SVN: r32212", "tree": {"sha": "c1ebb4b0526c7af728ba50f410f9d903a12a083e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1ebb4b0526c7af728ba50f410f9d903a12a083e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa52c1ffad50ffe721a19a816f474c56958b1d3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa52c1ffad50ffe721a19a816f474c56958b1d3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa52c1ffad50ffe721a19a816f474c56958b1d3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa52c1ffad50ffe721a19a816f474c56958b1d3a/comments", "author": null, "committer": null, "parents": [{"sha": "0172e2bc87664db2dead8bd8e4157a3343bce72e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0172e2bc87664db2dead8bd8e4157a3343bce72e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0172e2bc87664db2dead8bd8e4157a3343bce72e"}], "stats": {"total": 406, "additions": 205, "deletions": 201}, "files": [{"sha": "f5c9bcfa6df337f0bc87b6626d89637f6d4fd3ce", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=aa52c1ffad50ffe721a19a816f474c56958b1d3a", "patch": "@@ -1,3 +1,32 @@\n+2000-02-26  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\tImplement class scope using-declarations for functions.\n+\t* class.c (handle_using_decl): Call add_method for used functions.\n+\tUse IDENTIFIER_CLASS_VALUE to check for conflicts.\n+\t(add_method): Used functions are hidden by local functions.\n+\t(check_bases_and_members): Handle using-decls before finalizing\n+\tCLASSTYPE_METHOD_VEC.\n+\t* call.c (add_function_candidate): Add ctype parm; if non-zero,\n+\toverride the type of 'this' accordingly.\n+\t(add_template_candidate, add_template_candidate_real): Add ctype parm.\n+\t(convert_class_to_reference, build_user_type_conversion_1, \n+\tbuild_new_function_call, build_object_call, build_new_op,\n+\tbuild_new_method_call): Pass ctype parm.\n+\n+\t* search.c (lookup_member): Put rval_binfo, not basetype_path, in\n+\tthe baselink.\n+\t* call.c (convert_class_to_reference, build_user_type_conversion_1, \n+\tbuild_new_function_call, build_object_call, build_new_op,\n+\tbuild_new_method_call, build_op_delete_call): Don't get basetype_path\n+\tfrom a baselink.\n+\t* typeck.c (build_component_ref): Likewise.\n+\t* init.c (build_offset_ref): Likewise.\n+\t(resolve_offset_ref): Don't call enforce_access.  \n+\tCall build_scoped_ref.\n+\t* typeck2.c (build_scoped_ref): Simplify.  Do nothing if it\n+\twould cause an error or if -pedantic.\n+\t* class.c (alter_access): Lose binfo parm.\n+\n 2000-02-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* semantics.c (simplify_aggr_init_exprs_p): Don't walk into"}, {"sha": "8ced4781445dd739a53dc642297551dcc7023443", "filename": "gcc/cp/call.c", "status": "modified", "additions": 73, "deletions": 64, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=aa52c1ffad50ffe721a19a816f474c56958b1d3a", "patch": "@@ -61,10 +61,10 @@ static tree build_this PARAMS ((tree));\n static struct z_candidate * splice_viable PARAMS ((struct z_candidate *));\n static int any_viable PARAMS ((struct z_candidate *));\n static struct z_candidate * add_template_candidate\n-\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, int,\n+\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, int,\n \t       unification_kind_t));\n static struct z_candidate * add_template_candidate_real\n-\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, int,\n+\tPARAMS ((struct z_candidate *, tree, tree, tree, tree, tree, int,\n \t       tree, unification_kind_t));\n static struct z_candidate * add_template_conv_candidate \n         PARAMS ((struct z_candidate *, tree, tree, tree, tree));\n@@ -81,7 +81,7 @@ static struct z_candidate * build_builtin_candidate\n static struct z_candidate * add_conv_candidate \n \tPARAMS ((struct z_candidate *, tree, tree, tree));\n static struct z_candidate * add_function_candidate \n-\tPARAMS ((struct z_candidate *, tree, tree, int));\n+\tPARAMS ((struct z_candidate *, tree, tree, tree, int));\n static tree implicit_conversion PARAMS ((tree, tree, tree, int));\n static tree standard_conversion PARAMS ((tree, tree, tree));\n static tree reference_binding PARAMS ((tree, tree, tree, int));\n@@ -91,7 +91,7 @@ static int is_subseq PARAMS ((tree, tree));\n static int maybe_handle_ref_bind PARAMS ((tree*, tree*));\n static void maybe_handle_implicit_object PARAMS ((tree*));\n static struct z_candidate * add_candidate PARAMS ((struct z_candidate *,\n-\t\t\t\t\t\t tree, tree, int));\n+\t\t\t\t\t\t   tree, tree, int));\n static tree source_type PARAMS ((tree));\n static void add_warning PARAMS ((struct z_candidate *, struct z_candidate *));\n static int reference_related_p PARAMS ((tree, tree));\n@@ -879,7 +879,7 @@ convert_class_to_reference (t, s, expr)\n     {\n       tree fns = TREE_VALUE (conversions);\n \n-      while (fns)\n+      for (; fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree f = OVL_CURRENT (fns);\n \t  tree t2 = TREE_TYPE (TREE_TYPE (f));\n@@ -891,7 +891,7 @@ convert_class_to_reference (t, s, expr)\n \t    {\n \t      candidates \n \t\t= add_template_candidate (candidates,\n-\t\t\t\t\t  f,\n+\t\t\t\t\t  f, s,\n \t\t\t\t\t  NULL_TREE,\n \t\t\t\t\t  arglist,\n \t\t\t\t\t  build_reference_type (t),\n@@ -914,13 +914,11 @@ convert_class_to_reference (t, s, expr)\n \t  else if (TREE_CODE (t2) == REFERENCE_TYPE\n \t\t   && reference_compatible_p (t, TREE_TYPE (t2)))\n \t    candidates \n-\t      = add_function_candidate (candidates, f, arglist, \n+\t      = add_function_candidate (candidates, f, s, arglist, \n \t\t\t\t\tLOOKUP_NORMAL);\n \n \t  if (candidates != old_candidates)\n-\t    candidates->basetype_path = TREE_PURPOSE (conversions);\n-\n-\t  fns = OVL_NEXT (fns);\n+\t    candidates->basetype_path = TYPE_BINFO (s);\n \t}\n     }\n \n@@ -1235,12 +1233,15 @@ add_candidate (candidates, fn, convs, viable)\n \n /* Create an overload candidate for the function or method FN called with\n    the argument list ARGLIST and add it to CANDIDATES.  FLAGS is passed on\n-   to implicit_conversion.  */\n+   to implicit_conversion.\n+\n+   CTYPE, if non-NULL, is the type we want to pretend this function\n+   comes from for purposes of overload resolution.  */\n \n static struct z_candidate *\n-add_function_candidate (candidates, fn, arglist, flags)\n+add_function_candidate (candidates, fn, ctype, arglist, flags)\n      struct z_candidate *candidates;\n-     tree fn, arglist;\n+     tree fn, ctype, arglist;\n      int flags;\n {\n   tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n@@ -1307,25 +1308,31 @@ add_function_candidate (candidates, fn, arglist, flags)\n       tree arg = TREE_VALUE (argnode);\n       tree argtype = lvalue_type (arg);\n       tree t;\n+      int is_this;\n \n       if (parmnode == void_list_node)\n \tbreak;\n \n+      is_this = (i == 0 && DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n+\t\t && ! DECL_CONSTRUCTOR_P (fn));\n+\n       if (parmnode)\n \t{\n \t  tree parmtype = TREE_VALUE (parmnode);\n \n-\t  /* [over.match.funcs] For conversion functions, the function is\n-\t     considered to be a member of the class of the implicit object\n-\t     argument for the purpose of defining the type of the implicit\n-\t     object parameter.\n+\t  /* The type of the implicit object parameter ('this') for\n+\t     overload resolution is not always the same as for the\n+\t     function itself; conversion functions are considered to\n+\t     be members of the class being converted, and functions\n+\t     introduced by a using-declaration are considered to be\n+\t     members of the class that uses them.\n \n-\t     Since build_over_call ignores the ICS for the `this' parameter,\n-\t     we can just change the parm type.  */\n-\t  if (DECL_CONV_FN_P (fn) && i == 0)\n+\t     Since build_over_call ignores the ICS for the `this'\n+\t     parameter, we can just change the parm type.  */\n+\t  if (ctype && is_this)\n \t    {\n \t      parmtype\n-\t\t= build_qualified_type (TREE_TYPE (argtype),\n+\t\t= build_qualified_type (ctype,\n \t\t\t\t\tTYPE_QUALS (TREE_TYPE (parmtype)));\n \t      parmtype = build_pointer_type (parmtype);\n \t    }\n@@ -1338,8 +1345,7 @@ add_function_candidate (candidates, fn, arglist, flags)\n \t  ICS_ELLIPSIS_FLAG (t) = 1;\n \t}\n \n-      if (i == 0 && t && TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n-\t  && ! DECL_CONSTRUCTOR_P (fn))\n+      if (t && is_this)\n \tICS_THIS_FLAG (t) = 1;\n \n       TREE_VEC_ELT (convs, i) = t;\n@@ -2090,16 +2096,16 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n    TMPL is the template.  EXPLICIT_TARGS are any explicit template\n    arguments.  ARGLIST is the arguments provided at the call-site.\n    The RETURN_TYPE is the desired type for conversion operators.  If\n-   OBJ is NULL_TREE, FLAGS are as for add_function_candidate.  If an\n-   OBJ is supplied, FLAGS are ignored, and OBJ is as for\n+   OBJ is NULL_TREE, FLAGS and CTYPE are as for add_function_candidate.\n+   If an OBJ is supplied, FLAGS and CTYPE are ignored, and OBJ is as for\n    add_conv_candidate.  */\n \n static struct z_candidate*\n-add_template_candidate_real (candidates, tmpl, explicit_targs,\n+add_template_candidate_real (candidates, tmpl, ctype, explicit_targs,\n \t\t\t     arglist, return_type, flags,\n \t\t\t     obj, strict)\n      struct z_candidate *candidates;\n-     tree tmpl, explicit_targs, arglist, return_type;\n+     tree tmpl, ctype, explicit_targs, arglist, return_type;\n      int flags;\n      tree obj;\n      unification_kind_t strict;\n@@ -2124,7 +2130,8 @@ add_template_candidate_real (candidates, tmpl, explicit_targs,\n     /* Aha, this is a conversion function.  */\n     cand = add_conv_candidate (candidates, fn, obj, arglist);\n   else\n-    cand = add_function_candidate (candidates, fn, arglist, flags);\n+    cand = add_function_candidate (candidates, fn, ctype,\n+\t\t\t\t   arglist, flags);\n   if (DECL_TI_TEMPLATE (fn) != tmpl)\n     /* This situation can occur if a member template of a template\n        class is specialized.  Then, instantiate_template might return\n@@ -2152,16 +2159,16 @@ add_template_candidate_real (candidates, tmpl, explicit_targs,\n \n \n static struct z_candidate *\n-add_template_candidate (candidates, tmpl, explicit_targs, \n+add_template_candidate (candidates, tmpl, ctype, explicit_targs, \n \t\t\targlist, return_type, flags, strict)\n      struct z_candidate *candidates;\n-     tree tmpl, explicit_targs, arglist, return_type;\n+     tree tmpl, ctype, explicit_targs, arglist, return_type;\n      int flags;\n      unification_kind_t strict;\n {\n   return \n-    add_template_candidate_real (candidates, tmpl, explicit_targs,\n-\t\t\t\t arglist, return_type, flags,\n+    add_template_candidate_real (candidates, tmpl, ctype,\n+\t\t\t\t explicit_targs, arglist, return_type, flags,\n \t\t\t\t NULL_TREE, strict);\n }\n \n@@ -2172,8 +2179,8 @@ add_template_conv_candidate (candidates, tmpl, obj, arglist, return_type)\n      tree tmpl, obj, arglist, return_type;\n {\n   return \n-    add_template_candidate_real (candidates, tmpl, NULL_TREE, arglist,\n-\t\t\t\t return_type, 0, obj, DEDUCE_CONV);\n+    add_template_candidate_real (candidates, tmpl, NULL_TREE, NULL_TREE,\n+\t\t\t\t arglist, return_type, 0, obj, DEDUCE_CONV);\n }\n \n \n@@ -2290,12 +2297,12 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t{\n \t  templates = tree_cons (NULL_TREE, ctor, templates);\n \t  candidates = \n-\t    add_template_candidate (candidates, ctor,\n+\t    add_template_candidate (candidates, ctor, totype,\n \t\t\t\t    NULL_TREE, args, NULL_TREE, flags,\n \t\t\t\t    DEDUCE_CALL);\n \t} \n       else \n-\tcandidates = add_function_candidate (candidates, ctor,\n+\tcandidates = add_function_candidate (candidates, ctor, totype,\n \t\t\t\t\t     args, flags); \n \n       if (candidates) \n@@ -2336,16 +2343,23 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t    tree fn = OVL_CURRENT (fns);\n \t    struct z_candidate *old_candidates = candidates;\n \n+\t    /* [over.match.funcs] For conversion functions, the function is\n+\t       considered to be a member of the class of the implicit object\n+\t       argument for the purpose of defining the type of the implicit\n+\t       object parameter.\n+\n+\t       So we pass fromtype as CTYPE to add_*_candidate.  */\n+\n \t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t      {\n \t\ttemplates = tree_cons (NULL_TREE, fn, templates);\n \t\tcandidates = \n-\t\t  add_template_candidate (candidates, fn, NULL_TREE,\n+\t\t  add_template_candidate (candidates, fn, fromtype, NULL_TREE,\n \t\t\t\t\t  args, totype, flags,\n \t\t\t\t\t  DEDUCE_CONV);\n \t      } \n \t    else \n-\t      candidates = add_function_candidate (candidates, fn,\n+\t      candidates = add_function_candidate (candidates, fn, fromtype,\n \t\t\t\t\t\t   args, flags); \n \n \t    if (candidates != old_candidates)\n@@ -2356,7 +2370,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t\t     0, convflags);\n \n \t\tcandidates->second_conv = ics;\n-\t\tcandidates->basetype_path = TREE_PURPOSE (convs);\n+\t\tcandidates->basetype_path = TYPE_BINFO (fromtype);\n \n \t\tif (ics == NULL_TREE)\n \t\t  candidates->viable = 0;\n@@ -2491,21 +2505,17 @@ build_new_function_call (fn, args)\n       for (t1 = fn; t1; t1 = OVL_CHAIN (t1))\n \t{\n \t  tree t = OVL_FUNCTION (t1);\n-\t  struct z_candidate *old_candidates = candidates;\n \n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t    {\n \t      templates = tree_cons (NULL_TREE, t, templates);\n \t      candidates = add_template_candidate\n-\t\t(candidates, t, explicit_targs, args, NULL_TREE,\n+\t\t(candidates, t, NULL_TREE, explicit_targs, args, NULL_TREE,\n \t\t LOOKUP_NORMAL, DEDUCE_CALL);  \n \t    }\n \t  else if (! template_only)\n \t    candidates = add_function_candidate\n-\t      (candidates, t, args, LOOKUP_NORMAL);\n-\n-\t  if (candidates != old_candidates)\n-\t    candidates->basetype_path = CP_DECL_CONTEXT (t);\n+\t      (candidates, t, NULL_TREE, args, LOOKUP_NORMAL);\n \t}\n \n       if (! any_viable (candidates))\n@@ -2572,7 +2582,7 @@ build_object_call (obj, args)\n \n   if (fns)\n     {\n-      tree base = TREE_PURPOSE (fns);\n+      tree base = BINFO_TYPE (TREE_PURPOSE (fns));\n       mem_args = tree_cons (NULL_TREE, build_this (obj), args);\n \n       for (fns = TREE_VALUE (fns); fns; fns = OVL_NEXT (fns))\n@@ -2581,16 +2591,16 @@ build_object_call (obj, args)\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    {\n \t      candidates \n-\t\t= add_template_candidate (candidates, fn, NULL_TREE,\n+\t\t= add_template_candidate (candidates, fn, base, NULL_TREE,\n \t\t\t\t\t  mem_args, NULL_TREE, \n \t\t\t\t\t  LOOKUP_NORMAL, DEDUCE_CALL);\n \t    }\n \t  else\n \t    candidates = add_function_candidate\n-\t      (candidates, fn, mem_args, LOOKUP_NORMAL);\n+\t      (candidates, fn, base, mem_args, LOOKUP_NORMAL);\n \n \t  if (candidates)\n-\t    candidates->basetype_path = base;\n+\t    candidates->basetype_path = TYPE_BINFO (type);\n \t}\n     }\n \n@@ -2617,9 +2627,6 @@ build_object_call (obj, args)\n \t      }\n \t    else\n \t      candidates = add_conv_candidate (candidates, fn, obj, args);\n-\n-\t    if (candidates)\n-\t      candidates->basetype_path = TREE_PURPOSE (convs);\n \t  }\n     }\n \n@@ -3184,12 +3191,13 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t{\n \t  templates = tree_cons (NULL_TREE, fn, templates);\n \t  candidates \n-\t    = add_template_candidate (candidates, fn, NULL_TREE,\n+\t    = add_template_candidate (candidates, fn, NULL_TREE, NULL_TREE,\n \t\t\t\t      arglist, TREE_TYPE (fnname),\n \t\t\t\t      flags, DEDUCE_CALL); \n \t}\n       else\n-\tcandidates = add_function_candidate (candidates, fn, arglist, flags);\n+\tcandidates = add_function_candidate (candidates, fn, NULL_TREE,\n+\t\t\t\t\t     arglist, flags);\n     }\n \n   if (IS_AGGR_TYPE (TREE_TYPE (arg1)))\n@@ -3203,7 +3211,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \n   if (fns)\n     {\n-      tree basetype = TREE_PURPOSE (fns);\n+      tree basetype = BINFO_TYPE (TREE_PURPOSE (fns));\n       mem_arglist = tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n       for (fns = TREE_VALUE (fns); fns; fns = OVL_NEXT (fns))\n \t{\n@@ -3220,16 +3228,16 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t      /* A member template. */\n \t      templates = tree_cons (NULL_TREE, fn, templates);\n \t      candidates \n-\t\t= add_template_candidate (candidates, fn, NULL_TREE,\n+\t\t= add_template_candidate (candidates, fn, basetype, NULL_TREE,\n \t\t\t\t\t  this_arglist,  TREE_TYPE (fnname),\n \t\t\t\t\t  flags, DEDUCE_CALL); \n \t    }\n \t  else\n \t    candidates = add_function_candidate\n-\t      (candidates, fn, this_arglist, flags);\n+\t      (candidates, fn, basetype, this_arglist, flags);\n \n-\t  if (candidates) \n-\t    candidates->basetype_path = basetype;\n+\t  if (candidates)\n+\t    candidates->basetype_path = TYPE_BINFO (TREE_TYPE (arg1));\n \t}\n     }\n \n@@ -3547,7 +3555,7 @@ build_op_delete_call (code, addr, size, flags, placement)\n     {\n       if (TREE_CODE (fns) == TREE_LIST)\n \t/* Member functions.  */\n-\tenforce_access (TREE_PURPOSE (fns), fn);\n+\tenforce_access (type, fn);\n       return build_function_call (fn, tree_cons (NULL_TREE, addr, args));\n     }\n \n@@ -3567,7 +3575,7 @@ build_op_delete_call (code, addr, size, flags, placement)\n     {\n       if (BASELINK_P (fns))\n \t/* Member functions.  */\n-\tenforce_access (TREE_PURPOSE (fns), fn);\n+\tenforce_access (type, fn);\n       return build_function_call\n \t(fn, tree_cons (NULL_TREE, addr,\n \t\t\tbuild_tree_list (NULL_TREE, size)));\n@@ -4254,6 +4262,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     return error_mark_node;\n   if (fns)\n     {\n+      tree base = BINFO_TYPE (TREE_PURPOSE (fns));\n       tree fn = TREE_VALUE (fns);\n       if (name == ctor_identifier && TYPE_USES_VIRTUAL_BASECLASSES (basetype)\n \t  && ! (flags & LOOKUP_HAS_IN_CHARGE))\n@@ -4282,16 +4291,16 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t      /* A member template. */\n \t      templates = tree_cons (NULL_TREE, t, templates);\n \t      candidates = \n-\t\tadd_template_candidate (candidates, t, explicit_targs,\n+\t\tadd_template_candidate (candidates, t, base, explicit_targs,\n \t\t\t\t\tthis_arglist,\n \t\t\t\t\tTREE_TYPE (name), flags, DEDUCE_CALL); \n \t    }\n \t  else if (! template_only)\n-\t    candidates = add_function_candidate (candidates, t,\n+\t    candidates = add_function_candidate (candidates, t, base,\n \t\t\t\t\t\t this_arglist, flags);\n \n \t  if (candidates)\n-\t    candidates->basetype_path = TREE_PURPOSE (fns);\n+\t    candidates->basetype_path = basetype_path;\n \t}\n     }\n "}, {"sha": "d186027ae1de7ded565ee4565f6c4061d6e1c76a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 64, "deletions": 68, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=aa52c1ffad50ffe721a19a816f474c56958b1d3a", "patch": "@@ -91,7 +91,7 @@ static void add_virtual_function PARAMS ((tree *, tree *, int *, tree, tree));\n static tree delete_duplicate_fields_1 PARAMS ((tree, tree));\n static void delete_duplicate_fields PARAMS ((tree));\n static void finish_struct_bits PARAMS ((tree));\n-static int alter_access PARAMS ((tree, tree, tree, tree));\n+static int alter_access PARAMS ((tree, tree, tree));\n static void handle_using_decl PARAMS ((tree, tree));\n static int overrides PARAMS ((tree, tree));\n static int strictly_overrides PARAMS ((tree, tree));\n@@ -1441,8 +1441,7 @@ void\n add_method (type, fields, method)\n      tree type, *fields, method;\n {\n-  /* Setting the DECL_CONTEXT here is probably redundant.  */\n-  DECL_CONTEXT (method) = type;\n+  int using = (DECL_CONTEXT (method) != type);\n   \n   if (fields && *fields)\n     *fields = build_overload (method, *fields);\n@@ -1558,20 +1557,27 @@ add_method (type, fields, method)\n \t\t     same name and the same parameter types cannot be\n \t\t     overloaded if any of them is a static member\n \t\t     function declaration.  */\n-\t\t  if (DECL_STATIC_FUNCTION_P (fn)\n-\t\t      != DECL_STATIC_FUNCTION_P (method))\n+\t\t  if ((DECL_STATIC_FUNCTION_P (fn)\n+\t\t       != DECL_STATIC_FUNCTION_P (method))\n+\t\t      || using)\n \t\t    {\n \t\t      tree parms1 = TYPE_ARG_TYPES (TREE_TYPE (fn));\n \t\t      tree parms2 = TYPE_ARG_TYPES (TREE_TYPE (method));\n \n \t\t      if (! DECL_STATIC_FUNCTION_P (fn))\n \t\t\tparms1 = TREE_CHAIN (parms1);\n-\t\t      else\n+\t\t      if (! DECL_STATIC_FUNCTION_P (method))\n \t\t\tparms2 = TREE_CHAIN (parms2);\n \n \t\t      if (compparms (parms1, parms2))\n-\t\t\tcp_error (\"`%#D' and `%#D' cannot be overloaded\",\n-\t\t\t\t  fn, method);\n+\t\t\t{\n+\t\t\t  if (using)\n+\t\t\t    /* Defer to the local function.  */\n+\t\t\t    return;\n+\t\t\t  else\n+\t\t\t    cp_error (\"`%#D' and `%#D' cannot be overloaded\",\n+\t\t\t\t      fn, method);\n+\t\t\t}\n \t\t    }\n \n \t\t  /* Since this is an ordinary function in a\n@@ -1715,14 +1721,12 @@ delete_duplicate_fields (fields)\n     TREE_CHAIN (x) = delete_duplicate_fields_1 (x, TREE_CHAIN (x));\n }\n \n-/* Change the access of FDECL to ACCESS in T.  The access to FDECL is\n-   along the path given by BINFO.  Return 1 if change was legit,\n-   otherwise return 0.  */\n+/* Change the access of FDECL to ACCESS in T.  Return 1 if change was\n+   legit, otherwise return 0.  */\n \n static int\n-alter_access (t, binfo, fdecl, access)\n+alter_access (t, fdecl, access)\n      tree t;\n-     tree binfo;\n      tree fdecl;\n      tree access;\n {\n@@ -1746,7 +1750,7 @@ alter_access (t, binfo, fdecl, access)\n     }\n   else\n     {\n-      enforce_access (binfo, fdecl);\n+      enforce_access (t, fdecl);\n       DECL_ACCESS (fdecl) = tree_cons (t, access, DECL_ACCESS (fdecl));\n       return 1;\n     }\n@@ -1768,11 +1772,7 @@ handle_using_decl (using_decl, t)\n     : access_public_node;\n   tree fdecl, binfo;\n   tree flist = NULL_TREE;\n-  tree fields = TYPE_FIELDS (t);\n-  tree method_vec = CLASSTYPE_METHOD_VEC (t);\n-  tree tmp;\n-  int i;\n-  int n_methods;\n+  tree old_value;\n \n   binfo = binfo_or_else (ctype, t);\n   if (! binfo)\n@@ -1793,57 +1793,58 @@ handle_using_decl (using_decl, t)\n       return;\n     }\n \n-  /* Functions are represented as TREE_LIST, with the purpose\n-     being the type and the value the functions. Other members\n-     come as themselves. */\n-  if (TREE_CODE (fdecl) == TREE_LIST)\n+  if (BASELINK_P (fdecl))\n     /* Ignore base type this came from. */\n     fdecl = TREE_VALUE (fdecl);\n \n-  if (TREE_CODE (fdecl) == OVERLOAD)\n+  old_value = IDENTIFIER_CLASS_VALUE (name);\n+  if (old_value)\n     {\n-      /* We later iterate over all functions. */\n-      flist = fdecl;\n-      fdecl = OVL_FUNCTION (flist);\n+      if (is_overloaded_fn (old_value))\n+\told_value = OVL_CURRENT (old_value);\n+\n+      if (DECL_P (old_value) && DECL_CONTEXT (old_value) == t)\n+\t/* OK */;\n+      else\n+\told_value = NULL_TREE;\n     }\n-  \n-  name = DECL_NAME (fdecl);\n-  n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n-  for (i = 2; i < n_methods && TREE_VEC_ELT (method_vec, i); i++)\n-    if (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i)))\n-\t== name)\n-      {\n-\tcp_error (\"cannot adjust access to `%#D' in `%#T'\", fdecl, t);\n-\tcp_error_at (\"  because of local method `%#D' with same name\",\n-\t\t     OVL_CURRENT (TREE_VEC_ELT (method_vec, i)));\n-\treturn;\n-      }\n \n-  if (! DECL_LANG_SPECIFIC (fdecl))\n-    /* We don't currently handle DECL_ACCESS for TYPE_DECLs; just return.  */\n-    return;\n-  \n-  for (tmp = fields; tmp; tmp = TREE_CHAIN (tmp))\n-    if (DECL_NAME (tmp) == name)\n-      {\n-\tcp_error (\"cannot adjust access to `%#D' in `%#T'\", fdecl, t);\n-\tcp_error_at (\"  because of local field `%#D' with same name\", tmp);\n-\treturn;\n-      }\n-  \n-  /* Make type T see field decl FDECL with access ACCESS.*/\n-  if (flist)\n+  if (is_overloaded_fn (fdecl))\n+    flist = fdecl;\n+  else if (! DECL_LANG_SPECIFIC (fdecl))\n+    my_friendly_abort (20000221);\n+\n+  if (! old_value)\n+    ;\n+  else if (is_overloaded_fn (old_value))\n     {\n-      while (flist)\n+      if (flist)\n+\t/* It's OK to use functions from a base when there are functions with\n+\t   the same name already present in the current class.  */;\n+      else\n \t{\n-\t  if (alter_access (t, binfo, OVL_FUNCTION (flist), \n-\t\t\t    access) == 0)\n-\t    return;\n-\t  flist = OVL_CHAIN (flist);\n+\t  cp_error (\"`%D' invalid in `%#T'\", using_decl, t);\n+\t  cp_error_at (\"  because of local method `%#D' with same name\",\n+\t\t       OVL_CURRENT (old_value));\n+\t  return;\n \t}\n     }\n   else\n-    alter_access (t, binfo, fdecl, access);\n+    {\n+      cp_error (\"`%D' invalid in `%#T'\", using_decl, t);\n+      cp_error_at (\"  because of local field `%#D' with same name\", old_value);\n+      return;\n+    }\n+  \n+  /* Make type T see field decl FDECL with access ACCESS.*/\n+  if (flist)\n+    for (; flist; flist = OVL_NEXT (flist))\n+      {\n+\tadd_method (t, 0, OVL_CURRENT (flist));\n+\talter_access (t, OVL_CURRENT (flist), access);\n+      }\n+  else\n+    alter_access (t, fdecl, access);\n }\n \f\n /* Run through the base clases of T, updating\n@@ -4413,17 +4414,12 @@ check_bases_and_members (t, empty_p)\n \t\t\t\t   cant_have_const_ctor,\n \t\t\t\t   no_const_asn_ref);\n \n+  /* Process the using-declarations.  */\n+  for (; access_decls; access_decls = TREE_CHAIN (access_decls))\n+    handle_using_decl (TREE_VALUE (access_decls), t);\n+\n   /* Build and sort the CLASSTYPE_METHOD_VEC.  */\n   finish_struct_methods (t);\n-\n-  /* Process the access-declarations.  We wait until now to do this\n-     because handle_using_decls requires that the CLASSTYPE_METHOD_VEC\n-     be set up correctly.  */\n-  while (access_decls)\n-    {\n-      handle_using_decl (TREE_VALUE (access_decls), t);\n-      access_decls = TREE_CHAIN (access_decls);\n-    }\n }\n \n /* If T needs a pointer to its virtual function table, set TYPE_VFIELD"}, {"sha": "6902232a31df10eabd040a95c550000ee34e34a2", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=aa52c1ffad50ffe721a19a816f474c56958b1d3a", "patch": "@@ -635,15 +635,7 @@ tree\n convert_pointer_to (binfo, expr)\n      tree binfo, expr;\n {\n-  tree type;\n-\n-  if (TREE_CODE (binfo) == TREE_VEC)\n-    type = BINFO_TYPE (binfo);\n-  else if (IS_AGGR_TYPE (binfo))\n-    type = binfo;\n-  else\n-    type = binfo;\n-  return convert_pointer_to_real (type, expr);\n+  return convert_pointer_to_real (binfo, expr);\n }\n \f\n /* C++ conversions, preference to static cast conversions.  */"}, {"sha": "69a4e3a7bc0552a85e7d8dcf3bc60e0726a5fdb6", "filename": "gcc/cp/init.c", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=aa52c1ffad50ffe721a19a816f474c56958b1d3a", "patch": "@@ -1611,8 +1611,7 @@ build_offset_ref (type, name)\n   if (member == error_mark_node)\n     return error_mark_node;\n \n-  /* A lot of this logic is now handled in lookup_field and\n-     lookup_fnfield.  */\n+  /* A lot of this logic is now handled in lookup_member.  */\n   if (member && BASELINK_P (member))\n     {\n       /* Go from the TREE_BASELINK to the member function info.  */\n@@ -1648,7 +1647,6 @@ build_offset_ref (type, name)\n \t  t = OVL_CURRENT (t);\n \n \t  /* unique functions are handled easily.  */\n-\t  basebinfo = TREE_PURPOSE (fnfields);\n \t  if (!enforce_access (basebinfo, t))\n \t    return error_mark_node;\n \t  mark_used (t);\n@@ -1776,29 +1774,24 @@ resolve_offset_ref (exp)\n   if (TREE_CODE (member) == FIELD_DECL\n       && (base == current_class_ref || is_dummy_object (base)))\n     {\n-      tree basetype_path;\n       tree expr;\n \n+      basetype = DECL_CONTEXT (member);\n+\n+      /* Try to get to basetype from 'this'; if that doesn't work,\n+         nothing will.  */\n+      base = current_class_ref;\n+\n+      /* First convert to the intermediate base specified, if appropriate.  */\n       if (TREE_CODE (exp) == OFFSET_REF && TREE_CODE (type) == OFFSET_TYPE)\n-\tbasetype = TYPE_OFFSET_BASETYPE (type);\n-      else\n-\tbasetype = DECL_CONTEXT (member);\n+\tbase = build_scoped_ref (base, TYPE_OFFSET_BASETYPE (type));\n \n-      base = current_class_ptr;\n+      addr = build_unary_op (ADDR_EXPR, base, 0);\n+      addr = convert_pointer_to (basetype, addr);\n+\n+      if (addr == error_mark_node)\n+\treturn error_mark_node;\n \n-      if (get_base_distance (basetype, TREE_TYPE (TREE_TYPE (base)), 0, &basetype_path) < 0)\n-\t{\n-\t  error_not_base_type (basetype, TREE_TYPE (TREE_TYPE (base)));\n-\t  return error_mark_node;\n-\t}\n-      /* Kludge: we need to use basetype_path now, because\n-\t convert_pointer_to will bash it.  */\n-      enforce_access (basetype_path, member);\n-      addr = convert_pointer_to (basetype, base);\n-\n-      /* Even in the case of illegal access, we form the\n-\t COMPONENT_REF; that will allow better error recovery than\n-\t just feeding back error_mark_node.  */\n       expr = build (COMPONENT_REF, TREE_TYPE (member),\n \t\t    build_indirect_ref (addr, NULL_PTR), member);\n       return convert_from_reference (expr);"}, {"sha": "4b604eb3caed708f15e60651804084ee7727a744", "filename": "gcc/cp/search.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=aa52c1ffad50ffe721a19a816f474c56958b1d3a", "patch": "@@ -1606,7 +1606,15 @@ lookup_member (xbasetype, name, protect, want_type)\n \n   if (rval && is_overloaded_fn (rval)) \n     {\n-      rval = tree_cons (basetype_path, rval, NULL_TREE);\n+      /* Note that the binfo we put in the baselink is the binfo where\n+\t we found the functions, which we need for overload\n+\t resolution, but which should not be passed to enforce_access;\n+\t rather, enforce_access wants a binfo which refers to the\n+\t scope in which we started looking for the function.  This\n+\t will generally be the binfo passed into this function as\n+\t xbasetype.  */\n+\n+      rval = tree_cons (rval_binfo, rval, NULL_TREE);\n       SET_BASELINK_P (rval);\n     }\n "}, {"sha": "ae018006bb42320ca0a7920f431f64dfae026b23", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=aa52c1ffad50ffe721a19a816f474c56958b1d3a", "patch": "@@ -2151,7 +2151,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t  if (DECL_STATIC_FUNCTION_P (TREE_VALUE (fndecls)))\n \t\t    {\n \t\t      tree fndecl = TREE_VALUE (fndecls);\n-\t\t      enforce_access (TREE_PURPOSE (fndecls), fndecl);\n+\t\t      enforce_access (basetype_path, fndecl);\n \t\t      mark_used (fndecl);\n \t\t      return fndecl;\n \t\t    }\n@@ -2221,7 +2221,8 @@ build_component_ref (datum, component, basetype_path, protect)\n \t  else\n \t    addr = convert_pointer_to (base, addr);\n \t  datum = build_indirect_ref (addr, NULL_PTR);\n-\t  my_friendly_assert (datum != error_mark_node, 311);\n+\t  if (datum == error_mark_node)\n+\t    return error_mark_node;\n \t}\n       basetype = base;\n  "}, {"sha": "88ddc89d9879fd3188eedd6ada481995be1d4b54", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa52c1ffad50ffe721a19a816f474c56958b1d3a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=aa52c1ffad50ffe721a19a816f474c56958b1d3a", "patch": "@@ -1031,7 +1031,11 @@ process_init_constructor (type, init, elts)\n \n    x.A::ii refers to the ii member of the L part of\n    the A part of the C object named by X.  In this case,\n-   DATUM would be x, and BASETYPE would be A.  */\n+   DATUM would be x, and BASETYPE would be A.\n+\n+   Note that this is nonconformant; the standard specifies that first\n+   we look up ii in A, then convert x to an L& and pull out the ii part.\n+   But narrowing seems to be standard practice, so let's do it anyway.  */\n \n tree\n build_scoped_ref (datum, basetype)\n@@ -1044,43 +1048,15 @@ build_scoped_ref (datum, basetype)\n   if (datum == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n-\n-  type = TYPE_MAIN_VARIANT (type);\n+  /* Don't do this if it would cause an error or if we're being pedantic.  */\n+  if (! ACCESSIBLY_UNIQUELY_DERIVED_P (basetype, type)\n+      || pedantic)\n+    return datum;\n \n-  /* This is an easy conversion.  */\n-  if (is_aggr_type (basetype, 1))\n-    {\n-      tree binfo = TYPE_BINFO (basetype);\n-      if (binfo != TYPE_BINFO (type))\n-\t{\n-\t  binfo = get_binfo (binfo, type, 1);\n-\t  if (binfo == error_mark_node)\n-\t    return error_mark_node;\n-\t  if (binfo == 0)\n-\t    return error_not_base_type (basetype, type);\n-\t}\n+  ref = build_unary_op (ADDR_EXPR, datum, 0);\n+  ref = convert_pointer_to (basetype, ref);\n \n-      switch (TREE_CODE (datum))\n-\t{\n-\tcase NOP_EXPR:\n-\tcase CONVERT_EXPR:\n-\tcase FLOAT_EXPR:\n-\tcase FIX_TRUNC_EXPR:\n-\tcase FIX_FLOOR_EXPR:\n-\tcase FIX_ROUND_EXPR:\n-\tcase FIX_CEIL_EXPR:\n-\t  ref = convert_pointer_to (binfo,\n-\t\t\t\t    build_unary_op (ADDR_EXPR, TREE_OPERAND (datum, 0), 0));\n-\t  break;\n-\tdefault:\n-\t  ref = convert_pointer_to (binfo,\n-\t\t\t\t    build_unary_op (ADDR_EXPR, datum, 0));\n-\t}\n-      return build_indirect_ref (ref, \"(compiler error in build_scoped_ref)\");\n-    }\n-  return error_mark_node;\n+  return build_indirect_ref (ref, \"(compiler error in build_scoped_ref)\");\n }\n \n /* Build a reference to an object specified by the C++ `->' operator."}]}