{"sha": "5ba6e819ef513bff725602ef1cd94e389f6a4eb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJhNmU4MTllZjUxM2JmZjcyNTYwMmVmMWNkOTRlMzg5ZjZhNGViOA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:38Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-08-27T20:51:38Z"}, "message": "\ufffd\nMigrate from devo/gcc/ch.\n\nFrom-SVN: r22031", "tree": {"sha": "4d13df31386563867a6ca7a5b23b0975afdbb68b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d13df31386563867a6ca7a5b23b0975afdbb68b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ba6e819ef513bff725602ef1cd94e389f6a4eb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ba6e819ef513bff725602ef1cd94e389f6a4eb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ba6e819ef513bff725602ef1cd94e389f6a4eb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ba6e819ef513bff725602ef1cd94e389f6a4eb8/comments", "author": null, "committer": null, "parents": [{"sha": "f62502329f678b44c082429ccf4e705700c4d5ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62502329f678b44c082429ccf4e705700c4d5ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f62502329f678b44c082429ccf4e705700c4d5ea"}], "stats": {"total": 1322, "additions": 1322, "deletions": 0}, "files": [{"sha": "8a3da0079748dc61e10cb97374ebab6592dec02d", "filename": "gcc/ch/ch-tree.h", "status": "added", "additions": 1170, "deletions": 0, "changes": 1170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ba6e819ef513bff725602ef1cd94e389f6a4eb8/gcc%2Fch%2Fch-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ba6e819ef513bff725602ef1cd94e389f6a4eb8/gcc%2Fch%2Fch-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fch-tree.h?ref=5ba6e819ef513bff725602ef1cd94e389f6a4eb8", "patch": "@@ -0,0 +1,1170 @@\n+/* Definitions for CHILL parsing and type checking.\n+   Copyright (C) 1992, 93, 1994 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef _CH_TREE_H\n+#define _CH_TREE_H\n+\n+#include <stdio.h>\n+\n+/* Usage of TREE_LANG_FLAG_?:\n+   1: TUPLE_NAMED_FIELD\n+   \"  TYPE_FIELDS_READONLY (in ARRAY_TYPE, RECORD_TYPE or UNION_TYPE)\n+   \"  C_DECLARED_LABEL_FLAG\n+   \"  C_TYPE_VARIABLE_SIZE\n+   2: C_TYPE_FIELDS_VOLATILE (in RECORD_TYPE or UNION_TYPE)\n+   \"  ELSE_LABEL_SPECIFIED (in CASE selector expression)\n+   3: UNSATISFIED_FLAG\n+   4: CH_USE_SEIZEFILE_RESTRICTED\n+   \"  CH_ALREADY_GRANTED\n+   5: CH_DERIVED_FLAG   (in EXPR or DECL)\n+*/\n+\n+/* Usage of TYPE_LANG_FLAG_?:\n+   0: CH_TYPE_NONVALUE_P\n+   1: C_TYPE_VARIABLE_SIZE\n+   2: CH_IS_ACCESS_MODE  \n+   3: CH_IS_BUFFER_MODE\n+   4: CH_IS_EVENT_MODE\n+   5: CH_ENUM_IS_NUMBERED\n+   6: CH_IS_TEXT_MODE\n+*/\n+\n+/* Language-dependent contents of an identifier.  */\n+\n+struct lang_identifier\n+{\n+  /* These match the fields in c-tree.h. */\n+  struct tree_identifier ignore;\n+  tree outer_value, local_value, implicit_decl;\n+  tree error_locus, limbo_value;\n+\n+  /* These are Chill-specific. */\n+  tree forbid;\n+  tree signal_dest;\n+  int  signal_data;\n+};\n+\n+/* Macros for access to language-specific slots in an identifier.  */\n+\n+/* The outer_value is a chain of decls (normally a single decl),\n+   that have been granted into the scope surrounding all modules. */\n+#define IDENTIFIER_OUTER_VALUE(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->outer_value)\n+#define IDENTIFIER_LOCAL_VALUE(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->local_value)\n+#define IDENTIFIER_IMPLICIT_DECL(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->implicit_decl)\n+#define IDENTIFIER_ERROR_LOCUS(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->error_locus)\n+#define IDENTIFIER_FORBID(NODE)         \\\n+  (((struct lang_identifier *)(NODE))->forbid)\n+\n+/* The nesting level increates by one for every nested 'group'.\n+   Predefined declarations have level -1; the global scope is level 0.\n+ */\n+#define DECL_NESTING_LEVEL(DECL) \\\n+   ((DECL)->decl.vindex ? TREE_INT_CST_LOW((DECL)->decl.vindex) : -1)\n+\n+/* Nesting of things that can have an ON-unit attached. */\n+extern int action_nesting_level;\n+\n+/* The DECL_NAME of a FIELD_DECL that represents the ELSE part of a variant. */\n+#define ELSE_VARIANT_NAME ridpointers[(int) RID_ELSE]\n+\n+/* For a LABEL_DECL:  action_nesting_level of its target. */\n+#define DECL_ACTION_NESTING_LEVEL(NODE) ((NODE)->decl.saved_insns.i)\n+\n+#define DECL_OLD_PREFIX(DECL) ((DECL)->decl.initial)\n+#define DECL_NEW_PREFIX(DECL) ((DECL)->decl.result)\n+#define DECL_POSTFIX(DECL) ((DECL)->decl.arguments)\n+extern tree ALL_POSTFIX;\n+#define DECL_SEIZEFILE(DECL) ((DECL)->decl.size)\n+#define DECL_POSTFIX_ALL(DECL) (DECL_POSTFIX(DECL) == ALL_POSTFIX)\n+#define DECL_OLD_NAME(DECL) decl_old_name(DECL)\n+/* For a siezefile name this means restricted usage of this file.\n+   In this case, the USE_SEIZE_FILE directive will not be copied\n+   into the grant file */\n+#define CH_USE_SEIZEFILE_RESTRICTED(NODE) TREE_LANG_FLAG_4(NODE)\n+extern tree decl_old_name PROTO ((tree));\n+\n+/* for selective granting, mark as already granted */\n+#define CH_ALREADY_GRANTED(NODE) TREE_LANG_FLAG_4(NODE)\n+\n+/* to store the receiving process of that signal\n+   at definition time */\n+#define IDENTIFIER_SIGNAL_DEST(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->signal_dest)\n+\n+/* indicates a signal with no data */\n+#define IDENTIFIER_SIGNAL_DATA(NODE)\t\\\n+  (((struct lang_identifier *)(NODE))->signal_data)\n+\n+/* In identifiers, C uses the following fields in a special way:\n+   TREE_PUBLIC        to record that there was a previous local extern decl.\n+   TREE_USED          to record that such a decl was used.\n+   TREE_ADDRESSABLE   to record that the address of such a decl was used.  */\n+\n+/* Nonzero means reject anything that Z.200 Recommendation forbids.  */\n+extern int pedantic;\n+\n+/* the prototypical CHILL INSTANCE type */\n+extern tree instance_type_node;\n+\n+/* Non-zero if type or expr depends on non-resolved identifier. */\n+#define UNSATISFIED(expr) \\\n+  (UNSATISFIED_FLAG (expr) || TREE_CODE (expr) == IDENTIFIER_NODE)\n+#define UNSATISFIED_FLAG(expr) TREE_LANG_FLAG_3 (expr)\n+\n+/* Non-zero in a TREE_LIST if part of a labelled structure tuple. */\n+#define TUPLE_NAMED_FIELD(LIST) TREE_LANG_FLAG_1(LIST)\n+\n+/* In an ARRAY_TYPE, RECORD_TYPE or UNION_TYPE, nonzero if any component\n+   is read-only.  */\n+#define TYPE_FIELDS_READONLY(type) TREE_LANG_FLAG_1 (type)\n+\n+/* True if TYPE has the \"read-only property.\" */\n+#define TYPE_READONLY_PROPERTY(TYPE) \\\n+  (TYPE_READONLY (TYPE) || TYPE_FIELDS_READONLY (TYPE))\n+\n+/* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is volatile.  */\n+#define C_TYPE_FIELDS_VOLATILE(type) TREE_LANG_FLAG_2 (type)\n+\n+/* In a CASE selector expression, nonzero if any alternative specifies (ELSE) for\n+   that selector. */\n+#define ELSE_LABEL_SPECIFIED(expr) TREE_LANG_FLAG_2 (expr)\n+\n+/* CH_CHARS_TYPE_P(TYPE) is true iff TYPE is a character string type.\n+\n+   There is no essential difference between a string and a (one-dimensional)\n+   character array, at least for non-varying types.  I don't know where\n+   the Chill designers got the idea that it was useful to make a distinction.\n+   (I suspect packing might be involved, but on a byte-adressable machine\n+   we don't care.)  Since we want the same code to be generated for\n+   char arrays as for char strings, we use the same representation for\n+   both.  But we still need to distinguish them for the sake a Chill\n+   type checking.  We do that using TYPE_STRING_FLAG. */\n+\n+#define MARK_AS_STRING_TYPE(TYPE) (TYPE_STRING_FLAG (TYPE) = 1)\n+\n+#define CH_CHARS_TYPE_P(type) \\\n+  (TREE_CODE (type) == ARRAY_TYPE && TREE_CODE(TREE_TYPE(type)) == CHAR_TYPE \\\n+   && TYPE_STRING_FLAG (type))\n+\n+/* True if TYPE is CHARS(1). */\n+#define CH_CHARS_ONE_P(TYPE) (CH_CHARS_TYPE_P(TYPE) \\\n+   && integer_zerop (TYPE_MAX_VALUE (TYPE_DOMAIN (TYPE))))\n+\n+/* True if TYPE is a bitstring (BOOLS or BIT) type.\n+   The TYPE_STRING_FLAG is used to distinguish a bitstring from a powerset. */\n+\n+#define CH_BOOLS_TYPE_P(type) \\\n+  (TREE_CODE (type) == SET_TYPE && TYPE_STRING_FLAG (type))\n+\n+/* True if TYPE is BOOLS(1). */\n+#define CH_BOOLS_ONE_P(TYPE) (CH_BOOLS_TYPE_P(TYPE) \\\n+   && integer_zerop (TYPE_MAX_VALUE (TYPE_DOMAIN (TYPE))))\n+\n+/* Value is nonzero if TYPE is a CHILL string type.\n+   See CH_CHARS_TYPE_P and CH_BOOLS_TYPE_P above. */\n+\n+#define CH_STRING_TYPE_P(type) \\\n+ ((TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == SET_TYPE) \\\n+  && TYPE_STRING_FLAG (type))\n+\n+/* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n+struct lang_type_record\n+{\n+  int  len;\n+  tree tasking_code_decl;\n+  tree elts[1];\n+};\n+\n+struct lang_type\n+{\n+  union\n+    {\n+      struct lang_type_record rec;\n+    } foo;\n+};\n+\n+struct lang_decl\n+{\n+  union\n+    {\n+      tree stuff;\n+    } foo;\n+};\n+/* A tasking type's corresponding tasking_code_variable has its\n+   decl pointer in here. */\n+#define DECL_TASKING_CODE_DECL(DECL) (DECL_LANG_SPECIFIC(DECL))\n+\n+/* A pointer to an as-yet undefined type.  */\n+extern tree unknown_type_node;\n+\n+/* The CHILL type INT (either integer_type_node or \n+   short_integer_type_node). */\n+extern tree chill_integer_type_node;\n+extern tree chill_unsigned_type_node;\n+\n+/* Nonzero for FIELD_DECL node means that this FIELD_DECL is\n+   a member of a union construct.  */\n+#define TREE_UNION_ELEM(NODE) ((NODE)->decl.regdecl_flag) /* overloaded! */\n+\n+/* Mark which labels are explicitly declared.\n+   These may be shadowed, and may be referenced from nested functions.  */\n+#define C_DECLARED_LABEL_FLAG(label) TREE_LANG_FLAG_1 (label)\n+\n+/* Record whether a type was written with nonconstant size.\n+   Note that TYPE_SIZE may have simplified to a constant.  */\n+#define C_TYPE_VARIABLE_SIZE(type) TYPE_LANG_FLAG_1 (type)\n+\n+#define DECL_WEAK_NAME(DECL) DECL_LANG_FLAG_0(DECL)\n+\n+/* These are for FUNCTION_DECLs.  */\n+#define CH_DECL_GENERAL(DECL) DECL_LANG_FLAG_1(DECL)\n+#define CH_DECL_SIMPLE(DECL) DECL_LANG_FLAG_2(DECL)\n+#define CH_DECL_RECURSIVE(DECL) DECL_LANG_FLAG_3(DECL)\n+#define CH_FUNCTION_SETS_RESULT(DECL) DECL_LANG_FLAG_6(DECL)\n+\n+/* For a CONST_DECL, indicates that it was implicitly declared\n+   in a SET mode declaration, and it should not be explicitly granted. */\n+#define CH_DECL_ENUM(DECL)  DECL_LANG_FLAG_3(DECL)\n+\n+/* in a FIELD_DECL use DECL_LANG_FLAG_4 to mark FORBID in a grant-statement */\n+#define CH_DECL_FORBID(DECL) DECL_LANG_FLAG_4(DECL)\n+\n+/* in an ALIAS_DECL use DECL_LANG_FLAG_4 to mark decl was granted */\n+#define CH_DECL_GRANTED(DECL) DECL_LANG_FLAG_4(DECL)\n+\n+/* (in a non-FIELD_DECL) note that this decl was hidden by push_module(). */\n+#define DECL_HIDDEN_BY_MODULE(decl) DECL_LANG_FLAG_4 (decl)\n+\n+/* Record in each node resulting from a binary operator\n+   what operator was specified for it.  */\n+#define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n+\n+/* Store a value in that field.  */\n+#define C_SET_EXP_ORIGINAL_CODE(exp, code) \\\n+  (TREE_COMPLEXITY (exp) = (int)(code))\n+\n+/* Record whether a typedef for type `int' was actually `signed int'.  */\n+#define C_TYPEDEF_EXPLICITLY_SIGNED(exp) DECL_LANG_FLAG_1 ((exp))\n+\n+/* For FUNCTION_TYPE, a hidden list of types of arguments.  The same as\n+   TYPE_ARG_TYPES for functions with prototypes, but created for functions\n+   without prototypes.  */\n+#define TYPE_ACTUAL_ARG_TYPES(NODE) TYPE_NONCOPIED_PARTS (NODE)\n+\n+/* For FUNCTION_TYPE or METHOD_TYPE, a list of the\n+   (names of) exceptions that this type can raise.  */\n+#define TYPE_RAISES_EXCEPTIONS(NODE) ((NODE)->type.minval)\n+\n+/* For UNION_TYPE, the list of tag fields that distinguishes the members.  */\n+#define TYPE_TAGFIELDS(NODE) ((NODE)->type.minval)\n+\n+/* For RECORD_TYPE, the tag values that select it.  */\n+#define TYPE_TAG_VALUES(NODE) TYPE_BINFO(NODE)\n+\n+/* For VAR_DECL, TYPE_DECL, FUNCTION_DECL, indicates that\n+   the DECL was read from a seizefile but not seized */\n+#define CH_DECL_NOTDECLARED(DECL) DECL_LANG_FLAG_5(DECL)\n+\n+/* For FUNCTION_DECL's, mark as PROCESSEs. */\n+#define CH_DECL_PROCESS(DECL) DECL_LANG_FLAG_7(DECL)\n+\n+/* For TYPE_DECL's, mark as SIGNALs. */\n+#define CH_DECL_SIGNAL(DECL) DECL_LANG_FLAG_7(DECL)\n+\f\n+/* Macros using terminology of the CHILL Blue Book. */\n+\n+/* A class is either Null, All, M-value, M-derived, or M-reference,\n+   where M is some mode (type). */\n+\n+enum ch_class_kind {\n+  CH_ALL_CLASS, CH_NULL_CLASS,\n+  CH_VALUE_CLASS, CH_DERIVED_CLASS, CH_REFERENCE_CLASS\n+};\n+\n+typedef struct ch_class {\n+  enum ch_class_kind kind;\n+  tree mode;  /* The 'M' in M-value, M-derived, or M-reference. */\n+} ch_class;\n+\n+struct mode_chain;  /* Forward reference */\n+\n+#define CH_IS_REFERENCE_MODE(MODE) (TREE_CODE (MODE) == POINTER_TYPE)\n+#define CH_IS_BOUND_REFERENCE_MODE(MODE) \\\n+  (TREE_CODE (MODE) == POINTER_TYPE && TREE_TYPE(MODE) != void_type_node)\n+#define CH_IS_PROCEDURE_MODE(MODE) (TREE_CODE (MODE) == FUNCTION_TYPE)\n+#define CH_IS_INSTANCE_MODE(MODE)  (CH_SIMILAR (MODE, instance_type_node))\n+#define CH_IS_BUFFER_MODE(MODE)    (TYPE_LANG_FLAG_3(MODE))\n+#define CH_IS_EVENT_MODE(MODE)     (TYPE_LANG_FLAG_4(MODE))\n+/* This is TRUE if the set is numbered, which makes pred/succ\n+   unusable */\n+#define CH_ENUM_IS_NUMBERED(MODE)  (TYPE_LANG_FLAG_5(MODE))\n+\n+/* for ACCESS, and TEXT mode */\n+#define CH_IS_ACCESS_MODE(MODE)        (TYPE_LANG_FLAG_2(MODE))\n+#define CH_IS_TEXT_MODE(MODE)          (TYPE_LANG_FLAG_6(MODE))\n+#define CH_IS_ASSOCIATION_MODE(MODE)   (CH_SIMILAR (MODE, association_type_node))\n+#define CH_IS_USAGE_MODE(MODE)         (CH_SIMILAR (MODE, usage_type_node))\n+#define CH_IS_WHERE_MODE(MODE)         (CH_SIMILAR (MODE, where_type_node))\n+\n+/* for RECORD or ARRAY type */\n+#define CH_TYPE_NONVALUE_P(MODE)       (TYPE_LANG_FLAG_0(MODE))\n+\n+/* CH_NOVELTY is the novelty of a mode:  NULL_TREE means the novelty is nil;\n+   otherwise a TYPE_DECL matching the defining occurrence of a newmode. */\n+#define CH_NOVELTY(MODE)           TYPE_CONTEXT(MODE)\n+\n+/* Set the novelty of MODE to NOVELTY (which is assumed to be non-nil). */\n+#define SET_CH_NOVELTY(MODE, NOVELTY) (CH_NOVELTY (MODE) = (NOVELTY))\n+#define SET_CH_NOVELTY_NONNIL(MODE, NOVELTY) (CH_NOVELTY (MODE) = (NOVELTY))\n+\n+/* CH_DERIVED_FLAG is true the class of EXPR is X-derived for some X. */\n+#define CH_DERIVED_FLAG(EXPR) TREE_LANG_FLAG_5(EXPR)\n+\n+#define CH_HAS_REFERENCING_PROPERTY(MODE) \\\n+  (TREE_CODE (MODE) == POINTER_TYPE) /* incomplete FIXME! */\n+\n+/* CH_COMPATIBLE(EXPR, MODE) is true if the class of EXPR is\n+   \"compatible\" with the type MODE. */\n+#define CH_COMPATIBLE(EXPR, MODE)           chill_compatible(EXPR, MODE)\n+#define CH_COMPATIBLE_CLASSES(EXPR1, EXPR2) chill_compatible_classes(EXPR1, EXPR2)\n+#define CH_STATIC_MODE(MODE)                  1 /* for now */\n+#define CH_SIMILAR(MODE1, MODE2)              chill_similar(MODE1, MODE2, 0)\n+#define CH_ROOT_MODE(MODE) chill_root_mode(MODE)\n+#define CH_RESULTING_CLASS(C1, C2) chill_resulting_class(C1, C2)\n+#define CH_ROOT_RESULTING_CLASS(E1, E2) \\\n+  CH_RESULTING_CLASS (chill_expr_class(E1), chill_expr_class(E2))\n+#define CH_RESULTING_MODE(MODE1, MODE2) chill_resulting_mode(MODE1, MODE2)\n+#define CH_V_EQUIVALENT(MODE1, MODE2) (CH_SIMILAR(MODE1, MODE2) \\\n+   && CH_NOVELTY(MODE1) == CH_NOVELTY(MODE2))\n+#define CH_EQUIVALENT(MODE1, MODE2) \\\n+  (!integer_zerop (chill_equivalent (MODE1, MODE2, 0)))\n+#define CH_RESTRICTABLE_TO(MODE1, MODE2)  \\\n+    CH_EQUIVALENT(MODE1, MODE2) /* && some more stuff FIXME! */\n+\n+/* pass an OFFSET_TYPE or REFERENCE_TYPE's underlying type to SCALAR_P */\n+#define CH_READ_COMPATIBLE(modeM, modeN) chill_read_compatible(modeM, modeN)\n+\n+#define SCALAR_P(TYPE) (TYPE != NULL_TREE \\\n+\t\t\t&& (TREE_CODE (TYPE) == INTEGER_TYPE \\\n+\t\t\t    || TREE_CODE (TYPE) == REAL_TYPE \\\n+\t\t\t    || TREE_CODE (TYPE) == ENUMERAL_TYPE \\\n+\t\t\t    || TREE_CODE (TYPE) == BOOLEAN_TYPE \\\n+\t\t\t    || TREE_CODE (TYPE) == CHAR_TYPE \\\n+\t\t\t    || TREE_CODE (TYPE) == POINTER_TYPE \\\n+\t\t\t    || TREE_CODE (TYPE) == INSTANCE_TYPE))\n+#define CH_REFERABLE(EXPR) chill_referable(EXPR)\n+#define CH_LOCATION_P(EXPR) chill_location (EXPR)\n+\f\n+extern int maybe_objc_comptypes ();\n+extern tree maybe_building_objc_message_expr ();\n+\f\n+/* Standard named or nameless data types of the C compiler.  */\n+\n+/* Nonzero means `$' can be in an identifier.  */\n+\n+extern int dollars_in_ident;\n+\n+/* Nonzero means allow type mismatches in conditional expressions;\n+   just make their values `void'.   */\n+\n+extern int flag_cond_mismatch;\n+\n+/* Nonzero means don't recognize the keyword `asm'.  */\n+\n+extern int flag_no_asm;\n+\n+/* Nonzero means ignore `#ident' directives.  */\n+\n+extern int flag_no_ident;\n+\n+/* Nonzero means warn about implicit declarations.  */\n+\n+extern int warn_implicit;\n+\n+/* Nonzero means give string constants the type `const char *'\n+   to get extra warnings from them.  These warnings will be too numerous\n+   to be useful, except in thoroughly ANSIfied programs.  */\n+\n+extern int warn_write_strings;\n+\n+/* Nonzero means warn about sizeof (function) or addition/subtraction\n+   of function pointers.  */\n+\n+extern int warn_pointer_arith;\n+\n+/* Nonzero means warn for all old-style non-prototype function decls.  */\n+\n+extern int warn_strict_prototypes;\n+\n+/* Nonzero means warn about multiple (redundant) decls for the same single\n+   variable or function.  */\n+\n+extern int warn_redundant_decls;\n+\n+/* Nonzero means warn about extern declarations of objects not at\n+   file-scope level and about *all* declarations of functions (whether\n+   extern or static) not at file-scope level.  Note that we exclude\n+   implicit function declarations.  To get warnings about those, use\n+   -Wimplicit.  */\n+\n+extern int warn_nested_externs;\n+\n+/* Nonzero means warn about pointer casts that can drop a type qualifier\n+   from the pointer target type.  */\n+\n+extern int warn_cast_qual;\n+\n+/* Warn about traditional constructs whose meanings changed in ANSI C.  */\n+\n+extern int warn_traditional;\n+\n+/* Warn about *printf or *scanf format/argument anomalies. */\n+\n+extern int warn_format;\n+\n+/* Warn about a subscript that has type char.  */\n+\n+extern int warn_char_subscripts;\n+\n+/* Warn if a type conversion is done that might have confusing results.  */\n+\n+extern int warn_conversion;\n+\n+/* Warn if switch labels aren't complete, or are duplicated */\n+\n+extern int warn_switch;\n+\n+/* Nonzero means do some things the same way PCC does.  */\n+\n+extern int flag_traditional;\n+\n+/* Nonzero means warn about suggesting putting in ()'s.  */\n+\n+extern int warn_parentheses;\n+\n+/* Nonzero means this is a function to call to perform comptypes\n+   on two record types.  */\n+\n+extern int (*comptypes_record_hook) ();\n+\n+/* Nonzero means we are reading code that came from a system header file.  */\n+extern int system_header_p;\n+\n+/* One means range checking is on; <= 0 off; -1 permanently off. */\n+extern int range_checking;\n+\n+/* 0 means empty checking is off, else it is on */\n+extern int empty_checking;\n+\n+/* 1 means -fruntime-checking specified (default), o means -fno-runtime-checking */\n+extern int runtime_checking_flag;\n+\n+/* Type node for boolean types.  */\n+\n+extern tree boolean_type_node;\n+extern tree signed_boolean_type_node;\n+\n+extern tree string_one_type_node;\n+extern tree bitstring_one_type_node, bit_zero_node, bit_one_node;\n+\n+extern tree float_type_node, double_type_node;\n+extern tree void_type_node, ptr_type_node, const_ptr_type_node;\n+\n+/* a VOID_TYPE node, packaged in a TREE_LIST.  */\n+\n+extern tree void_list_node;\n+\n+/* Chill language-specific tree codes.  */\n+#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n+enum chill_tree_code {\n+  __DUMMY = LAST_AND_UNUSED_TREE_CODE,\n+#include \"ch-tree.def\"\n+  LAST_CHILL_TREE_CODE\n+};\n+#undef DEFTREECODE\n+\n+enum chill_built_in_function\n+{\n+  DUMMY_FIRST_CHILL_BUILT_IN = END_BUILTINS,\n+\n+  BUILT_IN_CH_ABS,\n+  BUILT_IN_ABSTIME,\n+  BUILT_IN_ADDR,\n+  BUILT_IN_ALLOCATE,\n+  BUILT_IN_ALLOCATE_GLOBAL_MEMORY,\n+  BUILT_IN_ALLOCATE_MEMORY,\n+  BUILT_IN_ARCCOS,\n+  BUILT_IN_ARCSIN,\n+  BUILT_IN_ARCTAN,\n+  BUILT_IN_ASSOCIATE,\n+  BUILT_IN_CARD,\n+  BUILT_IN_CONNECT,\n+  BUILT_IN_COPY_NUMBER,\n+  BUILT_IN_CH_COS,\n+  BUILT_IN_CREATE,\n+  BUILT_IN_DAYS,\n+  BUILT_IN_CH_DELETE,\n+  BUILT_IN_DESCR,\n+  BUILT_IN_DISCONNECT,\n+  BUILT_IN_DISSOCIATE,\n+  BUILT_IN_EOLN,\n+  BUILT_IN_EXP,\n+  BUILT_IN_EXPIRED,\n+  BUILT_IN_EXISTING,\n+  BUILT_IN_GEN_CODE,\n+  BUILT_IN_GEN_INST,\n+  BUILT_IN_GEN_PTYPE,\n+  BUILT_IN_GETASSOCIATION,\n+  BUILT_IN_GETSTACK,\n+  BUILT_IN_GETTEXTACCESS,\n+  BUILT_IN_GETTEXTINDEX,\n+  BUILT_IN_GETTEXTRECORD,\n+  BUILT_IN_GETUSAGE,\n+  BUILT_IN_HOURS,\n+  BUILT_IN_INDEXABLE,\n+  BUILT_IN_INTTIME,\n+  BUILT_IN_ISASSOCIATED,\n+  BUILT_IN_LENGTH,\n+  BUILT_IN_LOG,\n+  BUILT_IN_LOWER,\n+  BUILT_IN_LN,\n+  BUILT_IN_MAX,\n+  BUILT_IN_MILLISECS,\n+  BUILT_IN_MIN,\n+  BUILT_IN_MINUTES,\n+  BUILT_IN_MODIFY,\n+  BUILT_IN_NUM,\n+  BUILT_IN_OUTOFFILE,\n+  BUILT_IN_PRED,\n+  BUILT_IN_PROC_TYPE,\n+  BUILT_IN_QUEUE_LENGTH,\n+  BUILT_IN_READABLE,\n+  BUILT_IN_READRECORD,\n+  BUILT_IN_READTEXT,\n+  BUILT_IN_RETURN_MEMORY,\n+  BUILT_IN_SECS,\n+  BUILT_IN_SETTEXTACCESS,\n+  BUILT_IN_SETTEXTINDEX,\n+  BUILT_IN_SETTEXTRECORD,\n+  BUILT_IN_SEQUENCIBLE,\n+  BUILT_IN_SIZE,\n+  BUILT_IN_SQRT,\n+  BUILT_IN_SUCC,\n+  BUILT_IN_CH_SIN,\n+  BUILT_IN_TAN,\n+  BUILT_IN_TRUNC,\n+  BUILT_IN_TERMINATE,\n+  BUILT_IN_UPPER,\n+  BUILT_IN_VARIABLE,\n+  BUILT_IN_WAIT,\n+  BUILT_IN_WRITEABLE,\n+  BUILT_IN_WRITERECORD,\n+  BUILT_IN_WRITETEXT,\n+};\n+\f\n+/* name of additional (compiler generated) arguments for\n+   functions which may propagate exceptions. */\n+#define CALLER_FILE \"__CALLER_FILE__\"\n+#define CALLER_LINE \"__CALLER_LINE__\"\n+\n+/* field-name strings for the fields of the structure which\n+   represents a CHILL VARYING array.  The angle brackets assure\n+   that no user-defined structure can match this one.\n+   This field holds, at runtime, the current length of the\n+   array, in UNITS, not including the length itself. It's an\n+   integer_type_node */\n+#define VAR_LENGTH \"__var_length\"\n+\n+/* This field is statically allocated to the user-defined\n+   size, but contains valid array entries starting from the\n+   first allocated space, proceeding for VAR_LENGTH bytes.\n+   There are no holes in the data;  the user isn't allowed\n+   to store beyond the first available entry. */\n+\n+#define VAR_DATA \"__var_data\"\n+\n+/* This field is the name of the array, encapsulated in the CHILL\n+   structure used to represent an array type parameter. */\n+/*#define ARRAY_DATA \"__array_data\"*/\n+\n+/* The CHILL INSTANCE type is composed of two CHILL integer\n+   fields, the process_type (set by the user with the \n+   process_type compiler directive, and the proc_copy field,\n+   which is set by the start_process call's first parameter. */\n+#define INS_PTYPE \"__proc_type\"\n+#define INS_COPY  \"__proc_copy\"\n+\n+/* This is the actual array type inside the VARYING struct */\n+#define CH_VARYING_ARRAY_TYPE(TYPE) TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (TYPE)))\n+\n+/* Identifiers which hold the VAR_LENGTH and VAR_DATA strings.  */\n+extern tree var_length_id;\n+extern tree var_data_id;\n+\n+/* A RANGE_EXPR representing an ELSE in a case label. */\n+extern tree case_else_node;\n+\n+#if 0   /* changed to function */\n+/* return non-zero if type is a compiler-generated VARYING array record */\n+#define CH_VARYING_TYPE_P(type) (TREE_CODE (type) == RECORD_TYPE && \\\n+                           DECL_NAME (TYPE_FIELDS (type)) == \\\n+                                      get_identifier (VAR_LENGTH) && \\\n+                           DECL_NAME (TREE_CHAIN (TYPE_FIELDS (type))) == \\\n+                                      get_identifier (VAR_DATA) && \\\n+                   TREE_CHAIN (CH_VARYING_ARRAY_TYPE (type)) == NULL_TREE)\n+\n+#endif\n+\n+/* in c-aux-info.c */\n+extern void gen_aux_info_record                 PROTO((tree, int, int, int));\n+\n+/* in c-common.c */\n+extern tree combine_strings                     PROTO((tree));\n+extern void constant_expression_warning         PROTO((tree));\n+extern void decl_attributes                     PROTO((tree, tree));\n+extern void declare_function_name               PROTO((void));\n+extern char *get_directive_line                 PROTO((FILE *));\n+extern tree shorten_compare                     PROTO((tree *, tree *, tree *, enum tree_code *));\n+\n+/* in c-decl.c */\n+extern tree short_integer_type_node, integer_type_node;\n+extern tree long_integer_type_node, long_long_integer_type_node;\n+extern tree short_unsigned_type_node, unsigned_type_node;\n+extern tree long_unsigned_type_node, long_long_unsigned_type_node;\n+extern tree ptrdiff_type_node;\n+extern tree unsigned_char_type_node, signed_char_type_node, char_type_node;\n+extern tree wchar_type_node, signed_wchar_type_node, unsigned_wchar_type_node;\n+extern tree float_type_node, double_type_node, long_double_type_node;\n+extern tree void_type_node, ptr_type_node, const_ptr_type_node;\n+extern tree default_function_type;\n+extern tree double_ftype_double, double_ftype_double_double;\n+extern tree int_ftype_int, long_ftype_long;\n+extern tree void_ftype_ptr_ptr_int, int_ftype_ptr_ptr_int;\n+extern tree void_ftype_ptr_int_int, string_ftype_ptr_ptr;\n+extern tree int_ftype_string_string, int_ftype_cptr_cptr_sizet;\n+/* Nodes for boolean constants TRUE and FALSE */\n+extern tree boolean_true_node, boolean_false_node;\n+\n+extern tree global_function_decl;\n+\n+/* in except.c */\n+extern void except_init_pass_2                  PROTO((void));\n+\n+/* in ch-loop.c */\n+extern int flag_local_loop_counter;\n+extern void push_loop_block                     PROTO((void));\n+extern void pop_loop_block                      PROTO((void));\n+extern void build_loop_start                    PROTO((tree));\n+extern void top_loop_end_check\t\t\tPROTO((tree));\n+extern void build_loop_end                      PROTO((void));\n+extern void build_loop_iterator                 PROTO((tree, tree, tree, tree, int, int, int));\n+extern void begin_loop_scope                    PROTO((void));\n+extern void end_loop_scope                      PROTO((tree));\n+extern void nonvalue_begin_loop_scope           PROTO((void));\n+extern void nonvalue_end_loop_scope             PROTO((void));\n+\n+extern tree build_enumerator                    PROTO((tree, tree));\n+extern tree builtin_function                    PROTO((char *, tree, enum built_in_function function_, char *));\n+extern tree c_build_type_variant                PROTO((tree, int, int));\n+extern int  c_decode_option                     PROTO((int, char **));\n+extern void c_mark_varargs                      PROTO((void));\n+extern void clear_parm_order                    PROTO((void));\n+extern tree combine_parm_decls                  PROTO((tree, tree, int));\n+extern int  complete_array_type                 PROTO((tree, tree, int));\n+extern void declare_parm_level                  PROTO((int));\n+extern tree define_label                        PROTO((char *, int, tree));\n+extern void delete_block                        PROTO((tree));\n+extern void finish_decl                         PROTO((tree));\n+extern tree finish_enum                         PROTO((tree, tree));\n+extern void finish_function                     PROTO((int));\n+extern tree finish_struct                       PROTO((tree, tree));\n+extern tree get_parm_decls                      PROTO((void));\n+extern tree get_parm_info                       PROTO((int));\n+extern tree getdecls                            PROTO((void));\n+extern tree gettags                             PROTO((void));\n+extern int  global_bindings_p                   PROTO((void));\n+extern tree grokfield                           PROTO((char *, int, tree, tree, tree));\n+extern tree groktypename                        PROTO((tree));\n+extern tree groktypename_in_parm_context        PROTO((tree));\n+extern tree implicitly_declare                  PROTO((tree));\n+extern void init_decl_processing                PROTO((void));\n+extern void insert_block                        PROTO((tree));\n+extern void keep_next_level                     PROTO((void));\n+extern int  kept_level_p                        PROTO((void));\n+extern tree lookup_label                        PROTO((tree));\n+extern tree lookup_name                         PROTO((tree));\n+extern tree maybe_build_cleanup                 PROTO((tree));\n+extern void parmlist_tags_warning               PROTO((void));\n+extern void pending_xref_error                  PROTO((void));\n+extern void pop_chill_function_context          PROTO((void));\n+extern tree poplevel                            PROTO((int, int, int));\n+extern void print_lang_decl                     PROTO((FILE *,tree, int));\n+extern void print_lang_identifier               PROTO((FILE *,tree, int));\n+extern void print_lang_type                     PROTO((FILE *,tree, int));\n+extern void push_chill_function_context         PROTO((void));\n+extern void push_parm_decl                      PROTO((tree));\n+extern tree pushdecl                            PROTO((tree));\n+extern tree pushdecl_top_level                  PROTO((tree));\n+extern void pushlevel                           PROTO((int));\n+extern void set_block                           PROTO((tree));\n+extern tree shadow_label                        PROTO((tree));\n+extern void shadow_record_fields                PROTO((tree));\n+extern void shadow_tag                          PROTO((tree));\n+extern void shadow_tag_warned                   PROTO((tree, int));\n+extern tree start_enum                          PROTO((tree));\n+extern int  start_function                      PROTO((tree, tree, int));\n+extern tree start_decl                          PROTO((tree, tree, int));\n+extern tree start_struct                        PROTO((enum tree_code, tree));\n+extern void store_parm_decls                    PROTO((void));\n+extern tree xref_tag                            PROTO((enum tree_code, tree));\n+\n+/* in c-typeck.c */\n+extern tree build_array_ref                     PROTO((tree, tree));\n+extern tree build_c_cast                        PROTO((tree, tree));\n+extern tree build_chill_modify_expr             PROTO((tree, tree));\n+extern tree build_chill_component_ref           PROTO((tree, tree));\n+extern tree build_component_ref                 PROTO((tree, tree));\n+extern tree build_compound_expr                 PROTO((tree));\n+extern tree build_conditional_expr              PROTO((tree, tree, tree));\n+extern tree build_function_call                 PROTO((tree, tree));\n+extern tree build_indirect_ref                  PROTO((tree, char *));\n+extern tree build_modify_expr                   PROTO((tree, enum tree_code, tree));\n+extern tree build_unary_op                      PROTO((enum tree_code, tree, int));\n+extern tree c_alignof                           PROTO((tree));\n+extern tree c_alignof_expr                      PROTO((tree));\n+extern void c_expand_asm_operands               PROTO((tree, tree, tree, tree, int, char *, int));\n+extern tree c_sizeof                            PROTO((tree));\n+extern void c_expand_return                     PROTO((tree));\n+extern tree c_expand_start_case                 PROTO((tree));\n+extern tree common_type                         PROTO((tree, tree));\n+extern tree copy_novelty                        PROTO((tree, tree));\n+extern tree default_conversion                  PROTO((tree));\n+extern void finish_init                         PROTO((void));\n+extern tree parser_build_binary_op              PROTO((enum tree_code, tree, tree));\n+extern tree pop_init_level                      PROTO((int));\n+extern void process_init_default                PROTO((tree));\n+extern void process_init_element                PROTO((tree));\n+extern void push_init_level                     PROTO((int));\n+extern void really_start_incremental_init       PROTO((tree));\n+extern void set_init_index                      PROTO((tree, tree));\n+extern void set_init_label                      PROTO((tree));\n+extern void start_init                          PROTO((tree, tree, int));\n+extern void store_init_value                    PROTO((tree, tree));\n+extern tree valid_array_index_p                 PROTO((tree, tree, char *, int));\n+\n+/* in ch/actions.c */\n+extern int grant_only_flag;\n+extern void allocate_lang_decl                  PROTO((tree));\n+extern tree build_chill_abs                     PROTO((tree));\n+extern tree build_chill_array_ref_1             PROTO((tree, tree));\n+extern tree build_chill_array_ref               PROTO((tree, tree));\n+extern tree build_chill_bin_type                PROTO((tree));\n+extern tree build_chill_binary_op               PROTO((enum chill_tree_code, tree, tree));\n+extern tree build_chill_card                    PROTO((tree));\n+extern tree build_chill_case_expr               PROTO((tree, tree, tree)); \n+extern tree build_cause_exception               PROTO((tree, int));\n+extern tree build_chill_function_call           PROTO((tree, tree));\n+extern tree build_chill_length                  PROTO((tree));\n+extern tree build_chill_indirect_ref            PROTO((tree, tree, int));\n+extern tree build_chill_lower                   PROTO((tree));\n+extern tree build_chill_max                     PROTO((tree));\n+extern tree build_chill_min                     PROTO((tree));\n+extern tree build_chill_num                     PROTO((tree));\n+extern tree build_chill_repetition_op           PROTO((tree, tree));\n+extern tree build_chill_sizeof                  PROTO((tree));\n+extern tree build_chill_slice\t\t        PROTO((tree, tree, tree));\n+extern tree build_chill_slice_with_range        PROTO((tree, tree, tree));\n+extern tree build_chill_slice_with_length       PROTO((tree, tree, tree));\n+extern tree build_chill_struct_type             PROTO((tree));\n+extern tree build_chill_unary_op                PROTO((enum chill_tree_code, tree));\n+extern tree build_chill_upper                   PROTO((tree));\n+extern tree build_exception_variant             PROTO((tree, tree));\n+extern tree build_generalized_call              PROTO((tree, tree));\n+extern tree build_lang_decl                     PROTO((enum chill_tree_code, tree, tree));\n+extern tree build_rts_call                      PROTO((char *, tree, tree));\n+extern tree build_varying_struct                PROTO((tree));\n+extern void chill_check_decl                    PROTO((tree));\n+extern tree chill_convert_for_assignment        PROTO((tree, tree, char*));\n+extern void chill_expand_return                 PROTO((tree, int));\n+extern void chill_expand_result                 PROTO((tree, int));\n+extern void chill_handle_case_label\t\tPROTO((tree, tree));\n+extern int  chill_varying_string_type_p         PROTO((tree));\n+extern int  chill_varying_type_p                PROTO((tree));\n+extern int  ch_singleton_set                    PROTO((tree));\n+extern tree check_expression                    PROTO((tree, tree, tree));\n+extern tree check_non_null                      PROTO((tree));\n+extern tree check_range                         PROTO((tree, tree, tree,tree));\n+extern void cond_type_range_exception           PROTO((tree));\n+extern void expand_cause_exception              PROTO((tree));\n+extern tree finish_chill_binary_op              PROTO((tree));\n+extern tree finish_chill_unary_op               PROTO((tree));\n+extern tree high_domain_value                   PROTO((tree));\n+extern tree low_domain_value                    PROTO((tree));\n+extern tree maybe_array_ref\t\t\tPROTO((tree, tree));\n+extern void maybe_chill_check_decl              PROTO((tree));\n+extern tree powersetlen                         PROTO((tree));\n+extern tree test_range                          PROTO((tree, tree, tree));\n+/* in ch/convert.c */\n+extern tree build_array_type_for_scalar         PROTO((tree));\n+extern tree convert                             PROTO((tree, tree));\n+extern tree convert_from_reference              PROTO((tree));\n+extern tree convert_to_class                    PROTO((ch_class, tree));\n+extern char* display_int_cst\t\t\tPROTO((tree));\n+\n+/* in ch/decl.c */\n+extern tree build_enumerator\t\t        PROTO((tree, tree));\n+extern tree chill_munge_params                  PROTO((tree, tree, tree));\n+extern tree build_chill_function_type           PROTO((tree, tree, tree, tree));\n+extern tree decl_temp1                          PROTO((tree, tree, int, tree, int, int));\n+extern void do_based_decls                      PROTO((tree, tree, tree));\n+extern void do_chill_outparms                   PROTO((void));\n+extern tree do_decl                             PROTO((tree, tree, int, int, tree, int));\n+extern void do_decls                            PROTO((tree, tree, int, int, tree, int));\n+extern void expand_chill_outparms               PROTO((void));\n+extern void finish_chill_function               PROTO(());\n+extern tree finish_enum\t\t                PROTO((tree, tree));\n+extern void fixup_chill_parms                   PROTO((tree));\n+extern void finish_outer_function               PROTO((void));\n+extern tree grok_chill_fixedfields              PROTO((tree, tree, tree));\n+extern tree grok_chill_variantdefs              PROTO((tree, tree, tree));\n+/* extern tree lookup_remembered_decl PROTO((HOST_WIDE_INT, tree)); */\n+extern tree lookup_tag_fields\t\t        PROTO((tree, tree));\n+extern tree massage_param_node\t\t\tPROTO((tree, tree));\n+extern void pop_module                          PROTO((void));\n+extern void print_mode                          PROTO((tree));\n+extern tree push_extern_function                PROTO((tree, tree, tree, tree, int));\n+extern void push_extern_process                 PROTO((tree, tree, tree, int));\n+extern void push_extern_signal                  PROTO((tree, tree, tree));\n+extern tree push_modedef                        PROTO((tree, tree, int));\n+extern tree push_module                         PROTO((tree, int));\n+extern void push_parms                          PROTO((tree, tree, tree));\n+extern void push_syndecl                        PROTO((tree, tree, tree));\n+extern int result_never_set;\n+extern int  start_chill_function                PROTO((tree, tree, tree, tree, tree));\n+extern void start_outer_function\t        PROTO((void));\n+extern void switch_to_pass_2 \t                PROTO((void));\n+\n+/* in ch/except.c */\n+extern void chill_check_no_handlers             PROTO((void));\n+extern void chill_reraise_exceptions            PROTO((tree));\n+\n+/* in ch/expr.c */\n+extern tree build_chill_addr_expr               PROTO((tree, char *));\n+extern tree build_chill_arrow_expr              PROTO((tree, int));\n+extern tree build_component_ref\t\t        PROTO((tree, tree));\n+extern tree build_chill_descr                   PROTO((tree));\n+extern void build_chill_descr_type              PROTO((void));\n+extern void build_chill_inttime_type            PROTO((void));\n+extern tree build_compare_expr\t\t\tPROTO((enum chill_tree_code,\n+\t\t\t\t\t\t       tree, tree));\n+extern tree build_compare_discrete_expr\t\tPROTO((enum chill_tree_code,\n+\t\t\t\t\t\t       tree, tree));\n+extern tree check_case_selector                 PROTO((tree));\n+extern tree check_case_selector_list            PROTO((tree));\n+extern tree check_have_mode                     PROTO((tree, char*));\n+extern void init_chill_expand                   PROTO((void));\n+extern void chill_expand_assignment             PROTO((tree, enum chill_tree_code, tree));\n+extern void expand_assignment_action            PROTO((tree, enum chill_tree_code, tree));\n+extern int compare_int_csts\t\t\tPROTO((enum chill_tree_code,\n+\t\t\t\t\t\t       tree, tree));\n+extern void expand_varying_length_assignment    PROTO((tree, tree));\n+extern tree force_addr_of\t\t\tPROTO((tree));\n+extern tree resolve_component_ref               PROTO((tree));\n+extern tree truthvalue_conversion               PROTO((tree));\n+extern tree varying_to_slice\t\t        PROTO((tree));\n+\n+/* in ch/grant.c */\n+extern void chill_finish_compile                PROTO((void));\n+extern void chill_seize                         PROTO((tree, tree, tree));\n+extern void start_outer_function\t        PROTO((void));\n+extern void finish_chill_seize                  PROTO((tree));\n+extern void chill_grant                         PROTO((tree,tree, tree, tree));\n+extern void set_default_grant_file              PROTO((void));\n+extern void write_grant_file                    PROTO((void));\n+extern void write_spec_module                   PROTO((tree, tree));\n+\n+/* in ch/lang.c */\n+extern tree string_index_type_dummy;\n+extern tree integer_minus_one_node;\n+extern int  flag_old_strings;\n+extern void GNU_xref_begin                      PROTO((void));\n+extern void GNU_xref_end                        PROTO((void));\n+extern tree build_chill_array_type              PROTO((tree, tree, int, tree));\n+extern tree build_chill_struct_type             PROTO((tree));\n+extern tree build_chill_pointer_type            PROTO((tree));\n+extern tree build_chill_range_type              PROTO((tree, tree, tree));\n+extern tree build_chill_reference_type          PROTO((tree));\n+extern tree build_simple_array_type             PROTO((tree, tree, tree));\n+extern tree const_expr                          PROTO((tree));\n+extern tree get_identifier3\t\t\tPROTO((char*, char*, char*));\n+extern tree layout_chill_array_type             PROTO((tree));\n+extern tree layout_chill_range_type             PROTO((tree, int));\n+extern tree layout_chill_pointer_type           PROTO((tree));\n+extern tree layout_chill_struct_type            PROTO((tree));\n+extern tree layout_chill_variants               PROTO((tree));\n+extern tree layout_powerset_type                PROTO((tree));\n+extern tree lookup_interface                    PROTO((tree));\n+extern tree maybe_building_objc_message_expr    PROTO((void));\n+extern void maybe_objc_check_decl               PROTO((tree));\n+extern int  maybe_objc_comptypes                PROTO((tree, tree));\n+extern int  recognize_objc_keyword              PROTO((void));\n+\n+/* in ch/lex.l */\n+extern tree use_seizefile_name;\n+extern tree current_seizefile_name;\n+extern tree build_chill_string                  PROTO((int, char *));\n+extern int  check_newline                       PROTO((void));\n+extern tree get_chill_filename                  PROTO((void)); \n+extern tree get_chill_linenumber                PROTO((void));       \n+extern void register_seize_path                 PROTO((char *));\n+extern void reinit_parse_for_function           PROTO((void));\n+extern void mark_use_seizefile_written          PROTO((tree));\n+\n+/* in ch/loop.c */\n+extern void begin_chill_loop                    PROTO((tree, tree));\n+extern tree build_chill_iterator                PROTO((tree, tree, tree, int, int, int));\n+extern void end_chill_loop                      PROTO((void));\n+extern tree get_unique_identifier               PROTO((char *));\n+\n+/* in ch/inout.c */\n+extern tree access_recordmode                   PROTO((tree));\n+extern void invalidate_access_recordmode        PROTO((tree));\n+extern tree access_indexmode                    PROTO((tree));\n+extern tree access_dynamic                      PROTO((tree));\n+extern tree association_init_value;\n+extern tree association_type_node;\n+extern tree build_access_mode                   PROTO((tree, tree, int));\n+extern tree build_chill_associate               PROTO((tree, tree, tree));\n+extern tree build_chill_connect                 PROTO((tree, tree, tree, tree));\n+extern tree build_chill_create                  PROTO((tree));\n+extern tree build_chill_delete                  PROTO((tree));\n+extern tree build_chill_disconnect              PROTO((tree));\n+extern tree build_chill_dissociate              PROTO((tree));\n+extern tree build_chill_eoln                    PROTO((tree)); \n+extern tree build_chill_existing                PROTO((tree));\n+extern tree build_chill_gettextaccess           PROTO((tree)); \n+extern tree build_chill_getassociation          PROTO((tree)); \n+extern tree build_chill_gettextindex            PROTO((tree)); \n+extern tree build_chill_gettextrecord           PROTO((tree)); \n+extern tree build_chill_getusage                PROTO((tree)); \n+extern tree build_chill_indexable               PROTO((tree)); \n+extern tree build_chill_isassociated            PROTO((tree)); \n+extern tree build_chill_modify                  PROTO((tree, tree));\n+extern tree build_chill_outoffile               PROTO((tree)); \n+extern tree build_chill_readable                PROTO((tree));\n+extern tree build_chill_readrecord              PROTO((tree, tree));\n+extern tree build_chill_readtext                PROTO((tree, tree));\n+extern tree build_chill_sequencible             PROTO((tree)); \n+extern tree build_chill_settextaccess           PROTO((tree, tree));\n+extern tree build_chill_settextindex            PROTO((tree, tree));\n+extern tree build_chill_settextrecord           PROTO((tree, tree));\n+extern tree build_chill_variable                PROTO((tree)); \n+extern tree build_chill_writeable               PROTO((tree));\n+extern tree build_chill_writerecord             PROTO((tree, tree));\n+extern tree build_chill_writetext               PROTO((tree, tree));\n+extern tree build_text_mode                     PROTO((tree, tree, int));\n+extern tree check_text_length                   PROTO((tree, tree));\n+extern void init_access_location                PROTO((tree, tree));\n+extern void init_text_location                  PROTO((tree, tree));\n+extern void inout_init                          PROTO((void));\n+extern tree text_dynamic                        PROTO((tree));\n+extern tree text_indexmode                      PROTO((tree));\n+extern tree text_length                         PROTO((tree));\n+extern tree usage_type_node;\n+extern tree where_type_node;\n+\n+/* in ch/parse.c */\n+extern tree get_type_of                         PROTO((tree));\n+extern void set_yydebug                         PROTO((int));\n+extern void yyerror                             PROTO((char *));\n+extern int  pass;\n+extern int ignoring;\n+extern int seen_action;\n+extern int build_constructor;\n+extern void possibly_define_exit_label          PROTO((tree));\n+extern void to_global_binding_level             PROTO((void));\n+\n+/* in ch/satisfy.c */\n+extern tree satisfy_decl \t                PROTO((tree, int));\n+\n+/* in ch/tasking.c */\n+extern void add_taskstuff_to_list               PROTO((tree, char *, tree, tree, tree));\n+extern void process_buffer_decls                PROTO((tree, tree, int));\n+extern tree buffer_element_mode                 PROTO((tree));\n+extern void invalidate_buffer_element_mode      PROTO((tree));\n+extern tree build_buffer_descriptor             PROTO((tree, tree, tree));\n+extern tree build_buffer_type                   PROTO((tree, tree));\n+extern void build_delay_action                  PROTO((tree, tree));\n+extern tree build_delay_case_start              PROTO((tree, tree));\n+extern void build_delay_case_end                PROTO((tree, tree));\n+extern void build_delay_case_label              PROTO((tree, int));\n+extern tree build_event_type                    PROTO((tree));\n+extern void build_receive_case_end              PROTO((tree, tree, tree));\n+extern int  build_receive_case_if_generated     PROTO((void));\n+extern tree build_receive_case_label            PROTO((tree, tree));\n+extern tree build_receive_case_start            PROTO((tree));\n+extern void expand_continue_event               PROTO((tree));\n+extern void expand_send_buffer                  PROTO((tree, tree, tree, tree, tree));\n+extern void expand_send_signal                  PROTO((tree, tree, tree, tree, tree));\n+extern void build_start_process                 PROTO((tree, tree, tree, tree));\n+extern tree build_copy_number                   PROTO((tree));\n+extern tree build_gen_code                      PROTO((tree));\n+extern tree build_gen_inst                      PROTO((tree, tree));\n+extern tree build_gen_ptype                     PROTO((tree));\n+extern void build_instance_type                 PROTO((void));\n+extern tree build_process_header                PROTO((tree, tree));\n+extern void build_process_wrapper               PROTO((tree, tree));\n+extern tree build_proc_type                     PROTO((tree));\n+extern tree build_queue_length                  PROTO((tree));\n+extern tree build_signal_descriptor             PROTO((tree, tree));\n+extern tree build_signal_struct_type            PROTO((tree, tree, tree));\n+extern tree build_tasking_struct                PROTO((void));\n+extern tree chill_taskingcode_type_node;\n+extern tree check_queue_size                    PROTO((tree, tree));\n+extern tree generate_tasking_code_variable      PROTO((tree, tree *, int));\n+extern tree get_signal_type_name                PROTO((tree));\n+extern tree get_struct_type_name                PROTO((tree));\n+extern tree get_tasking_code_name               PROTO((tree));\n+extern tree make_process_struct                 PROTO((tree, tree));\n+extern tree make_signal_struct                  PROTO((tree));\n+extern tree max_queue_size                      PROTO((tree));\n+\n+/* in ch/timing.c */\n+extern tree abs_timing_type_node;\n+extern tree after_stack;\n+extern void build_after_end                     PROTO((void));\n+extern void build_after_start                   PROTO((tree, int));\n+extern void build_after_timeout_start           PROTO((void));\n+extern void build_at_action                     PROTO((tree));\n+extern void build_cycle_end                     PROTO((tree));\n+extern tree build_cycle_start                   PROTO((tree));\n+extern tree build_timeout_preface               PROTO((void));\n+extern void build_timesupervised_call           PROTO((tree, tree));\n+extern tree duration_timing_type_node;\n+extern void timing_init                         PROTO((void));\n+\n+/* in ch/tree.c */\n+extern tree build_alias_decl\t\t\tPROTO((tree, tree, tree));\n+extern tree build_bitstring_type                PROTO((tree));\n+extern tree build_powerset_type                 PROTO((tree));\n+extern tree build_string_type                   PROTO((tree, tree));\n+extern tree decl_check_rename\t\t\tPROTO((tree, tree));\n+extern tree discrete_count                      PROTO((tree));\n+extern int  list_length                         PROTO((tree));\n+extern tree munge_exit_label\t\t\tPROTO((tree));\n+extern tree save_if_needed\t\t\tPROTO((tree));\n+\n+/* in ch/typeck.c */\n+extern tree build_array_from_set                PROTO((tree));\n+extern tree build_chill_array_ref               PROTO((tree, tree));\n+extern tree build_chill_bitref                  PROTO((tree, tree));\n+extern tree build_chill_cast                    PROTO((tree, tree));\n+extern tree chill_equivalent\t                PROTO((tree, tree, struct mode_chain*));\n+extern tree build_init_struct                   PROTO((void));\n+extern tree build_readonly_type                 PROTO((tree));\n+extern int  chill_compatible                    PROTO((tree, tree));\n+extern int  chill_compatible_classes            PROTO((tree, tree));\n+extern ch_class chill_expr_class                PROTO((tree));\n+extern tree chill_give_type_to_expr             PROTO((tree, tree));\n+extern tree chill_expand_tuple                  PROTO((tree, tree));\n+extern ch_class chill_expr_class                PROTO((tree));\n+extern int  chill_location                      PROTO((tree));\n+extern tree chill_max_vary_array_index\t\tPROTO((tree));\n+extern int  chill_read_compatible               PROTO((tree, tree));\n+extern int  chill_referable                     PROTO((tree));\n+extern tree chill_root_mode\t                PROTO((tree));\n+extern ch_class chill_resulting_class           PROTO((ch_class, ch_class));\n+extern tree chill_resulting_mode                PROTO((tree, tree));\n+extern int  chill_similar\t                PROTO((tree, tree, struct mode_chain*));\n+extern int  discrete_type_p\t\t\tPROTO((tree));\n+extern tree convert_to_discrete                 PROTO((tree));\n+extern tree smash_dummy_type                    PROTO((tree));\n+extern tree string_assignment_condition         PROTO((tree, tree));\n+extern tree type_for_mode                       PROTO((enum machine_mode, int));\n+extern tree type_for_size                       PROTO((unsigned, int));\n+extern int  valid_array_index                   PROTO((tree, tree));\n+extern void validate_varying_array_ref          PROTO((tree, tree));\n+\n+/* in function.c */\n+extern void expand_function_end                 PROTO((char *, int, int));\n+extern void expand_function_start               PROTO((tree, int));\n+extern void init_function_start                 PROTO((tree, char *, int));\n+extern void pop_function_context                PROTO((void));\n+extern void push_function_context               PROTO((void));\n+\n+/* in integrate.c */\n+extern void output_inline_function              PROTO((tree));\n+\n+/* in stmt.c */\n+extern void remember_end_note                   PROTO((tree));\n+\n+/* in toplev.c */\n+extern void announce_function                   PROTO((tree));\n+extern int  floor_log2_wide                     PROTO((unsigned HOST_WIDE_INT));\n+extern void pedwarn                             PROTO((char *, ...));\n+extern void rest_of_compilation                 PROTO((tree));\n+extern void warning_with_decl                   PROTO((tree, char*, ...));\n+\n+/* in varasm.c */\n+extern void make_decl_rtl                       PROTO((tree, char *, int));\n+extern void make_function_rtl                   PROTO((tree));\n+\n+/* in ???? */\n+extern void init_iterators                      PROTO((void));\n+extern int  mark_addressable\t\t\tPROTO((tree));\n+extern tree chill_result_decl;\n+#ifdef RTX_CODE\n+extern rtx label_rtx                            PROTO((tree));\n+#endif\n+extern void permanent_allocation                PROTO((int));\n+\n+#ifndef SET_WORD_SIZE\n+#define SET_WORD_SIZE BITS_PER_WORD\n+#endif\n+\n+struct module\n+{\n+  struct module *next_module;  /* Next module, in order of their beginning. */\n+  struct module *prev_module;  /* The surrounding module, if any. */\n+  tree name;\n+  tree prefix_name; /* Usually same as name, expect for nested modules.\n+\t\t       Used to generate DECL_ASSEMBLER_NAMEs. */\t       \n+  /* procedure_seen indicates a procedure or process was declared.\n+     After this, no SEIZE, DCL, SYN, NEWMODE, SYNMODE statement is allowed */\n+  int procedure_seen;\n+  int is_spec_module;\n+\n+  /* The value of current_nesting_level inside the module. */\n+  int nesting_level;\n+\n+  /* A chain contain one ALIAS_DECL for each 'GRANT foo->bar'.\n+     The DECL_NAME is get_identifier(\"bar\"), and the DECL_INITIAL\n+     is get_identifier(\"bar\").  Only used in pass 1. */\n+  tree granted_decls;\n+};\n+\n+extern struct module *current_module;\n+\n+/* fold a tree to constant as much as possible */\n+extern tree deep_fold PROTO((tree));\n+#endif"}, {"sha": "59f743449ac84b8f2df2bbcdddce9533503604c7", "filename": "gcc/ch/runtime/exh.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ba6e819ef513bff725602ef1cd94e389f6a4eb8/gcc%2Fch%2Fruntime%2Fexh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ba6e819ef513bff725602ef1cd94e389f6a4eb8/gcc%2Fch%2Fruntime%2Fexh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fruntime%2Fexh.c?ref=5ba6e819ef513bff725602ef1cd94e389f6a4eb8", "patch": "@@ -0,0 +1,152 @@\n+/* Implement runtime actions for CHILL.\n+   Copyright (C) 1992,1993 Free Software Foundation, Inc.\n+   Author: Wilfried Moser\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#define __CHILL_LIB__\n+\n+#include \"config.h\"\n+#include <stdio.h>\n+#include <setjmp.h>\n+#include \"rtltypes.h\"\n+\n+extern void cause_exception (char *exname, char *file, int lineno, int user_arg);\n+extern void unhandled_exception (char *exname, char *file, int lineno, int user_arg);\n+\n+/* An action with a handler:\n+\tBODY ON (e1, e2): H12; (e3): H3; ELSE HE; END;\n+   is translated into:\n+\n+    struct __ch_handler __tmp;\n+    static struct __ch_handler_excepts _H[4] =\n+      {\n+        { <<e1>>, 1 },\n+        { <<e2>>, 1 },\n+        { <<e3>>, 2 },\n+        { __ch_else_except, 3 },\n+      };\n+    __ch_link_handler(&__tmp);\n+    __tmp.handlers = _H;\n+    switch (setmp(&__tmp.jbuf))\n+      {\t\n+      case 0:  BODY; __ch_unlink_handler(&__tmp); break;\n+      case 1:  H12; break;\n+      case 2:  H3; break;\n+      case 3:  HE; break;\n+      }\n+*/\n+\n+/* this part contains all neccessary functions to handle exceptions in CHILL */\n+\n+/* These two trivial function aren't inlines, to allow for\n+   more flexibility (e.g. a per-thread exception stack). */\n+\n+extern void __setexceptionStack (TExceptionHandlerStack *new);\n+extern TExceptionHandlerStack * __getexceptionStack (void);\n+\n+void\n+__ch_link_handler (handler)\n+     struct __ch_handler *handler;\n+{\n+  handler->prev = __getexceptionStack ();\n+  __setexceptionStack (handler);\n+}\n+\n+ void\n+__ch_unlink_handler (handler)\n+     struct __ch_handler *handler;\n+{\n+  __setexceptionStack (handler->prev);\n+}\n+\n+/*\n+ * function __cause_exception\n+ *\n+ * parameters:\n+ *  exnum\t\tname string of exception to raise\n+ *  file\t\tfilename of CAUSE statement\n+ *  lineno\t\tlinenumber of CAUSE statement\n+ *  user_arg\t\tuser specified argument\n+ *\n+ * returns:\n+ *  never\t\tleave function with longjmp or abort\n+ *\n+ * abstract:\n+ *  search exceptionstack for last handler of caused exception,\n+ *  call userdefined function to signal exception,\n+ *  jump to handler with longjmp or call unhandled_exception\n+ *\n+ */\n+\n+void\n+__cause_exception  (ex, file, lineno, user_arg)\n+     char *ex;\n+     char *file;\n+     int  lineno;\n+     int user_arg;\n+{\n+  register struct __ch_handler *handler = __getexceptionStack();\n+\n+  /* call user defined cause function */\n+  cause_exception (ex, file, lineno, user_arg);\n+  \n+  for ( ; handler != NULL; handler = handler->prev)\n+    {\n+      register struct __ch_handled_excepts *list = handler->handlers;\n+      for ( ; list->code != 0; list++ )\n+\t{\n+\t  if (list->ex == __ch_else_except || EX_EQ(list->ex, ex)) /* found */\n+\t    {\n+\t      __setexceptionStack (handler->prev);\n+\t      longjmp(handler->jbuf, list->code);\t  \n+\t    }\n+\t}\n+    }\n+\n+  /* no handler found -- call unhandled_exception */\n+  unhandled_exception (ex, file, lineno, user_arg);\n+  abort ();\n+}\n+\n+/*\n+ * function __cause_ex1\n+ *\n+ * parameters:\n+ *  exnum\t\tname string of exception to raise\n+ *  file\t\tfilename of CAUSE statement\n+ *  lineno\t\tlinenumber of CAUSE statement\n+ *\n+ * returns:\n+ *  never\t\tleave function with longjmp or abort\n+ *\n+ * abstract:\n+ *  This is the function the compiler generated code calls.\n+ *  Search exceptionstack for last handler of caused exception,\n+ *  call userdefined function to signal exception,\n+ *  jump to handler with longjmp or call unhandled_exception\n+ *\n+ */\n+\n+void\n+__cause_ex1  (ex, file, lineno)\n+     char *ex;\n+     char *file;\n+     int  lineno;\n+{\n+  __cause_exception (ex, file, lineno, 0);\n+}"}]}