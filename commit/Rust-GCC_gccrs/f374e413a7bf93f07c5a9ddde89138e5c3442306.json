{"sha": "f374e413a7bf93f07c5a9ddde89138e5c3442306", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM3NGU0MTNhN2JmOTNmMDdjNWE5ZGRkZTg5MTM4ZTVjMzQ0MjMwNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-18T19:33:46Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-18T19:33:46Z"}, "message": "mips.c (mips_frame_info): Add arg_pointer_offset and hard_frame_pointer_offset.\n\ngcc/\n\t* config/mips/mips.c (mips_frame_info): Add arg_pointer_offset\n\tand hard_frame_pointer_offset.\n\t(mips_debugger_offset): Use hard_frame_pointer_offset.\n\t(mips16e_collect_argument_save_p): Likewise.\n\t(compute_frame_size): Initialize arg_pointer_offset and\n\thard_frame_pointer_offset.\n\t(mips_initial_elimination_offset): Use them.\n\t(mips_output_function_prologue): Use hard_frame_pointer_offset.\n\t(mips_expand_prologue, mips_expand_epilogue): Likewise.\n\nFrom-SVN: r129458", "tree": {"sha": "27ae861b1313a0e106ad65c3bb34281ba719e24e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27ae861b1313a0e106ad65c3bb34281ba719e24e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f374e413a7bf93f07c5a9ddde89138e5c3442306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f374e413a7bf93f07c5a9ddde89138e5c3442306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f374e413a7bf93f07c5a9ddde89138e5c3442306", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f374e413a7bf93f07c5a9ddde89138e5c3442306/comments", "author": null, "committer": null, "parents": [{"sha": "67202da49d8f86671aca7fe4deaac3af996928e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67202da49d8f86671aca7fe4deaac3af996928e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67202da49d8f86671aca7fe4deaac3af996928e5"}], "stats": {"total": 110, "additions": 62, "deletions": 48}, "files": [{"sha": "bf29a081db87fd6bbc37bfe5e8fd8284b1653512", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f374e413a7bf93f07c5a9ddde89138e5c3442306/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f374e413a7bf93f07c5a9ddde89138e5c3442306/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f374e413a7bf93f07c5a9ddde89138e5c3442306", "patch": "@@ -1,3 +1,15 @@\n+2007-10-18  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips.c (mips_frame_info): Add arg_pointer_offset\n+\tand hard_frame_pointer_offset.\n+\t(mips_debugger_offset): Use hard_frame_pointer_offset.\n+\t(mips16e_collect_argument_save_p): Likewise.\n+\t(compute_frame_size): Initialize arg_pointer_offset and\n+\thard_frame_pointer_offset.\n+\t(mips_initial_elimination_offset): Use them.\n+\t(mips_output_function_prologue): Use hard_frame_pointer_offset.\n+\t(mips_expand_prologue, mips_expand_epilogue): Likewise.\n+\n 2007-10-18  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.h (STARTING_FRAME_OFFSET): Remove rtl"}, {"sha": "ff4eb9af943d47a575585f11a31b7e15185c01ab", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f374e413a7bf93f07c5a9ddde89138e5c3442306/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f374e413a7bf93f07c5a9ddde89138e5c3442306/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f374e413a7bf93f07c5a9ddde89138e5c3442306", "patch": "@@ -275,6 +275,12 @@ struct mips_frame_info GTY(())\n   HOST_WIDE_INT gp_sp_offset;\n   HOST_WIDE_INT fp_sp_offset;\n \n+  /* The offset of arg_pointer_rtx from frame_pointer_rtx.  */\n+  HOST_WIDE_INT arg_pointer_offset;\n+\n+  /* The offset of hard_frame_pointer_rtx from frame_pointer_rtx.  */\n+  HOST_WIDE_INT hard_frame_pointer_offset;\n+\n   /* True if this structure has been initialized after reload.  */\n   bool initialized;\n };\n@@ -6804,15 +6810,9 @@ mips_debugger_offset (rtx addr, HOST_WIDE_INT offset)\n   if (reg == stack_pointer_rtx || reg == frame_pointer_rtx\n       || reg == hard_frame_pointer_rtx)\n     {\n-      HOST_WIDE_INT frame_size = (!cfun->machine->frame.initialized)\n-\t\t\t\t  ? compute_frame_size (get_frame_size ())\n-\t\t\t\t  : cfun->machine->frame.total_size;\n-\n-      /* MIPS16 frame is smaller */\n-      if (frame_pointer_needed && TARGET_MIPS16)\n-\tframe_size -= cfun->machine->frame.args_size;\n-\n-      offset = offset - frame_size;\n+      offset -= cfun->machine->frame.total_size;\n+      if (reg == hard_frame_pointer_rtx)\n+\toffset += cfun->machine->frame.hard_frame_pointer_offset;\n     }\n \n   /* sdbout_parms does not want this to crash for unrecognized cases.  */\n@@ -7352,13 +7352,12 @@ mips16e_collect_argument_save_p (rtx dest, rtx src, rtx *reg_values,\n   argno = regno - GP_ARG_FIRST;\n \n   /* Check whether the address is an appropriate stack pointer or\n-     frame pointer access.  The frame pointer is offset from the\n-     stack pointer by the size of the outgoing arguments.  */\n+     frame pointer access.  */\n   addr = mips16e_collect_propagate_value (XEXP (dest, 0), reg_values);\n   mips_split_plus (addr, &base, &offset);\n   required_offset = cfun->machine->frame.total_size + argno * UNITS_PER_WORD;\n   if (base == hard_frame_pointer_rtx)\n-    required_offset -= cfun->machine->frame.args_size;\n+    required_offset -= cfun->machine->frame.hard_frame_pointer_offset;\n   else if (base != stack_pointer_rtx)\n     return false;\n   if (offset != required_offset)\n@@ -7991,6 +7990,7 @@ compute_frame_size (HOST_WIDE_INT size)\n \n   /* Move above the callee-allocated varargs save area.  */\n   offset += MIPS_STACK_ALIGN (cfun->machine->varargs_size);\n+  frame->arg_pointer_offset = offset;\n \n   /* Move above the callee-allocated area for pretend stack arguments.  */\n   offset += current_function_pretend_args_size;\n@@ -8002,6 +8002,12 @@ compute_frame_size (HOST_WIDE_INT size)\n   if (frame->fp_sp_offset > 0)\n     frame->fp_save_offset = frame->fp_sp_offset - offset;\n \n+  /* MIPS16 code offsets the frame pointer by the size of the outgoing\n+     arguments.  This tends to increase the chances of using unextended\n+     instructions for local variables and incoming arguments.  */\n+  if (TARGET_MIPS16)\n+    frame->hard_frame_pointer_offset = frame->args_size;\n+\n   frame->initialized = reload_completed;\n   return frame->total_size;\n }\n@@ -8035,24 +8041,24 @@ mips_initial_elimination_offset (int from, int to)\n \n   compute_frame_size (get_frame_size ());\n \n-  /* Set OFFSET to the offset from the stack pointer.  */\n+  /* Set OFFSET to the offset from the soft frame pointer, which is also\n+     the offset from the end-of-prologue stack pointer.  */\n   switch (from)\n     {\n     case FRAME_POINTER_REGNUM:\n       offset = 0;\n       break;\n \n     case ARG_POINTER_REGNUM:\n-      offset = (cfun->machine->frame.total_size\n-\t\t- current_function_pretend_args_size);\n+      offset = cfun->machine->frame.arg_pointer_offset;\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n-  if (TARGET_MIPS16 && to == HARD_FRAME_POINTER_REGNUM)\n-    offset -= cfun->machine->frame.args_size;\n+  if (to == HARD_FRAME_POINTER_REGNUM)\n+    offset -= cfun->machine->frame.hard_frame_pointer_offset;\n \n   return offset;\n }\n@@ -8248,8 +8254,8 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t       \", gp= \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t       (reg_names[(frame_pointer_needed)\n \t\t\t  ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n-\t       ((frame_pointer_needed && TARGET_MIPS16)\n-\t\t? tsize - cfun->machine->frame.args_size\n+\t       (frame_pointer_needed\n+\t\t? tsize - cfun->machine->frame.hard_frame_pointer_offset\n \t\t: tsize),\n \t       reg_names[GP_REG_FIRST + 31],\n \t       cfun->machine->frame.var_size,\n@@ -8497,36 +8503,34 @@ mips_expand_prologue (void)\n \t}\n     }\n \n-  /* Set up the frame pointer, if we're using one.  In mips16 code,\n-     we point the frame pointer ahead of the outgoing argument area.\n-     This should allow more variables & incoming arguments to be\n-     accessed with unextended instructions.  */\n+  /* Set up the frame pointer, if we're using one.  */\n   if (frame_pointer_needed)\n     {\n-      if (TARGET_MIPS16 && cfun->machine->frame.args_size != 0)\n+      HOST_WIDE_INT offset;\n+\n+      offset = cfun->machine->frame.hard_frame_pointer_offset;\n+      if (offset == 0)\n \t{\n-\t  rtx offset = GEN_INT (cfun->machine->frame.args_size);\n-\t  if (SMALL_OPERAND (cfun->machine->frame.args_size))\n-\t    RTX_FRAME_RELATED_P\n-\t      (emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n-\t\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t\t offset))) = 1;\n-\t  else\n-\t    {\n-\t      mips_emit_move (MIPS_PROLOGUE_TEMP (Pmode), offset);\n-\t      mips_emit_move (hard_frame_pointer_rtx, stack_pointer_rtx);\n-\t      emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n-\t\t\t\t\thard_frame_pointer_rtx,\n-\t\t\t\t\tMIPS_PROLOGUE_TEMP (Pmode)));\n-\t      mips_set_frame_expr\n-\t\t(gen_rtx_SET (VOIDmode, hard_frame_pointer_rtx,\n-\t\t\t      plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t     cfun->machine->frame.args_size)));\n-\t    }\n+\t  insn = mips_emit_move (hard_frame_pointer_rtx, stack_pointer_rtx);\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+      else if (SMALL_OPERAND (offset))\n+\t{\n+\t  insn = gen_add3_insn (hard_frame_pointer_rtx,\n+\t\t\t\tstack_pointer_rtx, GEN_INT (offset));\n+\t  RTX_FRAME_RELATED_P (emit_insn (insn)) = 1;\n \t}\n       else\n-\tRTX_FRAME_RELATED_P (mips_emit_move (hard_frame_pointer_rtx,\n-\t\t\t\t\t     stack_pointer_rtx)) = 1;\n+\t{\n+\t  mips_emit_move (MIPS_PROLOGUE_TEMP (Pmode), GEN_INT (offset));\n+\t  mips_emit_move (hard_frame_pointer_rtx, stack_pointer_rtx);\n+\t  emit_insn (gen_add3_insn (hard_frame_pointer_rtx,\n+\t\t\t\t    hard_frame_pointer_rtx,\n+\t\t\t\t    MIPS_PROLOGUE_TEMP (Pmode)));\n+\t  mips_set_frame_expr\n+\t    (gen_rtx_SET (VOIDmode, hard_frame_pointer_rtx,\n+\t\t\t  plus_constant (stack_pointer_rtx, offset)));\n+\t}\n     }\n \n   mips_emit_loadgp ();\n@@ -8614,15 +8618,13 @@ mips_expand_epilogue (int sibcall_p)\n   step1 = cfun->machine->frame.total_size;\n   step2 = 0;\n \n-  /* Work out which register holds the frame address.  Account for the\n-     frame pointer offset used by mips16 code.  */\n+  /* Work out which register holds the frame address.  */\n   if (!frame_pointer_needed)\n     base = stack_pointer_rtx;\n   else\n     {\n       base = hard_frame_pointer_rtx;\n-      if (TARGET_MIPS16)\n-\tstep1 -= cfun->machine->frame.args_size;\n+      step1 -= cfun->machine->frame.hard_frame_pointer_offset;\n     }\n \n   /* If we need to restore registers, deallocate as much stack as"}]}