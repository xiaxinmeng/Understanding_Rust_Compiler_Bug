{"sha": "93242b9c1b2e15fd90be6d6b0513cca9b2969c22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTMyNDJiOWMxYjJlMTVmZDkwYmU2ZDZiMDUxM2NjYTliMjk2OWMyMg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-03-26T19:37:11Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-03-26T19:37:11Z"}, "message": "ifcvt.c (noce_try_store_flag_constants): Don't check no_new_pseudos here.\n\n\t* ifcvt.c (noce_try_store_flag_constants): Don't check\n\tno_new_pseudos here.\n\t(noce_try_store_flag_constants): Don't check no_new_pseudos.\n\t(noce_try_addcc, noce_try_store_flag_mask, noce_try_cmove_arith,\n\tnoce_try_cmove_arith, noce_try_minmax, noce_try_abs,\n\tnoce_try_sign_mask): Likewise.\n\t(if_convert): Check no_new_pseudos here.\n\n\t(cond_exec_process_if_block, noce_process_if_block, find_if_block):\n\tRemove prototypes.\n\t(struct noce_if_info): Add then_bb, else_bb, join_bb members.\n\t(noce_get_condition): Handle new then_else_reversed argument.\n\t(noce_init_if_info): Remove, fold into noce_find_if_block.\n\t(noce_process_if_block): Take a struct noce_if_info as the\n\targument.  Don't set up one based on ce_if_info.  Update pointer\n\treferences accordingly.\n\t(cond_move_process_if_block): Likewise.\n\t(process_if_block): Removed.\n\t(find_if_block): Removed.  Move functionality two new functions,\n\tnoce_find_if_block and cond_exec_find_if_block.\n\t(noce_find_if_block): New function.  Be aware of IF-THEN-JOIN\n\tblocks and the symmetric IF-ELSE-JOIN case.\n\t(cond_exec_find_if_block): Also new function mostly based on old\n\tfind_if_block and process_if_block.\n\t(find_if_header): Replace find_if_block call with separately\n\tguarded calls to noce_find_if_block and cond_exec_find_if_block.\n\t(find_cond_trap): Update noce_get_condition call.\n\t(dead_or_predicable): Likewise.\n\nFrom-SVN: r123223", "tree": {"sha": "97d6abb7f3b657e147df001404d2424afbfa5236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97d6abb7f3b657e147df001404d2424afbfa5236"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93242b9c1b2e15fd90be6d6b0513cca9b2969c22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93242b9c1b2e15fd90be6d6b0513cca9b2969c22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93242b9c1b2e15fd90be6d6b0513cca9b2969c22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93242b9c1b2e15fd90be6d6b0513cca9b2969c22/comments", "author": null, "committer": null, "parents": [{"sha": "646714ab7532c9cb755e6195a99b6c28d3eb5b5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/646714ab7532c9cb755e6195a99b6c28d3eb5b5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/646714ab7532c9cb755e6195a99b6c28d3eb5b5a"}], "stats": {"total": 408, "additions": 237, "deletions": 171}, "files": [{"sha": "4cb6e8653f3ee9fd2234ebf5cc8a99b6484f50e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93242b9c1b2e15fd90be6d6b0513cca9b2969c22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93242b9c1b2e15fd90be6d6b0513cca9b2969c22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93242b9c1b2e15fd90be6d6b0513cca9b2969c22", "patch": "@@ -1,3 +1,34 @@\n+2007-03-26  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* ifcvt.c (noce_try_store_flag_constants): Don't check\n+\tno_new_pseudos here.\n+\t(noce_try_store_flag_constants): Don't check no_new_pseudos.\n+\t(noce_try_addcc, noce_try_store_flag_mask, noce_try_cmove_arith,\n+\tnoce_try_cmove_arith, noce_try_minmax, noce_try_abs,\n+\tnoce_try_sign_mask): Likewise.\n+\t(if_convert): Check no_new_pseudos here.\n+\n+\t(cond_exec_process_if_block, noce_process_if_block, find_if_block):\n+\tRemove prototypes.\n+\t(struct noce_if_info): Add then_bb, else_bb, join_bb members.\n+\t(noce_get_condition): Handle new then_else_reversed argument.\n+\t(noce_init_if_info): Remove, fold into noce_find_if_block.\n+\t(noce_process_if_block): Take a struct noce_if_info as the\n+\targument.  Don't set up one based on ce_if_info.  Update pointer\n+\treferences accordingly.\n+\t(cond_move_process_if_block): Likewise.\n+\t(process_if_block): Removed.\n+\t(find_if_block): Removed.  Move functionality two new functions,\n+\tnoce_find_if_block and cond_exec_find_if_block.\n+\t(noce_find_if_block): New function.  Be aware of IF-THEN-JOIN\n+\tblocks and the symmetric IF-ELSE-JOIN case.\n+\t(cond_exec_find_if_block): Also new function mostly based on old\n+\tfind_if_block and process_if_block.\n+\t(find_if_header): Replace find_if_block call with separately\n+\tguarded calls to noce_find_if_block and cond_exec_find_if_block.\n+\t(find_cond_trap): Update noce_get_condition call.\n+\t(dead_or_predicable): Likewise.\n+\n 2007-03-26  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (IX86_BUILTIN_CMPNEPD, IX86_BUILTIN_CMPNESD):"}, {"sha": "d4de03be238c6c00b7bdb8de8c41f738101d5d18", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 206, "deletions": 171, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93242b9c1b2e15fd90be6d6b0513cca9b2969c22/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93242b9c1b2e15fd90be6d6b0513cca9b2969c22/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=93242b9c1b2e15fd90be6d6b0513cca9b2969c22", "patch": "@@ -96,16 +96,14 @@ static rtx last_active_insn (basic_block, int);\n static basic_block block_fallthru (basic_block);\n static int cond_exec_process_insns (ce_if_block_t *, rtx, rtx, rtx, rtx, int);\n static rtx cond_exec_get_condition (rtx);\n-static int cond_exec_process_if_block (ce_if_block_t *, int);\n-static rtx noce_get_condition (rtx, rtx *);\n+static rtx noce_get_condition (rtx, rtx *, bool);\n static int noce_operand_ok (rtx);\n-static int noce_process_if_block (ce_if_block_t *);\n-static int process_if_block (ce_if_block_t *);\n static void merge_if_block (ce_if_block_t *);\n static int find_cond_trap (basic_block, edge, edge);\n static basic_block find_if_header (basic_block, int);\n static int block_jumps_and_fallthru_p (basic_block, basic_block);\n-static int find_if_block (ce_if_block_t *);\n+static int noce_find_if_block (basic_block, edge, edge, int);\n+static int cond_exec_find_if_block (ce_if_block_t *);\n static int find_if_case_1 (basic_block, edge, edge);\n static int find_if_case_2 (basic_block, edge, edge);\n static int find_memory (rtx *, void *);\n@@ -598,8 +596,8 @@ cond_exec_process_if_block (ce_if_block_t * ce_info,\n \n struct noce_if_info\n {\n-  /* A basic block that ends in a simple conditional jump.  */\n-  basic_block test_bb;\n+  /* The basic blocks that make up the IF-THEN-{ELSE-,}JOIN block.  */\n+  basic_block test_bb, then_bb, else_bb, join_bb;\n \n   /* The jump that ends TEST_BB.  */\n   rtx jump;\n@@ -938,8 +936,7 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n   int normalize, can_reverse;\n   enum machine_mode mode;\n \n-  if (! no_new_pseudos\n-      && GET_CODE (if_info->a) == CONST_INT\n+  if (GET_CODE (if_info->a) == CONST_INT\n       && GET_CODE (if_info->b) == CONST_INT)\n     {\n       mode = GET_MODE (if_info->x);\n@@ -1065,8 +1062,7 @@ noce_try_addcc (struct noce_if_info *if_info)\n   rtx target, seq;\n   int subtract, normalize;\n \n-  if (! no_new_pseudos\n-      && GET_CODE (if_info->a) == PLUS\n+  if (GET_CODE (if_info->a) == PLUS\n       && rtx_equal_p (XEXP (if_info->a, 0), if_info->b)\n       && (reversed_comparison_code (if_info->cond, if_info->jump)\n \t  != UNKNOWN))\n@@ -1157,9 +1153,8 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n   int reversep;\n \n   reversep = 0;\n-  if (! no_new_pseudos\n-      && (BRANCH_COST >= 2\n-\t  || STORE_FLAG_VALUE == -1)\n+  if ((BRANCH_COST >= 2\n+       || STORE_FLAG_VALUE == -1)\n       && ((if_info->a == const0_rtx\n \t   && rtx_equal_p (if_info->b, if_info->x))\n \t  || ((reversep = (reversed_comparison_code (if_info->cond,\n@@ -1314,7 +1309,8 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n      conditional on their addresses followed by a load.  Don't do this\n      early because it'll screw alias analysis.  Note that we've\n      already checked for no side effects.  */\n-  if (! no_new_pseudos && cse_not_expected\n+  /* ??? FIXME: Magic number 5.  */\n+  if (cse_not_expected\n       && MEM_P (a) && MEM_P (b)\n       && BRANCH_COST >= 5)\n     {\n@@ -1389,9 +1385,6 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n     {\n       rtx set;\n \n-      if (no_new_pseudos)\n-\tgoto end_seq_and_fail;\n-\n       if (is_mem)\n \t{\n \t  tmp = gen_reg_rtx (GET_MODE (a));\n@@ -1414,9 +1407,6 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n     {\n       rtx set, last;\n \n-      if (no_new_pseudos)\n-\tgoto end_seq_and_fail;\n-\n       if (is_mem)\n \t{\n           tmp = gen_reg_rtx (GET_MODE (b));\n@@ -1648,10 +1638,6 @@ noce_try_minmax (struct noce_if_info *if_info)\n   enum rtx_code code, op;\n   int unsignedp;\n \n-  /* ??? Can't guarantee that expand_binop won't create pseudos.  */\n-  if (no_new_pseudos)\n-    return FALSE;\n-\n   /* ??? Reject modes with NaNs or signed zeros since we don't know how\n      they will be resolved with an SMIN/SMAX.  It wouldn't be too hard\n      to get the target to tell us...  */\n@@ -1744,10 +1730,6 @@ noce_try_abs (struct noce_if_info *if_info)\n   rtx cond, earliest, target, seq, a, b, c;\n   int negate;\n \n-  /* ??? Can't guarantee that expand_binop won't create pseudos.  */\n-  if (no_new_pseudos)\n-    return FALSE;\n-\n   /* Recognize A and B as constituting an ABS or NABS.  The canonical\n      form is a branch around the negation, taken when the object is the\n      first operand of a comparison against 0 that evaluates to true.  */\n@@ -1868,9 +1850,6 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n   enum rtx_code code;\n   bool b_unconditional;\n \n-  if (no_new_pseudos)\n-    return FALSE;\n-\n   cond = if_info->cond;\n   code = GET_CODE (cond);\n   m = XEXP (cond, 0);\n@@ -2036,10 +2015,13 @@ noce_try_bitop (struct noce_if_info *if_info)\n \n \n /* Similar to get_condition, only the resulting condition must be\n-   valid at JUMP, instead of at EARLIEST.  */\n+   valid at JUMP, instead of at EARLIEST.\n+\n+   If THEN_ELSE_REVERSED is true, the fallthrough goes to the THEN\n+   block of the caller, and we have to reverse the condition.  */\n \n static rtx\n-noce_get_condition (rtx jump, rtx *earliest)\n+noce_get_condition (rtx jump, rtx *earliest, bool then_else_reversed)\n {\n   rtx cond, set, tmp;\n   bool reverse;\n@@ -2054,6 +2036,11 @@ noce_get_condition (rtx jump, rtx *earliest)\n   reverse = (GET_CODE (XEXP (SET_SRC (set), 2)) == LABEL_REF\n \t     && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (jump));\n \n+  /* We may have to reverse because the caller's if block is not canonical\n+     (i.e. the ELSE block isn't the fallthrough block for the TEST block).  */\n+  if (then_else_reversed)\n+    reverse = !reverse;\n+\n   /* If the condition variable is a register and is MODE_INT, accept it.  */\n \n   cond = XEXP (SET_SRC (set), 0);\n@@ -2074,52 +2061,6 @@ noce_get_condition (rtx jump, rtx *earliest)\n \t\t\t\t NULL_RTX, false, true);\n }\n \n-/* Initialize for a simple IF-THEN or IF-THEN-ELSE block.  We will not\n-   be using conditional execution.  Set some fields of IF_INFO based\n-   on CE_INFO: test_bb, cond, jump, cond_earliest.  Return TRUE if\n-   things look OK.  */\n-\n-static int\n-noce_init_if_info (struct ce_if_block *ce_info, struct noce_if_info *if_info)\n-{\n-  basic_block test_bb = ce_info->test_bb;\n-  rtx cond, jump;\n-\n-  /* If test is comprised of && or || elements, don't handle it unless\n-     it is the special case of && elements without an ELSE block.  */\n-  if (ce_info->num_multiple_test_blocks)\n-    {\n-      if (ce_info->else_bb || !ce_info->and_and_p)\n-\treturn FALSE;\n-\n-      ce_info->test_bb = test_bb = ce_info->last_test_bb;\n-      ce_info->num_multiple_test_blocks = 0;\n-      ce_info->num_and_and_blocks = 0;\n-      ce_info->num_or_or_blocks = 0;\n-    }\n-\n-  /* If this is not a standard conditional jump, we can't parse it.  */\n-  jump = BB_END (test_bb);\n-  cond = noce_get_condition (jump, &if_info->cond_earliest);\n-  if (!cond)\n-    return FALSE;\n-\n-  /* If the conditional jump is more than just a conditional\n-     jump, then we can not do if-conversion on this block.  */\n-  if (! onlyjump_p (jump))\n-    return FALSE;\n-\n-  /* We must be comparing objects whose modes imply the size.  */\n-  if (GET_MODE (XEXP (cond, 0)) == BLKmode)\n-    return FALSE;\n-\n-  if_info->test_bb = test_bb;\n-  if_info->cond = cond;\n-  if_info->jump = jump;\n-\n-  return TRUE;\n-}\n-\n /* Return true if OP is ok for if-then-else processing.  */\n \n static int\n@@ -2189,22 +2130,22 @@ noce_mem_write_may_trap_or_fault_p (rtx mem)\n   return false;\n }\n \n-/* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it\n-   without using conditional execution.  Return TRUE if we were\n-   successful at converting the block.  */\n+/* Given a simple IF-THEN-JOIN or IF-THEN-ELSE-JOIN block, attempt to convert\n+   it without using conditional execution.  Return TRUE if we were successful\n+   at converting the block.  */\n \n static int\n-noce_process_if_block (struct ce_if_block * ce_info)\n+noce_process_if_block (struct noce_if_info *if_info)\n {\n-  basic_block test_bb = ce_info->test_bb;\t/* test block */\n-  basic_block then_bb = ce_info->then_bb;\t/* THEN */\n-  basic_block else_bb = ce_info->else_bb;\t/* ELSE or NULL */\n-  basic_block join_bb;\n-  struct noce_if_info if_info;\n+  basic_block test_bb = if_info->test_bb;\t/* test block */\n+  basic_block then_bb = if_info->then_bb;\t/* THEN */\n+  basic_block else_bb = if_info->else_bb;\t/* ELSE or NULL */\n+  basic_block join_bb = if_info->join_bb;\t/* JOIN */\n+  rtx jump = if_info->jump;\n+  rtx cond = if_info->cond;\n   rtx insn_a, insn_b;\n   rtx set_a, set_b;\n   rtx orig_x, x, a, b;\n-  rtx jump, cond;\n \n   /* We're looking for patterns of the form\n \n@@ -2216,12 +2157,6 @@ noce_process_if_block (struct ce_if_block * ce_info)\n \n      ??? For future expansion, look for multiple X in such patterns.  */\n \n-  if (!noce_init_if_info (ce_info, &if_info))\n-    return FALSE;\n-\n-  cond = if_info.cond;\n-  jump = if_info.jump;\n-\n   /* Look for one of the potential sets.  */\n   insn_a = first_active_insn (then_bb);\n   if (! insn_a\n@@ -2251,7 +2186,7 @@ noce_process_if_block (struct ce_if_block * ce_info)\n     }\n   else\n     {\n-      insn_b = prev_nonnote_insn (if_info.cond_earliest);\n+      insn_b = prev_nonnote_insn (if_info->cond_earliest);\n       /* We're going to be moving the evaluation of B down from above\n \t COND_EARLIEST to JUMP.  Make sure the relevant data is still\n \t intact.  */\n@@ -2261,13 +2196,13 @@ noce_process_if_block (struct ce_if_block * ce_info)\n \t  || ! rtx_equal_p (x, SET_DEST (set_b))\n \t  || reg_overlap_mentioned_p (x, SET_SRC (set_b))\n \t  || modified_between_p (SET_SRC (set_b),\n-\t\t\t\t PREV_INSN (if_info.cond_earliest), jump)\n+\t\t\t\t PREV_INSN (if_info->cond_earliest), jump)\n \t  /* Likewise with X.  In particular this can happen when\n \t     noce_get_condition looks farther back in the instruction\n \t     stream than one might expect.  */\n \t  || reg_overlap_mentioned_p (x, cond)\n \t  || reg_overlap_mentioned_p (x, a)\n-\t  || modified_between_p (x, PREV_INSN (if_info.cond_earliest), jump))\n+\t  || modified_between_p (x, PREV_INSN (if_info->cond_earliest), jump))\n \tinsn_b = set_b = NULL_RTX;\n     }\n \n@@ -2288,7 +2223,7 @@ noce_process_if_block (struct ce_if_block * ce_info)\n       || (SMALL_REGISTER_CLASSES\n \t  && REGNO (x) < FIRST_PSEUDO_REGISTER))\n     {\n-      if (no_new_pseudos || GET_MODE (x) == BLKmode)\n+      if (GET_MODE (x) == BLKmode)\n \treturn FALSE;\n \n       if (GET_MODE (x) == ZERO_EXTRACT\n@@ -2305,11 +2240,11 @@ noce_process_if_block (struct ce_if_block * ce_info)\n     return FALSE;\n \n   /* Set up the info block for our subroutines.  */\n-  if_info.insn_a = insn_a;\n-  if_info.insn_b = insn_b;\n-  if_info.x = x;\n-  if_info.a = a;\n-  if_info.b = b;\n+  if_info->insn_a = insn_a;\n+  if_info->insn_b = insn_b;\n+  if_info->x = x;\n+  if_info->a = a;\n+  if_info->b = b;\n \n   /* Try optimizations in some approximation of a useful order.  */\n   /* ??? Should first look to see if X is live incoming at all.  If it\n@@ -2359,31 +2294,31 @@ noce_process_if_block (struct ce_if_block * ce_info)\n   if (!set_b && MEM_P (orig_x) && noce_mem_write_may_trap_or_fault_p (orig_x))\n     return FALSE;\n \n-  if (noce_try_move (&if_info))\n+  if (noce_try_move (if_info))\n     goto success;\n-  if (noce_try_store_flag (&if_info))\n+  if (noce_try_store_flag (if_info))\n     goto success;\n-  if (noce_try_bitop (&if_info))\n+  if (noce_try_bitop (if_info))\n     goto success;\n-  if (noce_try_minmax (&if_info))\n+  if (noce_try_minmax (if_info))\n     goto success;\n-  if (noce_try_abs (&if_info))\n+  if (noce_try_abs (if_info))\n     goto success;\n   if (HAVE_conditional_move\n-      && noce_try_cmove (&if_info))\n+      && noce_try_cmove (if_info))\n     goto success;\n   if (! HAVE_conditional_execution)\n     {\n-      if (noce_try_store_flag_constants (&if_info))\n+      if (noce_try_store_flag_constants (if_info))\n \tgoto success;\n-      if (noce_try_addcc (&if_info))\n+      if (noce_try_addcc (if_info))\n \tgoto success;\n-      if (noce_try_store_flag_mask (&if_info))\n+      if (noce_try_store_flag_mask (if_info))\n \tgoto success;\n       if (HAVE_conditional_move\n-\t  && noce_try_cmove_arith (&if_info))\n+\t  && noce_try_cmove_arith (if_info))\n \tgoto success;\n-      if (noce_try_sign_mask (&if_info))\n+      if (noce_try_sign_mask (if_info))\n \tgoto success;\n     }\n \n@@ -2409,8 +2344,6 @@ noce_process_if_block (struct ce_if_block * ce_info)\n   /* The original THEN and ELSE blocks may now be removed.  The test block\n      must now jump to the join block.  If the test block and the join block\n      can be merged, do so.  */\n-\n-  join_bb = single_succ (then_bb);\n   if (else_bb)\n     {\n       delete_basic_block (else_bb);\n@@ -2572,37 +2505,27 @@ cond_move_convert_if_block (struct noce_if_info *if_infop,\n   return true;\n }\n \n-/* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it\n-   using only conditional moves.  Return TRUE if we were successful at\n+/* Given a simple IF-THEN-JOIN or IF-THEN-ELSE-JOIN block, attempt to convert\n+   it using only conditional moves.  Return TRUE if we were successful at\n    converting the block.  */\n \n static int\n-cond_move_process_if_block (struct ce_if_block *ce_info)\n+cond_move_process_if_block (struct noce_if_info *if_info)\n {\n-  basic_block test_bb = ce_info->test_bb;\n-  basic_block then_bb = ce_info->then_bb;\n-  basic_block else_bb = ce_info->else_bb;\n-  basic_block join_bb;\n-  struct noce_if_info if_info;\n-  rtx jump, cond, seq, loc_insn;\n+  basic_block test_bb = if_info->test_bb;\n+  basic_block then_bb = if_info->then_bb;\n+  basic_block else_bb = if_info->else_bb;\n+  basic_block join_bb = if_info->join_bb;\n+  rtx jump = if_info->jump;\n+  rtx cond = if_info->cond;\n+  rtx seq, loc_insn;\n   int max_reg, size, c, reg;\n   rtx *then_vals;\n   rtx *else_vals;\n   VEC (int, heap) *then_regs = NULL;\n   VEC (int, heap) *else_regs = NULL;\n   unsigned int i;\n \n-  if (!HAVE_conditional_move || no_new_pseudos)\n-    return FALSE;\n-\n-  memset (&if_info, 0, sizeof if_info);\n-\n-  if (!noce_init_if_info (ce_info, &if_info))\n-    return FALSE;\n-\n-  cond = if_info.cond;\n-  jump = if_info.jump;\n-\n   /* Build a mapping for each block to the value used for each\n      register.  */\n   max_reg = max_reg_num ();\n@@ -2655,16 +2578,16 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n   /* Try to emit the conditional moves.  First do the then block,\n      then do anything left in the else blocks.  */\n   start_sequence ();\n-  if (!cond_move_convert_if_block (&if_info, then_bb, cond,\n+  if (!cond_move_convert_if_block (if_info, then_bb, cond,\n \t\t\t\t   then_vals, else_vals, false)\n       || (else_bb\n-\t  && !cond_move_convert_if_block (&if_info, else_bb, cond,\n+\t  && !cond_move_convert_if_block (if_info, else_bb, cond,\n \t\t\t\t\t  then_vals, else_vals, true)))\n     {\n       end_sequence ();\n       return FALSE;\n     }\n-  seq = end_ifcvt_sequence (&if_info);\n+  seq = end_ifcvt_sequence (if_info);\n   if (!seq)\n     return FALSE;\n \n@@ -2676,7 +2599,6 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n     }\n   emit_insn_before_setloc (seq, jump, INSN_LOCATOR (loc_insn));\n \n-  join_bb = single_succ (then_bb);\n   if (else_bb)\n     {\n       delete_basic_block (else_bb);\n@@ -2705,40 +2627,127 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n }\n \n \f\n-/* Attempt to convert an IF-THEN or IF-THEN-ELSE block into\n-   straight line code.  Return true if successful.  */\n+/* Determine if a given basic block heads a simple IF-THEN-JOIN or an\n+   IF-THEN-ELSE-JOIN block.\n+\n+   If so, we'll try to convert the insns to not require the branch,\n+   using only transformations that do not require conditional execution.\n+\n+   Return TRUE if we were successful at converting the block.  */\n \n static int\n-process_if_block (struct ce_if_block * ce_info)\n+noce_find_if_block (basic_block test_bb,\n+\t\t    edge then_edge, edge else_edge,\n+\t\t    int pass)\n {\n-  if (! reload_completed\n-      && noce_process_if_block (ce_info))\n-    return TRUE;\n+  basic_block then_bb, else_bb, join_bb;\n+  bool then_else_reversed = false;\n+  rtx jump, cond;\n+  struct noce_if_info if_info;\n \n-  if (HAVE_conditional_move\n-      && cond_move_process_if_block (ce_info))\n-    return TRUE;\n+  /* We only ever should get here before reload.  */\n+  gcc_assert (!reload_completed);\n \n-  if (HAVE_conditional_execution && reload_completed)\n+  /* Recognize an IF-THEN-ELSE-JOIN block.  */\n+  if (single_pred_p (then_edge->dest)\n+      && single_succ_p (then_edge->dest)\n+      && single_pred_p (else_edge->dest)\n+      && single_succ_p (else_edge->dest)\n+      && single_succ (then_edge->dest) == single_succ (else_edge->dest))\n     {\n-      /* If we have && and || tests, try to first handle combining the && and\n-         || tests into the conditional code, and if that fails, go back and\n-         handle it without the && and ||, which at present handles the && case\n-         if there was no ELSE block.  */\n-      if (cond_exec_process_if_block (ce_info, TRUE))\n-\treturn TRUE;\n+      then_bb = then_edge->dest;\n+      else_bb = else_edge->dest;\n+      join_bb = single_succ (then_bb);\n+    }\n+  /* Recognize an IF-THEN-JOIN block.  */\n+  else if (single_pred_p (then_edge->dest)\n+\t   && single_succ_p (then_edge->dest)\n+\t   && single_succ (then_edge->dest) == else_edge->dest)\n+    {\n+      then_bb = then_edge->dest;\n+      else_bb = NULL_BLOCK;\n+      join_bb = else_edge->dest;\n+    }\n+  /* Recognize an IF-ELSE-JOIN block.  We can have those because the order\n+     of basic blocks in cfglayout mode does not matter, so the fallthrough\n+     edge can go to any basic block (and not just to bb->next_bb, like in\n+     cfgrtl mode).  */ \n+  else if (single_pred_p (else_edge->dest)\n+\t   && single_succ_p (else_edge->dest)\n+\t   && single_succ (else_edge->dest) == then_edge->dest)\n+    {\n+      /* The noce transformations do not apply to IF-ELSE-JOIN blocks.\n+\t To make this work, we have to invert the THEN and ELSE blocks\n+\t and reverse the jump condition.  */\n+      then_bb = else_edge->dest;\n+      else_bb = NULL_BLOCK;\n+      join_bb = single_succ (then_bb);\n+      then_else_reversed = true;\n+    }\n+  else\n+    /* Not a form we can handle.  */\n+    return FALSE;\n+     \n+  /* The edges of the THEN and ELSE blocks cannot have complex edges.  */\n+  if (single_succ_edge (then_bb)->flags & EDGE_COMPLEX)\n+    return FALSE;\n+  if (else_bb\n+      && single_succ_edge (else_bb)->flags & EDGE_COMPLEX)\n+    return FALSE;\n \n-      if (ce_info->num_multiple_test_blocks)\n-\t{\n-\t  cancel_changes (0);\n+  num_possible_if_blocks++;\n \n-\t  if (cond_exec_process_if_block (ce_info, FALSE))\n-\t    return TRUE;\n-\t}\n+  if (dump_file)\n+    {\n+      fprintf (dump_file,\n+\t       \"\\nIF-THEN%s-JOIN block found, pass %d, test %d, then %d\",\n+\t       (else_bb) ? \"-ELSE\" : \"\",\n+\t       pass, test_bb->index, then_bb->index);\n+\n+      if (else_bb)\n+\tfprintf (dump_file, \", else %d\", else_bb->index);\n+\n+      fprintf (dump_file, \", join %d\\n\", join_bb->index);\n     }\n \n+  /* If the conditional jump is more than just a conditional\n+     jump, then we can not do if-conversion on this block.  */\n+  jump = BB_END (test_bb);\n+  if (! onlyjump_p (jump))\n+    return FALSE;\n+\n+  /* If this is not a standard conditional jump, we can't parse it.  */\n+  cond = noce_get_condition (jump,\n+\t\t\t     &if_info.cond_earliest,\n+\t\t\t     then_else_reversed);\n+  if (!cond)\n+    return FALSE;\n+\n+  /* We must be comparing objects whose modes imply the size.  */\n+  if (GET_MODE (XEXP (cond, 0)) == BLKmode)\n+    return FALSE;\n+\n+  /* Initialize an IF_INFO struct to pass around.  */\n+  memset (&if_info, 0, sizeof if_info);\n+  if_info.test_bb = test_bb;\n+  if_info.then_bb = then_bb;\n+  if_info.else_bb = else_bb;\n+  if_info.join_bb = join_bb;\n+  if_info.cond = cond;\n+  if_info.jump = jump;\n+\n+  /* Do the real work.  */\n+\n+  if (noce_process_if_block (&if_info))\n+    return TRUE;\n+\n+  if (HAVE_conditional_move\n+      && cond_move_process_if_block (&if_info))\n+    return TRUE;\n+\n   return FALSE;\n }\n+\f\n \n /* Merge the blocks and mark for local life update.  */\n \n@@ -2901,7 +2910,12 @@ find_if_header (basic_block test_bb, int pass)\n   IFCVT_INIT_EXTRA_FIELDS (&ce_info);\n #endif\n \n-  if (find_if_block (&ce_info))\n+  if (! reload_completed\n+      && noce_find_if_block (test_bb, then_edge, else_edge, pass))\n+    goto success;\n+\n+  if (HAVE_conditional_execution && reload_completed\n+      && cond_exec_find_if_block (&ce_info))\n     goto success;\n \n   if (HAVE_trap && HAVE_conditional_trap\n@@ -2999,7 +3013,7 @@ block_jumps_and_fallthru_p (basic_block cur_bb, basic_block target_bb)\n    Return TRUE if we were successful at converting the block.  */\n \n static int\n-find_if_block (struct ce_if_block * ce_info)\n+cond_exec_find_if_block (struct ce_if_block * ce_info)\n {\n   basic_block test_bb = ce_info->test_bb;\n   basic_block then_bb = ce_info->then_bb;\n@@ -3011,11 +3025,14 @@ find_if_block (struct ce_if_block * ce_info)\n \n   ce_info->last_test_bb = test_bb;\n \n+  /* We only ever should get here after reload,\n+     and only if we have conditional execution.  */\n+  gcc_assert (HAVE_conditional_execution && reload_completed);\n+\n   /* Discover if any fall through predecessors of the current test basic block\n      were && tests (which jump to the else block) or || tests (which jump to\n      the then block).  */\n-  if (HAVE_conditional_execution && reload_completed\n-      && single_pred_p (test_bb)\n+  if (single_pred_p (test_bb)\n       && single_pred_edge (test_bb)->flags == EDGE_FALLTHRU)\n     {\n       basic_block bb = single_pred (test_bb);\n@@ -3201,10 +3218,24 @@ find_if_block (struct ce_if_block * ce_info)\n     }\n \n   /* Do the real work.  */\n+\n   ce_info->else_bb = else_bb;\n   ce_info->join_bb = join_bb;\n \n-  return process_if_block (ce_info);\n+  /* If we have && and || tests, try to first handle combining the && and ||\n+     tests into the conditional code, and if that fails, go back and handle\n+     it without the && and ||, which at present handles the && case if there\n+     was no ELSE block.  */\n+  if (cond_exec_process_if_block (ce_info, TRUE))\n+    return TRUE;\n+\n+  if (ce_info->num_multiple_test_blocks)\n+    {\n+      cancel_changes (0);\n+\n+      if (cond_exec_process_if_block (ce_info, FALSE))\n+\treturn TRUE;\n+    }\n }\n \n /* Convert a branch over a trap, or a branch\n@@ -3237,7 +3268,7 @@ find_cond_trap (basic_block test_bb, edge then_edge, edge else_edge)\n \n   /* If this is not a standard conditional jump, we can't parse it.  */\n   jump = BB_END (test_bb);\n-  cond = noce_get_condition (jump, &cond_earliest);\n+  cond = noce_get_condition (jump, &cond_earliest, false);\n   if (! cond)\n     return FALSE;\n \n@@ -3733,7 +3764,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \treturn FALSE;\n \n       /* Find the extent of the conditional.  */\n-      cond = noce_get_condition (jump, &earliest);\n+      cond = noce_get_condition (jump, &earliest, false);\n       if (! cond)\n \treturn FALSE;\n \n@@ -3908,6 +3939,10 @@ if_convert (int x_life_data_ok)\n   num_true_changes = 0;\n   life_data_ok = (x_life_data_ok != 0);\n \n+  /* Some transformations in this pass can create new pseudos,\n+     if the pass runs before reload.  Make sure we can do so.  */\n+  gcc_assert (! no_new_pseudos || reload_completed);\n+\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n   if (current_loops)\n     {"}]}