{"sha": "715bdd81177d2e691d07c19c1a4e48d63474ed81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE1YmRkODExNzdkMmU2OTFkMDdjMTljMWE0ZTQ4ZDYzNDc0ZWQ4MQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@cygnus.com", "date": "2000-02-10T17:16:30Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2000-02-10T17:16:30Z"}, "message": "interpret.cc: Don't include fdlibm.h.\n\n2000-02-10  Andrew Haley  <aph@cygnus.com>\n\n\t* interpret.cc: Don't include fdlibm.h.\n\tReplace #if with #ifdef throughout.\n\tDeclare extern __ieee754_fmod.\n\t(continue1): Remove op_getfield, op_getstatic, op_putfield,\n\top_putstatic insns.\n\t* resolve.cc (_Jv_PrepareClass): Use imeth as method pointer.\n\tSearch class hierarchy for superclass vtable.\n\n\t* java/lang/natClassLoader.cc (_Jv_UnregisterClass): Don't fall\n\toff the end of a pointer list.\n\n\t* java/lang/natThread.cc (stop): Don't abort, throw an exception\n\tinstead.\n\t(suspend): Ditto.\n\nFrom-SVN: r31897", "tree": {"sha": "050f8341578bf95abc8c7ab48b6e79fd2b1e77ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/050f8341578bf95abc8c7ab48b6e79fd2b1e77ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/715bdd81177d2e691d07c19c1a4e48d63474ed81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/715bdd81177d2e691d07c19c1a4e48d63474ed81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/715bdd81177d2e691d07c19c1a4e48d63474ed81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/715bdd81177d2e691d07c19c1a4e48d63474ed81/comments", "author": null, "committer": null, "parents": [{"sha": "ae0a06c54bdf4fa7511c4b65315a05a684ca7c03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae0a06c54bdf4fa7511c4b65315a05a684ca7c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae0a06c54bdf4fa7511c4b65315a05a684ca7c03"}], "stats": {"total": 442, "additions": 130, "deletions": 312}, "files": [{"sha": "159853c6b0464535fbc8e049978729112d073311", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/715bdd81177d2e691d07c19c1a4e48d63474ed81/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/715bdd81177d2e691d07c19c1a4e48d63474ed81/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=715bdd81177d2e691d07c19c1a4e48d63474ed81", "patch": "@@ -1,3 +1,20 @@\n+2000-02-10  Andrew Haley  <aph@cygnus.com>\n+\n+\t* interpret.cc: Don't include fdlibm.h.\n+\tReplace #if with #ifdef throughout.\n+\tDeclare extern __ieee754_fmod.\n+\t(continue1): Remove op_getfield, op_getstatic, op_putfield,\n+\top_putstatic insns.\n+\t* resolve.cc (_Jv_PrepareClass): Use imeth as method pointer.\n+\tSearch class hierarchy for superclass vtable.\n+\n+\t* java/lang/natClassLoader.cc (_Jv_UnregisterClass): Don't fall\n+\toff the end of a pointer list.\n+\n+\t* java/lang/natThread.cc (stop): Don't abort, throw an exception\n+\tinstead.\n+\t(suspend): Ditto.\n+\t\n 2000-02-09  Tom Tromey  <tromey@cygnus.com>\n \n \t* java/lang/natRuntime.cc (_load): Call add_library."}, {"sha": "c8870c334f3f6532f944cfecd14fee04f7674982", "filename": "libjava/interpret.cc", "status": "modified", "additions": 88, "deletions": 303, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/715bdd81177d2e691d07c19c1a4e48d63474ed81/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/715bdd81177d2e691d07c19c1a4e48d63474ed81/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=715bdd81177d2e691d07c19c1a4e48d63474ed81", "patch": "@@ -17,7 +17,7 @@ details.  */\n #include <jvm.h>\n #include <java-cpool.h>\n #include <java-interp.h>\n-#include <java/lang/fdlibm.h>\n+// #include <java/lang/fdlibm.h>\n #include <java/lang/System.h>\n #include <java/lang/String.h>\n #include <java/lang/Integer.h>\n@@ -56,16 +56,18 @@ static void throw_internal_error (char *msg)\n   __attribute__ ((__noreturn__));\n static void throw_incompatible_class_change_error (jstring msg)\n   __attribute__ ((__noreturn__));\n-#if !HANDLE_SEGV\n+#ifndef HANDLE_SEGV\n static void throw_null_pointer_exception ()\n   __attribute__ ((__noreturn__));\n #endif\n-#if !HANDLE_FPE\n+#ifndef HANDLE_FPE\n static void throw_arithmetic_exception ()\n   __attribute__ ((__noreturn__));\n #endif\n \n \n+extern \"C\" double __ieee754_fmod __P((double,double));\n+\n static inline void dupx (_Jv_word *sp, int n, int x)\n {\n   // first \"slide\" n+x elements n to the right\n@@ -177,14 +179,14 @@ static jint get4(unsigned char* loc) {\n }\n \n \n-#if HANDLE_SEGV\n+#ifdef HANDLE_SEGV\n #define NULLCHECK(X) \n #else\n #define NULLCHECK(X) \\\n   do { if ((X)==NULL) throw_null_pointer_exception (); } while (0)\n #endif\n \n-#if HANDLE_FPE\n+#ifdef HANDLE_FPE\n #define ZEROCHECK(X)\n #else\n #define ZEROCHECK(X) \\\n@@ -620,32 +622,6 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n     INSN_LABEL(ifnonnull),\n     INSN_LABEL(goto_w),\n     INSN_LABEL(jsr_w),\n-\n-    INSN_LABEL(putfield_1),\n-    INSN_LABEL(putfield_2),\n-    INSN_LABEL(putfield_4),\n-    INSN_LABEL(putfield_8),\n-    INSN_LABEL(putfield_a),\n-\n-    INSN_LABEL(putstatic_1),\n-    INSN_LABEL(putstatic_2),\n-    INSN_LABEL(putstatic_4),\n-    INSN_LABEL(putstatic_8),\n-    INSN_LABEL(putstatic_a),\n-\n-    INSN_LABEL(getfield_1),\n-    INSN_LABEL(getfield_2s),\n-    INSN_LABEL(getfield_2u),\n-    INSN_LABEL(getfield_4),\n-    INSN_LABEL(getfield_8),\n-    INSN_LABEL(getfield_a),\n-\n-    INSN_LABEL(getstatic_1),\n-    INSN_LABEL(getstatic_2s),\n-    INSN_LABEL(getstatic_2u),\n-    INSN_LABEL(getstatic_4),\n-    INSN_LABEL(getstatic_8),\n-    INSN_LABEL(getstatic_a),\n   };\n \n #define SAVE_PC   inv->pc = pc-1\n@@ -665,7 +641,9 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \n #ifdef  INLINE_SWITCH\n \n-#define NEXT_INSN GOTO_INSN(*pc++)\n+#define NEXT_INSN do { GOTO_INSN(*pc++); } while (0)\n+\n+\n   NEXT_INSN;\n #else\n \n@@ -688,30 +666,10 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       LOADI (get1u (pc++));\n       NEXT_INSN;\n \n-     insn_getfield_4:\t\t// 0xd8\n-      SAVE_PC;\n-      {\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\tPUSHI (*(jint*) ((char*)obj + field_offset));\n-      }\n-      NEXT_INSN;\n-\n      insn_iload_1:\t\t// 0x1b\n       LOADI (1);\n       NEXT_INSN;\n \n-     insn_getfield_a:\t\t// 0xda\n-      SAVE_PC;\n-      {\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\tPUSHA(*(jobject*) ((char*)obj + field_offset));\n-      }\n-      NEXT_INSN;\n-\n      insn_invokevirtual:\t// 0xb6\n       SAVE_PC;\n       {\n@@ -1973,7 +1931,6 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n      insn_getstatic:\n       SAVE_PC;\n       {\n-\tunsigned char *base_pc = pc-1;\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n@@ -1989,38 +1946,34 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t    switch (type->size_in_bytes)\n \t      {\n \t      case 1:\n-\t\t*base_pc = op_getstatic_1;\n-\t\tbreak;\n+\t\tPUSHI (*(jbyte*) (field->u.addr));\n \n \t      case 2:\n \t\tif (type == JvPrimClass (char))\n-\t\t  *base_pc = op_getstatic_2u;\n+\t\t  PUSHI(*(jchar*) (field->u.addr));\n \t\telse\n-\t\t  *base_pc = op_getstatic_2s;\n+\t\t  PUSHI(*(jshort*) (field->u.addr));\n \t\tbreak;\n \n \t      case 4:\n-\t\t*base_pc = op_getstatic_4;\n+\t\tPUSHI(*(jint*) (field->u.addr));\n \t\tbreak;\n \n \t      case 8:\n-\t\t*base_pc = op_getstatic_8;\n+\t\tPUSHL(*(jlong*) (field->u.addr));\n \t\tbreak;\n \t      }\n \t  }\n \telse\n \t  {\n-\t    *base_pc = op_getstatic_a;\n+\t    PUSHA(*(jobject*) (field->u.addr));\n \t  }\n-\n-\tpc = base_pc;\n       }\n       NEXT_INSN;\n \n      insn_getfield:\n       SAVE_PC;\n       {\n-\tunsigned char *base_pc = pc-1;\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n@@ -2030,50 +1983,47 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t    (JvNewStringLatin1 (\"field is static\"));\n \n \tjclass type = field->type;\n+\tjint field_offset = field->u.boffset;\n+\tif (field_offset > 0xffff)\n+\t  JvThrow (new java::lang::VirtualMachineError);\n+\n+\tjobject obj   = POPA();\n+\tNULLCHECK(obj);\n \n \tif (type->isPrimitive ())\n \t  {\n \t    switch (type->size_in_bytes)\n \t      {\n \t      case 1:\n-\t\t*base_pc = op_getfield_1;\n+\t\tPUSHI (*(jbyte*) ((char*)obj + field_offset));\n \t\tbreak;\n \n \t      case 2:\n \t\tif (type == JvPrimClass (char))\n-\t\t  *base_pc = op_getfield_2u;\n+\t\t  PUSHI (*(jchar*) ((char*)obj + field_offset));\n \t\telse\n-\t\t  *base_pc = op_getfield_2s;\n+\t\t  PUSHI (*(jshort*) ((char*)obj + field_offset));\n \t\tbreak;\n \n \t      case 4:\n-\t\t*base_pc = op_getfield_4;\n+\t\tPUSHI (*(jint*) ((char*)obj + field_offset));\n \t\tbreak;\n \n \t      case 8:\n-\t\t*base_pc = op_getfield_8;\n+\t\tPUSHL(*(jlong*) ((char*)obj + field_offset));\n \t\tbreak;\n \t      }\n \t  }\n \telse\n \t  {\n-\t    *base_pc = op_getfield_a;\n+\t    PUSHA(*(jobject*) ((char*)obj + field_offset));\n \t  }\n-\n-\tif (field->u.boffset > 0xffff)\n-\t  JvThrow (new java::lang::VirtualMachineError);\n-\n-\tbase_pc[1] = (field->u.boffset>>8) & 0xff;\n-\tbase_pc[2] = field->u.boffset & 0xff;\n-\n-\tpc = base_pc;\n       }\n       NEXT_INSN;\n \n      insn_putstatic:\n       SAVE_PC;\n       {\n-\tunsigned char* base_pc = pc-1;\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n@@ -2085,45 +2035,51 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t  throw_incompatible_class_change_error \n \t    (JvNewStringLatin1 (\"field no longer static\"));\n \n-\t/* if this is patented, then maybe we could install\n-\t   a function in the constant pool, to do the right thing */\n-\n \tif (type->isPrimitive ())\n \t  {\n \t    switch (type->size_in_bytes) \n \t      {\n \t      case 1:\n-\t\t*base_pc = op_putstatic_1;\n-\t\tbreak;\n+\t\t{\n+\t\t  jint value = POPI();\n+\t\t  *(jbyte*) (field->u.addr) = value;\n+\t\t  break;\n+\t\t}\n \n \t      case 2:\n-\t\t*base_pc = op_putstatic_2;\n-\t\tbreak;\n+\t\t{\n+\t\t  jint value = POPI();\n+\t\t  *(jchar*) (field->u.addr) = value;\n+\t\t  break;\n+\t\t}\n \n \t      case 4:\n-\t\t*base_pc = op_putstatic_4;\n-\t\tbreak;\n+\t\t{\n+\t\t  jint value = POPI();\n+\t\t  *(jint*) (field->u.addr) = value;\n+\t\t  break;\n+\t\t}\n \n \t      case 8:\n-\t\t*base_pc = op_putstatic_8;\n-\t\tbreak;\n+\t\t{\n+\t\t  jlong value = POPL();\n+\t\t  *(jlong*) (field->u.addr) = value;\n+\t\t  break;\n+\t\t}\n \t      }\n \t  }\n \telse\n \t  {\n-\t    *base_pc = op_putstatic_a;\n+\t    jobject value = POPA();\n+\t    *(jobject*) (field->u.addr) = value;\n \t  }\n-\n-\t// do the instruction again!\n-\tpc = base_pc;\n       }\n       NEXT_INSN;\n \n \n      insn_putfield:\n       SAVE_PC;\n       {\n-\tunsigned char* base_pc = pc-1;\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n@@ -2134,229 +2090,58 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t  throw_incompatible_class_change_error \n \t    (JvNewStringLatin1 (\"field is static\"));\n \n+\tjint field_offset = field->u.boffset;\n+\tif (field_offset > 0xffff)\n+\t  JvThrow (new java::lang::VirtualMachineError);\n+\n \tif (type->isPrimitive ())\n \t  {\n \t    switch (type->size_in_bytes) \n \t      {\n \t      case 1:\n-\t\t*base_pc = op_putfield_1;\n-\t\tbreak;\n+\t\t{\n+\t\t  jint    value = POPI();\n+\t\t  jobject obj   = POPA();\n+\t\t  NULLCHECK(obj);\n+\t\t  *(jbyte*) ((char*)obj + field_offset) = value;\n+\t\t  break;\n+\t\t}\n \n \t      case 2:\n-\t\t*base_pc = op_putfield_2;\n-\t\tbreak;\n+\t\t{\n+\t\t  jint    value = POPI();\n+\t\t  jobject obj   = POPA();\n+\t\t  NULLCHECK(obj);\n+\t\t  *(jchar*) ((char*)obj + field_offset) = value;\n+\t\t  break;\n+\t\t}\n \n \t      case 4:\n-\t\t*base_pc = op_putfield_4;\n-\t\tbreak;\n+\t\t{\n+\t\t  jint    value = POPI();\n+\t\t  jobject obj   = POPA();\n+\t\t  NULLCHECK(obj);\n+\t\t  *(jint*) ((char*)obj + field_offset) = value;\n+\t\t  break;\n+\t\t}\n \n \t      case 8:\n-\t\t*base_pc = op_putfield_8;\n-\t\tbreak;\n+\t\t{\n+\t\t  jlong   value = POPL();\n+\t\t  jobject obj   = POPA();\n+\t\t  NULLCHECK(obj);\n+\t\t  *(jlong*) ((char*)obj + field_offset) = value;\n+\t\t  break;\n+\t\t}\n \t      }\n \t  }\n \telse\n \t  {\n-\t    *base_pc = op_putfield_a;\n+\t    jobject value = POPA();\n+\t    jobject obj   = POPA();\n+\t    NULLCHECK(obj);\n+\t    *(jobject*) ((char*)obj + field_offset) = value;\n \t  }\n-\n-\tif (field->u.boffset > 0xffff)\n-\t  JvThrow (new java::lang::VirtualMachineError);\n-\n-\tbase_pc[1] = (field->u.boffset>>8) & 0xff;\n-\tbase_pc[2] = field->u.boffset & 0xff;\n-\n-\t// do the instruction again!\n-\tpc = base_pc;\n-      }\n-      NEXT_INSN;\n-\n-\n-     insn_getfield_1:\n-      SAVE_PC;\n-      {\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\tPUSHI (*(jbyte*) ((char*)obj + field_offset));\n-      }\n-      NEXT_INSN;\n-\n-     insn_getfield_2s:\n-      SAVE_PC;\n-      {\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\tPUSHI (*(jshort*) ((char*)obj + field_offset));\n-      }\n-      NEXT_INSN;\n-\n-     insn_getfield_2u:\n-      SAVE_PC;\n-      {\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\tPUSHI (*(jchar*) ((char*)obj + field_offset));\n-      }\n-      NEXT_INSN;\n-\n-     insn_getfield_8:\n-      SAVE_PC;\n-      {\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\tPUSHL(*(jlong*) ((char*)obj + field_offset));\n-      }\n-      NEXT_INSN;\n-\n-     insn_getstatic_1:\n-      {\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\tPUSHI (*(jbyte*) (field->u.addr));\n-      }\n-      NEXT_INSN;\n-\n-     insn_getstatic_2s:\n-      {\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\tPUSHI(*(jshort*) (field->u.addr));\n-      }\n-      NEXT_INSN;\n-\n-     insn_getstatic_2u:\n-      {\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\tPUSHI(*(jchar*) (field->u.addr));\n-      }\n-      NEXT_INSN;\n-\n-     insn_getstatic_4:\n-      {\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\tPUSHI(*(jint*) (field->u.addr));\n-      }\n-      NEXT_INSN;\n-\n-     insn_getstatic_8:\n-      {\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\tPUSHL(*(jlong*) (field->u.addr));\n-      }\n-      NEXT_INSN;\n-\n-     insn_getstatic_a:\n-      {\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\tPUSHA(*(jobject*) (field->u.addr));\n-      }\n-      NEXT_INSN;\n-\n-     insn_putfield_1:\n-      SAVE_PC;\n-      {\n-\tjint    value = POPI();\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\t*(jbyte*) ((char*)obj + field_offset) = value;\n-      }\n-      NEXT_INSN;\n-\n-     insn_putfield_2:\n-      SAVE_PC;\n-      {\n-\tjint    value = POPI();\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\t*(jchar*) ((char*)obj + field_offset) = value;\n-      }\n-      NEXT_INSN;\n-\n-     insn_putfield_4:\n-      SAVE_PC;\n-      {\n-\tjint    value = POPI();\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\t*(jint*) ((char*)obj + field_offset) = value;\n-      }\n-      NEXT_INSN;\n-\n-     insn_putfield_8:\n-      SAVE_PC;\n-      {\n-\tjlong   value = POPL();\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\t*(jlong*) ((char*)obj + field_offset) = value;\n-      }\n-      NEXT_INSN;\n-\n-     insn_putfield_a:\n-      SAVE_PC;\n-      {\n-\tjobject value = POPA();\n-\tjobject obj   = POPA();\n-\tNULLCHECK(obj);\n-\tjint field_offset = get2u (pc); pc += 2;\n-\t*(jobject*) ((char*)obj + field_offset) = value;\n-      }\n-      NEXT_INSN;\n-\n-     insn_putstatic_1:\n-      {\n-\tjint    value = POPI();\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\t*(jbyte*) (field->u.addr) = value;\n-      }\n-      NEXT_INSN;\n-\n-     insn_putstatic_2:\n-      {\n-\tjint    value = POPI();\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\t*(jchar*) (field->u.addr) = value;\n-      }\n-      NEXT_INSN;\n-\n-     insn_putstatic_4:\n-      {\n-\tjint    value = POPI();\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\t*(jint*) (field->u.addr) = value;\n-      }\n-      NEXT_INSN;\n-\n-     insn_putstatic_8:\n-      {\n-\tjlong    value = POPL();\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\t*(jlong*) (field->u.addr) = value;\n-      }\n-      NEXT_INSN;\n-\n-     insn_putstatic_a:\n-      {\n-\tjobject value = POPA();\n-\tjint fieldref_index = get2u (pc); pc += 2;\n-\t_Jv_Field *field = pool_data[fieldref_index].field;\n-\t*(jobject*) (field->u.addr) = value;\n       }\n       NEXT_INSN;\n \n@@ -2641,7 +2426,7 @@ throw_incompatible_class_change_error (jstring msg)\n   JvThrow (new java::lang::IncompatibleClassChangeError (msg));\n }\n \n-#if !HANDLE_SEGV\n+#ifndef HANDLE_SEGV\n static java::lang::NullPointerException *null_pointer_exc;\n static void \n throw_null_pointer_exception ()\n@@ -2653,7 +2438,7 @@ throw_null_pointer_exception ()\n }\n #endif\n \n-#if !HANDLE_FPE\n+#ifndef HANDLE_FPE\n static java::lang::ArithmeticException *arithmetic_exc;\n static void \n throw_arithmetic_exception ()"}, {"sha": "e5ff17e02aba7fab9022db08a6fe048d86d60c88", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/715bdd81177d2e691d07c19c1a4e48d63474ed81/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/715bdd81177d2e691d07c19c1a4e48d63474ed81/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=715bdd81177d2e691d07c19c1a4e48d63474ed81", "patch": "@@ -368,12 +368,15 @@ _Jv_UnregisterClass (jclass the_class)\n     }\n \n   _Jv_LoaderInfo **info = &(initiated_classes[hash]);\n-  for ( ; *info; info = &((*info)->next))\n+  for ( ; ; info = &((*info)->next))\n     {\n-      while ((*info)->klass == the_class)\n+      while (*info && (*info)->klass == the_class)\n \t{\n \t  *info = (*info)->next;\n \t}\n+\n+      if (*info == NULL)\n+\tbreak;\n     }\n \n   _Jv_MonitorExit (&ClassClass);"}, {"sha": "6870f02c50d55aa3472b8cf79405695eb3b3262a", "filename": "libjava/java/lang/natThread.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/715bdd81177d2e691d07c19c1a4e48d63474ed81/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/715bdd81177d2e691d07c19c1a4e48d63474ed81/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=715bdd81177d2e691d07c19c1a4e48d63474ed81", "patch": "@@ -19,6 +19,7 @@ details.  */\n #include <java/lang/Thread.h>\n #include <java/lang/ThreadGroup.h>\n #include <java/lang/IllegalArgumentException.h>\n+#include <java/lang/UnsupportedOperationException.h>\n #include <java/lang/IllegalThreadStateException.h>\n #include <java/lang/InterruptedException.h>\n #include <java/lang/NullPointerException.h>\n@@ -306,14 +307,16 @@ java::lang::Thread::start (void)\n void\n java::lang::Thread::stop (java::lang::Throwable *)\n {\n-  JvFail (\"java::lang::Thread::stop unimplemented\");\n+  _Jv_Throw (new UnsupportedOperationException\n+\t     (JvNewStringLatin1 (\"java::lang::Thread::stop unimplemented\")));\n }\n \n void\n java::lang::Thread::suspend (void)\n {\n   checkAccess ();\n-  JvFail (\"java::lang::Thread::suspend unimplemented\");\n+  _Jv_Throw (new UnsupportedOperationException \n+\t     (JvNewStringLatin1 (\"java::lang::Thread::suspend unimplemented\")));\n }\n \n void"}, {"sha": "0d39de1ee6adb2700163687dd0da6598e6f77a84", "filename": "libjava/resolve.cc", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/715bdd81177d2e691d07c19c1a4e48d63474ed81/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/715bdd81177d2e691d07c19c1a4e48d63474ed81/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=715bdd81177d2e691d07c19c1a4e48d63474ed81", "patch": "@@ -576,7 +576,7 @@ _Jv_PrepareClass(jclass klass)\n \t}\n       else if (imeth != 0)\t\t// it could be abstract\n \t{\n-\t  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (im);\n+\t  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (imeth);\n \t  clz->methods[i].ncode = im->ncode ();\n \t}\n     }\n@@ -650,10 +650,20 @@ _Jv_PrepareClass(jclass klass)\n \t\t\t   + (sizeof (void*) * (vtable_count)));\n   vtable->clas = clz;\n \n-  /* copy super class' vtable entries (index 0 goes unused). */\n-  memcpy ((void*)&vtable->method[1],\n-\t  (void*)&super_class->vtable->method[1],\n-\t  sizeof (void*) * super_class->vtable_method_count);\n+  {\n+    jclass effective_superclass = super_class;\n+\n+    /* If super_class is abstract or an interface it has no vtable.\n+       We need to find a real one... */\n+    while (effective_superclass && effective_superclass->vtable == NULL)\n+      effective_superclass = effective_superclass->superclass;\n+\n+    /* copy super class' vtable entries (index 0 goes unused). */\n+    if (effective_superclass && effective_superclass->vtable)\n+      memcpy ((void*)&vtable->method[1],\n+\t      (void*)&effective_superclass->vtable->method[1],\n+\t      sizeof (void*) * effective_superclass->vtable_method_count);\n+  }\n \n   /* now, install our own vtable entries, reprise... */\n   for (int i = 0; i < clz->method_count; i++)"}]}