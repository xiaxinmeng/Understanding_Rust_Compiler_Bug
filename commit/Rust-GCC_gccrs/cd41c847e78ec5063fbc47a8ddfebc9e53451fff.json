{"sha": "cd41c847e78ec5063fbc47a8ddfebc9e53451fff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q0MWM4NDdlNzhlYzUwNjNmYmM0N2E4ZGRmZWJjOWU1MzQ1MWZmZg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-03-21T13:43:20Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-03-21T13:43:20Z"}, "message": "ffi.h.in: Define X86 instead of X86_64 in 32 bit mode.\n\n\t* libffi/include/ffi.h.in: Define X86 instead of X86_64 in 32\n\tbit mode.\n\t* libffi/src/x86/ffi.c (ffi_closure_SYSV, ffi_closure_raw_SYSV):\n\tReceive closure pointer through parameter, read args using\n\t__builtin_dwarf_cfa.\n\t(FFI_INIT_TRAMPOLINE): Send closure reference through eax.\n\nFrom-SVN: r64663", "tree": {"sha": "6dea143dc96cfc4e89d2a91d39d6ea3e47cf03e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dea143dc96cfc4e89d2a91d39d6ea3e47cf03e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd41c847e78ec5063fbc47a8ddfebc9e53451fff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd41c847e78ec5063fbc47a8ddfebc9e53451fff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd41c847e78ec5063fbc47a8ddfebc9e53451fff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd41c847e78ec5063fbc47a8ddfebc9e53451fff/comments", "author": null, "committer": null, "parents": [{"sha": "731458a46df64853cfea759eecdb3f704752dcbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/731458a46df64853cfea759eecdb3f704752dcbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/731458a46df64853cfea759eecdb3f704752dcbd"}], "stats": {"total": 61, "additions": 32, "deletions": 29}, "files": [{"sha": "01517c14c9f93cedb68193a3b7d2c363783f1902", "filename": "libffi/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd41c847e78ec5063fbc47a8ddfebc9e53451fff/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd41c847e78ec5063fbc47a8ddfebc9e53451fff/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=cd41c847e78ec5063fbc47a8ddfebc9e53451fff", "patch": "@@ -1,3 +1,12 @@\n+2003-03-21  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* libffi/include/ffi.h.in: Define X86 instead of X86_64 in 32\n+\tbit mode.\n+\t* libffi/src/x86/ffi.c (ffi_closure_SYSV, ffi_closure_raw_SYSV):\n+\tReceive closure pointer through parameter, read args using\n+\t__builtin_dwarf_cfa.\n+\t(FFI_INIT_TRAMPOLINE): Send closure reference through eax.\n+\n 2003-03-03  Andreas Tobler <a.tobler@schweiz.ch>\n \n         * src/powerpc/darwin_closure.S: Recode to fit dynamic libraries."}, {"sha": "fe91ecd5e2e701141ff4db7ae784eccc12fcf9b1", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd41c847e78ec5063fbc47a8ddfebc9e53451fff/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd41c847e78ec5063fbc47a8ddfebc9e53451fff/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=cd41c847e78ec5063fbc47a8ddfebc9e53451fff", "patch": "@@ -170,6 +170,13 @@ extern \"C\" {\n #endif\n #endif\n \n+#ifdef X86_64\n+#if defined (__i386__)\n+#undef X86_64\n+#define X86\n+#endif\n+#endif\n+\n #ifndef LIBFFI_ASM\n \n /* ---- Generic type definitions ----------------------------------------- */"}, {"sha": "bd0874f771aa52cab496f55058ddb9d5efd04c6a", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd41c847e78ec5063fbc47a8ddfebc9e53451fff/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd41c847e78ec5063fbc47a8ddfebc9e53451fff/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=cd41c847e78ec5063fbc47a8ddfebc9e53451fff", "patch": "@@ -214,35 +214,29 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n \n static void ffi_prep_incoming_args_SYSV (char *stack, void **ret,\n \t\t\t\t\t void** args, ffi_cif* cif);\n-static void ffi_closure_SYSV ();\n-static void ffi_closure_raw_SYSV ();\n+static void ffi_closure_SYSV (ffi_closure *)\n+     __attribute__ ((regparm(1)));\n+static void ffi_closure_raw_SYSV (ffi_raw_closure *)\n+     __attribute__ ((regparm(1)));\n \n-/* This function is jumped to by the trampoline, on entry, %ecx (a\n- * caller-save register) holds the address of the closure.  \n- * Clearly, this requires __GNUC__, so perhaps we should translate this\n- * into an assembly file if this is to be distributed with ffi.\n- */\n+/* This function is jumped to by the trampoline */\n \n static void\n-ffi_closure_SYSV ()\n+ffi_closure_SYSV (closure)\n+     ffi_closure *closure;\n {\n   // this is our return value storage\n   long double    res;\n \n   // our various things...\n-  void          *args;\n   ffi_cif       *cif;\n   void         **arg_area;\n-  ffi_closure   *closure;\n   unsigned short rtype;\n   void          *resp = (void*)&res;\n+  void *args = __builtin_dwarf_cfa ();\n \n-  /* grab the trampoline context pointer */\n-  asm (\"movl %%ecx,%0\" : \"=r\" (closure));\n-  \n   cif         = closure->cif;\n   arg_area    = (void**) alloca (cif->nargs * sizeof (void*));  \n-  asm (\"leal 8(%%ebp),%0\" : \"=q\" (args));  \n \n   /* this call will initialize ARG_AREA, such that each\n    * element in that array points to the corresponding \n@@ -330,11 +324,11 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n ({ unsigned char *__tramp = (unsigned char*)(TRAMP); \\\n    unsigned int  __fun = (unsigned int)(FUN); \\\n    unsigned int  __ctx = (unsigned int)(CTX); \\\n-   unsigned int  __dis = __fun - ((unsigned int) __tramp + 10); \\\n-   *(unsigned char*) &__tramp[0] = 0xb9; \\\n-   *(unsigned int*)  &__tramp[1] = __ctx; \\\n-   *(unsigned char*) &__tramp[5] = 0xe9; \\\n-   *(unsigned int*)  &__tramp[6] = __dis; \\\n+   unsigned int  __dis = __fun - ((unsigned int) __tramp + FFI_TRAMPOLINE_SIZE); \\\n+   *(unsigned char*) &__tramp[0] = 0xb8; \\\n+   *(unsigned int*)  &__tramp[1] = __ctx; /* movl __ctx, %eax */ \\\n+   *(unsigned char *)  &__tramp[5] = 0xe9; \\\n+   *(unsigned int*)  &__tramp[6] = __dis; /* jmp __fun  */ \\\n  })\n \n \n@@ -364,30 +358,23 @@ ffi_prep_closure (ffi_closure* closure,\n #if !FFI_NO_RAW_API\n \n static void\n-ffi_closure_raw_SYSV ()\n+ffi_closure_raw_SYSV (closure)\n+     ffi_raw_closure *closure;\n {\n   // this is our return value storage\n   long double    res;\n \n   // our various things...\n-  void            *args;\n   ffi_raw         *raw_args;\n   ffi_cif         *cif;\n-  ffi_raw_closure *closure;\n   unsigned short   rtype;\n   void            *resp = (void*)&res;\n \n-  /* grab the trampoline context pointer */\n-  asm (\"movl %%ecx,%0\" : \"=r\" (closure));\n-\n-  /* take the argument pointer */\n-  asm (\"leal 8(%%ebp),%0\" : \"=q\" (args));  \n-\n   /* get the cif */\n   cif = closure->cif;\n \n   /* the SYSV/X86 abi matches the RAW API exactly, well.. almost */\n-  raw_args = (ffi_raw*) args;\n+  raw_args = (ffi_raw*) __builtin_dwarf_cfa ();\n \n   (closure->fun) (cif, resp, raw_args, closure->user_data);\n "}]}