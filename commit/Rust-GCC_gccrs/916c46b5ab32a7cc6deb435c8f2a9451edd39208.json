{"sha": "916c46b5ab32a7cc6deb435c8f2a9451edd39208", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE2YzQ2YjVhYjMyYTdjYzZkZWI0MzVjOGYyYTk0NTFlZGQzOTIwOA==", "commit": {"author": {"name": "Adam Megacz", "email": "adam@xwt.org", "date": "2002-03-12T19:06:36Z"}, "committer": {"name": "Adam Megacz", "email": "megacz@gcc.gnu.org", "date": "2002-03-12T19:06:36Z"}, "message": "dyn_load.c: Renamed GC_win32s to GC_no_win32_dlls.\n\n2002-03-12  Adam Megacz  <adam@xwt.org>\n\n        * dyn_load.c: Renamed GC_win32s to GC_no_win32_dlls.\n        * misc.c: Renamed GC_is_win32s() to GC_no_win32_dlls\n        * os_dep.c: Renamed GC_win32s to GC_no_win32_dlls and\n        statically initialized it to TRUE if compiling with GCC.\n        * win32_threads.c (thread_start): We no longer use SEH if\n        compiling with GCC.\n        * mark.c (GC_mark_some): We no longer use SEH if\n        compiling with GCC.\n\nFrom-SVN: r50671", "tree": {"sha": "ba69ee2014e9ab9f0759258ec9d82f1ac809d901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba69ee2014e9ab9f0759258ec9d82f1ac809d901"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/916c46b5ab32a7cc6deb435c8f2a9451edd39208", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916c46b5ab32a7cc6deb435c8f2a9451edd39208", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916c46b5ab32a7cc6deb435c8f2a9451edd39208", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916c46b5ab32a7cc6deb435c8f2a9451edd39208/comments", "author": null, "committer": null, "parents": [{"sha": "089c8f976485ea1a57ca4d6590cea48782c51140", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/089c8f976485ea1a57ca4d6590cea48782c51140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/089c8f976485ea1a57ca4d6590cea48782c51140"}], "stats": {"total": 61, "additions": 38, "deletions": 23}, "files": [{"sha": "c132c031cf32f534021cf84630a2013760f0215d", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=916c46b5ab32a7cc6deb435c8f2a9451edd39208", "patch": "@@ -1,3 +1,14 @@\n+2002-03-12  Adam Megacz  <adam@xwt.org>\n+\n+        * dyn_load.c: Renamed GC_win32s to GC_no_win32_dlls.\n+        * misc.c: Renamed GC_is_win32s() to GC_no_win32_dlls\n+        * os_dep.c: Renamed GC_win32s to GC_no_win32_dlls and\n+        statically initialized it to TRUE if compiling with GCC.\n+        * win32_threads.c (thread_start): We no longer use SEH if\n+        compiling with GCC.\n+        * mark.c (GC_mark_some): We no longer use SEH if\n+        compiling with GCC.\n+\t\n 2002-03-09  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* include/gc_priv.h: Define ALIGN_DOUBLE on 32 bit targets if GCJ "}, {"sha": "a2676371037febbb15d6b98c1dff753440e1c72c", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=916c46b5ab32a7cc6deb435c8f2a9451edd39208", "patch": "@@ -775,7 +775,7 @@ void GC_register_dynamic_libraries()\n # endif\n \n # ifndef MSWINCE\n-  extern GC_bool GC_win32s;\n+  extern GC_bool GC_no_win32_dlls;\n # endif\n   \n   void GC_register_dynamic_libraries()\n@@ -788,7 +788,7 @@ void GC_register_dynamic_libraries()\n     char * limit, * new_limit;\n \n #   ifdef MSWIN32\n-      if (GC_win32s) return;\n+      if (GC_no_win32_dlls) return;\n #   endif\n     base = limit = p = GC_sysinfo.lpMinimumApplicationAddress;\n #   if defined(MSWINCE) && !defined(_WIN32_WCE_EMULATION)"}, {"sha": "170c279b718e101ad5db20fa1877d8babcfcb020", "filename": "boehm-gc/mark.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2Fmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2Fmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark.c?ref=916c46b5ab32a7cc6deb435c8f2a9451edd39208", "patch": "@@ -264,7 +264,7 @@ static void alloc_mark_stack();\n GC_bool GC_mark_some(cold_gc_frame)\n ptr_t cold_gc_frame;\n {\n-#ifdef MSWIN32\n+#if defined(MSWIN32) && !defined(__GNUC__)\n   /* Windows 98 appears to asynchronously create and remove writable\t*/\n   /* memory mappings, for reasons we haven't yet understood.  Since\t*/\n   /* we look for writable regions to determine the root set, we may\t*/\n@@ -274,7 +274,7 @@ ptr_t cold_gc_frame;\n   /* Note that this code should never generate an incremental GC write\t*/\n   /* fault.\t\t\t\t\t\t\t\t*/\n   __try {\n-#endif\n+#endif /* defined(MSWIN32) && !defined(__GNUC__) */\n     switch(GC_mark_state) {\n     \tcase MS_NONE:\n     \t    return(FALSE);\n@@ -395,7 +395,7 @@ ptr_t cold_gc_frame;\n     \t    ABORT(\"GC_mark_some: bad state\");\n     \t    return(FALSE);\n     }\n-#ifdef MSWIN32\n+#if defined(MSWIN32) && !defined(__GNUC__)\n   } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?\n \t    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {\n #   ifdef CONDPRINT\n@@ -410,7 +410,7 @@ ptr_t cold_gc_frame;\n     scan_ptr = 0;\n     return FALSE;\n   }\n-#endif /* MSWIN32 */\n+#endif /* defined(MSWIN32) && !defined(__GNUC__) */\n }\n \n "}, {"sha": "a89f04407b4c76b67942297bd604bf369f08e389", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=916c46b5ab32a7cc6deb435c8f2a9451edd39208", "patch": "@@ -483,9 +483,9 @@ int sig;\n #endif\n \n #ifdef MSWIN32\n-  extern GC_bool GC_is_win32s();\n+extern GC_bool GC_no_win32_dlls;\n #else\n-# define GC_is_win32s() FALSE\n+# define GC_no_win32_dlls FALSE\n #endif\n \n void GC_init_inner()\n@@ -637,7 +637,7 @@ void GC_init_inner()\n       GC_pcr_install();\n #   endif\n #   if !defined(SMALL_CONFIG)\n-      if (!GC_is_win32s() && 0 != GETENV(\"GC_ENABLE_INCREMENTAL\")) {\n+      if (!GC_no_win32_dlls && 0 != GETENV(\"GC_ENABLE_INCREMENTAL\")) {\n \tGC_ASSERT(!GC_incremental);\n         GC_setpagesize();\n #       ifndef GC_SOLARIS_THREADS\n@@ -681,7 +681,7 @@ void GC_enable_incremental GC_PROTO(())\n     LOCK();\n     if (GC_incremental) goto out;\n     GC_setpagesize();\n-    if (GC_is_win32s()) goto out;\n+    if (GC_no_win32_dlls) goto out;\n #   ifndef GC_SOLARIS_THREADS\n         GC_dirty_init();\n #   endif"}, {"sha": "b8f4cf84c3c3d6df1eb0a32c6db1db74b389f05d", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=916c46b5ab32a7cc6deb435c8f2a9451edd39208", "patch": "@@ -928,19 +928,17 @@ void GC_register_data_segments()\n   /* all real work is done by GC_register_dynamic_libraries.  Under\t*/\n   /* win32s, we cannot find the data segments associated with dll's.\t*/\n   /* We rgister the main data segment here.\t\t\t\t*/\n-  GC_bool GC_win32s = FALSE;\t/* We're running under win32s.\t*/\n-  \n-  GC_bool GC_is_win32s()\n-  {\n-      DWORD v = GetVersion();\n-      \n-      /* Check that this is not NT, and Windows major version <= 3\t*/\n-      return ((v & 0x80000000) && (v & 0xff) <= 3);\n-  }\n+#  ifdef __GCC__\n+  GC_bool GC_no_win32_dlls = TRUE;\t /* GCC can't do SEH, so we can't use VirtualQuery */\n+#  else\n+  GC_bool GC_no_win32_dlls = FALSE;\t \n+#  endif\n   \n   void GC_init_win32()\n   {\n-      GC_win32s = GC_is_win32s();\n+    /* if we're running under win32s, assume that no DLLs will be loaded */\n+    DWORD v = GetVersion();\n+    GC_no_win32_dlls |= ((v & 0x80000000) && (v & 0xff) <= 3);\n   }\n \n   /* Return the smallest address a such that VirtualQuery\t\t*/\n@@ -1008,7 +1006,7 @@ void GC_register_data_segments()\n       char * base;\n       char * limit, * new_limit;\n     \n-      if (!GC_win32s) return;\n+      if (!GC_no_win32_dlls) return;\n       p = base = limit = GC_least_described_address(static_root);\n       while (p < GC_sysinfo.lpMaximumApplicationAddress) {\n         result = VirtualQuery(p, &buf, sizeof(buf));\n@@ -1307,7 +1305,7 @@ SYSTEM_INFO GC_sysinfo;\n # ifdef USE_GLOBAL_ALLOC\n #   define GLOBAL_ALLOC_TEST 1\n # else\n-#   define GLOBAL_ALLOC_TEST GC_win32s\n+#   define GLOBAL_ALLOC_TEST GC_no_win32_dlls\n # endif\n \n word GC_n_heap_bases = 0;\n@@ -1338,7 +1336,7 @@ word bytes;\n \n void GC_win32_free_heap ()\n {\n-    if (GC_win32s) {\n+    if (GC_no_win32_dlls) {\n  \twhile (GC_n_heap_bases > 0) {\n  \t    GlobalFree (GC_heap_bases[--GC_n_heap_bases]);\n  \t    GC_heap_bases[GC_n_heap_bases] = 0;"}, {"sha": "38de099fa87cc677351945ec35066d9442a57e36", "filename": "boehm-gc/win32_threads.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2Fwin32_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916c46b5ab32a7cc6deb435c8f2a9451edd39208/boehm-gc%2Fwin32_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fwin32_threads.c?ref=916c46b5ab32a7cc6deb435c8f2a9451edd39208", "patch": "@@ -447,16 +447,22 @@ static DWORD WINAPI thread_start(LPVOID arg)\n     /* Clear the thread entry even if we exit with an exception.\t*/\n     /* This is probably pointless, since an uncaught exception is\t*/\n     /* supposed to result in the process being killed.\t\t\t*/\n+#ifndef __GNUC__\n     __try {\n+#endif /* __GNUC__ */\n \tret = args.start (args.param);\n+#ifndef __GNUC__\n     } __finally {\n+#endif /* __GNUC__ */\n \tLOCK();\n \targs.entry->stack = 0;\n \targs.entry->in_use = FALSE;\n \t      /* cast away volatile qualifier */\n \tBZERO((void *) &args.entry->context, sizeof(CONTEXT));\n \tUNLOCK();\n+#ifndef __GNUC__\n     }\n+#endif /* __GNUC__ */\n \n     return ret;\n }"}]}