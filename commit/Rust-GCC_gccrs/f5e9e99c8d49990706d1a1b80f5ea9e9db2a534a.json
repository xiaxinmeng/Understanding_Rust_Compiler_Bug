{"sha": "f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVlOWU5OWM4ZDQ5OTkwNzA2ZDFhMWI4MGY1ZWE5ZTlkYjJhNTM0YQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2005-02-24T13:01:44Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2005-02-24T13:01:44Z"}, "message": "Revert yesterday's patch:\n\n2005-02-23  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n\n                * gfortran.h (gfc_component, gfc_actual_arglist, ...\n                ... argument.  Copy string instead of pointing to it.\n\nFrom-SVN: r95496", "tree": {"sha": "d95c3b91fb77172e12ce112a85f983bc25d726e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d95c3b91fb77172e12ce112a85f983bc25d726e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c74636694956af8e2fe74bbeddf72891b9b5cfb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c74636694956af8e2fe74bbeddf72891b9b5cfb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c74636694956af8e2fe74bbeddf72891b9b5cfb1"}], "stats": {"total": 188, "additions": 83, "deletions": 105}, "files": [{"sha": "349a535678d2757a9314ab0429aac92c4002c074", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -1,3 +1,11 @@\n+2005-02-24  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tRevert yesterday's patch:\n+\t2005-02-23  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t\t* gfortran.h (gfc_component, gfc_actual_arglist, ...\n+\t\t... argument.  Copy string instead of pointing to it.\n+\n 2005-02-23  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* gfortran.h (gfc_get_namespace): Add second argument to prototype.\n@@ -38,6 +46,7 @@\n \t* trans-expr.c (gfc_conv_unary_op, gfc_conv_power_op,\n \tgfc_conv_concat_op, gfc_conv_expr_op): Likewise.\n \n+\t[ Reverted ]\n \t* gfortran.h (gfc_component, gfc_actual_arglist, gfc_user_op): Make\n \t'name' a 'const char *'.\n \t(gfc_symbol): Likewise, also for 'module'."}, {"sha": "7986c968f9b9254cd4b1643070c2d5193c8f5047", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -1214,7 +1214,7 @@ gfc_check_minloc_maxloc (gfc_actual_arglist * ap)\n   m = ap->next->next->expr;\n \n   if (m == NULL && d != NULL && d->ts.type == BT_LOGICAL\n-      && ap->next->name == NULL)\n+      && ap->next->name[0] == '\\0')\n     {\n       m = d;\n       d = NULL;\n@@ -1259,7 +1259,7 @@ check_reduction (gfc_actual_arglist * ap)\n   m = ap->next->next->expr;\n \n   if (m == NULL && d != NULL && d->ts.type == BT_LOGICAL\n-      && ap->next->name == NULL)\n+      && ap->next->name[0] == '\\0')\n     {\n       m = d;\n       d = NULL;"}, {"sha": "e60b4c082de2b6137f8d20ed621cd9da49827ff1", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -106,7 +106,7 @@ gfc_show_actual_arglist (gfc_actual_arglist * a)\n   for (; a; a = a->next)\n     {\n       gfc_status_char ('(');\n-      if (a->name != NULL)\n+      if (a->name[0] != '\\0')\n \tgfc_status (\"%s = \", a->name);\n       if (a->expr != NULL)\n \tgfc_show_expr (a->expr);"}, {"sha": "eb24cba4a8b7669e603b8b09d55f8170fed5085e", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -540,7 +540,7 @@ gfc_array_spec;\n /* Components of derived types.  */\n typedef struct gfc_component\n {\n-  const char *name;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_typespec ts;\n \n   int pointer, dimension;\n@@ -571,7 +571,7 @@ gfc_formal_arglist;\n /* The gfc_actual_arglist structure is for actual arguments.  */\n typedef struct gfc_actual_arglist\n {\n-  const char *name;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n   /* Alternate return label when the expr member is null.  */\n   struct gfc_st_label *label;\n \n@@ -636,7 +636,7 @@ gfc_interface;\n /* User operator nodes.  These are like stripped down symbols.  */\n typedef struct\n {\n-  const char *name;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n \n   gfc_interface *operator;\n   struct gfc_namespace *ns;\n@@ -652,8 +652,8 @@ gfc_user_op;\n \n typedef struct gfc_symbol\n {\n-  const char *name;\t/* Primary name, before renaming */\n-  const char *module;\t/* Module this symbol came from */\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\t/* Primary name, before renaming */\n+  char module[GFC_MAX_SYMBOL_LEN + 1];\t/* Module this symbol came from */\n   locus declared_at;\n \n   gfc_typespec ts;\n@@ -744,7 +744,7 @@ gfc_entry_list;\n typedef struct gfc_symtree\n {\n   BBT_HEADER (gfc_symtree);\n-  const char *name;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n   int ambiguous;\n   union\n   {\n@@ -1003,7 +1003,7 @@ gfc_resolve_f;\n \n typedef struct gfc_intrinsic_sym\n {\n-  const char *name, *lib_name;\n+  char name[GFC_MAX_SYMBOL_LEN + 1], lib_name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_intrinsic_arg *formal;\n   gfc_typespec ts;\n   int elemental, pure, generic, specific, actual_ok, standard;\n@@ -1654,8 +1654,8 @@ void gfc_save_all (gfc_namespace *);\n \n void gfc_symbol_state (void);\n \n-gfc_gsymbol *gfc_get_gsymbol (const char *);\n-gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);\n+gfc_gsymbol *gfc_get_gsymbol (char *);\n+gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, char *);\n \n /* intrinsic.c */\n extern int gfc_init_expr;\n@@ -1664,7 +1664,7 @@ extern int gfc_init_expr;\n    by placing it into a special module that is otherwise impossible to\n    read or write.  */\n \n-#define gfc_intrinsic_symbol(SYM) SYM->module = gfc_get_string (\"(intrinsic)\")\n+#define gfc_intrinsic_symbol(SYM) strcpy (SYM->module, \"(intrinsic)\")\n \n void gfc_intrinsic_init_1 (void);\n void gfc_intrinsic_done_1 (void);"}, {"sha": "9f163d0efd2f7d1b0ff2a3775ef63a8c0b2fa1f7", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -340,9 +340,8 @@ gfc_compare_types (gfc_typespec * ts1, gfc_typespec * ts2)\n      true names and module names are the same and the module name is\n      nonnull, then they are equal.  */\n   if (strcmp (ts1->derived->name, ts2->derived->name) == 0\n-      && ((ts1->derived->module == NULL && ts2->derived->module == NULL)\n-\t  || (ts1->derived != NULL && ts2->derived != NULL\n-\t      && strcmp (ts1->derived->module, ts2->derived->module) == 0)))\n+      && ts1->derived->module[0] != '\\0'\n+      && strcmp (ts1->derived->module, ts2->derived->module) == 0)\n     return 1;\n \n   /* Compare type via the rules of the standard.  Both types must have\n@@ -1166,7 +1165,7 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n \n   for (a = actual; a; a = a->next, f = f->next)\n     {\n-      if (a->name != NULL)\n+      if (a->name[0] != '\\0')\n \t{\n \t  i = 0;\n \t  for (f = formal; f; f = f->next, i++)"}, {"sha": "f9642c78ac8ab5e80028fa5961bad974e1673ee7", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -37,8 +37,7 @@ int gfc_init_expr = 0;\n /* Pointers to an intrinsic function and its argument names that are being\n    checked.  */\n \n-const char *gfc_current_intrinsic;\n-const char *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n+char *gfc_current_intrinsic, *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n locus *gfc_current_intrinsic_where;\n \n static gfc_intrinsic_sym *functions, *subroutines, *conversion, *next_sym;\n@@ -108,15 +107,15 @@ gfc_get_intrinsic_sub_symbol (const char * name)\n /* Return a pointer to the name of a conversion function given two\n    typespecs.  */\n \n-static const char *\n+static char *\n conv_name (gfc_typespec * from, gfc_typespec * to)\n {\n   static char name[30];\n \n   sprintf (name, \"__convert_%c%d_%c%d\", gfc_type_letter (from->type),\n \t   from->kind, gfc_type_letter (to->type), to->kind);\n \n-  return gfc_get_string (name);\n+  return name;\n }\n \n \n@@ -128,7 +127,7 @@ static gfc_intrinsic_sym *\n find_conv (gfc_typespec * from, gfc_typespec * to)\n {\n   gfc_intrinsic_sym *sym;\n-  const char *target;\n+  char *target;\n   int i;\n \n   target = conv_name (from, to);\n@@ -214,7 +213,7 @@ add_sym (const char *name, int elemental, int actual_ok ATTRIBUTE_UNUSED,\n \t bt type, int kind, int standard, gfc_check_f check,\n \t gfc_simplify_f simplify, gfc_resolve_f resolve, ...)\n {\n-  char buf[GFC_MAX_SYMBOL_LEN + 11]; /* 10 for '_gfortran_', 1 for '\\0'  */\n+\n   int optional, first_flag;\n   va_list argp;\n \n@@ -234,11 +233,10 @@ add_sym (const char *name, int elemental, int actual_ok ATTRIBUTE_UNUSED,\n       break;\n \n     case SZ_NOTHING:\n-      next_sym->name = gfc_get_string (name);\n+      strcpy (next_sym->name, name);\n \n-      strcpy (buf, \"_gfortran_\");\n-      strcat (buf, name);\n-      next_sym->lib_name = gfc_get_string (buf);\n+      strcpy (next_sym->lib_name, \"_gfortran_\");\n+      strcat (next_sym->lib_name, name);\n \n       next_sym->elemental = elemental;\n       next_sym->ts.type = type;\n@@ -787,11 +785,11 @@ make_generic (const char *name, gfc_generic_isym_id generic_id, int standard)\n   g->generic = 1;\n   g->specific = 1;\n   g->generic_id = generic_id;\n-  if ((g + 1)->name != NULL)\n+  if ((g + 1)->name[0] != '\\0')\n     g->specific_head = g + 1;\n   g++;\n \n-  while (g->name != NULL)\n+  while (g->name[0] != '\\0')\n     {\n       g->next = g + 1;\n       g->specific = 1;\n@@ -830,7 +828,7 @@ make_alias (const char *name, int standard)\n \n     case SZ_NOTHING:\n       next_sym[0] = next_sym[-1];\n-      next_sym->name = gfc_get_string (name);\n+      strcpy (next_sym->name, name);\n       next_sym++;\n       break;\n \n@@ -2154,8 +2152,8 @@ add_conv (bt from_type, int from_kind, bt to_type, int to_kind,\n \n   sym = conversion + nconv;\n \n-  sym->name =  conv_name (&from, &to);\n-  sym->lib_name = sym->name;\n+  strcpy (sym->name, conv_name (&from, &to));\n+  strcpy (sym->lib_name, sym->name);\n   sym->simplify.cc = simplify;\n   sym->elemental = 1;\n   sym->ts = to;\n@@ -2361,7 +2359,7 @@ sort_actual (const char *name, gfc_actual_arglist ** ap,\n       if (a == NULL)\n \tgoto optional;\n \n-      if (a->name != NULL)\n+      if (a->name[0] != '\\0')\n \tgoto keywords;\n \n       f->actual = a;"}, {"sha": "0c4472afd73a6d6321714cf8dc5b5a5e1036cb63", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -368,6 +368,6 @@ void gfc_resolve_unlink_sub (gfc_code *);\n \n #define MAX_INTRINSIC_ARGS 5\n \n-extern const char *gfc_current_intrinsic;\n-extern const char *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n+extern char *gfc_current_intrinsic,\n+  *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n extern locus *gfc_current_intrinsic_where;"}, {"sha": "8df1b9adf63af6c72efb798343414cb5c8f1777a", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 23, "deletions": 50, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -655,8 +655,7 @@ compare_true_names (void * _t1, void * _t2)\n   t1 = (true_name *) _t1;\n   t2 = (true_name *) _t2;\n \n-  c = ((t1->sym->module > t2->sym->module)\n-       - (t1->sym->module < t2->sym->module));\n+  c = strcmp (t1->sym->module, t2->sym->module);\n   if (c != 0)\n     return c;\n \n@@ -674,8 +673,8 @@ find_true_name (const char *name, const char *module)\n   gfc_symbol sym;\n   int c;\n \n-  sym.name = gfc_get_string (name);\n-  sym.module = gfc_get_string (module);\n+  strcpy (sym.name, name);\n+  strcpy (sym.module, module);\n   t.sym = &sym;\n \n   p = true_name_root;\n@@ -1342,33 +1341,8 @@ mio_allocated_string (const char *s)\n }\n \n \n-/* Read or write a string that is in static memory.  */\n-\n-static void\n-mio_pool_string (const char **stringp)\n-{\n-  /* TODO: one could write the string only once, and refer to it via a\n-     fixup pointer.  */\n-\n-  /* As a special case we have to deal with a NULL string.  This\n-     happens for the 'module' member of 'gfc_symbol's that are not in a\n-     module.  We read / write these as the empty string.  */\n-  if (iomode == IO_OUTPUT)\n-    {\n-      const char *p = *stringp == NULL ? \"\" : *stringp;\n-      write_atom (ATOM_STRING, p);\n-    }\n-  else\n-    {\n-      require_atom (ATOM_STRING);\n-      *stringp = atom_string[0] == '\\0' ? NULL : gfc_get_string (atom_string);\n-      gfc_free (atom_string);\n-    }\n-}\n-\n-\n-/* Read or write a string that is inside of some already-allocated\n-   structure.  */\n+/* Read or write a string that is in static memory or inside of some\n+   already-allocated structure.  */\n \n static void\n mio_internal_string (char *string)\n@@ -1828,7 +1802,7 @@ mio_component_ref (gfc_component ** cp, gfc_symbol * sym)\n     p->type = P_COMPONENT;\n \n   if (iomode == IO_OUTPUT)\n-    mio_pool_string (&(*cp)->name);\n+    mio_internal_string ((*cp)->name);\n   else\n     {\n       mio_internal_string (name);\n@@ -1877,7 +1851,7 @@ mio_component (gfc_component * c)\n   if (p->type == P_UNKNOWN)\n     p->type = P_COMPONENT;\n \n-  mio_pool_string (&c->name);\n+  mio_internal_string (c->name);\n   mio_typespec (&c->ts);\n   mio_array_spec (&c->as);\n \n@@ -1933,7 +1907,7 @@ mio_actual_arg (gfc_actual_arglist * a)\n {\n \n   mio_lparen ();\n-  mio_pool_string (&a->name);\n+  mio_internal_string (a->name);\n   mio_expr (&a->expr);\n   mio_rparen ();\n }\n@@ -2625,14 +2599,14 @@ mio_interface (gfc_interface ** ip)\n /* Save/restore a named operator interface.  */\n \n static void\n-mio_symbol_interface (const char **name, const char **module,\n+mio_symbol_interface (char *name, char *module,\n \t\t      gfc_interface ** ip)\n {\n \n   mio_lparen ();\n \n-  mio_pool_string (name);\n-  mio_pool_string (module);\n+  mio_internal_string (name);\n+  mio_internal_string (module);\n \n   mio_interface_rest (ip);\n }\n@@ -2910,7 +2884,7 @@ load_needed (pointer_info * p)\n \t}\n \n       sym = gfc_new_symbol (p->u.rsym.true_name, ns);\n-      sym->module = gfc_get_string (p->u.rsym.module);\n+      strcpy (sym->module, p->u.rsym.module);\n \n       associate_integer_pointer (p, sym);\n     }\n@@ -3063,7 +3037,7 @@ read_module (void)\n \t      sym = info->u.rsym.sym =\n \t\tgfc_new_symbol (info->u.rsym.true_name, gfc_current_ns);\n \n-\t      sym->module = gfc_get_string (info->u.rsym.module);\n+\t      strcpy (sym->module, info->u.rsym.module);\n \t    }\n \n \t  st->n.sym = sym;\n@@ -3196,7 +3170,7 @@ write_common (gfc_symtree *st)\n   write_common(st->right);\n \n   mio_lparen();\n-  mio_pool_string(&st->name);\n+  mio_internal_string(st->name);\n \n   p = st->n.common;\n   mio_symbol_ref(&p->head);\n@@ -3216,9 +3190,9 @@ write_symbol (int n, gfc_symbol * sym)\n     gfc_internal_error (\"write_symbol(): bad module symbol '%s'\", sym->name);\n \n   mio_integer (&n);\n-  mio_pool_string (&sym->name);\n+  mio_internal_string (sym->name);\n \n-  mio_pool_string (&sym->module);\n+  mio_internal_string (sym->module);\n   mio_pointer_ref (&sym->ns);\n \n   mio_symbol (sym);\n@@ -3243,8 +3217,8 @@ write_symbol0 (gfc_symtree * st)\n   write_symbol0 (st->right);\n \n   sym = st->n.sym;\n-  if (sym->module == NULL)\n-    sym->module = gfc_get_string (module_name);\n+  if (sym->module[0] == '\\0')\n+    strcpy (sym->module, module_name);\n \n   if (sym->attr.flavor == FL_PROCEDURE && sym->attr.generic\n       && !sym->attr.subroutine && !sym->attr.function)\n@@ -3291,8 +3265,8 @@ write_symbol1 (pointer_info * p)\n \n   /* FIXME: This shouldn't be necessary, but it works around\n      deficiencies in the module loader or/and symbol handling.  */\n-  if (p->u.wsym.sym->module == NULL && p->u.wsym.sym->attr.dummy)\n-    p->u.wsym.sym->module = gfc_get_string (module_name);\n+  if (p->u.wsym.sym->module[0] == '\\0' && p->u.wsym.sym->attr.dummy)\n+    strcpy (p->u.wsym.sym->module, module_name);\n \n   p->u.wsym.state = WRITTEN;\n   write_symbol (p->integer, p->u.wsym.sym);\n@@ -3307,13 +3281,12 @@ static void\n write_operator (gfc_user_op * uop)\n {\n   static char nullstring[] = \"\";\n-  const char *p = nullstring;\n \n   if (uop->operator == NULL\n       || !gfc_check_access (uop->access, uop->ns->default_access))\n     return;\n \n-  mio_symbol_interface (&uop->name, &p, &uop->operator);\n+  mio_symbol_interface (uop->name, nullstring, &uop->operator);\n }\n \n \n@@ -3327,7 +3300,7 @@ write_generic (gfc_symbol * sym)\n       || !gfc_check_access (sym->attr.access, sym->ns->default_access))\n     return;\n \n-  mio_symbol_interface (&sym->name, &sym->module, &sym->generic);\n+  mio_symbol_interface (sym->name, sym->module, &sym->generic);\n }\n \n \n@@ -3350,7 +3323,7 @@ write_symtree (gfc_symtree * st)\n   if (p == NULL)\n     gfc_internal_error (\"write_symtree(): Symbol not written\");\n \n-  mio_pool_string (&st->name);\n+  mio_internal_string (st->name);\n   mio_integer (&st->ambiguous);\n   mio_integer (&p->integer);\n }"}, {"sha": "f122779b1364f8af3e0fbe7f7273db50f7270580", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -1273,7 +1273,7 @@ match_keyword_arg (gfc_actual_arglist * actual, gfc_actual_arglist * base)\n   if (name[0] != '\\0')\n     {\n       for (a = base; a; a = a->next)\n-\tif (a->name != NULL && strcmp (a->name, name) == 0)\n+\tif (strcmp (a->name, name) == 0)\n \t  {\n \t    gfc_error\n \t      (\"Keyword '%s' at %C has already appeared in the current \"\n@@ -1282,7 +1282,7 @@ match_keyword_arg (gfc_actual_arglist * actual, gfc_actual_arglist * base)\n \t  }\n     }\n \n-  actual->name = gfc_get_string (name);\n+  strcpy (actual->name, name);\n   return MATCH_YES;\n \n cleanup:"}, {"sha": "77d3f1a3a2d79ea832ffd6c475e95ab63f2c841f", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -1157,7 +1157,7 @@ gfc_add_component (gfc_symbol * sym, const char *name, gfc_component ** componen\n   else\n     tail->next = p;\n \n-  p->name = gfc_get_string (name);\n+  strcpy (p->name, name);\n   p->loc = gfc_current_locus;\n \n   *component = p;\n@@ -1613,7 +1613,7 @@ gfc_new_symtree (gfc_symtree ** root, const char *name)\n   gfc_symtree *st;\n \n   st = gfc_getmem (sizeof (gfc_symtree));\n-  st->name = gfc_get_string (name);\n+  strcpy (st->name, name);\n \n   gfc_insert_bbt (root, st, compare_symtree);\n   return st;\n@@ -1629,7 +1629,7 @@ delete_symtree (gfc_symtree ** root, const char *name)\n \n   st0 = gfc_find_symtree (*root, name);\n \n-  st.name = gfc_get_string (name);\n+  strcpy (st.name, name);\n   gfc_delete_bbt (root, &st, compare_symtree);\n \n   gfc_free (st0);\n@@ -1674,7 +1674,7 @@ gfc_get_uop (const char *name)\n   st = gfc_new_symtree (&gfc_current_ns->uop_root, name);\n \n   uop = st->n.uop = gfc_getmem (sizeof (gfc_user_op));\n-  uop->name = gfc_get_string (name);\n+  strcpy (uop->name, name);\n   uop->access = ACCESS_UNKNOWN;\n   uop->ns = gfc_current_ns;\n \n@@ -1743,7 +1743,7 @@ gfc_new_symbol (const char *name, gfc_namespace * ns)\n   if (strlen (name) > GFC_MAX_SYMBOL_LEN)\n     gfc_internal_error (\"new_symbol(): Symbol name too long\");\n \n-  p->name = gfc_get_string (name);\n+  strcpy (p->name, name);\n   return p;\n }\n \n@@ -1754,7 +1754,7 @@ static void\n ambiguous_symbol (const char *name, gfc_symtree * st)\n {\n \n-  if (st->n.sym->module)\n+  if (st->n.sym->module[0])\n     gfc_error (\"Name '%s' at %C is an ambiguous reference to '%s' \"\n \t       \"from module '%s'\", name, st->n.sym->name, st->n.sym->module);\n   else\n@@ -2362,7 +2362,7 @@ gfc_symbol_state(void) {\n /* Search a tree for the global symbol.  */\n \n gfc_gsymbol *\n-gfc_find_gsymbol (gfc_gsymbol *symbol, const char *name)\n+gfc_find_gsymbol (gfc_gsymbol *symbol, char *name)\n {\n   gfc_gsymbol *s;\n \n@@ -2399,7 +2399,7 @@ gsym_compare (void * _s1, void * _s2)\n /* Get a global symbol, creating it if it doesn't exist.  */\n \n gfc_gsymbol *\n-gfc_get_gsymbol (const char *name)\n+gfc_get_gsymbol (char *name)\n {\n   gfc_gsymbol *s;\n "}, {"sha": "985abd478360986c427510b82d6cc34d9cc89a32", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -3071,7 +3071,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n   gcc_assert (!sym->attr.use_assoc);\n   gcc_assert (!TREE_STATIC (decl));\n-  gcc_assert (!sym->module);\n+  gcc_assert (!sym->module[0]);\n \n   if (sym->ts.type == BT_CHARACTER\n       && !INTEGER_CST_P (sym->ts.cl->backend_decl))"}, {"sha": "6567695ad29b7d47457a46de2bcd3d5bd387349a", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -272,7 +272,7 @@ gfc_sym_mangled_identifier (gfc_symbol * sym)\n {\n   char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];\n \n-  if (sym->module == NULL)\n+  if (sym->module[0] == 0)\n     return gfc_sym_identifier (sym);\n   else\n     {\n@@ -290,8 +290,8 @@ gfc_sym_mangled_function_id (gfc_symbol * sym)\n   int has_underscore;\n   char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];\n \n-  if (sym->module == NULL || sym->attr.proc == PROC_EXTERNAL\n-      || (sym->module != NULL && sym->attr.if_source == IFSRC_IFBODY))\n+  if (sym->module[0] == 0 || sym->attr.proc == PROC_EXTERNAL\n+      || (sym->module[0] != 0 && sym->attr.if_source == IFSRC_IFBODY))\n     {\n       if (strcmp (sym->name, \"MAIN__\") == 0\n \t  || sym->attr.proc == PROC_INTRINSIC)\n@@ -404,7 +404,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n       DECL_EXTERNAL (decl) = 1;\n       TREE_PUBLIC (decl) = 1;\n     }\n-  else if (sym->module && !sym->attr.result && !sym->attr.dummy)\n+  else if (sym->module[0] && !sym->attr.result && !sym->attr.dummy)\n     {\n       /* TODO: Don't set sym->module for result or dummy variables.  */\n       gcc_assert (current_function_decl == NULL_TREE);\n@@ -766,7 +766,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   /* Symbols from modules should have their assembler names mangled.\n      This is done here rather than in gfc_finish_var_decl because it\n      is different for string length variables.  */\n-  if (sym->module)\n+  if (sym->module[0])\n     SET_DECL_ASSEMBLER_NAME (decl, gfc_sym_mangled_identifier (sym));\n \n   if (sym->attr.dimension)\n@@ -808,7 +808,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t{\n \t  char name[GFC_MAX_MANGLED_SYMBOL_LEN + 2];\n \n-\t  if (sym->module)\n+\t  if (sym->module[0])\n \t    {\n \t      /* Also prefix the mangled name for symbols from modules.  */\n \t      strcpy (&name[1], sym->name);"}, {"sha": "b5ef13f5e1677d63a061b0c73dea41c74f074a1f", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=f5e9e99c8d49990706d1a1b80f5ea9e9db2a534a", "patch": "@@ -816,7 +816,7 @@ gfc_trans_inquire (gfc_code * code)\n \n \n static gfc_expr *\n-gfc_new_nml_name_expr (const char * name)\n+gfc_new_nml_name_expr (char * name)\n {\n    gfc_expr * nml_name;\n    nml_name = gfc_get_expr();\n@@ -825,8 +825,7 @@ gfc_new_nml_name_expr (const char * name)\n    nml_name->ts.kind = gfc_default_character_kind;\n    nml_name->ts.type = BT_CHARACTER;\n    nml_name->value.character.length = strlen(name);\n-   nml_name->value.character.string = gfc_getmem (strlen (name) + 1);\n-   strcpy (nml_name->value.character.string, name);\n+   nml_name->value.character.string = name;\n \n    return nml_name;\n }"}]}