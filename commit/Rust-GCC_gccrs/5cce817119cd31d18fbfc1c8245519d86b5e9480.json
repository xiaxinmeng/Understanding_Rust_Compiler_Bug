{"sha": "5cce817119cd31d18fbfc1c8245519d86b5e9480", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNjZTgxNzExOWNkMzFkMThmYmZjMWM4MjQ1NTE5ZDg2YjVlOTQ4MA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T18:00:51Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T18:00:51Z"}, "message": "Add an \"early rematerialisation\" pass\n\nThis patch looks for pseudo registers that are live across a call\nand for which no call-preserved hard registers exist.  It then\nrecomputes the pseudos as necessary to ensure that they are no\nlonger live across a call.  The comment at the head of the file\ndescribes the approach.\n\nA new target hook selects which modes should be treated in this way.\nBy default none are, in which case the pass is skipped very early.\n\nIt might also be worth looking for cases like:\n\n   C1: R1 := f (...)\n   ...\n   C2: R2 := f (...)\n   C3: R1 := C2\n\nand giving the same value number to C1 and C3, effectively treating\nit like:\n\n   C1: R1 := f (...)\n   ...\n   C2: R2 := f (...)\n   C3: R1 := f (...)\n\nAnother (much more expensive) enhancement would be to apply value\nnumbering to all pseudo registers (not just rematerialisation\ncandidates), so that we can handle things like:\n\n  C1: R1 := f (...R2...)\n  ...\n  C2: R1 := f (...R3...)\n\nwhere R2 and R3 hold the same value.  But the current pass seems\nto catch the vast majority of cases.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* Makefile.in (OBJS): Add early-remat.o.\n\t* target.def (select_early_remat_modes): New hook.\n\t* doc/tm.texi.in (TARGET_SELECT_EARLY_REMAT_MODES): New hook.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_select_early_remat_modes): Declare.\n\t* targhooks.c (default_select_early_remat_modes): New function.\n\t* timevar.def (TV_EARLY_REMAT): New timevar.\n\t* passes.def (pass_early_remat): New pass.\n\t* tree-pass.h (make_pass_early_remat): Declare.\n\t* early-remat.c: New file.\n\t* config/aarch64/aarch64.c (aarch64_select_early_remat_modes): New\n\tfunction.\n\t(TARGET_SELECT_EARLY_REMAT_MODES): Define.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/spill_1.c: Also test that no predicates\n\tare spilled.\n\t* gcc.target/aarch64/sve/spill_2.c: New test.\n\t* gcc.target/aarch64/sve/spill_3.c: Likewise.\n\t* gcc.target/aarch64/sve/spill_4.c: Likewise.\n\t* gcc.target/aarch64/sve/spill_5.c: Likewise.\n\t* gcc.target/aarch64/sve/spill_6.c: Likewise.\n\t* gcc.target/aarch64/sve/spill_7.c: Likewise.\n\nFrom-SVN: r256636", "tree": {"sha": "9fcd4a856308532c0061509406f541b072746f44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fcd4a856308532c0061509406f541b072746f44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cce817119cd31d18fbfc1c8245519d86b5e9480", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cce817119cd31d18fbfc1c8245519d86b5e9480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cce817119cd31d18fbfc1c8245519d86b5e9480", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cce817119cd31d18fbfc1c8245519d86b5e9480/comments", "author": null, "committer": null, "parents": [{"sha": "d1d20a49a788bdb82f09ada6377d932ceac07934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d20a49a788bdb82f09ada6377d932ceac07934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1d20a49a788bdb82f09ada6377d932ceac07934"}], "stats": {"total": 2945, "additions": 2945, "deletions": 0}, "files": [{"sha": "ae33935b92f8d8cb9415ae91b891c5abf74bb77b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -1,3 +1,19 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* Makefile.in (OBJS): Add early-remat.o.\n+\t* target.def (select_early_remat_modes): New hook.\n+\t* doc/tm.texi.in (TARGET_SELECT_EARLY_REMAT_MODES): New hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_select_early_remat_modes): Declare.\n+\t* targhooks.c (default_select_early_remat_modes): New function.\n+\t* timevar.def (TV_EARLY_REMAT): New timevar.\n+\t* passes.def (pass_early_remat): New pass.\n+\t* tree-pass.h (make_pass_early_remat): Declare.\n+\t* early-remat.c: New file.\n+\t* config/aarch64/aarch64.c (aarch64_select_early_remat_modes): New\n+\tfunction.\n+\t(TARGET_SELECT_EARLY_REMAT_MODES): Define.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "374bf3edeb42a82fb5a29c936dca89bfd9c33b54", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -1277,6 +1277,7 @@ OBJS = \\\n \tdwarf2asm.o \\\n \tdwarf2cfi.o \\\n \tdwarf2out.o \\\n+\tearly-remat.o \\\n \temit-rtl.o \\\n \tet-forest.o \\\n \texcept.o \\"}, {"sha": "899aca2f5be9f050a0e2f2d14ec1f6c19a67da4f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -17130,6 +17130,22 @@ aarch64_can_change_mode_class (machine_mode from,\n   return true;\n }\n \n+/* Implement TARGET_EARLY_REMAT_MODES.  */\n+\n+static void\n+aarch64_select_early_remat_modes (sbitmap modes)\n+{\n+  /* SVE values are not normally live across a call, so it should be\n+     worth doing early rematerialization even in VL-specific mode.  */\n+  for (int i = 0; i < NUM_MACHINE_MODES; ++i)\n+    {\n+      machine_mode mode = (machine_mode) i;\n+      unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n+      if (vec_flags & VEC_ANY_SVE)\n+\tbitmap_set_bit (modes, i);\n+    }\n+}\n+\n /* Target-specific selftests.  */\n \n #if CHECKING_P\n@@ -17596,6 +17612,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_CAN_CHANGE_MODE_CLASS\n #define TARGET_CAN_CHANGE_MODE_CLASS aarch64_can_change_mode_class\n \n+#undef TARGET_SELECT_EARLY_REMAT_MODES\n+#define TARGET_SELECT_EARLY_REMAT_MODES aarch64_select_early_remat_modes\n+\n #if CHECKING_P\n #undef TARGET_RUN_TARGET_SELFTESTS\n #define TARGET_RUN_TARGET_SELFTESTS selftest::aarch64_run_selftests"}, {"sha": "491f9c472725b95305aca9c1f4c3c9a64cd9e81f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -2774,6 +2774,17 @@ details.\n With LRA, the default is to use @var{mode} unmodified.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_SELECT_EARLY_REMAT_MODES (sbitmap @var{modes})\n+On some targets, certain modes cannot be held in registers around a\n+standard ABI call and are relatively expensive to spill to the stack.\n+The early rematerialization pass can help in such cases by aggressively\n+recomputing values after calls, so that they don't need to be spilled.\n+\n+This hook returns the set of such modes by setting the associated bits\n+in @var{modes}.  The default implementation selects no modes, which has\n+the effect of disabling the early rematerialization pass.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_CLASS_LIKELY_SPILLED_P (reg_class_t @var{rclass})\n A target hook which returns @code{true} if pseudos that have been assigned\n to registers of class @var{rclass} would likely be spilled because"}, {"sha": "90c24beee88f2987d48f6c9d4eb6b734420899de", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -2307,6 +2307,8 @@ Do not define this macro if you do not define\n \n @hook TARGET_SECONDARY_MEMORY_NEEDED_MODE\n \n+@hook TARGET_SELECT_EARLY_REMAT_MODES\n+\n @hook TARGET_CLASS_LIKELY_SPILLED_P\n \n @hook TARGET_CLASS_MAX_NREGS"}, {"sha": "28eb9b4b2de04ccb92b5c8f654ee35fc61ea245a", "filename": "gcc/early-remat.c", "status": "added", "additions": 2611, "deletions": 0, "changes": 2611, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Fearly-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Fearly-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fearly-remat.c?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -0,0 +1,2611 @@\n+/* Early (pre-RA) rematerialization\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"df.h\"\n+#include \"tree-pass.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+/* FIXME: The next two are only needed for gen_move_insn.  */\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"target.h\"\n+#include \"inchash.h\"\n+#include \"rtlhash.h\"\n+#include \"print-rtl.h\"\n+#include \"rtl-iter.h\"\n+\n+/* This pass runs before register allocation and implements an aggressive\n+   form of rematerialization.  It looks for pseudo registers R of mode M\n+   for which:\n+\n+     (a) there are no call-preserved registers of mode M; and\n+     (b) spilling R to the stack is expensive.\n+\n+   The assumption is that it's better to recompute R after each call instead\n+   of spilling it, even if this extends the live ranges of other registers.\n+\n+   The motivating example for which these conditions hold are AArch64 SVE\n+   vectors and predicates.  Spilling them to the stack makes the frame\n+   variable-sized, which we'd like to avoid if possible.  It's also very\n+   rare for SVE values to be \"naturally\" live across a call: usually this\n+   happens as a result of CSE or other code motion.\n+\n+   The pass is split into the following phases:\n+\n+   Collection phase\n+   ================\n+\n+   First we go through all pseudo registers looking for any that meet\n+   the conditions above.  For each such register R, we go through each\n+   instruction that defines R to see whether any of them are suitable\n+   rematerialization candidates.  If at least one is, we treat all the\n+   instructions that define R as candidates, but record which ones are\n+   not in fact suitable.  These unsuitable candidates exist only for the\n+   sake of calculating reaching definitions (see below).\n+\n+   A \"candidate\" is a single instruction that we want to rematerialize\n+   and a \"candidate register\" is a register that is set by at least one\n+   candidate.\n+\n+   Candidate sorting\n+   =================\n+\n+   Next we sort the candidates based on the cfg postorder, so that if\n+   candidate C1 uses candidate C2, C1 has a lower index than C2.\n+   This is useful when iterating through candidate bitmaps.\n+\n+   Reaching definition calculation\n+   ===============================\n+\n+   We then compute standard reaching-definition sets for each candidate.\n+   Each set specifies which candidates might provide the current definition\n+   of a live candidate register.\n+\n+   From here on, a candidate C is \"live\" at a point P if the candidate\n+   register defined by C is live at P and if C's definition reaches P.\n+   An instruction I \"uses\" a candidate C if I takes the register defined by\n+   C as input and if C is one of the reaching definitions of that register.\n+\n+   Candidate validation and value numbering\n+   ========================================\n+\n+   Next we simultaneously decide which candidates are valid and look\n+   for candidates that are equivalent to each other, assigning numbers\n+   to each unique candidate value.  A candidate C is invalid if:\n+\n+     (a) C uses an invalid candidate;\n+\n+     (b) there is a cycle of candidate uses involving C; or\n+\n+     (c) C takes a candidate register R as input and the reaching\n+         definitions of R do not have the same value number.\n+\n+   We assign a \"representative\" candidate C to each value number and from\n+   here on replace references to other candidates with that value number\n+   with references to C.  It is then only possible to rematerialize a\n+   register R at point P if (after this replacement) there is a single\n+   reaching definition of R at P.\n+\n+   Local phase\n+   ===========\n+\n+   During this phase we go through each block and look for cases in which:\n+\n+     (a) an instruction I comes between two call instructions CI1 and CI2;\n+\n+     (b) I uses a candidate register R;\n+\n+     (c) a candidate C provides the only reaching definition of R; and\n+\n+     (d) C does not come between CI1 and I.\n+\n+   We then emit a copy of C after CI1, as well as the transitive closure\n+   TC of the candidates used by C.  The copies of TC might use the original\n+   candidate registers or new temporary registers, depending on circumstances.\n+\n+   For example, if elsewhere we have:\n+\n+       C3: R3 <- f3 (...)\n+\t   ...\n+       C2: R2 <- f2 (...)\n+\t   ...\n+       C1: R1 <- f1 (R2, R3, ...)  // uses C2 and C3\n+\n+   then for a block containing:\n+\n+      CI1: call\n+\t   ...\n+\tI: use R1  // uses C1\n+\t   ...\n+      CI2: call\n+\n+   we would emit:\n+\n+      CI1: call\n+      C3': R3' <- f3 (...)\n+      C2': R2' <- f2 (...)\n+      C1': R1 <- f1 (R2', R3', ...)\n+\t   ...\n+\tI: use R1\n+\t   ...\n+      CI2: call\n+\n+   where R2' and R3' might be fresh registers.  If instead we had:\n+\n+      CI1: call\n+\t   ...\n+       I1: use R1  // uses C1\n+\t   ...\n+       I2: use R3  // uses C3\n+\t   ...\n+      CI2: call\n+\n+   we would keep the original R3:\n+\n+      CI1: call\n+      C3': R3 <- f3 (...)\n+      C2': R2' <- f2 (...)\n+      C1': R1 <- f1 (R2', R3, ...)\n+\t   ...\n+       I1: use R1  // uses C1\n+\t   ...\n+       I2: use R3  // uses C3\n+\t   ...\n+      CI2: call\n+\n+   We also record the last call in each block (if any) and compute:\n+\n+     rd_after_call:\n+       The set of candidates that either (a) are defined outside the block\n+       and are live after the last call or (b) are defined within the block\n+       and reach the end of the last call.  (We don't track whether the\n+       latter values are live or not.)\n+\n+     required_after_call:\n+       The set of candidates that need to be rematerialized after the\n+       last call in order to satisfy uses in the block itself.\n+\n+     required_in:\n+       The set of candidates that are live on entry to the block and are\n+       used without an intervening call.\n+\n+   In addition, we compute the initial values of the sets required by\n+   the global phase below.\n+\n+   Global phase\n+   ============\n+\n+   We next compute a maximal solution to the following availability\n+   problem:\n+\n+     available_in:\n+       The set of candidates that are live on entry to a block and can\n+       be used at that point without rematerialization.\n+\n+     available_out:\n+       The set of candidates that are live on exit from a block and can\n+       be used at that point without rematerialization.\n+\n+     available_locally:\n+       The subset of available_out that is due to code in the block itself.\n+       It contains candidates that are defined or used in the block and\n+       not invalidated by a later call.\n+\n+   We then go through each block B and look for an appropriate place\n+   to insert copies of required_in - available_in.  Conceptually we\n+   start by placing the copies at the head of B, but then move the\n+   copy of a candidate C to predecessors if:\n+\n+     (a) that seems cheaper;\n+\n+     (b) there is more than one reaching definition of C's register at\n+\t the head of B; or\n+\n+     (c) copying C would clobber a hard register that is live on entry to B.\n+\n+   Moving a copy of C to a predecessor block PB involves:\n+\n+     (1) adding C to PB's required_after_call, if PB contains a call; or\n+\n+     (2) adding C PB's required_in otherwise.\n+\n+   C is then available on output from each PB and on input to B.\n+\n+   Once all this is done, we emit instructions for the final required_in\n+   and required_after_call sets.  */\n+\n+namespace {\n+\n+/* An invalid candidate index, used to indicate that there is more than\n+   one reaching definition.  */\n+const unsigned int MULTIPLE_CANDIDATES = -1U;\n+\n+/* Pass-specific information about one basic block.  */\n+struct remat_block_info {\n+  /* The last call instruction in the block.  */\n+  rtx_insn *last_call;\n+\n+  /* The set of candidates that are live on entry to the block.  NULL is\n+     equivalent to an empty set.  */\n+  bitmap rd_in;\n+\n+  /* The set of candidates that are live on exit from the block.  This might\n+     reuse rd_in.  NULL is equivalent to an empty set.  */\n+  bitmap rd_out;\n+\n+  /* The subset of RD_OUT that comes from local definitions.  NULL is\n+     equivalent to an empty set.  */\n+  bitmap rd_gen;\n+\n+  /* The set of candidates that the block invalidates (because it defines\n+     the register to something else, or because the register's value is\n+     no longer important).  NULL is equivalent to an empty set.  */\n+  bitmap rd_kill;\n+\n+  /* The set of candidates that either (a) are defined outside the block\n+     and are live after LAST_CALL or (b) are defined within the block\n+     and reach the instruction after LAST_CALL.  (We don't track whether\n+     the latter values are live or not.)\n+\n+     Only used if LAST_CALL is nonnull.  NULL is equivalent to an\n+     empty set.  */\n+  bitmap rd_after_call;\n+\n+  /* Candidates that are live and available without rematerialization\n+     on entry to the block.  NULL is equivalent to an empty set.  */\n+  bitmap available_in;\n+\n+  /* Candidates that become available without rematerialization within the\n+     block, and remain so on exit.  NULL is equivalent to an empty set.  */\n+  bitmap available_locally;\n+\n+  /* Candidates that are available without rematerialization on exit from\n+     the block.  This might reuse available_in or available_locally.  */\n+  bitmap available_out;\n+\n+  /* Candidates that need to be rematerialized either at the start of the\n+     block or before entering the block.  */\n+  bitmap required_in;\n+\n+  /* Candidates that need to be rematerialized after LAST_CALL.\n+     Only used if LAST_CALL is nonnull.  */\n+  bitmap required_after_call;\n+\n+  /* The number of candidates in the block.  */\n+  unsigned int num_candidates;\n+\n+  /* The earliest candidate in the block (i.e. the one with the\n+     highest index).  Only valid if NUM_CANDIDATES is nonzero.  */\n+  unsigned int first_candidate;\n+\n+  /* The best (lowest) execution frequency for rematerializing REQUIRED_IN.\n+     This is the execution frequency of the block if LOCAL_REMAT_CHEAPER_P,\n+     otherwise it is the sum of the execution frequencies of whichever\n+     predecessor blocks would do the rematerialization.  */\n+  int remat_frequency;\n+\n+  /* True if the block ends with an abnormal call.  */\n+  unsigned int abnormal_call_p : 1;\n+\n+  /* Used to record whether a graph traversal has visited this block.  */\n+  unsigned int visited_p : 1;\n+\n+  /* True if we have calculated REMAT_FREQUENCY.  */\n+  unsigned int remat_frequency_valid_p : 1;\n+\n+  /* True if it is cheaper to rematerialize candidates at the start of\n+     the block, rather than moving them to predecessor blocks.  */\n+  unsigned int local_remat_cheaper_p : 1;\n+};\n+\n+/* Information about a group of candidates with the same value number.  */\n+struct remat_equiv_class {\n+  /* The candidates that have the same value number.  */\n+  bitmap members;\n+\n+  /* The candidate that was first added to MEMBERS.  */\n+  unsigned int earliest;\n+\n+  /* The candidate that represents the others.  This is always the one\n+     with the highest index.  */\n+  unsigned int representative;\n+};\n+\n+/* Information about an instruction that we might want to rematerialize.  */\n+struct remat_candidate {\n+  /* The pseudo register that the instruction sets.  */\n+  unsigned int regno;\n+\n+  /* A temporary register used when rematerializing uses of this candidate,\n+     if REGNO doesn't have the right value or isn't worth using.  */\n+  unsigned int copy_regno;\n+\n+  /* True if we intend to rematerialize this instruction by emitting\n+     a move of a constant into REGNO, false if we intend to emit a\n+     copy of the original instruction.  */\n+  unsigned int constant_p : 1;\n+\n+  /* True if we still think it's possible to rematerialize INSN.  */\n+  unsigned int can_copy_p : 1;\n+\n+  /* Used to record whether a graph traversal has visited this candidate.  */\n+  unsigned int visited_p : 1;\n+\n+  /* True if we have verified that it's possible to rematerialize INSN.\n+     Once this is true, both it and CAN_COPY_P remain true.  */\n+  unsigned int validated_p : 1;\n+\n+  /* True if we have \"stabilized\" INSN, i.e. ensured that all non-candidate\n+     registers read by INSN will have the same value when rematerializing INSN.\n+     Only ever true if CAN_COPY_P.  */\n+  unsigned int stabilized_p : 1;\n+\n+  /* Hash value used for value numbering.  */\n+  hashval_t hash;\n+\n+  /* The instruction that sets REGNO.  */\n+  rtx_insn *insn;\n+\n+  /* If CONSTANT_P, the value that should be moved into REGNO when\n+     rematerializing, otherwise the pattern of the instruction that\n+     should be used.  */\n+  rtx remat_rtx;\n+\n+  /* The set of candidates that INSN takes as input.  NULL is equivalent\n+     to the empty set.  All candidates in this set have a higher index\n+     than the current candidate.  */\n+  bitmap uses;\n+\n+  /* The set of hard registers that would be clobbered by rematerializing\n+     the candidate, including (transitively) all those that would be\n+     clobbered by rematerializing USES.  */\n+  bitmap clobbers;\n+\n+  /* The equivalence class to which the candidate belongs, or null if none.  */\n+  remat_equiv_class *equiv_class;\n+};\n+\n+/* Hash functions used for value numbering.  */\n+struct remat_candidate_hasher : nofree_ptr_hash <remat_candidate>\n+{\n+  typedef value_type compare_type;\n+  static hashval_t hash (const remat_candidate *);\n+  static bool equal (const remat_candidate *, const remat_candidate *);\n+};\n+\n+/* Main class for this pass.  */\n+class early_remat {\n+public:\n+  early_remat (function *, sbitmap);\n+  ~early_remat ();\n+\n+  void run (void);\n+\n+private:\n+  bitmap alloc_bitmap (void);\n+  bitmap get_bitmap (bitmap *);\n+  void init_temp_bitmap (bitmap *);\n+  void copy_temp_bitmap (bitmap *, bitmap *);\n+\n+  void dump_insn_id (rtx_insn *);\n+  void dump_candidate_bitmap (bitmap);\n+  void dump_all_candidates (void);\n+  void dump_edge_list (basic_block, bool);\n+  void dump_block_info (basic_block);\n+  void dump_all_blocks (void);\n+\n+  bool interesting_regno_p (unsigned int);\n+  remat_candidate *add_candidate (rtx_insn *, unsigned int, bool);\n+  bool maybe_add_candidate (rtx_insn *, unsigned int);\n+  bool collect_candidates (void);\n+  void init_block_info (void);\n+  void sort_candidates (void);\n+  void finalize_candidate_indices (void);\n+  void record_equiv_candidates (unsigned int, unsigned int);\n+  static bool rd_confluence_n (edge);\n+  static bool rd_transfer (int);\n+  void compute_rd (void);\n+  unsigned int canon_candidate (unsigned int);\n+  void canon_bitmap (bitmap *);\n+  unsigned int resolve_reaching_def (bitmap);\n+  bool check_candidate_uses (unsigned int);\n+  void compute_clobbers (unsigned int);\n+  void assign_value_number (unsigned int);\n+  void decide_candidate_validity (void);\n+  bool stable_use_p (unsigned int);\n+  void emit_copy_before (unsigned int, rtx, rtx);\n+  void stabilize_pattern (unsigned int);\n+  void replace_dest_with_copy (unsigned int);\n+  void stabilize_candidate_uses (unsigned int, bitmap, bitmap, bitmap,\n+\t\t\t\t bitmap);\n+  void emit_remat_insns (bitmap, bitmap, bitmap, rtx_insn *);\n+  bool set_available_out (remat_block_info *);\n+  void process_block (basic_block);\n+  void local_phase (void);\n+  static bool avail_confluence_n (edge);\n+  static bool avail_transfer (int);\n+  void compute_availability (void);\n+  void unshare_available_sets (remat_block_info *);\n+  bool can_move_across_edge_p (edge);\n+  bool local_remat_cheaper_p (unsigned int);\n+  bool need_to_move_candidate_p (unsigned int, unsigned int);\n+  void compute_minimum_move_set (unsigned int, bitmap);\n+  void move_to_predecessors (unsigned int, bitmap, bitmap);\n+  void choose_rematerialization_points (void);\n+  void emit_remat_insns_for_block (basic_block);\n+  void global_phase (void);\n+\n+  /* The function that we're optimizing.  */\n+  function *m_fn;\n+\n+  /* The modes that we want to rematerialize.  */\n+  sbitmap m_selected_modes;\n+\n+  /* All rematerialization candidates, identified by their index into the\n+     vector.  */\n+  auto_vec<remat_candidate> m_candidates;\n+\n+  /* The set of candidate registers.  */\n+  bitmap_head m_candidate_regnos;\n+\n+  /* Temporary sets.  */\n+  bitmap_head m_tmp_bitmap;\n+  bitmap m_available;\n+  bitmap m_required;\n+\n+  /* Information about each basic block.  */\n+  auto_vec<remat_block_info> m_block_info;\n+\n+  /* A mapping from register numbers to the set of associated candidates.\n+     Only valid for registers in M_CANDIDATE_REGNOS.  */\n+  auto_vec<bitmap> m_regno_to_candidates;\n+\n+  /* An obstack used for allocating bitmaps, so that we can free them all\n+     in one go.  */\n+  bitmap_obstack m_obstack;\n+\n+  /* A hash table of candidates used for value numbering.  If a candidate\n+     in the table is in an equivalence class, the candidate is marked as\n+     the earliest member of the class.  */\n+  hash_table<remat_candidate_hasher> m_value_table;\n+\n+  /* Used temporarily by callback functions.  */\n+  static early_remat *er;\n+};\n+\n+}\n+\n+early_remat *early_remat::er;\n+\n+/* rtx_equal_p_cb callback that treats any two SCRATCHes as equal.\n+   This allows us to compare two copies of a pattern, even though their\n+   SCRATCHes are always distinct.  */\n+\n+static int\n+scratch_equal (const_rtx *x, const_rtx *y, rtx *nx, rtx *ny)\n+{\n+  if (GET_CODE (*x) == SCRATCH && GET_CODE (*y) == SCRATCH)\n+    {\n+      *nx = const0_rtx;\n+      *ny = const0_rtx;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Hash callback functions for remat_candidate.  */\n+\n+hashval_t\n+remat_candidate_hasher::hash (const remat_candidate *cand)\n+{\n+  return cand->hash;\n+}\n+\n+bool\n+remat_candidate_hasher::equal (const remat_candidate *cand1,\n+\t\t\t       const remat_candidate *cand2)\n+{\n+  return (cand1->regno == cand2->regno\n+\t  && cand1->constant_p == cand2->constant_p\n+\t  && (cand1->constant_p\n+\t      ? rtx_equal_p (cand1->remat_rtx, cand2->remat_rtx)\n+\t      : rtx_equal_p_cb (cand1->remat_rtx, cand2->remat_rtx,\n+\t\t\t\tscratch_equal))\n+\t  && (!cand1->uses || bitmap_equal_p (cand1->uses, cand2->uses)));\n+}\n+\n+/* Return true if B is null or empty.  */\n+\n+inline bool\n+empty_p (bitmap b)\n+{\n+  return !b || bitmap_empty_p (b);\n+}\n+\n+/* Allocate a new bitmap.  It will be automatically freed at the end of\n+   the pass.  */\n+\n+inline bitmap\n+early_remat::alloc_bitmap (void)\n+{\n+  return bitmap_alloc (&m_obstack);\n+}\n+\n+/* Initialize *PTR to an empty bitmap if it is currently null.  */\n+\n+inline bitmap\n+early_remat::get_bitmap (bitmap *ptr)\n+{\n+  if (!*ptr)\n+    *ptr = alloc_bitmap ();\n+  return *ptr;\n+}\n+\n+/* *PTR is either null or empty.  If it is null, initialize it to an\n+   empty bitmap.  */\n+\n+inline void\n+early_remat::init_temp_bitmap (bitmap *ptr)\n+{\n+  if (!*ptr)\n+    *ptr = alloc_bitmap ();\n+  else\n+    gcc_checking_assert (bitmap_empty_p (*ptr));\n+}\n+\n+/* Move *SRC to *DEST and leave *SRC empty.  */\n+\n+inline void\n+early_remat::copy_temp_bitmap (bitmap *dest, bitmap *src)\n+{\n+  if (!empty_p (*src))\n+    {\n+      *dest = *src;\n+      *src = NULL;\n+    }\n+  else\n+    *dest = NULL;\n+}\n+\n+/* Print INSN's identifier to the dump file.  */\n+\n+void\n+early_remat::dump_insn_id (rtx_insn *insn)\n+{\n+  fprintf (dump_file, \"%d[bb:%d]\", INSN_UID (insn),\n+\t   BLOCK_FOR_INSN (insn)->index);\n+}\n+\n+/* Print candidate set CANDIDATES to the dump file, with a leading space.  */\n+\n+void\n+early_remat::dump_candidate_bitmap (bitmap candidates)\n+{\n+  if (empty_p (candidates))\n+    {\n+      fprintf (dump_file, \" none\");\n+      return;\n+    }\n+\n+  unsigned int cand_index;\n+  bitmap_iterator bi;\n+  EXECUTE_IF_SET_IN_BITMAP (candidates, 0, cand_index, bi)\n+    fprintf (dump_file, \" %d\", cand_index);\n+}\n+\n+/* Print information about all candidates to the dump file.  */\n+\n+void\n+early_remat::dump_all_candidates (void)\n+{\n+  fprintf (dump_file, \"\\n;; Candidates:\\n;;\\n\");\n+  fprintf (dump_file, \";; %5s %5s %8s %s\\n\", \"#\", \"reg\", \"mode\", \"insn\");\n+  fprintf (dump_file, \";; %5s %5s %8s %s\\n\", \"=\", \"===\", \"====\", \"====\");\n+  unsigned int cand_index;\n+  remat_candidate *cand;\n+  FOR_EACH_VEC_ELT (m_candidates, cand_index, cand)\n+    {\n+      fprintf (dump_file, \";; %5d %5d %8s \", cand_index, cand->regno,\n+\t       GET_MODE_NAME (GET_MODE (regno_reg_rtx[cand->regno])));\n+      dump_insn_id (cand->insn);\n+      if (!cand->can_copy_p)\n+\tfprintf (dump_file, \"   -- can't copy\");\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  fprintf (dump_file, \"\\n;; Register-to-candidate mapping:\\n;;\\n\");\n+  unsigned int regno;\n+  bitmap_iterator bi;\n+  EXECUTE_IF_SET_IN_BITMAP (&m_candidate_regnos, 0, regno, bi)\n+    {\n+      fprintf (dump_file, \";; %5d:\", regno);\n+      dump_candidate_bitmap (m_regno_to_candidates[regno]);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+/* Print the predecessors or successors of BB to the dump file, with a\n+   leading space.  DO_SUCC is true to print successors and false to print\n+   predecessors.  */\n+\n+void\n+early_remat::dump_edge_list (basic_block bb, bool do_succ)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, do_succ ? bb->succs : bb->preds)\n+    dump_edge_info (dump_file, e, 0, do_succ);\n+}\n+\n+/* Print information about basic block BB to the dump file.  */\n+\n+void\n+early_remat::dump_block_info (basic_block bb)\n+{\n+  remat_block_info *info = &m_block_info[bb->index];\n+  fprintf (dump_file, \";;\\n;; Block %d:\", bb->index);\n+  int width = 25;\n+\n+  fprintf (dump_file, \"\\n;;%*s:\", width, \"predecessors\");\n+  dump_edge_list (bb, false);\n+\n+  fprintf (dump_file, \"\\n;;%*s:\", width, \"successors\");\n+  dump_edge_list (bb, true);\n+\n+  fprintf (dump_file, \"\\n;;%*s: %d\", width, \"frequency\",\n+\t   bb->count.to_frequency (m_fn));\n+\n+  if (info->last_call)\n+    fprintf (dump_file, \"\\n;;%*s: %d\", width, \"last call\",\n+\t     INSN_UID (info->last_call));\n+\n+  if (!empty_p (info->rd_in))\n+    {\n+      fprintf (dump_file, \"\\n;;%*s:\", width, \"RD in\");\n+      dump_candidate_bitmap (info->rd_in);\n+    }\n+  if (!empty_p (info->rd_kill))\n+    {\n+      fprintf (dump_file, \"\\n;;%*s:\", width, \"RD kill\");\n+      dump_candidate_bitmap (info->rd_kill);\n+    }\n+  if (!empty_p (info->rd_gen))\n+    {\n+      fprintf (dump_file, \"\\n;;%*s:\", width, \"RD gen\");\n+      dump_candidate_bitmap (info->rd_gen);\n+    }\n+  if (!empty_p (info->rd_after_call))\n+    {\n+      fprintf (dump_file, \"\\n;;%*s:\", width, \"RD after call\");\n+      dump_candidate_bitmap (info->rd_after_call);\n+    }\n+  if (!empty_p (info->rd_out))\n+    {\n+      fprintf (dump_file, \"\\n;;%*s:\", width, \"RD out\");\n+      if (info->rd_in == info->rd_out)\n+\tfprintf (dump_file, \" RD in\");\n+      else\n+\tdump_candidate_bitmap (info->rd_out);\n+    }\n+  if (!empty_p (info->available_in))\n+    {\n+      fprintf (dump_file, \"\\n;;%*s:\", width, \"available in\");\n+      dump_candidate_bitmap (info->available_in);\n+    }\n+  if (!empty_p (info->available_locally))\n+    {\n+      fprintf (dump_file, \"\\n;;%*s:\", width, \"available locally\");\n+      dump_candidate_bitmap (info->available_locally);\n+    }\n+  if (!empty_p (info->available_out))\n+    {\n+      fprintf (dump_file, \"\\n;;%*s:\", width, \"available out\");\n+      if (info->available_in == info->available_out)\n+\tfprintf (dump_file, \" available in\");\n+      else if (info->available_locally == info->available_out)\n+\tfprintf (dump_file, \" available locally\");\n+      else\n+\tdump_candidate_bitmap (info->available_out);\n+    }\n+  if (!empty_p (info->required_in))\n+    {\n+      fprintf (dump_file, \"\\n;;%*s:\", width, \"required in\");\n+      dump_candidate_bitmap (info->required_in);\n+    }\n+  if (!empty_p (info->required_after_call))\n+    {\n+      fprintf (dump_file, \"\\n;;%*s:\", width, \"required after call\");\n+      dump_candidate_bitmap (info->required_after_call);\n+    }\n+  fprintf (dump_file, \"\\n\");\n+}\n+\n+/* Print information about all basic blocks to the dump file.  */\n+\n+void\n+early_remat::dump_all_blocks (void)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, m_fn)\n+    dump_block_info (bb);\n+}\n+\n+/* Return true if REGNO is worth rematerializing.  */\n+\n+bool\n+early_remat::interesting_regno_p (unsigned int regno)\n+{\n+  /* Ignore unused registers.  */\n+  rtx reg = regno_reg_rtx[regno];\n+  if (!reg || DF_REG_DEF_COUNT (regno) == 0)\n+    return false;\n+\n+  /* Make sure the register has a mode that we want to rematerialize.  */\n+  if (!bitmap_bit_p (m_selected_modes, GET_MODE (reg)))\n+    return false;\n+\n+  /* Ignore values that might sometimes be used uninitialized.  We could\n+     instead add dummy candidates for the entry block definition, and so\n+     handle uses that are definitely not uninitialized, but the combination\n+     of the two should be rare in practice.  */\n+  if (bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR_FOR_FN (m_fn)), regno))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Record the set of register REGNO in instruction INSN as a\n+   rematerialization candidate.  CAN_COPY_P is true unless we already\n+   know that rematerialization is impossible (in which case the candidate\n+   only exists for the reaching definition calculation).\n+\n+   The candidate's index is not fixed at this stage.  */\n+\n+remat_candidate *\n+early_remat::add_candidate (rtx_insn *insn, unsigned int regno,\n+\t\t\t    bool can_copy_p)\n+{\n+  remat_candidate cand;\n+  memset (&cand, 0, sizeof (cand));\n+  cand.regno = regno;\n+  cand.insn = insn;\n+  cand.remat_rtx = PATTERN (insn);\n+  cand.can_copy_p = can_copy_p;\n+  m_candidates.safe_push (cand);\n+\n+  bitmap_set_bit (&m_candidate_regnos, regno);\n+\n+  return &m_candidates.last ();\n+}\n+\n+/* Return true if we can rematerialize the set of register REGNO in\n+   instruction INSN, and add it as a candidate if so.  When returning\n+   false, print the reason to the dump file.  */\n+\n+bool\n+early_remat::maybe_add_candidate (rtx_insn *insn, unsigned int regno)\n+{\n+#define FAILURE_FORMAT \";; Can't rematerialize set of reg %d in %d[bb:%d]: \"\n+#define FAILURE_ARGS regno, INSN_UID (insn), BLOCK_FOR_INSN (insn)->index\n+\n+  /* The definition must come from an ordinary instruction.  */\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+  if (!NONJUMP_INSN_P (insn)\n+      || (insn == BB_END (bb)\n+\t  && has_abnormal_or_eh_outgoing_edge_p (bb)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, FAILURE_FORMAT \"insn alters control flow\\n\",\n+\t\t FAILURE_ARGS);\n+      return false;\n+    }\n+\n+  /* Prefer to rematerialize constants directly -- it's much easier.  */\n+  machine_mode mode = GET_MODE (regno_reg_rtx[regno]);\n+  if (rtx note = find_reg_equal_equiv_note (insn))\n+    {\n+      rtx val = XEXP (note, 0);\n+      if (CONSTANT_P (val)\n+\t  && targetm.legitimate_constant_p (mode, val))\n+\t{\n+\t  remat_candidate *cand = add_candidate (insn, regno, true);\n+\t  cand->constant_p = true;\n+\t  cand->remat_rtx = val;\n+\t  return true;\n+\t}\n+    }\n+\n+  /* See whether the target has reasons to prevent a copy.  */\n+  if (targetm.cannot_copy_insn_p && targetm.cannot_copy_insn_p (insn))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, FAILURE_FORMAT \"target forbids copying\\n\",\n+\t\t FAILURE_ARGS);\n+      return false;\n+    }\n+\n+  /* We can't copy trapping instructions.  */\n+  rtx pat = PATTERN (insn);\n+  if (may_trap_p (pat))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, FAILURE_FORMAT \"insn might trap\\n\", FAILURE_ARGS);\n+      return false;\n+    }\n+\n+  /* We can't copy instructions that read memory, unless we know that\n+     the contents never change.  */\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, pat, ALL)\n+    if (MEM_P (*iter) && !MEM_READONLY_P (*iter))\n+      {\n+\tif (dump_file)\n+\t  fprintf (dump_file, FAILURE_FORMAT \"insn references non-constant\"\n+\t\t   \" memory\\n\", FAILURE_ARGS);\n+\treturn false;\n+      }\n+\n+  /* Check each defined register.  */\n+  df_ref ref;\n+  FOR_EACH_INSN_DEF (ref, insn)\n+    {\n+      unsigned int def_regno = DF_REF_REGNO (ref);\n+      if (def_regno == regno)\n+\t{\n+\t  /* Make sure the definition is write-only.  (Partial definitions,\n+\t     such as setting the low part and clobbering the high part,\n+\t     are otherwise OK.)  */\n+\t  if (DF_REF_FLAGS_IS_SET (ref, DF_REF_READ_WRITE))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, FAILURE_FORMAT \"destination is\"\n+\t\t\t \" read-modify-write\\n\", FAILURE_ARGS);\n+\t      return false;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* The instruction can set additional registers, provided that\n+\t     they're call-clobbered hard registers.  This is useful for\n+\t     instructions that alter the condition codes.  */\n+\t  if (!HARD_REGISTER_NUM_P (def_regno))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, FAILURE_FORMAT \"insn also sets\"\n+\t\t\t \" pseudo reg %d\\n\", FAILURE_ARGS, def_regno);\n+\t      return false;\n+\t    }\n+\t  if (global_regs[def_regno])\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, FAILURE_FORMAT \"insn also sets\"\n+\t\t\t \" global reg %d\\n\", FAILURE_ARGS, def_regno);\n+\t      return false;\n+\t    }\n+\t  if (!TEST_HARD_REG_BIT (regs_invalidated_by_call, def_regno))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, FAILURE_FORMAT \"insn also sets\"\n+\t\t\t \" call-preserved reg %d\\n\", FAILURE_ARGS, def_regno);\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+\n+  /* If the instruction uses fixed hard registers, check that those\n+     registers have the same value throughout the function.  If the\n+     instruction uses non-fixed hard registers, check that we can\n+     replace them with pseudos.  */\n+  FOR_EACH_INSN_USE (ref, insn)\n+    {\n+      unsigned int use_regno = DF_REF_REGNO (ref);\n+      if (HARD_REGISTER_NUM_P (use_regno) && fixed_regs[use_regno])\n+\t{\n+\t  if (rtx_unstable_p (DF_REF_REAL_REG (ref)))\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, FAILURE_FORMAT \"insn uses fixed hard reg\"\n+\t\t\t \" %d\\n\", FAILURE_ARGS, use_regno);\n+\t      return false;\n+\t    }\n+\t}\n+      else if (HARD_REGISTER_NUM_P (use_regno))\n+\t{\n+\t  /* Allocate a dummy pseudo register and temporarily install it.\n+\t     Make the register number depend on the mode, which should\n+\t     provide enough sharing for match_dup while also weeding\n+\t     out cases in which operands with different modes are\n+\t     explicitly tied.  */\n+\t  rtx *loc = DF_REF_REAL_LOC (ref);\n+\t  unsigned int size = RTX_CODE_SIZE (REG);\n+\t  rtx new_reg = (rtx) alloca (size);\n+\t  memset (new_reg, 0, size);\n+\t  PUT_CODE (new_reg, REG);\n+\t  set_mode_and_regno (new_reg, GET_MODE (*loc),\n+\t\t\t      LAST_VIRTUAL_REGISTER + 1 + GET_MODE (*loc));\n+\t  validate_change (insn, loc, new_reg, 1);\n+\t}\n+    }\n+  bool ok_p = verify_changes (0);\n+  cancel_changes (0);\n+  if (!ok_p)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, FAILURE_FORMAT \"insn does not allow hard\"\n+\t\t \" register inputs to be replaced\\n\", FAILURE_ARGS);\n+      return false;\n+    }\n+\n+#undef FAILURE_ARGS\n+#undef FAILURE_FORMAT\n+\n+  add_candidate (insn, regno, true);\n+  return true;\n+}\n+\n+/* Calculate the set of rematerialization candidates.  Return true if\n+   we find at least one.  */\n+\n+bool\n+early_remat::collect_candidates (void)\n+{\n+  unsigned int nregs = DF_REG_SIZE (df);\n+  for (unsigned int regno = FIRST_PSEUDO_REGISTER; regno < nregs; ++regno)\n+    if (interesting_regno_p (regno))\n+      {\n+\t/* Create candidates for all suitable definitions.  */\n+\tbitmap_clear (&m_tmp_bitmap);\n+\tunsigned int bad = 0;\n+\tunsigned int id = 0;\n+\tfor (df_ref ref = DF_REG_DEF_CHAIN (regno); ref;\n+\t     ref = DF_REF_NEXT_REG (ref))\n+\t  {\n+\t    rtx_insn *insn = DF_REF_INSN (ref);\n+\t    if (maybe_add_candidate (insn, regno))\n+\t      bitmap_set_bit (&m_tmp_bitmap, id);\n+\t    else\n+\t      bad += 1;\n+\t    id += 1;\n+\t  }\n+\n+\t/* If we found at least one suitable definition, add dummy\n+\t   candidates for the rest, so that we can see which definitions\n+\t   are live where.  */\n+\tif (!bitmap_empty_p (&m_tmp_bitmap) && bad)\n+\t  {\n+\t    id = 0;\n+\t    for (df_ref ref = DF_REG_DEF_CHAIN (regno); ref;\n+\t\t ref = DF_REF_NEXT_REG (ref))\n+\t      {\n+\t\tif (!bitmap_bit_p (&m_tmp_bitmap, id))\n+\t\t  add_candidate (DF_REF_INSN (ref), regno, false);\n+\t\tid += 1;\n+\t      }\n+\t  }\n+      }\n+\n+\n+  return !m_candidates.is_empty ();\n+}\n+\n+/* Initialize the m_block_info array.  */\n+\n+void\n+early_remat::init_block_info (void)\n+{\n+  unsigned int n_blocks = last_basic_block_for_fn (m_fn);\n+  m_block_info.safe_grow_cleared (n_blocks);\n+}\n+\n+/* Maps basic block indices to their position in the post order.  */\n+static unsigned int *postorder_index;\n+\n+/* Order remat_candidates X_IN and Y_IN according to the cfg postorder.  */\n+\n+static int\n+compare_candidates (const void *x_in, const void *y_in)\n+{\n+  const remat_candidate *x = (const remat_candidate *) x_in;\n+  const remat_candidate *y = (const remat_candidate *) y_in;\n+  basic_block x_bb = BLOCK_FOR_INSN (x->insn);\n+  basic_block y_bb = BLOCK_FOR_INSN (y->insn);\n+  if (x_bb != y_bb)\n+    /* Make X and Y follow block postorder.  */\n+    return postorder_index[x_bb->index] - postorder_index[y_bb->index];\n+\n+  /* Make X and Y follow a backward traversal of the containing block.  */\n+  return DF_INSN_LUID (y->insn) - DF_INSN_LUID (x->insn);\n+}\n+\n+/* Sort the collected rematerialization candidates so that they follow\n+   cfg postorder.  */\n+\n+void\n+early_remat::sort_candidates (void)\n+{\n+  /* Make sure the DF LUIDs are up-to-date for all the blocks we\n+     care about.  */\n+  bitmap_clear (&m_tmp_bitmap);\n+  unsigned int cand_index;\n+  remat_candidate *cand;\n+  FOR_EACH_VEC_ELT (m_candidates, cand_index, cand)\n+    {\n+      basic_block bb = BLOCK_FOR_INSN (cand->insn);\n+      if (bitmap_set_bit (&m_tmp_bitmap, bb->index))\n+\tdf_recompute_luids (bb);\n+    }\n+\n+  /* Create a mapping from block numbers to their position in the\n+     postorder.  */\n+  unsigned int n_blocks = last_basic_block_for_fn (m_fn);\n+  int *postorder = df_get_postorder (DF_BACKWARD);\n+  unsigned int postorder_len = df_get_n_blocks (DF_BACKWARD);\n+  postorder_index = new unsigned int[n_blocks];\n+  for (unsigned int i = 0; i < postorder_len; ++i)\n+    postorder_index[postorder[i]] = i;\n+\n+  m_candidates.qsort (compare_candidates);\n+\n+  delete postorder_index;\n+}\n+\n+/* Commit to the current candidate indices and initialize cross-references.  */\n+\n+void\n+early_remat::finalize_candidate_indices (void)\n+{\n+  /* Create a bitmap for each candidate register.  */\n+  m_regno_to_candidates.safe_grow (max_reg_num ());\n+  unsigned int regno;\n+  bitmap_iterator bi;\n+  EXECUTE_IF_SET_IN_BITMAP (&m_candidate_regnos, 0, regno, bi)\n+    m_regno_to_candidates[regno] = alloc_bitmap ();\n+\n+  /* Go through each candidate and record its index.  */\n+  unsigned int cand_index;\n+  remat_candidate *cand;\n+  FOR_EACH_VEC_ELT (m_candidates, cand_index, cand)\n+    {\n+      basic_block bb = BLOCK_FOR_INSN (cand->insn);\n+      remat_block_info *info = &m_block_info[bb->index];\n+      info->num_candidates += 1;\n+      info->first_candidate = cand_index;\n+      bitmap_set_bit (m_regno_to_candidates[cand->regno], cand_index);\n+    }\n+}\n+\n+/* Record that candidates CAND1_INDEX and CAND2_INDEX are equivalent.\n+   CAND1_INDEX might already have an equivalence class, but CAND2_INDEX\n+   doesn't.  */\n+\n+void\n+early_remat::record_equiv_candidates (unsigned int cand1_index,\n+\t\t\t\t      unsigned int cand2_index)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \";; Candidate %d is equivalent to candidate %d\\n\",\n+\t     cand2_index, cand1_index);\n+\n+  remat_candidate *cand1 = &m_candidates[cand1_index];\n+  remat_candidate *cand2 = &m_candidates[cand2_index];\n+  gcc_checking_assert (!cand2->equiv_class);\n+\n+  remat_equiv_class *ec = cand1->equiv_class;\n+  if (!ec)\n+    {\n+      ec = XOBNEW (&m_obstack.obstack, remat_equiv_class);\n+      ec->members = alloc_bitmap ();\n+      bitmap_set_bit (ec->members, cand1_index);\n+      ec->earliest = cand1_index;\n+      ec->representative = cand1_index;\n+      cand1->equiv_class = ec;\n+    }\n+  cand1 = &m_candidates[ec->representative];\n+  cand2->equiv_class = ec;\n+  bitmap_set_bit (ec->members, cand2_index);\n+  if (cand2_index > ec->representative)\n+    ec->representative = cand2_index;\n+}\n+\n+/* Propagate information from the rd_out set of E->src to the rd_in set\n+   of E->dest, when computing global reaching definitions.  Return true\n+   if something changed.  */\n+\n+bool\n+early_remat::rd_confluence_n (edge e)\n+{\n+  remat_block_info *src = &er->m_block_info[e->src->index];\n+  remat_block_info *dest = &er->m_block_info[e->dest->index];\n+\n+  /* available_in temporarily contains the set of candidates whose\n+     registers are live on entry.  */\n+  if (empty_p (src->rd_out) || empty_p (dest->available_in))\n+    return false;\n+\n+  return bitmap_ior_and_into (er->get_bitmap (&dest->rd_in),\n+\t\t\t      src->rd_out, dest->available_in);\n+}\n+\n+/* Propagate information from the rd_in set of block BB_INDEX to rd_out.\n+   Return true if something changed.  */\n+\n+bool\n+early_remat::rd_transfer (int bb_index)\n+{\n+  remat_block_info *info = &er->m_block_info[bb_index];\n+\n+  if (empty_p (info->rd_in))\n+    return false;\n+\n+  if (empty_p (info->rd_kill))\n+    {\n+      gcc_checking_assert (empty_p (info->rd_gen));\n+      if (!info->rd_out)\n+\tinfo->rd_out = info->rd_in;\n+      else\n+\tgcc_checking_assert (info->rd_out == info->rd_in);\n+      /* Assume that we only get called if something changed.  */\n+      return true;\n+    }\n+\n+  if (empty_p (info->rd_gen))\n+    return bitmap_and_compl (er->get_bitmap (&info->rd_out),\n+\t\t\t     info->rd_in, info->rd_kill);\n+\n+  return bitmap_ior_and_compl (er->get_bitmap (&info->rd_out), info->rd_gen,\n+\t\t\t       info->rd_in, info->rd_kill);\n+}\n+\n+/* Calculate the rd_* sets for each block.  */\n+\n+void\n+early_remat::compute_rd (void)\n+{\n+  /* First calculate the rd_kill and rd_gen sets, using the fact\n+     that m_candidates is sorted in order of decreasing LUID.  */\n+  unsigned int cand_index;\n+  remat_candidate *cand;\n+  FOR_EACH_VEC_ELT_REVERSE (m_candidates, cand_index, cand)\n+    {\n+      rtx_insn *insn = cand->insn;\n+      basic_block bb = BLOCK_FOR_INSN (insn);\n+      remat_block_info *info = &m_block_info[bb->index];\n+      bitmap kill = m_regno_to_candidates[cand->regno];\n+      bitmap_ior_into (get_bitmap (&info->rd_kill), kill);\n+      if (bitmap_bit_p (DF_LR_OUT (bb), cand->regno))\n+\t{\n+\t  bitmap_and_compl_into (get_bitmap (&info->rd_gen), kill);\n+\t  bitmap_set_bit (info->rd_gen, cand_index);\n+\t}\n+    }\n+\n+  /* Set up the initial values of the other sets.  */\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, m_fn)\n+    {\n+      remat_block_info *info = &m_block_info[bb->index];\n+      unsigned int regno;\n+      bitmap_iterator bi;\n+      EXECUTE_IF_AND_IN_BITMAP (DF_LR_IN (bb), &m_candidate_regnos,\n+\t\t\t\t0, regno, bi)\n+\t{\n+\t  /* Use available_in to record the set of candidates whose\n+\t     registers are live on entry (i.e. a maximum bound on rd_in).  */\n+\t  bitmap_ior_into (get_bitmap (&info->available_in),\n+\t\t\t   m_regno_to_candidates[regno]);\n+\n+\t  /* Add registers that die in a block to the block's kill set,\n+\t     so that we don't needlessly propagate them through the rest\n+\t     of the function.  */\n+\t  if (!bitmap_bit_p (DF_LR_OUT (bb), regno))\n+\t    bitmap_ior_into (get_bitmap (&info->rd_kill),\n+\t\t\t     m_regno_to_candidates[regno]);\n+\t}\n+\n+      /* Initialize each block's rd_out to the minimal set (the set of\n+\t local definitions).  */\n+      if (!empty_p (info->rd_gen))\n+\tbitmap_copy (get_bitmap (&info->rd_out), info->rd_gen);\n+    }\n+\n+  /* Iterate until we reach a fixed point.  */\n+  er = this;\n+  bitmap_clear (&m_tmp_bitmap);\n+  bitmap_set_range (&m_tmp_bitmap, 0, last_basic_block_for_fn (m_fn));\n+  df_simple_dataflow (DF_FORWARD, NULL, NULL, rd_confluence_n, rd_transfer,\n+\t\t      &m_tmp_bitmap, df_get_postorder (DF_FORWARD),\n+\t\t      df_get_n_blocks (DF_FORWARD));\n+  er = 0;\n+\n+  /* Work out which definitions reach which candidates, again taking\n+     advantage of the candidate order.  */\n+  bitmap_head reaching;\n+  bitmap_initialize (&reaching, &m_obstack);\n+  basic_block old_bb = NULL;\n+  FOR_EACH_VEC_ELT_REVERSE (m_candidates, cand_index, cand)\n+    {\n+      bb = BLOCK_FOR_INSN (cand->insn);\n+      if (bb != old_bb)\n+\t{\n+\t  /* Get the definitions that reach the start of the new block.  */\n+\t  remat_block_info *info = &m_block_info[bb->index];\n+\t  if (info->rd_in)\n+\t    bitmap_copy (&reaching, info->rd_in);\n+\t  else\n+\t    bitmap_clear (&reaching);\n+\t  old_bb = bb;\n+\t}\n+      else\n+\t{\n+\t  /* Process the definitions of the previous instruction.  */\n+\t  bitmap kill = m_regno_to_candidates[cand[1].regno];\n+\t  bitmap_and_compl_into (&reaching, kill);\n+\t  bitmap_set_bit (&reaching, cand_index + 1);\n+\t}\n+\n+      if (cand->can_copy_p && !cand->constant_p)\n+\t{\n+\t  df_ref ref;\n+\t  FOR_EACH_INSN_USE (ref, cand->insn)\n+\t    {\n+\t      unsigned int regno = DF_REF_REGNO (ref);\n+\t      if (bitmap_bit_p (&m_candidate_regnos, regno))\n+\t\t{\n+\t\t  bitmap defs = m_regno_to_candidates[regno];\n+\t\t  bitmap_and (&m_tmp_bitmap, defs, &reaching);\n+\t\t  bitmap_ior_into (get_bitmap (&cand->uses), &m_tmp_bitmap);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  bitmap_clear (&reaching);\n+}\n+\n+/* If CAND_INDEX is in an equivalence class, return the representative\n+   of the class, otherwise return CAND_INDEX.  */\n+\n+inline unsigned int\n+early_remat::canon_candidate (unsigned int cand_index)\n+{\n+  if (remat_equiv_class *ec = m_candidates[cand_index].equiv_class)\n+    return ec->representative;\n+  return cand_index;\n+}\n+\n+/* Make candidate set *PTR refer to candidates using the representative\n+   of each equivalence class.  */\n+\n+void\n+early_remat::canon_bitmap (bitmap *ptr)\n+{\n+  bitmap old_set = *ptr;\n+  if (empty_p (old_set))\n+    return;\n+\n+  bitmap new_set = NULL;\n+  unsigned int old_index;\n+  bitmap_iterator bi;\n+  EXECUTE_IF_SET_IN_BITMAP (old_set, 0, old_index, bi)\n+    {\n+      unsigned int new_index = canon_candidate (old_index);\n+      if (old_index != new_index)\n+\t{\n+\t  if (!new_set)\n+\t    {\n+\t      new_set = alloc_bitmap ();\n+\t      bitmap_copy (new_set, old_set);\n+\t    }\n+\t  bitmap_clear_bit (new_set, old_index);\n+\t  bitmap_set_bit (new_set, new_index);\n+\t}\n+    }\n+  if (new_set)\n+    {\n+      BITMAP_FREE (*ptr);\n+      *ptr = new_set;\n+    }\n+}\n+\n+/* If the candidates in REACHING all have the same value, return the\n+   earliest instance of that value (i.e. the first one to be added\n+   to m_value_table), otherwise return MULTIPLE_CANDIDATES.  */\n+\n+unsigned int\n+early_remat::resolve_reaching_def (bitmap reaching)\n+{\n+  unsigned int cand_index = bitmap_first_set_bit (reaching);\n+  if (remat_equiv_class *ec = m_candidates[cand_index].equiv_class)\n+    {\n+      if (!bitmap_intersect_compl_p (reaching, ec->members))\n+\treturn ec->earliest;\n+    }\n+  else if (bitmap_single_bit_set_p (reaching))\n+    return cand_index;\n+\n+  return MULTIPLE_CANDIDATES;\n+}\n+\n+/* Check whether all candidate registers used by candidate CAND_INDEX have\n+   unique definitions.  Return true if so, replacing the candidate's uses\n+   set with the appropriate form for value numbering.  */\n+\n+bool\n+early_remat::check_candidate_uses (unsigned int cand_index)\n+{\n+  remat_candidate *cand = &m_candidates[cand_index];\n+\n+  /* Process the uses for each register in turn.  */\n+  bitmap_head uses;\n+  bitmap_initialize (&uses, &m_obstack);\n+  bitmap_copy (&uses, cand->uses);\n+  bitmap uses_ec = alloc_bitmap ();\n+  while (!bitmap_empty_p (&uses))\n+    {\n+      /* Get the register for the lowest-indexed candidate remaining,\n+\t and the reaching definitions of that register.  */\n+      unsigned int first = bitmap_first_set_bit (&uses);\n+      unsigned int regno = m_candidates[first].regno;\n+      bitmap_and (&m_tmp_bitmap, &uses, m_regno_to_candidates[regno]);\n+\n+      /* See whether all reaching definitions have the same value and if\n+\t so get the index of the first candidate we saw with that value.  */\n+      unsigned int def = resolve_reaching_def (&m_tmp_bitmap);\n+      if (def == MULTIPLE_CANDIDATES)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; Removing candidate %d because there is\"\n+\t\t     \" more than one reaching definition of reg %d\\n\",\n+\t\t     cand_index, regno);\n+\t  cand->can_copy_p = false;\n+\t  break;\n+\t}\n+      bitmap_set_bit (uses_ec, def);\n+      bitmap_and_compl_into (&uses, &m_tmp_bitmap);\n+    }\n+  BITMAP_FREE (cand->uses);\n+  cand->uses = uses_ec;\n+  return cand->can_copy_p;\n+}\n+\n+/* Calculate the set of hard registers that would be clobbered by\n+   rematerializing candidate CAND_INDEX.  At this point the candidate's\n+   set of uses is final.  */\n+\n+void\n+early_remat::compute_clobbers (unsigned int cand_index)\n+{\n+  remat_candidate *cand = &m_candidates[cand_index];\n+  if (cand->uses)\n+    {\n+      unsigned int use_index;\n+      bitmap_iterator bi;\n+      EXECUTE_IF_SET_IN_BITMAP (cand->uses, 0, use_index, bi)\n+\tif (bitmap clobbers = m_candidates[use_index].clobbers)\n+\t  bitmap_ior_into (get_bitmap (&cand->clobbers), clobbers);\n+    }\n+\n+  df_ref ref;\n+  FOR_EACH_INSN_DEF (ref, cand->insn)\n+    {\n+      unsigned int def_regno = DF_REF_REGNO (ref);\n+      if (def_regno != cand->regno)\n+\tbitmap_set_bit (get_bitmap (&cand->clobbers), def_regno);\n+    }\n+}\n+\n+/* Mark candidate CAND_INDEX as validated and add it to the value table.  */\n+\n+void\n+early_remat::assign_value_number (unsigned int cand_index)\n+{\n+  remat_candidate *cand = &m_candidates[cand_index];\n+  gcc_checking_assert (cand->can_copy_p && !cand->validated_p);\n+\n+  compute_clobbers (cand_index);\n+  cand->validated_p = true;\n+\n+  inchash::hash h;\n+  h.add_int (cand->regno);\n+  inchash::add_rtx (cand->remat_rtx, h);\n+  cand->hash = h.end ();\n+\n+  remat_candidate **slot\n+    = m_value_table.find_slot_with_hash (cand, cand->hash, INSERT);\n+  if (!*slot)\n+    {\n+      *slot = cand;\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Candidate %d is not equivalent to\"\n+\t\t \" others seen so far\\n\", cand_index);\n+    }\n+  else\n+    record_equiv_candidates (*slot - m_candidates.address (), cand_index);\n+}\n+\n+/* Make a final decision about which candidates are valid and assign\n+   value numbers to those that are.  */\n+\n+void\n+early_remat::decide_candidate_validity (void)\n+{\n+  auto_vec<unsigned int, 16> stack;\n+  unsigned int cand1_index;\n+  remat_candidate *cand1;\n+  FOR_EACH_VEC_ELT_REVERSE (m_candidates, cand1_index, cand1)\n+    {\n+      if (!cand1->can_copy_p || cand1->validated_p)\n+\tcontinue;\n+\n+      if (empty_p (cand1->uses))\n+\t{\n+\t  assign_value_number (cand1_index);\n+\t  continue;\n+\t}\n+\n+      stack.safe_push (cand1_index);\n+      while (!stack.is_empty ())\n+\t{\n+\t  unsigned int cand2_index = stack.last ();\n+\t  unsigned int watermark = stack.length ();\n+\t  remat_candidate *cand2 = &m_candidates[cand2_index];\n+\t  if (!cand2->can_copy_p || cand2->validated_p)\n+\t    {\n+\t      stack.pop ();\n+\t      continue;\n+\t    }\n+\t  cand2->visited_p = true;\n+\t  unsigned int cand3_index;\n+\t  bitmap_iterator bi;\n+\t  EXECUTE_IF_SET_IN_BITMAP (cand2->uses, 0, cand3_index, bi)\n+\t    {\n+\t      remat_candidate *cand3 = &m_candidates[cand3_index];\n+\t      if (!cand3->can_copy_p)\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \";; Removing candidate %d because\"\n+\t\t\t     \" it uses removed candidate %d\\n\", cand2_index,\n+\t\t\t     cand3_index);\n+\t\t  cand2->can_copy_p = false;\n+\t\t  break;\n+\t\t}\n+\t      if (!cand3->validated_p)\n+\t\t{\n+\t\t  if (empty_p (cand3->uses))\n+\t\t    assign_value_number (cand3_index);\n+\t\t  else if (cand3->visited_p)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \";; Removing candidate %d\"\n+\t\t\t\t \" because its definition is cyclic\\n\",\n+\t\t\t\t cand2_index);\n+\t\t      cand2->can_copy_p = false;\n+\t\t      break;\n+\t\t    }\n+\t\t  else\n+\t\t    stack.safe_push (cand3_index);\n+\t\t}\n+\t    }\n+\t  if (!cand2->can_copy_p)\n+\t    {\n+\t      cand2->visited_p = false;\n+\t      stack.truncate (watermark - 1);\n+\t    }\n+\t  else if (watermark == stack.length ())\n+\t    {\n+\t      cand2->visited_p = false;\n+\t      if (check_candidate_uses (cand2_index))\n+\t\tassign_value_number (cand2_index);\n+\t      stack.pop ();\n+\t    }\n+\t}\n+    }\n+\n+  /* Ensure that the candidates always use the same candidate index\n+     to refer to an equivalence class.  */\n+  FOR_EACH_VEC_ELT_REVERSE (m_candidates, cand1_index, cand1)\n+    if (cand1->can_copy_p && !empty_p (cand1->uses))\n+      {\n+\tcanon_bitmap (&cand1->uses);\n+\tgcc_checking_assert (bitmap_first_set_bit (cand1->uses) > cand1_index);\n+      }\n+}\n+\n+/* Assuming that every path reaching a point P contains a copy of a\n+   use U of REGNO, return true if another copy of U at P would have\n+   access to the same value of REGNO.  */\n+\n+bool\n+early_remat::stable_use_p (unsigned int regno)\n+{\n+  /* Conservatively assume not for hard registers.  */\n+  if (HARD_REGISTER_NUM_P (regno))\n+    return false;\n+\n+  /* See if REGNO has a single definition and is never used uninitialized.\n+     In this case the definition of REGNO dominates the common dominator\n+     of the uses U, which in turn dominates P.  */\n+  if (DF_REG_DEF_COUNT (regno) == 1\n+      && !bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR_FOR_FN (m_fn)), regno))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Emit a copy from register DEST to register SRC before candidate\n+   CAND_INDEX's instruction.  */\n+\n+void\n+early_remat::emit_copy_before (unsigned int cand_index, rtx dest, rtx src)\n+{\n+  remat_candidate *cand = &m_candidates[cand_index];\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \";; Stabilizing insn \");\n+      dump_insn_id (cand->insn);\n+      fprintf (dump_file, \" by copying source reg %d:%s to temporary reg %d\\n\",\n+\t       REGNO (src), GET_MODE_NAME (GET_MODE (src)), REGNO (dest));\n+    }\n+  emit_insn_before (gen_move_insn (dest, src), cand->insn);\n+}\n+\n+/* Check whether any inputs to candidate CAND_INDEX's instruction could\n+   change at rematerialization points and replace them with new pseudo\n+   registers if so.  */\n+\n+void\n+early_remat::stabilize_pattern (unsigned int cand_index)\n+{\n+  remat_candidate *cand = &m_candidates[cand_index];\n+  if (cand->stabilized_p)\n+    return;\n+\n+  remat_equiv_class *ec = cand->equiv_class;\n+  gcc_checking_assert (!ec || cand_index == ec->representative);\n+\n+  /* Record the replacements we've made so far, so that we don't\n+     create two separate registers for match_dups.  Lookup is O(n),\n+     but the n is very small.  */\n+  typedef std::pair<rtx, rtx> reg_pair;\n+  auto_vec<reg_pair, 16> reg_map;\n+\n+  rtx_insn *insn = cand->insn;\n+  df_ref ref;\n+  FOR_EACH_INSN_USE (ref, insn)\n+    {\n+      unsigned int old_regno = DF_REF_REGNO (ref);\n+      rtx *loc = DF_REF_REAL_LOC (ref);\n+\n+      if (HARD_REGISTER_NUM_P (old_regno) && fixed_regs[old_regno])\n+\t{\n+\t  /* We checked when adding the candidate that the value is stable.  */\n+\t  gcc_checking_assert (!rtx_unstable_p (*loc));\n+\t  continue;\n+\t}\n+\n+      if (bitmap_bit_p (&m_candidate_regnos, old_regno))\n+\t/* We already know which candidate provides the definition\n+\t   and will handle it during copying.  */\n+\tcontinue;\n+\n+      if (stable_use_p (old_regno))\n+\t/* We can continue to use the existing register.  */\n+\tcontinue;\n+\n+      /* We need to replace the register.  See whether we've already\n+\t created a suitable copy.  */\n+      rtx old_reg = *loc;\n+      rtx new_reg = NULL_RTX;\n+      machine_mode mode = GET_MODE (old_reg);\n+      reg_pair *p;\n+      unsigned int pi;\n+      FOR_EACH_VEC_ELT (reg_map, pi, p)\n+\tif (REGNO (p->first) == old_regno\n+\t    && GET_MODE (p->first) == mode)\n+\t  {\n+\t    new_reg = p->second;\n+\t    break;\n+\t  }\n+\n+      if (!new_reg)\n+\t{\n+\t  /* Create a new register and initialize it just before\n+\t     the instruction.  */\n+\t  new_reg = gen_reg_rtx (mode);\n+\t  reg_map.safe_push (reg_pair (old_reg, new_reg));\n+\t  if (ec)\n+\t    {\n+\t      unsigned int member_index;\n+\t      bitmap_iterator bi;\n+\t      EXECUTE_IF_SET_IN_BITMAP (ec->members, 0, member_index, bi)\n+\t\temit_copy_before (member_index, new_reg, old_reg);\n+\t    }\n+\t  else\n+\t    emit_copy_before (cand_index, new_reg, old_reg);\n+\t}\n+      validate_change (insn, loc, new_reg, true);\n+    }\n+  if (num_changes_pending ())\n+    {\n+      if (!apply_change_group ())\n+\t/* We checked when adding the candidates that the pattern allows\n+\t   hard registers to be replaced.  Nothing else should make the\n+\t   changes invalid.  */\n+\tgcc_unreachable ();\n+\n+      if (ec)\n+\t{\n+\t  /* Copy the new pattern to other members of the equivalence\n+\t     class.  */\n+\t  unsigned int member_index;\n+\t  bitmap_iterator bi;\n+\t  EXECUTE_IF_SET_IN_BITMAP (ec->members, 0, member_index, bi)\n+\t    if (cand_index != member_index)\n+\t      {\n+\t\trtx_insn *other_insn = m_candidates[member_index].insn;\n+\t\tif (!validate_change (other_insn, &PATTERN (other_insn),\n+\t\t\t\t      copy_insn (PATTERN (insn)), 0))\n+\t\t  /* If the original instruction was valid then the copy\n+\t\t     should be too.  */\n+\t\t  gcc_unreachable ();\n+\t      }\n+\t}\n+    }\n+\n+  cand->stabilized_p = true;\n+}\n+\n+/* Change CAND's instruction so that it sets CAND->copy_regno instead\n+   of CAND->regno.  */\n+\n+void\n+early_remat::replace_dest_with_copy (unsigned int cand_index)\n+{\n+  remat_candidate *cand = &m_candidates[cand_index];\n+  df_ref def;\n+  FOR_EACH_INSN_DEF (def, cand->insn)\n+    if (DF_REF_REGNO (def) == cand->regno)\n+      validate_change (cand->insn, DF_REF_REAL_LOC (def),\n+\t\t       regno_reg_rtx[cand->copy_regno], 1);\n+}\n+\n+/* Make sure that the candidates used by candidate CAND_INDEX are available.\n+   There are two ways of doing this for an input candidate I:\n+\n+   (1) Using the existing register number and ensuring that I is available.\n+\n+   (2) Using a new register number (recorded in copy_regno) and adding I\n+       to VIA_COPY.  This guarantees that making I available does not\n+       conflict with other uses of the original register.\n+\n+   REQUIRED is the set of candidates that are required but not available\n+   before the copy of CAND_INDEX.  AVAILABLE is the set of candidates\n+   that are already available before the copy of CAND_INDEX.  REACHING\n+   is the set of candidates that reach the copy of CAND_INDEX.  VIA_COPY\n+   is the set of candidates that will use new register numbers recorded\n+   in copy_regno instead of the original ones.  */\n+\n+void\n+early_remat::stabilize_candidate_uses (unsigned int cand_index,\n+\t\t\t\t       bitmap required, bitmap available,\n+\t\t\t\t       bitmap reaching, bitmap via_copy)\n+{\n+  remat_candidate *cand = &m_candidates[cand_index];\n+  df_ref use;\n+  FOR_EACH_INSN_USE (use, cand->insn)\n+    {\n+      unsigned int regno = DF_REF_REGNO (use);\n+      if (!bitmap_bit_p (&m_candidate_regnos, regno))\n+\tcontinue;\n+\n+      /* Work out which candidate provides the definition.  */\n+      bitmap defs = m_regno_to_candidates[regno];\n+      bitmap_and (&m_tmp_bitmap, cand->uses, defs);\n+      gcc_checking_assert (bitmap_single_bit_set_p (&m_tmp_bitmap));\n+      unsigned int def_index = bitmap_first_set_bit (&m_tmp_bitmap);\n+\n+      /* First see if DEF_INDEX is the only reaching definition of REGNO\n+\t at this point too and if it is or will become available.  We can\n+\t continue to use REGNO if so.  */\n+      bitmap_and (&m_tmp_bitmap, reaching, defs);\n+      if (bitmap_single_bit_set_p (&m_tmp_bitmap)\n+\t  && bitmap_first_set_bit (&m_tmp_bitmap) == def_index\n+\t  && ((available && bitmap_bit_p (available, def_index))\n+\t      || bitmap_bit_p (required, def_index)))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; Keeping reg %d for use of candidate %d\"\n+\t\t     \" in candidate %d\\n\", regno, def_index, cand_index);\n+\t  continue;\n+\t}\n+\n+      /* Otherwise fall back to using a copy.  There are other cases\n+\t in which we *could* continue to use REGNO, but there's not\n+\t really much point.  Using a separate register ought to make\n+\t things easier for the register allocator.  */\n+      remat_candidate *def_cand = &m_candidates[def_index];\n+      rtx *loc = DF_REF_REAL_LOC (use);\n+      rtx new_reg;\n+      if (bitmap_set_bit (via_copy, def_index))\n+\t{\n+\t  new_reg = gen_reg_rtx (GET_MODE (*loc));\n+\t  def_cand->copy_regno = REGNO (new_reg);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; Creating reg %d for use of candidate %d\"\n+\t\t     \" in candidate %d\\n\", REGNO (new_reg), def_index,\n+\t\t     cand_index);\n+\t}\n+      else\n+\tnew_reg = regno_reg_rtx[def_cand->copy_regno];\n+      validate_change (cand->insn, loc, new_reg, 1);\n+    }\n+}\n+\n+/* Rematerialize the candidates in REQUIRED after instruction INSN,\n+   given that the candidates in AVAILABLE are already available\n+   and that REACHING is the set of candidates live after INSN.\n+   REQUIRED and AVAILABLE are disjoint on entry.\n+\n+   Clear REQUIRED on exit.  */\n+\n+void\n+early_remat::emit_remat_insns (bitmap required, bitmap available,\n+\t\t\t       bitmap reaching, rtx_insn *insn)\n+{\n+  /* Quick exit if there's nothing to do.  */\n+  if (empty_p (required))\n+    return;\n+\n+  /* Only reaching definitions should be available or required.  */\n+  gcc_checking_assert (!bitmap_intersect_compl_p (required, reaching));\n+  if (available)\n+    gcc_checking_assert (!bitmap_intersect_compl_p (available, reaching));\n+\n+  bitmap_head via_copy;\n+  bitmap_initialize (&via_copy, &m_obstack);\n+  while (!bitmap_empty_p (required) || !bitmap_empty_p (&via_copy))\n+    {\n+      /* Pick the lowest-indexed candidate left.  */\n+      unsigned int required_index = (bitmap_empty_p (required)\n+\t\t\t\t     ? ~0U : bitmap_first_set_bit (required));\n+      unsigned int via_copy_index = (bitmap_empty_p (&via_copy)\n+\t\t\t\t     ? ~0U : bitmap_first_set_bit (&via_copy));\n+      unsigned int cand_index = MIN (required_index, via_copy_index);\n+      remat_candidate *cand = &m_candidates[cand_index];\n+\n+      bool via_copy_p = (cand_index == via_copy_index);\n+      if (via_copy_p)\n+\tbitmap_clear_bit (&via_copy, cand_index);\n+      else\n+\t{\n+\t  /* Remove all candidates for the same register from REQUIRED.  */\n+\t  bitmap_and (&m_tmp_bitmap, reaching,\n+\t\t      m_regno_to_candidates[cand->regno]);\n+\t  bitmap_and_compl_into (required, &m_tmp_bitmap);\n+\t  gcc_checking_assert (!bitmap_bit_p (required, cand_index));\n+\n+\t  /* Only rematerialize if we have a single reaching definition\n+\t     of the register.  */\n+\t  if (!bitmap_single_bit_set_p (&m_tmp_bitmap))\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \";; Can't rematerialize reg %d after \",\n+\t\t\t   cand->regno);\n+\t\t  dump_insn_id (insn);\n+\t\t  fprintf (dump_file, \": more than one reaching definition\\n\");\n+\t\t}\n+\t      continue;\n+\t    }\n+\n+\t  /* Skip candidates that can't be rematerialized.  */\n+\t  if (!cand->can_copy_p)\n+\t    continue;\n+\n+\t  /* Check the function precondition.  */\n+\t  gcc_checking_assert (!available\n+\t\t\t       || !bitmap_bit_p (available, cand_index));\n+\t}\n+\n+      /* Invalid candidates should have been weeded out by now.  */\n+      gcc_assert (cand->can_copy_p);\n+\n+      rtx new_pattern;\n+      if (cand->constant_p)\n+\t{\n+\t  /* Emit a simple move.  */\n+\t  unsigned int regno = via_copy_p ? cand->copy_regno : cand->regno;\n+\t  new_pattern = gen_move_insn (regno_reg_rtx[regno], cand->remat_rtx);\n+\t}\n+      else\n+\t{\n+\t  /* If this is the first time we've copied the instruction, make\n+\t     sure that any inputs will have the same value after INSN.  */\n+\t  stabilize_pattern (cand_index);\n+\n+\t  /* Temporarily adjust the original instruction so that it has\n+\t     the right form for the copy.  */\n+\t  if (via_copy_p)\n+\t    replace_dest_with_copy (cand_index);\n+\t  if (cand->uses)\n+\t    stabilize_candidate_uses (cand_index, required, available,\n+\t\t\t\t      reaching, &via_copy);\n+\n+\t  /* Get the new instruction pattern.  */\n+\t  new_pattern = copy_insn (cand->remat_rtx);\n+\n+\t  /* Undo the temporary changes.  */\n+\t  cancel_changes (0);\n+\t}\n+\n+      /* Emit the new instruction.  */\n+      rtx_insn *new_insn = emit_insn_after (new_pattern, insn);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \";; Rematerializing candidate %d after \",\n+\t\t   cand_index);\n+\t  dump_insn_id (insn);\n+\t  if (via_copy_p)\n+\t    fprintf (dump_file, \" with new destination reg %d\",\n+\t\t     cand->copy_regno);\n+\t  fprintf (dump_file, \":\\n\\n\");\n+\t  print_rtl_single (dump_file, new_insn);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+    }\n+}\n+\n+/* Recompute INFO's available_out set, given that it's distinct from\n+   available_in and available_locally.  */\n+\n+bool\n+early_remat::set_available_out (remat_block_info *info)\n+{\n+  if (empty_p (info->available_locally))\n+    return bitmap_and_compl (get_bitmap (&info->available_out),\n+\t\t\t     info->available_in, info->rd_kill);\n+\n+  if (empty_p (info->rd_kill))\n+    return bitmap_ior (get_bitmap (&info->available_out),\n+\t\t       info->available_locally, info->available_in);\n+\n+  return bitmap_ior_and_compl (get_bitmap (&info->available_out),\n+\t\t\t       info->available_locally, info->available_in,\n+\t\t\t       info->rd_kill);\n+}\n+\n+/* If BB has more than one call, decide which candidates should be\n+   rematerialized after the non-final calls and emit the associated\n+   instructions.  Record other information about the block in preparation\n+   for the global phase.  */\n+\n+void\n+early_remat::process_block (basic_block bb)\n+{\n+  remat_block_info *info = &m_block_info[bb->index];\n+  rtx_insn *last_call = NULL;\n+  rtx_insn *insn;\n+\n+  /* Ensure that we always use the same candidate index to refer to an\n+     equivalence class.  */\n+  if (info->rd_out == info->rd_in)\n+    {\n+      canon_bitmap (&info->rd_in);\n+      info->rd_out = info->rd_in;\n+    }\n+  else\n+    {\n+      canon_bitmap (&info->rd_in);\n+      canon_bitmap (&info->rd_out);\n+    }\n+  canon_bitmap (&info->rd_kill);\n+  canon_bitmap (&info->rd_gen);\n+\n+  /* The set of candidates that should be rematerialized on entry to the\n+     block or after the previous call (whichever is more recent).  */\n+  init_temp_bitmap (&m_required);\n+\n+  /* The set of candidates that reach the current instruction (i.e. are\n+     live just before the instruction).  */\n+  bitmap_head reaching;\n+  bitmap_initialize (&reaching, &m_obstack);\n+  if (info->rd_in)\n+    bitmap_copy (&reaching, info->rd_in);\n+\n+  /* The set of candidates that are live and available without\n+     rematerialization just before the current instruction.  This only\n+     accounts for earlier candidates in the block, or those that become\n+     available by being added to M_REQUIRED.  */\n+  init_temp_bitmap (&m_available);\n+\n+  /* Get the range of candidates in the block.  */\n+  unsigned int next_candidate = info->first_candidate;\n+  unsigned int num_candidates = info->num_candidates;\n+  remat_candidate *next_def = (num_candidates > 0\n+\t\t\t       ? &m_candidates[next_candidate]\n+\t\t\t       : NULL);\n+\n+  FOR_BB_INSNS (bb, insn)\n+    {\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+\n+      /* First process uses, since this is a forward walk.  */\n+      df_ref ref;\n+      FOR_EACH_INSN_USE (ref, insn)\n+\t{\n+\t  unsigned int regno = DF_REF_REGNO (ref);\n+\t  if (bitmap_bit_p (&m_candidate_regnos, regno))\n+\t    {\n+\t      bitmap defs = m_regno_to_candidates[regno];\n+\t      bitmap_and (&m_tmp_bitmap, defs, &reaching);\n+\t      gcc_checking_assert (!bitmap_empty_p (&m_tmp_bitmap));\n+\t      if (!bitmap_intersect_p (defs, m_available))\n+\t\t{\n+\t\t  /* There has been no definition of the register since\n+\t\t     the last call or the start of the block (whichever\n+\t\t     is most recent).  Mark the reaching definitions\n+\t\t     as required at that point and thus available here.  */\n+\t\t  bitmap_ior_into (m_required, &m_tmp_bitmap);\n+\t\t  bitmap_ior_into (m_available, &m_tmp_bitmap);\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (CALL_P (insn))\n+\t{\n+\t  if (!last_call)\n+\t    {\n+\t      /* The first call in the block.  Record which candidates are\n+\t\t required at the start of the block.  */\n+\t      copy_temp_bitmap (&info->required_in, &m_required);\n+\t      init_temp_bitmap (&m_required);\n+\t    }\n+\t  else\n+\t    /* The fully-local case: candidates that need to be\n+\t       rematerialized after a previous call in the block.  */\n+\t    emit_remat_insns (m_required, NULL, info->rd_after_call,\n+\t\t\t      last_call);\n+\t  last_call = insn;\n+\t  bitmap_clear (m_available);\n+\t  gcc_checking_assert (empty_p (m_required));\n+\t}\n+\n+      /* Now process definitions.  */\n+      if (next_def && insn == next_def->insn)\n+\t{\n+\t  unsigned int gen = canon_candidate (next_candidate);\n+\n+\t  /* Other candidates with the same regno are not available\n+\t     any more.  */\n+\t  bitmap kill = m_regno_to_candidates[next_def->regno];\n+\t  bitmap_and_compl_into (m_available, kill);\n+\t  bitmap_and_compl_into (&reaching, kill);\n+\n+\t  /* Record that this candidate is available without\n+\t     rematerialization.  */\n+\t  bitmap_set_bit (m_available, gen);\n+\t  bitmap_set_bit (&reaching, gen);\n+\n+\t  /* Find the next candidate in the block.  */\n+\t  num_candidates -= 1;\n+\t  next_candidate -= 1;\n+\t  if (num_candidates > 0)\n+\t    next_def -= 1;\n+\t  else\n+\t    next_def = NULL;\n+\t}\n+\n+      if (insn == last_call)\n+\tbitmap_copy (get_bitmap (&info->rd_after_call), &reaching);\n+    }\n+  bitmap_clear (&reaching);\n+  gcc_checking_assert (num_candidates == 0);\n+\n+  /* Remove values from the available set if they aren't live (and so\n+     aren't interesting to successor blocks).  */\n+  if (info->rd_out)\n+    bitmap_and_into (m_available, info->rd_out);\n+\n+  /* Record the accumulated information.  */\n+  info->last_call = last_call;\n+  info->abnormal_call_p = (last_call\n+\t\t\t   && last_call == BB_END (bb)\n+\t\t\t   && has_abnormal_or_eh_outgoing_edge_p (bb));\n+  copy_temp_bitmap (&info->available_locally, &m_available);\n+  if (last_call)\n+    copy_temp_bitmap (&info->required_after_call, &m_required);\n+  else\n+    copy_temp_bitmap (&info->required_in, &m_required);\n+\n+  /* Assume at first that all live-in values are available without\n+     rematerialization (i.e. start with the most optimistic assumption).  */\n+  if (info->available_in)\n+    {\n+      if (info->rd_in)\n+\tbitmap_copy (info->available_in, info->rd_in);\n+      else\n+\tBITMAP_FREE (info->available_in);\n+    }\n+\n+  if (last_call || empty_p (info->available_in))\n+    /* The values available on exit from the block are exactly those that\n+       are available locally.  This set doesn't change.  */\n+    info->available_out = info->available_locally;\n+  else if (empty_p (info->available_locally) && empty_p (info->rd_kill))\n+    /* The values available on exit are the same as those available on entry.\n+       Updating one updates the other.  */\n+    info->available_out = info->available_in;\n+  else\n+    set_available_out (info);\n+}\n+\n+/* Process each block as for process_block, visiting dominators before\n+   the blocks they dominate.  */\n+\n+void\n+early_remat::local_phase (void)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n;; Local phase:\\n\");\n+\n+  int *postorder = df_get_postorder (DF_BACKWARD);\n+  unsigned int postorder_len = df_get_n_blocks (DF_BACKWARD);\n+  for (unsigned int i = postorder_len; i-- > 0; )\n+    if (postorder[i] >= NUM_FIXED_BLOCKS)\n+      process_block (BASIC_BLOCK_FOR_FN (m_fn, postorder[i]));\n+}\n+\n+/* Return true if available values survive across edge E.  */\n+\n+static inline bool\n+available_across_edge_p (edge e)\n+{\n+  return (e->flags & EDGE_EH) == 0;\n+}\n+\n+/* Propagate information from the available_out set of E->src to the\n+   available_in set of E->dest, when computing global availability.\n+   Return true if something changed.  */\n+\n+bool\n+early_remat::avail_confluence_n (edge e)\n+{\n+  remat_block_info *src = &er->m_block_info[e->src->index];\n+  remat_block_info *dest = &er->m_block_info[e->dest->index];\n+\n+  if (!available_across_edge_p (e))\n+    return false;\n+\n+  if (empty_p (dest->available_in))\n+    return false;\n+\n+  if (!src->available_out)\n+    {\n+      bitmap_clear (dest->available_in);\n+      return true;\n+    }\n+\n+  return bitmap_and_into (dest->available_in, src->available_out);\n+}\n+\n+/* Propagate information from the available_in set of block BB_INDEX\n+   to available_out.  Return true if something changed.  */\n+\n+bool\n+early_remat::avail_transfer (int bb_index)\n+{\n+  remat_block_info *info = &er->m_block_info[bb_index];\n+\n+  if (info->available_out == info->available_locally)\n+    return false;\n+\n+  if (info->available_out == info->available_in)\n+    /* Assume that we are only called if the input changed.  */\n+    return true;\n+\n+  return er->set_available_out (info);\n+}\n+\n+/* Compute global availability for the function, starting with the local\n+   information computed by local_phase.  */\n+\n+void\n+early_remat::compute_availability (void)\n+{\n+  /* We use df_simple_dataflow instead of the lcm routines for three reasons:\n+\n+     (1) it avoids recomputing the traversal order;\n+     (2) many of the sets are likely to be sparse, so we don't necessarily\n+\t want to use sbitmaps; and\n+     (3) it means we can avoid creating an explicit kill set for the call.  */\n+  er = this;\n+  bitmap_clear (&m_tmp_bitmap);\n+  bitmap_set_range (&m_tmp_bitmap, 0, last_basic_block_for_fn (m_fn));\n+  df_simple_dataflow (DF_FORWARD, NULL, NULL,\n+\t\t      avail_confluence_n, avail_transfer,\n+\t\t      &m_tmp_bitmap, df_get_postorder (DF_FORWARD),\n+\t\t      df_get_n_blocks (DF_FORWARD));\n+  er = 0;\n+\n+  /* Restrict the required_in sets to values that aren't available.  */\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, m_fn)\n+    {\n+      remat_block_info *info = &m_block_info[bb->index];\n+      if (info->required_in && info->available_in)\n+\tbitmap_and_compl_into (info->required_in, info->available_in);\n+    }\n+}\n+\n+/* Make sure that INFO's available_out and available_in sets are unique.  */\n+\n+inline void\n+early_remat::unshare_available_sets (remat_block_info *info)\n+{\n+  if (info->available_in && info->available_in == info->available_out)\n+    {\n+      info->available_in = alloc_bitmap ();\n+      bitmap_copy (info->available_in, info->available_out);\n+    }\n+}\n+\n+/* Return true if it is possible to move rematerializations from the\n+   destination of E to the source of E.  */\n+\n+inline bool\n+early_remat::can_move_across_edge_p (edge e)\n+{\n+  return (available_across_edge_p (e)\n+\t  && !m_block_info[e->src->index].abnormal_call_p);\n+}\n+\n+/* Return true if it is cheaper to rematerialize values at the head of\n+   block QUERY_BB_INDEX instead of rematerializing in its predecessors.  */\n+\n+bool\n+early_remat::local_remat_cheaper_p (unsigned int query_bb_index)\n+{\n+  if (m_block_info[query_bb_index].remat_frequency_valid_p)\n+    return m_block_info[query_bb_index].local_remat_cheaper_p;\n+\n+  /* Iteratively compute the cost of rematerializing values in the\n+     predecessor blocks, then compare that with the cost of\n+     rematerializing at the head of the block.\n+\n+     A cycle indicates that there is no call on that execution path,\n+     so it isn't necessary to rematerialize on that path.  */\n+  auto_vec<basic_block, 16> stack;\n+  stack.quick_push (BASIC_BLOCK_FOR_FN (m_fn, query_bb_index));\n+  while (!stack.is_empty ())\n+    {\n+      basic_block bb = stack.last ();\n+      remat_block_info *info = &m_block_info[bb->index];\n+      if (info->remat_frequency_valid_p)\n+\t{\n+\t  stack.pop ();\n+\t  continue;\n+\t}\n+\n+      info->visited_p = true;\n+      int frequency = 0;\n+      bool can_move_p = true;\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tif (!can_move_across_edge_p (e))\n+\t  {\n+\t    can_move_p = false;\n+\t    break;\n+\t  }\n+\telse if (m_block_info[e->src->index].last_call)\n+\t  /* We'll rematerialize after the call.  */\n+\t  frequency += e->src->count.to_frequency (m_fn);\n+\telse if (m_block_info[e->src->index].remat_frequency_valid_p)\n+\t  /* Add the cost of rematerializing at the head of E->src\n+\t     or in its predecessors (whichever is cheaper).  */\n+\t  frequency += m_block_info[e->src->index].remat_frequency;\n+\telse if (!m_block_info[e->src->index].visited_p)\n+\t  /* Queue E->src and then revisit this block again.  */\n+\t  stack.safe_push (e->src);\n+\n+      /* Come back to this block later if we need to process some of\n+\t its predecessors.  */\n+      if (stack.last () != bb)\n+\tcontinue;\n+\n+      /* If rematerializing in and before the block have equal cost, prefer\n+\t rematerializing in the block.  This should shorten the live range.  */\n+      int bb_frequency = bb->count.to_frequency (m_fn);\n+      if (!can_move_p || frequency >= bb_frequency)\n+\t{\n+\t  info->local_remat_cheaper_p = true;\n+\t  info->remat_frequency = bb_frequency;\n+\t}\n+      else\n+\tinfo->remat_frequency = frequency;\n+      info->remat_frequency_valid_p = true;\n+      info->visited_p = false;\n+      if (dump_file)\n+\t{\n+\t  if (!can_move_p)\n+\t    fprintf (dump_file, \";; Need to rematerialize at the head of\"\n+\t\t     \" block %d; cannot move to predecessors.\\n\", bb->index);\n+\t  else\n+\t    {\n+\t      fprintf (dump_file, \";; Block %d has frequency %d,\"\n+\t\t       \" rematerializing in predecessors has frequency %d\",\n+\t\t       bb->index, bb_frequency, frequency);\n+\t      if (info->local_remat_cheaper_p)\n+\t\tfprintf (dump_file, \"; prefer to rematerialize\"\n+\t\t\t \" in the block\\n\");\n+\t      else\n+\t\tfprintf (dump_file, \"; prefer to rematerialize\"\n+\t\t\t \" in predecessors\\n\");\n+\t    }\n+\t}\n+      stack.pop ();\n+    }\n+  return m_block_info[query_bb_index].local_remat_cheaper_p;\n+}\n+\n+/* Return true if we cannot rematerialize candidate CAND_INDEX at the head of\n+   block BB_INDEX.  */\n+\n+bool\n+early_remat::need_to_move_candidate_p (unsigned int bb_index,\n+\t\t\t\t       unsigned int cand_index)\n+{\n+  remat_block_info *info = &m_block_info[bb_index];\n+  remat_candidate *cand = &m_candidates[cand_index];\n+  basic_block bb = BASIC_BLOCK_FOR_FN (m_fn, bb_index);\n+\n+  /* If there is more than one reaching definition of REGNO,\n+     we'll need to rematerialize in predecessors instead.  */\n+  bitmap_and (&m_tmp_bitmap, info->rd_in, m_regno_to_candidates[cand->regno]);\n+  if (!bitmap_single_bit_set_p (&m_tmp_bitmap))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Cannot rematerialize %d at the\"\n+\t\t \" head of block %d because there is more than one\"\n+\t\t \" reaching definition of reg %d\\n\", cand_index,\n+\t\t bb_index, cand->regno);\n+      return true;\n+    }\n+\n+  /* Likewise if rematerializing CAND here would clobber a live register.  */\n+  if (cand->clobbers\n+      && bitmap_intersect_p (cand->clobbers, DF_LR_IN (bb)))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \";; Cannot rematerialize %d at the\"\n+\t\t \" head of block %d because it would clobber live\"\n+\t\t \" registers\\n\", cand_index, bb_index);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Set REQUIRED to the minimum set of candidates that must be rematerialized\n+   in predecessors of block BB_INDEX instead of at the start of the block.  */\n+\n+void\n+early_remat::compute_minimum_move_set (unsigned int bb_index,\n+\t\t\t\t       bitmap required)\n+{\n+  remat_block_info *info = &m_block_info[bb_index];\n+  bitmap_head remaining;\n+\n+  bitmap_clear (required);\n+  bitmap_initialize (&remaining, &m_obstack);\n+  bitmap_copy (&remaining, info->required_in);\n+  while (!bitmap_empty_p (&remaining))\n+    {\n+      unsigned int cand_index = bitmap_first_set_bit (&remaining);\n+      remat_candidate *cand = &m_candidates[cand_index];\n+      bitmap_clear_bit (&remaining, cand_index);\n+\n+      /* Leave invalid candidates where they are.  */\n+      if (!cand->can_copy_p)\n+\tcontinue;\n+\n+      /* Decide whether to move this candidate.  */\n+      if (!bitmap_bit_p (required, cand_index))\n+\t{\n+\t  if (!need_to_move_candidate_p (bb_index, cand_index))\n+\t    continue;\n+\t  bitmap_set_bit (required, cand_index);\n+\t}\n+\n+      /* Also move values used by the candidate, so that we don't\n+\t rematerialize them twice.  */\n+      if (cand->uses)\n+\t{\n+\t  bitmap_ior_and_into (required, cand->uses, info->required_in);\n+\t  bitmap_ior_and_into (&remaining, cand->uses, info->required_in);\n+\t}\n+    }\n+}\n+\n+/* Make the predecessors of BB_INDEX rematerialize the candidates in\n+   REQUIRED.  Add any blocks whose required_in set changes to\n+   PENDING_BLOCKS.  */\n+\n+void\n+early_remat::move_to_predecessors (unsigned int bb_index, bitmap required,\n+\t\t\t\t   bitmap pending_blocks)\n+{\n+  if (empty_p (required))\n+    return;\n+  remat_block_info *dest_info = &m_block_info[bb_index];\n+  basic_block bb = BASIC_BLOCK_FOR_FN (m_fn, bb_index);\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      remat_block_info *src_info = &m_block_info[e->src->index];\n+\n+      /* Restrict the set we add to the reaching definitions.  */\n+      bitmap_and (&m_tmp_bitmap, required, src_info->rd_out);\n+      if (bitmap_empty_p (&m_tmp_bitmap))\n+\tcontinue;\n+\n+      if (!can_move_across_edge_p (e))\n+\t{\n+\t  /* We can't move the rematerialization and we can't do it at\n+\t     the start of the block either.  In this case we just give up\n+\t     and rely on spilling to make the values available across E.  */\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \";; Cannot rematerialize the following\"\n+\t\t       \" candidates in block %d:\", e->src->index);\n+\t      dump_candidate_bitmap (required);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  continue;\n+\t}\n+\n+      /* Remove candidates that are already available.  */\n+      if (src_info->available_out)\n+\t{\n+\t  bitmap_and_compl_into (&m_tmp_bitmap, src_info->available_out);\n+\t  if (bitmap_empty_p (&m_tmp_bitmap))\n+\t    continue;\n+\t}\n+\n+      /* Add the remaining candidates to the appropriate required set.  */\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \";; Moving this set from block %d\"\n+\t\t   \" to block %d:\", bb_index, e->src->index);\n+\t  dump_candidate_bitmap (&m_tmp_bitmap);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      /* If the source block contains a call, we want to rematerialize\n+\t after the call, otherwise we want to rematerialize at the start\n+\t of the block.  */\n+      bitmap src_required = get_bitmap (src_info->last_call\n+\t\t\t\t\t? &src_info->required_after_call\n+\t\t\t\t\t: &src_info->required_in);\n+      if (bitmap_ior_into (src_required, &m_tmp_bitmap))\n+\t{\n+\t  if (!src_info->last_call)\n+\t    bitmap_set_bit (pending_blocks, e->src->index);\n+\t  unshare_available_sets (src_info);\n+\t  bitmap_ior_into (get_bitmap (&src_info->available_out),\n+\t\t\t   &m_tmp_bitmap);\n+\t}\n+    }\n+\n+  /* The candidates are now available on entry to the block.  */\n+  bitmap_and_compl_into (dest_info->required_in, required);\n+  unshare_available_sets (dest_info);\n+  bitmap_ior_into (get_bitmap (&dest_info->available_in), required);\n+}\n+\n+/* Go through the candidates that are currently marked as being\n+   rematerialized at the beginning of a block.  Decide in each case\n+   whether that's valid and profitable; if it isn't, move the\n+   rematerialization to predecessor blocks instead.  */\n+\n+void\n+early_remat::choose_rematerialization_points (void)\n+{\n+  bitmap_head required;\n+  bitmap_head pending_blocks;\n+\n+  int *postorder = df_get_postorder (DF_BACKWARD);\n+  unsigned int postorder_len = df_get_n_blocks (DF_BACKWARD);\n+  bitmap_initialize (&required, &m_obstack);\n+  bitmap_initialize (&pending_blocks, &m_obstack);\n+  do\n+    /* Process the blocks in postorder, to reduce the number of iterations\n+       of the outer loop.  */\n+    for (unsigned int i = 0; i < postorder_len; ++i)\n+      {\n+\tunsigned int bb_index = postorder[i];\n+\tremat_block_info *info = &m_block_info[bb_index];\n+\tbitmap_clear_bit (&pending_blocks, bb_index);\n+\n+\tif (empty_p (info->required_in))\n+\t  continue;\n+\n+\tif (info->available_in)\n+\t  gcc_checking_assert (!bitmap_intersect_p (info->required_in,\n+\t\t\t\t\t\t    info->available_in));\n+\n+\tif (local_remat_cheaper_p (bb_index))\n+\t  {\n+\t    /* We'd prefer to rematerialize at the head of the block.\n+\t       Only move candidates if we need to.  */\n+\t    compute_minimum_move_set (bb_index, &required);\n+\t    move_to_predecessors (bb_index, &required, &pending_blocks);\n+\t  }\n+\telse\n+\t  move_to_predecessors (bb_index, info->required_in,\n+\t\t\t\t&pending_blocks);\n+      }\n+  while (!bitmap_empty_p (&pending_blocks));\n+  bitmap_clear (&required);\n+}\n+\n+/* Emit all rematerialization instructions queued for BB.  */\n+\n+void\n+early_remat::emit_remat_insns_for_block (basic_block bb)\n+{\n+  remat_block_info *info = &m_block_info[bb->index];\n+\n+  if (info->last_call && !empty_p (info->required_after_call))\n+    emit_remat_insns (info->required_after_call, NULL,\n+\t\t      info->rd_after_call, info->last_call);\n+\n+  if (!empty_p (info->required_in))\n+    {\n+      rtx_insn *insn = BB_HEAD (bb);\n+      while (insn != BB_END (bb)\n+\t     && !INSN_P (NEXT_INSN (insn)))\n+\tinsn = NEXT_INSN (insn);\n+      emit_remat_insns (info->required_in, info->available_in,\n+\t\t\tinfo->rd_in, insn);\n+    }\n+}\n+\n+/* Decide which candidates in each block's REQUIRED_IN set need to be\n+   rematerialized and decide where the rematerialization instructions\n+   should go.  Emit queued rematerialization instructions at the start\n+   of blocks and after the last calls in blocks.  */\n+\n+void\n+early_remat::global_phase (void)\n+{\n+  compute_availability ();\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n;; Blocks after computing global\"\n+\t       \" availability:\\n\");\n+      dump_all_blocks ();\n+    }\n+\n+  choose_rematerialization_points ();\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n;; Blocks after choosing rematerialization\"\n+\t       \" points:\\n\");\n+      dump_all_blocks ();\n+    }\n+\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, m_fn)\n+    emit_remat_insns_for_block (bb);\n+}\n+\n+/* Main function for the pass.  */\n+\n+void\n+early_remat::run (void)\n+{\n+  df_analyze ();\n+\n+  if (!collect_candidates ())\n+    return;\n+\n+  init_block_info ();\n+  sort_candidates ();\n+  finalize_candidate_indices ();\n+  if (dump_file)\n+    dump_all_candidates ();\n+\n+  compute_rd ();\n+  decide_candidate_validity ();\n+  local_phase ();\n+  global_phase ();\n+}\n+\n+early_remat::early_remat (function *fn, sbitmap selected_modes)\n+  : m_fn (fn),\n+    m_selected_modes (selected_modes),\n+    m_available (0),\n+    m_required (0),\n+    m_value_table (63)\n+{\n+  bitmap_obstack_initialize (&m_obstack);\n+  bitmap_initialize (&m_candidate_regnos, &m_obstack);\n+  bitmap_initialize (&m_tmp_bitmap, &m_obstack);\n+}\n+\n+early_remat::~early_remat ()\n+{\n+  bitmap_obstack_release (&m_obstack);\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_early_remat =\n+{\n+  RTL_PASS, /* type */\n+  \"early_remat\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_EARLY_REMAT, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_df_finish, /* todo_flags_finish */\n+};\n+\n+class pass_early_remat : public rtl_opt_pass\n+{\n+public:\n+  pass_early_remat (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_early_remat, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+  {\n+    return optimize > 1 && NUM_POLY_INT_COEFFS > 1;\n+  }\n+\n+  virtual unsigned int execute (function *f)\n+  {\n+    auto_sbitmap selected_modes (NUM_MACHINE_MODES);\n+    bitmap_clear (selected_modes);\n+    targetm.select_early_remat_modes (selected_modes);\n+    if (!bitmap_empty_p (selected_modes))\n+      early_remat (f, selected_modes).run ();\n+    return 0;\n+  }\n+}; // class pass_early_remat\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_early_remat (gcc::context *ctxt)\n+{\n+  return new pass_early_remat (ctxt);\n+}"}, {"sha": "9802f08ecfcc07e60ed07158c138a7c007b0fa65", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -460,6 +460,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_sms);\n       NEXT_PASS (pass_live_range_shrinkage);\n       NEXT_PASS (pass_sched);\n+      NEXT_PASS (pass_early_remat);\n       NEXT_PASS (pass_ira);\n       NEXT_PASS (pass_reload);\n       NEXT_PASS (pass_postreload);"}, {"sha": "363935b49de65a3c790e0f204a961faff3607a8e", "filename": "gcc/target.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -5572,6 +5572,19 @@ reload from using some alternatives, like @code{TARGET_PREFERRED_RELOAD_CLASS}.\"\n  (rtx x, reg_class_t rclass),\n  default_preferred_output_reload_class)\n \n+DEFHOOK\n+(select_early_remat_modes,\n+ \"On some targets, certain modes cannot be held in registers around a\\n\\\n+standard ABI call and are relatively expensive to spill to the stack.\\n\\\n+The early rematerialization pass can help in such cases by aggressively\\n\\\n+recomputing values after calls, so that they don't need to be spilled.\\n\\\n+\\n\\\n+This hook returns the set of such modes by setting the associated bits\\n\\\n+in @var{modes}.  The default implementation selects no modes, which has\\n\\\n+the effect of disabling the early rematerialization pass.\",\n+ void, (sbitmap modes),\n+ default_select_early_remat_modes)\n+\n DEFHOOK\n (class_likely_spilled_p,\n  \"A target hook which returns @code{true} if pseudos that have been assigned\\n\\"}, {"sha": "fc88bf06bab8c0ea53677d746fe7ed332fb80415", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -82,6 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"real.h\"\n #include \"langhooks.h\"\n+#include \"sbitmap.h\"\n \n bool\n default_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n@@ -2329,4 +2330,11 @@ default_stack_clash_protection_final_dynamic_probe (rtx residual ATTRIBUTE_UNUSE\n   return 0;\n }\n \n+/* The default implementation of TARGET_EARLY_REMAT_MODES.  */\n+\n+void\n+default_select_early_remat_modes (sbitmap)\n+{\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "d1b7a34ef84c71fce3af490866a9354e0a601502", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -287,5 +287,6 @@ extern unsigned int default_min_arithmetic_precision (void);\n extern enum flt_eval_method\n default_excess_precision (enum excess_precision_type ATTRIBUTE_UNUSED);\n extern bool default_stack_clash_protection_final_dynamic_probe (rtx);\n+extern void default_select_early_remat_modes (sbitmap);\n \n #endif /* GCC_TARGHOOKS_H */"}, {"sha": "b393ceff26cecf49da53e252f9af7637774fc50d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -1,3 +1,14 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.target/aarch64/sve/spill_1.c: Also test that no predicates\n+\tare spilled.\n+\t* gcc.target/aarch64/sve/spill_2.c: New test.\n+\t* gcc.target/aarch64/sve/spill_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/spill_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/spill_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/spill_6.c: Likewise.\n+\t* gcc.target/aarch64/sve/spill_7.c: Likewise.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "8039f5526aa22daf23b7a74af181af5e9f49f3d9", "filename": "gcc/testsuite/gcc.target/aarch64/sve/spill_1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_1.c?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -26,3 +26,5 @@ TEST_LOOP (uint64_t, 511);\n /* { dg-final { scan-assembler-times {\\tmov\\tz[0-9]+\\.d, #511\\n} 2 } } */\n /* { dg-final { scan-assembler-not {\\tldr\\tz[0-9]} } } */\n /* { dg-final { scan-assembler-not {\\tstr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tp[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tp[0-9]} } } */"}, {"sha": "28fcc442975026a1781677fa0aa523a5c2e33689", "filename": "gcc/testsuite/gcc.target/aarch64/sve/spill_2.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_2.c?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+void consumer (void *);\n+\n+#define TEST_LOOP(TYPE)\t\t\t\t\\\n+  void\t\t\t\t\t\t\\\n+  multi_loop_##TYPE (TYPE *x, TYPE val)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < 7; ++i)\t\t\t\\\n+      x[i] += val;\t\t\t\t\\\n+    consumer (x);\t\t\t\t\\\n+    for (int i = 0; i < 7; ++i)\t\t\t\\\n+      x[i] += val;\t\t\t\t\\\n+    consumer (x);\t\t\t\t\\\n+    for (int i = 0; i < 7; ++i)\t\t\t\\\n+      x[i] += val;\t\t\t\t\\\n+    consumer (x);\t\t\t\t\\\n+  }\n+\n+/* One iteration is enough.  */\n+TEST_LOOP (uint8_t);\n+TEST_LOOP (uint16_t);\n+/* Two iterations are enough.  Complete unrolling makes sense\n+   even at -O2.  */\n+TEST_LOOP (uint32_t);\n+/* Four iterations are needed; ought to stay a loop.  */\n+TEST_LOOP (uint64_t);\n+\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-9]\\.b} 3 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-9]\\.h} 3 } } */\n+/* { dg-final { scan-assembler {\\twhilelo\\tp[0-9]\\.s} } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-9]\\.d} 6 } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tp[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tp[0-9]} } } */"}, {"sha": "8cb904ed0fb9caad6fcdce5f8658f23aed79d869", "filename": "gcc/testsuite/gcc.target/aarch64/sve/spill_3.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_3.c?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+void consumer (void *);\n+\n+#define TEST_LOOP(TYPE) \\\n+  void\t\t\t\t\t\t\t\t\\\n+  multi_loop_##TYPE (TYPE *x, TYPE val1, TYPE val2, int n)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tx[i * 2] += val1;\t\t\t\t\t\\\n+\tx[i * 2 + 1] += val2;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    consumer (x);\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tx[i * 2] += val1;\t\t\t\t\t\\\n+\tx[i * 2 + 1] += val2;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    consumer (x);\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tx[i * 2] += val1;\t\t\t\t\t\\\n+\tx[i * 2 + 1] += val2;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    consumer (x);\t\t\t\t\t\t\\\n+  }\n+\n+/* One iteration is enough.  */\n+TEST_LOOP (uint8_t);\n+TEST_LOOP (uint16_t);\n+/* Two iterations are enough.  Complete unrolling makes sense\n+   even at -O2.  */\n+TEST_LOOP (uint32_t);\n+/* Four iterations are needed; ought to stay a loop.  */\n+TEST_LOOP (uint64_t);\n+\n+/* { dg-final { scan-assembler {\\tld1b\\tz[0-9]\\.b} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\tz[0-9]\\.h} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\tz[0-9]\\.s} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\tz[0-9]\\.d} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tp[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tp[0-9]} } } */"}, {"sha": "29e1a49dc848ec73e4decb98875aa05514d81088", "filename": "gcc/testsuite/gcc.target/aarch64/sve/spill_4.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_4.c?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+void consumer (void *);\n+\n+#define TEST_LOOP(TYPE, VAL)\t\t\t\\\n+  void\t\t\t\t\t\t\\\n+  multi_loop_##TYPE (TYPE *x)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < 100; ++i)\t\t\\\n+      x[i] += VAL;\t\t\t\t\\\n+    consumer (x);\t\t\t\t\\\n+    for (int i = 0; i < 100; ++i)\t\t\\\n+      x[i] += VAL;\t\t\t\t\\\n+    consumer (x);\t\t\t\t\\\n+    for (int i = 0; i < 100; ++i)\t\t\\\n+      x[i] += VAL;\t\t\t\t\\\n+    consumer (x);\t\t\t\t\\\n+  }\n+\n+TEST_LOOP (uint16_t, 0x1234);\n+TEST_LOOP (uint32_t, 0x12345);\n+TEST_LOOP (uint64_t, 0x123456);\n+\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-9]+\\.h,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-9]+\\.s,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tptrue\\tp[0-9]+\\.d,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1rh\\tz[0-9]+\\.h,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1rw\\tz[0-9]+\\.s,} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d,} 3 } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tp[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tp[0-9]} } } */"}, {"sha": "4602a5c128523784de341940eda7ee30a19daab8", "filename": "gcc/testsuite/gcc.target/aarch64/sve/spill_5.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_5.c?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include <stdint.h>\n+\n+void consumer (void *);\n+\n+#define TEST_LOOP(TYPE, VAL)\t\t\t\\\n+  void\t\t\t\t\t\t\\\n+  multi_loop_##TYPE (TYPE *x)\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int i = 0; i < 100; ++i)\t\t\\\n+      x[i] += VAL + i;\t\t\t\t\\\n+    consumer (x);\t\t\t\t\\\n+    for (int i = 0; i < 100; ++i)\t\t\\\n+      x[i] += VAL + i;\t\t\t\t\\\n+    consumer (x);\t\t\t\t\\\n+    for (int i = 0; i < 100; ++i)\t\t\\\n+      x[i] += VAL + i;\t\t\t\t\\\n+    consumer (x);\t\t\t\t\\\n+  }\n+\n+TEST_LOOP (uint8_t, 3);\n+TEST_LOOP (uint16_t, 4);\n+TEST_LOOP (uint32_t, 5);\n+TEST_LOOP (uint64_t, 6);\n+TEST_LOOP (float, 2.5f);\n+TEST_LOOP (double, 3.5);\n+\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\..,} 18 } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tp[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tp[0-9]} } } */"}, {"sha": "ae9c338f5696a9f743696b58f3d8e1dd991de501", "filename": "gcc/testsuite/gcc.target/aarch64/sve/spill_6.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_6.c?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=scalable\" } */\n+\n+#include <stdint.h>\n+\n+void consumer (void *);\n+\n+#define TEST_LOOP(TYPE, VAL)\t\t\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\t\\\n+  multi_loop_##TYPE (TYPE *x1, TYPE *x2, TYPE *x3, TYPE *x4, int which) \\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (which)\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfor (int i = 0; i < 7; ++i)\t\t\t\t\t\\\n+\t  x1[i] += VAL;\t\t\t\t\t\t\t\\\n+\tconsumer (x1);\t\t\t\t\t\t\t\\\n+\tfor (int i = 0; i < 7; ++i)\t\t\t\t\t\\\n+\t  x2[i] -= VAL;\t\t\t\t\t\t\t\\\n+\tconsumer (x2);\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfor (int i = 0; i < 7; ++i)\t\t\t\t\t\\\n+\t  x3[i] &= VAL;\t\t\t\t\t\t\t\\\n+\tconsumer (x3);\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < 7; ++i)\t\t\t\t\t\t\\\n+      x4[i] |= VAL;\t\t\t\t\t\t\t\\\n+    consumer (x4);\t\t\t\t\t\t\t\\\n+  }\n+\n+TEST_LOOP (uint8_t, 0x12);\n+TEST_LOOP (uint16_t, 0x1234);\n+TEST_LOOP (uint32_t, 0x12345);\n+TEST_LOOP (uint64_t, 0x123456);\n+\n+/* { dg-final { scan-assembler {\\tld1b\\tz[0-9]+\\.b,} } } */\n+/* { dg-final { scan-assembler {\\tld1h\\tz[0-9]+\\.h,} } } */\n+/* { dg-final { scan-assembler {\\tld1w\\tz[0-9]+\\.s,} } } */\n+/* { dg-final { scan-assembler {\\tld1d\\tz[0-9]+\\.d,} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tp[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tp[0-9]} } } */"}, {"sha": "b79d267483a0881c21ff9207826ec2481d7a2d96", "filename": "gcc/testsuite/gcc.target/aarch64/sve/spill_7.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fspill_7.c?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -ffast-math\" } */\n+\n+#include <stdint.h>\n+\n+void consumer (void *);\n+\n+#define TEST_LOOP(TYPE, VAL)\t\t\t\\\n+  void\t\t\t\t\t\t\\\n+  multi_loop_##TYPE (TYPE *x, int n)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    for (int k = 0; k < 4; ++k)\t\t\t\\\n+      {\t\t\t\t\t\t\\\n+\tfor (int j = 0; j < n; ++j)\t\t\\\n+\t  {\t\t\t\t\t\\\n+\t    for (int i = 0; i < 100; ++i)\t\\\n+\t      x[i] += VAL + i;\t\t\t\\\n+\t    asm volatile (\"\");\t\t\t\\\n+\t  }\t\t\t\t\t\\\n+\tfor (int j = 0; j < n; ++j)\t\t\\\n+\t  consumer (x);\t\t\t\t\\\n+\tfor (int j = 0; j < n; ++j)\t\t\\\n+\t  {\t\t\t\t\t\\\n+\t    for (int i = 0; i < 100; ++i)\t\\\n+\t      x[i] += VAL + i;\t\t\t\\\n+\t    asm volatile (\"\");\t\t\t\\\n+\t  }\t\t\t\t\t\\\n+\tconsumer (x);\t\t\t\t\\\n+\tfor (int i = 0; i < 100; ++i)\t\t\\\n+\t  x[i] += VAL + i;\t\t\t\\\n+\tconsumer (x);\t\t\t\t\\\n+      }\t\t\t\t\t\t\\\n+  }\n+\n+TEST_LOOP (uint8_t, 3);\n+TEST_LOOP (uint16_t, 4);\n+TEST_LOOP (uint32_t, 5);\n+TEST_LOOP (uint64_t, 6);\n+TEST_LOOP (float, 2.5f);\n+TEST_LOOP (double, 3.5);\n+\n+/* { dg-final { scan-assembler-times {\\tindex\\tz[0-9]+\\..,} 18 } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tz[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tldr\\tp[0-9]} } } */\n+/* { dg-final { scan-assembler-not {\\tstr\\tp[0-9]} } } */"}, {"sha": "91221ae5b0ef23746d7b7dad4b2f631ef33b482d", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -253,6 +253,7 @@ DEFTIMEVAR (TV_MODE_SWITCH           , \"mode switching\")\n DEFTIMEVAR (TV_SMS\t\t     , \"sms modulo scheduling\")\n DEFTIMEVAR (TV_LIVE_RANGE_SHRINKAGE  , \"live range shrinkage\")\n DEFTIMEVAR (TV_SCHED                 , \"scheduling\")\n+DEFTIMEVAR (TV_EARLY_REMAT           , \"early rematerialization\")\n DEFTIMEVAR (TV_IRA\t\t     , \"integrated RA\")\n DEFTIMEVAR (TV_LRA\t\t     , \"LRA non-specific\")\n DEFTIMEVAR (TV_LRA_ELIMINATE\t     , \"LRA virtuals elimination\")"}, {"sha": "93a6a99eb7a16a47a9bd2a534fc64103cc517127", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cce817119cd31d18fbfc1c8245519d86b5e9480/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=5cce817119cd31d18fbfc1c8245519d86b5e9480", "patch": "@@ -576,6 +576,7 @@ extern rtl_opt_pass *make_pass_mode_switching (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_sms (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_sched (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_live_range_shrinkage (gcc::context *ctxt);\n+extern rtl_opt_pass *make_pass_early_remat (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_ira (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_reload (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_clean_state (gcc::context *ctxt);"}]}