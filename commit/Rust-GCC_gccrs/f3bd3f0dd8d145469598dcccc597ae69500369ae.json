{"sha": "f3bd3f0dd8d145469598dcccc597ae69500369ae", "node_id": "C_kwDOANBUbNoAKGYzYmQzZjBkZDhkMTQ1NDY5NTk4ZGNjY2M1OTdhZTY5NTAwMzY5YWU", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-21T21:31:21Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-22T10:48:42Z"}, "message": "Decouple the loop from processing a potential candidate in a path\n\nCode cleanup to extract the body out of the loop to make the code more\ntestable and reuseable.", "tree": {"sha": "545497533edcc1850207926f291d73b9937822bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/545497533edcc1850207926f291d73b9937822bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3bd3f0dd8d145469598dcccc597ae69500369ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3bd3f0dd8d145469598dcccc597ae69500369ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3bd3f0dd8d145469598dcccc597ae69500369ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3bd3f0dd8d145469598dcccc597ae69500369ae/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3b37e2c5cda1eace7acf9dad6eb6568a90a4ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b37e2c5cda1eace7acf9dad6eb6568a90a4ea4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b37e2c5cda1eace7acf9dad6eb6568a90a4ea4"}], "stats": {"total": 155, "additions": 75, "deletions": 80}, "files": [{"sha": "326adb40a6a86c9bd75b2e661f5706d56c1c7ce2", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 75, "deletions": 80, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3bd3f0dd8d145469598dcccc597ae69500369ae/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3bd3f0dd8d145469598dcccc597ae69500369ae/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=f3bd3f0dd8d145469598dcccc597ae69500369ae", "patch": "@@ -146,8 +146,14 @@ class PathProbeType : public TypeCheckBase\n \n     std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n       union_type_bounds = probe.union_bounds (probed_bounds, specified_bounds);\n-    probe.process_traits_for_candidates (union_type_bounds,\n-\t\t\t\t\t ignore_mandatory_trait_items);\n+    for (auto &candidate : union_type_bounds)\n+      {\n+\tconst TraitReference *trait_ref = candidate.first;\n+\tHIR::ImplBlock *impl = candidate.second;\n+\tprobe.process_associated_trait_for_candidates (\n+\t  trait_ref, impl, ignore_mandatory_trait_items);\n+      }\n+\n     return probe.candidates;\n   }\n \n@@ -234,96 +240,85 @@ class PathProbeType : public TypeCheckBase\n     item->accept_vis (*this);\n   }\n \n-  void process_traits_for_candidates (\n-    const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n-      traits,\n-    bool ignore_mandatory_trait_items)\n+  void\n+  process_associated_trait_for_candidates (const TraitReference *trait_ref,\n+\t\t\t\t\t   HIR::ImplBlock *impl,\n+\t\t\t\t\t   bool ignore_mandatory_trait_items)\n   {\n-    for (auto &ref : traits)\n-      {\n-\tconst TraitReference *trait_ref = ref.first;\n-\tHIR::ImplBlock *impl = ref.second;\n-\n-\tconst TraitItemReference *trait_item_ref = nullptr;\n-\tif (!trait_ref->lookup_trait_item (search.as_string (),\n-\t\t\t\t\t   &trait_item_ref))\n-\t  continue;\n-\n-\tbool trait_item_needs_implementation = !trait_item_ref->is_optional ();\n-\tif (ignore_mandatory_trait_items && trait_item_needs_implementation)\n-\t  continue;\n+    const TraitItemReference *trait_item_ref = nullptr;\n+    if (!trait_ref->lookup_trait_item (search.as_string (), &trait_item_ref))\n+      return;\n \n-\tPathProbeCandidate::CandidateType candidate_type;\n-\tswitch (trait_item_ref->get_trait_item_type ())\n-\t  {\n-\t  case TraitItemReference::TraitItemType::FN:\n-\t    candidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n-\t    break;\n-\t  case TraitItemReference::TraitItemType::CONST:\n-\t    candidate_type\n-\t      = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n-\t    break;\n-\t  case TraitItemReference::TraitItemType::TYPE:\n-\t    candidate_type\n-\t      = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n-\t    break;\n+    bool trait_item_needs_implementation = !trait_item_ref->is_optional ();\n+    if (ignore_mandatory_trait_items && trait_item_needs_implementation)\n+      return;\n \n-\t  case TraitItemReference::TraitItemType::ERROR:\n-\t  default:\n-\t    gcc_unreachable ();\n-\t    break;\n-\t  }\n+    PathProbeCandidate::CandidateType candidate_type;\n+    switch (trait_item_ref->get_trait_item_type ())\n+      {\n+      case TraitItemReference::TraitItemType::FN:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::CONST:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+\tbreak;\n+      case TraitItemReference::TraitItemType::TYPE:\n+\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+\tbreak;\n+\n+      case TraitItemReference::TraitItemType::ERROR:\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n+      }\n \n-\tTyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n-\tif (impl != nullptr && !is_reciever_generic ())\n+    TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n+    if (impl != nullptr && !is_reciever_generic ())\n \n-\t  {\n-\t    HirId impl_block_id = impl->get_mappings ().get_hirid ();\n-\t    AssociatedImplTrait *lookup_associated = nullptr;\n-\t    bool found_impl_trait\n-\t      = context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t\t       &lookup_associated);\n-\t    // see testsuite/rust/compile/torture/traits10.rs this can be false\n-\t    if (found_impl_trait)\n-\t      lookup_associated->setup_associated_types ();\n-\t  }\n+      {\n+\tHirId impl_block_id = impl->get_mappings ().get_hirid ();\n+\tAssociatedImplTrait *lookup_associated = nullptr;\n+\tbool found_impl_trait\n+\t  = context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t   &lookup_associated);\n+\t// see testsuite/rust/compile/torture/traits10.rs this can be false\n+\tif (found_impl_trait)\n+\t  lookup_associated->setup_associated_types ();\n+      }\n \n-\t// we can substitute the Self with the receiver here\n-\tif (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    // we can substitute the Self with the receiver here\n+    if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+      {\n+\tTyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+\tTyTy::SubstitutionParamMapping *param = nullptr;\n+\tfor (auto &param_mapping : fn->get_substs ())\n \t  {\n-\t    TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n-\t    TyTy::SubstitutionParamMapping *param = nullptr;\n-\t    for (auto &param_mapping : fn->get_substs ())\n+\t    const HIR::TypeParam &type_param\n+\t      = param_mapping.get_generic_param ();\n+\t    if (type_param.get_type_representation ().compare (\"Self\") == 0)\n \t      {\n-\t\tconst HIR::TypeParam &type_param\n-\t\t  = param_mapping.get_generic_param ();\n-\t\tif (type_param.get_type_representation ().compare (\"Self\") == 0)\n-\t\t  {\n-\t\t    param = &param_mapping;\n-\t\t    break;\n-\t\t  }\n+\t\tparam = &param_mapping;\n+\t\tbreak;\n \t      }\n-\t    rust_assert (param != nullptr);\n-\n-\t    std::vector<TyTy::SubstitutionArg> mappings;\n-\t    mappings.push_back (\n-\t      TyTy::SubstitutionArg (param, receiver->clone ()));\n-\n-\t    Location locus; // FIXME\n-\t    TyTy::SubstitutionArgumentMappings args (std::move (mappings),\n-\t\t\t\t\t\t     locus);\n-\t    trait_item_tyty\n-\t      = SubstMapperInternal::Resolve (trait_item_tyty, args);\n \t  }\n+\trust_assert (param != nullptr);\n \n-\tPathProbeCandidate::TraitItemCandidate trait_item_candidate{\n-\t  trait_ref, trait_item_ref, impl};\n-\tPathProbeCandidate candidate{candidate_type,\n-\t\t\t\t     trait_item_tyty,\n-\t\t\t\t     trait_ref->get_locus (),\n-\t\t\t\t     {trait_item_candidate}};\n-\tcandidates.push_back (std::move (candidate));\n+\tstd::vector<TyTy::SubstitutionArg> mappings;\n+\tmappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n+\n+\tLocation locus; // FIXME\n+\tTyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n+\ttrait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n       }\n+\n+    PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n+\t\t\t\t\t\t\t\ttrait_item_ref,\n+\t\t\t\t\t\t\t\timpl};\n+    PathProbeCandidate candidate{candidate_type,\n+\t\t\t\t trait_item_tyty,\n+\t\t\t\t trait_ref->get_locus (),\n+\t\t\t\t {trait_item_candidate}};\n+    candidates.push_back (std::move (candidate));\n   }\n \n protected:"}]}