{"sha": "235783d1f06a6107df508d57e1fd462220583afa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM1NzgzZDFmMDZhNjEwN2RmNTA4ZDU3ZTFmZDQ2MjIyMDU4M2FmYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-10-20T20:57:21Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-10-20T20:57:21Z"}, "message": "expr.c (expand_expr, [...]): Set RTX_UNCHANGING_P on returned MEM.\n\n\t* expr.c (expand_expr, case SAVE_EXPR): Set RTX_UNCHANGING_P on\n\treturned MEM.\n\t(expand_expr_unaligned, case ARRAY_REF): Check that index is\n\ta constant before comparing it; use tree_low_cst.\n\t* tree.c (save_expr): Set TREE_READONLY.\n\t(substitute_expr): Return inside of NON_LVALUE_EXPR.\n\t(build, build1): Set TREE_READONLY if all operands are.\n\t(build_index_type): If upper bound is a negative number, lower\n\tbound is zero and sizetype is unsigned, use upper bound of one and\n\tlower of zero.\n\nFrom-SVN: r36979", "tree": {"sha": "0a6fc6a8a2eadc64eb528baac5aba3b8271e3eed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a6fc6a8a2eadc64eb528baac5aba3b8271e3eed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/235783d1f06a6107df508d57e1fd462220583afa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235783d1f06a6107df508d57e1fd462220583afa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/235783d1f06a6107df508d57e1fd462220583afa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/235783d1f06a6107df508d57e1fd462220583afa/comments", "author": null, "committer": null, "parents": [{"sha": "948068e2ed9b6f34dc92cff5b6e846406f4b3a7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/948068e2ed9b6f34dc92cff5b6e846406f4b3a7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/948068e2ed9b6f34dc92cff5b6e846406f4b3a7e"}], "stats": {"total": 81, "additions": 64, "deletions": 17}, "files": [{"sha": "1701c6298deb09704be8f519695c68f75831a34c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235783d1f06a6107df508d57e1fd462220583afa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235783d1f06a6107df508d57e1fd462220583afa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=235783d1f06a6107df508d57e1fd462220583afa", "patch": "@@ -1,3 +1,16 @@\n+Fri Oct 20 17:05:49 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (expand_expr, case SAVE_EXPR): Set RTX_UNCHANGING_P on\n+\treturned MEM.\n+\t(expand_expr_unaligned, case ARRAY_REF): Check that index is\n+\ta constant before comparing it; use tree_low_cst.\n+\t* tree.c (save_expr): Set TREE_READONLY.\n+\t(substitute_expr): Return inside of NON_LVALUE_EXPR.\n+\t(build, build1): Set TREE_READONLY if all operands are.\n+\t(build_index_type): If upper bound is a negative number, lower\n+\tbound is zero and sizetype is unsigned, use upper bound of one and\n+\tlower of zero.\n+\n 2000-10-20  David Edelsohn  <edelsohn@gnu.org>\n \n \t* gcc.c (process_command, main): Use \"because\" instead of"}, {"sha": "cc3ec34e390a21e2f0eb462bdd350e63502b2772", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235783d1f06a6107df508d57e1fd462220583afa/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235783d1f06a6107df508d57e1fd462220583afa/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=235783d1f06a6107df508d57e1fd462220583afa", "patch": "@@ -6222,7 +6222,11 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (mode == VOIDmode)\n \t    temp = const0_rtx;\n \t  else\n-\t    temp = assign_temp (type, 3, 0, 0);\n+\t    {\n+\t      temp = assign_temp (type, 3, 0, 0);\n+\t      if (GET_CODE (temp) == MEM)\n+\t\tRTX_UNCHANGING_P (temp) = 1;\n+\t    }\n \n \t  SAVE_EXPR_RTL (exp) = temp;\n \t  if (!optimize && GET_CODE (temp) == REG)\n@@ -8683,14 +8687,15 @@ expand_expr_unaligned (exp, palign)\n \t   that was declared const.  */\n \n \tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array)\n+\t    && host_integerp (index, 0)\n \t    && 0 > compare_tree_int (index,\n \t\t\t\t     list_length (CONSTRUCTOR_ELTS\n \t\t\t\t\t\t  (TREE_OPERAND (exp, 0)))))\n \t  {\n \t    tree elem;\n \n \t    for (elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)),\n-\t\t i = TREE_INT_CST_LOW (index);\n+\t\t i = tree_low_cst (index, 0);\n \t\t elem != 0 && i != 0; i--, elem = TREE_CHAIN (elem))\n \t      ;\n "}, {"sha": "f4aae6646134667d3d032bcdbea8ebaebd3f9698", "filename": "gcc/tree.c", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/235783d1f06a6107df508d57e1fd462220583afa/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/235783d1f06a6107df508d57e1fd462220583afa/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=235783d1f06a6107df508d57e1fd462220583afa", "patch": "@@ -1727,6 +1727,7 @@ save_expr (expr)\n      value was computed on both sides of the jump.  So make sure it isn't\n      eliminated as dead.  */\n   TREE_SIDE_EFFECTS (t) = 1;\n+  TREE_READONLY (t) = 1;\n   return t;\n }\n \n@@ -2173,6 +2174,9 @@ substitute_in_expr (exp, f, r)\n \t  if (op0 == TREE_OPERAND (exp, 0))\n \t    return exp;\n \n+\t  if (code == NON_LVALUE_EXPR)\n+\t    return op0;\n+\n \t  new = fold (build1 (code, TREE_TYPE (exp), op0));\n \t  break;\n \n@@ -2488,49 +2492,56 @@ build VPARAMS ((enum tree_code code, tree tt, ...))\n   length = TREE_CODE_LENGTH (code);\n   TREE_TYPE (t) = tt;\n \n-  /* Below, we automatically set TREE_SIDE_EFFECTS and TREE_RAISED for\n-     the result based on those same flags for the arguments.  But, if\n-     the arguments aren't really even `tree' expressions, we shouldn't\n-     be trying to do this.  */\n+  /* Below, we automatically set TREE_SIDE_EFFECTS and TREE_READONLY for the\n+     result based on those same flags for the arguments.  But if the\n+     arguments aren't really even `tree' expressions, we shouldn't be trying\n+     to do this.  */\n   fro = first_rtl_op (code);\n \n   if (length == 2)\n     {\n       /* This is equivalent to the loop below, but faster.  */\n       register tree arg0 = va_arg (p, tree);\n       register tree arg1 = va_arg (p, tree);\n+\n       TREE_OPERAND (t, 0) = arg0;\n       TREE_OPERAND (t, 1) = arg1;\n+      TREE_READONLY (t) = 1;\n       if (arg0 && fro > 0)\n \t{\n \t  if (TREE_SIDE_EFFECTS (arg0))\n \t    TREE_SIDE_EFFECTS (t) = 1;\n+\t  if (!TREE_READONLY (arg0))\n+\t    TREE_READONLY (t) = 0;\n \t}\n+\n       if (arg1 && fro > 1)\n \t{\n \t  if (TREE_SIDE_EFFECTS (arg1))\n \t    TREE_SIDE_EFFECTS (t) = 1;\n+\t  if (!TREE_READONLY (arg1))\n+\t    TREE_READONLY (t) = 0;\n \t}\n     }\n   else if (length == 1)\n     {\n       register tree arg0 = va_arg (p, tree);\n \n-      /* Call build1 for this!  */\n+      /* The only one-operand cases we handle here are those with side-effects.\n+\t Others are handled with build1.  So don't bother checked if the\n+\t arg has side-effects since we'll already have set it.\n+\n+\t ??? This really should use build1 too.  */\n       if (TREE_CODE_CLASS (code) != 's')\n \tabort ();\n       TREE_OPERAND (t, 0) = arg0;\n-      if (fro > 0)\n-\t{\n-\t  if (arg0 && TREE_SIDE_EFFECTS (arg0))\n-\t    TREE_SIDE_EFFECTS (t) = 1;\n-\t}\n     }\n   else\n     {\n       for (i = 0; i < length; i++)\n \t{\n \t  register tree operand = va_arg (p, tree);\n+\n \t  TREE_OPERAND (t, i) = operand;\n \t  if (operand && fro > i)\n \t    {\n@@ -2578,11 +2589,15 @@ build1 (code, type, node)\n #endif\n \n   TREE_SET_CODE (t, code);\n+\n   TREE_TYPE (t) = type;\n   TREE_COMPLEXITY (t) = 0;\n   TREE_OPERAND (t, 0) = node;\n-  if (node && first_rtl_op (code) != 0 && TREE_SIDE_EFFECTS (node))\n-    TREE_SIDE_EFFECTS (t) = 1;\n+  if (node && first_rtl_op (code) != 0)\n+    {\n+      TREE_SIDE_EFFECTS (t) = TREE_SIDE_EFFECTS (node);\n+      TREE_READONLY (t) = TREE_READONLY (node);\n+    }\n \n   switch (code)\n     {\n@@ -2597,6 +2612,7 @@ build1 (code, type, node)\n       /* All of these have side-effects, no matter what their\n \t operands are.  */\n       TREE_SIDE_EFFECTS (t) = 1;\n+      TREE_READONLY (t) = 0;\n       break;\n \n     default:\n@@ -3802,20 +3818,33 @@ build_index_type (maxval)\n      tree maxval;\n {\n   register tree itype = make_node (INTEGER_TYPE);\n+  int no_hash = 0;\n \n   TREE_TYPE (itype) = sizetype;\n   TYPE_PRECISION (itype) = TYPE_PRECISION (sizetype);\n-  TYPE_MIN_VALUE (itype) = size_zero_node;\n \n-  TYPE_MAX_VALUE (itype) = convert (sizetype, maxval);\n+  /* If sizetype is unsigned and the upper bound is negative, use a\n+     lower bound of one and an upper bound of zero.  */\n+  if (TREE_UNSIGNED (sizetype) && TREE_CODE (maxval) == INTEGER_CST\n+      && tree_int_cst_sgn (maxval) < 0)\n+    {\n+      TYPE_MIN_VALUE (itype) = size_one_node;\n+      TYPE_MAX_VALUE (itype) = size_zero_node;\n+      no_hash = 1;\n+    }\n+  else\n+    {\n+      TYPE_MIN_VALUE (itype) = size_zero_node;\n+      TYPE_MAX_VALUE (itype) = convert (sizetype, maxval);\n+    }\n \n   TYPE_MODE (itype) = TYPE_MODE (sizetype);\n   TYPE_SIZE (itype) = TYPE_SIZE (sizetype);\n   TYPE_SIZE_UNIT (itype) = TYPE_SIZE_UNIT (sizetype);\n   TYPE_ALIGN (itype) = TYPE_ALIGN (sizetype);\n   TYPE_USER_ALIGN (itype) = TYPE_USER_ALIGN (sizetype);\n \n-  if (host_integerp (maxval, 1))\n+  if (!no_hash && host_integerp (maxval, 1))\n     return type_hash_canon (tree_low_cst (maxval, 1), itype);\n   else\n     return itype;"}]}