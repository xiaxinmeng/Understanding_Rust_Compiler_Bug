{"sha": "0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZlMmFlMjkwMmU5ZTY1YTRjZTZjZjU2YjNjMzRjMDI2NzdkMzNhNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-04T06:56:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-10-04T06:56:02Z"}, "message": "re PR c++/71504 ([C++11] constexpr fails with multidimensional arrays)\n\n\tPR c++/71504\n\t* constexpr.c (cxx_fold_indirect_ref_1): New function.\n\t(cxx_fold_indirect_ref): Use it.\n\n\t* g++.dg/cpp0x/constexpr-array21.C: New test.\n\t* g++.dg/cpp1y/constexpr-array7.C: New test.\n\t* g++.dg/cpp1z/constexpr-array1.C: New test.\n\n2019-10-04  Jason Merrill  <jason@redhat.com>\n\n\tPR c++/71504\n\t* g++.dg/cpp0x/constexpr-array20.C: New test.\n\nFrom-SVN: r276563", "tree": {"sha": "da09480f193d690523899f897466bdd507134d52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da09480f193d690523899f897466bdd507134d52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/comments", "author": null, "committer": null, "parents": [{"sha": "708935b2b44663505a1cccf1a4aec80b310d0052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/708935b2b44663505a1cccf1a4aec80b310d0052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/708935b2b44663505a1cccf1a4aec80b310d0052"}], "stats": {"total": 351, "additions": 223, "deletions": 128}, "files": [{"sha": "e705bcce438dad5f93b1aac28e2645662a07d88d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "patch": "@@ -1,5 +1,9 @@\n 2019-10-04  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/71504\n+\t* constexpr.c (cxx_fold_indirect_ref_1): New function.\n+\t(cxx_fold_indirect_ref): Use it.\n+\n \tPR c++/91974\n \t* cp-gimplify.c (cp_gimplify_expr) <case CALL_EXPR>: For\n \t-fstrong-eval-order ensure CALL_EXPR_FN side-effects are evaluated"}, {"sha": "2dc57f145c3f6bd565e884fce1812610f10435ce", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 103, "deletions": 128, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "patch": "@@ -3346,16 +3346,111 @@ same_type_ignoring_tlq_and_bounds_p (tree type1, tree type2)\n   return same_type_ignoring_top_level_qualifiers_p (type1, type2);\n }\n \n+/* Helper function for cxx_fold_indirect_ref_1, called recursively.  */\n+\n+static tree\n+cxx_fold_indirect_ref_1 (location_t loc, tree type, tree op,\n+\t\t\t unsigned HOST_WIDE_INT off, bool *empty_base)\n+{\n+  tree optype = TREE_TYPE (op);\n+  unsigned HOST_WIDE_INT const_nunits;\n+  if (off == 0)\n+    {\n+      if (similar_type_p (optype, type))\n+\treturn op;\n+      /* Also handle conversion to an empty base class, which\n+\t is represented with a NOP_EXPR.  */\n+      /* *(foo *)&complexfoo => __real__ complexfoo */\n+      else if (TREE_CODE (optype) == COMPLEX_TYPE\n+\t       && similar_type_p (type, TREE_TYPE (optype)))\n+\treturn build1_loc (loc, REALPART_EXPR, type, op);\n+    }\n+  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n+  else if (TREE_CODE (optype) == COMPLEX_TYPE\n+\t   && similar_type_p (type, TREE_TYPE (optype))\n+\t   && tree_to_uhwi (TYPE_SIZE_UNIT (type)) == off)\n+    return build1_loc (loc, IMAGPART_EXPR, type, op);\n+  if (is_empty_class (type)\n+      && CLASS_TYPE_P (optype)\n+      && DERIVED_FROM_P (type, optype))\n+    {\n+      *empty_base = true;\n+      return op;\n+    }\n+  /* ((foo*)&vectorfoo)[x] => BIT_FIELD_REF<vectorfoo,...> */\n+  else if (VECTOR_TYPE_P (optype)\n+\t   && similar_type_p (type, TREE_TYPE (optype))\n+\t   && TYPE_VECTOR_SUBPARTS (optype).is_constant (&const_nunits))\n+    {\n+      unsigned HOST_WIDE_INT part_width = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+      unsigned HOST_WIDE_INT max_offset = part_width * const_nunits;\n+      if (off < max_offset && off % part_width == 0)\n+\t{\n+\t  tree index = bitsize_int (off * BITS_PER_UNIT);\n+\t  return build3_loc (loc, BIT_FIELD_REF, type, op,\n+\t\t\t     TYPE_SIZE (type), index);\n+\t}\n+    }\n+  /* ((foo *)&fooarray)[x] => fooarray[x] */\n+  else if (TREE_CODE (optype) == ARRAY_TYPE\n+\t   && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (optype)))\n+\t   && !integer_zerop (TYPE_SIZE_UNIT (TREE_TYPE (optype))))\n+    {\n+      tree type_domain = TYPE_DOMAIN (optype);\n+      tree min_val = size_zero_node;\n+      if (type_domain && TYPE_MIN_VALUE (type_domain))\n+\tmin_val = TYPE_MIN_VALUE (type_domain);\n+      unsigned HOST_WIDE_INT el_sz\n+\t= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (optype)));\n+      unsigned HOST_WIDE_INT idx = off / el_sz;\n+      unsigned HOST_WIDE_INT rem = off % el_sz;\n+      if (tree_fits_uhwi_p (min_val))\n+\t{\n+\t  tree index = size_int (idx + tree_to_uhwi (min_val));\n+\t  op = build4_loc (loc, ARRAY_REF, TREE_TYPE (optype), op, index,\n+\t\t\t   NULL_TREE, NULL_TREE);\n+\t  return cxx_fold_indirect_ref_1 (loc, type, op, rem,\n+\t\t\t\t\t  empty_base);\n+\t}\n+    }\n+  /* ((foo *)&struct_with_foo_field)[x] => COMPONENT_REF */\n+  else if (TREE_CODE (optype) == RECORD_TYPE)\n+    {\n+      for (tree field = TYPE_FIELDS (optype);\n+\t   field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL\n+\t    && TREE_TYPE (field) != error_mark_node\n+\t    && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (field))))\n+\t  {\n+\t    tree pos = byte_position (field);\n+\t    if (!tree_fits_uhwi_p (pos))\n+\t      continue;\n+\t    unsigned HOST_WIDE_INT upos = tree_to_uhwi (pos);\n+\t    unsigned el_sz\n+\t      = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (field)));\n+\t    if (upos <= off && off < upos + el_sz)\n+\t      {\n+\t\ttree cop = build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t\t   op, field, NULL_TREE);\n+\t\tif (tree ret = cxx_fold_indirect_ref_1 (loc, type, cop,\n+\t\t\t\t\t\t\toff - upos,\n+\t\t\t\t\t\t\tempty_base))\n+\t\t  return ret;\n+\t      }\n+\t  }\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* A less strict version of fold_indirect_ref_1, which requires cv-quals to\n    match.  We want to be less strict for simple *& folding; if we have a\n    non-const temporary that we access through a const pointer, that should\n    work.  We handle this here rather than change fold_indirect_ref_1\n    because we're dealing with things like ADDR_EXPR of INTEGER_CST which\n    don't really make sense outside of constant expression evaluation.  Also\n    we want to allow folding to COMPONENT_REF, which could cause trouble\n-   with TBAA in fold_indirect_ref_1.\n-\n-   Try to keep this function synced with fold_indirect_ref_1.  */\n+   with TBAA in fold_indirect_ref_1.  */\n \n static tree\n cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n@@ -3386,139 +3481,19 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \t  else\n \t    return op;\n \t}\n-      /* *(foo *)&fooarray => fooarray[0] */\n-      else if (TREE_CODE (optype) == ARRAY_TYPE\n-\t       && similar_type_p (type, TREE_TYPE (optype)))\n-\t{\n-\t  tree type_domain = TYPE_DOMAIN (optype);\n-\t  tree min_val = size_zero_node;\n-\t  if (type_domain && TYPE_MIN_VALUE (type_domain))\n-\t    min_val = TYPE_MIN_VALUE (type_domain);\n-\t  return build4_loc (loc, ARRAY_REF, type, op, min_val,\n-\t\t\t     NULL_TREE, NULL_TREE);\n-\t}\n-      /* *(foo *)&complexfoo => __real__ complexfoo */\n-      else if (TREE_CODE (optype) == COMPLEX_TYPE\n-\t       && similar_type_p (type, TREE_TYPE (optype)))\n-\treturn fold_build1_loc (loc, REALPART_EXPR, type, op);\n-      /* *(foo *)&vectorfoo => BIT_FIELD_REF<vectorfoo,...> */\n-      else if (VECTOR_TYPE_P (optype)\n-\t       && similar_type_p (type, TREE_TYPE (optype)))\n-\t{\n-\t  tree part_width = TYPE_SIZE (type);\n-\t  tree index = bitsize_int (0);\n-\t  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width,\n-\t\t\t\t  index);\n-\t}\n-      /* Also handle conversion to an empty base class, which\n-\t is represented with a NOP_EXPR.  */\n-      else if (is_empty_class (type)\n-\t       && CLASS_TYPE_P (optype)\n-\t       && DERIVED_FROM_P (type, optype))\n-\t{\n-\t  *empty_base = true;\n-\t  return op;\n-\t}\n-      /* *(foo *)&struct_with_foo_field => COMPONENT_REF */\n-      else if (RECORD_OR_UNION_TYPE_P (optype))\n-\t{\n-\t  tree field = TYPE_FIELDS (optype);\n-\t  for (; field; field = DECL_CHAIN (field))\n-\t    if (TREE_CODE (field) == FIELD_DECL\n-\t\t&& TREE_TYPE (field) != error_mark_node\n-\t\t&& integer_zerop (byte_position (field))\n-\t\t&& similar_type_p (TREE_TYPE (field), type))\n-\t      return fold_build3 (COMPONENT_REF, type, op, field, NULL_TREE);\n-\t}\n+      else\n+\treturn cxx_fold_indirect_ref_1 (loc, type, op, 0, empty_base);\n     }\n   else if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n-\t   && poly_int_tree_p (TREE_OPERAND (sub, 1), &const_op01))\n+\t   && tree_fits_uhwi_p (TREE_OPERAND (sub, 1)))\n     {\n       tree op00 = TREE_OPERAND (sub, 0);\n       tree op01 = TREE_OPERAND (sub, 1);\n \n       STRIP_NOPS (op00);\n       if (TREE_CODE (op00) == ADDR_EXPR)\n-\t{\n-\t  tree op00type;\n-\t  op00 = TREE_OPERAND (op00, 0);\n-\t  op00type = TREE_TYPE (op00);\n-\n-\t  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */\n-\t  if (VECTOR_TYPE_P (op00type)\n-\t      && similar_type_p (type, TREE_TYPE (op00type))\n-\t      /* POINTER_PLUS_EXPR second operand is sizetype, unsigned,\n-\t\t but we want to treat offsets with MSB set as negative.\n-\t\t For the code below negative offsets are invalid and\n-\t\t TYPE_SIZE of the element is something unsigned, so\n-\t\t check whether op01 fits into poly_int64, which implies\n-\t\t it is from 0 to INTTYPE_MAXIMUM (HOST_WIDE_INT), and\n-\t\t then just use poly_uint64 because we want to treat the\n-\t\t value as unsigned.  */\n-\t      && tree_fits_poly_int64_p (op01))\n-\t    {\n-\t      tree part_width = TYPE_SIZE (type);\n-\t      poly_uint64 max_offset\n-\t\t= (tree_to_uhwi (part_width) / BITS_PER_UNIT\n-\t\t   * TYPE_VECTOR_SUBPARTS (op00type));\n-\t      if (known_lt (const_op01, max_offset))\n-\t\t{\n-\t\t  tree index = bitsize_int (const_op01 * BITS_PER_UNIT);\n-\t\t  return fold_build3_loc (loc,\n-\t\t\t\t\t  BIT_FIELD_REF, type, op00,\n-\t\t\t\t\t  part_width, index);\n-\t\t}\n-\t    }\n-\t  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n-\t  else if (TREE_CODE (op00type) == COMPLEX_TYPE\n-\t\t   && similar_type_p (type, TREE_TYPE (op00type)))\n-\t    {\n-\t      if (known_eq (wi::to_poly_offset (TYPE_SIZE_UNIT (type)),\n-\t\t\t    const_op01))\n-\t\treturn fold_build1_loc (loc, IMAGPART_EXPR, type, op00);\n-\t    }\n-\t  /* ((foo *)&fooarray)[1] => fooarray[1] */\n-\t  else if (TREE_CODE (op00type) == ARRAY_TYPE\n-\t\t   && similar_type_p (type, TREE_TYPE (op00type)))\n-\t    {\n-\t      tree type_domain = TYPE_DOMAIN (op00type);\n-\t      tree min_val = size_zero_node;\n-\t      if (type_domain && TYPE_MIN_VALUE (type_domain))\n-\t\tmin_val = TYPE_MIN_VALUE (type_domain);\n-\t      offset_int off = wi::to_offset (op01);\n-\t      offset_int el_sz = wi::to_offset (TYPE_SIZE_UNIT (type));\n-\t      offset_int remainder;\n-\t      off = wi::divmod_trunc (off, el_sz, SIGNED, &remainder);\n-\t      if (remainder == 0 && TREE_CODE (min_val) == INTEGER_CST)\n-\t\t{\n-\t\t  off = off + wi::to_offset (min_val);\n-\t\t  op01 = wide_int_to_tree (sizetype, off);\n-\t\t  return build4_loc (loc, ARRAY_REF, type, op00, op01,\n-\t\t\t\t     NULL_TREE, NULL_TREE);\n-\t\t}\n-\t    }\n-\t  /* Also handle conversion to an empty base class, which\n-\t     is represented with a NOP_EXPR.  */\n-\t  else if (is_empty_class (type)\n-\t\t   && CLASS_TYPE_P (op00type)\n-\t\t   && DERIVED_FROM_P (type, op00type))\n-\t    {\n-\t      *empty_base = true;\n-\t      return op00;\n-\t    }\n-\t  /* ((foo *)&struct_with_foo_field)[1] => COMPONENT_REF */\n-\t  else if (RECORD_OR_UNION_TYPE_P (op00type))\n-\t    {\n-\t      tree field = TYPE_FIELDS (op00type);\n-\t      for (; field; field = DECL_CHAIN (field))\n-\t\tif (TREE_CODE (field) == FIELD_DECL\n-\t\t    && TREE_TYPE (field) != error_mark_node\n-\t\t    && tree_int_cst_equal (byte_position (field), op01)\n-\t\t    && similar_type_p (TREE_TYPE (field), type))\n-\t\t  return fold_build3 (COMPONENT_REF, type, op00,\n-\t\t\t\t      field, NULL_TREE);\n-\t    }\n-\t}\n+\treturn cxx_fold_indirect_ref_1 (loc, type, TREE_OPERAND (op00, 0),\n+\t\t\t\t\ttree_to_uhwi (op01), empty_base);\n     }\n   /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n   else if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE"}, {"sha": "60e6caa25205fd7d78a337afacbeec0d2ebce672", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "patch": "@@ -1,3 +1,15 @@\n+2019-10-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/71504\n+\t* g++.dg/cpp0x/constexpr-array21.C: New test.\n+\t* g++.dg/cpp1y/constexpr-array7.C: New test.\n+\t* g++.dg/cpp1z/constexpr-array1.C: New test.\n+\n+2019-10-04  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/71504\n+\t* g++.dg/cpp0x/constexpr-array20.C: New test.\n+\n 2019-10-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/91974"}, {"sha": "217bbf4efb7769b2f4f5c034aa14bec0747fe27d", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array20.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array20.C?ref=0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/71504\n+// { dg-do compile { target c++11 } }\n+\n+enum E { e };\n+\n+constexpr bool arr[1][1] = {{true}};\n+\n+template<E x, E y>\n+void check() { \n+    static_assert(arr[x][y], \"\"); \n+}\n+\n+int main() { \n+    check<e, e>(); \n+}"}, {"sha": "e085098445ab876611f3faf281295c0442936b96", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-array21.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-array21.C?ref=0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "patch": "@@ -0,0 +1,27 @@\n+// PR c++/71504\n+// { dg-do compile { target c++11 } }\n+\n+typedef const char A4 [10];\n+\n+constexpr A4 a [] = { \"123\", \"123456\", \"123456789\" };\n+\n+constexpr int len (const char *s)\n+{\n+  return *s ? 1 + len (s + 1) : 0;\n+}\n+\n+constexpr const char *s = a[0];\n+constexpr const char *t = (a + 2)[-2];\n+\n+constexpr int n0 = len (s);\n+constexpr int n1 = len (t);\n+\n+constexpr int n2 = len (a[0]);\n+constexpr int n3 = len ((a + 2)[-2]);\n+\n+#define A(e) static_assert ((e), #e)\n+\n+A (n0 == 3);\n+A (n0 == n1);\n+A (n0 == n2);\n+A (n0 == n3);"}, {"sha": "30bd8fd023b56a2bd1ea73ce907ef4d441ebce94", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-array7.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-array7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-array7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-array7.C?ref=0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/71504\n+// { dg-do compile { target c++14 } }\n+\n+template <typename A>\n+constexpr auto\n+sum (A const &a)\n+{\n+  int tot = 0;\n+  for (auto &row : a)\n+    for (auto elem : row)\n+      tot += elem;\n+  return tot;\n+}\n+\n+constexpr int const a22[2][2] = {{1,2},{3,4}};\n+static_assert (sum(a22) == 10, \"badsum\");"}, {"sha": "02435d505de41c09bea0250e91eff578be8f8415", "filename": "gcc/testsuite/g++.dg/cpp1z/constexpr-array1.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-array1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-array1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-array1.C?ref=0fe2ae2902e9e65a4ce6cf56b3c34c02677d33a4", "patch": "@@ -0,0 +1,46 @@\n+// PR c++/71504\n+// { dg-do compile { target c++17 } }\n+\n+typedef __SIZE_TYPE__ size_t;\n+template <typename T, T v>\n+struct integral_constant\n+{\n+  static constexpr T value = v;\n+  typedef T value_type;\n+  typedef integral_constant<T, v> type;\n+  constexpr operator value_type () const noexcept { return value; }\n+  constexpr value_type operator() () const noexcept { return value; }\n+};\n+template <typename T, T v>\n+constexpr T integral_constant<T, v>::value;\n+typedef integral_constant<bool, true> true_type;\n+typedef integral_constant<bool, false> false_type;\n+template <typename>\n+struct is_array : public false_type { };\n+template <typename T, size_t s>\n+struct is_array<T[s]> : public true_type { };\n+template <typename T>\n+struct is_array<T[]> : public true_type { };\n+template <bool, typename, typename>\n+struct conditional;\n+template <bool C, typename T, typename F>\n+struct conditional { typedef T type; };\n+template <typename T, typename F>\n+struct conditional<false, T, F> { typedef F type; };\n+template <typename T>\n+struct array_ref;\n+template <typename T>\n+using ref_t = typename conditional<is_array<T>::value, array_ref<T>, T&>::type;\n+template <typename T, unsigned N>\n+struct array_ref<T[N]>\n+{\n+  T *a;\n+  using const_reference = const ref_t<T>;\n+  constexpr const_reference operator[] (unsigned I) const { return {a[I]}; }\n+};\n+template <typename A>\n+array_ref (A&) -> array_ref<A>;\n+constexpr int a2[2] = {1,2};\n+static_assert (array_ref{a2}[0] == 1);\n+constexpr int a22[2][2] = {{1,2},{3,4}};\n+static_assert (array_ref{a22}[0][0] == 1);"}]}