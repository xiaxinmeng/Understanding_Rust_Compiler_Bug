{"sha": "05ae1c31cf55c746a49ff06bab5470c466e0b13d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVhZTFjMzFjZjU1Yzc0NmE0OWZmMDZiYWI1NDcwYzQ2NmUwYjEzZA==", "commit": {"author": {"name": "Oskar Liljeblad", "email": "osk@hem.passagen.se", "date": "2000-07-23T17:52:13Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-07-23T17:52:13Z"}, "message": "StreamTokenizer.java: Merged with classpath.\n\n2000-07-23  Oskar Liljeblad <osk@hem.passagen.se>\n\n\t* java/io/StreamTokenizer.java: Merged with classpath.\n\nFrom-SVN: r35208", "tree": {"sha": "707ef87242730023326aecd59940f7bbc1051498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/707ef87242730023326aecd59940f7bbc1051498"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05ae1c31cf55c746a49ff06bab5470c466e0b13d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05ae1c31cf55c746a49ff06bab5470c466e0b13d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05ae1c31cf55c746a49ff06bab5470c466e0b13d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05ae1c31cf55c746a49ff06bab5470c466e0b13d/comments", "author": null, "committer": null, "parents": [{"sha": "1adcd149387a1c8138b3de3f07027522be681940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1adcd149387a1c8138b3de3f07027522be681940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1adcd149387a1c8138b3de3f07027522be681940"}], "stats": {"total": 302, "additions": 253, "deletions": 49}, "files": [{"sha": "655081fc143228fd0d14dcfe00d5d4daf3050b55", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05ae1c31cf55c746a49ff06bab5470c466e0b13d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05ae1c31cf55c746a49ff06bab5470c466e0b13d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=05ae1c31cf55c746a49ff06bab5470c466e0b13d", "patch": "@@ -1,3 +1,7 @@\n+2000-07-23  Oskar Liljeblad <osk@hem.passagen.se>\n+\n+\t* java/io/StreamTokenizer.java: Merged with classpath.\n+\n 2000-07-20  Tom Tromey  <tromey@cygnus.com>\n \n \t* Makefile.in: Rebuilt."}, {"sha": "f0099d40abe4b5895d92f9dbaa9f016a902e83fc", "filename": "libjava/java/io/StreamTokenizer.java", "status": "modified", "additions": 249, "deletions": 49, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05ae1c31cf55c746a49ff06bab5470c466e0b13d/libjava%2Fjava%2Fio%2FStreamTokenizer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05ae1c31cf55c746a49ff06bab5470c466e0b13d/libjava%2Fjava%2Fio%2FStreamTokenizer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FStreamTokenizer.java?ref=05ae1c31cf55c746a49ff06bab5470c466e0b13d", "patch": "@@ -9,6 +9,10 @@\n package java.io;\n \n /**\n+ * This class parses streams of characters into tokens.  There are a\n+ * million-zillion flags that can be set to control the parsing, as \n+ * described under the various method headings.\n+ *\n  * @author Warren Levy <warrenl@cygnus.com>\n  * @date October 25, 1998.  \n  */\n@@ -20,25 +24,40 @@\n  \n public class StreamTokenizer\n {\n-  /* A constant indicating that the end of the stream has been read. */\n+  /** A constant indicating that the end of the stream has been read. */\n   public static final int TT_EOF = -1;\n \n-  /* A constant indicating that the end of the line has been read. */\n+  /** A constant indicating that the end of the line has been read. */\n   public static final int TT_EOL = '\\n';\n \n-  /* A constant indicating that a number token has been read. */\n+  /** A constant indicating that a number token has been read. */\n   public static final int TT_NUMBER = -2;\n \n-  /* A constant indicating that a word token has been read. */\n+  /** A constant indicating that a word token has been read. */\n   public static final int TT_WORD = -3;\n \n-  /* Contains the type of the token read resulting from a call to nextToken. */\n-  public int ttype;\n-\n-  /* The String associated with word and string tokens. */\n+  /** A constant indicating that no tokens have been read yet. */\n+  public static final int TT_NONE = -4;\n+\n+  /**\n+   * Contains the type of the token read resulting from a call to nextToken\n+   * The rules are as follows:\n+   * <ul>\n+   * <li>For a token consisting of a single ordinary character, this is the \n+   *     value of that character.\n+   * <li>For a quoted string, this is the value of the quote character\n+   * <li>For a word, this is TT_WORD\n+   * <li>For a number, this is TT_NUMBER\n+   * <li>For the end of the line, this is TT_EOL\n+   * <li>For the end of the stream, this is TT_EOF\n+   * </ul>\n+   */\n+  public int ttype = TT_NONE;\n+\n+  /** The String associated with word and string tokens. */\n   public String sval;\n \n-  /* The numeric value associated with number tokens. */\n+  /** The numeric value associated with number tokens. */\n   public double nval;\n \n   /* Indicates whether end-of-line is recognized as a token. */\n@@ -54,11 +73,11 @@\n   private boolean slashStar = false;\n \n   /* Attribute tables of each byte from 0x00 to 0xFF. */\n-  private boolean[] whitespace;\n-  private boolean[] alphabetic;\n-  private boolean[] numeric;\n-  private boolean[] quote;\n-  private boolean[] comment;\n+  private boolean[] whitespace = new boolean[256];\n+  private boolean[] alphabetic = new boolean[256];\n+  private boolean[] numeric = new boolean[256];\n+  private boolean[] quote = new boolean[256];\n+  private boolean[] comment = new boolean[256];\n \n   /* The Reader associated with this class. */\n   private PushbackReader in;\n@@ -69,24 +88,45 @@\n   /* Contains the current line number of the reader. */\n   private int lineNumber = 1;\n \n-  // Deprecated in JDK 1.1.\n+  /**\n+   * This method reads bytes from an <code>InputStream</code> and tokenizes\n+   * them.  For details on how this method operates by default, see\n+   * <code>StreamTokenizer(Reader)</code>.\n+   *\n+   * @param in The <code>InputStream</code> to read from\n+   *\n+   * @deprecated Since JDK 1.1.\n+   */\n   public StreamTokenizer(InputStream is)\n   {\n     this(new InputStreamReader(is));\n   }\n \n+  /**\n+   * This method initializes a new <code>StreamTokenizer</code> to read \n+   * characters from a <code>Reader</code> and parse them.  The char values\n+   * have their hight bits masked so that the value is treated a character\n+   * in the range of 0x0000 to 0x00FF.\n+   * <p>\n+   * This constructor sets up the parsing table to parse the stream in the\n+   * following manner:\n+   * <ul>\n+   * <li>The values 'A' through 'Z', 'a' through 'z' and 0xA0 through 0xFF\n+   *     are initialized as alphabetic\n+   * <li>The values 0x00 through 0x20 are initialized as whitespace\n+   * <li>The values '\\'' and '\"' are initialized as quote characters\n+   * <li>'/' is a comment character\n+   * <li>Numbers will be parsed\n+   * <li>EOL is not treated as significant\n+   * <li>C  and C++ (//) comments are not recognized\n+   * </ul>\n+   *\n+   * @param in The <code>Reader</code> to read chars from\n+   */\n   public StreamTokenizer(Reader r)\n   {\n     in = new PushbackReader(r);\n \n-    whitespace = new boolean[256];\n-    alphabetic = new boolean[256];\n-    numeric = new boolean[256];\n-    quote = new boolean[256];\n-    comment = new boolean[256];\n-    for (int i = 0; i < 256; i++)\n-      resetChar(i);\n-\n     whitespaceChars(0x00, 0x20);\n     wordChars('A', 'Z');\n     wordChars('a', 'z');\n@@ -97,75 +137,137 @@ public StreamTokenizer(Reader r)\n     parseNumbers();\n   }\n \n+  /**\n+   * This method sets the comment attribute on the specified character.\n+   *\n+   * @param c The character to set the comment attribute for, passed as an int\n+   */\n   public void commentChar(int ch)\n   {\n     if (ch >= 0 && ch <= 255)\n       comment[ch] = true;\n   }\n \n+  /**\n+   * This method sets a flag that indicates whether or not the end of line\n+   * sequence terminates and is a token.  The defaults to <code>false</code>\n+   *\n+   * @param flag <code>true</code> if EOF is significant, <code>false</code>\n+   *             otherwise\n+   */\n   public void eolIsSignificant(boolean flag)\n   {\n     eolSignificant = flag;\n   }\n \n+  /**\n+   * This method returns the current line number.  Note that if the \n+   * <code>pushBack()</code> method is called, it has no effect on the\n+   * line number returned by this method.\n+   *\n+   * @return The current line number\n+   */\n   public int lineno()\n   {\n     return lineNumber;\n   }\n \n+  /**\n+   * This method sets a flag that indicates whether or not alphabetic\n+   * tokens that are returned should be converted to lower case.\n+   * \n+   * @param flag <code>true</code> to convert to lower case,\n+   *             <code>false</code> otherwise\n+   */\n   public void lowerCaseMode(boolean flag)\n   {\n     lowerCase = flag;\n   }\n \n   private boolean isWhitespace(int ch)\n   {\n-    if (ch >= 0 && ch <= 255)\n-      return whitespace[ch];\n-\n-    return false;\n+    return (ch >= 0 && ch <= 255 && whitespace[ch]);\n   }\n \n   private boolean isAlphabetic(int ch)\n   {\n-    if (ch >= 0 && ch <= 255)\n-      return alphabetic[ch];\n-    else if (ch > 255)\n-      return true;\n-\n-    return false;\n+    return ((ch > 255) || (ch >= 0 && alphabetic[ch]));\n   }\n \n   private boolean isNumeric(int ch)\n   {\n-    if (ch >= 0 && ch <= 255)\n-      return numeric[ch];\n-\n-    return false;\n+    return (ch >= 0 && ch <= 255 && numeric[ch]);\n   }\n \n   private boolean isQuote(int ch)\n   {\n-    if (ch >= 0 && ch <= 255)\n-      return quote[ch];\n-\n-    return false;\n+    return (ch >= 0 && ch <= 255 && quote[ch]);\n   }\n \n   private boolean isComment(int ch)\n   {\n-    if (ch >= 0 && ch <= 255)\n-      return comment[ch];\n-\n-    return false;\n+    return (ch >= 0 && ch <= 255 && comment[ch]);\n   }\n \n+  /**\n+   * This method reads the next token from the stream.  It sets the \n+   * <code>ttype</code> variable to the appropriate token type and \n+   * returns it.  It also can set <code>sval</code> or <code>nval</code>\n+   * as described below.  The parsing strategy is as follows:\n+   * <ul>\n+   * <li>Skip any whitespace characters.\n+   * <li>If a numeric character is encountered, attempt to parse a numeric\n+   * value.  Leading '-' characters indicate a numeric only if followed by\n+   * another non-'-' numeric.  The value of the numeric token is terminated\n+   * by either the first non-numeric encountered, or the second occurrence of\n+   * '-' or '.'.  The token type returned is TT_NUMBER and <code>nval</code>\n+   * is set to the value parsed.\n+   * <li>If an alphabetic character is parsed, all subsequent characters\n+   * are read until the first non-alphabetic or non-numeric character is\n+   * encountered.  The token type returned is TT_WORD and the value parsed\n+   * is stored in <code>sval</code>.  If lower case mode is set, the token\n+   * stored in <code>sval</code> is converted to lower case.  The end of line\n+   * sequence terminates a word only if EOL signficance has been turned on.\n+   * The start of a comment also terminates a word.  Any character with a \n+   * non-alphabetic and non-numeric attribute (such as white space, a quote,\n+   * or a commet) are treated as non-alphabetic and terminate the word.\n+   * <li>If a comment charcters is parsed, then all remaining characters on\n+   * the current line are skipped and another token is parsed.  Any EOL or\n+   * EOF's encountered are not discarded, but rather terminate the comment.\n+   * <li>If a quote character is parsed, then all characters up to the \n+   * second occurrence of the same quote character are parsed into a\n+   * <code>String</code>.  This <code>String</code> is stored as\n+   * <code>sval</code>, but is not converted to lower case, even if lower case\n+   * mode is enabled.  The token type returned is the value of the quote\n+   * character encountered.  Any escape sequences\n+   * (\\b (backspace), \\t (HTAB), \\n (linefeed), \\f (form feed), \\r\n+   * (carriage return), \\\" (double quote), \\' (single quote), \\\\\n+   * (backslash), \\XXX (octal esacpe)) are converted to the appropriate\n+   * char values.  Invalid esacape sequences are left in untranslated.  \n+   * Unicode characters like ('\\ u0000') are not recognized. \n+   * <li>If the C++ comment sequence \"//\" is encountered, and the parser\n+   * is configured to handle that sequence, then the remainder of the line\n+   * is skipped and another token is read exactly as if a character with\n+   * the comment attribute was encountered.\n+   * <li>If the C comment sequence \"/*\" is encountered, and the parser\n+   * is configured to handle that sequence, then all characters up to and\n+   * including the comment terminator sequence are discarded and another\n+   * token is parsed.\n+   * <li>If all cases above are not met, then the character is an ordinary\n+   * character that is parsed as a token by itself.  The char encountered\n+   * is returned as the token type.\n+   * </ul>\n+   *\n+   * @return The token type\n+   * @exception IOException If an I/O error occurs\n+   */\n   public int nextToken() throws IOException\n   {\n     if (pushedBack)\n       {\n \tpushedBack = false;\n-\treturn ttype;\n+\tif (ttype != TT_NONE)\n+\t  return ttype;\n       }\n \n     sval = null;\n@@ -355,12 +457,32 @@ private void resetChar(int ch)\n       false;\n   }\n \n+  /**\n+   * This method makes the specified character an ordinary character.  This\n+   * means that none of the attributes (whitespace, alphabetic, numeric,\n+   * quote, or comment) will be set on this character.  This character will\n+   * parse as its own token.\n+   *\n+   * @param c The charcter to make ordinary, passed as an int\n+   */\n   public void ordinaryChar(int ch)\n   {\n     if (ch >= 0 && ch <= 255)\n       resetChar(ch);\n   }\n \n+  /**\n+   * This method makes all the characters in the specified range, range\n+   * terminators included, ordinary.  This means the none of the attributes\n+   * (whitespace, alphabetic, numeric, quote, or comment) will be set on\n+   * any of the characters in the range.  This makes each character in this\n+   * range parse as its own token.\n+   *\n+   * @param low The low end of the range of values to set the whitespace\n+   *            attribute for\n+   * @param high The high end of the range of values to set the whitespace\n+   *            attribute for\n+   */\n   public void ordinaryChars(int low, int hi)\n   {\n     if (low < 0)\n@@ -371,6 +493,10 @@ public void ordinaryChars(int low, int hi)\n       resetChar(i);\n   }\n \n+  /**\n+   * This method sets the numeric attribute on the characters '0' - '9' and\n+   * the characters '.' and '-'.\n+   */\n   public void parseNumbers()\n   {\n     for (int i = 0; i <= 9; i++)\n@@ -380,34 +506,88 @@ public void parseNumbers()\n     numeric['-'] = true;\n   }\n \n+  /**\n+   * This method returns the current line number.  Note that if the \n+   * <code>pushBack()</code> method is called, it has no effect on the\n+   * line number returned by this method.\n+   *\n+   * @return The current line number\n+   */\n   public void pushBack()\n   {\n     // pushBack may cause the lineno method to return an incorrect value\n     // if lineno is called before the next call to nextToken.\n     pushedBack = true;\n   }\n \n+  /**\n+   * This method sets the quote attribute on the specified character.\n+   *\n+   * @param c The character to set the quote attribute for, passed as an int.\n+   */\n   public void quoteChar(int ch)\n   {\n     if (ch >= 0 && ch <= 255)\n       quote[ch] = true;\n   }\n \n+  /**\n+   * This method removes all attributes (whitespace, alphabetic, numeric,\n+   * quote, and comment) from all characters.  It is equivalent to calling\n+   * <code>ordinaryChars(0x00, 0xFF)</code>.\n+   *\n+   * @see ordinaryChars\n+   */\n   public void resetSyntax()\n   {\n     ordinaryChars(0x00, 0xFF);\n   }\n \n+  /**\n+   * This method sets a flag that indicates whether or not \"C++\" language style\n+   * comments (\"//\" comments through EOL ) are handled by the parser.\n+   * If this is <code>true</code> commented out sequences are skipped and\n+   * ignored by the parser.  This defaults to <code>false</code>.\n+   *\n+   * @param flag <code>true</code> to recognized and handle \"C++\" style\n+   *             comments, <code>false</code> otherwise\n+   */\n   public void slashSlashComments(boolean flag)\n   {\n     slashSlash = flag;\n   }\n \n+  /**\n+   * This method sets a flag that indicates whether or not \"C\" language style\n+   * comments (with nesting not allowed) are handled by the parser.\n+   * If this is <code>true</code> commented out sequences are skipped and\n+   * ignored by the parser.  This defaults to <code>false</code>.\n+   *\n+   * @param flag <code>true</code> to recognized and handle \"C\" style comments,\n+   *             <code>false</code> otherwise\n+   */\n   public void slashStarComments(boolean flag)\n   {\n     slashStar = flag;\n   }\n \n+  /**\n+   * This method returns the current token value as a <code>String</code> in\n+   * the form \"Token[x], line n\", where 'n' is the current line numbers and\n+   * 'x' is determined as follows.\n+   * <p>\n+   * <ul>\n+   * <li>If no token has been read, then 'x' is \"NOTHING\" and 'n' is 0\n+   * <li>If <code>ttype</code> is TT_EOF, then 'x' is \"EOF\"\n+   * <li>If <code>ttype</code> is TT_EOL, then 'x' is \"EOL\"\n+   * <li>If <code>ttype</code> is TT_WORD, then 'x' is <code>sval</code>\n+   * <li>If <code>ttype</code> is TT_NUMBER, then 'x' is \"n=strnval\" where\n+   * 'strnval' is <code>String.valueOf(nval)</code>.\n+   * <li>If <code>ttype</code> is a quote character, then 'x' is\n+   * <code>sval</code>\n+   * <li>For all other cases, 'x' is <code>ttype</code>\n+   * </ul>\n+   */\n   public String toString()\n   {\n     String tempstr;\n@@ -418,13 +598,24 @@ else if (ttype == TT_EOL)\n     else if (ttype == TT_WORD)\n       tempstr = sval;\n     else if (ttype == TT_NUMBER)\n-      tempstr = \"n=\" + Double.toString(nval);\n+      tempstr = \"n=\" + nval;\n+    else if (ttype == TT_NONE)\n+      tempstr = \"NOTHING\";\n     else // must be an ordinary char.\n-      tempstr = \"\\'\" + (new Character((char) ttype)).toString() + \"\\'\";\n+      tempstr = \"\\'\" + (char) ttype + \"\\'\";\n \n-    return \"Token[\" + tempstr + \"], line \" + Integer.toString(lineno());\n+    return \"Token[\" + tempstr + \"], line \" + lineno();\n   }\n \n+  /**\n+   * This method sets the whitespace attribute for all charcters in the\n+   * specified range, range terminators included.\n+   *\n+   * @param low The low end of the range of values to set the whitespace\n+   *            attribute for\n+   * @param high The high end of the range of values to set the whitespace\n+   *             attribute for\n+   */\n   public void whitespaceChars(int low, int hi)\n   {\n     if (low < 0)\n@@ -435,6 +626,15 @@ public void whitespaceChars(int low, int hi)\n       whitespace[i] = true;\n   }\n \n+  /**\n+   * This method sets the alphabetic attribute for all charcters in the\n+   * specified range, range terminators included.\n+   *\n+   * @param low The low end of the range of values to set the alphabetic\n+   *            attribute for\n+   * @param high The high end of the range of values to set the alphabetic\n+   *             attribute for\n+   */\n   public void wordChars(int low, int hi)\n   {\n     if (low < 0)"}]}