{"sha": "cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q2NGRjOTg1YTgxYjRlYjgwYTIzOGY2MzNkZjlmOGU5YzQwZWQ5MA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-09-06T02:25:00Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-09-06T02:25:00Z"}, "message": "check-init.c, [...]: Fix comment typos.\n\n\t* check-init.c, decl.c, expr.c, gcj.texi, java-tree.h,\n\tjcf-parse.c, jcf.h, parse.h, parse.y, typeck.c: Fix comment\n\ttypos.  Follow spelling conventions.\n\nFrom-SVN: r103927", "tree": {"sha": "6986aaabf8b78d0d7811ad4cd7a7312cdc1d9a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6986aaabf8b78d0d7811ad4cd7a7312cdc1d9a13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/comments", "author": null, "committer": null, "parents": [{"sha": "1634705dd6bf842b1dca21c690a38b3fdbef53a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1634705dd6bf842b1dca21c690a38b3fdbef53a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1634705dd6bf842b1dca21c690a38b3fdbef53a4"}], "stats": {"total": 42, "additions": 24, "deletions": 18}, "files": [{"sha": "ba3a435d953d071ba81e76a5cb2ed2dd44cbe4c9", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -1,3 +1,9 @@\n+2005-09-06  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* check-init.c, decl.c, expr.c, gcj.texi, java-tree.h,\n+\tjcf-parse.c, jcf.h, parse.h, parse.y, typeck.c: Fix comment\n+\ttypos.  Follow spelling conventions.\n+\n 2005-09-05  Ranjit Mathew  <rmathew@hotmail.com>\n \n \tPR java/23431"}, {"sha": "e18ba94a4f6434a3126a8b0a81ce72730fc4c05d", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -37,7 +37,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n /* The basic idea is that we assign each local variable declaration\n    and each blank final field an index, and then we pass around\n    bitstrings, where the (2*i)'th bit is set if decl whose DECL_BIT_INDEX\n-   is i is definitely assigned, and the the (2*i=1)'th bit is set if \n+   is i is definitely assigned, and the (2*i=1)'th bit is set if \n    decl whose DECL_BIT_INDEX is i is definitely unassigned */\n \n /* One segment of a bitstring. */"}, {"sha": "de8f9ada3e985c9acee1019ca4a8c9a55c7a0653", "filename": "gcc/java/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -1231,7 +1231,7 @@ lookup_name (tree name)\n }\n \n /* Similar to `lookup_name' but look only at current binding level and\n-   the previous one if its the parameter level.  */\n+   the previous one if it's the parameter level.  */\n \n static tree\n lookup_name_current_level (tree name)\n@@ -2165,7 +2165,7 @@ java_mark_decl_local (tree decl)\n static void\n java_mark_cni_decl_local (tree decl)\n {\n-  /* Setting DECL_LOCAL_CNI_METHOD_P changes the behaviour of the mangler.\n+  /* Setting DECL_LOCAL_CNI_METHOD_P changes the behavior of the mangler.\n      We expect that we should not yet have referenced this decl in a \n      context that requires it.  Check this invariant even if we don't have\n      support for hidden aliases.  */\n@@ -2179,7 +2179,7 @@ java_mark_cni_decl_local (tree decl)\n   DECL_LOCAL_CNI_METHOD_P (decl) = 1;\n }\n \n-/* Use the preceeding two functions and mark all members of the class.  */\n+/* Use the preceding two functions and mark all members of the class.  */\n \n void\n java_mark_class_local (tree class)"}, {"sha": "d65a6ff563c79a46efa0877dee26f74e0d30bdb9", "filename": "gcc/java/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -2999,8 +2999,8 @@ process_jvm_instruction (int PC, const unsigned char* byte_ops,\n   const char *opname; /* Temporary ??? */\n   int oldpc = PC; /* PC at instruction start. */\n \n-  /* If the instruction is at the beginning of a exception handler,\n-     replace the top of the stack with the thrown object reference */\n+  /* If the instruction is at the beginning of an exception handler,\n+     replace the top of the stack with the thrown object reference.  */\n   if (instruction_bits [PC] & BCODE_EXCEPTION_TARGET)\n     {\n       /* Note that the verifier will not emit a type map at all for\n@@ -3321,7 +3321,7 @@ peek_opcode_at_pc (JCF *jcf, int code_offset, int pc)\n \n    This function is used by `give_name_to_locals' so that a local's\n    DECL features a DECL_LOCAL_START_PC such that the first related\n-   store operation will use DECL as a destination, not a unrelated\n+   store operation will use DECL as a destination, not an unrelated\n    temporary created for the occasion.\n \n    This function uses a global (instruction_bits) `note_instructions' should"}, {"sha": "142671eb8526cbf3ee137b506b95b6667a72f307", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -2649,7 +2649,7 @@ Enables printing serialization debugging by the @code{java.io.ObjectInput} and\n string.  Only used when running a debug build of the library.\n \n @item gnu.classpath.vm.shortname\n-This is a succint name of the virtual machine.  For @code{libgcj},\n+This is a succinct name of the virtual machine.  For @code{libgcj},\n this will always be @samp{libgcj}.\n \n @item gnu.classpath.home.url"}, {"sha": "8f30878dd5644661fa897d4fb85c2050051d86ec", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -1660,12 +1660,12 @@ extern tree *type_map;\n #define INNER_CLASS_DECL_P(NODE) (TYPE_NAME (TREE_TYPE (NODE)) == NODE\t\\\n \t\t\t\t  && DECL_CONTEXT (NODE))\n \n-/* True if NODE is an top level class TYPE_DECL node: NODE isn't\n+/* True if NODE is a top level class TYPE_DECL node: NODE isn't\n    an inner class or NODE is a static class.  */\n #define TOPLEVEL_CLASS_DECL_P(NODE) (!INNER_CLASS_DECL_P (NODE) \t\\\n \t\t\t\t     || CLASS_STATIC (NODE))\n \n-/* True if the class decl NODE was declared in a inner scope and is\n+/* True if the class decl NODE was declared in an inner scope and is\n    not a toplevel class */\n #define PURE_INNER_CLASS_DECL_P(NODE) \\\n   (INNER_CLASS_DECL_P (NODE) && !CLASS_STATIC (NODE))\n@@ -1678,7 +1678,7 @@ extern tree *type_map;\n #define TOPLEVEL_CLASS_TYPE_P(NODE) (!INNER_CLASS_TYPE_P (NODE) \t\\\n \t\t\t\t     || CLASS_STATIC (TYPE_NAME (NODE)))\n \n-/* True if the class type NODE was declared in a inner scope and is\n+/* True if the class type NODE was declared in an inner scope and is\n    not a toplevel class */\n #define PURE_INNER_CLASS_TYPE_P(NODE) \\\n   (INNER_CLASS_TYPE_P (NODE) && !CLASS_STATIC (TYPE_NAME (NODE)))"}, {"sha": "425dc4d274620225e2e941e3a123e2f93aa9cdc8", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -683,7 +683,7 @@ load_class (tree class_or_name, int verbose)\n \t    break;\n \n \t  /* We failed loading name. Now consider that we might be looking\n-\t     for a inner class. */\n+\t     for an inner class.  */\n \t  if ((separator = strrchr (IDENTIFIER_POINTER (name), '$'))\n \t      || (separator = strrchr (IDENTIFIER_POINTER (name), '.')))\n \t    {"}, {"sha": "c92c34bd6c4574a36280d3a76ba2ab07d0cf74b1", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -62,8 +62,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n    open() call.\n \n    If you want to add another host, add your define to the list below\n-   (i.e. defined(WIN32) || defined(YOUR_HOST)) and add an host-specific\n-   .c file to Make-lang.in similar to win32-host.c  */\n+   (i.e. defined(WIN32) || defined(YOUR_HOST)) and add a host-specific\n+   .c file to Make-lang.in similar to win32-host.c.  */\n #if defined(WIN32)\n extern int\n jcf_open_exact_case (const char* filename, int oflag);"}, {"sha": "d95be2677076160264ebcb34b828d1259175c8b5", "filename": "gcc/java/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -157,7 +157,7 @@ extern void parse_error_context (tree cl, const char *gmsgid, ...) ATTRIBUTE_GCC\n    IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (TYPE))))\n \n /* Pedantic warning on obsolete modifiers. Note: when cl is NULL,\n-   flags was set artificially, such as for a interface method */\n+   flags was set artificially, such as for an interface method.  */\n #define OBSOLETE_MODIFIER_WARNING(cl, flags, __modifier, arg)                \\\n   {                                                                          \\\n     if (flag_redundant && (cl) && ((flags) & (__modifier)))\t\t     \\"}, {"sha": "11c273863f4740ccc81d9a64580b321e107c8b23", "filename": "gcc/java/parse.y", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -6074,8 +6074,8 @@ resolve_and_layout (tree something, tree cl)\n   if (TREE_CODE (something) == EXPR_WITH_FILE_LOCATION)\n     something = EXPR_WFL_NODE (something);\n \n-  /* Otherwise, if something is not and IDENTIFIER_NODE, it can be a a\n-     TYPE_DECL or a real TYPE */\n+  /* Otherwise, if something is not and IDENTIFIER_NODE, it can be a\n+     TYPE_DECL or a real TYPE.  */\n   else if (TREE_CODE (something) != IDENTIFIER_NODE)\n     something = (TREE_CODE (TYPE_NAME (something)) == TYPE_DECL ?\n \t    DECL_NAME (TYPE_NAME (something)) : TYPE_NAME (something));"}, {"sha": "7a4abf85cdb91249d58e7feaacf585ce78b70f4b", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd64dc985a81b4eb80a238f633df9f8e9c40ed90/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=cd64dc985a81b4eb80a238f633df9f8e9c40ed90", "patch": "@@ -329,7 +329,7 @@ java_array_type_length (tree array_type)\n   return -1;\n }\n \n-/* An array of unknown length will be ultimately given an length of\n+/* An array of unknown length will be ultimately given a length of\n    -2, so that we can still have `length' producing a negative value\n    even if found. This was part of an optimization aiming at removing\n    `length' from static arrays. We could restore it, FIXME.  */"}]}