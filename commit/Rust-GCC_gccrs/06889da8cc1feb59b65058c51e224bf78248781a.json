{"sha": "06889da8cc1feb59b65058c51e224bf78248781a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY4ODlkYThjYzFmZWI1OWI2NTA1OGM1MWUyMjRiZjc4MjQ4NzgxYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:56:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:56:24Z"}, "message": "poly_int: expand_debug_expr\n\nThis patch makes expand_debug_expr track polynomial memory offsets.\nIt simplifies the handling of the case in which the reference is not\nto the first byte of the base, which seemed non-trivial enough to\nmake it worth splitting out as a separate patch.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree.h (get_inner_reference): Add a version that returns the\n\toffset and size as poly_int64_pods rather than HOST_WIDE_INTs.\n\t* cfgexpand.c (expand_debug_expr): Track polynomial offsets.  Simply\n\tthe case in which bitpos is not associated with the first byte.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255892", "tree": {"sha": "57a0599b5088de25892ba4b6ed4e28bf05925cce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57a0599b5088de25892ba4b6ed4e28bf05925cce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06889da8cc1feb59b65058c51e224bf78248781a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06889da8cc1feb59b65058c51e224bf78248781a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06889da8cc1feb59b65058c51e224bf78248781a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06889da8cc1feb59b65058c51e224bf78248781a/comments", "author": null, "committer": null, "parents": [{"sha": "a85d87b20c607cdcb878901cee8535bdd35489d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a85d87b20c607cdcb878901cee8535bdd35489d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a85d87b20c607cdcb878901cee8535bdd35489d4"}], "stats": {"total": 60, "additions": 38, "deletions": 22}, "files": [{"sha": "3aca9c59ccd5de472136f775b833d7ac9ff2e337", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06889da8cc1feb59b65058c51e224bf78248781a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06889da8cc1feb59b65058c51e224bf78248781a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06889da8cc1feb59b65058c51e224bf78248781a", "patch": "@@ -1,3 +1,12 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree.h (get_inner_reference): Add a version that returns the\n+\toffset and size as poly_int64_pods rather than HOST_WIDE_INTs.\n+\t* cfgexpand.c (expand_debug_expr): Track polynomial offsets.  Simply\n+\tthe case in which bitpos is not associated with the first byte.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "d509326b9e649adfa3c238c13fe47072e7eb6724", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06889da8cc1feb59b65058c51e224bf78248781a/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06889da8cc1feb59b65058c51e224bf78248781a/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=06889da8cc1feb59b65058c51e224bf78248781a", "patch": "@@ -4470,15 +4470,15 @@ expand_debug_expr (tree exp)\n     case VIEW_CONVERT_EXPR:\n       {\n \tmachine_mode mode1;\n-\tHOST_WIDE_INT bitsize, bitpos;\n+\tpoly_int64 bitsize, bitpos;\n \ttree offset;\n \tint reversep, volatilep = 0;\n \ttree tem\n \t  = get_inner_reference (exp, &bitsize, &bitpos, &offset, &mode1,\n \t\t\t\t &unsignedp, &reversep, &volatilep);\n \trtx orig_op0;\n \n-\tif (bitsize == 0)\n+\tif (known_eq (bitsize, 0))\n \t  return NULL;\n \n \torig_op0 = op0 = expand_debug_expr (tem);\n@@ -4521,19 +4521,14 @@ expand_debug_expr (tree exp)\n \t    if (mode1 == VOIDmode)\n \t      /* Bitfield.  */\n \t      mode1 = smallest_int_mode_for_size (bitsize);\n-\t    if (bitpos >= BITS_PER_UNIT)\n+\t    poly_int64 bytepos = bits_to_bytes_round_down (bitpos);\n+\t    if (maybe_ne (bytepos, 0))\n \t      {\n-\t\top0 = adjust_address_nv (op0, mode1, bitpos / BITS_PER_UNIT);\n-\t\tbitpos %= BITS_PER_UNIT;\n+\t\top0 = adjust_address_nv (op0, mode1, bytepos);\n+\t\tbitpos = num_trailing_bits (bitpos);\n \t      }\n-\t    else if (bitpos < 0)\n-\t      {\n-\t\tHOST_WIDE_INT units\n-\t\t  = (-bitpos + BITS_PER_UNIT - 1) / BITS_PER_UNIT;\n-\t\top0 = adjust_address_nv (op0, mode1, -units);\n-\t\tbitpos += units * BITS_PER_UNIT;\n-\t      }\n-\t    else if (bitpos == 0 && bitsize == GET_MODE_BITSIZE (mode))\n+\t    else if (known_eq (bitpos, 0)\n+\t\t     && known_eq (bitsize, GET_MODE_BITSIZE (mode)))\n \t      op0 = adjust_address_nv (op0, mode, 0);\n \t    else if (GET_MODE (op0) != mode1)\n \t      op0 = adjust_address_nv (op0, mode1, 0);\n@@ -4544,17 +4539,18 @@ expand_debug_expr (tree exp)\n \t    set_mem_attributes (op0, exp, 0);\n \t  }\n \n-\tif (bitpos == 0 && mode == GET_MODE (op0))\n+\tif (known_eq (bitpos, 0) && mode == GET_MODE (op0))\n \t  return op0;\n \n-        if (bitpos < 0)\n+\tif (maybe_lt (bitpos, 0))\n           return NULL;\n \n \tif (GET_MODE (op0) == BLKmode)\n \t  return NULL;\n \n-\tif ((bitpos % BITS_PER_UNIT) == 0\n-\t    && bitsize == GET_MODE_BITSIZE (mode1))\n+\tpoly_int64 bytepos;\n+\tif (multiple_p (bitpos, BITS_PER_UNIT, &bytepos)\n+\t    && known_eq (bitsize, GET_MODE_BITSIZE (mode1)))\n \t  {\n \t    machine_mode opmode = GET_MODE (op0);\n \n@@ -4567,12 +4563,11 @@ expand_debug_expr (tree exp)\n \t       debug stmts).  The gen_subreg below would rightfully\n \t       crash, and the address doesn't really exist, so just\n \t       drop it.  */\n-\t    if (bitpos >= GET_MODE_BITSIZE (opmode))\n+\t    if (known_ge (bitpos, GET_MODE_BITSIZE (opmode)))\n \t      return NULL;\n \n-\t    if ((bitpos % GET_MODE_BITSIZE (mode)) == 0)\n-\t      return simplify_gen_subreg (mode, op0, opmode,\n-\t\t\t\t\t  bitpos / BITS_PER_UNIT);\n+\t    if (multiple_p (bitpos, GET_MODE_BITSIZE (mode)))\n+\t      return simplify_gen_subreg (mode, op0, opmode, bytepos);\n \t  }\n \n \treturn simplify_gen_ternary (SCALAR_INT_MODE_P (GET_MODE (op0))\n@@ -4582,7 +4577,8 @@ expand_debug_expr (tree exp)\n \t\t\t\t     GET_MODE (op0) != VOIDmode\n \t\t\t\t     ? GET_MODE (op0)\n \t\t\t\t     : TYPE_MODE (TREE_TYPE (tem)),\n-\t\t\t\t     op0, GEN_INT (bitsize), GEN_INT (bitpos));\n+\t\t\t\t     op0, gen_int_mode (bitsize, word_mode),\n+\t\t\t\t     gen_int_mode (bitpos, word_mode));\n       }\n \n     case ABS_EXPR:"}, {"sha": "db87321882797a4426057eeb96f86b17634e240c", "filename": "gcc/tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06889da8cc1feb59b65058c51e224bf78248781a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06889da8cc1feb59b65058c51e224bf78248781a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=06889da8cc1feb59b65058c51e224bf78248781a", "patch": "@@ -5638,6 +5638,17 @@ extern bool complete_ctor_at_level_p (const_tree, HOST_WIDE_INT, const_tree);\n    the access position and size.  */\n extern tree get_inner_reference (tree, HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t\t tree *, machine_mode *, int *, int *, int *);\n+/* Temporary.  */\n+inline tree\n+get_inner_reference (tree exp, poly_int64_pod *pbitsize,\n+\t\t     poly_int64_pod *pbitpos, tree *poffset,\n+\t\t     machine_mode *pmode, int *punsignedp,\n+\t\t     int *preversep, int *pvolatilep)\n+{\n+  return get_inner_reference (exp, &pbitsize->coeffs[0], &pbitpos->coeffs[0],\n+\t\t\t      poffset, pmode, punsignedp, preversep,\n+\t\t\t      pvolatilep);\n+}\n \n extern tree build_personality_function (const char *);\n "}]}