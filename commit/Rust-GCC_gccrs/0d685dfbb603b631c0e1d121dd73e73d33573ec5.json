{"sha": "0d685dfbb603b631c0e1d121dd73e73d33573ec5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ2ODVkZmJiNjAzYjYzMWMwZTFkMTIxZGQ3M2U3M2QzMzU3M2VjNQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-06-07T16:49:56Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-07-16T16:52:47Z"}, "message": "rs6000: Add functions for matching types, part 1 of 3\n\n2021-06-07  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-gen-builtins.c (void_status): New enum.\n\t(basetype): Likewise.\n\t(typeinfo): Likewise.\n\t(handle_pointer): New function.\n\t(match_basetype): New stub function.\n\t(match_const_restriction): Likewise.\n\t(match_type): New function.", "tree": {"sha": "ef44af73995dbf67b0cf22425a0839ae49f45168", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef44af73995dbf67b0cf22425a0839ae49f45168"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d685dfbb603b631c0e1d121dd73e73d33573ec5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d685dfbb603b631c0e1d121dd73e73d33573ec5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d685dfbb603b631c0e1d121dd73e73d33573ec5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d685dfbb603b631c0e1d121dd73e73d33573ec5/comments", "author": null, "committer": null, "parents": [{"sha": "9abd2ac5a9b694bcdd871165d109f94866032534", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abd2ac5a9b694bcdd871165d109f94866032534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9abd2ac5a9b694bcdd871165d109f94866032534"}], "stats": {"total": 367, "additions": 367, "deletions": 0}, "files": [{"sha": "384507142463d8149b3e36640f98a56f584a9a09", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d685dfbb603b631c0e1d121dd73e73d33573ec5/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d685dfbb603b631c0e1d121dd73e73d33573ec5/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=0d685dfbb603b631c0e1d121dd73e73d33573ec5", "patch": "@@ -186,6 +186,52 @@ static char linebuf[LINELEN];\n static int line;\n static int pos;\n \n+/* Used to determine whether a type can be void (only return types).  */\n+enum void_status\n+{\n+ VOID_NOTOK,\n+ VOID_OK\n+};\n+\n+/* Legal base types for an argument or return type.  */\n+enum basetype\n+{\n+  BT_CHAR,\n+  BT_SHORT,\n+  BT_INT,\n+  BT_LONG,\n+  BT_LONGLONG,\n+  BT_FLOAT,\n+  BT_DOUBLE,\n+  BT_LONGDOUBLE,\n+  BT_INT128,\n+  BT_FLOAT128,\n+  BT_BOOL,\n+  BT_STRING,\n+  BT_DECIMAL32,\n+  BT_DECIMAL64,\n+  BT_DECIMAL128,\n+  BT_IBM128,\n+  BT_VPAIR,\n+  BT_VQUAD\n+};\n+\n+/* Type modifiers for an argument or return type.  */\n+struct typeinfo\n+{\n+  char isvoid;\n+  char isconst;\n+  char isvector;\n+  char issigned;\n+  char isunsigned;\n+  char isbool;\n+  char ispixel;\n+  char ispointer;\n+  basetype base;\n+  char *val1;\n+  char *val2;\n+};\n+\n /* Pointer to a diagnostic function.  */\n static void (*diag) (const char *, ...)\n   __attribute__ ((format (printf, 1, 2)));\n@@ -320,3 +366,324 @@ match_to_right_bracket (void)\n   pos = lastpos + 1;\n   return buf;\n }\n+\n+static inline void\n+handle_pointer (typeinfo *typedata)\n+{\n+  consume_whitespace ();\n+  if (linebuf[pos] == '*')\n+    {\n+      typedata->ispointer = 1;\n+      safe_inc_pos ();\n+    }\n+}\n+\n+/* Match one of the allowable base types.  Consumes one token unless the\n+   token is \"long\", which must be paired with a second \"long\".  Optionally\n+   consumes a following '*' token for pointers.  Return 1 for success,\n+   0 for failure.  */\n+static int\n+match_basetype (typeinfo *typedata)\n+{\n+  return 1;\n+}\n+\n+/* A const int argument may be restricted to certain values.  This is\n+   indicated by one of the following occurring after the \"int' token:\n+\n+     <x>   restricts the constant to x bits, interpreted as unsigned\n+     <x,y> restricts the constant to the inclusive range [x,y]\n+     [x,y] restricts the constant to the inclusive range [x,y],\n+\t   but only applies if the argument is constant.\n+     {x,y} restricts the constant to one of two values, x or y.\n+\n+   Here x and y are integer tokens.  Note that the \"const\" token is a\n+   lie when the restriction is [x,y], but this simplifies the parsing\n+   significantly and is hopefully forgivable.\n+\n+   Return 1 for success, else 0.  */\n+static int\n+match_const_restriction (typeinfo *typedata)\n+{\n+  return 1;\n+}\n+\n+/* Look for a type, which can be terminated by a token that is not part of\n+   a type, a comma, or a closing parenthesis.  Place information about the\n+   type in TYPEDATA.  Return 1 for success, 0 for failure.  */\n+static int\n+match_type (typeinfo *typedata, int voidok)\n+{\n+  /* A legal type is of the form:\n+\n+       [const] [[signed|unsigned] <basetype> | <vectype>] [*]\n+\n+     Legal values of <basetype> are (for now):\n+\n+       char\n+       short\n+       int\n+       long\n+       long double\n+       long long\n+       float\n+       double\n+       __int128\n+       _Float128\n+       bool\n+       string\n+       _Decimal32\n+       _Decimal64\n+       _Decimal128\n+       __ibm128\n+\n+     Legal values of <vectype> are as follows, and are shorthand for\n+     the associated meaning:\n+\n+       vsc\tvector signed char\n+       vuc\tvector unsigned char\n+       vbc\tvector bool char\n+       vss\tvector signed short\n+       vus\tvector unsigned short\n+       vbs\tvector bool short\n+       vsi\tvector signed int\n+       vui\tvector unsigned int\n+       vbi\tvector bool int\n+       vsll\tvector signed long long\n+       vull\tvector unsigned long long\n+       vbll\tvector bool long long\n+       vsq\tvector signed __int128\n+       vuq\tvector unsigned __int128\n+       vbq\tvector bool __int128\n+       vp\tvector pixel\n+       vf\tvector float\n+       vd\tvector double\n+       v256\t__vector_pair\n+       v512\t__vector_quad\n+\n+     For simplicity, We don't support \"short int\" and \"long long int\".\n+     We don't currently support a <basetype> of \"_Float16\".  \"signed\"\n+     and \"unsigned\" only apply to integral base types.  The optional *\n+     indicates a pointer type.  */\n+\n+  consume_whitespace ();\n+  memset (typedata, 0, sizeof *typedata);\n+  int oldpos = pos;\n+\n+  char *token = match_identifier ();\n+  if (!token)\n+    return 0;\n+\n+  if (!strcmp (token, \"const\"))\n+    {\n+      typedata->isconst = 1;\n+      consume_whitespace ();\n+      oldpos = pos;\n+      token = match_identifier ();\n+    }\n+\n+  if (!strcmp (token, \"void\"))\n+    typedata->isvoid = 1;\n+\n+  if (!strcmp (token, \"vsc\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->issigned = 1;\n+      typedata->base = BT_CHAR;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vuc\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->isunsigned = 1;\n+      typedata->base = BT_CHAR;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vbc\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->isbool = 1;\n+      typedata->base = BT_CHAR;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vss\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->issigned = 1;\n+      typedata->base = BT_SHORT;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vus\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->isunsigned = 1;\n+      typedata->base = BT_SHORT;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vbs\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->isbool = 1;\n+      typedata->base = BT_SHORT;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vsi\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->issigned = 1;\n+      typedata->base = BT_INT;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vui\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->isunsigned = 1;\n+      typedata->base = BT_INT;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vbi\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->isbool = 1;\n+      typedata->base = BT_INT;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vsll\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->issigned = 1;\n+      typedata->base = BT_LONGLONG;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vull\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->isunsigned = 1;\n+      typedata->base = BT_LONGLONG;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vbll\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->isbool = 1;\n+      typedata->base = BT_LONGLONG;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vsq\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->issigned = 1;\n+      typedata->base = BT_INT128;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vuq\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->isunsigned = 1;\n+      typedata->base = BT_INT128;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vbq\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->isbool = 1;\n+      typedata->base = BT_INT128;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vp\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->ispixel = 1;\n+      typedata->base = BT_SHORT;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vf\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->base = BT_FLOAT;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"vd\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->base = BT_DOUBLE;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"v256\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->base = BT_VPAIR;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"v512\"))\n+    {\n+      typedata->isvector = 1;\n+      typedata->base = BT_VQUAD;\n+      handle_pointer (typedata);\n+      return 1;\n+    }\n+  else if (!strcmp (token, \"signed\"))\n+    typedata->issigned = 1;\n+  else if (!strcmp (token, \"unsigned\"))\n+    typedata->isunsigned = 1;\n+  else if (!typedata->isvoid && !typedata->isconst)\n+    {\n+      /* Push back token.  */\n+      pos = oldpos;\n+      return match_basetype (typedata);\n+    }\n+\n+  if (typedata->isvoid)\n+    {\n+      consume_whitespace ();\n+      if (linebuf[pos] == '*')\n+\t{\n+\t  typedata->ispointer = 1;\n+\t  safe_inc_pos ();\n+\t}\n+      else if (!voidok)\n+\treturn 0;\n+      return 1;\n+    }\n+\n+  if (!typedata->issigned && !typedata->isunsigned)\n+    pos = oldpos;\n+  if (!match_basetype (typedata))\n+    return 0;\n+\n+  if (typedata->isconst)\n+    {\n+      if (typedata->ispointer)\n+\treturn 1;\n+      if (typedata->base != BT_INT)\n+\t{\n+\t  (*diag)(\"'const' at %d requires pointer or integer type\",\n+\t\t  oldpos + 1);\n+\t  return 0;\n+\t}\n+      consume_whitespace ();\n+      if (linebuf[pos] == '<' || linebuf[pos] == '{' || linebuf[pos] == '[')\n+\treturn match_const_restriction (typedata);\n+    }\n+\n+  return 1;\n+}"}]}