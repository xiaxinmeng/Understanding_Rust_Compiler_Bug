{"sha": "89f8f30f3565328a2805adafd22e05219b56d562", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlmOGYzMGYzNTY1MzI4YTI4MDVhZGFmZDIyZTA1MjE5YjU2ZDU2Mg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-02-06T21:49:49Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-02-06T21:49:49Z"}, "message": "loop.texi: Document possibility not to perform disambiguation of loops with multiple latches.\n\n\t* doc/loop.texi: Document possibility not to perform disambiguation\n\tof loops with multiple latches.\n\t* cfgloopmanip.c (alp_enum_p): Removed.\n\t(add_loop): Handle subloops.  Use get_loop_body_with_size.\n\t(create_preheader): Do not allow ENTRY_BLOCK_PTR to be preheader.\n\t* cfghooks.c (redirect_edge_and_branch_force): Set dominator for\n\tthe new forwarder block.\n\t(make_forwarder_block): Only call new_bb_cbk if it is not NULL.\n\tHandle the case latch is NULL.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Avoid cfg modifications\n\twhen marking loop exits.\n\t* ifcvt.c (if_convert): Ditto.  Mark loop exits even if cfg cannot\n\tbe modified.\n\t* loop-init.c (loop_optimizer_init): Do not modify cfg.  Call\n\tdisambiguate_loops_with_multiple_latches.\n\t* tree-cfgcleanup.c (cleanup_tree_cfg_loop): Calculate dominators\n\tbefore fix_loop_structure.\n\t* cfgloop.c: Include pointer-set.h and output.h.\n\t(canonicalize_loop_headers, HEADER_BLOCK, LATCH_EDGE,\n\tupdate_latch_info, mfb_keep_just, mfb_keep_nonlatch): Removed.\n\t(get_loop_latch_edges, find_subloop_latch_edge_by_profile,\n\tfind_subloop_latch_edge_by_ivs, find_subloop_latch_edge,\n\tmfb_redirect_edges_in_set, form_subloop, merge_latch_edges,\n\tdisambiguate_multiple_latches, get_loop_body_with_size,\n\tdisambiguate_loops_with_multiple_latches): New functions.\n\t(flow_loop_dump): Dump multiple latch edges.\n\t(flow_loop_nodes_find): Handle loops with multiple latches.\n\t(flow_loops_find): Ditto. Do not call canonicalize_loop_headers.\n\t(glb_enum_p): Modified.\n\t(get_loop_body): Use get_loop_body_with_size.\n\t* cfgloop.h (LOOPS_HAVE_RECORDED_EXITS): New flag.\n\t(AVOID_CFG_MODIFICATIONS): New constant.\n\t(disambiguate_loops_with_multiple_latches, add_loop,\n\tget_loop_body_with_size): Declare.\n\t* Makefile.in (cfgloop.o): Add pointer-set.h and output.h.\n\n\t* gcc.dg/tree-ssa/loop-25.c: New test.\n\nFrom-SVN: r121670", "tree": {"sha": "0b2228e5e39d0218784f7e5f8304e2e94d0d96c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b2228e5e39d0218784f7e5f8304e2e94d0d96c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89f8f30f3565328a2805adafd22e05219b56d562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89f8f30f3565328a2805adafd22e05219b56d562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89f8f30f3565328a2805adafd22e05219b56d562", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89f8f30f3565328a2805adafd22e05219b56d562/comments", "author": null, "committer": null, "parents": [{"sha": "ca20820ef1e80ac23138cbc3beb5ba895b59a1e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca20820ef1e80ac23138cbc3beb5ba895b59a1e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca20820ef1e80ac23138cbc3beb5ba895b59a1e3"}], "stats": {"total": 879, "additions": 615, "deletions": 264}, "files": [{"sha": "fac53a7ad065ece03bbe60c3a92fa721cd26e80a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -1,3 +1,41 @@\n+2007-02-06  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* doc/loop.texi: Document possibility not to perform disambiguation\n+\tof loops with multiple latches.\n+\t* cfgloopmanip.c (alp_enum_p): Removed.\n+\t(add_loop): Handle subloops.  Use get_loop_body_with_size.\n+\t(create_preheader): Do not allow ENTRY_BLOCK_PTR to be preheader.\n+\t* cfghooks.c (redirect_edge_and_branch_force): Set dominator for\n+\tthe new forwarder block.\n+\t(make_forwarder_block): Only call new_bb_cbk if it is not NULL.\n+\tHandle the case latch is NULL.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Avoid cfg modifications\n+\twhen marking loop exits.\n+\t* ifcvt.c (if_convert): Ditto.  Mark loop exits even if cfg cannot\n+\tbe modified.\n+\t* loop-init.c (loop_optimizer_init): Do not modify cfg.  Call\n+\tdisambiguate_loops_with_multiple_latches.\n+\t* tree-cfgcleanup.c (cleanup_tree_cfg_loop): Calculate dominators\n+\tbefore fix_loop_structure.\n+\t* cfgloop.c: Include pointer-set.h and output.h.\n+\t(canonicalize_loop_headers, HEADER_BLOCK, LATCH_EDGE,\n+\tupdate_latch_info, mfb_keep_just, mfb_keep_nonlatch): Removed.\n+\t(get_loop_latch_edges, find_subloop_latch_edge_by_profile,\n+\tfind_subloop_latch_edge_by_ivs, find_subloop_latch_edge,\n+\tmfb_redirect_edges_in_set, form_subloop, merge_latch_edges,\n+\tdisambiguate_multiple_latches, get_loop_body_with_size,\n+\tdisambiguate_loops_with_multiple_latches): New functions.\n+\t(flow_loop_dump): Dump multiple latch edges.\n+\t(flow_loop_nodes_find): Handle loops with multiple latches.\n+\t(flow_loops_find): Ditto. Do not call canonicalize_loop_headers.\n+\t(glb_enum_p): Modified.\n+\t(get_loop_body): Use get_loop_body_with_size.\n+\t* cfgloop.h (LOOPS_HAVE_RECORDED_EXITS): New flag.\n+\t(AVOID_CFG_MODIFICATIONS): New constant.\n+\t(disambiguate_loops_with_multiple_latches, add_loop,\n+\tget_loop_body_with_size): Declare.\n+\t* Makefile.in (cfgloop.o): Add pointer-set.h and output.h.\n+\n 2007-02-06  Seongbae Park <seongbae.park@gmail.com>\n \n \tPR inline-asm/28686"}, {"sha": "22111d5ea76ea53110c1d32394f3c9821b450754", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -2585,7 +2585,7 @@ cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(REGS_H) $(EMIT_RTL_H) $(CFGLAYOUT_H) tree-pass.h $(CFGLOOP_H) $(EXPR_H)\n cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(FLAGS_H) $(FUNCTION_H) \\\n-   $(OBSTACK_H) toplev.h $(TREE_FLOW_H) $(TREE_H)\n+   $(OBSTACK_H) toplev.h $(TREE_FLOW_H) $(TREE_H) pointer-set.h output.h\n cfgloopanal.o : cfgloopanal.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) \\\n    $(OBSTACK_H) output.h"}, {"sha": "1fa3aa76498e2451c1245a0808720932fa597cf8", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -378,6 +378,10 @@ redirect_edge_and_branch_force (edge e, basic_block dest)\n     rescan_loop_exit (e, false, true);\n \n   ret = cfg_hooks->redirect_edge_and_branch_force (e, dest);\n+  if (ret != NULL\n+      && dom_info_available_p (CDI_DOMINATORS))\n+    set_immediate_dominator (CDI_DOMINATORS, ret, src);\n+\n   if (current_loops != NULL)\n     {\n       if (ret != NULL)\n@@ -724,7 +728,8 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n \tfallthru->count = 0;\n \n       jump = redirect_edge_and_branch_force (e, bb);\n-      if (jump)\n+      if (jump != NULL\n+\t  && new_bb_cbk != NULL)\n \tnew_bb_cbk (jump);\n     }\n \n@@ -742,9 +747,12 @@ make_forwarder_block (basic_block bb, bool (*redirect_edge_p) (edge),\n       /* If we do not split a loop header, then both blocks belong to the\n \t same loop.  In case we split loop header and do not redirect the\n \t latch edge to DUMMY, then DUMMY belongs to the outer loop, and\n-\t BB becomes the new header.  */\n+\t BB becomes the new header.  If latch is not recorded for the loop,\n+\t we leave this updating on the caller (this may only happen during\n+\t loop analysis).  */\n       loop = dummy->loop_father;\n       if (loop->header == dummy\n+\t  && loop->latch != NULL\n \t  && find_edge (loop->latch, dummy) == NULL)\n \t{\n \t  remove_bb_from_loops (dummy);"}, {"sha": "4465b119f91c29743e80ae4104bd2b06eaecfb9b", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 353, "deletions": 204, "changes": 557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -32,18 +32,11 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"flags.h\"\n #include \"tree.h\"\n #include \"tree-flow.h\"\n-\n-/* Ratio of frequencies of edges so that one of more latch edges is\n-   considered to belong to inner loop with same header.  */\n-#define HEAVY_EDGE_RATIO 8\n-\n-#define HEADER_BLOCK(B) (* (int *) (B)->aux)\n-#define LATCH_EDGE(E) (*(int *) (E)->aux)\n+#include \"pointer-set.h\"\n+#include \"output.h\"\n \n static void flow_loops_cfg_dump (FILE *);\n static void establish_preds (struct loop *);\n-static void canonicalize_loop_headers (void);\n-static bool glb_enum_p (basic_block, void *);\n \f\n /* Dump loop related CFG information.  */\n \n@@ -90,6 +83,24 @@ superloop_at_depth (struct loop *loop, unsigned depth)\n   return loop->pred[depth];\n }\n \n+/* Returns the list of the latch edges of LOOP.  */\n+\n+static VEC (edge, heap) *\n+get_loop_latch_edges (const struct loop *loop)\n+{\n+  edge_iterator ei;\n+  edge e;\n+  VEC (edge, heap) *ret = NULL;\n+\n+  FOR_EACH_EDGE (e, ei, loop->header->preds)\n+    {\n+      if (dominated_by_p (CDI_DOMINATORS, e->src, loop->header))\n+\tVEC_safe_push (edge, heap, ret, e);\n+    }\n+\n+  return ret;\n+}\n+\n /* Dump the loop information specified by LOOP to the stream FILE\n    using auxiliary dump callback function LOOP_DUMP_AUX if non null.  */\n \n@@ -100,14 +111,27 @@ flow_loop_dump (const struct loop *loop, FILE *file,\n {\n   basic_block *bbs;\n   unsigned i;\n+  VEC (edge, heap) *latches;\n+  edge e;\n \n   if (! loop || ! loop->header)\n     return;\n \n   fprintf (file, \";;\\n;; Loop %d\\n\", loop->num);\n \n-  fprintf (file, \";;  header %d, latch %d\\n\",\n-\t   loop->header->index, loop->latch->index);\n+  fprintf (file, \";;  header %d, \", loop->header->index);\n+  if (loop->latch)\n+    fprintf (file, \"latch %d\\n\", loop->latch->index);\n+  else\n+    {\n+      fprintf (file, \"multiple latches:\");\n+      latches = get_loop_latch_edges (loop);\n+      for (i = 0; VEC_iterate (edge, latches, i, e); i++)\n+\tfprintf (file, \" %d\", e->src->index);\n+      VEC_free (edge, heap, latches);\n+      fprintf (file, \"\\n\");\n+    }\n+\n   fprintf (file, \";;  depth %d, outer %ld\\n\",\n \t   loop->depth, (long) (loop->outer ? loop->outer->num : -1));\n \n@@ -198,46 +222,49 @@ flow_loops_free (struct loops *loops)\n int\n flow_loop_nodes_find (basic_block header, struct loop *loop)\n {\n-  basic_block *stack;\n-  int sp;\n+  VEC (basic_block, heap) *stack = NULL;\n   int num_nodes = 1;\n+  edge latch;\n+  edge_iterator latch_ei;\n \n   header->loop_father = loop;\n   header->loop_depth = loop->depth;\n \n-  if (loop->latch->loop_father != loop)\n+  FOR_EACH_EDGE (latch, latch_ei, loop->header->preds)\n     {\n-      stack = XNEWVEC (basic_block, n_basic_blocks);\n-      sp = 0;\n+      if (latch->src->loop_father == loop\n+\t  || !dominated_by_p (CDI_DOMINATORS, latch->src, loop->header))\n+\tcontinue;\n+\n       num_nodes++;\n-      stack[sp++] = loop->latch;\n-      loop->latch->loop_father = loop;\n-      loop->latch->loop_depth = loop->depth;\n+      VEC_safe_push (basic_block, heap, stack, latch->src);\n+      latch->src->loop_father = loop;\n+      latch->src->loop_depth = loop->depth;\n \n-      while (sp)\n+      while (!VEC_empty (basic_block, stack))\n \t{\n \t  basic_block node;\n \t  edge e;\n \t  edge_iterator ei;\n \n-\t  node = stack[--sp];\n+\t  node = VEC_pop (basic_block, stack);\n \n \t  FOR_EACH_EDGE (e, ei, node->preds)\n \t    {\n \t      basic_block ancestor = e->src;\n \n-\t      if (ancestor != ENTRY_BLOCK_PTR\n-\t\t  && ancestor->loop_father != loop)\n+\t      if (ancestor->loop_father != loop)\n \t\t{\n \t\t  ancestor->loop_father = loop;\n \t\t  ancestor->loop_depth = loop->depth;\n \t\t  num_nodes++;\n-\t\t  stack[sp++] = ancestor;\n+\t\t  VEC_safe_push (basic_block, heap, stack, ancestor);\n \t\t}\n \t    }\n \t}\n-      free (stack);\n     }\n+  VEC_free (basic_block, heap, stack);\n+\n   return num_nodes;\n }\n \n@@ -299,156 +326,6 @@ flow_loop_tree_node_remove (struct loop *loop)\n   loop->pred = NULL;\n }\n \n-/* A callback to update latch and header info for basic block JUMP created\n-   by redirecting an edge.  */\n-\n-static void\n-update_latch_info (basic_block jump)\n-{\n-  alloc_aux_for_block (jump, sizeof (int));\n-  HEADER_BLOCK (jump) = 0;\n-  alloc_aux_for_edge (single_pred_edge (jump), sizeof (int));\n-  LATCH_EDGE (single_pred_edge (jump)) = 0;\n-  set_immediate_dominator (CDI_DOMINATORS, jump, single_pred (jump));\n-}\n-\n-/* A callback for make_forwarder block, to redirect all edges except for\n-   MFB_KJ_EDGE to the entry part.  E is the edge for that we should decide\n-   whether to redirect it.  */\n-\n-static edge mfb_kj_edge;\n-static bool\n-mfb_keep_just (edge e)\n-{\n-  return e != mfb_kj_edge;\n-}\n-\n-/* A callback for make_forwarder block, to redirect the latch edges into an\n-   entry part.  E is the edge for that we should decide whether to redirect\n-   it.  */\n-\n-static bool\n-mfb_keep_nonlatch (edge e)\n-{\n-  return LATCH_EDGE (e);\n-}\n-\n-/* Takes care of merging natural loops with shared headers.  */\n-\n-static void\n-canonicalize_loop_headers (void)\n-{\n-  basic_block header;\n-  edge e;\n-\n-  alloc_aux_for_blocks (sizeof (int));\n-  alloc_aux_for_edges (sizeof (int));\n-\n-  /* Split blocks so that each loop has only single latch.  */\n-  FOR_EACH_BB (header)\n-    {\n-      edge_iterator ei;\n-      int num_latches = 0;\n-      int have_abnormal_edge = 0;\n-\n-      FOR_EACH_EDGE (e, ei, header->preds)\n-\t{\n-\t  basic_block latch = e->src;\n-\n-\t  if (e->flags & EDGE_ABNORMAL)\n-\t    have_abnormal_edge = 1;\n-\n-\t  if (latch != ENTRY_BLOCK_PTR\n-\t      && dominated_by_p (CDI_DOMINATORS, latch, header))\n-\t    {\n-\t      num_latches++;\n-\t      LATCH_EDGE (e) = 1;\n-\t    }\n-\t}\n-      if (have_abnormal_edge)\n-\tHEADER_BLOCK (header) = 0;\n-      else\n-\tHEADER_BLOCK (header) = num_latches;\n-    }\n-\n-  if (HEADER_BLOCK (single_succ (ENTRY_BLOCK_PTR)))\n-    {\n-      basic_block bb;\n-\n-      /* We could not redirect edges freely here. On the other hand,\n-\t we can simply split the edge from entry block.  */\n-      bb = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n-\n-      alloc_aux_for_edge (single_succ_edge (bb), sizeof (int));\n-      LATCH_EDGE (single_succ_edge (bb)) = 0;\n-      alloc_aux_for_block (bb, sizeof (int));\n-      HEADER_BLOCK (bb) = 0;\n-    }\n-\n-  FOR_EACH_BB (header)\n-    {\n-      int max_freq, is_heavy;\n-      edge heavy, tmp_edge;\n-      edge_iterator ei;\n-\n-      if (HEADER_BLOCK (header) <= 1)\n-\tcontinue;\n-\n-      /* Find a heavy edge.  */\n-      is_heavy = 1;\n-      heavy = NULL;\n-      max_freq = 0;\n-      FOR_EACH_EDGE (e, ei, header->preds)\n-\tif (LATCH_EDGE (e) &&\n-\t    EDGE_FREQUENCY (e) > max_freq)\n-\t  max_freq = EDGE_FREQUENCY (e);\n-      FOR_EACH_EDGE (e, ei, header->preds)\n-\tif (LATCH_EDGE (e) &&\n-\t    EDGE_FREQUENCY (e) >= max_freq / HEAVY_EDGE_RATIO)\n-\t  {\n-\t    if (heavy)\n-\t      {\n-\t\tis_heavy = 0;\n-\t\tbreak;\n-\t      }\n-\t    else\n-\t      heavy = e;\n-\t  }\n-\n-      if (is_heavy)\n-\t{\n-\t  /* Split out the heavy edge, and create inner loop for it.  */\n-\t  mfb_kj_edge = heavy;\n-\t  tmp_edge = make_forwarder_block (header, mfb_keep_just,\n-\t\t\t\t\t   update_latch_info);\n-\t  alloc_aux_for_block (tmp_edge->dest, sizeof (int));\n-\t  HEADER_BLOCK (tmp_edge->dest) = 1;\n-\t  alloc_aux_for_edge (tmp_edge, sizeof (int));\n-\t  LATCH_EDGE (tmp_edge) = 0;\n-\t  HEADER_BLOCK (header)--;\n-\t}\n-\n-      if (HEADER_BLOCK (header) > 1)\n-\t{\n-\t  /* Create a new latch block.  */\n-\t  tmp_edge = make_forwarder_block (header, mfb_keep_nonlatch,\n-\t\t\t\t\t   update_latch_info);\n-\t  alloc_aux_for_block (tmp_edge->dest, sizeof (int));\n-\t  HEADER_BLOCK (tmp_edge->src) = 0;\n-\t  HEADER_BLOCK (tmp_edge->dest) = 1;\n-\t  alloc_aux_for_edge (tmp_edge, sizeof (int));\n-\t  LATCH_EDGE (tmp_edge) = 1;\n-\t}\n-    }\n-\n-  free_aux_for_blocks ();\n-  free_aux_for_edges ();\n-\n-#ifdef ENABLE_CHECKING\n-  verify_dominators (CDI_DOMINATORS);\n-#endif\n-}\n-\n /* Allocates and returns new loop structure.  */\n \n struct loop *\n@@ -494,9 +371,6 @@ flow_loops_find (struct loops *loops)\n   /* Ensure that the dominators are computed.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* Join loops with shared headers.  */\n-  canonicalize_loop_headers ();\n-\n   /* Count the number of loop headers.  This should be the\n      same as the number of natural loops.  */\n   headers = sbitmap_alloc (last_basic_block);\n@@ -506,7 +380,6 @@ flow_loops_find (struct loops *loops)\n   FOR_EACH_BB (header)\n     {\n       edge_iterator ei;\n-      int more_latches = 0;\n \n       header->loop_depth = 0;\n \n@@ -533,8 +406,6 @@ flow_loops_find (struct loops *loops)\n \t      && dominated_by_p (CDI_DOMINATORS, latch, header))\n \t    {\n \t      /* Shared headers should be eliminated by now.  */\n-\t      gcc_assert (!more_latches);\n-\t      more_latches = 1;\n \t      SET_BIT (headers, header->index);\n \t      num_loops++;\n \t    }\n@@ -589,21 +460,26 @@ flow_loops_find (struct loops *loops)\n \t  loop->num = num_loops;\n \t  num_loops++;\n \n-\t  /* Look for the latch for this header block.  */\n+\t  flow_loop_tree_node_add (header->loop_father, loop);\n+\t  loop->num_nodes = flow_loop_nodes_find (loop->header, loop);\n+\n+\t  /* Look for the latch for this header block, if it has just a\n+\t     single one.  */\n \t  FOR_EACH_EDGE (e, ei, header->preds)\n \t    {\n \t      basic_block latch = e->src;\n \n-\t      if (latch != ENTRY_BLOCK_PTR\n-\t\t  && dominated_by_p (CDI_DOMINATORS, latch, header))\n+\t      if (flow_bb_inside_loop_p (loop, latch))\n \t\t{\n+\t\t  if (loop->latch != NULL)\n+\t\t    {\n+\t\t      /* More than one latch edge.  */\n+\t\t      loop->latch = NULL;\n+\t\t      break;\n+\t\t    }\n \t\t  loop->latch = latch;\n-\t\t  break;\n \t\t}\n \t    }\n-\n-\t  flow_loop_tree_node_add (header->loop_father, loop);\n-\t  loop->num_nodes = flow_loop_nodes_find (loop->header, loop);\n \t}\n \n       free (dfs_order);\n@@ -617,6 +493,264 @@ flow_loops_find (struct loops *loops)\n   return VEC_length (loop_p, loops->larray);\n }\n \n+/* Ratio of frequencies of edges so that one of more latch edges is\n+   considered to belong to inner loop with same header.  */\n+#define HEAVY_EDGE_RATIO 8\n+\n+/* Minimum number of samples for that we apply\n+   find_subloop_latch_edge_by_profile heuristics.  */\n+#define HEAVY_EDGE_MIN_SAMPLES 10\n+\n+/* If the profile info is available, finds an edge in LATCHES that much more\n+   frequent than the remaining edges.  Returns such an edge, or NULL if we do\n+   not find one.\n+\n+   We do not use guessed profile here, only the measured one.  The guessed\n+   profile is usually too flat and unreliable for this (and it is mostly based\n+   on the loop structure of the program, so it does not make much sense to\n+   derive the loop structure from it).  */\n+   \n+static edge\n+find_subloop_latch_edge_by_profile (VEC (edge, heap) *latches)\n+{\n+  unsigned i;\n+  edge e, me = NULL;\n+  gcov_type mcount = 0, tcount = 0;\n+\n+  for (i = 0; VEC_iterate (edge, latches, i, e); i++)\n+    {\n+      if (e->count > mcount)\n+\t{\n+\t  me = e;\n+\t  mcount = e->count;\n+\t}\n+      tcount += e->count;\n+    }\n+\n+  if (tcount < HEAVY_EDGE_MIN_SAMPLES\n+      || (tcount - mcount) * HEAVY_EDGE_RATIO > tcount)\n+    return NULL;\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Found latch edge %d -> %d using profile information.\\n\",\n+\t     me->src->index, me->dest->index);\n+  return me;\n+}\n+\n+/* Among LATCHES, guesses a latch edge of LOOP corresponding to subloop, based\n+   on the structure of induction variables.  Returns this edge, or NULL if we\n+   do not find any.\n+\n+   We are quite conservative, and look just for an obvious simple innermost\n+   loop (which is the case where we would lose the most performance by not\n+   disambiguating the loop).  More precisely, we look for the following\n+   situation: The source of the chosen latch edge dominates sources of all\n+   the other latch edges.  Additionally, the header does not contain a phi node\n+   such that the argument from the chosen edge is equal to the argument from\n+   another edge.  */\n+\n+static edge\n+find_subloop_latch_edge_by_ivs (struct loop *loop, VEC (edge, heap) *latches)\n+{\n+  edge e, latch = VEC_index (edge, latches, 0);\n+  unsigned i;\n+  tree phi, lop;\n+  basic_block bb;\n+\n+  /* Find the candidate for the latch edge.  */\n+  for (i = 1; VEC_iterate (edge, latches, i, e); i++)\n+    if (dominated_by_p (CDI_DOMINATORS, latch->src, e->src))\n+      latch = e;\n+\n+  /* Verify that it dominates all the latch edges.  */\n+  for (i = 0; VEC_iterate (edge, latches, i, e); i++)\n+    if (!dominated_by_p (CDI_DOMINATORS, e->src, latch->src))\n+      return NULL;\n+\n+  /* Check for a phi node that would deny that this is a latch edge of\n+     a subloop.  */\n+  for (phi = phi_nodes (loop->header); phi; phi = PHI_CHAIN (phi))\n+    {\n+      lop = PHI_ARG_DEF_FROM_EDGE (phi, latch);\n+\n+      /* Ignore the values that are not changed inside the subloop.  */\n+      if (TREE_CODE (lop) != SSA_NAME\n+\t  || SSA_NAME_DEF_STMT (lop) == phi)\n+\tcontinue;\n+      bb = bb_for_stmt (SSA_NAME_DEF_STMT (lop));\n+      if (!bb || !flow_bb_inside_loop_p (loop, bb))\n+\tcontinue;\n+\n+      for (i = 0; VEC_iterate (edge, latches, i, e); i++)\n+\tif (e != latch\n+\t    && PHI_ARG_DEF_FROM_EDGE (phi, e) == lop)\n+\t  return NULL;\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"Found latch edge %d -> %d using iv structure.\\n\",\n+\t     latch->src->index, latch->dest->index);\n+  return latch;\n+}\n+\n+/* If we can determine that one of the several latch edges of LOOP behaves\n+   as a latch edge of a separate subloop, returns this edge.  Otherwise\n+   returns NULL.  */\n+\n+static edge\n+find_subloop_latch_edge (struct loop *loop)\n+{\n+  VEC (edge, heap) *latches = get_loop_latch_edges (loop);\n+  edge latch = NULL;\n+\n+  if (VEC_length (edge, latches) > 1)\n+    {\n+      latch = find_subloop_latch_edge_by_profile (latches);\n+\n+      if (!latch\n+\t  /* We consider ivs to guess the latch edge only in SSA.  Perhaps we\n+\t     should use cfghook for this, but it is hard to imagine it would\n+\t     be useful elsewhere.  */\n+\t  && current_ir_type () == IR_GIMPLE)\n+\tlatch = find_subloop_latch_edge_by_ivs (loop, latches);\n+    }\n+\n+  VEC_free (edge, heap, latches);\n+  return latch;\n+}\n+\n+/* Callback for make_forwarder_block.  Returns true if the edge E is marked\n+   in the set MFB_REIS_SET.  */\n+\n+static struct pointer_set_t *mfb_reis_set;\n+static bool\n+mfb_redirect_edges_in_set (edge e)\n+{\n+  return pointer_set_contains (mfb_reis_set, e);\n+}\n+\n+/* Creates a subloop of LOOP with latch edge LATCH.  */\n+\n+static void\n+form_subloop (struct loop *loop, edge latch)\n+{\n+  edge_iterator ei;\n+  edge e, new_entry;\n+  struct loop *new_loop;\n+      \n+  mfb_reis_set = pointer_set_create ();\n+  FOR_EACH_EDGE (e, ei, loop->header->preds)\n+    {\n+      if (e != latch)\n+\tpointer_set_insert (mfb_reis_set, e);\n+    }\n+  new_entry = make_forwarder_block (loop->header, mfb_redirect_edges_in_set,\n+\t\t\t\t    NULL);\n+  pointer_set_destroy (mfb_reis_set);\n+\n+  loop->header = new_entry->src;\n+\n+  /* Find the blocks and subloops that belong to the new loop, and add it to\n+     the appropriate place in the loop tree.  */\n+  new_loop = alloc_loop ();\n+  new_loop->header = new_entry->dest;\n+  new_loop->latch = latch->src;\n+  add_loop (new_loop, loop);\n+}\n+\n+/* Make all the latch edges of LOOP to go to a single forwarder block --\n+   a new latch of LOOP.  */\n+\n+static void\n+merge_latch_edges (struct loop *loop)\n+{\n+  VEC (edge, heap) *latches = get_loop_latch_edges (loop);\n+  edge latch, e;\n+  unsigned i;\n+\n+  gcc_assert (VEC_length (edge, latches) > 0);\n+\n+  if (VEC_length (edge, latches) == 1)\n+    loop->latch = VEC_index (edge, latches, 0)->src;\n+  else\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Merged latch edges of loop %d\\n\", loop->num);\n+\n+      mfb_reis_set = pointer_set_create ();\n+      for (i = 0; VEC_iterate (edge, latches, i, e); i++)\n+\tpointer_set_insert (mfb_reis_set, e);\n+      latch = make_forwarder_block (loop->header, mfb_redirect_edges_in_set,\n+\t\t\t\t    NULL);\n+      pointer_set_destroy (mfb_reis_set);\n+\n+      loop->header = latch->dest;\n+      loop->latch = latch->src;\n+    }\n+\n+  VEC_free (edge, heap, latches);\n+}\n+\n+/* LOOP may have several latch edges.  Transform it into (possibly several)\n+   loops with single latch edge.  */\n+\n+static void\n+disambiguate_multiple_latches (struct loop *loop)\n+{\n+  edge e;\n+\n+  /* We eliminate the mutiple latches by splitting the header to the forwarder\n+     block F and the rest R, and redirecting the edges.  There are two cases:\n+\n+     1) If there is a latch edge E that corresponds to a subloop (we guess\n+        that based on profile -- if it is taken much more often than the\n+\tremaining edges; and on trees, using the information about induction\n+\tvariables of the loops), we redirect E to R, all the remaining edges to\n+\tF, then rescan the loops and try again for the outer loop.\n+     2) If there is no such edge, we redirect all latch edges to F, and the\n+        entry edges to R, thus making F the single latch of the loop.  */\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Disambiguating loop %d with multiple latches\\n\",\n+\t     loop->num);\n+\n+  /* During latch merging, we may need to redirect the entry edges to a new\n+     block.  This would cause problems if the entry edge was the one from the\n+     entry block.  To avoid having to handle this case specially, split\n+     such entry edge.  */\n+  e = find_edge (ENTRY_BLOCK_PTR, loop->header);\n+  if (e)\n+    split_edge (e);\n+\n+  while (1)\n+    {\n+      e = find_subloop_latch_edge (loop);\n+      if (!e)\n+\tbreak;\n+\n+      form_subloop (loop, e);\n+    }\n+\n+  merge_latch_edges (loop);\n+}\n+\n+/* Split loops with multiple latch edges.  */\n+\n+void\n+disambiguate_loops_with_multiple_latches (void)\n+{\n+  loop_iterator li;\n+  struct loop *loop;\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      if (!loop->latch)\n+\tdisambiguate_multiple_latches (loop);\n+    }\n+}\n+\n /* Return nonzero if basic block BB belongs to LOOP.  */\n bool\n flow_bb_inside_loop_p (const struct loop *loop, const basic_block bb)\n@@ -630,44 +764,59 @@ flow_bb_inside_loop_p (const struct loop *loop, const basic_block bb)\n   return loop == source_loop || flow_loop_nested_p (loop, source_loop);\n }\n \n-/* Enumeration predicate for get_loop_body.  */\n+/* Enumeration predicate for get_loop_body_with_size.  */\n static bool\n-glb_enum_p (basic_block bb, void *glb_header)\n+glb_enum_p (basic_block bb, void *glb_loop)\n+{\n+  struct loop *loop = glb_loop;\n+  return (bb != loop->header\n+\t  && dominated_by_p (CDI_DOMINATORS, bb, loop->header));\n+}\n+\n+/* Gets basic blocks of a LOOP.  Header is the 0-th block, rest is in dfs\n+   order against direction of edges from latch.  Specially, if\n+   header != latch, latch is the 1-st block.  LOOP cannot be the fake\n+   loop tree root, and its size must be at most MAX_SIZE.  The blocks\n+   in the LOOP body are stored to BODY, and the size of the LOOP is\n+   returned.  */\n+\n+unsigned\n+get_loop_body_with_size (const struct loop *loop, basic_block *body,\n+\t\t\t unsigned max_size)\n {\n-  return bb != (basic_block) glb_header;\n+  return dfs_enumerate_from (loop->header, 1, glb_enum_p,\n+\t\t\t     body, max_size, (void *) loop);\n }\n \n /* Gets basic blocks of a LOOP.  Header is the 0-th block, rest is in dfs\n    order against direction of edges from latch.  Specially, if\n    header != latch, latch is the 1-st block.  */\n+\n basic_block *\n get_loop_body (const struct loop *loop)\n {\n-  basic_block *tovisit, bb;\n+  basic_block *body, bb;\n   unsigned tv = 0;\n \n   gcc_assert (loop->num_nodes);\n \n-  tovisit = XCNEWVEC (basic_block, loop->num_nodes);\n-  tovisit[tv++] = loop->header;\n+  body = XCNEWVEC (basic_block, loop->num_nodes);\n \n   if (loop->latch == EXIT_BLOCK_PTR)\n     {\n-      /* There may be blocks unreachable from EXIT_BLOCK.  */\n+      /* There may be blocks unreachable from EXIT_BLOCK, hence we need to\n+\t special-case the fake loop that contains the whole function.  */\n       gcc_assert (loop->num_nodes == (unsigned) n_basic_blocks);\n+      body[tv++] = loop->header;\n+      body[tv++] = EXIT_BLOCK_PTR;\n       FOR_EACH_BB (bb)\n-\ttovisit[tv++] = bb;\n-      tovisit[tv++] = EXIT_BLOCK_PTR;\n-    }\n-  else if (loop->latch != loop->header)\n-    {\n-      tv = dfs_enumerate_from (loop->latch, 1, glb_enum_p,\n-\t\t\t       tovisit + 1, loop->num_nodes - 1,\n-\t\t\t       loop->header) + 1;\n+\tbody[tv++] = bb;\n     }\n+  else\n+    tv = get_loop_body_with_size (loop, body, loop->num_nodes);\n \n   gcc_assert (tv == loop->num_nodes);\n-  return tovisit;\n+  return body;\n }\n \n /* Fills dominance descendants inside LOOP of the basic block BB into"}, {"sha": "09eef08ca3de1aba309e50f074cf10b95456b7a1", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -168,11 +168,13 @@ enum\n   LOOPS_HAVE_PREHEADERS = 1,\n   LOOPS_HAVE_SIMPLE_LATCHES = 2,\n   LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS = 4,\n-  LOOPS_HAVE_RECORDED_EXITS = 8\n+  LOOPS_HAVE_RECORDED_EXITS = 8,\n+  LOOPS_MAY_HAVE_MULTIPLE_LATCHES = 16\n };\n \n #define LOOPS_NORMAL (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES \\\n \t\t      | LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS)\n+#define AVOID_CFG_MODIFICATIONS (LOOPS_MAY_HAVE_MULTIPLE_LATCHES)\n \n typedef struct loop *loop_p;\n DEF_VEC_P (loop_p);\n@@ -198,6 +200,7 @@ struct loops\n \n /* Loop recognition.  */\n extern int flow_loops_find (struct loops *);\n+extern void disambiguate_loops_with_multiple_latches (void);\n extern void flow_loops_free (struct loops *);\n extern void flow_loops_dump (FILE *,\n \t\t\t     void (*)(const struct loop *, FILE *, int), int);\n@@ -215,6 +218,7 @@ void rescan_loop_exit (edge, bool, bool);\n /* Loop data structure manipulation/querying.  */\n extern void flow_loop_tree_node_add (struct loop *, struct loop *);\n extern void flow_loop_tree_node_remove (struct loop *);\n+extern void add_loop (struct loop *, struct loop *);\n extern bool flow_loop_nested_p\t(const struct loop *, const struct loop *);\n extern bool flow_bb_inside_loop_p (const struct loop *, const basic_block);\n extern struct loop * find_common_loop (struct loop *, struct loop *);\n@@ -229,6 +233,8 @@ extern void mark_loop_exit_edges (void);\n \n /* Loops & cfg manipulation.  */\n extern basic_block *get_loop_body (const struct loop *);\n+extern unsigned get_loop_body_with_size (const struct loop *, basic_block *,\n+\t\t\t\t\t unsigned);\n extern basic_block *get_loop_body_in_dom_order (const struct loop *);\n extern basic_block *get_loop_body_in_bfs_order (const struct loop *);\n extern VEC (edge, heap) *get_loop_exit_edges (const struct loop *);"}, {"sha": "9ca3947a0c60df20dd3b2234c573c1f9f88e2559", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -38,11 +38,9 @@ static void loop_redirect_edge (edge, basic_block);\n static void remove_bbs (basic_block *, int);\n static bool rpe_enum_p (basic_block, void *);\n static int find_path (edge, basic_block **);\n-static bool alp_enum_p (basic_block, void *);\n static void fix_loop_placements (struct loop *, bool *);\n static bool fix_bb_placement (basic_block);\n static void fix_bb_placements (basic_block, bool *);\n-static void place_new_loop (struct loop *);\n static basic_block create_preheader (struct loop *, int);\n static void unloop (struct loop *, bool *);\n \n@@ -395,39 +393,54 @@ remove_path (edge e)\n   return true;\n }\n \n-/* Predicate for enumeration in add_loop.  */\n-static bool\n-alp_enum_p (basic_block bb, void *alp_header)\n+/* Creates place for a new LOOP in loops structure.  */\n+\n+static void\n+place_new_loop (struct loop *loop)\n {\n-  return bb != (basic_block) alp_header;\n+  loop->num = number_of_loops ();\n+  VEC_safe_push (loop_p, heap, current_loops->larray, loop);\n }\n \n /* Given LOOP structure with filled header and latch, find the body of the\n    corresponding loop and add it to loops tree.  Insert the LOOP as a son of\n    outer.  */\n \n-static void\n+void\n add_loop (struct loop *loop, struct loop *outer)\n {\n   basic_block *bbs;\n   int i, n;\n+  struct loop *subloop;\n \n   /* Add it to loop structure.  */\n   place_new_loop (loop);\n   flow_loop_tree_node_add (outer, loop);\n \n   /* Find its nodes.  */\n-  bbs = XCNEWVEC (basic_block, n_basic_blocks);\n-  n = dfs_enumerate_from (loop->latch, 1, alp_enum_p,\n-\t\t\t  bbs, n_basic_blocks, loop->header);\n+  bbs = XNEWVEC (basic_block, n_basic_blocks);\n+  n = get_loop_body_with_size (loop, bbs, n_basic_blocks);\n \n   for (i = 0; i < n; i++)\n     {\n-      remove_bb_from_loops (bbs[i]);\n-      add_bb_to_loop (bbs[i], loop);\n+      if (bbs[i]->loop_father == outer)\n+\t{\n+\t  remove_bb_from_loops (bbs[i]);\n+\t  add_bb_to_loop (bbs[i], loop);\n+\t  continue;\n+\t}\n+\n+      loop->num_nodes++;\n+\n+      /* If we find a direct subloop of OUTER, move it to LOOP.  */\n+      subloop = bbs[i]->loop_father;\n+      if (subloop->outer == outer\n+\t  && subloop->header == bbs[i])\n+\t{\n+\t  flow_loop_tree_node_remove (subloop);\n+\t  flow_loop_tree_node_add (loop, subloop);\n+\t}\n     }\n-  remove_bb_from_loops (loop->header);\n-  add_bb_to_loop (loop->header, loop);\n \n   free (bbs);\n }\n@@ -631,14 +644,6 @@ fix_loop_placements (struct loop *loop, bool *irred_invalidated)\n     }\n }\n \n-/* Creates place for a new LOOP in loops structure.  */\n-static void\n-place_new_loop (struct loop *loop)\n-{\n-  loop->num = number_of_loops ();\n-  VEC_safe_push (loop_p, heap, current_loops->larray, loop);\n-}\n-\n /* Copies copy of LOOP as subloop of TARGET loop, placing newly\n    created loop into loops structure.  */\n struct loop *\n@@ -1115,12 +1120,15 @@ create_preheader (struct loop *loop, int flags)\n   gcc_assert (nentry);\n   if (nentry == 1)\n     {\n-      /* Get an edge that is different from the one from loop->latch\n-\t to loop->header.  */\n-      e = EDGE_PRED (loop->header,\n-\t\t     EDGE_PRED (loop->header, 0)->src == loop->latch);\n-\n-      if (!(flags & CP_SIMPLE_PREHEADERS) || single_succ_p (e->src))\n+      e = loop_preheader_edge (loop);\n+\n+      if (/* We do not allow entry block to be the loop preheader, since we\n+\t     cannot emit code there.  */\n+\t  e->src != ENTRY_BLOCK_PTR\n+\t  /* If we want simple preheaders, also force the preheader to have\n+\t     just a single successor.  */\n+\t  && !((flags & CP_SIMPLE_PREHEADERS)\n+\t       && !single_succ_p (e->src)))\n \treturn NULL;\n     }\n "}, {"sha": "3f0076e8f79fc81acecaa07bd9e6d76fe04a15b4", "filename": "gcc/doc/loop.texi", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fdoc%2Floop.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fdoc%2Floop.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Floop.texi?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -48,11 +48,17 @@ a single header, or if there is a branching in the middle of the loop.\n The representation of loops in GCC however allows only loops with a\n single latch.  During loop analysis, headers of such loops are split and\n forwarder blocks are created in order to disambiguate their structures.\n-A heuristic based on profile information is used to determine whether\n-the latches correspond to sub-loops or to control flow in a single loop.\n-This means that the analysis sometimes changes the CFG, and if you run\n-it in the middle of an optimization pass, you must be able to deal with\n-the new blocks.\n+Heuristic based on profile information and structure of the induction\n+variables in the loops is used to determine whether the latches\n+correspond to sub-loops or to control flow in a single loop.  This means\n+that the analysis sometimes changes the CFG, and if you run it in the\n+middle of an optimization pass, you must be able to deal with the new\n+blocks.  You may avoid CFG changes by passing\n+@code{LOOPS_MAY_HAVE_MULTIPLE_LATCHES} flag to the loop discovery,\n+note however that most other loop manipulation functions will not work\n+correctly for loops with multiple latch edges (the functions that only\n+query membership of blocks to loops and subloop relationships, or\n+enumerate and test loop exits, can be expected to work).\n \n Body of the loop is the set of blocks that are dominated by its header,\n and reachable from its latch against the direction of edges in CFG.  The\n@@ -96,6 +102,13 @@ bitmask.  These flags specify what other properties of the loop\n structures should be calculated/enforced and preserved later:\n \n @itemize\n+@item @code{LOOPS_MAY_HAVE_MULTIPLE_LATCHES}: If this flag is set, no\n+changes to CFG will be performed in the loop analysis, in particular,\n+loops with multiple latch edges will not be disambiguated.  If a loop\n+has multiple latches, its latch block is set to NULL.  Most of\n+the loop manipulation functions will not work for loops in this shape.\n+No other flags that require CFG changes can be passed to\n+loop_optimizer_init.\n @item @code{LOOPS_HAVE_PREHEADERS}: Forwarder blocks are created in such\n a way that each loop has only one entry edge, and additionally, the\n source block of this entry edge has only one successor.  This creates a"}, {"sha": "9df57bb157408b0e389887e381d04d02b43ef406", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -3908,18 +3908,13 @@ if_convert (int x_life_data_ok)\n   num_true_changes = 0;\n   life_data_ok = (x_life_data_ok != 0);\n \n-  if ((! targetm.cannot_modify_jumps_p ())\n-      && (!flag_reorder_blocks_and_partition || !no_new_pseudos\n-\t  || !targetm.have_named_sections))\n+  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+  if (current_loops)\n     {\n-      loop_optimizer_init (0);\n-      if (current_loops)\n-\t{\n-\t  mark_loop_exit_edges ();\n-\t  loop_optimizer_finalize ();\n-\t}\n-      free_dominance_info (CDI_DOMINATORS);\n+      mark_loop_exit_edges ();\n+      loop_optimizer_finalize ();\n     }\n+  free_dominance_info (CDI_DOMINATORS);\n \n   /* Compute postdominators if we think we'll use them.  */\n   if (HAVE_conditional_execution || life_data_ok)"}, {"sha": "3e6d3428b897cb2c4c06f5631c443444113722a3", "filename": "gcc/loop-init.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -40,22 +40,11 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n void\n loop_optimizer_init (unsigned flags)\n {\n-  edge e;\n-  edge_iterator ei;\n   struct loops *loops;\n \n   gcc_assert (!current_loops);\n   loops = XCNEW (struct loops);\n \n-  /* Avoid annoying special cases of edges going to exit\n-     block.  */\n-\n-  for (ei = ei_start (EXIT_BLOCK_PTR->preds); (e = ei_safe_edge (ei)); )\n-    if ((e->flags & EDGE_FALLTHRU) && !single_succ_p (e->src))\n-      split_edge (e);\n-    else\n-      ei_next (&ei);\n-\n   /* Find the loops.  */\n \n   flow_loops_find (loops);\n@@ -69,6 +58,19 @@ loop_optimizer_init (unsigned flags)\n       return;\n     }\n \n+  if (flags & LOOPS_MAY_HAVE_MULTIPLE_LATCHES)\n+    {\n+      /* If the loops may have multiple latches, we cannot canonicalize\n+\t them further (and most of the loop manipulation functions will\n+\t not work).  However, we avoid modifying cfg, which some\n+\t passes may want.  */\n+      gcc_assert ((flags & ~(LOOPS_MAY_HAVE_MULTIPLE_LATCHES\n+\t\t\t     | LOOPS_HAVE_RECORDED_EXITS)) == 0);\n+      current_loops->state = LOOPS_MAY_HAVE_MULTIPLE_LATCHES;\n+    }\n+  else\n+    disambiguate_loops_with_multiple_latches ();\n+\n   /* Create pre-headers.  */\n   if (flags & LOOPS_HAVE_PREHEADERS)\n     create_preheaders (CP_SIMPLE_PREHEADERS);"}, {"sha": "d976bd003bc48e711a876a0b7c4743bb298a7bc6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -1,3 +1,7 @@\n+2007-02-06  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-25.c: New test.\n+\n 2007-02-06  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.target/i386/cvt-1.c: Don't expect xmm registers."}, {"sha": "a15a388149a60e6e36836f22d4f242a16298a327", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-25.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-25.c?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -0,0 +1,128 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+int foo(void);\n+void bla(void);\n+void bar(void);\n+\n+void test1 (void)\n+{\n+  unsigned i;\n+\n+  /* Only one loop should be found here.  */\n+  i = 0;\n+  while (1)\n+    {\n+      i++;\n+      if (i == 100)\n+\tbreak;\n+\n+      if (foo ())\n+\tbla ();\n+      else\n+\tbar ();\n+    }\n+}\n+\n+void test2 (void)\n+{\n+  unsigned i, j;\n+\n+  /* Two loops should be found, in this case.  */\n+  i = j = 0;\n+  while (1)\n+    {\n+      j++;\n+      foo ();\n+      if (j < 100)\n+\tcontinue;\n+\n+      i++;\n+      j = 0;\n+      if (i == 100)\n+\tbreak;\n+    }\n+}\n+\n+void test3 (void)\n+{\n+  unsigned i, j, k;\n+\n+  /* Three loops.  */\n+  i = j = k = 0;\n+  while (1)\n+    {\n+      j++;\n+      foo ();\n+      if (j < 100)\n+\tcontinue;\n+\n+      j = 0;\n+      k++;\n+      if (k < 100)\n+\tcontinue;\n+\n+      k = 0;\n+      i++;\n+      if (i == 100)\n+\tbreak;\n+    }\n+}\n+\n+void test4 (void)\n+{\n+  unsigned i, j, k;\n+\n+  /* Two loops with a nested subloop.  */\n+  i = j = 0;\n+  while (1)\n+    {\n+      j++;\n+      foo ();\n+      for (k = 0; k < 100; k++)\n+\tfoo ();\n+\n+      if (j < 100)\n+\tcontinue;\n+\n+      i++;\n+      j = 0;\n+      if (i == 100)\n+\tbreak;\n+    }\n+}\n+\n+\n+void test5 (void)\n+{\n+  unsigned i, j;\n+\n+  /* Both subloop and non-subloop back edges.  */\n+  i = j = 0;\n+  while (1)\n+    {\n+      j++;\n+      foo ();\n+      if (j < 100)\n+\tcontinue;\n+      j = 0;\n+\n+      i++;\n+      if (i == 100)\n+\tbreak;\n+\n+      if (foo ())\n+\tbla ();\n+      else\n+\tbar ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Disambiguating loop\" 5 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Found latch edge\" 5 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Merged latch edges\" 2 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"4 loops found\" 2 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"3 loops found\" 2 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"2 loops found\" 1 \"vrp1\" } } */\n+\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "f78be8ecf686d81cc1b1695ba8021850b8ecfe8d", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -582,8 +582,8 @@ cleanup_tree_cfg_loop (void)\n   if (changed)\n     {\n       bitmap changed_bbs = BITMAP_ALLOC (NULL);\n-      fix_loop_structure (changed_bbs);\n       calculate_dominance_info (CDI_DOMINATORS);\n+      fix_loop_structure (changed_bbs);\n \n       /* This usually does nothing.  But sometimes parts of cfg that originally\n \t were inside a loop get out of it due to edge removal (since they"}, {"sha": "8ebd1399fb8d5b413c1e7245390e53d1a5433803", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89f8f30f3565328a2805adafd22e05219b56d562/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=89f8f30f3565328a2805adafd22e05219b56d562", "patch": "@@ -279,7 +279,7 @@ tree_ssa_dominator_optimize (void)\n   /* We need to know which edges exit loops so that we can\n      aggressively thread through loop headers to an exit\n      edge.  */\n-  loop_optimizer_init (0);\n+  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n   if (current_loops)\n     {\n       mark_loop_exit_edges ();"}]}