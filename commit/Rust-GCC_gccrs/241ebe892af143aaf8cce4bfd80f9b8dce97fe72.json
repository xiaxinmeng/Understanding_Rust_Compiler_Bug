{"sha": "241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQxZWJlODkyYWYxNDNhYWY4Y2NlNGJmZDgwZjliOGRjZTk3ZmU3Mg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2015-05-26T10:46:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-26T10:46:58Z"}, "message": "exp_ch3.adb (Expand_N_Full_Type_Declaration): Capture, set and restore the Ghost mode.\n\n2015-05-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Full_Type_Declaration): Capture, set and\n\trestore the Ghost mode.\n\t(Expand_N_Object_Declaration): Capture, set and restore the Ghost mode.\n\t(Freeze_Type): Update the call to Set_Ghost_Mode.\n\t(Restore_Globals): New routine.\n\t* exp_ch5.adb Add with and use clauses for Ghost.\n\t(Expand_N_Assignment_Statement): Capture, set and restore the\n\tGhost mode.\n\t(Restore_Globals): New routine.\n\t* exp_ch6.adb Add with and use clauses for Ghost.\n\t(Expand_N_Procedure_Call_Statement): Capture, set and\n\trestore the Ghost mode.\n\t(Expand_N_Subprogram_Body):\n\tCode cleanup. Capture, set and restore the Ghost mode.\n\t(Expand_N_Subprogram_Declaration): Capture, set and restore the\n\tGhost mode.\n\t(Restore_Globals): New routine.\n\t* exp_ch7.adb Add with and use clauses for Ghost.\n\t(Expand_N_Package_Body): Capture, set and restore the Ghost mode.\n\t(Expand_N_Package_Declaration): Capture, set and restore the\n\tGhost mode.\n\t(Wrap_HSS_In_Block): Create a proper identifier for the block.\n\t* exp_ch8.adb Add with and use clauses for Ghost.\n\t(Expand_N_Exception_Renaming_Declaration): Code\n\tcleanup. Capture, set and restore the Ghost mode.\n\t(Expand_N_Object_Renaming_Declaration): Capture, set and restore\n\tthe Ghost mode.\n\t(Expand_N_Package_Renaming_Declaration): Capture, set and restore the\n\tGhost mode.\n\t(Expand_N_Subprogram_Renaming_Declaration): Capture, set and\n\trestore the Ghost mode.\n\t* exp_ch11.adb (Expand_N_Exception_Declaration): Code\n\tcleanup. Capture, set and restore the Ghost mode.\n\t* exp_disp.adb (Make_DT): Update the call to Set_Ghost_Mode. Do\n\tnot initialize the dispatch table slot of a Ghost subprogram.\n\t* exp_prag.adb Add with and use clauses for Ghost.\n\t(Expand_Pragma_Check): Capture, set and restore the Ghost mode.\n\t(Expand_Pragma_Contract_Cases): Capture, set and restore the\n\tGhost mode.\n\t(Expand_Pragma_Initial_Condition): Capture, set and\n\trestore the Ghost mode.\n\t(Expand_Pragma_Loop_Variant): Capture,\n\tset and restore the Ghost mode.\n\t(Restore_Globals): New routine.\n\t* exp_util.adb Add with and use clauses for Ghost.\n\t(Make_Predicate_Call): Code cleanup. Capture, set and restore\n\tthe Ghost mode.\n\t(Restore_Globals): New routine.\n\t* freeze.adb (Freeze_Entity): Code cleanup. Update the call\n\tto Set_Ghost_Mode.\n\t* ghost.adb Add with and use clause for Sem_Prag.\n\t(Check_Ghost_Completion): Code cleanup.\n\t(Check_Ghost_Overriding): New routine.\n\t(Check_Ghost_Policy): Code cleanup.\n\t(Ghost_Entity): New routine.\n\t(Is_Ghost_Declaration): Removed.\n\t(Is_Ghost_Statement_Or_Pragma): Removed.\n\t(Is_OK_Context): Reimplemented.\n\t(Is_OK_Declaration): New routine.\n\t(Is_OK_Pragma): New routine.\n\t(Is_OK_Statement): New routine.\n\t(Mark_Full_View_As_Ghost): New routine.\n\t(Mark_Pragma_As_Ghost): New routine.\n\t(Mark_Renaming_As_Ghost): New routine.\n\t(Propagate_Ignored_Ghost_Code): Update the comment on usage.\n\t(Set_From_Entity): New routine.\n\t(Set_From_Policy): New routine.\n\t(Set_Ghost_Mode): This routine now handles pragmas and freeze nodes.\n\t(Set_Ghost_Mode_For_Freeze): Removed.\n\t(Set_Ghost_Mode_From_Entity): New routine.\n\t(Set_Ghost_Mode_From_Policy): Removed.\n\t* ghost.ads (Check_Ghost_Overriding): New routine.\n\t(Mark_Full_View_As_Ghost): New routine.\n\t(Mark_Pragma_As_Ghost): New routine.\n\t(Mark_Renaming_As_Ghost): New routine.\n\t(Set_Ghost_Mode): Update the parameter profile. Update the\n\tcomment on usage.\n\t(Set_Ghost_Mode_For_Freeze): Removed.\n\t(Set_Ghost_Mode_From_Entity): New routine.\n\t* sem_ch3.adb (Analyze_Full_Type_Declaration):\n\tCapture and restore the Ghost mode. Mark a type\n\tas Ghost regardless of whether it comes from source.\n\t(Analyze_Incomplete_Type_Decl): Capture, set and restore the\n\tGhost mode.\n\t(Analyze_Number_Declaration): Capture and restore the Ghost mode.\n\t(Analyze_Object_Declaration): Capture and restore the Ghost mode.\n\t(Analyze_Private_Extension_Declaration): Capture and\n\trestore the Ghost mode.\n\t(Analyze_Subtype_Declaration): Capture and restore the Ghost mode.\n\t(Process_Full_View): The full view inherits all Ghost-related\n\tattributes from the private view.\n\t(Restore_Globals): New routine.\n\t* sem_ch5.adb (Analyze_Assignment): Capture and restore the\n\tGhost mode.\n\t(Restore_Globals): New routine.\n\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration):\n\tCode cleanup. Capture and restore the Ghost mode. Mark a\n\tsubprogram as Ghost regarless of whether it comes from source.\n\t(Analyze_Procedure_Call): Capture and restore the Ghost mode.\n\t(Analyze_Subprogram_Body_Helper): Capture and restore the Ghost mode.\n\t(Analyze_Subprogram_Declaration): Capture and restore the Ghost mode.\n\t(New_Overloaded_Entity): Ensure that a\n\tparent subprogram and an overriding subprogram have compatible\n\tGhost policies.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): Capture and restore\n\tthe Ghost mode.\n\t(Analyze_Package_Declaration): Capture and\n\trestore the Ghost mode. Mark a package as Ghost when it is\n\tdeclared in a Ghost region.\n\t(Analyze_Private_Type_Declaration): Capture and restore the Ghost mode.\n\t(Restore_Globals): New routine.\n\t* sem_ch8.adb (Analyze_Exception_Renaming): Code\n\treformatting. Capture and restore the Ghost mode. A renaming\n\tbecomes Ghost when its name references a Ghost entity.\n\t(Analyze_Generic_Renaming): Capture and restore the Ghost mode. A\n\trenaming becomes Ghost when its name references a Ghost entity.\n\t(Analyze_Object_Renaming): Capture and restore the Ghost mode. A\n\trenaming becomes Ghost when its name references a Ghost entity.\n\t(Analyze_Package_Renaming): Capture and restore the Ghost mode. A\n\trenaming becomes Ghost when its name references a Ghost entity.\n\t(Analyze_Subprogram_Renaming): Capture and restore the Ghost\n\tmode. A renaming becomes Ghost when its name references a\n\tGhost entity.\n\t* sem_ch11.adb (Analyze_Exception_Declaration): Capture, set\n\tand restore the Ghost mode.\n\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Capture and\n\trestore the Ghost mode.\n\t(Analyze_Generic_Subprogram_Declaration):\n\tCapture and restore the Ghost mode.\n\t* sem_ch13.adb Add with and use clauses for Ghost.\n\t(Add_Invariant): New routine.\n\t(Add_Invariants): Factor out code.\n\t(Add_Predicate): New routine.\n\t(Add_Predicates): Factor out code.\n\t(Build_Invariant_Procedure_Declaration): Code cleanup. Capture,\n\tset and restore the Ghost mode.\n\t(Build_Invariant_Procedure): Code cleanup.\n\t(Build_Predicate_Functions): Capture, set and\n\trestore the Ghost mode. Mark the generated functions as Ghost.\n\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part):\n\tCapture, set and restore the Ghost mode.\n\t(Analyze_External_Property_In_Decl_Part): Capture, set and restore\n\tthe Ghost mode.\n\t(Analyze_Initial_Condition_In_Decl_Part):\n\tCapture, set and restore the Ghost mode.\n\t(Analyze_Pragma):\n\tCode cleanup. Capture, set and restore the Ghost mode. Flag\n\tpragmas Linker_Section, No_Return, Unmodified, Unreferenced and\n\tUnreferenced_Objects as illegal when it applies to both Ghost\n\tand living arguments. Pragma Ghost cannot apply to synchronized\n\tobjects.\n\t(Check_Kind): Moved to the spec of Sem_Prag.\n\t(Process_Inline): Flag the pragma as illegal when it applies to\n\tboth Ghost and living arguments.\n\t(Restore_Globals): New routine.\n\t* sem_prag.ads Add pragma Default_Initial_Condition\n\tto table Assertion_Expression_Pragma. Add new table\n\tIs_Aspect_Specifying_Pragma.\n\t(Check_Kind): Moved from body of Sem_Prag.\n\t* sem_util.adb Add with and use clauses for Ghost.\n\t(Build_Default_Init_Cond_Procedure_Body): Capture, set and restore\n\tthe Ghost mode.\n\t(Build_Default_Init_Cond_Procedure_Declaration):\n\tCapture, set and restore the Ghost mode. Mark the default\n\tinitial condition procedure as Ghost when it is declared\n\tin a Ghost region.\n\t(Is_Renaming_Declaration): New routine.\n\t(Policy_In_List): Account for the single argument version of\n\tCheck_Pragma.\n\t* sem_util.ads (Is_Renaming_Declaration): New routine.\n\t* sinfo.adb (Is_Ghost_Pragma): New routine.\n\t(Set_Is_Ghost_Pragma): New routine.\n\t* sinfo.ads New attribute Is_Ghost_Pragma.\n\t(Is_Ghost_Pragma): New routine along with pragma Inline.\n\t(Set_Is_Ghost_Pragma): New routine along with pragma Inline.\n\nFrom-SVN: r223684", "tree": {"sha": "bed88940e055630033e81202254038ad081b708f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bed88940e055630033e81202254038ad081b708f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "138cac6426259ed3ed98371f0aa0989df32c0724", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/138cac6426259ed3ed98371f0aa0989df32c0724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/138cac6426259ed3ed98371f0aa0989df32c0724"}], "stats": {"total": 3930, "additions": 2922, "deletions": 1008}, "files": [{"sha": "d3ef056bf31661dd251fed36a03f2643032c796c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -1,3 +1,181 @@\n+2015-05-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Full_Type_Declaration): Capture, set and\n+\trestore the Ghost mode.\n+\t(Expand_N_Object_Declaration): Capture, set and restore the Ghost mode.\n+\t(Freeze_Type): Update the call to Set_Ghost_Mode.\n+\t(Restore_Globals): New routine.\n+\t* exp_ch5.adb Add with and use clauses for Ghost.\n+\t(Expand_N_Assignment_Statement): Capture, set and restore the\n+\tGhost mode.\n+\t(Restore_Globals): New routine.\n+\t* exp_ch6.adb Add with and use clauses for Ghost.\n+\t(Expand_N_Procedure_Call_Statement): Capture, set and\n+\trestore the Ghost mode.\n+\t(Expand_N_Subprogram_Body):\n+\tCode cleanup. Capture, set and restore the Ghost mode.\n+\t(Expand_N_Subprogram_Declaration): Capture, set and restore the\n+\tGhost mode.\n+\t(Restore_Globals): New routine.\n+\t* exp_ch7.adb Add with and use clauses for Ghost.\n+\t(Expand_N_Package_Body): Capture, set and restore the Ghost mode.\n+\t(Expand_N_Package_Declaration): Capture, set and restore the\n+\tGhost mode.\n+\t(Wrap_HSS_In_Block): Create a proper identifier for the block.\n+\t* exp_ch8.adb Add with and use clauses for Ghost.\n+\t(Expand_N_Exception_Renaming_Declaration): Code\n+\tcleanup. Capture, set and restore the Ghost mode.\n+\t(Expand_N_Object_Renaming_Declaration): Capture, set and restore\n+\tthe Ghost mode.\n+\t(Expand_N_Package_Renaming_Declaration): Capture, set and restore the\n+\tGhost mode.\n+\t(Expand_N_Subprogram_Renaming_Declaration): Capture, set and\n+\trestore the Ghost mode.\n+\t* exp_ch11.adb (Expand_N_Exception_Declaration): Code\n+\tcleanup. Capture, set and restore the Ghost mode.\n+\t* exp_disp.adb (Make_DT): Update the call to Set_Ghost_Mode. Do\n+\tnot initialize the dispatch table slot of a Ghost subprogram.\n+\t* exp_prag.adb Add with and use clauses for Ghost.\n+\t(Expand_Pragma_Check): Capture, set and restore the Ghost mode.\n+\t(Expand_Pragma_Contract_Cases): Capture, set and restore the\n+\tGhost mode.\n+\t(Expand_Pragma_Initial_Condition): Capture, set and\n+\trestore the Ghost mode.\n+\t(Expand_Pragma_Loop_Variant): Capture,\n+\tset and restore the Ghost mode.\n+\t(Restore_Globals): New routine.\n+\t* exp_util.adb Add with and use clauses for Ghost.\n+\t(Make_Predicate_Call): Code cleanup. Capture, set and restore\n+\tthe Ghost mode.\n+\t(Restore_Globals): New routine.\n+\t* freeze.adb (Freeze_Entity): Code cleanup. Update the call\n+\tto Set_Ghost_Mode.\n+\t* ghost.adb Add with and use clause for Sem_Prag.\n+\t(Check_Ghost_Completion): Code cleanup.\n+\t(Check_Ghost_Overriding): New routine.\n+\t(Check_Ghost_Policy): Code cleanup.\n+\t(Ghost_Entity): New routine.\n+\t(Is_Ghost_Declaration): Removed.\n+\t(Is_Ghost_Statement_Or_Pragma): Removed.\n+\t(Is_OK_Context): Reimplemented.\n+\t(Is_OK_Declaration): New routine.\n+\t(Is_OK_Pragma): New routine.\n+\t(Is_OK_Statement): New routine.\n+\t(Mark_Full_View_As_Ghost): New routine.\n+\t(Mark_Pragma_As_Ghost): New routine.\n+\t(Mark_Renaming_As_Ghost): New routine.\n+\t(Propagate_Ignored_Ghost_Code): Update the comment on usage.\n+\t(Set_From_Entity): New routine.\n+\t(Set_From_Policy): New routine.\n+\t(Set_Ghost_Mode): This routine now handles pragmas and freeze nodes.\n+\t(Set_Ghost_Mode_For_Freeze): Removed.\n+\t(Set_Ghost_Mode_From_Entity): New routine.\n+\t(Set_Ghost_Mode_From_Policy): Removed.\n+\t* ghost.ads (Check_Ghost_Overriding): New routine.\n+\t(Mark_Full_View_As_Ghost): New routine.\n+\t(Mark_Pragma_As_Ghost): New routine.\n+\t(Mark_Renaming_As_Ghost): New routine.\n+\t(Set_Ghost_Mode): Update the parameter profile. Update the\n+\tcomment on usage.\n+\t(Set_Ghost_Mode_For_Freeze): Removed.\n+\t(Set_Ghost_Mode_From_Entity): New routine.\n+\t* sem_ch3.adb (Analyze_Full_Type_Declaration):\n+\tCapture and restore the Ghost mode. Mark a type\n+\tas Ghost regardless of whether it comes from source.\n+\t(Analyze_Incomplete_Type_Decl): Capture, set and restore the\n+\tGhost mode.\n+\t(Analyze_Number_Declaration): Capture and restore the Ghost mode.\n+\t(Analyze_Object_Declaration): Capture and restore the Ghost mode.\n+\t(Analyze_Private_Extension_Declaration): Capture and\n+\trestore the Ghost mode.\n+\t(Analyze_Subtype_Declaration): Capture and restore the Ghost mode.\n+\t(Process_Full_View): The full view inherits all Ghost-related\n+\tattributes from the private view.\n+\t(Restore_Globals): New routine.\n+\t* sem_ch5.adb (Analyze_Assignment): Capture and restore the\n+\tGhost mode.\n+\t(Restore_Globals): New routine.\n+\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration):\n+\tCode cleanup. Capture and restore the Ghost mode. Mark a\n+\tsubprogram as Ghost regarless of whether it comes from source.\n+\t(Analyze_Procedure_Call): Capture and restore the Ghost mode.\n+\t(Analyze_Subprogram_Body_Helper): Capture and restore the Ghost mode.\n+\t(Analyze_Subprogram_Declaration): Capture and restore the Ghost mode.\n+\t(New_Overloaded_Entity): Ensure that a\n+\tparent subprogram and an overriding subprogram have compatible\n+\tGhost policies.\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper): Capture and restore\n+\tthe Ghost mode.\n+\t(Analyze_Package_Declaration): Capture and\n+\trestore the Ghost mode. Mark a package as Ghost when it is\n+\tdeclared in a Ghost region.\n+\t(Analyze_Private_Type_Declaration): Capture and restore the Ghost mode.\n+\t(Restore_Globals): New routine.\n+\t* sem_ch8.adb (Analyze_Exception_Renaming): Code\n+\treformatting. Capture and restore the Ghost mode. A renaming\n+\tbecomes Ghost when its name references a Ghost entity.\n+\t(Analyze_Generic_Renaming): Capture and restore the Ghost mode. A\n+\trenaming becomes Ghost when its name references a Ghost entity.\n+\t(Analyze_Object_Renaming): Capture and restore the Ghost mode. A\n+\trenaming becomes Ghost when its name references a Ghost entity.\n+\t(Analyze_Package_Renaming): Capture and restore the Ghost mode. A\n+\trenaming becomes Ghost when its name references a Ghost entity.\n+\t(Analyze_Subprogram_Renaming): Capture and restore the Ghost\n+\tmode. A renaming becomes Ghost when its name references a\n+\tGhost entity.\n+\t* sem_ch11.adb (Analyze_Exception_Declaration): Capture, set\n+\tand restore the Ghost mode.\n+\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Capture and\n+\trestore the Ghost mode.\n+\t(Analyze_Generic_Subprogram_Declaration):\n+\tCapture and restore the Ghost mode.\n+\t* sem_ch13.adb Add with and use clauses for Ghost.\n+\t(Add_Invariant): New routine.\n+\t(Add_Invariants): Factor out code.\n+\t(Add_Predicate): New routine.\n+\t(Add_Predicates): Factor out code.\n+\t(Build_Invariant_Procedure_Declaration): Code cleanup. Capture,\n+\tset and restore the Ghost mode.\n+\t(Build_Invariant_Procedure): Code cleanup.\n+\t(Build_Predicate_Functions): Capture, set and\n+\trestore the Ghost mode. Mark the generated functions as Ghost.\n+\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part):\n+\tCapture, set and restore the Ghost mode.\n+\t(Analyze_External_Property_In_Decl_Part): Capture, set and restore\n+\tthe Ghost mode.\n+\t(Analyze_Initial_Condition_In_Decl_Part):\n+\tCapture, set and restore the Ghost mode.\n+\t(Analyze_Pragma):\n+\tCode cleanup. Capture, set and restore the Ghost mode. Flag\n+\tpragmas Linker_Section, No_Return, Unmodified, Unreferenced and\n+\tUnreferenced_Objects as illegal when it applies to both Ghost\n+\tand living arguments. Pragma Ghost cannot apply to synchronized\n+\tobjects.\n+\t(Check_Kind): Moved to the spec of Sem_Prag.\n+\t(Process_Inline): Flag the pragma as illegal when it applies to\n+\tboth Ghost and living arguments.\n+\t(Restore_Globals): New routine.\n+\t* sem_prag.ads Add pragma Default_Initial_Condition\n+\tto table Assertion_Expression_Pragma. Add new table\n+\tIs_Aspect_Specifying_Pragma.\n+\t(Check_Kind): Moved from body of Sem_Prag.\n+\t* sem_util.adb Add with and use clauses for Ghost.\n+\t(Build_Default_Init_Cond_Procedure_Body): Capture, set and restore\n+\tthe Ghost mode.\n+\t(Build_Default_Init_Cond_Procedure_Declaration):\n+\tCapture, set and restore the Ghost mode. Mark the default\n+\tinitial condition procedure as Ghost when it is declared\n+\tin a Ghost region.\n+\t(Is_Renaming_Declaration): New routine.\n+\t(Policy_In_List): Account for the single argument version of\n+\tCheck_Pragma.\n+\t* sem_util.ads (Is_Renaming_Declaration): New routine.\n+\t* sinfo.adb (Is_Ghost_Pragma): New routine.\n+\t(Set_Is_Ghost_Pragma): New routine.\n+\t* sinfo.ads New attribute Is_Ghost_Pragma.\n+\t(Is_Ghost_Pragma): New routine along with pragma Inline.\n+\t(Set_Is_Ghost_Pragma): New routine along with pragma Inline.\n+\n 2015-05-26  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, sem_aux.adb, sem_aux.ads, exp_ch6.adb, sprint.adb:"}, {"sha": "dd0423a5a509641e4d53d12cfebc6173bc9099f4", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,6 +31,7 @@ with Errout;   use Errout;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Intr; use Exp_Intr;\n with Exp_Util; use Exp_Util;\n+with Ghost;    use Ghost;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -1189,14 +1190,12 @@ package body Exp_Ch11 is\n    --     end if;\n \n    procedure Expand_N_Exception_Declaration (N : Node_Id) is\n-      Loc     : constant Source_Ptr := Sloc (N);\n+      GM      : constant Ghost_Mode_Type := Ghost_Mode;\n       Id      : constant Entity_Id  := Defining_Identifier (N);\n-      L       : List_Id             := New_List;\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Ex_Id   : Entity_Id;\n       Flag_Id : Entity_Id;\n-\n-      Name_Exname : constant Name_Id := New_External_Name (Chars (Id), 'E');\n-      Exname      : constant Node_Id :=\n-                      Make_Defining_Identifier (Loc, Name_Exname);\n+      L       : List_Id := New_List;\n \n       procedure Force_Static_Allocation_Of_Referenced_Objects\n         (Aggregate : Node_Id);\n@@ -1280,18 +1279,27 @@ package body Exp_Ch11 is\n          return;\n       end if;\n \n+      --  The exception declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Definition of the external name: nam : constant String := \"A.B.NAME\";\n \n+      Ex_Id :=\n+        Make_Defining_Identifier (Loc, New_External_Name (Chars (Id), 'E'));\n+\n       Insert_Action (N,\n         Make_Object_Declaration (Loc,\n-          Defining_Identifier => Exname,\n+          Defining_Identifier => Ex_Id,\n           Constant_Present    => True,\n           Object_Definition   => New_Occurrence_Of (Standard_String, Loc),\n           Expression          =>\n             Make_String_Literal (Loc,\n               Strval => Fully_Qualified_Name_String (Id))));\n \n-      Set_Is_Statically_Allocated (Exname);\n+      Set_Is_Statically_Allocated (Ex_Id);\n \n       --  Create the aggregate list for type Standard.Exception_Type:\n       --  Handled_By_Other component: False\n@@ -1309,14 +1317,14 @@ package body Exp_Ch11 is\n \n       Append_To (L,\n         Make_Attribute_Reference (Loc,\n-          Prefix         => New_Occurrence_Of (Exname, Loc),\n+          Prefix         => New_Occurrence_Of (Ex_Id, Loc),\n           Attribute_Name => Name_Length));\n \n       --  Full_Name component: Standard.A_Char!(Nam'Address)\n \n       Append_To (L, Unchecked_Convert_To (Standard_A_Char,\n         Make_Attribute_Reference (Loc,\n-          Prefix         => New_Occurrence_Of (Exname, Loc),\n+          Prefix         => New_Occurrence_Of (Ex_Id, Loc),\n           Attribute_Name => Name_Address)));\n \n       --  HTable_Ptr component: null\n@@ -1342,19 +1350,21 @@ package body Exp_Ch11 is\n         and then not Restriction_Active (No_Exception_Registration)\n       then\n          L := New_List (\n-                Make_Procedure_Call_Statement (Loc,\n-                  Name => New_Occurrence_Of (RTE (RE_Register_Exception), Loc),\n-                  Parameter_Associations => New_List (\n-                    Unchecked_Convert_To (RTE (RE_Exception_Data_Ptr),\n-                      Make_Attribute_Reference (Loc,\n-                        Prefix         => New_Occurrence_Of (Id, Loc),\n-                        Attribute_Name => Name_Unrestricted_Access)))));\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE_Register_Exception), Loc),\n+             Parameter_Associations => New_List (\n+               Unchecked_Convert_To (RTE (RE_Exception_Data_Ptr),\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Occurrence_Of (Id, Loc),\n+                   Attribute_Name => Name_Unrestricted_Access)))));\n \n          Set_Register_Exception_Call (Id, First (L));\n \n          if not Is_Library_Level_Entity (Id) then\n-            Flag_Id :=  Make_Defining_Identifier (Loc,\n-                          New_External_Name (Chars (Id), 'F'));\n+            Flag_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Chars (Id), 'F'));\n \n             Insert_Action (N,\n               Make_Object_Declaration (Loc,\n@@ -1380,6 +1390,11 @@ package body Exp_Ch11 is\n             Insert_List_After_And_Analyze (N, L);\n          end if;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_N_Exception_Declaration;\n \n    ---------------------------------------------"}, {"sha": "d7f453417d5d6ff94898b3c38269e204ddd45885", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -4794,12 +4794,19 @@ package body Exp_Ch3 is\n \n       Def_Id : constant Entity_Id := Defining_Identifier (N);\n       B_Id   : constant Entity_Id := Base_Type (Def_Id);\n+      GM     : constant Ghost_Mode_Type := Ghost_Mode;\n       FN     : Node_Id;\n       Par_Id : Entity_Id;\n \n    --  Start of processing for Expand_N_Full_Type_Declaration\n \n    begin\n+      --  The type declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       if Is_Access_Type (Def_Id) then\n          Build_Master (Def_Id);\n \n@@ -4923,6 +4930,11 @@ package body Exp_Ch3 is\n             end if;\n          end;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_N_Full_Type_Declaration;\n \n    ---------------------------------\n@@ -4932,6 +4944,7 @@ package body Exp_Ch3 is\n    procedure Expand_N_Object_Declaration (N : Node_Id) is\n       Def_Id   : constant Entity_Id  := Defining_Identifier (N);\n       Expr     : constant Node_Id    := Expression (N);\n+      GM       : constant Ghost_Mode_Type := Ghost_Mode;\n       Loc      : constant Source_Ptr := Sloc (N);\n       Obj_Def  : constant Node_Id    := Object_Definition (N);\n       Typ      : constant Entity_Id  := Etype (Def_Id);\n@@ -4947,6 +4960,9 @@ package body Exp_Ch3 is\n       --  Generate all default initialization actions for object Def_Id. Any\n       --  new code is inserted after node After.\n \n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n       function Rewrite_As_Renaming return Boolean;\n       --  Indicate whether to rewrite a declaration with initialization into an\n       --  object renaming declaration (see below).\n@@ -5377,6 +5393,15 @@ package body Exp_Ch3 is\n          end if;\n       end Default_Initialize_Object;\n \n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n       -------------------------\n       -- Rewrite_As_Renaming --\n       -------------------------\n@@ -5392,17 +5417,16 @@ package body Exp_Ch3 is\n \n       --  Local variables\n \n-      Next_N  : constant Node_Id := Next (N);\n-      Id_Ref  : Node_Id;\n+      Next_N     : constant Node_Id := Next (N);\n+      Id_Ref     : Node_Id;\n+      Tag_Assign : Node_Id;\n \n       Init_After : Node_Id := N;\n       --  Node after which the initialization actions are to be inserted. This\n       --  is normally N, except for the case of a shared passive variable, in\n       --  which case the init proc call must be inserted only after the bodies\n       --  of the shared variable procedures have been seen.\n \n-      Tag_Assign : Node_Id;\n-\n    --  Start of processing for Expand_N_Object_Declaration\n \n    begin\n@@ -5421,6 +5445,12 @@ package body Exp_Ch3 is\n          return;\n       end if;\n \n+      --  The object declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  First we do special processing for objects of a tagged type where\n       --  this is the point at which the type is frozen. The creation of the\n       --  dispatch table and the initialization procedure have to be deferred\n@@ -5589,6 +5619,7 @@ package body Exp_Ch3 is\n            and then Is_Build_In_Place_Function_Call (Expr_Q)\n          then\n             Make_Build_In_Place_Call_In_Object_Declaration (N, Expr_Q);\n+            Restore_Globals;\n \n             --  The previous call expands the expression initializing the\n             --  built-in-place object into further code that will be analyzed\n@@ -5833,6 +5864,7 @@ package body Exp_Ch3 is\n                end;\n             end if;\n \n+            Restore_Globals;\n             return;\n \n          --  Common case of explicit object initialization\n@@ -5948,6 +5980,7 @@ package body Exp_Ch3 is\n                --  to avoid its management in the backend\n \n                Set_Expression (N, Empty);\n+               Restore_Globals;\n                return;\n \n             --  Handle initialization of limited tagged types\n@@ -6169,10 +6202,13 @@ package body Exp_Ch3 is\n          end;\n       end if;\n \n+      Restore_Globals;\n+\n    --  Exception on library entity not available\n \n    exception\n       when RE_Not_Available =>\n+         Restore_Globals;\n          return;\n    end Expand_N_Object_Declaration;\n \n@@ -7609,7 +7645,7 @@ package body Exp_Ch3 is\n       --  Ignore. Set the mode now to ensure that any nodes generated during\n       --  freezing are properly flagged as ignored Ghost.\n \n-      Set_Ghost_Mode_For_Freeze (Def_Id, N);\n+      Set_Ghost_Mode (N, Def_Id);\n \n       --  Process any remote access-to-class-wide types designating the type\n       --  being frozen."}, {"sha": "ca6971e0530847bf1b085c0f4c697068ad957018", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -38,6 +38,7 @@ with Exp_Dbug; use Exp_Dbug;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n+with Ghost;    use Ghost;\n with Inline;   use Inline;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -1626,14 +1627,38 @@ package body Exp_Ch5 is\n    --  cannot just be passed on to the back end in untransformed state.\n \n    procedure Expand_N_Assignment_Statement (N : Node_Id) is\n-      Loc  : constant Source_Ptr := Sloc (N);\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n+      --  Local variables\n+\n       Crep : constant Boolean    := Change_Of_Representation (N);\n       Lhs  : constant Node_Id    := Name (N);\n+      Loc  : constant Source_Ptr := Sloc (N);\n       Rhs  : constant Node_Id    := Expression (N);\n       Typ  : constant Entity_Id  := Underlying_Type (Etype (Lhs));\n       Exp  : Node_Id;\n \n+   --  Start of processing for Expand_N_Assignment_Statement\n+\n    begin\n+      --  The assignment statement may be Ghost if the left hand side is Ghost.\n+      --  Set the mode now to ensure that any nodes generated during expansion\n+      --  are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Special case to check right away, if the Componentwise_Assignment\n       --  flag is set, this is a reanalysis from the expansion of the primitive\n       --  assignment procedure for a tagged type, and all we need to do is to\n@@ -1643,6 +1668,7 @@ package body Exp_Ch5 is\n \n       if Componentwise_Assignment (N) then\n          Expand_Assign_Record (N);\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -1736,6 +1762,8 @@ package body Exp_Ch5 is\n \n                Rewrite (N, Call);\n                Analyze (N);\n+\n+               Restore_Globals;\n                return;\n             end if;\n          end;\n@@ -1885,6 +1913,8 @@ package body Exp_Ch5 is\n          Convert_Aggr_In_Assignment (N);\n          Rewrite (N, Make_Null_Statement (Loc));\n          Analyze (N);\n+\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -2104,6 +2134,7 @@ package body Exp_Ch5 is\n \n          if not Crep then\n             Expand_Bit_Packed_Element_Set (N);\n+            Restore_Globals;\n             return;\n \n          --  Change of representation case\n@@ -2155,6 +2186,7 @@ package body Exp_Ch5 is\n          --  Nothing to do for valuetypes\n          --  ??? Set_Scope_Is_Transient (False);\n \n+         Restore_Globals;\n          return;\n \n       elsif Is_Tagged_Type (Typ)\n@@ -2210,6 +2242,7 @@ package body Exp_Ch5 is\n                   --  expansion, since they would be missed in -gnatc mode ???\n \n                   Error_Msg_N (\"assignment not available on limited type\", N);\n+                  Restore_Globals;\n                   return;\n                end if;\n \n@@ -2380,6 +2413,7 @@ package body Exp_Ch5 is\n             --  it with all checks suppressed.\n \n             Analyze (N, Suppress => All_Checks);\n+            Restore_Globals;\n             return;\n          end Tagged_Case;\n \n@@ -2397,13 +2431,15 @@ package body Exp_Ch5 is\n             end loop;\n \n             Expand_Assign_Array (N, Actual_Rhs);\n+            Restore_Globals;\n             return;\n          end;\n \n       --  Record types\n \n       elsif Is_Record_Type (Typ) then\n          Expand_Assign_Record (N);\n+         Restore_Globals;\n          return;\n \n       --  Scalar types. This is where we perform the processing related to the\n@@ -2516,8 +2552,11 @@ package body Exp_Ch5 is\n          end if;\n       end if;\n \n+      Restore_Globals;\n+\n    exception\n       when RE_Not_Available =>\n+         Restore_Globals;\n          return;\n    end Expand_N_Assignment_Statement;\n "}, {"sha": "01081a0cd0fde669080f398df577f21e8df5b867", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -45,6 +45,7 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Unst; use Exp_Unst;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Inline;   use Inline;\n with Lib;      use Lib;\n with Namet;    use Namet;\n@@ -4916,8 +4917,20 @@ package body Exp_Ch6 is\n    ---------------------------------------\n \n    procedure Expand_N_Procedure_Call_Statement (N : Node_Id) is\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n    begin\n+      --  The procedure call may be Ghost if the name is Ghost. Set the mode\n+      --  now to ensure that any nodes generated during expansion are properly\n+      --  flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n       Expand_Call (N);\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_N_Procedure_Call_Statement;\n \n    --------------------------------------\n@@ -4992,8 +5005,9 @@ package body Exp_Ch6 is\n    --  Wrap thread body\n \n    procedure Expand_N_Subprogram_Body (N : Node_Id) is\n+      GM       : constant Ghost_Mode_Type := Ghost_Mode;\n       Loc      : constant Source_Ptr := Sloc (N);\n-      H        : constant Node_Id    := Handled_Statement_Sequence (N);\n+      HSS      : constant Node_Id    := Handled_Statement_Sequence (N);\n       Body_Id  : Entity_Id;\n       Except_H : Node_Id;\n       L        : List_Id;\n@@ -5005,6 +5019,9 @@ package body Exp_Ch6 is\n       --  the latter test is not critical, it does not matter if we add a few\n       --  extra returns, since they get eliminated anyway later on.\n \n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n       ----------------\n       -- Add_Return --\n       ----------------\n@@ -5038,8 +5055,8 @@ package body Exp_Ch6 is\n               and then not Comes_From_Source (Parent (S))\n             then\n                Loc := Sloc (Last_Stmt);\n-            elsif Present (End_Label (H)) then\n-               Loc := Sloc (End_Label (H));\n+            elsif Present (End_Label (HSS)) then\n+               Loc := Sloc (End_Label (HSS));\n             else\n                Loc := Sloc (Last_Stmt);\n             end if;\n@@ -5077,17 +5094,32 @@ package body Exp_Ch6 is\n          end if;\n       end Add_Return;\n \n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n    --  Start of processing for Expand_N_Subprogram_Body\n \n    begin\n+      --  The subprogram body may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  expansion are flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Set L to either the list of declarations if present, or to the list\n       --  of statements if no declarations are present. This is used to insert\n       --  new stuff at the start.\n \n       if Is_Non_Empty_List (Declarations (N)) then\n          L := Declarations (N);\n       else\n-         L := Statements (H);\n+         L := Statements (HSS);\n       end if;\n \n       --  If local-exception-to-goto optimization active, insert dummy push\n@@ -5112,8 +5144,8 @@ package body Exp_Ch6 is\n             --  or to the last declaration if there are no statements present.\n             --  It is the node after which the pop's are generated.\n \n-            if Is_Non_Empty_List (Statements (H)) then\n-               LS := Last (Statements (H));\n+            if Is_Non_Empty_List (Statements (HSS)) then\n+               LS := Last (Statements (HSS));\n             else\n                LS := Last (L);\n             end if;\n@@ -5255,6 +5287,8 @@ package body Exp_Ch6 is\n             Set_Handled_Statement_Sequence (N,\n               Make_Handled_Sequence_Of_Statements (Loc,\n                 Statements => New_List (Make_Null_Statement (Loc))));\n+\n+            Restore_Globals;\n             return;\n          end if;\n       end if;\n@@ -5295,10 +5329,10 @@ package body Exp_Ch6 is\n       --  the subprogram.\n \n       if Ekind_In (Spec_Id, E_Procedure, E_Generic_Procedure) then\n-         Add_Return (Statements (H));\n+         Add_Return (Statements (HSS));\n \n-         if Present (Exception_Handlers (H)) then\n-            Except_H := First_Non_Pragma (Exception_Handlers (H));\n+         if Present (Exception_Handlers (HSS)) then\n+            Except_H := First_Non_Pragma (Exception_Handlers (HSS));\n             while Present (Except_H) loop\n                Add_Return (Statements (Except_H));\n                Next_Non_Pragma (Except_H);\n@@ -5333,10 +5367,10 @@ package body Exp_Ch6 is\n \n       elsif Has_Missing_Return (Spec_Id) then\n          declare\n-            Hloc : constant Source_Ptr := Sloc (H);\n+            Hloc : constant Source_Ptr := Sloc (HSS);\n             Blok : constant Node_Id    :=\n                      Make_Block_Statement (Hloc,\n-                       Handled_Statement_Sequence => H);\n+                       Handled_Statement_Sequence => HSS);\n             Rais : constant Node_Id    :=\n                      Make_Raise_Program_Error (Hloc,\n                        Reason => PE_Missing_Return);\n@@ -5389,6 +5423,8 @@ package body Exp_Ch6 is\n       then\n          Unest_Bodies.Append ((Spec_Id, N));\n       end if;\n+\n+      Restore_Globals;\n    end Expand_N_Subprogram_Body;\n \n    -----------------------------------\n@@ -5415,14 +5451,21 @@ package body Exp_Ch6 is\n    --  If the declaration is for a null procedure, emit null body\n \n    procedure Expand_N_Subprogram_Declaration (N : Node_Id) is\n+      GM        : constant Ghost_Mode_Type := Ghost_Mode;\n       Loc       : constant Source_Ptr := Sloc (N);\n       Subp      : constant Entity_Id  := Defining_Entity (N);\n       Scop      : constant Entity_Id  := Scope (Subp);\n-      Prot_Decl : Node_Id;\n       Prot_Bod  : Node_Id;\n+      Prot_Decl : Node_Id;\n       Prot_Id   : Entity_Id;\n \n    begin\n+      --  The subprogram declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  expansion are flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  In SPARK, subprogram declarations are only allowed in package\n       --  specifications.\n \n@@ -5523,6 +5566,11 @@ package body Exp_Ch6 is\n             Set_Is_Inlined (Subp, False);\n          end;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_N_Subprogram_Declaration;\n \n    --------------------------------"}, {"sha": "7452146d40f907ce7908eff1834590d3234a7355", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -42,6 +42,7 @@ with Exp_Prag; use Exp_Prag;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Lib;      use Lib;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -3951,8 +3952,9 @@ package body Exp_Ch7 is\n       -----------------------\n \n       procedure Wrap_HSS_In_Block is\n-         Block   : Node_Id;\n-         End_Lab : Node_Id;\n+         Block    : Node_Id;\n+         Block_Id : Entity_Id;\n+         End_Lab  : Node_Id;\n \n       begin\n          --  Preserve end label to provide proper cross-reference information\n@@ -3961,6 +3963,11 @@ package body Exp_Ch7 is\n          Block :=\n            Make_Block_Statement (Loc, Handled_Statement_Sequence => HSS);\n \n+         Block_Id := New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n+         Set_Identifier (Block, New_Occurrence_Of (Block_Id, Loc));\n+         Set_Etype (Block_Id, Standard_Void_Type);\n+         Set_Block_Node (Block_Id, Identifier (Block));\n+\n          --  Signal the finalization machinery that this particular block\n          --  contains the original context.\n \n@@ -4163,10 +4170,17 @@ package body Exp_Ch7 is\n    --  Encode entity names in package body\n \n    procedure Expand_N_Package_Body (N : Node_Id) is\n+      GM       : constant Ghost_Mode_Type := Ghost_Mode;\n       Spec_Ent : constant Entity_Id := Corresponding_Spec (N);\n       Fin_Id   : Entity_Id;\n \n    begin\n+      --  The package body may be subject to pragma Ghost with policy Ignore.\n+      --  Set the mode now to ensure that any nodes generated during expansion\n+      --  are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  This is done only for non-generic packages\n \n       if Ekind (Spec_Ent) = E_Package then\n@@ -4222,6 +4236,11 @@ package body Exp_Ch7 is\n             end;\n          end if;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_N_Package_Body;\n \n    ----------------------------------\n@@ -4234,6 +4253,7 @@ package body Exp_Ch7 is\n    --  appear.\n \n    procedure Expand_N_Package_Declaration (N : Node_Id) is\n+      GM     : constant Ghost_Mode_Type := Ghost_Mode;\n       Id     : constant Entity_Id := Defining_Entity (N);\n       Spec   : constant Node_Id   := Specification (N);\n       Decls  : List_Id;\n@@ -4277,6 +4297,12 @@ package body Exp_Ch7 is\n          return;\n       end if;\n \n+      --  The package declaration may be subject to pragma Ghost with policy\n+      --  Ignore. Set the mode now to ensure that any nodes generated during\n+      --  expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  For a package declaration that implies no associated body, generate\n       --  task activation call and RACW supporting bodies now (since we won't\n       --  have a specific separate compilation unit for that).\n@@ -4350,6 +4376,11 @@ package body Exp_Ch7 is\n \n          Set_Finalizer (Id, Fin_Id);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_N_Package_Declaration;\n \n    -----------------------------"}, {"sha": "2c47b7f2894018b7a18ba30235e2f2f680e909ee", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,6 +30,7 @@ with Exp_Ch6;  use Exp_Ch6;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Namet;    use Namet;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n@@ -49,11 +50,26 @@ package body Exp_Ch8 is\n    ---------------------------------------------\n \n    procedure Expand_N_Exception_Renaming_Declaration (N : Node_Id) is\n-      Decl : constant Node_Id := Debug_Renaming_Declaration (N);\n+      GM   : constant Ghost_Mode_Type := Ghost_Mode;\n+      Decl : Node_Id;\n+\n    begin\n+      --  The exception renaming declaration may be subject to pragma Ghost\n+      --  with policy Ignore. Set the mode now to ensure that any nodes\n+      --  generated during expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n+      Decl := Debug_Renaming_Declaration (N);\n+\n       if Present (Decl) then\n          Insert_Action (N, Decl);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_N_Exception_Renaming_Declaration;\n \n    ------------------------------------------\n@@ -141,9 +157,19 @@ package body Exp_Ch8 is\n          end if;\n       end Evaluation_Required;\n \n+      --  Local variables\n+\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n    --  Start of processing for Expand_N_Object_Renaming_Declaration\n \n    begin\n+      --  The object renaming declaration may be subject to pragma Ghost with\n+      --  policy Ignore. Set the mode now to ensure that any nodes generated\n+      --  during expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Perform name evaluation if required\n \n       if Evaluation_Required (Nam) then\n@@ -186,16 +212,30 @@ package body Exp_Ch8 is\n       if Present (Decl) then\n          Insert_Action (N, Decl);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_N_Object_Renaming_Declaration;\n \n    -------------------------------------------\n    -- Expand_N_Package_Renaming_Declaration --\n    -------------------------------------------\n \n    procedure Expand_N_Package_Renaming_Declaration (N : Node_Id) is\n-      Decl : constant Node_Id := Debug_Renaming_Declaration (N);\n+      GM   : constant Ghost_Mode_Type := Ghost_Mode;\n+      Decl : Node_Id;\n \n    begin\n+      --  The package renaming declaration may be subject to pragma Ghost with\n+      --  policy Ignore. Set the mode now to ensure that any nodes generated\n+      --  during expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n+      Decl := Debug_Renaming_Declaration (N);\n+\n       if Present (Decl) then\n \n          --  If we are in a compilation unit, then this is an outer\n@@ -232,6 +272,11 @@ package body Exp_Ch8 is\n             Insert_Action (N, Decl);\n          end if;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_N_Package_Renaming_Declaration;\n \n    ----------------------------------------------\n@@ -281,11 +326,18 @@ package body Exp_Ch8 is\n \n       --  Local variables\n \n+      GM  : constant Ghost_Mode_Type := Ghost_Mode;\n       Nam : constant Node_Id := Name (N);\n \n    --  Start of processing for Expand_N_Subprogram_Renaming_Declaration\n \n    begin\n+      --  The subprogram renaming declaration may be subject to pragma Ghost\n+      --  with policy Ignore. Set the mode now to ensure that any nodes created\n+      --  during expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  When the prefix of the name is a function call, we must force the\n       --  call to be made by removing side effects from the call, since we\n       --  must only call the function once.\n@@ -349,6 +401,11 @@ package body Exp_Ch8 is\n             end if;\n          end;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_N_Subprogram_Renaming_Declaration;\n \n end Exp_Ch8;"}, {"sha": "f50899b3c6b6ce63dbecbcac41ca1765df63725e", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -4477,12 +4477,11 @@ package body Exp_Disp is\n    begin\n       pragma Assert (Is_Frozen (Typ));\n \n-      --  The tagged type for which the dispatch table is being build may be\n-      --  subject to pragma Ghost with policy Ignore. Set the mode now to\n-      --  ensure that any nodes generated during freezing are properly flagged\n-      --  as ignored Ghost.\n+      --  The tagged type being processed may be subject to pragma Ghost with\n+      --  policy Ignore. Set the mode now to ensure that any nodes generated\n+      --  during dispatch table creation are properly flagged as ignored Ghost.\n \n-      Set_Ghost_Mode_For_Freeze (Typ, Typ);\n+      Set_Ghost_Mode (Declaration_Node (Typ), Typ);\n \n       --  Handle cases in which there is no need to build the dispatch table\n \n@@ -5784,21 +5783,34 @@ package body Exp_Disp is\n                   E        := Ultimate_Alias (Prim);\n                   Prim_Pos := UI_To_Int (DT_Position (E));\n \n-                  --  Do not reference predefined primitives because they are\n-                  --  located in a separate dispatch table; skip entities with\n-                  --  attribute Interface_Alias because they are only required\n-                  --  to build secondary dispatch tables; skip abstract and\n-                  --  eliminated primitives; for derivations of CPP types skip\n-                  --  primitives located in the C++ part of the dispatch table\n-                  --  because their slot is initialized by the IC routine.\n+                  --  Skip predefined primitives because they are located in a\n+                  --  separate dispatch table.\n \n                   if not Is_Predefined_Dispatching_Operation (Prim)\n                     and then not Is_Predefined_Dispatching_Operation (E)\n+\n+                    --  Skip entities with attribute Interface_Alias because\n+                    --  those are only required to build secondary dispatch\n+                    --  tables.\n+\n                     and then not Present (Interface_Alias (Prim))\n+\n+                    --  Skip abstract and eliminated primitives\n+\n                     and then not Is_Abstract_Subprogram (E)\n                     and then not Is_Eliminated (E)\n+\n+                    --  For derivations of CPP types skip primitives located in\n+                    --  the C++ part of the dispatch table because their slots\n+                    --  are initialized by the IC routine.\n+\n                     and then (not Is_CPP_Class (Root_Type (Typ))\n                                or else Prim_Pos > CPP_Nb_Prims)\n+\n+                    --  Skip ignored Ghost subprograms as those will be removed\n+                    --  from the executable.\n+\n+                    and then not Is_Ignored_Ghost_Entity (E)\n                   then\n                      pragma Assert\n                        (UI_To_Int (DT_Position (Prim)) <= Nb_Prim);"}, {"sha": "fab3facddc34a49cfe19e5b4fda21226222763d3", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 74, "deletions": 6, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -32,6 +32,7 @@ with Errout;   use Errout;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Util; use Exp_Util;\n with Expander; use Expander;\n+with Ghost;    use Ghost;\n with Inline;   use Inline;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n@@ -292,6 +293,7 @@ package body Exp_Prag is\n    --------------------------\n \n    procedure Expand_Pragma_Check (N : Node_Id) is\n+      GM   : constant Ghost_Mode_Type := Ghost_Mode;\n       Cond : constant Node_Id := Arg2 (N);\n       Nam  : constant Name_Id := Chars (Arg1 (N));\n       Msg  : Node_Id;\n@@ -317,6 +319,16 @@ package body Exp_Prag is\n          return;\n       end if;\n \n+      --  Set the Ghost mode in effect from the pragma. In general both the\n+      --  assertion policy and the Ghost policy of pragma Check must agree,\n+      --  but there are cases where this can be circumvented. For instance,\n+      --  a living subtype with an ignored predicate may be declared in one\n+      --  packade, an ignored Ghost object in another and the compilation may\n+      --  use -gnata to enable assertions.\n+      --  ??? Ghost predicates are under redesign\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Since this check is active, we rewrite the pragma into a\n       --  corresponding if statement, and then analyze the statement.\n \n@@ -480,6 +492,11 @@ package body Exp_Prag is\n             Error_Msg_N (\"?A?check will fail at run time\", N);\n          end if;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_Pragma_Check;\n \n    ---------------------------------\n@@ -963,9 +980,10 @@ package body Exp_Prag is\n \n       --  Local variables\n \n-      Aggr          : constant Node_Id :=\n-                        Expression (First\n-                          (Pragma_Argument_Associations (CCs)));\n+      Aggr : constant Node_Id :=\n+               Expression (First (Pragma_Argument_Associations (CCs)));\n+      GM   : constant Ghost_Mode_Type := Ghost_Mode;\n+\n       Case_Guard    : Node_Id;\n       CG_Checks     : Node_Id;\n       CG_Stmts      : List_Id;\n@@ -999,6 +1017,12 @@ package body Exp_Prag is\n          return;\n       end if;\n \n+      --  The contract cases may be subject to pragma Ghost with policy Ignore.\n+      --  Set the mode now to ensure that any nodes generated during expansion\n+      --  are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (CCs);\n+\n       Multiple_PCs := List_Length (Component_Associations (Aggr)) > 1;\n \n       --  Create the counter which tracks the number of case guards that\n@@ -1223,6 +1247,11 @@ package body Exp_Prag is\n       end if;\n \n       Append_To (Stmts, Conseq_Checks);\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_Pragma_Contract_Cases;\n \n    ---------------------------------------\n@@ -1322,13 +1351,31 @@ package body Exp_Prag is\n    -------------------------------------\n \n    procedure Expand_Pragma_Initial_Condition (Spec_Or_Body : Node_Id) is\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n+      --  Local variables\n+\n       Loc       : constant Source_Ptr := Sloc (Spec_Or_Body);\n       Check     : Node_Id;\n       Expr      : Node_Id;\n       Init_Cond : Node_Id;\n       List      : List_Id;\n       Pack_Id   : Entity_Id;\n \n+   --  Start of processing for Expand_Pragma_Initial_Condition\n+\n    begin\n       if Nkind (Spec_Or_Body) = N_Package_Body then\n          Pack_Id := Corresponding_Spec (Spec_Or_Body);\n@@ -1367,6 +1414,12 @@ package body Exp_Prag is\n \n       Init_Cond := Get_Pragma (Pack_Id, Pragma_Initial_Condition);\n \n+      --  The initial condition be subject to pragma Ghost with policy Ignore.\n+      --  Set the mode now to ensure that any nodes generated during expansion\n+      --  are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (Init_Cond);\n+\n       --  The caller should check whether the package is subject to pragma\n       --  Initial_Condition.\n \n@@ -1379,6 +1432,7 @@ package body Exp_Prag is\n       --  runtime check as it will repeat the illegality.\n \n       if Error_Posted (Init_Cond) or else Error_Posted (Expr) then\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -1396,6 +1450,8 @@ package body Exp_Prag is\n \n       Append_To (List, Check);\n       Analyze (Check);\n+\n+      Restore_Globals;\n    end Expand_Pragma_Initial_Condition;\n \n    ------------------------------------\n@@ -1524,9 +1580,8 @@ package body Exp_Prag is\n    --     end loop;\n \n    procedure Expand_Pragma_Loop_Variant (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n-\n       Last_Var : constant Node_Id := Last (Pragma_Argument_Associations (N));\n+      Loc      : constant Source_Ptr := Sloc (N);\n \n       Curr_Assign : List_Id   := No_List;\n       Flag_Id     : Entity_Id := Empty;\n@@ -1743,6 +1798,10 @@ package body Exp_Prag is\n          end if;\n       end Process_Variant;\n \n+      --  Local variables\n+\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n    --  Start of processing for Expand_Pragma_Loop_Variant\n \n    begin\n@@ -1755,6 +1814,12 @@ package body Exp_Prag is\n          return;\n       end if;\n \n+      --  The loop variant may be subject to pragma Ghost with policy Ignore.\n+      --  Set the mode now to ensure that any nodes generated during expansion\n+      --  are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Locate the enclosing loop for which this assertion applies. In the\n       --  case of Ada 2012 array iteration, we might be dealing with nested\n       --  loops. Only the outermost loop has an identifier.\n@@ -1777,7 +1842,6 @@ package body Exp_Prag is\n       Variant := First (Pragma_Argument_Associations (N));\n       while Present (Variant) loop\n          Process_Variant (Variant, Is_Last => Variant = Last_Var);\n-\n          Next (Variant);\n       end loop;\n \n@@ -1817,6 +1881,10 @@ package body Exp_Prag is\n       --  corresponding declarations and statements. We leave it in the tree\n       --  for documentation purposes. It will be ignored by the backend.\n \n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Expand_Pragma_Loop_Variant;\n \n    --------------------------------"}, {"sha": "eec7149ebb285112be1784784cd998a262ab1333", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -34,6 +34,7 @@ with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n+with Ghost;    use Ghost;\n with Inline;   use Inline;\n with Itypes;   use Itypes;\n with Lib;      use Lib;\n@@ -6423,33 +6424,63 @@ package body Exp_Util is\n       Expr : Node_Id;\n       Mem  : Boolean := False) return Node_Id\n    is\n-      Loc : constant Source_Ptr := Sloc (Expr);\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n+      --  Local variables\n+\n+      Loc  : constant Source_Ptr := Sloc (Expr);\n+      Call : Node_Id;\n+      PFM  : Entity_Id;\n+\n+   --  Start of processing for Make_Predicate_Call\n \n    begin\n       pragma Assert (Present (Predicate_Function (Typ)));\n \n+      --  The related type may be subject to pragma Ghost with policy Ignore.\n+      --  Set the mode now to ensure that the call is properly flagged as\n+      --  ignored Ghost.\n+\n+      Set_Ghost_Mode_From_Entity (Typ);\n+\n       --  Call special membership version if requested and available\n \n       if Mem then\n-         declare\n-            PFM : constant Entity_Id := Predicate_Function_M (Typ);\n-         begin\n-            if Present (PFM) then\n-               return\n-                 Make_Function_Call (Loc,\n-                   Name                   => New_Occurrence_Of (PFM, Loc),\n-                   Parameter_Associations => New_List (Relocate_Node (Expr)));\n-            end if;\n-         end;\n+         PFM := Predicate_Function_M (Typ);\n+\n+         if Present (PFM) then\n+            Call :=\n+              Make_Function_Call (Loc,\n+                Name                   => New_Occurrence_Of (PFM, Loc),\n+                Parameter_Associations => New_List (Relocate_Node (Expr)));\n+\n+            Restore_Globals;\n+            return Call;\n+         end if;\n       end if;\n \n       --  Case of calling normal predicate function\n \n-      return\n-          Make_Function_Call (Loc,\n-            Name                   =>\n-              New_Occurrence_Of (Predicate_Function (Typ), Loc),\n-            Parameter_Associations => New_List (Relocate_Node (Expr)));\n+      Call :=\n+        Make_Function_Call (Loc,\n+          Name                   =>\n+            New_Occurrence_Of (Predicate_Function (Typ), Loc),\n+          Parameter_Associations => New_List (Relocate_Node (Expr)));\n+\n+      Restore_Globals;\n+      return Call;\n    end Make_Predicate_Call;\n \n    --------------------------"}, {"sha": "fc029c9658b99f840205f1e389af797198a46484", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -1862,17 +1862,17 @@ package body Freeze is\n       Formal : Entity_Id;\n       Indx   : Node_Id;\n \n-      Test_E : Entity_Id := E;\n-      --  This could use a comment ???\n+      Has_Default_Initialization : Boolean := False;\n+      --  This flag gets set to true for a variable with default initialization\n \n       Late_Freezing : Boolean := False;\n       --  Used to detect attempt to freeze function declared in another unit\n \n       Result : List_Id := No_List;\n       --  List of freezing actions, left at No_List if none\n \n-      Has_Default_Initialization : Boolean := False;\n-      --  This flag gets set to true for a variable with default initialization\n+      Test_E : Entity_Id := E;\n+      --  This could use a comment ???\n \n       procedure Add_To_Result (N : Node_Id);\n       --  N is a freezing action to be appended to the Result\n@@ -4632,7 +4632,7 @@ package body Freeze is\n       --  Ignore. Set the mode now to ensure that any nodes generated during\n       --  freezing are properly flagged as ignored Ghost.\n \n-      Set_Ghost_Mode_For_Freeze (E, N);\n+      Set_Ghost_Mode_From_Entity (E);\n \n       --  We are going to test for various reasons why this entity need not be\n       --  frozen here, but in the case of an Itype that's defined within a"}, {"sha": "75ceb4b2b589da6a322d45157c47758880b12581", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 446, "deletions": 208, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -37,6 +37,7 @@ with Opt;      use Opt;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n+with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -62,10 +63,15 @@ package body Ghost is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Ghost_Entity (N : Node_Id) return Entity_Id;\n+   --  Subsidiary to Check_Ghost_Context and Set_Ghost_Mode. Find the entity of\n+   --  a reference to a Ghost entity. Return Empty if there is no such entity.\n+\n    procedure Propagate_Ignored_Ghost_Code (N : Node_Id);\n-   --  Subsidiary to Set_Ghost_Mode_xxx. Signal all enclosing scopes that they\n-   --  now contain ignored Ghost code. Add the compilation unit containing N to\n-   --  table Ignored_Ghost_Units for post processing.\n+   --  Subsidiary to routines Mark_xxx_As_Ghost and Set_Ghost_Mode_From_xxx.\n+   --  Signal all enclosing scopes that they now contain ignored Ghost code.\n+   --  Add the compilation unit containing N to table Ignored_Ghost_Units for\n+   --  post processing.\n \n    ----------------------------\n    -- Add_Ignored_Ghost_Unit --\n@@ -113,18 +119,20 @@ package body Ghost is\n       then\n          Error_Msg_Sloc := Sloc (Full_View);\n \n-         Error_Msg_N (\"incompatible ghost policies in effect\",   Partial_View);\n-         Error_Msg_N (\"\\& declared with ghost policy Check\",     Partial_View);\n-         Error_Msg_N (\"\\& completed # with ghost policy Ignore\", Partial_View);\n+         Error_Msg_N (\"incompatible ghost policies in effect\", Partial_View);\n+         Error_Msg_N (\"\\& declared with ghost policy `Check`\", Partial_View);\n+         Error_Msg_N\n+           (\"\\& completed # with ghost policy `Ignore`\", Partial_View);\n \n       elsif Is_Ignored_Ghost_Entity (Partial_View)\n         and then Policy = Name_Check\n       then\n          Error_Msg_Sloc := Sloc (Full_View);\n \n-         Error_Msg_N (\"incompatible ghost policies in effect\",  Partial_View);\n-         Error_Msg_N (\"\\& declared with ghost policy Ignore\",   Partial_View);\n-         Error_Msg_N (\"\\& completed # with ghost policy Check\", Partial_View);\n+         Error_Msg_N (\"incompatible ghost policies in effect\", Partial_View);\n+         Error_Msg_N (\"\\& declared with ghost policy `Ignore`\", Partial_View);\n+         Error_Msg_N\n+           (\"\\& completed # with ghost policy `Check`\", Partial_View);\n       end if;\n    end Check_Ghost_Completion;\n \n@@ -147,213 +155,282 @@ package body Ghost is\n       -------------------------\n \n       function Is_OK_Ghost_Context (Context : Node_Id) return Boolean is\n-         function Is_Ghost_Declaration (Decl : Node_Id) return Boolean;\n-         --  Determine whether node Decl is a Ghost declaration or appears\n-         --  within a Ghost declaration.\n-\n-         function Is_Ghost_Statement_Or_Pragma (N : Node_Id) return Boolean;\n-         --  Determine whether statement or pragma N is Ghost or appears within\n-         --  a Ghost statement or pragma. To qualify as such, N must either\n-         --    1) Occur within a ghost subprogram or package\n-         --    2) Denote a call to a ghost procedure\n-         --    3) Denote an assignment statement whose target is a ghost\n-         --       variable.\n-         --    4) Denote a pragma that mentions a ghost entity\n-\n-         --------------------------\n-         -- Is_Ghost_Declaration --\n-         --------------------------\n-\n-         function Is_Ghost_Declaration (Decl : Node_Id) return Boolean is\n-            Par       : Node_Id;\n+         function Is_OK_Declaration (Decl : Node_Id) return Boolean;\n+         --  Determine whether node Decl is a suitable context for a reference\n+         --  to a Ghost entity. To qualify as such, Decl must either\n+         --    1) Be subject to pragma Ghost\n+         --    2) Rename a Ghost entity\n+\n+         function Is_OK_Pragma (Prag : Node_Id) return Boolean;\n+         --  Determine whether node Prag is a suitable context for a reference\n+         --  to a Ghost entity. To qualify as such, Prag must either\n+         --    1) Be an assertion expression pragma\n+         --    2) Denote pragma Global, Depends, Initializes, Refined_Global,\n+         --       Refined_Depends or Refined_State\n+         --    3) Specify an aspect of a Ghost entity\n+         --    4) Contain a reference to a Ghost entity\n+\n+         function Is_OK_Statement (Stmt : Node_Id) return Boolean;\n+         --  Determine whether node Stmt is a suitable context for a reference\n+         --  to a Ghost entity. To qualify as such, Stmt must either\n+         --    1) Denote a call to a Ghost procedure\n+         --    2) Denote an assignment statement whose target is Ghost\n+\n+         -----------------------\n+         -- Is_OK_Declaration --\n+         -----------------------\n+\n+         function Is_OK_Declaration (Decl : Node_Id) return Boolean is\n+            function Is_Ghost_Renaming (Ren_Decl : Node_Id) return Boolean;\n+            --  Determine whether node Ren_Decl denotes a renaming declaration\n+            --  with a Ghost name.\n+\n+            -----------------------\n+            -- Is_Ghost_Renaming --\n+            -----------------------\n+\n+            function Is_Ghost_Renaming (Ren_Decl : Node_Id) return Boolean is\n+               Nam_Id : Entity_Id;\n+\n+            begin\n+               if Is_Renaming_Declaration (Ren_Decl) then\n+                  Nam_Id := Ghost_Entity (Name (Ren_Decl));\n+\n+                  return Present (Nam_Id) and then Is_Ghost_Entity (Nam_Id);\n+               end if;\n+\n+               return False;\n+            end Is_Ghost_Renaming;\n+\n+            --  Local variables\n+\n             Subp_Decl : Node_Id;\n             Subp_Id   : Entity_Id;\n \n+         --  Start of processing for Is_OK_Declaration\n+\n          begin\n-            --  Climb the parent chain looking for an object declaration\n+            if Is_Declaration (Decl) then\n \n-            Par := Decl;\n-            while Present (Par) loop\n-               if Is_Declaration (Par) then\n+               --  A renaming declaration is Ghost when it renames a Ghost\n+               --  entity.\n \n-                  --  A declaration is Ghost when it appears within a Ghost\n-                  --  package or subprogram.\n+               if Is_Ghost_Renaming (Decl) then\n+                  return True;\n \n-                  if Ghost_Mode > None then\n-                     return True;\n+               --  The declaration may not have been analyzed yet, determine\n+               --  whether it is subject to pragma Ghost.\n \n-                  --  Otherwise the declaration may not have been analyzed yet,\n-                  --  determine whether it is subject to aspect/pragma Ghost.\n+               elsif Is_Subject_To_Ghost (Decl) then\n+                  return True;\n \n-                  else\n-                     return Is_Subject_To_Ghost (Par);\n-                  end if;\n+               --  The declaration appears within an assertion expression\n \n-               --  Special cases\n+               elsif In_Assertion_Expr > 0 then\n+                  return True;\n+               end if;\n \n-               --  A reference to a Ghost entity may appear as the default\n-               --  expression of a formal parameter of a subprogram body. This\n-               --  context must be treated as suitable because the relation\n-               --  between the spec and the body has not been established and\n-               --  the body is not marked as Ghost yet. The real check was\n-               --  performed on the spec.\n+            --  Special cases\n \n-               elsif Nkind (Par) = N_Parameter_Specification\n-                 and then Nkind (Parent (Parent (Par))) = N_Subprogram_Body\n-               then\n-                  return True;\n+            --  A reference to a Ghost entity may appear as the default\n+            --  expression of a formal parameter of a subprogram body. This\n+            --  context must be treated as suitable because the relation\n+            --  between the spec and the body has not been established and\n+            --  the body is not marked as Ghost yet. The real check was\n+            --  performed on the spec.\n \n-               --  References to Ghost entities may be relocated in internally\n-               --  generated bodies.\n+            elsif Nkind (Decl) = N_Parameter_Specification\n+              and then Nkind (Parent (Parent (Decl))) = N_Subprogram_Body\n+            then\n+               return True;\n \n-               elsif Nkind (Par) = N_Subprogram_Body\n-                 and then not Comes_From_Source (Par)\n-               then\n-                  Subp_Id := Corresponding_Spec (Par);\n+            --  References to Ghost entities may be relocated in internally\n+            --  generated bodies.\n \n-                  --  The original context is an expression function that has\n-                  --  been split into a spec and a body. The context is OK as\n-                  --  long as the the initial declaration is Ghost.\n+            elsif Nkind (Decl) = N_Subprogram_Body\n+              and then not Comes_From_Source (Decl)\n+            then\n+               Subp_Id := Corresponding_Spec (Decl);\n \n-                  if Present (Subp_Id) then\n-                     Subp_Decl :=\n-                       Original_Node (Unit_Declaration_Node (Subp_Id));\n+               --  The original context is an expression function that has\n+               --  been split into a spec and a body. The context is OK as\n+               --  long as the initial declaration is Ghost.\n \n-                     if Nkind (Subp_Decl) = N_Expression_Function then\n-                        return Is_Subject_To_Ghost (Subp_Decl);\n-                     end if;\n+               if Present (Subp_Id) then\n+                  Subp_Decl := Original_Node (Unit_Declaration_Node (Subp_Id));\n+\n+                  if Nkind (Subp_Decl) = N_Expression_Function then\n+                     return Is_Subject_To_Ghost (Subp_Decl);\n                   end if;\n \n-                  --  Otherwise this is either an internal body or an internal\n-                  --  completion. Both are OK because the real check was done\n-                  --  before expansion activities.\n+               --  Otherwise this is either an internal body or an internal\n+               --  completion. Both are OK because the real check was done\n+               --  before expansion activities.\n \n+               else\n                   return True;\n                end if;\n-\n-               --  Prevent the search from going too far\n-\n-               if Is_Body_Or_Package_Declaration (Par) then\n-                  return False;\n-               end if;\n-\n-               Par := Parent (Par);\n-            end loop;\n+            end if;\n \n             return False;\n-         end Is_Ghost_Declaration;\n+         end Is_OK_Declaration;\n \n-         ----------------------------------\n-         -- Is_Ghost_Statement_Or_Pragma --\n-         ----------------------------------\n+         ------------------\n+         -- Is_OK_Pragma --\n+         ------------------\n \n-         function Is_Ghost_Statement_Or_Pragma (N : Node_Id) return Boolean is\n-            function Is_Ghost_Entity_Reference (N : Node_Id) return Boolean;\n-            --  Determine whether an arbitrary node denotes a reference to a\n-            --  Ghost entity.\n+         function Is_OK_Pragma (Prag : Node_Id) return Boolean is\n+            procedure Check_Policies (Prag_Nam : Name_Id);\n+            --  Verify that the Ghost policy in effect is the same as the\n+            --  assertion policy for pragma name Prag_Nam. Emit an error if\n+            --  this is not the case.\n \n-            -------------------------------\n-            -- Is_Ghost_Entity_Reference --\n-            -------------------------------\n+            --------------------\n+            -- Check_Policies --\n+            --------------------\n \n-            function Is_Ghost_Entity_Reference (N : Node_Id) return Boolean is\n-               Ref : Node_Id;\n+            procedure Check_Policies (Prag_Nam : Name_Id) is\n+               AP : constant Name_Id := Check_Kind (Prag_Nam);\n+               GP : constant Name_Id := Policy_In_Effect (Name_Ghost);\n \n             begin\n-               --  When the reference extracts a subcomponent, recover the\n-               --  related object (SPARK RM 6.9(1)).\n-\n-               Ref := N;\n-               while Nkind_In (Ref, N_Explicit_Dereference,\n-                                    N_Indexed_Component,\n-                                    N_Selected_Component,\n-                                    N_Slice)\n-               loop\n-                  Ref := Prefix (Ref);\n-               end loop;\n-\n-               return\n-                 Is_Entity_Name (Ref)\n-                   and then Present (Entity (Ref))\n-                   and then Is_Ghost_Entity (Entity (Ref));\n-            end Is_Ghost_Entity_Reference;\n+               --  If the Ghost policy in effect at the point of a Ghost entity\n+               --  reference is Ignore, then the assertion policy of the pragma\n+               --  must be Ignore (SPARK RM 6.9(18)).\n+\n+               if GP = Name_Ignore and then AP /= Name_Ignore then\n+                  Error_Msg_N\n+                    (\"incompatible ghost policies in effect\", Ghost_Ref);\n+                  Error_Msg_NE\n+                    (\"\\ghost entity & has policy `Ignore`\",\n+                     Ghost_Ref, Ghost_Id);\n+\n+                  Error_Msg_Name_1 := AP;\n+                  Error_Msg_N\n+                    (\"\\assertion expression has policy %\", Ghost_Ref);\n+               end if;\n+            end Check_Policies;\n \n             --  Local variables\n \n-            Arg  : Node_Id;\n-            Stmt : Node_Id;\n+            Arg      : Node_Id;\n+            Arg_Id   : Entity_Id;\n+            Prag_Id  : Pragma_Id;\n+            Prag_Nam : Name_Id;\n \n-         --  Start of processing for Is_Ghost_Statement_Or_Pragma\n+         --  Start of processing for Is_OK_Pragma\n \n          begin\n-            if Nkind (N) = N_Pragma then\n+            if Nkind (Prag) = N_Pragma then\n+               Prag_Id  := Get_Pragma_Id (Prag);\n+               Prag_Nam := Original_Aspect_Pragma_Name (Prag);\n \n-               --  A pragma is Ghost when it appears within a Ghost package or\n-               --  subprogram.\n+               --  A pragma that applies to a Ghost construct or specifies an\n+               --  aspect of a Ghost entity is a Ghost pragma (SPARK RM 6.9(3))\n \n-               if Ghost_Mode > None then\n+               if Is_Ghost_Pragma (Prag) then\n                   return True;\n-               end if;\n \n-               --  A pragma is Ghost when it mentions a Ghost entity\n+               --  An assertion expression is a Ghost pragma when it contains a\n+               --  reference to a Ghost entity (SPARK RM 6.9(11)).\n \n-               Arg := First (Pragma_Argument_Associations (N));\n-               while Present (Arg) loop\n-                  if Is_Ghost_Entity_Reference (Get_Pragma_Arg (Arg)) then\n-                     return True;\n-                  end if;\n+               elsif Assertion_Expression_Pragma (Prag_Id) then\n \n-                  Next (Arg);\n-               end loop;\n-            end if;\n+                  --  Predicates are excluded from this category when they do\n+                  --  not apply to a Ghost subtype (SPARK RM 6.9(12)).\n \n-            Stmt := N;\n-            while Present (Stmt) loop\n-               if Is_Statement (Stmt) then\n+                  if Nam_In (Prag_Nam, Name_Dynamic_Predicate,\n+                                       Name_Predicate,\n+                                       Name_Static_Predicate)\n+                  then\n+                     return False;\n \n-                  --  A statement is Ghost when it appears within a Ghost\n-                  --  package or subprogram.\n+                  --  Otherwise ensure that the assertion policy and the Ghost\n+                  --  policy are compatible (SPARK RM 6.9(18)).\n \n-                  if Ghost_Mode > None then\n+                  else\n+                     Check_Policies (Prag_Nam);\n                      return True;\n+                  end if;\n \n-                  --  An assignment statement or a procedure call is Ghost when\n-                  --  the name denotes a Ghost entity.\n+               --  Several pragmas that may apply to a non-Ghost entity are\n+               --  treated as Ghost when they contain a reference to a Ghost\n+               --  entity (SPARK RM 6.9(12)).\n \n-                  elsif Nkind_In (Stmt, N_Assignment_Statement,\n-                                        N_Procedure_Call_Statement)\n-                  then\n-                     return Is_Ghost_Entity_Reference (Name (Stmt));\n-                  end if;\n+               elsif Nam_In (Prag_Nam, Name_Global,\n+                                       Name_Depends,\n+                                       Name_Initializes,\n+                                       Name_Refined_Global,\n+                                       Name_Refined_Depends,\n+                                       Name_Refined_State)\n+               then\n+                  return True;\n \n-               --  Prevent the search from going too far\n+               --  Otherwise a normal pragma is Ghost when it encloses a Ghost\n+               --  name (SPARK RM 6.9(3)).\n \n-               elsif Is_Body_Or_Package_Declaration (Stmt) then\n-                  return False;\n-               end if;\n+               else\n+                  Arg := First (Pragma_Argument_Associations (Prag));\n+                  while Present (Arg) loop\n+                     Arg_Id := Ghost_Entity (Get_Pragma_Arg (Arg));\n \n-               Stmt := Parent (Stmt);\n-            end loop;\n+                     if Present (Arg_Id) and then Is_Ghost_Entity (Arg_Id) then\n+                        return True;\n+                     end if;\n+\n+                     Next (Arg);\n+                  end loop;\n+               end if;\n+            end if;\n \n             return False;\n-         end Is_Ghost_Statement_Or_Pragma;\n+         end Is_OK_Pragma;\n \n-      --  Start of processing for Is_OK_Ghost_Context\n+         ---------------------\n+         -- Is_OK_Statement --\n+         ---------------------\n \n-      begin\n-         --  The Ghost entity appears within an assertion expression\n+         function Is_OK_Statement (Stmt : Node_Id) return Boolean is\n+            Nam_Id : Entity_Id;\n \n-         if In_Assertion_Expr > 0 then\n-            return True;\n+         begin\n+            --  An assignment statement or a procedure call is Ghost when the\n+            --  name denotes a Ghost entity.\n \n-         --  The Ghost entity is part of a declaration or its completion\n+            if Nkind_In (Stmt, N_Assignment_Statement,\n+                               N_Procedure_Call_Statement)\n+            then\n+               Nam_Id := Ghost_Entity (Name (Stmt));\n \n-         elsif Is_Ghost_Declaration (Context) then\n-            return True;\n+               return Present (Nam_Id) and then Is_Ghost_Entity (Nam_Id);\n+\n+            --  Special cases\n+\n+            --  An if statement is a suitable context for a Ghost entity if it\n+            --  is the byproduct of assertion expression expansion.\n+\n+            elsif Nkind (Stmt) = N_If_Statement\n+              and then Nkind (Original_Node (Stmt)) = N_Pragma\n+              and then Assertion_Expression_Pragma\n+                         (Get_Pragma_Id (Original_Node (Stmt)))\n+            then\n+               return True;\n+            end if;\n+\n+            return False;\n+         end Is_OK_Statement;\n+\n+         --  Local variables\n \n-         --  The Ghost entity is referenced within a Ghost statement\n+         Par : Node_Id;\n \n-         elsif Is_Ghost_Statement_Or_Pragma (Context) then\n+      --  Start of processing for Is_OK_Ghost_Context\n+\n+      begin\n+         --  The context is Ghost when it appears within a Ghost package or\n+         --  subprogram.\n+\n+         if Ghost_Mode > None then\n             return True;\n \n          --  Routine Expand_Record_Extension creates a parent subtype without\n@@ -364,7 +441,39 @@ package body Ghost is\n          elsif No (Parent (Context)) and then Is_Tagged_Type (Ghost_Id) then\n             return True;\n \n+         --  Otherwise climb the parent chain looking for a suitable Ghost\n+         --  context.\n+\n          else\n+            Par := Context;\n+            while Present (Par) loop\n+               if Is_Ignored_Ghost_Node (Par) then\n+                  return True;\n+\n+               --  A reference to a Ghost entity can appear within an aspect\n+               --  specification (SPARK RM 6.9(11)).\n+\n+               elsif Nkind (Par) = N_Aspect_Specification then\n+                  return True;\n+\n+               elsif Is_OK_Declaration (Par) then\n+                  return True;\n+\n+               elsif Is_OK_Pragma (Par) then\n+                  return True;\n+\n+               elsif Is_OK_Statement (Par) then\n+                  return True;\n+\n+               --  Prevent the search from going too far\n+\n+               elsif Is_Body_Or_Package_Declaration (Par) then\n+                  return False;\n+               end if;\n+\n+               Par := Parent (Par);\n+            end loop;\n+\n             return False;\n          end if;\n       end Is_OK_Ghost_Context;\n@@ -384,15 +493,15 @@ package body Ghost is\n             Error_Msg_Sloc := Sloc (Err_N);\n \n             Error_Msg_N  (\"incompatible ghost policies in effect\", Err_N);\n-            Error_Msg_NE (\"\\& declared with ghost policy Check\", Err_N, Id);\n-            Error_Msg_NE (\"\\& used # with ghost policy Ignore\", Err_N, Id);\n+            Error_Msg_NE (\"\\& declared with ghost policy `Check`\", Err_N, Id);\n+            Error_Msg_NE (\"\\& used # with ghost policy `Ignore`\", Err_N, Id);\n \n          elsif Is_Ignored_Ghost_Entity (Id) and then Policy = Name_Check then\n             Error_Msg_Sloc := Sloc (Err_N);\n \n             Error_Msg_N  (\"incompatible ghost policies in effect\", Err_N);\n-            Error_Msg_NE (\"\\& declared with ghost policy Ignore\", Err_N, Id);\n-            Error_Msg_NE (\"\\& used # with ghost policy Check\", Err_N, Id);\n+            Error_Msg_NE (\"\\& declared with ghost policy `Ignore`\", Err_N, Id);\n+            Error_Msg_NE (\"\\& used # with ghost policy `Check`\", Err_N, Id);\n          end if;\n       end Check_Ghost_Policy;\n \n@@ -458,6 +567,75 @@ package body Ghost is\n       end if;\n    end Check_Ghost_Derivation;\n \n+   ----------------------------\n+   -- Check_Ghost_Overriding --\n+   ----------------------------\n+\n+   procedure Check_Ghost_Overriding\n+     (Subp            : Entity_Id;\n+      Overridden_Subp : Entity_Id)\n+   is\n+      Par_Subp : Entity_Id;\n+\n+   begin\n+      if Present (Subp) and then Present (Overridden_Subp) then\n+         Par_Subp := Ultimate_Alias (Overridden_Subp);\n+\n+         --  The Ghost policy in effect at the point of declaration of a parent\n+         --  and an overriding subprogram must match (SPARK RM 6.9(17)).\n+\n+         if Is_Checked_Ghost_Entity (Par_Subp)\n+           and then Is_Ignored_Ghost_Entity (Subp)\n+         then\n+            Error_Msg_N (\"incompatible ghost policies in effect\", Subp);\n+\n+            Error_Msg_Sloc := Sloc (Par_Subp);\n+            Error_Msg_N (\"\\& declared # with ghost policy `Check`\", Subp);\n+\n+            Error_Msg_Sloc := Sloc (Subp);\n+            Error_Msg_N (\"\\overridden # with ghost policy `Ignore`\", Subp);\n+\n+         elsif Is_Ignored_Ghost_Entity (Par_Subp)\n+           and then Is_Checked_Ghost_Entity (Subp)\n+         then\n+            Error_Msg_N (\"incompatible ghost policies in effect\", Subp);\n+\n+            Error_Msg_Sloc := Sloc (Par_Subp);\n+            Error_Msg_N (\"\\& declared # with ghost policy `Ignore`\", Subp);\n+\n+            Error_Msg_Sloc := Sloc (Subp);\n+            Error_Msg_N (\"\\overridden # with ghost policy `Check`\", Subp);\n+         end if;\n+      end if;\n+   end Check_Ghost_Overriding;\n+\n+   ------------------\n+   -- Ghost_Entity --\n+   ------------------\n+\n+   function Ghost_Entity (N : Node_Id) return Entity_Id is\n+      Ref : Node_Id;\n+\n+   begin\n+      --  When the reference extracts a subcomponent, recover the related\n+      --  object (SPARK RM 6.9(1)).\n+\n+      Ref := N;\n+      while Nkind_In (Ref, N_Explicit_Dereference,\n+                           N_Indexed_Component,\n+                           N_Selected_Component,\n+                           N_Slice)\n+      loop\n+         Ref := Prefix (Ref);\n+      end loop;\n+\n+      if Is_Entity_Name (Ref) then\n+         return Entity (Ref);\n+      else\n+         return Empty;\n+      end if;\n+   end Ghost_Entity;\n+\n    --------------------------------\n    -- Implements_Ghost_Interface --\n    --------------------------------\n@@ -639,6 +817,67 @@ package body Ghost is\n       Ignored_Ghost_Units.Release;\n    end Lock;\n \n+   -----------------------------\n+   -- Mark_Full_View_As_Ghost --\n+   -----------------------------\n+\n+   procedure Mark_Full_View_As_Ghost\n+     (Priv_Typ : Entity_Id;\n+      Full_Typ : Entity_Id)\n+   is\n+      Full_Decl : constant Node_Id := Declaration_Node (Full_Typ);\n+\n+   begin\n+      if Is_Checked_Ghost_Entity (Priv_Typ) then\n+         Set_Is_Checked_Ghost_Entity (Full_Typ);\n+\n+      elsif Is_Ignored_Ghost_Entity (Priv_Typ) then\n+         Set_Is_Ignored_Ghost_Entity (Full_Typ);\n+         Set_Is_Ignored_Ghost_Node (Full_Decl);\n+         Propagate_Ignored_Ghost_Code (Full_Decl);\n+      end if;\n+   end Mark_Full_View_As_Ghost;\n+\n+   --------------------------\n+   -- Mark_Pragma_As_Ghost --\n+   --------------------------\n+\n+   procedure Mark_Pragma_As_Ghost\n+     (Prag       : Node_Id;\n+      Context_Id : Entity_Id)\n+   is\n+   begin\n+      if Is_Checked_Ghost_Entity (Context_Id) then\n+         Set_Is_Ghost_Pragma (Prag);\n+\n+      elsif Is_Ignored_Ghost_Entity (Context_Id) then\n+         Set_Is_Ghost_Pragma (Prag);\n+         Set_Is_Ignored_Ghost_Node (Prag);\n+         Propagate_Ignored_Ghost_Code (Prag);\n+      end if;\n+   end Mark_Pragma_As_Ghost;\n+\n+   ----------------------------\n+   -- Mark_Renaming_As_Ghost --\n+   ----------------------------\n+\n+   procedure Mark_Renaming_As_Ghost\n+     (Ren_Decl : Node_Id;\n+      Nam_Id   : Entity_Id)\n+   is\n+      Ren_Id : constant Entity_Id := Defining_Entity (Ren_Decl);\n+\n+   begin\n+      if Is_Checked_Ghost_Entity (Nam_Id) then\n+         Set_Is_Checked_Ghost_Entity (Ren_Id);\n+\n+      elsif Is_Ignored_Ghost_Entity (Nam_Id) then\n+         Set_Is_Ignored_Ghost_Entity (Ren_Id);\n+         Set_Is_Ignored_Ghost_Node (Ren_Decl);\n+         Propagate_Ignored_Ghost_Code (Ren_Decl);\n+      end if;\n+   end Mark_Renaming_As_Ghost;\n+\n    ----------------------------------\n    -- Propagate_Ignored_Ghost_Code --\n    ----------------------------------\n@@ -799,37 +1038,34 @@ package body Ghost is\n    -- Set_Ghost_Mode --\n    --------------------\n \n-   procedure Set_Ghost_Mode (N : Node_Id; Prev_Id : Entity_Id := Empty) is\n-      procedure Set_Ghost_Mode_From_Entity (Id : Entity_Id);\n+   procedure Set_Ghost_Mode (N : Node_Id; Id : Entity_Id := Empty) is\n+      procedure Set_From_Entity (Ent_Id : Entity_Id);\n       --  Set the value of global variable Ghost_Mode depending on the mode of\n-      --  entity Id.\n+      --  entity Ent_Id.\n \n-      procedure Set_Ghost_Mode_From_Policy;\n+      procedure Set_From_Policy;\n       --  Set the value of global variable Ghost_Mode depending on the current\n       --  Ghost policy in effect.\n \n-      --------------------------------\n-      -- Set_Ghost_Mode_From_Entity --\n-      --------------------------------\n+      ---------------------\n+      -- Set_From_Entity --\n+      ---------------------\n \n-      procedure Set_Ghost_Mode_From_Entity (Id : Entity_Id) is\n+      procedure Set_From_Entity (Ent_Id : Entity_Id) is\n       begin\n-         if Is_Checked_Ghost_Entity (Id) then\n-            Ghost_Mode := Check;\n-\n-         elsif Is_Ignored_Ghost_Entity (Id) then\n-            Ghost_Mode := Ignore;\n+         Set_Ghost_Mode_From_Entity (Ent_Id);\n \n+         if Is_Ignored_Ghost_Entity (Ent_Id) then\n             Set_Is_Ignored_Ghost_Node (N);\n             Propagate_Ignored_Ghost_Code (N);\n          end if;\n-      end Set_Ghost_Mode_From_Entity;\n+      end Set_From_Entity;\n \n-      --------------------------------\n-      -- Set_Ghost_Mode_From_Policy --\n-      --------------------------------\n+      ---------------------\n+      -- Set_From_Policy --\n+      ---------------------\n \n-      procedure Set_Ghost_Mode_From_Policy is\n+      procedure Set_From_Policy is\n          Policy : constant Name_Id := Policy_In_Effect (Name_Ghost);\n \n       begin\n@@ -842,11 +1078,11 @@ package body Ghost is\n             Set_Is_Ignored_Ghost_Node (N);\n             Propagate_Ignored_Ghost_Code (N);\n          end if;\n-      end Set_Ghost_Mode_From_Policy;\n+      end Set_From_Policy;\n \n       --  Local variables\n \n-      Nam : Node_Id;\n+      Nam_Id : Entity_Id;\n \n    --  Start of processing for Set_Ghost_Mode\n \n@@ -856,25 +1092,25 @@ package body Ghost is\n \n       if Is_Declaration (N) then\n          if Is_Subject_To_Ghost (N) then\n-            Set_Ghost_Mode_From_Policy;\n+            Set_From_Policy;\n \n          --  The declaration denotes the completion of a deferred constant,\n          --  pragma Ghost appears on the partial declaration.\n \n          elsif Nkind (N) = N_Object_Declaration\n            and then Constant_Present (N)\n-           and then Present (Prev_Id)\n+           and then Present (Id)\n          then\n-            Set_Ghost_Mode_From_Entity (Prev_Id);\n+            Set_From_Entity (Id);\n \n          --  The declaration denotes the full view of a private type, pragma\n          --  Ghost appears on the partial declaration.\n \n          elsif Nkind (N) = N_Full_Type_Declaration\n            and then Is_Private_Type (Defining_Entity (N))\n-           and then Present (Prev_Id)\n+           and then Present (Id)\n          then\n-            Set_Ghost_Mode_From_Entity (Prev_Id);\n+            Set_From_Entity (Id);\n          end if;\n \n       --  The input denotes an assignment or a procedure call. In this case\n@@ -883,48 +1119,50 @@ package body Ghost is\n       elsif Nkind_In (N, N_Assignment_Statement,\n                          N_Procedure_Call_Statement)\n       then\n-         --  When the reference extracts a subcomponent, recover the related\n-         --  object (SPARK RM 6.9(1)).\n-\n-         Nam := Name (N);\n-         while Nkind_In (Nam, N_Explicit_Dereference,\n-                              N_Indexed_Component,\n-                              N_Selected_Component,\n-                              N_Slice)\n-         loop\n-            Nam := Prefix (Nam);\n-         end loop;\n+         Nam_Id := Ghost_Entity (Name (N));\n \n-         if Is_Entity_Name (Nam)\n-           and then Present (Entity (Nam))\n-         then\n-            Set_Ghost_Mode_From_Entity (Entity (Nam));\n+         if Present (Nam_Id) then\n+            Set_From_Entity (Nam_Id);\n          end if;\n \n       --  The input denotes a package or subprogram body\n \n       elsif Nkind_In (N, N_Package_Body, N_Subprogram_Body) then\n-         if (Present (Prev_Id) and then Is_Ghost_Entity (Prev_Id))\n+         if (Present (Id) and then Is_Ghost_Entity (Id))\n            or else Is_Subject_To_Ghost (N)\n          then\n-            Set_Ghost_Mode_From_Policy;\n+            Set_From_Policy;\n+         end if;\n+\n+      --  The input denotes a pragma\n+\n+      elsif Nkind (N) = N_Pragma and then Is_Ghost_Pragma (N) then\n+         if Is_Ignored_Ghost_Node (N) then\n+            Ghost_Mode := Ignore;\n+         else\n+            Ghost_Mode := Check;\n          end if;\n+\n+      --  The input denotes a freeze node\n+\n+      elsif Nkind (N) = N_Freeze_Entity and then Present (Id) then\n+         Set_From_Entity (Id);\n       end if;\n    end Set_Ghost_Mode;\n \n-   -------------------------------\n-   -- Set_Ghost_Mode_For_Freeze --\n-   -------------------------------\n+   --------------------------------\n+   -- Set_Ghost_Mode_From_Entity --\n+   --------------------------------\n \n-   procedure Set_Ghost_Mode_For_Freeze (Id : Entity_Id; N : Node_Id) is\n+   procedure Set_Ghost_Mode_From_Entity (Id : Entity_Id) is\n    begin\n       if Is_Checked_Ghost_Entity (Id) then\n          Ghost_Mode := Check;\n+\n       elsif Is_Ignored_Ghost_Entity (Id) then\n          Ghost_Mode := Ignore;\n-         Propagate_Ignored_Ghost_Code (N);\n       end if;\n-   end Set_Ghost_Mode_For_Freeze;\n+   end Set_Ghost_Mode_From_Entity;\n \n    -------------------------\n    -- Set_Is_Ghost_Entity --"}, {"sha": "c267e70e0fcbec389a2126bdb1509b591037410a", "filename": "gcc/ada/ghost.ads", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fghost.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fghost.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.ads?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 2014-2015, Free Software Foundation, Inc.       --\n+--          Copyright (C) 2014-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,6 +49,13 @@ package Ghost is\n    --  Verify that the parent type and all progenitors of derived type or type\n    --  extension Typ are Ghost. If this is not the case, issue an error.\n \n+   procedure Check_Ghost_Overriding\n+     (Subp            : Entity_Id;\n+      Overridden_Subp : Entity_Id);\n+   --  Verify that the Ghost policy of parent subprogram Overridden_Subp is the\n+   --  same as the Ghost policy of overriding subprogram Subp. Emit an error if\n+   --  this is not the case.\n+\n    function Implements_Ghost_Interface (Typ : Entity_Id) return Boolean;\n    --  Determine whether type Typ implements at least one Ghost interface\n \n@@ -68,48 +75,70 @@ package Ghost is\n    procedure Lock;\n    --  Lock internal tables before calling backend\n \n+   procedure Mark_Full_View_As_Ghost\n+     (Priv_Typ : Entity_Id;\n+      Full_Typ : Entity_Id);\n+   --  Set all Ghost-related attributes of type Full_Typ depending on the Ghost\n+   --  mode of incomplete or private type Priv_Typ.\n+\n+   procedure Mark_Pragma_As_Ghost\n+     (Prag       : Node_Id;\n+      Context_Id : Entity_Id);\n+   --  Set all Ghost-related attributes of pragma Prag if its context denoted\n+   --  by Id is a Ghost entity.\n+\n+   procedure Mark_Renaming_As_Ghost\n+     (Ren_Decl : Node_Id;\n+      Nam_Id   : Entity_Id);\n+   --  Set all Ghost-related attributes of renaming declaration Ren_Decl if its\n+   --  renamed name denoted by Nam_Id is a Ghost entity.\n+\n    procedure Remove_Ignored_Ghost_Code;\n    --  Remove all code marked as ignored Ghost from the trees of all qualifying\n    --  units.\n    --\n    --  WARNING: this is a separate front end pass, care should be taken to keep\n    --  it optimized.\n \n-   procedure Set_Ghost_Mode (N : Node_Id; Prev_Id : Entity_Id := Empty);\n+   procedure Set_Ghost_Mode (N : Node_Id; Id : Entity_Id := Empty);\n    --  Set the value of global variable Ghost_Mode depending on the following\n    --  scenarios:\n    --\n    --    If N is a declaration, determine whether N is subject to pragma Ghost.\n    --    If this is the case, the Ghost_Mode is set based on the current Ghost\n    --    policy in effect. Special cases:\n    --\n-   --      N is the completion of a deferred constant, Prev_Id denotes the\n-   --      entity of the partial declaration.\n+   --      N is the completion of a deferred constant, the Ghost_Mode is set\n+   --      based on the mode of partial declaration entity denoted by Id.\n+   --\n+   --      N is the full view of a private type, the Ghost_Mode is set based\n+   --      on the mode of the partial declaration entity denoted by Id.\n+   --\n+   --    If N is an assignment statement or a procedure call, the Ghost_Mode is\n+   --    set based on the mode of the name.\n    --\n-   --      N is the full view of a private type, Prev_Id denotes the entity\n-   --      of the partial declaration.\n+   --    If N denotes a package or a subprogram body, the Ghost_Mode is set to\n+   --    the current Ghost policy in effect if the body is subject to Ghost or\n+   --    the corresponding spec denoted by Id is a Ghost entity.\n    --\n-   --    If N is an assignment statement or a procedure call, determine whether\n-   --    the name of N denotes a reference to a Ghost entity. If this is the\n-   --    case, the Global_Mode is set based on the mode of the name.\n+   --    If N is a pragma, the Ghost_Mode is set based on the mode of the\n+   --    pragma.\n    --\n-   --    If N denotes a package or a subprogram body, determine whether the\n-   --    corresponding spec Prev_Id is a Ghost entity or the body is subject\n-   --    to pragma Ghost. If this is the case, the Global_Mode is set based on\n-   --    the current Ghost policy in effect.\n+   --    If N is a freeze node, the Global_Mode is set based on the mode of\n+   --    entity Id.\n    --\n    --  WARNING: the caller must save and restore the value of Ghost_Mode in a\n    --  a stack-like fasion as this routine may override the existing value.\n \n-   procedure Set_Ghost_Mode_For_Freeze (Id : Entity_Id; N : Node_Id);\n-   --  Set the value of global variable Ghost_Mode depending on the mode of\n-   --  entity Id. N denotes the context of the freeze.\n+   procedure Set_Ghost_Mode_From_Entity (Id : Entity_Id);\n+   --  Set the valye of global variable Ghost_Mode depending on the mode of\n+   --  entity Id.\n    --\n    --  WARNING: the caller must save and restore the value of Ghost_Mode in a\n    --  a stack-like fasion as this routine may override the existing value.\n \n    procedure Set_Is_Ghost_Entity (Id : Entity_Id);\n-   --  Set the relevant ghost attribute of entity Id depending on the current\n+   --  Set the relevant Ghost attributes of entity Id depending on the current\n    --  Ghost assertion policy in effect.\n \n end Ghost;"}, {"sha": "e1ff0c1c8712ece02a26849fd28fba6fec78ad75", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -55,6 +55,7 @@ package body Sem_Ch11 is\n    -----------------------------------\n \n    procedure Analyze_Exception_Declaration (N : Node_Id) is\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n       Id : constant Entity_Id := Defining_Identifier (N);\n       PF : constant Boolean   := Is_Pure (Current_Scope);\n \n@@ -82,6 +83,11 @@ package body Sem_Ch11 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Exception_Declaration;\n \n    --------------------------------"}, {"sha": "266b746a7a7e2205c2c6fe0245102dd1e2132e43", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -3124,14 +3124,15 @@ package body Sem_Ch12 is\n    ------------------------------------------\n \n    procedure Analyze_Generic_Package_Declaration (N : Node_Id) is\n+      GM          : constant Ghost_Mode_Type := Ghost_Mode;\n       Loc         : constant Source_Ptr := Sloc (N);\n-      Id          : Entity_Id;\n-      New_N       : Node_Id;\n-      Save_Parent : Node_Id;\n-      Renaming    : Node_Id;\n       Decls       : constant List_Id :=\n                       Visible_Declarations (Specification (N));\n       Decl        : Node_Id;\n+      Id          : Entity_Id;\n+      New_N       : Node_Id;\n+      Renaming    : Node_Id;\n+      Save_Parent : Node_Id;\n \n    begin\n       --  The generic package declaration may be subject to pragma Ghost with\n@@ -3290,13 +3291,19 @@ package body Sem_Ch12 is\n             end if;\n          end;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Generic_Package_Declaration;\n \n    --------------------------------------------\n    -- Analyze_Generic_Subprogram_Declaration --\n    --------------------------------------------\n \n    procedure Analyze_Generic_Subprogram_Declaration (N : Node_Id) is\n+      GM          : constant Ghost_Mode_Type := Ghost_Mode;\n       Formals     : List_Id;\n       Id          : Entity_Id;\n       New_N       : Node_Id;\n@@ -3460,6 +3467,11 @@ package body Sem_Ch12 is\n       Generate_Reference_To_Formals (Id);\n \n       List_Inherited_Pre_Post_Aspects (Id);\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Generic_Subprogram_Declaration;\n \n    -----------------------------------"}, {"sha": "8db5b5088a0787b4757005a9cfa698d46112e287", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 374, "deletions": 332, "changes": 706, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -34,6 +34,7 @@ with Exp_Disp; use Exp_Disp;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n@@ -7762,21 +7763,25 @@ package body Sem_Ch13 is\n    function Build_Invariant_Procedure_Declaration\n      (Typ : Entity_Id) return Node_Id\n    is\n-      Loc           : constant Source_Ptr := Sloc (Typ);\n-      Object_Entity : constant Entity_Id :=\n-        Make_Defining_Identifier (Loc, New_Internal_Name ('I'));\n-      Spec          : Node_Id;\n-      SId           : Entity_Id;\n+      GM     : constant Ghost_Mode_Type := Ghost_Mode;\n+      Loc    : constant Source_Ptr := Sloc (Typ);\n+      Decl   : Node_Id;\n+      Obj_Id : Entity_Id;\n+      SId    : Entity_Id;\n \n    begin\n-      Set_Etype (Object_Entity, Typ);\n-\n-      --  Check for duplicate definiations.\n+      --  Check for duplicate definiations\n \n       if Has_Invariants (Typ) and then Present (Invariant_Procedure (Typ)) then\n          return Empty;\n       end if;\n \n+      --  The related type may be subject to pragma Ghost with policy Ignore.\n+      --  Set the mode now to ensure that the predicate functions are properly\n+      --  flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode_From_Entity (Typ);\n+\n       SId :=\n         Make_Defining_Identifier (Loc,\n           Chars => New_External_Name (Chars (Typ), \"Invariant\"));\n@@ -7786,15 +7791,31 @@ package body Sem_Ch13 is\n       Set_Is_Invariant_Procedure (SId);\n       Set_Invariant_Procedure (Typ, SId);\n \n-      Spec :=\n-        Make_Procedure_Specification (Loc,\n-          Defining_Unit_Name       => SId,\n-          Parameter_Specifications => New_List (\n-            Make_Parameter_Specification (Loc,\n-              Defining_Identifier => Object_Entity,\n-              Parameter_Type      => New_Occurrence_Of (Typ, Loc))));\n+      --  Mark the invariant procedure explicitly as Ghost because it does not\n+      --  come from source.\n+\n+      if Ghost_Mode > None then\n+         Set_Is_Ghost_Entity (SId);\n+      end if;\n+\n+      Obj_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('I'));\n+      Set_Etype (Obj_Id, Typ);\n+\n+      Decl :=\n+        Make_Subprogram_Declaration (Loc,\n+          Make_Procedure_Specification (Loc,\n+            Defining_Unit_Name       => SId,\n+            Parameter_Specifications => New_List (\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => Obj_Id,\n+                Parameter_Type      => New_Occurrence_Of (Typ, Loc)))));\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n \n-      return Make_Subprogram_Declaration (Loc, Specification => Spec);\n+      return Decl;\n    end Build_Invariant_Procedure_Declaration;\n \n    -------------------------------\n@@ -7813,20 +7834,21 @@ package body Sem_Ch13 is\n    --  end typInvariant;\n \n    procedure Build_Invariant_Procedure (Typ : Entity_Id; N : Node_Id) is\n+      Priv_Decls : constant List_Id := Private_Declarations (N);\n+      Vis_Decls  : constant List_Id := Visible_Declarations (N);\n+\n       Loc   : constant Source_Ptr := Sloc (Typ);\n       Stmts : List_Id;\n       Spec  : Node_Id;\n       SId   : Entity_Id;\n       PDecl : Node_Id;\n       PBody : Node_Id;\n \n-      Nam : Name_Id;\n-      --  Name for Check pragma, usually Invariant, but might be Type_Invariant\n-      --  if we come from a Type_Invariant aspect, we make sure to build the\n-      --  Check pragma with the right name, so that Check_Policy works right.\n+      Object_Entity : Node_Id;\n+      --  The entity of the formal for the procedure\n \n-      Visible_Decls : constant List_Id := Visible_Declarations (N);\n-      Private_Decls : constant List_Id := Private_Declarations (N);\n+      Object_Name : Name_Id;\n+      --  Name for argument of invariant procedure\n \n       procedure Add_Invariants (T : Entity_Id; Inherit : Boolean);\n       --  Appends statements to Stmts for any invariants in the rep item chain\n@@ -7836,246 +7858,229 @@ package body Sem_Ch13 is\n       --  \"inherited\" to the exception message and generating an informational\n       --  message about the inheritance of an invariant.\n \n-      Object_Name : Name_Id;\n-      --  Name for argument of invariant procedure\n-\n-      Object_Entity : Node_Id;\n-      --  The entity of the formal for the procedure\n-\n       --------------------\n       -- Add_Invariants --\n       --------------------\n \n       procedure Add_Invariants (T : Entity_Id; Inherit : Boolean) is\n-         Ritem : Node_Id;\n-         Arg1  : Node_Id;\n-         Arg2  : Node_Id;\n-         Arg3  : Node_Id;\n-         Exp   : Node_Id;\n-         Loc   : Source_Ptr;\n-         Assoc : List_Id;\n-         Str   : String_Id;\n-\n-         procedure Replace_Type_Reference (N : Node_Id);\n-         --  Replace a single occurrence N of the subtype name with a reference\n-         --  to the formal of the predicate function. N can be an identifier\n-         --  referencing the subtype, or a selected component, representing an\n-         --  appropriately qualified occurrence of the subtype name.\n-\n-         procedure Replace_Type_References is\n-           new Replace_Type_References_Generic (Replace_Type_Reference);\n-         --  Traverse an expression replacing all occurrences of the subtype\n-         --  name with appropriate references to the object that is the formal\n-         --  parameter of the predicate function. Note that we must ensure\n-         --  that the type and entity information is properly set in the\n-         --  replacement node, since we will do a Preanalyze call of this\n-         --  expression without proper visibility of the procedure argument.\n+         procedure Add_Invariant (Prag : Node_Id);\n+         --  Create a runtime check to verify the exression of invariant pragma\n+         --  Prag. All generated code is added to list Stmts.\n \n-         ----------------------------\n-         -- Replace_Type_Reference --\n-         ----------------------------\n+         -------------------\n+         -- Add_Invariant --\n+         -------------------\n \n-         --  Note: See comments in Add_Predicates.Replace_Type_Reference\n-         --  regarding handling of Sloc and Comes_From_Source.\n+         procedure Add_Invariant (Prag : Node_Id) is\n+            procedure Replace_Type_Reference (N : Node_Id);\n+            --  Replace a single occurrence N of the subtype name with a\n+            --  reference to the formal of the predicate function. N can be an\n+            --  identifier referencing the subtype, or a selected component,\n+            --  representing an appropriately qualified occurrence of the\n+            --  subtype name.\n+\n+            procedure Replace_Type_References is\n+              new Replace_Type_References_Generic (Replace_Type_Reference);\n+            --  Traverse an expression replacing all occurrences of the subtype\n+            --  name with appropriate references to the formal of the predicate\n+            --  function. Note that we must ensure that the type and entity\n+            --  information is properly set in the replacement node, since we\n+            --  will do a Preanalyze call of this expression without proper\n+            --  visibility of the procedure argument.\n+\n+            ----------------------------\n+            -- Replace_Type_Reference --\n+            ----------------------------\n+\n+            --  Note: See comments in Add_Predicates.Replace_Type_Reference\n+            --  regarding handling of Sloc and Comes_From_Source.\n+\n+            procedure Replace_Type_Reference (N : Node_Id) is\n+               Nloc : constant Source_Ptr := Sloc (N);\n \n-         procedure Replace_Type_Reference (N : Node_Id) is\n-         begin\n+            begin\n+               --  Add semantic information to node to be rewritten, for ASIS\n+               --  navigation needs.\n \n-            --  Add semantic information to node to be rewritten, for ASIS\n-            --  navigation needs.\n+               if Nkind (N) = N_Identifier then\n+                  Set_Entity (N, T);\n+                  Set_Etype  (N, T);\n \n-            if Nkind (N) = N_Identifier then\n-               Set_Entity (N, T);\n-               Set_Etype  (N, T);\n+               elsif Nkind (N) = N_Selected_Component then\n+                  Analyze (Prefix (N));\n+                  Set_Entity (Selector_Name (N), T);\n+                  Set_Etype  (Selector_Name (N), T);\n+               end if;\n \n-            elsif Nkind (N) = N_Selected_Component then\n-               Analyze (Prefix (N));\n-               Set_Entity (Selector_Name (N), T);\n-               Set_Etype  (Selector_Name (N), T);\n-            end if;\n+               --  Invariant'Class, replace with T'Class (obj)\n \n-            --  Invariant'Class, replace with T'Class (obj)\n-            --  In ASIS mode, an inherited item is analyzed already, and the\n-            --  replacement has been done, so do not repeat transformation\n-            --  to prevent ill-formed tree.\n+               if Class_Present (Prag) then\n \n-            if Class_Present (Ritem) then\n-               if ASIS_Mode\n-                 and then Nkind (Parent (N)) = N_Attribute_Reference\n-                 and then Attribute_Name (Parent (N)) = Name_Class\n-               then\n-                  null;\n+                  --  In ASIS mode, an inherited item is already analyzed,\n+                  --  and the replacement has been done, so do not repeat\n+                  --  the transformation to prevent a malformed tree.\n \n-               else\n-                  Rewrite (N,\n-                    Make_Type_Conversion (Sloc (N),\n-                      Subtype_Mark =>\n-                        Make_Attribute_Reference (Sloc (N),\n-                          Prefix         => New_Occurrence_Of (T, Sloc (N)),\n-                          Attribute_Name => Name_Class),\n-                      Expression   =>\n-                         Make_Identifier (Sloc (N), Object_Name)));\n+                  if ASIS_Mode\n+                    and then Nkind (Parent (N)) = N_Attribute_Reference\n+                    and then Attribute_Name (Parent (N)) = Name_Class\n+                  then\n+                     null;\n \n-                  Set_Entity (Expression (N), Object_Entity);\n-                  Set_Etype  (Expression (N), Typ);\n-               end if;\n+                  else\n+                     Rewrite (N,\n+                       Make_Type_Conversion (Nloc,\n+                         Subtype_Mark =>\n+                           Make_Attribute_Reference (Nloc,\n+                             Prefix         => New_Occurrence_Of (T, Nloc),\n+                             Attribute_Name => Name_Class),\n+                         Expression   => Make_Identifier (Nloc, Object_Name)));\n+\n+                     Set_Entity (Expression (N), Object_Entity);\n+                     Set_Etype  (Expression (N), Typ);\n+                  end if;\n \n-            --  Invariant, replace with obj\n+               --  Invariant, replace with obj\n \n-            else\n-               Rewrite (N, Make_Identifier (Sloc (N), Object_Name));\n-               Set_Entity (N, Object_Entity);\n-               Set_Etype  (N, Typ);\n-            end if;\n+               else\n+                  Rewrite (N, Make_Identifier (Nloc, Object_Name));\n+                  Set_Entity (N, Object_Entity);\n+                  Set_Etype  (N, Typ);\n+               end if;\n \n-            Set_Comes_From_Source (N, True);\n-         end Replace_Type_Reference;\n+               Set_Comes_From_Source (N, True);\n+            end Replace_Type_Reference;\n \n-      --  Start of processing for Add_Invariants\n+            --  Local variables\n \n-      begin\n-         Ritem := First_Rep_Item (T);\n-         while Present (Ritem) loop\n-            if Nkind (Ritem) = N_Pragma\n-              and then Pragma_Name (Ritem) = Name_Invariant\n-            then\n-               Arg1 := First (Pragma_Argument_Associations (Ritem));\n-               Arg2 := Next (Arg1);\n-               Arg3 := Next (Arg2);\n+            Asp   : constant Node_Id    := Corresponding_Aspect (Prag);\n+            Nam   : constant Name_Id    := Original_Aspect_Pragma_Name (Prag);\n+            Ploc  : constant Source_Ptr := Sloc (Prag);\n+            Arg1  : Node_Id;\n+            Arg2  : Node_Id;\n+            Arg3  : Node_Id;\n+            Assoc : List_Id;\n+            Expr  : Node_Id;\n+            Str   : String_Id;\n \n-               Arg1 := Get_Pragma_Arg (Arg1);\n-               Arg2 := Get_Pragma_Arg (Arg2);\n+         --  Start of processing for Add_Invariant\n \n-               --  For Inherit case, ignore Invariant, process only Class case\n+         begin\n+            --  Extract the arguments of the invariant pragma\n \n-               if Inherit then\n-                  if not Class_Present (Ritem) then\n-                     goto Continue;\n-                  end if;\n+            Arg1 := First (Pragma_Argument_Associations (Prag));\n+            Arg2 := Next (Arg1);\n+            Arg3 := Next (Arg2);\n \n-               --  For Inherit false, process only item for right type\n+            Arg1 := Get_Pragma_Arg (Arg1);\n+            Arg2 := Get_Pragma_Arg (Arg2);\n \n-               else\n-                  if Entity (Arg1) /= Typ then\n-                     goto Continue;\n-                  end if;\n-               end if;\n+            --  The caller requests processing of all Invariant'Class pragmas,\n+            --  but the current pragma does not fall in this category. Return\n+            --  as there is nothing left to do.\n \n-               if No (Stmts) then\n-                  Stmts := Empty_List;\n+            if Inherit then\n+               if not Class_Present (Prag) then\n+                  return;\n                end if;\n \n-               Exp := New_Copy_Tree (Arg2);\n+            --  Otherwise the pragma must apply to the current type\n \n-               --  Preserve sloc of original pragma Invariant\n+            elsif Entity (Arg1) /= T then\n+               return;\n+            end if;\n \n-               Loc := Sloc (Ritem);\n+            Expr := New_Copy_Tree (Arg2);\n \n-               --  We need to replace any occurrences of the name of the type\n-               --  with references to the object, converted to type'Class in\n-               --  the case of Invariant'Class aspects.\n+            --  Replace all occurrences of the type's name with references to\n+            --  the formal parameter of the invariant procedure.\n \n-               Replace_Type_References (Exp, T);\n+            Replace_Type_References (Expr, T);\n \n-               --  If this invariant comes from an aspect, find the aspect\n-               --  specification, and replace the saved expression because\n-               --  we need the subtype references replaced for the calls to\n-               --  Preanalyze_Spec_Expressin in Check_Aspect_At_Freeze_Point\n-               --  and Check_Aspect_At_End_Of_Declarations.\n+            --  If the invariant pragma comes from an aspect, replace the saved\n+            --  expression because we need the subtype references replaced for\n+            --  the calls to Preanalyze_Spec_Expression in Check_Aspect_At_xxx\n+            --  routines.\n \n-               if From_Aspect_Specification (Ritem) then\n-                  declare\n-                     Aitem : Node_Id;\n+            if Present (Asp) then\n+               Set_Entity (Identifier (Asp), New_Copy_Tree (Expr));\n+            end if;\n \n-                  begin\n-                     --  Loop to find corresponding aspect, note that this\n-                     --  must be present given the pragma is marked delayed.\n+            --  Preanalyze the invariant expression to capture the visibility\n+            --  of the proper package part. In general the expression is not\n+            --  fully analyzed until the body of the invariant procedure is\n+            --  analyzed at the end of the private part, but that yields the\n+            --  wrong visibility.\n \n-                     --  Note: in practice Next_Rep_Item (Ritem) is Empty so\n-                     --  this loop does nothing. Furthermore, why isn't this\n-                     --  simply Corresponding_Aspect ???\n+            --  Historic note: we used to set N as the parent, but a package\n+            --  specification as the parent of an expression is bizarre.\n \n-                     Aitem := Next_Rep_Item (Ritem);\n-                     while Present (Aitem) loop\n-                        if Nkind (Aitem) = N_Aspect_Specification\n-                          and then Aspect_Rep_Item (Aitem) = Ritem\n-                        then\n-                           Set_Entity\n-                             (Identifier (Aitem), New_Copy_Tree (Exp));\n-                           exit;\n-                        end if;\n+            Set_Parent (Expr, Parent (Arg2));\n+            Preanalyze_Assert_Expression (Expr, Any_Boolean);\n \n-                        Aitem := Next_Rep_Item (Aitem);\n-                     end loop;\n-                  end;\n-               end if;\n-\n-               --  Now we need to preanalyze the expression to properly capture\n-               --  the visibility in the visible part. The expression will not\n-               --  be analyzed for real until the body is analyzed, but that is\n-               --  at the end of the private part and has the wrong visibility.\n+            --  A class-wide invariant may be inherited in a separate unit,\n+            --  where the corresponding expression cannot be resolved by\n+            --  visibility, because it refers to a local function. Propagate\n+            --  semantic information to the original representation item, to\n+            --  be used when an invariant procedure for a derived type is\n+            --  constructed.\n \n-               Set_Parent (Exp, N);\n-               Preanalyze_Assert_Expression (Exp, Any_Boolean);\n+            --  ??? Unclear how to handle class-wide invariants that are not\n+            --  function calls.\n \n-               --  A class-wide invariant may be inherited in a separate unit,\n-               --  where the corresponding expression cannot be resolved by\n-               --  visibility, because it refers to a local function. Propagate\n-               --  semantic information to the original representation item, to\n-               --  be used when an invariant procedure for a derived type is\n-               --  constructed.\n+            if not Inherit\n+              and then Class_Present (Prag)\n+              and then Nkind (Expr) = N_Function_Call\n+              and then Nkind (Arg2) = N_Indexed_Component\n+            then\n+               Rewrite (Arg2,\n+                 Make_Function_Call (Ploc,\n+                   Name                   =>\n+                     New_Occurrence_Of (Entity (Name (Expr)), Ploc),\n+                   Parameter_Associations =>\n+                     New_Copy_List (Expressions (Arg2))));\n+            end if;\n \n-               --  Unclear how to handle class-wide invariants that are not\n-               --  function calls ???\n+            --  In ASIS mode, even if assertions are not enabled, we must\n+            --  analyze the original expression in the aspect specification\n+            --  because it is part of the original tree.\n \n-               if not Inherit\n-                 and then Class_Present (Ritem)\n-                 and then Nkind (Exp) = N_Function_Call\n-                 and then Nkind (Arg2) = N_Indexed_Component\n-               then\n-                  Rewrite (Arg2,\n-                    Make_Function_Call (Loc,\n-                      Name                   =>\n-                        New_Occurrence_Of (Entity (Name (Exp)), Loc),\n-                      Parameter_Associations =>\n-                        New_Copy_List (Expressions (Arg2))));\n-               end if;\n-\n-               --  In ASIS mode, even if assertions are not enabled, we must\n-               --  analyze the original expression in the aspect specification\n-               --  because it is part of the original tree.\n+            if ASIS_Mode and then Present (Asp) then\n+               declare\n+                  Orig_Expr : constant Node_Id := Expression (Asp);\n+               begin\n+                  Replace_Type_References (Orig_Expr, T);\n+                  Preanalyze_Assert_Expression (Orig_Expr, Any_Boolean);\n+               end;\n+            end if;\n \n-               if ASIS_Mode and then From_Aspect_Specification (Ritem) then\n-                  declare\n-                     Inv : constant Node_Id :=\n-                             Expression (Corresponding_Aspect (Ritem));\n-                  begin\n-                     Replace_Type_References (Inv, T);\n-                     Preanalyze_Assert_Expression (Inv, Standard_Boolean);\n-                  end;\n-               end if;\n+            --  An ignored invariant must not generate a runtime check. Add a\n+            --  null statement to ensure that the invariant procedure does get\n+            --  a completing body.\n \n-               --  Get name to be used for Check pragma. Using the original\n-               --  name ensures that 'Class case is properly handled.\n+            if No (Stmts) then\n+               Stmts := Empty_List;\n+            end if;\n \n-               Nam := Original_Aspect_Pragma_Name (Ritem);\n+            if Is_Ignored (Prag) then\n+               Append_To (Stmts, Make_Null_Statement (Ploc));\n \n-               --  Build first two arguments for Check pragma\n+            --  Otherwise the invariant is checked. Build a Check pragma to\n+            --  verify the expression at runtime.\n \n-               Assoc :=\n-                 New_List (\n-                   Make_Pragma_Argument_Association (Loc,\n-                     Expression => Make_Identifier (Loc, Chars => Nam)),\n-                   Make_Pragma_Argument_Association (Loc,\n-                     Expression => Exp));\n+            else\n+               Assoc := New_List (\n+                 Make_Pragma_Argument_Association (Ploc,\n+                   Expression => Make_Identifier (Ploc, Nam)),\n+                 Make_Pragma_Argument_Association (Ploc,\n+                   Expression => Expr));\n \n-               --  Add message if present in Invariant pragma\n+               --  Handle the String argument (if any)\n \n                if Present (Arg3) then\n                   Str := Strval (Get_Pragma_Arg (Arg3));\n \n-                  --  If inherited case, and message starts \"failed invariant\",\n-                  --  change it to be \"failed inherited invariant\".\n+                  --  When inheriting an invariant, modify the message from\n+                  --  \"failed invariant\" to \"failed inherited invariant\".\n \n                   if Inherit then\n                      String_To_Name_Buffer (Str);\n@@ -8087,30 +8092,45 @@ package body Sem_Ch13 is\n                   end if;\n \n                   Append_To (Assoc,\n-                    Make_Pragma_Argument_Association (Loc,\n-                      Expression => Make_String_Literal (Loc, Str)));\n+                    Make_Pragma_Argument_Association (Ploc,\n+                      Expression => Make_String_Literal (Ploc, Str)));\n                end if;\n \n-               --  Add Check pragma to list of statements\n+               --  Generate:\n+               --    pragma Check (Nam, Expr, Str);\n \n                Append_To (Stmts,\n-                 Make_Pragma (Loc,\n+                 Make_Pragma (Ploc,\n                    Pragma_Identifier            =>\n-                     Make_Identifier (Loc, Name_Check),\n+                     Make_Identifier (Ploc, Name_Check),\n                    Pragma_Argument_Associations => Assoc));\n+            end if;\n \n-               --  If Inherited case and option enabled, output info msg. Note\n-               --  that we know this is a case of Invariant'Class.\n+            --  Output an info message when inheriting an invariant and the\n+            --  listing option is enabled.\n \n-               if Inherit and Opt.List_Inherited_Aspects then\n-                  Error_Msg_Sloc := Sloc (Ritem);\n-                  Error_Msg_N\n-                    (\"info: & inherits `Invariant''Class` aspect from #?L?\",\n-                     Typ);\n-               end if;\n+            if Inherit and Opt.List_Inherited_Aspects then\n+               Error_Msg_Sloc := Sloc (Prag);\n+               Error_Msg_N\n+                 (\"info: & inherits `Invariant''Class` aspect from #?L?\", Typ);\n+            end if;\n+         end Add_Invariant;\n+\n+         --  Local variables\n+\n+         Ritem : Node_Id;\n+\n+      --  Start of processing for Add_Invariants\n+\n+      begin\n+         Ritem := First_Rep_Item (T);\n+         while Present (Ritem) loop\n+            if Nkind (Ritem) = N_Pragma\n+              and then Pragma_Name (Ritem) = Name_Invariant\n+            then\n+               Add_Invariant (Ritem);\n             end if;\n \n-         <<Continue>>\n             Next_Rep_Item (Ritem);\n          end loop;\n       end Add_Invariants;\n@@ -8228,13 +8248,13 @@ package body Sem_Ch13 is\n          --  If declaration is already analyzed, it was processed by the\n          --  generated pragma.\n \n-         if Present (Private_Decls) then\n+         if Present (Priv_Decls) then\n \n             --  The spec goes at the end of visible declarations, but they have\n             --  already been analyzed, so we need to explicitly do the analyze.\n \n             if not Analyzed (PDecl) then\n-               Append_To (Visible_Decls, PDecl);\n+               Append_To (Vis_Decls, PDecl);\n                Analyze (PDecl);\n             end if;\n \n@@ -8243,7 +8263,7 @@ package body Sem_Ch13 is\n             --  analyze call. We skip this if there are no private declarations\n             --  (this is an error that will be caught elsewhere);\n \n-            Append_To (Private_Decls, PBody);\n+            Append_To (Priv_Decls, PBody);\n \n             --  If the invariant appears on the full view of a type, the\n             --  analysis of the private part is complete, and we must\n@@ -8261,8 +8281,8 @@ package body Sem_Ch13 is\n          --  that the type is about to be frozen.\n \n          elsif not Is_Private_Type (Typ) then\n-            Append_To (Visible_Decls, PDecl);\n-            Append_To (Visible_Decls, PBody);\n+            Append_To (Vis_Decls, PDecl);\n+            Append_To (Vis_Decls, PBody);\n             Analyze (PDecl);\n             Analyze (PBody);\n          end if;\n@@ -8332,20 +8352,20 @@ package body Sem_Ch13 is\n       --  Inheritance of predicates for the parent type is done by calling the\n       --  Predicate_Function of the parent type, using Add_Call above.\n \n-      function Test_RE (N : Node_Id) return Traverse_Result;\n-      --  Used in Test_REs, tests one node for being a raise expression, and if\n-      --  so sets Raise_Expression_Present True.\n-\n-      procedure Test_REs is new Traverse_Proc (Test_RE);\n-      --  Tests to see if Expr contains any raise expressions\n-\n       function Process_RE (N : Node_Id) return Traverse_Result;\n       --  Used in Process REs, tests if node N is a raise expression, and if\n       --  so, marks it to be converted to return False.\n \n       procedure Process_REs is new Traverse_Proc (Process_RE);\n       --  Marks any raise expressions in Expr_M to return False\n \n+      function Test_RE (N : Node_Id) return Traverse_Result;\n+      --  Used in Test_REs, tests one node for being a raise expression, and if\n+      --  so sets Raise_Expression_Present True.\n+\n+      procedure Test_REs is new Traverse_Proc (Test_RE);\n+      --  Tests to see if Expr contains any raise expressions\n+\n       --------------\n       -- Add_Call --\n       --------------\n@@ -8399,128 +8419,121 @@ package body Sem_Ch13 is\n       --------------------\n \n       procedure Add_Predicates is\n-         Ritem : Node_Id;\n-         Arg1  : Node_Id;\n-         Arg2  : Node_Id;\n-\n-         procedure Replace_Type_Reference (N : Node_Id);\n-         --  Replace a single occurrence N of the subtype name with a reference\n-         --  to the formal of the predicate function. N can be an identifier\n-         --  referencing the subtype, or a selected component, representing an\n-         --  appropriately qualified occurrence of the subtype name.\n+         procedure Add_Predicate (Prag : Node_Id);\n+         --  Concatenate the expression of predicate pragma Prag to Expr by\n+         --  using a short circuit \"and then\" operator.\n \n-         procedure Replace_Type_References is\n-           new Replace_Type_References_Generic (Replace_Type_Reference);\n-         --  Traverse an expression changing every occurrence of an identifier\n-         --  whose name matches the name of the subtype with a reference to\n-         --  the formal parameter of the predicate function.\n+         -------------------\n+         -- Add_Predicate --\n+         -------------------\n \n-         ----------------------------\n-         -- Replace_Type_Reference --\n-         ----------------------------\n+         procedure Add_Predicate (Prag : Node_Id) is\n+            procedure Replace_Type_Reference (N : Node_Id);\n+            --  Replace a single occurrence N of the subtype name with a\n+            --  reference to the formal of the predicate function. N can be an\n+            --  identifier referencing the subtype, or a selected component,\n+            --  representing an appropriately qualified occurrence of the\n+            --  subtype name.\n+\n+            procedure Replace_Type_References is\n+              new Replace_Type_References_Generic (Replace_Type_Reference);\n+            --  Traverse an expression changing every occurrence of an\n+            --  identifier whose name matches the name of the subtype with a\n+            --  reference to the formal parameter of the predicate function.\n+\n+            ----------------------------\n+            -- Replace_Type_Reference --\n+            ----------------------------\n+\n+            procedure Replace_Type_Reference (N : Node_Id) is\n+            begin\n+               Rewrite (N, Make_Identifier (Sloc (N), Object_Name));\n+               --  Use the Sloc of the usage name, not the defining name\n \n-         procedure Replace_Type_Reference (N : Node_Id) is\n-         begin\n-            Rewrite (N, Make_Identifier (Sloc (N), Object_Name));\n-            --  Use the Sloc of the usage name, not the defining name\n+               Set_Etype (N, Typ);\n+               Set_Entity (N, Object_Entity);\n \n-            Set_Etype (N, Typ);\n-            Set_Entity (N, Object_Entity);\n+               --  We want to treat the node as if it comes from source, so\n+               --  that ASIS will not ignore it.\n \n-            --  We want to treat the node as if it comes from source, so that\n-            --  ASIS will not ignore it\n+               Set_Comes_From_Source (N, True);\n+            end Replace_Type_Reference;\n \n-            Set_Comes_From_Source (N, True);\n-         end Replace_Type_Reference;\n+            --  Local variables\n \n-      --  Start of processing for Add_Predicates\n+            Asp  : constant Node_Id := Corresponding_Aspect (Prag);\n+            Arg1 : Node_Id;\n+            Arg2 : Node_Id;\n \n-      begin\n-         Ritem := First_Rep_Item (Typ);\n+         --  Start of processing for Add_Predicate\n \n-         while Present (Ritem) loop\n-            if Nkind (Ritem) = N_Pragma\n-              and then Pragma_Name (Ritem) = Name_Predicate\n-            then\n-               --  Acquire arguments. The expression itself is copied for use\n-               --  in the predicate function, to preserve the original version\n-               --  for ASIS use.\n-\n-               Arg1 := First (Pragma_Argument_Associations (Ritem));\n-               Arg2 := Next (Arg1);\n+         begin\n+            --  Extract the arguments of the pragma. The expression itself\n+            --  is copied for use in the predicate function, to preserve the\n+            --  original version for ASIS use.\n \n-               Arg1 := Get_Pragma_Arg (Arg1);\n-               Arg2 := New_Copy_Tree (Get_Pragma_Arg (Arg2));\n+            Arg1 := First (Pragma_Argument_Associations (Prag));\n+            Arg2 := Next (Arg1);\n \n-               --  See if this predicate pragma is for the current type or for\n-               --  its full view. A predicate on a private completion is placed\n-               --  on the partial view beause this is the visible entity that\n-               --  is frozen.\n+            Arg1 := Get_Pragma_Arg (Arg1);\n+            Arg2 := New_Copy_Tree (Get_Pragma_Arg (Arg2));\n \n-               if Entity (Arg1) = Typ\n-                 or else Full_View (Entity (Arg1)) = Typ\n-               then\n-                  --  We have a match, this entry is for our subtype\n+            --  When the predicate pragma applies to the current type or its\n+            --  full view, replace all occurrences of the subtype name with\n+            --  references to the formal parameter of the predicate function.\n \n-                  --  We need to replace any occurrences of the name of the\n-                  --  type with references to the object.\n+            if Entity (Arg1) = Typ\n+              or else Full_View (Entity (Arg1)) = Typ\n+            then\n+               Replace_Type_References (Arg2, Typ);\n \n-                  Replace_Type_References (Arg2, Typ);\n+               --  If the predicate pragma comes from an aspect, replace the\n+               --  saved expression because we need the subtype references\n+               --  replaced for the calls to Preanalyze_Spec_Expression in\n+               --  Check_Aspect_At_xxx routines.\n \n-                  --  If this predicate comes from an aspect, find the aspect\n-                  --  specification, and replace the saved expression because\n-                  --  we need the subtype references replaced for the calls to\n-                  --  Preanalyze_Spec_Expressin in Check_Aspect_At_Freeze_Point\n-                  --  and Check_Aspect_At_End_Of_Declarations.\n+               if Present (Asp) then\n \n-                  if From_Aspect_Specification (Ritem) then\n-                     declare\n-                        Aitem     : Node_Id;\n-                        Orig_Expr : constant Node_Id :=\n-                           Expression (Corresponding_Aspect (Ritem));\n+                  --  For ASIS use, perform semantic analysis of the original\n+                  --  predicate expression, which is otherwise not utilized.\n \n-                     begin\n+                  if ASIS_Mode then\n+                     Preanalyze_And_Resolve (Expression (Asp));\n+                  end if;\n \n-                        --  For ASIS use, perform semantic analysis of the\n-                        --  original predicate expression, which is otherwise\n-                        --  not utilized.\n+                  Set_Entity (Identifier (Asp), New_Copy_Tree (Arg2));\n+               end if;\n \n-                        if ASIS_Mode then\n-                           Preanalyze_And_Resolve (Orig_Expr);\n-                        end if;\n+               --  Concatenate to the existing predicate expressions by using\n+               --  \"and then\".\n \n-                        --  Loop to find corresponding aspect, note that this\n-                        --  must be present given the pragma is marked delayed.\n+               if Present (Expr) then\n+                  Expr :=\n+                    Make_And_Then (Loc,\n+                      Left_Opnd  => Relocate_Node (Expr),\n+                      Right_Opnd => Relocate_Node (Arg2));\n \n-                        Aitem := Next_Rep_Item (Ritem);\n-                        loop\n-                           if Nkind (Aitem) = N_Aspect_Specification\n-                             and then Aspect_Rep_Item (Aitem) = Ritem\n-                           then\n-                              Set_Entity\n-                                (Identifier (Aitem), New_Copy_Tree (Arg2));\n-                              exit;\n-                           end if;\n+               --  Otherwise this is the first predicate expression\n \n-                           Aitem := Next_Rep_Item (Aitem);\n-                        end loop;\n-                     end;\n-                  end if;\n+               else\n+                  Expr := Relocate_Node (Arg2);\n+               end if;\n+            end if;\n+         end Add_Predicate;\n \n-                  --  Now we can add the expression\n+         --  Local variables\n \n-                  if No (Expr) then\n-                     Expr := Relocate_Node (Arg2);\n+         Ritem : Node_Id;\n \n-                  --  There already was a predicate, so add to it\n+      --  Start of processing for Add_Predicates\n \n-                  else\n-                     Expr :=\n-                       Make_And_Then (Loc,\n-                         Left_Opnd  => Relocate_Node (Expr),\n-                         Right_Opnd => Relocate_Node (Arg2));\n-                  end if;\n-               end if;\n+      begin\n+         Ritem := First_Rep_Item (Typ);\n+         while Present (Ritem) loop\n+            if Nkind (Ritem) = N_Pragma\n+              and then Pragma_Name (Ritem) = Name_Predicate\n+            then\n+               Add_Predicate (Ritem);\n             end if;\n \n             Next_Rep_Item (Ritem);\n@@ -8555,6 +8568,10 @@ package body Sem_Ch13 is\n          end if;\n       end Test_RE;\n \n+      --  Local variables\n+\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n    --  Start of processing for Build_Predicate_Functions\n \n    begin\n@@ -8566,6 +8583,12 @@ package body Sem_Ch13 is\n          return;\n       end if;\n \n+      --  The related type may be subject to pragma Ghost with policy Ignore.\n+      --  Set the mode now to ensure that the predicate functions are properly\n+      --  flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode_From_Entity (Typ);\n+\n       --  Prepare to construct predicate expression\n \n       Expr := Empty;\n@@ -8670,6 +8693,13 @@ package body Sem_Ch13 is\n                Set_Predicate_Function (Full_View (Typ), SId);\n             end if;\n \n+            --  Mark the predicate function explicitly as Ghost because it does\n+            --  not come from source.\n+\n+            if Ghost_Mode > None then\n+               Set_Is_Ghost_Entity (SId);\n+            end if;\n+\n             Spec :=\n               Make_Function_Specification (Loc,\n                 Defining_Unit_Name       => SId,\n@@ -8750,6 +8780,13 @@ package body Sem_Ch13 is\n                   Set_Predicate_Function_M (Full_View (Typ), SId);\n                end if;\n \n+               --  Mark the predicate function explicitly as Ghost because it\n+               --  does not come from source.\n+\n+               if Ghost_Mode > None then\n+                  Set_Is_Ghost_Entity (SId);\n+               end if;\n+\n                Spec :=\n                  Make_Function_Specification (Loc,\n                    Defining_Unit_Name       => SId,\n@@ -8896,6 +8933,11 @@ package body Sem_Ch13 is\n             end if;\n          end;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Build_Predicate_Functions;\n \n    -----------------------------------------"}, {"sha": "fa84de419c13327fc6ca071b6119277852e79767", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 98, "deletions": 17, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -2558,6 +2558,7 @@ package body Sem_Ch3 is\n    procedure Analyze_Full_Type_Declaration (N : Node_Id) is\n       Def    : constant Node_Id   := Type_Definition (N);\n       Def_Id : constant Entity_Id := Defining_Identifier (N);\n+      GM     : constant Ghost_Mode_Type := Ghost_Mode;\n       T      : Entity_Id;\n       Prev   : Entity_Id;\n \n@@ -2575,6 +2576,9 @@ package body Sem_Ch3 is\n       --  list later in Sem_Disp.Check_Operation_From_Incomplete_Type (which\n       --  is called from Process_Incomplete_Dependents).\n \n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n       ------------------------------------\n       -- Check_Ops_From_Incomplete_Type --\n       ------------------------------------\n@@ -2612,6 +2616,15 @@ package body Sem_Ch3 is\n          end if;\n       end Check_Ops_From_Incomplete_Type;\n \n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n    --  Start of processing for Analyze_Full_Type_Declaration\n \n    begin\n@@ -2760,6 +2773,7 @@ package body Sem_Ch3 is\n       end if;\n \n       if Etype (T) = Any_Type then\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -2772,7 +2786,7 @@ package body Sem_Ch3 is\n       --  A type declared within a Ghost region is automatically Ghost\n       --  (SPARK RM 6.9(2)).\n \n-      if Comes_From_Source (T) and then Ghost_Mode > None then\n+      if Ghost_Mode > None then\n          Set_Is_Ghost_Entity (T);\n       end if;\n \n@@ -2900,19 +2914,27 @@ package body Sem_Ch3 is\n             Analyze_Aspect_Specifications (N, Def_Id);\n          end if;\n       end if;\n+\n+      Restore_Globals;\n    end Analyze_Full_Type_Declaration;\n \n    ----------------------------------\n    -- Analyze_Incomplete_Type_Decl --\n    ----------------------------------\n \n    procedure Analyze_Incomplete_Type_Decl (N : Node_Id) is\n-      F : constant Boolean := Is_Pure (Current_Scope);\n-      T : Entity_Id;\n+      F  : constant Boolean := Is_Pure (Current_Scope);\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+      T  : Entity_Id;\n \n    begin\n       Check_SPARK_05_Restriction (\"incomplete type is not allowed\", N);\n \n+      --  The incomplete type declaration may be subject to pragma Ghost with\n+      --  policy Ignore. Set the mode now to ensure that any nodes generated\n+      --  during analysis and expansion are properly flagged as ignored Ghost.\n+\n+      Set_Ghost_Mode (N);\n       Generate_Definition (Defining_Identifier (N));\n \n       --  Process an incomplete declaration. The identifier must not have been\n@@ -2962,6 +2984,11 @@ package body Sem_Ch3 is\n \n       Set_Private_Dependents (T, New_Elmt_List);\n       Set_Is_Pure            (T, F);\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Incomplete_Type_Decl;\n \n    -----------------------------------\n@@ -3036,11 +3063,29 @@ package body Sem_Ch3 is\n    --------------------------------\n \n    procedure Analyze_Number_Declaration (N : Node_Id) is\n-      Id    : constant Entity_Id := Defining_Identifier (N);\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n+      --  Local variables\n+\n       E     : constant Node_Id   := Expression (N);\n-      T     : Entity_Id;\n+      Id    : constant Entity_Id := Defining_Identifier (N);\n       Index : Interp_Index;\n       It    : Interp;\n+      T     : Entity_Id;\n+\n+   --  Start of processing for Analyze_Number_Declaration\n \n    begin\n       --  The number declaration may be subject to pragma Ghost with policy\n@@ -3068,6 +3113,8 @@ package body Sem_Ch3 is\n          Set_Etype     (Id, Universal_Integer);\n          Set_Ekind     (Id, E_Named_Integer);\n          Set_Is_Frozen (Id, True);\n+\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -3169,6 +3216,8 @@ package body Sem_Ch3 is\n          Set_Ekind               (Id, E_Constant);\n          Set_Never_Set_In_Source (Id, True);\n          Set_Is_True_Constant    (Id, True);\n+\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -3182,6 +3231,8 @@ package body Sem_Ch3 is\n          Rewrite (E, Make_Integer_Literal (Sloc (N), 1));\n          Set_Etype (E, Any_Type);\n       end if;\n+\n+      Restore_Globals;\n    end Analyze_Number_Declaration;\n \n    -----------------------------\n@@ -3355,10 +3406,11 @@ package body Sem_Ch3 is\n    --------------------------------\n \n    procedure Analyze_Object_Declaration (N : Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (N);\n+      GM    : constant Ghost_Mode_Type := Ghost_Mode;\n       Id    : constant Entity_Id  := Defining_Identifier (N);\n-      T     : Entity_Id;\n+      Loc   : constant Source_Ptr := Sloc (N);\n       Act_T : Entity_Id;\n+      T     : Entity_Id;\n \n       E : Node_Id := Expression (N);\n       --  E is set to Expression (N) throughout this routine. When\n@@ -3385,6 +3437,9 @@ package body Sem_Ch3 is\n \n       --  Any other relevant delayed aspects on object declarations ???\n \n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n       -----------------\n       -- Count_Tasks --\n       -----------------\n@@ -3463,6 +3518,15 @@ package body Sem_Ch3 is\n          return False;\n       end Delayed_Aspect_Present;\n \n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n    --  Start of processing for Analyze_Object_Declaration\n \n    begin\n@@ -3802,6 +3866,7 @@ package body Sem_Ch3 is\n            and then Analyzed (N)\n            and then No (Expression (N))\n          then\n+            Restore_Globals;\n             return;\n          end if;\n \n@@ -4073,6 +4138,8 @@ package body Sem_Ch3 is\n                Set_Renamed_Object (Id, E);\n                Freeze_Before (N, T);\n                Set_Is_Frozen (Id);\n+\n+               Restore_Globals;\n                return;\n \n             else\n@@ -4419,7 +4486,8 @@ package body Sem_Ch3 is\n \n       --  Deal with setting In_Private_Part flag if in private part\n \n-      if Ekind (Scope (Id)) = E_Package and then In_Private_Part (Scope (Id))\n+      if Ekind (Scope (Id)) = E_Package\n+        and then In_Private_Part (Scope (Id))\n       then\n          Set_In_Private_Part (Id);\n       end if;\n@@ -4453,6 +4521,8 @@ package body Sem_Ch3 is\n       if Ekind (Id) = E_Variable then\n          Check_No_Hidden_State (Id);\n       end if;\n+\n+      Restore_Globals;\n    end Analyze_Object_Declaration;\n \n    ---------------------------\n@@ -4473,10 +4543,11 @@ package body Sem_Ch3 is\n    -------------------------------------------\n \n    procedure Analyze_Private_Extension_Declaration (N : Node_Id) is\n-      T           : constant Entity_Id := Defining_Identifier (N);\n+      GM          : constant Ghost_Mode_Type := Ghost_Mode;\n       Indic       : constant Node_Id   := Subtype_Indication (N);\n-      Parent_Type : Entity_Id;\n+      T           : constant Entity_Id := Defining_Identifier (N);\n       Parent_Base : Entity_Id;\n+      Parent_Type : Entity_Id;\n \n    begin\n       --  The private extension declaration may be subject to pragma Ghost with\n@@ -4698,6 +4769,11 @@ package body Sem_Ch3 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, T);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Private_Extension_Declaration;\n \n    ---------------------------------\n@@ -4708,9 +4784,10 @@ package body Sem_Ch3 is\n      (N    : Node_Id;\n       Skip : Boolean := False)\n    is\n+      GM       : constant Ghost_Mode_Type := Ghost_Mode;\n       Id       : constant Entity_Id := Defining_Identifier (N);\n-      T        : Entity_Id;\n       R_Checks : Check_Result;\n+      T        : Entity_Id;\n \n    begin\n       --  The subtype declaration may be subject to pragma Ghost with policy\n@@ -5316,6 +5393,11 @@ package body Sem_Ch3 is\n       end if;\n \n       Analyze_Dimension (N);\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Subtype_Declaration;\n \n    --------------------------------\n@@ -10809,7 +10891,6 @@ package body Sem_Ch3 is\n       ----------------\n \n       procedure Post_Error is\n-\n          procedure Missing_Body;\n          --  Output missing body message\n \n@@ -10835,7 +10916,6 @@ package body Sem_Ch3 is\n \n       begin\n          if not Comes_From_Source (E) then\n-\n             if Ekind_In (E, E_Task_Type, E_Protected_Type) then\n \n                --  It may be an anonymous protected type created for a\n@@ -19963,11 +20043,7 @@ package body Sem_Ch3 is\n             Private_To_Full_View => True);\n       end if;\n \n-      --  Propagate the attributes related to pragma Ghost from the private to\n-      --  the full view.\n-\n       if Is_Ghost_Entity (Priv_T) then\n-         Set_Is_Ghost_Entity (Full_T);\n \n          --  The Ghost policy in effect at the point of declaration and at the\n          --  point of completion must match (SPARK RM 6.9(14)).\n@@ -19981,6 +20057,11 @@ package body Sem_Ch3 is\n          if Is_Derived_Type (Full_T) then\n             Check_Ghost_Derivation (Full_T);\n          end if;\n+\n+         --  Propagate the attributes related to pragma Ghost from the private\n+         --  to the full view.\n+\n+         Mark_Full_View_As_Ghost (Priv_T, Full_T);\n       end if;\n \n       --  Propagate invariants to full type"}, {"sha": "162e6db03a8a142faa3be686edd568fb9848c7d3", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -90,6 +90,7 @@ package body Sem_Ch5 is\n    ------------------------\n \n    procedure Analyze_Assignment (N : Node_Id) is\n+      GM   : constant Ghost_Mode_Type := Ghost_Mode;\n       Lhs  : constant Node_Id := Name (N);\n       Rhs  : constant Node_Id := Expression (N);\n       T1   : Entity_Id;\n@@ -106,6 +107,9 @@ package body Sem_Ch5 is\n       --  the assignment, and at the end of processing before setting any new\n       --  current values in place.\n \n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n       procedure Set_Assignment_Type\n         (Opnd      : Node_Id;\n          Opnd_Type : in out Entity_Id);\n@@ -211,6 +215,15 @@ package body Sem_Ch5 is\n          end if;\n       end Kill_Lhs;\n \n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n       -------------------------\n       -- Set_Assignment_Type --\n       -------------------------\n@@ -378,6 +391,7 @@ package body Sem_Ch5 is\n             Error_Msg_N\n               (\"no valid types for left-hand side for assignment\", Lhs);\n             Kill_Lhs;\n+            Restore_Globals;\n             return;\n          end if;\n       end if;\n@@ -453,12 +467,14 @@ package body Sem_Ch5 is\n                                   \"specified??\", Lhs);\n                   end if;\n \n+                  Restore_Globals;\n                   return;\n                end if;\n             end if;\n          end;\n \n          Diagnose_Non_Variable_Lhs (Lhs);\n+         Restore_Globals;\n          return;\n \n       --  Error of assigning to limited type. We do however allow this in\n@@ -478,6 +494,8 @@ package body Sem_Ch5 is\n               (\"left hand of assignment must not be limited type\", Lhs);\n             Explain_Limited_Type (T1, Lhs);\n          end if;\n+\n+         Restore_Globals;\n          return;\n \n       --  Enforce RM 3.9.3 (8): the target of an assignment operation cannot be\n@@ -516,6 +534,7 @@ package body Sem_Ch5 is\n       then\n          Error_Msg_N (\"invalid use of incomplete type\", Lhs);\n          Kill_Lhs;\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -533,6 +552,7 @@ package body Sem_Ch5 is\n \n       if Rhs = Error then\n          Kill_Lhs;\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -541,6 +561,7 @@ package body Sem_Ch5 is\n       if not Covers (T1, T2) then\n          Wrong_Type (Rhs, Etype (Lhs));\n          Kill_Lhs;\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -568,6 +589,7 @@ package body Sem_Ch5 is\n \n       if T1 = Any_Type or else T2 = Any_Type then\n          Kill_Lhs;\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -660,6 +682,7 @@ package body Sem_Ch5 is\n             --  to reset Is_True_Constant, and desirable for xref purposes.\n \n             Note_Possible_Modification (Lhs, Sure => True);\n+            Restore_Globals;\n             return;\n \n          --  If we know the right hand side is non-null, then we convert to the\n@@ -866,6 +889,7 @@ package body Sem_Ch5 is\n       end;\n \n       Analyze_Dimension (N);\n+      Restore_Globals;\n    end Analyze_Assignment;\n \n    -----------------------------"}, {"sha": "07579f0fcb0f28dcde4f15163b510bc013489b22", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 118, "deletions": 28, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -209,9 +209,10 @@ package body Sem_Ch6 is\n    ---------------------------------------------\n \n    procedure Analyze_Abstract_Subprogram_Declaration (N : Node_Id) is\n-      Designator : constant Entity_Id :=\n-                     Analyze_Subprogram_Specification (Specification (N));\n-      Scop       : constant Entity_Id := Current_Scope;\n+      GM      : constant Ghost_Mode_Type := Ghost_Mode;\n+      Scop    : constant Entity_Id := Current_Scope;\n+      Subp_Id : constant Entity_Id :=\n+                  Analyze_Subprogram_Specification (Specification (N));\n \n    begin\n       --  The abstract subprogram declaration may be subject to pragma Ghost\n@@ -222,45 +223,49 @@ package body Sem_Ch6 is\n       Set_Ghost_Mode (N);\n       Check_SPARK_05_Restriction (\"abstract subprogram is not allowed\", N);\n \n-      Generate_Definition (Designator);\n+      Generate_Definition (Subp_Id);\n \n-      Set_Is_Abstract_Subprogram (Designator);\n-      New_Overloaded_Entity (Designator);\n-      Check_Delayed_Subprogram (Designator);\n+      Set_Is_Abstract_Subprogram (Subp_Id);\n+      New_Overloaded_Entity (Subp_Id);\n+      Check_Delayed_Subprogram (Subp_Id);\n \n-      Set_Categorization_From_Scope (Designator, Scop);\n+      Set_Categorization_From_Scope (Subp_Id, Scop);\n \n       --  An abstract subprogram declared within a Ghost region is rendered\n       --  Ghost (SPARK RM 6.9(2)).\n \n-      if Comes_From_Source (Designator) and then Ghost_Mode > None then\n-         Set_Is_Ghost_Entity (Designator);\n+      if Ghost_Mode > None then\n+         Set_Is_Ghost_Entity (Subp_Id);\n       end if;\n \n-      if Ekind (Scope (Designator)) = E_Protected_Type then\n-         Error_Msg_N\n-           (\"abstract subprogram not allowed in protected type\", N);\n+      if Ekind (Scope (Subp_Id)) = E_Protected_Type then\n+         Error_Msg_N (\"abstract subprogram not allowed in protected type\", N);\n \n       --  Issue a warning if the abstract subprogram is neither a dispatching\n       --  operation nor an operation that overrides an inherited subprogram or\n       --  predefined operator, since this most likely indicates a mistake.\n \n       elsif Warn_On_Redundant_Constructs\n-        and then not Is_Dispatching_Operation (Designator)\n-        and then not Present (Overridden_Operation (Designator))\n-        and then (not Is_Operator_Symbol_Name (Chars (Designator))\n-                   or else Scop /= Scope (Etype (First_Formal (Designator))))\n+        and then not Is_Dispatching_Operation (Subp_Id)\n+        and then not Present (Overridden_Operation (Subp_Id))\n+        and then (not Is_Operator_Symbol_Name (Chars (Subp_Id))\n+                   or else Scop /= Scope (Etype (First_Formal (Subp_Id))))\n       then\n          Error_Msg_N\n            (\"abstract subprogram is not dispatching or overriding?r?\", N);\n       end if;\n \n-      Generate_Reference_To_Formals (Designator);\n-      Check_Eliminated (Designator);\n+      Generate_Reference_To_Formals (Subp_Id);\n+      Check_Eliminated (Subp_Id);\n \n       if Has_Aspects (N) then\n-         Analyze_Aspect_Specifications (N, Designator);\n+         Analyze_Aspect_Specifications (N, Subp_Id);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Abstract_Subprogram_Declaration;\n \n    ---------------------------------\n@@ -1542,16 +1547,15 @@ package body Sem_Ch6 is\n    ----------------------------\n \n    procedure Analyze_Procedure_Call (N : Node_Id) is\n-      Loc     : constant Source_Ptr := Sloc (N);\n-      P       : constant Node_Id    := Name (N);\n-      Actuals : constant List_Id    := Parameter_Associations (N);\n-      Actual  : Node_Id;\n-      New_N   : Node_Id;\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n \n       procedure Analyze_Call_And_Resolve;\n       --  Do Analyze and Resolve calls for procedure call\n       --  At end, check illegal order dependence.\n \n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n       ------------------------------\n       -- Analyze_Call_And_Resolve --\n       ------------------------------\n@@ -1566,6 +1570,23 @@ package body Sem_Ch6 is\n          end if;\n       end Analyze_Call_And_Resolve;\n \n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n+      --  Local variables\n+\n+      Actuals : constant List_Id    := Parameter_Associations (N);\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      P       : constant Node_Id    := Name (N);\n+      Actual  : Node_Id;\n+      New_N   : Node_Id;\n+\n    --  Start of processing for Analyze_Procedure_Call\n \n    begin\n@@ -1636,6 +1657,7 @@ package body Sem_Ch6 is\n         and then Is_Record_Type (Etype (Entity (P)))\n         and then Remote_AST_I_Dereference (P)\n       then\n+         Restore_Globals;\n          return;\n \n       elsif Is_Entity_Name (P)\n@@ -1771,6 +1793,8 @@ package body Sem_Ch6 is\n       else\n          Error_Msg_N (\"invalid procedure or entry call\", N);\n       end if;\n+\n+      Restore_Globals;\n    end Analyze_Procedure_Call;\n \n    ------------------------------\n@@ -2251,6 +2275,7 @@ package body Sem_Ch6 is\n    --  the subprogram, or to perform conformance checks.\n \n    procedure Analyze_Subprogram_Body_Helper (N : Node_Id) is\n+      GM           : constant Ghost_Mode_Type := Ghost_Mode;\n       Loc          : constant Source_Ptr := Sloc (N);\n       Body_Spec    : Node_Id             := Specification (N);\n       Body_Id      : Entity_Id           := Defining_Entity (Body_Spec);\n@@ -2326,6 +2351,9 @@ package body Sem_Ch6 is\n       --  Determine whether subprogram Subp_Id is a primitive of a concurrent\n       --  type that implements an interface and has a private view.\n \n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n       procedure Set_Trivial_Subprogram (N : Node_Id);\n       --  Sets the Is_Trivial_Subprogram flag in both spec and body of the\n       --  subprogram whose body is being analyzed. N is the statement node\n@@ -2902,6 +2930,15 @@ package body Sem_Ch6 is\n          return False;\n       end Is_Private_Concurrent_Primitive;\n \n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n       ----------------------------\n       -- Set_Trivial_Subprogram --\n       ----------------------------\n@@ -3044,13 +3081,15 @@ package body Sem_Ch6 is\n                Check_Missing_Return;\n             end if;\n \n+            Restore_Globals;\n             return;\n \n          else\n             --  Previous entity conflicts with subprogram name. Attempting to\n             --  enter name will post error.\n \n             Enter_Name (Body_Id);\n+            Restore_Globals;\n             return;\n          end if;\n \n@@ -3061,6 +3100,7 @@ package body Sem_Ch6 is\n       --  analysis.\n \n       elsif Prev_Id = Body_Id and then Has_Completion (Body_Id) then\n+         Restore_Globals;\n          return;\n \n       else\n@@ -3139,6 +3179,7 @@ package body Sem_Ch6 is\n             --  If this is a duplicate body, no point in analyzing it\n \n             if Error_Posted (N) then\n+               Restore_Globals;\n                return;\n             end if;\n \n@@ -3251,6 +3292,7 @@ package body Sem_Ch6 is\n \n          if Is_Abstract_Subprogram (Spec_Id) then\n             Error_Msg_N (\"an abstract subprogram cannot have a body\", N);\n+            Restore_Globals;\n             return;\n \n          else\n@@ -3320,6 +3362,7 @@ package body Sem_Ch6 is\n             if not Conformant\n               and then not Mode_Conformant (Body_Id, Spec_Id)\n             then\n+               Restore_Globals;\n                return;\n             end if;\n          end if;\n@@ -3526,6 +3569,7 @@ package body Sem_Ch6 is\n             Analyze_Aspect_Specifications_On_Body_Or_Stub (N);\n          end if;\n \n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -3989,6 +4033,8 @@ package body Sem_Ch6 is\n             Set_Has_Nested_Subprogram (Ent);\n          end if;\n       end;\n+\n+      Restore_Globals;\n    end Analyze_Subprogram_Body_Helper;\n \n    ---------------------------------\n@@ -4093,12 +4139,30 @@ package body Sem_Ch6 is\n    ------------------------------------\n \n    procedure Analyze_Subprogram_Declaration (N : Node_Id) is\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n+      --  Local variables\n+\n       Scop       : constant Entity_Id := Current_Scope;\n       Designator : Entity_Id;\n \n       Is_Completion : Boolean;\n       --  Indicates whether a null procedure declaration is a completion\n \n+   --  Start of processing for Analyze_Subprogram_Declaration\n+\n    begin\n       --  The subprogram declaration may be subject to pragma Ghost with policy\n       --  Ignore. Set the mode now to ensure that any nodes generated during\n@@ -4124,10 +4188,10 @@ package body Sem_Ch6 is\n \n          Analyze_Null_Procedure (N, Is_Completion);\n \n-         if Is_Completion then\n-\n-            --  The null procedure acts as a body, nothing further is needed\n+         --  The null procedure acts as a body, nothing further is needed\n \n+         if Is_Completion then\n+            Restore_Globals;\n             return;\n          end if;\n       end if;\n@@ -4308,6 +4372,8 @@ package body Sem_Ch6 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Designator);\n       end if;\n+\n+      Restore_Globals;\n    end Analyze_Subprogram_Declaration;\n \n    --------------------------------------\n@@ -9374,6 +9440,12 @@ package body Sem_Ch6 is\n \n             Check_Overriding_Indicator\n               (S, Overridden_Subp, Is_Primitive => Is_Primitive_Subp);\n+\n+            --  The Ghost policy in effect at the point of declaration of a\n+            --  parent subprogram and an overriding subprogram must match\n+            --  (SPARK RM 6.9(17)).\n+\n+            Check_Ghost_Overriding (S, Overridden_Subp);\n          end if;\n \n       --  If there is a homonym that is not overloadable, then we have an\n@@ -9526,6 +9598,12 @@ package body Sem_Ch6 is\n \n                   if Comes_From_Source (E) then\n                      Check_Overriding_Indicator (E, S, Is_Primitive => False);\n+\n+                     --  The Ghost policy in effect at the point of declaration\n+                     --  of a parent subprogram and an overriding subprogram\n+                     --  must match (SPARK RM 6.9(17)).\n+\n+                     Check_Ghost_Overriding (E, S);\n                   end if;\n \n                   return;\n@@ -9721,6 +9799,12 @@ package body Sem_Ch6 is\n \n                      Check_Overriding_Indicator (S, E, Is_Primitive => True);\n \n+                     --  The Ghost policy in effect at the point of declaration\n+                     --  of a parent subprogram and an overriding subprogram\n+                     --  must match (SPARK RM 6.9(17)).\n+\n+                     Check_Ghost_Overriding (S, E);\n+\n                      --  If S is a user-defined subprogram or a null procedure\n                      --  expanded to override an inherited null procedure, or a\n                      --  predefined dispatching primitive then indicate that E\n@@ -9857,6 +9941,12 @@ package body Sem_Ch6 is\n          Check_Overriding_Indicator\n            (S, Overridden_Subp, Is_Primitive => Is_Primitive_Subp);\n \n+         --  The Ghost policy in effect at the point of declaration of a parent\n+         --  subprogram and an overriding subprogram must match\n+         --  (SPARK RM 6.9(17)).\n+\n+         Check_Ghost_Overriding (S, Overridden_Subp);\n+\n          --  Overloading is not allowed in SPARK, except for operators\n \n          if Nkind (S) /= N_Defining_Operator_Symbol then"}, {"sha": "f39da2c0066b2a2808cdfa9709245919ed7fe7eb", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -571,6 +571,7 @@ package body Sem_Ch7 is\n \n       --  Local variables\n \n+      GM               : constant Ghost_Mode_Type := Ghost_Mode;\n       Body_Id          : Entity_Id;\n       HSS              : Node_Id;\n       Last_Spec_Entity : Entity_Id;\n@@ -940,6 +941,11 @@ package body Sem_Ch7 is\n             Qualify_Entity_Names (N);\n          end if;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Package_Body_Helper;\n \n    ------------------------------\n@@ -1015,17 +1021,35 @@ package body Sem_Ch7 is\n    ---------------------------------\n \n    procedure Analyze_Package_Declaration (N : Node_Id) is\n-      Id : constant Node_Id := Defining_Entity (N);\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n \n-      PF : Boolean;\n-      --  True when in the context of a declared pure library unit\n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n+      --  Local variables\n+\n+      Id : constant Node_Id := Defining_Entity (N);\n \n       Body_Required : Boolean;\n       --  True when this package declaration requires a corresponding body\n \n       Comp_Unit : Boolean;\n       --  True when this package declaration is not a nested declaration\n \n+      PF : Boolean;\n+      --  True when in the context of a declared pure library unit\n+\n+   --  Start of processing for Analyze_Package_Declaration\n+\n    begin\n       if Debug_Flag_C then\n          Write_Str (\"==> package spec \");\n@@ -1056,6 +1080,13 @@ package body Sem_Ch7 is\n          Set_SPARK_Aux_Pragma_Inherited (Id, True);\n       end if;\n \n+      --  A package declared within a Ghost refion is automatically Ghost\n+      --  (SPARK RM 6.9(2)).\n+\n+      if Ghost_Mode > None then\n+         Set_Is_Ghost_Entity (Id);\n+      end if;\n+\n       --  Analyze aspect specifications immediately, since we need to recognize\n       --  things like Pure early enough to diagnose violations during analysis.\n \n@@ -1071,6 +1102,7 @@ package body Sem_Ch7 is\n       --     package Pkg is ...\n \n       if From_Limited_With (Id) then\n+         Restore_Globals;\n          return;\n       end if;\n \n@@ -1098,6 +1130,7 @@ package body Sem_Ch7 is\n       end if;\n \n       Comp_Unit := Nkind (Parent (N)) = N_Compilation_Unit;\n+\n       if Comp_Unit then\n \n          --  Set Body_Required indication on the compilation unit node, and\n@@ -1108,7 +1141,6 @@ package body Sem_Ch7 is\n          if not Body_Required then\n             Set_Suppress_Elaboration_Warnings (Id);\n          end if;\n-\n       end if;\n \n       End_Package_Scope (Id);\n@@ -1131,6 +1163,8 @@ package body Sem_Ch7 is\n          Write_Location (Sloc (N));\n          Write_Eol;\n       end if;\n+\n+      Restore_Globals;\n    end Analyze_Package_Declaration;\n \n    -----------------------------------\n@@ -1817,8 +1851,9 @@ package body Sem_Ch7 is\n    --------------------------------------\n \n    procedure Analyze_Private_Type_Declaration (N : Node_Id) is\n-      PF : constant Boolean   := Is_Pure (Enclosing_Lib_Unit_Entity);\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n       Id : constant Entity_Id := Defining_Identifier (N);\n+      PF : constant Boolean   := Is_Pure (Enclosing_Lib_Unit_Entity);\n \n    begin\n       --  The private type declaration may be subject to pragma Ghost with\n@@ -1850,6 +1885,11 @@ package body Sem_Ch7 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Private_Type_Declaration;\n \n    ----------------------------------"}, {"sha": "239fadc2f2b1c596eb9f312278958f78c93a543b", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 83, "deletions": 46, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -550,8 +550,9 @@ package body Sem_Ch8 is\n    --  there is more than one element in the list.\n \n    procedure Analyze_Exception_Renaming (N : Node_Id) is\n-      Id  : constant Node_Id := Defining_Identifier (N);\n-      Nam : constant Node_Id := Name (N);\n+      GM  : constant Ghost_Mode_Type := Ghost_Mode;\n+      Id  : constant Entity_Id       := Defining_Entity (N);\n+      Nam : constant Node_Id         := Name (N);\n \n    begin\n       --  The exception renaming declaration may be subject to pragma Ghost\n@@ -565,27 +566,26 @@ package body Sem_Ch8 is\n       Enter_Name (Id);\n       Analyze (Nam);\n \n-      Set_Ekind          (Id, E_Exception);\n-      Set_Etype          (Id, Standard_Exception_Type);\n-      Set_Is_Pure        (Id, Is_Pure (Current_Scope));\n+      Set_Ekind   (Id, E_Exception);\n+      Set_Etype   (Id, Standard_Exception_Type);\n+      Set_Is_Pure (Id, Is_Pure (Current_Scope));\n \n-      if not Is_Entity_Name (Nam)\n-        or else Ekind (Entity (Nam)) /= E_Exception\n+      if Is_Entity_Name (Nam)\n+        and then Present (Entity (Nam))\n+        and then Ekind (Entity (Nam)) = E_Exception\n       then\n-         Error_Msg_N (\"invalid exception name in renaming\", Nam);\n-      else\n          if Present (Renamed_Object (Entity (Nam))) then\n             Set_Renamed_Object (Id, Renamed_Object (Entity (Nam)));\n          else\n             Set_Renamed_Object (Id, Entity (Nam));\n          end if;\n \n-         --  An exception renaming is Ghost if the renamed entity is Ghost or\n-         --  the construct appears within a Ghost scope.\n+         --  The exception renaming declaration may become Ghost if it renames\n+         --  a Ghost entity.\n \n-         if Is_Ghost_Entity (Entity (Nam)) or else Ghost_Mode > None then\n-            Set_Is_Ghost_Entity (Id);\n-         end if;\n+         Mark_Renaming_As_Ghost (N, Entity (Nam));\n+      else\n+         Error_Msg_N (\"invalid exception name in renaming\", Nam);\n       end if;\n \n       --  Implementation-defined aspect specifications can appear in a renaming\n@@ -595,6 +595,11 @@ package body Sem_Ch8 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, Id);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Exception_Renaming;\n \n    ---------------------------\n@@ -664,9 +669,10 @@ package body Sem_Ch8 is\n      (N : Node_Id;\n       K : Entity_Kind)\n    is\n-      New_P : constant Entity_Id := Defining_Entity (N);\n+      GM    : constant Ghost_Mode_Type := Ghost_Mode;\n+      New_P : constant Entity_Id       := Defining_Entity (N);\n       Old_P : Entity_Id;\n-      Inst  : Boolean   := False; -- prevent junk warning\n+      Inst  : Boolean := False; -- prevent junk warning\n \n    begin\n       if Name (N) = Error then\n@@ -710,7 +716,7 @@ package body Sem_Ch8 is\n \n       else\n          if Present (Renamed_Object (Old_P)) then\n-            Set_Renamed_Object (New_P,  Renamed_Object (Old_P));\n+            Set_Renamed_Object (New_P, Renamed_Object (Old_P));\n          else\n             Set_Renamed_Object (New_P, Old_P);\n          end if;\n@@ -721,12 +727,10 @@ package body Sem_Ch8 is\n          Set_Etype (New_P, Etype (Old_P));\n          Set_Has_Completion (New_P);\n \n-         --  An generic renaming is Ghost if the renamed entity is Ghost or the\n-         --  construct appears within a Ghost scope.\n+         --  The generic renaming declaration may become Ghost if it renames a\n+         --  Ghost entity.\n \n-         if Is_Ghost_Entity (Old_P) or else Ghost_Mode > None then\n-            Set_Is_Ghost_Entity (New_P);\n-         end if;\n+         Mark_Renaming_As_Ghost (N, Old_P);\n \n          if In_Open_Scopes (Old_P) then\n             Error_Msg_N (\"within its scope, generic denotes its instance\", N);\n@@ -750,17 +754,22 @@ package body Sem_Ch8 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, New_P);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Generic_Renaming;\n \n    -----------------------------\n    -- Analyze_Object_Renaming --\n    -----------------------------\n \n    procedure Analyze_Object_Renaming (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n       Id  : constant Entity_Id  := Defining_Identifier (N);\n-      Dec : Node_Id;\n+      Loc : constant Source_Ptr := Sloc (N);\n       Nam : constant Node_Id    := Name (N);\n+      Dec : Node_Id;\n       T   : Entity_Id;\n       T2  : Entity_Id;\n \n@@ -856,6 +865,10 @@ package body Sem_Ch8 is\n          return False;\n       end In_Generic_Scope;\n \n+      --  Local variables\n+\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n    --  Start of processing for Analyze_Object_Renaming\n \n    begin\n@@ -1347,14 +1360,11 @@ package body Sem_Ch8 is\n          Set_Is_True_Constant    (Id, True);\n       end if;\n \n-      --  An object renaming is Ghost if the renamed entity is Ghost or the\n-      --  construct appears within a Ghost scope.\n+      --  The object renaming declaration may become Ghost if it renames a\n+      --  Ghost entity.\n \n-      if (Is_Entity_Name (Nam)\n-           and then Is_Ghost_Entity (Entity (Nam)))\n-        or else Ghost_Mode > None\n-      then\n-         Set_Is_Ghost_Entity (Id);\n+      if Is_Entity_Name (Nam) then\n+         Mark_Renaming_As_Ghost (N, Entity (Nam));\n       end if;\n \n       --  The entity of the renaming declaration needs to reflect whether the\n@@ -1401,17 +1411,40 @@ package body Sem_Ch8 is\n       --  Deal with dimensions\n \n       Analyze_Dimension (N);\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Object_Renaming;\n \n    ------------------------------\n    -- Analyze_Package_Renaming --\n    ------------------------------\n \n    procedure Analyze_Package_Renaming (N : Node_Id) is\n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n+      procedure Restore_Globals;\n+      --  Restore the values of all saved global variables\n+\n+      ---------------------\n+      -- Restore_Globals --\n+      ---------------------\n+\n+      procedure Restore_Globals is\n+      begin\n+         Ghost_Mode := GM;\n+      end Restore_Globals;\n+\n+      --  Local variables\n+\n       New_P : constant Entity_Id := Defining_Entity (N);\n       Old_P : Entity_Id;\n       Spec  : Node_Id;\n \n+   --  Start of processing for Analyze_Package_Renaming\n+\n    begin\n       if Name (N) = Error then\n          return;\n@@ -1486,12 +1519,10 @@ package body Sem_Ch8 is\n          Check_Library_Unit_Renaming (N, Old_P);\n          Generate_Reference (Old_P, Name (N));\n \n-         --  A package renaming is Ghost if the renamed entity is Ghost or\n-         --  the construct appears within a Ghost scope.\n+         --  The package renaming declaration may become Ghost if it renames a\n+         --  Ghost entity.\n \n-         if Is_Ghost_Entity (Old_P) or else Ghost_Mode > None then\n-            Set_Is_Ghost_Entity (New_P);\n-         end if;\n+         Mark_Renaming_As_Ghost (N, Old_P);\n \n          --  If the renaming is in the visible part of a package, then we set\n          --  Renamed_In_Spec for the renamed package, to prevent giving\n@@ -1524,6 +1555,7 @@ package body Sem_Ch8 is\n          --  subtypes again, so they are compatible with types in their class.\n \n          if not Is_Generic_Instance (Old_P) then\n+            Restore_Globals;\n             return;\n          else\n             Spec := Specification (Unit_Declaration_Node (Old_P));\n@@ -1565,6 +1597,8 @@ package body Sem_Ch8 is\n       if Has_Aspects (N) then\n          Analyze_Aspect_Specifications (N, New_P);\n       end if;\n+\n+      Restore_Globals;\n    end Analyze_Package_Renaming;\n \n    -------------------------------\n@@ -2611,6 +2645,7 @@ package body Sem_Ch8 is\n       --  defaulted formal subprogram when the actual for a related formal\n       --  type is class-wide.\n \n+      GM        : constant Ghost_Mode_Type := Ghost_Mode;\n       Inst_Node : Node_Id := Empty;\n       New_S     : Entity_Id;\n \n@@ -3094,12 +3129,10 @@ package body Sem_Ch8 is\n          Set_Is_Pure          (New_S, Is_Pure          (Entity (Nam)));\n          Set_Is_Preelaborated (New_S, Is_Preelaborated (Entity (Nam)));\n \n-         --  A subprogram renaming is Ghost if the renamed entity is Ghost or\n-         --  the construct appears within a Ghost scope.\n+         --  The subprogram renaming declaration may become Ghost if it renames\n+         --  a Ghost entity.\n \n-         if Is_Ghost_Entity (Entity (Nam)) or else Ghost_Mode > None then\n-            Set_Is_Ghost_Entity (New_S);\n-         end if;\n+         Mark_Renaming_As_Ghost (N, Entity (Nam));\n \n          --  Ada 2005 (AI-423): Check the consistency of null exclusions\n          --  between a subprogram and its correct renaming.\n@@ -3417,11 +3450,10 @@ package body Sem_Ch8 is\n                if Present (F1) and then Present (Default_Value (F1)) then\n                   if Present (Next_Formal (F1)) then\n                      Error_Msg_NE\n-                       (\"\\missing specification for &\" &\n-                          \" and other formals with defaults\", Spec, F1);\n+                       (\"\\missing specification for & and other formals with \"\n+                        & \"defaults\", Spec, F1);\n                   else\n-                     Error_Msg_NE\n-                    (\"\\missing specification for &\", Spec, F1);\n+                     Error_Msg_NE (\"\\missing specification for &\", Spec, F1);\n                   end if;\n                end if;\n \n@@ -3507,7 +3539,7 @@ package body Sem_Ch8 is\n         and then Chars (Current_Scope) /= Chars (Old_S)\n       then\n          Error_Msg_N\n-          (\"redundant renaming, entity is directly visible?r?\", Name (N));\n+           (\"redundant renaming, entity is directly visible?r?\", Name (N));\n       end if;\n \n       --  Implementation-defined aspect specifications can appear in a renaming\n@@ -3544,6 +3576,11 @@ package body Sem_Ch8 is\n             Analyze (N);\n          end if;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Subprogram_Renaming;\n \n    -------------------------"}, {"sha": "fbe5f6c4f97401c69ac662505b68851c90493c94", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 827, "deletions": 232, "changes": 1059, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -183,25 +183,6 @@ package body Sem_Prag is\n    --  Query whether a particular item appears in a mixed list of nodes and\n    --  entities. It is assumed that all nodes in the list have entities.\n \n-   function Check_Kind (Nam : Name_Id) return Name_Id;\n-   --  This function is used in connection with pragmas Assert, Check,\n-   --  and assertion aspects and pragmas, to determine if Check pragmas\n-   --  (or corresponding assertion aspects or pragmas) are currently active\n-   --  as determined by the presence of -gnata on the command line (which\n-   --  sets the default), and the appearance of pragmas Check_Policy and\n-   --  Assertion_Policy as configuration pragmas either in a configuration\n-   --  pragma file, or at the start of the current unit, or locally given\n-   --  Check_Policy and Assertion_Policy pragmas that are currently active.\n-   --\n-   --  The value returned is one of the names Check, Ignore, Disable (On\n-   --  returns Check, and Off returns Ignore).\n-   --\n-   --  Note: for assertion kinds Pre'Class, Post'Class, Invariant'Class,\n-   --  and Type_Invariant'Class, the name passed is Name_uPre, Name_uPost,\n-   --  Name_uInvariant, or Name_uType_Invariant, which corresponds to _Pre,\n-   --  _Post, _Invariant, or _Type_Invariant, which are special names used\n-   --  in identifiers to represent these attribute references.\n-\n    procedure Check_Postcondition_Use_In_Inlined_Subprogram\n      (Prag    : Node_Id;\n       Spec_Id : Entity_Id);\n@@ -409,6 +390,8 @@ package body Sem_Prag is\n \n       --  Local variables\n \n+      GM : constant Ghost_Mode_Type := Ghost_Mode;\n+\n       Subp_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n       Spec_Id   : constant Entity_Id := Corresponding_Spec_Of (Subp_Decl);\n       CCases    : constant Node_Id   := Expression (Get_Argument (N, Spec_Id));\n@@ -419,6 +402,12 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Contract_Cases_In_Decl_Part\n \n    begin\n+      --  Set the Ghost mode in effect from the pragma. Due to the delayed\n+      --  analysis of the pragma, the Ghost mode at point of declaration and\n+      --  point of analysis may not necessarely be the same. Use the mode in\n+      --  effect at the point of declaration.\n+\n+      Set_Ghost_Mode (N);\n       Set_Analyzed (N);\n \n       --  Single and multiple contract cases must appear in aggregate form. If\n@@ -464,6 +453,11 @@ package body Sem_Prag is\n       else\n          Error_Msg_N (\"wrong syntax for constract cases\", N);\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Contract_Cases_In_Decl_Part;\n \n    ----------------------------------\n@@ -1721,11 +1715,18 @@ package body Sem_Prag is\n      (N        : Node_Id;\n       Expr_Val : out Boolean)\n    is\n+      GM     : constant Ghost_Mode_Type := Ghost_Mode;\n       Arg1   : constant Node_Id   := First (Pragma_Argument_Associations (N));\n       Obj_Id : constant Entity_Id := Entity (Get_Pragma_Arg (Arg1));\n       Expr   : constant Node_Id   := Get_Pragma_Arg (Next (Arg1));\n \n    begin\n+      --  Set the Ghost mode in effect from the pragma. Due to the delayed\n+      --  analysis of the pragma, the Ghost mode at point of declaration and\n+      --  point of analysis may not necessarely be the same. Use the mode in\n+      --  effect at the point of declaration.\n+\n+      Set_Ghost_Mode (N);\n       Error_Msg_Name_1 := Pragma_Name (N);\n \n       --  An external property pragma must apply to an effectively volatile\n@@ -1756,6 +1757,11 @@ package body Sem_Prag is\n             SPARK_Msg_N (\"expression of % must be static\", Expr);\n          end if;\n       end if;\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_External_Property_In_Decl_Part;\n \n    ---------------------------------\n@@ -2258,18 +2264,30 @@ package body Sem_Prag is\n    --------------------------------------------\n \n    procedure Analyze_Initial_Condition_In_Decl_Part (N : Node_Id) is\n+      GM        : constant Ghost_Mode_Type := Ghost_Mode;\n       Pack_Decl : constant Node_Id   := Find_Related_Package_Or_Body (N);\n       Pack_Id   : constant Entity_Id := Defining_Entity (Pack_Decl);\n       Expr      : constant Node_Id   := Expression (Get_Argument (N, Pack_Id));\n \n    begin\n+      --  Set the Ghost mode in effect from the pragma. Due to the delayed\n+      --  analysis of the pragma, the Ghost mode at point of declaration and\n+      --  point of analysis may not necessarely be the same. Use the mode in\n+      --  effect at the point of declaration.\n+\n+      Set_Ghost_Mode (N);\n       Set_Analyzed (N);\n \n       --  The expression is preanalyzed because it has not been moved to its\n       --  final place yet. A direct analysis may generate side effects and this\n       --  is not desired at this point.\n \n       Preanalyze_Assert_Expression (Expr, Standard_Boolean);\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Initial_Condition_In_Decl_Part;\n \n    --------------------------------------\n@@ -3314,6 +3332,10 @@ package body Sem_Prag is\n \n          Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n \n+         --  A pragma that applies to a Ghost entity becomes Ghost for the\n+         --  purposes of legality checks and removal of ignored Ghost code.\n+\n+         Mark_Pragma_As_Ghost (N, Spec_Id);\n          Ensure_Aggregate_Form (Get_Argument (N, Spec_Id));\n \n          --  Fully analyze the pragma when it appears inside a subprogram body\n@@ -3505,6 +3527,7 @@ package body Sem_Prag is\n       procedure Analyze_Pre_Post_Condition is\n          Prag_Iden : constant Node_Id := Pragma_Identifier (N);\n          Subp_Decl : Node_Id;\n+         Subp_Id   : Entity_Id;\n \n          Duplicates_OK : Boolean := False;\n          --  Flag set when a pre/postcondition allows multiple pragmas of the\n@@ -3642,6 +3665,13 @@ package body Sem_Prag is\n             return;\n          end if;\n \n+         Subp_Id := Defining_Entity (Subp_Decl);\n+\n+         --  A pragma that applies to a Ghost entity becomes Ghost for the\n+         --  purposes of legality checks and removal of ignored Ghost code.\n+\n+         Mark_Pragma_As_Ghost (N, Subp_Id);\n+\n          --  Fully analyze the pragma when it appears inside a subprogram\n          --  body because it cannot benefit from forward references.\n \n@@ -3728,6 +3758,11 @@ package body Sem_Prag is\n             return;\n          end if;\n \n+         --  A pragma that applies to a Ghost entity becomes Ghost for the\n+         --  purposes of legality checks and removal of ignored Ghost code.\n+\n+         Mark_Pragma_As_Ghost (N, Spec_Id);\n+\n          --  If we get here, then the pragma is legal\n \n          if Nam_In (Pname, Name_Refined_Depends,\n@@ -5836,9 +5871,9 @@ package body Sem_Prag is\n       ------------------------------------------------\n \n       procedure Process_Atomic_Independent_Shared_Volatile is\n-         E_Id : Node_Id;\n-         E    : Entity_Id;\n          D    : Node_Id;\n+         E    : Entity_Id;\n+         E_Id : Node_Id;\n          K    : Node_Kind;\n          Utyp : Entity_Id;\n \n@@ -5882,6 +5917,11 @@ package body Sem_Prag is\n          D := Declaration_Node (E);\n          K := Nkind (D);\n \n+         --  A pragma that applies to a Ghost entity becomes Ghost for the\n+         --  purposes of legality checks and removal of ignored Ghost code.\n+\n+         Mark_Pragma_As_Ghost (N, E);\n+\n          --  Check duplicate before we chain ourselves\n \n          Check_Duplicate_Pragma (E);\n@@ -7506,6 +7546,11 @@ package body Sem_Prag is\n \n          else\n             Process_Convention (C, Def_Id);\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Def_Id);\n             Kill_Size_Check_Code (Def_Id);\n             Note_Possible_Modification (Get_Pragma_Arg (Arg2), Sure => False);\n          end if;\n@@ -7878,11 +7923,19 @@ package body Sem_Prag is\n       --------------------\n \n       procedure Process_Inline (Status : Inline_Status) is\n-         Assoc     : Node_Id;\n-         Decl      : Node_Id;\n-         Subp_Id   : Node_Id;\n-         Subp      : Entity_Id;\n-         Applies   : Boolean;\n+         Applies : Boolean;\n+         Assoc   : Node_Id;\n+         Decl    : Node_Id;\n+         Subp    : Entity_Id;\n+         Subp_Id : Node_Id;\n+\n+         Ghost_Error_Posted : Boolean := False;\n+         --  Flag set when an error concerning the illegal mix of Ghost and\n+         --  non-Ghost subprograms is emitted.\n+\n+         Ghost_Id : Entity_Id := Empty;\n+         --  The entity of the first Ghost subprogram encountered while\n+         --  processing the arguments of the pragma.\n \n          procedure Make_Inline (Subp : Entity_Id);\n          --  Subp is the defining unit name of the subprogram declaration. Set\n@@ -8151,6 +8204,37 @@ package body Sem_Prag is\n                      Set_Is_Inlined (Subp, True);\n                   end if;\n             end case;\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Subp);\n+\n+            --  Capture the entity of the first Ghost subprogram being\n+            --  processed for error detection purposes.\n+\n+            if Is_Ghost_Entity (Subp) then\n+               if No (Ghost_Id) then\n+                  Ghost_Id := Subp;\n+               end if;\n+\n+            --  Otherwise the subprogram is non-Ghost. It is illegal to mix\n+            --  references to Ghost and non-Ghost entities (SPARK RM 6.9).\n+\n+            elsif Present (Ghost_Id) and then not Ghost_Error_Posted then\n+               Ghost_Error_Posted := True;\n+\n+               Error_Msg_Name_1 := Pname;\n+               Error_Msg_N\n+                 (\"pragma % cannot mention ghost and non-ghost subprograms\",\n+                  N);\n+\n+               Error_Msg_Sloc := Sloc (Ghost_Id);\n+               Error_Msg_NE (\"\\& # declared as ghost\", N, Ghost_Id);\n+\n+               Error_Msg_Sloc := Sloc (Subp);\n+               Error_Msg_NE (\"\\& # declared as non-ghost\", N, Subp);\n+            end if;\n          end Set_Inline_Flags;\n \n       --  Start of processing for Process_Inline\n@@ -8422,6 +8506,10 @@ package body Sem_Prag is\n          Proc_Scope   : constant Entity_Id := Scope (Handler_Proc);\n \n       begin\n+         --  A pragma that applies to a Ghost entity becomes Ghost for the\n+         --  purposes of legality checks and removal of ignored Ghost code.\n+\n+         Mark_Pragma_As_Ghost (N, Handler_Proc);\n          Set_Is_Interrupt_Handler (Handler_Proc);\n \n          --  If the pragma is not associated with a handler procedure within a\n@@ -8757,8 +8845,8 @@ package body Sem_Prag is\n \n       procedure Process_Suppress_Unsuppress (Suppress_Case : Boolean) is\n          C    : Check_Id;\n-         E_Id : Node_Id;\n          E    : Entity_Id;\n+         E_Id : Node_Id;\n \n          In_Package_Spec : constant Boolean :=\n                              Is_Package_Or_Generic_Package (Current_Scope)\n@@ -8813,8 +8901,8 @@ package body Sem_Prag is\n          --  on user code: we want to generate checks for analysis purposes, as\n          --  set respectively by -gnatC and -gnatd.F\n \n-         if (CodePeer_Mode or GNATprove_Mode)\n-           and then Comes_From_Source (N)\n+         if Comes_From_Source (N)\n+           and then (CodePeer_Mode or GNATprove_Mode)\n          then\n             return;\n          end if;\n@@ -8917,6 +9005,11 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, E);\n+\n             --  Enforce RM 11.5(7) which requires that for a pragma that\n             --  appears within a package spec, the named entity must be\n             --  within the package spec. We allow the package name itself\n@@ -10033,7 +10126,7 @@ package body Sem_Prag is\n                   --  An abstract state declared within a Ghost region becomes\n                   --  Ghost (SPARK RM 6.9(2)).\n \n-                  if Ghost_Mode > None then\n+                  if Ghost_Mode > None or else Is_Ghost_Entity (Pack_Id) then\n                      Set_Is_Ghost_Entity (State_Id);\n                   end if;\n \n@@ -10299,15 +10392,11 @@ package body Sem_Prag is\n \n             Pack_Id := Defining_Entity (Pack_Decl);\n \n-            Ensure_Aggregate_Form (Get_Argument (N, Pack_Id));\n-\n-            --  Mark the associated package as Ghost if it is subject to aspect\n-            --  or pragma Ghost as this affects the declaration of an abstract\n-            --  state.\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n \n-            if Is_Subject_To_Ghost (Unit_Declaration_Node (Pack_Id)) then\n-               Set_Is_Ghost_Entity (Pack_Id);\n-            end if;\n+            Mark_Pragma_As_Ghost (N, Pack_Id);\n+            Ensure_Aggregate_Form (Get_Argument (N, Pack_Id));\n \n             States := Expression (Get_Argument (N, Pack_Id));\n \n@@ -10554,11 +10643,14 @@ package body Sem_Prag is\n \n             Lib_Entity := Find_Lib_Unit_Name;\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Lib_Entity);\n+\n             --  This pragma should only apply to a RCI unit (RM E.2.3(23))\n \n-            if Present (Lib_Entity)\n-              and then not Debug_Flag_U\n-            then\n+            if Present (Lib_Entity) and then not Debug_Flag_U then\n                if not Is_Remote_Call_Interface (Lib_Entity) then\n                   Error_Pragma (\"pragma% only apply to rci unit\");\n \n@@ -10567,7 +10659,6 @@ package body Sem_Prag is\n                else\n                   Set_Has_All_Calls_Remote (Lib_Entity);\n                end if;\n-\n             end if;\n          end All_Calls_Remote;\n \n@@ -10604,80 +10695,87 @@ package body Sem_Prag is\n          --  not analyzed.\n \n          when Pragma_Annotate => Annotate : declare\n-            Arg : Node_Id;\n-            Exp : Node_Id;\n+            Arg     : Node_Id;\n+            Expr    : Node_Id;\n+            Nam_Arg : Node_Id;\n \n          begin\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (1);\n \n-            --  See if last argument is Entity => local_Name, and if so process\n-            --  and then remove it for remaining processing.\n+            Nam_Arg := Last (Pragma_Argument_Associations (N));\n \n-            declare\n-               Last_Arg : constant Node_Id :=\n-                            Last (Pragma_Argument_Associations (N));\n+            --  Determine whether the last argument is \"Entity => local_NAME\"\n+            --  and if it is, perform the required semantic checks. Remove the\n+            --  argument from further processing.\n \n-            begin\n-               if Nkind (Last_Arg) = N_Pragma_Argument_Association\n-                 and then Chars (Last_Arg) = Name_Entity\n-               then\n-                  Check_Arg_Is_Local_Name (Last_Arg);\n-                  Arg_Count := Arg_Count - 1;\n+            if Nkind (Nam_Arg) = N_Pragma_Argument_Association\n+              and then Chars (Nam_Arg) = Name_Entity\n+            then\n+               Check_Arg_Is_Local_Name (Nam_Arg);\n+               Arg_Count := Arg_Count - 1;\n \n-                  --  Not allowed in compiler units (bootstrap issues)\n+               --  A pragma that applies to a Ghost entity becomes Ghost for\n+               --  the purposes of legality checks and removal of ignored Ghost\n+               --  code.\n \n-                  Check_Compiler_Unit (\"Entity for pragma Annotate\", N);\n+               if Is_Entity_Name (Get_Pragma_Arg (Nam_Arg))\n+                 and then Present (Entity (Get_Pragma_Arg (Nam_Arg)))\n+               then\n+                  Mark_Pragma_As_Ghost (N, Entity (Get_Pragma_Arg (Nam_Arg)));\n                end if;\n-            end;\n \n-            --  Continue processing with last argument removed for now\n+               --  Not allowed in compiler units (bootstrap issues)\n+\n+               Check_Compiler_Unit (\"Entity for pragma Annotate\", N);\n+            end if;\n+\n+            --  Continue the processing with last argument removed for now\n \n             Check_Arg_Is_Identifier (Arg1);\n             Check_No_Identifiers;\n             Store_Note (N);\n \n-            --  Second parameter is optional, it is never analyzed\n+            --  The second parameter is optional, it is never analyzed\n \n             if No (Arg2) then\n                null;\n \n-            --  Here if we have a second parameter\n+            --  Otherwise there is a second parameter\n \n             else\n-               --  Second parameter must be identifier\n+               --  The second parameter must be an identifier\n \n                Check_Arg_Is_Identifier (Arg2);\n \n-               --  Process remaining parameters if any\n+               --  Process the remaining parameters (if any)\n \n                Arg := Next (Arg2);\n                while Present (Arg) loop\n-                  Exp := Get_Pragma_Arg (Arg);\n-                  Analyze (Exp);\n+                  Expr := Get_Pragma_Arg (Arg);\n+                  Analyze (Expr);\n \n-                  if Is_Entity_Name (Exp) then\n+                  if Is_Entity_Name (Expr) then\n                      null;\n \n                   --  For string literals, we assume Standard_String as the\n                   --  type, unless the string contains wide or wide_wide\n                   --  characters.\n \n-                  elsif Nkind (Exp) = N_String_Literal then\n-                     if Has_Wide_Wide_Character (Exp) then\n-                        Resolve (Exp, Standard_Wide_Wide_String);\n-                     elsif Has_Wide_Character (Exp) then\n-                        Resolve (Exp, Standard_Wide_String);\n+                  elsif Nkind (Expr) = N_String_Literal then\n+                     if Has_Wide_Wide_Character (Expr) then\n+                        Resolve (Expr, Standard_Wide_Wide_String);\n+                     elsif Has_Wide_Character (Expr) then\n+                        Resolve (Expr, Standard_Wide_String);\n                      else\n-                        Resolve (Exp, Standard_String);\n+                        Resolve (Expr, Standard_String);\n                      end if;\n \n-                  elsif Is_Overloaded (Exp) then\n-                        Error_Pragma_Arg\n-                          (\"ambiguous argument for pragma%\", Exp);\n+                  elsif Is_Overloaded (Expr) then\n+                     Error_Pragma_Arg (\"ambiguous argument for pragma%\", Expr);\n \n                   else\n-                     Resolve (Exp);\n+                     Resolve (Expr);\n                   end if;\n \n                   Next (Arg);\n@@ -10751,12 +10849,18 @@ package body Sem_Prag is\n \n             --  Local variables\n \n-            Expr : Node_Id;\n-            Newa : List_Id;\n+            GM       : constant Ghost_Mode_Type := Ghost_Mode;\n+            Expr     : Node_Id;\n+            New_Args : List_Id;\n \n          --  Start of processing for Assert\n \n          begin\n+            --  Ensure that analysis and expansion produce Ghost nodes if the\n+            --  pragma itself is Ghost.\n+\n+            Set_Ghost_Mode (N);\n+\n             --  Assert is an Ada 2005 RM-defined pragma\n \n             if Prag_Id = Pragma_Assert then\n@@ -10779,7 +10883,7 @@ package body Sem_Prag is\n             --  assertion pragma contains attribute Loop_Entry, ensure that\n             --  the related pragma is within a loop.\n \n-            if Prag_Id = Pragma_Loop_Invariant\n+            if        Prag_Id = Pragma_Loop_Invariant\n               or else Prag_Id = Pragma_Loop_Variant\n               or else Contains_Loop_Entry (Expr)\n             then\n@@ -10788,7 +10892,7 @@ package body Sem_Prag is\n                --  Perform preanalysis to deal with embedded Loop_Entry\n                --  attributes.\n \n-               Preanalyze_Assert_Expression (Expression (Arg1), Any_Boolean);\n+               Preanalyze_Assert_Expression (Expr, Any_Boolean);\n             end if;\n \n             --  Implement Assert[_And_Cut]/Assume/Loop_Invariant by generating\n@@ -10805,7 +10909,7 @@ package body Sem_Prag is\n             --  Assume, or Assert_And_Cut pragma can be retrieved from the\n             --  pragma kind of Original_Node(N).\n \n-            Newa := New_List (\n+            New_Args := New_List (\n               Make_Pragma_Argument_Association (Loc,\n                 Expression => Make_Identifier (Loc, Pname)),\n               Make_Pragma_Argument_Association (Sloc (Expr),\n@@ -10818,16 +10922,22 @@ package body Sem_Prag is\n                --  ASIS use, before rewriting.\n \n                Preanalyze_And_Resolve (Expression (Arg2), Standard_String);\n-               Append_To (Newa, New_Copy_Tree (Arg2));\n+               Append_To (New_Args, New_Copy_Tree (Arg2));\n             end if;\n \n             --  Rewrite as Check pragma\n \n             Rewrite (N,\n               Make_Pragma (Loc,\n                 Chars                        => Name_Check,\n-                Pragma_Argument_Associations => Newa));\n+                Pragma_Argument_Associations => New_Args));\n+\n             Analyze (N);\n+\n+            --  Restore the original Ghost mode once analysis and expansion\n+            --  have taken place.\n+\n+            Ghost_Mode := GM;\n          end Assert;\n \n          ----------------------\n@@ -11114,6 +11224,12 @@ package body Sem_Prag is\n             then\n                Obj_Id := Entity (Obj);\n \n+               --  A pragma that applies to a Ghost entity becomes Ghost for\n+               --  the purposes of legality checks and removal of ignored Ghost\n+               --  code.\n+\n+               Mark_Pragma_As_Ghost (N, Obj_Id);\n+\n                --  Detect a duplicate pragma. Note that it is not efficient to\n                --  examine preceding statements as Boolean aspects may appear\n                --  anywhere between the related object declaration and its\n@@ -11150,12 +11266,12 @@ package body Sem_Prag is\n          --  pragma Asynchronous (LOCAL_NAME);\n \n          when Pragma_Asynchronous => Asynchronous : declare\n-            Nm     : Entity_Id;\n             C_Ent  : Entity_Id;\n+            Decl   : Node_Id;\n+            Formal : Entity_Id;\n             L      : List_Id;\n+            Nm     : Entity_Id;\n             S      : Node_Id;\n-            N      : Node_Id;\n-            Formal : Entity_Id;\n \n             procedure Process_Async_Pragma;\n             --  Common processing for procedure and access-to-procedure case\n@@ -11207,6 +11323,11 @@ package body Sem_Prag is\n             Analyze (Get_Pragma_Arg (Arg1));\n             Nm := Entity (Get_Pragma_Arg (Arg1));\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Nm);\n+\n             if not Is_Remote_Call_Interface (C_Ent)\n               and then not Is_Remote_Types (C_Ent)\n             then\n@@ -11235,24 +11356,24 @@ package body Sem_Prag is\n                  (\"pragma% cannot be applied to function\", Arg1);\n \n             elsif Is_Remote_Access_To_Subprogram_Type (Nm) then\n-                  if Is_Record_Type (Nm) then\n+               if Is_Record_Type (Nm) then\n \n                   --  A record type that is the Equivalent_Type for a remote\n                   --  access-to-subprogram type.\n \n-                     N := Declaration_Node (Corresponding_Remote_Type (Nm));\n+                  Decl := Declaration_Node (Corresponding_Remote_Type (Nm));\n \n-                  else\n-                     --  A non-expanded RAS type (distribution is not enabled)\n+               else\n+                  --  A non-expanded RAS type (distribution is not enabled)\n \n-                     N := Declaration_Node (Nm);\n-                  end if;\n+                  Decl := Declaration_Node (Nm);\n+               end if;\n \n-               if Nkind (N) = N_Full_Type_Declaration\n-                 and then Nkind (Type_Definition (N)) =\n+               if Nkind (Decl) = N_Full_Type_Declaration\n+                 and then Nkind (Type_Definition (Decl)) =\n                                      N_Access_Procedure_Definition\n                then\n-                  L := Parameter_Specifications (Type_Definition (N));\n+                  L := Parameter_Specifications (Type_Definition (Decl));\n                   Process_Async_Pragma;\n \n                   if Is_Asynchronous (Nm)\n@@ -11303,11 +11424,10 @@ package body Sem_Prag is\n \n          when Pragma_Atomic_Components   |\n               Pragma_Volatile_Components =>\n-\n          Atomic_Components : declare\n-            E_Id : Node_Id;\n-            E    : Entity_Id;\n             D    : Node_Id;\n+            E    : Entity_Id;\n+            E_Id : Node_Id;\n             K    : Node_Kind;\n \n          begin\n@@ -11323,6 +11443,10 @@ package body Sem_Prag is\n \n             E := Entity (E_Id);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, E);\n             Check_Duplicate_Pragma (E);\n \n             if Rep_Item_Too_Early (E, N)\n@@ -11468,12 +11592,18 @@ package body Sem_Prag is\n          --  allowed, since they have special meaning for Check_Policy.\n \n          when Pragma_Check => Check : declare\n-            Expr  : Node_Id;\n-            Eloc  : Source_Ptr;\n+            GM    : constant Ghost_Mode_Type := Ghost_Mode;\n             Cname : Name_Id;\n+            Eloc  : Source_Ptr;\n+            Expr  : Node_Id;\n             Str   : Node_Id;\n \n          begin\n+            --  Ensure that analysis and expansion produce Ghost nodes if the\n+            --  pragma itself is Ghost.\n+\n+            Set_Ghost_Mode (N);\n+\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (2);\n             Check_At_Most_N_Arguments (3);\n@@ -11494,8 +11624,8 @@ package body Sem_Prag is\n             case Cname is\n                when Name_Assertions =>\n                   Error_Pragma_Arg\n-                    (\"\"\"Assertions\"\" is not allowed as a check kind \"\n-                     & \"for pragma%\", Arg1);\n+                    (\"\"\"Assertions\"\" is not allowed as a check kind for \"\n+                     & \"pragma%\", Arg1);\n \n                when Name_Statement_Assertions =>\n                   Error_Pragma_Arg\n@@ -11556,21 +11686,18 @@ package body Sem_Prag is\n             --  Deal with SCO generation\n \n             case Cname is\n-               when Name_Predicate |\n-                    Name_Invariant =>\n \n-                  --  Nothing to do: since checks occur in client units,\n-                  --  the SCO for the aspect in the declaration unit is\n-                  --  conservatively always enabled.\n+               --  Nothing to do for invariants and predicates as the checks\n+               --  occur in the client units. The SCO for the aspect in the\n+               --  declaration unit is conservatively always enabled.\n \n+               when Name_Invariant | Name_Predicate =>\n                   null;\n \n-               when others =>\n+               --  Otherwise mark aspect/pragma SCO as enabled\n \n+               when others =>\n                   if Is_Checked (N) and then not Split_PPC (N) then\n-\n-                     --  Mark aspect/pragma SCO as enabled\n-\n                      Set_SCO_Pragma_Enabled (Loc);\n                   end if;\n             end case;\n@@ -11629,7 +11756,7 @@ package body Sem_Prag is\n                        Left_Opnd  => Make_Identifier (Eloc, Name_False),\n                        Right_Opnd => Expr),\n                    Then_Statements => New_List (\n-                            Make_Null_Statement (Eloc))));\n+                     Make_Null_Statement (Eloc))));\n \n                --  Now go ahead and analyze the if statement\n \n@@ -11671,6 +11798,11 @@ package body Sem_Prag is\n                Analyze_And_Resolve (Expr, Any_Boolean);\n                In_Assertion_Expr := In_Assertion_Expr - 1;\n             end if;\n+\n+            --  Restore the original Ghost mode once analysis and expansion\n+            --  have taken place.\n+\n+            Ghost_Mode := GM;\n          end Check;\n \n          --------------------------\n@@ -12222,6 +12354,10 @@ package body Sem_Prag is\n \n             Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Spec_Id);\n             Ensure_Aggregate_Form (Get_Argument (N, Spec_Id));\n \n             --  Fully analyze the pragma when it appears inside a subprogram\n@@ -12278,6 +12414,11 @@ package body Sem_Prag is\n             Check_Ada_83_Warning;\n             Check_Arg_Count (2);\n             Process_Convention (C, E);\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, E);\n          end Convention;\n \n          ---------------------------\n@@ -12745,6 +12886,10 @@ package body Sem_Prag is\n                Stmt := Prev (Stmt);\n             end loop;\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Typ);\n             Set_Has_Default_Init_Cond (Typ);\n             Set_Has_Inherited_Default_Init_Cond (Typ, False);\n \n@@ -12804,7 +12949,10 @@ package body Sem_Prag is\n \n          --  pragma Default_Storage_Pool (storage_pool_NAME | null);\n \n-         when Pragma_Default_Storage_Pool =>\n+         when Pragma_Default_Storage_Pool => Default_Storage_Pool : declare\n+            Pool : Node_Id;\n+\n+         begin\n             Ada_2012_Pragma;\n             Check_Arg_Count (1);\n \n@@ -12815,44 +12963,57 @@ package body Sem_Prag is\n                Check_Is_In_Decl_Part_Or_Package_Spec;\n             end if;\n \n-            --  Case of Default_Storage_Pool (null);\n+            if Present (Arg1) then\n+               Pool := Get_Pragma_Arg (Arg1);\n+\n+               --  Case of Default_Storage_Pool (null);\n \n-            if Nkind (Expression (Arg1)) = N_Null then\n-               Analyze (Expression (Arg1));\n+               if Nkind (Pool) = N_Null then\n+                  Analyze (Pool);\n \n-               --  This is an odd case, this is not really an expression, so\n-               --  we don't have a type for it. So just set the type to Empty.\n+                  --  This is an odd case, this is not really an expression,\n+                  --  so we don't have a type for it. So just set the type to\n+                  --  Empty.\n \n-               Set_Etype (Expression (Arg1), Empty);\n+                  Set_Etype (Pool, Empty);\n \n-            --  Case of Default_Storage_Pool (storage_pool_NAME);\n+               --  Case of Default_Storage_Pool (storage_pool_NAME);\n \n-            else\n-               --  If it's a configuration pragma, then the only allowed\n-               --  argument is \"null\".\n+               else\n+                  --  If it's a configuration pragma, then the only allowed\n+                  --  argument is \"null\".\n \n-               if Is_Configuration_Pragma then\n-                  Error_Pragma_Arg (\"NULL expected\", Arg1);\n-               end if;\n+                  if Is_Configuration_Pragma then\n+                     Error_Pragma_Arg (\"NULL expected\", Arg1);\n+                  end if;\n \n-               --  The expected type for a non-\"null\" argument is\n-               --  Root_Storage_Pool'Class, and the pool must be a variable.\n+                  --  The expected type for a non-\"null\" argument is\n+                  --  Root_Storage_Pool'Class, and the pool must be a variable.\n \n-               Analyze_And_Resolve\n-                 (Get_Pragma_Arg (Arg1),\n-                  Typ => Class_Wide_Type (RTE (RE_Root_Storage_Pool)));\n+                  Analyze_And_Resolve\n+                    (Pool, Class_Wide_Type (RTE (RE_Root_Storage_Pool)));\n \n-               if not Is_Variable (Expression (Arg1)) then\n-                  Error_Pragma_Arg\n-                    (\"default storage pool must be a variable\", Arg1);\n+                  if Is_Variable (Pool) then\n+\n+                     --  A pragma that applies to a Ghost entity becomes Ghost\n+                     --  for the purposes of legality checks and removal of\n+                     --  ignored Ghost code.\n+\n+                     Mark_Pragma_As_Ghost (N, Entity (Pool));\n+\n+                  else\n+                     Error_Pragma_Arg\n+                       (\"default storage pool must be a variable\", Arg1);\n+                  end if;\n                end if;\n-            end if;\n \n-            --  Finally, record the pool name (or null). Freeze.Freeze_Entity\n-            --  for an access type will use this information to set the\n-            --  appropriate attributes of the access type.\n+               --  Record the pool name (or null). Freeze.Freeze_Entity for an\n+               --  access type will use this information to set the appropriate\n+               --  attributes of the access type.\n \n-            Default_Pool := Expression (Arg1);\n+               Default_Pool := Pool;\n+            end if;\n+         end Default_Storage_Pool;\n \n          -------------\n          -- Depends --\n@@ -12941,7 +13102,7 @@ package body Sem_Prag is\n \n          when Pragma_Discard_Names => Discard_Names : declare\n             E    : Entity_Id;\n-            E_Id : Entity_Id;\n+            E_Id : Node_Id;\n \n          begin\n             Check_Ada_83_Warning;\n@@ -12980,6 +13141,12 @@ package body Sem_Prag is\n                      E := Entity (E_Id);\n                   end if;\n \n+                  --  A pragma that applies to a Ghost entity becomes Ghost for\n+                  --  the purposes of legality checks and removal of ignored\n+                  --  Ghost code.\n+\n+                  Mark_Pragma_As_Ghost (N, E);\n+\n                   if (Is_First_Subtype (E)\n                       and then\n                         (Is_Enumeration_Type (E) or else Is_Tagged_Type (E)))\n@@ -12992,7 +13159,6 @@ package body Sem_Prag is\n                      Error_Pragma_Arg\n                        (\"inappropriate entity for pragma%\", Arg1);\n                   end if;\n-\n                end if;\n             end if;\n          end Discard_Names;\n@@ -13024,6 +13190,12 @@ package body Sem_Prag is\n                Arg := Get_Pragma_Arg (Arg1);\n                Ent := Defining_Identifier (Parent (P));\n \n+               --  A pragma that applies to a Ghost entity becomes Ghost for\n+               --  the purposes of legality checks and removal of ignored Ghost\n+               --  code.\n+\n+               Mark_Pragma_As_Ghost (N, Ent);\n+\n                --  The expression must be analyzed in the special manner\n                --  described in \"Handling of Default and Per-Object\n                --  Expressions\" in sem.ads.\n@@ -13245,6 +13417,11 @@ package body Sem_Prag is\n             Cunit_Node := Cunit (Current_Sem_Unit);\n             Cunit_Ent  := Cunit_Entity (Current_Sem_Unit);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Cunit_Ent);\n+\n             if Nkind_In (Unit (Cunit_Node), N_Package_Body,\n                                             N_Subprogram_Body)\n             then\n@@ -13432,6 +13609,12 @@ package body Sem_Prag is\n             else\n                Process_Convention (C, Def_Id);\n \n+               --  A pragma that applies to a Ghost entity becomes Ghost for\n+               --  the purposes of legality checks and removal of ignored Ghost\n+               --  code.\n+\n+               Mark_Pragma_As_Ghost (N, Def_Id);\n+\n                if Ekind (Def_Id) /= E_Constant then\n                   Note_Possible_Modification\n                     (Get_Pragma_Arg (Arg2), Sure => False);\n@@ -13848,6 +14031,12 @@ package body Sem_Prag is\n \n             Spec_Id := Corresponding_Spec_Of (Subp_Decl);\n \n+            --  Mark the pragma as Ghost if the related subprogram is also\n+            --  Ghost. This also ensures that any expansion performed further\n+            --  below will produce Ghost nodes.\n+\n+            Mark_Pragma_As_Ghost (N, Spec_Id);\n+\n             --  Examine the formals of the related subprogram\n \n             Formal := First_Formal (Spec_Id);\n@@ -13881,6 +14070,7 @@ package body Sem_Prag is\n                Error_Msg_NE\n                  (\"\\subprogram & lacks parameter of specific tagged or \"\n                   & \"generic private type\", N, Spec_Id);\n+\n                return;\n             end if;\n \n@@ -13914,10 +14104,9 @@ package body Sem_Prag is\n          --    [, [Link_Name     =>] static_string_EXPRESSION ]);\n \n          when Pragma_External => External : declare\n-               Def_Id : Entity_Id;\n-\n-               C : Convention_Id;\n-               pragma Warnings (Off, C);\n+            C : Convention_Id;\n+            E : Entity_Id;\n+            pragma Warnings (Off, C);\n \n          begin\n             GNAT_Pragma;\n@@ -13928,11 +14117,17 @@ package body Sem_Prag is\n                 Name_Link_Name));\n             Check_At_Least_N_Arguments (2);\n             Check_At_Most_N_Arguments  (4);\n-            Process_Convention (C, Def_Id);\n+            Process_Convention (C, E);\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, E);\n+\n             Note_Possible_Modification\n               (Get_Pragma_Arg (Arg2), Sure => False);\n-            Process_Interface_Name (Def_Id, Arg3, Arg4);\n-            Set_Exported (Def_Id, Arg2);\n+            Process_Interface_Name (E, Arg3, Arg4);\n+            Set_Exported (E, Arg2);\n          end External;\n \n          --------------------------\n@@ -14003,20 +14198,25 @@ package body Sem_Prag is\n          --  pragma Favor_Top_Level (type_NAME);\n \n          when Pragma_Favor_Top_Level => Favor_Top_Level : declare\n-               Named_Entity : Entity_Id;\n+            Typ : Entity_Id;\n \n          begin\n             GNAT_Pragma;\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Check_Arg_Is_Local_Name (Arg1);\n-            Named_Entity := Entity (Get_Pragma_Arg (Arg1));\n+            Typ := Entity (Get_Pragma_Arg (Arg1));\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Typ);\n \n             --  If it's an access-to-subprogram type (in particular, not a\n             --  subtype), set the flag on that type.\n \n-            if Is_Access_Subprogram_Type (Named_Entity) then\n-               Set_Can_Use_Internal_Rep (Named_Entity, False);\n+            if Is_Access_Subprogram_Type (Typ) then\n+               Set_Can_Use_Internal_Rep (Typ, False);\n \n             --  Otherwise it's an error (name denotes the wrong sort of entity)\n \n@@ -14110,6 +14310,7 @@ package body Sem_Prag is\n                   end if;\n \n                --  Protected and task types cannot be subject to pragma Ghost\n+               --  (SPARK RM 6.9(19)).\n \n                elsif Nkind (Stmt) = N_Protected_Type_Declaration then\n                   Error_Pragma (\"pragma % cannot apply to a protected type\");\n@@ -14248,6 +14449,19 @@ package body Sem_Prag is\n                      return;\n                   end if;\n                end if;\n+\n+            --  A synchronized object cannot be subject to pragma Ghost\n+            --  (SPARK RM 6.9(19)).\n+\n+            elsif Ekind (Id) = E_Variable then\n+               if Is_Protected_Type (Etype (Id)) then\n+                  Error_Pragma (\"pragma % cannot apply to a protected object\");\n+                  return;\n+\n+               elsif Is_Task_Type (Etype (Id)) then\n+                  Error_Pragma (\"pragma % cannot apply to a task object\");\n+                  return;\n+               end if;\n             end if;\n \n             --  Analyze the Boolean expression (if any)\n@@ -14815,11 +15029,11 @@ package body Sem_Prag is\n          --  pragma Independent_Components (array_or_record_LOCAL_NAME);\n \n          when Pragma_Independent_Components => Independent_Components : declare\n+            C    : Node_Id;\n+            D    : Node_Id;\n             E_Id : Node_Id;\n             E    : Entity_Id;\n-            D    : Node_Id;\n             K    : Node_Kind;\n-            C    : Node_Id;\n \n          begin\n             Check_Ada_83_Warning;\n@@ -14835,6 +15049,11 @@ package body Sem_Prag is\n \n             E := Entity (E_Id);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, E);\n+\n             --  Check duplicate before we chain ourselves\n \n             Check_Duplicate_Pragma (E);\n@@ -14944,6 +15163,11 @@ package body Sem_Prag is\n \n             Pack_Id := Defining_Entity (Pack_Decl);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Pack_Id);\n+\n             --  Verify the declaration order of pragma Initial_Condition with\n             --  respect to pragmas Abstract_State and Initializes when SPARK\n             --  checks are enabled.\n@@ -15055,6 +15279,10 @@ package body Sem_Prag is\n \n             Pack_Id := Defining_Entity (Pack_Decl);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Pack_Id);\n             Ensure_Aggregate_Form (Get_Argument (N, Pack_Id));\n \n             --  Verify the declaration order of pragmas Abstract_State and\n@@ -15512,9 +15740,10 @@ package body Sem_Prag is\n          --     [,[Message =>] String_Expression]);\n \n          when Pragma_Invariant => Invariant : declare\n-            Type_Id : Node_Id;\n-            Typ     : Entity_Id;\n+            GM      : constant Ghost_Mode_Type := Ghost_Mode;\n             Discard : Boolean;\n+            Typ     : Entity_Id;\n+            Type_Id : Node_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -15569,6 +15798,11 @@ package body Sem_Prag is\n                  (\"pragma% only allowed for private type\", Arg1);\n             end if;\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Typ);\n+\n             --  Not allowed for abstract type in the non-class case (it is\n             --  allowed to use Invariant'Class for abstract types).\n \n@@ -15577,6 +15811,11 @@ package body Sem_Prag is\n                  (\"pragma% not allowed for abstract type\", Arg1);\n             end if;\n \n+            --  Link the pragma on to the rep item chain, for processing when\n+            --  the type is frozen.\n+\n+            Discard := Rep_Item_Too_Late (Typ, N, FOnly => True);\n+\n             --  Note that the type has at least one invariant, and also that\n             --  it has inheritable invariants if we have Invariant'Class\n             --  or Type_Invariant'Class. Build the corresponding invariant\n@@ -15596,11 +15835,10 @@ package body Sem_Prag is\n                Set_Has_Inheritable_Invariants (Typ);\n             end if;\n \n-            --  The remaining processing is simply to link the pragma on to\n-            --  the rep item chain, for processing when the type is frozen.\n-            --  This is accomplished by a call to Rep_Item_Too_Late.\n+            --  Restore the original Ghost mode once analysis and expansion\n+            --  have taken place.\n \n-            Discard := Rep_Item_Too_Late (Typ, N, FOnly => True);\n+            Ghost_Mode := GM;\n          end Invariant;\n \n          ----------------------\n@@ -16197,14 +16435,22 @@ package body Sem_Prag is\n          --------------------\n \n          --  pragma Linker_Section (\n-         --      [Entity  =>]  LOCAL_NAME\n-         --      [Section =>]  static_string_EXPRESSION);\n+         --      [Entity  =>] LOCAL_NAME\n+         --      [Section =>] static_string_EXPRESSION);\n \n          when Pragma_Linker_Section => Linker_Section : declare\n             Arg : Node_Id;\n             Ent : Entity_Id;\n             LPE : Node_Id;\n \n+            Ghost_Error_Posted : Boolean := False;\n+            --  Flag set when an error concerning the illegal mix of Ghost and\n+            --  non-Ghost subprograms is emitted.\n+\n+            Ghost_Id : Entity_Id := Empty;\n+            --  The entity of the first Ghost subprogram encountered while\n+            --  processing the arguments of the pragma.\n+\n          begin\n             GNAT_Pragma;\n             Check_Arg_Order ((Name_Entity, Name_Section));\n@@ -16236,6 +16482,12 @@ package body Sem_Prag is\n \n                   Set_Linker_Section_Pragma (Ent, N);\n \n+                  --  A pragma that applies to a Ghost entity becomes Ghost for\n+                  --  the purposes of legality checks and removal of ignored\n+                  --  Ghost code.\n+\n+                  Mark_Pragma_As_Ghost (N, Ent);\n+\n                --  Subprograms\n \n                when Subprogram_Kind =>\n@@ -16253,6 +16505,43 @@ package body Sem_Prag is\n                      loop\n                         if No (Linker_Section_Pragma (Ent)) then\n                            Set_Linker_Section_Pragma (Ent, N);\n+\n+                           --  A pragma that applies to a Ghost entity becomes\n+                           --  Ghost for the purposes of legality checks and\n+                           --  removal of ignored Ghost code.\n+\n+                           Mark_Pragma_As_Ghost (N, Ent);\n+\n+                           --  Capture the entity of the first Ghost subprogram\n+                           --  being processed for error detection purposes.\n+\n+                           if Is_Ghost_Entity (Ent) then\n+                              if No (Ghost_Id) then\n+                                 Ghost_Id := Ent;\n+                              end if;\n+\n+                           --  Otherwise the subprogram is non-Ghost. It is\n+                           --  illegal to mix references to Ghost and non-Ghost\n+                           --  entities (SPARK RM 6.9).\n+\n+                           elsif Present (Ghost_Id)\n+                             and then not Ghost_Error_Posted\n+                           then\n+                              Ghost_Error_Posted := True;\n+\n+                              Error_Msg_Name_1 := Pname;\n+                              Error_Msg_N\n+                                (\"pragma % cannot mention ghost and \"\n+                                 & \"non-ghost subprograms\", N);\n+\n+                              Error_Msg_Sloc := Sloc (Ghost_Id);\n+                              Error_Msg_NE\n+                                (\"\\& # declared as ghost\", N, Ghost_Id);\n+\n+                              Error_Msg_Sloc := Sloc (Ent);\n+                              Error_Msg_NE\n+                                (\"\\& # declared as non-ghost\", N, Ent);\n+                           end if;\n                         end if;\n \n                         Ent := Homonym (Ent);\n@@ -16624,8 +16913,7 @@ package body Sem_Prag is\n \n          --  pragma No_Elaboration_Code_All;\n \n-         when Pragma_No_Elaboration_Code_All => NECA : declare\n-         begin\n+         when Pragma_No_Elaboration_Code_All =>\n             GNAT_Pragma;\n             Check_Valid_Library_Unit_Pragma;\n \n@@ -16672,7 +16960,6 @@ package body Sem_Prag is\n             if In_Extended_Main_Source_Unit (N) then\n                Opt.No_Elab_Code_All_Pragma := N;\n             end if;\n-         end NECA;\n \n          ---------------\n          -- No_Inline --\n@@ -16691,10 +16978,18 @@ package body Sem_Prag is\n          --  pragma No_Return (procedure_LOCAL_NAME {, procedure_Local_Name});\n \n          when Pragma_No_Return => No_Return : declare\n-            Id    : Node_Id;\n+            Arg   : Node_Id;\n             E     : Entity_Id;\n             Found : Boolean;\n-            Arg   : Node_Id;\n+            Id    : Node_Id;\n+\n+            Ghost_Error_Posted : Boolean := False;\n+            --  Flag set when an error concerning the illegal mix of Ghost and\n+            --  non-Ghost subprograms is emitted.\n+\n+            Ghost_Id : Entity_Id := Empty;\n+            --  The entity of the first Ghost procedure encountered while\n+            --  processing the arguments of the pragma.\n \n          begin\n             Ada_2005_Pragma;\n@@ -16719,13 +17014,49 @@ package body Sem_Prag is\n                --  Loop to find matching procedures\n \n                E := Entity (Id);\n+\n                Found := False;\n                while Present (E)\n                  and then Scope (E) = Current_Scope\n                loop\n                   if Ekind_In (E, E_Procedure, E_Generic_Procedure) then\n                      Set_No_Return (E);\n \n+                     --  A pragma that applies to a Ghost entity becomes Ghost\n+                     --  for the purposes of legality checks and removal of\n+                     --  ignored Ghost code.\n+\n+                     Mark_Pragma_As_Ghost (N, E);\n+\n+                     --  Capture the entity of the first Ghost procedure being\n+                     --  processed for error detection purposes.\n+\n+                     if Is_Ghost_Entity (E) then\n+                        if No (Ghost_Id) then\n+                           Ghost_Id := E;\n+                        end if;\n+\n+                     --  Otherwise the subprogram is non-Ghost. It is illegal\n+                     --  to mix references to Ghost and non-Ghost entities\n+                     --  (SPARK RM 6.9).\n+\n+                     elsif Present (Ghost_Id)\n+                       and then not Ghost_Error_Posted\n+                     then\n+                        Ghost_Error_Posted := True;\n+\n+                        Error_Msg_Name_1 := Pname;\n+                        Error_Msg_N\n+                          (\"pragma % cannot mention ghost and non-ghost \"\n+                           & \"procedures\", N);\n+\n+                        Error_Msg_Sloc := Sloc (Ghost_Id);\n+                        Error_Msg_NE (\"\\& # declared as ghost\", N, Ghost_Id);\n+\n+                        Error_Msg_Sloc := Sloc (E);\n+                        Error_Msg_NE (\"\\& # declared as non-ghost\", N, E);\n+                     end if;\n+\n                      --  Set flag on any alias as well\n \n                      if Is_Overloadable (E) and then Present (Alias (E)) then\n@@ -16794,8 +17125,8 @@ package body Sem_Prag is\n             --  pragma No_Tagged_Streams ([Entity => ]tagged_type_local_NAME);\n \n          when Pragma_No_Tagged_Streams => No_Tagged_Strms : declare\n-            E_Id : Node_Id;\n             E    : Entity_Id;\n+            E_Id : Node_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -16906,8 +17237,8 @@ package body Sem_Prag is\n          --  [,[Version =>] Ada_05]] );\n \n          when Pragma_Obsolescent => Obsolescent : declare\n-            Ename : Node_Id;\n             Decl  : Node_Id;\n+            Ename : Node_Id;\n \n             procedure Set_Obsolescent (E : Entity_Id);\n             --  Given an entity Ent, mark it as obsolescent if appropriate\n@@ -16925,6 +17256,12 @@ package body Sem_Prag is\n                Active := True;\n                Ent    := E;\n \n+               --  A pragma that applies to a Ghost entity becomes Ghost for\n+               --  the purposes of legality checks and removal of ignored Ghost\n+               --  code.\n+\n+               Mark_Pragma_As_Ghost (N, E);\n+\n                --  Entity name was given\n \n                if Present (Ename) then\n@@ -17295,10 +17632,10 @@ package body Sem_Prag is\n \n          when Pragma_Pack => Pack : declare\n             Assoc   : constant Node_Id := Arg1;\n-            Type_Id : Node_Id;\n-            Typ     : Entity_Id;\n             Ctyp    : Entity_Id;\n             Ignore  : Boolean := False;\n+            Typ     : Entity_Id;\n+            Type_Id : Node_Id;\n \n          begin\n             Check_No_Identifiers;\n@@ -17324,6 +17661,11 @@ package body Sem_Prag is\n                Typ := Underlying_Type (Typ);\n             end if;\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Typ);\n+\n             if not Is_Array_Type (Typ) and then not Is_Record_Type (Typ) then\n                Error_Pragma (\"pragma% must specify array or record type\");\n             end if;\n@@ -17581,6 +17923,11 @@ package body Sem_Prag is\n             Item_Id := Defining_Entity (Stmt);\n             State   := Get_Pragma_Arg  (Arg1);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Item_Id);\n+\n             --  Detect any discrepancies between the placement of the object\n             --  or package instantiation with respect to state space and the\n             --  encapsulating state.\n@@ -17703,6 +18050,11 @@ package body Sem_Prag is\n             Check_First_Subtype (Arg1);\n             Ent := Entity (Get_Pragma_Arg (Arg1));\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Ent);\n+\n             --  The pragma may come from an aspect on a private declaration,\n             --  even if the freeze point at which this is analyzed in the\n             --  private part after the full view.\n@@ -17791,6 +18143,12 @@ package body Sem_Prag is\n                Ent := Entity (Get_Pragma_Arg (Arg1));\n                Decl := Parent (Ent);\n \n+               --  A pragma that applies to a Ghost entity becomes Ghost for\n+               --  the purposes of legality checks and removal of ignored Ghost\n+               --  code.\n+\n+               Mark_Pragma_As_Ghost (N, Ent);\n+\n                --  Check for duplication before inserting in list of\n                --  representation items.\n \n@@ -17939,9 +18297,9 @@ package body Sem_Prag is\n          --     [Check  =>] boolean_EXPRESSION);\n \n          when Pragma_Predicate => Predicate : declare\n-            Type_Id : Node_Id;\n-            Typ     : Entity_Id;\n             Discard : Boolean;\n+            Typ     : Entity_Id;\n+            Type_Id : Node_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -17959,6 +18317,11 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Typ);\n+\n             --  The remaining processing is simply to link the pragma on to\n             --  the rep item chain, for processing when the type is frozen.\n             --  This is accomplished by a call to Rep_Item_Too_Late. We also\n@@ -17990,6 +18353,11 @@ package body Sem_Prag is\n             end if;\n \n             Ent := Find_Lib_Unit_Name;\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Ent);\n             Check_Duplicate_Pragma (Ent);\n \n             --  This filters out pragmas inside generic parents that show up\n@@ -18616,6 +18984,11 @@ package body Sem_Prag is\n             end if;\n \n             Ent := Find_Lib_Unit_Name;\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Ent);\n             Set_Is_Pure (Ent);\n             Set_Has_Pragma_Pure (Ent);\n             Set_Suppress_Elaboration_Warnings (Ent);\n@@ -18628,9 +19001,9 @@ package body Sem_Prag is\n          --  pragma Pure_Function ([Entity =>] function_LOCAL_NAME);\n \n          when Pragma_Pure_Function => Pure_Function : declare\n-            E_Id      : Node_Id;\n-            E         : Entity_Id;\n             Def_Id    : Entity_Id;\n+            E         : Entity_Id;\n+            E_Id      : Node_Id;\n             Effective : Boolean := False;\n \n          begin\n@@ -18648,6 +19021,11 @@ package body Sem_Prag is\n \n             E := Entity (E_Id);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, E);\n+\n             if Present (E) then\n                loop\n                   Def_Id := Get_Base_Subprogram (E);\n@@ -18917,6 +19295,11 @@ package body Sem_Prag is\n \n             Spec_Id := Corresponding_Spec (Pack_Decl);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Spec_Id);\n+\n             --  State refinement is allowed only when the corresponding package\n             --  declaration has non-null pragma Abstract_State. Refinement not\n             --  enforced when SPARK checks are suppressed (SPARK RM 7.2.2(3)).\n@@ -18982,7 +19365,7 @@ package body Sem_Prag is\n             --  Item chain of Ent since it is rewritten by the expander as a\n             --  procedure call statement that will break the chain.\n \n-            Set_Has_Relative_Deadline_Pragma (P, True);\n+            Set_Has_Relative_Deadline_Pragma (P);\n          end Relative_Deadline;\n \n          ------------------------\n@@ -19002,6 +19385,11 @@ package body Sem_Prag is\n \n             E := Entity (Get_Pragma_Arg (Arg1));\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, E);\n+\n             if Nkind (Parent (E)) = N_Formal_Type_Declaration\n               and then Ekind (E) = E_General_Access_Type\n               and then Is_Class_Wide_Type (Directly_Designated_Type (E))\n@@ -19042,6 +19430,11 @@ package body Sem_Prag is\n             K          := Nkind (Unit (Cunit_Node));\n             Cunit_Ent  := Cunit_Entity (Current_Sem_Unit);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Cunit_Ent);\n+\n             if K = N_Package_Declaration\n               or else K = N_Generic_Package_Declaration\n               or else K = N_Subprogram_Declaration\n@@ -19079,6 +19472,11 @@ package body Sem_Prag is\n             Cunit_Node := Cunit (Current_Sem_Unit);\n             Cunit_Ent  := Cunit_Entity (Current_Sem_Unit);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Cunit_Ent);\n+\n             if not Nkind_In (Unit (Cunit_Node), N_Package_Declaration,\n                                                 N_Generic_Package_Declaration)\n             then\n@@ -19231,6 +19629,11 @@ package body Sem_Prag is\n             Cunit_Node := Cunit (Current_Sem_Unit);\n             Cunit_Ent  := Cunit_Entity (Current_Sem_Unit);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Cunit_Ent);\n+\n             if not Nkind_In (Unit (Cunit_Node), N_Package_Declaration,\n                                                 N_Generic_Package_Declaration)\n             then\n@@ -19262,8 +19665,8 @@ package body Sem_Prag is\n \n          when Pragma_Simple_Storage_Pool_Type =>\n          Simple_Storage_Pool_Type : declare\n-            Type_Id : Node_Id;\n             Typ     : Entity_Id;\n+            Type_Id : Node_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -19278,6 +19681,11 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Typ);\n+\n             --  We require the pragma to apply to a type declared in a package\n             --  declaration, but not (immediately) within a package body.\n \n@@ -20195,12 +20603,23 @@ package body Sem_Prag is\n \n          --  pragma Suppress_Debug_Info ([Entity =>] LOCAL_NAME);\n \n-         when Pragma_Suppress_Debug_Info =>\n+         when Pragma_Suppress_Debug_Info => Suppress_Debug_Info : declare\n+            Nam_Id : Entity_Id;\n+\n+         begin\n             GNAT_Pragma;\n             Check_Arg_Count (1);\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n-            Set_Debug_Info_Off (Entity (Get_Pragma_Arg (Arg1)));\n+\n+            Nam_Id := Entity (Get_Pragma_Arg (Arg1));\n+\n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Nam_Id);\n+            Set_Debug_Info_Off (Nam_Id);\n+         end Suppress_Debug_Info;\n \n          ----------------------------------\n          -- Suppress_Exception_Locations --\n@@ -20221,8 +20640,8 @@ package body Sem_Prag is\n          --  pragma Suppress_Initialization ([Entity =>] type_Name);\n \n          when Pragma_Suppress_Initialization => Suppress_Init : declare\n-            E_Id : Node_Id;\n             E    : Entity_Id;\n+            E_Id : Node_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -20238,6 +20657,11 @@ package body Sem_Prag is\n \n             E := Entity (E_Id);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, E);\n+\n             if not Is_Type (E) and then Ekind (E) /= E_Variable then\n                Error_Pragma_Arg\n                  (\"pragma% requires variable, type or subtype\", Arg1);\n@@ -20631,6 +21055,11 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Subp_Id);\n+\n             --  Preanalyze the original aspect argument \"Name\" for ASIS or for\n             --  a generic subprogram to properly capture global references.\n \n@@ -20678,8 +21107,8 @@ package body Sem_Prag is\n          --  pragma Thread_Local_Storage ([Entity =>] LOCAL_NAME);\n \n          when Pragma_Thread_Local_Storage => Thread_Local_Storage : declare\n-            Id : Node_Id;\n             E  : Entity_Id;\n+            Id : Node_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -20698,8 +21127,14 @@ package body Sem_Prag is\n \n             E := Entity (Id);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, E);\n+\n             if Rep_Item_Too_Early (E, N)\n-              or else Rep_Item_Too_Late (E, N)\n+                 or else\n+               Rep_Item_Too_Late (E, N)\n             then\n                raise Pragma_Exit;\n             end if;\n@@ -20824,12 +21259,12 @@ package body Sem_Prag is\n          when Pragma_Unchecked_Union => Unchecked_Union : declare\n             Assoc   : constant Node_Id := Arg1;\n             Type_Id : constant Node_Id := Get_Pragma_Arg (Assoc);\n-            Typ     : Entity_Id;\n-            Tdef    : Node_Id;\n             Clist   : Node_Id;\n-            Vpart   : Node_Id;\n             Comp    : Node_Id;\n+            Tdef    : Node_Id;\n+            Typ     : Entity_Id;\n             Variant : Node_Id;\n+            Vpart   : Node_Id;\n \n          begin\n             Ada_2005_Pragma;\n@@ -20841,6 +21276,11 @@ package body Sem_Prag is\n \n             Typ := Entity (Type_Id);\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, Typ);\n+\n             if Typ = Any_Type\n               or else Rep_Item_Too_Early (Typ, N)\n             then\n@@ -20869,7 +21309,7 @@ package body Sem_Prag is\n \n             elsif not Has_Discriminants (Typ) then\n                Error_Msg_N\n-                (\"unchecked union must have one discriminant\", Typ);\n+                 (\"unchecked union must have one discriminant\", Typ);\n                return;\n \n             --  Note: in previous versions of GNAT we used to check for limited\n@@ -20974,6 +21414,10 @@ package body Sem_Prag is\n                Error_Pragma_Arg (\"pragma% requires type\", Arg1);\n             end if;\n \n+            --  A pragma that applies to a Ghost entity becomes Ghost for the\n+            --  purposes of legality checks and removal of ignored Ghost code.\n+\n+            Mark_Pragma_As_Ghost (N, E_Id);\n             Set_Universal_Aliasing (Implementation_Base_Type (E_Id));\n             Record_Rep_Item (E_Id, N);\n          end Universal_Alias;\n@@ -21010,19 +21454,27 @@ package body Sem_Prag is\n          --  pragma Unmodified (LOCAL_NAME {, LOCAL_NAME});\n \n          when Pragma_Unmodified => Unmodified : declare\n-            Arg_Node : Node_Id;\n+            Arg      : Node_Id;\n             Arg_Expr : Node_Id;\n-            Arg_Ent  : Entity_Id;\n+            Arg_Id   : Entity_Id;\n+\n+            Ghost_Error_Posted : Boolean := False;\n+            --  Flag set when an error concerning the illegal mix of Ghost and\n+            --  non-Ghost variables is emitted.\n+\n+            Ghost_Id : Entity_Id := Empty;\n+            --  The entity of the first Ghost variable encountered while\n+            --  processing the arguments of the pragma.\n \n          begin\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (1);\n \n             --  Loop through arguments\n \n-            Arg_Node := Arg1;\n-            while Present (Arg_Node) loop\n-               Check_No_Identifier (Arg_Node);\n+            Arg := Arg1;\n+            while Present (Arg) loop\n+               Check_No_Identifier (Arg);\n \n                --  Note: the analyze call done by Check_Arg_Is_Local_Name will\n                --  in fact generate reference, so that the entity will have a\n@@ -21032,22 +21484,59 @@ package body Sem_Prag is\n                --  Has_Pragma_Unreferenced flag is set, so that no warning is\n                --  generated for this reference.\n \n-               Check_Arg_Is_Local_Name (Arg_Node);\n-               Arg_Expr := Get_Pragma_Arg (Arg_Node);\n+               Check_Arg_Is_Local_Name (Arg);\n+               Arg_Expr := Get_Pragma_Arg (Arg);\n \n                if Is_Entity_Name (Arg_Expr) then\n-                  Arg_Ent := Entity (Arg_Expr);\n+                  Arg_Id := Entity (Arg_Expr);\n+\n+                  if Is_Assignable (Arg_Id) then\n+                     Set_Has_Pragma_Unmodified (Arg_Id);\n+\n+                     --  A pragma that applies to a Ghost entity becomes Ghost\n+                     --  for the purposes of legality checks and removal of\n+                     --  ignored Ghost code.\n+\n+                     Mark_Pragma_As_Ghost (N, Arg_Id);\n+\n+                     --  Capture the entity of the first Ghost variable being\n+                     --  processed for error detection purposes.\n+\n+                     if Is_Ghost_Entity (Arg_Id) then\n+                        if No (Ghost_Id) then\n+                           Ghost_Id := Arg_Id;\n+                        end if;\n+\n+                     --  Otherwise the variable is non-Ghost. It is illegal\n+                     --  to mix references to Ghost and non-Ghost entities\n+                     --  (SPARK RM 6.9).\n+\n+                     elsif Present (Ghost_Id)\n+                       and then not Ghost_Error_Posted\n+                     then\n+                        Ghost_Error_Posted := True;\n+\n+                        Error_Msg_Name_1 := Pname;\n+                        Error_Msg_N\n+                          (\"pragma % cannot mention ghost and non-ghost \"\n+                           & \"variables\", N);\n+\n+                        Error_Msg_Sloc := Sloc (Ghost_Id);\n+                        Error_Msg_NE (\"\\& # declared as ghost\", N, Ghost_Id);\n+\n+                        Error_Msg_Sloc := Sloc (Arg_Id);\n+                        Error_Msg_NE (\"\\& # declared as non-ghost\", N, Arg_Id);\n+                     end if;\n+\n+                  --  Otherwise the pragma referenced an illegal entity\n \n-                  if not Is_Assignable (Arg_Ent) then\n-                     Error_Pragma_Arg\n-                       (\"pragma% can only be applied to a variable\",\n-                        Arg_Expr);\n                   else\n-                     Set_Has_Pragma_Unmodified (Arg_Ent);\n+                     Error_Pragma_Arg\n+                       (\"pragma% can only be applied to a variable\", Arg_Expr);\n                   end if;\n                end if;\n \n-               Next (Arg_Node);\n+               Next (Arg);\n             end loop;\n          end Unmodified;\n \n@@ -21062,11 +21551,19 @@ package body Sem_Prag is\n          --  pragma Unreferenced (library_unit_NAME {, library_unit_NAME}\n \n          when Pragma_Unreferenced => Unreferenced : declare\n-            Arg_Node : Node_Id;\n+            Arg      : Node_Id;\n             Arg_Expr : Node_Id;\n-            Arg_Ent  : Entity_Id;\n+            Arg_Id   : Entity_Id;\n             Citem    : Node_Id;\n \n+            Ghost_Error_Posted : Boolean := False;\n+            --  Flag set when an error concerning the illegal mix of Ghost and\n+            --  non-Ghost names is emitted.\n+\n+            Ghost_Id : Entity_Id := Empty;\n+            --  The entity of the first Ghost name encountered while processing\n+            --  the arguments of the pragma.\n+\n          begin\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (1);\n@@ -21080,20 +21577,20 @@ package body Sem_Prag is\n                --  Par.Prag) that the arguments are either identifiers or\n                --  selected components.\n \n-               Arg_Node := Arg1;\n-               while Present (Arg_Node) loop\n+               Arg := Arg1;\n+               while Present (Arg) loop\n                   Citem := First (List_Containing (N));\n                   while Citem /= N loop\n+                     Arg_Expr := Get_Pragma_Arg (Arg);\n+\n                      if Nkind (Citem) = N_With_Clause\n-                       and then\n-                         Same_Name (Name (Citem), Get_Pragma_Arg (Arg_Node))\n+                       and then Same_Name (Name (Citem), Arg_Expr)\n                      then\n                         Set_Has_Pragma_Unreferenced\n                           (Cunit_Entity\n                              (Get_Source_Unit\n                                 (Library_Unit (Citem))));\n-                        Set_Elab_Unit_Name\n-                          (Get_Pragma_Arg (Arg_Node), Name (Citem));\n+                        Set_Elab_Unit_Name (Arg_Expr, Name (Citem));\n                         exit;\n                      end if;\n \n@@ -21102,18 +21599,18 @@ package body Sem_Prag is\n \n                   if Citem = N then\n                      Error_Pragma_Arg\n-                       (\"argument of pragma% is not withed unit\", Arg_Node);\n+                       (\"argument of pragma% is not withed unit\", Arg);\n                   end if;\n \n-                  Next (Arg_Node);\n+                  Next (Arg);\n                end loop;\n \n             --  Case of not in list of context items\n \n             else\n-               Arg_Node := Arg1;\n-               while Present (Arg_Node) loop\n-                  Check_No_Identifier (Arg_Node);\n+               Arg := Arg1;\n+               while Present (Arg) loop\n+                  Check_No_Identifier (Arg);\n \n                   --  Note: the analyze call done by Check_Arg_Is_Local_Name\n                   --  will in fact generate reference, so that the entity will\n@@ -21123,25 +21620,60 @@ package body Sem_Prag is\n                   --  before the Has_Pragma_Unreferenced flag is set, so that\n                   --  no warning is generated for this reference.\n \n-                  Check_Arg_Is_Local_Name (Arg_Node);\n-                  Arg_Expr := Get_Pragma_Arg (Arg_Node);\n+                  Check_Arg_Is_Local_Name (Arg);\n+                  Arg_Expr := Get_Pragma_Arg (Arg);\n \n                   if Is_Entity_Name (Arg_Expr) then\n-                     Arg_Ent := Entity (Arg_Expr);\n+                     Arg_Id := Entity (Arg_Expr);\n \n                      --  If the entity is overloaded, the pragma applies to the\n                      --  most recent overloading, as documented. In this case,\n                      --  name resolution does not generate a reference, so it\n                      --  must be done here explicitly.\n \n                      if Is_Overloaded (Arg_Expr) then\n-                        Generate_Reference (Arg_Ent, N);\n+                        Generate_Reference (Arg_Id, N);\n                      end if;\n \n-                     Set_Has_Pragma_Unreferenced (Arg_Ent);\n+                     Set_Has_Pragma_Unreferenced (Arg_Id);\n+\n+                     --  A pragma that applies to a Ghost entity becomes Ghost\n+                     --  for the purposes of legality checks and removal of\n+                     --  ignored Ghost code.\n+\n+                     Mark_Pragma_As_Ghost (N, Arg_Id);\n+\n+                     --  Capture the entity of the first Ghost name being\n+                     --  processed for error detection purposes.\n+\n+                     if Is_Ghost_Entity (Arg_Id) then\n+                        if No (Ghost_Id) then\n+                           Ghost_Id := Arg_Id;\n+                        end if;\n+\n+                     --  Otherwise the name is non-Ghost. It is illegal to mix\n+                     --  references to Ghost and non-Ghost entities\n+                     --  (SPARK RM 6.9).\n+\n+                     elsif Present (Ghost_Id)\n+                       and then not Ghost_Error_Posted\n+                     then\n+                        Ghost_Error_Posted := True;\n+\n+                        Error_Msg_Name_1 := Pname;\n+                        Error_Msg_N\n+                          (\"pragma % cannot mention ghost and non-ghost names\",\n+                           N);\n+\n+                        Error_Msg_Sloc := Sloc (Ghost_Id);\n+                        Error_Msg_NE (\"\\& # declared as ghost\", N, Ghost_Id);\n+\n+                        Error_Msg_Sloc := Sloc (Arg_Id);\n+                        Error_Msg_NE (\"\\& # declared as non-ghost\", N, Arg_Id);\n+                     end if;\n                   end if;\n \n-                  Next (Arg_Node);\n+                  Next (Arg);\n                end loop;\n             end if;\n          end Unreferenced;\n@@ -21153,28 +21685,78 @@ package body Sem_Prag is\n          --  pragma Unreferenced_Objects (LOCAL_NAME {, LOCAL_NAME});\n \n          when Pragma_Unreferenced_Objects => Unreferenced_Objects : declare\n-            Arg_Node : Node_Id;\n+            Arg      : Node_Id;\n             Arg_Expr : Node_Id;\n+            Arg_Id   : Entity_Id;\n+\n+            Ghost_Error_Posted : Boolean := False;\n+            --  Flag set when an error concerning the illegal mix of Ghost and\n+            --  non-Ghost types is emitted.\n+\n+            Ghost_Id : Entity_Id := Empty;\n+            --  The entity of the first Ghost type encountered while processing\n+            --  the arguments of the pragma.\n \n          begin\n             GNAT_Pragma;\n             Check_At_Least_N_Arguments (1);\n \n-            Arg_Node := Arg1;\n-            while Present (Arg_Node) loop\n-               Check_No_Identifier (Arg_Node);\n-               Check_Arg_Is_Local_Name (Arg_Node);\n-               Arg_Expr := Get_Pragma_Arg (Arg_Node);\n+            Arg := Arg1;\n+            while Present (Arg) loop\n+               Check_No_Identifier (Arg);\n+               Check_Arg_Is_Local_Name (Arg);\n+               Arg_Expr := Get_Pragma_Arg (Arg);\n+\n+               if Is_Entity_Name (Arg_Expr) then\n+                  Arg_Id := Entity (Arg_Expr);\n \n-               if not Is_Entity_Name (Arg_Expr)\n-                 or else not Is_Type (Entity (Arg_Expr))\n-               then\n+                  if Is_Type (Arg_Id) then\n+                     Set_Has_Pragma_Unreferenced_Objects (Arg_Id);\n+\n+                     --  A pragma that applies to a Ghost entity becomes Ghost\n+                     --  for the purposes of legality checks and removal of\n+                     --  ignored Ghost code.\n+\n+                     Mark_Pragma_As_Ghost (N, Arg_Id);\n+\n+                     --  Capture the entity of the first Ghost type being\n+                     --  processed for error detection purposes.\n+\n+                     if Is_Ghost_Entity (Arg_Id) then\n+                        if No (Ghost_Id) then\n+                           Ghost_Id := Arg_Id;\n+                        end if;\n+\n+                     --  Otherwise the type is non-Ghost. It is illegal to mix\n+                     --  references to Ghost and non-Ghost entities\n+                     --  (SPARK RM 6.9).\n+\n+                     elsif Present (Ghost_Id)\n+                       and then not Ghost_Error_Posted\n+                     then\n+                        Ghost_Error_Posted := True;\n+\n+                        Error_Msg_Name_1 := Pname;\n+                        Error_Msg_N\n+                          (\"pragma % cannot mention ghost and non-ghost types\",\n+                           N);\n+\n+                        Error_Msg_Sloc := Sloc (Ghost_Id);\n+                        Error_Msg_NE (\"\\& # declared as ghost\", N, Ghost_Id);\n+\n+                        Error_Msg_Sloc := Sloc (Arg_Id);\n+                        Error_Msg_NE (\"\\& # declared as non-ghost\", N, Arg_Id);\n+                     end if;\n+                  else\n+                     Error_Pragma_Arg\n+                       (\"argument for pragma% must be type or subtype\", Arg);\n+                  end if;\n+               else\n                   Error_Pragma_Arg\n-                    (\"argument for pragma% must be type or subtype\", Arg_Node);\n+                    (\"argument for pragma% must be type or subtype\", Arg);\n                end if;\n \n-               Set_Has_Pragma_Unreferenced_Objects (Entity (Arg_Expr));\n-               Next (Arg_Node);\n+               Next (Arg);\n             end loop;\n          end Unreferenced_Objects;\n \n@@ -21320,7 +21902,7 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             Process_Atomic_Independent_Shared_Volatile;\n \n-            -------------------------\n+         -------------------------\n          -- Volatile_Components --\n          -------------------------\n \n@@ -21909,6 +22491,7 @@ package body Sem_Prag is\n \n       --  Local variables\n \n+      GM        : constant Ghost_Mode_Type := Ghost_Mode;\n       Subp_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n       Spec_Id   : constant Entity_Id := Corresponding_Spec_Of (Subp_Decl);\n       Expr      : constant Node_Id   := Expression (Get_Argument (N, Spec_Id));\n@@ -21918,6 +22501,13 @@ package body Sem_Prag is\n    --  Start of processing for Analyze_Pre_Post_Condition_In_Decl_Part\n \n    begin\n+      --  Set the Ghost mode in effect from the pragma. Due to the delayed\n+      --  analysis of the pragma, the Ghost mode at point of declaration and\n+      --  point of analysis may not necessarely be the same. Use the mode in\n+      --  effect at the point of declaration.\n+\n+      Set_Ghost_Mode (N);\n+\n       --  Ensure that the subprogram and its formals are visible when analyzing\n       --  the expression of the pragma.\n \n@@ -21951,6 +22541,11 @@ package body Sem_Prag is\n       --  subprogram subject to pragma Inline_Always.\n \n       Check_Postcondition_Use_In_Inlined_Subprogram (N, Spec_Id);\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Analyze_Pre_Post_Condition_In_Decl_Part;\n \n    ------------------------------------------"}, {"sha": "52f6935f8e6400d91ed4551aaa705767f0c83a11", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 131, "deletions": 21, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -33,31 +33,122 @@ with Types;  use Types;\n \n package Sem_Prag is\n \n+   --  The following table lists all pragmas that emulate an Ada 2012 aspect\n+\n+   Aspect_Specifying_Pragma : constant array (Pragma_Id) of Boolean :=\n+     (Pragma_Abstract_State               => True,\n+      Pragma_All_Calls_Remote             => True,\n+      Pragma_Annotate                     => True,\n+      Pragma_Async_Readers                => True,\n+      Pragma_Async_Writers                => True,\n+      Pragma_Asynchronous                 => True,\n+      Pragma_Atomic                       => True,\n+      Pragma_Atomic_Components            => True,\n+      Pragma_Attach_Handler               => True,\n+      Pragma_Contract_Cases               => True,\n+      Pragma_Convention                   => True,\n+      Pragma_CPU                          => True,\n+      Pragma_Default_Initial_Condition    => True,\n+      Pragma_Default_Storage_Pool         => True,\n+      Pragma_Depends                      => True,\n+      Pragma_Discard_Names                => True,\n+      Pragma_Dispatching_Domain           => True,\n+      Pragma_Effective_Reads              => True,\n+      Pragma_Effective_Writes             => True,\n+      Pragma_Elaborate_Body               => True,\n+      Pragma_Export                       => True,\n+      Pragma_Extensions_Visible           => True,\n+      Pragma_Favor_Top_Level              => True,\n+      Pragma_Ghost                        => True,\n+      Pragma_Global                       => True,\n+      Pragma_Import                       => True,\n+      Pragma_Independent                  => True,\n+      Pragma_Independent_Components       => True,\n+      Pragma_Initial_Condition            => True,\n+      Pragma_Initializes                  => True,\n+      Pragma_Inline                       => True,\n+      Pragma_Inline_Always                => True,\n+      Pragma_Interrupt_Handler            => True,\n+      Pragma_Interrupt_Priority           => True,\n+      Pragma_Invariant                    => True,\n+      Pragma_Linker_Section               => True,\n+      Pragma_Lock_Free                    => True,\n+      Pragma_No_Elaboration_Code_All      => True,\n+      Pragma_No_Return                    => True,\n+      Pragma_Obsolescent                  => True,\n+      Pragma_Pack                         => True,\n+      Pragma_Part_Of                      => True,\n+      Pragma_Persistent_BSS               => True,\n+      Pragma_Post                         => True,\n+      Pragma_Post_Class                   => True,\n+      Pragma_Postcondition                => True,\n+      Pragma_Pre                          => True,\n+      Pragma_Pre_Class                    => True,\n+      Pragma_Precondition                 => True,\n+      Pragma_Predicate                    => True,\n+      Pragma_Preelaborable_Initialization => True,\n+      Pragma_Preelaborate                 => True,\n+      Pragma_Priority                     => True,\n+      Pragma_Pure                         => True,\n+      Pragma_Pure_Function                => True,\n+      Pragma_Refined_Depends              => True,\n+      Pragma_Refined_Global               => True,\n+      Pragma_Refined_Post                 => True,\n+      Pragma_Refined_State                => True,\n+      Pragma_Relative_Deadline            => True,\n+      Pragma_Remote_Access_Type           => True,\n+      Pragma_Remote_Call_Interface        => True,\n+      Pragma_Remote_Types                 => True,\n+      Pragma_Shared                       => True,\n+      Pragma_Shared_Passive               => True,\n+      Pragma_Simple_Storage_Pool_Type     => True,\n+      Pragma_SPARK_Mode                   => True,\n+      Pragma_Storage_Size                 => True,\n+      Pragma_Suppress                     => True,\n+      Pragma_Suppress_Debug_Info          => True,\n+      Pragma_Suppress_Initialization      => True,\n+      Pragma_Test_Case                    => True,\n+      Pragma_Thread_Local_Storage         => True,\n+      Pragma_Type_Invariant               => True,\n+      Pragma_Unchecked_Union              => True,\n+      Pragma_Universal_Aliasing           => True,\n+      Pragma_Universal_Data               => True,\n+      Pragma_Unmodified                   => True,\n+      Pragma_Unreferenced                 => True,\n+      Pragma_Unreferenced_Objects         => True,\n+      Pragma_Unsuppress                   => True,\n+      Pragma_Volatile                     => True,\n+      Pragma_Volatile_Components          => True,\n+      Pragma_Volatile_Full_Access         => True,\n+      Pragma_Warnings                     => True,\n+      others                              => False);\n+\n    --  The following table lists all pragmas that act as an assertion\n    --  expression.\n \n    Assertion_Expression_Pragma : constant array (Pragma_Id) of Boolean :=\n-     (Pragma_Assert               => True,\n-      Pragma_Assert_And_Cut       => True,\n-      Pragma_Assume               => True,\n-      Pragma_Check                => True,\n-      Pragma_Contract_Cases       => True,\n-      Pragma_Initial_Condition    => True,\n-      Pragma_Invariant            => True,\n-      Pragma_Loop_Invariant       => True,\n-      Pragma_Loop_Variant         => True,\n-      Pragma_Post                 => True,\n-      Pragma_Post_Class           => True,\n-      Pragma_Postcondition        => True,\n-      Pragma_Pre                  => True,\n-      Pragma_Pre_Class            => True,\n-      Pragma_Precondition         => True,\n-      Pragma_Predicate            => True,\n-      Pragma_Refined_Post         => True,\n-      Pragma_Test_Case            => True,\n-      Pragma_Type_Invariant       => True,\n-      Pragma_Type_Invariant_Class => True,\n-      others                      => False);\n+     (Pragma_Assert                    => True,\n+      Pragma_Assert_And_Cut            => True,\n+      Pragma_Assume                    => True,\n+      Pragma_Check                     => True,\n+      Pragma_Contract_Cases            => True,\n+      Pragma_Default_Initial_Condition => True,\n+      Pragma_Initial_Condition         => True,\n+      Pragma_Invariant                 => True,\n+      Pragma_Loop_Invariant            => True,\n+      Pragma_Loop_Variant              => True,\n+      Pragma_Post                      => True,\n+      Pragma_Post_Class                => True,\n+      Pragma_Postcondition             => True,\n+      Pragma_Pre                       => True,\n+      Pragma_Pre_Class                 => True,\n+      Pragma_Precondition              => True,\n+      Pragma_Predicate                 => True,\n+      Pragma_Refined_Post              => True,\n+      Pragma_Test_Case                 => True,\n+      Pragma_Type_Invariant            => True,\n+      Pragma_Type_Invariant_Class      => True,\n+      others                           => False);\n \n    --  The following table lists all the implementation-defined pragmas that\n    --  may apply to a body stub (no language defined pragmas apply). The table\n@@ -156,6 +247,25 @@ package Sem_Prag is\n    --  is the related variable or state. Ensure legality of the combination and\n    --  issue an error for an illegal combination.\n \n+   function Check_Kind (Nam : Name_Id) return Name_Id;\n+   --  This function is used in connection with pragmas Assert, Check,\n+   --  and assertion aspects and pragmas, to determine if Check pragmas\n+   --  (or corresponding assertion aspects or pragmas) are currently active\n+   --  as determined by the presence of -gnata on the command line (which\n+   --  sets the default), and the appearance of pragmas Check_Policy and\n+   --  Assertion_Policy as configuration pragmas either in a configuration\n+   --  pragma file, or at the start of the current unit, or locally given\n+   --  Check_Policy and Assertion_Policy pragmas that are currently active.\n+   --\n+   --  The value returned is one of the names Check, Ignore, Disable (On\n+   --  returns Check, and Off returns Ignore).\n+   --\n+   --  Note: for assertion kinds Pre'Class, Post'Class, Invariant'Class,\n+   --  and Type_Invariant'Class, the name passed is Name_uPre, Name_uPost,\n+   --  Name_uInvariant, or Name_uType_Invariant, which corresponds to _Pre,\n+   --  _Post, _Invariant, or _Type_Invariant, which are special names used\n+   --  in identifiers to represent these attribute references.\n+\n    procedure Check_Missing_Part_Of (Item_Id : Entity_Id);\n    --  Determine whether the placement within the state space of an abstract\n    --  state, variable or package instantiation denoted by Item_Id requires the"}, {"sha": "c7d220cca198cdc2dd5616c0146590325fdddb34", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 77, "deletions": 15, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -35,6 +35,7 @@ with Exp_Disp; use Exp_Disp;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n+with Ghost;    use Ghost;\n with Lib;      use Lib;\n with Lib.Xref; use Lib.Xref;\n with Namet.Sp; use Namet.Sp;\n@@ -1313,6 +1314,7 @@ package body Sem_Util is\n \n          --  Local variables\n \n+         GM        : constant Ghost_Mode_Type := Ghost_Mode;\n          Loc       : constant Source_Ptr := Sloc (Typ);\n          Prag      : constant Node_Id    :=\n                        Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n@@ -1339,6 +1341,11 @@ package body Sem_Util is\n             return;\n          end if;\n \n+         --  Ensure that the analysis and expansion produce Ghost nodes if the\n+         --  type itself is Ghost.\n+\n+         Set_Ghost_Mode_From_Entity (Typ);\n+\n          Param_Id := First_Formal (Proc_Id);\n \n          --  The pragma has an argument. Note that the argument is analyzed\n@@ -1405,6 +1412,11 @@ package body Sem_Util is\n          Set_Corresponding_Spec (Body_Decl, Proc_Id);\n \n          Insert_After_And_Analyze (Declaration_Node (Typ), Body_Decl);\n+\n+         --  Restore the original Ghost mode once analysis and expansion have\n+         --  taken place.\n+\n+         Ghost_Mode := GM;\n       end Build_Default_Init_Cond_Procedure_Body;\n \n       --  Local variables\n@@ -1453,6 +1465,7 @@ package body Sem_Util is\n    ---------------------------------------------------\n \n    procedure Build_Default_Init_Cond_Procedure_Declaration (Typ : Entity_Id) is\n+      GM      : constant Ghost_Mode_Type := Ghost_Mode;\n       Loc     : constant Source_Ptr := Sloc (Typ);\n       Prag    : constant Node_Id    :=\n                   Get_Pragma (Typ, Pragma_Default_Initial_Condition);\n@@ -1472,7 +1485,12 @@ package body Sem_Util is\n          return;\n       end if;\n \n-      Proc_Id  :=\n+      --  Ensure that the analysis and expansion produce Ghost nodes if the\n+      --  type itself is Ghost.\n+\n+      Set_Ghost_Mode_From_Entity (Typ);\n+\n+      Proc_Id :=\n         Make_Defining_Identifier (Loc,\n           Chars => New_External_Name (Chars (Typ), \"Default_Init_Cond\"));\n \n@@ -1482,6 +1500,13 @@ package body Sem_Util is\n       Set_Is_Default_Init_Cond_Procedure (Proc_Id);\n       Set_Default_Init_Cond_Procedure (Typ, Proc_Id);\n \n+      --  Mark the default initial condition procedure explicitly as Ghost\n+      --  because it does not come from source.\n+\n+      if Ghost_Mode > None then\n+         Set_Is_Ghost_Entity (Proc_Id);\n+      end if;\n+\n       --  Generate:\n       --    procedure <Typ>Default_Init_Cond (Inn : <Typ>);\n \n@@ -1494,6 +1519,11 @@ package body Sem_Util is\n                 Make_Parameter_Specification (Loc,\n                   Defining_Identifier => Make_Temporary (Loc, 'I'),\n                   Parameter_Type      => New_Occurrence_Of (Typ, Loc))))));\n+\n+      --  Restore the original Ghost mode once analysis and expansion have\n+      --  taken place.\n+\n+      Ghost_Mode := GM;\n    end Build_Default_Init_Cond_Procedure_Declaration;\n \n    ---------------------------\n@@ -12782,6 +12812,27 @@ package body Sem_Util is\n       return False;\n    end Is_Renamed_Entry;\n \n+   -----------------------------\n+   -- Is_Renaming_Declaration --\n+   -----------------------------\n+\n+   function Is_Renaming_Declaration (N : Node_Id) return Boolean is\n+   begin\n+      case Nkind (N) is\n+         when N_Exception_Renaming_Declaration         |\n+              N_Generic_Function_Renaming_Declaration  |\n+              N_Generic_Package_Renaming_Declaration   |\n+              N_Generic_Procedure_Renaming_Declaration |\n+              N_Object_Renaming_Declaration            |\n+              N_Package_Renaming_Declaration           |\n+              N_Subprogram_Renaming_Declaration        =>\n+            return True;\n+\n+         when others                                   =>\n+            return False;\n+      end case;\n+   end Is_Renaming_Declaration;\n+\n    ----------------------------\n    -- Is_Reversible_Iterator --\n    ----------------------------\n@@ -16256,21 +16307,24 @@ package body Sem_Util is\n       --------------------\n \n       function Policy_In_List (List : Node_Id) return Name_Id is\n-         Arg  : Node_Id;\n-         Expr : Node_Id;\n+         Arg1 : Node_Id;\n+         Arg2 : Node_Id;\n          Prag : Node_Id;\n \n       begin\n          Prag := List;\n          while Present (Prag) loop\n-            Arg  := First (Pragma_Argument_Associations (Prag));\n-            Expr := Get_Pragma_Arg (Arg);\n+            Arg1 := First (Pragma_Argument_Associations (Prag));\n+            Arg2 := Next (Arg1);\n+\n+            Arg1 := Get_Pragma_Arg (Arg1);\n+            Arg2 := Get_Pragma_Arg (Arg2);\n \n-            --  The current Check_Policy pragma matches the requested policy,\n-            --  return the second argument which denotes the policy identifier.\n+            --  The current Check_Policy pragma matches the requested policy or\n+            --  appears in the single argument form (Assertion, policy_id).\n \n-            if Chars (Expr) = Policy then\n-               return Chars (Get_Pragma_Arg (Next (Arg)));\n+            if Nam_In (Chars (Arg1), Name_Assertion, Policy) then\n+               return Chars (Arg2);\n             end if;\n \n             Prag := Next_Pragma (Prag);\n@@ -16948,13 +17002,20 @@ package body Sem_Util is\n          begin\n             Comp := First_Entity (Typ);\n             while Present (Comp) loop\n-               if Ekind (Comp) = E_Component\n-                  and then Requires_Transient_Scope (Etype (Comp))\n-               then\n-                  return True;\n-               else\n-                  Next_Entity (Comp);\n+               if Ekind (Comp) = E_Component then\n+                  --  ???It's not cleare we need a full recursive call to\n+                  --  Requires_Transient_Scope here. Note that the following\n+                  --  can't happen.\n+\n+                  pragma Assert (Is_Definite_Subtype (Etype (Comp)));\n+                  pragma Assert (not Has_Controlled_Component (Etype (Comp)));\n+\n+                  if Requires_Transient_Scope (Etype (Comp)) then\n+                     return True;\n+                  end if;\n                end if;\n+\n+               Next_Entity (Comp);\n             end loop;\n          end;\n \n@@ -16985,6 +17046,7 @@ package body Sem_Util is\n       --  All other cases do not require a transient scope\n \n       else\n+         pragma Assert (Is_Protected_Type (Typ) or else Is_Task_Type (Typ));\n          return False;\n       end if;\n    end Requires_Transient_Scope;"}, {"sha": "d8a04e0643a80a02ae712496a3e0b2d9426618a0", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -1440,6 +1440,9 @@ package Sem_Util is\n    function Is_Renamed_Entry (Proc_Nam : Entity_Id) return Boolean;\n    --  Return True if Proc_Nam is a procedure renaming of an entry\n \n+   function Is_Renaming_Declaration (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N denotes a renaming declaration\n+\n    function Is_Reversible_Iterator (Typ : Entity_Id) return Boolean;\n    --  AI05-0139-2: Check whether Typ is derived from the predefined interface\n    --  Ada.Iterator_Interfaces.Reversible_Iterator."}, {"sha": "824acd51ca11ef58deee760f43e42b39e78c2f32", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -1884,6 +1884,14 @@ package body Sinfo is\n       return Flag2 (N);\n    end Is_Generic_Contract_Pragma;\n \n+   function Is_Ghost_Pragma\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag3 (N);\n+   end Is_Ghost_Pragma;\n+\n    function Is_Ignored\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5089,6 +5097,14 @@ package body Sinfo is\n       Set_Flag2 (N, Val);\n    end Set_Is_Generic_Contract_Pragma;\n \n+   procedure Set_Is_Ghost_Pragma\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag3 (N, Val);\n+   end Set_Is_Ghost_Pragma;\n+\n    procedure Set_Is_Ignored\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "eefca477da02b5deea656bb53b24d7597a8358ce", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/241ebe892af143aaf8cce4bfd80f9b8dce97fe72/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=241ebe892af143aaf8cce4bfd80f9b8dce97fe72", "patch": "@@ -1627,6 +1627,11 @@ package Sinfo is\n    --      Refined_State\n    --      Test_Case\n \n+   --  Is_Ghost_Pragma (Flag3-Sem)\n+   --    This flag is present in N_Pragma nodes. It is set when the pragma is\n+   --    either declared within a Ghost construct or it applies to a Ghost\n+   --    construct.\n+\n    --  Is_Ignored (Flag9-Sem)\n    --    A flag set in an N_Aspect_Specification or N_Pragma node if there was\n    --    a Check_Policy or Assertion_Policy (or in the case of a Debug_Pragma)\n@@ -2468,6 +2473,7 @@ package Sinfo is\n       --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Is_Disabled (Flag15-Sem)\n       --  Is_Generic_Contract_Pragma (Flag2-Sem)\n+      --  Is_Ghost_Pragma (Flag3-Sem);\n       --  Is_Ignored (Flag9-Sem)\n       --  Is_Inherited (Flag4-Sem)\n       --  Split_PPC (Flag17) set if corresponding aspect had Split_PPC set\n@@ -9322,6 +9328,9 @@ package Sinfo is\n    function Is_Generic_Contract_Pragma\n      (N : Node_Id) return Boolean;    -- Flag2\n \n+   function Is_Ghost_Pragma\n+     (N : Node_Id) return Boolean;    -- Flag3\n+\n    function Is_Ignored\n      (N : Node_Id) return Boolean;    -- Flag9\n \n@@ -10345,6 +10354,9 @@ package Sinfo is\n    procedure Set_Is_Generic_Contract_Pragma\n      (N : Node_Id; Val : Boolean := True);    -- Flag2\n \n+   procedure Set_Is_Ghost_Pragma\n+     (N : Node_Id; Val : Boolean := True);    -- Flag3\n+\n    procedure Set_Is_Ignored\n      (N : Node_Id; Val : Boolean := True);    -- Flag9\n \n@@ -12736,6 +12748,7 @@ package Sinfo is\n    pragma Inline (Is_Finalization_Wrapper);\n    pragma Inline (Is_Folded_In_Parser);\n    pragma Inline (Is_Generic_Contract_Pragma);\n+   pragma Inline (Is_Ghost_Pragma);\n    pragma Inline (Is_Ignored);\n    pragma Inline (Is_In_Discriminant_Check);\n    pragma Inline (Is_Inherited);\n@@ -13072,6 +13085,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Finalization_Wrapper);\n    pragma Inline (Set_Is_Folded_In_Parser);\n    pragma Inline (Set_Is_Generic_Contract_Pragma);\n+   pragma Inline (Set_Is_Ghost_Pragma);\n    pragma Inline (Set_Is_Ignored);\n    pragma Inline (Set_Is_In_Discriminant_Check);\n    pragma Inline (Set_Is_Inherited);"}]}