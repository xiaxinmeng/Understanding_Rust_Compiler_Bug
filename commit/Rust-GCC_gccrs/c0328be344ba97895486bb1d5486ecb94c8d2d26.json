{"sha": "c0328be344ba97895486bb1d5486ecb94c8d2d26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAzMjhiZTM0NGJhOTc4OTU0ODZiYjFkNTQ4NmVjYjk0YzhkMmQyNg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-02-08T15:31:53Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-02-08T15:31:53Z"}, "message": "* convert.c (convert_to_integer_1): Re-indent.\n\nFrom-SVN: r233217", "tree": {"sha": "c02112685d1507d0cd4d0a9d41943c81e1a857f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c02112685d1507d0cd4d0a9d41943c81e1a857f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0328be344ba97895486bb1d5486ecb94c8d2d26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0328be344ba97895486bb1d5486ecb94c8d2d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0328be344ba97895486bb1d5486ecb94c8d2d26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0328be344ba97895486bb1d5486ecb94c8d2d26/comments", "author": null, "committer": null, "parents": [{"sha": "415594bb5c49d69f5350401d07abac62bce8656a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/415594bb5c49d69f5350401d07abac62bce8656a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/415594bb5c49d69f5350401d07abac62bce8656a"}], "stats": {"total": 429, "additions": 215, "deletions": 214}, "files": [{"sha": "e6b4d295c4ea393f869c74ff0d15e4c845409a0e", "filename": "gcc/convert.c", "status": "modified", "additions": 215, "deletions": 214, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0328be344ba97895486bb1d5486ecb94c8d2d26/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0328be344ba97895486bb1d5486ecb94c8d2d26/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=c0328be344ba97895486bb1d5486ecb94c8d2d26", "patch": "@@ -670,229 +670,230 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n \t make a wider result--are handled by \"shorten\" in build_binary_op.  */\n \n       if (dofold)\n-      switch (ex_form)\n-\t{\n-\tcase RSHIFT_EXPR:\n-\t  /* We can pass truncation down through right shifting\n-\t     when the shift count is a nonpositive constant.  */\n-\t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n-\t      && tree_int_cst_sgn (TREE_OPERAND (expr, 1)) <= 0)\n-\t    goto trunc1;\n-\t  break;\n-\n-\tcase LSHIFT_EXPR:\n-\t  /* We can pass truncation down through left shifting\n-\t     when the shift count is a nonnegative constant and\n-\t     the target type is unsigned.  */\n-\t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n-\t      && tree_int_cst_sgn (TREE_OPERAND (expr, 1)) >= 0\n-\t      && TYPE_UNSIGNED (type)\n-\t      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n-\t    {\n-\t      /* If shift count is less than the width of the truncated type,\n-\t\t really shift.  */\n-\t      if (tree_int_cst_lt (TREE_OPERAND (expr, 1), TYPE_SIZE (type)))\n-\t\t/* In this case, shifting is like multiplication.  */\n-\t\tgoto trunc1;\n-\t      else\n-\t\t{\n-\t\t  /* If it is >= that width, result is zero.\n-\t\t     Handling this with trunc1 would give the wrong result:\n-\t\t     (int) ((long long) a << 32) is well defined (as 0)\n-\t\t     but (int) a << 32 is undefined and would get a\n-\t\t     warning.  */\n-\n-\t\t  tree t = build_int_cst (type, 0);\n-\n-\t\t  /* If the original expression had side-effects, we must\n-\t\t     preserve it.  */\n-\t\t  if (TREE_SIDE_EFFECTS (expr))\n-\t\t    return build2 (COMPOUND_EXPR, type, expr, t);\n-\t\t  else\n-\t\t    return t;\n-\t\t}\n-\t    }\n-\t  break;\n-\n-\tcase TRUNC_DIV_EXPR:\n+\tswitch (ex_form)\n \t  {\n-\t    tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n-\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n-\n-\t    /* Don't distribute unless the output precision is at least as big\n-\t       as the actual inputs and it has the same signedness.  */\n-\t    if (outprec >= TYPE_PRECISION (TREE_TYPE (arg0))\n-\t\t&& outprec >= TYPE_PRECISION (TREE_TYPE (arg1))\n-\t\t/* If signedness of arg0 and arg1 don't match,\n-\t\t   we can't necessarily find a type to compare them in.  */\n-\t\t&& (TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t    == TYPE_UNSIGNED (TREE_TYPE (arg1)))\n-\t\t/* Do not change the sign of the division.  */\n-\t\t&& (TYPE_UNSIGNED (TREE_TYPE (expr))\n-\t\t    == TYPE_UNSIGNED (TREE_TYPE (arg0)))\n-\t\t/* Either require unsigned division or a division by\n-\t\t   a constant that is not -1.  */\n-\t\t&& (TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t    || (TREE_CODE (arg1) == INTEGER_CST\n-\t\t\t&& !integer_all_onesp (arg1))))\n+\t  case RSHIFT_EXPR:\n+\t    /* We can pass truncation down through right shifting\n+\t       when the shift count is a nonpositive constant.  */\n+\t    if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n+\t\t&& tree_int_cst_sgn (TREE_OPERAND (expr, 1)) <= 0)\n \t      goto trunc1;\n \t    break;\n-\t  }\n \n-\tcase MAX_EXPR:\n-\tcase MIN_EXPR:\n-\tcase MULT_EXPR:\n-\t  {\n-\t    tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n-\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n-\n-\t    /* Don't distribute unless the output precision is at least as big\n-\t       as the actual inputs.  Otherwise, the comparison of the\n-\t       truncated values will be wrong.  */\n-\t    if (outprec >= TYPE_PRECISION (TREE_TYPE (arg0))\n-\t\t&& outprec >= TYPE_PRECISION (TREE_TYPE (arg1))\n-\t\t/* If signedness of arg0 and arg1 don't match,\n-\t\t   we can't necessarily find a type to compare them in.  */\n-\t\t&& (TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t    == TYPE_UNSIGNED (TREE_TYPE (arg1))))\n-\t      goto trunc1;\n-\t    break;\n-\t  }\n-\n-\tcase PLUS_EXPR:\n-\tcase MINUS_EXPR:\n-\tcase BIT_AND_EXPR:\n-\tcase BIT_IOR_EXPR:\n-\tcase BIT_XOR_EXPR:\n-\ttrunc1:\n-\t  {\n-\t    tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n-\t    tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n-\n-\t    /* Do not try to narrow operands of pointer subtraction;\n-\t       that will interfere with other folding.  */\n-\t    if (ex_form == MINUS_EXPR\n-\t\t&& CONVERT_EXPR_P (arg0)\n-\t\t&& CONVERT_EXPR_P (arg1)\n-\t\t&& POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 0)))\n-\t\t&& POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (arg1, 0))))\n-\t      break;\n-\n-\t    if (outprec >= BITS_PER_WORD\n-\t\t|| TRULY_NOOP_TRUNCATION (outprec, inprec)\n-\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg0))\n-\t\t|| inprec > TYPE_PRECISION (TREE_TYPE (arg1)))\n+\t  case LSHIFT_EXPR:\n+\t    /* We can pass truncation down through left shifting\n+\t       when the shift count is a nonnegative constant and\n+\t       the target type is unsigned.  */\n+\t    if (TREE_CODE (TREE_OPERAND (expr, 1)) == INTEGER_CST\n+\t\t&& tree_int_cst_sgn (TREE_OPERAND (expr, 1)) >= 0\n+\t\t&& TYPE_UNSIGNED (type)\n+\t\t&& TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)\n \t      {\n-\t\t/* Do the arithmetic in type TYPEX,\n-\t\t   then convert result to TYPE.  */\n-\t\ttree typex = type;\n-\n-\t\t/* Can't do arithmetic in enumeral types\n-\t\t   so use an integer type that will hold the values.  */\n-\t\tif (TREE_CODE (typex) == ENUMERAL_TYPE)\n-\t\t  typex\n-\t\t    = lang_hooks.types.type_for_size (TYPE_PRECISION (typex),\n-\t\t\t\t\t\t      TYPE_UNSIGNED (typex));\n-\n-\t\t/* But now perhaps TYPEX is as wide as INPREC.\n-\t\t   In that case, do nothing special here.\n-\t\t   (Otherwise would recurse infinitely in convert.  */\n-\t\tif (TYPE_PRECISION (typex) != inprec)\n+\t\t/* If shift count is less than the width of the truncated type,\n+\t\t   really shift.  */\n+\t\tif (tree_int_cst_lt (TREE_OPERAND (expr, 1), TYPE_SIZE (type)))\n+\t\t  /* In this case, shifting is like multiplication.  */\n+\t\t  goto trunc1;\n+\t\telse\n \t\t  {\n-\t\t    /* Don't do unsigned arithmetic where signed was wanted,\n-\t\t       or vice versa.\n-\t\t       Exception: if both of the original operands were\n-\t\t       unsigned then we can safely do the work as unsigned.\n-\t\t       Exception: shift operations take their type solely\n-\t\t       from the first argument.\n-\t\t       Exception: the LSHIFT_EXPR case above requires that\n-\t\t       we perform this operation unsigned lest we produce\n-\t\t       signed-overflow undefinedness.\n-\t\t       And we may need to do it as unsigned\n-\t\t       if we truncate to the original size.  */\n-\t\t    if (TYPE_UNSIGNED (TREE_TYPE (expr))\n-\t\t\t|| (TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t\t    && (TYPE_UNSIGNED (TREE_TYPE (arg1))\n-\t\t\t\t|| ex_form == LSHIFT_EXPR\n-\t\t\t\t|| ex_form == RSHIFT_EXPR\n-\t\t\t\t|| ex_form == LROTATE_EXPR\n-\t\t\t\t|| ex_form == RROTATE_EXPR))\n-\t\t\t|| ex_form == LSHIFT_EXPR\n-\t\t\t/* If we have !flag_wrapv, and either ARG0 or\n-\t\t\t   ARG1 is of a signed type, we have to do\n-\t\t\t   PLUS_EXPR, MINUS_EXPR or MULT_EXPR in an unsigned\n-\t\t\t   type in case the operation in outprec precision\n-\t\t\t   could overflow.  Otherwise, we would introduce\n-\t\t\t   signed-overflow undefinedness.  */\n-\t\t\t|| ((!TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0))\n-\t\t\t     || !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg1)))\n-\t\t\t    && ((TYPE_PRECISION (TREE_TYPE (arg0)) * 2u\n-\t\t\t\t > outprec)\n-\t\t\t\t|| (TYPE_PRECISION (TREE_TYPE (arg1)) * 2u\n-\t\t\t\t    > outprec))\n-\t\t\t    && (ex_form == PLUS_EXPR\n-\t\t\t\t|| ex_form == MINUS_EXPR\n-\t\t\t\t|| ex_form == MULT_EXPR)))\n-\t\t      {\n-\t\t\tif (!TYPE_UNSIGNED (typex))\n-\t\t\t  typex = unsigned_type_for (typex);\n-\t\t      }\n+\t\t    /* If it is >= that width, result is zero.\n+\t\t       Handling this with trunc1 would give the wrong result:\n+\t\t       (int) ((long long) a << 32) is well defined (as 0)\n+\t\t       but (int) a << 32 is undefined and would get a\n+\t\t       warning.  */\n+\n+\t\t    tree t = build_int_cst (type, 0);\n+\n+\t\t    /* If the original expression had side-effects, we must\n+\t\t       preserve it.  */\n+\t\t    if (TREE_SIDE_EFFECTS (expr))\n+\t\t      return build2 (COMPOUND_EXPR, type, expr, t);\n \t\t    else\n-\t\t      {\n-\t\t\tif (TYPE_UNSIGNED (typex))\n-\t\t\t  typex = signed_type_for (typex);\n-\t\t      }\n-\t\t    /* We should do away with all this once we have a proper\n-\t\t       type promotion/demotion pass, see PR45397.  */\n-\t\t    expr = maybe_fold_build2_loc (dofold, loc, ex_form, typex,\n-\t\t\t\t\t\t  convert (typex, arg0),\n-\t\t\t\t\t\t  convert (typex, arg1));\n-\t\t    return convert (type, expr);\n+\t\t      return t;\n \t\t  }\n \t      }\n-\t  }\n-\t  break;\n+\t    break;\n \n-\tcase NEGATE_EXPR:\n-\tcase BIT_NOT_EXPR:\n-\t  /* This is not correct for ABS_EXPR,\n-\t     since we must test the sign before truncation.  */\n-\t  {\n-\t    /* Do the arithmetic in type TYPEX,\n-\t       then convert result to TYPE.  */\n-\t    tree typex = type;\n-\n-\t    /* Can't do arithmetic in enumeral types\n-\t       so use an integer type that will hold the values.  */\n-\t    if (TREE_CODE (typex) == ENUMERAL_TYPE)\n-\t      typex\n-\t\t= lang_hooks.types.type_for_size (TYPE_PRECISION (typex),\n-\t\t\t\t\t\t  TYPE_UNSIGNED (typex));\n-\n-\t    if (!TYPE_UNSIGNED (typex))\n-\t      typex = unsigned_type_for (typex);\n-\t    return convert (type,\n-\t\t\t    fold_build1 (ex_form, typex,\n-\t\t\t\t\t convert (typex,\n-\t\t\t\t\t\t  TREE_OPERAND (expr, 0))));\n-\t  }\n+\t  case TRUNC_DIV_EXPR:\n+\t    {\n+\t      tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n+\t      tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n+\n+\t      /* Don't distribute unless the output precision is at least as\n+\t\t big as the actual inputs and it has the same signedness.  */\n+\t      if (outprec >= TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t  && outprec >= TYPE_PRECISION (TREE_TYPE (arg1))\n+\t\t  /* If signedness of arg0 and arg1 don't match,\n+\t\t     we can't necessarily find a type to compare them in.  */\n+\t\t  && (TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t      == TYPE_UNSIGNED (TREE_TYPE (arg1)))\n+\t\t  /* Do not change the sign of the division.  */\n+\t\t  && (TYPE_UNSIGNED (TREE_TYPE (expr))\n+\t\t      == TYPE_UNSIGNED (TREE_TYPE (arg0)))\n+\t\t  /* Either require unsigned division or a division by\n+\t\t     a constant that is not -1.  */\n+\t\t  && (TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t      || (TREE_CODE (arg1) == INTEGER_CST\n+\t\t\t  && !integer_all_onesp (arg1))))\n+\t\tgoto trunc1;\n+\t      break;\n+\t    }\n \n-\tCASE_CONVERT:\n-\t  /* Don't introduce a\n-\t     \"can't convert between vector values of different size\" error.  */\n-\t  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == VECTOR_TYPE\n-\t      && (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (TREE_OPERAND (expr, 0))))\n-\t\t  != GET_MODE_SIZE (TYPE_MODE (type))))\n+\t  case MAX_EXPR:\n+\t  case MIN_EXPR:\n+\t  case MULT_EXPR:\n+\t    {\n+\t      tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n+\t      tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n+\n+\t      /* Don't distribute unless the output precision is at least as\n+\t\t big as the actual inputs.  Otherwise, the comparison of the\n+\t\t truncated values will be wrong.  */\n+\t      if (outprec >= TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t  && outprec >= TYPE_PRECISION (TREE_TYPE (arg1))\n+\t\t  /* If signedness of arg0 and arg1 don't match,\n+\t\t     we can't necessarily find a type to compare them in.  */\n+\t\t  && (TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t      == TYPE_UNSIGNED (TREE_TYPE (arg1))))\n+\t\tgoto trunc1;\n+\t      break;\n+\t    }\n+\n+\t  case PLUS_EXPR:\n+\t  case MINUS_EXPR:\n+\t  case BIT_AND_EXPR:\n+\t  case BIT_IOR_EXPR:\n+\t  case BIT_XOR_EXPR:\n+\t  trunc1:\n+\t    {\n+\t      tree arg0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n+\t      tree arg1 = get_unwidened (TREE_OPERAND (expr, 1), type);\n+\n+\t      /* Do not try to narrow operands of pointer subtraction;\n+\t\t that will interfere with other folding.  */\n+\t      if (ex_form == MINUS_EXPR\n+\t\t  && CONVERT_EXPR_P (arg0)\n+\t\t  && CONVERT_EXPR_P (arg1)\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 0)))\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (arg1, 0))))\n+\t\tbreak;\n+\n+\t      if (outprec >= BITS_PER_WORD\n+\t\t  || TRULY_NOOP_TRUNCATION (outprec, inprec)\n+\t\t  || inprec > TYPE_PRECISION (TREE_TYPE (arg0))\n+\t\t  || inprec > TYPE_PRECISION (TREE_TYPE (arg1)))\n+\t\t{\n+\t\t  /* Do the arithmetic in type TYPEX,\n+\t\t     then convert result to TYPE.  */\n+\t\t  tree typex = type;\n+\n+\t\t  /* Can't do arithmetic in enumeral types\n+\t\t     so use an integer type that will hold the values.  */\n+\t\t  if (TREE_CODE (typex) == ENUMERAL_TYPE)\n+\t\t    typex\n+\t\t      = lang_hooks.types.type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t\t\t\tTYPE_UNSIGNED (typex));\n+\n+\t\t  /* But now perhaps TYPEX is as wide as INPREC.\n+\t\t     In that case, do nothing special here.\n+\t\t     (Otherwise would recurse infinitely in convert.  */\n+\t\t  if (TYPE_PRECISION (typex) != inprec)\n+\t\t    {\n+\t\t      /* Don't do unsigned arithmetic where signed was wanted,\n+\t\t\t or vice versa.\n+\t\t\t Exception: if both of the original operands were\n+\t\t\t unsigned then we can safely do the work as unsigned.\n+\t\t\t Exception: shift operations take their type solely\n+\t\t\t from the first argument.\n+\t\t\t Exception: the LSHIFT_EXPR case above requires that\n+\t\t\t we perform this operation unsigned lest we produce\n+\t\t\t signed-overflow undefinedness.\n+\t\t\t And we may need to do it as unsigned\n+\t\t\t if we truncate to the original size.  */\n+\t\t      if (TYPE_UNSIGNED (TREE_TYPE (expr))\n+\t\t\t  || (TYPE_UNSIGNED (TREE_TYPE (arg0))\n+\t\t\t      && (TYPE_UNSIGNED (TREE_TYPE (arg1))\n+\t\t\t\t  || ex_form == LSHIFT_EXPR\n+\t\t\t\t  || ex_form == RSHIFT_EXPR\n+\t\t\t\t  || ex_form == LROTATE_EXPR\n+\t\t\t\t  || ex_form == RROTATE_EXPR))\n+\t\t\t  || ex_form == LSHIFT_EXPR\n+\t\t\t  /* If we have !flag_wrapv, and either ARG0 or\n+\t\t\t     ARG1 is of a signed type, we have to do\n+\t\t\t     PLUS_EXPR, MINUS_EXPR or MULT_EXPR in an unsigned\n+\t\t\t     type in case the operation in outprec precision\n+\t\t\t     could overflow.  Otherwise, we would introduce\n+\t\t\t     signed-overflow undefinedness.  */\n+\t\t\t  || ((!TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0))\n+\t\t\t       || !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg1)))\n+\t\t\t      && ((TYPE_PRECISION (TREE_TYPE (arg0)) * 2u\n+\t\t\t\t   > outprec)\n+\t\t\t\t  || (TYPE_PRECISION (TREE_TYPE (arg1)) * 2u\n+\t\t\t\t      > outprec))\n+\t\t\t      && (ex_form == PLUS_EXPR\n+\t\t\t\t  || ex_form == MINUS_EXPR\n+\t\t\t\t  || ex_form == MULT_EXPR)))\n+\t\t\t{\n+\t\t\t  if (!TYPE_UNSIGNED (typex))\n+\t\t\t    typex = unsigned_type_for (typex);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  if (TYPE_UNSIGNED (typex))\n+\t\t\t    typex = signed_type_for (typex);\n+\t\t\t}\n+\t\t      /* We should do away with all this once we have a proper\n+\t\t\t type promotion/demotion pass, see PR45397.  */\n+\t\t      expr = maybe_fold_build2_loc (dofold, loc, ex_form, typex,\n+\t\t\t\t\t\t    convert (typex, arg0),\n+\t\t\t\t\t\t    convert (typex, arg1));\n+\t\t      return convert (type, expr);\n+\t\t    }\n+\t\t}\n+\t    }\n \t    break;\n-\t  /* If truncating after truncating, might as well do all at once.\n-\t     If truncating after extending, we may get rid of wasted work.  */\n-\t  return convert (type, get_unwidened (TREE_OPERAND (expr, 0), type));\n-\n-\tcase COND_EXPR:\n-\t  /* It is sometimes worthwhile to push the narrowing down through\n-\t     the conditional and never loses.  A COND_EXPR may have a throw\n-\t     as one operand, which then has void type.  Just leave void\n-\t     operands as they are.  */\n+\n+\t  case NEGATE_EXPR:\n+\t  case BIT_NOT_EXPR:\n+\t    /* This is not correct for ABS_EXPR,\n+\t       since we must test the sign before truncation.  */\n+\t    {\n+\t      /* Do the arithmetic in type TYPEX,\n+\t\t then convert result to TYPE.  */\n+\t      tree typex = type;\n+\n+\t      /* Can't do arithmetic in enumeral types\n+\t\t so use an integer type that will hold the values.  */\n+\t      if (TREE_CODE (typex) == ENUMERAL_TYPE)\n+\t\ttypex\n+\t\t  = lang_hooks.types.type_for_size (TYPE_PRECISION (typex),\n+\t\t\t\t\t\t    TYPE_UNSIGNED (typex));\n+\n+\t      if (!TYPE_UNSIGNED (typex))\n+\t\ttypex = unsigned_type_for (typex);\n+\t      return convert (type,\n+\t\t\t      fold_build1 (ex_form, typex,\n+\t\t\t\t\t   convert (typex,\n+\t\t\t\t\t\t    TREE_OPERAND (expr, 0))));\n+\t    }\n+\n+\t  CASE_CONVERT:\n+\t    /* Don't introduce a \"can't convert between vector values of\n+\t       different size\" error.  */\n+\t    if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == VECTOR_TYPE\n+\t\t&& (GET_MODE_SIZE (TYPE_MODE\n+\t\t\t\t   (TREE_TYPE (TREE_OPERAND (expr, 0))))\n+\t\t    != GET_MODE_SIZE (TYPE_MODE (type))))\n+\t      break;\n+\t    /* If truncating after truncating, might as well do all at once.\n+\t       If truncating after extending, we may get rid of wasted work.  */\n+\t    return convert (type, get_unwidened (TREE_OPERAND (expr, 0), type));\n+\n+\t  case COND_EXPR:\n+\t    /* It is sometimes worthwhile to push the narrowing down through\n+\t       the conditional and never loses.  A COND_EXPR may have a throw\n+\t       as one operand, which then has void type.  Just leave void\n+\t       operands as they are.  */\n \t    return\n \t      fold_build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n \t\t\t   VOID_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 1)))\n@@ -902,9 +903,9 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n \t\t\t   ? TREE_OPERAND (expr, 2)\n \t\t\t   : convert (type, TREE_OPERAND (expr, 2)));\n \n-\tdefault:\n-\t  break;\n-\t}\n+\t  default:\n+\t    break;\n+\t  }\n \n       /* When parsing long initializers, we might end up with a lot of casts.\n \t Shortcut this.  */"}]}