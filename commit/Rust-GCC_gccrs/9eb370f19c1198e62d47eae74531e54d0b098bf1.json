{"sha": "9eb370f19c1198e62d47eae74531e54d0b098bf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWViMzcwZjE5YzExOThlNjJkNDdlYWU3NDUzMWU1NGQwYjA5OGJmMQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-06-24T21:39:21Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-07-14T13:35:53Z"}, "message": "c++: Improve checking of decls with trailing return type [PR95820]\n\nThis is an ICE-on-invalid but I've been seeing it when reducing\nvarious testcases, so it's more important for me than usually.\n\nsplice_late_return_type now checks that if we've seen a late return\ntype, the function return type was auto.  That's a fair assumption\nbut grokdeclarator/cdk_function wasn't giving errors for function\npointers and similar.  So we want to perform various checks not only\nwhen funcdecl_p || inner_declarator == NULL.  But only give the\n!late_return_type errors when funcdecl_p, to accept e.g.\n\nauto (*fp)() = f;\n\nin C++11.  Here's a diff -w to ease the review:\n\n--- a/gcc/cp/decl.c\n+++ b/gcc/cp/decl.c\n@@ -12102,14 +12102,9 @@ grokdeclarator (const cp_declarator *declarator,\n\n \t    /* Handle a late-specified return type.  */\n \t    tree late_return_type = declarator->u.function.late_return_type;\n-\t    if (funcdecl_p\n-\t\t/* This is the case e.g. for\n-\t\t   using T = auto () -> int.  */\n-\t\t|| inner_declarator == NULL)\n-\t      {\n \t    if (tree auto_node = type_uses_auto (type))\n \t      {\n-\t\t    if (!late_return_type)\n+\t\tif (!late_return_type && funcdecl_p)\n \t\t  {\n \t\t    if (current_class_type\n \t\t\t&& LAMBDA_TYPE_P (current_class_type))\n@@ -12201,7 +12196,6 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t    \"type specifier\", name);\n \t\treturn error_mark_node;\n \t      }\n-\t      }\n \t    type = splice_late_return_type (type, late_return_type);\n \t    if (type == error_mark_node)\n \t      return error_mark_node;\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95820\n\t* decl.c (grokdeclarator) <case cdk_function>: Check also\n\tpointers/references/... to functions.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95820\n\t* g++.dg/cpp1y/auto-fn58.C: New test.", "tree": {"sha": "aaf53785b7e57c6bb431eb9deefeedf24e4d30e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaf53785b7e57c6bb431eb9deefeedf24e4d30e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eb370f19c1198e62d47eae74531e54d0b098bf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb370f19c1198e62d47eae74531e54d0b098bf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb370f19c1198e62d47eae74531e54d0b098bf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb370f19c1198e62d47eae74531e54d0b098bf1/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf567bb3b3cb43e299e947bbdfa00da416de0890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf567bb3b3cb43e299e947bbdfa00da416de0890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf567bb3b3cb43e299e947bbdfa00da416de0890"}], "stats": {"total": 179, "additions": 93, "deletions": 86}, "files": [{"sha": "6e4d546d55e7b0ce5e56e138a66361a7c8342a11", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 80, "deletions": 86, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb370f19c1198e62d47eae74531e54d0b098bf1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb370f19c1198e62d47eae74531e54d0b098bf1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9eb370f19c1198e62d47eae74531e54d0b098bf1", "patch": "@@ -12105,106 +12105,100 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t    /* Handle a late-specified return type.  */\n \t    tree late_return_type = declarator->u.function.late_return_type;\n-\t    if (funcdecl_p\n-\t\t/* This is the case e.g. for\n-\t\t   using T = auto () -> int.  */\n-\t\t|| inner_declarator == NULL)\n+\t    if (tree auto_node = type_uses_auto (type))\n \t      {\n-\t\tif (tree auto_node = type_uses_auto (type))\n+\t\tif (!late_return_type && funcdecl_p)\n \t\t  {\n-\t\t    if (!late_return_type)\n+\t\t    if (current_class_type\n+\t\t\t&& LAMBDA_TYPE_P (current_class_type))\n+\t\t      /* OK for C++11 lambdas.  */;\n+\t\t    else if (cxx_dialect < cxx14)\n \t\t      {\n-\t\t\tif (current_class_type\n-\t\t\t    && LAMBDA_TYPE_P (current_class_type))\n-\t\t\t  /* OK for C++11 lambdas.  */;\n-\t\t\telse if (cxx_dialect < cxx14)\n-\t\t\t  {\n-\t\t\t    error_at (typespec_loc, \"%qs function uses \"\n-\t\t\t\t      \"%<auto%> type specifier without \"\n-\t\t\t\t      \"trailing return type\", name);\n-\t\t\t    inform (typespec_loc,\n-\t\t\t\t    \"deduced return type only available \"\n-\t\t\t\t    \"with %<-std=c++14%> or %<-std=gnu++14%>\");\n-\t\t\t  }\n-\t\t\telse if (virtualp)\n-\t\t\t  {\n-\t\t\t    error_at (typespec_loc, \"virtual function \"\n-\t\t\t\t      \"cannot have deduced return type\");\n-\t\t\t    virtualp = false;\n-\t\t\t  }\n+\t\t\terror_at (typespec_loc, \"%qs function uses \"\n+\t\t\t\t  \"%<auto%> type specifier without \"\n+\t\t\t\t  \"trailing return type\", name);\n+\t\t\tinform (typespec_loc,\n+\t\t\t\t\"deduced return type only available \"\n+\t\t\t\t\"with %<-std=c++14%> or %<-std=gnu++14%>\");\n \t\t      }\n-\t\t    else if (!is_auto (type) && sfk != sfk_conversion)\n+\t\t    else if (virtualp)\n \t\t      {\n-\t\t\terror_at (typespec_loc, \"%qs function with trailing \"\n-\t\t\t\t  \"return type has %qT as its type rather \"\n-\t\t\t\t  \"than plain %<auto%>\", name, type);\n-\t\t\treturn error_mark_node;\n+\t\t\terror_at (typespec_loc, \"virtual function \"\n+\t\t\t\t  \"cannot have deduced return type\");\n+\t\t\tvirtualp = false;\n \t\t      }\n-\t\t    else if (is_auto (type) && AUTO_IS_DECLTYPE (type))\n+\t\t  }\n+\t\telse if (!is_auto (type) && sfk != sfk_conversion)\n+\t\t  {\n+\t\t    error_at (typespec_loc, \"%qs function with trailing \"\n+\t\t\t      \"return type has %qT as its type rather \"\n+\t\t\t      \"than plain %<auto%>\", name, type);\n+\t\t    return error_mark_node;\n+\t\t  }\n+\t\telse if (is_auto (type) && AUTO_IS_DECLTYPE (type))\n+\t\t  {\n+\t\t    if (funcdecl_p)\n+\t\t      error_at (typespec_loc,\n+\t\t\t\t\"%qs function with trailing return type \"\n+\t\t\t\t\"has %<decltype(auto)%> as its type \"\n+\t\t\t\t\"rather than plain %<auto%>\", name);\n+\t\t    else\n+\t\t      error_at (typespec_loc,\n+\t\t\t\t\"invalid use of %<decltype(auto)%>\");\n+\t\t    return error_mark_node;\n+\t\t  }\n+\t\ttree tmpl = CLASS_PLACEHOLDER_TEMPLATE (auto_node);\n+\t\tif (!tmpl)\n+\t\t  if (tree late_auto = type_uses_auto (late_return_type))\n+\t\t    tmpl = CLASS_PLACEHOLDER_TEMPLATE (late_auto);\n+\t\tif (tmpl && funcdecl_p)\n+\t\t  {\n+\t\t    if (!dguide_name_p (unqualified_id))\n \t\t      {\n-\t\t\tif (funcdecl_p)\n-\t\t\t  error_at (typespec_loc,\n-\t\t\t\t    \"%qs function with trailing return type \"\n-\t\t\t\t    \"has %<decltype(auto)%> as its type \"\n-\t\t\t\t    \"rather than plain %<auto%>\", name);\n-\t\t\telse\n-\t\t\t  error_at (typespec_loc,\n-\t\t\t\t    \"invalid use of %<decltype(auto)%>\");\n+\t\t\terror_at (declarator->id_loc, \"deduced class \"\n+\t\t\t\t  \"type %qD in function return type\",\n+\t\t\t\t  DECL_NAME (tmpl));\n+\t\t\tinform (DECL_SOURCE_LOCATION (tmpl),\n+\t\t\t\t\"%qD declared here\", tmpl);\n \t\t\treturn error_mark_node;\n \t\t      }\n-\t\t    tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (auto_node);\n-\t\t    if (!tmpl)\n-\t\t      if (tree late_auto = type_uses_auto (late_return_type))\n-\t\t\ttmpl = CLASS_PLACEHOLDER_TEMPLATE (late_auto);\n-\t\t    if (tmpl && funcdecl_p)\n+\t\t    else if (!late_return_type)\n \t\t      {\n-\t\t\tif (!dguide_name_p (unqualified_id))\n-\t\t\t  {\n-\t\t\t    error_at (declarator->id_loc, \"deduced class \"\n-\t\t\t\t      \"type %qD in function return type\",\n-\t\t\t\t      DECL_NAME (tmpl));\n-\t\t\t    inform (DECL_SOURCE_LOCATION (tmpl),\n-\t\t\t\t    \"%qD declared here\", tmpl);\n-\t\t\t    return error_mark_node;\n-\t\t\t  }\n-\t\t\telse if (!late_return_type)\n-\t\t\t  {\n-\t\t\t    error_at (declarator->id_loc, \"deduction guide \"\n-\t\t\t\t      \"for %qT must have trailing return \"\n-\t\t\t\t      \"type\", TREE_TYPE (tmpl));\n-\t\t\t    inform (DECL_SOURCE_LOCATION (tmpl),\n-\t\t\t\t    \"%qD declared here\", tmpl);\n-\t\t\t    return error_mark_node;\n-\t\t\t  }\n-\t\t\telse if (CLASS_TYPE_P (late_return_type)\n-\t\t\t\t && CLASSTYPE_TEMPLATE_INFO (late_return_type)\n-\t\t\t\t && (CLASSTYPE_TI_TEMPLATE (late_return_type)\n-\t\t\t\t     == tmpl))\n-\t\t\t  /* OK */;\n-\t\t\telse\n-\t\t\t  error (\"trailing return type %qT of deduction guide \"\n-\t\t\t\t \"is not a specialization of %qT\",\n-\t\t\t\t late_return_type, TREE_TYPE (tmpl));\n+\t\t\terror_at (declarator->id_loc, \"deduction guide \"\n+\t\t\t\t  \"for %qT must have trailing return \"\n+\t\t\t\t  \"type\", TREE_TYPE (tmpl));\n+\t\t\tinform (DECL_SOURCE_LOCATION (tmpl),\n+\t\t\t\t\"%qD declared here\", tmpl);\n+\t\t\treturn error_mark_node;\n \t\t      }\n-\t\t  }\n-\t\telse if (late_return_type\n-\t\t\t && sfk != sfk_conversion)\n-\t\t  {\n-\t\t    if (late_return_type == error_mark_node)\n-\t\t      return error_mark_node;\n-\t\t    if (cxx_dialect < cxx11)\n-\t\t      /* Not using maybe_warn_cpp0x because this should\n-\t\t\t always be an error.  */\n-\t\t      error_at (typespec_loc,\n-\t\t\t\t\"trailing return type only available \"\n-\t\t\t\t\"with %<-std=c++11%> or %<-std=gnu++11%>\");\n+\t\t    else if (CLASS_TYPE_P (late_return_type)\n+\t\t\t      && CLASSTYPE_TEMPLATE_INFO (late_return_type)\n+\t\t\t      && (CLASSTYPE_TI_TEMPLATE (late_return_type)\n+\t\t\t\t  == tmpl))\n+\t\t      /* OK */;\n \t\t    else\n-\t\t      error_at (typespec_loc, \"%qs function with trailing \"\n-\t\t\t\t\"return type not declared with %<auto%> \"\n-\t\t\t\t\"type specifier\", name);\n-\t\t    return error_mark_node;\n+\t\t      error (\"trailing return type %qT of deduction guide \"\n+\t\t\t      \"is not a specialization of %qT\",\n+\t\t\t      late_return_type, TREE_TYPE (tmpl));\n \t\t  }\n \t      }\n+\t    else if (late_return_type\n+\t\t     && sfk != sfk_conversion)\n+\t      {\n+\t\tif (late_return_type == error_mark_node)\n+\t\t  return error_mark_node;\n+\t\tif (cxx_dialect < cxx11)\n+\t\t  /* Not using maybe_warn_cpp0x because this should\n+\t\t     always be an error.  */\n+\t\t  error_at (typespec_loc,\n+\t\t\t    \"trailing return type only available \"\n+\t\t\t    \"with %<-std=c++11%> or %<-std=gnu++11%>\");\n+\t\telse\n+\t\t  error_at (typespec_loc, \"%qs function with trailing \"\n+\t\t\t    \"return type not declared with %<auto%> \"\n+\t\t\t    \"type specifier\", name);\n+\t\treturn error_mark_node;\n+\t      }\n \t    type = splice_late_return_type (type, late_return_type);\n \t    if (type == error_mark_node)\n \t      return error_mark_node;"}, {"sha": "8c4f24ccc74cdb1abdbcc2971266ee0595adb8a9", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn58.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb370f19c1198e62d47eae74531e54d0b098bf1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn58.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb370f19c1198e62d47eae74531e54d0b098bf1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn58.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn58.C?ref=9eb370f19c1198e62d47eae74531e54d0b098bf1", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/95820\n+// { dg-do compile { target c++14 } }\n+\n+auto (*a)() -> bool = nullptr;\n+int (*b)() -> bool = nullptr; // { dg-error \"function with trailing return type\" }\n+int (**c)() -> bool = nullptr; // { dg-error \"function with trailing return type\" }\n+int (&d)() -> bool = nullptr; // { dg-error \"function with trailing return type\" }\n+int (*&e)() -> bool = nullptr; // { dg-error \"function with trailing return type\" }\n+int (f[])() -> bool = nullptr; // { dg-error \"function with trailing return type\" }\n+auto* (*g)() -> bool = nullptr; // { dg-error \"function with trailing return type\" }\n+decltype(auto) (*h)() -> bool = nullptr; // { dg-error \"invalid use\" }\n+decltype(auto)* (*i)() -> bool = nullptr; // { dg-error \"function with trailing return type\" }\n+decltype(auto)& (*j)() -> bool = nullptr; // { dg-error \"function with trailing return type\" }"}]}