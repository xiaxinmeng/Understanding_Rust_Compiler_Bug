{"sha": "c75ab022811aa05c49657d6c48471962b48c9666", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc1YWIwMjI4MTFhYTA1YzQ5NjU3ZDZjNDg0NzE5NjJiNDhjOTY2Ng==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-03-13T00:46:07Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-03-13T00:46:07Z"}, "message": "In gcc/ada/ 2005-03-12 Daniel Berlin <dberlin@dberlin.org>\n\nIn gcc/ada/\n2005-03-12  Daniel Berlin <dberlin@dberlin.org>\n\n\t* misc.c (gnat_post_options): Turn off structural\n\taliasing for now.\nIn gcc/\n2005-03-12  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-flow-inline.h (ref_contains_array_ref): New function.\n\t(lookup_subvars_for_var): Ditto.\n\t(get_subvars_for_var): Ditto.\n\t(var_can_have_subvars): Ditto.\n\n\t* tree-flow.h (mem_tag_kind): Add STRUCT_FIELD.\n\t(struct subvar): New type.\n\n\t* tree-dfa.c (okay_component_ref_for_subvars): New function.\n\n\t* tree-optimize.c (init_tree_optimization_passes): Call\n\tpass_create_structure_vars.\n\n\t* tree-ssa-alias.c: Include vec.h.\n\t(init_alias_info): Don't auto-clear call clobbered on struct-field\n\ttags.\n\t(compute_flow_insensitive_aliasing): Handle subvars.\n\t(group_aliases): Handle STRUCT_FIELD aliases.\n\t(setup_pointers_and_addressables): Ditto.\n\tDon't mark variables non-addressable if they still have\n\taddressable subvars.\n\tAlso mark subvars addressable when the real variable is marked\n\taddressable.\n\t(add_pointed_to_var): Try to prune the pointed-to set by only\n\tpointing to subvars when possible.\n\tOtherwise, make sure we set addresses_needed and pt_vars to\n\tproperly include subvars.\n\t(bitpos_of_field): New function.\n\t(push_fields_onto_fieldstack): Ditto.\n\t(get_or_create_used_part_for): Ditto.\n\t(create_overlap_variables_for): Ditto.\n\t(find_used_portions): Ditto.\n\t(create_structure_vars): Ditto.\n\t(pass_create_structure_vars): New structure.\n\n\t* tree-ssa-operands.c (finalize_ssa_v_must_defs): Remove assert.\n\t(get_expr_operands): Handle subvars.  Also try to turn\n\tCOMPONENT_REF accesses into must-defs now that we can accurately\n\tportray it.\n\t(note_addressable): Try to only mark as addressable those subvars\n\twe know a COMPONENT_REF touches.\n\t(overlap_subvar): New function.\n\n\t* tree-vect-analyze.c (vect_object_analysis): Add new parameter.\n\tHandle subvar storing.\n\t(vect_address_analysis): Update caller of vect_object_analysis.\n\n\t* tree-vect-transform.c (vect_create_data_ref_ptr): Copy subvars.\n\n\t* tree-vectorizer.h (struct _stmt_vec_info): Add subvars member.\n\t(STMT_VINFO_SUBVARS): New macro.\n\n\t* common.opts: add flag_tree_salias.\n\n\t* opts.c (decode_options): flag_tree_salias defaults to on.\n\n\t* doc/invoke.texi: Document fdump-tree-svars and -ftree-salias.\n\n\t* doc/tree-ssa.texi: Document structural alias analysis.\n\nFrom-SVN: r96362", "tree": {"sha": "03744f60b00db0493040ec2c836323945507bf16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03744f60b00db0493040ec2c836323945507bf16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c75ab022811aa05c49657d6c48471962b48c9666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75ab022811aa05c49657d6c48471962b48c9666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c75ab022811aa05c49657d6c48471962b48c9666", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75ab022811aa05c49657d6c48471962b48c9666/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "23845f022033163786a64dfef44b7c127b92c5bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23845f022033163786a64dfef44b7c127b92c5bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23845f022033163786a64dfef44b7c127b92c5bb"}], "stats": {"total": 1098, "additions": 1026, "deletions": 72}, "files": [{"sha": "f5e5829e19ddfb60f1cf44439c546edae86c1071", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -1,3 +1,65 @@\n+2005-03-12  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-flow-inline.h (ref_contains_array_ref): New function.\n+\t(lookup_subvars_for_var): Ditto.\n+\t(get_subvars_for_var): Ditto.\n+\t(var_can_have_subvars): Ditto.\n+\n+\t* tree-flow.h (mem_tag_kind): Add STRUCT_FIELD.\n+\t(struct subvar): New type.\n+\n+\t* tree-dfa.c (okay_component_ref_for_subvars): New function.\n+\n+\t* tree-optimize.c (init_tree_optimization_passes): Call\n+\tpass_create_structure_vars.\n+\n+\t* tree-ssa-alias.c: Include vec.h.\n+\t(init_alias_info): Don't auto-clear call clobbered on struct-field\n+\ttags.\n+\t(compute_flow_insensitive_aliasing): Handle subvars.\n+\t(group_aliases): Handle STRUCT_FIELD aliases.\n+\t(setup_pointers_and_addressables): Ditto.\n+\tDon't mark variables non-addressable if they still have\n+\taddressable subvars.\n+\tAlso mark subvars addressable when the real variable is marked\n+\taddressable. \n+\t(add_pointed_to_var): Try to prune the pointed-to set by only\n+\tpointing to subvars when possible.\n+\tOtherwise, make sure we set addresses_needed and pt_vars to\n+\tproperly include subvars.\n+\t(bitpos_of_field): New function.\n+\t(push_fields_onto_fieldstack): Ditto.\n+\t(get_or_create_used_part_for): Ditto.\n+\t(create_overlap_variables_for): Ditto.\n+\t(find_used_portions): Ditto.\n+\t(create_structure_vars): Ditto.\n+\t(pass_create_structure_vars): New structure.\n+\n+\t* tree-ssa-operands.c (finalize_ssa_v_must_defs): Remove assert.\n+\t(get_expr_operands): Handle subvars.  Also try to turn\n+\tCOMPONENT_REF accesses into must-defs now that we can accurately\n+\tportray it.\n+\t(note_addressable): Try to only mark as addressable those subvars\n+\twe know a COMPONENT_REF touches.\n+\t(overlap_subvar): New function.\n+\n+\t* tree-vect-analyze.c (vect_object_analysis): Add new parameter.\n+\tHandle subvar storing.\n+\t(vect_address_analysis): Update caller of vect_object_analysis.\n+\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr): Copy subvars.\n+\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Add subvars member.\n+\t(STMT_VINFO_SUBVARS): New macro.\n+\n+\t* common.opts: add flag_tree_salias.\n+\t\n+\t* opts.c (decode_options): flag_tree_salias defaults to on.\n+\t\n+\t* doc/invoke.texi: Document fdump-tree-svars and -ftree-salias.\n+\n+\t* doc/tree-ssa.texi: Document structural alias analysis.\n+\t\n 2005-03-12  Steven Bosscher  <stevenb@suse.de>\n \n \t* tree-cfg.c (make_goto_expr_edges): Don't use error_mark_node."}, {"sha": "328436cba770cf5d2b2817fc234560c9c3fc2109", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -1,3 +1,8 @@\n+2005-03-12  Daniel Berlin <dberlin@dberlin.org>\n+\n+\t* misc.c (gnat_post_options): Turn off structural\n+\taliasing for now.\n+\t\n 2005-03-08  Laurent Guerby <laurent@guerby.net>\n \n \t* system-linux-sparc.ads: Fix typo in previous commit."}, {"sha": "81f8249c425ba85604b9370e557c327430e6f931", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -352,6 +352,8 @@ gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n     flag_no_inline = 1;\n   if (flag_inline_functions)\n     flag_inline_trees = 2;\n+  \n+  flag_tree_salias = 0;\n \n   return false;\n }"}, {"sha": "1fc2289db23363e558b189df276c6662eff18cba", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -872,6 +872,10 @@ ftree-pre\n Common Report Var(flag_tree_pre)\n Enable SSA-PRE optimization on trees\n \n+ftree-salias\n+Common Report Var(flag_tree_salias)\n+Perform structural alias analysis\n+\n ftree-sink\n Common Report Var(flag_tree_sink)\n Enable SSA code sinking on trees"}, {"sha": "c30b161888d07d9874b2eda0dd9ef526eb168050", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -266,6 +266,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-tree-nrv -fdump-tree-vect @gol\n -fdump-tree-sink @gol\n -fdump-tree-sra@r{[}-@var{n}@r{]} @gol\n+-fdump-tree-salias @gol\n -fdump-tree-fre@r{[}-@var{n}@r{]} @gol\n -ftree-vectorizer-verbose=@var{n} @gol\n -feliminate-dwarf2-dups -feliminate-unused-debug-types @gol\n@@ -322,6 +323,7 @@ Objective-C and Objective-C++ Dialects}.\n -ftree-loop-linear -ftree-loop-im -ftree-loop-ivcanon -fivopts @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename -ftree-sink @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-lrs -ftree-fre -ftree-vectorize @gol\n+-ftree-salias @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n \n@@ -3819,6 +3821,11 @@ appending @file{.ch} to the source file name.\n Dump SSA related information to a file.  The file name is made by appending\n @file{.ssa} to the source file name.\n \n+@item salias\n+@opindex fdump-tree-salias\n+Dump structure aliasing variable information to a file.  This file name\n+is made by appending @file{.salias} to the source file name.\n+\n @item alias\n @opindex fdump-tree-alias\n Dump aliasing information for each function.  The file name is made by\n@@ -4695,6 +4702,10 @@ that are computed on all paths leading to the redundant computation.\n This analysis faster than PRE, though it exposes fewer redundancies.\n This flag is enabled by default at @option{-O} and higher.\n \n+@item -ftree-salias\n+Perform structural alias analysis on trees.  This flag\n+is enabled by default at @option{-O} and higher.\n+\n @item -ftree-sink\n Perform forward store motion  on trees.  This flag is\n enabled by default at @option{-O} and higher."}, {"sha": "4679912fa9aacbc4ae0d2132385952ebde3c441c", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -1208,9 +1208,46 @@ hooks to execute custom code at various points during traversal:\n @cindex flow-sensitive alias analysis\n @cindex flow-insensitive alias analysis\n \n-Alias analysis proceeds in 3 main phases:\n+Alias analysis proceeds in 4 main phases:\n \n @enumerate\n+@item   Structural alias analysis.\n+\n+This phase walks the types for structure variables, and determines which\n+of the fields can overlap using offset and size of each field.  For each\n+field, a ``subvariable'' called a ``Structure field tag'' (SFT)@ is\n+created, which represents that field as a separate variable.  All\n+accesses that could possibly overlap with a given field will have\n+virtual operands for the SFT of that field.\n+\n+@smallexample\n+struct foo\n+@{\n+  int a;\n+  int b;\n+@}\n+struct foo temp;\n+int bar (void)\n+@{\n+  int tmp1, tmp2, tmp3;\n+  SFT.0_2 = V_MUST_DEF <SFT.0_1>\n+  temp.a = 5;\n+  SFT.1_4 = V_MUST_DEF <SFT.1_3>\n+  temp.b = 6;\n+  \n+  VUSE <SFT.1_4>\n+  tmp1_5 = temp.b;\n+  VUSE <SFT.0_2>\n+  tmp2_6 = temp.a;\n+\n+  tmp3_7 = tmp1_5 + tmp2_6;\n+  return tmp3_7;\n+@}\n+@end smallexample\n+\n+If you copy the type tag for a variable for some reason, you probably\n+also want to copy the subvariables for that variable.\n+\n @item\tPoints-to and escape analysis.\n \n This phase walks the use-def chains in the SSA web looking for"}, {"sha": "c6940013a5065469066cdcdaa3bb45d593c3ea30", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -502,6 +502,7 @@ decode_options (unsigned int argc, const char **argv)\n       flag_tree_copyrename = 1;\n       flag_tree_fre = 1;\n       flag_tree_sink = 1;\n+      flag_tree_salias = 1;\n \n       if (!optimize_size)\n \t{"}, {"sha": "99abc761ab588234fd7b1a0a1dd75543ca5bfd07", "filename": "gcc/testsuite/gcc.dg/tree-ssa/structopt-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstructopt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstructopt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstructopt-1.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim-details\" } */\n+int x; int y;\n+struct { int x; int y; } global;\n+int foo() {\n+\tint i;\n+\tfor ( i=0; i<10; i++)\n+\t\ty += x*x;\n+\tfor ( i=0; i<10; i++)\n+\t\tglobal.y += global.x*global.x;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Executing store motion of global.y\" 1 \"lim\" } } */\n+/* XXX: We should also check for the load motion of global.x, but there is no easy way to do this.  */\n+"}, {"sha": "327b54c162c17a1895c45df125355a69d4361458", "filename": "gcc/testsuite/gcc.dg/tree-ssa/structopt-2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstructopt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstructopt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstructopt-2.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fno-tree-sra\" } */\n+\n+/* Even without SRA being enabled, we should be able to eliminate every structure store and load here. */\n+extern void foo (const int);\n+int main(void)\n+{\n+\tstruct a\n+\t{\n+\t\tint e;\n+\t\tint f;\n+\t\tint g;\n+\t}  a;\n+\tstruct a b;\n+\tint x, c;\n+\ta.e = 50;\n+\ta.f = 9;\n+\ta.g = a.e * a.f;\n+\tfoo (a.f);\n+\tfoo (a.g);\n+\tx = a.f;\n+\tc = a.e;\n+\tfoo (x);\n+\tfoo (c);\n+\ta.e = 5;\n+\ta.f = 40;\n+\ta.g = 90;\n+\tfoo (a.e);\n+\tfoo (a.f);\n+\tfoo (a.g);\n+\tc = a.f;\n+\tfoo (c);\n+\tb.e = 9;\n+\ta.e = b.e + 1 * c;\n+\ta.f = 30;\n+\tfoo (a.e);\n+\tfoo (a.f);\n+\tx = a.e * a.f;\n+\tfoo (x);\n+\n+}\n+/* { dg-final { scan-tree-dump-times \"a.e\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"a.f\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"a.g\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"b.e\" 0 \"optimized\" } } */"}, {"sha": "793ee24feb9354965df19d0a21aba15d46d2b2b3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/structopt-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstructopt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstructopt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstructopt-3.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+struct foo\n+{\n+\tint a;\n+\tint b;\n+} temp;\n+/* We should be able to optimize this to return 11. */\n+int main(void)\n+{\n+\ttemp.a = 5;\n+\ttemp.b = 6;\n+\treturn temp.a + temp.b;\n+}\n+/* { dg-final { scan-tree-dump-times \"return 11\" 1 \"optimized\" } } */"}, {"sha": "6bbec8f8d1e0b48a6edf3c0da34f1fb05c386004", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -1053,3 +1053,46 @@ mark_call_clobbered_vars_to_rename (void)\n       bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n     }\n }\n+\n+/* If REF is a COMPONENT_REF for a structure that can have sub-variables, and\n+   we know where REF is accessing, return the variable in REF that has the\n+   sub-variables.  If the return value is not NULL, POFFSET will be the\n+   offset, in bits, of REF inside the return value, and PSIZE will be the\n+   size, in bits, of REF inside the return value.  */\n+\n+tree\n+okay_component_ref_for_subvars (tree ref, HOST_WIDE_INT *poffset,\n+\t\t\t\tHOST_WIDE_INT *psize)\n+{\n+  tree result = NULL;\n+  HOST_WIDE_INT bitsize;\n+  HOST_WIDE_INT bitpos;\n+  tree offset;\n+  enum machine_mode mode;\n+  int unsignedp;\n+  int volatilep;\n+\n+  gcc_assert (!SSA_VAR_P (ref));\n+  *poffset = 0;  \n+  *psize = (unsigned int) -1;\n+  \n+  if (ref_contains_array_ref (ref))\n+    return result;\n+  ref = get_inner_reference (ref, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t     &unsignedp, &volatilep, false);\n+  if (TREE_CODE (ref) == INDIRECT_REF)\n+    return result;\n+  else if (offset == NULL && bitsize != -1 && SSA_VAR_P (ref))\n+    {\n+      *poffset = bitpos;      \n+      *psize = bitsize;\n+      if (get_subvars_for_var (ref) != NULL)\n+\treturn ref;\n+    }\n+  else if (SSA_VAR_P (ref))\n+    {\n+      if (get_subvars_for_var (ref) != NULL)\n+\treturn ref;\n+    }\n+  return NULL_TREE;\n+}"}, {"sha": "7701e5cc7fd3c5eac327bc3d8672fa9da916609c", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -878,4 +878,60 @@ op_iter_init_mustdef (ssa_op_iter *ptr, tree stmt, use_operand_p *kill,\n   op_iter_init (ptr, stmt, SSA_OP_VMUSTDEFKILL);\n   op_iter_next_mustdef (kill, def, ptr);\n }\n+\n+/* Return true if REF, a COMPONENT_REF, has an ARRAY_REF somewhere in it.  */\n+\n+static inline bool\n+ref_contains_array_ref (tree ref)\n+{\n+  while (handled_component_p (ref))\n+    {\n+      if (TREE_CODE (ref) == ARRAY_REF)\n+\treturn true;\n+      ref = TREE_OPERAND (ref, 0);\n+    }\n+  return false;\n+}\n+\n+/* Given a variable VAR, lookup and return a pointer to the list of\n+   subvariables for it.  */\n+\n+static inline subvar_t *\n+lookup_subvars_for_var (tree var)\n+{\n+  var_ann_t ann = var_ann (var);\n+  gcc_assert (ann);\n+  return &ann->subvars;\n+}\n+\n+/* Given a variable VAR, return a linked list of subvariables for VAR, or\n+   NULL, if there are no subvariables.  */\n+\n+static inline subvar_t\n+get_subvars_for_var (tree var)\n+{\n+  subvar_t subvars;\n+\n+  gcc_assert (SSA_VAR_P (var));  \n+  \n+  if (TREE_CODE (var) == SSA_NAME)\n+    subvars = *(lookup_subvars_for_var (SSA_NAME_VAR (var)));\n+  else\n+    subvars = *(lookup_subvars_for_var (var));\n+  return subvars;\n+}\n+\n+/* Return true if V is a tree that we can have subvars for.\n+   Normally, this is any aggregate type, however, due to implementation\n+   limitations ATM, we exclude array types as well.  */\n+\n+static inline bool\n+var_can_have_subvars (tree v)\n+{\n+  return (AGGREGATE_TYPE_P (TREE_TYPE (v)) &&\n+\t  TREE_CODE (TREE_TYPE (v)) != ARRAY_TYPE);\n+}\n+\n+  \n+\n #endif /* _TREE_FLOW_INLINE_H  */"}, {"sha": "25d3e5ab0815d0a6f30418074d22d63b79ac70bb", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -138,7 +138,26 @@ enum mem_tag_kind {\n   TYPE_TAG,\n \n   /* This variable is a name memory tag (NMT).  */\n-  NAME_TAG\n+  NAME_TAG,\n+\n+  /* This variable represents a structure field.  */\n+  STRUCT_FIELD\n+};\n+struct subvar;\n+typedef struct subvar *subvar_t;\n+\n+/* This structure represents a fake sub-variable for a structure field.  */\n+\n+struct subvar GTY(())\n+{\n+  /* Fake variable name */\n+  tree var;\n+  /* Offset inside structure.  */\n+  HOST_WIDE_INT offset;\n+  /* Size of field.  */\n+  HOST_WIDE_INT size;\n+  /* Next subvar for this structure.  */\n+  subvar_t next;\n };\n \n struct var_ann_d GTY(())\n@@ -211,6 +230,8 @@ struct var_ann_d GTY(())\n      live at the same time and this can happen for each call to the\n      dominator optimizer.  */\n   tree current_def;\n+  \n+  subvar_t subvars;\n };\n \n \n@@ -556,6 +577,9 @@ extern tree make_rename_temp (tree, const char *);\n extern void record_vars (tree);\n extern bool block_may_fallthru (tree block);\n \n+typedef tree tree_on_heap;\n+DEF_VEC_MALLOC_P (tree_on_heap);\n+\n /* In tree-ssa-alias.c  */\n extern void dump_may_aliases_for (FILE *, tree);\n extern void debug_may_aliases_for (tree);\n@@ -567,13 +591,15 @@ extern void dump_points_to_info_for (FILE *, tree);\n extern void debug_points_to_info_for (tree);\n extern bool may_be_aliased (tree);\n extern struct ptr_info_def *get_ptr_info (tree);\n-\n+static inline subvar_t get_subvars_for_var (tree);\n+static inline bool ref_contains_array_ref (tree);\n+extern tree okay_component_ref_for_subvars (tree, HOST_WIDE_INT *,\n+\t\t\t\t\t    HOST_WIDE_INT *);\n+static inline bool var_can_have_subvars (tree);\n /* Call-back function for walk_use_def_chains().  At each reaching\n    definition, a function with this prototype is called.  */\n typedef bool (*walk_use_def_chains_fn) (tree, tree, void *);\n \n-typedef tree tree_on_heap;\n-DEF_VEC_MALLOC_P (tree_on_heap);\n \n /* In tree-ssa.c  */\n extern void init_tree_ssa (void);"}, {"sha": "bb31a0edc35dd916ed942713823f1344902e1493", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -348,6 +348,7 @@ init_tree_optimization_passes (void)\n \n   p = &pass_all_optimizations.sub;\n   NEXT_PASS (pass_referenced_vars);\n+  NEXT_PASS (pass_create_structure_vars);\n   NEXT_PASS (pass_build_ssa);\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_rename_ssa_copies);"}, {"sha": "da5b8994fcf2f90a970055789b3c93e7c38d9d9f", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -167,5 +167,6 @@ extern struct tree_opt_pass pass_rest_of_compilation;\n extern struct tree_opt_pass pass_sink_code;\n extern struct tree_opt_pass pass_fre;\n extern struct tree_opt_pass pass_linear_transform;\n+extern struct tree_opt_pass pass_create_structure_vars;\n \n #endif /* GCC_TREE_PASS_H */"}, {"sha": "e38a8c2490c82319e992bce44364c98405c7cbf8", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 532, "deletions": 21, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -42,6 +42,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-pass.h\"\n #include \"convert.h\"\n #include \"params.h\"\n+#include \"vec.h\"\n \n /* 'true' after aliases have been computed (see compute_may_aliases).  */\n bool aliases_computed_p;\n@@ -524,8 +525,15 @@ init_alias_info (void)\n \t     variables, clear the call-clobbered flag.  Variables that\n \t     are intrinsically call-clobbered (globals, local statics,\n \t     etc) will not be marked by the aliasing code, so we can't\n-\t     remove them from CALL_CLOBBERED_VARS.  */\n-\t  if (ann->mem_tag_kind != NOT_A_TAG || !is_global_var (var))\n+\t     remove them from CALL_CLOBBERED_VARS.  \n+\n+\t     NB: STRUCT_FIELDS are still call clobbered if they are for\n+\t     a global variable, so we *don't* clear their call clobberedness\n+\t     just because they are tags, though we will clear it if they\n+\t     aren't for global variables.  */\n+\t  if (ann->mem_tag_kind == NAME_TAG \n+\t      || ann->mem_tag_kind == TYPE_TAG \n+\t      || !is_global_var (var))\n \t    clear_call_clobbered (var);\n \t}\n \n@@ -982,13 +990,28 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t     \n \t  if (may_alias_p (p_map->var, p_map->set, var, v_map->set))\n \t    {\n+\t      subvar_t svars;\n \t      size_t num_tag_refs, num_var_refs;\n \n \t      num_tag_refs = VARRAY_UINT (ai->num_references, tag_ann->uid);\n \t      num_var_refs = VARRAY_UINT (ai->num_references, v_ann->uid);\n \n \t      /* Add VAR to TAG's may-aliases set.  */\n-\t      add_may_alias (tag, var);\n+\n+\t      /* If this is an aggregate, we may have subvariables for it\n+\t\t that need to be pointed to.  */\n+\t      if (var_can_have_subvars (var)\n+\t\t  && (svars = get_subvars_for_var (var)))\n+\t\t{\n+\t\t  subvar_t sv;\n+\n+\t\t  for (sv = svars; sv; sv = sv->next)\n+\t\t    add_may_alias (tag, sv->var);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  add_may_alias (tag, var);\n+\t\t}\n \n \t      /* Update the total number of virtual operands due to\n \t\t aliasing.  Since we are adding one more alias to TAG's\n@@ -1040,7 +1063,7 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t  sbitmap may_aliases2 = p_map2->may_aliases;\n \n \t  /* If the pointers may not point to each other, do nothing.  */\n-\t  if (!may_alias_p (p_map1->var, p_map1->set, p_map2->var, p_map2->set))\n+\t  if (!may_alias_p (p_map1->var, p_map1->set, tag2, p_map2->set))\n \t    continue;\n \n \t  /* The two pointers may alias each other.  If they already have\n@@ -1293,7 +1316,9 @@ group_aliases (struct alias_info *ai)\n \t  tree alias = VARRAY_TREE (aliases, j);\n \t  var_ann_t ann = var_ann (alias);\n \n-\t  if (ann->mem_tag_kind == NOT_A_TAG && ann->may_aliases)\n+\t  if ((ann->mem_tag_kind == NOT_A_TAG \n+\t       || ann->mem_tag_kind == STRUCT_FIELD)\n+\t      && ann->may_aliases)\n \t    {\n \t      tree new_alias;\n \n@@ -1378,34 +1403,56 @@ setup_pointers_and_addressables (struct alias_info *ai)\n     {\n       tree var = referenced_var (i);\n       var_ann_t v_ann = var_ann (var);\n+      subvar_t svars;\n \n       /* Name memory tags already have flow-sensitive aliasing\n \t information, so they need not be processed by\n \t compute_flow_insensitive_aliasing.  Similarly, type memory\n \t tags are already accounted for when we process their\n-\t associated pointer.  */\n-      if (v_ann->mem_tag_kind != NOT_A_TAG)\n+\t associated pointer. \n+      \n+         Structure fields, on the other hand, have to have some of this\n+         information processed for them, but it's pointless to mark them\n+         non-addressable (since they are fake variables anyway).  */\n+      if (v_ann->mem_tag_kind != NOT_A_TAG\n+\t  && v_ann->mem_tag_kind != STRUCT_FIELD) \n \tcontinue;\n \n       /* Remove the ADDRESSABLE flag from every addressable variable whose\n          address is not needed anymore.  This is caused by the propagation\n          of ADDR_EXPR constants into INDIRECT_REF expressions and the\n          removal of dead pointer assignments done by the early scalar\n          cleanup passes.  */\n-      if (TREE_ADDRESSABLE (var))\n+      if (TREE_ADDRESSABLE (var) && v_ann->mem_tag_kind != STRUCT_FIELD)\n \t{\n \t  if (!bitmap_bit_p (ai->addresses_needed, v_ann->uid)\n \t      && TREE_CODE (var) != RESULT_DECL\n \t      && !is_global_var (var))\n \t    {\n+\t      bool okay_to_mark = true;\n+\t      /* Since VAR is now a regular GIMPLE register, we will need\n+\t\t to rename VAR into SSA afterwards.  */\n+\t      bitmap_set_bit (vars_to_rename, v_ann->uid);\n+\n+\t      if (var_can_have_subvars (var)\n+\t\t  && (svars = get_subvars_for_var (var)))\n+\t\t{\n+\t\t  subvar_t sv;\n+\n+\t\t  for (sv = svars; sv; sv = sv->next)\n+\t\t    {\t      \n+\t\t      var_ann_t svann = var_ann (sv->var);\n+\t\t      if (bitmap_bit_p (ai->addresses_needed, svann->uid))\n+\t\t\tokay_to_mark = false;\n+\t\t      bitmap_set_bit (vars_to_rename, svann->uid);\n+\t\t    }\n+\t\t}\n \t      /* The address of VAR is not needed, remove the\n \t\t addressable bit, so that it can be optimized as a\n \t\t regular variable.  */\n-\t      mark_non_addressable (var);\n+\t      if (okay_to_mark)\n+\t\tmark_non_addressable (var);\n \n-\t      /* Since VAR is now a regular GIMPLE register, we will need\n-\t\t to rename VAR into SSA afterwards.  */\n-\t      bitmap_set_bit (vars_to_rename, v_ann->uid);\n \t    }\n \t  else\n \t    {\n@@ -1414,6 +1461,14 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t\t clobber memory.  In those cases, we need to clobber\n \t\t all call-clobbered variables and all addressables.  */\n \t      bitmap_set_bit (addressable_vars, v_ann->uid);\n+\t      if (var_can_have_subvars (var)\n+\t\t  && (svars = get_subvars_for_var (var)))\n+\t\t{\n+\t\t  subvar_t sv;\n+\t\t  for (sv = svars; sv; sv = sv->next)\n+\t\t    bitmap_set_bit (addressable_vars, var_ann (sv->var)->uid);\n+\t\t}\n+\n \t    }\n \t}\n \n@@ -1422,7 +1477,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n       if (may_be_aliased (var))\n \t{\n \t  create_alias_map_for (var, ai);\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n+\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\t  \n \t}\n \n       /* Add pointer variables that have been dereferenced to the POINTERS\n@@ -1579,7 +1634,17 @@ maybe_create_global_var (struct alias_info *ai)\n \t .GLOBAL_VAR has been created, make it an alias for all\n \t call-clobbered variables.  */\n       if (global_var && var != global_var)\n-\tadd_may_alias (var, global_var);\n+\t{\n+\t  subvar_t svars;\n+\t  add_may_alias (var, global_var);\n+\t  if (var_can_have_subvars (var)\n+\t      && (svars = get_subvars_for_var (var)))\n+\t    {\n+\t      subvar_t sv;\n+\t      for (sv = svars; sv; sv = sv->next)\n+\t\tbitmap_set_bit (vars_to_rename, var_ann (sv->var)->uid);\n+\t    }\n+\t}\n       \n       bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n     }\n@@ -1644,7 +1709,6 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n       alias_stats.tbaa_resolved++;\n       return false;\n     }\n-\n   alias_stats.alias_mayalias++;\n   return true;\n }\n@@ -1894,23 +1958,73 @@ static void\n add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n {\n   struct ptr_info_def *pi = get_ptr_info (ptr);\n-  tree pt_var;\n+  tree pt_var = NULL_TREE;\n+  HOST_WIDE_INT offset, size;\n+  tree addrop;\n   size_t uid;\n+  tree ref;\n+  subvar_t svars;\n \n   gcc_assert (TREE_CODE (value) == ADDR_EXPR);\n \n-  pt_var = TREE_OPERAND (value, 0);\n-  if (REFERENCE_CLASS_P (pt_var))\n-    pt_var = get_base_address (pt_var);\n+  addrop = TREE_OPERAND (value, 0);\n+  if (REFERENCE_CLASS_P (addrop))\n+    pt_var = get_base_address (addrop);\n+  else \n+    pt_var = addrop;\n+\n+  /* If this is a component_ref, see if we can get a smaller number of\n+     variables to take the address of.  */\n+  if (TREE_CODE (addrop) == COMPONENT_REF\n+      && (ref = okay_component_ref_for_subvars (addrop, &offset ,&size)))\n+    {    \n+      subvar_t sv;\n+      svars = get_subvars_for_var (ref);\n+\n+      uid = var_ann (pt_var)->uid;\n+      bitmap_set_bit (ai->addresses_needed, uid);\n+      if (pi->pt_vars == NULL)\n+\tpi->pt_vars = BITMAP_GGC_ALLOC ();\n+       /* If the variable is a global, mark the pointer as pointing to\n+\t global memory (which will make its tag a global variable).  */\n+      if (is_global_var (pt_var))\n+\tpi->pt_global_mem = 1;     \n \n-  if (pt_var && SSA_VAR_P (pt_var))\n+      for (sv = svars; sv; sv = sv->next)\n+\t{\n+\t  if (offset == sv->offset && size == sv->size)\n+\t    bitmap_set_bit (pi->pt_vars, var_ann (sv->var)->uid);\n+\t  else if (offset >= sv->offset && offset < (sv->offset + sv->size))\n+\t    bitmap_set_bit (pi->pt_vars, var_ann (sv->var)->uid);\n+\t  else if (offset < sv->offset \n+\t\t   && (offset + size > sv->offset))\n+\t    bitmap_set_bit (pi->pt_vars, var_ann (sv->var)->uid);\n+\t}\n+    }\n+  else if (pt_var && SSA_VAR_P (pt_var))\n     {\n+    \n       uid = var_ann (pt_var)->uid;\n       bitmap_set_bit (ai->addresses_needed, uid);\n \n       if (pi->pt_vars == NULL)\n \tpi->pt_vars = BITMAP_GGC_ALLOC ();\n-      bitmap_set_bit (pi->pt_vars, uid);\n+\n+      /* If this is an aggregate, we may have subvariables for it that need\n+\t to be pointed to.  */\n+      if (var_can_have_subvars (pt_var)\n+\t  && (svars = get_subvars_for_var (pt_var)))\n+\t{\n+\t  subvar_t sv;\n+\t  for (sv = svars; sv; sv = sv->next)\n+\t    {\n+\t      uid = var_ann (sv->var)->uid;\n+\t      bitmap_set_bit (ai->addresses_needed, uid);\t      \n+\t      bitmap_set_bit (pi->pt_vars, uid);\n+\t    }\n+\t}\n+      else\t\n+\tbitmap_set_bit (pi->pt_vars, uid);\t  \n \n       /* If the variable is a global, mark the pointer as pointing to\n \t global memory (which will make its tag a global variable).  */\n@@ -2540,3 +2654,400 @@ may_be_aliased (tree var)\n \n   return true;\n }\n+\n+/* This structure is simply used during pushing fields onto the fieldstack\n+   to track the offset of the field, since bitpos_of_field gives it relative\n+   to its immediate containing type, and we want it relative to the ultimate\n+   containing object.  */\n+\n+typedef struct fieldoff\n+{\n+  tree field;\n+  HOST_WIDE_INT offset;  \n+} *fieldoff_t;\n+\n+DEF_VEC_MALLOC_P(fieldoff_t);\n+\n+/* Return the position, in bits, of FIELD_DECL from the beginning of its\n+   structure. \n+   Return -1 if the position is conditional or otherwise non-constant\n+   integer.  */\n+\n+static HOST_WIDE_INT\n+bitpos_of_field (const tree fdecl)\n+{\n+\n+  if (TREE_CODE (DECL_FIELD_OFFSET (fdecl)) != INTEGER_CST\n+      || TREE_CODE (DECL_FIELD_BIT_OFFSET (fdecl)) != INTEGER_CST)\n+    return -1;\n+\n+  return (tree_low_cst (DECL_FIELD_OFFSET (fdecl), 1) * 8) \n+    + tree_low_cst (DECL_FIELD_BIT_OFFSET (fdecl), 1);\n+}\n+\n+/* Given a TYPE, and a vector of field offsets FIELDSTACK, push all the fields\n+   of TYPE onto fieldstack, recording their offsets along the way.\n+   OFFSET is used to keep track of the offset in this entire structure, rather\n+   than just the immediately containing structure.  */\n+\n+static void\n+push_fields_onto_fieldstack (tree type, VEC(fieldoff_t) **fieldstack, \n+\t\t\t     HOST_WIDE_INT offset)\n+{\n+  fieldoff_t pair;\n+  tree field = TYPE_FIELDS (type);\n+  if (!field)\n+    return;\n+  if (var_can_have_subvars (field)\n+      && TREE_CODE (field) == FIELD_DECL)\n+    {\n+      size_t before = VEC_length (fieldoff_t, *fieldstack);\n+      /* Empty structures may have actual size, like in C++. So see if we\n+\t actually end up pushing a field, and if not, if the size is non-zero,\n+\t push the field onto the stack */\n+      push_fields_onto_fieldstack (TREE_TYPE (field), fieldstack, offset);\n+      if (before == VEC_length (fieldoff_t, *fieldstack)\n+\t  && DECL_SIZE (field)\n+\t  && !integer_zerop (DECL_SIZE (field)))\n+\t{\n+\t  pair = xmalloc (sizeof (struct fieldoff));\n+\t  pair->field = field;\n+\t  pair->offset = offset;\n+\t  VEC_safe_push (fieldoff_t, *fieldstack, pair);\n+\t}\n+    }\n+  else if (TREE_CODE (field) == FIELD_DECL)\n+    {\n+      pair = xmalloc (sizeof (struct fieldoff));\n+      pair->field = field;\n+      pair->offset = offset + bitpos_of_field (field);\n+      VEC_safe_push (fieldoff_t, *fieldstack, pair);\n+    }\n+  for (field = TREE_CHAIN (field); field; field = TREE_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+      if (var_can_have_subvars (field))\n+\t{\n+\t  push_fields_onto_fieldstack (TREE_TYPE (field), fieldstack, \n+\t\t\t\t       offset + bitpos_of_field (field));\n+\t}\n+      else\n+\t{\n+\t  pair = xmalloc (sizeof (struct fieldoff));\n+\t  pair->field = field;\n+\t  pair->offset = offset + bitpos_of_field (field);\n+\t  VEC_safe_push (fieldoff_t, *fieldstack, pair);\n+\t}\n+    }\n+}\n+\n+\n+/* This represents the used range of a variable.  */\n+\n+typedef struct used_part\n+{\n+  HOST_WIDE_INT minused;\n+  HOST_WIDE_INT maxused;\n+} *used_part_t;\n+\n+/* An array of used_part structures, indexed by variable uid.  */\n+\n+static used_part_t *used_portions;\n+\n+/* Given a variable uid, UID, get or create the entry in the used portions\n+   table for the variable.  */\n+\n+static used_part_t\n+get_or_create_used_part_for (size_t uid)\n+{\n+  used_part_t up;\n+  if (used_portions[uid] == NULL)\n+    {\n+      up = xcalloc (1, sizeof (struct used_part));\n+      up->minused = INT_MAX;\n+      up->maxused = 0;\n+    }\n+  else\n+    up = used_portions[uid];\n+  return up;\n+}\n+\n+\t    \n+  \n+/* Given an aggregate VAR, create the subvariables that represent its\n+   fields.  */\n+\n+static void\n+create_overlap_variables_for (tree var)\n+{\n+  VEC(fieldoff_t) *fieldstack = NULL;\n+  used_part_t up;\n+  size_t uid = var_ann (var)->uid;\n+\n+  if (used_portions[uid] == NULL)\n+    return;\n+\n+  push_fields_onto_fieldstack (TREE_TYPE (var), &fieldstack, 0);\n+  if (VEC_length (fieldoff_t, fieldstack) != 0)\n+    {\n+      subvar_t *subvars;\n+      fieldoff_t fo;\n+      bool notokay = false;\n+      int i;\n+\n+      /* Not all fields have DECL_SIZE set, and those that don't, we don't\n+\t know their size, and thus, can't handle.\n+\t The same is true of fields with DECL_SIZE that is not an integer\n+\t constant (such as variable sized fields).\n+\t Fields with offsets which are not constant will have an offset < 0 \n+\t We *could* handle fields that are constant sized arrays, but\n+\t currently don't.  Doing so would require some extra changes to\n+\t tree-ssa-operands.c.  */\n+\n+      for (i = 0; VEC_iterate (fieldoff_t, fieldstack, i, fo); i++)\n+\t{\n+\t  if (!DECL_SIZE (fo->field) \n+\t      || TREE_CODE (DECL_SIZE (fo->field)) != INTEGER_CST\n+\t      || TREE_CODE (TREE_TYPE (fo->field)) == ARRAY_TYPE\n+\t      || fo->offset < 0)\n+\t    {\n+\t      notokay = true;\n+\t      break;\n+\t    }\n+\t}\n+      /* Cleanup after ourselves if we can't create overlap variables.  */\n+      if (notokay)\n+\t{\n+\t  while (VEC_length (fieldoff_t, fieldstack) != 0)\n+\t    {\n+\t      fo = VEC_pop (fieldoff_t, fieldstack);\n+\t      free (fo);\n+\t    }\n+\t  VEC_free (fieldoff_t, fieldstack);\n+\t  return;\n+\t}\n+      /* Otherwise, create the variables.  */\n+      subvars = lookup_subvars_for_var (var);\n+      up = used_portions[uid];\n+      \n+      while (VEC_length (fieldoff_t, fieldstack) != 0)\n+\t{\n+\t  subvar_t sv = ggc_alloc (sizeof (struct subvar));\n+\t  HOST_WIDE_INT fosize;\n+\t  var_ann_t ann;\n+\n+\t  fo = VEC_pop (fieldoff_t, fieldstack);\t  \n+\t  fosize = TREE_INT_CST_LOW (DECL_SIZE (fo->field));\n+\n+\t  if ((fo->offset <= up->minused\n+\t       && fo->offset + fosize <= up->minused)\n+\t      || fo->offset >= up->maxused)\n+\t    {\n+\t      free (fo);\n+\t      continue;\n+\t    }\n+\n+\t  sv->offset = fo->offset;\n+\t  sv->size = fosize;\n+\t  sv->next = *subvars;\n+\t  sv->var = create_tmp_var_raw (TREE_TYPE (fo->field), \"SFT\");\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"structure field tag %s created for var %s\",\n+\t\t       get_name (sv->var), get_name (var));\n+\t      fprintf (dump_file, \" offset \" HOST_WIDE_INT_PRINT_DEC,\n+\t\t       sv->offset);\n+\t      fprintf (dump_file, \" size \" HOST_WIDE_INT_PRINT_DEC,\n+\t\t       sv->size);\n+\t      fprintf (dump_file, \"\\n\");\n+\t      \n+\t    }\n+\t  \n+\t  /* We need to copy the various flags from var to sv->var, so that\n+\t     they are is_global_var iff the original variable was.  */\n+\n+\t  DECL_EXTERNAL (sv->var) = DECL_EXTERNAL (var);\n+\t  TREE_PUBLIC  (sv->var) = TREE_PUBLIC (var);\n+\t  TREE_STATIC (sv->var) = TREE_STATIC (var);\n+\t  TREE_READONLY (sv->var) = TREE_READONLY (var);\n+\n+\t  /* Like other memory tags, these need to be marked addressable to\n+\t     keep is_gimple_reg from thinking they are real.  */\n+\t  TREE_ADDRESSABLE (sv->var) = 1;\n+\n+\t  DECL_CONTEXT (sv->var) = DECL_CONTEXT (var);\n+\n+\t  ann = get_var_ann (sv->var);\n+\t  ann->mem_tag_kind = STRUCT_FIELD; \n+\t  ann->type_mem_tag = NULL;  \t\n+\t  add_referenced_tmp_var (sv->var);\n+\t    \n+\t  *subvars = sv;\n+\t  free (fo);\n+\t}\n+    }\n+  \n+  VEC_free (fieldoff_t, fieldstack);\n+}\n+\n+\n+/* Find the conservative answer to the question of what portions of what \n+   structures are used by this statement.  We assume that if we have a\n+   component ref with a known size + offset, that we only need that part\n+   of the structure.  For unknown cases, or cases where we do something\n+   to the whole structure, we assume we need to create fields for the \n+   entire structure.  */\n+\n+static tree\n+find_used_portions (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n+{\n+  switch (TREE_CODE (*tp))\n+    {\n+    case COMPONENT_REF:\n+      {\n+\tHOST_WIDE_INT bitsize;\n+\tHOST_WIDE_INT bitpos;\n+\ttree offset;\n+\tenum machine_mode mode;\n+\tint unsignedp;\n+\tint volatilep;\t\n+\ttree ref;\n+\tref = get_inner_reference (*tp, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t   &unsignedp, &volatilep, false);\n+\tif (DECL_P (ref) && offset == NULL && bitsize != -1)\n+\t  {\t    \n+\t    size_t uid = var_ann (ref)->uid;\n+\t    used_part_t up;\n+\n+\t    up = get_or_create_used_part_for (uid);\t    \n+\n+\t    if (bitpos <= up->minused)\n+\t      up->minused = bitpos;\n+\t    if ((bitpos + bitsize >= up->maxused))\n+\t      up->maxused = bitpos + bitsize;\t    \n+\n+\t    used_portions[uid] = up;\n+\n+\t    *walk_subtrees = 0;\n+\t    return NULL_TREE;\n+\t  }\n+\telse if (DECL_P (ref))\n+\t  {\n+\t    if (DECL_SIZE (ref)\n+\t\t&& var_can_have_subvars (ref)\n+\t\t&& TREE_CODE (DECL_SIZE (ref)) == INTEGER_CST)\n+\t      {\n+\t\tused_part_t up;\n+\t\tsize_t uid = var_ann (ref)->uid;\n+\n+\t\tup = get_or_create_used_part_for (uid);\n+\n+\t\tup->minused = 0;\n+\t\tup->maxused = TREE_INT_CST_LOW (DECL_SIZE (ref));\n+\n+\t\tused_portions[uid] = up;\n+\n+\t\t*walk_subtrees = 0;\n+\t\treturn NULL_TREE;\n+\t      }\n+\t  }\n+      }\n+      break;\n+    case VAR_DECL:\n+    case PARM_DECL:\n+      {\n+\ttree var = *tp;\n+\tif (DECL_SIZE (var)\n+\t    && var_can_have_subvars (var)\n+\t    && TREE_CODE (DECL_SIZE (var)) == INTEGER_CST)\n+\t  {\n+\t    used_part_t up;\n+\t    size_t uid = var_ann (var)->uid;\t    \n+\t    \n+\t    up = get_or_create_used_part_for (uid);\n+ \n+\t    up->minused = 0;\n+\t    up->maxused = TREE_INT_CST_LOW (DECL_SIZE (var));\n+\n+\t    used_portions[uid] = up;\n+\t    *walk_subtrees = 0;\n+\t    return NULL_TREE;\n+\t  }\n+      }\n+      break;\n+      \n+    default:\n+      break;\n+      \n+    }\n+  return NULL_TREE;\n+}\n+\n+/* We are about to create some new referenced variables, and we need the\n+   before size.  */\n+\n+static size_t old_referenced_vars;\n+\n+\n+/* Create structure field variables for structures used in this function.  */\n+\n+static void\n+create_structure_vars (void)\n+{\n+  basic_block bb;\n+  size_t i;\n+\n+  old_referenced_vars = num_referenced_vars;\n+  used_portions = xcalloc (num_referenced_vars, sizeof (used_part_t));\n+  \n+  FOR_EACH_BB (bb)\n+    {\n+      block_stmt_iterator bsi;\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  walk_tree_without_duplicates (bsi_stmt_ptr (bsi), \n+\t\t\t\t\tfind_used_portions,\n+\t\t\t\t\tNULL);\n+\t}\n+    }\n+  for (i = 0; i < old_referenced_vars; i++)\n+    {\n+      tree var = referenced_var (i);\n+      /* The C++ FE creates vars without DECL_SIZE set, for some reason.  */\n+      if (var \t  \n+\t  && DECL_SIZE (var)\n+\t  && var_can_have_subvars (var)\n+\t  && var_ann (var)->mem_tag_kind == NOT_A_TAG\n+\t  && TREE_CODE (DECL_SIZE (var)) == INTEGER_CST)\n+\tcreate_overlap_variables_for (var);\n+    }\n+  for (i = 0; i < old_referenced_vars; i++)\n+    free (used_portions[i]);\n+\n+  free (used_portions);\n+}\n+\n+static bool\n+gate_structure_vars (void)\n+{\n+  return flag_tree_salias != 0;\n+}\n+\n+struct tree_opt_pass pass_create_structure_vars = \n+{\n+  \"salias\",\t\t /* name */\n+  gate_structure_vars,\t /* gate */\n+  create_structure_vars, /* execute */\n+  NULL,\t\t\t /* sub */\n+  NULL,\t\t\t /* next */\n+  0,\t\t\t /* static_pass_number */\n+  0,\t\t\t /* tv_id */\n+  PROP_cfg,\t\t /* properties_required */\n+  0,\t\t\t /* properties_provided */\n+  0,\t\t\t /* properties_destroyed */\n+  0,\t\t\t /* todo_flags_start */\n+  TODO_dump_func,\t /* todo_flags_finish */\n+  0\t\t\t /* letter */\n+};\n+"}, {"sha": "8db74e1fadb85416b36958bfb1630e772821cc35", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 142, "deletions": 39, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -683,8 +683,12 @@ finalize_ssa_v_must_defs (v_must_def_optype *old_ops_p,\n   if (num == 0)\n     return NULL;\n \n-  /* There should only be a single V_MUST_DEF per assignment.  */\n-  gcc_assert (TREE_CODE (stmt) != MODIFY_EXPR || num <= 1);\n+  /* In the presence of subvars, there may be more than one V_MUST_DEF per\n+     statement (one for each subvar).  It is a bit expensive to verify that\n+     all must-defs in a statement belong to subvars if there is more than one\n+     MUST-def, so we don't do it.  Suffice to say, if you reach here without\n+     having subvars, and have num >1, you have hit a bug. */\n+     \n \n   old_ops = *old_ops_p;\n \n@@ -907,7 +911,6 @@ build_ssa_operands (tree stmt, stmt_ann_t ann, stmt_operands_p old_ops,\n \t  lhs = TREE_OPERAND (lhs, 0);\n \n \tif (TREE_CODE (lhs) != ARRAY_REF && TREE_CODE (lhs) != ARRAY_RANGE_REF\n-\t    && TREE_CODE (lhs) != COMPONENT_REF\n \t    && TREE_CODE (lhs) != BIT_FIELD_REF\n \t    && TREE_CODE (lhs) != REALPART_EXPR\n \t    && TREE_CODE (lhs) != IMAGPART_EXPR)\n@@ -1021,6 +1024,49 @@ get_stmt_operands (tree stmt)\n }\n \n \n+/* Return true if OFFSET and SIZE define a range that overlaps with some\n+   portion of the range of SV, a subvar.  If there was an exact overlap,\n+   *EXACT will be set to true upon return. */\n+\n+static bool\n+overlap_subvar (HOST_WIDE_INT offset, HOST_WIDE_INT size,\n+\t\tsubvar_t sv,  bool *exact)\n+{\n+  /* There are three possible cases of overlap.\n+     1. We can have an exact overlap, like so:   \n+     |offset, offset + size             |\n+     |sv->offset, sv->offset + sv->size |\n+     \n+     2. We can have offset starting after sv->offset, like so:\n+     \n+           |offset, offset + size              |\n+     |sv->offset, sv->offset + sv->size  |\n+\n+     3. We can have offset starting before sv->offset, like so:\n+     \n+     |offset, offset + size    |\n+       |sv->offset, sv->offset + sv->size|\n+  */\n+\n+  if (exact)\n+    *exact = false;\n+  if (offset == sv->offset && size == sv->size)\n+    {\n+      if (exact)\n+\t*exact = true;\n+      return true;\n+    }\n+  else if (offset >= sv->offset && offset < (sv->offset + sv->size))\n+    {\n+      return true;\n+    }\n+  else if (offset < sv->offset && (offset + size > sv->offset))\n+    {\n+      return true;\n+    }\n+  return false;\n+\n+}\n /* Recursively scan the expression pointed by EXPR_P in statement referred to\n    by INFO.  FLAGS is one of the OPF_* constants modifying how to interpret the\n    operands found.  */\n@@ -1068,11 +1114,25 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case PARM_DECL:\n     case RESULT_DECL:\n     case CONST_DECL:\n-      /* If we found a variable, add it to DEFS or USES depending\n-\t on the operand flags.  */\n-      add_stmt_operand (expr_p, s_ann, flags);\n-      return;\n-\n+      {\n+\tsubvar_t svars;\n+\t\n+\t/* Add the subvars for a variable if it has subvars, to DEFS or USES.\n+\t   Otherwise, add the variable itself.  \n+\t   Whether it goes to USES or DEFS depends on the operand flags.  */\n+\tif (var_can_have_subvars (expr)\n+\t    && (svars = get_subvars_for_var (expr)))\n+\t  {\n+\t    subvar_t sv;\n+\t    for (sv = svars; sv; sv = sv->next)\n+\t      add_stmt_operand (&sv->var, s_ann, flags);\n+\t  }\n+\telse\n+\t  {\n+\t    add_stmt_operand (expr_p, s_ann, flags);\n+\t  }\n+\treturn;\n+      }\n     case MISALIGNED_INDIRECT_REF:\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n       /* fall through */\n@@ -1104,30 +1164,39 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case COMPONENT_REF:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      /* Similarly to arrays, references to compound variables (complex\n-\t types and structures/unions) are globbed.\n-\n-\t FIXME: This means that\n-\n-     \t\t\ta.x = 6;\n-\t\t\ta.y = 7;\n-\t\t\tfoo (a.x, a.y);\n-\n-\t will not be constant propagated because the two partial\n-\t definitions to 'a' will kill each other.  Note that SRA may be\n-\t able to fix this problem if 'a' can be scalarized.  */\n-\n-      /* If the LHS of the compound reference is not a regular variable,\n-\t recurse to keep looking for more operands in the subexpression.  */\n-      if (SSA_VAR_P (TREE_OPERAND (expr, 0)))\n-\tadd_stmt_operand (expr_p, s_ann, flags);\n-      else\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n-\n-      if (code == COMPONENT_REF)\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n-      return;\n-\n+      {\n+\ttree ref;\n+\tHOST_WIDE_INT offset, size;\n+ \t/* This component ref becomes an access to all of the subvariables\n+\t   it can touch,  if we can determine that, but *NOT* the real one.\n+\t   If we can't determine which fields we could touch, the recursion\n+\t   will eventually get to a variable and add *all* of its subvars, or\n+\t   whatever is the minimum correct subset.  */\n+\n+\tref = okay_component_ref_for_subvars (expr, &offset, &size);\n+\tif (ref)\n+\t  {\t  \n+\t    subvar_t svars = get_subvars_for_var (ref);\n+\t    subvar_t sv;\n+\t    for (sv = svars; sv; sv = sv->next)\n+\t      {\n+\t\tbool exact;\t\t\n+\t\tif (overlap_subvar (offset, size, sv, &exact))\n+\t\t  {\n+\t\t    if (exact)\n+\t\t      flags &= ~opf_kill_def;\n+\t\t    add_stmt_operand (&sv->var, s_ann, flags);\n+\t\t  }\n+\t      }\n+\t  }\n+\telse\n+\t  get_expr_operands (stmt, &TREE_OPERAND (expr, 0), \n+\t\t\t     flags & ~opf_kill_def);\n+\t\n+\tif (code == COMPONENT_REF)\n+\t  get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n+\treturn;\n+      }\n     case WITH_SIZE_EXPR:\n       /* WITH_SIZE_EXPR is a pass-through reference to its first argument,\n \t and an rvalue reference to its second argument.  */\n@@ -1158,7 +1227,6 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t  op = TREE_OPERAND (expr, 0);\n \tif (TREE_CODE (op) == ARRAY_REF\n \t    || TREE_CODE (op) == ARRAY_RANGE_REF\n-\t    || TREE_CODE (op) == COMPONENT_REF\n \t    || TREE_CODE (op) == REALPART_EXPR\n \t    || TREE_CODE (op) == IMAGPART_EXPR)\n \t  subflags = opf_is_def;\n@@ -1554,9 +1622,10 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n \t    {\n \t      if (flags & opf_kill_def)\n \t\t{\n-\t\t  /* Only regular variables may get a V_MUST_DEF\n-\t\t     operand.  */\n-\t\t  gcc_assert (v_ann->mem_tag_kind == NOT_A_TAG);\n+\t\t  /* Only regular variables or struct fields may get a\n+\t\t     V_MUST_DEF operand.  */\n+\t\t  gcc_assert (v_ann->mem_tag_kind == NOT_A_TAG \n+\t\t\t      || v_ann->mem_tag_kind == STRUCT_FIELD);\n \t\t  /* V_MUST_DEF for non-aliased, non-GIMPLE register \n \t\t    variable definitions.  */\n \t\t  append_v_must_def (var);\n@@ -1615,26 +1684,60 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n     }\n }\n \n-\n+  \n /* Record that VAR had its address taken in the statement with annotations\n    S_ANN.  */\n \n static void\n note_addressable (tree var, stmt_ann_t s_ann)\n {\n+  tree ref;\n+  subvar_t svars;\n+  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT size;\n+\n   if (!s_ann)\n     return;\n+  \n+  /* If this is a COMPONENT_REF, and we know exactly what it touches, we only\n+     take the address of the subvariables it will touch.\n+     Otherwise, we take the address of all the subvariables, plus the real\n+     ones.  */\n \n+  if (var && TREE_CODE (var) == COMPONENT_REF \n+      && (ref = okay_component_ref_for_subvars (var, &offset, &size)))\n+    {\n+      subvar_t sv;\n+      svars = get_subvars_for_var (ref);\n+      \n+      if (s_ann->addresses_taken == NULL)\n+\ts_ann->addresses_taken = BITMAP_GGC_ALLOC ();      \n+      \n+      for (sv = svars; sv; sv = sv->next)\n+\t{\n+\t  if (overlap_subvar (offset, size, sv, NULL))\n+\t    bitmap_set_bit (s_ann->addresses_taken, var_ann (sv->var)->uid);\n+\t}\n+      return;\n+    }\n+  \n   var = get_base_address (var);\n   if (var && SSA_VAR_P (var))\n     {\n       if (s_ann->addresses_taken == NULL)\n-\ts_ann->addresses_taken = BITMAP_GGC_ALLOC ();\n+\ts_ann->addresses_taken = BITMAP_GGC_ALLOC ();      \n+      \n       bitmap_set_bit (s_ann->addresses_taken, var_ann (var)->uid);\n+      if (var_can_have_subvars (var)\n+\t  && (svars = get_subvars_for_var (var)))\n+\t{\n+\t  subvar_t sv;\n+\t  for (sv = svars; sv; sv = sv->next)\n+\t    bitmap_set_bit (s_ann->addresses_taken, var_ann (sv->var)->uid);\n+\t}\n     }\n }\n \n-\n /* Add clobbering definitions for .GLOBAL_VAR or for each of the call\n    clobbered variables in the function.  */\n "}, {"sha": "2595e49772323ee3eee41300a864cd99bd168cc4", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -70,7 +70,7 @@ static bool vect_base_addr_differ_p (struct data_reference *,\n \t\t\t\t     struct data_reference *drb, bool *);\n static tree vect_object_analysis (tree, tree, bool, tree, \n \t\t\t\t  struct data_reference **, tree *, tree *, \n-\t\t\t\t  tree *, bool *, tree *);\n+\t\t\t\t  tree *, bool *, tree *, subvar_t *);\n static tree vect_address_analysis (tree, tree, bool, tree, \n \t\t\t\t   struct data_reference *, tree *, tree *, \n \t\t\t\t   tree *, bool *);\n@@ -1377,6 +1377,7 @@ vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype,\n   tree oprnd0, oprnd1, base_address, offset_expr, base_addr0, base_addr1;\n   tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n   tree dummy;\n+  subvar_t dummy2;\n \n   switch (TREE_CODE (expr))\n     {\n@@ -1426,9 +1427,10 @@ vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype,\n       return base_addr0 ? base_addr0 : base_addr1;\n \n     case ADDR_EXPR:\n-      base_address = vect_object_analysis (TREE_OPERAND (expr, 0), stmt, is_read, \n-\t\t\t\t   vectype, &dr, offset, misalign, step, \n-\t\t\t\t   base_aligned, &dummy);\n+      base_address = vect_object_analysis (TREE_OPERAND (expr, 0), stmt,\n+\t\t\t\t\t   is_read, vectype, &dr, offset, \n+\t\t\t\t\t   misalign, step, base_aligned, \n+\t\t\t\t\t   &dummy, &dummy2);\n       return base_address;\n \n     case SSA_NAME:\n@@ -1507,6 +1509,7 @@ vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype,\n    STEP - evolution of the DR_REF in the loop\n    BASE_ALIGNED - indicates if BASE is aligned\n    MEMTAG - memory tag for aliasing purposes\n+   SUBVAR - Sub-variables of the variable\n  \n    If something unexpected is encountered (an unsupported form of data-ref),\n    then NULL_TREE is returned.  */\n@@ -1515,7 +1518,8 @@ static tree\n vect_object_analysis (tree memref, tree stmt, bool is_read,\n \t\t      tree vectype, struct data_reference **dr,\n \t\t      tree *offset, tree *misalign, tree *step,\n-\t\t      bool *base_aligned, tree *memtag)\n+\t\t      bool *base_aligned, tree *memtag,\n+\t\t      subvar_t *subvars)\n {\n   tree base = NULL_TREE, base_address = NULL_TREE;\n   tree object_offset = ssize_int (0), object_misalign = ssize_int (0);\n@@ -1611,6 +1615,8 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n \t   us to object.  */\n \tDR_BASE_NAME ((*dr)) = memref;\n \n+      if (SSA_VAR_P (memref) && var_can_have_subvars (memref))\t\n+\t*subvars = get_subvars_for_var (memref);\n       base_address = build_fold_addr_expr (memref);\n       *memtag = memref;\n     }\n@@ -1698,6 +1704,9 @@ vect_object_analysis (tree memref, tree stmt, bool is_read,\n     /* MEMREF cannot be analyzed.  */\n     return NULL_TREE;\n \n+  if (SSA_VAR_P (*memtag) && var_can_have_subvars (*memtag))\n+    *subvars = get_subvars_for_var (*memtag);\n+\n   /* Part 2: Combine the results of object and address analysis to calculate \n      INITIAL_OFFSET, STEP and misalignment info.  */\n   *offset = size_binop (PLUS_EXPR, object_offset, address_offset);\n@@ -1780,6 +1789,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  tree scalar_type, vectype;\t  \n \t  tree base, offset, misalign, step, tag;\n \t  bool base_aligned;\n+\t  subvar_t subvars;\n \n \t  /* Assumption: there exists a data-ref in stmt, if and only if \n              it has vuses/vdefs.  */\n@@ -1843,7 +1853,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  dr = NULL; \n \t  base = vect_object_analysis (memref, stmt, is_read, vectype, &dr, \n \t\t\t\t       &offset, &misalign, &step, \n-\t\t\t\t       &base_aligned, &tag);\n+\t\t\t\t       &base_aligned, &tag, &subvars);\n \t  if (!base)\n \t    {\n \t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS,\n@@ -1860,6 +1870,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n \t  STMT_VINFO_VECT_MISALIGNMENT (stmt_info) = misalign;\n \t  STMT_VINFO_VECT_BASE_ALIGNED_P (stmt_info) = base_aligned;\n \t  STMT_VINFO_MEMTAG (stmt_info) = tag;\n+\t  STMT_VINFO_SUBVARS (stmt_info) = subvars;\n \t  STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \t  VARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n \t  STMT_VINFO_DATA_REF (stmt_info) = dr;"}, {"sha": "1a82f288cb2bc92aee4fe7ebe95482071d7a9fe0", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -353,12 +353,14 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   tag = STMT_VINFO_MEMTAG (stmt_info);\n   gcc_assert (tag);\n   get_var_ann (vect_ptr)->type_mem_tag = tag;\n-  \n+  get_var_ann (vect_ptr)->subvars = STMT_VINFO_SUBVARS (stmt_info);\n+\n   /* Mark for renaming all aliased variables\n      (i.e, the may-aliases of the type-mem-tag).  */\n   nvuses = NUM_VUSES (vuses);\n   nv_may_defs = NUM_V_MAY_DEFS (v_may_defs);\n   nv_must_defs = NUM_V_MUST_DEFS (v_must_defs);\n+\n   for (i = 0; i < nvuses; i++)\n     {\n       tree use = VUSE_OP (vuses, i);"}, {"sha": "b761f4d0ef3a231b475180340e9cbdcb7e0f0160", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75ab022811aa05c49657d6c48471962b48c9666/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c75ab022811aa05c49657d6c48471962b48c9666", "patch": "@@ -172,6 +172,7 @@ typedef struct _stmt_vec_info {\n \n   /* Aliasing information.  */\n   tree memtag;\n+  subvar_t subvars;\n \n   /** The following fields are used to store the information about \n       data-reference. {base_address + initial_offset} is the first location \n@@ -213,6 +214,7 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VEC_STMT(S)            (S)->vectorized_stmt\n #define STMT_VINFO_DATA_REF(S)            (S)->data_ref_info\n #define STMT_VINFO_MEMTAG(S)              (S)->memtag\n+#define STMT_VINFO_SUBVARS(S)              (S)->subvars\n #define STMT_VINFO_VECT_DR_BASE_ADDRESS(S)(S)->base_address\n #define STMT_VINFO_VECT_INIT_OFFSET(S)    (S)->initial_offset\n #define STMT_VINFO_VECT_STEP(S)           (S)->step"}]}