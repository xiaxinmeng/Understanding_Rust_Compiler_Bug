{"sha": "56f48ce9765aa2b6d4742a4923fee581a12c1418", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZmNDhjZTk3NjVhYTJiNmQ0NzQyYTQ5MjNmZWU1ODFhMTJjMTQxOA==", "commit": {"author": {"name": "Dave Brolley", "email": "brolley@cygnus.com", "date": "1998-07-20T13:35:38Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1998-07-20T13:35:38Z"}, "message": "configure.in (enable_c_mbchar): New configure option.\n\nMon Jul 20 16:16:38 1998  Dave Brolley  <brolley@cygnus.com>\n\t* configure.in (enable_c_mbchar): New configure option.\n\t(extra_cpp_objs): Always available now.\n\t* cexp.y (mbchar.h): #include it.\n\t(yylex): Handle Multibyte characters in character literals.\n\t* cccp.c (mbchar.h): #include it.\n\t(main): Set character set based on LANG environment variable.\n\t(rescan): Handle multibyte characters in comments.\n\t(skip_if_group): See above.\n\t(validate_else): See above.\n\t(skip_to_end_of_comment): See above.\n\t(macarg1): See above.\n\t(discard_comments): See above.\n\t(rescan): Handle multibyte characters in string and character literals.\n\t(collect_expansion): See above.\n\t(skip_quoted_string): See above.\n\t(macroexpand): See above.\n\t(macarg1): See above.\n\t(discard_comments): See above.\n\t(change_newlines): See above.\n\t* c-lex.c (mbchar.h): #include it.\n\t(GET_ENVIRONMENT): New macro.\n\t(init_lex): Set character set based on LANG environment variable.\n\t(yylex): Handle multibyte characters in character literals.\n\t(yylex): Handle multibyte characters in string literals.\n\t* Makefile.in (mbchar.o): New target.\n\t(cccp$(exeext)): @extra_cpp_objs@ is always available.\n\t(cppmain$(exeext)): @extra_cpp_objs@ is always available.\n\t* mbchar.[ch]: New files for multibyte character handling.\n\nFrom-SVN: r21303", "tree": {"sha": "671dda9b98d314335b4825d12e41d06427ebd8ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/671dda9b98d314335b4825d12e41d06427ebd8ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56f48ce9765aa2b6d4742a4923fee581a12c1418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56f48ce9765aa2b6d4742a4923fee581a12c1418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56f48ce9765aa2b6d4742a4923fee581a12c1418", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56f48ce9765aa2b6d4742a4923fee581a12c1418/comments", "author": null, "committer": null, "parents": [{"sha": "689fcba8611f93ce241fa090a0423e8d35324027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/689fcba8611f93ce241fa090a0423e8d35324027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/689fcba8611f93ce241fa090a0423e8d35324027"}], "stats": {"total": 1143, "additions": 987, "deletions": 156}, "files": [{"sha": "b5f465adfb9a6f5421b585729339e158cc995f73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56f48ce9765aa2b6d4742a4923fee581a12c1418", "patch": "@@ -1,3 +1,39 @@\n+Mon Jul 20 16:16:38 1998  Dave Brolley  <brolley@cygnus.com>\n+\n+\t* configure.in (enable_c_mbchar): New configure option.\n+\t(extra_cpp_objs): Always available now.\n+\n+\t* cexp.y (mbchar.h): #include it.\n+\t(yylex): Handle Multibyte characters in character literals.\n+\n+\t* cccp.c (mbchar.h): #include it.\n+\t(main): Set character set based on LANG environment variable.\n+\t(rescan): Handle multibyte characters in comments.\n+\t(skip_if_group): See above.\n+\t(validate_else): See above.\n+\t(skip_to_end_of_comment): See above.\n+\t(macarg1): See above.\n+\t(discard_comments): See above.\n+\t(rescan): Handle multibyte characters in string and character literals.\n+\t(collect_expansion): See above.\n+\t(skip_quoted_string): See above.\n+\t(macroexpand): See above.\n+\t(macarg1): See above.\n+\t(discard_comments): See above.\n+\t(change_newlines): See above.\n+\n+\t* c-lex.c (mbchar.h): #include it.\n+\t(GET_ENVIRONMENT): New macro.\n+\t(init_lex): Set character set based on LANG environment variable.\n+\t(yylex): Handle multibyte characters in character literals.\n+\t(yylex): Handle multibyte characters in string literals.\n+\n+\t* Makefile.in (mbchar.o): New target.\n+\t(cccp$(exeext)): @extra_cpp_objs@ is always available.\n+\t(cppmain$(exeext)): @extra_cpp_objs@ is always available.\n+\n+\t* mbchar.[ch]: New files for multibyte character handling.\n+\n Mon Jul 20 01:11:11 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n \n \t* jump.c (jump_optimize): When simplifying noop moves and"}, {"sha": "ea0a0b52e9aa7d68b49834774b2488b48e97e7bf", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=56f48ce9765aa2b6d4742a4923fee581a12c1418", "patch": "@@ -641,7 +641,8 @@ OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  regclass.o local-alloc.o global.o reload.o reload1.o caller-save.o gcse.o \\\n  insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n- profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o\n+ profile.o insn-attrtab.o $(out_object_file) getpwd.o $(EXTRA_OBJS) convert.o \\\n+ mbchar.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1275,13 +1276,14 @@ c-lang.o : c-lang.c $(CONFIG_H) system.h $(TREE_H) c-tree.h c-lex.h toplev.h \\\n     output.h\n c-lex.o : c-lex.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-lex.h c-tree.h \\\n     $(srcdir)/c-parse.h input.h flags.h $(srcdir)/c-gperf.h c-pragma.h \\\n-    toplev.h output.h\n+    toplev.h output.h mbchar.h\n c-aux-info.o : c-aux-info.c  $(CONFIG_H) system.h $(TREE_H) c-tree.h flags.h\n c-convert.o : c-convert.c $(CONFIG_H) system.h $(TREE_H) flags.h toplev.h\n c-pragma.o: c-pragma.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) except.h \\\n     function.h defaults.h c-pragma.h toplev.h\n c-iterate.o: c-iterate.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) c-tree.h \\\n     flags.h toplev.h $(EXPR_H)\n+mbchar.o: $(CONFIG_H) system.h gansidecl.h mbchar.h\n \n collect2$(exeext): collect2.o tlink.o hash.o cplus-dem.o underscore.o \\\n \tversion.o choose-temp.o mkstemp.o $(LIBDEPS)\n@@ -1816,15 +1818,16 @@ $(HOST_PREFIX_1):\n cpp$(exeext): $(CCCP)$(exeext)\n \t-rm -f cpp$(exeext)\n \t$(LN) $(CCCP)$(exeext) cpp$(exeext)\n-cccp$(exeext): cccp.o cexp.o version.o prefix.o $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ cccp.o cexp.o prefix.o \\\n-\t  version.o $(LIBS)\n+cccp$(exeext): cccp.o cexp.o version.o prefix.o mbchar.o @extra_cpp_objs@ $(LIBDEPS)\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ cccp.o cexp.o prefix.o mbchar.o \\\n+\t  version.o @extra_cpp_objs@ $(LIBS)\n cexp.o: $(srcdir)/cexp.c $(CONFIG_H) system.h gansidecl.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -c $(srcdir)/cexp.c\n $(srcdir)/cexp.c: $(srcdir)/cexp.y\n \tcd $(srcdir); $(BISON) -o cexp.c cexp.y\n \n-cccp.o: cccp.c $(CONFIG_H) pcp.h version.c config.status system.h gansidecl.h\n+cccp.o: cccp.c $(CONFIG_H) pcp.h version.c config.status system.h gansidecl.h \\\n+           mbchar.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  -DGCC_INCLUDE_DIR=\\\"$(libsubdir)/include\\\" \\\n \t  -DGPLUSPLUS_INCLUDE_DIR=\\\"$(gxx_include_dir)\\\" \\\n@@ -1835,8 +1838,9 @@ cccp.o: cccp.c $(CONFIG_H) pcp.h version.c config.status system.h gansidecl.h\n \t  -c `echo $(srcdir)/cccp.c | sed 's,^\\./,,'`\n \n cppmain$(exeext): cppmain.o cpplib.o cpphash.o cppalloc.o cpperror.o cppexp.o \\\n-  prefix.o version.o $(LIBDEPS)\n+  prefix.o version.o mbchar.o @extra_cpp_objs@ $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ cppmain.o cpplib.o cpphash.o \\\n+\t  mbchar.o @extra_cpp_objs@ \\\n \t  cppalloc.o cpperror.o cppexp.o prefix.o version.o $(LIBS)\n \n cppmain.o: cppmain.c $(CONFIG_H) cpplib.h system.h gansidecl.h"}, {"sha": "f4f4a12d1e8b3a38f33821a42806904d3b2fa2ca", "filename": "gcc/c-lex.c", "status": "modified", "additions": 179, "deletions": 85, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=56f48ce9765aa2b6d4742a4923fee581a12c1418", "patch": "@@ -33,16 +33,14 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-pragma.h\"\n #include \"toplev.h\"\n \n-/* MULTIBYTE_CHARS support only works for native compilers.\n-   ??? Ideally what we want is to model widechar support after\n-   the current floating point support.  */\n-#ifdef CROSS_COMPILE\n-#undef MULTIBYTE_CHARS\n-#endif\n-\n #ifdef MULTIBYTE_CHARS\n+#include \"mbchar.h\"\n #include <locale.h>\n+\n+#ifndef GET_ENVIRONMENT\n+#define GET_ENVIRONMENT(ENV_VALUE,ENV_NAME) ((ENV_VALUE) = getenv (ENV_NAME))\n #endif\n+#endif /* MULTIBYTE_CHARS */\n \n #if USE_CPPLIB\n #include \"cpplib.h\"\n@@ -232,6 +230,7 @@ init_lex ()\n #ifdef MULTIBYTE_CHARS\n   /* Change to the native locale for multibyte conversions.  */\n   setlocale (LC_CTYPE, \"\");\n+  GET_ENVIRONMENT (literal_codeset, \"LANG\");\n #endif\n \n   maxtoken = 40;\n@@ -1795,30 +1794,27 @@ yylex ()\n       {\n \tregister int result = 0;\n \tregister int num_chars = 0;\n+\tint chars_seen = 0;\n \tunsigned width = TYPE_PRECISION (char_type_node);\n \tint max_chars;\n-\n-\tif (wide_flag)\n-\t  {\n-\t    width = WCHAR_TYPE_SIZE;\n #ifdef MULTIBYTE_CHARS\n-\t    max_chars = MB_CUR_MAX;\n-#else\n-\t    max_chars = 1;\n+\tint longest_char = local_mb_cur_max ();\n+\t(void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n #endif\n-\t  }\n-\telse\n-\t  max_chars = TYPE_PRECISION (integer_type_node) / width;\n+\n+\tmax_chars = TYPE_PRECISION (integer_type_node) / width;\n+\tif (wide_flag)\n+\t  width = WCHAR_TYPE_SIZE;\n \n \twhile (1)\n \t  {\n \t  tryagain:\n-\n \t    c = GETC();\n \n \t    if (c == '\\'' || c == EOF)\n \t      break;\n \n+\t    ++chars_seen;\n \t    if (c == '\\\\')\n \t      {\n \t\tint ignore = 0;\n@@ -1839,18 +1835,76 @@ yylex ()\n \t\t  pedwarn (\"ANSI C forbids newline in character constant\");\n \t\tlineno++;\n \t      }\n-#ifdef MAP_CHARACTER\n \t    else\n-\t      c = MAP_CHARACTER (c);\n+\t      {\n+#ifdef MULTIBYTE_CHARS\n+\t\twchar_t wc;\n+\t\tint i;\n+\t\tint char_len = -1;\n+\t\tfor (i = 1; i <= longest_char; ++i)\n+\t\t  {\n+\t\t    if (i > maxtoken - 4)\n+\t\t      extend_token_buffer (token_buffer);\n+\n+\t\t    token_buffer[i] = c;\n+\t\t    char_len = local_mbtowc (& wc,\n+\t\t\t\t\t     token_buffer + 1,\n+\t\t\t\t\t     i);\n+\t\t    if (char_len != -1)\n+\t\t      break;\n+\t\t    c = GETC ();\n+\t\t  }\n+\t\tif (char_len > 1)\n+\t\t  {\n+\t\t    /* mbtowc sometimes needs an extra char before accepting */\n+\t\t    if (char_len < i)\n+\t\t      UNGETC (c);\n+\t\t    if (! wide_flag)\n+\t\t      {\n+\t\t\t/* Merge character into result; ignore excess chars.  */\n+\t\t\tfor (i = 1; i <= char_len; ++i)\n+\t\t\t  {\n+\t\t\t    if (i > max_chars)\n+\t\t\t      break;\n+\t\t\t    if (width < HOST_BITS_PER_INT)\n+\t\t\t      result = (result << width)\n+\t\t\t\t| (token_buffer[i]\n+\t\t\t\t   & ((1 << width) - 1));\n+\t\t\t    else\n+\t\t\t      result = token_buffer[i];\n+\t\t\t  }\n+\t\t\tnum_chars += char_len;\n+\t\t\tgoto tryagain;\n+\t\t      }\n+\t\t    c = wc;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (char_len == -1)\n+\t\t      warning (\"Ignoring invalid multibyte character\");\n+\t\t    if (wide_flag)\n+\t\t      c = wc;\n+#ifdef MAP_CHARACTER\n+\t\t    else\n+\t\t      c = MAP_CHARACTER (c);\n #endif\n+\t\t  }\n+#else /* ! MULTIBYTE_CHARS */\n+#ifdef MAP_CHARACTER\n+\t\tc = MAP_CHARACTER (c);\n+#endif\n+#endif /* ! MULTIBYTE_CHARS */\n+\t      }\n \n-\t    num_chars++;\n-\t    if (num_chars > maxtoken - 4)\n-\t      extend_token_buffer (token_buffer);\n-\n-\t    token_buffer[num_chars] = c;\n+\t    if (wide_flag)\n+\t      {\n+\t\tif (chars_seen == 1) /* only keep the first one */\n+\t\t  result = c;\n+\t\tgoto tryagain;\n+\t      }\n \n \t    /* Merge character into result; ignore excess chars.  */\n+\t    num_chars += (width / TYPE_PRECISION (char_type_node));\n \t    if (num_chars < max_chars + 1)\n \t      {\n \t\tif (width < HOST_BITS_PER_INT)\n@@ -1860,19 +1914,16 @@ yylex ()\n \t      }\n \t  }\n \n-\ttoken_buffer[num_chars + 1] = '\\'';\n-\ttoken_buffer[num_chars + 2] = 0;\n-\n \tif (c != '\\'')\n \t  error (\"malformatted character constant\");\n-\telse if (num_chars == 0)\n+\telse if (chars_seen == 0)\n \t  error (\"empty character constant\");\n \telse if (num_chars > max_chars)\n \t  {\n \t    num_chars = max_chars;\n \t    error (\"character constant too long\");\n \t  }\n-\telse if (num_chars != 1 && ! flag_traditional && warn_multichar)\n+\telse if (chars_seen != 1 && ! flag_traditional && warn_multichar)\n \t  warning (\"multi-character character constant\");\n \n \t/* If char type is signed, sign-extend the constant.  */\n@@ -1897,22 +1948,6 @@ yylex ()\n \t  }\n \telse\n \t  {\n-#ifdef MULTIBYTE_CHARS\n-\t    /* Set the initial shift state and convert the next sequence.  */\n-\t    result = 0;\n-\t    /* In all locales L'\\0' is zero and mbtowc will return zero,\n-\t       so don't use it.  */\n-\t    if (num_chars > 1\n-\t\t|| (num_chars == 1 && token_buffer[1] != '\\0'))\n-\t      {\n-\t\twchar_t wc;\n-\t\t(void) mbtowc (NULL_PTR, NULL_PTR, 0);\n-\t\tif (mbtowc (& wc, token_buffer + 1, num_chars) == num_chars)\n-\t\t  result = wc;\n-\t\telse\n-\t\t  warning (\"Ignoring invalid multibyte character\");\n-\t      }\n-#endif\n \t    yylval.ttype = build_int_2 (result, 0);\n \t    TREE_TYPE (yylval.ttype) = wchar_type_node;\n \t  }\n@@ -1924,7 +1959,13 @@ yylex ()\n     case '\"':\n     string_constant:\n       {\n-\tc = GETC();\n+\tunsigned width = wide_flag ? WCHAR_TYPE_SIZE\n+\t                           : TYPE_PRECISION (char_type_node);\n+#ifdef MULTIBYTE_CHARS\n+\tint longest_char = local_mb_cur_max ();\n+\t(void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n+#endif\n+\tc = GETC ();\n \tp = token_buffer + 1;\n \n \twhile (c != '\"' && c >= 0)\n@@ -1935,9 +1976,8 @@ yylex ()\n \t\tc = readescape (&ignore);\n \t\tif (ignore)\n \t\t  goto skipnewline;\n-\t\tif (!wide_flag\n-\t\t    && TYPE_PRECISION (char_type_node) < HOST_BITS_PER_INT\n-\t\t    && c >= (1 << TYPE_PRECISION (char_type_node)))\n+\t\tif (width < HOST_BITS_PER_INT\n+\t\t    && (unsigned) c >= (1 << width))\n \t\t  pedwarn (\"escape sequence out of range for character\");\n \t      }\n \t    else if (c == '\\n')\n@@ -1946,15 +1986,94 @@ yylex ()\n \t\t  pedwarn (\"ANSI C forbids newline in string constant\");\n \t\tlineno++;\n \t      }\n+\t    else\n+\t      {\n+#ifdef MULTIBYTE_CHARS\n+\t\twchar_t wc;\n+\t\tint i;\n+\t\tint char_len = -1;\n+\t\tfor (i = 0; i < longest_char; ++i)\n+\t\t  {\n+\t\t    if (p + i == token_buffer + maxtoken)\n+\t\t      p = extend_token_buffer (p);\n+\t\t    p[i] = c;\n \n-\t    if (p == token_buffer + maxtoken)\n-\t      p = extend_token_buffer (p);\n-\t    *p++ = c;\n+\t\t    char_len = local_mbtowc (& wc, p, i + 1);\n+\t\t    if (char_len != -1)\n+\t\t      break;\n+\t\t    c = GETC ();\n+\t\t  }\n+\t\tif (char_len == -1)\n+\t\t  warning (\"Ignoring invalid multibyte character\");\n+\t\telse\n+\t\t  {\n+\t\t    /* mbtowc sometimes needs an extra char before accepting */\n+\t\t    if (char_len <= i)\n+\t\t      UNGETC (c);\n+\t\t    if (wide_flag)\n+\t\t      {\n+\t\t\t*(wchar_t *)p = wc;\n+\t\t\tp += sizeof (wc);\n+\t\t      }\n+\t\t    else\n+\t\t      p += (i + 1);\n+\t\t    c = GETC ();\n+\t\t    continue;\n+\t\t  }\n+#endif /* MULTIBYTE_CHARS */\n+\t      }\n+\n+\t    /* Add this single character into the buffer either as a wchar_t\n+\t       or as a single byte.  */\n+\t    if (wide_flag)\n+\t      {\n+\t\tunsigned width = TYPE_PRECISION (char_type_node);\n+\t\tunsigned bytemask = (1 << width) - 1;\n+\t\tint byte;\n+\n+\t\tif (p + WCHAR_BYTES >= token_buffer + maxtoken)\n+\t\t  p = extend_token_buffer (p);\n+\n+\t\tfor (byte = 0; byte < WCHAR_BYTES; ++byte)\n+\t\t  {\n+\t\t    int value;\n+\t\t    if (byte >= sizeof (c))\n+\t\t      value = 0;\n+\t\t    else\n+\t\t      value = (c >> (byte * width)) & bytemask;\n+\t\t    if (BYTES_BIG_ENDIAN)\n+\t\t      p[WCHAR_BYTES - byte - 1] = value;\n+\t\t    else\n+\t\t      p[byte] = value;\n+\t\t  }\n+\t\tp += WCHAR_BYTES;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (p == token_buffer + maxtoken)\n+\t\t  p = extend_token_buffer (p);\n+\t\t*p++ = c;\n+\t      }\n \n \t  skipnewline:\n-\t    c = GETC();\n+\t    c = GETC ();\n+\t  }\n+\n+\t/* Terminate the string value, either with a single byte zero\n+\t   or with a wide zero.  */\n+\tif (wide_flag)\n+\t  {\n+\t    if (p + WCHAR_BYTES >= token_buffer + maxtoken)\n+\t      p = extend_token_buffer (p);\n+\t    bzero (p, WCHAR_BYTES);\n+\t    p += WCHAR_BYTES;\n+\t  }\n+\telse\n+\t  {\n+\t    if (p == token_buffer + maxtoken)\n+\t      p = extend_token_buffer (p);\n+\t    *p++ = 0;\n \t  }\n-\t*p = 0;\n \n \tif (c < 0)\n \t  error (\"Unterminated string constant\");\n@@ -1964,52 +2083,27 @@ yylex ()\n \n \tif (wide_flag)\n \t  {\n-\t    /* If this is a L\"...\" wide-string, convert the multibyte string\n-\t       to a wide character string.  */\n-\t    char *widep = (char *) alloca ((p - token_buffer) * WCHAR_BYTES);\n-\t    int len;\n-\n-#ifdef MULTIBYTE_CHARS\n-\t    len = mbstowcs ((wchar_t *) widep, token_buffer + 1, p - token_buffer);\n-\t    if (len < 0 || len >= (p - token_buffer))\n-\t      {\n-\t\twarning (\"Ignoring invalid multibyte string\");\n-\t\tlen = 0;\n-\t      }\n-\t    bzero (widep + (len * WCHAR_BYTES), WCHAR_BYTES);\n-#else\n-\t    {\n-\t      char *wp, *cp;\n-\n-\t      wp = widep + (BYTES_BIG_ENDIAN ? WCHAR_BYTES - 1 : 0);\n-\t      bzero (widep, (p - token_buffer) * WCHAR_BYTES);\n-\t      for (cp = token_buffer + 1; cp < p; cp++)\n-\t\t*wp = *cp, wp += WCHAR_BYTES;\n-\t      len = p - token_buffer - 1;\n-\t    }\n-#endif\n-\t    yylval.ttype = build_string ((len + 1) * WCHAR_BYTES, widep);\n+\t    yylval.ttype = build_string (p - (token_buffer + 1),\n+\t\t\t\t\t token_buffer + 1);\n \t    TREE_TYPE (yylval.ttype) = wchar_array_type_node;\n \t    value = STRING;\n \t  }\n \telse if (objc_flag)\n \t  {\n \t    /* Return an Objective-C @\"...\" constant string object.  */\n-\t    yylval.ttype = build_objc_string (p - token_buffer,\n+\t    yylval.ttype = build_objc_string (p - (token_buffer + 1),\n \t\t\t\t\t      token_buffer + 1);\n \t    TREE_TYPE (yylval.ttype) = char_array_type_node;\n \t    value = OBJC_STRING;\n \t  }\n \telse\n \t  {\n-\t    yylval.ttype = build_string (p - token_buffer, token_buffer + 1);\n+\t    yylval.ttype = build_string (p - (token_buffer + 1),\n+\t\t\t\t\t token_buffer + 1);\n \t    TREE_TYPE (yylval.ttype) = char_array_type_node;\n \t    value = STRING;\n \t  }\n \n-\t*p++ = '\"';\n-\t*p = 0;\n-\n \tbreak;\n       }\n "}, {"sha": "55b6e68b7abe84f7889afc97e223d664f4f0d470", "filename": "gcc/cccp.c", "status": "modified", "additions": 339, "deletions": 20, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=56f48ce9765aa2b6d4742a4923fee581a12c1418", "patch": "@@ -45,6 +45,11 @@ typedef unsigned char U_CHAR;\n #include \"gansidecl.h\"\n #include \"pcp.h\"\n \n+#ifdef MULTIBYTE_CHARS\n+#include \"mbchar.h\"\n+#include <locale.h>\n+#endif /* MULTIBYTE_CHARS */\n+\n #ifndef GET_ENVIRONMENT\n #define GET_ENVIRONMENT(ENV_VALUE,ENV_NAME) ENV_VALUE = getenv (ENV_NAME)\n #endif\n@@ -1308,6 +1313,12 @@ main (argc, argv)\n   bzero ((char *) pend_assertions, argc * sizeof (char *));\n   bzero ((char *) pend_includes, argc * sizeof (char *));\n \n+#ifdef MULTIBYTE_CHARS\n+  /* Change to the native locale for multibyte conversions.  */\n+  setlocale (LC_CTYPE, \"\");\n+  GET_ENVIRONMENT (literal_codeset, \"LANG\");\n+#endif\n+\n   /* Process switches and find input file name.  */\n \n   for (i = 1; i < argc; i++) {\n@@ -2774,9 +2785,27 @@ do { ip = &instack[indepth];\t\t\\\n \t      bp += 2;\n \t    else if (*bp == '/' && bp[1] == '*') {\n \t      bp += 2;\n-\t      while (!(*bp == '*' && bp[1] == '/'))\n-\t\tbp++;\n-\t      bp += 2;\n+\t      while (1)\n+\t\t{\n+\t\t  if (*bp == '*')\n+\t\t    {\n+\t\t      if (bp[1] == '/')\n+\t\t\t{\n+\t\t\t  bp += 2;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+#ifdef MULTIBYTE_CHARS\n+\t\t      int length;\n+\t\t      length = local_mblen (bp, limit - bp);\n+\t\t      if (length > 1)\n+\t\t\tbp += (length - 1);\n+#endif\n+\t\t    }\n+\t\t  bp++;\n+\t\t}\n \t    }\n \t    /* There is no point in trying to deal with C++ // comments here,\n \t       because if there is one, then this # must be part of the\n@@ -2937,6 +2966,24 @@ do { ip = &instack[indepth];\t\t\\\n \t  if (ibp[-1] == c)\n \t    goto while2end;\n \t  break;\n+#ifdef MULTIBYTE_CHARS\n+\tdefault:\n+\t  {\n+\t    int length;\n+\t    --ibp;\n+\t    length = local_mblen (ibp, limit - ibp);\n+\t    if (length > 0)\n+\t      {\n+\t\t--obp;\n+\t\tbcopy (ibp, obp, length);\n+\t\tobp += length;\n+\t\tibp += length;\n+\t      }\n+\t    else\n+\t      ++ibp;\n+\t  }\n+\t  break;\n+#endif\n \t}\n       }\n     while2end:\n@@ -2983,6 +3030,15 @@ do { ip = &instack[indepth];\t\t\\\n \t\t*obp++ = '\\n';\n \t      ++op->lineno;\n \t    }\n+\t    else\n+\t      {\n+#ifdef MULTIBYTE_CHARS\n+\t\tint length;\n+\t\tlength = local_mblen (ibp, limit - ibp);\n+\t\tif (length > 1)\n+\t\t  ibp += (length - 1);\n+#endif\n+\t      }\n \t  }\n \t  break;\n \t}\n@@ -3071,6 +3127,16 @@ do { ip = &instack[indepth];\t\t\\\n \t      goto limit_reached;\n \t    }\n \t    break;\n+#ifdef MULTIBYTE_CHARS\n+\t  default:\n+\t    {\n+\t      int length;\n+\t      length = local_mblen (ibp, limit - ibp);\n+\t      if (length > 1)\n+\t\tibp += (length - 1);\n+\t    }\n+\t    break;\n+#endif\n \t  }\n \t}\n       comment_end:\n@@ -3433,11 +3499,27 @@ do { ip = &instack[indepth];\t\t\\\n \t\t\t      break;\n \t\t\t    }\n \t\t\t  }\n-\t\t\t  if (*ibp == '\\n') {\n+\t\t\t  else if (*ibp == '\\n') {\n \t\t\t    /* Newline in a file.  Count it.  */\n \t\t\t    ++ip->lineno;\n \t\t\t    ++op->lineno;\n \t\t\t  }\n+\t\t\t  else\n+\t\t\t    {\n+#ifdef MULTIBYTE_CHARS\n+\t\t\t      int length;\n+\t\t\t      length = local_mblen (ibp, limit - ibp);\n+\t\t\t      if (length > 1)\n+\t\t\t\t{\n+\t\t\t\t  if (put_out_comments)\n+\t\t\t\t    {\n+\t\t\t\t      bcopy (ibp, obp, length - 1);\n+\t\t\t\t      obp += length - 1;\n+\t\t\t\t    }\n+\t\t\t\t  ibp += (length - 1);\n+\t\t\t\t}\n+#endif\n+\t\t\t    }\n \t\t\t  if (put_out_comments)\n \t\t\t    *obp++ = *ibp;\n \t\t\t}\n@@ -3448,9 +3530,32 @@ do { ip = &instack[indepth];\t\t\\\n \t\t\t} else if (! traditional) {\n \t\t\t  *obp++ = ' ';\n \t\t\t}\n-\t\t\tfor (ibp += 2; *ibp != '\\n' || ibp[-1] == '\\\\'; ibp++)\n-\t\t\t  if (put_out_comments)\n-\t\t\t    *obp++ = *ibp;\n+\t\t\tfor (ibp += 2; ; ibp++)\n+\t\t\t  {\n+\t\t\t    if (*ibp == '\\n')\n+\t\t\t      {\n+\t\t\t\tif (ibp[-1] != '\\\\')\n+\t\t\t\t  break;\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      {\n+#ifdef MULTIBYTE_CHARS\n+\t\t\t\tint length;\n+\t\t\t\tlength = local_mblen (ibp, limit - ibp);\n+\t\t\t\tif (length > 1)\n+\t\t\t\t  {\n+\t\t\t\t    if (put_out_comments)\n+\t\t\t\t      {\n+\t\t\t\t\tbcopy (ibp, obp, length - 1);\n+\t\t\t\t\tobp += length - 1;\n+\t\t\t\t      }\n+\t\t\t\t    ibp += (length - 1);\n+\t\t\t\t  }\n+#endif\n+\t\t\t      }\n+\t\t\t    if (put_out_comments)\n+\t\t\t      *obp++ = *ibp;\n+\t\t\t  }\n \t\t      } else\n \t\t\tbreak;\n \t\t    }\n@@ -6186,6 +6291,25 @@ collect_expansion (buf, end, nargs, arglist)\n       }\n     }\n \n+#ifdef MULTIBYTE_CHARS\n+    /* Handle multibyte characters inside string and character literals.  */\n+    if (expected_delimiter != '\\0')\n+      {\n+\tint length;\n+\t--p;\n+\tlength = local_mblen (p, limit - p);\n+\tif (length > 1)\n+\t  {\n+\t    --exp_p;\n+\t    bcopy (p, exp_p, length);\n+\t    p += length;\n+\t    exp_p += length;\n+\t    continue;\n+\t  }\n+\t++p;\n+      }\n+#endif\n+\n     /* Handle the start of a symbol.  */\n     if (is_idchar[c] && nargs > 0) {\n       U_CHAR *id_beg = p - 1;\n@@ -7412,9 +7536,27 @@ skip_if_group (ip, any, op)\n \t    bp += 2;\n \t  else if (*bp == '/' && bp[1] == '*') {\n \t    bp += 2;\n-\t    while (!(*bp == '*' && bp[1] == '/'))\n-\t      bp++;\n-\t    bp += 2;\n+\t    while (1)\n+\t      {\n+\t\tif (*bp == '*')\n+\t\t  {\n+\t\t    if (bp[1] == '/')\n+\t\t      {\n+\t\t\tbp += 2;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+#ifdef MULTIBYTE_CHARS\n+\t\t    int length;\n+\t\t    length = local_mblen (bp, endb - bp);\n+\t\t    if (length > 1)\n+\t\t      bp += (length - 1);\n+#endif\n+\t\t  }\n+\t\tbp++;\n+\t      }\n \t  }\n \t  /* There is no point in trying to deal with C++ // comments here,\n \t     because if there is one, then this # must be part of the\n@@ -7458,6 +7600,15 @@ skip_if_group (ip, any, op)\n \t\tif (bp[1] == '/')\n \t\t  break;\n \t      }\n+\t      else\n+\t\t{\n+#ifdef MULTIBYTE_CHARS\n+\t\t  int length;\n+\t\t  length = local_mblen (bp, endb - bp);\n+\t\t  if (length > 1)\n+\t\t    bp += (length - 1);\n+#endif\n+\t\t}\n \t    }\n \t    bp += 2;\n \t  } else if (bp[1] == '/' && cplusplus_comments) {\n@@ -7469,6 +7620,15 @@ skip_if_group (ip, any, op)\n \t\t  warning (\"multiline `//' comment\");\n \t\tip->lineno++;\n \t      }\n+\t      else\n+\t\t{\n+#ifdef MULTIBYTE_CHARS\n+\t\t  int length;\n+\t\t  length = local_mblen (bp, endb - bp);\n+\t\t  if (length > 1)\n+\t\t    bp += (length - 1);\n+#endif\n+\t\t}\n \t    }\n \t  } else\n \t    break;\n@@ -7764,6 +7924,15 @@ validate_else (p, limit)\n \t      break;\n \t    }\n \t  }\n+\t  else\n+\t    {\n+#ifdef MULTIBYTE_CHARS\n+\t      int length;\n+\t      length = local_mblen (p, limit - p);\n+\t      if (length > 1)\n+\t\tp += (length - 1);\n+#endif\n+\t    }\n \t}\n       }\n       else if (cplusplus_comments && p[1] == '/')\n@@ -7817,6 +7986,22 @@ skip_to_end_of_comment (ip, line_counter, nowarn)\n \tif (op)\n \t  ++op->lineno;\n       }\n+      else\n+\t{\n+#ifdef MULTIBYTE_CHARS\n+\t  int length;\n+\t  length = local_mblen (bp, limit - bp);\n+\t  if (length > 1)\n+\t    {\n+\t      if (op)\n+\t\t{\n+\t\t  bcopy (bp, op->bufp, length - 1);\n+\t\t  op->bufp += (length - 1);\n+\t\t}\n+\t      bp += (length - 1);\n+\t    }\n+#endif\n+\t}\n       if (op)\n \t*op->bufp++ = *bp;\n     }\n@@ -7854,6 +8039,23 @@ skip_to_end_of_comment (ip, line_counter, nowarn)\n \treturn bp;\n       }\n       break;\n+#ifdef MULTIBYTE_CHARS\n+    default:\n+      {\n+\tint length;\n+\tbp--;\n+\tlength = local_mblen (bp, limit - bp);\n+\tif (length <= 0)\n+\t  length = 1;\n+\tif (op)\n+\t  {\n+\t    op->bufp--;\n+\t    bcopy (bp, op->bufp, length);\n+\t    op->bufp += length;\n+\t  }\n+\tbp += length;\n+      }\n+#endif\n     }\n   }\n \n@@ -7944,6 +8146,16 @@ skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p,\n       }\n     } else if (c == match)\n       break;\n+#ifdef MULTIBYTE_CHARS\n+    {\n+      int length;\n+      --bp;\n+      length = local_mblen (bp, limit - bp);\n+      if (length <= 0)\n+\tlength = 1;\n+      bp += length;\n+    }\n+#endif\n   }\n   return bp;\n }\n@@ -8381,9 +8593,23 @@ macroexpand (hp, op)\n \t    else {\n \t      if (c == '\\\\')\n \t\tescaped = 1;\n-\t      if (in_string) {\n+\t      else if (in_string) {\n \t\tif (c == in_string)\n \t\t  in_string = 0;\n+\t\telse\n+\t\t  {\n+#ifdef MULTIBYTE_CHARS\n+\t\t    int length;\n+\t\t    length = local_mblen (arg->raw + i, arglen - i);\n+\t\t    if (length > 1)\n+\t\t      {\n+\t\t\tbcopy (arg->raw + i, xbuf + totlen, length);\n+\t\t\ti += length - 1;\n+\t\t\ttotlen += length;\n+\t\t\tcontinue;\n+\t\t      }\n+#endif\n+\t\t  }\n \t      } else if (c == '\\\"' || c == '\\'')\n \t\tin_string = c;\n \t    }\n@@ -8717,6 +8943,15 @@ macarg1 (start, limit, macro, depthptr, newlines, comments, rest_args)\n \t      break;\n \t    }\n \t  }\n+\t  else\n+\t    {\n+#ifdef MULTIBYTE_CHARS\n+\t      int length;\n+\t      length = local_mblen (bp, limit - bp);\n+\t      if (length > 1)\n+\t\tbp += (length - 1);\n+#endif\n+\t    }\n \t}\n       } else if (bp[1] == '/' && cplusplus_comments) {\n \t*comments = 1;\n@@ -8728,6 +8963,15 @@ macarg1 (start, limit, macro, depthptr, newlines, comments, rest_args)\n \t    if (warn_comments)\n \t      warning (\"multiline `//' comment\");\n \t  }\n+\t  else\n+\t    {\n+#ifdef MULTIBYTE_CHARS\n+\t      int length;\n+\t      length = local_mblen (bp, limit - bp);\n+\t      if (length > 1)\n+\t\tbp += (length - 1);\n+#endif\n+\t    }\n \t}\n       }\n       break;\n@@ -8751,6 +8995,15 @@ macarg1 (start, limit, macro, depthptr, newlines, comments, rest_args)\n \t    if (quotec == '\\'')\n \t      break;\n \t  }\n+\t  else\n+\t    {\n+#ifdef MULTIBYTE_CHARS\n+\t      int length;\n+\t      length = local_mblen (bp, limit - bp);\n+\t      if (length > 1)\n+\t\tbp += (length - 1);\n+#endif\n+\t    }\n \t}\n       }\n       break;\n@@ -8828,8 +9081,23 @@ discard_comments (start, length, newlines)\n \t/* Comments are equivalent to spaces.  */\n \tobp[-1] = ' ';\n \tibp++;\n-\twhile (ibp < limit && (*ibp != '\\n' || ibp[-1] == '\\\\'))\n-\t  ibp++;\n+\twhile (ibp < limit)\n+\t  {\n+\t    if (*ibp == '\\n')\n+\t      {\n+\t\tif (ibp[-1] != '\\\\')\n+\t\t  break;\n+\t      }\n+\t    else\n+\t      {\n+#ifdef MULTIBYTE_CHARS\n+\t\tint length = local_mblen (ibp, limit - ibp);\n+\t\tif (length > 1)\n+\t\t  ibp += (length - 1);\n+#endif\n+\t      }\n+\t    ibp++;\n+\t  }\n \tbreak;\n       }\n       if (ibp[0] != '*' || ibp + 1 >= limit)\n@@ -8849,6 +9117,14 @@ discard_comments (start, length, newlines)\n \t    break;\n \t  }\n \t}\n+\telse\n+\t  {\n+#ifdef MULTIBYTE_CHARS\n+\t    int length = local_mblen (ibp, limit - ibp);\n+\t    if (length > 1)\n+\t      ibp += (length - 1);\n+#endif\n+\t  }\n       }\n       break;\n \n@@ -8863,9 +9139,12 @@ discard_comments (start, length, newlines)\n \t  *obp++ = c = *ibp++;\n \t  if (c == quotec)\n \t    break;\n-\t  if (c == '\\n' && quotec == '\\'')\n-\t    break;\n-\t  if (c == '\\\\') {\n+\t  if (c == '\\n')\n+\t    {\n+\t      if (quotec == '\\'')\n+\t\tbreak;\n+\t    }\n+\t  else if (c == '\\\\') {\n \t    if (ibp < limit && *ibp == '\\n') {\n \t      ibp++;\n \t      obp--;\n@@ -8876,6 +9155,23 @@ discard_comments (start, length, newlines)\n \t\t*obp++ = *ibp++;\n \t    }\n \t  }\n+\t  else\n+\t    {\n+#ifdef MULTIBYTE_CHARS\n+\t      int length;\n+\t      ibp--;\n+\t      length = local_mblen (ibp, limit - ibp);\n+\t      if (length > 1)\n+\t\t{\n+\t\t  obp--;\n+\t\t  bcopy (ibp, obp, length);\n+\t\t  ibp += length;\n+\t\t  obp += length;\n+\t\t}\n+\t      else\n+\t\tibp++;\n+#endif\n+\t    }\n \t}\n       }\n       break;\n@@ -8925,10 +9221,33 @@ change_newlines (start, length)\n \tint quotec = c;\n \twhile (ibp < limit) {\n \t  *obp++ = c = *ibp++;\n-\t  if (c == quotec && ibp[-2] != '\\\\')\n-\t    break;\n-\t  if (c == '\\n' && quotec == '\\'')\n-\t    break;\n+\t  if (c == quotec)\n+\t    {\n+\t      if (ibp[-2] != '\\\\')\n+\t\tbreak;\n+\t    }\n+\t  else if (c == '\\n')\n+\t    {\n+\t      if (quotec == '\\'')\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    {\n+#ifdef MULTIBYTE_CHARS\n+\t      int length;\n+\t      ibp--;\n+\t      length = local_mblen (ibp, limit - ibp);\n+\t      if (length > 1)\n+\t\t{\n+\t\t  obp--;\n+\t\t  bcopy (ibp, obp, length);\n+\t\t  ibp += length;\n+\t\t  obp += length;\n+\t\t}\n+\t      else\n+\t\tibp++;\n+#endif\n+\t    }\n \t}\n       }\n       break;"}, {"sha": "5d36329e7e94adfff2689b06f0beee6da034dae9", "filename": "gcc/cexp.y", "status": "modified", "additions": 72, "deletions": 41, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fcexp.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fcexp.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.y?ref=56f48ce9765aa2b6d4742a4923fee581a12c1418", "patch": "@@ -39,12 +39,12 @@ Boston, MA 02111-1307, USA.\n #include \"system.h\"\n #include <setjmp.h>\n /* #define YYDEBUG 1 */\n+#include \"gansidecl.h\"\n \n #ifdef MULTIBYTE_CHARS\n+#include \"mbchar.h\"\n #include <locale.h>\n-#endif\n-\n-#include \"gansidecl.h\"\n+#endif /* MULTIBYTE_CHARS */\n \n typedef unsigned char U_CHAR;\n \n@@ -641,23 +641,18 @@ yylex ()\n     {\n       register HOST_WIDE_INT result = 0;\n       register int num_chars = 0;\n+      int chars_seen = 0;\n       unsigned width = MAX_CHAR_TYPE_SIZE;\n       int max_chars;\n-      char *token_buffer;\n-\n-      if (wide_flag)\n-\t{\n-\t  width = MAX_WCHAR_TYPE_SIZE;\n #ifdef MULTIBYTE_CHARS\n-\t  max_chars = MB_CUR_MAX;\n-#else\n-\t  max_chars = 1;\n+      int longest_char = local_mb_cur_max ();\n+      char *token_buffer = (char *) alloca (longest_char);\n+      (void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n #endif\n-\t}\n-      else\n-\tmax_chars = MAX_LONG_TYPE_SIZE / width;\n \n-      token_buffer = (char *) alloca (max_chars + 1);\n+      max_chars = MAX_LONG_TYPE_SIZE / width;\n+      if (wide_flag)\n+\twidth = MAX_WCHAR_TYPE_SIZE;\n \n       while (1)\n \t{\n@@ -666,44 +661,96 @@ yylex ()\n \t  if (c == '\\'' || c == EOF)\n \t    break;\n \n+\t  ++chars_seen;\n \t  if (c == '\\\\')\n \t    {\n \t      c = parse_escape (&lexptr, mask);\n \t    }\n+\t  else\n+\t    {\n+#ifdef MULTIBYTE_CHARS\n+\t      wchar_t wc;\n+\t      int i;\n+\t      int char_len = -1;\n+\t      for (i = 1; i <= longest_char; ++i)\n+\t\t{\n+\t\t  token_buffer[i - 1] = c;\n+\t\t  char_len = local_mbtowc (& wc, token_buffer, i);\n+\t\t  if (char_len != -1)\n+\t\t    break;\n+\t\t  c = *lexptr++;\n+\t\t}\n+\t      if (char_len > 1)\n+\t\t{\n+\t\t  /* mbtowc sometimes needs an extra char before accepting */\n+\t\t  if (char_len < i)\n+\t\t    lexptr--;\n+\t\t  if (! wide_flag)\n+\t\t    {\n+\t\t      /* Merge character into result; ignore excess chars.  */\n+\t\t      for (i = 1; i <= char_len; ++i)\n+\t\t\t{\n+\t\t\t  if (i > max_chars)\n+\t\t\t    break;\n+\t\t\t  if (width < HOST_BITS_PER_INT)\n+\t\t\t    result = (result << width)\n+\t\t\t      | (token_buffer[i - 1]\n+\t\t\t\t & ((1 << width) - 1));\n+\t\t\t  else\n+\t\t\t    result = token_buffer[i - 1];\n+\t\t\t}\n+\t\t      num_chars += char_len;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (char_len == -1)\n+\t\t    warning (\"Ignoring invalid multibyte character\");\n+\t\t}\n+\t      if (wide_flag)\n+\t\tc = wc;\n+#endif /* ! MULTIBYTE_CHARS */\n+\t    }\n \n-\t  num_chars++;\n+\t  if (wide_flag)\n+\t    {\n+\t      if (chars_seen == 1) /* only keep the first one */\n+\t\tresult = c;\n+\t      continue;\n+\t    }\n \n \t  /* Merge character into result; ignore excess chars.  */\n+\t  num_chars++;\n \t  if (num_chars <= max_chars)\n \t    {\n-\t      if (width < HOST_BITS_PER_WIDE_INT)\n-\t\tresult = (result << width) | c;\n+\t      if (width < HOST_BITS_PER_INT)\n+\t\tresult = (result << width) | (c & ((1 << width) - 1));\n \t      else\n \t\tresult = c;\n-\t      token_buffer[num_chars - 1] = c;\n \t    }\n \t}\n \n-      token_buffer[num_chars] = 0;\n-\n       if (c != '\\'')\n \terror (\"malformatted character constant\");\n-      else if (num_chars == 0)\n+      else if (chars_seen == 0)\n \terror (\"empty character constant\");\n       else if (num_chars > max_chars)\n \t{\n \t  num_chars = max_chars;\n \t  error (\"character constant too long\");\n \t}\n-      else if (num_chars != 1 && ! traditional)\n+      else if (chars_seen != 1 && ! traditional)\n \twarning (\"multi-character character constant\");\n \n       /* If char type is signed, sign-extend the constant.  */\n       if (! wide_flag)\n \t{\n \t  int num_bits = num_chars * width;\n-\n-\t  if (lookup ((U_CHAR *) \"__CHAR_UNSIGNED__\",\n+\t  if (num_bits == 0)\n+\t    /* We already got an error; avoid invalid shift.  */\n+\t    yylval.integer.value = 0;\n+\t  else if (lookup ((U_CHAR *) \"__CHAR_UNSIGNED__\",\n \t\t      sizeof (\"__CHAR_UNSIGNED__\") - 1, -1)\n \t      || ((result >> (num_bits - 1)) & 1) == 0)\n \t    yylval.integer.value\n@@ -716,22 +763,6 @@ yylex ()\n \t}\n       else\n \t{\n-#ifdef MULTIBYTE_CHARS\n-\t  /* Set the initial shift state and convert the next sequence.  */\n-\t  result = 0;\n-\t  /* In all locales L'\\0' is zero and mbtowc will return zero,\n-\t     so don't use it.  */\n-\t  if (num_chars > 1\n-\t      || (num_chars == 1 && token_buffer[0] != '\\0'))\n-\t    {\n-\t      wchar_t wc;\n-\t      (void) mbtowc (NULL_PTR, NULL_PTR, 0);\n-\t      if (mbtowc (& wc, token_buffer, num_chars) == num_chars)\n-\t\tresult = wc;\n-\t      else\n-\t\tpedwarn (\"Ignoring invalid multibyte character\");\n-\t    }\n-#endif\n \t  yylval.integer.value = result;\n \t}\n     }"}, {"sha": "b4c1aca12d7c52138de23e525e2d2d4da4d1060e", "filename": "gcc/configure.in", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=56f48ce9765aa2b6d4742a4923fee581a12c1418", "patch": "@@ -84,7 +84,7 @@ AC_DEFINE(ENABLE_CHECKING)\n # Enable use of cpplib for C.\n cpp_main=cccp\n AC_ARG_ENABLE(c-cpplib,\n-[  --enable-c-cpplib       Use cpplib for C.],\n+[  --enable-c-cpplib       Use cpplib for C and C++.],\n if [[[ x$enable_c_cpplib != xno ]]]; then\n   extra_c_objs=\"${extra_c_objs} cpplib.o cppexp.o cpphash.o cpperror.o\"\n   extra_c_objs=\"${extra_c_objs} prefix.o\"\n@@ -93,6 +93,13 @@ if [[[ x$enable_c_cpplib != xno ]]]; then\n   cpp_main=cppmain\n fi)\n   \n+# Enable Multibyte Characters for C/C++\n+AC_ARG_ENABLE(c-mbchar,\n+[  --enable-c-mbchar       Enable multibyte characters for C and C++.],\n+if [[[ x$enable_c_mbchar != xno ]]]; then\n+  extra_c_flags=-DMULTIBYTE_CHARS=1\n+fi)\n+  \n # Enable Haifa scheduler.\n AC_ARG_ENABLE(haifa,\n [  --enable-haifa          Use the experimental scheduler.\n@@ -193,6 +200,9 @@ AC_CHECK_FUNCS(strtoul bsearch strerror putenv popen bcopy bzero bcmp \\\n \tindex rindex strchr strrchr kill getrlimit setrlimit atoll atoq \\\n \tsysconf isascii gettimeofday)\n \n+# Make sure wchar_t is available\n+#AC_CHECK_TYPE(wchar_t, unsigned int)\n+\n GCC_FUNC_VFPRINTF_DOPRNT\n GCC_FUNC_PRINTF_PTR\n \n@@ -3585,6 +3595,7 @@ AC_SUBST(extra_programs)\n AC_SUBST(extra_parts)\n AC_SUBST(extra_c_objs)\n AC_SUBST(extra_cxx_objs)\n+AC_SUBST(extra_cpp_objs)\n AC_SUBST(extra_c_flags)\n AC_SUBST(extra_objs)\n AC_SUBST(host_extra_gcc_objs)"}, {"sha": "3b3ad4313db6bce854571df52238772cf5866468", "filename": "gcc/invoke.texi", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=56f48ce9765aa2b6d4742a4923fee581a12c1418", "patch": "@@ -5964,8 +5964,9 @@ the language standard.  You should not need to use these options yourself.\n @cindex environment variables\n \n This section describes several environment variables that affect how GNU\n-CC operates.  They work by specifying directories or prefixes to use\n-when searching for various kinds of files.\n+CC operates.  Some of them work by specifying directories or prefixes to use\n+when searching for various kinds of files. Some are used to specify other\n+ascpects of the compilation environment.\n \n @ifclear INTERNALS\n Note that you can also specify places to search using options such as\n@@ -6065,6 +6066,28 @@ which case the Make rules are written to that file, guessing the target\n name from the source file name.  Or the value can have the form\n @samp{@var{file} @var{target}}, in which case the rules are written to\n file @var{file} using @var{target} as the target name.\n+\n+@item LANG\n+@findex LANG\n+@cindex locale definition\n+This variable is used to pass locale information to the compiler. One way in\n+which this information is used is to determine the character set to be used\n+when character literals, string literals and comments are parsed in C and C++.\n+When the compiler is configured to allow multibyte characters,\n+the following values for @code{LANG} are recognized:\n+\n+@table @code\n+@item C-JIS\n+Recognize JIS characters.\n+@item C-SJIS\n+Recognize SJIS characters.\n+@item C-EUCJP\n+Recognize EUCJP characters.\n+@end table\n+\n+If @code{LANG} is not defined, or if it has some ther value, then the\n+compiler will use mblen and mbtowc as defined by the default locale to\n+recognize and translate multibyte characters.\n @end table\n \n @node Running Protoize"}, {"sha": "d54a49749ce58a31173fcf2f6b883a050c65b0b7", "filename": "gcc/mbchar.c", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fmbchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fmbchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmbchar.c?ref=56f48ce9765aa2b6d4742a4923fee581a12c1418", "patch": "@@ -0,0 +1,288 @@\n+/* Multibyte Character Functions.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* These functions are used to manipulate multibyte characters.  */\n+\n+/* Note regarding cross compilation:\n+\n+   In general translation of multibyte characters to wide characters can\n+   only work in a native compiler since the translation function (mbtowc)\n+   needs to know about both the source and target character encoding.  However,\n+   this particular implementation for JIS, SJIS and EUCJP source characters\n+   will work for any compiler with a newlib target.  Other targets may also\n+   work provided that their wchar_t implementation is 2 bytes and the encoding\n+   leaves the source character values unchanged (except for removing the\n+   state shifting markers).  */\n+\n+#ifdef MULTIBYTE_CHARS\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"gansidecl.h\"\n+#include \"mbchar.h\"\n+#include <locale.h>\n+\n+typedef enum\n+{\n+  ESCAPE, DOLLAR, BRACKET, AT, B, J, NUL, JIS_CHAR, OTHER, JIS_C_NUM\n+} JIS_CHAR_TYPE;\n+\n+typedef enum\n+{\n+  ASCII, A_ESC, A_ESC_DL, JIS, JIS_1, JIS_2, J_ESC, J_ESC_BR,\n+  J2_ESC, J2_ESC_BR, INV, JIS_S_NUM\n+} JIS_STATE; \n+\n+typedef enum\n+{\n+  COPYA, COPYJ, COPYJ2, MAKE_A, MAKE_J, NOOP, EMPTY, ERROR\n+} JIS_ACTION;\n+\n+/*****************************************************************************\n+ * state/action tables for processing JIS encoding\n+ * Where possible, switches to JIS are grouped with proceding JIS characters\n+ * and switches to ASCII are grouped with preceding JIS characters.\n+ * Thus, maximum returned length is:\n+ *   2 (switch to JIS) + 2 (JIS characters) + 2 (switch back to ASCII) = 6.\n+ *****************************************************************************/\n+static JIS_STATE JIS_state_table[JIS_S_NUM][JIS_C_NUM] = {\n+/*            ESCAPE DOLLAR   BRACKET   AT     B      J     NUL JIS_CHAR OTHER*/\n+/*ASCII*/   { A_ESC, ASCII,   ASCII,    ASCII, ASCII, ASCII, ASCII,ASCII,ASCII},\n+/*A_ESC*/   { ASCII, A_ESC_DL,ASCII,    ASCII, ASCII, ASCII, ASCII,ASCII,ASCII},\n+/*A_ESC_DL*/{ ASCII, ASCII,   ASCII,    JIS,   JIS,   ASCII, ASCII,ASCII,ASCII},\n+/*JIS*/     { J_ESC, JIS_1,   JIS_1,    JIS_1, JIS_1, JIS_1, INV,  JIS_1,INV },\n+/*JIS_1*/   { INV,   JIS_2,   JIS_2,    JIS_2, JIS_2, JIS_2, INV,  JIS_2,INV },\n+/*JIS_2*/   { J2_ESC,JIS,     JIS,      JIS,   JIS,   JIS,   INV,  JIS,  JIS },\n+/*J_ESC*/   { INV,   INV,     J_ESC_BR, INV,   INV,   INV,   INV,  INV,  INV },\n+/*J_ESC_BR*/{ INV,   INV,     INV,      INV,   ASCII, ASCII, INV,  INV,  INV },\n+/*J2_ESC*/  { INV,   INV,     J2_ESC_BR,INV,   INV,   INV,   INV,  INV,  INV },\n+/*J2_ESC_BR*/{INV,   INV,     INV,      INV,   ASCII, ASCII, INV,  INV,  INV },\n+};\n+\n+static JIS_ACTION JIS_action_table[JIS_S_NUM][JIS_C_NUM] = {\n+/*            ESCAPE DOLLAR BRACKET AT     B       J      NUL  JIS_CHAR OTHER */\n+/*ASCII */   {NOOP,  COPYA, COPYA, COPYA,  COPYA,  COPYA, EMPTY, COPYA, COPYA},\n+/*A_ESC */   {COPYA, NOOP,  COPYA, COPYA,  COPYA,  COPYA, COPYA, COPYA, COPYA},\n+/*A_ESC_DL */{COPYA, COPYA, COPYA, MAKE_J, MAKE_J, COPYA, COPYA, COPYA, COPYA},\n+/*JIS */     {NOOP,  NOOP,  NOOP,  NOOP,   NOOP,   NOOP,  ERROR, NOOP,  ERROR },\n+/*JIS_1 */   {ERROR, NOOP,  NOOP,  NOOP,   NOOP,   NOOP,  ERROR, NOOP,  ERROR },\n+/*JIS_2 */   {NOOP,  COPYJ2,COPYJ2,COPYJ2, COPYJ2, COPYJ2,ERROR, COPYJ2,COPYJ2},\n+/*J_ESC */   {ERROR, ERROR, NOOP,  ERROR,  ERROR,  ERROR, ERROR, ERROR, ERROR },\n+/*J_ESC_BR */{ERROR, ERROR, ERROR, ERROR,  NOOP,   NOOP,  ERROR, ERROR, ERROR },\n+/*J2_ESC */  {ERROR, ERROR, NOOP,  ERROR,  ERROR,  ERROR, ERROR, ERROR, ERROR },\n+/*J2_ESC_BR*/{ERROR, ERROR, ERROR, ERROR,  COPYJ,  COPYJ, ERROR, ERROR, ERROR },\n+};\n+\n+\n+char *literal_codeset = NULL;\n+\n+int\n+local_mbtowc (pwc, s, n)\n+     wchar_t       *pwc;\n+     const char    *s;\n+     size_t         n;\n+{\n+  static JIS_STATE save_state = ASCII;\n+  JIS_STATE curr_state = save_state;\n+  unsigned char *t = (unsigned char *)s;\n+\n+  if (s != NULL && n == 0)\n+    return -1;\n+\n+  if (literal_codeset == NULL || strlen (literal_codeset) <= 1)\n+    {\n+      /* This must be the \"C\" locale or unknown locale -- fall thru */\n+    }\n+  else if (! strcmp (literal_codeset, \"C-SJIS\"))\n+    {\n+      int char1;\n+      if (s == NULL)\n+        return 0;  /* not state-dependent */\n+      char1 = *t;\n+      if (ISSJIS1 (char1))\n+        {\n+          int char2 = t[1];\n+          if (n <= 1)\n+            return -1;\n+          if (ISSJIS2 (char2))\n+            {\n+\t      if (pwc != NULL)\n+\t\t*pwc = (((wchar_t)*t) << 8) + (wchar_t)(*(t+1));\n+              return 2;\n+            }\n+\t  return -1;\n+        }\n+      if (pwc != NULL)\n+\t*pwc = (wchar_t)*t;\n+      if (*t == '\\0')\n+\treturn 0;\n+      return 1;\n+    }\n+  else if (! strcmp (literal_codeset, \"C-EUCJP\"))\n+    {\n+      int char1;\n+      if (s == NULL)\n+        return 0;  /* not state-dependent */\n+      char1 = *t;\n+      if (ISEUCJP (char1))\n+        {\n+          int char2 = t[1];     \n+          if (n <= 1)\n+            return -1;\n+          if (ISEUCJP (char2))\n+            {\n+\t      if (pwc != NULL)\n+\t\t*pwc = (((wchar_t)*t) << 8) + (wchar_t)(*(t+1));\n+              return 2;\n+            }\n+\t  return -1;\n+        }\n+      if (pwc != NULL)\n+\t*pwc = (wchar_t)*t;\n+      if (*t == '\\0')\n+\treturn 0;\n+      return 1;\n+    }\n+  else if (! strcmp (literal_codeset, \"C-JIS\"))\n+    {\n+      JIS_ACTION action;\n+      JIS_CHAR_TYPE ch;\n+      unsigned char *ptr;\n+      int i, curr_ch;\n+ \n+      if (s == NULL)\n+\t{\n+\t  save_state = ASCII;\n+\t  return 1;  /* state-dependent */\n+\t}\n+\n+      ptr = t;\n+\n+      for (i = 0; i < n; ++i)\n+        {\n+          curr_ch = t[i];\n+          switch (curr_ch)\n+            {\n+\t    case JIS_ESC_CHAR:\n+              ch = ESCAPE;\n+              break;\n+\t    case '$':\n+              ch = DOLLAR;\n+              break;\n+            case '@':\n+              ch = AT;\n+              break;\n+            case '(':\n+\t      ch = BRACKET;\n+              break;\n+            case 'B':\n+              ch = B;\n+              break;\n+            case 'J':\n+              ch = J;\n+              break;\n+            case '\\0':\n+              ch = NUL;\n+              break;\n+            default:\n+              if (ISJIS (curr_ch))\n+                ch = JIS_CHAR;\n+              else\n+                ch = OTHER;\n+\t    }\n+\n+          action = JIS_action_table[curr_state][ch];\n+          curr_state = JIS_state_table[curr_state][ch];\n+        \n+          switch (action)\n+            {\n+            case NOOP:\n+              break;\n+            case EMPTY:\n+\t      if (pwc != NULL)\n+\t\t*pwc = (wchar_t)0;\n+\t      save_state = curr_state;\n+              return i;\n+            case COPYA:\n+\t      if (pwc != NULL)\n+\t\t*pwc = (wchar_t)*ptr;\n+\t      save_state = curr_state;\n+              return (i + 1);\n+            case COPYJ:\n+\t      if (pwc != NULL)\n+\t\t*pwc = (((wchar_t)*ptr) << 8) + (wchar_t)(*(ptr+1));\n+\t      save_state = curr_state;\n+              return (i + 1);\n+            case COPYJ2:\n+\t      if (pwc != NULL)\n+\t\t*pwc = (((wchar_t)*ptr) << 8) + (wchar_t)(*(ptr+1));\n+\t      save_state = curr_state;\n+              return (ptr - t) + 2;\n+            case MAKE_A:\n+            case MAKE_J:\n+              ptr = (char *)(t + i + 1);\n+              break;\n+            case ERROR:\n+            default:\n+              return -1;\n+            }\n+        }\n+\n+      return -1;  /* n < bytes needed */\n+    }\n+               \n+#ifdef CROSS_COMPILE\n+  if (s == NULL)\n+    return 0;  /* not state-dependent */\n+  if (pwc != NULL)\n+    *pwc = *s;\n+  return 1;\n+#else\n+  /* This must be the \"C\" locale or unknown locale. */\n+  return mbtowc (pwc, s, n);\n+#endif\n+}\n+\n+int\n+local_mblen (s, n)\n+     const char    *s;\n+     size_t         n;\n+{\n+  return local_mbtowc (NULL, s, n);\n+}\n+\n+int\n+local_mb_cur_max ()\n+{\n+  if (literal_codeset == NULL || strlen (literal_codeset) <= 1)\n+    ;\n+  else if (! strcmp (literal_codeset, \"C-SJIS\"))\n+    return 2;\n+  else if (! strcmp (literal_codeset, \"C-EUCJP\"))\n+    return 2;\n+  else if (! strcmp (literal_codeset, \"C-JIS\"))\n+    return 8; /* 3 + 2 + 3 */\n+\n+#ifdef CROSS_COMPILE\n+  return 1;\n+#else\n+  return MB_CUR_MAX;\n+#endif\n+}\n+#endif /* MULTIBYTE_CHARS */"}, {"sha": "a4b82c0558dfd6fb951e2b556b00ecdb3de4424a", "filename": "gcc/mbchar.h", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fmbchar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56f48ce9765aa2b6d4742a4923fee581a12c1418/gcc%2Fmbchar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmbchar.h?ref=56f48ce9765aa2b6d4742a4923fee581a12c1418", "patch": "@@ -0,0 +1,25 @@\n+/* mbchar.h - Various declarations for functions found in mbchar.c\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+ */\n+\n+#ifndef __GCC_MBCHAR_H__\n+#define __GCC_MBCHAR_H__\n+\n+#ifdef MULTIBYTE_CHARS\n+/* escape character used for JIS encoding */\n+#define JIS_ESC_CHAR 0x1b\n+\n+#define ISSJIS1(c)   ((c) >= 0x81 && (c) <= 0x9f || (c) >= 0xe0 && (c) <= 0xef)\n+#define ISSJIS2(c)   ((c) >= 0x40 && (c) <= 0x7e || (c) >= 0x80 && (c) <= 0xfc)\n+#define ISEUCJP(c)   ((c) >= 0xa1 && (c) <= 0xfe)\n+#define ISJIS(c)     ((c) >= 0x21 && (c) <= 0x7e)\n+\n+int local_mbtowc     PROTO ((wchar_t *, const char *, size_t));\n+int local_mblen      PROTO ((const char *, size_t));\n+int local_mb_cur_max PROTO ((void));\n+\n+/* The locale being used for multibyte characters in string/char literals.  */\n+extern char *literal_codeset;\n+#endif /* MULTIBYTE_CHARS */\n+\n+#endif /* __GCC_MBCHAR_H__ */"}]}