{"sha": "e8abc66f6066b9f808fa9d86376f950b68c3236c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThhYmM2NmY2MDY2YjlmODA4ZmE5ZDg2Mzc2Zjk1MGI2OGMzMjM2Yw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-04-24T17:27:46Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-04-24T17:27:46Z"}, "message": "67th Cygnus<->FSF merge\n\nFrom-SVN: r9433", "tree": {"sha": "05387abeca235d05928bcbdd91eb5aa83da77407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05387abeca235d05928bcbdd91eb5aa83da77407"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8abc66f6066b9f808fa9d86376f950b68c3236c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8abc66f6066b9f808fa9d86376f950b68c3236c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8abc66f6066b9f808fa9d86376f950b68c3236c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8abc66f6066b9f808fa9d86376f950b68c3236c/comments", "author": null, "committer": null, "parents": [{"sha": "87c7361897db3abd2756356ce485a96430087938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c7361897db3abd2756356ce485a96430087938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87c7361897db3abd2756356ce485a96430087938"}], "stats": {"total": 839, "additions": 358, "deletions": 481}, "files": [{"sha": "86705874c352a3c7c31cda60c3d34f554ebf943c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -1,3 +1,98 @@\n+Sun Apr 23 12:32:38 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (finish_file): Fix broken linked list handling.\n+\n+Fri Apr 21 18:08:43 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (finish_base_struct): Don't set TYPE_HAS_COMPLEX_*_REF\n+\tas often.\n+\t(finish_struct): Ditto.\n+\n+\t* various: Use TYPE_HAS_TRIVIAL_* instead of TYPE_HAS_COMPLEX_*.\n+\n+\t* cp-tree.h (TYPE_HAS_TRIVIAL_INIT_REF): New macro.\n+\t(TYPE_HAS_TRIVIAL_ASSIGN_REF): New macro.\n+\n+Fri Apr 21 15:52:22 1995  Jason Merrill  <jason@python.cygnus.com>\n+\n+\t* typeck.c (c_expand_return): Only expand a returned TARGET_EXPR if\n+\tit is of the same type as the return value.\n+\n+Fri Apr 21 03:01:46 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl2.c (finish_file): Reconsider if synthesizing a method wrote\n+\tout its assembly.\n+\n+\t* typeck.c (convert_for_initialization): Don't call a trivial copy\n+\tconstructor.\n+\n+\t* typeck2.c (store_init_value): Only abort if the type has a\n+\tnon-trivial copy constructor.\n+\n+\t* typeck.c (c_expand_return): If we're returning in a register and\n+\tthe return value is a TARGET_EXPR, expand it.  Only do\n+\texpand_aggr_init if we're returning in memory.\n+\t(expand_target_expr): Function to expand a TARGET_EXPR.\n+\t(build_modify_expr): Use it.\n+\n+\t* tree.c (build_cplus_new): Layout the slot.\n+\n+\t* expr.c (cplus_expand_expr): Use expand_call to expand the call\n+\tunder a NEW_EXPR, so the target is not discarded.\n+\n+Thu Apr 20 14:59:31 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gc.c (build_dynamic_cast): Tighten error checking.\n+\n+Thu Apr 20 11:23:54 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* expr.c (cplus_expand_expr): Only abort if the returned target is\n+\tdifferent from what we expected if the type has a non-trivial copy\n+\tconstructor.\n+\n+\t* decl2.c (cplus_decl_attributes): Attributes applied to a template\n+\treally apply to the template's result.\n+\n+\t* tree.c (lvalue_p): Check IS_AGGR_TYPE instead of TREE_ADDRESSABLE\n+\tto decide whether to consider a CALL_EXPR an lvalue.\n+\n+\t* class.c (finish_struct_bits): Only set TREE_ADDRESSABLE if the\n+\ttype has a non-trivial copy constructor.\n+\n+\t* decl.c (start_function): If interface_known, unset\n+\tDECL_NOT_REALLY_EXTERN on the function.\n+\n+Wed Apr 19 16:53:13 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* pt.c (do_function_instantiation): Handle explicit instantiation of\n+\tmember functions.\n+\t(do_type_instantiation): Handle 'inline template class foo<int>',\n+\tmeaning just spit out the vtable.\n+\n+\t* lex.c (cons_up_default_function): Set DECL_NOT_REALLY_EXTERN on\n+\tthe consed functions.\n+\n+\t* decl2.c (import_export_inline): Set DECL_INTERFACE_KNOWN.\n+\n+Wed Apr 19 16:28:17 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* call.c, class.c, decl2.c, gc.c, init.c, parse.y, pt.c, search.c,\n+\ttypeck.c: Include output.h.\n+\n+Wed Apr 19 14:57:21 1995  Gerald Baumgartner  (gb@alexander.cs.purdue.edu)\n+\n+\t* call.c (build_method_call): Allow a signature member functions to\n+\tbe called from a default implementation.\n+\n+Wed Apr 19 10:21:17 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* repo.c (finish_repo): Remember what directory we are in.\n+\n+\t* search.c (expand_upcast_fixups): Don't mess with abort_fndecl.\n+\n+\t* repo.c: Use obstacks instead of fixed-size buffers.  Don't spit\n+\tout the second copy of the symbol name.  Don't remember COLLECT_GCC.\n+\n Wed Apr 19 02:32:40 1995  Mike Stump  <mrs@cygnus.com>\n \n \t* search.c (virtual_context): New function to get the virtual"}, {"sha": "fa92ed86a2762288698205e72e45a5419d78a762", "filename": "gcc/cp/call.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -27,6 +27,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include <stdio.h>\n #include \"cp-tree.h\"\n #include \"class.h\"\n+#include \"output.h\"\n #include \"flags.h\"\n \n #include \"obstack.h\"\n@@ -1683,10 +1684,24 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \tneed_vtbl = (dtor_label || ctor_label)\n \t  ? unneeded : maybe_needed;\n \n-      instance = C_C_D;\n-      instance_ptr = current_class_decl;\n-      result = build_field_call (TYPE_BINFO (current_class_type),\n-\t\t\t\t instance_ptr, name, parms);\n+      /* If `this' is a signature pointer and `name' is not a constructor,\n+\t we are calling a signature member function.  In that case, set the\n+\t `basetype' to the signature type and dereference the `optr' field.  */\n+      if (IS_SIGNATURE_POINTER (basetype)\n+\t  && TYPE_IDENTIFIER (basetype) != name)\n+\t{\n+\t  basetype = SIGNATURE_TYPE (basetype);\n+\t  instance_ptr = build_optr_ref (instance);\n+\t  instance_ptr = convert (TYPE_POINTER_TO (basetype), instance_ptr);\n+\t  basetype_path = TYPE_BINFO (basetype);\n+\t}\n+      else\n+\t{\n+\t  instance = C_C_D;\n+\t  instance_ptr = current_class_decl;\n+\t  basetype_path = TYPE_BINFO (current_class_type);\n+\t}\n+      result = build_field_call (basetype_path, instance_ptr, name, parms);\n \n       if (result)\n \treturn result;"}, {"sha": "78d0c5d21eef70b77aad197d523589cc2d9c5497", "filename": "gcc/cp/class.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -27,6 +27,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"cp-tree.h\"\n #include \"flags.h\"\n #include \"rtl.h\"\n+#include \"output.h\"\n \n #include \"obstack.h\"\n #define obstack_chunk_alloc xmalloc\n@@ -1412,8 +1413,7 @@ finish_base_struct (t, b, t_binfo)\n       TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (basetype);\n       TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_NEEDS_DESTRUCTOR (basetype);\n       TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (basetype);\n-      TYPE_HAS_COMPLEX_INIT_REF (t) |= (TYPE_HAS_COMPLEX_INIT_REF (basetype)\n-\t\t\t\t\t|| TYPE_NEEDS_CONSTRUCTING (basetype));\n+      TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (basetype);\n \n       TYPE_OVERLOADS_CALL_EXPR (t) |= TYPE_OVERLOADS_CALL_EXPR (basetype);\n       TYPE_OVERLOADS_ARRAY_REF (t) |= TYPE_OVERLOADS_ARRAY_REF (basetype);\n@@ -1688,19 +1688,19 @@ finish_struct_bits (t, max_has_virtual)\n \t}\n     }\n \n-  /* If this type has constructors, force its mode to be BLKmode,\n-     and force its TREE_ADDRESSABLE bit to be nonzero.  */\n-  if (TYPE_NEEDS_CONSTRUCTING (t) || TYPE_NEEDS_DESTRUCTOR (t))\n+  /* If this type has a copy constructor, force its mode to be BLKmode, and\n+     force its TREE_ADDRESSABLE bit to be nonzero.  This will cause it to\n+     be passed by invisible reference and prevent it from being returned in\n+     a register.  */\n+  if (! TYPE_HAS_TRIVIAL_INIT_REF (t))\n     {\n-      tree variants = t;\n-\n+      tree variants;\n       if (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n \tDECL_MODE (TYPE_NAME (t)) = BLKmode;\n-      while (variants)\n+      for (variants = t; variants; variants = TYPE_NEXT_VARIANT (variants))\n \t{\n \t  TYPE_MODE (variants) = BLKmode;\n \t  TREE_ADDRESSABLE (variants) = 1;\n-\t  variants = TYPE_NEXT_VARIANT (variants);\n \t}\n     }\n }\n@@ -3085,7 +3085,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t\t members.  */\n \t      cant_synth_asn_ref = 1;\n \t      cant_have_default_ctor = 1;\n-\t      TYPE_HAS_COMPLEX_INIT_REF (t) = 1;\n \n \t      if (! TYPE_HAS_CONSTRUCTOR (t) && extra_warnings)\n \t\t{\n@@ -3109,7 +3108,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t\t members.  */\n \t      cant_synth_asn_ref = 1;\n \t      cant_have_default_ctor = 1;\n-\t      TYPE_HAS_COMPLEX_INIT_REF (t) = 1;\n \n \t      if (! TYPE_HAS_CONSTRUCTOR (t) && !IS_SIGNATURE (t)\n \t\t  && extra_warnings)\n@@ -3266,9 +3264,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t\t      TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (type);\n \t\t      TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_NEEDS_DESTRUCTOR (type);\n \t\t      TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n-\t\t      TYPE_HAS_COMPLEX_INIT_REF (t)\n-\t\t\t|= (TYPE_HAS_COMPLEX_INIT_REF (type)\n-\t\t\t    || TYPE_NEEDS_CONSTRUCTING (type));\n+\t\t      TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (type);\n \t\t    }\n \n \t\t  if (! TYPE_HAS_INIT_REF (type)\n@@ -3374,7 +3370,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \n   TYPE_HAS_COMPLEX_INIT_REF (t)\n     |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n-\t|| has_virtual || any_default_members || first_vfn_base_index >= 0);\n+\t|| any_default_members);\n   TYPE_NEEDS_CONSTRUCTING (t)\n     |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n \t|| has_virtual || any_default_members || first_vfn_base_index >= 0);\n@@ -3406,8 +3402,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   TYPE_HAS_REAL_ASSIGNMENT (t) |= TYPE_HAS_ASSIGNMENT (t);\n   TYPE_HAS_REAL_ASSIGN_REF (t) |= TYPE_HAS_ASSIGN_REF (t);\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n-    |= (TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n-\t|| has_virtual || first_vfn_base_index >= 0);\n+    |= TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t);\n \n   if (! TYPE_HAS_ASSIGN_REF (t) && ! cant_synth_asn_ref\n       && ! IS_SIGNATURE (t))"}, {"sha": "22dd9c4a75d6bdfbaa729bf90c6f83ef6e8d949e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -1220,6 +1220,16 @@ struct lang_decl\n    of ARRAY_TYPE is the type of the elements needs a destructor.  */\n #define TYPE_NEEDS_DESTRUCTOR(NODE) (TYPE_LANG_FLAG_4(NODE))\n \n+/* Nonzero for class type means that initialization of this type can use\n+   a bitwise copy.  */\n+#define TYPE_HAS_TRIVIAL_INIT_REF(NODE) \\\n+  (TYPE_HAS_INIT_REF (NODE) && ! TYPE_HAS_COMPLEX_INIT_REF (NODE))\n+\n+/* Nonzero for class type means that assignment of this type can use\n+   a bitwise copy.  */\n+#define TYPE_HAS_TRIVIAL_ASSIGN_REF(NODE) \\\n+  (TYPE_HAS_ASSIGN_REF (NODE) && ! TYPE_HAS_COMPLEX_ASSIGN_REF (NODE))\n+\n /* Nonzero for _TYPE node means that this type is a pointer to member\n    function type. */\n #define TYPE_PTRMEMFUNC_P(NODE) (TREE_CODE(NODE) == RECORD_TYPE && TYPE_LANG_SPECIFIC(NODE)->type_flags.ptrmemfunc_flag)"}, {"sha": "74dca4f2080625560d8853104f1b34cb0ba78775", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -10827,6 +10827,7 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t     || (DECL_THIS_INLINE (decl1) && ! flag_implement_inlines));\n       else\n \tDECL_EXTERNAL (decl1) = 0;\n+      DECL_NOT_REALLY_EXTERN (decl1) = 0;\n       DECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n   else"}, {"sha": "5952d856b9cd616e9e57957421f05613bbbc6c82", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -34,6 +34,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"cp-tree.h\"\n #include \"decl.h\"\n #include \"lex.h\"\n+#include \"output.h\"\n \n extern tree grokdeclarator ();\n extern tree get_file_function_name ();\n@@ -1948,8 +1949,13 @@ void\n cplus_decl_attributes (decl, attributes, prefix_attributes)\n      tree decl, attributes, prefix_attributes;\n {\n-  if (decl && decl != void_type_node)\n-    decl_attributes (decl, attributes, prefix_attributes);\n+  if (decl == NULL_TREE || decl == void_type_node)\n+    return;\n+\n+  if (TREE_CODE (decl) == TEMPLATE_DECL)\n+    decl = DECL_TEMPLATE_RESULT (decl);\n+\n+  decl_attributes (decl, attributes, prefix_attributes);\n }\n \f\n /* CONSTRUCTOR_NAME:\n@@ -2775,6 +2781,8 @@ import_export_inline (decl)\n     }\n   else\n     TREE_PUBLIC (decl) = 0;\n+\n+  DECL_INTERFACE_KNOWN (decl) = 1;\n }\n \n extern int parse_time, varconst_time;\n@@ -3086,11 +3094,12 @@ finish_file ()\n      inline'.  */\n   {\n     int reconsider = 1;\t\t/* More may be referenced; check again */\n-    saved_inlines = tree_cons (NULL_TREE, NULL_TREE, saved_inlines);\n \n     while (reconsider)\n       {\n-\ttree last = saved_inlines;\n+\ttree last = saved_inlines = tree_cons (NULL_TREE, NULL_TREE,\n+\t\t\t\t\t       saved_inlines);\n+\ttree last_head = last;\n \ttree place = TREE_CHAIN (saved_inlines);\n \treconsider = 0;\n \n@@ -3100,11 +3109,23 @@ finish_file ()\n \t  {\n \t    tree decl = TREE_VALUE (place);\n \n+\t    /* Slice out the empty elements put in just above in the\n+\t       previous reconsidering.  */\n+\t    if (decl == NULL_TREE)\n+\t      {\n+\t\tTREE_CHAIN (last) = TREE_CHAIN (place);\n+\t\tcontinue;\n+\t      }\n+\n \t    if (DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl))\n \t      {\n \t\tif (TREE_USED (decl)\n \t\t    || (TREE_PUBLIC (decl) && DECL_NOT_REALLY_EXTERN (decl)))\n-\t\t  synthesize_method (decl);\n+\t\t  {\n+\t\t    synthesize_method (decl);\n+\t\t    if (TREE_ASM_WRITTEN (decl))\n+\t\t      reconsider = 1;\n+\t\t  }\n \t\telse\n \t\t  {\n \t\t    last = place;"}, {"sha": "c6630cb5b1fa819ae294f7d60ff32b771be938c3", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -142,7 +142,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \tpreserve_temp_slots (DECL_RTL (slot));\n \tcall_exp = build (CALL_EXPR, type, func, args, 0);\n \tTREE_SIDE_EFFECTS (call_exp) = 1;\n-\treturn_target = expand_expr (call_exp, call_target, mode, 0);\n+\treturn_target = expand_call (call_exp, call_target, ignore);\n \tfree_temp_slots ();\n \tif (call_target == 0)\n \t  {\n@@ -174,7 +174,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \n \tif (call_target != return_target)\n \t  {\n-\t    my_friendly_assert (! TYPE_NEEDS_CONSTRUCTING (type), 317);\n+\t    my_friendly_assert (TYPE_HAS_TRIVIAL_INIT_REF (type), 317);\n \t    if (GET_MODE (return_target) == BLKmode)\n \t      emit_block_move (call_target, return_target, expr_size (exp),\n \t\t\t       TYPE_ALIGN (type) / BITS_PER_UNIT);"}, {"sha": "cb3beab4c52fd4cce70effb67c7438b486c25828", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 75, "deletions": 22, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -1145,16 +1145,21 @@ independent representation for exceptions.\n The C++ front-end exceptions are mapping into the unwind-protect\n semantics by the C++ front-end.  The mapping is describe below.\n \n-Objects with RTTI support should use the RTTI information to do mapping\n-and checking.  Objects without RTTI, like int and const char *, have to\n-use another means of matching.  Currently we use the normal mangling used in\n-building functions names.  Int's are \"i\", const char * is PCc, etc...\n-\n-Unfortunately, the standard allows standard type conversions on throw\n-parameters so they can match catch handlers.  This means we need a\n-mechanism to handle type conversion at run time, ICK.  I read this part\n-again, and it appears that we only have to be able to do a few of the\n-conversions at run time, so we should be ok.\n+When -frtti is used, rtti is used to do exception object type checking,\n+when it isn't used, the encoded name for the type of the object being\n+thrown is used instead.  All code that originates exceptions, even code\n+that throws exceptions as a side effect, like dynamic casting, and all\n+code that catches exceptions must be compiled with either -frtti, or\n+-fno-rtti.  It is not possible to mix rtti base exception handling\n+objects with code that doesn't use rtti.  The exceptions to this, are\n+code that doesn't catch or throw exceptions, catch (...), and code that\n+just rethrows an exception.\n+\n+Currently we use the normal mangling used in building functions names\n+(int's are \"i\", const char * is PCc) to build the non-rtti base type\n+descriptors for exception handling.  These descriptors are just plain\n+NULL terminated strings, and internally they are passed around as char\n+*.\n \n In C++, all cleanups should be protected by exception regions.  The\n region starts just after the reason why the cleanup is created has\n@@ -1192,18 +1197,20 @@ throwing.  The only bad part, is that the stack remains large.\n The below points out some flaws in g++'s exception handling, as it now\n stands.\n \n-Only exact type matching or reference matching of throw types works.\n-Only works on a SPARC machines (like Suns), i386 machines, arm machines\n-and rs6000 machines.  Partial support is also in for alpha, hppa, m68k\n-and mips machines, but a stack unwinder called __unwind_function has to\n-be written, and added to libgcc2 for them.  All completely constructed\n-temps and local variables are cleaned up in all unwinded scopes.\n-Completed parts of partially constructed objects are not cleaned up.\n-Don't expect exception handling to work right if you optimize, in fact\n-the compiler will probably core dump.  If two EH regions are the exact\n-same size, the backend cannot tell which one is first.  It punts by\n-picking the last one, if they tie.  This is usually right.  We really\n-should stick in a nop, if they are the same size.\n+Only exact type matching or reference matching of throw types works when\n+-fno-rtti is used.  Only works on a SPARC (like Suns), i386, arm and\n+rs6000 machines.  Partial support is also in for alpha, hppa, m68k and\n+mips machines, but a stack unwinder called __unwind_function has to be\n+written, and added to libgcc2 for them.  See below for details on\n+__unwind_function.  All completely constructed temps and local variables\n+are cleaned up in all unwinded scopes.  Completed parts of partially\n+constructed objects are cleaned up with the exception that partially\n+built arrays are not cleaned up as required.  Don't expect exception\n+handling to work right if you optimize, in fact the compiler will\n+probably core dump.  If two EH regions are the exact same size, the\n+backend cannot tell which one is first.  It punts by picking the last\n+one, if they tie.  This is usually right.  We really should stick in a\n+nop, if they are the same size.\n \n When we invoke the copy constructor for an exception object because it\n is passed by value, and if we take a hit (exception) inside the copy\n@@ -1232,6 +1239,52 @@ When the backend returns a value, it can create new exception regions\n that need protecting.  The new region should rethrow the object in\n context of the last associated cleanup that ran to completion.\n \n+The __unwind_function takes a pointer to the throw handler, and is\n+expected to pop the stack frame that was built to call it, as well as\n+the frame underneath and then jump to the throw handler.  It must not\n+change the three registers allocated for the pointer to the exception\n+object, the pointer to the type descriptor that identifies the type of\n+the exception object, and the pointer to the code that threw.  On hppa,\n+these are %r5, %r6, %r7.  On m68k these are a2, a3, a4.  On mips they\n+are s0, s1, s2.  On Alpha these are $9, $10, $11.  It takes about a day\n+to write this routine, if someone wants to volunteer to write this\n+routine for any architecture, exception support for that architecture\n+will be added to g++.  Please send in those code donations.\n+\n+\n+The backend must be extended to fully support exceptions.  Right now\n+there are a few hooks into the alpha exception handling backend that\n+resides in the C++ frontend from that backend that allows exception\n+handling to work in g++.  An exception region is a segment of generated\n+code that has a handler associated with it.  The exception regions are\n+denoted in the generated code as address ranges denoted by a starting PC\n+value and an ending PC value of the region.  Some of the limitations\n+with this scheme are:\n+\n+@itemize @bullet\n+@item\n+The backend replicates insns for such things as loop unrolling and\n+function inlining.  Right now, there are no hooks into the frontend's\n+exception handling backend to handle the replication of insns.  When\n+replication happens, a new exception region descriptor needs to be\n+generated for the new region.\n+\n+@item\n+The backend expects to be able to rearrange code, for things like jump\n+optimization.  Any rearranging of the code needs have exception region\n+descriptors updated appropriately.\n+\n+@item\n+The backend can eliminate dead code.  Any associated exception region\n+descriptor that refers to fully contained code that has been eliminated\n+should also be removed, although not doing this is harmless in terms of\n+semantics.\n+\n+#end itemize\n+\n+The above is not meant to be exhaustive, but does include all things I\n+have thought of so far.  I am sure other limitations exist.\n+\n @node Free Store, Concept Index, Exception Handling, Top\n @section Free Store\n "}, {"sha": "61ed7e7a722997b5c2a647c2bfb7dec77660e42a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -26,6 +26,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"rtl.h\"\n #include \"cp-tree.h\"\n #include \"flags.h\"\n+#include \"output.h\"\n \n #undef NULL\n #define NULL 0\n@@ -1202,8 +1203,7 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n     }\n \n   if (init && TREE_CHAIN (parms) == NULL_TREE\n-      && TYPE_HAS_CONSTRUCTOR (type)\n-      && ! TYPE_NEEDS_CONSTRUCTING (type)\n+      && TYPE_HAS_TRIVIAL_INIT_REF (type)\n       && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (init)))\n     {\n       rval = build (INIT_EXPR, type, exp, init);"}, {"sha": "7c6b791aecfa8b05809c0ce5dd2a896dad141fb9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 348, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -1801,6 +1801,8 @@ cons_up_default_function (type, full_name, kind)\n \t\t\t    || ! flag_implement_inlines);\n       TREE_STATIC (fn) = ! DECL_EXTERNAL (fn);\n     }\n+  else\n+    DECL_NOT_REALLY_EXTERN (fn) = 1;\n \n   /* When on-the-fly synthesis works properly, remove the second and third\n      conditions here.  */\n@@ -1849,354 +1851,6 @@ cons_up_default_function (type, full_name, kind)\n   return fn;\n }\n \n-#if 0\n-/* Used by default_copy_constructor_body.  For the anonymous union\n-   in TYPE, return the member that is at least as large as the rest\n-   of the members, so we can copy it.  */\n-static tree\n-largest_union_member (type)\n-     tree type;\n-{\n-  tree f, type_size = TYPE_SIZE (type);\n-\n-  for (f = TYPE_FIELDS (type); f; f = TREE_CHAIN (f))\n-    if (simple_cst_equal (DECL_SIZE (f), type_size))\n-      return f;\n-\n-  /* We should always find one.  */\n-  my_friendly_abort (323);\n-  return NULL_TREE;\n-}\n-\n-/* Construct the body of a default assignment operator.\n-   Mostly copied directly from default_copy_constructor_body.  */\n-static void\n-default_assign_ref_body (bufp, lenp, type, fields)\n-     char **bufp;\n-     int *lenp;\n-     tree type, fields;\n-{\n-  static struct obstack body;\n-  static int inited = FALSE;\n-  int n_bases = CLASSTYPE_N_BASECLASSES (type);\n-  char *tbuf;\n-  int tgot, tneed;\n-\n-  if (!inited)\n-    {\n-      obstack_init (&body);\n-      inited = TRUE;\n-    }\n-  body.next_free = body.object_base;\n-\n-  obstack_1grow (&body, '{');\n-\n-  /* Small buffer for sprintf().  */\n-\n-  tgot = 100;\n-  tbuf = (char *) alloca (tgot);\n-\n-  /* If we don't need a real op=, just do a bitwise copy.  */\n-  if (! TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n-    {\n-      tbuf = \"{__builtin_memcpy(this,&_ctor_arg,sizeof(_ctor_arg));return *this;}\";\n-      *lenp = strlen (tbuf);\n-      *bufp = obstack_alloc (&inline_text_obstack, *lenp + 1);\n-      strcpy (*bufp, tbuf);\n-      return;\n-    }\n-\n-  if (TREE_CODE (type) == UNION_TYPE)\n-    {\n-      if (fields)\n-\t{\n-\t  tree main = fields;\n-\t  char * s;\n-\t  tree f;\n-\n-\t  for (f = TREE_CHAIN (fields); f; f = TREE_CHAIN (f))\n-\t    if (tree_int_cst_lt (TYPE_SIZE (TREE_TYPE (main)),\n-\t\t\t\t TYPE_SIZE (TREE_TYPE (f))))\n-\t      main = f;\n-\n-\t  s = IDENTIFIER_POINTER (DECL_NAME (main));\n-\n-\t  tneed = (2 * strlen (s)) + 28;\n-\t  if (tgot < tneed)\n-\t    {\n-\t      tgot = tneed;\n-\t      tbuf = (char *) alloca (tgot);\n-\t    }\n-\n-\t  sprintf (tbuf, \"{%s=_ctor_arg.%s;return *this;}\", s, s);\n-\t}\n-      else\n-\ttbuf = \"{}\";\n-      \n-      *lenp = strlen (tbuf);\n-      *bufp = obstack_alloc (&inline_text_obstack, *lenp + 1);\n-      strcpy (*bufp, tbuf);\n-      return;\n-    }\n-\n-  /* Construct base classes...\n-     FIXME: Does not deal with multiple inheritance and virtual bases\n-     correctly.  See g++.old-deja/g++.jason/opeq5.C for a testcase.\n-     We need to do wacky things if everything between us and the virtual\n-     base (by all paths) has a \"complex\" op=.  */\n-\n-  if (n_bases)\n-    {\n-      tree bases = TYPE_BINFO_BASETYPES (type);\n-      int i = 0;\n-\n-      for (i = 0; i < n_bases; i++)\n-\t{\n-\t  tree binfo = TREE_VEC_ELT (bases, i);\n-\t  tree btype, name;\n-\t  char *s;\n-\n-\t  btype = BINFO_TYPE (binfo);\n-\t  name = TYPE_NESTED_NAME (btype);\n-\t  s = IDENTIFIER_POINTER (name);\n-\n-\t  tneed = (2 * strlen (s)) + 42;\n-\t  if (tgot < tneed)\n-\t    {\n-\t      tgot = tneed;\n-\t      tbuf = (char *) alloca (tgot);\n-\t    }\n-\n-\t  sprintf (tbuf, \"%s::operator=((%s%s ::%s&)_ctor_arg);\", s,\n-\t\t   TYPE_READONLY (type) ? \"const \" : \"\",\n-\t\t   CLASSTYPE_DECLARED_CLASS (btype) ? \"class\" : \"struct\",\n-\t\t   s);\n-\t  obstack_grow (&body, tbuf, strlen (tbuf));\n-\t}\n-    }\n-\n-  /* Construct fields.  */\n-\n-  if (fields)\n-    {\n-      tree f;\n-\n-      for (f = fields; f; f = TREE_CHAIN (f))\n-\t{\n-\t  if (TREE_CODE (f) == FIELD_DECL && ! DECL_VIRTUAL_P (f))\n-\t    {\n-\t      char *s;\n-\t      tree x;\n-\t      tree t = TREE_TYPE (f);\n-\n-\t      if (DECL_NAME (f))\n-\t\tx = f;\n-\t      else if (t != NULL_TREE\n-\t\t       && TREE_CODE (t) == UNION_TYPE\n-\t\t       && ((TREE_CODE (TYPE_NAME (t)) == IDENTIFIER_NODE\n-\t\t\t    && ANON_AGGRNAME_P (TYPE_NAME (t)))\n-\t\t\t   || (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n-\t\t\t       && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))))\n-\t\t       && TYPE_FIELDS (t) != NULL_TREE)\n-\t\tx = largest_union_member (t);\n-\t      else\n-\t\tcontinue;\n-\n-\t      s = IDENTIFIER_POINTER (DECL_NAME (x));\n-\t      tneed = (2 * strlen (s)) + 13;\n-\t      if (tgot < tneed)\n-\t\t{\n-\t\t  tgot = tneed;\n-\t\t  tbuf = (char *) alloca (tgot);\n-\t\t}\n-\n-\t      sprintf (tbuf, \"%s=_ctor_arg.%s;\", s, s);\n-\t      obstack_grow (&body, tbuf, strlen (tbuf));\n-\t    }\n-\t}\n-    }\n-\n-  obstack_grow (&body, \"return *this;}\", 15);\n-\n-  *lenp = obstack_object_size (&body) - 1;\n-  *bufp = obstack_alloc (&inline_text_obstack, *lenp);\n-\n-  strcpy (*bufp, body.object_base);\n-}\n-\n-/* Construct the body of a default copy constructor.  */\n-static void\n-default_copy_constructor_body (bufp, lenp, type, fields)\n-     char **bufp;\n-     int *lenp;\n-     tree type, fields;\n-{\n-  static struct obstack prologue;\n-  static int inited = FALSE;\n-  int n_bases = CLASSTYPE_N_BASECLASSES (type);\n-  char sep = ':';\n-  char *tbuf;\n-  int tgot, tneed;\n-\n-  /* Create a buffer to call base class constructors and construct members\n-     (fields).  */\n-\n-  if (!inited)\n-    {\n-      obstack_init (&prologue);\n-      inited = TRUE;\n-    }\n-  prologue.next_free = prologue.object_base;\n-\n-  /* If we don't need a real copy ctor, just do a bitwise copy.  */\n-  if (! TYPE_HAS_COMPLEX_INIT_REF (type))\n-    {\n-      tbuf = \"{__builtin_memcpy(this,&_ctor_arg,sizeof(_ctor_arg));}\";\n-      *lenp = strlen (tbuf);\n-      *bufp = obstack_alloc (&inline_text_obstack, *lenp + 1);\n-      strcpy (*bufp, tbuf);\n-      return;\n-    }\n-\n-  /* Small buffer for sprintf().  */\n-\n-  tgot = 100;\n-  tbuf = (char *) alloca (tgot);\n-\n-  if (TREE_CODE (type) == UNION_TYPE)\n-    {\n-      if (fields)\n-\t{\n-\t  tree main = fields;\n-\t  char * s;\n-\t  tree f;\n-\n-\t  for (f = TREE_CHAIN (fields); f; f = TREE_CHAIN (f))\n-\t    if (tree_int_cst_lt (TYPE_SIZE (TREE_TYPE (main)),\n-\t\t\t\t TYPE_SIZE (TREE_TYPE (f))))\n-\t      main = f;\n-\n-\t  s = IDENTIFIER_POINTER (DECL_NAME (main));\n-\t  tneed = (2 * strlen (s)) + 16;\n-\t  if (tgot < tneed)\n-\t    {\n-\t      tgot = tneed;\n-\t      tbuf = (char *) alloca (tgot);\n-\t    }\n-\n-\t  sprintf (tbuf, \":%s(_ctor_arg.%s){}\", s, s);\n-\t}\n-      else\n-\ttbuf = \"{}\";\n-\n-      *lenp = strlen (tbuf);\n-      *bufp = obstack_alloc (&inline_text_obstack, *lenp + 1);\n-      strcpy (*bufp, tbuf);\n-      return;\n-    }\n-\n-  /* Construct base classes... */\n-\n-  if (n_bases)\n-    {\n-      /* Note that CLASSTYPE_VBASECLASSES isn't set yet... */\n-      tree v = get_vbase_types (type);\n-      tree bases = TYPE_BINFO_BASETYPES (type);\n-      int i = 0;\n-\n-      for (;;)\n-\t{\n-\t  tree binfo, btype, name;\n-\t  char *s;\n-\n-\t  if (v)\n-\t    {\n-\t      binfo = v;\n-\t      v = TREE_CHAIN (v);\n-\t    }\n-\t  else if (i < n_bases)\n-\t    {\n-\t      binfo = TREE_VEC_ELT (bases, i++);\n-\t      if (TREE_VIA_VIRTUAL (binfo))\n-\t\tcontinue;\n-\t    }\n-\t  else\n-\t    break;\n-\n-\t  btype = BINFO_TYPE (binfo);\n-\t  name = TYPE_NESTED_NAME (btype);\n-\t  s = IDENTIFIER_POINTER (name);\n-\n-\t  tneed = (2 * strlen (s)) + 39;\n-\t  if (tgot < tneed)\n-\t    {\n-\t      tgot = tneed;\n-\t      tbuf = (char *) alloca (tgot);\n-\t    }\n-\n-\t  sprintf (tbuf, \"%c%s((%s%s ::%s&)_ctor_arg)\", sep, s,\n-\t\t   TYPE_READONLY (type) ? \"const \" : \"\",\n-\t\t   CLASSTYPE_DECLARED_CLASS (btype) ? \"class\" : \"struct\",\n-\t\t   s);\n-\t  sep = ',';\n-\t  obstack_grow (&prologue, tbuf, strlen (tbuf));\n-\t}\n-    }\n-\n-  /* Construct fields.  */\n-\n-  if (fields)\n-    {\n-      tree f;\n-\n-      for (f = fields; f; f = TREE_CHAIN (f))\n-\t{\n-\t  if (TREE_CODE (f) == FIELD_DECL && ! DECL_VIRTUAL_P (f))\n-\t    {\n-\t      char *s;\n-\t      tree x;\n-\t      tree t = TREE_TYPE (f);\n-\n-\t      if (DECL_NAME (f))\n-\t\tx = f;\n-\t      else if (t != NULL_TREE\n-\t\t       && TREE_CODE (t) == UNION_TYPE\n-\t\t       && ((TREE_CODE (TYPE_NAME (t)) == IDENTIFIER_NODE\n-\t\t\t    && ANON_AGGRNAME_P (TYPE_NAME (t)))\n-\t\t\t   || (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n-\t\t\t       && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t))))\n-\t\t       && TYPE_FIELDS (t) != NULL_TREE)\n-\t\tx = largest_union_member (t);\n-\t      else\n-\t\tcontinue;\n-\n-\t      s = IDENTIFIER_POINTER (DECL_NAME (x));\n-\t      tneed = (2 * strlen (s)) + 30;\n-\t      if (tgot < tneed)\n-\t\t{\n-\t\t  tgot = tneed;\n-\t\t  tbuf = (char *) alloca (tgot);\n-\t\t}\n-\n-\t      sprintf (tbuf, \"%c%s(_ctor_arg.%s)\", sep, s, s);\n-\t      sep = ',';\n-\t      obstack_grow (&prologue, tbuf, strlen (tbuf));\n-\t    }\n-\t}\n-    }\n-\n-  /* Concatenate constructor body to prologue.  */\n-\n-  *lenp = obstack_object_size (&prologue) + 2;\n-  *bufp = obstack_alloc (&inline_text_obstack, *lenp + 1);\n-\n-  obstack_1grow (&prologue, '\\0');\n-\n-  strcpy (*bufp, prologue.object_base);\n-  strcat (*bufp, \"{}\");\n-}\n-#endif\n-\n /* Heuristic to tell whether the user is missing a semicolon\n    after a struct or enum declaration.  Emit an error message\n    if we know the user has blown it.  */"}, {"sha": "ddf65b1df312935e96fddb9d7a2c4aac74b41786", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -2052,7 +2052,7 @@ do_build_copy_constructor (fndecl)\n     parm = TREE_CHAIN (parm);\n   parm = convert_from_reference (parm);\n \n-  if (! TYPE_HAS_COMPLEX_INIT_REF (current_class_type))\n+  if (TYPE_HAS_TRIVIAL_INIT_REF (current_class_type))\n     {\n       t = build (INIT_EXPR, void_type_node, C_C_D, parm);\n       TREE_SIDE_EFFECTS (t) = 1;\n@@ -2140,7 +2140,7 @@ do_build_assign_ref (fndecl)\n \n   parm = convert_from_reference (parm);\n \n-  if (! TYPE_HAS_COMPLEX_ASSIGN_REF (current_class_type))\n+  if (TYPE_HAS_TRIVIAL_ASSIGN_REF (current_class_type))\n     {\n       tree t = build (MODIFY_EXPR, void_type_node, C_C_D, parm);\n       TREE_SIDE_EFFECTS (t) = 1;"}, {"sha": "46eb2b47311912abdd01cc9115d85f0751822d07", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -53,6 +53,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"flags.h\"\n #include \"lex.h\"\n #include \"cp-tree.h\"\n+#include \"output.h\"\n \n /* Since parsers are distinct for each language, put the language string\n    definition here.  (fnf) */"}, {"sha": "9d6266f28d4557e4e6a33725a23a6da2e238536e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -38,6 +38,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"decl.h\"\n #include \"parse.h\"\n #include \"lex.h\"\n+#include \"output.h\"\n \n extern struct obstack permanent_obstack;\n extern tree grokdeclarator ();\n@@ -2510,11 +2511,17 @@ do_function_instantiation (declspecs, declarator, storage)\n      tree declspecs, declarator, storage;\n {\n   tree decl = grokdeclarator (declarator, declspecs, NORMAL, 0, 0);\n-  tree name = DECL_NAME (decl);\n-  tree fn = IDENTIFIER_GLOBAL_VALUE (name);\n+  tree name;\n+  tree fn;\n   tree result = NULL_TREE;\n   int extern_p = 0;\n-  if (fn)\n+\n+  /* If we've already seen this template instance, use it.  */\n+  if (name = DECL_ASSEMBLER_NAME (decl),\n+      fn = IDENTIFIER_GLOBAL_VALUE (name),\n+      fn && DECL_TEMPLATE_INSTANTIATION (fn))\n+    result = fn;\n+  else if (name = DECL_NAME (decl), fn = IDENTIFIER_GLOBAL_VALUE (name), fn)\n     {\n       for (fn = get_first_fn (fn); fn; fn = DECL_CHAIN (fn))\n \tif (decls_match (fn, decl)\n@@ -2578,12 +2585,14 @@ mark_class_instantiated (t, extern_p)\n       rest_of_type_compilation (t, 1);\n     }\n }     \n+\n void\n do_type_instantiation (name, storage)\n      tree name, storage;\n {\n   tree t = TREE_TYPE (name);\n-  int extern_p;\n+  int extern_p = 0;\n+  int nomem_p = 0;\n \n   /* With -fexternal-templates, explicit instantiations are treated the same\n      as implicit ones.  */\n@@ -2598,7 +2607,9 @@ do_type_instantiation (name, storage)\n     }\n \n   if (storage == NULL_TREE)\n-    extern_p = 0;\n+    /* OK */;\n+  else if (storage == ridpointers[(int) RID_INLINE])\n+    nomem_p = 1;\n   else if (storage == ridpointers[(int) RID_EXTERN])\n     extern_p = 1;\n   else\n@@ -2618,7 +2629,10 @@ do_type_instantiation (name, storage)\n       mark_class_instantiated (t, extern_p);\n       repo_template_instantiated (t, extern_p);\n     }\n-  \n+\n+  if (nomem_p)\n+    return;\n+\n   {\n     tree tmp;\n     /* Classes nested in template classes currently don't have an"}, {"sha": "fa04bcd1361dd0b15a8829fc03f10e47127c5014", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -33,14 +33,17 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n extern char * rindex ();\n extern char * getenv ();\n+extern char * getpwd ();\n \n static tree pending_repo;\n static tree original_repo;\n-static char repo_name[1024];\n+static char *repo_name;\n static FILE *repo_file;\n \n extern int flag_use_repository;\n extern int errorcount, sorrycount;\n+extern struct obstack temporary_obstack;\n+extern struct obstack permanent_obstack;\n \n #define IDENTIFIER_REPO_USED(NODE)   (TREE_LANG_FLAG_3 (NODE))\n #define IDENTIFIER_REPO_CHOSEN(NODE) (TREE_LANG_FLAG_4 (NODE))\n@@ -187,7 +190,6 @@ save_string (s, len)\n      char *s;\n      int len;\n {\n-  extern struct obstack temporary_obstack;\n   return obstack_copy0 (&temporary_obstack, s, len);\n }\n \n@@ -244,36 +246,42 @@ open_repo_file (filename)\n      char *filename;\n {\n   register char *p, *q;\n-  char *file = get_base_filename (filename);\n-  char *s;\n+  char *s = get_base_filename (filename);\n \n-  if (file == NULL)\n+  if (s == NULL)\n     return;\n \n-  s = rindex (file, '/');\n-  if (s == NULL)\n-    s = file;\n-  else\n-    ++s;\n+  p = rindex (s, '/');\n+  if (! p)\n+    p = s;\n+  p = rindex (p, '.');\n+  if (! p)\n+    p = s + strlen (s);\n \n-  for (p = repo_name, q = file; q < s; )\n-    *p++ = *q++;\n-/*  *p++ = '.'; */\n-  if ((s = rindex (q, '.')) == NULL)\n-    strcpy (p, q);\n-  else\n-    for (; q < s;)\n-      *p++ = *q++;\n-  strcat (p, \".rpo\");\n+  obstack_grow (&permanent_obstack, s, p - s);\n+  repo_name = obstack_copy0 (&permanent_obstack, \".rpo\", 4);\n \n   repo_file = fopen (repo_name, \"r\");\n }\n \n+static char *\n+afgets (stream)\n+     FILE *stream;\n+{\n+  int c;\n+  while ((c = getc (stream)) != EOF && c != '\\n')\n+    obstack_1grow (&temporary_obstack, c);\n+  if (obstack_object_size (&temporary_obstack) == 0)\n+    return NULL;\n+  obstack_1grow (&temporary_obstack, '\\0');\n+  return obstack_finish (&temporary_obstack);\n+}\n+\n void\n init_repo (filename)\n      char *filename;\n {\n-  char buf[1024];\n+  char *buf;\n \n   if (! flag_use_repository)\n     return;\n@@ -283,23 +291,19 @@ init_repo (filename)\n   if (repo_file == 0)\n     return;\n \n-  while (fgets (buf, 1024, repo_file))\n+  while (buf = afgets (repo_file))\n     {\n       switch (buf[0])\n \t{\n \tcase 'A':\n-\tcase 'G':\n+\tcase 'D':\n \tcase 'M':\n \t  break;\n \tcase 'C':\n \tcase 'O':\n \t  {\n-\t    char *q;\n-\t    tree id, orig;\n-\n-\t    for (q = &buf[2]; *q && *q != ' ' && *q != '\\n'; ++q) ;\n-\t    q = save_string (&buf[2], q - &buf[2]);\n-\t    id = get_identifier (q);\n+\t    tree id = get_identifier (buf + 2);\n+\t    tree orig;\n \n \t    if (buf[0] == 'C')\n \t      {\n@@ -315,6 +319,7 @@ init_repo (filename)\n \tdefault:\n \t  error (\"mysterious repository information in %s\", repo_name);\n \t}\n+      obstack_free (&temporary_obstack, buf);\n     }\n }\n \n@@ -382,9 +387,8 @@ finish_repo ()\n \n   fprintf (repo_file, \"M %s\\n\", main_input_filename);\n \n-  p = getenv (\"COLLECT_GCC\");\n-  if (p != 0)\n-    fprintf (repo_file, \"G %s\\n\", p);\n+  p = getpwd ();\n+  fprintf (repo_file, \"D %s\\n\", p);\n \n   p = getenv (\"COLLECT_GCC_OPTIONS\");\n   if (p != 0)\n@@ -395,9 +399,7 @@ finish_repo ()\n       tree val = TREE_VALUE (t);\n       char type = IDENTIFIER_REPO_CHOSEN (val) ? 'C' : 'O';\n \n-      fprintf (repo_file, \"%c %s \", type, IDENTIFIER_POINTER (val));\n-      ASM_OUTPUT_LABELREF (repo_file, IDENTIFIER_POINTER (val));\n-      putc ('\\n', repo_file);\n+      fprintf (repo_file, \"%c %s\\n\", type, IDENTIFIER_POINTER (val));\n     }\n \n  out:"}, {"sha": "c58683570f24fe5c726aa95651f57900c4db0132", "filename": "gcc/cp/search.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -28,12 +28,14 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"obstack.h\"\n #include \"flags.h\"\n #include \"rtl.h\"\n+#include \"output.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n void init_search ();\n extern struct obstack *current_obstack;\n+extern tree abort_fndecl;\n \n #include \"stack.h\"\n \n@@ -2626,6 +2628,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, t, vbase_offsets)\n       current_fndecl = FNADDR_FROM_VTABLE_ENTRY (current_fndecl);\n       current_fndecl = TREE_OPERAND (current_fndecl, 0);\n       if (current_fndecl\n+\t  && current_fndecl != abort_fndecl\n \t  && (vc=virtual_context (current_fndecl, t, vbase)) != vbase)\n \t{\n \t  /* This may in fact need a runtime fixup. */"}, {"sha": "196f1a4e3eafa8e34369239e63dbf66df7411c4d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -153,7 +153,7 @@ lvalue_p (ref)\n       return 1;\n \n     case CALL_EXPR:\n-      if (TREE_ADDRESSABLE (TREE_TYPE (ref)))\n+      if (IS_AGGR_TYPE (TREE_TYPE (ref)))\n \treturn 1;\n       break;\n \n@@ -217,9 +217,13 @@ build_cplus_new (type, init, with_cleanup_p)\n      tree init;\n      int with_cleanup_p;\n {\n-  tree slot = build (VAR_DECL, type);\n-  tree rval = build (NEW_EXPR, type,\n-\t\t     TREE_OPERAND (init, 0), TREE_OPERAND (init, 1), slot);\n+  tree slot;\n+  tree rval;\n+\n+  slot = build (VAR_DECL, type);\n+  layout_decl (slot, 0);\n+  rval = build (NEW_EXPR, type,\n+\t\tTREE_OPERAND (init, 0), TREE_OPERAND (init, 1), slot);\n   TREE_SIDE_EFFECTS (rval) = 1;\n   TREE_ADDRESSABLE (rval) = 1;\n   rval = build (TARGET_EXPR, type, slot, rval, 0);"}, {"sha": "71846dabd82ff77e6eee731e43b4d16c07f63211", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -37,6 +37,7 @@ extern void warning ();\n #include \"rtl.h\"\n #include \"cp-tree.h\"\n #include \"flags.h\"\n+#include \"output.h\"\n \n int mark_addressable ();\n static tree convert_for_assignment ();\n@@ -2665,8 +2666,7 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t    /* Convert `float' to `double'.  */\n \t    result = tree_cons (NULL_TREE, convert (double_type_node, val), result);\n \t  else if (TYPE_LANG_SPECIFIC (TREE_TYPE (val))\n-\t\t   && (! TYPE_HAS_INIT_REF (TREE_TYPE (val))\n-\t\t       || TYPE_HAS_COMPLEX_INIT_REF (TREE_TYPE (val))))\n+\t\t   && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (val)))\n \t    {\n \t      cp_warning (\"cannot pass objects of type `%T' through `...'\",\n \t\t\t  TREE_TYPE (val));\n@@ -5454,6 +5454,26 @@ init_noncopied_parts (lhs, list)\n   return parts;\n }\n \n+tree\n+expand_target_expr (t)\n+     tree t;\n+{\n+  tree xval = make_node (RTL_EXPR);\n+  rtx rtxval;\n+\n+  do_pending_stack_adjust ();\n+  start_sequence_for_rtl_expr (xval);\n+  emit_note (0, -1);\n+  rtxval = expand_expr (t, NULL, VOIDmode, 0);\n+  do_pending_stack_adjust ();\n+  TREE_SIDE_EFFECTS (xval) = 1;\n+  RTL_EXPR_SEQUENCE (xval) = get_insns ();\n+  end_sequence ();\n+  RTL_EXPR_RTL (xval) = rtxval;\n+  TREE_TYPE (xval) = TREE_TYPE (t);\n+  return xval;\n+}\n+\n /* Build an assignment expression of lvalue LHS from value RHS.\n    MODIFYCODE is the code for a binary operator that we use\n    to combine the old value of LHS with RHS to get the new value.\n@@ -5586,7 +5606,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t/* Do the default thing */;\n       else if (! TYPE_HAS_CONSTRUCTOR (lhstype))\n \tcp_error (\"`%T' has no constructors\", lhstype);\n-      else if (! TYPE_NEEDS_CONSTRUCTING (lhstype)\n+      else if (TYPE_HAS_TRIVIAL_INIT_REF (lhstype)\n \t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n \t/* Do the default thing */;\n       else\n@@ -5607,8 +5627,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t/* Do the default thing */;\n       else if (! TYPE_HAS_ASSIGNMENT (lhstype))\n \tcp_error (\"`%T' does not define operator=\", lhstype);\n-      else if (! TYPE_HAS_REAL_ASSIGNMENT (lhstype)\n-\t       && ! TYPE_HAS_COMPLEX_ASSIGN_REF (lhstype)\n+      else if (TYPE_HAS_TRIVIAL_ASSIGN_REF (lhstype)\n \t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n \t/* Do the default thing */;\n       else\n@@ -6002,28 +6021,12 @@ build_modify_expr (lhs, modifycode, rhs)\n \t  && TYPE_NEEDS_CONSTRUCTING (lhstype))\n \tnewrhs = build_cplus_new (lhstype, newrhs, 0);\n \n+      /* Can't initialize directly from a TARGET_EXPR, since that would\n+\t cause the lhs to be constructed twice.  So we force the\n+\t TARGET_EXPR to be expanded.  expand_expr should really do this\n+\t by itself.  */\n       if (TREE_CODE (newrhs) == TARGET_EXPR)\n-\t{\n-\t  /* Can't initialize directly from a TARGET_EXPR, since that would\n-\t     cause the lhs to be constructed twice.  So we force the\n-\t     TARGET_EXPR to be expanded.  expand_expr should really do this\n-\t     by itself.  */\n-\n-\t  tree xval = make_node (RTL_EXPR);\n-\t  rtx rtxval;\n-\n-\t  do_pending_stack_adjust ();\n-\t  start_sequence_for_rtl_expr (xval);\n-\t  emit_note (0, -1);\n-\t  rtxval = expand_expr (newrhs, NULL, VOIDmode, 0);\n-\t  do_pending_stack_adjust ();\n-\t  TREE_SIDE_EFFECTS (xval) = 1;\n-\t  RTL_EXPR_SEQUENCE (xval) = get_insns ();\n-\t  end_sequence ();\n-\t  RTL_EXPR_RTL (xval) = rtxval;\n-\t  TREE_TYPE (xval) = lhstype;\n-\t  newrhs = xval;\n-\t}\n+\tnewrhs = expand_target_expr (newrhs);\n     }\n \n   if (TREE_CODE (newrhs) == ERROR_MARK)\n@@ -6964,6 +6967,8 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t\trhs = build_cplus_new (type, TREE_OPERAND (rhs, 0), 0);\n \t      return rhs;\n \t    }\n+\t  else if (TYPE_HAS_TRIVIAL_INIT_REF (type))\n+\t    return rhs;\n \t}\n       if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (rhstype)\n \t  || (IS_AGGR_TYPE (rhstype) && UNIQUELY_DERIVED_FROM_P (type, rhstype)))\n@@ -7227,6 +7232,13 @@ c_expand_return (retval)\n      (3) If an X(X&) constructor is defined, the return\n      value must be returned via that.  */\n \n+  /* If we're returning in a register, we can't initialize the\n+     return value from a TARGET_EXPR.  */\n+  if (TREE_CODE (retval) == TARGET_EXPR\n+      && TYPE_MAIN_VARIANT (TREE_TYPE (retval)) == TYPE_MAIN_VARIANT (valtype)\n+      && ! current_function_returns_struct)\n+    retval = expand_target_expr (retval);\n+\n   if (retval == result\n       /* Watch out for constructors, which \"return\" aggregates\n \t via initialization, but which otherwise \"return\" a pointer.  */\n@@ -7243,12 +7255,8 @@ c_expand_return (retval)\n \t  use_temp = obey_regdecls;\n \t}\n     }\n-  else if (IS_AGGR_TYPE (valtype) && TYPE_NEEDS_CONSTRUCTING (valtype))\n+  else if (IS_AGGR_TYPE (valtype) && current_function_returns_struct)\n     {\n-      /* Throw away the cleanup that `build_functional_cast' gave us.  */\n-      if (TREE_CODE (retval) == WITH_CLEANUP_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (retval, 0)) == TARGET_EXPR)\n-\tretval = TREE_OPERAND (retval, 0);\n       expand_aggr_init (result, retval, 0, LOOKUP_ONLYCONVERTING);\n       expand_cleanups_to (NULL_TREE);\n       DECL_INITIAL (result) = NULL_TREE;"}, {"sha": "1c719aa00353ca5c53b9f3b3a470519939f37d4b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8abc66f6066b9f808fa9d86376f950b68c3236c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=e8abc66f6066b9f808fa9d86376f950b68c3236c", "patch": "@@ -540,11 +540,12 @@ store_init_value (decl, init)\n   /* Take care of C++ business up here.  */\n   type = TYPE_MAIN_VARIANT (type);\n \n-  /* implicitly tests if IS_AGGR_TYPE.  */\n-  if (TYPE_NEEDS_CONSTRUCTING (type) && TREE_CODE (init) != CONSTRUCTOR)\n-    my_friendly_abort (109);\n-  else if (IS_AGGR_TYPE (type))\n+  if (IS_AGGR_TYPE (type))\n     {\n+      if (! TYPE_HAS_TRIVIAL_INIT_REF (type)\n+\t  && TREE_CODE (init) != CONSTRUCTOR)\n+\tmy_friendly_abort (109);\n+\n       /* Although we are not allowed to declare variables of signature\n \t type, we complain about a possible constructor call in such a\n \t declaration as well.  */"}]}