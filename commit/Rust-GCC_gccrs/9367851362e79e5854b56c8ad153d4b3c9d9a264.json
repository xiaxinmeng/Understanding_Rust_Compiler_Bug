{"sha": "9367851362e79e5854b56c8ad153d4b3c9d9a264", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM2Nzg1MTM2MmU3OWU1ODU0YjU2YzhhZDE1M2Q0YjNjOWQ5YTI2NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-02-01T01:01:34Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-02-01T01:01:34Z"}, "message": "decl.c (build_enumerator): Do not issue duplicate error messages about invalid enumeration constants.\n\n\t* decl.c (build_enumerator): Do not issue duplicate error messages\n\tabout invalid enumeration constants.\n\t* parser.c (cp_parser_non_integral_constant_expression): Always\n\tset parser->non_integral_constant_expression_p.\n\t(cp_parser_primary_expression): Add cast_p parameter.  Issue\n\terrors about invalid uses of floating-point literals in\n\tcast-expressions.\n\t(cp_parser_postfix_expression): Add cast_p parameter.\n\t(cp_parser_open_square_expression): Pass it.\n\t(cp_parser_parenthesized_expression_list): Add cast_p parameter.\n\t(cp_parser_unary_expression): Likewise.\n\t(cp_parser_new_placement): Pass it.\n\t(cp_parser_direct_new_declarator): Likewise.\n\t(cp_parser_new_initializer): Likewise.\n\t(cp_parser_cast_expression): Add cast_p parameter.\n\t(cp_parser_binary_expression): Likewise.\n\t(cp_parser_question_colon_clause): Likewise.\n\t(cp_parser_assignment_expression): Likewise.\n\t(cp_parser_expression): Likewise.\n\t(cp_parser_constant_expression): If an integral constant\n\texpression is invalid, return error_mark_node.\n\t(cp_parser_expression_statement): Pass cast_p.\n\t(cp_parser_condition): Likewise.\n\t(cp_parser_iteration_statement): Likewise.\n\t(cp_parser_jump_statement): Likewise.\n\t(cp_parser_mem_initializer): Likewise.\n\t(cp_parser_template_argument): Likewise.\n\t(cp_parser_parameter_declaration): Likewise.\n\t(cp_parser_initializer): Likewise.\n\t(cp_parser_throw_expression): Likewise.\n\t(cp_parser_attribute_list): Likewise.\n\t(cp_parser_simple_cast_expression): Likewise.\n\t(cp_parser_functional_cast): Likewise.\n\t(cp_parser_late_parsing_default_args): Likewise.\n\t(cp_parser_sizeof_operand): Save/restore\n\tnon_integral_constant_expression_p.\n\n\t* include/std/std_limits.h (numeric_limits<float>::has_denorm):\n\tAdd required cast.\n\t(numeric_limits<double>::has_denorm): Likewise.\n\t(numeric_limits<long double>::has_denorm): Likewise.\n\n\t* g++.dg/other/warning1.C: Adjust error messags.\n\t* g++.dg/parse/constant5.C: New test.\n\nFrom-SVN: r94512", "tree": {"sha": "cfa0b1e39e621b716ae38190c9b764f2198c23ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfa0b1e39e621b716ae38190c9b764f2198c23ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9367851362e79e5854b56c8ad153d4b3c9d9a264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9367851362e79e5854b56c8ad153d4b3c9d9a264", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9367851362e79e5854b56c8ad153d4b3c9d9a264", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9367851362e79e5854b56c8ad153d4b3c9d9a264/comments", "author": null, "committer": null, "parents": [{"sha": "782c0a3ea9b082471e96d881b8c832405785ba2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/782c0a3ea9b082471e96d881b8c832405785ba2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/782c0a3ea9b082471e96d881b8c832405785ba2c"}], "stats": {"total": 290, "additions": 223, "deletions": 67}, "files": [{"sha": "92cebfa46a994a88ddcf6eac3bc2b38ab0ea1fca", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9367851362e79e5854b56c8ad153d4b3c9d9a264", "patch": "@@ -1,3 +1,42 @@\n+2005-01-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (build_enumerator): Do not issue duplicate error messages\n+\tabout invalid enumeration constants.\n+\t* parser.c (cp_parser_non_integral_constant_expression): Always\n+\tset parser->non_integral_constant_expression_p.\n+\t(cp_parser_primary_expression): Add cast_p parameter.  Issue\n+\terrors about invalid uses of floating-point literals in\n+\tcast-expressions.\n+\t(cp_parser_postfix_expression): Add cast_p parameter.\n+\t(cp_parser_open_square_expression): Pass it.\n+\t(cp_parser_parenthesized_expression_list): Add cast_p parameter.\n+\t(cp_parser_unary_expression): Likewise.\n+\t(cp_parser_new_placement): Pass it.\n+\t(cp_parser_direct_new_declarator): Likewise.\n+\t(cp_parser_new_initializer): Likewise.\n+\t(cp_parser_cast_expression): Add cast_p parameter.\n+\t(cp_parser_binary_expression): Likewise.\n+\t(cp_parser_question_colon_clause): Likewise.\n+\t(cp_parser_assignment_expression): Likewise.\n+\t(cp_parser_expression): Likewise.\n+\t(cp_parser_constant_expression): If an integral constant\n+\texpression is invalid, return error_mark_node.\n+\t(cp_parser_expression_statement): Pass cast_p.\n+\t(cp_parser_condition): Likewise.\n+\t(cp_parser_iteration_statement): Likewise.\n+\t(cp_parser_jump_statement): Likewise.\n+\t(cp_parser_mem_initializer): Likewise.\n+\t(cp_parser_template_argument): Likewise.\n+\t(cp_parser_parameter_declaration): Likewise.\n+\t(cp_parser_initializer): Likewise.\n+\t(cp_parser_throw_expression): Likewise.\n+\t(cp_parser_attribute_list): Likewise.\n+\t(cp_parser_simple_cast_expression): Likewise.\n+\t(cp_parser_functional_cast): Likewise.\n+\t(cp_parser_late_parsing_default_args): Likewise.\n+\t(cp_parser_sizeof_operand): Save/restore\n+\tnon_integral_constant_expression_p.\n+\n 2005-01-31  Mike Stump  <mrs@apple.com>\n \n \t* parser.c (cp_lexer_new_main): Get the first token, first, before"}, {"sha": "9be5adf4af3cfadc51845131fb412e979620ab66", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9367851362e79e5854b56c8ad153d4b3c9d9a264", "patch": "@@ -9682,6 +9682,11 @@ build_enumerator (tree name, tree value, tree enumtype)\n   tree context;\n   tree type;\n \n+  /* If the VALUE was erroneous, pretend it wasn't there; that will\n+     result in the enum being assigned the next value in sequence.  */\n+  if (value == error_mark_node)\n+    value = NULL_TREE;\n+\n   /* Remove no-op casts from the value.  */\n   if (value)\n     STRIP_TYPE_NOPS (value);"}, {"sha": "e5ea0699aae8a57bc16cd9940fedd30459c019b2", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 148, "deletions": 62, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9367851362e79e5854b56c8ad153d4b3c9d9a264", "patch": "@@ -1357,7 +1357,7 @@ static bool cp_parser_translation_unit\n /* Expressions [gram.expr]  */\n \n static tree cp_parser_primary_expression\n-  (cp_parser *, cp_id_kind *, tree *);\n+  (cp_parser *, bool, cp_id_kind *, tree *);\n static tree cp_parser_id_expression\n   (cp_parser *, bool, bool, bool *, bool);\n static tree cp_parser_unqualified_id\n@@ -1369,17 +1369,17 @@ static tree cp_parser_nested_name_specifier\n static tree cp_parser_class_or_namespace_name\n   (cp_parser *, bool, bool, bool, bool, bool);\n static tree cp_parser_postfix_expression\n-  (cp_parser *, bool);\n+  (cp_parser *, bool, bool);\n static tree cp_parser_postfix_open_square_expression\n   (cp_parser *, tree, bool);\n static tree cp_parser_postfix_dot_deref_expression\n   (cp_parser *, enum cpp_ttype, tree, bool, cp_id_kind *);\n static tree cp_parser_parenthesized_expression_list\n-  (cp_parser *, bool, bool *);\n+  (cp_parser *, bool, bool, bool *);\n static void cp_parser_pseudo_destructor_name\n   (cp_parser *, tree *, tree *);\n static tree cp_parser_unary_expression\n-  (cp_parser *, bool);\n+  (cp_parser *, bool, bool);\n static enum tree_code cp_parser_unary_operator\n   (cp_token *);\n static tree cp_parser_new_expression\n@@ -1397,17 +1397,17 @@ static tree cp_parser_new_initializer\n static tree cp_parser_delete_expression\n   (cp_parser *);\n static tree cp_parser_cast_expression\n-  (cp_parser *, bool);\n+  (cp_parser *, bool, bool);\n static tree cp_parser_binary_expression\n-  (cp_parser *);\n+  (cp_parser *, bool);\n static tree cp_parser_question_colon_clause\n   (cp_parser *, tree);\n static tree cp_parser_assignment_expression\n-  (cp_parser *);\n+  (cp_parser *, bool);\n static enum tree_code cp_parser_assignment_operator_opt\n   (cp_parser *);\n static tree cp_parser_expression\n-  (cp_parser *);\n+  (cp_parser *, bool);\n static tree cp_parser_constant_expression\n   (cp_parser *, bool, bool *);\n static tree cp_parser_builtin_offsetof\n@@ -1945,20 +1945,21 @@ cp_parser_check_for_invalid_template_id (cp_parser* parser,\n \n /* If parsing an integral constant-expression, issue an error message\n    about the fact that THING appeared and return true.  Otherwise,\n-   return false, marking the current expression as non-constant.  */\n+   return false.  In either case, set\n+   PARSER->NON_INTEGRAL_CONSTANT_EXPRESSION_P.  */ \n \n static bool\n cp_parser_non_integral_constant_expression (cp_parser  *parser,\n \t\t\t\t\t    const char *thing)\n {\n+  parser->non_integral_constant_expression_p = true;\n   if (parser->integral_constant_expression_p)\n     {\n       if (!parser->allow_non_integral_constant_expression_p)\n \t{\n \t  error (\"%s cannot appear in a constant-expression\", thing);\n \t  return true;\n \t}\n-      parser->non_integral_constant_expression_p = true;\n     }\n   return false;\n }\n@@ -2639,6 +2640,8 @@ cp_parser_translation_unit (cp_parser* parser)\n    literal:\n      __null\n \n+   CAST_P is true if this primary expression is the target of a cast.\n+\n    Returns a representation of the expression.\n \n    *IDK indicates what kind of id-expression (if any) was present.\n@@ -2650,6 +2653,7 @@ cp_parser_translation_unit (cp_parser* parser)\n \n static tree\n cp_parser_primary_expression (cp_parser *parser,\n+\t\t\t      bool cast_p,\n \t\t\t      cp_id_kind *idk,\n \t\t\t      tree *qualifying_class)\n {\n@@ -2674,6 +2678,42 @@ cp_parser_primary_expression (cp_parser *parser,\n     case CPP_WCHAR:\n     case CPP_NUMBER:\n       token = cp_lexer_consume_token (parser->lexer);\n+      /* Floating-point literals are only allowed in an integral\n+\t constant expression if they are cast to an integral or\n+\t enumeration type.  */\n+      if (TREE_CODE (token->value) == REAL_CST\n+\t  && parser->integral_constant_expression_p)\n+\t{\n+\t  /* CAST_P will be set even in invalid code like \"int(2.7 +\n+\t     ...)\".   Therefore, we have to check that the next token\n+\t     is sure to end the cast.  */\n+\t  if (cast_p)\n+\t    {\n+\t      cp_token *next_token;\n+\n+\t      next_token = cp_lexer_peek_token (parser->lexer);\n+\t      if (/* The comma at the end of an\n+\t\t     enumerator-definition.  */\n+\t\t  next_token->type != CPP_COMMA\n+\t\t  /* The curly brace at the end of an enum-specifier.  */\n+\t\t  && next_token->type != CPP_CLOSE_BRACE\n+\t\t  /* The end of a statement.  */\n+\t\t  && next_token->type != CPP_SEMICOLON\n+\t\t  /* The end of the cast-expression.  */\n+\t\t  && next_token->type != CPP_CLOSE_PAREN\n+\t\t  /* The end of an array bound.  */\n+\t\t  && next_token->type != CPP_CLOSE_SQUARE)\n+\t\tcast_p = false;\n+\t    }\n+\n+\t  /* If we are within a cast, then the constraint that the\n+\t     cast is to an integral or enumeration type will be\n+\t     checked at that point.  If we are not within a cast, then\n+\t     this code is invalid.  */\n+\t  if (!cast_p)\n+\t    cp_parser_non_integral_constant_expression \n+\t      (parser, \"floating-point literal\");\n+\t}\n       return token->value;\n \n     case CPP_STRING:\n@@ -2724,7 +2764,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \telse\n \t  {\n \t    /* Parse the parenthesized expression.  */\n-\t    expr = cp_parser_expression (parser);\n+\t    expr = cp_parser_expression (parser, cast_p);\n \t    /* Let the front end know that this expression was\n \t       enclosed in parentheses. This matters in case, for\n \t       example, the expression is of the form `A::B', since\n@@ -2803,7 +2843,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    /* Look for the opening `('.  */\n \t    cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n \t    /* Now, parse the assignment-expression.  */\n-\t    expression = cp_parser_assignment_expression (parser);\n+\t    expression = cp_parser_assignment_expression (parser,\n+\t\t\t\t\t\t\t  /*cast_p=*/false);\n \t    /* Look for the `,'.  */\n \t    cp_parser_require (parser, CPP_COMMA, \"`,'\");\n \t    /* Parse the type-id.  */\n@@ -3666,12 +3707,13 @@ cp_parser_class_or_namespace_name (cp_parser *parser,\n    but they are essentially the same concept.)\n \n    If ADDRESS_P is true, the postfix expression is the operand of the\n-   `&' operator.\n+   `&' operator.  CAST_P is true if this expression is the target of a\n+   cast. \n \n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n+cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n {\n   cp_token *token;\n   enum rid keyword;\n@@ -3718,7 +3760,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \n \t/* And the expression which is being cast.  */\n \tcp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n-\texpression = cp_parser_expression (parser);\n+\texpression = cp_parser_expression (parser, /*cast_p=*/true);\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \n \t/* Only type conversions to integral or enumeration types\n@@ -3791,7 +3833,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    tree expression;\n \n \t    /* Look for an expression.  */\n-\t    expression = cp_parser_expression (parser);\n+\t    expression = cp_parser_expression (parser, /*cast_p=*/false);\n \t    /* Compute its typeid.  */\n \t    postfix_expression = build_typeid (expression);\n \t    /* Look for the `)' token.  */\n@@ -3923,6 +3965,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \n \t/* It must be a primary-expression.  */\n \tpostfix_expression = cp_parser_primary_expression (parser,\n+\t\t\t\t\t\t\t   cast_p,\n \t\t\t\t\t\t\t   &idk,\n \t\t\t\t\t\t\t   &qualifying_class);\n       }\n@@ -3981,7 +4024,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t  {\n \t    bool koenig_p;\n \t    tree args = (cp_parser_parenthesized_expression_list\n-\t\t\t (parser, false, /*non_constant_p=*/NULL));\n+\t\t\t (parser, false, \n+\t\t\t  /*cast_p=*/false,\n+\t\t\t  /*non_constant_p=*/NULL));\n \n \t    if (args == error_mark_node)\n \t      {\n@@ -4174,7 +4219,7 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n   if (for_offsetof)\n     index = cp_parser_constant_expression (parser, false, NULL);\n   else\n-    index = cp_parser_expression (parser);\n+    index = cp_parser_expression (parser, /*cast_p=*/false);\n \n   /* Look for the closing `]'.  */\n   cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n@@ -4354,6 +4399,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n      identifier\n      identifier, expression-list\n \n+   CAST_P is true if this expression is the target of a cast.\n+\n    Returns a TREE_LIST.  The TREE_VALUE of each node is a\n    representation of an assignment-expression.  Note that a TREE_LIST\n    is returned even if there is only a single expression in the list.\n@@ -4367,6 +4414,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n static tree\n cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t\t\t\t bool is_attribute_list,\n+\t\t\t\t\t bool cast_p,\n \t\t\t\t\t bool *non_constant_p)\n {\n   tree expression_list = NULL_TREE;\n@@ -4411,7 +4459,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t  *non_constant_p = true;\n \t      }\n \t    else\n-\t      expr = cp_parser_assignment_expression (parser);\n+\t      expr = cp_parser_assignment_expression (parser, cast_p);\n \n \t    if (fold_expr_p)\n \t      expr = fold_non_dependent_expr (expr);\n@@ -4569,12 +4617,13 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n      && identifier\n \n    ADDRESS_P is true iff the unary-expression is appearing as the\n-   operand of the `&' operator.\n+   operand of the `&' operator.   CAST_P is true if this expression is\n+   the target of a cast.\n \n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_unary_expression (cp_parser *parser, bool address_p)\n+cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p)\n {\n   cp_token *token;\n   enum tree_code unary_operator;\n@@ -4702,7 +4751,9 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n       token = cp_lexer_consume_token (parser->lexer);\n       /* Parse the cast-expression.  */\n       cast_expression\n-\t= cp_parser_cast_expression (parser, unary_operator == ADDR_EXPR);\n+\t= cp_parser_cast_expression (parser, \n+\t\t\t\t     unary_operator == ADDR_EXPR,\n+\t\t\t\t     /*cast_p=*/false);\n       /* Now, build an appropriate representation.  */\n       switch (unary_operator)\n \t{\n@@ -4741,7 +4792,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n       return expression;\n     }\n \n-  return cp_parser_postfix_expression (parser, address_p);\n+  return cp_parser_postfix_expression (parser, address_p, cast_p);\n }\n \n /* Returns ERROR_MARK if TOKEN is not a unary-operator.  If TOKEN is a\n@@ -4862,7 +4913,8 @@ cp_parser_new_placement (cp_parser* parser)\n \n   /* Parse the expression-list.  */\n   expression_list = (cp_parser_parenthesized_expression_list\n-\t\t     (parser, false, /*non_constant_p=*/NULL));\n+\t\t     (parser, false, /*cast_p=*/false,\n+\t\t      /*non_constant_p=*/NULL));\n \n   return expression_list;\n }\n@@ -5009,7 +5061,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n       /* The first expression is not required to be constant.  */\n       if (!declarator)\n \t{\n-\t  expression = cp_parser_expression (parser);\n+\t  expression = cp_parser_expression (parser, /*cast_p=*/false);\n \t  /* The standard requires that the expression have integral\n \t     type.  DR 74 adds enumeration types.  We believe that the\n \t     real intent is that these expressions be handled like the\n@@ -5065,7 +5117,8 @@ cp_parser_new_initializer (cp_parser* parser)\n   tree expression_list;\n \n   expression_list = (cp_parser_parenthesized_expression_list\n-\t\t     (parser, false, /*non_constant_p=*/NULL));\n+\t\t     (parser, false, /*cast_p=*/false,\n+\t\t      /*non_constant_p=*/NULL));\n   if (!expression_list)\n     expression_list = void_zero_node;\n \n@@ -5124,10 +5177,14 @@ cp_parser_delete_expression (cp_parser* parser)\n      unary-expression\n      ( type-id ) cast-expression\n \n+   ADDRESS_P is true iff the unary-expression is appearing as the\n+   operand of the `&' operator.   CAST_P is true if this expression is\n+   the target of a cast.\n+\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_cast_expression (cp_parser *parser, bool address_p)\n+cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n {\n   /* If it's a `(', then we might be looking at a cast.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n@@ -5197,7 +5254,9 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n          ctor of T, but looks like a cast to function returning T\n          without a dependent expression.  */\n       if (!cp_parser_error_occurred (parser))\n-\texpr = cp_parser_simple_cast_expression (parser);\n+\texpr = cp_parser_cast_expression (parser, \n+\t\t\t\t\t  /*address_p=*/false,\n+\t\t\t\t\t  /*cast_p=*/true);\n \n       if (cp_parser_parse_definitely (parser))\n \t{\n@@ -5227,7 +5286,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n \n   /* If we get here, then it's not a cast, so it must be a\n      unary-expression.  */\n-  return cp_parser_unary_expression (parser, address_p);\n+  return cp_parser_unary_expression (parser, address_p, cast_p);\n }\n \n /* Parse a binary expression of the general form:\n@@ -5297,6 +5356,8 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n      simple-cast-expression\n      binary-expression <token> binary-expression\n \n+   CAST_P is true if this expression is the target of a cast.\n+\n    The binops_by_token map is used to get the tree codes for each <token> type.\n    binary-expressions are associated according to a precedence table.  */\n \n@@ -5306,7 +5367,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n    : binops_by_token[token->type].prec)\n \n static tree\n-cp_parser_binary_expression (cp_parser* parser)\n+cp_parser_binary_expression (cp_parser* parser, bool cast_p)\n {\n   cp_parser_expression_stack stack;\n   cp_parser_expression_stack_entry *sp = &stack[0];\n@@ -5317,7 +5378,7 @@ cp_parser_binary_expression (cp_parser* parser)\n   bool overloaded_p;\n \n   /* Parse the first expression.  */\n-  lhs = cp_parser_simple_cast_expression (parser);\n+  lhs = cp_parser_cast_expression (parser, /*address_p=*/false, cast_p);\n \n   for (;;)\n     {\n@@ -5431,12 +5492,12 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n     expr = NULL_TREE;\n   else\n     /* Parse the expression.  */\n-    expr = cp_parser_expression (parser);\n+    expr = cp_parser_expression (parser, /*cast_p=*/false);\n \n   /* The next token should be a `:'.  */\n   cp_parser_require (parser, CPP_COLON, \"`:'\");\n   /* Parse the assignment-expression.  */\n-  assignment_expr = cp_parser_assignment_expression (parser);\n+  assignment_expr = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n \n   /* Build the conditional-expression.  */\n   return build_x_conditional_expr (logical_or_expr,\n@@ -5451,10 +5512,12 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n      logical-or-expression assignment-operator assignment_expression\n      throw-expression\n \n+   CAST_P is true if this expression is the target of a cast.\n+\n    Returns a representation for the expression.  */\n \n static tree\n-cp_parser_assignment_expression (cp_parser* parser)\n+cp_parser_assignment_expression (cp_parser* parser, bool cast_p)\n {\n   tree expr;\n \n@@ -5467,7 +5530,7 @@ cp_parser_assignment_expression (cp_parser* parser)\n   else\n     {\n       /* Parse the binary expressions (logical-or-expression).  */\n-      expr = cp_parser_binary_expression (parser);\n+      expr = cp_parser_binary_expression (parser, cast_p);\n       /* If the next token is a `?' then we're actually looking at a\n \t conditional-expression.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_QUERY))\n@@ -5485,7 +5548,7 @@ cp_parser_assignment_expression (cp_parser* parser)\n \t      tree rhs;\n \n \t      /* Parse the right-hand side of the assignment.  */\n-\t      rhs = cp_parser_assignment_expression (parser);\n+\t      rhs = cp_parser_assignment_expression (parser, cast_p);\n \t      /* An assignment may not appear in a\n \t\t constant-expression.  */\n \t      if (cp_parser_non_integral_constant_expression (parser,\n@@ -5600,10 +5663,12 @@ cp_parser_assignment_operator_opt (cp_parser* parser)\n      assignment-expression\n      expression , assignment-expression\n \n+   CAST_P is true if this expression is the target of a cast.\n+\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_expression (cp_parser* parser)\n+cp_parser_expression (cp_parser* parser, bool cast_p)\n {\n   tree expression = NULL_TREE;\n \n@@ -5613,7 +5678,7 @@ cp_parser_expression (cp_parser* parser)\n \n       /* Parse the next assignment-expression.  */\n       assignment_expression\n-\t= cp_parser_assignment_expression (parser);\n+\t= cp_parser_assignment_expression (parser, cast_p);\n       /* If this is the first assignment-expression, we can just\n \t save it away.  */\n       if (!expression)\n@@ -5691,14 +5756,18 @@ cp_parser_constant_expression (cp_parser* parser,\n      For example, cp_parser_initializer_clauses uses this function to\n      determine whether a particular assignment-expression is in fact\n      constant.  */\n-  expression = cp_parser_assignment_expression (parser);\n+  expression = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n   /* Restore the old settings.  */\n-  parser->integral_constant_expression_p = saved_integral_constant_expression_p;\n+  parser->integral_constant_expression_p \n+    = saved_integral_constant_expression_p;\n   parser->allow_non_integral_constant_expression_p\n     = saved_allow_non_integral_constant_expression_p;\n   if (allow_non_constant_p)\n     *non_constant_p = parser->non_integral_constant_expression_p;\n-  parser->non_integral_constant_expression_p = saved_non_integral_constant_expression_p;\n+  else if (parser->non_integral_constant_expression_p)\n+    expression = error_mark_node;\n+  parser->non_integral_constant_expression_p \n+    = saved_non_integral_constant_expression_p;\n \n   return expression;\n }\n@@ -6009,18 +6078,16 @@ cp_parser_expression_statement (cp_parser* parser, tree in_statement_expr)\n   /* If the next token is a ';', then there is no expression\n      statement.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    statement = cp_parser_expression (parser);\n+    statement = cp_parser_expression (parser, /*cast_p=*/false);\n \n   /* Consume the final `;'.  */\n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n \n   if (in_statement_expr\n       && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n-    {\n-      /* This is the final expression statement of a statement\n-\t expression.  */\n-      statement = finish_stmt_expr_expr (statement, in_statement_expr);\n-    }\n+    /* This is the final expression statement of a statement\n+       expression.  */\n+    statement = finish_stmt_expr_expr (statement, in_statement_expr);\n   else if (statement)\n     statement = finish_expr_stmt (statement);\n   else\n@@ -6247,7 +6314,8 @@ cp_parser_condition (cp_parser* parser)\n \t\t\t     attributes, /*prefix_attributes=*/NULL_TREE,\n \t\t\t     &pushed_scope);\n \t  /* Parse the assignment-expression.  */\n-\t  initializer = cp_parser_assignment_expression (parser);\n+\t  initializer = cp_parser_assignment_expression (parser,\n+\t\t\t\t\t\t\t /*cast_p=*/false);\n \n \t  /* Process the initializer.  */\n \t  cp_finish_decl (decl,\n@@ -6267,7 +6335,7 @@ cp_parser_condition (cp_parser* parser)\n     cp_parser_abort_tentative_parse (parser);\n \n   /* Otherwise, we are looking at an expression.  */\n-  return cp_parser_expression (parser);\n+  return cp_parser_expression (parser, /*cast_p=*/false);\n }\n \n /* Parse an iteration-statement.\n@@ -6340,7 +6408,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Look for the `('.  */\n \tcp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n \t/* Parse the expression.  */\n-\texpression = cp_parser_expression (parser);\n+\texpression = cp_parser_expression (parser, /*cast_p=*/false);\n \t/* We're done with the do-statement.  */\n \tfinish_do_stmt (expression, statement);\n \t/* Look for the `)'.  */\n@@ -6372,7 +6440,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n \n \t/* If there's an expression, process it.  */\n \tif (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n-\t  expression = cp_parser_expression (parser);\n+\t  expression = cp_parser_expression (parser, /*cast_p=*/false);\n \tfinish_for_expr (expression, statement);\n \t/* Look for the `)'.  */\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n@@ -6489,7 +6557,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t/* If the next token is a `;', then there is no\n \t   expression.  */\n \tif (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-\t  expr = cp_parser_expression (parser);\n+\t  expr = cp_parser_expression (parser, /*cast_p=*/false);\n \telse\n \t  expr = NULL_TREE;\n \t/* Build the return-statement.  */\n@@ -6509,7 +6577,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t  /* Consume the '*' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Parse the dependent expression.  */\n-\t  finish_goto_stmt (cp_parser_expression (parser));\n+\t  finish_goto_stmt (cp_parser_expression (parser, /*cast_p=*/false));\n \t}\n       else\n \tfinish_goto_stmt (cp_parser_identifier (parser));\n@@ -7624,6 +7692,7 @@ cp_parser_mem_initializer (cp_parser* parser)\n \n   expression_list\n     = cp_parser_parenthesized_expression_list (parser, false,\n+\t\t\t\t\t       /*cast_p=*/false,\n \t\t\t\t\t       /*non_constant_p=*/NULL);\n   if (!expression_list)\n     expression_list = void_type_node;\n@@ -8828,6 +8897,7 @@ cp_parser_template_argument (cp_parser* parser)\n     {\n       cp_parser_parse_tentatively (parser);\n       argument = cp_parser_primary_expression (parser,\n+\t\t\t\t\t       /*cast_p=*/false,\n \t\t\t\t\t       &idk,\n \t\t\t\t\t       &qualifying_class);\n       if (TREE_CODE (argument) != TEMPLATE_PARM_INDEX\n@@ -8852,6 +8922,7 @@ cp_parser_template_argument (cp_parser* parser)\n     {\n       cp_parser_parse_tentatively (parser);\n       argument = cp_parser_primary_expression (parser,\n+\t\t\t\t\t       /*cast_p=*/false,\n \t\t\t\t\t       &idk,\n \t\t\t\t\t       &qualifying_class);\n       if (cp_parser_error_occurred (parser)\n@@ -11875,7 +11946,8 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t    = parser->local_variables_forbidden_p;\n \t  parser->local_variables_forbidden_p = true;\n \t  /* Parse the assignment-expression.  */\n-\t  default_argument = cp_parser_assignment_expression (parser);\n+\t  default_argument \n+\t    = cp_parser_assignment_expression (parser, /*cast_p=*/false);\n \t  /* Restore saved state.  */\n \t  parser->greater_than_is_operator_p\n \t    = saved_greater_than_is_operator_p;\n@@ -11973,6 +12045,7 @@ cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init,\n     }\n   else if (token->type == CPP_OPEN_PAREN)\n     init = cp_parser_parenthesized_expression_list (parser, false,\n+\t\t\t\t\t\t    /*cast_p=*/false,\n \t\t\t\t\t\t    non_constant_p);\n   else\n     {\n@@ -13748,7 +13821,8 @@ cp_parser_throw_expression (cp_parser* parser)\n       || token->type == CPP_COLON)\n     expression = NULL_TREE;\n   else\n-    expression = cp_parser_assignment_expression (parser);\n+    expression = cp_parser_assignment_expression (parser,\n+\t\t\t\t\t\t  /*cast_p=*/false);\n \n   return build_throw (expression);\n }\n@@ -13838,7 +13912,7 @@ cp_parser_asm_operand_list (cp_parser* parser)\n       /* Look for the `('.  */\n       cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n       /* Parse the expression.  */\n-      expression = cp_parser_expression (parser);\n+      expression = cp_parser_expression (parser, /*cast_p=*/false);\n       /* Look for the `)'.  */\n       cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \n@@ -13994,7 +14068,8 @@ cp_parser_attribute_list (cp_parser* parser)\n \t  tree arguments;\n \n \t  arguments = (cp_parser_parenthesized_expression_list\n-\t\t       (parser, true, /*non_constant_p=*/NULL));\n+\t\t       (parser, true, /*cast_p=*/false, \n+\t\t\t/*non_constant_p=*/NULL));\n \t  /* Save the identifier and arguments away.  */\n \t  TREE_VALUE (attribute) = arguments;\n \t}\n@@ -14971,7 +15046,8 @@ cp_parser_single_declaration (cp_parser* parser,\n static tree\n cp_parser_simple_cast_expression (cp_parser *parser)\n {\n-  return cp_parser_cast_expression (parser, /*address_p=*/false);\n+  return cp_parser_cast_expression (parser, /*address_p=*/false,\n+\t\t\t\t    /*cast_p=*/false);\n }\n \n /* Parse a functional cast to TYPE.  Returns an expression\n@@ -14985,6 +15061,7 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n \n   expression_list\n     = cp_parser_parenthesized_expression_list (parser, false,\n+\t\t\t\t\t       /*cast_p=*/true,\n \t\t\t\t\t       /*non_constant_p=*/NULL);\n \n   cast = build_functional_cast (type, expression_list);\n@@ -15268,7 +15345,8 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n       cp_parser_push_lexer_for_tokens (parser, tokens);\n \n       /* Parse the assignment-expression.  */\n-      TREE_PURPOSE (parm) = cp_parser_assignment_expression (parser);\n+      TREE_PURPOSE (parm) = cp_parser_assignment_expression (parser,\n+\t\t\t\t\t\t\t     /*cast_p=*/false);\n \n       /* If the token stream has not been completely used up, then\n \t there was extra junk after the end of the default\n@@ -15300,6 +15378,7 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n   tree expr = NULL_TREE;\n   const char *saved_message;\n   bool saved_integral_constant_expression_p;\n+  bool saved_non_integral_constant_expression_p;\n \n   /* Initialize FORMAT the first time we get here.  */\n   if (!format)\n@@ -15318,7 +15397,10 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n \n   /* The restrictions on constant-expressions do not apply inside\n      sizeof expressions.  */\n-  saved_integral_constant_expression_p = parser->integral_constant_expression_p;\n+  saved_integral_constant_expression_p \n+    = parser->integral_constant_expression_p;\n+  saved_non_integral_constant_expression_p\n+    = parser->non_integral_constant_expression_p;\n   parser->integral_constant_expression_p = false;\n \n   /* Do not actually evaluate the expression.  */\n@@ -15363,15 +15445,19 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n   /* If the type-id production did not work out, then we must be\n      looking at the unary-expression production.  */\n   if (!expr)\n-    expr = cp_parser_unary_expression (parser, /*address_p=*/false);\n+    expr = cp_parser_unary_expression (parser, /*address_p=*/false,\n+\t\t\t\t       /*cast_p=*/false);\n   /* Go back to evaluating expressions.  */\n   --skip_evaluation;\n \n   /* Free the message we created.  */\n   free ((char *) parser->type_definition_forbidden_message);\n   /* And restore the old one.  */\n   parser->type_definition_forbidden_message = saved_message;\n-  parser->integral_constant_expression_p = saved_integral_constant_expression_p;\n+  parser->integral_constant_expression_p \n+    = saved_integral_constant_expression_p;\n+  parser->non_integral_constant_expression_p\n+    = saved_non_integral_constant_expression_p;\n \n   return expr;\n }"}, {"sha": "4c7011ec9901bbefc882c7b2a234b93234f8c8d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9367851362e79e5854b56c8ad153d4b3c9d9a264", "patch": "@@ -1,3 +1,8 @@\n+2005-01-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/other/warning1.C: Adjust error messags.\n+\t* g++.dg/parse/constant5.C: New test.\n+\n 2005-01-31  Steven Bosscher  <stevenb@suse.de>\n \n \tPR c/19333"}, {"sha": "a5cce6ce04110f06f722bb01e44f46ead655605f", "filename": "gcc/testsuite/g++.dg/other/warning1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fwarning1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fwarning1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fwarning1.C?ref=9367851362e79e5854b56c8ad153d4b3c9d9a264", "patch": "@@ -7,8 +7,8 @@ extern \"C\" int printf(const char *, ...);\n \n struct S\n {\n-  static const float inf = 1.0f / 0.0f; // { dg-warning \"1.0|initialization\" }\n-  static const float nan = 0.0f / 0.0f; // { dg-warning \"0.0|initialization\" }\n+  static const float inf = 1.0f / 0.0f; // { dg-warning \"1.0|float|initialization\" }\n+  static const float nan = 0.0f / 0.0f; // { dg-warning \"0.0|float|initialization\" }\n };\n \n int main()"}, {"sha": "db11afb51b255f4107be3548a82742f151d043c2", "filename": "gcc/testsuite/g++.dg/parse/constant5.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9367851362e79e5854b56c8ad153d4b3c9d9a264/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fconstant5.C?ref=9367851362e79e5854b56c8ad153d4b3c9d9a264", "patch": "@@ -0,0 +1,14 @@\n+enum E { \n+  a = 24.2, // { dg-error \"constant\" }\n+  b = (int)3.7, \n+  c = int(4.2),\n+  d = (int)(4.2 + 3.7), // { dg-error \"constant\" }\n+  e = int(4.2 - 3.7), // { dg-error \"constant\" }\n+  f = (int)17.25\n+};\n+\n+struct S {\n+  static const int i = (int)4.2;\n+  int j[(int)4.2];\n+  static const int k = static_cast<short>(3.7);\n+};"}, {"sha": "f875fa4ab3af5491fa202d72439a650700809b7c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9367851362e79e5854b56c8ad153d4b3c9d9a264/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9367851362e79e5854b56c8ad153d4b3c9d9a264/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9367851362e79e5854b56c8ad153d4b3c9d9a264", "patch": "@@ -1,3 +1,10 @@\n+2005-01-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* include/std/std_limits.h (numeric_limits<float>::has_denorm):\n+\tAdd required cast.\n+\t(numeric_limits<double>::has_denorm): Likewise.\n+\t(numeric_limits<long double>::has_denorm): Likewise.\n+\n 2005-01-31  Paolo Carlini  <pcarlini@suse.de>\n \t    Gabriel Dos Reis  <gdr@integrable-solutions.net>\n "}, {"sha": "6927de1ccb4e51612769bef81a7483eef1d1bd4b", "filename": "libstdc++-v3/include/std/std_limits.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9367851362e79e5854b56c8ad153d4b3c9d9a264/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_limits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9367851362e79e5854b56c8ad153d4b3c9d9a264/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_limits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_limits.h?ref=9367851362e79e5854b56c8ad153d4b3c9d9a264", "patch": "@@ -1007,7 +1007,7 @@ namespace std\n       static const bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;\n       static const bool has_signaling_NaN = has_quiet_NaN;\n       static const float_denorm_style has_denorm\n-\t= __FLT_DENORM_MIN__ ? denorm_present : denorm_absent;\n+\t= bool(__FLT_DENORM_MIN__) ? denorm_present : denorm_absent;\n       static const bool has_denorm_loss = __glibcxx_float_has_denorm_loss;\n \n       static float infinity() throw()\n@@ -1064,7 +1064,7 @@ namespace std\n       static const bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;\n       static const bool has_signaling_NaN = has_quiet_NaN;\n       static const float_denorm_style has_denorm\n-\t= __DBL_DENORM_MIN__ ? denorm_present : denorm_absent;\n+\t= bool(__DBL_DENORM_MIN__) ? denorm_present : denorm_absent;\n       static const bool has_denorm_loss = __glibcxx_double_has_denorm_loss;\n \n       static double infinity() throw()\n@@ -1121,7 +1121,7 @@ namespace std\n       static const bool has_quiet_NaN = __LDBL_HAS_QUIET_NAN__;\n       static const bool has_signaling_NaN = has_quiet_NaN;\n       static const float_denorm_style has_denorm\n-\t= __LDBL_DENORM_MIN__ ? denorm_present : denorm_absent;\n+\t= bool(__LDBL_DENORM_MIN__) ? denorm_present : denorm_absent;\n       static const bool has_denorm_loss\n \t= __glibcxx_long_double_has_denorm_loss;\n "}]}