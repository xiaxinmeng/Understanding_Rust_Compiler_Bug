{"sha": "1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWViODc1OWIxYmMwZmQyYTc0ZGRiZDgzZGIxZjAxZGYxYTM1ZGY2OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-01-24T20:10:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-01-24T20:10:04Z"}, "message": "rtl.def: Add unordered fp comparisions.\n\n        * rtl.def: Add unordered fp comparisions.\n        * tree.def: Likewise.\n\t* tree.h: Add ISO C 9x unordered fp comparision builtins.\n\n\t* builtins.c (expand_tree_builtin): New function.\n\t* c-typeck.c (build_function_call): Use it.\n\t(build_binary_op): Support unordered compares.\n\t* c-common.c (c_common_nodes_and_builtins): Add unordered compares.\n\n\t* combine.c (known_cond): Handle reverse_condition returning UNKNOWN.\n\t(reversible_comparison_p): Allow UNORDERED/ORDERED to be reversed.\n\t* cse.c (fold_rtx): Check FLOAT_MODE_P before reversing.\n\t(record_jump_equiv): Handle reverse_condition returning UNKNOWN.\n\t* jump.c (reverse_condition): Don't abort for UNLE etc, but\n\treturn UNKNOWN.\n\t(swap_condition): Handle unordered compares.\n\t(thread_jumps): Check can_reverse before reversing.\n\t* loop.c (get_condition): Likewise.  Allow UNORERED/ORDERED to be\n\treversed for FP.\n\n\t* optabs.c (can_compare_p): New argument CODE.  Verify branch or\n\tsetcc is present before acking for cmp_optab.  Update all callers.\n\t(prepare_float_lib_cmp, init_optabs): Handle UNORDERED.\n\t* expmed.c (do_cmp_and_jump): Update for can_compare_p.\n\t* expr.c (expand_expr): Likewise.  Support unordered compares.\n\t(do_jump, do_store_flag): Likewise.\n\t* expr.h (enum libfunc_index): Add unordered compares.\n\n\t* Makefile.in (FPBIT_FUNCS): Add _unord_sf.\n\t(DPBIT_FUNCS): Add _unord_df.\n\t* config/fp-bit.c (_unord_f2): New.\n\t* fp-test.c (main): Try unordered compare builtins.\n\n\t* alpha-protos.h (alpha_fp_comparison_operator): Declare.\n\t* alpha.c (alpha_comparison_operator): Check mode properly.\n\t(alpha_swapped_comparison_operator): Likewise.\n\t(signed_comparison_operator): Likewise.\n\t(alpha_fp_comparison_operator): New.\n\t(alpha_emit_conditional_branch): Handle unordered compares.\n\t* alpha.h (PREDICATE_CODES): Update.\n\t* alpha.md (fp compares): Use alpha_fp_comparison_operator.\n\t(bunordered, bordered): New.\n\n\t* cp/call.c (build_over_call): Use expand_tree_builtin.\n\t* cp/typeck.c (build_function_call_real): Likewise.\n\t(build_binary_op_nodefault): Handle unordered compares.\n\n\t* gcc.c-torture/execute/ieee/fp-cmp-4.c: New.\n\nFrom-SVN: r31591", "tree": {"sha": "a9f7967b844ec94122754eade0945e4f551bf9f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9f7967b844ec94122754eade0945e4f551bf9f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/comments", "author": null, "committer": null, "parents": [{"sha": "d6cde8451a650824fcf971d56978b50d949aa3a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6cde8451a650824fcf971d56978b50d949aa3a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6cde8451a650824fcf971d56978b50d949aa3a2"}], "stats": {"total": 995, "additions": 801, "deletions": 194}, "files": [{"sha": "159d95b951ec257abb750aade327978a32fe29e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 29, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -1,3 +1,48 @@\n+2000-01-24  Richard Henderson  <rth@cygnus.com>\n+\n+\t* rtl.def: Add unordered fp comparisions.\n+\t* tree.def: Likewise.\n+\t* tree.h: Add ISO C 9x unordered fp comparision builtins.\n+\n+\t* builtins.c (expand_tree_builtin): New function.\n+\t* c-typeck.c (build_function_call): Use it.\n+\t(build_binary_op): Support unordered compares.\n+\t* c-common.c (c_common_nodes_and_builtins): Add unordered compares.\n+\n+\t* combine.c (known_cond): Handle reverse_condition returning UNKNOWN.\n+\t(reversible_comparison_p): Allow UNORDERED/ORDERED to be reversed.\n+\t* cse.c (fold_rtx): Check FLOAT_MODE_P before reversing.\n+\t(record_jump_equiv): Handle reverse_condition returning UNKNOWN.\n+\t* jump.c (reverse_condition): Don't abort for UNLE etc, but\n+\treturn UNKNOWN.\n+\t(swap_condition): Handle unordered compares.\n+\t(thread_jumps): Check can_reverse before reversing.\n+\t* loop.c (get_condition): Likewise.  Allow UNORERED/ORDERED to be\n+\treversed for FP.\n+\n+\t* optabs.c (can_compare_p): New argument CODE.  Verify branch or\n+\tsetcc is present before acking for cmp_optab.  Update all callers.\n+\t(prepare_float_lib_cmp, init_optabs): Handle UNORDERED.\n+\t* expmed.c (do_cmp_and_jump): Update for can_compare_p.\n+\t* expr.c (expand_expr): Likewise.  Support unordered compares.\n+\t(do_jump, do_store_flag): Likewise.\n+\t* expr.h (enum libfunc_index): Add unordered compares.\n+\n+\t* Makefile.in (FPBIT_FUNCS): Add _unord_sf.\n+\t(DPBIT_FUNCS): Add _unord_df.\n+\t* config/fp-bit.c (_unord_f2): New.\n+\t* fp-test.c (main): Try unordered compare builtins.\n+\n+\t* alpha-protos.h (alpha_fp_comparison_operator): Declare.\n+\t* alpha.c (alpha_comparison_operator): Check mode properly.\n+\t(alpha_swapped_comparison_operator): Likewise.\n+\t(signed_comparison_operator): Likewise.\n+\t(alpha_fp_comparison_operator): New.\n+\t(alpha_emit_conditional_branch): Handle unordered compares.\n+\t* alpha.h (PREDICATE_CODES): Update.\n+\t* alpha.md (fp compares): Use alpha_fp_comparison_operator.\n+\t(bunordered, bordered): New.\n+\n 2000-01-24  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha.c (alpha_emit_xfloating_cvt): Thinko in operand manipulation.\n@@ -139,8 +184,8 @@ Mon Jan 24 16:50:08 MET 2000  Jan Hubicka  <jh@suse.cz>\n \n 2000-01-22  Alan Modra <alan@SPRI.Levels.UniSA.Edu.Au>\n \n-        * config/elfos.h (UNIQUE_SECTION): Restore uninitialised data\n-        section naming to that prior to 2000-01-07 patch.\n+\t* config/elfos.h (UNIQUE_SECTION): Restore uninitialised data\n+\tsection naming to that prior to 2000-01-07 patch.\n \t* config/mips/elf.h (UNIQUE_SECTION): Ditto.\n \t* config/mips/elf64.h (UNIQUE_SECTION): Ditto.\n \t* config/mips/iris6gld.h (UNIQUE_SECTION): Ditto.\n@@ -188,18 +233,18 @@ Mon Jan 24 16:50:08 MET 2000  Jan Hubicka  <jh@suse.cz>\n 2000-01-20  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* Makefile.in (fixinc.sh): Depend on specs.\n-        * fixinc/Makefile.in: Add rule to create machname.h.\n-        (fixlib.o): Depend on machname.h.\n-        * fixinc/fixtests.c (machine_name): New test.\n-        * fixinc/fixfixes.c (machine_name): New fix.\n-        * fixinc/fixlib.c (mn_get_regexps): New helper function for\n-        the machine_name test and fix.\n-        * fixinc/fixlib.h: Prototype it.\n-        * fixinc/inclhack.def (machine_name): Use the C test and fix.\n+\t* fixinc/Makefile.in: Add rule to create machname.h.\n+\t(fixlib.o): Depend on machname.h.\n+\t* fixinc/fixtests.c (machine_name): New test.\n+\t* fixinc/fixfixes.c (machine_name): New fix.\n+\t* fixinc/fixlib.c (mn_get_regexps): New helper function for\n+\tthe machine_name test and fix.\n+\t* fixinc/fixlib.h: Prototype it.\n+\t* fixinc/inclhack.def (machine_name): Use the C test and fix.\n \t* fixinc/fixincl.x, fixinc/inclhack.sh: Rebuild.\n \n-        * gcc.c (do_spec_1) [case P]: Take care not to create\n-        identifiers with three leading or trailing underscores.\n+\t* gcc.c (do_spec_1) [case P]: Take care not to create\n+\tidentifiers with three leading or trailing underscores.\n \n \t* fixinc/Makefile.in (FIXINC_DEFS): Add -DIN_GCC.\n \t(fixincl): Don't specify libraries twice on link line.\n@@ -851,8 +896,8 @@ Sat Jan 15 15:41:14 EST 2000  John Wehle  (john@feith.com)\n 2000-01-14  Clinton Popetz  <cpopetz@cygnus.com>\n \n \t* config/mips/mips.h (REGISTER_MOVE_COST): Remove redundant\n-        case for moving from HI/LO/HI_LO_REG.  This makes the behavior\n-        match the comment for MIPS16.\n+\tcase for moving from HI/LO/HI_LO_REG.  This makes the behavior\n+\tmatch the comment for MIPS16.\n \n Fri Jan 14 00:28:06 2000  Jeffrey A Law  (law@cygnus.com)\n \n@@ -878,7 +923,7 @@ Thu Jan 13 23:44:03 2000  Richard Henderson  <rth@cygnus.com>\n \tUse emit_jump_insn for the return insn.\n \n Thu Jan 13 14:46:03 2000  Jason Eckhardt  <jle@cygnus.com>\n-                          Stan Cox  <scox@cygnus.com>\n+\t                  Stan Cox  <scox@cygnus.com>\n \n \t* predict.c: New file. Preliminary infrastructure work for static\n \tbranch prediction and basic block reordering.\n@@ -1278,21 +1323,21 @@ Tue Jan 11 18:59:35 MET 2000  Jan Hubicka <jh@suse.cz>\n \n 2000-01-11  Clinton Popetz  <cpopetz@cygnus.com>\n \n-        * config/mips/mips.c (mips_va_arg): For EABI, emit the queued\n-        integer vararg POSTINCREMENT before the destination of the jump\n-        for the hard fp case. \n-        (function_arg_pass_by_reference): Pass a copy of CUM to \n+\t* config/mips/mips.c (mips_va_arg): For EABI, emit the queued\n+\tinteger vararg POSTINCREMENT before the destination of the jump\n+\tfor the hard fp case. \n+\t(function_arg_pass_by_reference): Pass a copy of CUM to \n \tFUNCTION_ARG.\n-        \n-        * config/mips/mips.h (GO_IF_LEGITIMATE_ADDRESS): Move check\n-        for CONSTANT_ADDRESS_P above while loop for subreg.\n+\t\n+\t* config/mips/mips.h (GO_IF_LEGITIMATE_ADDRESS): Move check\n+\tfor CONSTANT_ADDRESS_P above while loop for subreg.\n \n 2000-01-11  Clinton Popetz  <cpopetz@cygnus.com>\n \n \t* flow.c (propagate_block): When a prologue/epilogue insn\n-        is marked dead, unconditionally clear libcall_is_dead and\n-        insn_is_dead, and only dump rtl if warnings aren't being\n-        suppressed.\n+\tis marked dead, unconditionally clear libcall_is_dead and\n+\tinsn_is_dead, and only dump rtl if warnings aren't being\n+\tsuppressed.\n \n Tue Jan 11 16:26:47 MET 2000  Jan Hubicka <jh@suse.cz>\n \n@@ -1660,11 +1705,11 @@ Thu Jan  6 13:44:59 CET 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* configure.in (m68*-*-rtemscoff*): New target, formal name for\n \told m68*-*-rtems*.\n-        (m68*-*-rtemself*): New target.\n+\t(m68*-*-rtemself*): New target.\n \t(mips64orion-*-rtems*): Remove duplicate definition of tm_file.\n \t(sparc*-*-rtemsaout*): New target, formal name for old sparc*-*-rtems*.\n-        (sparc*-*-rtemself*): New target.\n-        (sparc*-*-rtems*): Now elf not a.out.\n+\t(sparc*-*-rtemself*): New target.\n+\t(sparc*-*-rtems*): Now elf not a.out.\n \t* config/i386/rtems.h: Include config/rtems.h.\n \t* config/i386/rtemself.h: Include config/rtems.h.\n \t* config/i960/rtems.h: Include config/rtems.h.\n@@ -1956,7 +2001,7 @@ Fri Dec 31 19:10:31 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 1999-12-30  Herman A.J. ten Brugge  <Haj.Ten.Brugge@net.HCC.nl>\n \n-        * genrecog.c (change_state) Corrected typo.\n+\t* genrecog.c (change_state) Corrected typo.\n \n 1999-12-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n "}, {"sha": "5e6b6e581813c325becf09d8fd262885f2a6d330", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -730,12 +730,12 @@ LIB2FUNCS_EH = _eh\n \n FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \\\n     _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \\\n-    _lt_sf _le_sf _si_to_sf _sf_to_si _negate_sf _make_sf \\\n+    _lt_sf _le_sf _unord_sf _si_to_sf _sf_to_si _negate_sf _make_sf \\\n     _sf_to_df _thenan_sf _sf_to_usi _df_to_usi\n \n DPBIT_FUNCS = _pack_df _unpack_df _addsub_df _mul_df _div_df \\\n     _fpcmp_parts_df _compare_df _eq_df _ne_df _gt_df _ge_df \\\n-    _lt_df _le_df _si_to_df _df_to_si _negate_df _make_df \\\n+    _lt_df _le_df _unord_df _si_to_df _df_to_si _negate_df _make_df \\\n     _df_to_sf _thenan_df _sf_to_usi _df_to_usi\n \n # The files that \"belong\" in CONFIG_H are deliberately omitted"}, {"sha": "fcb6a7aa676fa29ae4330e77e4f837844ab2d603", "filename": "gcc/builtins.c", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -2520,3 +2520,100 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n      to be called normally.  */\n   return expand_call (exp, target, ignore);\n }\n+\n+/* Recognize certain built-in functions so we can make tree-codes\n+   other than CALL_EXPR.  We do this when it enables fold-const.c\n+   to do something useful.  */\n+\n+tree\n+expand_tree_builtin (function, params, coerced_params)\n+     tree function, params, coerced_params;\n+{\n+  enum tree_code code;\n+\n+  if (DECL_BUILT_IN_CLASS (function) != BUILT_IN_NORMAL)\n+    return NULL_TREE;\n+\n+  switch (DECL_FUNCTION_CODE (function))\n+    {\n+    case BUILT_IN_ABS:\n+    case BUILT_IN_LABS:\n+    case BUILT_IN_FABS:\n+      if (coerced_params == 0)\n+\treturn integer_zero_node;\n+      return build_unary_op (ABS_EXPR, TREE_VALUE (coerced_params), 0);\n+\n+    case BUILT_IN_ISGREATER:\n+      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+\tcode = UNLE_EXPR;\n+      else\n+\tcode = LE_EXPR;\n+      goto unordered_cmp;\n+\n+    case BUILT_IN_ISGREATEREQUAL:\n+      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+\tcode = UNLT_EXPR;\n+      else\n+\tcode = LT_EXPR;\n+      goto unordered_cmp;\n+\n+    case BUILT_IN_ISLESS:\n+      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+\tcode = UNGE_EXPR;\n+      else\n+\tcode = GE_EXPR;\n+      goto unordered_cmp;\n+\n+    case BUILT_IN_ISLESSEQUAL:\n+      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+\tcode = UNGT_EXPR;\n+      else\n+\tcode = GT_EXPR;\n+      goto unordered_cmp;\n+\n+    case BUILT_IN_ISLESSGREATER:\n+      if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+\tcode = UNEQ_EXPR;\n+      else\n+\tcode = EQ_EXPR;\n+      goto unordered_cmp;\n+\n+    case BUILT_IN_ISUNORDERED:\n+      if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT)\n+\treturn integer_zero_node;\n+      code = UNORDERED_EXPR;\n+      goto unordered_cmp;\n+\n+    unordered_cmp:\n+      {\n+\ttree arg0, arg1;\n+\n+\tif (params == 0\n+\t    || TREE_CHAIN (params) == 0)\n+\t  {\n+\t    error (\"too few arguments to function `%s'\",\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (function)));\n+\t    return error_mark_node;\n+\t  }\n+\telse if (TREE_CHAIN (TREE_CHAIN (params)) != 0)\n+\t  {\n+\t    error (\"too many arguments to function `%s'\",\n+\t\t   IDENTIFIER_POINTER (DECL_NAME (function)));\n+\t    return error_mark_node;\n+\t  }\n+\n+\targ0 = TREE_VALUE (params);\n+\targ1 = TREE_VALUE (TREE_CHAIN (params));\n+\targ0 = build_binary_op (code, arg0, arg1, 0);\n+\tif (code != UNORDERED_EXPR)\n+\t  arg0 = build_unary_op (TRUTH_NOT_EXPR, arg0, 0);\n+\treturn arg0;\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}"}, {"sha": "6d9181094b49f210dd420c1de8c4c664b32c5e03", "filename": "gcc/c-common.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -3710,6 +3710,20 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n   builtin_function (\"__builtin_trap\", void_ftype, BUILT_IN_TRAP,\n \t\t    BUILT_IN_NORMAL, NULL_PTR);\n \n+  /* ISO C99 IEEE Unordered compares.  */\n+  builtin_function (\"__builtin_isgreater\", default_function_type,\n+\t\t    BUILT_IN_ISGREATER, BUILT_IN_NORMAL, NULL_PTR);\n+  builtin_function (\"__builtin_isgreaterequal\", default_function_type,\n+\t\t    BUILT_IN_ISGREATEREQUAL, BUILT_IN_NORMAL, NULL_PTR);\n+  builtin_function (\"__builtin_isless\", default_function_type,\n+\t\t    BUILT_IN_ISLESS, BUILT_IN_NORMAL, NULL_PTR);\n+  builtin_function (\"__builtin_islessequal\", default_function_type,\n+\t\t    BUILT_IN_ISLESSEQUAL, BUILT_IN_NORMAL, NULL_PTR);\n+  builtin_function (\"__builtin_islessgreater\", default_function_type,\n+\t\t    BUILT_IN_ISLESSGREATER, BUILT_IN_NORMAL, NULL_PTR);\n+  builtin_function (\"__builtin_isunordered\", default_function_type,\n+\t\t    BUILT_IN_ISUNORDERED, BUILT_IN_NORMAL, NULL_PTR);\n+\n   /* Untyped call and return.  */\n   builtin_function (\"__builtin_apply_args\", ptr_ftype,\n \t\t    BUILT_IN_APPLY_ARGS, BUILT_IN_NORMAL, NULL_PTR);"}, {"sha": "f85931ad4a020636a061907cc5e2b3e673ef63d1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -1405,7 +1405,7 @@ build_function_call (function, params)\n {\n   register tree fntype, fundecl = 0;\n   register tree coerced_params;\n-  tree name = NULL_TREE, assembler_name = NULL_TREE;\n+  tree name = NULL_TREE, assembler_name = NULL_TREE, result;\n \n   /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */\n   STRIP_TYPE_NOPS (function);\n@@ -1460,30 +1460,21 @@ build_function_call (function, params)\n \n   if (TREE_CODE (function) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL\n-      && DECL_BUILT_IN (TREE_OPERAND (function, 0))\n-      && DECL_BUILT_IN_CLASS (TREE_OPERAND (function, 0)) == BUILT_IN_NORMAL)\n-    switch (DECL_FUNCTION_CODE (TREE_OPERAND (function, 0)))\n-      {\n-      case BUILT_IN_ABS:\n-      case BUILT_IN_LABS:\n-      case BUILT_IN_FABS:\n-\tif (coerced_params == 0)\n-\t  return integer_zero_node;\n-\treturn build_unary_op (ABS_EXPR, TREE_VALUE (coerced_params), 0);\n-      default:\n-\tbreak;\n-      }\n+      && DECL_BUILT_IN (TREE_OPERAND (function, 0)))\n+    {\n+      result = expand_tree_builtin (TREE_OPERAND (function, 0),\n+\t\t\t\t    params, coerced_params);\n+      if (result)\n+\treturn result;\n+    }\n \n-  {\n-    register tree result\n-      = build (CALL_EXPR, TREE_TYPE (fntype),\n-\t       function, coerced_params, NULL_TREE);\n-\n-    TREE_SIDE_EFFECTS (result) = 1;\n-    if (TREE_TYPE (result) == void_type_node)\n-      return result;\n-    return require_complete_type (result);\n-  }\n+  result = build (CALL_EXPR, TREE_TYPE (fntype),\n+\t\t  function, coerced_params, NULL_TREE);\n+\n+  TREE_SIDE_EFFECTS (result) = 1;\n+  if (TREE_TYPE (result) == void_type_node)\n+    return result;\n+  return require_complete_type (result);\n }\n \f\n /* Convert the argument expressions in the list VALUES\n@@ -2233,7 +2224,24 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \t    pedwarn (\"comparison between pointer and integer\");\n \t}\n       break;\n-      \n+\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case UNNE_EXPR:\n+      build_type = integer_type_node;\n+      if (code0 != REAL_TYPE || code1 != REAL_TYPE)\n+\t{\n+\t  error (\"unordered comparison on non-floating point argument\");\n+\t  return error_mark_node;\n+\t}\n+      common = 1;\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "8d578eb6691574fcf5a3bb86b09f81ad2ee6f743", "filename": "gcc/combine.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -7313,11 +7313,17 @@ known_cond (x, cond, reg, val)\n       if (rtx_equal_p (XEXP (x, 0), reg) && rtx_equal_p (XEXP (x, 1), val))\n \t{\n \t  if (GET_RTX_CLASS (code) == '<')\n-\t    return (comparison_dominates_p (cond, code) ? const_true_rtx\n-\t\t    : (comparison_dominates_p (cond,\n-\t\t\t\t\t       reverse_condition (code))\n-\t\t       ? const0_rtx : x));\n+\t    {\n+\t      if (comparison_dominates_p (cond, code))\n+\t\treturn const_true_rtx;\n \n+\t      code = reverse_condition (code);\n+\t      if (code != UNKNOWN\n+\t\t  && comparison_dominates_p (cond, code))\n+\t\treturn const0_rtx;\n+\t      else\n+\t\treturn x;\n+\t    }\n \t  else if (code == SMAX || code == SMIN\n \t\t   || code == UMIN || code == UMAX)\n \t    {\n@@ -10852,7 +10858,8 @@ reversible_comparison_p (x)\n {\n   if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n       || flag_fast_math\n-      || GET_CODE (x) == NE || GET_CODE (x) == EQ)\n+      || GET_CODE (x) == NE || GET_CODE (x) == EQ\n+      || GET_CODE (x) == UNORDERED || GET_CODE (x) == ORDERED)\n     return 1;\n \n   switch (GET_MODE_CLASS (GET_MODE (XEXP (x, 0))))"}, {"sha": "693fa245bcc76dff82950eb5f55547c528b770c7", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -58,6 +58,7 @@ extern int call_operand PARAMS ((rtx, enum machine_mode));\n extern int alpha_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int alpha_swapped_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int signed_comparison_operator PARAMS ((rtx, enum machine_mode));\n+extern int alpha_fp_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int divmod_operator PARAMS ((rtx, enum machine_mode));\n extern int aligned_memory_operand PARAMS ((rtx, enum machine_mode));\n extern int unaligned_memory_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "cbc16883d6fdef334b9ef718b9737387f9863047", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -706,7 +706,7 @@ alpha_comparison_operator (op, mode)\n {\n   enum rtx_code code = GET_CODE (op);\n \n-  if (mode != GET_MODE (op) || GET_RTX_CLASS (code) != '<')\n+  if (mode != GET_MODE (op) && mode != VOIDmode)\n     return 0;\n \n   return (code == EQ || code == LE || code == LT\n@@ -722,7 +722,8 @@ alpha_swapped_comparison_operator (op, mode)\n {\n   enum rtx_code code = GET_CODE (op);\n \n-  if (mode != GET_MODE (op) || GET_RTX_CLASS (code) != '<')\n+  if ((mode != GET_MODE (op) && mode != VOIDmode)\n+      || GET_RTX_CLASS (code) != '<')\n     return 0;\n \n   code = swap_condition (code);\n@@ -737,16 +738,30 @@ signed_comparison_operator (op, mode)\n      register rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  switch (GET_CODE (op))\n-    {\n-    case EQ:  case NE:  case LE:  case LT:  case GE:   case GT:\n-      return 1;\n+  enum rtx_code code = GET_CODE (op);\n \n-    default:\n-      break;\n-    }\n+  if (mode != GET_MODE (op) && mode != VOIDmode)\n+    return 0;\n \n-  return 0;\n+  return (code == EQ || code == NE\n+\t  || code == LE || code == LT\n+\t  || code == GE || code == GT);\n+}\n+\n+/* Return 1 if OP is a valid Alpha floating point comparison operator.\n+   Here we know which comparisons are valid in which insn.  */\n+\n+int\n+alpha_fp_comparison_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (mode != GET_MODE (op) && mode != VOIDmode)\n+    return 0;\n+\n+  return (code == EQ || code == LE || code == LT || code == UNORDERED);\n }\n \n /* Return 1 if this is a divide or modulus operator.  */\n@@ -1484,13 +1499,15 @@ alpha_emit_conditional_branch (code)\n   switch (code)\n     {\n     case EQ:  case LE:  case LT:  case LEU:  case LTU:\n+    case UNORDERED:\n       /* We have these compares: */\n       cmp_code = code, branch_code = NE;\n       break;\n \n     case NE:\n-      /* This must be reversed. */\n-      cmp_code = EQ, branch_code = EQ;\n+    case ORDERED:\n+      /* These must be reversed. */\n+      cmp_code = reverse_condition (code), branch_code = EQ;\n       break;\n \n     case GE:  case GT: case GEU:  case GTU:\n@@ -3383,6 +3400,8 @@ print_operand (file, x, code)\n \t  fprintf (file, \"ule\");\n         else if (c == LTU)\n \t  fprintf (file, \"ult\");\n+\telse if (c == UNORDERED)\n+\t  fprintf (file, \"un\");\n         else\n \t  fprintf (file, \"%s\", GET_RTX_NAME (c));\n       }"}, {"sha": "ad45596f0bb1d8cc5da5cb211d7c9bffde60af47", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -2311,6 +2311,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"alpha_comparison_operator\", {EQ, LE, LT, LEU, LTU}},\t\t\\\n   {\"alpha_swapped_comparison_operator\", {EQ, GE, GT, GEU, GTU}},\t\\\n   {\"signed_comparison_operator\", {EQ, NE, LE, LT, GE, GT}},\t\t\\\n+  {\"alpha_fp_comparison_operator\", {EQ, LE, LT, UNORDERED}},\t\t\\\n   {\"divmod_operator\", {DIV, MOD, UDIV, UMOD}},\t\t\t\t\\\n   {\"fp0_operand\", {CONST_DOUBLE}},\t\t\t\t\t\\\n   {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\t\\"}, {"sha": "2325483d02dc7835bb27952ca069a43ee8844042", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -2752,22 +2752,22 @@\n   \"\")\n \f\n ;; The following are the corresponding floating-point insns.  Recall\n-;; we need to have variants that expand the arguments from SF mode\n+;; we need to have variants that expand the arguments from SFmode\n ;; to DFmode.\n \n-(define_insn \"\"\n+(define_insn \"*cmpdf_tp\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=&f\")\n-\t(match_operator:DF 1 \"alpha_comparison_operator\"\n+\t(match_operator:DF 1 \"alpha_fp_comparison_operator\"\n \t\t\t   [(match_operand:DF 2 \"reg_or_fp0_operand\" \"fG\")\n \t\t\t    (match_operand:DF 3 \"reg_or_fp0_operand\" \"fG\")]))]\n   \"TARGET_FP && alpha_fptm >= ALPHA_FPTM_SU\"\n   \"cmp%-%C1%' %R2,%R3,%0\"\n   [(set_attr \"type\" \"fadd\")\n    (set_attr \"trap\" \"yes\")])\n \n-(define_insn \"\"\n+(define_insn \"*cmpdf_no_tp\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(match_operator:DF 1 \"alpha_comparison_operator\"\n+\t(match_operator:DF 1 \"alpha_fp_comparison_operator\"\n \t\t\t   [(match_operand:DF 2 \"reg_or_fp0_operand\" \"fG\")\n \t\t\t    (match_operand:DF 3 \"reg_or_fp0_operand\" \"fG\")]))]\n   \"TARGET_FP && alpha_fptm < ALPHA_FPTM_SU\"\n@@ -2777,7 +2777,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=&f\")\n-\t(match_operator:DF 1 \"alpha_comparison_operator\"\n+\t(match_operator:DF 1 \"alpha_fp_comparison_operator\"\n \t\t\t   [(float_extend:DF\n \t\t\t     (match_operand:SF 2 \"reg_or_fp0_operand\" \"fG\"))\n \t\t\t    (match_operand:DF 3 \"reg_or_fp0_operand\" \"fG\")]))]\n@@ -2788,7 +2788,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(match_operator:DF 1 \"alpha_comparison_operator\"\n+\t(match_operator:DF 1 \"alpha_fp_comparison_operator\"\n \t\t\t   [(float_extend:DF\n \t\t\t     (match_operand:SF 2 \"reg_or_fp0_operand\" \"fG\"))\n \t\t\t    (match_operand:DF 3 \"reg_or_fp0_operand\" \"fG\")]))]\n@@ -2799,7 +2799,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=&f\")\n-\t(match_operator:DF 1 \"alpha_comparison_operator\"\n+\t(match_operator:DF 1 \"alpha_fp_comparison_operator\"\n \t\t\t   [(match_operand:DF 2 \"reg_or_fp0_operand\" \"fG\")\n \t\t\t    (float_extend:DF\n \t\t\t     (match_operand:SF 3 \"reg_or_fp0_operand\" \"fG\"))]))]\n@@ -2810,7 +2810,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(match_operator:DF 1 \"alpha_comparison_operator\"\n+\t(match_operator:DF 1 \"alpha_fp_comparison_operator\"\n \t\t\t   [(match_operand:DF 2 \"reg_or_fp0_operand\" \"fG\")\n \t\t\t    (float_extend:DF\n \t\t\t     (match_operand:SF 3 \"reg_or_fp0_operand\" \"fG\"))]))]\n@@ -2821,7 +2821,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=&f\")\n-\t(match_operator:DF 1 \"alpha_comparison_operator\"\n+\t(match_operator:DF 1 \"alpha_fp_comparison_operator\"\n \t\t\t   [(float_extend:DF\n \t\t\t     (match_operand:SF 2 \"reg_or_fp0_operand\" \"fG\"))\n \t\t\t    (float_extend:DF\n@@ -2833,7 +2833,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(match_operator:DF 1 \"alpha_comparison_operator\"\n+\t(match_operator:DF 1 \"alpha_fp_comparison_operator\"\n \t\t\t   [(float_extend:DF\n \t\t\t     (match_operand:SF 2 \"reg_or_fp0_operand\" \"fG\"))\n \t\t\t    (float_extend:DF\n@@ -3126,6 +3126,22 @@\n   \"\"\n   \"{ operands[1] = alpha_emit_conditional_branch (GEU); }\")\n \n+(define_expand \"bunordered\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{ operands[1] = alpha_emit_conditional_branch (UNORDERED); }\")\n+\n+(define_expand \"bordered\"\n+  [(set (pc)\n+\t(if_then_else (match_dup 1)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"{ operands[1] = alpha_emit_conditional_branch (ORDERED); }\")\n+\n (define_expand \"seq\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_dup 1))]"}, {"sha": "fc496c0f0592da104e67a4cf4b7fa5fd4cb51d43", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -1,7 +1,7 @@\n /* This is a software floating point library which can be used instead of\n    the floating point routines in libgcc1.c for targets without hardware\n    floating point. \n- Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1994-1998, 2000 Free Software Foundation, Inc.\n \n This file is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -78,6 +78,8 @@ Boston, MA 02111-1307, USA.  */\n #define L_lt_df\n #define L_le_sf\n #define L_le_df\n+#define L_unord_sf\n+#define L_unord_df\n #define L_si_to_sf\n #define L_si_to_df\n #define L_sf_to_si\n@@ -268,6 +270,7 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #\t\tdefine _ge_f2 \t\t__gesf2\n #\t\tdefine _lt_f2 \t\t__ltsf2\n #\t\tdefine _le_f2 \t\t__lesf2\n+#\t\tdefine _unord_f2\t__unordsf2\n #\t\tdefine si_to_float \t__floatsisf\n #\t\tdefine float_to_si \t__fixsfsi\n #\t\tdefine float_to_usi \t__fixunssfsi\n@@ -285,6 +288,7 @@ typedef unsigned int UDItype __attribute__ ((mode (DI)));\n #\t\tdefine _ge_f2 \t\t__gedf2\n #\t\tdefine _lt_f2 \t\t__ltdf2\n #\t\tdefine _le_f2 \t\t__ledf2\n+#\t\tdefine _unord_f2\t__unorddf2\n #\t\tdefine si_to_float \t__floatsidf\n #\t\tdefine float_to_si \t__fixdfsi\n #\t\tdefine float_to_usi \t__fixunsdfsi\n@@ -1370,6 +1374,24 @@ _le_f2 (FLO_type arg_a, FLO_type arg_b)\n }\n #endif\n \n+#if defined(L_unord_sf) || defined(L_unord_df)\n+CMPtype\n+_unord_f2 (FLO_type arg_a, FLO_type arg_b)\n+{\n+  fp_number_type a;\n+  fp_number_type b;\n+  FLO_union_type au, bu;\n+\n+  au.value = arg_a;\n+  bu.value = arg_b;\n+\n+  unpack_d (&au, &a);\n+  unpack_d (&bu, &b);\n+\n+  return (isnan (&a) || isnan (&b);\n+}\n+#endif\n+\n #endif /* ! US_SOFTWARE_GOFAST */\n \n #if defined(L_si_to_sf) || defined(L_si_to_df)"}, {"sha": "92dcb793124294a5a9bfd5afce0cdb0b6e79b46c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -1,3 +1,9 @@\n+2000-01-24  Richard Henderson  <rth@cygnus.com>\n+\n+\t* call.c (build_over_call): Use expand_tree_builtin.\n+\t* typeck.c (build_function_call_real): Likewise.\n+\t(build_binary_op_nodefault): Handle unordered compares.\n+\n 2000-01-24  Nathan Sidwell  <sidwell@codesourcery.com>\n \n \t* cp-tree.h (CPTI_BAD_CAST, CPTI_BAD_TYPEID, CPTI_DCAST): New\n@@ -111,10 +117,10 @@\n \n 2000-01-19  Gabriel Dos Reis  <gdr@codesourcery.coom>\n \n-        * typeck.c (build_unary_op): Use cp_pedwarn, not pedwarn.\n+\t* typeck.c (build_unary_op): Use cp_pedwarn, not pedwarn.\n \n-        * typeck2.c (incomplete_type_error): Restore previous\n-        cp_error and cp_error_at call sequence.\n+\t* typeck2.c (incomplete_type_error): Restore previous\n+\tcp_error and cp_error_at call sequence.\n \t\n 2000-01-20  Brad Lucier  <lucier@math.purdue.edu>\n "}, {"sha": "991a79dcd99f84ee7dbe3ca63f18d8383c18008c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -4145,19 +4145,13 @@ build_over_call (cand, args, flags)\n \n   if (TREE_CODE (fn) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL\n-      && DECL_BUILT_IN (TREE_OPERAND (fn, 0))\n-      && DECL_BUILT_IN_CLASS (TREE_OPERAND (fn, 0)) == BUILT_IN_NORMAL)\n-    switch (DECL_FUNCTION_CODE (TREE_OPERAND (fn, 0)))\n-      {\n-      case BUILT_IN_ABS:\n-      case BUILT_IN_LABS:\n-      case BUILT_IN_FABS:\n-\tif (converted_args == 0)\n-\t  return integer_zero_node;\n-\treturn build_unary_op (ABS_EXPR, TREE_VALUE (converted_args), 0);\n-      default:\n-        break;\n-      }\n+      && DECL_BUILT_IN (TREE_OPERAND (fn, 0)))\n+    {\n+      tree exp;\n+      exp = expand_tree_builtin (TREE_OPERAND (fn, 0), args, converted_args);\n+      if (exp)\n+\treturn exp;\n+    }\n \n   fn = build_call (fn, TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))), converted_args);\n   if (TREE_CODE (TREE_TYPE (fn)) == VOID_TYPE)"}, {"sha": "29f60860ad20fcdcf14076ee304f3f6d6ed46ee5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -2926,6 +2926,7 @@ build_function_call_real (function, params, require_complete, flags)\n   register tree fntype, fndecl;\n   register tree value_type;\n   register tree coerced_params;\n+  tree result;\n   tree name = NULL_TREE, assembler_name = NULL_TREE;\n   int is_method;\n \n@@ -3023,37 +3024,27 @@ build_function_call_real (function, params, require_complete, flags)\n \n   if (TREE_CODE (function) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL\n-      && DECL_BUILT_IN (TREE_OPERAND (function, 0))\n-      && DECL_BUILT_IN_CLASS (TREE_OPERAND (function, 0)) == BUILT_IN_NORMAL)\n-    switch (DECL_FUNCTION_CODE (TREE_OPERAND (function, 0)))\n-      {\n-      case BUILT_IN_ABS:\n-      case BUILT_IN_LABS:\n-      case BUILT_IN_FABS:\n-\tif (coerced_params == 0)\n-\t  return integer_zero_node;\n-\treturn build_unary_op (ABS_EXPR, TREE_VALUE (coerced_params), 0);\n-\n-      default:\n-\tbreak;\n-      }\n+      && DECL_BUILT_IN (TREE_OPERAND (function, 0)))\n+    {\n+      result = expand_tree_builtin (TREE_OPERAND (function, 0),\n+\t\t\t\t    params, coerced_params);\n+      if (result)\n+\treturn result;\n+    }\n \n   /* C++ */\n   value_type = TREE_TYPE (fntype) ? TREE_TYPE (fntype) : void_type_node;\n-  {\n-    register tree result\n-      = build_call (function, value_type, coerced_params);\n+  result = build_call (function, value_type, coerced_params);\n \n-    if (require_complete)\n-      {\n-\tif (TREE_CODE (value_type) == VOID_TYPE)\n-\t  return result;\n-\tresult = require_complete_type (result);\n-      }\n-    if (IS_AGGR_TYPE (value_type))\n-      result = build_cplus_new (value_type, result);\n-    return convert_from_reference (result);\n-  }\n+  if (require_complete)\n+    {\n+      if (TREE_CODE (value_type) == VOID_TYPE)\n+\treturn result;\n+      result = require_complete_type (result);\n+    }\n+  if (IS_AGGR_TYPE (value_type))\n+    result = build_cplus_new (value_type, result);\n+  return convert_from_reference (result);\n }\n \n tree\n@@ -3792,6 +3783,23 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t}\n       break;\n \n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case UNNE_EXPR:\n+      build_type = integer_type_node;\n+      if (code0 != REAL_TYPE || code1 != REAL_TYPE)\n+\t{\n+\t  error (\"unordered comparison on non-floating point argument\");\n+\t  return error_mark_node;\n+\t}\n+      common = 1;\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "9aced05f6072b21618e12971a3ae25bfbb3436fd", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -3718,9 +3718,9 @@ fold_rtx (x, insn)\n \t\t      struct qty_table_elem *ent = &qty_table[qty];\n \n \t\t      if ((comparison_dominates_p (ent->comparison_code, code)\n-\t\t\t   || (comparison_dominates_p (ent->comparison_code,\n-\t\t\t\t\t\t       reverse_condition (code))\n-\t\t\t       && ! FLOAT_MODE_P (mode_arg0)))\n+\t\t\t   || (! FLOAT_MODE_P (mode_arg0)\n+\t\t\t       && comparison_dominates_p (ent->comparison_code,\n+\t\t\t\t\t\t          reverse_condition (code))))\n \t\t\t  && (rtx_equal_p (ent->comparison_const, folded_arg1)\n \t\t\t      || (const_arg1\n \t\t\t\t  && rtx_equal_p (ent->comparison_const,\n@@ -4156,6 +4156,10 @@ record_jump_equiv (insn, taken)\n     {\n       reversed_nonequality = (code != EQ && code != NE);\n       code = reverse_condition (code);\n+\n+      /* Don't remember if we can't find the inverse.  */\n+      if (code == UNKNOWN)\n+\treturn;\n     }\n \n   /* The mode is the mode of the non-constant.  */"}, {"sha": "92d9a16537580cd8d8ed1ad399b4cc731f128f7f", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -4561,7 +4561,8 @@ do_cmp_and_jump (arg1, arg2, op, mode, label)\n   /* If this mode is an integer too wide to compare properly,\n      compare word by word.  Rely on cse to optimize constant cases.  */\n \n-  if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode, ccp_jump))\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && ! can_compare_p (op, mode, ccp_jump))\n     {\n       rtx label2 = gen_label_rtx ();\n "}, {"sha": "62f7d56b057dcf8f9b93a12f456475d49442cd13", "filename": "gcc/expr.c", "status": "modified", "additions": 120, "deletions": 9, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -7537,7 +7537,8 @@ expand_expr (exp, target, tmode, modifier)\n \n       /* If this mode is an integer too wide to compare properly,\n \t compare word by word.  Rely on cse to optimize constant cases.  */\n-      if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode, ccp_jump))\n+      if (GET_MODE_CLASS (mode) == MODE_INT\n+\t  && ! can_compare_p (GE, mode, ccp_jump))\n \t{\n \t  if (code == MAX_EXPR)\n \t    do_jump_by_parts_greater_rtx (mode, TREE_UNSIGNED (type),\n@@ -7618,6 +7619,14 @@ expand_expr (exp, target, tmode, modifier)\n     case GE_EXPR:\n     case EQ_EXPR:\n     case NE_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case UNNE_EXPR:\n       preexpand_calls (exp);\n       temp = do_store_flag (exp, target, tmode != VOIDmode ? tmode : mode, 0);\n       if (temp != 0)\n@@ -9413,7 +9422,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t  do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);\n \n \telse if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n-\t\t && !can_compare_p (TYPE_MODE (inner_type), ccp_jump))\n+\t\t && !can_compare_p (EQ, TYPE_MODE (inner_type), ccp_jump))\n \t  do_jump_by_parts_equality (exp, if_false_label, if_true_label);\n \telse\n \t  do_compare_and_jump (exp, EQ, EQ, if_false_label, if_true_label);\n@@ -9453,7 +9462,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t  do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n \n \telse if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n-\t\t && !can_compare_p (TYPE_MODE (inner_type), ccp_jump))\n+\t\t && !can_compare_p (NE, TYPE_MODE (inner_type), ccp_jump))\n \t  do_jump_by_parts_equality (exp, if_true_label, if_false_label);\n \telse\n \t  do_compare_and_jump (exp, NE, NE, if_false_label, if_true_label);\n@@ -9463,7 +9472,7 @@ do_jump (exp, if_false_label, if_true_label)\n     case LT_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && ! can_compare_p (mode, ccp_jump))\n+\t  && ! can_compare_p (LT, mode, ccp_jump))\n \tdo_jump_by_parts_greater (exp, 1, if_false_label, if_true_label);\n       else\n \tdo_compare_and_jump (exp, LT, LTU, if_false_label, if_true_label);\n@@ -9472,7 +9481,7 @@ do_jump (exp, if_false_label, if_true_label)\n     case LE_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && ! can_compare_p (mode, ccp_jump))\n+\t  && ! can_compare_p (LE, mode, ccp_jump))\n \tdo_jump_by_parts_greater (exp, 0, if_true_label, if_false_label);\n       else\n \tdo_compare_and_jump (exp, LE, LEU, if_false_label, if_true_label);\n@@ -9481,7 +9490,7 @@ do_jump (exp, if_false_label, if_true_label)\n     case GT_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && ! can_compare_p (mode, ccp_jump))\n+\t  && ! can_compare_p (GT, mode, ccp_jump))\n \tdo_jump_by_parts_greater (exp, 0, if_false_label, if_true_label);\n       else\n \tdo_compare_and_jump (exp, GT, GTU, if_false_label, if_true_label);\n@@ -9490,12 +9499,87 @@ do_jump (exp, if_false_label, if_true_label)\n     case GE_EXPR:\n       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && ! can_compare_p (mode, ccp_jump))\n+\t  && ! can_compare_p (GE, mode, ccp_jump))\n \tdo_jump_by_parts_greater (exp, 1, if_true_label, if_false_label);\n       else\n \tdo_compare_and_jump (exp, GE, GEU, if_false_label, if_true_label);\n       break;\n \n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+      {\n+\tenum rtx_code cmp, rcmp;\n+\tint do_rev;\n+\n+\tif (code == UNORDERED_EXPR)\n+\t  cmp = UNORDERED, rcmp = ORDERED;\n+\telse\n+\t  cmp = ORDERED, rcmp = UNORDERED;\n+        mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\n+\tdo_rev = 0;\n+\tif (! can_compare_p (cmp, mode, ccp_jump)\n+\t    && (can_compare_p (rcmp, mode, ccp_jump)\n+\t\t/* If the target doesn't provide either UNORDERED or ORDERED\n+\t\t   comparisons, canonicalize on UNORDERED for the library.  */\n+\t\t|| rcmp == UNORDERED))\n+\t  do_rev = 1;\n+\n+        if (! do_rev)\n+\t  do_compare_and_jump (exp, cmp, cmp, if_false_label, if_true_label);\n+\telse\n+\t  do_compare_and_jump (exp, rcmp, rcmp, if_true_label, if_false_label);\n+      }\n+      break;\n+\n+    {\n+      enum rtx_code rcode1;\n+      enum tree_code tcode2;\n+\n+      case UNLT_EXPR:\n+\trcode1 = UNLT;\n+\ttcode2 = LT_EXPR;\n+\tgoto unordered_bcc;\n+      case UNLE_EXPR:\n+\trcode1 = UNLE;\n+\ttcode2 = LE_EXPR;\n+\tgoto unordered_bcc;\n+      case UNGT_EXPR:\n+\trcode1 = UNGT;\n+\ttcode2 = GT_EXPR;\n+\tgoto unordered_bcc;\n+      case UNGE_EXPR:\n+\trcode1 = UNGE;\n+\ttcode2 = GE_EXPR;\n+\tgoto unordered_bcc;\n+      case UNEQ_EXPR:\n+\trcode1 = UNEQ;\n+\ttcode2 = EQ_EXPR;\n+\tgoto unordered_bcc;\n+      case UNNE_EXPR:\n+\trcode1 = UNNE;\n+\ttcode2 = NE_EXPR;\n+      unordered_bcc:\n+        mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\tif (can_compare_p (rcode1, mode, ccp_jump))\n+\t  do_compare_and_jump (exp, rcode1, rcode1, if_false_label,\n+\t\t\t       if_true_label);\n+\telse\n+\t  {\n+\t    tree op0 = save_expr (TREE_OPERAND (exp, 0));\n+\t    tree op1 = save_expr (TREE_OPERAND (exp, 1));\n+\t    tree cmp0, cmp1;\n+\n+\t    /* If the target doesn't support combined unordered \n+\t       compares, decompose into UNORDERED + comparison.  */\n+\t    cmp0 = fold (build (UNORDERED_EXPR, TREE_TYPE (exp), op0, op1));\n+\t    cmp1 = fold (build (tcode2, TREE_TYPE (exp), op0, op1));\n+\t    exp = build (TRUTH_ORIF_EXPR, TREE_TYPE (exp), cmp0, cmp1);\n+\t    do_jump (exp, if_false_label, if_true_label);\n+\t  }\n+      }\n+      break;\n+\n     default:\n     normal:\n       temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n@@ -9519,7 +9603,7 @@ do_jump (exp, if_false_label, if_true_label)\n \t    emit_jump (target);\n \t}\n       else if (GET_MODE_CLASS (GET_MODE (temp)) == MODE_INT\n-\t       && ! can_compare_p (GET_MODE (temp), ccp_jump))\n+\t       && ! can_compare_p (NE, GET_MODE (temp), ccp_jump))\n \t/* Note swapping the labels gives us not-equal.  */\n \tdo_jump_by_parts_equality_rtx (temp, if_true_label, if_false_label);\n       else if (GET_MODE (temp) != VOIDmode)\n@@ -10059,6 +10143,32 @@ do_store_flag (exp, target, mode, only_cheap)\n       else\n \tcode = unsignedp ? GEU : GE;\n       break;\n+\n+    case UNORDERED_EXPR:\n+      code = UNORDERED;\n+      break;\n+    case ORDERED_EXPR:\n+      code = ORDERED;\n+      break;\n+    case UNLT_EXPR:\n+      code = UNLT;\n+      break;\n+    case UNLE_EXPR:\n+      code = UNLE;\n+      break;\n+    case UNGT_EXPR:\n+      code = UNGT;\n+      break;\n+    case UNGE_EXPR:\n+      code = UNGE;\n+      break;\n+    case UNEQ_EXPR:\n+      code = UNEQ;\n+      break;\n+    case UNNE_EXPR:\n+      code = UNNE;\n+      break;\n+\n     default:\n       abort ();\n     }\n@@ -10134,8 +10244,9 @@ do_store_flag (exp, target, mode, only_cheap)\n     }\n \n   /* Now see if we are likely to be able to do this.  Return if not.  */\n-  if (! can_compare_p (operand_mode, ccp_store_flag))\n+  if (! can_compare_p (code, operand_mode, ccp_store_flag))\n     return 0;\n+\n   icode = setcc_gen_code[(int) code];\n   if (icode == CODE_FOR_nothing\n       || (only_cheap && insn_data[(int) icode].operand[0].mode != mode))"}, {"sha": "95c694210ce788057d4e7edfa04c5d236f736191", "filename": "gcc/expr.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -499,34 +499,39 @@ enum libfunc_index\n   LTI_gehf2,\n   LTI_lthf2,\n   LTI_lehf2,\n+  LTI_unordhf2,\n \n   LTI_eqsf2,\n   LTI_nesf2,\n   LTI_gtsf2,\n   LTI_gesf2,\n   LTI_ltsf2,\n   LTI_lesf2,\n+  LTI_unordsf2,\n \n   LTI_eqdf2,\n   LTI_nedf2,\n   LTI_gtdf2,\n   LTI_gedf2,\n   LTI_ltdf2,\n   LTI_ledf2,\n+  LTI_unorddf2,\n \n   LTI_eqxf2,\n   LTI_nexf2,\n   LTI_gtxf2,\n   LTI_gexf2,\n   LTI_ltxf2,\n   LTI_lexf2,\n+  LTI_unordxf2,\n \n   LTI_eqtf2,\n   LTI_netf2,\n   LTI_gttf2,\n   LTI_getf2,\n   LTI_lttf2,\n   LTI_letf2,\n+  LTI_unordtf2,\n \n   LTI_floatsisf,\n   LTI_floatdisf,\n@@ -627,34 +632,39 @@ extern rtx libfunc_table[LTI_MAX];\n #define gehf2_libfunc\t(libfunc_table[LTI_gehf2])\n #define lthf2_libfunc\t(libfunc_table[LTI_lthf2])\n #define lehf2_libfunc\t(libfunc_table[LTI_lehf2])\n+#define unordhf2_libfunc\t(libfunc_table[LTI_unordhf2])\n \n #define eqsf2_libfunc\t(libfunc_table[LTI_eqsf2])\n #define nesf2_libfunc\t(libfunc_table[LTI_nesf2])\n #define gtsf2_libfunc\t(libfunc_table[LTI_gtsf2])\n #define gesf2_libfunc\t(libfunc_table[LTI_gesf2])\n #define ltsf2_libfunc\t(libfunc_table[LTI_ltsf2])\n #define lesf2_libfunc\t(libfunc_table[LTI_lesf2])\n+#define unordsf2_libfunc\t(libfunc_table[LTI_unordsf2])\n \n #define eqdf2_libfunc\t(libfunc_table[LTI_eqdf2])\n #define nedf2_libfunc\t(libfunc_table[LTI_nedf2])\n #define gtdf2_libfunc\t(libfunc_table[LTI_gtdf2])\n #define gedf2_libfunc\t(libfunc_table[LTI_gedf2])\n #define ltdf2_libfunc\t(libfunc_table[LTI_ltdf2])\n #define ledf2_libfunc\t(libfunc_table[LTI_ledf2])\n+#define unorddf2_libfunc\t(libfunc_table[LTI_unorddf2])\n \n #define eqxf2_libfunc\t(libfunc_table[LTI_eqxf2])\n #define nexf2_libfunc\t(libfunc_table[LTI_nexf2])\n #define gtxf2_libfunc\t(libfunc_table[LTI_gtxf2])\n #define gexf2_libfunc\t(libfunc_table[LTI_gexf2])\n #define ltxf2_libfunc\t(libfunc_table[LTI_ltxf2])\n #define lexf2_libfunc\t(libfunc_table[LTI_lexf2])\n+#define unordxf2_libfunc\t(libfunc_table[LTI_unordxf2])\n \n #define eqtf2_libfunc\t(libfunc_table[LTI_eqtf2])\n #define netf2_libfunc\t(libfunc_table[LTI_netf2])\n #define gttf2_libfunc\t(libfunc_table[LTI_gttf2])\n #define getf2_libfunc\t(libfunc_table[LTI_getf2])\n #define lttf2_libfunc\t(libfunc_table[LTI_lttf2])\n #define letf2_libfunc\t(libfunc_table[LTI_letf2])\n+#define unordtf2_libfunc\t(libfunc_table[LTI_unordtf2])\n \n #define floatsisf_libfunc\t(libfunc_table[LTI_floatsisf])\n #define floatdisf_libfunc\t(libfunc_table[LTI_floatdisf])\n@@ -795,9 +805,11 @@ enum can_compare_purpose\n   ccp_cmov,\n   ccp_store_flag\n };\n+\n /* Nonzero if a compare of mode MODE can be done straightforwardly\n    (without splitting it into pieces).  */\n-extern int can_compare_p PARAMS ((enum machine_mode, enum can_compare_purpose));\n+extern int can_compare_p PARAMS ((enum rtx_code, enum machine_mode,\n+\t\t\t\t  enum can_compare_purpose));\n \n extern void prepare_cmp_insn PARAMS ((rtx *, rtx *, enum rtx_code *, rtx,\n \t\t\t\t      enum machine_mode *, int *, int,\n@@ -885,6 +897,7 @@ extern rtx gen_cond_trap PARAMS ((enum rtx_code, rtx, rtx, rtx));\n /* Functions from builtins.c:  */\n #ifdef TREE_CODE\n extern rtx expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n+extern tree expand_tree_builtin PARAMS ((tree, tree, tree));\n extern void std_expand_builtin_va_start PARAMS ((int, tree, rtx));\n extern rtx std_expand_builtin_va_arg PARAMS ((tree, tree));\n extern rtx expand_builtin_va_arg PARAMS ((tree, tree));"}, {"sha": "d07124462628033ced863ccc2a00ad51b88bb9ce", "filename": "gcc/fp-test.c", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Ffp-test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Ffp-test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffp-test.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -1,23 +1,23 @@\n /* fp-test.c - Check that all floating-point operations are available.\n-   Copyright (C) 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 2000 Free Software Foundation, Inc.\n    Contributed by Ronald F. Guilmette <rfg@monkeys.com>.\n \n-This file is part of GNU CC.\n+   This file is part of GNU CC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n \n /* This is a trivial test program which may be useful to people who are\n    porting the GCC or G++ compilers to a new system.  The intent here is\n@@ -104,6 +104,13 @@ main ()\n   si = f1 >= f2;\n   si = f1 <= f2;\n \n+  si = __builtin_isgreater (f1, f2);\n+  si = __builtin_isgreaterequal (f1, f2);\n+  si = __builtin_isless (f1, f2);\n+  si = __builtin_islessequal (f1, f2);\n+  si = __builtin_islessgreater (f1, f2);\n+  si = __builtin_isunordered (f1, f2);\n+\n   sc = f1;\n   uc = f1;\n   ss = f1;\n@@ -143,6 +150,13 @@ main ()\n   si = d1 >= d2;\n   si = d1 <= d2;\n \n+  si = __builtin_isgreater (d1, d2);\n+  si = __builtin_isgreaterequal (d1, d2);\n+  si = __builtin_isless (d1, d2);\n+  si = __builtin_islessequal (d1, d2);\n+  si = __builtin_islessgreater (d1, d2);\n+  si = __builtin_isunordered (d1, d2);\n+\n   sc = d1;\n   uc = d1;\n   ss = d1;\n@@ -182,6 +196,13 @@ main ()\n   si = D1 >= D2;\n   si = D1 <= D2;\n \n+  si = __builtin_isgreater (D1, D2);\n+  si = __builtin_isgreaterequal (D1, D2);\n+  si = __builtin_isless (D1, D2);\n+  si = __builtin_islessequal (D1, D2);\n+  si = __builtin_islessgreater (D1, D2);\n+  si = __builtin_isunordered (D1, D2);\n+\n   sc = D1;\n   uc = D1;\n   ss = D1;"}, {"sha": "bd22231fcfad0ea22a2f3bf3e828db2aa8b20b73", "filename": "gcc/jump.c", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -3429,11 +3429,12 @@ can_reverse_comparison_p (comparison, insn)\n \t      && GET_MODE_CLASS (GET_MODE (arg0)) != MODE_FLOAT));\n }\n \n-/* Given an rtx-code for a comparison, return the code\n-   for the negated comparison.\n-   WATCH OUT!  reverse_condition is not safe to use on a jump\n-   that might be acting on the results of an IEEE floating point comparison,\n-   because of the special treatment of non-signaling nans in comparisons.  \n+/* Given an rtx-code for a comparison, return the code for the negated\n+   comparison.  If no such code exists, return UNKNOWN.\n+\n+   WATCH OUT!  reverse_condition is not safe to use on a jump that might\n+   be acting on the results of an IEEE floating point comparison, because\n+   of the special treatment of non-signaling nans in comparisons.  \n    Use can_reverse_comparison_p to be sure.  */\n \n enum rtx_code\n@@ -3444,37 +3445,39 @@ reverse_condition (code)\n     {\n     case EQ:\n       return NE;\n-\n     case NE:\n       return EQ;\n-\n     case GT:\n       return LE;\n-\n     case GE:\n       return LT;\n-\n     case LT:\n       return GE;\n-\n     case LE:\n       return GT;\n-\n     case GTU:\n       return LEU;\n-\n     case GEU:\n       return LTU;\n-\n     case LTU:\n       return GEU;\n-\n     case LEU:\n       return GTU;\n+    case UNORDERED:\n+      return ORDERED;\n+    case ORDERED:\n+      return UNORDERED;\n+\n+    case UNLT:\n+    case UNLE:\n+    case UNGT:\n+    case UNGE:\n+    case UNEQ:\n+    case UNNE:\n+      return UNKNOWN;\n \n     default:\n       abort ();\n-      return UNKNOWN;\n     }\n }\n \n@@ -3489,35 +3492,40 @@ swap_condition (code)\n     {\n     case EQ:\n     case NE:\n+    case UNORDERED:\n+    case ORDERED:\n+    case UNEQ:\n+    case UNNE:\n       return code;\n \n     case GT:\n       return LT;\n-\n     case GE:\n       return LE;\n-\n     case LT:\n       return GT;\n-\n     case LE:\n       return GE;\n-\n     case GTU:\n       return LTU;\n-\n     case GEU:\n       return LEU;\n-\n     case LTU:\n       return GTU;\n-\n     case LEU:\n       return GEU;\n \n+    case UNLT:\n+      return UNGT;\n+    case UNLE:\n+      return UNGE;\n+    case UNGT:\n+      return UNLT;\n+    case UNGE:\n+      return UNLE;\n+\n     default:\n       abort ();\n-      return UNKNOWN;\n     }\n }\n \n@@ -5272,10 +5280,11 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t  if (rtx_equal_for_thread_p (b1op0, b2op0, b2)\n \t      && rtx_equal_for_thread_p (b1op1, b2op1, b2)\n \t      && (comparison_dominates_p (code1, code2)\n-\t\t  || (comparison_dominates_p (code1, reverse_condition (code2))\n-\t\t      && can_reverse_comparison_p (XEXP (SET_SRC (PATTERN (b1)),\n-\t\t\t\t\t\t\t 0),\n-\t\t\t\t\t\t   b1))))\n+\t\t  || (can_reverse_comparison_p (XEXP (SET_SRC (PATTERN (b1)),\n+\t\t\t\t\t\t      0),\n+\t\t\t\t\t\tb1)\n+\t\t      && comparison_dominates_p (code1, reverse_condition (code2)))))\n+\n \t    {\n \t      t1 = prev_nonnote_insn (b1);\n \t      t2 = prev_nonnote_insn (b2);"}, {"sha": "152f9cf2f1b8dbfe3341947b127be38c9cc75ddb", "filename": "gcc/loop.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -9163,6 +9163,8 @@ get_condition (jump, earliest)\n \t  if (reverse_code)\n \t    {\n \t      code = reverse_condition (code);\n+\t      if (code == UNKNOWN)\n+\t\treturn 0;\n \t      did_reverse_condition ^= 1;\n \t      reverse_code = 0;\n \t    }\n@@ -9227,9 +9229,10 @@ get_condition (jump, earliest)\n     }\n \n   /* If this was floating-point and we reversed anything other than an\n-     EQ or NE, return zero.  */\n+     EQ or NE or (UN)ORDERED, return zero.  */\n   if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-      && did_reverse_condition && code != NE && code != EQ\n+      && did_reverse_condition\n+      && code != NE && code != EQ && code != UNORDERED && code != ORDERED\n       && ! flag_fast_math\n       && GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n     return 0;"}, {"sha": "df08316a32559f31bcee3c777ea8f8dc36d69fd6", "filename": "gcc/optabs.c", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -2325,7 +2325,8 @@ expand_abs (mode, op0, target, safe)\n \n   /* If this mode is an integer too wide to compare properly,\n      compare word by word.  Rely on CSE to optimize constant cases.  */\n-  if (GET_MODE_CLASS (mode) == MODE_INT && ! can_compare_p (mode, ccp_jump))\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && ! can_compare_p (GE, mode, ccp_jump))\n     do_jump_by_parts_greater_rtx (mode, 0, target, const0_rtx, \n \t\t\t\t  NULL_RTX, op1);\n   else\n@@ -2840,18 +2841,31 @@ emit_0_to_1_insn (x)\n }\n \n /* Nonzero if we can perform a comparison of mode MODE straightforwardly.\n-   If FOR_JUMP is nonzero, we will be generating a jump based on this\n-   comparison, otherwise a store-flags operation.  */\n+   PURPOSE describes how this comparison will be used.  CODE is the rtx\n+   comparison code we will be using.\n+\n+   ??? Actually, CODE is slightly weaker than that.  A target is still\n+   required to implement all of the normal bcc operations, but not \n+   required to implement all (or any) of the unordered bcc operations.  */\n   \n int\n-can_compare_p (mode, purpose)\n+can_compare_p (code, mode, purpose)\n+     enum rtx_code code;\n      enum machine_mode mode;\n      enum can_compare_purpose purpose;\n {\n   do\n     {\n       if (cmp_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n-\treturn 1;\n+\t{\n+\t  if (purpose == ccp_jump)\n+\t    return bcc_gen_fctn[(int)code] != NULL;\n+\t  else if (purpose == ccp_store_flag)\n+\t    return setcc_gen_code[(int)code] != CODE_FOR_nothing;\n+\t  else\n+\t    /* There's only one cmov entry point, and it's allowed to fail.  */\n+\t    return 1;\n+\t}\n       if (purpose == ccp_jump\n \t  && cbranch_optab->handlers[(int)mode].insn_code != CODE_FOR_nothing)\n \treturn 1;\n@@ -3016,7 +3030,7 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align,\n \n   *px = x;\n   *py = y;\n-  if (can_compare_p (mode, purpose))\n+  if (can_compare_p (*pcomparison, mode, purpose))\n     return;\n \n   /* Handle a lib call just for the mode we are using.  */\n@@ -3267,6 +3281,10 @@ prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n \tlibfunc = lehf2_libfunc;\n \tbreak;\n \n+      case UNORDERED:\n+\tlibfunc = unordhf2_libfunc;\n+\tbreak;\n+\n       default:\n \tbreak;\n       }\n@@ -3297,6 +3315,10 @@ prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n \tlibfunc = lesf2_libfunc;\n \tbreak;\n \n+      case UNORDERED:\n+\tlibfunc = unordsf2_libfunc;\n+\tbreak;\n+\n       default:\n \tbreak;\n       }\n@@ -3327,6 +3349,10 @@ prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n \tlibfunc = ledf2_libfunc;\n \tbreak;\n \n+      case UNORDERED:\n+\tlibfunc = unorddf2_libfunc;\n+\tbreak;\n+\n       default:\n \tbreak;\n       }\n@@ -3357,6 +3383,10 @@ prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n \tlibfunc = lexf2_libfunc;\n \tbreak;\n \n+      case UNORDERED:\n+\tlibfunc = unordxf2_libfunc;\n+\tbreak;\n+\n       default:\n \tbreak;\n       }\n@@ -3387,6 +3417,10 @@ prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n \tlibfunc = letf2_libfunc;\n \tbreak;\n \n+      case UNORDERED:\n+\tlibfunc = unordtf2_libfunc;\n+\tbreak;\n+\n       default:\n \tbreak;\n       }\n@@ -3415,8 +3449,7 @@ prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n   if (libfunc == 0)\n     abort ();\n \n-  emit_library_call (libfunc, 1,\n-\t\t     word_mode, 2, x, mode, y, mode);\n+  emit_library_call (libfunc, 1, word_mode, 2, x, mode, y, mode);\n \n   /* Immediately move the result of the libcall into a pseudo\n      register so reload doesn't clobber the value if it needs\n@@ -3426,8 +3459,10 @@ prepare_float_lib_cmp (px, py, pcomparison, pmode, punsignedp)\n   *px = result;\n   *py = const0_rtx;\n   *pmode = word_mode;\n+  if (comparison == UNORDERED)\n+    *pcomparison = NE;\n #ifdef FLOAT_LIB_COMPARE_RETURNS_BOOL\n-  if (FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, comparison))\n+  else if (FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, comparison))\n     *pcomparison = NE;\n #endif\n   *punsignedp = 0;\n@@ -4650,34 +4685,39 @@ init_optabs ()\n   gehf2_libfunc = init_one_libfunc (\"__gehf2\");\n   lthf2_libfunc = init_one_libfunc (\"__lthf2\");\n   lehf2_libfunc = init_one_libfunc (\"__lehf2\");\n+  unordhf2_libfunc = init_one_libfunc (\"__unordhf2\");\n \n   eqsf2_libfunc = init_one_libfunc (\"__eqsf2\");\n   nesf2_libfunc = init_one_libfunc (\"__nesf2\");\n   gtsf2_libfunc = init_one_libfunc (\"__gtsf2\");\n   gesf2_libfunc = init_one_libfunc (\"__gesf2\");\n   ltsf2_libfunc = init_one_libfunc (\"__ltsf2\");\n   lesf2_libfunc = init_one_libfunc (\"__lesf2\");\n+  unordsf2_libfunc = init_one_libfunc (\"__unordsf2\");\n \n   eqdf2_libfunc = init_one_libfunc (\"__eqdf2\");\n   nedf2_libfunc = init_one_libfunc (\"__nedf2\");\n   gtdf2_libfunc = init_one_libfunc (\"__gtdf2\");\n   gedf2_libfunc = init_one_libfunc (\"__gedf2\");\n   ltdf2_libfunc = init_one_libfunc (\"__ltdf2\");\n   ledf2_libfunc = init_one_libfunc (\"__ledf2\");\n+  unorddf2_libfunc = init_one_libfunc (\"__unorddf2\");\n \n   eqxf2_libfunc = init_one_libfunc (\"__eqxf2\");\n   nexf2_libfunc = init_one_libfunc (\"__nexf2\");\n   gtxf2_libfunc = init_one_libfunc (\"__gtxf2\");\n   gexf2_libfunc = init_one_libfunc (\"__gexf2\");\n   ltxf2_libfunc = init_one_libfunc (\"__ltxf2\");\n   lexf2_libfunc = init_one_libfunc (\"__lexf2\");\n+  unordxf2_libfunc = init_one_libfunc (\"__unordxf2\");\n \n   eqtf2_libfunc = init_one_libfunc (\"__eqtf2\");\n   netf2_libfunc = init_one_libfunc (\"__netf2\");\n   gttf2_libfunc = init_one_libfunc (\"__gttf2\");\n   getf2_libfunc = init_one_libfunc (\"__getf2\");\n   lttf2_libfunc = init_one_libfunc (\"__lttf2\");\n   letf2_libfunc = init_one_libfunc (\"__letf2\");\n+  unordtf2_libfunc = init_one_libfunc (\"__unordtf2\");\n \n   floatsisf_libfunc = init_one_libfunc (\"__floatsisf\");\n   floatdisf_libfunc = init_one_libfunc (\"__floatdisf\");"}, {"sha": "94b72b810d21450fe659d8c674b09e3437579ffb", "filename": "gcc/rtl.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -737,6 +737,18 @@ DEF_RTL_EXPR(GTU, \"gtu\", \"ee\", '<')\n DEF_RTL_EXPR(LEU, \"leu\", \"ee\", '<')\n DEF_RTL_EXPR(LTU, \"ltu\", \"ee\", '<')\n \n+/* Additional floating point unordered comparision flavors.  */\n+DEF_RTL_EXPR(UNORDERED, \"unordered\", \"ee\", '<')\n+DEF_RTL_EXPR(ORDERED, \"ordered\", \"ee\", '<')\n+\n+/* These are equivalent to unordered or ... */\n+DEF_RTL_EXPR(UNNE, \"unne\", \"ee\", '<')\n+DEF_RTL_EXPR(UNEQ, \"uneq\", \"ee\", '<')\n+DEF_RTL_EXPR(UNGE, \"unge\", \"ee\", '<')\n+DEF_RTL_EXPR(UNGT, \"ungt\", \"ee\", '<')\n+DEF_RTL_EXPR(UNLE, \"unle\", \"ee\", '<')\n+DEF_RTL_EXPR(UNLT, \"unlt\", \"ee\", '<')\n+\n /* Represents the result of sign-extending the sole operand.\n    The machine modes of the operand and of the SIGN_EXTEND expression\n    determine how much sign-extension is going on.  */"}, {"sha": "20813131cc5b21d03fbe95a6b455822bd2849b23", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -1,3 +1,7 @@\n+2000-01-24  Richard Henderson  <rth@cygnus.com>\n+\n+\t* gcc.c-torture/execute/ieee/fp-cmp-4.c: New.\n+\n Thu Jan 20 12:34:48 2000  Jeffrey A Law  (law@cygnus.com)\n \n \t* gcc.c-torture/execute/20000120-2.c: New test."}, {"sha": "80342eefa9baa591788d6c6d922bbd57e6a47e7a", "filename": "gcc/testsuite/gcc.c-torture/execute/ieee/fp-cmp-4.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fieee%2Ffp-cmp-4.c?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -0,0 +1,131 @@\n+void\n+test_isunordered(double x, double y, int true)\n+{\n+  if (__builtin_isunordered(x, y))\n+    {\n+      if (! true)\n+\tabort ();\n+    }\n+  else\n+    {\n+      if (true)\n+\tabort ();\n+    }\n+}\n+\n+void\n+test_isless(double x, double y, int true)\n+{\n+  if (__builtin_isless(x, y))\n+    {\n+      if (! true)\n+\tabort ();\n+    }\n+  else\n+    {\n+      if (true)\n+\tabort ();\n+    }\n+}\n+\n+void\n+test_islessequal(double x, double y, int true)\n+{\n+  if (__builtin_islessequal(x, y))\n+    {\n+      if (! true)\n+\tabort ();\n+    }\n+  else\n+    {\n+      if (true)\n+\tabort ();\n+    }\n+}\n+\n+void\n+test_isgreater(double x, double y, int true)\n+{\n+  if (__builtin_isgreater(x, y))\n+    {\n+      if (! true)\n+\tabort ();\n+    }\n+  else\n+    {\n+      if (true)\n+\tabort ();\n+    }\n+}\n+\n+void\n+test_isgreaterequal(double x, double y, int true)\n+{\n+  if (__builtin_isgreaterequal(x, y))\n+    {\n+      if (! true)\n+\tabort ();\n+    }\n+  else\n+    {\n+      if (true)\n+\tabort ();\n+    }\n+}\n+\n+void\n+test_islessgreater(double x, double y, int true)\n+{\n+  if (__builtin_islessgreater(x, y))\n+    {\n+      if (! true)\n+\tabort ();\n+    }\n+  else\n+    {\n+      if (true)\n+\tabort ();\n+    }\n+}\n+\n+#define NAN (0.0 / 0.0)\n+\n+int\n+main()\n+{\n+  struct try\n+  {\n+    double x, y;\n+    unsigned unord : 1;\n+    unsigned lt : 1;\n+    unsigned le : 1;\n+    unsigned gt : 1;\n+    unsigned ge : 1;\n+    unsigned lg : 1;\n+  };\n+\n+  const struct try data[] =\n+  {\n+    { NAN, NAN, 1, 0, 0, 0, 0, 0 },\n+    { 0.0, NAN, 1, 0, 0, 0, 0, 0 },\n+    { NAN, 0.0, 1, 0, 0, 0, 0, 0 },\n+    { 0.0, 0.0, 0, 0, 1, 0, 1, 0 },\n+    { 1.0, 2.0, 0, 1, 1, 0, 0, 1 },\n+    { 2.0, 1.0, 0, 0, 0, 1, 1, 1 },\n+  };\n+\n+  const int n = sizeof(data) / sizeof(data[0]);\n+  int i;\n+\n+  for (i = 0; i < n; ++i)\n+    {\n+      test_isunordered (data[i].x, data[i].y, data[i].unord);\n+      test_isless (data[i].x, data[i].y, data[i].lt);\n+      test_islessequal (data[i].x, data[i].y, data[i].le);\n+      test_isgreater (data[i].x, data[i].y, data[i].gt);\n+      test_isgreaterequal (data[i].x, data[i].y, data[i].ge);\n+      test_islessgreater (data[i].x, data[i].y, data[i].lg);\n+    }\n+\n+  exit (0);\n+}"}, {"sha": "b4fb3cac6a123239a2dbadd6b3bc9fc4a90ba131", "filename": "gcc/tree.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -641,6 +641,18 @@ DEFTREECODE (GE_EXPR, \"ge_expr\", '<', 2)\n DEFTREECODE (EQ_EXPR, \"eq_expr\", '<', 2)\n DEFTREECODE (NE_EXPR, \"ne_expr\", '<', 2)\n \n+/* Additional relational operators for floating point unordered.  */\n+DEFTREECODE (UNORDERED_EXPR, \"unordered_expr\", '<', 2)\n+DEFTREECODE (ORDERED_EXPR, \"ordered_expr\", '<', 2)\n+\n+/* These are equivalent to unordered or ... */\n+DEFTREECODE (UNLT_EXPR, \"unlt_expr\", '<', 2)\n+DEFTREECODE (UNLE_EXPR, \"unle_expr\", '<', 2)\n+DEFTREECODE (UNGT_EXPR, \"ungt_expr\", '<', 2)\n+DEFTREECODE (UNGE_EXPR, \"unge_expr\", '<', 2)\n+DEFTREECODE (UNEQ_EXPR, \"uneq_expr\", '<', 2)\n+DEFTREECODE (UNNE_EXPR, \"unne_expr\", '<', 2)\n+\n /* Operations for Pascal sets.  Not used now.  */\n DEFTREECODE (IN_EXPR, \"in_expr\", '2', 2)\n DEFTREECODE (SET_LE_EXPR, \"set_le_expr\", '<', 2)"}, {"sha": "d6e51a0e485a739811589624191ee88527ca576e", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1eb8759b1bc0fd2a74ddbd83db1f01df1a35df69", "patch": "@@ -116,6 +116,14 @@ enum built_in_function\n   BUILT_IN_LONGJMP,\n   BUILT_IN_TRAP,\n \n+  /* ISO C99 floating point unordered comparisons.  */\n+  BUILT_IN_ISGREATER,\n+  BUILT_IN_ISGREATEREQUAL,\n+  BUILT_IN_ISLESS,\n+  BUILT_IN_ISLESSEQUAL,\n+  BUILT_IN_ISLESSGREATER,\n+  BUILT_IN_ISUNORDERED,\n+\n   /* Various hooks for the DWARF 2 __throw routine.  */\n   BUILT_IN_UNWIND_INIT,\n   BUILT_IN_DWARF_CFA,"}]}