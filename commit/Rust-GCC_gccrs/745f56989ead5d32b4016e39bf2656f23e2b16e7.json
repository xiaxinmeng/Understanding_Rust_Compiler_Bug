{"sha": "745f56989ead5d32b4016e39bf2656f23e2b16e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ1ZjU2OTg5ZWFkNWQzMmI0MDE2ZTM5YmYyNjU2ZjIzZTJiMTZlNw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2020-05-26T19:39:38Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-10T09:16:18Z"}, "message": "[Ada] Part of implementation of AI12-0212: container aggregates\n\ngcc/ada/\n\n\t* aspects.ads: Add Aspect_Aggregate.\n\t* exp_aggr.adb (Expand_Container_Aggregate): Expand positional\n\tcontainer aggregates into separate initialization and insertion\n\toperations.\n\t* sem_aggr.ads (Resolve_Container_Aggregate): New subprogram.\n\t* sem_aggr.adb (Resolve_Container_Aggregate): Parse aspect\n\taggregate, establish element types and key types if present, and\n\tresolve aggregate components.\n\t* sem_ch13.ads (Parse_Aspect_Aggregate): Public subprogram used\n\tin validation, resolution and expansion of container aggregates\n\t* sem_ch13.adb\n\t(Parse_Aspect_Aggregate): Retrieve names of primitives specified\n\tin aspect specification.\n\t(Validate_Aspect_Aggregate): Check legality of specified\n\toperations given in aspect specification, before nane\n\tresolution.\n\t(Resolve_Aspect_Aggregate): At freeze point resolve operations\n\tand verify that given operations have the required profile.\n\t* sem_res.adb (Resolve): Call Resolve_Aspect_Aggregate if aspect\n\tis present for type.\n\t* snames.ads-tmpl: Add names used in aspect Aggregate: Empty,\n\tAdd_Named, Add_Unnamed, New_Indexed, Assign_Indexed.", "tree": {"sha": "5bd171fd34ae57a8e0bd9d2d71f2111add18f5c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bd171fd34ae57a8e0bd9d2d71f2111add18f5c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/745f56989ead5d32b4016e39bf2656f23e2b16e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/745f56989ead5d32b4016e39bf2656f23e2b16e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/745f56989ead5d32b4016e39bf2656f23e2b16e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/745f56989ead5d32b4016e39bf2656f23e2b16e7/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f9821a09ac0c5f07ce621ef6a32acfdfa2e485e"}], "stats": {"total": 462, "additions": 460, "deletions": 2}, "files": [{"sha": "4e517d1fb5b2a31cbbab25bb3ddf971f1de4b659", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=745f56989ead5d32b4016e39bf2656f23e2b16e7", "patch": "@@ -76,6 +76,7 @@ package Aspects is\n      (No_Aspect,                            -- Dummy entry for no aspect\n       Aspect_Abstract_State,                -- GNAT\n       Aspect_Address,\n+      Aspect_Aggregate,\n       Aspect_Alignment,\n       Aspect_Annotate,                      -- GNAT\n       Aspect_Async_Readers,                 -- GNAT\n@@ -300,6 +301,7 @@ package Aspects is\n       Aspect_Iterator_Element           => True,\n       Aspect_Iterable                   => True,\n       Aspect_Variable_Indexing          => True,\n+      Aspect_Aggregate                  => True,\n       others                            => False);\n \n    --  The following array indicates aspects for which multiple occurrences of\n@@ -345,6 +347,7 @@ package Aspects is\n      (No_Aspect                         => Optional_Expression,\n       Aspect_Abstract_State             => Expression,\n       Aspect_Address                    => Expression,\n+      Aspect_Aggregate                  => Expression,\n       Aspect_Alignment                  => Expression,\n       Aspect_Annotate                   => Expression,\n       Aspect_Async_Readers              => Optional_Expression,\n@@ -442,6 +445,7 @@ package Aspects is\n      (No_Aspect                           => False,\n       Aspect_Abstract_State               => False,\n       Aspect_Address                      => True,\n+      Aspect_Aggregate                    => False,\n       Aspect_Alignment                    => True,\n       Aspect_Annotate                     => False,\n       Aspect_Async_Readers                => False,\n@@ -580,6 +584,7 @@ package Aspects is\n      (No_Aspect                           => No_Name,\n       Aspect_Abstract_State               => Name_Abstract_State,\n       Aspect_Address                      => Name_Address,\n+      Aspect_Aggregate                    => Name_Aggregate,\n       Aspect_Alignment                    => Name_Alignment,\n       Aspect_All_Calls_Remote             => Name_All_Calls_Remote,\n       Aspect_Annotate                     => Name_Annotate,\n@@ -828,6 +833,7 @@ package Aspects is\n    Aspect_Delay : constant array (Aspect_Id) of Delay_Type :=\n      (No_Aspect                           => Always_Delay,\n       Aspect_Address                      => Always_Delay,\n+      Aspect_Aggregate                    => Always_Delay,\n       Aspect_All_Calls_Remote             => Always_Delay,\n       Aspect_Asynchronous                 => Always_Delay,\n       Aspect_Attach_Handler               => Always_Delay,"}, {"sha": "eb5cc29e44f91cf90f9e2e85fc3a101b8df71475", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=745f56989ead5d32b4016e39bf2656f23e2b16e7", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n@@ -52,6 +53,7 @@ with Sem;      use Sem;\n with Sem_Aggr; use Sem_Aggr;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n@@ -86,6 +88,7 @@ package body Exp_Aggr is\n \n    procedure Expand_Delta_Array_Aggregate  (N : Node_Id; Deltas : List_Id);\n    procedure Expand_Delta_Record_Aggregate (N : Node_Id; Deltas : List_Id);\n+   procedure Expand_Container_Aggregate (N : Node_Id);\n \n    function Get_Base_Object (N : Node_Id) return Entity_Id;\n    --  Return the base object, i.e. the outermost prefix object, that N refers\n@@ -6740,6 +6743,9 @@ package body Exp_Aggr is\n       if Is_Record_Type (Etype (N)) then\n          Expand_Record_Aggregate (N);\n \n+      elsif Has_Aspect (Etype (N), Aspect_Aggregate) then\n+         Expand_Container_Aggregate (N);\n+\n       --  Array aggregate case\n \n       else\n@@ -6839,6 +6845,73 @@ package body Exp_Aggr is\n          return;\n    end Expand_N_Aggregate;\n \n+   --------------------------------\n+   -- Expand_Container_Aggregate --\n+   --------------------------------\n+\n+   procedure Expand_Container_Aggregate (N : Node_Id) is\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      Typ   : constant Entity_Id := Etype (N);\n+      Asp   : constant Node_Id := Find_Value_Of_Aspect (Typ, Aspect_Aggregate);\n+\n+      Empty_Subp          : Node_Id := Empty;\n+      Add_Named_Subp      : Node_Id := Empty;\n+      Add_Unnamed_Subp    : Node_Id := Empty;\n+      New_Indexed_Subp    : Node_Id := Empty;\n+      Assign_Indexed_Subp : Node_Id := Empty;\n+\n+      Aggr_Code  : constant List_Id := New_List;\n+      Temp       : constant Entity_Id :=  Make_Temporary (Loc, 'C', N);\n+\n+      Decl      : Node_Id;\n+      Init_Stat  : Node_Id;\n+   begin\n+      Parse_Aspect_Aggregate (Asp,\n+        Empty_Subp, Add_Named_Subp, Add_Unnamed_Subp,\n+        New_Indexed_Subp, Assign_Indexed_Subp);\n+      Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Temp,\n+          Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+\n+         Insert_Action (N, Decl);\n+         if Ekind (Entity (Empty_Subp)) = E_Constant then\n+            Init_Stat := Make_Assignment_Statement (Loc,\n+              Name => New_Occurrence_Of (Temp, Loc),\n+              Expression => Make_Function_Call (Loc,\n+                Name => New_Occurrence_Of (Entity (Empty_Subp), Loc)));\n+         else\n+            Init_Stat := Make_Assignment_Statement (Loc,\n+              Name => New_Occurrence_Of (Temp, Loc),\n+              Expression => New_Occurrence_Of (Entity (Empty_Subp), Loc));\n+         end if;\n+         Append (Init_Stat, Aggr_Code);\n+\n+         --  First case : positional aggregate.\n+\n+         if Present (Expressions (N)) then\n+            declare\n+               Insert : constant Entity_Id := Entity (Add_Unnamed_Subp);\n+               Comp   : Node_Id;\n+               Stat   : Node_Id;\n+            begin\n+               Comp := First (Expressions (N));\n+               while Present (Comp) loop\n+                  Stat := Make_Procedure_Call_Statement (Loc,\n+                    Name => New_Occurrence_Of (Insert, Loc),\n+                    Parameter_Associations =>\n+                      New_List (New_Occurrence_Of (Temp, Loc),\n+                         New_Copy_Tree (Comp)));\n+                  Append (Stat, Aggr_Code);\n+                  Next (Comp);\n+               end loop;\n+            end;\n+         end if;\n+         Insert_Actions (N, Aggr_Code);\n+         Rewrite (N, New_Occurrence_Of (Temp, Loc));\n+         Analyze_And_Resolve (N, Typ);\n+   end Expand_Container_Aggregate;\n+\n    ------------------------------\n    -- Expand_N_Delta_Aggregate --\n    ------------------------------"}, {"sha": "ffe2ae66a772315d09b89e1489c57f65c505a7fb", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=745f56989ead5d32b4016e39bf2656f23e2b16e7", "patch": "@@ -2639,6 +2639,57 @@ package body Sem_Aggr is\n       return Success;\n    end Resolve_Array_Aggregate;\n \n+   ---------------------------------\n+   -- Resolve_Container_Aggregate --\n+   ---------------------------------\n+\n+   procedure Resolve_Container_Aggregate (N : Node_Id; Typ : Entity_Id) is\n+      Asp   : constant Node_Id := Find_Value_Of_Aspect (Typ, Aspect_Aggregate);\n+\n+      Empty_Subp          : Node_Id := Empty;\n+      Add_Named_Subp      : Node_Id := Empty;\n+      Add_Unnamed_Subp    : Node_Id := Empty;\n+      New_Indexed_Subp    : Node_Id := Empty;\n+      Assign_Indexed_Subp : Node_Id := Empty;\n+\n+   begin\n+      if Nkind (Asp) /= N_Aggregate then\n+         pragma Assert (False);\n+         return;\n+      else\n+         Set_Etype (N, Typ);\n+         Parse_Aspect_Aggregate (Asp,\n+           Empty_Subp, Add_Named_Subp, Add_Unnamed_Subp,\n+           New_Indexed_Subp, Assign_Indexed_Subp);\n+\n+         if Present (Add_Unnamed_Subp) then\n+            declare\n+               Elmt_Type : constant Entity_Id :=\n+                 Etype (Next_Formal\n+                   (First_Formal (Entity (Add_Unnamed_Subp))));\n+               Comp : Node_Id;\n+            begin\n+               if Present (Expressions (N)) then\n+                  --  positional aggregate\n+\n+                  Comp := First (Expressions (N));\n+                  while Present (Comp) loop\n+                     Analyze_And_Resolve (Comp, Elmt_Type);\n+                     Next (Comp);\n+                  end loop;\n+               else\n+\n+                  --  Empty aggregate, to be replaced by Empty during\n+                  --  expansion.\n+                  null;\n+               end if;\n+            end;\n+         else\n+            Error_Msg_N (\"indexed aggregates are forthcoming\", N);\n+         end if;\n+      end if;\n+   end Resolve_Container_Aggregate;\n+\n    -----------------------------\n    -- Resolve_Delta_Aggregate --\n    -----------------------------"}, {"sha": "b0b4e147fe575fe8db66ad887856690ba8432a9f", "filename": "gcc/ada/sem_aggr.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsem_aggr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsem_aggr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.ads?ref=745f56989ead5d32b4016e39bf2656f23e2b16e7", "patch": "@@ -33,6 +33,7 @@ package Sem_Aggr is\n    procedure Resolve_Delta_Aggregate     (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Aggregate           (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Extension_Aggregate (N : Node_Id; Typ : Entity_Id);\n+   procedure Resolve_Container_Aggregate (N : Node_Id; Typ : Entity_Id);\n \n    function Is_Others_Aggregate (Aggr : Node_Id) return Boolean;\n    --  Returns True is aggregate Aggr consists of a single OTHERS choice"}, {"sha": "c6a177d21b3f1900bca379d12ff5330980d929f5", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 298, "deletions": 2, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=745f56989ead5d32b4016e39bf2656f23e2b16e7", "patch": "@@ -242,6 +242,16 @@ package body Sem_Ch13 is\n    --  Register a check for the address clause N. The rest of the parameters\n    --  are in keeping with the components of Address_Clause_Check_Record below.\n \n+   procedure Validate_Aspect_Aggregate (N : Node_Id);\n+   --  Check legality of operations given in the Ada_2020 Aggregate aspect\n+   --  for containers.\n+\n+   procedure Resolve_Aspect_Aggregate\n+    (Typ  : Entity_Id;\n+     Expr : Node_Id);\n+   --  Resolve each one of the operations specified in the specification of\n+   --  Aspect_Aggregate.\n+\n    procedure Resolve_Iterable_Operation\n      (N      : Node_Id;\n       Cursor : Entity_Id;\n@@ -1471,6 +1481,9 @@ package body Sem_Ch13 is\n                   when Aspect_Iterable =>\n                      Validate_Iterable_Aspect (E, ASN);\n \n+                  when Aspect_Aggregate =>\n+                     null;\n+\n                   when others =>\n                      null;\n                end case;\n@@ -4043,6 +4056,11 @@ package body Sem_Ch13 is\n \n                   Aitem := Empty;\n \n+               when Aspect_Aggregate =>\n+                  Validate_Aspect_Aggregate (Expr);\n+                  Record_Rep_Item (E, Aspect);\n+                  return;\n+\n                when Aspect_Integer_Literal\n                   | Aspect_Real_Literal\n                   | Aspect_String_Literal\n@@ -5193,8 +5211,9 @@ package body Sem_Ch13 is\n          Indexing_Found : Boolean := False;\n \n          procedure Check_Inherited_Indexing;\n-         --  For a derived type, check that no indexing aspect is specified\n-         --  for the type if it is also inherited\n+         --  For a derived type, check tha for a derived type a specification\n+         --  of an indexing aspect can only be confirming, i.e. uses the\n+         --  the same name as in the parent type.\n          --  AI12-0160: verify that an indexing cannot be specified for\n          --  a derived type unless it is specified for the parent.\n \n@@ -6613,6 +6632,7 @@ package body Sem_Ch13 is\n               or else not Is_Type (Entity (Expr))\n             then\n                Error_Msg_N (\"aspect Iterator_Element must be a type\", Expr);\n+               return;\n             end if;\n \n          -------------------\n@@ -10542,6 +10562,10 @@ package body Sem_Ch13 is\n \n             return;\n \n+         when Aspect_Aggregate =>\n+            Resolve_Aspect_Aggregate (Entity (ASN), Expr);\n+            return;\n+\n          --  Invariant/Predicate take boolean expressions\n \n          when Aspect_Dynamic_Predicate\n@@ -14329,6 +14353,9 @@ package body Sem_Ch13 is\n             begin\n                case A_Id is\n \n+                  when Aspect_Aggregate =>\n+                     Resolve_Aspect_Aggregate (Entity (ASN), Expr);\n+\n                   --  For now we only deal with aspects that do not generate\n                   --  subprograms, or that may mention current instances of\n                   --  types. These will require special handling (???TBD).\n@@ -14642,6 +14669,92 @@ package body Sem_Ch13 is\n       end if;\n    end Same_Representation;\n \n+   ----------------------------\n+   -- Parse_Aspect_Aggregate --\n+   ----------------------------\n+\n+   procedure Parse_Aspect_Aggregate\n+     (N                   : Node_Id;\n+      Empty_Subp          : in out Node_Id;\n+      Add_Named_Subp      : in out Node_Id;\n+      Add_Unnamed_Subp    : in out Node_Id;\n+      New_Indexed_Subp    : in out Node_Id;\n+      Assign_Indexed_Subp : in out Node_Id)\n+   is\n+      Assoc   : Node_Id := First (Component_Associations (N));\n+      Op_Name : Name_Id;\n+      Subp    : Node_Id;\n+\n+   begin\n+      while Present (Assoc) loop\n+         Subp := Expression (Assoc);\n+         Op_Name := Chars (First (Choices (Assoc)));\n+         if Op_Name = Name_Empty then\n+            Empty_Subp := Subp;\n+\n+         elsif Op_Name = Name_Add_Named then\n+            Add_Named_Subp := Subp;\n+\n+         elsif Op_Name = Name_Add_Unnamed then\n+            Add_Unnamed_Subp := Subp;\n+\n+         elsif Op_Name = Name_New_Indexed then\n+            New_Indexed_Subp :=  Subp;\n+\n+         elsif Op_Name = Name_Assign_Indexed then\n+            Assign_Indexed_Subp := Subp;\n+         end if;\n+\n+         Next (Assoc);\n+      end loop;\n+   end Parse_Aspect_Aggregate;\n+\n+   -------------------------------\n+   -- Validate_Aspect_Aggregate --\n+   -------------------------------\n+\n+   procedure Validate_Aspect_Aggregate (N : Node_Id) is\n+      Empty_Subp          : Node_Id := Empty;\n+      Add_Named_Subp      : Node_Id := Empty;\n+      Add_Unnamed_Subp    : Node_Id := Empty;\n+      New_Indexed_Subp    : Node_Id := Empty;\n+      Assign_Indexed_Subp : Node_Id := Empty;\n+\n+   begin\n+      if Ada_Version < Ada_2020 then\n+         Error_Msg_N (\"Aspect Aggregate is an Ada_2020 feature\", N);\n+\n+      elsif Nkind (N) /= N_Aggregate\n+        or else Present (Expressions (N))\n+        or else No (Component_Associations (N))\n+      then\n+         Error_Msg_N (\"Aspect Aggregate requires an aggregate \"\n+                        & \"with component associations\", N);\n+         return;\n+      end if;\n+\n+      Parse_Aspect_Aggregate (N,\n+        Empty_Subp, Add_Named_Subp, Add_Unnamed_Subp,\n+        New_Indexed_Subp, Assign_Indexed_Subp);\n+\n+      if No (Empty_Subp) then\n+         Error_Msg_N (\"missing specification for Empty in aggregate\", N);\n+      end if;\n+\n+      if Present (Add_Named_Subp) then\n+         if Present (Add_Unnamed_Subp)\n+           or else Present (Assign_Indexed_Subp)\n+         then\n+            Error_Msg_N\n+             (\"conflicting operations for aggregate (RM 4.3.5)\", N);\n+            return;\n+         end if;\n+\n+      elsif Present (New_Indexed_Subp) /= Present (Assign_Indexed_Subp) then\n+         Error_Msg_N (\"incomplete specification for indexed aggregate\", N);\n+      end if;\n+   end Validate_Aspect_Aggregate;\n+\n    --------------------------------\n    -- Resolve_Iterable_Operation --\n    --------------------------------\n@@ -14803,6 +14916,189 @@ package body Sem_Ch13 is\n       end if;\n    end Resolve_Iterable_Operation;\n \n+   ------------------------------\n+   -- Resolve_Aspect_Aggregate --\n+   ------------------------------\n+\n+   procedure Resolve_Aspect_Aggregate\n+    (Typ :  Entity_Id;\n+     Expr : Node_Id)\n+   is\n+      --  Predicates that establish the legality of each possible\n+      --  operation in an Aggregate aspect.\n+\n+      function Valid_Empty          (E : Entity_Id) return Boolean;\n+      function Valid_Add_Named      (E : Entity_Id) return Boolean;\n+      function Valid_Add_Unnamed    (E : Entity_Id) return Boolean;\n+      function Valid_New_Indexed    (E : Entity_Id) return Boolean;\n+\n+      --  Note : the leglity rules for Assign_Indexed are the same\n+      --  as for Add_Named.\n+\n+      generic\n+        with function Pred (Id : Node_Id) return Boolean;\n+      procedure Resolve_Operation (Subp_Id : Node_Id);\n+      --  Common processing to resolve each aggregate operation.\n+\n+      -----------------\n+      -- Valid_Emoty --\n+      -----------------\n+\n+      function Valid_Empty (E :  Entity_Id) return Boolean is\n+      begin\n+         if Etype (E) /= Typ or else Scope (E) /= Scope (Typ)  then\n+            return False;\n+\n+         elsif Ekind (E) = E_Constant then\n+            return True;\n+\n+         elsif Ekind (E) = E_Function then\n+            return No (First_Formal (E))\n+              or else\n+               (Is_Integer_Type (Etype (First_Formal (E)))\n+                  and then No (Next_Formal (First_Formal (E))));\n+         else\n+            return False;\n+         end if;\n+      end Valid_Empty;\n+\n+      ---------------------\n+      -- Valid_Add_Named --\n+      ---------------------\n+\n+      function Valid_Add_Named  (E : Entity_Id) return Boolean is\n+         F2, F3 : Entity_Id;\n+      begin\n+         if Ekind (E) = E_Procedure\n+           and then Scope (E) = Scope (Typ)\n+           and then Number_Formals (E) = 3\n+           and then Etype (First_Formal (E)) = Typ\n+           and then Ekind (First_Formal (E)) = E_In_Out_Parameter\n+         then\n+            F2 := Next_Formal (First_Formal (E));\n+            F3 := Next_Formal (F2);\n+            return Ekind (F2) = E_In_Parameter\n+              and then Ekind (F3) = E_In_Parameter\n+              and then not Is_Limited_Type (Etype (F2))\n+              and then not Is_Limited_Type (Etype (F3));\n+         else\n+            return False;\n+         end if;\n+      end Valid_Add_Named;\n+\n+      -----------------------\n+      -- Valid_Add_Unnamed --\n+      -----------------------\n+\n+      function Valid_Add_Unnamed (E : Entity_Id) return Boolean is\n+      begin\n+         return Ekind (E) = E_Procedure\n+           and then Scope (E) = Scope (Typ)\n+           and then Number_Formals (E) = 2\n+           and then Etype (First_Formal (E)) = Typ\n+           and then Ekind (First_Formal (E)) = E_In_Out_Parameter\n+           and then\n+              not Is_Limited_Type (Etype (Next_Formal (First_Formal (E))));\n+      end Valid_Add_Unnamed;\n+\n+      -----------------------\n+      -- Valid_Nmw_Indexed --\n+      -----------------------\n+\n+      function Valid_New_Indexed (E : Entity_Id) return Boolean is\n+      begin\n+         return Ekind (E) = E_Function\n+           and then Scope (E) = Scope (Typ)\n+           and then Etype (E) = Typ\n+           and then Number_Formals (E) = 2\n+           and then Is_Discrete_Type (Etype (First_Formal (E)))\n+           and then Etype (First_Formal (E)) =\n+             Etype (Next_Formal (First_Formal (E)));\n+      end Valid_New_Indexed;\n+\n+      -----------------------\n+      -- Resolve_Operation --\n+      -----------------------\n+\n+      procedure Resolve_Operation (Subp_Id : Node_Id) is\n+         Subp : Entity_Id;\n+\n+         I  : Interp_Index;\n+         It : Interp;\n+\n+      begin\n+         if not Is_Overloaded (Subp_Id) then\n+            Subp := Entity (Subp_Id);\n+            if not Pred (Subp) then\n+               Error_Msg_NE\n+                 (\"improper aggregate operation for&\", Subp_Id, Typ);\n+            end if;\n+\n+         else\n+            Set_Entity (Subp_Id, Empty);\n+            Get_First_Interp (Subp_Id, I, It);\n+            while Present (It.Nam) loop\n+               if Pred (It.Nam) then\n+                  Set_Is_Overloaded (Subp_Id, False);\n+                  Set_Entity (Subp_Id, It.Nam);\n+                  exit;\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n+            end loop;\n+\n+            if No (Entity (Subp_Id)) then\n+               Error_Msg_NE\n+                 (\"improper aggregate operation for&\", Subp_Id, Typ);\n+            end if;\n+         end if;\n+      end Resolve_Operation;\n+\n+      Assoc   : Node_Id;\n+      Op_Name : Name_Id;\n+      Subp_Id : Node_Id;\n+\n+      procedure Resolve_Empty   is new Resolve_Operation (Valid_Empty);\n+      procedure Resolve_Unnamed is new Resolve_Operation (Valid_Add_Unnamed);\n+      procedure Resolve_Named   is new Resolve_Operation (Valid_Add_Named);\n+      procedure Resolve_Indexed is new Resolve_Operation (Valid_New_Indexed);\n+      procedure Resolve_Assign_Indexed\n+                                is new Resolve_Operation (Valid_Add_Named);\n+   begin\n+      Assoc := First (Component_Associations (Expr));\n+\n+      while Present (Assoc) loop\n+         Op_Name := Chars (First (Choices (Assoc)));\n+\n+         --  When verifying the consistency of aspects between\n+         --  the freeze point and the end of declarqtions, we\n+         --  use a copy which is not analyzed yet, so do it now.\n+\n+         Subp_Id := Expression (Assoc);\n+         if No (Etype (Subp_Id)) then\n+            Analyze (Subp_Id);\n+         end if;\n+\n+         if Op_Name = Name_Empty then\n+            Resolve_Empty (Subp_Id);\n+\n+         elsif Op_Name = Name_Add_Named then\n+            Resolve_Named (Subp_Id);\n+\n+         elsif Op_Name = Name_Add_Unnamed then\n+            Resolve_Unnamed (Subp_Id);\n+\n+         elsif Op_Name = Name_New_Indexed then\n+            Resolve_Indexed (Subp_Id);\n+\n+         elsif Op_Name = Name_Assign_Indexed then\n+            Resolve_Assign_Indexed (Subp_Id);\n+         end if;\n+\n+         Next (Assoc);\n+      end loop;\n+   end Resolve_Aspect_Aggregate;\n+\n    ----------------\n    -- Set_Biased --\n    ----------------"}, {"sha": "a08a1f4b6bf02da6e970f7aa794fdf0d4c7a13c2", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=745f56989ead5d32b4016e39bf2656f23e2b16e7", "patch": "@@ -128,6 +128,17 @@ package Sem_Ch13 is\n    --  If the size is too small, and an error message is given, then both\n    --  Esize and RM_Size are reset to the allowed minimum value in T.\n \n+   procedure Parse_Aspect_Aggregate\n+     (N                   : Node_Id;\n+      Empty_Subp          : in out Node_Id;\n+      Add_Named_Subp      : in out Node_Id;\n+      Add_Unnamed_Subp    : in out Node_Id;\n+      New_Indexed_Subp    : in out Node_Id;\n+      Assign_Indexed_Subp : in out Node_Id);\n+   --  Utility to unpack the subprogramz in an occurrence of asoect Aggregate,\n+   --  used to verify the structure of the asoect, and resolve and expand an\n+   --  aggregate for a container type that carries the asoect.\n+\n    function Rep_Item_Too_Early (T : Entity_Id; N : Node_Id) return Boolean;\n    --  Called at start of processing a representation clause/pragma. Used to\n    --  check that the representation item is not being applied to an incomplete"}, {"sha": "f76366d944b6fd2f152d4544fbb4d329f8641c0c", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=745f56989ead5d32b4016e39bf2656f23e2b16e7", "patch": "@@ -2776,6 +2776,17 @@ package body Sem_Res is\n             elsif Nkind (N) = N_Aggregate\n               and then Etype (N) = Any_Composite\n             then\n+               if Ada_Version >= Ada_2020\n+                 and then Has_Aspect (Typ, Aspect_Aggregate)\n+               then\n+                  Resolve_Container_Aggregate (N, Typ);\n+\n+                  if Expander_Active then\n+                     Expand (N);\n+                  end if;\n+                  return;\n+               end if;\n+\n                --  Disable expansion in any case. If there is a type mismatch\n                --  it may be fatal to try to expand the aggregate. The flag\n                --  would otherwise be set to false when the error is posted."}, {"sha": "c26ac32f7a2912e97310432caa6a36b08e81669b", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/745f56989ead5d32b4016e39bf2656f23e2b16e7/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=745f56989ead5d32b4016e39bf2656f23e2b16e7", "patch": "@@ -1550,6 +1550,15 @@ package Snames is\n    Name_Reference_Control_Type           : constant Name_Id := N + $;\n    Name_Get_Element_Access               : constant Name_Id := N + $;\n \n+   --  Names for Ada2020 Aggregate aspect. Nmme_Aggregate is already\n+   --  present for gprbuild.\n+\n+   Name_Empty                            : constant Name_Id := N + $;\n+   Name_Add_Named                        : constant Name_Id := N + $;\n+   Name_Add_Unnamed                      : constant Name_Id := N + $;\n+   Name_New_Indexed                      : constant Name_Id := N + $;\n+   Name_Assign_Indexed                   : constant Name_Id := N + $;\n+\n    --  Ada 2005 reserved words\n \n    First_2005_Reserved_Word              : constant Name_Id := N + $;"}]}