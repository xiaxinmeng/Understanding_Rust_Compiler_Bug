{"sha": "59909673d11f6e1a0655c360c96653e9b0a37b84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk5MDk2NzNkMTFmNmUxYTA2NTVjMzYwYzk2NjUzZTliMGEzN2I4NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-02-24T10:21:39Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-02-24T10:21:39Z"}, "message": "c-ada-spec.c (dump_ada_function_declaration): Add comment about the treatment of parameters with pointer-to-tagged type and...\n\nc-family/\n\t* c-ada-spec.c (dump_ada_function_declaration): Add comment about the\n\ttreatment of parameters with pointer-to-tagged type and tidy up.\n\t(print_ada_methods): Remove the special treatment of C++ static member\n\tfunctions.\nada/\n\t* gcc-interface/decl.c: Include demangle.h.\n\t(is_cplusplus_method): Return again true for a primitive operation\n\tonly if it is dispatching.  For a subprogram with an interface name,\n\tcall the demangler to get the number of C++ parameters and compare it\n\twith the number of Ada parameters.\n\nFrom-SVN: r245700", "tree": {"sha": "df12757df9ec86f21787ed3c08d95ad2187e1379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df12757df9ec86f21787ed3c08d95ad2187e1379"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59909673d11f6e1a0655c360c96653e9b0a37b84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59909673d11f6e1a0655c360c96653e9b0a37b84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59909673d11f6e1a0655c360c96653e9b0a37b84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59909673d11f6e1a0655c360c96653e9b0a37b84/comments", "author": null, "committer": null, "parents": [{"sha": "8ff873dcdc0b87cbb30a1a951384293cc2d15a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ff873dcdc0b87cbb30a1a951384293cc2d15a41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ff873dcdc0b87cbb30a1a951384293cc2d15a41"}], "stats": {"total": 207, "additions": 97, "deletions": 110}, "files": [{"sha": "c7b1ef0ab6d5b5a8fed6adc7765430d3fcdcb579", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59909673d11f6e1a0655c360c96653e9b0a37b84/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59909673d11f6e1a0655c360c96653e9b0a37b84/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=59909673d11f6e1a0655c360c96653e9b0a37b84", "patch": "@@ -1,3 +1,11 @@\n+2017-02-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c: Include demangle.h.\n+\t(is_cplusplus_method): Return again true for a primitive operation\n+\tonly if it is dispatching.  For a subprogram with an interface name,\n+\tcall the demangler to get the number of C++ parameters and compare it\n+\twith the number of Ada parameters.\n+\n 2017-02-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Handled_Sequence_Of_Statements_to_gnu): If"}, {"sha": "b493e807c3fb01de964efcfb0f9339ea6492e6cd", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 69, "deletions": 12, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59909673d11f6e1a0655c360c96653e9b0a37b84/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59909673d11f6e1a0655c360c96653e9b0a37b84/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=59909673d11f6e1a0655c360c96653e9b0a37b84", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2017, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -34,6 +34,7 @@\n #include \"fold-const.h\"\n #include \"stor-layout.h\"\n #include \"tree-inline.h\"\n+#include \"demangle.h\"\n \n #include \"ada.h\"\n #include \"types.h\"\n@@ -5093,17 +5094,17 @@ get_unpadded_type (Entity_Id gnat_entity)\n bool\n is_cplusplus_method (Entity_Id gnat_entity)\n {\n-  /* Check that the subprogram has C++ convention.  */\n-  if (Convention (gnat_entity) != Convention_CPP)\n-    return false;\n-\n   /* A constructor is a method on the C++ side.  We deal with it now because\n      it is declared without the 'this' parameter in the sources and, although\n      the front-end will create a version with the 'this' parameter for code\n      generation purposes, we want to return true for both versions.  */\n   if (Is_Constructor (gnat_entity))\n     return true;\n \n+  /* Check that the subprogram has C++ convention.  */\n+  if (Convention (gnat_entity) != Convention_CPP)\n+    return false;\n+\n   /* And that the type of the first parameter (indirectly) has it too.  */\n   Entity_Id gnat_first = First_Formal (gnat_entity);\n   if (No (gnat_first))\n@@ -5115,19 +5116,75 @@ is_cplusplus_method (Entity_Id gnat_entity)\n   if (Convention (gnat_type) != Convention_CPP)\n     return false;\n \n-  /* This is the main case: C++ method imported as a primitive operation.\n-     Note that a C++ class with no virtual functions can be imported as a\n-     limited record type so the operation is not necessarily dispatching.  */\n-  if (Is_Primitive (gnat_entity))\n+  /* This is the main case: a C++ virtual method imported as a primitive\n+     operation of a tagged type.  */\n+  if (Is_Dispatching_Operation (gnat_entity))\n+    return true;\n+\n+  /* This is set on the E_Subprogram_Type built for a dispatching call.  */\n+  if (Is_Dispatch_Table_Entity (gnat_entity))\n     return true;\n \n   /* A thunk needs to be handled like its associated primitive operation.  */\n   if (Is_Subprogram (gnat_entity) && Is_Thunk (gnat_entity))\n     return true;\n \n-  /* This is set on the E_Subprogram_Type built for a dispatching call.  */\n-  if (Is_Dispatch_Table_Entity (gnat_entity))\n-    return true;\n+  /* Now on to the annoying case: a C++ non-virtual method, imported either\n+     as a non-primitive operation of a tagged type or as a primitive operation\n+     of an untagged type.  We cannot reliably differentiate these cases from\n+     their static member or regular function equivalents in Ada, so we ask\n+     the C++ side through the mangled name of the function, as the implicit\n+     'this' parameter is not encoded in the mangled name of a method.  */\n+  if (Is_Subprogram (gnat_entity) && Present (Interface_Name (gnat_entity)))\n+    {\n+      String_Pointer sp = { NULL, NULL };\n+      Get_External_Name (gnat_entity, false, sp);\n+\n+      void *mem;\n+      struct demangle_component *cmp\n+\t= cplus_demangle_v3_components (Name_Buffer,\n+\t\t\t\t\tDMGL_GNU_V3\n+\t\t\t\t\t| DMGL_TYPES\n+\t\t\t\t\t| DMGL_PARAMS\n+\t\t\t\t\t| DMGL_RET_DROP,\n+\t\t\t\t\t&mem);\n+      if (!cmp)\n+\treturn false;\n+\n+      /* We need to release MEM once we have a successful demangling.  */\n+      bool ret = false;\n+\n+      if (cmp->type == DEMANGLE_COMPONENT_TYPED_NAME\n+\t  && cmp->u.s_binary.right->type == DEMANGLE_COMPONENT_FUNCTION_TYPE\n+\t  && (cmp = cmp->u.s_binary.right->u.s_binary.right) != NULL\n+\t  && cmp->type == DEMANGLE_COMPONENT_ARGLIST)\n+\t{\n+\t  /* Make sure there is at least one parameter in C++ too.  */\n+\t  if (cmp->u.s_binary.left)\n+\t    {\n+\t      unsigned int n_ada_args = 0;\n+\t      do {\n+\t\tn_ada_args++;\n+\t\tgnat_first = Next_Formal (gnat_first);\n+\t      } while (Present (gnat_first));\n+\n+\t      unsigned int n_cpp_args = 0;\n+\t      do {\n+\t\tn_cpp_args++;\n+\t\tcmp = cmp->u.s_binary.right;\n+\t      } while (cmp);\n+\n+\t      if (n_cpp_args < n_ada_args)\n+\t\tret = true;\n+\t    }\n+\t  else\n+\t    ret = true;\n+\t}\n+\n+      free (mem);\n+\n+      return ret;\n+    }\n \n   return false;\n }"}, {"sha": "c234c892e724bafb7167fa3da2687843691a869a", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59909673d11f6e1a0655c360c96653e9b0a37b84/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59909673d11f6e1a0655c360c96653e9b0a37b84/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=59909673d11f6e1a0655c360c96653e9b0a37b84", "patch": "@@ -1,3 +1,10 @@\n+2017-02-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-ada-spec.c (dump_ada_function_declaration): Add comment about the\n+\ttreatment of parameters with pointer-to-tagged type and tidy up.\n+\t(print_ada_methods): Remove the special treatment of C++ static member\n+\tfunctions.\n+\n 2017-02-22  Martin Liska  <mliska@suse.cz>\n \n \t* c.opt: Replace inequality signs with square brackets"}, {"sha": "6db741107a366a4afa7ddb87ea060acb5f72ff54", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 13, "deletions": 98, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59909673d11f6e1a0655c360c96653e9b0a37b84/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59909673d11f6e1a0655c360c96653e9b0a37b84/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=59909673d11f6e1a0655c360c96653e9b0a37b84", "patch": "@@ -1683,13 +1683,18 @@ dump_ada_function_declaration (pretty_printer *buffer, tree func,\n \t  dump_generic_ada_node (buffer, TREE_VALUE (arg), node, spc, 0, true);\n \t}\n \n-      if (TREE_TYPE (arg) && TREE_TYPE (TREE_TYPE (arg))\n-\t  && is_tagged_type (TREE_TYPE (TREE_TYPE (arg))))\n-\t{\n-\t  if (!is_method\n-\t      || (num != 1 || (!DECL_VINDEX (func) && !is_constructor)))\n-\t    pp_string (buffer, \"'Class\");\n-\t}\n+      /* If the type is a pointer to a tagged type, we need to differentiate\n+\t virtual methods from the rest (non-virtual methods, static member\n+\t or regular functions) and import only them as primitive operations,\n+\t because they make up the virtual table which is mirrored on the Ada\n+\t side by the dispatch table.  So we add 'Class to the type of every\n+\t parameter that is not the first one of a method which either has a\n+\t slot in the virtual table or is a constructor.  */\n+      if (TREE_TYPE (arg)\n+\t  && POINTER_TYPE_P (TREE_TYPE (arg))\n+\t  && is_tagged_type (TREE_TYPE (TREE_TYPE (arg)))\n+\t  && !(num == 1 && is_method && (DECL_VINDEX (func) || is_constructor)))\n+\tpp_string (buffer, \"'Class\");\n \n       arg = TREE_CHAIN (arg);\n \n@@ -2432,25 +2437,11 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n }\n \n /* Dump in BUFFER NODE's methods.  SPC is the indentation level.  Return 1 if\n-   methods were printed, 0 otherwise.\n-\n-   We do it in 2 passes: first, the regular methods, i.e. non-static member\n-   functions, are output immediately within the package created for the class\n-   so that they are considered as primitive operations in Ada; second, the\n-   static member functions are output in a nested package so that they are\n-   _not_ considered as primitive operations in Ada.\n-\n-   This approach is necessary because the formers have the implicit 'this'\n-   pointer whereas the latters don't and, on 32-bit x86/Windows, the calling\n-   conventions for the 'this' pointer are special.  Therefore, the compiler\n-   needs to be able to differentiate regular methods (with 'this' pointer)\n-   from static member functions that take a pointer to the class as first\n-   parameter.  */\n+   methods were printed, 0 otherwise.  */\n \n static int\n print_ada_methods (pretty_printer *buffer, tree node, int spc)\n {\n-  bool has_static_methods = false;\n   tree t;\n   int res;\n \n@@ -2459,16 +2450,9 @@ print_ada_methods (pretty_printer *buffer, tree node, int spc)\n \n   pp_semicolon (buffer);\n \n-  /* First pass: the regular methods.  */\n   res = 1;\n   for (t = TYPE_METHODS (node); t; t = TREE_CHAIN (t))\n     {\n-      if (TREE_CODE (TREE_TYPE (t)) != METHOD_TYPE)\n-\t{\n-\t  has_static_methods = true;\n-\t  continue;\n-\t}\n-\n       if (res)\n \t{\n \t  pp_newline (buffer);\n@@ -2478,75 +2462,6 @@ print_ada_methods (pretty_printer *buffer, tree node, int spc)\n       res = print_ada_declaration (buffer, t, node, spc);\n     }\n \n-  if (!has_static_methods)\n-    return 1;\n-\n-  pp_newline (buffer);\n-  newline_and_indent (buffer, spc);\n-\n-  /* Second pass: the static member functions.  */\n-  pp_string (buffer, \"package Static is\");\n-  pp_newline (buffer);\n-  spc += INDENT_INCR;\n-\n-  res = 0;\n-  for (t = TYPE_METHODS (node); t; t = TREE_CHAIN (t))\n-    {\n-      if (TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE)\n-\tcontinue;\n-\n-      if (res)\n-\t{\n-\t  pp_newline (buffer);\n-\t  pp_newline (buffer);\n-\t}\n-\n-      res = print_ada_declaration (buffer, t, node, spc);\n-    }\n-\n-  spc -= INDENT_INCR;\n-  newline_and_indent (buffer, spc);\n-  pp_string (buffer, \"end;\");\n-\n-  /* In order to save the clients from adding a second use clause for the\n-     nested package, we generate renamings for the static member functions\n-     in the package created for the class.  */\n-  for (t = TYPE_METHODS (node); t; t = TREE_CHAIN (t))\n-    {\n-      bool is_function;\n-\n-      if (TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE)\n-\tcontinue;\n-\n-      pp_newline (buffer);\n-      newline_and_indent (buffer, spc);\n-\n-      if (VOID_TYPE_P (TREE_TYPE (TREE_TYPE (t))))\n-\t{\n-\t  pp_string (buffer, \"procedure \");\n-\t  is_function = false;\n-\t}\n-      else\n-\t{\n-\t  pp_string (buffer, \"function \");\n-\t  is_function = true;\n-\t}\n-\n-      dump_ada_decl_name (buffer, t, false);\n-      dump_ada_function_declaration (buffer, t, false, false, false, spc);\n-\n-      if (is_function)\n-\t{\n-\t  pp_string (buffer, \" return \");\n-\t  dump_generic_ada_node (buffer, TREE_TYPE (TREE_TYPE (t)), node,\n-\t\t\t\t spc, false, true);\n-\t}\n-\n-       pp_string (buffer, \" renames Static.\");\n-       dump_ada_decl_name (buffer, t, false);\n-       pp_semicolon (buffer);\n-    }\n-\n   return 1;\n }\n "}]}