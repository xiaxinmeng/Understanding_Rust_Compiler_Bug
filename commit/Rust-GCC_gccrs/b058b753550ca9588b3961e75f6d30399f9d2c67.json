{"sha": "b058b753550ca9588b3961e75f6d30399f9d2c67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA1OGI3NTM1NTBjYTk1ODhiMzk2MWU3NWY2ZDMwMzk5ZjlkMmM2Nw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-02-11T11:43:24Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-02-11T11:43:24Z"}, "message": "re PR target/39118 (x86_64 red zone violation)\n\n\tPR target/39118\n\t* config/i386/i386.md (UNSPEC_MEMORY_BLOCKAGE): New constant.\n\t(memory_blockage): New expander.\n\t(*memory_blockage): New insn pattern.\n\t* config/i386/i386.c (ix86_expand_prologue): Use memory_blockage\n\tinstead of general blockage at the end of function prologue when\n\tframe pointer is used to access red zone area.  Do not emit blockage\n\twhen profiling, it is emitted in generic code.\n\t(ix86_expand_epilogue): Emit memory_blockage at the beginning of\n\tfunction epilogue when frame pointer is used to access red zone area.\n\nFrom-SVN: r144100", "tree": {"sha": "c424a6a795052d439c23fbac5081b3142dbb1ec6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c424a6a795052d439c23fbac5081b3142dbb1ec6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b058b753550ca9588b3961e75f6d30399f9d2c67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b058b753550ca9588b3961e75f6d30399f9d2c67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b058b753550ca9588b3961e75f6d30399f9d2c67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b058b753550ca9588b3961e75f6d30399f9d2c67/comments", "author": null, "committer": null, "parents": [{"sha": "3a24ac1d39d91e45d5c52b69b024a1e42b64e097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a24ac1d39d91e45d5c52b69b024a1e42b64e097", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a24ac1d39d91e45d5c52b69b024a1e42b64e097"}], "stats": {"total": 73, "additions": 52, "deletions": 21}, "files": [{"sha": "71c859e7b8dfe0f545e861f6e98d00412a203b23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b058b753550ca9588b3961e75f6d30399f9d2c67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b058b753550ca9588b3961e75f6d30399f9d2c67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b058b753550ca9588b3961e75f6d30399f9d2c67", "patch": "@@ -1,3 +1,17 @@\n+2009-02-11  Uros Bizjak  <ubizjak@gmail.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/39118\n+\t* config/i386/i386.md (UNSPEC_MEMORY_BLOCKAGE): New constant.\n+\t(memory_blockage): New expander.\n+\t(*memory_blockage): New insn pattern.\n+\t* config/i386/i386.c (ix86_expand_prologue): Use memory_blockage\n+\tinstead of general blockage at the end of function prologue when\n+\tframe pointer is used to access red zone area.  Do not emit blockage\n+\twhen profiling, it is emitted in generic code.\n+\t(ix86_expand_epilogue): Emit memory_blockage at the beginning of\n+\tfunction epilogue when frame pointer is used to access red zone area.\n+\n 2009-02-11  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* config/i386/i386.md: Add two new peephole2 to avoid mov followed\n@@ -32,8 +46,7 @@\n \tcancel_loop_tree, not before it.\n \n \tPR target/39139\n-\t* function.h (struct function): Add has_local_explicit_reg_vars\n-\tbit.\n+\t* function.h (struct function): Add has_local_explicit_reg_vars bit.\n \t* gimplify.c (gimplify_bind_expr): Set it if local DECL_HARD_REGISTER\n \tVAR_DECLs were seen.\n \t* tree-ssa-live.c (remove_unused_locals): Recompute\n@@ -89,8 +102,8 @@\n 2009-02-09  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR middle-end/38953\n-\t* graphite.c (if_region_set_false_region): After moving a region \n-\tin the false branch of a condition, remove the empty dummy basic block.\n+\t* graphite.c (if_region_set_false_region): After moving a region in\n+\tthe false branch of a condition, remove the empty dummy basic block.\n \t(gloog): Remove wrong fix for PR38953.\n \n 2009-02-09  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>"}, {"sha": "3e02102284f9c98d2f03056acb5848046df4330e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b058b753550ca9588b3961e75f6d30399f9d2c67/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b058b753550ca9588b3961e75f6d30399f9d2c67/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b058b753550ca9588b3961e75f6d30399f9d2c67", "patch": "@@ -7997,7 +7997,6 @@ ix86_expand_prologue (void)\n {\n   rtx insn;\n   bool pic_reg_used;\n-  bool emit_blockage = false;\n   struct ix86_frame frame;\n   HOST_WIDE_INT allocate;\n \n@@ -8209,14 +8208,12 @@ ix86_expand_prologue (void)\n         insn = emit_insn (gen_set_got (pic_offset_table_rtx));\n     }\n \n-  /* Prevent function calls from being scheduled before the call to mcount.\n-     In the pic_reg_used case, make sure that the got load isn't deleted.  */\n-  if (crtl->profile)\n-    {\n-      if (pic_reg_used)\n-\temit_insn (gen_prologue_use (pic_offset_table_rtx));\n-      emit_blockage = true;\n-    }\n+  /* In the pic_reg_used case, make sure that the got load isn't deleted\n+     when mcount needs it.  Blockage to avoid call movement across mcount\n+     call is emitted in generic code after the NOTE_INSN_PROLOGUE_END\n+     note.  */\n+  if (crtl->profile && pic_reg_used)\n+    emit_insn (gen_prologue_use (pic_offset_table_rtx));\n \n   if (crtl->drap_reg && !crtl->stack_realign_needed)\n     {\n@@ -8235,10 +8232,7 @@ ix86_expand_prologue (void)\n      prologue, and moving instructions that access redzone area via frame\n      pointer inside push sequence violates this assumption.  */\n   if (frame_pointer_needed && frame.red_zone_size)\n-    emit_blockage = true;\n-\n-  if (emit_blockage)\n-    emit_insn (gen_blockage ()); \n+    emit_insn (gen_memory_blockage ());\n \n   /* Emit cld instruction if stringops are used in the function.  */\n   if (TARGET_CLD && ix86_current_function_needs_cld)\n@@ -8326,6 +8320,11 @@ ix86_expand_epilogue (int style)\n \n   ix86_compute_frame_layout (&frame);\n \n+  /* See the comment about red zone and frame\n+     pointer usage in ix86_expand_prologue.  */\n+  if (frame_pointer_needed && frame.red_zone_size)\n+    emit_insn (gen_memory_blockage ()); \n+\n   /* Calculate start of saved registers relative to ebp.  Special care\n      must be taken for the normal return case of a function using\n      eh_return: the eax and edx registers are marked as saved, but not"}, {"sha": "1516237ae69c05fd6e6b3446d04a0f34192209a7", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b058b753550ca9588b3961e75f6d30399f9d2c67/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b058b753550ca9588b3961e75f6d30399f9d2c67/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b058b753550ca9588b3961e75f6d30399f9d2c67", "patch": "@@ -68,12 +68,13 @@\n    (UNSPEC_DEF_CFA\t\t15)\n    (UNSPEC_SET_RIP\t\t16)\n    (UNSPEC_SET_GOT_OFFSET\t17)\n+   (UNSPEC_MEMORY_BLOCKAGE\t18)\n \n    ; TLS support\n-   (UNSPEC_TP\t\t\t18)\n-   (UNSPEC_TLS_GD\t\t19)\n-   (UNSPEC_TLS_LD_BASE\t\t20)\n-   (UNSPEC_TLSDESC\t\t21)\n+   (UNSPEC_TP\t\t\t20)\n+   (UNSPEC_TLS_GD\t\t21)\n+   (UNSPEC_TLS_LD_BASE\t\t22)\n+   (UNSPEC_TLSDESC\t\t23)\n \n    ; Other random patterns\n    (UNSPEC_SCAS\t\t\t30)\n@@ -15175,6 +15176,24 @@\n   \"\"\n   [(set_attr \"length\" \"0\")])\n \n+;; Do not schedule instructions accessing memory across this point.\n+\n+(define_expand \"memory_blockage\"\n+  [(set (match_dup 0)\n+\t(unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BLOCKAGE))]\n+  \"\"\n+{\n+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n+})\n+\n+(define_insn \"*memory_blockage\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+\t(unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BLOCKAGE))]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n+\n ;; As USE insns aren't meaningful after reload, this is used instead\n ;; to prevent deleting instructions setting registers for PIC code\n (define_insn \"prologue_use\""}]}