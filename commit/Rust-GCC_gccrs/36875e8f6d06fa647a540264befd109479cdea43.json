{"sha": "36875e8f6d06fa647a540264befd109479cdea43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY4NzVlOGY2ZDA2ZmE2NDdhNTQwMjY0YmVmZDEwOTQ3OWNkZWE0Mw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-09-16T08:10:28Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-09-16T08:10:28Z"}, "message": "tree-loop-distribution.c (enum rdg_dep_type): Add control_dd.\n\n2013-09-16  Richard Biener  <rguenther@suse.de>\n\n\t* tree-loop-distribution.c (enum rdg_dep_type): Add control_dd.\n\t(dot_rdg_1): Handle control_dd.\n\t(create_edge_for_control_dependence): New function.\n\t(create_rdg_edges): Add control dependences if asked for.\n\t(build_rdg): Likewise.\n\t(generate_loops_for_partition): If there are not necessary\n\tcontrol stmts remove all their dependencies.\n\t(collect_condition_stmts, rdg_flag_loop_exits): Remove.\n\t(distribute_loop): Pass on control dependences.\n\t(tree_loop_distribution): Compute control dependences and remove\n\trestriction on number of loop nodes.\n\n\t* gcc.dg/tree-ssa/ldist-22.c: New testcase.\n\nFrom-SVN: r202619", "tree": {"sha": "717caeea9aacb4b8aad809724ea63220920e6d8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/717caeea9aacb4b8aad809724ea63220920e6d8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36875e8f6d06fa647a540264befd109479cdea43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36875e8f6d06fa647a540264befd109479cdea43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36875e8f6d06fa647a540264befd109479cdea43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36875e8f6d06fa647a540264befd109479cdea43/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "62e42210ef0f4c2d80a542cb676b663f4df2bb88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e42210ef0f4c2d80a542cb676b663f4df2bb88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e42210ef0f4c2d80a542cb676b663f4df2bb88"}], "stats": {"total": 214, "additions": 141, "deletions": 73}, "files": [{"sha": "373bd8fc5cd64389280a26a83446bf132fa02aa0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36875e8f6d06fa647a540264befd109479cdea43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36875e8f6d06fa647a540264befd109479cdea43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36875e8f6d06fa647a540264befd109479cdea43", "patch": "@@ -1,3 +1,17 @@\n+2013-09-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-loop-distribution.c (enum rdg_dep_type): Add control_dd.\n+\t(dot_rdg_1): Handle control_dd.\n+\t(create_edge_for_control_dependence): New function.\n+\t(create_rdg_edges): Add control dependences if asked for.\n+\t(build_rdg): Likewise.\n+\t(generate_loops_for_partition): If there are not necessary\n+\tcontrol stmts remove all their dependencies.\n+\t(collect_condition_stmts, rdg_flag_loop_exits): Remove.\n+\t(distribute_loop): Pass on control dependences.\n+\t(tree_loop_distribution): Compute control dependences and remove\n+\trestriction on number of loop nodes.\n+\n 2013-09-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Return early"}, {"sha": "6b9b3bc205bc4c0053fc6236ff483e43944975b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36875e8f6d06fa647a540264befd109479cdea43/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36875e8f6d06fa647a540264befd109479cdea43/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=36875e8f6d06fa647a540264befd109479cdea43", "patch": "@@ -1,3 +1,7 @@\n+2013-09-16  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ldist-22.c: New testcase.\n+\n 2013-09-16  Adam Butcher  <adam@jessamine.co.uk>\n \n \t* g++.dg/cpp0x/auto9.C: Downgrade two previously expected errors (now"}, {"sha": "f6fff77f3feae095b9e7a00c3dc970d91f28c117", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-22.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36875e8f6d06fa647a540264befd109479cdea43/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36875e8f6d06fa647a540264befd109479cdea43/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-22.c?ref=36875e8f6d06fa647a540264befd109479cdea43", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-tree-ldist-details\" } */\n+\n+extern void abort (void);\n+\n+int a[1024], b[1024];\n+\n+void __attribute__((noinline,noclone))\n+foo (void)\n+{\n+  int i;\n+  for (i = 0; i < 1024; ++i)\n+    {\n+      a[i] = 0;\n+      if (i > 100)\n+\tb[i] = i;\n+    }\n+}\n+\n+int main()\n+{\n+  b[100] = 1;\n+  foo ();\n+  if (b[100] != 1 || b[101] != 101)\n+    abort ();\n+  if (a[0] != 0 || a[101] != 0)\n+    abort ();\n+  return;\n+}\n+\n+/* { dg-final { scan-tree-dump \"generated memset zero\" \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "e3e4e12b0256c33bddce54e31e4c8ce8cc2cb735", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 91, "deletions": 73, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36875e8f6d06fa647a540264befd109479cdea43/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36875e8f6d06fa647a540264befd109479cdea43/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=36875e8f6d06fa647a540264befd109479cdea43", "patch": "@@ -92,7 +92,10 @@ enum rdg_dep_type\n   output_dd = 'o',\n \n   /* Read After Read (RAR).  */\n-  input_dd = 'i'\n+  input_dd = 'i',\n+\n+  /* Control dependence (execute conditional on).  */\n+  control_dd = 'c'\n };\n \n /* Dependence information attached to an edge of the RDG.  */\n@@ -218,6 +221,10 @@ dot_rdg_1 (FILE *file, struct graph *rdg)\n              fprintf (file, \"%d -> %d [label=anti] \\n\", i, e->dest);\n              break;\n \n+\t   case control_dd:\n+             fprintf (file, \"%d -> %d [label=control] \\n\", i, e->dest);\n+             break;\n+\n            default:\n              gcc_unreachable ();\n            }\n@@ -325,10 +332,38 @@ create_rdg_edges_for_scalar (struct graph *rdg, tree def, int idef)\n     }\n }\n \n+/* Creates an edge for the control dependences of BB to the vertex V.  */\n+\n+static void\n+create_edge_for_control_dependence (struct graph *rdg, basic_block bb,\n+\t\t\t\t    int v, control_dependences *cd)\n+{\n+  bitmap_iterator bi;\n+  unsigned edge_n;\n+  EXECUTE_IF_SET_IN_BITMAP (cd->get_edges_dependent_on (bb->index),\n+\t\t\t    0, edge_n, bi)\n+    {\n+      basic_block cond_bb = cd->get_edge (edge_n)->src;\n+      gimple stmt = last_stmt (cond_bb);\n+      if (stmt && is_ctrl_stmt (stmt))\n+\t{\n+\t  struct graph_edge *e;\n+\t  int c = rdg_vertex_for_stmt (rdg, stmt);\n+\t  if (c < 0)\n+\t    continue;\n+\n+\t  e = add_edge (rdg, c, v);\n+\t  e->data = XNEW (struct rdg_edge);\n+\t  RDGE_TYPE (e) = control_dd;\n+\t  RDGE_RELATION (e) = NULL;\n+\t}\n+    }\n+}\n+\n /* Creates the edges of the reduced dependence graph RDG.  */\n \n static void\n-create_rdg_edges (struct graph *rdg, vec<ddr_p> ddrs)\n+create_rdg_edges (struct graph *rdg, vec<ddr_p> ddrs, control_dependences *cd)\n {\n   int i;\n   struct data_dependence_relation *ddr;\n@@ -345,6 +380,21 @@ create_rdg_edges (struct graph *rdg, vec<ddr_p> ddrs)\n     FOR_EACH_PHI_OR_STMT_DEF (def_p, RDG_STMT (rdg, i),\n \t\t\t      iter, SSA_OP_DEF)\n       create_rdg_edges_for_scalar (rdg, DEF_FROM_PTR (def_p), i);\n+\n+  if (cd)\n+    for (i = 0; i < rdg->n_vertices; i++)\n+      {\n+\tgimple stmt = RDG_STMT (rdg, i);\n+\tif (gimple_code (stmt) == GIMPLE_PHI)\n+\t  {\n+\t    edge_iterator ei;\n+\t    edge e;\n+\t    FOR_EACH_EDGE (e, ei, gimple_bb (stmt)->preds)\n+\t      create_edge_for_control_dependence (rdg, e->src, i, cd);\n+\t  }\n+\telse\n+\t  create_edge_for_control_dependence (rdg, gimple_bb (stmt), i, cd);\n+      }\n }\n \n /* Build the vertices of the reduced dependence graph RDG.  Return false\n@@ -465,7 +515,7 @@ free_rdg (struct graph *rdg)\n    scalar dependence.  */\n \n static struct graph *\n-build_rdg (vec<loop_p> loop_nest)\n+build_rdg (vec<loop_p> loop_nest, control_dependences *cd)\n {\n   struct graph *rdg;\n   vec<gimple> stmts;\n@@ -497,7 +547,7 @@ build_rdg (vec<loop_p> loop_nest)\n       free_rdg (rdg);\n       return NULL;\n     }\n-  create_rdg_edges (rdg, dependence_relations);\n+  create_rdg_edges (rdg, dependence_relations, cd);\n   dependence_relations.release ();\n   datarefs.release ();\n \n@@ -699,12 +749,28 @@ generate_loops_for_partition (struct loop *loop, partition_t partition,\n \t      && !is_gimple_debug (stmt)\n \t      && !bitmap_bit_p (partition->stmts, gimple_uid (stmt)))\n \t    {\n-\t      unlink_stmt_vdef (stmt);\n-\t      gsi_remove (&bsi, true);\n-\t      release_defs (stmt);\n+\t      /* Choose an arbitrary path through the empty CFG part\n+\t\t that this unnecessary control stmt controls.  */\n+\t      if (gimple_code (stmt) == GIMPLE_COND)\n+\t\t{\n+\t\t  gimple_cond_make_false (stmt);\n+\t\t  update_stmt (stmt);\n+\t\t}\n+\t      else if (gimple_code (stmt) == GIMPLE_SWITCH)\n+\t\t{\n+\t\t  gimple_switch_set_index\n+\t\t      (stmt, CASE_LOW (gimple_switch_label (stmt, 1)));\n+\t\t  update_stmt (stmt);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  unlink_stmt_vdef (stmt);\n+\t\t  gsi_remove (&bsi, true);\n+\t\t  release_defs (stmt);\n+\t\t  continue;\n+\t\t}\n \t    }\n-\t  else\n-\t    gsi_next (&bsi);\n+\t  gsi_next (&bsi);\n \t}\n     }\n \n@@ -1031,62 +1097,6 @@ rdg_flag_vertex_and_dependent (struct graph *rdg, int v, partition_t partition,\n   nodes.release ();\n }\n \n-/* Initialize CONDS with all the condition statements from the basic\n-   blocks of LOOP.  */\n-\n-static void\n-collect_condition_stmts (struct loop *loop, vec<gimple> *conds)\n-{\n-  unsigned i;\n-  edge e;\n-  vec<edge> exits = get_loop_exit_edges (loop);\n-\n-  FOR_EACH_VEC_ELT (exits, i, e)\n-    {\n-      gimple cond = last_stmt (e->src);\n-\n-      if (cond)\n-\tconds->safe_push (cond);\n-    }\n-\n-  exits.release ();\n-}\n-\n-/* Add to PARTITION all the exit condition statements for LOOPS\n-   together with all their dependent statements determined from\n-   RDG.  */\n-\n-static void\n-rdg_flag_loop_exits (struct graph *rdg, partition_t partition,\n-\t\t     bitmap processed)\n-{\n-  unsigned i;\n-  bitmap_iterator bi;\n-  vec<gimple> conds;\n-  conds.create (3);\n-\n-  EXECUTE_IF_SET_IN_BITMAP (partition->loops, 0, i, bi)\n-    collect_condition_stmts (get_loop (cfun, i), &conds);\n-\n-  while (!conds.is_empty ())\n-    {\n-      gimple cond = conds.pop ();\n-      int v = rdg_vertex_for_stmt (rdg, cond);\n-      if (!already_processed_vertex_p (processed, v))\n-\t{\n-\t  bitmap saved_loops = BITMAP_ALLOC (NULL);\n-\t  bitmap_copy (saved_loops, partition->loops);\n-\t  rdg_flag_vertex_and_dependent (rdg, v, partition, processed);\n-\t  EXECUTE_IF_AND_COMPL_IN_BITMAP (partition->loops, saved_loops,\n-\t\t\t\t\t  0, i, bi)\n-\t    collect_condition_stmts (get_loop (cfun, i), &conds);\n-\t  BITMAP_FREE (saved_loops);\n-\t}\n-    }\n-\n-  conds.release ();\n-}\n-\n /* Returns a partition with all the statements needed for computing\n    the vertex V of the RDG, also including the loop exit conditions.  */\n \n@@ -1096,7 +1106,6 @@ build_rdg_partition_for_vertex (struct graph *rdg, int v)\n   partition_t partition = partition_alloc (NULL, NULL);\n   bitmap processed = BITMAP_ALLOC (NULL);\n   rdg_flag_vertex_and_dependent (rdg, v, partition, processed);\n-  rdg_flag_loop_exits (rdg, partition, processed);\n   BITMAP_FREE (processed);\n   return partition;\n }\n@@ -1463,7 +1472,8 @@ partition_contains_all_rw (struct graph *rdg,\n    Returns the number of distributed loops.  */\n \n static int\n-distribute_loop (struct loop *loop, vec<gimple> stmts)\n+distribute_loop (struct loop *loop, vec<gimple> stmts,\n+\t\t control_dependences *cd)\n {\n   struct graph *rdg;\n   vec<loop_p> loop_nest;\n@@ -1479,7 +1489,7 @@ distribute_loop (struct loop *loop, vec<gimple> stmts)\n       return 0;\n     }\n \n-  rdg = build_rdg (loop_nest);\n+  rdg = build_rdg (loop_nest, cd);\n   if (!rdg)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1631,6 +1641,7 @@ tree_loop_distribution (void)\n   loop_iterator li;\n   bool changed = false;\n   basic_block bb;\n+  control_dependences *cd = NULL;\n \n   FOR_ALL_BB (bb)\n     {\n@@ -1660,10 +1671,6 @@ tree_loop_distribution (void)\n       if (!optimize_loop_for_speed_p (loop))\n \tcontinue;\n \n-      /* Only distribute loops with a header and latch for now.  */\n-      if (loop->num_nodes > 2)\n-\tcontinue;\n-\n       /* Initialize the worklist with stmts we seed the partitions with.  */\n       bbs = get_loop_body_in_dom_order (loop);\n       for (i = 0; i < loop->num_nodes; ++i)\n@@ -1697,7 +1704,15 @@ tree_loop_distribution (void)\n       free (bbs);\n \n       if (work_list.length () > 0)\n-\tnb_generated_loops = distribute_loop (loop, work_list);\n+\t{\n+\t  if (!cd)\n+\t    {\n+\t      calculate_dominance_info (CDI_POST_DOMINATORS);\n+\t      cd = new control_dependences (create_edge_list ());\n+\t      free_dominance_info (CDI_POST_DOMINATORS);\n+\t    }\n+\t  nb_generated_loops = distribute_loop (loop, work_list, cd);\n+\t}\n \n       if (nb_generated_loops > 0)\n \tchanged = true;\n@@ -1714,6 +1729,9 @@ tree_loop_distribution (void)\n       work_list.release ();\n     }\n \n+  if (cd)\n+    delete cd;\n+\n   if (changed)\n     {\n       mark_virtual_operands_for_renaming (cfun);"}]}