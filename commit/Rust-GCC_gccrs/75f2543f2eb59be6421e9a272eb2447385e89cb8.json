{"sha": "75f2543f2eb59be6421e9a272eb2447385e89cb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVmMjU0M2YyZWI1OWJlNjQyMWU5YTI3MmViMjQ0NzM4NWU4OWNiOA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-03-28T23:22:49Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-03-28T23:22:49Z"}, "message": "re PR libfortran/32972 (performance of pack/unpack)\n\n2008-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/32972\n\tPR libfortran/32512\n\t* Makefile.am:  Add new variable, i_spread_c, containing\n\tpack_i1.c, pack_i2.c, pack_i4.c, pack_i8.c, spread_i16.c,\n\tspread_r4.c, spread_r8.c, spread_r10.c, spread_r16.c,\n\tspread_c4.c, spread_c8.c, spread_c10.c, spread_c16.c.\n\t* Makefile.in:  Regenerated.\n\t* libgfortran.h:  Add prototypes for spread_i1, spread_i2,\n\tspread_i4, spread_i8, spread_i16, spread_r4, spread_r8,\n\tspread_c4, spread_c8, spread_c10, spread_c16,\n\tspread_scalar_i1, spread_scalar_i2, spread_scalar_i4,\n\tspread_scalar_i8, spread_scalar_i16, spread_scalar_r4\n\tspread_scalar_r8, spread_scalar_c4, spread_scalar_c8,\n\tspread_scalar_c10 and spread_scalar_c16.\n\tAdd macros to isolate both type and size information\n\tfrom array descriptors with a single mask operation.\n\t* intrinsics/spread_generic.c:  Add calls to specific\n\tspread functions.\n\t* m4/spread.m4:  New file.\n\t* generated/spread_i1.c:  New file.\n\t* generated/spread_i2.c:  New file.\n\t* generated/spread_i4.c:  New file.\n\t* generated/spread_i8.c:  New file.\n\t* generated/spread_i16.c:  New file.\n\t* generated/spread_r4.c:  New file.\n\t* generated/spread_r8.c:  New file.\n\t* generated/spread_r10.c:  New file.\n\t* generated/spread_r16.c:  New file.\n\t* generated/spread_c4.c:  New file.\n\t* generated/spread_c8.c:  New file.\n\t* generated/spread_c10.c:  New file.\n\t* generated/spread_c16.c:  New file.\n\n2008-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/32972\n\tPR libfortran/32512\n\t* intrinsic_spread_1.f90:  New file.\n\t* intrinsic_spread_2.f90:  New file.\n\t* intrinsic_spread_3.f90:  New file.\n\nFrom-SVN: r133702", "tree": {"sha": "5827b3722b26897a74f2d953658b92b0ec5321c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5827b3722b26897a74f2d953658b92b0ec5321c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75f2543f2eb59be6421e9a272eb2447385e89cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75f2543f2eb59be6421e9a272eb2447385e89cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75f2543f2eb59be6421e9a272eb2447385e89cb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75f2543f2eb59be6421e9a272eb2447385e89cb8/comments", "author": null, "committer": null, "parents": [{"sha": "01d2a7d70396ca672c10a4ed68d1739b42dbc1ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d2a7d70396ca672c10a4ed68d1739b42dbc1ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d2a7d70396ca672c10a4ed68d1739b42dbc1ae"}], "stats": {"total": 4668, "additions": 4651, "deletions": 17}, "files": [{"sha": "303840604440868194feb81db8d577558709f778", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -1,3 +1,11 @@\n+2008-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/32972\n+\tPR libfortran/32512\n+\t* intrinsic_spread_1.f90:  New file.\n+\t* intrinsic_spread_2.f90:  New file.\n+\t* intrinsic_spread_3.f90:  New file.\n+\n 2008-03-28  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/34714"}, {"sha": "e2a0e169bea11f00aea1a79dd0b126ab0d4e191f", "filename": "gcc/testsuite/gfortran.dg/intrinsic_spread_1.f90", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_spread_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_spread_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_spread_1.f90?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,123 @@\n+! { dg-do run }\n+program foo\n+   implicit none\n+   integer(kind=1), dimension (10) :: i_1\n+   integer(kind=1), dimension (2, 3) :: a_1\n+   integer(kind=1), dimension (2, 2, 3) :: b_1\n+   integer(kind=2), dimension (10) :: i_2\n+   integer(kind=2), dimension (2, 3) :: a_2\n+   integer(kind=2), dimension (2, 2, 3) :: b_2\n+   integer(kind=4), dimension (10) :: i_4\n+   integer(kind=4), dimension (2, 3) :: a_4\n+   integer(kind=4), dimension (2, 2, 3) :: b_4\n+   integer(kind=8), dimension (10) :: i_8\n+   integer(kind=8), dimension (2, 3) :: a_8\n+   integer(kind=8), dimension (2, 2, 3) :: b_8\n+   real(kind=4), dimension (10) :: r_4\n+   real(kind=4), dimension (2, 3) :: ar_4\n+   real(kind=4), dimension (2, 2, 3) :: br_4\n+   real(kind=8), dimension (10) :: r_8\n+   real(kind=8), dimension (2, 3) :: ar_8\n+   real(kind=8), dimension (2, 2, 3) :: br_8\n+   character (len=200) line1, line2, line3\n+\n+   a_1 = reshape ((/1_1, 2_1, 3_1, 4_1, 5_1, 6_1/), (/2, 3/))\n+   b_1 = spread (a_1, 1, 2)\n+   if (any (b_1 .ne. reshape ((/1_1, 1_1, 2_1, 2_1, 3_1, 3_1, 4_1, 4_1, 5_1, 5_1, 6_1, 6_1/), &\n+                            (/2, 2, 3/)))) &\n+      call abort\n+   line1 = ' '\n+   write(line1, 9000) b_1\n+   line2 = ' '\n+   write(line2, 9000) spread (a_1, 1, 2)\n+   if (line1 /= line2) call abort\n+   line3 = ' '\n+   write(line3, 9000) spread (a_1, 1, 2) + 0_1\n+   if (line1 /= line3) call abort\n+   i_1 = spread(1_1,1,10)\n+   if (any(i_1 /= 1_1)) call abort\n+\n+   a_2 = reshape ((/1_2, 2_2, 3_2, 4_2, 5_2, 6_2/), (/2, 3/))\n+   b_2 = spread (a_2, 1, 2)\n+   if (any (b_2 .ne. reshape ((/1_2, 1_2, 2_2, 2_2, 3_2, 3_2, 4_2, 4_2, 5_2, 5_2, 6_2, 6_2/), &\n+                            (/2, 2, 3/)))) &\n+      call abort\n+   line1 = ' '\n+   write(line1, 9000) b_2\n+   line2 = ' '\n+   write(line2, 9000) spread (a_2, 1, 2)\n+   if (line1 /= line2) call abort\n+   line3 = ' '\n+   write(line3, 9000) spread (a_2, 1, 2) + 0_2\n+   if (line1 /= line3) call abort\n+   i_2 = spread(1_2,1,10)\n+   if (any(i_2 /= 1_2)) call abort\n+\n+   a_4 = reshape ((/1_4, 2_4, 3_4, 4_4, 5_4, 6_4/), (/2, 3/))\n+   b_4 = spread (a_4, 1, 2)\n+   if (any (b_4 .ne. reshape ((/1_4, 1_4, 2_4, 2_4, 3_4, 3_4, 4_4, 4_4, 5_4, 5_4, 6_4, 6_4/), &\n+                            (/2, 2, 3/)))) &\n+      call abort\n+   line1 = ' '\n+   write(line1, 9000) b_4\n+   line2 = ' '\n+   write(line2, 9000) spread (a_4, 1, 2)\n+   if (line1 /= line2) call abort\n+   line3 = ' '\n+   write(line3, 9000) spread (a_4, 1, 2) + 0_4\n+   if (line1 /= line3) call abort\n+   i_4 = spread(1_4,1,10)\n+   if (any(i_4 /= 1_4)) call abort\n+\n+   a_8 = reshape ((/1_8, 2_8, 3_8, 4_8, 5_8, 6_8/), (/2, 3/))\n+   b_8 = spread (a_8, 1, 2)\n+   if (any (b_8 .ne. reshape ((/1_8, 1_8, 2_8, 2_8, 3_8, 3_8, 4_8, 4_8, 5_8, 5_8, 6_8, 6_8/), &\n+                            (/2, 2, 3/)))) &\n+      call abort\n+   line1 = ' '\n+   write(line1, 9000) b_8\n+   line2 = ' '\n+   write(line2, 9000) spread (a_8, 1, 2)\n+   if (line1 /= line2) call abort\n+   line3 = ' '\n+   write(line3, 9000) spread (a_8, 1, 2) + 0_8\n+   if (line1 /= line3) call abort\n+   i_8 = spread(1_8,1,10)\n+   if (any(i_8 /= 1_8)) call abort\n+\n+\n+   ar_4 = reshape ((/1._4, 2._4, 3._4, 4._4, 5._4, 6._4/), (/2, 3/))\n+   br_4 = spread (ar_4, 1, 2)\n+   if (any (br_4 .ne. reshape ((/1._4, 1._4, 2._4, 2._4, 3._4, 3._4, &\n+   & 4._4, 4._4, 5._4, 5._4, 6._4, 6._4/), (/2, 2, 3/)))) call abort\n+   line1 = ' '\n+   write(line1, 9010) br_4\n+   line2 = ' '\n+   write(line2, 9010) spread (ar_4, 1, 2)\n+   if (line1 /= line2) call abort\n+   line3 = ' '\n+   write(line3, 9010) spread (ar_4, 1, 2) + 0._4\n+   if (line1 /= line3) call abort\n+   r_4 = spread(1._4,1,10)\n+   if (any(r_4 /= 1._4)) call abort\n+\n+\n+   ar_8 = reshape ((/1._8, 2._8, 3._8, 4._8, 5._8, 6._8/), (/2, 3/))\n+   br_8 = spread (ar_8, 1, 2)\n+   if (any (br_8 .ne. reshape ((/1._8, 1._8, 2._8, 2._8, 3._8, 3._8, &\n+   & 4._8, 4._8, 5._8, 5._8, 6._8, 6._8/), (/2, 2, 3/)))) call abort\n+   line1 = ' '\n+   write(line1, 9010) br_8\n+   line2 = ' '\n+   write(line2, 9010) spread (ar_8, 1, 2)\n+   if (line1 /= line2) call abort\n+   line3 = ' '\n+   write(line3, 9010) spread (ar_8, 1, 2) + 0._8\n+   if (line1 /= line3) call abort\n+   r_8 = spread(1._8,1,10)\n+   if (any(r_8 /= 1._8)) call abort\n+\n+9000 format(12I3)\n+9010 format(12F7.3)\n+\n+end program"}, {"sha": "ab0152182c153291e1ffd3cff42ad00a83758d0d", "filename": "gcc/testsuite/gfortran.dg/intrinsic_spread_2.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_spread_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_spread_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_spread_2.f90?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! { dg-require-effective-target fortran_large_real }\n+program foo\n+   implicit none\n+   integer,parameter :: k = selected_real_kind (precision (0.0_8) + 1)\n+\n+   real(kind=k), dimension(10) :: r_k\n+   real(kind=k), dimension (2, 3) :: ar_k\n+   real(kind=k), dimension (2, 2, 3) :: br_k\n+   character (len=200) line1, line2, line3\n+\n+   ar_k = reshape ((/1._k, 2._k, 3._k, 4._k, 5._k, 6._k/), (/2, 3/))\n+   br_k = spread (ar_k, 1, 2)\n+   if (any (br_k .ne. reshape ((/1._k, 1._k, 2._k, 2._k, 3._k, 3._k, &\n+   & 4._k, 4._k, 5._k, 5._k, 6._k, 6._k/), (/2, 2, 3/)))) call abort\n+   line1 = ' '\n+   write(line1, 9010) br_k\n+   line2 = ' '\n+   write(line2, 9010) spread (ar_k, 1, 2)\n+   if (line1 /= line2) call abort\n+   line3 = ' '\n+   write(line3, 9010) spread (ar_k, 1, 2) + 0._k\n+   if (line1 /= line3) call abort\n+   r_k = spread(1._k,1,10)\n+   if (any(r_k /= 1._k)) call abort\n+\n+9010 format(12F7.3)\n+\n+end program"}, {"sha": "1dd2feb1d2198d17b1cf50c2b9d46911d6e1a2e0", "filename": "gcc/testsuite/gfortran.dg/intrinsic_spread_3.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_spread_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_spread_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_spread_3.f90?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do run }\n+! { dg-require-effective-target fortran_large_int }\n+\n+program foo\n+   implicit none\n+   integer,parameter :: k = selected_int_kind (range (0_8) + 1)\n+\n+   integer(kind=k), dimension(10) :: i_k\n+   integer(kind=k), dimension (2, 3) :: a_k\n+   integer(kind=k), dimension (2, 2, 3) :: b_k\n+   character (len=200) line1, line2, line3\n+\n+   a_k = reshape ((/1_k, 2_k, 3_k, 4_k, 5_k, 6_k/), (/2, 3/))\n+   b_k = spread (a_k, 1, 2)\n+   if (any (b_k .ne. reshape ((/1_k, 1_k, 2_k, 2_k, 3_k, 3_k, 4_k, 4_k, 5_k, 5_k, 6_k, 6_k/), &\n+                            (/2, 2, 3/)))) &\n+      call abort\n+   line1 = ' '\n+   write(line1, 9000) b_k\n+   line2 = ' '\n+   write(line2, 9000) spread (a_k, 1, 2)\n+   if (line1 /= line2) call abort\n+   line3 = ' '\n+   write(line3, 9000) spread (a_k, 1, 2) + 0_k\n+   if (line1 /= line3) call abort\n+   i_k = spread(1_k,1,10)\n+   if (any(i_k /= 1_k)) call abort\n+\n+9000 format(12I3)\n+\n+end program"}, {"sha": "11592e4b4cc4368beabf72442c6d9fbfc9080644", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -1,3 +1,38 @@\n+2008-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/32972\n+\tPR libfortran/32512\n+\t* Makefile.am:  Add new variable, i_spread_c, containing\n+\tpack_i1.c, pack_i2.c, pack_i4.c, pack_i8.c, spread_i16.c,\n+\tspread_r4.c, spread_r8.c, spread_r10.c, spread_r16.c,\n+\tspread_c4.c, spread_c8.c, spread_c10.c, spread_c16.c.\n+\t* Makefile.in:  Regenerated.\n+\t* libgfortran.h:  Add prototypes for spread_i1, spread_i2,\n+\tspread_i4, spread_i8, spread_i16, spread_r4, spread_r8,\n+\tspread_c4, spread_c8, spread_c10, spread_c16,\n+\tspread_scalar_i1, spread_scalar_i2, spread_scalar_i4,\n+\tspread_scalar_i8, spread_scalar_i16, spread_scalar_r4\n+\tspread_scalar_r8, spread_scalar_c4, spread_scalar_c8,\n+\tspread_scalar_c10 and spread_scalar_c16.\n+\tAdd macros to isolate both type and size information\n+\tfrom array descriptors with a single mask operation.\n+\t* intrinsics/spread_generic.c:  Add calls to specific\n+\tspread functions.\n+\t* m4/spread.m4:  New file.\n+\t* generated/spread_i1.c:  New file.\n+\t* generated/spread_i2.c:  New file.\n+\t* generated/spread_i4.c:  New file.\n+\t* generated/spread_i8.c:  New file.\n+\t* generated/spread_i16.c:  New file.\n+\t* generated/spread_r4.c:  New file.\n+\t* generated/spread_r8.c:  New file.\n+\t* generated/spread_r10.c:  New file.\n+\t* generated/spread_r16.c:  New file.\n+\t* generated/spread_c4.c:  New file.\n+\t* generated/spread_c8.c:  New file.\n+\t* generated/spread_c10.c:  New file.\n+\t* generated/spread_c16.c:  New file.\n+\n 2008-03-28  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/35699"}, {"sha": "62ae5f31db830b37e09a5703e40c8ca821c8a8eb", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -506,6 +506,21 @@ $(srcdir)/generated/unpack_c8.c \\\n $(srcdir)/generated/unpack_c10.c \\\n $(srcdir)/generated/unpack_c16.c\n \n+i_spread_c = \\\n+$(srcdir)/generated/spread_i1.c \\\n+$(srcdir)/generated/spread_i2.c \\\n+$(srcdir)/generated/spread_i4.c \\\n+$(srcdir)/generated/spread_i8.c \\\n+$(srcdir)/generated/spread_i16.c \\\n+$(srcdir)/generated/spread_r4.c \\\n+$(srcdir)/generated/spread_r8.c \\\n+$(srcdir)/generated/spread_r10.c \\\n+$(srcdir)/generated/spread_r16.c \\\n+$(srcdir)/generated/spread_c4.c \\\n+$(srcdir)/generated/spread_c8.c \\\n+$(srcdir)/generated/spread_c10.c \\\n+$(srcdir)/generated/spread_c16.c \n+\n m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n     m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n@@ -515,7 +530,7 @@ m4_files= m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n     m4/fraction.m4 m4/nearest.m4 m4/set_exponent.m4 m4/pow.m4 \\\n     m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4 \\\n-    m4/unpack.m4\n+    m4/unpack.m4 m4/spread.m4\n \n gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n@@ -524,7 +539,7 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n     $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) $(i_unpack_c) \\\n-    selected_int_kind.inc selected_real_kind.inc kinds.h \\\n+    $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     kinds.inc c99_protos.inc fpu-target.h\n \n # Machine generated specifics\n@@ -845,6 +860,9 @@ $(i_pack_c): m4/pack.m4 $(I_M4_DEPS)\n $(i_unpack_c): m4/unpack.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 unpack.m4 > $@\n \n+$(i_spread_c): m4/spread.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 spread.m4 > $@\n+\n $(gfor_built_specific_src): m4/specific.m4 m4/head.m4\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 specific.m4 > $@\n "}, {"sha": "71eb44e23df63a79e5d0553d5ace39bd9cfb912f", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 155, "deletions": 15, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -382,7 +382,20 @@ am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c \\\n \t$(srcdir)/generated/unpack_c4.c \\\n \t$(srcdir)/generated/unpack_c8.c \\\n \t$(srcdir)/generated/unpack_c10.c \\\n-\t$(srcdir)/generated/unpack_c16.c selected_int_kind.inc \\\n+\t$(srcdir)/generated/unpack_c16.c \\\n+\t$(srcdir)/generated/spread_i1.c \\\n+\t$(srcdir)/generated/spread_i2.c \\\n+\t$(srcdir)/generated/spread_i4.c \\\n+\t$(srcdir)/generated/spread_i8.c \\\n+\t$(srcdir)/generated/spread_i16.c \\\n+\t$(srcdir)/generated/spread_r4.c \\\n+\t$(srcdir)/generated/spread_r8.c \\\n+\t$(srcdir)/generated/spread_r10.c \\\n+\t$(srcdir)/generated/spread_r16.c \\\n+\t$(srcdir)/generated/spread_c4.c \\\n+\t$(srcdir)/generated/spread_c8.c \\\n+\t$(srcdir)/generated/spread_c10.c \\\n+\t$(srcdir)/generated/spread_c16.c selected_int_kind.inc \\\n \tselected_real_kind.inc kinds.h kinds.inc c99_protos.inc \\\n \tfpu-target.h io/close.c io/file_pos.c io/format.c io/inquire.c \\\n \tio/intrinsics.c io/list_read.c io/lock.c io/open.c io/read.c \\\n@@ -659,7 +672,11 @@ am__objects_31 = unpack_i1.lo unpack_i2.lo unpack_i4.lo unpack_i8.lo \\\n \tunpack_i16.lo unpack_r4.lo unpack_r8.lo unpack_r10.lo \\\n \tunpack_r16.lo unpack_c4.lo unpack_c8.lo unpack_c10.lo \\\n \tunpack_c16.lo\n-am__objects_32 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n+am__objects_32 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \\\n+\tspread_i16.lo spread_r4.lo spread_r8.lo spread_r10.lo \\\n+\tspread_r16.lo spread_c4.lo spread_c8.lo spread_c10.lo \\\n+\tspread_c16.lo\n+am__objects_33 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_5) $(am__objects_6) $(am__objects_7) \\\n \t$(am__objects_8) $(am__objects_9) $(am__objects_10) \\\n \t$(am__objects_11) $(am__objects_12) $(am__objects_13) \\\n@@ -668,11 +685,12 @@ am__objects_32 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_20) $(am__objects_21) $(am__objects_22) \\\n \t$(am__objects_23) $(am__objects_24) $(am__objects_25) \\\n \t$(am__objects_26) $(am__objects_27) $(am__objects_28) \\\n-\t$(am__objects_29) $(am__objects_30) $(am__objects_31)\n-am__objects_33 = close.lo file_pos.lo format.lo inquire.lo \\\n+\t$(am__objects_29) $(am__objects_30) $(am__objects_31) \\\n+\t$(am__objects_32)\n+am__objects_34 = close.lo file_pos.lo format.lo inquire.lo \\\n \tintrinsics.lo list_read.lo lock.lo open.lo read.lo \\\n \tsize_from_kind.lo transfer.lo unit.lo unix.lo write.lo\n-am__objects_34 = associated.lo abort.lo access.lo args.lo \\\n+am__objects_35 = associated.lo abort.lo access.lo args.lo \\\n \tc99_functions.lo chdir.lo chmod.lo clock.lo cpu_time.lo \\\n \tcshift0.lo ctime.lo date_and_time.lo dtime.lo env.lo \\\n \teoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo exit.lo \\\n@@ -686,8 +704,8 @@ am__objects_34 = associated.lo abort.lo access.lo args.lo \\\n \tsystem_clock.lo time.lo transpose_generic.lo umask.lo \\\n \tunlink.lo unpack_generic.lo in_pack_generic.lo \\\n \tin_unpack_generic.lo\n-am__objects_35 =\n-am__objects_36 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_36 =\n+am__objects_37 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -711,18 +729,18 @@ am__objects_36 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_37 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_38 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_38 = misc_specifics.lo\n-am__objects_39 = $(am__objects_36) $(am__objects_37) $(am__objects_38) \\\n+am__objects_39 = misc_specifics.lo\n+am__objects_40 = $(am__objects_37) $(am__objects_38) $(am__objects_39) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_40 = $(am__objects_1) $(am__objects_32) $(am__objects_33) \\\n-\t$(am__objects_34) $(am__objects_35) $(am__objects_39)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_40)\n+am__objects_41 = $(am__objects_1) $(am__objects_33) $(am__objects_34) \\\n+\t$(am__objects_35) $(am__objects_36) $(am__objects_40)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_41)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n libgfortranbegin_la_LIBADD =\n@@ -1386,6 +1404,21 @@ $(srcdir)/generated/unpack_c8.c \\\n $(srcdir)/generated/unpack_c10.c \\\n $(srcdir)/generated/unpack_c16.c\n \n+i_spread_c = \\\n+$(srcdir)/generated/spread_i1.c \\\n+$(srcdir)/generated/spread_i2.c \\\n+$(srcdir)/generated/spread_i4.c \\\n+$(srcdir)/generated/spread_i8.c \\\n+$(srcdir)/generated/spread_i16.c \\\n+$(srcdir)/generated/spread_r4.c \\\n+$(srcdir)/generated/spread_r8.c \\\n+$(srcdir)/generated/spread_r10.c \\\n+$(srcdir)/generated/spread_r16.c \\\n+$(srcdir)/generated/spread_c4.c \\\n+$(srcdir)/generated/spread_c8.c \\\n+$(srcdir)/generated/spread_c10.c \\\n+$(srcdir)/generated/spread_c16.c \n+\n m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/any.m4 m4/count.m4 m4/maxloc0.m4 m4/maxloc1.m4 m4/maxval.m4 \\\n     m4/minloc0.m4 m4/minloc1.m4 m4/minval.m4 m4/product.m4 m4/sum.m4 \\\n@@ -1395,7 +1428,7 @@ m4_files = m4/iparm.m4 m4/ifunction.m4 m4/iforeach.m4 m4/all.m4 \\\n     m4/transpose.m4 m4/eoshift1.m4 m4/eoshift3.m4 m4/exponent.m4 \\\n     m4/fraction.m4 m4/nearest.m4 m4/set_exponent.m4 m4/pow.m4 \\\n     m4/misc_specifics.m4 m4/rrspacing.m4 m4/spacing.m4 m4/pack.m4 \\\n-    m4/unpack.m4\n+    m4/unpack.m4 m4/spread.m4\n \n gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_maxloc1_c) $(i_maxval_c) $(i_minloc0_c) $(i_minloc1_c) $(i_minval_c) \\\n@@ -1404,7 +1437,7 @@ gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_eoshift3_c) $(i_cshift1_c) $(i_reshape_c) $(in_pack_c) $(in_unpack_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n     $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) $(i_unpack_c) \\\n-    selected_int_kind.inc selected_real_kind.inc kinds.h \\\n+    $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n     kinds.inc c99_protos.inc fpu-target.h\n \n \n@@ -2054,7 +2087,20 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spacing_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spacing_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spacing_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_c10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_c16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_c4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_c8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_generic.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/spread_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stat.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/stop.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/string.Plo@am__quote@\n@@ -4884,6 +4930,97 @@ unpack_c16.lo: $(srcdir)/generated/unpack_c16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o unpack_c16.lo `test -f '$(srcdir)/generated/unpack_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/unpack_c16.c\n \n+spread_i1.lo: $(srcdir)/generated/spread_i1.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_i1.lo -MD -MP -MF \"$(DEPDIR)/spread_i1.Tpo\" -c -o spread_i1.lo `test -f '$(srcdir)/generated/spread_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i1.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_i1.Tpo\" \"$(DEPDIR)/spread_i1.Plo\"; else rm -f \"$(DEPDIR)/spread_i1.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_i1.c' object='spread_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_i1.lo `test -f '$(srcdir)/generated/spread_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i1.c\n+\n+spread_i2.lo: $(srcdir)/generated/spread_i2.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_i2.lo -MD -MP -MF \"$(DEPDIR)/spread_i2.Tpo\" -c -o spread_i2.lo `test -f '$(srcdir)/generated/spread_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i2.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_i2.Tpo\" \"$(DEPDIR)/spread_i2.Plo\"; else rm -f \"$(DEPDIR)/spread_i2.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_i2.c' object='spread_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_i2.lo `test -f '$(srcdir)/generated/spread_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i2.c\n+\n+spread_i4.lo: $(srcdir)/generated/spread_i4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_i4.lo -MD -MP -MF \"$(DEPDIR)/spread_i4.Tpo\" -c -o spread_i4.lo `test -f '$(srcdir)/generated/spread_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_i4.Tpo\" \"$(DEPDIR)/spread_i4.Plo\"; else rm -f \"$(DEPDIR)/spread_i4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_i4.c' object='spread_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_i4.lo `test -f '$(srcdir)/generated/spread_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i4.c\n+\n+spread_i8.lo: $(srcdir)/generated/spread_i8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_i8.lo -MD -MP -MF \"$(DEPDIR)/spread_i8.Tpo\" -c -o spread_i8.lo `test -f '$(srcdir)/generated/spread_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_i8.Tpo\" \"$(DEPDIR)/spread_i8.Plo\"; else rm -f \"$(DEPDIR)/spread_i8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_i8.c' object='spread_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_i8.lo `test -f '$(srcdir)/generated/spread_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i8.c\n+\n+spread_i16.lo: $(srcdir)/generated/spread_i16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_i16.lo -MD -MP -MF \"$(DEPDIR)/spread_i16.Tpo\" -c -o spread_i16.lo `test -f '$(srcdir)/generated/spread_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_i16.Tpo\" \"$(DEPDIR)/spread_i16.Plo\"; else rm -f \"$(DEPDIR)/spread_i16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_i16.c' object='spread_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_i16.lo `test -f '$(srcdir)/generated/spread_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_i16.c\n+\n+spread_r4.lo: $(srcdir)/generated/spread_r4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_r4.lo -MD -MP -MF \"$(DEPDIR)/spread_r4.Tpo\" -c -o spread_r4.lo `test -f '$(srcdir)/generated/spread_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_r4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_r4.Tpo\" \"$(DEPDIR)/spread_r4.Plo\"; else rm -f \"$(DEPDIR)/spread_r4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_r4.c' object='spread_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_r4.lo `test -f '$(srcdir)/generated/spread_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_r4.c\n+\n+spread_r8.lo: $(srcdir)/generated/spread_r8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_r8.lo -MD -MP -MF \"$(DEPDIR)/spread_r8.Tpo\" -c -o spread_r8.lo `test -f '$(srcdir)/generated/spread_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_r8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_r8.Tpo\" \"$(DEPDIR)/spread_r8.Plo\"; else rm -f \"$(DEPDIR)/spread_r8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_r8.c' object='spread_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_r8.lo `test -f '$(srcdir)/generated/spread_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_r8.c\n+\n+spread_r10.lo: $(srcdir)/generated/spread_r10.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_r10.lo -MD -MP -MF \"$(DEPDIR)/spread_r10.Tpo\" -c -o spread_r10.lo `test -f '$(srcdir)/generated/spread_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_r10.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_r10.Tpo\" \"$(DEPDIR)/spread_r10.Plo\"; else rm -f \"$(DEPDIR)/spread_r10.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_r10.c' object='spread_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_r10.lo `test -f '$(srcdir)/generated/spread_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_r10.c\n+\n+spread_r16.lo: $(srcdir)/generated/spread_r16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_r16.lo -MD -MP -MF \"$(DEPDIR)/spread_r16.Tpo\" -c -o spread_r16.lo `test -f '$(srcdir)/generated/spread_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_r16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_r16.Tpo\" \"$(DEPDIR)/spread_r16.Plo\"; else rm -f \"$(DEPDIR)/spread_r16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_r16.c' object='spread_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_r16.lo `test -f '$(srcdir)/generated/spread_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_r16.c\n+\n+spread_c4.lo: $(srcdir)/generated/spread_c4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_c4.lo -MD -MP -MF \"$(DEPDIR)/spread_c4.Tpo\" -c -o spread_c4.lo `test -f '$(srcdir)/generated/spread_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_c4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_c4.Tpo\" \"$(DEPDIR)/spread_c4.Plo\"; else rm -f \"$(DEPDIR)/spread_c4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_c4.c' object='spread_c4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_c4.lo `test -f '$(srcdir)/generated/spread_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_c4.c\n+\n+spread_c8.lo: $(srcdir)/generated/spread_c8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_c8.lo -MD -MP -MF \"$(DEPDIR)/spread_c8.Tpo\" -c -o spread_c8.lo `test -f '$(srcdir)/generated/spread_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_c8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_c8.Tpo\" \"$(DEPDIR)/spread_c8.Plo\"; else rm -f \"$(DEPDIR)/spread_c8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_c8.c' object='spread_c8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_c8.lo `test -f '$(srcdir)/generated/spread_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_c8.c\n+\n+spread_c10.lo: $(srcdir)/generated/spread_c10.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_c10.lo -MD -MP -MF \"$(DEPDIR)/spread_c10.Tpo\" -c -o spread_c10.lo `test -f '$(srcdir)/generated/spread_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_c10.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_c10.Tpo\" \"$(DEPDIR)/spread_c10.Plo\"; else rm -f \"$(DEPDIR)/spread_c10.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_c10.c' object='spread_c10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_c10.lo `test -f '$(srcdir)/generated/spread_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_c10.c\n+\n+spread_c16.lo: $(srcdir)/generated/spread_c16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT spread_c16.lo -MD -MP -MF \"$(DEPDIR)/spread_c16.Tpo\" -c -o spread_c16.lo `test -f '$(srcdir)/generated/spread_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_c16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/spread_c16.Tpo\" \"$(DEPDIR)/spread_c16.Plo\"; else rm -f \"$(DEPDIR)/spread_c16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/spread_c16.c' object='spread_c16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_c16.lo `test -f '$(srcdir)/generated/spread_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_c16.c\n+\n close.lo: io/close.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT close.lo -MD -MP -MF \"$(DEPDIR)/close.Tpo\" -c -o close.lo `test -f 'io/close.c' || echo '$(srcdir)/'`io/close.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/close.Tpo\" \"$(DEPDIR)/close.Plo\"; else rm -f \"$(DEPDIR)/close.Tpo\"; exit 1; fi\n@@ -5841,6 +5978,9 @@ fpu-target.h: $(srcdir)/$(FPU_HOST_HEADER)\n @MAINTAINER_MODE_TRUE@$(i_unpack_c): m4/unpack.m4 $(I_M4_DEPS)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 unpack.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_spread_c): m4/spread.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 spread.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(gfor_built_specific_src): m4/specific.m4 m4/head.m4\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 specific.m4 > $@\n "}, {"sha": "76a361406c107773b655297590bab4f16d2ae7cb", "filename": "libgfortran/generated/spread_c10.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c10.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\n+void\n+spread_c10 (gfc_array_c10 *ret, const gfc_array_c10 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_COMPLEX_10 *rptr;\n+  GFC_COMPLEX_10 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_COMPLEX_10 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_COMPLEX_10));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_c10 (gfc_array_c10 *ret, const GFC_COMPLEX_10 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_COMPLEX_10 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_COMPLEX_10));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "0ea57561849ed08aee3a8d8a025874ab38e31947", "filename": "libgfortran/generated/spread_c16.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c16.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\n+void\n+spread_c16 (gfc_array_c16 *ret, const gfc_array_c16 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_COMPLEX_16 *rptr;\n+  GFC_COMPLEX_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_COMPLEX_16 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_COMPLEX_16));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_c16 (gfc_array_c16 *ret, const GFC_COMPLEX_16 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_COMPLEX_16 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_COMPLEX_16));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "f86da84a58f81065a0e762294e2232b1ffe801df", "filename": "libgfortran/generated/spread_c4.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c4.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+\n+void\n+spread_c4 (gfc_array_c4 *ret, const gfc_array_c4 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_COMPLEX_4 *rptr;\n+  GFC_COMPLEX_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_COMPLEX_4 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_COMPLEX_4));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_c4 (gfc_array_c4 *ret, const GFC_COMPLEX_4 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_COMPLEX_4 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_COMPLEX_4));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "7a3f4dfd2109658b5cca1d6929fd13f8a94e9fda", "filename": "libgfortran/generated/spread_c8.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_c8.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+\n+void\n+spread_c8 (gfc_array_c8 *ret, const gfc_array_c8 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_COMPLEX_8 *rptr;\n+  GFC_COMPLEX_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_COMPLEX_8 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_COMPLEX_8));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_c8 (gfc_array_c8 *ret, const GFC_COMPLEX_8 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_COMPLEX_8 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_COMPLEX_8));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "396a521eab8c6efd850e08e160e7a6ffbe23a323", "filename": "libgfortran/generated/spread_i1.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i1.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1)\n+\n+void\n+spread_i1 (gfc_array_i1 *ret, const gfc_array_i1 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_INTEGER_1 *rptr;\n+  GFC_INTEGER_1 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_INTEGER_1 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_INTEGER_1));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_i1 (gfc_array_i1 *ret, const GFC_INTEGER_1 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_INTEGER_1 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_INTEGER_1));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "5599342405403921f6fa9bbb1ef721433ff01aab", "filename": "libgfortran/generated/spread_i16.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i16.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+spread_i16 (gfc_array_i16 *ret, const gfc_array_i16 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_INTEGER_16 *rptr;\n+  GFC_INTEGER_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_INTEGER_16 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_INTEGER_16));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_i16 (gfc_array_i16 *ret, const GFC_INTEGER_16 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_INTEGER_16 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_INTEGER_16));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "d8ac9dc9af19a54d3165076b0b6064079649502a", "filename": "libgfortran/generated/spread_i2.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i2.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2)\n+\n+void\n+spread_i2 (gfc_array_i2 *ret, const gfc_array_i2 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_INTEGER_2 *rptr;\n+  GFC_INTEGER_2 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_INTEGER_2 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_INTEGER_2));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_i2 (gfc_array_i2 *ret, const GFC_INTEGER_2 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_INTEGER_2 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_INTEGER_2));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "c0890b666a12bac7f571be8376b4dd3c7bc6a53b", "filename": "libgfortran/generated/spread_i4.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i4.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+spread_i4 (gfc_array_i4 *ret, const gfc_array_i4 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_INTEGER_4 *rptr;\n+  GFC_INTEGER_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_INTEGER_4 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_INTEGER_4));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_i4 (gfc_array_i4 *ret, const GFC_INTEGER_4 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_INTEGER_4 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_INTEGER_4));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "b0032bf64dd85148df4ba54b90a19ca82555bc25", "filename": "libgfortran/generated/spread_i8.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_i8.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+spread_i8 (gfc_array_i8 *ret, const gfc_array_i8 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_INTEGER_8 *rptr;\n+  GFC_INTEGER_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_INTEGER_8 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_INTEGER_8));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_i8 (gfc_array_i8 *ret, const GFC_INTEGER_8 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_INTEGER_8 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_INTEGER_8));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "404aaa4654c413d269a0b3840b77578e7b5c2c40", "filename": "libgfortran/generated/spread_r10.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r10.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+void\n+spread_r10 (gfc_array_r10 *ret, const gfc_array_r10 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_REAL_10 *rptr;\n+  GFC_REAL_10 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_REAL_10 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_REAL_10));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_r10 (gfc_array_r10 *ret, const GFC_REAL_10 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_REAL_10 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_REAL_10));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "122673305e81ffd667540f03358638f8bb147aa1", "filename": "libgfortran/generated/spread_r16.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r16.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+void\n+spread_r16 (gfc_array_r16 *ret, const gfc_array_r16 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_REAL_16 *rptr;\n+  GFC_REAL_16 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_REAL_16 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_REAL_16));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_r16 (gfc_array_r16 *ret, const GFC_REAL_16 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_REAL_16 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_REAL_16));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "1569dbc09f35ad3584ae278f5521573cf8f05824", "filename": "libgfortran/generated/spread_r4.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r4.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+void\n+spread_r4 (gfc_array_r4 *ret, const gfc_array_r4 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_REAL_4 *rptr;\n+  GFC_REAL_4 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_REAL_4 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_REAL_4));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_r4 (gfc_array_r4 *ret, const GFC_REAL_4 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_REAL_4 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_REAL_4));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "c028f804079e2ad97a3acb403d1b808f87e211c3", "filename": "libgfortran/generated/spread_r8.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fgenerated%2Fspread_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fspread_r8.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,277 @@\n+/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+void\n+spread_r8 (gfc_array_r8 *ret, const gfc_array_r8 *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  GFC_REAL_8 *rptr;\n+  GFC_REAL_8 *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const GFC_REAL_8 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof(GFC_REAL_8));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_r8 (gfc_array_r8 *ret, const GFC_REAL_8 *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  GFC_REAL_8 * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof (GFC_REAL_8));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif"}, {"sha": "16578f788fceed598968e15694cf9dccba4ea297", "filename": "libgfortran/intrinsics/spread_generic.c", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fintrinsics%2Fspread_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fintrinsics%2Fspread_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fspread_generic.c?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -276,6 +276,92 @@ void\n spread (gfc_array_char *ret, const gfc_array_char *source,\n \tconst index_type *along, const index_type *pncopies)\n {\n+  index_type type_size;\n+\n+  type_size = GFC_DTYPE_TYPE_SIZE(ret);\n+  switch(type_size)\n+    {\n+    case GFC_DTYPE_LOGICAL_1:\n+    case GFC_DTYPE_INTEGER_1:\n+      spread_i1 ((gfc_array_i1 *) ret, (gfc_array_i1 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_2:\n+    case GFC_DTYPE_INTEGER_2:\n+      spread_i2 ((gfc_array_i2 *) ret, (gfc_array_i2 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_4:\n+    case GFC_DTYPE_INTEGER_4:\n+      spread_i4 ((gfc_array_i4 *) ret, (gfc_array_i4 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_8:\n+    case GFC_DTYPE_INTEGER_8:\n+      spread_i8 ((gfc_array_i8 *) ret, (gfc_array_i8 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+    case GFC_DTYPE_LOGICAL_16:\n+    case GFC_DTYPE_INTEGER_16:\n+      spread_i16 ((gfc_array_i16 *) ret, (gfc_array_i16 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_REAL_4:\n+      spread_r4 ((gfc_array_r4 *) ret, (gfc_array_r4 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+\n+    case GFC_DTYPE_REAL_8:\n+      spread_r8 ((gfc_array_r8 *) ret, (gfc_array_r8 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+\n+#ifdef GFC_HAVE_REAL_10\n+    case GFC_DTYPE_REAL_10:\n+      spread_r10 ((gfc_array_r10 *) ret, (gfc_array_r10 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+#endif\n+\n+#ifdef GFC_HAVE_REAL_16\n+    case GFC_DTYPE_REAL_16:\n+      spread_r16 ((gfc_array_r16 *) ret, (gfc_array_r16 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_COMPLEX_4:\n+      spread_c4 ((gfc_array_c4 *) ret, (gfc_array_c4 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+\n+    case GFC_DTYPE_COMPLEX_8:\n+      spread_c8 ((gfc_array_c8 *) ret, (gfc_array_c8 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+\n+#ifdef GFC_HAVE_COMPLEX_10\n+    case GFC_DTYPE_COMPLEX_10:\n+      spread_c10 ((gfc_array_c10 *) ret, (gfc_array_c10 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+#endif\n+\n+#ifdef GFC_HAVE_COMPLEX_16\n+    case GFC_DTYPE_COMPLEX_16:\n+      spread_c16 ((gfc_array_c16 *) ret, (gfc_array_c16 *) source,\n+\t\t *along, *pncopies);\n+      return;\n+#endif\n+\n+    }\n   spread_internal (ret, source, along, pncopies, GFC_DESCRIPTOR_SIZE (source));\n }\n \n@@ -304,8 +390,96 @@ void\n spread_scalar (gfc_array_char *ret, const char *source,\n \t       const index_type *along, const index_type *pncopies)\n {\n+  index_type type_size;\n+\n   if (!ret->dtype)\n     runtime_error (\"return array missing descriptor in spread()\");\n+\n+  type_size = GFC_DTYPE_TYPE_SIZE(ret);\n+  switch(type_size)\n+    {\n+    case GFC_DTYPE_LOGICAL_1:\n+    case GFC_DTYPE_INTEGER_1:\n+      spread_scalar_i1 ((gfc_array_i1 *) ret, (GFC_INTEGER_1 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_2:\n+    case GFC_DTYPE_INTEGER_2:\n+      spread_scalar_i2 ((gfc_array_i2 *) ret, (GFC_INTEGER_2 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_4:\n+    case GFC_DTYPE_INTEGER_4:\n+      spread_scalar_i4 ((gfc_array_i4 *) ret, (GFC_INTEGER_4 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_8:\n+    case GFC_DTYPE_INTEGER_8:\n+      spread_scalar_i8 ((gfc_array_i8 *) ret, (GFC_INTEGER_8 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+    case GFC_DTYPE_LOGICAL_16:\n+    case GFC_DTYPE_INTEGER_16:\n+      spread_scalar_i16 ((gfc_array_i16 *) ret, (GFC_INTEGER_16 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_REAL_4:\n+      spread_scalar_r4 ((gfc_array_r4 *) ret, (GFC_REAL_4 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+\n+    case GFC_DTYPE_REAL_8:\n+      spread_scalar_r8 ((gfc_array_r8 *) ret, (GFC_REAL_8 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+\n+#ifdef HAVE_GFC_REAL_10\n+    case GFC_DTYPE_REAL_10:\n+      spread_scalar_r10 ((gfc_array_r10 *) ret, (GFC_REAL_10 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+    case GFC_DTYPE_REAL_16:\n+      spread_scalar_r16 ((gfc_array_r16 *) ret, (GFC_REAL_16 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_COMPLEX_4:\n+      spread_scalar_c4 ((gfc_array_c4 *) ret, (GFC_COMPLEX_4 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+\n+    case GFC_DTYPE_COMPLEX_8:\n+      spread_scalar_c8 ((gfc_array_c8 *) ret, (GFC_COMPLEX_8 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+    case GFC_DTYPE_COMPLEX_10:\n+      spread_scalar_c10 ((gfc_array_c10 *) ret, (GFC_COMPLEX_10 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+    case GFC_DTYPE_COMPLEX_16:\n+      spread_scalar_c16 ((gfc_array_c16 *) ret, (GFC_COMPLEX_16 *) source,\n+\t\t\t*along, *pncopies);\n+      return;\n+#endif\n+\n+    }\n+\n   spread_internal_scalar (ret, source, along, pncopies, GFC_DESCRIPTOR_SIZE (ret));\n }\n "}, {"sha": "b5cad85c85fcbe3f49f3f4f6ce4a695cc1ac8b21", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -308,6 +308,66 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_16) gfc_array_l16;\n #define GFC_DESCRIPTOR_DATA(desc) ((desc)->data)\n #define GFC_DESCRIPTOR_DTYPE(desc) ((desc)->dtype)\n \n+/* Macros to get both the size and the type with a single masking operation  */\n+\n+#define GFC_DTYPE_SIZE_MASK \\\n+  ((~((index_type) 0) >> GFC_DTYPE_SIZE_SHIFT) << GFC_DTYPE_SIZE_SHIFT)\n+#define GFC_DTYPE_TYPE_SIZE_MASK (GFC_DTYPE_SIZE_MASK | GFC_DTYPE_TYPE_MASK)\n+\n+#define GFC_DTYPE_TYPE_SIZE(desc) ((desc)->dtype & GFC_DTYPE_TYPE_SIZE_MASK)\n+\n+#define GFC_DTYPE_INTEGER_1 ((GFC_DTYPE_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_INTEGER_1) << GFC_DTYPE_SIZE_SHIFT))\n+#define GFC_DTYPE_INTEGER_2 ((GFC_DTYPE_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_INTEGER_2) << GFC_DTYPE_SIZE_SHIFT))\n+#define GFC_DTYPE_INTEGER_4 ((GFC_DTYPE_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_INTEGER_4) << GFC_DTYPE_SIZE_SHIFT))\n+#define GFC_DTYPE_INTEGER_8 ((GFC_DTYPE_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_INTEGER_8) << GFC_DTYPE_SIZE_SHIFT))\n+#ifdef HAVE_GFC_INTEGER_16\n+#define GFC_DTYPE_INTEGER_16 ((GFC_DTYPE_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_INTEGER_16) << GFC_DTYPE_SIZE_SHIFT))\n+#endif\n+\n+#define GFC_DTYPE_LOGICAL_1 ((GFC_DTYPE_LOGICAL << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_LOGICAL_1) << GFC_DTYPE_SIZE_SHIFT))\n+#define GFC_DTYPE_LOGICAL_2 ((GFC_DTYPE_LOGICAL << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_LOGICAL_2) << GFC_DTYPE_SIZE_SHIFT))\n+#define GFC_DTYPE_LOGICAL_4 ((GFC_DTYPE_LOGICAL << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_LOGICAL_4) << GFC_DTYPE_SIZE_SHIFT))\n+#define GFC_DTYPE_LOGICAL_8 ((GFC_DTYPE_LOGICAL << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_LOGICAL_8) << GFC_DTYPE_SIZE_SHIFT))\n+#ifdef HAVE_GFC_LOGICAL_16\n+#define GFC_DTYPE_LOGICAL_16 ((GFC_DTYPE_LOGICAL << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_LOGICAL_16) << GFC_DTYPE_SIZE_SHIFT))\n+#endif\n+\n+#define GFC_DTYPE_REAL_4 ((GFC_DTYPE_REAL << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_REAL_4) << GFC_DTYPE_SIZE_SHIFT))\n+#define GFC_DTYPE_REAL_8 ((GFC_DTYPE_REAL << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_REAL_8) << GFC_DTYPE_SIZE_SHIFT))\n+#ifdef HAVE_GFC_REAL_10\n+#define GFC_DTYPE_REAL_10  ((GFC_DTYPE_REAL << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_REAL_10) << GFC_DTYPE_SIZE_SHIFT))\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+#define GFC_DTYPE_REAL_16 ((GFC_DTYPE_REAL << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_REAL_16) << GFC_DTYPE_SIZE_SHIFT))\n+#endif\n+\n+#define GFC_DTYPE_COMPLEX_4 ((GFC_DTYPE_COMPLEX << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_COMPLEX_4) << GFC_DTYPE_SIZE_SHIFT))\n+#define GFC_DTYPE_COMPLEX_8 ((GFC_DTYPE_COMPLEX << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_COMPLEX_8) << GFC_DTYPE_SIZE_SHIFT))\n+#ifdef HAVE_GFC_COMPLEX_10\n+#define GFC_DTYPE_COMPLEX_10 ((GFC_DTYPE_COMPLEX << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_COMPLEX_10) << GFC_DTYPE_SIZE_SHIFT))\n+#endif\n+#ifdef HAVE_GFC_COMPLEX_16\n+#define GFC_DTYPE_COMPLEX_16 ((GFC_DTYPE_COMPLEX << GFC_DTYPE_TYPE_SHIFT) \\\n+   | (sizeof(GFC_COMPLEX_16) << GFC_DTYPE_SIZE_SHIFT))\n+#endif\n+\n /* Runtime library include.  */\n #define stringize(x) expand_macro(x)\n #define expand_macro(x) # x\n@@ -910,6 +970,142 @@ extern void unpack1_c16 (gfc_array_c16 *, const gfc_array_c16 *,\n internal_proto(unpack1_c16);\n #endif\n \n+/* Helper functions for spread.  */\n+\n+extern void spread_i1 (gfc_array_i1 *, const gfc_array_i1 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_i1);\n+\n+extern void spread_i2 (gfc_array_i2 *, const gfc_array_i2 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_i2);\n+\n+extern void spread_i4 (gfc_array_i4 *, const gfc_array_i4 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_i4);\n+\n+extern void spread_i8 (gfc_array_i8 *, const gfc_array_i8 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_i8);\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+extern void spread_i16 (gfc_array_i16 *, const gfc_array_i16 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_i16);\n+\n+#endif\n+\n+extern void spread_r4 (gfc_array_r4 *, const gfc_array_r4 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_r4);\n+\n+extern void spread_r8 (gfc_array_r8 *, const gfc_array_r8 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_r8);\n+\n+#ifdef HAVE_GFC_REAL_10\n+extern void spread_r10 (gfc_array_r10 *, const gfc_array_r10 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_r10);\n+\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+extern void spread_r16 (gfc_array_r16 *, const gfc_array_r16 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_r16);\n+\n+#endif\n+\n+extern void spread_c4 (gfc_array_c4 *, const gfc_array_c4 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_c4);\n+\n+extern void spread_c8 (gfc_array_c8 *, const gfc_array_c8 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_c8);\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+extern void spread_c10 (gfc_array_c10 *, const gfc_array_c10 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_c10);\n+\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+extern void spread_c16 (gfc_array_c16 *, const gfc_array_c16 *,\n+\t\t       const index_type, const index_type);\n+internal_proto(spread_c16);\n+\n+#endif\n+\n+extern void spread_scalar_i1 (gfc_array_i1 *, const GFC_INTEGER_1 *,\n+\t\t\t      const index_type, const index_type);\n+internal_proto(spread_scalar_i1);\n+\n+extern void spread_scalar_i2 (gfc_array_i2 *, const GFC_INTEGER_2 *,\n+\t\t\t      const index_type, const index_type);\n+internal_proto(spread_scalar_i2);\n+\n+extern void spread_scalar_i4 (gfc_array_i4 *, const GFC_INTEGER_4 *,\n+\t\t\t      const index_type, const index_type);\n+internal_proto(spread_scalar_i4);\n+\n+extern void spread_scalar_i8 (gfc_array_i8 *, const GFC_INTEGER_8 *,\n+\t\t\t      const index_type, const index_type);\n+internal_proto(spread_scalar_i8);\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+extern void spread_scalar_i16 (gfc_array_i16 *, const GFC_INTEGER_16 *,\n+\t\t\t       const index_type, const index_type);\n+internal_proto(spread_scalar_i16);\n+\n+#endif\n+\n+extern void spread_scalar_r4 (gfc_array_r4 *, const GFC_REAL_4 *,\n+\t\t\t      const index_type, const index_type);\n+internal_proto(spread_scalar_r4);\n+\n+extern void spread_scalar_r8 (gfc_array_r8 *, const GFC_REAL_8 *,\n+\t\t\t      const index_type, const index_type);\n+internal_proto(spread_scalar_r8);\n+\n+#ifdef HAVE_GFC_REAL_10\n+extern void spread_scalar_r10 (gfc_array_r10 *, const GFC_REAL_10 *,\n+\t\t\t       const index_type, const index_type);\n+internal_proto(spread_scalar_r10);\n+\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+extern void spread_scalar_r16 (gfc_array_r16 *, const GFC_REAL_16 *,\n+\t\t\t       const index_type, const index_type);\n+internal_proto(spread_scalar_r16);\n+\n+#endif\n+\n+extern void spread_scalar_c4 (gfc_array_c4 *, const GFC_COMPLEX_4 *,\n+\t\t\t      const index_type, const index_type);\n+internal_proto(spread_scalar_c4);\n+\n+extern void spread_scalar_c8 (gfc_array_c8 *, const GFC_COMPLEX_8 *,\n+\t\t\t      const index_type, const index_type);\n+internal_proto(spread_scalar_c8);\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+extern void spread_scalar_c10 (gfc_array_c10 *, const GFC_COMPLEX_10 *,\n+\t\t\t       const index_type, const index_type);\n+internal_proto(spread_scalar_c10);\n+\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+extern void spread_scalar_c16 (gfc_array_c16 *, const GFC_COMPLEX_16 *,\n+\t\t\t       const index_type, const index_type);\n+internal_proto(spread_scalar_c16);\n+\n+#endif\n+\n /* string_intrinsics.c */\n \n extern int compare_string (GFC_INTEGER_4, const char *,"}, {"sha": "c301d1f1e3221505c0d209545d5102fc61cc5025", "filename": "libgfortran/m4/spread.m4", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fm4%2Fspread.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f2543f2eb59be6421e9a272eb2447385e89cb8/libgfortran%2Fm4%2Fspread.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fspread.m4?ref=75f2543f2eb59be6421e9a272eb2447385e89cb8", "patch": "@@ -0,0 +1,279 @@\n+`/* Special implementation of the SPREAD intrinsic\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>, based on\n+   spread_generic.c written by Paul Brook <paul@nowt.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Ligbfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>'\n+\n+include(iparm.m4)dnl\n+\n+`#if defined (HAVE_'rtype_name`)\n+\n+void\n+spread_'rtype_code` ('rtype` *ret, const 'rtype` *source,\n+\t\t const index_type along, const index_type pncopies)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type rdelta = 0;\n+  index_type rrank;\n+  index_type rs;\n+  'rtype_name` *rptr;\n+  'rtype_name` *dest;\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type srank;\n+  const 'rtype_name` *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type n;\n+  index_type dim;\n+  index_type ncopies;\n+\n+  srank = GFC_DESCRIPTOR_RANK(source);\n+\n+  rrank = srank + 1;\n+  if (rrank > GFC_MAX_DIMENSIONS)\n+    runtime_error (\"return rank too large in spread()\");\n+\n+  if (along > rrank)\n+      runtime_error (\"dim outside of rank in spread()\");\n+\n+  ncopies = pncopies;\n+\n+  if (ret->data == NULL)\n+    {\n+      /* The front end has signalled that we need to populate the\n+\t return array descriptor.  */\n+      ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rrank;\n+      dim = 0;\n+      rs = 1;\n+      for (n = 0; n < rrank; n++)\n+\t{\n+\t  ret->dim[n].stride = rs;\n+\t  ret->dim[n].lbound = 0;\n+\t  if (n == along - 1)\n+\t    {\n+\t      ret->dim[n].ubound = ncopies - 1;\n+\t      rdelta = rs;\n+\t      rs *= ncopies;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[dim] = 0;\n+\t      extent[dim] = source->dim[dim].ubound + 1\n+\t\t- source->dim[dim].lbound;\n+\t      sstride[dim] = source->dim[dim].stride;\n+\t      rstride[dim] = rs;\n+\n+\t      ret->dim[n].ubound = extent[dim]-1;\n+\t      rs *= extent[dim];\n+\t      dim++;\n+\t    }\n+\t}\n+      ret->offset = 0;\n+      if (rs > 0)\n+        ret->data = internal_malloc_size (rs * sizeof('rtype_name`));\n+      else\n+\t{\n+\t  ret->data = internal_malloc_size (1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      int zero_sized;\n+\n+      zero_sized = 0;\n+\n+      dim = 0;\n+      if (GFC_DESCRIPTOR_RANK(ret) != rrank)\n+\truntime_error (\"rank mismatch in spread()\");\n+\n+      if (compile_options.bounds_check)\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      index_type ret_extent;\n+\n+\t      ret_extent = ret->dim[n].ubound + 1 - ret->dim[n].lbound;\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\n+\t\t  if (ret_extent != ncopies)\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent, (long int) ncopies);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (ret_extent != extent[dim])\n+\t\t    runtime_error(\"Incorrect extent in return value of SPREAD\"\n+\t\t\t\t  \" intrinsic in dimension %ld: is %ld,\"\n+\t\t\t\t  \" should be %ld\", (long int) n+1,\n+\t\t\t\t  (long int) ret_extent,\n+\t\t\t\t  (long int) extent[dim]);\n+\t\t    \n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  for (n = 0; n < rrank; n++)\n+\t    {\n+\t      if (n == along - 1)\n+\t\t{\n+\t\t  rdelta = ret->dim[n].stride;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  count[dim] = 0;\n+\t\t  extent[dim] = source->dim[dim].ubound + 1\n+\t\t    - source->dim[dim].lbound;\n+\t\t  if (extent[dim] <= 0)\n+\t\t    zero_sized = 1;\n+\t\t  sstride[dim] = source->dim[dim].stride;\n+\t\t  rstride[dim] = ret->dim[n].stride;\n+\t\t  dim++;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (zero_sized)\n+\treturn;\n+\n+      if (sstride[0] == 0)\n+\tsstride[0] = 1;\n+    }\n+  sstride0 = sstride[0];\n+  rstride0 = rstride[0];\n+  rptr = ret->data;\n+  sptr = source->data;\n+\n+  while (sptr)\n+    {\n+      /* Spread this element.  */\n+      dest = rptr;\n+      for (n = 0; n < ncopies; n++)\n+        {\n+\t  *dest = *sptr;\n+          dest += rdelta;\n+        }\n+      /* Advance to the next element.  */\n+      sptr += sstride0;\n+      rptr += rstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          sptr -= sstride[n] * extent[n];\n+          rptr -= rstride[n] * extent[n];\n+          n++;\n+          if (n >= srank)\n+            {\n+              /* Break out of the loop.  */\n+              sptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              sptr += sstride[n];\n+              rptr += rstride[n];\n+            }\n+        }\n+    }\n+}\n+\n+/* This version of spread_internal treats the special case of a scalar\n+   source.  This is much simpler than the more general case above.  */\n+\n+void\n+spread_scalar_'rtype_code` ('rtype` *ret, const 'rtype_name` *source,\n+\t\t\tconst index_type along, const index_type pncopies)\n+{\n+  int n;\n+  int ncopies = pncopies;\n+  'rtype_name` * dest;\n+  index_type stride;\n+\n+  if (GFC_DESCRIPTOR_RANK (ret) != 1)\n+    runtime_error (\"incorrect destination rank in spread()\");\n+\n+  if (along > 1)\n+    runtime_error (\"dim outside of rank in spread()\");\n+\n+  if (ret->data == NULL)\n+    {\n+      ret->data = internal_malloc_size (ncopies * sizeof ('rtype_name`));\n+      ret->offset = 0;\n+      ret->dim[0].stride = 1;\n+      ret->dim[0].lbound = 0;\n+      ret->dim[0].ubound = ncopies - 1;\n+    }\n+  else\n+    {\n+      if (ncopies - 1 > (ret->dim[0].ubound - ret->dim[0].lbound)\n+\t\t\t   / ret->dim[0].stride)\n+\truntime_error (\"dim too large in spread()\");\n+    }\n+\n+  dest = ret->data;\n+  stride = ret->dim[0].stride;\n+\n+  for (n = 0; n < ncopies; n++)\n+    {\n+      *dest = *source;\n+      dest += stride;\n+    }\n+}\n+\n+#endif\n+'"}]}