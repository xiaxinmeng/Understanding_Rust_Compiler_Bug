{"sha": "4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE4ZmIxYTFkZTdjMzRmYzc4OGNjY2EyMWYzYTE1OTgwYmJjZTA5Mw==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2013-04-26T00:28:35Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2013-04-26T00:28:35Z"}, "message": "This patch is the main part of a consolodation of the hash_table patches to the...\n\nThis patch is the main part of a consolodation of the hash_table\npatches to the cxx-conversion branch for files not under gcc/config.\n\nUpdate various hash tables from htab_t to hash_table.\nModify types and calls to match.\n\n* tree-parloops.c'reduction\n* tree-parloops.c'name_to_copy\n\nFold reduction_info_hash and reduction_info_eq into new struct\nreduction_hasher.  Fold name_to_copy_elt_eq and name_to_copy_elt_hash\ninto new struct name_to_copy_hasher.\n\n* trans-mem.c'tm_log\n\nFold tm_log_hash, tm_log_eq, tm_log_free into new struct log_entry_hasher.\n\n* trans-mem.c'tm_memopt_value_numbers\n\nFold tm_memop_hash, tm_memop_eq into new struct tm_memop_hasher.\n\n* tree-ssa-strlen.c'decl_to_stridxlist_htab\n\nFold decl_to_stridxlist_hash into new struct stridxlist_hasher.\n\n* tree-ssa-loop-ivopts.c'ivopts_data::inv_expr_tab\n\nFold htab_inv_expr_hash and htab_inv_expr_eq into new struct\niv_inv_expr_hasher.\n\n* tree-ssa-uncprop.c'equiv\n\nEquiv renamed to val_ssa_equiv because of name ambiguity with local variables.\n\nFold equiv_hash, equiv_eq and equiv_free into new struct val_ssa_equiv_hasher.\n\nRenamed variables equiv_hash_elt to an_equiv_elt because of name ambiguity\nwith struct type.  Changed equiv_hash_elt_p to an_equiv_elt_p to match.\n\n* tree-ssa-phiopt.c'seen_ssa_names\n\nFold name_to_bb_hash and name_to_bb_eq into new struct ssa_names_hasher.\n\n* tree-ssa-structalias.c'pointer_equiv_class_table\n* tree-ssa-structalias.c'location_equiv_class_table\n\nFold equiv_class_label_hash and equiv_class_label_eq into new\nstruct equiv_class_hasher.\n\n* tree-ssa-structalias.c'shared_bitmap_table\n\nFold shared_bitmap_hash and shared_bitmap_eq into new struct\nshared_bitmap_hasher.\n\n* tree-ssa-live.c'var_map_base_init::tree_to_index\n\nNew struct tree_int_map_hasher.\n\n* tree-sra.c'candidates\n\nFold uid_decl_map_hash and uid_decl_map_eq into new struct\nuid_decl_hasher.  This change moves the definitions from tree-ssa.c\ninto tree-sra.c and removes the declarations from tree-flow.h\n\ntree-browser.c\n\nRemove stale declaration of removed TB_parent_eq.\nFix template parameter for base class to match value_type.\n\ngimple.h\n\nUse gimplify_hasher::hash rather than gimple_tree_hash in the\n  assertion check.\nChange return values to match return type. (I.e. no conversions.)\n\n* graphite-clast-to-gimple.c'ivs_params::newivs_index\n* graphite-clast-to-gimple.c'ivs_params::params_index\n* graphite-clast-to-gimple.c'print_generated_program::params_index\n* graphite-clast-to-gimple.c'gloog::newivs_index\n* graphite-clast-to-gimple.c'gloog::params_index\n* graphite.c graphite_transform_loops::bb_pbb_mapping\n* sese.c copy_bb_and_scalar_dependences::rename_map\n\nMove hash table declarations to a new graphite-htab.h, because they\nare used in few places.\n\nRemove unused:\n\nhtab_t scop::original_pddrs\nSCOP_ORIGINAL_PDDRS\n\nRemove unused:\n\ninsert_loop_close_phis\ninsert_guard_phis\ndebug_ivtype_map\nivtype_map_elt_info\nnew_ivtype_map_elt\n\n* gimplify.c'gimplify_ctx::temp_htab\n\nMove struct gimple_temp_hash_elt and struct gimplify_ctx to a new\ngimplify-ctx.h, because they are used few places.\n\n* cselib.c'cselib_hash_table\n* gcse.c'pre_ldst_table\n* gimple-ssa-strength-reduction.c'base_cand_map\n* haifa-sched.c'delay_htab\n* haifa-sched.c'delay_htab_i2\n* ira-color.c'allocno_hard_regs_htab\n* ira-costs.c'cost_classes_htab\n* loop-invariant.c'merge_identical_invariants::eq\n* loop-iv.c'bivs\n* loop-unroll.c'opt_info::insns_to_split\n* loop-unroll.c'opt_info::insns_with_var_to_expand\n* passes.c'name_to_pass_map\n* plugin.c'event_tab\n* postreload-gcse.c'expr_table\n* store-motion.c'store_motion_mems_table\n* tree-cfg.c'discriminator_per_locus\n* tree-scalar-evolution.c'resolve_mixers::cache\n* tree-ssa-dom.c'avail_exprs\n\nRemove unused:\ndse.c bitmap clear_alias_sets\ndse.c bitmap disqualified_clear_alias_sets\ndse.c alloc_pool clear_alias_mode_pool\ndse.c dse_step2_spill\ndse.c dse_step5_spill\ngraphds.h htab_t graph::indices\n\n* attribs.c'scoped_attributes::attribute_hash\n* bitmap.c'bitmap_desc_hash\n* dwarf2cfi.c'trace_index\n* dwarf2out.c'break_out_includes::cu_hash_table\n* dwarf2out.c'copy_decls_for_unworthy_types::decl_table\n* dwarf2out.c'optimize_external_refs::map\n* dwarf2out.c'output_comp_unit::extern_map\n* dwarf2out.c'output_comdat_type_unit::extern_map\n* dwarf2out.c'output_macinfo::macinfo_htab\n* dwarf2out.c'optimize_location_lists::htab\n* dwarf2out.c'dwarf2out_finish::comdat_type_table\n* except.c'ehspec_hash_type\n* except.c'assign_filter_values::ttypes\n* except.c'assign_filter_values::ehspec\n* except.c'sjlj_assign_call_site_values::ar_hash\n* except.c'convert_to_eh_region_ranges::ar_hash\n* trans-mem.c'tm_new_mem_hash\n* tree-browser.c'TB_up_ht\n* tree-eh.c'finally_tree\n\nMove the declaration of hash_table <alloc_pool_hasher> alloc_pool_hash\nin alloc-pool.c to after the method definitions for its parameter\nclass.\n\n* ggc-common.c'loc_hash\n* ggc-common.c'ptr_hash\n\nAdd a new hash_table method elements_with_deleted to meet the needs of\ngcc-common.c.\n\nCorrect many methods with parameter types compare_type to the correct\nvalue_type.  (Correct code was unlikely to notice the change, but\nincorrect code will.)\n\n* tree-complex.c'complex_variable_components\n* tree-parloops.c'eliminate_local_variables_stmt::decl_address\n* tree-parloops.c'separate_decls_in_region::decl_copies\n\nMove hash table declarations to a new tree-hasher.h, to resolve\ncompilation dependences and because they are used in few places.\n\n* lto-streamer.h'output_block::string_hash_table\n* lto-streamer-in.c'file_name_hash_table\n* lto-streamer.c'tree_htab\n\nThe struct string_slot moves from data-streamer.h to lto-streamer.h to\nresolve compilation dependences.\n\nTested on x86_64.\n\n\nIndex: gcc/ChangeLog\n\n2013-04-25  Lawrence Crowl  <crowl@google.com>\n\n\t* Makefile.in: Update as needed below.\n\n\t* alloc-pool.c (static hash_table <alloc_pool_hasher> alloc_pool_hash):\n\tMove declaration to after the type's method definitons.\n\n\t* attribs.c (htab_t scoped_attributes::attribute_hash):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* bitmap.c (htab_t bitmap_desc_hash):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* cselib.c (htab_t cselib_hash_table):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* data-streamer.h (struct string_slot): Move to lto-streamer.h.\n\t(hash_string_slot_node): Move implementation into lto-streamer.h\n\tstruct string_slot_hasher.\n\t(eq_string_slot_node): Likewise.\n\n\t* data-streamer-out.c: Update output_block::string_hash_table\n\tdependent calls and types.\n\n\t* dwarf2cfi.c (htab_t trace_index):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* dwarf2out.c (htab_t break_out_includes::cu_hash_table):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(htab_t copy_decls_for_unworthy_types::decl_table): Likewise.\n\t(htab_t optimize_external_refs::map): Likewise.\n\t(htab_t output_comp_unit::extern_map): Likewise.\n\t(htab_t output_comdat_type_unit::extern_map): Likewise.\n\t(htab_t output_macinfo::macinfo_htab): Likewise.\n\t(htab_t optimize_location_lists::htab): Likewise.\n\t(htab_t dwarf2out_finish::comdat_type_table): Likewise.\n\n\t* except.c (htab_t ehspec_hash_type):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(assign_filter_values::ttypes): Likewise.\n\t(assign_filter_values::ehspec): Likewise.\n\t(sjlj_assign_call_site_values::ar_hash): Likewise.\n\t(convert_to_eh_region_ranges::ar_hash): Likewise.\n\n\t* gcse.c (htab_t pre_ldst_table):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* ggc-common.c (htab_t saving_htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(htab_t loc_hash): Likewise.\n\t(htab_t ptr_hash): Likewise.\n\t(call_count): Rename ggc_call_count.\n\t(call_alloc): Rename ggc_call_alloc.\n\t(loc_descriptor): Rename make_loc_descriptor.\n\t(add_statistics): Rename ggc_add_statistics.\n\n\t* ggc-common.c (saving_htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* gimple.h (struct gimplify_ctx): Move to gimplify-ctx.h.\n\t(push_gimplify_context): Likewise.\n\t(pop_gimplify_context): Likewise.\n\t(struct gimple_temp_hash_elt): Added.\n\t(struct gimplify_hasher): Likewise.\n\t(struct gimplify_ctx.temp_htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* gimple-fold.c: Include gimplify-ctx.h.\n\n\t* gimple-ssa-strength-reduction.c (htab_t base_cand_map):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(base_cand_dump_callback): Rename to ssa_base_cand_dump_callback to\n\tavoid potential global name collision.\n\n\t* gimplify.c: Include gimplify-ctx.h.\n\t(struct gimple_temp_hash_elt): Move to gimplify-ctx.h.\n\t(htab_t gimplify_ctx::temp_htab):\n\tUpdate dependent calls and types for new type hash_table.\n\t(gimple_tree_hash): Move into gimplify_hasher in gimplify-ctx.h.\n\t(gimple_tree_eq): Move into gimplify_hasher in gimplify-ctx.h.\n\n\t* gimplify-ctx.h: New.\n\t(struct gimple_temp_hash_elt): Move from gimplify.c.\n\t(class gimplify_hasher): New.\n\t(struct gimplify_ctx): Move from gimple.h.\n\t(htab_t gimplify_ctx::temp_htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* graphite-clast-to-gimple.c: Include graphite-htab.h.\n\t(htab_t ivs_params::newivs_index):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(htab_t ivs_params::params_index): Likewise.\n\t(htab_t print_generated_program::params_index): Likewise.\n\t(htab_t gloog::newivs_index): Likewise.\n\t(htab_t gloog::params_index): Likewise.\n\n\t* graphite.c: Include graphite-htab.h.\n\t4htab_t graphite_transform_loops::bb_pbb_mapping):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* graphite-clast-to-gimple.h: (extern gloog) Move to graphite-htab.h.\n\t(bb_pbb_map_hash): Fold into bb_pbb_htab_type in graphite-htab.h.\n\t(eq_bb_pbb_map): Fold into bb_pbb_htab_type in graphite-htab.h.\n\n\t* graphite-dependences.c: Include graphite-htab.h.\n\t(loop_is_parallel_p): Change hash table type of parameter.\n\n\t* graphite-htab.h: New.\n\t(typedef hash_table <bb_pbb_hasher> bb_pbb_htab_type): New.\n\t(extern find_pbb_via_hash): Move from graphite-poly.h.\n\t(extern loop_is_parallel_p): Move from graphite-poly.h.\n\t(extern get_loop_body_pbbs): Move from graphite-poly.h.\n\n\t* graphite-poly.h (extern find_pbb_via_hash): Move to graphite-htab.h.\n\t(extern loop_is_parallel_p): Move to graphite-htab.h.\n\t(extern get_loop_body_pbbs): Move to graphite-htab.h.\n\n\t* haifa-sched.c (htab_t delay_htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(htab_t delay_htab_i2): Likewise.\n\n\t* ira-color.c (htab_t allocno_hard_regs_htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* ira-costs.c (htab_t cost_classes_htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* loop-invariant.c (htab_t merge_identical_invariants::eq):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* loop-iv.c (htab_t bivs):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* loop-unroll.c (htab_t opt_info::insns_to_split):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(htab_t opt_info::insns_with_var_to_expand): Likewise.\n\n\t* lto-streamer.h (struct string_slot): Move from data-streamer.h\n\t(struct string_slot_hasher): New.\n\t(htab_t output_block::string_hash_table):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* lto-streamer-in.c (freeing_string_slot_hasher): New.\n\t(htab_t file_name_hash_table):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* lto-streamer-out.c: Update output_block::string_hash_table dependent\n\tcalls and types.\n\n\t* lto-streamer.c (htab_t tree_htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* omp-low.c: Include gimplify-ctx.h.\n\n\t* passes.c (htab_t name_to_pass_map):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(pass_traverse): Rename to passes_pass_traverse.\n\n\t* plugin.c (htab_t event_tab):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* postreload-gcse.c (htab_t expr_table):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(dump_hash_table_entry): Rename dump_expr_hash_table_entry.\n\n\t* sese.c (debug_rename_map_1): Make extern.\n\t(htab_t copy_bb_and_scalar_dependences::rename_map):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* sese.h (extern debug_rename_map): Move to .c file.\n\n\t* store-motion.c (htab_t store_motion_mems_table):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* trans-mem.c (htab_t tm_new_mem_hash):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-browser.c (htab_t TB_up_ht):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-cfg.c (htab_t discriminator_per_locus):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-complex.c: Include tree-hasher.h\n\t(htab_t complex_variable_components):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-eh.c (htab_t finally_tree):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-flow.h (extern int_tree_map_hash): Moved into tree-hasher\n\tstruct int_tree_hasher.\n\t(extern int_tree_map_eq): Likewise.\n\t(uid_decl_map_hash): Removed.\n\t(extern decl_tree_map_eq): Likewise.\n\n\t* tree-hasher.h: New.\n\t(struct int_tree_hasher): New.\n\t(typedef int_tree_htab_type): New.\n\n\t* tree-inline.c: Include gimplify-ctx.h.\n\n\t* tree-mudflap.c: Include gimplify-ctx.h.\n\n\t* tree-parloops.c: Include tree-hasher.h.\n\t(htab_t eliminate_local_variables_stmt::decl_address):\n\tChange type to hash_table.  Update dependent calls and types.\n\t(htab_t separate_decls_in_region::decl_copies): Likewise.\n\n\t* tree-scalar-evolution.c (htab_t resolve_mixers::cache):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-sra.c (candidates):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-ssa.c (int_tree_map_eq): Moved into struct int_tree_hasher\n\tin tree-flow.h.\n\t(int_tree_map_hash): Likewise.\n\n\t* tree-ssa-dom.c (htab_t avail_exprs):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-ssa-live.c (var_map_base_init::tree_to_index):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-ssa-loop-ivopts.c (struct ivopts_data.inv_expr_tab):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-ssa-phiopt.c (seen_ssa_names):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-ssa-strlen.c (decl_to_stridxlist_htab):\n\tChange type to hash_table.  Update dependent calls and types.\n\n\t* tree-ssa-uncprop.c (equiv):\n\tChange type to hash_table.  Update dependent calls and types.\n\nFrom-SVN: r198329", "tree": {"sha": "5115f0a81b7cea52ab7997ce3322160f2baf2374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5115f0a81b7cea52ab7997ce3322160f2baf2374"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/comments", "author": null, "committer": null, "parents": [{"sha": "11dae3ad79feec9dda4610f1f9adbc742a2b3661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11dae3ad79feec9dda4610f1f9adbc742a2b3661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11dae3ad79feec9dda4610f1f9adbc742a2b3661"}], "stats": {"total": 4415, "additions": 2572, "deletions": 1843}, "files": [{"sha": "c63c9e08f7c2ec9c3aac92e9b685a12397250409", "filename": "gcc/ChangeLog", "status": "modified", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -1,3 +1,240 @@\n+2013-04-25  Lawrence Crowl  <crowl@google.com>\n+\n+\t* Makefile.in: Update as needed below.\n+\n+\t* alloc-pool.c (static hash_table <alloc_pool_hasher> alloc_pool_hash):\n+\tMove declaration to after the type's method definitons.\n+\n+\t* attribs.c (htab_t scoped_attributes::attribute_hash):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* bitmap.c (htab_t bitmap_desc_hash):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* cselib.c (htab_t cselib_hash_table):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* data-streamer.h (struct string_slot): Move to lto-streamer.h.\n+\t(hash_string_slot_node): Move implementation into lto-streamer.h\n+\tstruct string_slot_hasher.\n+\t(eq_string_slot_node): Likewise.\n+\n+\t* data-streamer-out.c: Update output_block::string_hash_table\n+\tdependent calls and types.\n+\n+\t* dwarf2cfi.c (htab_t trace_index):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* dwarf2out.c (htab_t break_out_includes::cu_hash_table):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(htab_t copy_decls_for_unworthy_types::decl_table): Likewise.\n+\t(htab_t optimize_external_refs::map): Likewise.\n+\t(htab_t output_comp_unit::extern_map): Likewise.\n+\t(htab_t output_comdat_type_unit::extern_map): Likewise.\n+\t(htab_t output_macinfo::macinfo_htab): Likewise.\n+\t(htab_t optimize_location_lists::htab): Likewise.\n+\t(htab_t dwarf2out_finish::comdat_type_table): Likewise.\n+\n+\t* except.c (htab_t ehspec_hash_type):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(assign_filter_values::ttypes): Likewise.\n+\t(assign_filter_values::ehspec): Likewise.\n+\t(sjlj_assign_call_site_values::ar_hash): Likewise.\n+\t(convert_to_eh_region_ranges::ar_hash): Likewise.\n+\n+\t* gcse.c (htab_t pre_ldst_table):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* ggc-common.c (htab_t saving_htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(htab_t loc_hash): Likewise.\n+\t(htab_t ptr_hash): Likewise.\n+\t(call_count): Rename ggc_call_count.\n+\t(call_alloc): Rename ggc_call_alloc.\n+\t(loc_descriptor): Rename make_loc_descriptor.\n+\t(add_statistics): Rename ggc_add_statistics.\n+\n+\t* ggc-common.c (saving_htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* gimple.h (struct gimplify_ctx): Move to gimplify-ctx.h.\n+\t(push_gimplify_context): Likewise.\n+\t(pop_gimplify_context): Likewise.\n+\t(struct gimple_temp_hash_elt): Added.\n+\t(struct gimplify_hasher): Likewise.\n+\t(struct gimplify_ctx.temp_htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* gimple-fold.c: Include gimplify-ctx.h.\n+\n+\t* gimple-ssa-strength-reduction.c (htab_t base_cand_map):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(base_cand_dump_callback): Rename to ssa_base_cand_dump_callback to\n+\tavoid potential global name collision.\n+\n+\t* gimplify.c: Include gimplify-ctx.h.\n+\t(struct gimple_temp_hash_elt): Move to gimplify-ctx.h.\n+\t(htab_t gimplify_ctx::temp_htab):\n+\tUpdate dependent calls and types for new type hash_table.\n+\t(gimple_tree_hash): Move into gimplify_hasher in gimplify-ctx.h.\n+\t(gimple_tree_eq): Move into gimplify_hasher in gimplify-ctx.h.\n+\n+\t* gimplify-ctx.h: New.\n+\t(struct gimple_temp_hash_elt): Move from gimplify.c.\n+\t(class gimplify_hasher): New.\n+\t(struct gimplify_ctx): Move from gimple.h.\n+\t(htab_t gimplify_ctx::temp_htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* graphite-clast-to-gimple.c: Include graphite-htab.h.\n+\t(htab_t ivs_params::newivs_index):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(htab_t ivs_params::params_index): Likewise.\n+\t(htab_t print_generated_program::params_index): Likewise.\n+\t(htab_t gloog::newivs_index): Likewise.\n+\t(htab_t gloog::params_index): Likewise.\n+\n+\t* graphite.c: Include graphite-htab.h.\n+\t4htab_t graphite_transform_loops::bb_pbb_mapping):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* graphite-clast-to-gimple.h: (extern gloog) Move to graphite-htab.h.\n+\t(bb_pbb_map_hash): Fold into bb_pbb_htab_type in graphite-htab.h.\n+\t(eq_bb_pbb_map): Fold into bb_pbb_htab_type in graphite-htab.h.\n+\n+\t* graphite-dependences.c: Include graphite-htab.h.\n+\t(loop_is_parallel_p): Change hash table type of parameter.\n+\n+\t* graphite-htab.h: New.\n+\t(typedef hash_table <bb_pbb_hasher> bb_pbb_htab_type): New.\n+\t(extern find_pbb_via_hash): Move from graphite-poly.h.\n+\t(extern loop_is_parallel_p): Move from graphite-poly.h.\n+\t(extern get_loop_body_pbbs): Move from graphite-poly.h.\n+\n+\t* graphite-poly.h (extern find_pbb_via_hash): Move to graphite-htab.h.\n+\t(extern loop_is_parallel_p): Move to graphite-htab.h.\n+\t(extern get_loop_body_pbbs): Move to graphite-htab.h.\n+\n+\t* haifa-sched.c (htab_t delay_htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(htab_t delay_htab_i2): Likewise.\n+\n+\t* ira-color.c (htab_t allocno_hard_regs_htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* ira-costs.c (htab_t cost_classes_htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* loop-invariant.c (htab_t merge_identical_invariants::eq):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* loop-iv.c (htab_t bivs):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* loop-unroll.c (htab_t opt_info::insns_to_split):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(htab_t opt_info::insns_with_var_to_expand): Likewise.\n+\n+\t* lto-streamer.h (struct string_slot): Move from data-streamer.h\n+\t(struct string_slot_hasher): New.\n+\t(htab_t output_block::string_hash_table):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* lto-streamer-in.c (freeing_string_slot_hasher): New.\n+\t(htab_t file_name_hash_table):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* lto-streamer-out.c: Update output_block::string_hash_table dependent\n+\tcalls and types.\n+\n+\t* lto-streamer.c (htab_t tree_htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* omp-low.c: Include gimplify-ctx.h.\n+\n+\t* passes.c (htab_t name_to_pass_map):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(pass_traverse): Rename to passes_pass_traverse.\n+\n+\t* plugin.c (htab_t event_tab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* postreload-gcse.c (htab_t expr_table):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(dump_hash_table_entry): Rename dump_expr_hash_table_entry.\n+\n+\t* sese.c (debug_rename_map_1): Make extern.\n+\t(htab_t copy_bb_and_scalar_dependences::rename_map):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* sese.h (extern debug_rename_map): Move to .c file.\n+\n+\t* store-motion.c (htab_t store_motion_mems_table):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* trans-mem.c (htab_t tm_new_mem_hash):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-browser.c (htab_t TB_up_ht):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-cfg.c (htab_t discriminator_per_locus):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-complex.c: Include tree-hasher.h\n+\t(htab_t complex_variable_components):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-eh.c (htab_t finally_tree):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-flow.h (extern int_tree_map_hash): Moved into tree-hasher\n+\tstruct int_tree_hasher.\n+\t(extern int_tree_map_eq): Likewise.\n+\t(uid_decl_map_hash): Removed.\n+\t(extern decl_tree_map_eq): Likewise.\n+\n+\t* tree-hasher.h: New.\n+\t(struct int_tree_hasher): New.\n+\t(typedef int_tree_htab_type): New.\n+\n+\t* tree-inline.c: Include gimplify-ctx.h.\n+\n+\t* tree-mudflap.c: Include gimplify-ctx.h.\n+\n+\t* tree-parloops.c: Include tree-hasher.h.\n+\t(htab_t eliminate_local_variables_stmt::decl_address):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\t(htab_t separate_decls_in_region::decl_copies): Likewise.\n+\n+\t* tree-scalar-evolution.c (htab_t resolve_mixers::cache):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-sra.c (candidates):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-ssa.c (int_tree_map_eq): Moved into struct int_tree_hasher\n+\tin tree-flow.h.\n+\t(int_tree_map_hash): Likewise.\n+\n+\t* tree-ssa-dom.c (htab_t avail_exprs):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-ssa-live.c (var_map_base_init::tree_to_index):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-ssa-loop-ivopts.c (struct ivopts_data.inv_expr_tab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-ssa-phiopt.c (seen_ssa_names):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-ssa-strlen.c (decl_to_stridxlist_htab):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n+\t* tree-ssa-uncprop.c (equiv):\n+\tChange type to hash_table.  Update dependent calls and types.\n+\n 2013-04-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/57003"}, {"sha": "a3105b1ab86ad0977ed436028161e3f7a1fef124", "filename": "gcc/Makefile.in", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -875,7 +875,7 @@ BASIC_BLOCK_H = basic-block.h $(PREDICT_H) $(VEC_H) $(FUNCTION_H) \\\n \tcfg-flags.def cfghooks.h\n GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h $(VEC_H) \\\n \t$(GGC_H) $(BASIC_BLOCK_H) $(TREE_H) tree-ssa-operands.h \\\n-\ttree-ssa-alias.h $(INTERNAL_FN_H)\n+\ttree-ssa-alias.h $(INTERNAL_FN_H) $(HASH_TABLE_H)\n TRANS_MEM_H = trans-mem.h\n GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h\n COVERAGE_H = coverage.h $(GCOV_IO_H)\n@@ -938,6 +938,7 @@ TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \\\n \t\t$(BITMAP_H) sbitmap.h $(BASIC_BLOCK_H) $(GIMPLE_H) \\\n \t\t$(HASHTAB_H) $(CGRAPH_H) $(IPA_REFERENCE_H) \\\n \t\ttree-ssa-alias.h\n+TREE_HASHER_H = tree-hasher.h $(HASH_TABLE_H) $(TREE_FLOW_H)\n TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H)\n SSAEXPAND_H = ssaexpand.h $(TREE_SSA_LIVE_H)\n PRETTY_PRINT_H = pretty-print.h $(INPUT_H) $(OBSTACK_H)\n@@ -958,7 +959,7 @@ LRA_INT_H = lra.h $(BITMAP_H) $(RECOG_H) $(INSN_ATTR_H) insn-codes.h \\\n    insn-config.h $(REGS_H) lra-int.h\n DBGCNT_H = dbgcnt.h dbgcnt.def\n LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \\\n-\t\t$(CGRAPH_H) $(VEC_H) $(TREE_H) $(GIMPLE_H) \\\n+\t\t$(CGRAPH_H) $(VEC_H) $(HASH_TABLE_H) $(TREE_H) $(GIMPLE_H) \\\n \t\t$(GCOV_IO_H) $(DIAGNOSTIC_H) alloc-pool.h\n DATA_STREAMER_H = data-streamer.h $(VEC_H) $(LTO_STREAMER_H)\n GIMPLE_STREAMER_H = gimple-streamer.h $(LTO_STREAMER_H) $(BASIC_BLOCK_H) \\\n@@ -977,6 +978,7 @@ GCC_PLUGIN_H = gcc-plugin.h highlev-plugin-common.h plugin.def \\\n PLUGIN_H = plugin.h $(GCC_PLUGIN_H)\n PLUGIN_VERSION_H = plugin-version.h configargs.h\n LIBFUNCS_H = libfuncs.h $(HASHTAB_H)\n+GRAPHITE_HTAB_H = graphite-htab.h graphite-clast-to-gimple.h $(HASH_TABLE_H)\n \n #\f\n # Now figure out from those variables how to compile and link.\n@@ -2016,7 +2018,7 @@ default-c.o: config/default-c.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n # Files used by all variants of C and some other languages.\n \n attribs.o : attribs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-\t$(FLAGS_H) $(DIAGNOSTIC_CORE_H) $(GGC_H) $(TM_P_H) \\\n+\t$(HASH_TABLE_H) $(FLAGS_H) $(DIAGNOSTIC_CORE_H) $(GGC_H) $(TM_P_H) \\\n \t$(TARGET_H) langhooks.h $(CPPLIB_H) $(PLUGIN_H)\n \n incpath.o: incpath.c incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \\\n@@ -2108,15 +2110,15 @@ gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \t$(CFGLOOP_H) $(TARGET_H) $(IPA_PROP_H) $(LTO_STREAMER_H) \\\n \ttarget-globals.h\n \n-trans-mem.o : trans-mem.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+trans-mem.o : trans-mem.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(HASH_TABLE_H) \\\n \t$(TREE_H) $(GIMPLE_H) $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_INLINE_H) \\\n \t$(DIAGNOSTIC_CORE_H) $(DEMANGLE_H) output.h $(TRANS_MEM_H) \\\n \t$(PARAMS_H) $(TARGET_H) langhooks.h \\\n \t$(GIMPLE_PRETTY_PRINT_H) $(CFGLOOP_H) \\\n \tgt-trans-mem.h\n \n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\t\\\n-\t$(GGC_H) $(HASHTAB_H) $(DIAGNOSTIC_CORE_H) $(PARAMS_H) hosthooks.h\t\\\n+\t$(GGC_H) $(HASH_TABLE_H) $(DIAGNOSTIC_CORE_H) $(PARAMS_H) hosthooks.h \\\n \t$(HOSTHOOKS_DEF_H) $(VEC_H) $(PLUGIN_H) $(GGC_INTERNAL_H) $(TIMEVAR_H)\n \n ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n@@ -2252,8 +2254,8 @@ tree-ssa-tail-merge.o: tree-ssa-tail-merge.c \\\n    $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) $(TREE_DUMP_H) $(HASH_TABLE_H) \\\n    $(GIMPLE_H) $(FUNCTION_H) tree-ssa-sccvn.h \\\n    $(CGRAPH_H) $(GIMPLE_PRETTY_PRINT_H) $(PARAMS_H)\n-tree-ssa-structalias.o: tree-ssa-structalias.c \\\n-   $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(GGC_H) $(OBSTACK_H) $(BITMAP_H) \\\n+tree-ssa-structalias.o: tree-ssa-structalias.c $(SYSTEM_H) $(CONFIG_H) \\\n+   coretypes.h $(HASH_TABLE_H) $(TM_H) $(GGC_H) $(OBSTACK_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(DIAGNOSTIC_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n    $(GIMPLE_H) $(HASH_TABLE_H) $(FUNCTION_H) $(CGRAPH_H) \\\n@@ -2266,7 +2268,7 @@ tree-ssa-uninit.o : tree-ssa-uninit.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(FLAGS_H) $(HASHTAB_H) pointer-set.h \\\n    $(GIMPLE_H) $(TREE_INLINE_H) $(GIMPLE_PRETTY_PRINT_H)\n tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   $(TREE_H) $(TM_P_H) $(EXPR_H) $(DIAGNOSTIC_H) \\\n+   $(HASH_TABLE_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(DIAGNOSTIC_H) \\\n    toplev.h $(FUNCTION_H) $(TM_H) coretypes.h \\\n    langhooks.h $(TREE_PASS_H) $(BASIC_BLOCK_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(GGC_H) $(HASHTAB_H) pointer-set.h \\\n@@ -2308,7 +2310,7 @@ tree-ssa-ifcombine.o : tree-ssa-ifcombine.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(DIAGNOSTIC_H) \\\n    $(TREE_PRETTY_PRINT_H)\n tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TM_H) $(GGC_H) $(TREE_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n+   $(HASH_TABLE_H) $(TM_H) $(GGC_H) $(TREE_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) langhooks.h $(FLAGS_H) \\\n    $(DIAGNOSTIC_H) pointer-set.h domwalk.h $(CFGLOOP_H) \\\n    $(TREE_DATA_REF_H) $(TREE_PRETTY_PRINT_H) $(GIMPLE_PRETTY_PRINT_H) \\\n@@ -2329,13 +2331,13 @@ tree-ssa-propagate.o : tree-ssa-propagate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    tree-ssa-propagate.h $(VEC_H) value-prof.h gt-tree-ssa-propagate.h $(FLAGS_H) \\\n    $(GIMPLE_H) $(GIMPLE_PRETTY_PRINT_H)\n tree-ssa-dom.o : tree-ssa-dom.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   $(TREE_H) $(TM_P_H) $(DIAGNOSTIC_H) \\\n+   $(HASH_TABLE_H) $(TREE_H) $(TM_P_H) $(DIAGNOSTIC_H) \\\n    $(FUNCTION_H) $(TM_H) coretypes.h \\\n    $(BASIC_BLOCK_H) domwalk.h $(TREE_PASS_H) $(FLAGS_H) langhooks.h \\\n    tree-ssa-propagate.h $(CFGLOOP_H) $(PARAMS_H) \\\n    $(GIMPLE_PRETTY_PRINT_H)\n tree-ssa-uncprop.o : tree-ssa-uncprop.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(TREE_H) $(TM_P_H) \\\n+   $(SYSTEM_H) $(HASH_TABLE_H) $(TREE_H) $(TM_P_H) \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TM_H) coretypes.h \\\n    $(BASIC_BLOCK_H) domwalk.h $(TREE_PASS_H) $(FLAGS_H) \\\n    tree-ssa-propagate.h\n@@ -2358,7 +2360,7 @@ domwalk.o : domwalk.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) domwalk.h sbitmap.h\n tree-ssa-live.o : tree-ssa-live.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(DUMPFILE_H) $(TIMEVAR_H) \\\n-   $(TREE_SSA_LIVE_H) $(BITMAP_H) debug.h $(FLAGS_H) \\\n+   $(TREE_SSA_LIVE_H) $(BITMAP_H) debug.h $(FLAGS_H) $(HASH_TABLE_H) \\\n    $(GIMPLE_PRETTY_PRINT_H) $(GIMPLE_H)\n tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(DIAGNOSTIC_H) $(FUNCTION_H) \\\n@@ -2380,15 +2382,15 @@ tree-ssa-sccvn.o : tree-ssa-sccvn.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(PARAMS_H) $(GIMPLE_PRETTY_PRINT_H) gimple-fold.h\n gimple-ssa-strength-reduction.o : gimple-ssa-strength-reduction.c $(CONFIG_H) \\\n    $(SYSTEM_H) coretypes.h $(TREE_H) $(GIMPLE_H) $(BASIC_BLOCK_H) \\\n-   $(TREE_PASS_H) $(CFGLOOP_H) $(TREE_PRETTY_PRINT_H) \\\n+   $(HASH_TABLE_H) $(TREE_PASS_H) $(CFGLOOP_H) $(TREE_PRETTY_PRINT_H) \\\n    $(GIMPLE_PRETTY_PRINT_H) alloc-pool.h $(TREE_FLOW_H) domwalk.h \\\n    pointer-set.h expmed.h\n tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(DIAGNOSTIC_CORE_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) tree-ssa-propagate.h $(FLAGS_H) $(TREE_DUMP_H) \\\n    $(CFGLOOP_H) $(SCEV_H) intl.h \\\n    $(GIMPLE_PRETTY_PRINT_H) gimple-fold.h $(OPTABS_H) $(EXPR_H)\n-tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) $(HASH_TABLE_H) \\\n    $(TREE_H) $(TM_P_H) $(GGC_H) $(FLAGS_H) $(TARGET_H) \\\n    $(DIAGNOSTIC_CORE_H) $(FUNCTION_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(EXCEPT_H) $(CFGLOOP_H) $(TREE_PASS_H) \\\n@@ -2433,7 +2435,7 @@ tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    langhooks.h $(IPA_REFERENCE_H) $(GIMPLE_PRETTY_PRINT_H)\n tree-eh.o : tree-eh.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TM_H) $(FLAGS_H) $(FUNCTION_H) $(EXCEPT_H) langhooks.h \\\n-   $(GGC_H) $(TREE_PASS_H) coretypes.h pointer-set.h \\\n+   $(HASH_TABLE_H) $(GGC_H) $(TREE_PASS_H) coretypes.h pointer-set.h \\\n    $(TREE_INLINE_H) tree-iterator.h toplev.h \\\n    $(DIAGNOSTIC_CORE_H) $(TARGET_H) $(CFGLOOP_H)\n tree-ssa-loop.o : tree-ssa-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n@@ -2479,7 +2481,7 @@ tree-predcom.o: tree-predcom.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_P_H) \\\n tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(EXPR_H) \\\n    $(DIAGNOSTIC_H) $(TM_H) coretypes.h \\\n-   $(TREE_PASS_H) $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \\\n+   $(TREE_PASS_H) $(GGC_H) $(RECOG_H) insn-config.h $(HASH_TABLE_H) $(SCEV_H) \\\n    $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) \\\n    tree-affine.h pointer-set.h $(TARGET_H) \\\n    $(GIMPLE_PRETTY_PRINT_H) tree-ssa-propagate.h\n@@ -2493,7 +2495,7 @@ tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(CFGLOOP_H) $(TREE_PASS_H) \\\n    $(SCEV_H) $(PARAMS_H) $(TREE_INLINE_H) langhooks.h\n tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n-   $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h \\\n+   $(SYSTEM_H) $(HASH_TABLE_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h \\\n    $(PARAMS_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h \\\n    $(TREE_PASS_H) $(FLAGS_H) $(BASIC_BLOCK_H) \\\n    pointer-set.h tree-affine.h tree-ssa-propagate.h $(GIMPLE_PRETTY_PRINT_H)\n@@ -2546,15 +2548,15 @@ omp-low.o : omp-low.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TREE_PASS_H) $(GGC_H) $(EXCEPT_H) $(SPLAY_TREE_H) $(OPTABS_H) \\\n    $(CFGLOOP_H) tree-iterator.h gt-omp-low.h\n tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TREE_H) $(TREE_PRETTY_PRINT_H)\n+   coretypes.h $(HASH_TABLE_H) $(TREE_H) $(TREE_PRETTY_PRINT_H)\n omega.o : omega.c $(OMEGA_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DUMPFILE_H) \\\n    $(TREE_H) $(DIAGNOSTIC_CORE_H)\n tree-chrec.o : tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DUMPFILE_H) \\\n    $(TREE_PRETTY_PRINT_H) $(CFGLOOP_H) $(TREE_FLOW_H) $(SCEV_H) \\\n    $(PARAMS_H)\n tree-scalar-evolution.o : tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(DUMPFILE_H) $(GIMPLE_PRETTY_PRINT_H) $(TREE_FLOW_H) \\\n-   $(CFGLOOP_H) $(SCEV_H) $(PARAMS_H) gt-tree-scalar-evolution.h\n+   coretypes.h $(DUMPFILE_H) $(HASH_TABLE_H) $(GIMPLE_PRETTY_PRINT_H) \\\n+   $(TREE_FLOW_H) $(CFGLOOP_H) $(SCEV_H) $(PARAMS_H) gt-tree-scalar-evolution.h\n tree-data-ref.o : tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(DUMPFILE_H) \\\n    $(GIMPLE_PRETTY_PRINT_H) $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n@@ -2563,18 +2565,18 @@ sese.o : sese.c sese.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_PRETTY_PRINT_H\n    $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H) value-prof.h\n graphite.o : graphite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h \\\n-   $(DBGCNT_H) graphite-poly.h graphite-scop-detection.h \\\n+   $(DBGCNT_H) $(GRAPHITE_HTAB_H) graphite-poly.h graphite-scop-detection.h \\\n    graphite-clast-to-gimple.h graphite-sese-to-poly.h\n graphite-blocking.o : graphite-blocking.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(DUMPFILE_H) $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n    sese.h graphite-poly.h\n graphite-clast-to-gimple.o : graphite-clast-to-gimple.c $(CONFIG_H) \\\n    $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) $(TREE_FLOW_H) $(TREE_PASS_H) \\\n-   $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h \\\n+   $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h $(GRAPHITE_HTAB_H) \\\n    graphite-poly.h graphite-clast-to-gimple.h\n graphite-dependences.o : graphite-dependences.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(TREE_PASS_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n-   sese.h graphite-poly.h\n+   sese.h $(GRAPHITE_HTAB_H) graphite-poly.h\n graphite-interchange.o : graphite-interchange.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(DUMPFILE_H) $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n    sese.h graphite-poly.h\n@@ -2628,7 +2630,8 @@ tree-vectorizer.o: tree-vectorizer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n tree-loop-distribution.o: tree-loop-distribution.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H)\n tree-parloops.o: tree-parloops.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(GIMPLE_PRETTY_PRINT_H) \\\n+   $(TREE_FLOW_H) $(TREE_HASHER_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \\\n+   $(GIMPLE_PRETTY_PRINT_H) $(HASH_TABLE_H) \\\n    $(TREE_PASS_H) langhooks.h gt-tree-parloops.h $(TREE_VECTORIZER_H)\n tree-stdarg.o: tree-stdarg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FUNCTION_H) $(TREE_FLOW_H) $(TREE_PASS_H) \\\n@@ -2647,8 +2650,9 @@ gimple-pretty-print.o : gimple-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) $(TREE_FLOW_H) \\\n    $(TM_H) $(GIMPLE_H) value-prof.h \\\n    $(TRANS_MEM_H) $(GIMPLE_PRETTY_PRINT_H)\n-tree-mudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n-   $(GIMPLE_H) $(DIAGNOSTIC_H) $(DEMANGLE_H) $(HASHTAB_H) langhooks.h tree-mudflap.h \\\n+tree-mudflap.o : tree-mudflap.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n+   $(TREE_INLINE_H) $(GIMPLE_H) $(DIAGNOSTIC_H) \\\n+   $(DEMANGLE_H) $(HASHTAB_H) langhooks.h tree-mudflap.h \\\n    $(TM_H) coretypes.h $(TREE_PASS_H) $(CGRAPH_H) $(GGC_H) \\\n    gt-tree-mudflap.h $(BASIC_BLOCK_H) $(FLAGS_H) $(FUNCTION_H) \\\n    $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_CORE_H) $(GIMPLE_H) tree-iterator.h\n@@ -2729,7 +2733,8 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(PLUGIN_H) $(IPA_UTILS_H)\n \n plugin.o : plugin.c $(PLUGIN_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-   $(DIAGNOSTIC_CORE_H) $(TREE_H) $(TREE_PASS_H) intl.h $(PLUGIN_VERSION_H) $(GGC_H)\n+   $(HASH_TABLE_H) $(DIAGNOSTIC_CORE_H) $(TREE_H) $(TREE_PASS_H) \\\n+   intl.h $(PLUGIN_VERSION_H) $(GGC_H)\n \n main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(DIAGNOSTIC_CORE_H)\n \n@@ -2777,7 +2782,8 @@ stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DUMPFILE_H) $(TM_H) \\\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(EXCEPT_H) $(FUNCTION_H) $(EXPR_H) $(LIBFUNCS_H) \\\n    langhooks.h insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n-   dwarf2asm.h $(DWARF2OUT_H) toplev.h $(DIAGNOSTIC_CORE_H) $(HASHTAB_H) intl.h $(GGC_H) \\\n+   dwarf2asm.h $(DWARF2OUT_H) toplev.h $(DIAGNOSTIC_CORE_H) $(HASH_TABLE_H) \\\n+   intl.h $(GGC_H) \\\n    gt-except.h $(CGRAPH_H) $(DIAGNOSTIC_H) $(DWARF2_H) \\\n    $(TARGET_H) $(TM_P_H) $(TREE_PASS_H) $(TREE_FLOW_H) \\\n    $(TREE_PRETTY_PRINT_H) sbitmap.h $(COMMON_TARGET_H) $(CFGLOOP_H)\n@@ -2831,12 +2837,12 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DUMPFILE_H) \\\n    $(TM_H) $(TREE_H) version.h $(RTL_H) $(DWARF2_H) debug.h $(FLAGS_H) \\\n    insn-config.h output.h $(DIAGNOSTIC_H) hard-reg-set.h $(REGS_H) $(EXPR_H) \\\n    toplev.h $(DIAGNOSTIC_CORE_H) $(DWARF2OUT_H) reload.h \\\n-   $(GGC_H) $(EXCEPT_H) dwarf2asm.h $(TM_P_H) langhooks.h $(HASHTAB_H) \\\n+   $(GGC_H) $(EXCEPT_H) dwarf2asm.h $(TM_P_H) langhooks.h $(HASH_TABLE_H) \\\n    gt-dwarf2out.h $(TARGET_H) $(CGRAPH_H) $(MD5_H) $(INPUT_H) $(FUNCTION_H) \\\n    $(GIMPLE_H) ira.h lra.h $(TREE_FLOW_H) \\\n    $(TREE_PRETTY_PRINT_H) $(COMMON_TARGET_H) $(OPTS_H)\n-dwarf2cfi.o : dwarf2cfi.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   version.h $(RTL_H) $(EXPR_H) $(REGS_H) $(FUNCTION_H) output.h \\\n+dwarf2cfi.o : dwarf2cfi.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(HASH_TABLE_H) \\\n+   $(TM_H) version.h $(RTL_H) $(EXPR_H) $(REGS_H) $(FUNCTION_H) output.h \\\n    gt-dwarf2cfi.h debug.h $(DWARF2_H) dwarf2asm.h $(DWARF2OUT_H) $(COMMON_TARGET_H) \\\n    $(GGC_H) $(TM_P_H) $(TARGET_H) $(TREE_PASS_H) $(BASIC_BLOCK_H) $(EXCEPT_H)\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n@@ -2965,7 +2971,7 @@ coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    tree-iterator.h $(CGRAPH_H) gcov-io.c $(TM_P_H) \\\n    $(DIAGNOSTIC_CORE_H) intl.h gt-coverage.h $(TARGET_H) $(HASH_TABLE_H)\n cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DUMPFILE_H) \\\n-   $(TM_H) $(RTL_H) \\\n+   $(HASH_TABLE_H) $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(RECOG_H) \\\n    $(EMIT_RTL_H) $(DIAGNOSTIC_CORE_H) $(FUNCTION_H) \\\n    cselib.h gt-cselib.h $(GGC_H) $(TM_P_H) $(PARAMS_H) alloc-pool.h \\\n@@ -3005,12 +3011,13 @@ cprop.o : cprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    intl.h $(OBSTACK_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H) $(TARGET_H) \\\n    $(DF_H) $(CFGLOOP_H)\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(GGC_H) \\\n+   $(HASH_TABLE_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(GGC_H) \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) toplev.h $(DIAGNOSTIC_CORE_H) \\\n    $(TM_P_H) $(PARAMS_H) cselib.h $(EXCEPT_H) gt-gcse.h $(TREE_H) \\\n    intl.h $(OBSTACK_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H) $(TARGET_H) \\\n    $(DF_H) gcse.h\n-store-motion.o : store-motion.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+store-motion.o : store-motion.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(HASH_TABLE_H) $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(GGC_H) \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) toplev.h $(DIAGNOSTIC_CORE_H) \\\n    $(TM_P_H) $(EXCEPT_H) $(TREE_H) \\\n@@ -3043,9 +3050,9 @@ tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(DBGCNT_H) $(GIMPLE_PRETTY_PRINT_H) gimple-fold.h\n tree-ssa-strlen.o : tree-ssa-strlen.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) domwalk.h alloc-pool.h tree-ssa-propagate.h \\\n-   $(GIMPLE_PRETTY_PRINT_H) $(PARAMS_H) $(EXPR_H)\n+   $(GIMPLE_PRETTY_PRINT_H) $(PARAMS_H) $(EXPR_H) $(HASH_TABLE_H)\n tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) coretypes.h alloc-pool.h \\\n-   $(TM_H) $(TREE_H) $(GIMPLE_H) $(CGRAPH_H) $(TREE_FLOW_H) \\\n+   $(HASH_TABLE_H) $(TM_H) $(TREE_H) $(GIMPLE_H) $(CGRAPH_H) $(TREE_FLOW_H) \\\n    $(IPA_PROP_H) $(DIAGNOSTIC_H) statistics.h \\\n    $(PARAMS_H) $(TARGET_H) $(FLAGS_H) \\\n    $(DBGCNT_H) $(TREE_INLINE_H) $(GIMPLE_PRETTY_PRINT_H)\n@@ -3056,7 +3063,7 @@ tree-switch-conversion.o : tree-switch-conversion.c $(CONFIG_H) $(SYSTEM_H) \\\n     $(GGC_H) $(OBSTACK_H) $(PARAMS_H) $(CPPLIB_H) $(PARAMS_H) \\\n     $(GIMPLE_PRETTY_PRINT_H) langhooks.h\n tree-complex.o : tree-complex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n-    $(TM_H) $(FLAGS_H) $(TREE_FLOW_H) $(GIMPLE_H) \\\n+    $(TM_H) $(FLAGS_H) $(TREE_FLOW_H) $(TREE_HASHER_H) $(GIMPLE_H) \\\n     tree-iterator.h $(TREE_PASS_H) tree-ssa-propagate.h\n tree-emutls.o : tree-emutls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n     $(GIMPLE_H) $(TREE_PASS_H) $(TREE_FLOW_H) $(CGRAPH_H) langhooks.h \\\n@@ -3114,7 +3121,7 @@ loop-doloop.o : loop-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(DUMPFILE_H) $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \\\n    $(DIAGNOSTIC_CORE_H) $(CFGLOOP_H) $(PARAMS_H) $(TARGET_H)\n-alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h $(HASHTAB_H)\n+alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h $(HASH_TABLE_H)\n auto-inc-dec.o : auto-inc-dec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) insn-config.h \\\n    $(REGS_H) $(FLAGS_H) $(FUNCTION_H) $(EXCEPT_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) \\\n@@ -3162,12 +3169,12 @@ graphds.o : graphds.c graphds.h $(CONFIG_H) $(SYSTEM_H) $(BITMAP_H) $(OBSTACK_H)\n loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DUMPFILE_H) \\\n    $(RTL_H) $(BASIC_BLOCK_H) \\\n    hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) $(TM_H) $(OBSTACK_H) \\\n-   intl.h $(DIAGNOSTIC_CORE_H) $(DF_H) $(HASHTAB_H)\n+   intl.h $(DIAGNOSTIC_CORE_H) $(DF_H) $(HASH_TABLE_H)\n loop-invariant.o : loop-invariant.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(DUMPFILE_H) \\\n    $(RTL_H) $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) $(RECOG_H) \\\n    $(TM_H) $(TM_P_H) $(FUNCTION_H) $(FLAGS_H) $(DF_H) $(TARGET_H) \\\n-   $(OBSTACK_H) $(HASHTAB_H) $(EXCEPT_H) $(PARAMS_H) $(REGS_H) ira.h\n+   $(OBSTACK_H) $(HASH_TABLE_H) $(EXCEPT_H) $(PARAMS_H) $(REGS_H) ira.h\n cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) \\\n    coretypes.h $(TM_H) $(OBSTACK_H) $(TREE_FLOW_H)\n@@ -3181,8 +3188,7 @@ loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(EXPR_H) $(TM_H) $(OBSTACK_H)\n loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DUMPFILE_H) \\\n    $(RTL_H) $(TM_H) $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(PARAMS_H) \\\n-   $(EXPR_H) $(TM_H) $(HASHTAB_H) $(RECOG_H) \\\n-   $(OBSTACK_H)\n+   $(EXPR_H) $(TM_H) $(HASH_TABLE_H) $(RECOG_H) $(OBSTACK_H)\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h $(OBSTACK_H) $(DIAGNOSTIC_CORE_H) \\\n    $(TIMEVAR_H) graphds.h pointer-set.h $(BITMAP_H)\n@@ -3201,7 +3207,7 @@ reginfo.o : reginfo.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FUNCTION_H) output.h $(TM_P_H) $(EXPR_H) $(HASHTAB_H) \\\n    $(TARGET_H) $(TREE_PASS_H) $(DF_H) ira.h\n bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(VEC_H) \\\n-   $(GGC_H) gt-bitmap.h $(BITMAP_H) $(OBSTACK_H) $(HASHTAB_H)\n+   $(GGC_H) gt-bitmap.h $(BITMAP_H) $(OBSTACK_H) $(HASH_TABLE_H)\n vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(VEC_H) $(GGC_H) \\\n    $(DIAGNOSTIC_CORE_H) $(HASHTAB_H)\n hash-table.o : hash-table.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n@@ -3226,8 +3232,8 @@ postreload.o : postreload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n postreload-gcse.o : postreload-gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) $(DIAGNOSTIC_CORE_H) \\\n-   $(TM_P_H) $(EXCEPT_H) $(TREE_H) $(TARGET_H) $(HASHTAB_H) intl.h $(OBSTACK_H) \\\n-   $(PARAMS_H) $(TREE_PASS_H) $(DBGCNT_H)\n+   $(TM_P_H) $(EXCEPT_H) $(TREE_H) $(TARGET_H) $(HASH_TABLE_H) intl.h \\\n+   $(OBSTACK_H) $(PARAMS_H) $(TREE_PASS_H) $(DBGCNT_H)\n caller-save.o : caller-save.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(DUMPFILE_H) $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(REGS_H) hard-reg-set.h insn-config.h $(BASIC_BLOCK_H) $(FUNCTION_H) \\\n@@ -3261,14 +3267,14 @@ ira-build.o: ira-build.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(PARAMS_H) $(DF_H) sparseset.h $(IRA_INT_H) reload.h\n ira-costs.o: ira-costs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    hard-reg-set.h $(RTL_H) $(EXPR_H) $(TM_P_H) $(FLAGS_H) $(BASIC_BLOCK_H) \\\n-   $(REGS_H) addresses.h insn-config.h $(RECOG_H) $(DIAGNOSTIC_CORE_H) $(TARGET_H) \\\n-   $(PARAMS_H) $(IRA_INT_H) reload.h\n+   $(REGS_H) addresses.h insn-config.h $(RECOG_H) $(DIAGNOSTIC_CORE_H) \\\n+   $(HASH_TABLE_H) $(TARGET_H) $(PARAMS_H) $(IRA_INT_H) reload.h\n ira-conflicts.o: ira-conflicts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TARGET_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(TREE_H) $(FLAGS_H) \\\n    insn-config.h $(RECOG_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_CORE_H) $(TM_P_H) $(PARAMS_H) \\\n    $(DF_H) sparseset.h addresses.h $(IRA_INT_H)\n ira-color.o: ira-color.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TARGET_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \\\n+   $(HASH_TABLE_H) $(TARGET_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \\\n    $(EXPR_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_CORE_H) $(TM_P_H) reload.h $(PARAMS_H) \\\n    $(DF_H) $(IRA_INT_H)\n ira-emit.o: ira-emit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n@@ -3348,7 +3354,7 @@ haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(FUNCTION_H) \\\n    $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(EXCEPT_H) $(TM_P_H) $(TARGET_H) \\\n    $(PARAMS_H) $(DBGCNT_H) $(CFGLOOP_H) ira.h $(EMIT_RTL_H) $(COMMON_TARGET_H) \\\n-   $(HASHTAB_H)\n+   $(HASH_TABLE_H)\n sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(EXCEPT_H) cselib.h \\"}, {"sha": "6590754456539e039c168c65d626eabc4dee39b9", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -82,6 +82,7 @@ struct alloc_pool_descriptor\n   int elt_size;\n };\n \n+/* Hashtable helpers.  */\n struct alloc_pool_hasher : typed_noop_remove <alloc_pool_descriptor>\n {\n   typedef alloc_pool_descriptor value_type;\n@@ -90,10 +91,6 @@ struct alloc_pool_hasher : typed_noop_remove <alloc_pool_descriptor>\n   static inline bool equal (const value_type *, const compare_type *);\n };\n \n-/* Hashtable mapping alloc_pool names to descriptors.  */\n-static hash_table <alloc_pool_hasher>  alloc_pool_hash;\n-\n-/* Hashtable helpers.  */\n inline hashval_t\n alloc_pool_hasher::hash (const value_type *d)\n {\n@@ -107,6 +104,9 @@ alloc_pool_hasher::equal (const value_type *d,\n   return d->name == p2;\n }\n \n+/* Hashtable mapping alloc_pool names to descriptors.  */\n+static hash_table <alloc_pool_hasher>  alloc_pool_hash;\n+\n /* For given name, return descriptor, create new if needed.  */\n static struct alloc_pool_descriptor *\n allocate_pool_descriptor (const char *name)"}, {"sha": "164385b2b3c4598d11c729b4543ee67fbd693518", "filename": "gcc/attribs.c", "status": "modified", "additions": 42, "deletions": 41, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cpplib.h\"\n #include \"target.h\"\n #include \"langhooks.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"plugin.h\"\n \n /* Table of the tables of attributes (common, language, format, machine)\n@@ -44,13 +44,45 @@ struct substring\n   int length;\n };\n \n+/* Simple hash function to avoid need to scan whole string.  */\n+\n+static inline hashval_t\n+substring_hash (const char *str, int l)\n+{\n+  return str[0] + str[l - 1] * 256 + l * 65536;\n+}\n+\n+/* Used for attribute_hash.  */\n+\n+struct attribute_hasher : typed_noop_remove <attribute_spec>\n+{\n+  typedef attribute_spec value_type;\n+  typedef substring compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+attribute_hasher::hash (const value_type *spec)\n+{\n+  const int l = strlen (spec->name);\n+  return substring_hash (spec->name, l);\n+}\n+\n+inline bool\n+attribute_hasher::equal (const value_type *spec, const compare_type *str)\n+{\n+  return (strncmp (spec->name, str->str, str->length) == 0\n+\t  && !spec->name[str->length]);\n+}\n+\n /* Scoped attribute name representation.  */\n \n struct scoped_attributes\n {\n   const char *ns;\n   vec<attribute_spec> attributes;\n-  htab_t attribute_hash;\n+  hash_table <attribute_hasher> attribute_hash;\n };\n \n /* The table of scope attributes.  */\n@@ -83,36 +115,6 @@ extract_attribute_substring (struct substring *str)\n     }\n }\n \n-/* Simple hash function to avoid need to scan whole string.  */\n-\n-static inline hashval_t\n-substring_hash (const char *str, int l)\n-{\n-  return str[0] + str[l - 1] * 256 + l * 65536;\n-}\n-\n-/* Used for attribute_hash.  */\n-\n-static hashval_t\n-hash_attr (const void *p)\n-{\n-  const struct attribute_spec *const spec = (const struct attribute_spec *) p;\n-  const int l = strlen (spec->name);\n-\n-  return substring_hash (spec->name, l);\n-}\n-\n-/* Used for attribute_hash.  */\n-\n-static int\n-eq_attr (const void *p, const void *q)\n-{\n-  const struct attribute_spec *const spec = (const struct attribute_spec *) p;\n-  const struct substring *const str = (const struct substring *) q;\n-\n-  return (!strncmp (spec->name, str->str, str->length) && !spec->name[str->length]);\n-}\n-\n /* Insert an array of attributes ATTRIBUTES into a namespace.  This\n    array must be NULL terminated.  NS is the name of attribute\n    namespace.  The function returns the namespace into which the\n@@ -139,7 +141,7 @@ register_scoped_attributes (const struct attribute_spec * attributes,\n       sa.ns = ns;\n       sa.attributes.create (64);\n       result = attributes_table.safe_push (sa);\n-      result->attribute_hash = htab_create (200, hash_attr, eq_attr, NULL);\n+      result->attribute_hash.create (200);\n     }\n \n   /* Really add the attributes to their namespace now.  */\n@@ -272,11 +274,11 @@ register_scoped_attribute (const struct attribute_spec *attr,\n \t\t\t   scoped_attributes *name_space)\n {\n   struct substring str;\n-  void **slot;\n+  attribute_spec **slot;\n \n   gcc_assert (attr != NULL && name_space != NULL);\n \n-  gcc_assert (name_space->attribute_hash != NULL);\n+  gcc_assert (name_space->attribute_hash.is_created ());\n \n   str.str = attr->name;\n   str.length = strlen (str.str);\n@@ -285,11 +287,11 @@ register_scoped_attribute (const struct attribute_spec *attr,\n      in the form '__text__'.  */\n   gcc_assert (str.length > 0 && str.str[0] != '_');\n \n-  slot = htab_find_slot_with_hash (name_space->attribute_hash, &str,\n-\t\t\t\t   substring_hash (str.str, str.length),\n-\t\t\t\t   INSERT);\n+  slot = name_space->attribute_hash\n+\t .find_slot_with_hash (&str, substring_hash (str.str, str.length),\n+\t\t\t       INSERT);\n   gcc_assert (!*slot || attr->name[0] == '*');\n-  *slot = (void *) CONST_CAST (struct attribute_spec *, attr);\n+  *slot = CONST_CAST (struct attribute_spec *, attr);\n }\n \n /* Return the spec for the scoped attribute with namespace NS and\n@@ -311,8 +313,7 @@ lookup_scoped_attribute_spec (const_tree ns, const_tree name)\n   attr.str = IDENTIFIER_POINTER (name);\n   attr.length = IDENTIFIER_LENGTH (name);\n   extract_attribute_substring (&attr);\n-  return (const struct attribute_spec *)\n-    htab_find_with_hash (attrs->attribute_hash, &attr,\n+  return attrs->attribute_hash.find_with_hash (&attr,\n \t\t\t substring_hash (attr.str, attr.length));\n }\n "}, {"sha": "2c5d228fdd1e5e9fbfbd5c521d962d3cc40a049b", "filename": "gcc/bitmap.c", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"obstack.h\"\n #include \"ggc.h\"\n #include \"bitmap.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"vec.h\"\n \n /* Store information about each particular bitmap, per allocation site.  */\n@@ -50,48 +50,55 @@ static int next_bitmap_desc_id = 0;\n /* Vector mapping descriptor ids to descriptors.  */\n static vec<bitmap_descriptor> bitmap_descriptors;\n \n-/* Hashtable mapping bitmap names to descriptors.  */\n-static htab_t bitmap_desc_hash;\n-\n /* Hashtable helpers.  */\n-static hashval_t\n-hash_descriptor (const void *p)\n-{\n-  const_bitmap_descriptor d = (const_bitmap_descriptor) p;\n-  return htab_hash_pointer (d->file) + d->line;\n-}\n+\n struct loc\n {\n   const char *file;\n   const char *function;\n   int line;\n };\n-static int\n-eq_descriptor (const void *p1, const void *p2)\n+\n+struct bitmap_desc_hasher : typed_noop_remove <bitmap_descriptor_d>\n+{\n+  typedef bitmap_descriptor_d value_type;\n+  typedef loc compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+bitmap_desc_hasher::hash (const value_type *d)\n+{\n+  return htab_hash_pointer (d->file) + d->line;\n+}\n+\n+inline bool\n+bitmap_desc_hasher::equal (const value_type *d, const compare_type *l)\n {\n-  const_bitmap_descriptor d = (const_bitmap_descriptor) p1;\n-  const struct loc *const l = (const struct loc *) p2;\n   return d->file == l->file && d->function == l->function && d->line == l->line;\n }\n \n+/* Hashtable mapping bitmap names to descriptors.  */\n+static hash_table <bitmap_desc_hasher> bitmap_desc_hash;\n+\n /* For given file and line, return descriptor, create new if needed.  */\n static bitmap_descriptor\n get_bitmap_descriptor (const char *file, int line, const char *function)\n {\n-  bitmap_descriptor *slot;\n+  bitmap_descriptor_d **slot;\n   struct loc loc;\n \n   loc.file = file;\n   loc.function = function;\n   loc.line = line;\n \n-  if (!bitmap_desc_hash)\n-    bitmap_desc_hash = htab_create (10, hash_descriptor, eq_descriptor, NULL);\n+  if (!bitmap_desc_hash.is_created ())\n+    bitmap_desc_hash.create (10);\n \n-  slot = (bitmap_descriptor *)\n-    htab_find_slot_with_hash (bitmap_desc_hash, &loc,\n-\t\t\t      htab_hash_pointer (file) + line,\n-\t\t\t      INSERT);\n+  slot = bitmap_desc_hash.find_slot_with_hash (&loc,\n+\t\t\t\t\t       htab_hash_pointer (file) + line,\n+\t\t\t\t\t       INSERT);\n   if (*slot)\n     return *slot;\n \n@@ -2141,13 +2148,12 @@ struct output_info\n   unsigned HOST_WIDEST_INT count;\n };\n \n-/* Called via htab_traverse.  Output bitmap descriptor pointed out by SLOT\n-   and update statistics.  */\n-static int\n-print_statistics (void **slot, void *b)\n+/* Called via hash_table::traverse.  Output bitmap descriptor pointed out by\n+   SLOT and update statistics.  */\n+int\n+print_statistics (bitmap_descriptor_d **slot, output_info *i)\n {\n-  bitmap_descriptor d = (bitmap_descriptor) *slot;\n-  struct output_info *i = (struct output_info *) b;\n+  bitmap_descriptor d = *slot;\n   char s[4096];\n \n   if (d->allocated)\n@@ -2181,7 +2187,7 @@ dump_bitmap_statistics (void)\n   if (! GATHER_STATISTICS)\n     return;\n \n-  if (!bitmap_desc_hash)\n+  if (!bitmap_desc_hash.is_created ())\n     return;\n \n   fprintf (stderr,\n@@ -2192,7 +2198,7 @@ dump_bitmap_statistics (void)\n   fprintf (stderr, \"---------------------------------------------------------------------------------\\n\");\n   info.count = 0;\n   info.size = 0;\n-  htab_traverse (bitmap_desc_hash, print_statistics, &info);\n+  bitmap_desc_hash.traverse <output_info *, print_statistics> (&info);\n   fprintf (stderr, \"---------------------------------------------------------------------------------\\n\");\n   fprintf (stderr,\n \t   \"%-41s %9\"HOST_WIDEST_INT_PRINT\"d %15\"HOST_WIDEST_INT_PRINT\"d\\n\","}, {"sha": "589e41ed3dfb5d7592cb8bdf17c02d02d27bf1fa", "filename": "gcc/cselib.c", "status": "modified", "additions": 88, "deletions": 90, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -34,7 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"emit-rtl.h\"\n #include \"diagnostic-core.h\"\n #include \"ggc.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"dumpfile.h\"\n #include \"cselib.h\"\n #include \"valtrack.h\"\n@@ -49,18 +49,18 @@ struct elt_list {\n     cselib_val *elt;\n };\n \n+/* See the documentation of cselib_find_slot below.  */\n+static enum machine_mode find_slot_memmode;\n+\n static bool cselib_record_memory;\n static bool cselib_preserve_constants;\n static bool cselib_any_perm_equivs;\n-static int entry_and_rtx_equal_p (const void *, const void *);\n-static hashval_t get_value_hash (const void *);\n+static inline void promote_debug_loc (struct elt_loc_list *l);\n static struct elt_list *new_elt_list (struct elt_list *, cselib_val *);\n static void new_elt_loc_list (cselib_val *, rtx);\n static void unchain_one_value (cselib_val *);\n static void unchain_one_elt_list (struct elt_list **);\n static void unchain_one_elt_loc_list (struct elt_loc_list **);\n-static int discard_useless_locs (void **, void *);\n-static int discard_useless_values (void **, void *);\n static void remove_useless_values (void);\n static int rtx_equal_for_cselib_1 (rtx, rtx, enum machine_mode);\n static unsigned int cselib_hash_rtx (rtx, int, enum machine_mode);\n@@ -91,8 +91,61 @@ static rtx cselib_expand_value_rtx_1 (rtx, struct expand_value_data *, int);\n      this involves walking the table entries for a given value and comparing\n      the locations of the entries with the rtx we are looking up.  */\n \n+struct cselib_hasher : typed_noop_remove <cselib_val>\n+{\n+  typedef cselib_val value_type;\n+  typedef rtx_def compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* The hash function for our hash table.  The value is always computed with\n+   cselib_hash_rtx when adding an element; this function just extracts the\n+   hash value from a cselib_val structure.  */\n+\n+inline hashval_t\n+cselib_hasher::hash (const value_type *v)\n+{\n+  return v->hash;\n+}\n+\n+/* The equality test for our hash table.  The first argument V is a table\n+   element (i.e. a cselib_val), while the second arg X is an rtx.  We know\n+   that all callers of htab_find_slot_with_hash will wrap CONST_INTs into a\n+   CONST of an appropriate mode.  */\n+\n+inline bool\n+cselib_hasher::equal (const value_type *v, const compare_type *x_arg)\n+{\n+  struct elt_loc_list *l;\n+  rtx x = CONST_CAST_RTX (x_arg);\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  gcc_assert (!CONST_SCALAR_INT_P (x) && GET_CODE (x) != CONST_FIXED);\n+\n+  if (mode != GET_MODE (v->val_rtx))\n+    return false;\n+\n+  /* Unwrap X if necessary.  */\n+  if (GET_CODE (x) == CONST\n+      && (CONST_SCALAR_INT_P (XEXP (x, 0))\n+\t  || GET_CODE (XEXP (x, 0)) == CONST_FIXED))\n+    x = XEXP (x, 0);\n+\n+  /* We don't guarantee that distinct rtx's have different hash values,\n+     so we need to do a comparison.  */\n+  for (l = v->locs; l; l = l->next)\n+    if (rtx_equal_for_cselib_1 (l->loc, x, find_slot_memmode))\n+      {\n+\tpromote_debug_loc (l);\n+\treturn true;\n+      }\n+\n+  return false;\n+}\n+\n /* A table that enables us to look up elts by their value.  */\n-static htab_t cselib_hash_table;\n+static hash_table <cselib_hasher> cselib_hash_table;\n \n /* This is a global so we don't have to pass this through every function.\n    It is used in new_elt_loc_list to set SETTING_INSN.  */\n@@ -432,13 +485,13 @@ invariant_or_equiv_p (cselib_val *v)\n /* Remove from hash table all VALUEs except constants, function\n    invariants and VALUE equivalences.  */\n \n-static int\n-preserve_constants_and_equivs (void **x, void *info ATTRIBUTE_UNUSED)\n+int\n+preserve_constants_and_equivs (cselib_val **x, void *info ATTRIBUTE_UNUSED)\n {\n-  cselib_val *v = (cselib_val *)*x;\n+  cselib_val *v = *x;\n \n   if (!invariant_or_equiv_p (v))\n-    htab_clear_slot (cselib_hash_table, x);\n+    cselib_hash_table.clear_slot (x);\n   return 1;\n }\n \n@@ -478,10 +531,10 @@ cselib_reset_table (unsigned int num)\n     }\n \n   if (cselib_preserve_constants)\n-    htab_traverse (cselib_hash_table, preserve_constants_and_equivs, NULL);\n+    cselib_hash_table.traverse <void *, preserve_constants_and_equivs> (NULL);\n   else\n     {\n-      htab_empty (cselib_hash_table);\n+      cselib_hash_table.empty ();\n       gcc_checking_assert (!cselib_any_perm_equivs);\n     }\n \n@@ -502,73 +555,23 @@ cselib_get_next_uid (void)\n   return next_uid;\n }\n \n-/* See the documentation of cselib_find_slot below.  */\n-static enum machine_mode find_slot_memmode;\n-\n /* Search for X, whose hashcode is HASH, in CSELIB_HASH_TABLE,\n    INSERTing if requested.  When X is part of the address of a MEM,\n    MEMMODE should specify the mode of the MEM.  While searching the\n    table, MEMMODE is held in FIND_SLOT_MEMMODE, so that autoinc RTXs\n    in X can be resolved.  */\n \n-static void **\n+static cselib_val **\n cselib_find_slot (rtx x, hashval_t hash, enum insert_option insert,\n \t\t  enum machine_mode memmode)\n {\n-  void **slot;\n+  cselib_val **slot;\n   find_slot_memmode = memmode;\n-  slot = htab_find_slot_with_hash (cselib_hash_table, x, hash, insert);\n+  slot = cselib_hash_table.find_slot_with_hash (x, hash, insert);\n   find_slot_memmode = VOIDmode;\n   return slot;\n }\n \n-/* The equality test for our hash table.  The first argument ENTRY is a table\n-   element (i.e. a cselib_val), while the second arg X is an rtx.  We know\n-   that all callers of htab_find_slot_with_hash will wrap CONST_INTs into a\n-   CONST of an appropriate mode.  */\n-\n-static int\n-entry_and_rtx_equal_p (const void *entry, const void *x_arg)\n-{\n-  struct elt_loc_list *l;\n-  const cselib_val *const v = (const cselib_val *) entry;\n-  rtx x = CONST_CAST_RTX ((const_rtx)x_arg);\n-  enum machine_mode mode = GET_MODE (x);\n-\n-  gcc_assert (!CONST_SCALAR_INT_P (x) && GET_CODE (x) != CONST_FIXED);\n-\n-  if (mode != GET_MODE (v->val_rtx))\n-    return 0;\n-\n-  /* Unwrap X if necessary.  */\n-  if (GET_CODE (x) == CONST\n-      && (CONST_SCALAR_INT_P (XEXP (x, 0))\n-\t  || GET_CODE (XEXP (x, 0)) == CONST_FIXED))\n-    x = XEXP (x, 0);\n-\n-  /* We don't guarantee that distinct rtx's have different hash values,\n-     so we need to do a comparison.  */\n-  for (l = v->locs; l; l = l->next)\n-    if (rtx_equal_for_cselib_1 (l->loc, x, find_slot_memmode))\n-      {\n-\tpromote_debug_loc (l);\n-\treturn 1;\n-      }\n-\n-  return 0;\n-}\n-\n-/* The hash function for our hash table.  The value is always computed with\n-   cselib_hash_rtx when adding an element; this function just extracts the\n-   hash value from a cselib_val structure.  */\n-\n-static hashval_t\n-get_value_hash (const void *entry)\n-{\n-  const cselib_val *const v = (const cselib_val *) entry;\n-  return v->hash;\n-}\n-\n /* Return true if X contains a VALUE rtx.  If ONLY_USELESS is set, we\n    only return true for values which point to a cselib_val whose value\n    element has been set to zero, which implies the cselib_val will be\n@@ -603,10 +606,10 @@ references_value_p (const_rtx x, int only_useless)\n    values (i.e. values without any location).  Called through\n    htab_traverse.  */\n \n-static int\n-discard_useless_locs (void **x, void *info ATTRIBUTE_UNUSED)\n+int\n+discard_useless_locs (cselib_val **x, void *info ATTRIBUTE_UNUSED)\n {\n-  cselib_val *v = (cselib_val *)*x;\n+  cselib_val *v = *x;\n   struct elt_loc_list **p = &v->locs;\n   bool had_locs = v->locs != NULL;\n   rtx setting_insn = v->locs ? v->locs->setting_insn : NULL;\n@@ -632,18 +635,18 @@ discard_useless_locs (void **x, void *info ATTRIBUTE_UNUSED)\n \n /* If X is a value with no locations, remove it from the hashtable.  */\n \n-static int\n-discard_useless_values (void **x, void *info ATTRIBUTE_UNUSED)\n+int\n+discard_useless_values (cselib_val **x, void *info ATTRIBUTE_UNUSED)\n {\n-  cselib_val *v = (cselib_val *)*x;\n+  cselib_val *v = *x;\n \n   if (v->locs == 0 && !PRESERVED_VALUE_P (v->val_rtx))\n     {\n       if (cselib_discard_hook)\n \tcselib_discard_hook (v);\n \n       CSELIB_VAL_PTR (v->val_rtx) = NULL;\n-      htab_clear_slot (cselib_hash_table, x);\n+      cselib_hash_table.clear_slot (x);\n       unchain_one_value (v);\n       n_useless_values--;\n     }\n@@ -664,7 +667,7 @@ remove_useless_values (void)\n   do\n     {\n       values_became_useless = 0;\n-      htab_traverse (cselib_hash_table, discard_useless_locs, 0);\n+      cselib_hash_table.traverse <void *, discard_useless_locs> (NULL);\n     }\n   while (values_became_useless);\n \n@@ -683,7 +686,7 @@ remove_useless_values (void)\n   n_debug_values -= n_useless_debug_values;\n   n_useless_debug_values = 0;\n \n-  htab_traverse (cselib_hash_table, discard_useless_values, 0);\n+  cselib_hash_table.traverse <void *, discard_useless_values> (NULL);\n \n   gcc_assert (!n_useless_values);\n }\n@@ -1352,7 +1355,7 @@ cselib_lookup_mem (rtx x, int create)\n {\n   enum machine_mode mode = GET_MODE (x);\n   enum machine_mode addr_mode;\n-  void **slot;\n+  cselib_val **slot;\n   cselib_val *addr;\n   cselib_val *mem_elt;\n   struct elt_list *l;\n@@ -1958,7 +1961,7 @@ static cselib_val *\n cselib_lookup_1 (rtx x, enum machine_mode mode,\n \t\t int create, enum machine_mode memmode)\n {\n-  void **slot;\n+  cselib_val **slot;\n   cselib_val *e;\n   unsigned int hashval;\n \n@@ -2069,7 +2072,7 @@ cselib_lookup_1 (rtx x, enum machine_mode mode,\n   /* We have to fill the slot before calling cselib_subst_to_values:\n      the hash table is inconsistent until we do so, and\n      cselib_subst_to_values will need to do lookups.  */\n-  *slot = (void *) e;\n+  *slot = e;\n   new_elt_loc_list (e, cselib_subst_to_values (x, memmode));\n   return e;\n }\n@@ -2695,9 +2698,7 @@ cselib_process_insn (rtx insn)\n          quadratic behavior for very large hashtables with very few\n \t useless elements.  */\n       && ((unsigned int)n_useless_values\n-\t  > (cselib_hash_table->n_elements\n-\t     - cselib_hash_table->n_deleted\n-\t     - n_debug_values) / 4))\n+\t  > (cselib_hash_table.elements () - n_debug_values) / 4))\n     remove_useless_values ();\n }\n \n@@ -2738,8 +2739,7 @@ cselib_init (int record_what)\n     }\n   used_regs = XNEWVEC (unsigned int, cselib_nregs);\n   n_used_regs = 0;\n-  cselib_hash_table = htab_create (31, get_value_hash,\n-\t\t\t\t   entry_and_rtx_equal_p, NULL);\n+  cselib_hash_table.create (31);\n   next_uid = 1;\n }\n \n@@ -2758,23 +2758,21 @@ cselib_finish (void)\n   free_alloc_pool (cselib_val_pool);\n   free_alloc_pool (value_pool);\n   cselib_clear_table ();\n-  htab_delete (cselib_hash_table);\n+  cselib_hash_table.dispose ();\n   free (used_regs);\n   used_regs = 0;\n-  cselib_hash_table = 0;\n   n_useless_values = 0;\n   n_useless_debug_values = 0;\n   n_debug_values = 0;\n   next_uid = 0;\n }\n \n-/* Dump the cselib_val *X to FILE *info.  */\n+/* Dump the cselib_val *X to FILE *OUT.  */\n \n-static int\n-dump_cselib_val (void **x, void *info)\n+int\n+dump_cselib_val (cselib_val **x, FILE *out)\n {\n-  cselib_val *v = (cselib_val *)*x;\n-  FILE *out = (FILE *)info;\n+  cselib_val *v = *x;\n   bool need_lf = true;\n \n   print_inline_rtx (out, v->val_rtx, 0);\n@@ -2849,7 +2847,7 @@ void\n dump_cselib_table (FILE *out)\n {\n   fprintf (out, \"cselib hash table:\\n\");\n-  htab_traverse (cselib_hash_table, dump_cselib_val, out);\n+  cselib_hash_table.traverse <FILE *, dump_cselib_val> (out);\n   if (first_containing_mem != &dummy_val)\n     {\n       fputs (\"first mem \", out);"}, {"sha": "4165b8747fca112cf9bd0a1484a517d1092158f9", "filename": "gcc/data-streamer-out.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fdata-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fdata-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer-out.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -42,8 +42,7 @@ streamer_string_index (struct output_block *ob, const char *s, unsigned int len,\n   s_slot.len = len;\n   s_slot.slot_num = 0;\n \n-  slot = (struct string_slot **) htab_find_slot (ob->string_hash_table,\n-\t\t\t\t\t\t &s_slot, INSERT);\n+  slot = ob->string_hash_table.find_slot (&s_slot, INSERT);\n   if (*slot == NULL)\n     {\n       struct lto_output_stream *string_stream = ob->string_stream;"}, {"sha": "b79abd9fd9221241dd281aee81fe1d31da2ee11b", "filename": "gcc/data-streamer.h", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fdata-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fdata-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdata-streamer.h?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -44,15 +44,6 @@ struct bitpack_d\n   void *stream;\n };\n \n-\n-/* String hashing.  */\n-struct string_slot\n-{\n-  const char *s;\n-  int len;\n-  unsigned int slot_num;\n-};\n-\n /* In data-streamer.c  */\n void bp_pack_var_len_unsigned (struct bitpack_d *, unsigned HOST_WIDE_INT);\n void bp_pack_var_len_int (struct bitpack_d *, HOST_WIDE_INT);\n@@ -93,35 +84,6 @@ unsigned HOST_WIDE_INT streamer_read_uhwi (struct lto_input_block *);\n HOST_WIDE_INT streamer_read_hwi (struct lto_input_block *);\n gcov_type streamer_read_gcov_count (struct lto_input_block *);\n \n-/* Returns a hash code for P.  Adapted from libiberty's htab_hash_string\n-   to support strings that may not end in '\\0'.  */\n-\n-static inline hashval_t\n-hash_string_slot_node (const void *p)\n-{\n-  const struct string_slot *ds = (const struct string_slot *) p;\n-  hashval_t r = ds->len;\n-  int i;\n-\n-  for (i = 0; i < ds->len; i++)\n-     r = r * 67 + (unsigned)ds->s[i] - 113;\n-  return r;\n-}\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static inline int\n-eq_string_slot_node (const void *p1, const void *p2)\n-{\n-  const struct string_slot *ds1 = (const struct string_slot *) p1;\n-  const struct string_slot *ds2 = (const struct string_slot *) p2;\n-\n-  if (ds1->len == ds2->len)\n-    return memcmp (ds1->s, ds2->s, ds1->len) == 0;\n-\n-  return 0;\n-}\n-\n /* Returns a new bit-packing context for bit-packing into S.  */\n static inline struct bitpack_d\n bitpack_create (struct lto_output_stream *s)"}, {"sha": "29779d6ad6a731ee1b0ac8df531c7a10c1271d82", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dwarf2out.h\"\n #include \"dwarf2asm.h\"\n #include \"ggc.h\"\n+#include \"hash-table.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"common/common-target.h\"\n@@ -153,10 +154,33 @@ typedef struct\n typedef dw_trace_info *dw_trace_info_ref;\n \n \n+/* Hashtable helpers.  */\n+\n+struct trace_info_hasher : typed_noop_remove <dw_trace_info>\n+{\n+  typedef dw_trace_info value_type;\n+  typedef dw_trace_info compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+trace_info_hasher::hash (const value_type *ti)\n+{\n+  return INSN_UID (ti->head);\n+}\n+\n+inline bool\n+trace_info_hasher::equal (const value_type *a, const compare_type *b)\n+{\n+  return a->head == b->head;\n+}\n+\n+\n /* The variables making up the pseudo-cfg, as described above.  */\n static vec<dw_trace_info> trace_info;\n static vec<dw_trace_info_ref> trace_work_list;\n-static htab_t trace_index;\n+static hash_table <trace_info_hasher> trace_index;\n \n /* A vector of call frame insns for the CIE.  */\n cfi_vec cie_cfi_vec;\n@@ -275,28 +299,12 @@ expand_builtin_init_dwarf_reg_sizes (tree address)\n }\n \n \f\n-static hashval_t\n-dw_trace_info_hash (const void *ptr)\n-{\n-  const dw_trace_info *ti = (const dw_trace_info *) ptr;\n-  return INSN_UID (ti->head);\n-}\n-\n-static int\n-dw_trace_info_eq (const void *ptr_a, const void *ptr_b)\n-{\n-  const dw_trace_info *a = (const dw_trace_info *) ptr_a;\n-  const dw_trace_info *b = (const dw_trace_info *) ptr_b;\n-  return a->head == b->head;\n-}\n-\n static dw_trace_info *\n get_trace_info (rtx insn)\n {\n   dw_trace_info dummy;\n   dummy.head = insn;\n-  return (dw_trace_info *)\n-    htab_find_with_hash (trace_index, &dummy, INSN_UID (insn));\n+  return trace_index.find_with_hash (&dummy, INSN_UID (insn));\n }\n \n static bool\n@@ -2744,22 +2752,20 @@ create_pseudo_cfg (void)\n \n   /* Create the trace index after we've finished building trace_info,\n      avoiding stale pointer problems due to reallocation.  */\n-  trace_index = htab_create (trace_info.length (),\n-\t\t\t     dw_trace_info_hash, dw_trace_info_eq, NULL);\n+  trace_index.create (trace_info.length ());\n   dw_trace_info *tp;\n   FOR_EACH_VEC_ELT (trace_info, i, tp)\n     {\n-      void **slot;\n+      dw_trace_info **slot;\n \n       if (dump_file)\n \tfprintf (dump_file, \"Creating trace %u : start at %s %d%s\\n\", i,\n \t\t rtx_name[(int) GET_CODE (tp->head)], INSN_UID (tp->head),\n \t\t tp->switch_sections ? \" (section switch)\" : \"\");\n \n-      slot = htab_find_slot_with_hash (trace_index, tp,\n-\t\t\t\t       INSN_UID (tp->head), INSERT);\n+      slot = trace_index.find_slot_with_hash (tp, INSN_UID (tp->head), INSERT);\n       gcc_assert (*slot == NULL);\n-      *slot = (void *) tp;\n+      *slot = tp;\n     }\n }\n \n@@ -2908,8 +2914,7 @@ execute_dwarf2_frame (void)\n   }\n   trace_info.release ();\n \n-  htab_delete (trace_index);\n-  trace_index = NULL;\n+  trace_index.dispose ();\n \n   return 0;\n }"}, {"sha": "de69cc8d7a71089bf105e2158e7e5fb97775604f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 235, "deletions": 213, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -84,7 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"common/common-target.h\"\n #include \"langhooks.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"cgraph.h\"\n #include \"input.h\"\n #include \"gimple.h\"\n@@ -3038,17 +3038,9 @@ static dw_die_ref remove_child_or_replace_with_skeleton (dw_die_ref,\n                                                          dw_die_ref,\n                                                          dw_die_ref);\n static void break_out_comdat_types (dw_die_ref);\n-static dw_die_ref copy_ancestor_tree (dw_die_ref, dw_die_ref, htab_t);\n-static void copy_decls_walk (dw_die_ref, dw_die_ref, htab_t);\n static void copy_decls_for_unworthy_types (dw_die_ref);\n \n-static hashval_t htab_cu_hash (const void *);\n-static int htab_cu_eq (const void *, const void *);\n-static void htab_cu_del (void *);\n-static int check_duplicate_cu (dw_die_ref, htab_t, unsigned *);\n-static void record_comdat_symbol_number (dw_die_ref, htab_t, unsigned);\n static void add_sibling_attributes (dw_die_ref);\n-static void build_abbrev_table (dw_die_ref, htab_t);\n static void output_location_lists (dw_die_ref);\n static int constant_size (unsigned HOST_WIDE_INT);\n static unsigned long size_of_die (dw_die_ref);\n@@ -6539,31 +6531,34 @@ struct cu_hash_table_entry\n   struct cu_hash_table_entry *next;\n };\n \n-/* Routines to manipulate hash table of CUs.  */\n-static hashval_t\n-htab_cu_hash (const void *of)\n+/* Helpers to manipulate hash table of CUs.  */\n+\n+struct cu_hash_table_entry_hasher\n {\n-  const struct cu_hash_table_entry *const entry =\n-    (const struct cu_hash_table_entry *) of;\n+  typedef cu_hash_table_entry value_type;\n+  typedef die_struct compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n \n+inline hashval_t\n+cu_hash_table_entry_hasher::hash (const value_type *entry)\n+{\n   return htab_hash_string (entry->cu->die_id.die_symbol);\n }\n \n-static int\n-htab_cu_eq (const void *of1, const void *of2)\n+inline bool\n+cu_hash_table_entry_hasher::equal (const value_type *entry1,\n+\t\t\t\t   const compare_type *entry2)\n {\n-  const struct cu_hash_table_entry *const entry1 =\n-    (const struct cu_hash_table_entry *) of1;\n-  const struct die_struct *const entry2 = (const struct die_struct *) of2;\n-\n   return !strcmp (entry1->cu->die_id.die_symbol, entry2->die_id.die_symbol);\n }\n \n-static void\n-htab_cu_del (void *what)\n+inline void\n+cu_hash_table_entry_hasher::remove (value_type *entry)\n {\n-  struct cu_hash_table_entry *next,\n-    *entry = (struct cu_hash_table_entry *) what;\n+  struct cu_hash_table_entry *next;\n \n   while (entry)\n     {\n@@ -6573,19 +6568,21 @@ htab_cu_del (void *what)\n     }\n }\n \n+typedef hash_table <cu_hash_table_entry_hasher> cu_hash_type;\n+\n /* Check whether we have already seen this CU and set up SYM_NUM\n    accordingly.  */\n static int\n-check_duplicate_cu (dw_die_ref cu, htab_t htable, unsigned int *sym_num)\n+check_duplicate_cu (dw_die_ref cu, cu_hash_type htable, unsigned int *sym_num)\n {\n   struct cu_hash_table_entry dummy;\n   struct cu_hash_table_entry **slot, *entry, *last = &dummy;\n \n   dummy.max_comdat_num = 0;\n \n-  slot = (struct cu_hash_table_entry **)\n-    htab_find_slot_with_hash (htable, cu, htab_hash_string (cu->die_id.die_symbol),\n-\tINSERT);\n+  slot = htable.find_slot_with_hash (cu,\n+\t\t\t\t     htab_hash_string (cu->die_id.die_symbol),\n+\t\t\t\t     INSERT);\n   entry = *slot;\n \n   for (; entry; last = entry, entry = entry->next)\n@@ -6611,13 +6608,14 @@ check_duplicate_cu (dw_die_ref cu, htab_t htable, unsigned int *sym_num)\n \n /* Record SYM_NUM to record of CU in HTABLE.  */\n static void\n-record_comdat_symbol_number (dw_die_ref cu, htab_t htable, unsigned int sym_num)\n+record_comdat_symbol_number (dw_die_ref cu, cu_hash_type htable,\n+\t\t\t     unsigned int sym_num)\n {\n   struct cu_hash_table_entry **slot, *entry;\n \n-  slot = (struct cu_hash_table_entry **)\n-    htab_find_slot_with_hash (htable, cu, htab_hash_string (cu->die_id.die_symbol),\n-\tNO_INSERT);\n+  slot = htable.find_slot_with_hash (cu,\n+\t\t\t\t     htab_hash_string (cu->die_id.die_symbol),\n+\t\t\t\t     NO_INSERT);\n   entry = *slot;\n \n   entry->max_comdat_num = sym_num;\n@@ -6633,7 +6631,7 @@ break_out_includes (dw_die_ref die)\n   dw_die_ref c;\n   dw_die_ref unit = NULL;\n   limbo_die_node *node, **pnode;\n-  htab_t cu_hash_table;\n+  cu_hash_type cu_hash_table;\n \n   c = die->die_child;\n   if (c) do {\n@@ -6666,7 +6664,7 @@ break_out_includes (dw_die_ref die)\n #endif\n \n   assign_symbol_names (die);\n-  cu_hash_table = htab_create (10, htab_cu_hash, htab_cu_eq, htab_cu_del);\n+  cu_hash_table.create (10);\n   for (node = limbo_die_list, pnode = &limbo_die_list;\n        node;\n        node = node->next)\n@@ -6686,7 +6684,7 @@ break_out_includes (dw_die_ref die)\n \t\tcomdat_symbol_number);\n \t}\n     }\n-  htab_delete (cu_hash_table);\n+  cu_hash_table.dispose ();\n }\n \n /* Return non-zero if this DIE is a declaration.  */\n@@ -6861,6 +6859,94 @@ clone_as_declaration (dw_die_ref die)\n   return clone;\n }\n \n+\n+/* Structure to map a DIE in one CU to its copy in a comdat type unit.  */\n+\n+struct decl_table_entry\n+{\n+  dw_die_ref orig;\n+  dw_die_ref copy;\n+};\n+\n+/* Helpers to manipulate hash table of copied declarations.  */\n+\n+/* Hashtable helpers.  */\n+\n+struct decl_table_entry_hasher : typed_free_remove <decl_table_entry>\n+{\n+  typedef decl_table_entry value_type;\n+  typedef die_struct compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+decl_table_entry_hasher::hash (const value_type *entry)\n+{\n+  return htab_hash_pointer (entry->orig);\n+}\n+\n+inline bool\n+decl_table_entry_hasher::equal (const value_type *entry1,\n+\t\t\t\tconst compare_type *entry2)\n+{\n+  return entry1->orig == entry2;\n+}\n+\n+typedef hash_table <decl_table_entry_hasher> decl_hash_type;\n+\n+/* Copy DIE and its ancestors, up to, but not including, the compile unit\n+   or type unit entry, to a new tree.  Adds the new tree to UNIT and returns\n+   a pointer to the copy of DIE.  If DECL_TABLE is provided, it is used\n+   to check if the ancestor has already been copied into UNIT.  */\n+\n+static dw_die_ref\n+copy_ancestor_tree (dw_die_ref unit, dw_die_ref die, decl_hash_type decl_table)\n+{\n+  dw_die_ref parent = die->die_parent;\n+  dw_die_ref new_parent = unit;\n+  dw_die_ref copy;\n+  decl_table_entry **slot = NULL;\n+  struct decl_table_entry *entry = NULL;\n+\n+  if (decl_table.is_created ())\n+    {\n+      /* Check if the entry has already been copied to UNIT.  */\n+      slot = decl_table.find_slot_with_hash (die, htab_hash_pointer (die),\n+\t\t\t\t\t     INSERT);\n+      if (*slot != HTAB_EMPTY_ENTRY)\n+        {\n+          entry = *slot;\n+          return entry->copy;\n+        }\n+\n+      /* Record in DECL_TABLE that DIE has been copied to UNIT.  */\n+      entry = XCNEW (struct decl_table_entry);\n+      entry->orig = die;\n+      entry->copy = NULL;\n+      *slot = entry;\n+    }\n+\n+  if (parent != NULL)\n+    {\n+      dw_die_ref spec = get_AT_ref (parent, DW_AT_specification);\n+      if (spec != NULL)\n+        parent = spec;\n+      if (!is_unit_die (parent))\n+        new_parent = copy_ancestor_tree (unit, parent, decl_table);\n+    }\n+\n+  copy = clone_as_declaration (die);\n+  add_child_die (new_parent, copy);\n+\n+  if (decl_table.is_created ())\n+    {\n+      /* Record the pointer to the copy.  */\n+      entry->copy = copy;\n+    }\n+\n+  return copy;\n+}\n /* Copy the declaration context to the new type unit DIE.  This includes\n    any surrounding namespace or type declarations.  If the DIE has an\n    AT_specification attribute, it also includes attributes and children\n@@ -6908,7 +6994,7 @@ copy_declaration_context (dw_die_ref unit, dw_die_ref die)\n   if (decl->die_parent != NULL\n       && !is_unit_die (decl->die_parent))\n     {\n-      new_decl = copy_ancestor_tree (unit, decl, NULL);\n+      new_decl = copy_ancestor_tree (unit, decl, decl_hash_type ());\n       if (new_decl != NULL)\n         {\n           remove_AT (new_decl, DW_AT_signature);\n@@ -7107,106 +7193,16 @@ break_out_comdat_types (dw_die_ref die)\n   } while (next != NULL);\n }\n \n-/* Structure to map a DIE in one CU to its copy in a comdat type unit.  */\n-\n-struct decl_table_entry\n-{\n-  dw_die_ref orig;\n-  dw_die_ref copy;\n-};\n-\n-/* Routines to manipulate hash table of copied declarations.  */\n-\n-static hashval_t\n-htab_decl_hash (const void *of)\n-{\n-  const struct decl_table_entry *const entry =\n-    (const struct decl_table_entry *) of;\n-\n-  return htab_hash_pointer (entry->orig);\n-}\n-\n-static int\n-htab_decl_eq (const void *of1, const void *of2)\n-{\n-  const struct decl_table_entry *const entry1 =\n-    (const struct decl_table_entry *) of1;\n-  const struct die_struct *const entry2 = (const struct die_struct *) of2;\n-\n-  return entry1->orig == entry2;\n-}\n-\n-static void\n-htab_decl_del (void *what)\n-{\n-  struct decl_table_entry *entry = (struct decl_table_entry *) what;\n-\n-  free (entry);\n-}\n-\n-/* Copy DIE and its ancestors, up to, but not including, the compile unit\n-   or type unit entry, to a new tree.  Adds the new tree to UNIT and returns\n-   a pointer to the copy of DIE.  If DECL_TABLE is provided, it is used\n-   to check if the ancestor has already been copied into UNIT.  */\n-\n-static dw_die_ref\n-copy_ancestor_tree (dw_die_ref unit, dw_die_ref die, htab_t decl_table)\n-{\n-  dw_die_ref parent = die->die_parent;\n-  dw_die_ref new_parent = unit;\n-  dw_die_ref copy;\n-  void **slot = NULL;\n-  struct decl_table_entry *entry = NULL;\n-\n-  if (decl_table)\n-    {\n-      /* Check if the entry has already been copied to UNIT.  */\n-      slot = htab_find_slot_with_hash (decl_table, die,\n-                                       htab_hash_pointer (die), INSERT);\n-      if (*slot != HTAB_EMPTY_ENTRY)\n-        {\n-          entry = (struct decl_table_entry *) *slot;\n-          return entry->copy;\n-        }\n-\n-      /* Record in DECL_TABLE that DIE has been copied to UNIT.  */\n-      entry = XCNEW (struct decl_table_entry);\n-      entry->orig = die;\n-      entry->copy = NULL;\n-      *slot = entry;\n-    }\n-\n-  if (parent != NULL)\n-    {\n-      dw_die_ref spec = get_AT_ref (parent, DW_AT_specification);\n-      if (spec != NULL)\n-        parent = spec;\n-      if (!is_unit_die (parent))\n-        new_parent = copy_ancestor_tree (unit, parent, decl_table);\n-    }\n-\n-  copy = clone_as_declaration (die);\n-  add_child_die (new_parent, copy);\n-\n-  if (decl_table != NULL)\n-    {\n-      /* Record the pointer to the copy.  */\n-      entry->copy = copy;\n-    }\n-\n-  return copy;\n-}\n-\n /* Like clone_tree, but additionally enter all the children into\n    the hash table decl_table.  */\n \n static dw_die_ref\n-clone_tree_hash (dw_die_ref die, htab_t decl_table)\n+clone_tree_hash (dw_die_ref die, decl_hash_type decl_table)\n {\n   dw_die_ref c;\n   dw_die_ref clone = clone_die (die);\n   struct decl_table_entry *entry;\n-  void **slot = htab_find_slot_with_hash (decl_table, die,\n+  decl_table_entry **slot = decl_table.find_slot_with_hash (die,\n \t\t\t\t\t  htab_hash_pointer (die), INSERT);\n   /* Assert that DIE isn't in the hash table yet.  If it would be there\n      before, the ancestors would be necessarily there as well, therefore\n@@ -7228,7 +7224,7 @@ clone_tree_hash (dw_die_ref die, htab_t decl_table)\n    type_unit).  */\n \n static void\n-copy_decls_walk (dw_die_ref unit, dw_die_ref die, htab_t decl_table)\n+copy_decls_walk (dw_die_ref unit, dw_die_ref die, decl_hash_type decl_table)\n {\n   dw_die_ref c;\n   dw_attr_ref a;\n@@ -7239,20 +7235,20 @@ copy_decls_walk (dw_die_ref unit, dw_die_ref die, htab_t decl_table)\n       if (AT_class (a) == dw_val_class_die_ref)\n         {\n           dw_die_ref targ = AT_ref (a);\n-          void **slot;\n+          decl_table_entry **slot;\n           struct decl_table_entry *entry;\n \n           if (targ->die_mark != 0 || targ->comdat_type_p)\n             continue;\n \n-          slot = htab_find_slot_with_hash (decl_table, targ,\n-                                           htab_hash_pointer (targ), INSERT);\n+          slot = decl_table.find_slot_with_hash (targ, htab_hash_pointer (targ),\n+\t\t\t\t\t\t INSERT);\n \n           if (*slot != HTAB_EMPTY_ENTRY)\n             {\n               /* TARG has already been copied, so we just need to\n                  modify the reference to point to the copy.  */\n-              entry = (struct decl_table_entry *) *slot;\n+              entry = *slot;\n               a->dw_attr_val.v.val_die_ref.die = entry->copy;\n             }\n           else\n@@ -7319,12 +7315,12 @@ copy_decls_walk (dw_die_ref unit, dw_die_ref die, htab_t decl_table)\n static void\n copy_decls_for_unworthy_types (dw_die_ref unit)\n {\n-  htab_t decl_table;\n+  decl_hash_type decl_table;\n \n   mark_dies (unit);\n-  decl_table = htab_create (10, htab_decl_hash, htab_decl_eq, htab_decl_del);\n+  decl_table.create (10);\n   copy_decls_walk (unit, unit, decl_table);\n-  htab_delete (decl_table);\n+  decl_table.dispose ();\n   unmark_dies (unit);\n }\n \n@@ -7379,37 +7375,42 @@ struct external_ref\n   unsigned n_refs;\n };\n \n-/* Hash an external_ref.  */\n+/* Hashtable helpers.  */\n \n-static hashval_t\n-hash_external_ref (const void *p)\n+struct external_ref_hasher : typed_free_remove <external_ref>\n+{\n+  typedef external_ref value_type;\n+  typedef external_ref compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+external_ref_hasher::hash (const value_type *r)\n {\n-  const struct external_ref *r = (const struct external_ref *)p;\n   return htab_hash_pointer (r->type);\n }\n \n-/* Compare external_refs.  */\n-\n-static int\n-external_ref_eq (const void *p1, const void *p2)\n+inline bool\n+external_ref_hasher::equal (const value_type *r1, const compare_type *r2)\n {\n-  const struct external_ref *r1 = (const struct external_ref *)p1;\n-  const struct external_ref *r2 = (const struct external_ref *)p2;\n   return r1->type == r2->type;\n }\n \n+typedef hash_table <external_ref_hasher> external_ref_hash_type;\n+\n /* Return a pointer to the external_ref for references to DIE.  */\n \n static struct external_ref *\n-lookup_external_ref (htab_t map, dw_die_ref die)\n+lookup_external_ref (external_ref_hash_type map, dw_die_ref die)\n {\n   struct external_ref ref, *ref_p;\n-  void ** slot;\n+  external_ref **slot;\n \n   ref.type = die;\n-  slot = htab_find_slot (map, &ref, INSERT);\n+  slot = map.find_slot (&ref, INSERT);\n   if (*slot != HTAB_EMPTY_ENTRY)\n-    return (struct external_ref *) *slot;\n+    return *slot;\n \n   ref_p = XCNEW (struct external_ref);\n   ref_p->type = die;\n@@ -7423,7 +7424,7 @@ lookup_external_ref (htab_t map, dw_die_ref die)\n    references, remember how many we've seen.  */\n \n static void\n-optimize_external_refs_1 (dw_die_ref die, htab_t map)\n+optimize_external_refs_1 (dw_die_ref die, external_ref_hash_type map)\n {\n   dw_die_ref c;\n   dw_attr_ref a;\n@@ -7456,17 +7457,17 @@ optimize_external_refs_1 (dw_die_ref die, htab_t map)\n    points to an external_ref, DATA is the CU we're processing.  If we don't\n    already have a local stub, and we have multiple refs, build a stub.  */\n \n-static int\n-build_local_stub (void **slot, void *data)\n+int\n+dwarf2_build_local_stub (external_ref **slot, dw_die_ref data)\n {\n-  struct external_ref *ref_p = (struct external_ref *)*slot;\n+  struct external_ref *ref_p = *slot;\n \n   if (ref_p->stub == NULL && ref_p->n_refs > 1 && !dwarf_strict)\n     {\n       /* We have multiple references to this type, so build a small stub.\n \t Both of these forms are a bit dodgy from the perspective of the\n \t DWARF standard, since technically they should have names.  */\n-      dw_die_ref cu = (dw_die_ref) data;\n+      dw_die_ref cu = data;\n       dw_die_ref type = ref_p->type;\n       dw_die_ref stub = NULL;\n \n@@ -7494,12 +7495,13 @@ build_local_stub (void **slot, void *data)\n    them which will be applied in build_abbrev_table.  This is useful because\n    references to local DIEs are smaller.  */\n \n-static htab_t\n+static external_ref_hash_type\n optimize_external_refs (dw_die_ref die)\n {\n-  htab_t map = htab_create (10, hash_external_ref, external_ref_eq, free);\n+  external_ref_hash_type map;\n+  map.create (10);\n   optimize_external_refs_1 (die, map);\n-  htab_traverse (map, build_local_stub, die);\n+  map.traverse <dw_die_ref, dwarf2_build_local_stub> (die);\n   return map;\n }\n \n@@ -7509,7 +7511,7 @@ optimize_external_refs (dw_die_ref die)\n    die are visited recursively.  */\n \n static void\n-build_abbrev_table (dw_die_ref die, htab_t extern_map)\n+build_abbrev_table (dw_die_ref die, external_ref_hash_type extern_map)\n {\n   unsigned long abbrev_id;\n   unsigned int n_alloc;\n@@ -8640,7 +8642,7 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n {\n   const char *secname, *oldsym;\n   char *tmp;\n-  htab_t extern_map;\n+  external_ref_hash_type extern_map;\n \n   /* Unless we are outputting main CU, we may throw away empty ones.  */\n   if (!output_if_empty && die->die_child == NULL)\n@@ -8657,7 +8659,7 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n \n   build_abbrev_table (die, extern_map);\n \n-  htab_delete (extern_map);\n+  extern_map.dispose ();\n \n   /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */\n   next_die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n@@ -8830,7 +8832,7 @@ output_comdat_type_unit (comdat_type_node *node)\n #if defined (OBJECT_FORMAT_ELF)\n   tree comdat_key;\n #endif\n-  htab_t extern_map;\n+  external_ref_hash_type extern_map;\n \n   /* First mark all the DIEs in this CU so we know which get local refs.  */\n   mark_dies (node->root_die);\n@@ -8839,7 +8841,7 @@ output_comdat_type_unit (comdat_type_node *node)\n \n   build_abbrev_table (node->root_die, extern_map);\n \n-  htab_delete (extern_map);\n+  extern_map.dispose ();\n \n   /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */\n   next_die_offset = DWARF_COMDAT_TYPE_UNIT_HEADER_SIZE;\n@@ -21326,26 +21328,31 @@ dwarf2out_undef (unsigned int lineno ATTRIBUTE_UNUSED,\n     }\n }\n \n-/* Routines to manipulate hash table of CUs.  */\n+/* Helpers to manipulate hash table of CUs.  */\n \n-static hashval_t\n-htab_macinfo_hash (const void *of)\n+struct macinfo_entry_hasher : typed_noop_remove <macinfo_entry>\n {\n-  const macinfo_entry *const entry =\n-    (const macinfo_entry *) of;\n+  typedef macinfo_entry value_type;\n+  typedef macinfo_entry compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n \n+inline hashval_t\n+macinfo_entry_hasher::hash (const value_type *entry)\n+{\n   return htab_hash_string (entry->info);\n }\n \n-static int\n-htab_macinfo_eq (const void *of1, const void *of2)\n+inline bool\n+macinfo_entry_hasher::equal (const value_type *entry1,\n+\t\t\t     const compare_type *entry2)\n {\n-  const macinfo_entry *const entry1 = (const macinfo_entry *) of1;\n-  const macinfo_entry *const entry2 = (const macinfo_entry *) of2;\n-\n   return !strcmp (entry1->info, entry2->info);\n }\n \n+typedef hash_table <macinfo_entry_hasher> macinfo_hash_type;\n+\n /* Output a single .debug_macinfo entry.  */\n \n static void\n@@ -21434,7 +21441,7 @@ output_macinfo_op (macinfo_entry *ref)\n \n static unsigned\n optimize_macinfo_range (unsigned int idx, vec<macinfo_entry, va_gc> *files,\n-\t\t\thtab_t *macinfo_htab)\n+\t\t\tmacinfo_hash_type *macinfo_htab)\n {\n   macinfo_entry *first, *second, *cur, *inc;\n   char linebuf[sizeof (HOST_WIDE_INT) * 3 + 1];\n@@ -21443,7 +21450,7 @@ optimize_macinfo_range (unsigned int idx, vec<macinfo_entry, va_gc> *files,\n   char *grp_name, *tail;\n   const char *base;\n   unsigned int i, count, encoded_filename_len, linebuf_len;\n-  void **slot;\n+  macinfo_entry **slot;\n \n   first = &(*macinfo_table)[idx];\n   second = &(*macinfo_table)[idx + 1];\n@@ -21521,17 +21528,17 @@ optimize_macinfo_range (unsigned int idx, vec<macinfo_entry, va_gc> *files,\n   inc->code = DW_MACRO_GNU_transparent_include;\n   inc->lineno = 0;\n   inc->info = ggc_strdup (grp_name);\n-  if (*macinfo_htab == NULL)\n-    *macinfo_htab = htab_create (10, htab_macinfo_hash, htab_macinfo_eq, NULL);\n+  if (!macinfo_htab->is_created ())\n+    macinfo_htab->create (10);\n   /* Avoid emitting duplicates.  */\n-  slot = htab_find_slot (*macinfo_htab, inc, INSERT);\n+  slot = macinfo_htab->find_slot (inc, INSERT);\n   if (*slot != NULL)\n     {\n       inc->code = 0;\n       inc->info = NULL;\n       /* If such an entry has been used before, just emit\n \t a DW_MACRO_GNU_transparent_include op.  */\n-      inc = (macinfo_entry *) *slot;\n+      inc = *slot;\n       output_macinfo_op (inc);\n       /* And clear all macinfo_entry in the range to avoid emitting them\n \t in the second pass.  */\n@@ -21544,7 +21551,7 @@ optimize_macinfo_range (unsigned int idx, vec<macinfo_entry, va_gc> *files,\n   else\n     {\n       *slot = inc;\n-      inc->lineno = htab_elements (*macinfo_htab);\n+      inc->lineno = macinfo_htab->elements ();\n       output_macinfo_op (inc);\n     }\n   return count;\n@@ -21595,7 +21602,7 @@ output_macinfo (void)\n   unsigned long length = vec_safe_length (macinfo_table);\n   macinfo_entry *ref;\n   vec<macinfo_entry, va_gc> *files = NULL;\n-  htab_t macinfo_htab = NULL;\n+  macinfo_hash_type macinfo_htab;\n \n   if (! length)\n     return;\n@@ -21668,10 +21675,10 @@ output_macinfo (void)\n       ref->code = 0;\n     }\n \n-  if (macinfo_htab == NULL)\n+  if (!macinfo_htab.is_created ())\n     return;\n \n-  htab_delete (macinfo_htab);\n+  macinfo_htab.dispose ();\n \n   /* If any DW_MACRO_GNU_transparent_include were used, on those\n      DW_MACRO_GNU_transparent_include entries terminate the\n@@ -22410,24 +22417,28 @@ file_table_relative_p (void ** slot, void *param)\n   return 1;\n }\n \n-/* Routines to manipulate hash table of comdat type units.  */\n+/* Helpers to manipulate hash table of comdat type units.  */\n \n-static hashval_t\n-htab_ct_hash (const void *of)\n+struct comdat_type_hasher : typed_noop_remove <comdat_type_node>\n {\n-  hashval_t h;\n-  const comdat_type_node *const type_node = (const comdat_type_node *) of;\n+  typedef comdat_type_node value_type;\n+  typedef comdat_type_node compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n \n+inline hashval_t\n+comdat_type_hasher::hash (const value_type *type_node)\n+{\n+  hashval_t h;\n   memcpy (&h, type_node->signature, sizeof (h));\n   return h;\n }\n \n-static int\n-htab_ct_eq (const void *of1, const void *of2)\n+inline bool\n+comdat_type_hasher::equal (const value_type *type_node_1,\n+\t\t\t   const compare_type *type_node_2)\n {\n-  const comdat_type_node *const type_node_1 = (const comdat_type_node *) of1;\n-  const comdat_type_node *const type_node_2 = (const comdat_type_node *) of2;\n-\n   return (! memcmp (type_node_1->signature, type_node_2->signature,\n                     DWARF_TYPE_SIGNATURE_SIZE));\n }\n@@ -23491,21 +23502,29 @@ compare_locs (dw_loc_descr_ref x, dw_loc_descr_ref y)\n   return x == NULL && y == NULL;\n }\n \n+/* Hashtable helpers.  */\n+\n+struct loc_list_hasher : typed_noop_remove <dw_loc_list_struct>\n+{\n+  typedef dw_loc_list_struct value_type;\n+  typedef dw_loc_list_struct compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n /* Return precomputed hash of location list X.  */\n \n-static hashval_t\n-loc_list_hash (const void *x)\n+inline hashval_t\n+loc_list_hasher::hash (const value_type *x)\n {\n-  return ((const struct dw_loc_list_struct *) x)->hash;\n+  return x->hash;\n }\n \n-/* Return 1 if location lists X and Y are the same.  */\n+/* Return true if location lists A and B are the same.  */\n \n-static int\n-loc_list_eq (const void *x, const void *y)\n+inline bool\n+loc_list_hasher::equal (const value_type *a, const compare_type *b)\n {\n-  const struct dw_loc_list_struct *a = (const struct dw_loc_list_struct *) x;\n-  const struct dw_loc_list_struct *b = (const struct dw_loc_list_struct *) y;\n   if (a == b)\n     return 1;\n   if (a->hash != b->hash)\n@@ -23520,16 +23539,19 @@ loc_list_eq (const void *x, const void *y)\n   return a == NULL && b == NULL;\n }\n \n+typedef hash_table <loc_list_hasher> loc_list_hash_type;\n+\n+\n /* Recursively optimize location lists referenced from DIE\n    children and share them whenever possible.  */\n \n static void\n-optimize_location_lists_1 (dw_die_ref die, htab_t htab)\n+optimize_location_lists_1 (dw_die_ref die, loc_list_hash_type htab)\n {\n   dw_die_ref c;\n   dw_attr_ref a;\n   unsigned ix;\n-  void **slot;\n+  dw_loc_list_struct **slot;\n \n   FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_loc_list)\n@@ -23538,12 +23560,11 @@ optimize_location_lists_1 (dw_die_ref die, htab_t htab)\n \t/* TODO: perform some optimizations here, before hashing\n \t   it and storing into the hash table.  */\n \thash_loc_list (list);\n-\tslot = htab_find_slot_with_hash (htab, list, list->hash,\n-\t\t\t\t\t INSERT);\n+\tslot = htab.find_slot_with_hash (list, list->hash, INSERT);\n \tif (*slot == NULL)\n-\t  *slot = (void *) list;\n+\t  *slot = list;\n \telse\n-          a->dw_attr_val.v.val_loc_list = (dw_loc_list_ref) *slot;\n+          a->dw_attr_val.v.val_loc_list = *slot;\n       }\n \n   FOR_EACH_CHILD (die, c, optimize_location_lists_1 (c, htab));\n@@ -23588,9 +23609,10 @@ index_location_lists (dw_die_ref die)\n static void\n optimize_location_lists (dw_die_ref die)\n {\n-  htab_t htab = htab_create (500, loc_list_hash, loc_list_eq, NULL);\n+  loc_list_hash_type htab;\n+  htab.create (500);\n   optimize_location_lists_1 (die, htab);\n-  htab_delete (htab);\n+  htab.dispose ();\n }\n \f\n /* Output stuff that dwarf requires at the end of every file,\n@@ -23601,7 +23623,7 @@ dwarf2out_finish (const char *filename)\n {\n   limbo_die_node *node, *next_node;\n   comdat_type_node *ctnode;\n-  htab_t comdat_type_table;\n+  hash_table <comdat_type_hasher> comdat_type_table;\n   unsigned int i;\n   dw_die_ref main_comp_unit_die;\n \n@@ -23870,10 +23892,10 @@ dwarf2out_finish (const char *filename)\n   for (node = limbo_die_list; node; node = node->next)\n     output_comp_unit (node->die, 0);\n \n-  comdat_type_table = htab_create (100, htab_ct_hash, htab_ct_eq, NULL);\n+  comdat_type_table.create (100);\n   for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n     {\n-      void **slot = htab_find_slot (comdat_type_table, ctnode, INSERT);\n+      comdat_type_node **slot = comdat_type_table.find_slot (ctnode, INSERT);\n \n       /* Don't output duplicate types.  */\n       if (*slot != HTAB_EMPTY_ENTRY)\n@@ -23891,7 +23913,7 @@ dwarf2out_finish (const char *filename)\n       output_comdat_type_unit (ctnode);\n       *slot = ctnode;\n     }\n-  htab_delete (comdat_type_table);\n+  comdat_type_table.dispose ();\n \n   /* The AT_pubnames attribute needs to go in all skeleton dies, including\n      both the main_cu and all skeleton TUs.  Making this call unconditional"}, {"sha": "b25207b4c87e5f64150c156d7e0c36ac3273d47d", "filename": "gcc/except.c", "status": "modified", "additions": 100, "deletions": 81, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -128,7 +128,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dwarf2out.h\"\n #include \"dwarf2.h\"\n #include \"toplev.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"intl.h\"\n #include \"ggc.h\"\n #include \"tm_p.h\"\n@@ -166,25 +166,59 @@ struct GTY(()) call_site_record_d\n   rtx landing_pad;\n   int action;\n };\n+\n+/* In the following structure and associated functions,\n+   we represent entries in the action table as 1-based indices.\n+   Special cases are:\n+\n+\t 0:\tnull action record, non-null landing pad; implies cleanups\n+\t-1:\tnull action record, null landing pad; implies no action\n+\t-2:\tno call-site entry; implies must_not_throw\n+\t-3:\twe have yet to process outer regions\n+\n+   Further, no special cases apply to the \"next\" field of the record.\n+   For next, 0 means end of list.  */\n+\n+struct action_record\n+{\n+  int offset;\n+  int filter;\n+  int next;\n+};\n+\n+/* Hashtable helpers.  */\n+\n+struct action_record_hasher : typed_free_remove <action_record>\n+{\n+  typedef action_record value_type;\n+  typedef action_record compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+action_record_hasher::hash (const value_type *entry)\n+{\n+  return entry->next * 1009 + entry->filter;\n+}\n+\n+inline bool\n+action_record_hasher::equal (const value_type *entry, const compare_type *data)\n+{\n+  return entry->filter == data->filter && entry->next == data->next;\n+}\n+\n+typedef hash_table <action_record_hasher> action_hash_type;\n \f\n static bool get_eh_region_and_lp_from_rtx (const_rtx, eh_region *,\n \t\t\t\t\t   eh_landing_pad *);\n \n static int t2r_eq (const void *, const void *);\n static hashval_t t2r_hash (const void *);\n \n-static int ttypes_filter_eq (const void *, const void *);\n-static hashval_t ttypes_filter_hash (const void *);\n-static int ehspec_filter_eq (const void *, const void *);\n-static hashval_t ehspec_filter_hash (const void *);\n-static int add_ttypes_entry (htab_t, tree);\n-static int add_ehspec_entry (htab_t, htab_t, tree);\n static void dw2_build_landing_pads (void);\n \n-static int action_record_eq (const void *, const void *);\n-static hashval_t action_record_hash (const void *);\n-static int add_action_record (htab_t, int, int);\n-static int collect_one_action_chain (htab_t, eh_region);\n+static int collect_one_action_chain (action_hash_type, eh_region);\n static int add_call_site (rtx, int, int);\n \n static void push_uleb128 (vec<uchar, va_gc> **, unsigned int);\n@@ -687,46 +721,60 @@ struct ttypes_filter {\n   int filter;\n };\n \n+/* Helper for ttypes_filter hashing.  */\n+\n+struct ttypes_filter_hasher : typed_free_remove <ttypes_filter>\n+{\n+  typedef ttypes_filter value_type;\n+  typedef tree_node compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n /* Compare ENTRY (a ttypes_filter entry in the hash table) with DATA\n    (a tree) for a @TTypes type node we are thinking about adding.  */\n \n-static int\n-ttypes_filter_eq (const void *pentry, const void *pdata)\n+inline bool\n+ttypes_filter_hasher::equal (const value_type *entry, const compare_type *data)\n {\n-  const struct ttypes_filter *const entry\n-    = (const struct ttypes_filter *) pentry;\n-  const_tree const data = (const_tree) pdata;\n-\n   return entry->t == data;\n }\n \n-static hashval_t\n-ttypes_filter_hash (const void *pentry)\n+inline hashval_t\n+ttypes_filter_hasher::hash (const value_type *entry)\n {\n-  const struct ttypes_filter *entry = (const struct ttypes_filter *) pentry;\n   return TREE_HASH (entry->t);\n }\n \n+typedef hash_table <ttypes_filter_hasher> ttypes_hash_type;\n+\n+\n+/* Helper for ehspec hashing.  */\n+\n+struct ehspec_hasher : typed_free_remove <ttypes_filter>\n+{\n+  typedef ttypes_filter value_type;\n+  typedef ttypes_filter compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n /* Compare ENTRY with DATA (both struct ttypes_filter) for a @TTypes\n    exception specification list we are thinking about adding.  */\n /* ??? Currently we use the type lists in the order given.  Someone\n    should put these in some canonical order.  */\n \n-static int\n-ehspec_filter_eq (const void *pentry, const void *pdata)\n+inline bool\n+ehspec_hasher::equal (const value_type *entry, const compare_type *data)\n {\n-  const struct ttypes_filter *entry = (const struct ttypes_filter *) pentry;\n-  const struct ttypes_filter *data = (const struct ttypes_filter *) pdata;\n-\n   return type_list_equal (entry->t, data->t);\n }\n \n /* Hash function for exception specification lists.  */\n \n-static hashval_t\n-ehspec_filter_hash (const void *pentry)\n+inline hashval_t\n+ehspec_hasher::hash (const value_type *entry)\n {\n-  const struct ttypes_filter *entry = (const struct ttypes_filter *) pentry;\n   hashval_t h = 0;\n   tree list;\n \n@@ -735,16 +783,19 @@ ehspec_filter_hash (const void *pentry)\n   return h;\n }\n \n+typedef hash_table <ehspec_hasher> ehspec_hash_type;\n+\n+\n /* Add TYPE (which may be NULL) to cfun->eh->ttype_data, using TYPES_HASH\n    to speed up the search.  Return the filter value to be used.  */\n \n static int\n-add_ttypes_entry (htab_t ttypes_hash, tree type)\n+add_ttypes_entry (ttypes_hash_type ttypes_hash, tree type)\n {\n   struct ttypes_filter **slot, *n;\n \n-  slot = (struct ttypes_filter **)\n-    htab_find_slot_with_hash (ttypes_hash, type, TREE_HASH (type), INSERT);\n+  slot = ttypes_hash.find_slot_with_hash (type, (hashval_t) TREE_HASH (type),\n+\t\t\t\t\t  INSERT);\n \n   if ((n = *slot) == NULL)\n     {\n@@ -765,14 +816,14 @@ add_ttypes_entry (htab_t ttypes_hash, tree type)\n    to speed up the search.  Return the filter value to be used.  */\n \n static int\n-add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n+add_ehspec_entry (ehspec_hash_type ehspec_hash, ttypes_hash_type ttypes_hash,\n+\t\t  tree list)\n {\n   struct ttypes_filter **slot, *n;\n   struct ttypes_filter dummy;\n \n   dummy.t = list;\n-  slot = (struct ttypes_filter **)\n-    htab_find_slot (ehspec_hash, &dummy, INSERT);\n+  slot = ehspec_hash.find_slot (&dummy, INSERT);\n \n   if ((n = *slot) == NULL)\n     {\n@@ -821,7 +872,8 @@ void\n assign_filter_values (void)\n {\n   int i;\n-  htab_t ttypes, ehspec;\n+  ttypes_hash_type ttypes;\n+  ehspec_hash_type ehspec;\n   eh_region r;\n   eh_catch c;\n \n@@ -831,8 +883,8 @@ assign_filter_values (void)\n   else\n     vec_alloc (cfun->eh->ehspec_data.other, 64);\n \n-  ttypes = htab_create (31, ttypes_filter_hash, ttypes_filter_eq, free);\n-  ehspec = htab_create (31, ehspec_filter_hash, ehspec_filter_eq, free);\n+  ttypes.create (31);\n+  ehspec.create (31);\n \n   for (i = 1; vec_safe_iterate (cfun->eh->region_array, i, &r); ++i)\n     {\n@@ -886,8 +938,8 @@ assign_filter_values (void)\n \t}\n     }\n \n-  htab_delete (ttypes);\n-  htab_delete (ehspec);\n+  ttypes.dispose ();\n+  ehspec.dispose ();\n }\n \n /* Emit SEQ into basic block just before INSN (that is assumed to be\n@@ -1009,12 +1061,12 @@ static vec<int> sjlj_lp_call_site_index;\n static int\n sjlj_assign_call_site_values (void)\n {\n-  htab_t ar_hash;\n+  action_hash_type ar_hash;\n   int i, disp_index;\n   eh_landing_pad lp;\n \n   vec_alloc (crtl->eh.action_record_data, 64);\n-  ar_hash = htab_create (31, action_record_hash, action_record_eq, free);\n+  ar_hash.create (31);\n \n   disp_index = 0;\n   call_site_base = 1;\n@@ -1043,7 +1095,7 @@ sjlj_assign_call_site_values (void)\n \tdisp_index++;\n       }\n \n-  htab_delete (ar_hash);\n+  ar_hash.dispose ();\n \n   return disp_index;\n }\n@@ -2236,47 +2288,14 @@ expand_builtin_extend_pointer (tree addr_tree)\n   return convert_modes (targetm.unwind_word_mode (), ptr_mode, addr, extend);\n }\n \f\n-/* In the following functions, we represent entries in the action table\n-   as 1-based indices.  Special cases are:\n-\n-\t 0:\tnull action record, non-null landing pad; implies cleanups\n-\t-1:\tnull action record, null landing pad; implies no action\n-\t-2:\tno call-site entry; implies must_not_throw\n-\t-3:\twe have yet to process outer regions\n-\n-   Further, no special cases apply to the \"next\" field of the record.\n-   For next, 0 means end of list.  */\n-\n-struct action_record\n-{\n-  int offset;\n-  int filter;\n-  int next;\n-};\n-\n-static int\n-action_record_eq (const void *pentry, const void *pdata)\n-{\n-  const struct action_record *entry = (const struct action_record *) pentry;\n-  const struct action_record *data = (const struct action_record *) pdata;\n-  return entry->filter == data->filter && entry->next == data->next;\n-}\n-\n-static hashval_t\n-action_record_hash (const void *pentry)\n-{\n-  const struct action_record *entry = (const struct action_record *) pentry;\n-  return entry->next * 1009 + entry->filter;\n-}\n-\n static int\n-add_action_record (htab_t ar_hash, int filter, int next)\n+add_action_record (action_hash_type ar_hash, int filter, int next)\n {\n   struct action_record **slot, *new_ar, tmp;\n \n   tmp.filter = filter;\n   tmp.next = next;\n-  slot = (struct action_record **) htab_find_slot (ar_hash, &tmp, INSERT);\n+  slot = ar_hash.find_slot (&tmp, INSERT);\n \n   if ((new_ar = *slot) == NULL)\n     {\n@@ -2301,7 +2320,7 @@ add_action_record (htab_t ar_hash, int filter, int next)\n }\n \n static int\n-collect_one_action_chain (htab_t ar_hash, eh_region region)\n+collect_one_action_chain (action_hash_type ar_hash, eh_region region)\n {\n   int next;\n \n@@ -2430,7 +2449,7 @@ static unsigned int\n convert_to_eh_region_ranges (void)\n {\n   rtx insn, iter, note;\n-  htab_t ar_hash;\n+  action_hash_type ar_hash;\n   int last_action = -3;\n   rtx last_action_insn = NULL_RTX;\n   rtx last_landing_pad = NULL_RTX;\n@@ -2444,7 +2463,7 @@ convert_to_eh_region_ranges (void)\n \n   vec_alloc (crtl->eh.action_record_data, 64);\n \n-  ar_hash = htab_create (31, action_record_hash, action_record_eq, free);\n+  ar_hash.create (31);\n \n   for (iter = get_insns (); iter ; iter = NEXT_INSN (iter))\n     if (INSN_P (iter))\n@@ -2581,7 +2600,7 @@ convert_to_eh_region_ranges (void)\n \n   call_site_base = saved_call_site_base;\n \n-  htab_delete (ar_hash);\n+  ar_hash.dispose ();\n   return 0;\n }\n "}, {"sha": "07043f76a4d1183b4d04075f9435f6bb3161a7da", "filename": "gcc/gcse.c", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -158,7 +158,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"obstack.h\"\n #include \"tree-pass.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"df.h\"\n #include \"dbgcnt.h\"\n #include \"target.h\"\n@@ -359,8 +359,34 @@ struct ls_expr\n /* Head of the list of load/store memory refs.  */\n static struct ls_expr * pre_ldst_mems = NULL;\n \n+struct pre_ldst_expr_hasher : typed_noop_remove <ls_expr>\n+{\n+  typedef ls_expr value_type;\n+  typedef value_type compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Hashtable helpers.  */\n+inline hashval_t\n+pre_ldst_expr_hasher::hash (const value_type *x)\n+{\n+  int do_not_record_p = 0;\n+  return\n+    hash_rtx (x->pattern, GET_MODE (x->pattern), &do_not_record_p, NULL, false);\n+}\n+\n+static int expr_equiv_p (const_rtx, const_rtx);\n+\n+inline bool\n+pre_ldst_expr_hasher::equal (const value_type *ptr1,\n+\t\t\t     const compare_type *ptr2)\n+{\n+  return expr_equiv_p (ptr1->pattern, ptr2->pattern);\n+}\n+\n /* Hashtable for the load/store memory refs.  */\n-static htab_t pre_ldst_table = NULL;\n+static hash_table <pre_ldst_expr_hasher> pre_ldst_table;\n \n /* Bitmap containing one bit for each register in the program.\n    Used when performing GCSE to track which registers have been set since\n@@ -447,7 +473,6 @@ static int oprs_available_p (const_rtx, const_rtx);\n static void insert_expr_in_table (rtx, enum machine_mode, rtx, int, int, int,\n \t\t\t\t  struct hash_table_d *);\n static unsigned int hash_expr (const_rtx, enum machine_mode, int *, int);\n-static int expr_equiv_p (const_rtx, const_rtx);\n static void record_last_reg_set_info (rtx, int);\n static void record_last_mem_set_info (rtx);\n static void record_last_set_info (rtx, const_rtx, void *);\n@@ -3652,23 +3677,6 @@ one_code_hoisting_pass (void)\n     load towards the exit, and we end up with no loads or stores of 'i'\n     in the loop.  */\n \n-static hashval_t\n-pre_ldst_expr_hash (const void *p)\n-{\n-  int do_not_record_p = 0;\n-  const struct ls_expr *const x = (const struct ls_expr *) p;\n-  return\n-    hash_rtx (x->pattern, GET_MODE (x->pattern), &do_not_record_p, NULL, false);\n-}\n-\n-static int\n-pre_ldst_expr_eq (const void *p1, const void *p2)\n-{\n-  const struct ls_expr *const ptr1 = (const struct ls_expr *) p1,\n-    *const ptr2 = (const struct ls_expr *) p2;\n-  return expr_equiv_p (ptr1->pattern, ptr2->pattern);\n-}\n-\n /* This will search the ldst list for a matching expression. If it\n    doesn't find one, we create one and initialize it.  */\n \n@@ -3678,16 +3686,16 @@ ldst_entry (rtx x)\n   int do_not_record_p = 0;\n   struct ls_expr * ptr;\n   unsigned int hash;\n-  void **slot;\n+  ls_expr **slot;\n   struct ls_expr e;\n \n   hash = hash_rtx (x, GET_MODE (x), &do_not_record_p,\n \t\t   NULL,  /*have_reg_qty=*/false);\n \n   e.pattern = x;\n-  slot = htab_find_slot_with_hash (pre_ldst_table, &e, hash, INSERT);\n+  slot = pre_ldst_table.find_slot_with_hash (&e, hash, INSERT);\n   if (*slot)\n-    return (struct ls_expr *)*slot;\n+    return *slot;\n \n   ptr = XNEW (struct ls_expr);\n \n@@ -3723,9 +3731,8 @@ free_ldst_entry (struct ls_expr * ptr)\n static void\n free_ld_motion_mems (void)\n {\n-  if (pre_ldst_table)\n-    htab_delete (pre_ldst_table);\n-  pre_ldst_table = NULL;\n+  if (pre_ldst_table.is_created ())\n+    pre_ldst_table.dispose ();\n \n   while (pre_ldst_mems)\n     {\n@@ -3780,14 +3787,14 @@ static struct ls_expr *\n find_rtx_in_ldst (rtx x)\n {\n   struct ls_expr e;\n-  void **slot;\n-  if (!pre_ldst_table)\n+  ls_expr **slot;\n+  if (!pre_ldst_table.is_created ())\n     return NULL;\n   e.pattern = x;\n-  slot = htab_find_slot (pre_ldst_table, &e, NO_INSERT);\n-  if (!slot || ((struct ls_expr *)*slot)->invalid)\n+  slot = pre_ldst_table.find_slot (&e, NO_INSERT);\n+  if (!slot || (*slot)->invalid)\n     return NULL;\n-  return (struct ls_expr *) *slot;\n+  return *slot;\n }\n \f\n /* Load Motion for loads which only kill themselves.  */\n@@ -3875,8 +3882,7 @@ compute_ld_motion_mems (void)\n   rtx insn;\n \n   pre_ldst_mems = NULL;\n-  pre_ldst_table\n-    = htab_create (13, pre_ldst_expr_hash, pre_ldst_expr_eq, NULL);\n+  pre_ldst_table.create (13);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -3967,7 +3973,7 @@ trim_ld_motion_mems (void)\n       else\n \t{\n \t  *last = ptr->next;\n-\t  htab_remove_elt_with_hash (pre_ldst_table, ptr, ptr->hash_index);\n+\t  pre_ldst_table.remove_elt_with_hash (ptr, ptr->hash_index);\n \t  free_ldst_entry (ptr);\n \t  ptr = * last;\n \t}"}, {"sha": "0bb2eb19f23bee455026249d4bdf828e99d50813", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 93, "deletions": 82, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"ggc.h\"\n #include \"ggc-internal.h\"\n #include \"diagnostic-core.h\"\n@@ -46,10 +46,6 @@ static ggc_statistics *ggc_stats;\n struct traversal_state;\n \n static int ggc_htab_delete (void **, void *);\n-static hashval_t saving_htab_hash (const void *);\n-static int saving_htab_eq (const void *, const void *);\n-static int call_count (void **, void *);\n-static int call_alloc (void **, void *);\n static int compare_ptr_data (const void *, const void *);\n static void relocate_ptrs (void *, void *);\n static void write_pch_globals (const struct ggc_root_tab * const *tab,\n@@ -289,8 +285,6 @@ ggc_print_common_statistics (FILE *stream ATTRIBUTE_UNUSED,\n \f\n /* Functions for saving and restoring GCable memory to disk.  */\n \n-static htab_t saving_htab;\n-\n struct ptr_data\n {\n   void *obj;\n@@ -303,6 +297,30 @@ struct ptr_data\n \n #define POINTER_HASH(x) (hashval_t)((intptr_t)x >> 3)\n \n+/* Helper for hashing saving_htab.  */\n+\n+struct saving_hasher : typed_free_remove <ptr_data>\n+{\n+  typedef ptr_data value_type;\n+  typedef void compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+saving_hasher::hash (const value_type *p)\n+{\n+  return POINTER_HASH (p->obj);\n+}\n+\n+inline bool\n+saving_hasher::equal (const value_type *p1, const compare_type *p2)\n+{\n+  return p1->obj == p2;\n+}\n+\n+static hash_table <saving_hasher> saving_htab;\n+\n /* Register an object in the hash table.  */\n \n int\n@@ -315,8 +333,7 @@ gt_pch_note_object (void *obj, void *note_ptr_cookie,\n     return 0;\n \n   slot = (struct ptr_data **)\n-    htab_find_slot_with_hash (saving_htab, obj, POINTER_HASH (obj),\n-\t\t\t      INSERT);\n+    saving_htab.find_slot_with_hash (obj, POINTER_HASH (obj), INSERT);\n   if (*slot != NULL)\n     {\n       gcc_assert ((*slot)->note_ptr_fn == note_ptr_fn\n@@ -347,26 +364,12 @@ gt_pch_note_reorder (void *obj, void *note_ptr_cookie,\n     return;\n \n   data = (struct ptr_data *)\n-    htab_find_with_hash (saving_htab, obj, POINTER_HASH (obj));\n+    saving_htab.find_with_hash (obj, POINTER_HASH (obj));\n   gcc_assert (data && data->note_ptr_cookie == note_ptr_cookie);\n \n   data->reorder_fn = reorder_fn;\n }\n \n-/* Hash and equality functions for saving_htab, callbacks for htab_create.  */\n-\n-static hashval_t\n-saving_htab_hash (const void *p)\n-{\n-  return POINTER_HASH (((const struct ptr_data *)p)->obj);\n-}\n-\n-static int\n-saving_htab_eq (const void *p1, const void *p2)\n-{\n-  return ((const struct ptr_data *)p1)->obj == p2;\n-}\n-\n /* Handy state for the traversal functions.  */\n \n struct traversal_state\n@@ -380,23 +383,21 @@ struct traversal_state\n \n /* Callbacks for htab_traverse.  */\n \n-static int\n-call_count (void **slot, void *state_p)\n+int\n+ggc_call_count (ptr_data **slot, traversal_state *state)\n {\n-  struct ptr_data *d = (struct ptr_data *)*slot;\n-  struct traversal_state *state = (struct traversal_state *)state_p;\n+  struct ptr_data *d = *slot;\n \n   ggc_pch_count_object (state->d, d->obj, d->size,\n \t\t\td->note_ptr_fn == gt_pch_p_S);\n   state->count++;\n   return 1;\n }\n \n-static int\n-call_alloc (void **slot, void *state_p)\n+int\n+ggc_call_alloc (ptr_data **slot, traversal_state *state)\n {\n-  struct ptr_data *d = (struct ptr_data *)*slot;\n-  struct traversal_state *state = (struct traversal_state *)state_p;\n+  struct ptr_data *d = *slot;\n \n   d->new_addr = ggc_pch_alloc_object (state->d, d->obj, d->size,\n \t\t\t\t      d->note_ptr_fn == gt_pch_p_S);\n@@ -429,7 +430,7 @@ relocate_ptrs (void *ptr_p, void *state_p)\n     return;\n \n   result = (struct ptr_data *)\n-    htab_find_with_hash (saving_htab, *ptr, POINTER_HASH (*ptr));\n+    saving_htab.find_with_hash (*ptr, POINTER_HASH (*ptr));\n   gcc_assert (result);\n   *ptr = result->new_addr;\n }\n@@ -458,7 +459,7 @@ write_pch_globals (const struct ggc_root_tab * const *tab,\n \t  else\n \t    {\n \t      new_ptr = (struct ptr_data *)\n-\t\thtab_find_with_hash (saving_htab, ptr, POINTER_HASH (ptr));\n+\t\tsaving_htab.find_with_hash (ptr, POINTER_HASH (ptr));\n \t      if (fwrite (&new_ptr->new_addr, sizeof (void *), 1, state->f)\n \t\t  != 1)\n \t\tfatal_error (\"can%'t write PCH file: %m\");\n@@ -492,7 +493,7 @@ gt_pch_save (FILE *f)\n   gt_pch_save_stringpool ();\n \n   timevar_push (TV_PCH_PTR_REALLOC);\n-  saving_htab = htab_create (50000, saving_htab_hash, saving_htab_eq, free);\n+  saving_htab.create (50000);\n \n   for (rt = gt_ggc_rtab; *rt; rt++)\n     for (rti = *rt; rti->base != NULL; rti++)\n@@ -508,7 +509,7 @@ gt_pch_save (FILE *f)\n   state.f = f;\n   state.d = init_ggc_pch ();\n   state.count = 0;\n-  htab_traverse (saving_htab, call_count, &state);\n+  saving_htab.traverse <traversal_state *, ggc_call_count> (&state);\n \n   mmi.size = ggc_pch_total_size (state.d);\n \n@@ -524,7 +525,7 @@ gt_pch_save (FILE *f)\n   state.ptrs = XNEWVEC (struct ptr_data *, state.count);\n   state.ptrs_i = 0;\n \n-  htab_traverse (saving_htab, call_alloc, &state);\n+  saving_htab.traverse <traversal_state *, ggc_call_alloc> (&state);\n   timevar_pop (TV_PCH_PTR_REALLOC);\n \n   timevar_push (TV_PCH_PTR_SORT);\n@@ -653,7 +654,7 @@ gt_pch_save (FILE *f)\n \n   XDELETE (state.ptrs);\n   XDELETE (this_object);\n-  htab_delete (saving_htab);\n+  saving_htab.dispose ();\n }\n \n /* Read the state of the compiler back in from F.  */\n@@ -913,68 +914,78 @@ struct loc_descriptor\n   size_t collected;\n };\n \n-/* Hashtable used for statistics.  */\n-static htab_t loc_hash;\n+/* Hash table helper.  */\n \n-/* Hash table helpers functions.  */\n-static hashval_t\n-hash_descriptor (const void *p)\n+struct loc_desc_hasher : typed_noop_remove <loc_descriptor>\n {\n-  const struct loc_descriptor *const d = (const struct loc_descriptor *) p;\n+  typedef loc_descriptor value_type;\n+  typedef loc_descriptor compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n \n+inline hashval_t\n+loc_desc_hasher::hash (const value_type *d)\n+{\n   return htab_hash_pointer (d->function) | d->line;\n }\n \n-static int\n-eq_descriptor (const void *p1, const void *p2)\n+inline bool\n+loc_desc_hasher::equal (const value_type *d, const compare_type *d2)\n {\n-  const struct loc_descriptor *const d = (const struct loc_descriptor *) p1;\n-  const struct loc_descriptor *const d2 = (const struct loc_descriptor *) p2;\n-\n   return (d->file == d2->file && d->line == d2->line\n \t  && d->function == d2->function);\n }\n \n-/* Hashtable converting address of allocated field to loc descriptor.  */\n-static htab_t ptr_hash;\n+/* Hashtable used for statistics.  */\n+static hash_table <loc_desc_hasher> loc_hash;\n+\n struct ptr_hash_entry\n {\n   void *ptr;\n   struct loc_descriptor *loc;\n   size_t size;\n };\n \n-/* Hash table helpers functions.  */\n-static hashval_t\n-hash_ptr (const void *p)\n+/* Helper for ptr_hash table.  */\n+\n+struct ptr_hash_hasher : typed_noop_remove <ptr_hash_entry>\n {\n-  const struct ptr_hash_entry *const d = (const struct ptr_hash_entry *) p;\n+  typedef ptr_hash_entry value_type;\n+  typedef void compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n \n+inline hashval_t\n+ptr_hash_hasher::hash (const value_type *d)\n+{\n   return htab_hash_pointer (d->ptr);\n }\n \n-static int\n-eq_ptr (const void *p1, const void *p2)\n+inline bool\n+ptr_hash_hasher::equal (const value_type *p, const compare_type *p2)\n {\n-  const struct ptr_hash_entry *const p = (const struct ptr_hash_entry *) p1;\n-\n   return (p->ptr == p2);\n }\n \n+/* Hashtable converting address of allocated field to loc descriptor.  */\n+static hash_table <ptr_hash_hasher> ptr_hash;\n+\n /* Return descriptor for given call site, create new one if needed.  */\n static struct loc_descriptor *\n-loc_descriptor (const char *name, int line, const char *function)\n+make_loc_descriptor (const char *name, int line, const char *function)\n {\n   struct loc_descriptor loc;\n   struct loc_descriptor **slot;\n \n   loc.file = name;\n   loc.line = line;\n   loc.function = function;\n-  if (!loc_hash)\n-    loc_hash = htab_create (10, hash_descriptor, eq_descriptor, NULL);\n+  if (!loc_hash.is_created ())\n+    loc_hash.create (10);\n \n-  slot = (struct loc_descriptor **) htab_find_slot (loc_hash, &loc, INSERT);\n+  slot = loc_hash.find_slot (&loc, INSERT);\n   if (*slot)\n     return *slot;\n   *slot = XCNEW (struct loc_descriptor);\n@@ -989,16 +1000,16 @@ void\n ggc_record_overhead (size_t allocated, size_t overhead, void *ptr,\n \t\t     const char *name, int line, const char *function)\n {\n-  struct loc_descriptor *loc = loc_descriptor (name, line, function);\n+  struct loc_descriptor *loc = make_loc_descriptor (name, line, function);\n   struct ptr_hash_entry *p = XNEW (struct ptr_hash_entry);\n-  PTR *slot;\n+  ptr_hash_entry **slot;\n \n   p->ptr = ptr;\n   p->loc = loc;\n   p->size = allocated + overhead;\n-  if (!ptr_hash)\n-    ptr_hash = htab_create (10, hash_ptr, eq_ptr, NULL);\n-  slot = htab_find_slot_with_hash (ptr_hash, ptr, htab_hash_pointer (ptr), INSERT);\n+  if (!ptr_hash.is_created ())\n+    ptr_hash.create (10);\n+  slot = ptr_hash.find_slot_with_hash (ptr, htab_hash_pointer (ptr), INSERT);\n   gcc_assert (!*slot);\n   *slot = p;\n \n@@ -1009,14 +1020,14 @@ ggc_record_overhead (size_t allocated, size_t overhead, void *ptr,\n \n /* Helper function for prune_overhead_list.  See if SLOT is still marked and\n    remove it from hashtable if it is not.  */\n-static int\n-ggc_prune_ptr (void **slot, void *b ATTRIBUTE_UNUSED)\n+int\n+ggc_prune_ptr (ptr_hash_entry **slot, void *b ATTRIBUTE_UNUSED)\n {\n-  struct ptr_hash_entry *p = (struct ptr_hash_entry *) *slot;\n+  struct ptr_hash_entry *p = *slot;\n   if (!ggc_marked_p (p->ptr))\n     {\n       p->loc->collected += p->size;\n-      htab_clear_slot (ptr_hash, slot);\n+      ptr_hash.clear_slot (slot);\n       free (p);\n     }\n   return 1;\n@@ -1027,15 +1038,15 @@ ggc_prune_ptr (void **slot, void *b ATTRIBUTE_UNUSED)\n void\n ggc_prune_overhead_list (void)\n {\n-  htab_traverse (ptr_hash, ggc_prune_ptr, NULL);\n+  ptr_hash.traverse <void *, ggc_prune_ptr> (NULL);\n }\n \n /* Notice that the pointer has been freed.  */\n void\n ggc_free_overhead (void *ptr)\n {\n-  PTR *slot = htab_find_slot_with_hash (ptr_hash, ptr, htab_hash_pointer (ptr),\n-\t\t\t\t\tNO_INSERT);\n+  ptr_hash_entry **slot;\n+  slot = ptr_hash.find_slot_with_hash (ptr, htab_hash_pointer (ptr), NO_INSERT);\n   struct ptr_hash_entry *p;\n   /* The pointer might be not found if a PCH read happened between allocation\n      and ggc_free () call.  FIXME: account memory properly in the presence of\n@@ -1044,7 +1055,7 @@ ggc_free_overhead (void *ptr)\n       return;\n   p = (struct ptr_hash_entry *) *slot;\n   p->loc->freed += p->size;\n-  htab_clear_slot (ptr_hash, slot);\n+  ptr_hash.clear_slot (slot);\n   free (p);\n }\n \n@@ -1083,11 +1094,10 @@ cmp_statistic (const void *loc1, const void *loc2)\n \n /* Collect array of the descriptors from hashtable.  */\n static struct loc_descriptor **loc_array;\n-static int\n-add_statistics (void **slot, void *b)\n+int\n+ggc_add_statistics (loc_descriptor **slot, int *n)\n {\n-  int *n = (int *)b;\n-  loc_array[*n] = (struct loc_descriptor *) *slot;\n+  loc_array[*n] = *slot;\n   (*n)++;\n   return 1;\n }\n@@ -1108,12 +1118,13 @@ dump_ggc_loc_statistics (bool final)\n   ggc_force_collect = true;\n   ggc_collect ();\n \n-  loc_array = XCNEWVEC (struct loc_descriptor *, loc_hash->n_elements);\n+  loc_array = XCNEWVEC (struct loc_descriptor *,\n+\t\t\tloc_hash.elements_with_deleted ());\n   fprintf (stderr, \"-------------------------------------------------------\\n\");\n   fprintf (stderr, \"\\n%-48s %10s       %10s       %10s       %10s       %10s\\n\",\n \t   \"source location\", \"Garbage\", \"Freed\", \"Leak\", \"Overhead\", \"Times\");\n   fprintf (stderr, \"-------------------------------------------------------\\n\");\n-  htab_traverse (loc_hash, add_statistics, &nentries);\n+  loc_hash.traverse <int *, ggc_add_statistics> (&nentries);\n   qsort (loc_array, nentries, sizeof (*loc_array),\n \t final ? final_cmp_statistic : cmp_statistic);\n   for (i = 0; i < nentries; i++)"}, {"sha": "9f4902d424fcb92716d865bfb6861dd273678afb", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pointer-set.h\"\n #include \"expmed.h\"\n #include \"params.h\"\n+#include \"hash-table.h\"\n \f\n /* Information about a strength reduction candidate.  Each statement\n    in the candidate table represents an expression of one of the\n@@ -287,9 +288,6 @@ static struct pointer_map_t *stmt_cand_map;\n /* Obstack for candidates.  */\n static struct obstack cand_obstack;\n \n-/* Hash table embodying a mapping from base exprs to chains of candidates.  */\n-static htab_t base_cand_map;\n-\n /* Obstack for candidate chains.  */\n static struct obstack chain_obstack;\n \n@@ -311,32 +309,31 @@ lookup_cand (cand_idx idx)\n   return cand_vec[idx - 1];\n }\n \n-/* Callback to produce a hash value for a candidate chain header.  */\n+/* Helper for hashing a candidate chain header.  */\n \n-static hashval_t\n-base_cand_hash (const void *p)\n+struct cand_chain_hasher : typed_noop_remove <cand_chain>\n {\n-  tree base_expr = ((const_cand_chain_t) p)->base_expr;\n-  return iterative_hash_expr (base_expr, 0);\n-}\n-\n-/* Callback when an element is removed from the hash table.\n-   We never remove entries until the entire table is released.  */\n+  typedef cand_chain value_type;\n+  typedef cand_chain compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n \n-static void\n-base_cand_free (void *p ATTRIBUTE_UNUSED)\n+inline hashval_t\n+cand_chain_hasher::hash (const value_type *p)\n {\n+  tree base_expr = p->base_expr;\n+  return iterative_hash_expr (base_expr, 0);\n }\n \n-/* Callback to return true if two candidate chain headers are equal.  */\n-\n-static int\n-base_cand_eq (const void *p1, const void *p2)\n+inline bool\n+cand_chain_hasher::equal (const value_type *chain1, const compare_type *chain2)\n {\n-  const_cand_chain_t const chain1 = (const_cand_chain_t) p1;\n-  const_cand_chain_t const chain2 = (const_cand_chain_t) p2;\n   return operand_equal_p (chain1->base_expr, chain2->base_expr, 0);\n }\n+\n+/* Hash table embodying a mapping from base exprs to chains of candidates.  */\n+static hash_table <cand_chain_hasher> base_cand_map;\n \f\n /* Use the base expr from candidate C to look for possible candidates\n    that can serve as a basis for C.  Each potential basis must also\n@@ -357,7 +354,7 @@ find_basis_for_candidate (slsr_cand_t c)\n   int max_iters = PARAM_VALUE (PARAM_MAX_SLSR_CANDIDATE_SCAN);\n \n   mapping_key.base_expr = c->base_expr;\n-  chain = (cand_chain_t) htab_find (base_cand_map, &mapping_key);\n+  chain = base_cand_map.find (&mapping_key);\n \n   for (; chain && iters < max_iters; chain = chain->next, ++iters)\n     {\n@@ -393,13 +390,13 @@ static void\n record_potential_basis (slsr_cand_t c)\n {\n   cand_chain_t node;\n-  void **slot;\n+  cand_chain **slot;\n \n   node = (cand_chain_t) obstack_alloc (&chain_obstack, sizeof (cand_chain));\n   node->base_expr = c->base_expr;\n   node->cand = c;\n   node->next = NULL;\n-  slot = htab_find_slot (base_cand_map, node, INSERT);\n+  slot = base_cand_map.find_slot (node, INSERT);\n \n   if (*slot)\n     {\n@@ -1435,10 +1432,10 @@ dump_cand_vec (void)\n \n /* Callback used to dump the candidate chains hash table.  */\n \n-static int\n-base_cand_dump_callback (void **slot, void *ignored ATTRIBUTE_UNUSED)\n+int\n+ssa_base_cand_dump_callback (cand_chain **slot, void *ignored ATTRIBUTE_UNUSED)\n {\n-  const_cand_chain_t chain = *((const_cand_chain_t *) slot);\n+  const_cand_chain_t chain = *slot;\n   cand_chain_t p;\n \n   print_generic_expr (dump_file, chain->base_expr, 0);\n@@ -1457,7 +1454,7 @@ static void\n dump_cand_chains (void)\n {\n   fprintf (dump_file, \"\\nStrength reduction candidate chains:\\n\\n\");\n-  htab_traverse_noresize (base_cand_map, base_cand_dump_callback, NULL);\n+  base_cand_map.traverse_noresize <void *, ssa_base_cand_dump_callback> (NULL);\n   fputs (\"\\n\", dump_file);\n }\n \n@@ -2641,8 +2638,7 @@ execute_strength_reduction (void)\n   gcc_obstack_init (&chain_obstack);\n \n   /* Allocate the mapping from base expressions to candidate chains.  */\n-  base_cand_map = htab_create (500, base_cand_hash,\n-\t\t\t       base_cand_eq, base_cand_free);\n+  base_cand_map.create (500);\n \n   /* Initialize the loop optimizer.  We need to detect flow across\n      back edges, and this gives us dominator information as well.  */\n@@ -2673,7 +2669,7 @@ execute_strength_reduction (void)\n   /* Free resources.  */\n   fini_walk_dominator_tree (&walk_data);\n   loop_optimizer_finalize ();\n-  htab_delete (base_cand_map);\n+  base_cand_map.dispose ();\n   obstack_free (&chain_obstack, NULL);\n   pointer_map_destroy (stmt_cand_map);\n   cand_vec.release ();"}, {"sha": "b4de403e65ce67dcc013b2776910aa259ee03def", "filename": "gcc/gimple.h", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_GIMPLE_H\n \n #include \"pointer-set.h\"\n+#include \"hash-table.h\"\n #include \"vec.h\"\n #include \"ggc.h\"\n #include \"basic-block.h\"\n@@ -959,6 +960,55 @@ enum gimplify_status {\n   GS_ALL_DONE\t= 1\t/* The expression is fully gimplified.  */\n };\n \n+/* Formal (expression) temporary table handling: multiple occurrences of\n+   the same scalar expression are evaluated into the same temporary.  */\n+\n+typedef struct gimple_temp_hash_elt\n+{\n+  tree val;   /* Key */\n+  tree temp;  /* Value */\n+} elt_t;\n+\n+/* Gimplify hashtable helper.  */\n+\n+struct gimplify_hasher : typed_free_remove <elt_t>\n+{\n+  typedef elt_t value_type;\n+  typedef elt_t compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+gimplify_hasher::hash (const value_type *p)\n+{\n+  tree t = p->val;\n+  return iterative_hash_expr (t, 0);\n+}\n+\n+inline bool\n+gimplify_hasher::equal (const value_type *p1, const compare_type *p2)\n+{\n+  tree t1 = p1->val;\n+  tree t2 = p2->val;\n+  enum tree_code code = TREE_CODE (t1);\n+\n+  if (TREE_CODE (t2) != code\n+      || TREE_TYPE (t1) != TREE_TYPE (t2))\n+    return false;\n+\n+  if (!operand_equal_p (t1, t2, 0))\n+    return false;\n+\n+#ifdef ENABLE_CHECKING\n+  /* Only allow them to compare equal if they also hash equal; otherwise\n+     results are nondeterminate, and we fail bootstrap comparison.  */\n+  gcc_assert (hash (p1) == hash (p2));\n+#endif\n+\n+  return true;\n+}\n+\n struct gimplify_ctx\n {\n   struct gimplify_ctx *prev_context;\n@@ -971,7 +1021,7 @@ struct gimplify_ctx\n \n   vec<tree> case_labels;\n   /* The formal temporary table.  Should this be persistent?  */\n-  htab_t temp_htab;\n+  hash_table <gimplify_hasher> temp_htab;\n \n   int conditions;\n   bool save_stack;"}, {"sha": "fc7bfcf251c0c221b151a4bbe44f3aa7d7cc8430", "filename": "gcc/gimplify.c", "status": "modified", "additions": 8, "deletions": 52, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -87,15 +87,6 @@ static struct gimplify_ctx *gimplify_ctxp;\n static struct gimplify_omp_ctx *gimplify_omp_ctxp;\n \n \n-/* Formal (expression) temporary table handling: multiple occurrences of\n-   the same scalar expression are evaluated into the same temporary.  */\n-\n-typedef struct gimple_temp_hash_elt\n-{\n-  tree val;   /* Key */\n-  tree temp;  /* Value */\n-} elt_t;\n-\n /* Forward declaration.  */\n static enum gimplify_status gimplify_compound_expr (tree *, gimple_seq *, bool);\n \n@@ -130,40 +121,6 @@ mark_addressable (tree x)\n     }\n }\n \n-/* Return a hash value for a formal temporary table entry.  */\n-\n-static hashval_t\n-gimple_tree_hash (const void *p)\n-{\n-  tree t = ((const elt_t *) p)->val;\n-  return iterative_hash_expr (t, 0);\n-}\n-\n-/* Compare two formal temporary table entries.  */\n-\n-static int\n-gimple_tree_eq (const void *p1, const void *p2)\n-{\n-  tree t1 = ((const elt_t *) p1)->val;\n-  tree t2 = ((const elt_t *) p2)->val;\n-  enum tree_code code = TREE_CODE (t1);\n-\n-  if (TREE_CODE (t2) != code\n-      || TREE_TYPE (t1) != TREE_TYPE (t2))\n-    return 0;\n-\n-  if (!operand_equal_p (t1, t2, 0))\n-    return 0;\n-\n-#ifdef ENABLE_CHECKING\n-  /* Only allow them to compare equal if they also hash equal; otherwise\n-     results are nondeterminate, and we fail bootstrap comparison.  */\n-  gcc_assert (gimple_tree_hash (p1) == gimple_tree_hash (p2));\n-#endif\n-\n-  return 1;\n-}\n-\n /* Link gimple statement GS to the end of the sequence *SEQ_P.  If\n    *SEQ_P is NULL, a new sequence is allocated.  This function is\n    similar to gimple_seq_add_stmt, but does not scan the operands.\n@@ -241,8 +198,8 @@ pop_gimplify_context (gimple body)\n   else\n     record_vars (c->temps);\n \n-  if (c->temp_htab)\n-    htab_delete (c->temp_htab);\n+  if (c->temp_htab.is_created ())\n+    c->temp_htab.dispose ();\n }\n \n /* Push a GIMPLE_BIND tuple onto the stack of bindings.  */\n@@ -585,23 +542,22 @@ lookup_tmp_var (tree val, bool is_formal)\n   else\n     {\n       elt_t elt, *elt_p;\n-      void **slot;\n+      elt_t **slot;\n \n       elt.val = val;\n-      if (gimplify_ctxp->temp_htab == NULL)\n-        gimplify_ctxp->temp_htab\n-\t  = htab_create (1000, gimple_tree_hash, gimple_tree_eq, free);\n-      slot = htab_find_slot (gimplify_ctxp->temp_htab, (void *)&elt, INSERT);\n+      if (!gimplify_ctxp->temp_htab.is_created ())\n+        gimplify_ctxp->temp_htab.create (1000);\n+      slot = gimplify_ctxp->temp_htab.find_slot (&elt, INSERT);\n       if (*slot == NULL)\n \t{\n \t  elt_p = XNEW (elt_t);\n \t  elt_p->val = val;\n \t  elt_p->temp = ret = create_tmp_from_val (val, is_formal);\n-\t  *slot = (void *) elt_p;\n+\t  *slot = elt_p;\n \t}\n       else\n \t{\n-\t  elt_p = (elt_t *) *slot;\n+\t  elt_p = *slot;\n           ret = elt_p->temp;\n \t}\n     }"}, {"sha": "dcf8b94eaa1e524680b9c893b056687bda36e390", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 98, "deletions": 88, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cloog/cloog.h\"\n #include \"graphite-poly.h\"\n #include \"graphite-clast-to-gimple.h\"\n+#include \"graphite-htab.h\"\n \n typedef const struct clast_expr *clast_name_p;\n \n@@ -124,6 +125,55 @@ typedef struct clast_name_index {\n   char *free_name;\n } *clast_name_index_p;\n \n+/* Helper for hashing clast_name_index.  */\n+\n+struct clast_index_hasher\n+{\n+  typedef clast_name_index value_type;\n+  typedef clast_name_index compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n+\n+/* Computes a hash function for database element E.  */\n+\n+inline hashval_t\n+clast_index_hasher::hash (const value_type *e)\n+{\n+  hashval_t hash = 0;\n+\n+  int length = strlen (e->name);\n+  int i;\n+\n+  for (i = 0; i < length; ++i)\n+    hash = hash | (e->name[i] << (i % 4));\n+\n+  return hash;\n+}\n+\n+/* Compares database elements ELT1 and ELT2.  */\n+\n+inline bool\n+clast_index_hasher::equal (const value_type *elt1, const compare_type *elt2)\n+{\n+  return strcmp (elt1->name, elt2->name) == 0;\n+}\n+\n+/* Free the memory taken by a clast_name_index struct.  */\n+\n+inline void\n+clast_index_hasher::remove (value_type *c)\n+{\n+  if (c->free_name)\n+    free (c->free_name);\n+  mpz_clear (c->bound_one);\n+  mpz_clear (c->bound_two);\n+  free (c);\n+}\n+\n+typedef hash_table <clast_index_hasher> clast_index_htab_type;\n+\n /* Returns a pointer to a new element of type clast_name_index_p built\n    from NAME, INDEX, LEVEL, BOUND_ONE, and BOUND_TWO.  */\n \n@@ -146,35 +196,22 @@ new_clast_name_index (const char *name, int index, int level,\n   return res;\n }\n \n-/* Free the memory taken by a clast_name_index struct.  */\n-\n-static void\n-free_clast_name_index (void *ptr)\n-{\n-  struct clast_name_index *c = (struct clast_name_index *) ptr;\n-  if (c->free_name)\n-    free (c->free_name);\n-  mpz_clear (c->bound_one);\n-  mpz_clear (c->bound_two);\n-  free (ptr);\n-}\n-\n /* For a given clast NAME, returns -1 if NAME is not in the\n    INDEX_TABLE, otherwise returns the loop level for the induction\n    variable NAME, or if it is a parameter, the parameter number in the\n    vector of parameters.  */\n \n static inline int\n-clast_name_to_level (clast_name_p name, htab_t index_table)\n+clast_name_to_level (clast_name_p name, clast_index_htab_type index_table)\n {\n   struct clast_name_index tmp;\n-  PTR *slot;\n+  clast_name_index **slot;\n \n   gcc_assert (name->type == clast_expr_name);\n   tmp.name = ((const struct clast_name *) name)->name;\n   tmp.free_name = NULL;\n \n-  slot = htab_find_slot (index_table, &tmp, NO_INSERT);\n+  slot = index_table.find_slot (&tmp, NO_INSERT);\n \n   if (slot && *slot)\n     return ((struct clast_name_index *) *slot)->level;\n@@ -187,18 +224,18 @@ clast_name_to_level (clast_name_p name, htab_t index_table)\n    SCATTERING_DIMENSIONS vector.  */\n \n static inline int\n-clast_name_to_index (struct clast_name *name, htab_t index_table)\n+clast_name_to_index (struct clast_name *name, clast_index_htab_type index_table)\n {\n   struct clast_name_index tmp;\n-  PTR *slot;\n+  clast_name_index **slot;\n \n   tmp.name = ((const struct clast_name *) name)->name;\n   tmp.free_name = NULL;\n \n-  slot = htab_find_slot (index_table, &tmp, NO_INSERT);\n+  slot = index_table.find_slot (&tmp, NO_INSERT);\n \n   if (slot && *slot)\n-    return ((struct clast_name_index *) *slot)->index;\n+    return (*slot)->index;\n \n   return -1;\n }\n@@ -208,16 +245,16 @@ clast_name_to_index (struct clast_name *name, htab_t index_table)\n    found in the INDEX_TABLE, false otherwise.  */\n \n static inline bool\n-clast_name_to_lb_ub (struct clast_name *name, htab_t index_table,\n+clast_name_to_lb_ub (struct clast_name *name, clast_index_htab_type index_table,\n \t\t     mpz_t bound_one, mpz_t bound_two)\n {\n   struct clast_name_index tmp;\n-  PTR *slot;\n+  clast_name_index **slot;\n \n   tmp.name = name->name;\n   tmp.free_name = NULL;\n \n-  slot = htab_find_slot (index_table, &tmp, NO_INSERT);\n+  slot = index_table.find_slot (&tmp, NO_INSERT);\n \n   if (slot && *slot)\n     {\n@@ -232,15 +269,15 @@ clast_name_to_lb_ub (struct clast_name *name, htab_t index_table,\n /* Records in INDEX_TABLE the INDEX and LEVEL for NAME.  */\n \n static inline void\n-save_clast_name_index (htab_t index_table, const char *name,\n+save_clast_name_index (clast_index_htab_type index_table, const char *name,\n \t\t       int index, int level, mpz_t bound_one, mpz_t bound_two)\n {\n   struct clast_name_index tmp;\n-  PTR *slot;\n+  clast_name_index **slot;\n \n   tmp.name = name;\n   tmp.free_name = NULL;\n-  slot = htab_find_slot (index_table, &tmp, INSERT);\n+  slot = index_table.find_slot (&tmp, INSERT);\n \n   if (slot)\n     {\n@@ -249,35 +286,6 @@ save_clast_name_index (htab_t index_table, const char *name,\n       *slot = new_clast_name_index (name, index, level, bound_one, bound_two);\n     }\n }\n-\n-/* Computes a hash function for database element ELT.  */\n-\n-static inline hashval_t\n-clast_name_index_elt_info (const void *elt)\n-{\n-  const struct clast_name_index *e = ((const struct clast_name_index *) elt);\n-  hashval_t hash = 0;\n-\n-  int length = strlen (e->name);\n-  int i;\n-\n-  for (i = 0; i < length; ++i)\n-    hash = hash | (e->name[i] << (i % 4));\n-\n-  return hash;\n-}\n-\n-/* Compares database elements E1 and E2.  */\n-\n-static inline int\n-eq_clast_name_indexes (const void *e1, const void *e2)\n-{\n-  const struct clast_name_index *elt1 = (const struct clast_name_index *) e1;\n-  const struct clast_name_index *elt2 = (const struct clast_name_index *) e2;\n-\n-  return strcmp (elt1->name, elt2->name) == 0;\n-}\n-\n \f\n \n /* NEWIVS_INDEX binds CLooG's scattering name to the index of the tree\n@@ -288,7 +296,7 @@ eq_clast_name_indexes (const void *e1, const void *e2)\n \n typedef struct ivs_params {\n   vec<tree> params, *newivs;\n-  htab_t newivs_index, params_index;\n+  clast_index_htab_type newivs_index, params_index;\n   sese region;\n } *ivs_params_p;\n \n@@ -300,15 +308,15 @@ clast_name_to_gcc (struct clast_name *name, ivs_params_p ip)\n {\n   int index;\n \n-  if (ip->params.exists () && ip->params_index)\n+  if (ip->params.exists () && ip->params_index.is_created ())\n     {\n       index = clast_name_to_index (name, ip->params_index);\n \n       if (index >= 0)\n \treturn ip->params[index];\n     }\n \n-  gcc_assert (ip->newivs && ip->newivs_index);\n+  gcc_assert (ip->newivs && ip->newivs_index.is_created ());\n   index = clast_name_to_index (name, ip->newivs_index);\n   gcc_assert (index >= 0);\n \n@@ -699,12 +707,12 @@ type_for_clast_name (struct clast_name *name, ivs_params_p ip, mpz_t bound_one,\n {\n   bool found = false;\n \n-  if (ip->params.exists () && ip->params_index)\n+  if (ip->params.exists () && ip->params_index.is_created ())\n     found = clast_name_to_lb_ub (name, ip->params_index, bound_one, bound_two);\n \n   if (!found)\n     {\n-      gcc_assert (ip->newivs && ip->newivs_index);\n+      gcc_assert (ip->newivs && ip->newivs_index.is_created ());\n       found = clast_name_to_lb_ub (name, ip->newivs_index, bound_one,\n \t\t\t\t   bound_two);\n       gcc_assert (found);\n@@ -1009,13 +1017,14 @@ new_bb_pbb_def (basic_block bb, poly_bb_p pbb)\n /* Mark BB with it's relevant PBB via hashing table BB_PBB_MAPPING.  */\n \n static void\n-mark_bb_with_pbb (poly_bb_p pbb, basic_block bb, htab_t bb_pbb_mapping)\n+mark_bb_with_pbb (poly_bb_p pbb, basic_block bb,\n+\t\t  bb_pbb_htab_type bb_pbb_mapping)\n {\n   bb_pbb_def tmp;\n-  PTR *x;\n+  bb_pbb_def **x;\n \n   tmp.bb = bb;\n-  x = htab_find_slot (bb_pbb_mapping, &tmp, INSERT);\n+  x = bb_pbb_mapping.find_slot (&tmp, INSERT);\n \n   if (x && !*x)\n     *x = new_bb_pbb_def (bb, pbb);\n@@ -1024,13 +1033,13 @@ mark_bb_with_pbb (poly_bb_p pbb, basic_block bb, htab_t bb_pbb_mapping)\n /* Find BB's related poly_bb_p in hash table BB_PBB_MAPPING.  */\n \n poly_bb_p\n-find_pbb_via_hash (htab_t bb_pbb_mapping, basic_block bb)\n+find_pbb_via_hash (bb_pbb_htab_type bb_pbb_mapping, basic_block bb)\n {\n   bb_pbb_def tmp;\n-  PTR *slot;\n+  bb_pbb_def **slot;\n \n   tmp.bb = bb;\n-  slot = htab_find_slot (bb_pbb_mapping, &tmp, NO_INSERT);\n+  slot = bb_pbb_mapping.find_slot (&tmp, NO_INSERT);\n \n   if (slot && *slot)\n     return ((bb_pbb_def *) *slot)->pbb;\n@@ -1044,7 +1053,7 @@ find_pbb_via_hash (htab_t bb_pbb_mapping, basic_block bb)\n    related poly_bb_p.  */\n \n scop_p\n-get_loop_body_pbbs (loop_p loop, htab_t bb_pbb_mapping,\n+get_loop_body_pbbs (loop_p loop, bb_pbb_htab_type bb_pbb_mapping,\n \t\t    vec<poly_bb_p> *pbbs)\n {\n   unsigned i;\n@@ -1074,7 +1083,7 @@ get_loop_body_pbbs (loop_p loop, htab_t bb_pbb_mapping,\n \n static edge\n translate_clast_user (struct clast_user_stmt *stmt, edge next_e,\n-\t\t      htab_t bb_pbb_mapping, ivs_params_p ip)\n+\t\t      bb_pbb_htab_type bb_pbb_mapping, ivs_params_p ip)\n {\n   int i, nb_loops;\n   basic_block new_bb;\n@@ -1143,7 +1152,8 @@ graphite_create_new_loop_guard (edge entry_edge, struct clast_for *stmt,\n }\n \n static edge\n-translate_clast (loop_p, struct clast_stmt *, edge, htab_t, int, ivs_params_p);\n+translate_clast (loop_p, struct clast_stmt *, edge, bb_pbb_htab_type,\n+\t\t int, ivs_params_p);\n \n /* Create the loop for a clast for statement.\n \n@@ -1152,8 +1162,9 @@ translate_clast (loop_p, struct clast_stmt *, edge, htab_t, int, ivs_params_p);\n \n static edge\n translate_clast_for_loop (loop_p context_loop, struct clast_for *stmt,\n-\t\t\t  edge next_e, htab_t bb_pbb_mapping, int level,\n-\t\t\t  tree type, tree lb, tree ub, ivs_params_p ip)\n+\t\t\t  edge next_e, bb_pbb_htab_type bb_pbb_mapping,\n+\t\t\t  int level, tree type, tree lb, tree ub,\n+\t\t\t  ivs_params_p ip)\n {\n   struct loop *loop = graphite_create_new_loop (next_e, stmt, context_loop,\n \t\t\t\t\t\ttype, lb, ub, level, ip);\n@@ -1186,7 +1197,8 @@ translate_clast_for_loop (loop_p context_loop, struct clast_for *stmt,\n \n static edge\n translate_clast_for (loop_p context_loop, struct clast_for *stmt, edge next_e,\n-\t\t     htab_t bb_pbb_mapping, int level, ivs_params_p ip)\n+\t\t     bb_pbb_htab_type bb_pbb_mapping, int level,\n+\t\t     ivs_params_p ip)\n {\n   tree type, lb, ub;\n   edge last_e = graphite_create_new_loop_guard (next_e, stmt, &type,\n@@ -1244,7 +1256,7 @@ translate_clast_assignment (struct clast_assignment *stmt, edge next_e,\n \n static edge\n translate_clast_guard (loop_p context_loop, struct clast_guard *stmt,\n-\t\t       edge next_e, htab_t bb_pbb_mapping, int level,\n+\t\t       edge next_e, bb_pbb_htab_type bb_pbb_mapping, int level,\n \t\t       ivs_params_p ip)\n {\n   edge last_e = graphite_create_new_guard (next_e, stmt, ip);\n@@ -1263,7 +1275,7 @@ translate_clast_guard (loop_p context_loop, struct clast_guard *stmt,\n \n static edge\n translate_clast (loop_p context_loop, struct clast_stmt *stmt, edge next_e,\n-\t\t htab_t bb_pbb_mapping, int level, ivs_params_p ip)\n+\t\t bb_pbb_htab_type bb_pbb_mapping, int level, ivs_params_p ip)\n {\n   if (!stmt)\n     return next_e;\n@@ -1304,7 +1316,8 @@ translate_clast (loop_p context_loop, struct clast_stmt *stmt, edge next_e,\n \n static CloogUnionDomain *\n add_names_to_union_domain (scop_p scop, CloogUnionDomain *union_domain,\n-\t\t\t   int nb_scattering_dims, htab_t params_index)\n+\t\t\t   int nb_scattering_dims,\n+\t\t\t   clast_index_htab_type params_index)\n {\n   sese region = SCOP_REGION (scop);\n   int i;\n@@ -1547,7 +1560,7 @@ int get_max_scattering_dimensions (scop_p scop)\n }\n \n static CloogInput *\n-generate_cloog_input (scop_p scop, htab_t params_index)\n+generate_cloog_input (scop_p scop, clast_index_htab_type params_index)\n {\n   CloogUnionDomain *union_domain;\n   CloogInput *cloog_input;\n@@ -1570,7 +1583,7 @@ generate_cloog_input (scop_p scop, htab_t params_index)\n    without a program.  */\n \n static struct clast_stmt *\n-scop_to_clast (scop_p scop, htab_t params_index)\n+scop_to_clast (scop_p scop, clast_index_htab_type params_index)\n {\n   CloogInput *cloog_input;\n   struct clast_stmt *clast;\n@@ -1599,11 +1612,10 @@ void\n print_generated_program (FILE *file, scop_p scop)\n {\n   CloogOptions *options = set_cloog_options ();\n-  htab_t params_index;\n+  clast_index_htab_type params_index;\n   struct clast_stmt *clast;\n \n-  params_index = htab_create (10, clast_name_index_elt_info,\n-            eq_clast_name_indexes, free_clast_name_index);\n+  params_index.create (10);\n \n   clast = scop_to_clast (scop, params_index);\n \n@@ -1629,22 +1641,21 @@ debug_generated_program (scop_p scop)\n */\n \n bool\n-gloog (scop_p scop, htab_t bb_pbb_mapping)\n+gloog (scop_p scop, bb_pbb_htab_type bb_pbb_mapping)\n {\n   vec<tree> newivs;\n   newivs.create (10);\n   loop_p context_loop;\n   sese region = SCOP_REGION (scop);\n   ifsese if_region = NULL;\n-  htab_t newivs_index, params_index;\n+  clast_index_htab_type newivs_index, params_index;\n   struct clast_stmt *clast;\n   struct ivs_params ip;\n \n   timevar_push (TV_GRAPHITE_CODE_GEN);\n   gloog_error = false;\n \n-  params_index = htab_create (10, clast_name_index_elt_info,\n-\t\t\t      eq_clast_name_indexes, free_clast_name_index);\n+  params_index.create (10);\n \n   clast = scop_to_clast (scop, params_index);\n \n@@ -1667,8 +1678,7 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n   graphite_verify ();\n \n   context_loop = SESE_ENTRY (region)->src->loop_father;\n-  newivs_index = htab_create (10, clast_name_index_elt_info,\n-\t\t\t      eq_clast_name_indexes, free_clast_name_index);\n+  newivs_index.create (10);\n \n   ip.newivs = &newivs;\n   ip.newivs_index = newivs_index;\n@@ -1690,8 +1700,8 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n   free (if_region->region);\n   free (if_region);\n \n-  htab_delete (newivs_index);\n-  htab_delete (params_index);\n+  newivs_index.dispose ();\n+  params_index.dispose ();\n   newivs.release ();\n   cloog_clast_free (clast);\n   timevar_pop (TV_GRAPHITE_CODE_GEN);"}, {"sha": "78e60e2dafa45cb890cef00cc9ec365e2939a035", "filename": "gcc/graphite-clast-to-gimple.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite-clast-to-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite-clast-to-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.h?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -38,26 +38,7 @@ typedef struct bb_pbb_def\n   poly_bb_p pbb;\n } bb_pbb_def;\n \n-extern bool gloog (scop_p, htab_t);\n extern void debug_clast_stmt (struct clast_stmt *);\n extern void print_clast_stmt (FILE *, struct clast_stmt *);\n \n-/* Hash function for data base element BB_PBB.  */\n-\n-static inline hashval_t\n-bb_pbb_map_hash (const void *bb_pbb)\n-{\n-  return (hashval_t)(((const bb_pbb_def *)bb_pbb)->bb->index);\n-}\n-\n-/* Compare data base element BB_PBB1 and BB_PBB2.  */\n-\n-static inline int\n-eq_bb_pbb_map (const void *bb_pbb1, const void *bb_pbb2)\n-{\n-  const bb_pbb_def *bp1 = (const bb_pbb_def *) bb_pbb1;\n-  const bb_pbb_def *bp2 = (const bb_pbb_def *) bb_pbb2;\n-  return (bp1->bb->index == bp2->bb->index);\n-}\n-\n #endif"}, {"sha": "366588b359537c3f67158777587182b25c544695", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifdef HAVE_cloog\n #include \"graphite-poly.h\"\n+#include \"graphite-htab.h\"\n \n /* Add the constraints from the set S to the domain of MAP.  */\n \n@@ -579,7 +580,7 @@ loop_level_carries_dependences (scop_p scop, vec<poly_bb_p> body,\n    poly_bb_p.  */\n \n bool\n-loop_is_parallel_p (loop_p loop, htab_t bb_pbb_mapping, int depth)\n+loop_is_parallel_p (loop_p loop, bb_pbb_htab_type bb_pbb_mapping, int depth)\n {\n   bool dependences;\n   scop_p scop;"}, {"sha": "022b7698791796a46afaa961b9850006f061512a", "filename": "gcc/graphite-htab.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite-htab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite-htab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-htab.h?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -0,0 +1,60 @@\n+/* Translation of CLAST (CLooG AST) to Gimple.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <sebastian.pop@amd.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GRAPHITE_HTAB_H\n+#define GCC_GRAPHITE_HTAB_H\n+\n+#include \"hash-table.h\"\n+#include \"graphite-clast-to-gimple.h\"\n+\n+/* Hashtable helpers.  */\n+\n+struct bb_pbb_hasher : typed_free_remove <bb_pbb_def>\n+{\n+  typedef bb_pbb_def value_type;\n+  typedef bb_pbb_def compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Hash function for data base element BB_PBB.  */\n+\n+inline hashval_t\n+bb_pbb_hasher::hash (const value_type *bb_pbb)\n+{\n+  return (hashval_t)(bb_pbb->bb->index);\n+}\n+\n+/* Compare data base element PB1 and PB2.  */\n+\n+inline bool\n+bb_pbb_hasher::equal (const value_type *bp1, const compare_type *bp2)\n+{\n+  return (bp1->bb->index == bp2->bb->index);\n+}\n+\n+typedef hash_table <bb_pbb_hasher> bb_pbb_htab_type;\n+\n+extern bool gloog (scop_p, bb_pbb_htab_type);\n+poly_bb_p find_pbb_via_hash (bb_pbb_htab_type, basic_block);\n+bool loop_is_parallel_p (loop_p, bb_pbb_htab_type, int);\n+scop_p get_loop_body_pbbs (loop_p, bb_pbb_htab_type, vec<poly_bb_p> *);\n+\n+#endif"}, {"sha": "52d6b1cdc538d90b7a31012b4700ceda1f3394c3", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -1531,9 +1531,6 @@ restore_scattering (scop_p scop)\n }\n \n bool graphite_legal_transform (scop_p);\n-poly_bb_p find_pbb_via_hash (htab_t, basic_block);\n-bool loop_is_parallel_p (loop_p, htab_t, int);\n-scop_p get_loop_body_pbbs (loop_p, htab_t, vec<poly_bb_p> *);\n isl_map *reverse_loop_at_level (poly_bb_p, int);\n isl_union_map *reverse_loop_for_pbbs (scop_p, vec<poly_bb_p> , int);\n __isl_give isl_union_map *extend_schedule (__isl_take isl_union_map *);"}, {"sha": "10d1dd510c97c96a110c46b6600ea776dd4f827d", "filename": "gcc/graphite.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graphite-scop-detection.h\"\n #include \"graphite-clast-to-gimple.h\"\n #include \"graphite-sese-to-poly.h\"\n+#include \"graphite-htab.h\"\n \n CloogState *cloog_state;\n \n@@ -255,7 +256,7 @@ graphite_transform_loops (void)\n   scop_p scop;\n   bool need_cfg_cleanup_p = false;\n   vec<scop_p> scops = vNULL;\n-  htab_t bb_pbb_mapping;\n+  bb_pbb_htab_type bb_pbb_mapping;\n   isl_ctx *ctx;\n \n   /* If a function is parallel it was most probably already run through graphite\n@@ -277,7 +278,7 @@ graphite_transform_loops (void)\n       print_global_statistics (dump_file);\n     }\n \n-  bb_pbb_mapping = htab_create (10, bb_pbb_map_hash, eq_bb_pbb_map, free);\n+  bb_pbb_mapping.create (10);\n \n   FOR_EACH_VEC_ELT (scops, i, scop)\n     if (dbg_cnt (graphite_scop))\n@@ -291,7 +292,7 @@ graphite_transform_loops (void)\n \t  need_cfg_cleanup_p = true;\n       }\n \n-  htab_delete (bb_pbb_mapping);\n+  bb_pbb_mapping.dispose ();\n   free_scops (scops);\n   graphite_finalize (need_cfg_cleanup_p);\n   the_isl_ctx = NULL;"}, {"sha": "15ddedbe113c2c0763f8d3a4236c16b96505ff46", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 85, "deletions": 77, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -145,7 +145,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"ira.h\"\n #include \"emit-rtl.h\"  /* FIXME: Can go away once crtl is moved to rtl.h.  */\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"dumpfile.h\"\n \n #ifdef INSN_SCHEDULING\n@@ -581,39 +581,88 @@ struct delay_pair\n   int stages;\n };\n \n+/* Helpers for delay hashing.  */\n+\n+struct delay_i1_hasher : typed_noop_remove <delay_pair>\n+{\n+  typedef delay_pair value_type;\n+  typedef void compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Returns a hash value for X, based on hashing just I1.  */\n+\n+inline hashval_t\n+delay_i1_hasher::hash (const value_type *x)\n+{\n+  return htab_hash_pointer (x->i1);\n+}\n+\n+/* Return true if I1 of pair X is the same as that of pair Y.  */\n+\n+inline bool\n+delay_i1_hasher::equal (const value_type *x, const compare_type *y)\n+{\n+  return x->i1 == y;\n+}\n+\n+struct delay_i2_hasher : typed_free_remove <delay_pair>\n+{\n+  typedef delay_pair value_type;\n+  typedef void compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Returns a hash value for X, based on hashing just I2.  */\n+\n+inline hashval_t\n+delay_i2_hasher::hash (const value_type *x)\n+{\n+  return htab_hash_pointer (x->i2);\n+}\n+\n+/* Return true if I2 of pair X is the same as that of pair Y.  */\n+\n+inline bool\n+delay_i2_hasher::equal (const value_type *x, const compare_type *y)\n+{\n+  return x->i2 == y;\n+}\n+\n /* Two hash tables to record delay_pairs, one indexed by I1 and the other\n    indexed by I2.  */\n-static htab_t delay_htab;\n-static htab_t delay_htab_i2;\n+static hash_table <delay_i1_hasher> delay_htab;\n+static hash_table <delay_i2_hasher> delay_htab_i2;\n \n /* Called through htab_traverse.  Walk the hashtable using I2 as\n    index, and delete all elements involving an UID higher than\n    that pointed to by *DATA.  */\n-static int\n-htab_i2_traverse (void **slot, void *data)\n+int\n+haifa_htab_i2_traverse (delay_pair **slot, int *data)\n {\n-  int maxuid = *(int *)data;\n-  struct delay_pair *p = *(struct delay_pair **)slot;\n+  int maxuid = *data;\n+  struct delay_pair *p = *slot;\n   if (INSN_UID (p->i2) >= maxuid || INSN_UID (p->i1) >= maxuid)\n     {\n-      htab_clear_slot (delay_htab_i2, slot);\n+      delay_htab_i2.clear_slot (slot);\n     }\n   return 1;\n }\n \n /* Called through htab_traverse.  Walk the hashtable using I2 as\n    index, and delete all elements involving an UID higher than\n    that pointed to by *DATA.  */\n-static int\n-htab_i1_traverse (void **slot, void *data)\n+int\n+haifa_htab_i1_traverse (delay_pair **pslot, int *data)\n {\n-  int maxuid = *(int *)data;\n-  struct delay_pair **pslot = (struct delay_pair **)slot;\n+  int maxuid = *data;\n   struct delay_pair *p, *first, **pprev;\n \n   if (INSN_UID ((*pslot)->i1) >= maxuid)\n     {\n-      htab_clear_slot (delay_htab, slot);\n+      delay_htab.clear_slot (pslot);\n       return 1;\n     }\n   pprev = &first;\n@@ -627,7 +676,7 @@ htab_i1_traverse (void **slot, void *data)\n     }\n   *pprev = NULL;\n   if (first == NULL)\n-    htab_clear_slot (delay_htab, slot);\n+    delay_htab.clear_slot (pslot);\n   else\n     *pslot = first;\n   return 1;\n@@ -638,38 +687,8 @@ htab_i1_traverse (void **slot, void *data)\n void\n discard_delay_pairs_above (int max_uid)\n {\n-  htab_traverse (delay_htab, htab_i1_traverse, &max_uid);\n-  htab_traverse (delay_htab_i2, htab_i2_traverse, &max_uid);\n-}\n-\n-/* Returns a hash value for X (which really is a delay_pair), based on\n-   hashing just I1.  */\n-static hashval_t\n-delay_hash_i1 (const void *x)\n-{\n-  return htab_hash_pointer (((const struct delay_pair *) x)->i1);\n-}\n-\n-/* Returns a hash value for X (which really is a delay_pair), based on\n-   hashing just I2.  */\n-static hashval_t\n-delay_hash_i2 (const void *x)\n-{\n-  return htab_hash_pointer (((const struct delay_pair *) x)->i2);\n-}\n-\n-/* Return nonzero if I1 of pair X is the same as that of pair Y.  */\n-static int\n-delay_i1_eq (const void *x, const void *y)\n-{\n-  return ((const struct delay_pair *) x)->i1 == y;\n-}\n-\n-/* Return nonzero if I2 of pair X is the same as that of pair Y.  */\n-static int\n-delay_i2_eq (const void *x, const void *y)\n-{\n-  return ((const struct delay_pair *) x)->i2 == y;\n+  delay_htab.traverse <int *, haifa_htab_i1_traverse> (&max_uid);\n+  delay_htab_i2.traverse <int *, haifa_htab_i2_traverse> (&max_uid);\n }\n \n /* This function can be called by a port just before it starts the final\n@@ -699,19 +718,15 @@ record_delay_slot_pair (rtx i1, rtx i2, int cycles, int stages)\n   p->cycles = cycles;\n   p->stages = stages;\n \n-  if (!delay_htab)\n+  if (!delay_htab.is_created ())\n     {\n-      delay_htab = htab_create (10, delay_hash_i1, delay_i1_eq, NULL);\n-      delay_htab_i2 = htab_create (10, delay_hash_i2, delay_i2_eq, free);\n+      delay_htab.create (10);\n+      delay_htab_i2.create (10);\n     }\n-  slot = ((struct delay_pair **)\n-\t  htab_find_slot_with_hash (delay_htab, i1, htab_hash_pointer (i1),\n-\t\t\t\t    INSERT));\n+  slot = delay_htab.find_slot_with_hash (i1, htab_hash_pointer (i1), INSERT);\n   p->next_same_i1 = *slot;\n   *slot = p;\n-  slot = ((struct delay_pair **)\n-\t  htab_find_slot_with_hash (delay_htab_i2, i2, htab_hash_pointer (i2),\n-\t\t\t\t    INSERT));\n+  slot = delay_htab_i2.find_slot_with_hash (i2, htab_hash_pointer (i2), INSERT);\n   *slot = p;\n }\n \n@@ -722,12 +737,10 @@ real_insn_for_shadow (rtx insn)\n {\n   struct delay_pair *pair;\n \n-  if (delay_htab == NULL)\n+  if (!delay_htab.is_created ())\n     return NULL_RTX;\n \n-  pair\n-    = (struct delay_pair *)htab_find_with_hash (delay_htab_i2, insn,\n-\t\t\t\t\t\thtab_hash_pointer (insn));\n+  pair = delay_htab_i2.find_with_hash (insn, htab_hash_pointer (insn));\n   if (!pair || pair->stages > 0)\n     return NULL_RTX;\n   return pair->i1;\n@@ -755,12 +768,10 @@ add_delay_dependencies (rtx insn)\n   sd_iterator_def sd_it;\n   dep_t dep;\n \n-  if (!delay_htab)\n+  if (!delay_htab.is_created ())\n     return;\n \n-  pair\n-    = (struct delay_pair *)htab_find_with_hash (delay_htab_i2, insn,\n-\t\t\t\t\t\thtab_hash_pointer (insn));\n+  pair = delay_htab_i2.find_with_hash (insn, htab_hash_pointer (insn));\n   if (!pair)\n     return;\n   add_dependence (insn, pair->i1, REG_DEP_ANTI);\n@@ -771,8 +782,7 @@ add_delay_dependencies (rtx insn)\n     {\n       rtx pro = DEP_PRO (dep);\n       struct delay_pair *other_pair\n-\t= (struct delay_pair *)htab_find_with_hash (delay_htab_i2, pro,\n-\t\t\t\t\t\t    htab_hash_pointer (pro));\n+\t= delay_htab_i2.find_with_hash (pro, htab_hash_pointer (pro));\n       if (!other_pair || other_pair->stages)\n \tcontinue;\n       if (pair_delay (other_pair) >= pair_delay (pair))\n@@ -1395,12 +1405,11 @@ dep_cost_1 (dep_t link, dw_t dw)\n   if (DEP_COST (link) != UNKNOWN_DEP_COST)\n     return DEP_COST (link);\n \n-  if (delay_htab)\n+  if (delay_htab.is_created ())\n     {\n       struct delay_pair *delay_entry;\n       delay_entry\n-\t= (struct delay_pair *)htab_find_with_hash (delay_htab_i2, used,\n-\t\t\t\t\t\t    htab_hash_pointer (used));\n+\t= delay_htab_i2.find_with_hash (used, htab_hash_pointer (used));\n       if (delay_entry)\n \t{\n \t  if (delay_entry->i1 == insn)\n@@ -5726,12 +5735,12 @@ prune_ready_list (state_t temp_state, bool first_cycle_insn_p,\n \t    {\n \t      int delay_cost = 0;\n \n-\t      if (delay_htab)\n+\t      if (delay_htab.is_created ())\n \t\t{\n \t\t  struct delay_pair *delay_entry;\n \t\t  delay_entry\n-\t\t    = (struct delay_pair *)htab_find_with_hash (delay_htab, insn,\n-\t\t\t\t\t\t\t\thtab_hash_pointer (insn));\n+\t\t    = delay_htab.find_with_hash (insn,\n+\t\t\t\t\t\t htab_hash_pointer (insn));\n \t\t  while (delay_entry && delay_cost == 0)\n \t\t    {\n \t\t      delay_cost = estimate_shadow_tick (delay_entry);\n@@ -6189,14 +6198,13 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t      goto restart_choose_ready;\n \t    }\n \n-\t  if (delay_htab)\n+\t  if (delay_htab.is_created ())\n \t    {\n \t      /* If this insn is the first part of a delay-slot pair, record a\n \t\t backtrack point.  */\n \t      struct delay_pair *delay_entry;\n \t      delay_entry\n-\t\t= (struct delay_pair *)htab_find_with_hash (delay_htab, insn,\n-\t\t\t\t\t\t\t    htab_hash_pointer (insn));\n+\t\t= delay_htab.find_with_hash (insn, htab_hash_pointer (insn));\n \t      if (delay_entry)\n \t\t{\n \t\t  save_backtrack_point (delay_entry, ls);\n@@ -6761,10 +6769,10 @@ sched_finish (void)\n void\n free_delay_pairs (void)\n {\n-  if (delay_htab)\n+  if (delay_htab.is_created ())\n     {\n-      htab_empty (delay_htab);\n-      htab_empty (delay_htab_i2);\n+      delay_htab.empty ();\n+      delay_htab_i2.empty ();\n     }\n }\n "}, {"sha": "0ee31573e2e66f71577586d51c0405e8a6907e46", "filename": "gcc/ira-color.c", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n+#include \"hash-table.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"expr.h\"\n@@ -173,54 +174,56 @@ static vec<ira_allocno_t> allocno_stack_vec;\n /* Vector of unique allocno hard registers.  */\n static vec<allocno_hard_regs_t> allocno_hard_regs_vec;\n \n-/* Returns hash value for allocno hard registers V.  */\n-static hashval_t\n-allocno_hard_regs_hash (const void *v)\n+struct allocno_hard_regs_hasher : typed_noop_remove <allocno_hard_regs>\n {\n-  const struct allocno_hard_regs *hv = (const struct allocno_hard_regs *) v;\n+  typedef allocno_hard_regs value_type;\n+  typedef allocno_hard_regs compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n \n+/* Returns hash value for allocno hard registers V.  */\n+inline hashval_t\n+allocno_hard_regs_hasher::hash (const value_type *hv)\n+{\n   return iterative_hash (&hv->set, sizeof (HARD_REG_SET), 0);\n }\n \n /* Compares allocno hard registers V1 and V2.  */\n-static int\n-allocno_hard_regs_eq (const void *v1, const void *v2)\n+inline bool\n+allocno_hard_regs_hasher::equal (const value_type *hv1, const compare_type *hv2)\n {\n-  const struct allocno_hard_regs *hv1 = (const struct allocno_hard_regs *) v1;\n-  const struct allocno_hard_regs *hv2 = (const struct allocno_hard_regs *) v2;\n-\n   return hard_reg_set_equal_p (hv1->set, hv2->set);\n }\n \n /* Hash table of unique allocno hard registers.  */\n-static htab_t allocno_hard_regs_htab;\n+static hash_table <allocno_hard_regs_hasher> allocno_hard_regs_htab;\n \n /* Return allocno hard registers in the hash table equal to HV.  */\n static allocno_hard_regs_t\n find_hard_regs (allocno_hard_regs_t hv)\n {\n-  return (allocno_hard_regs_t) htab_find (allocno_hard_regs_htab, hv);\n+  return allocno_hard_regs_htab.find (hv);\n }\n \n /* Insert allocno hard registers HV in the hash table (if it is not\n    there yet) and return the value which in the table.  */\n static allocno_hard_regs_t\n insert_hard_regs (allocno_hard_regs_t hv)\n {\n-  PTR *slot = htab_find_slot (allocno_hard_regs_htab, hv, INSERT);\n+  allocno_hard_regs **slot = allocno_hard_regs_htab.find_slot (hv, INSERT);\n \n   if (*slot == NULL)\n     *slot = hv;\n-  return (allocno_hard_regs_t) *slot;\n+  return *slot;\n }\n \n /* Initialize data concerning allocno hard registers.  */\n static void\n init_allocno_hard_regs (void)\n {\n   allocno_hard_regs_vec.create (200);\n-  allocno_hard_regs_htab\n-    = htab_create (200, allocno_hard_regs_hash, allocno_hard_regs_eq, NULL);\n+  allocno_hard_regs_htab.create (200);\n }\n \n /* Add (or update info about) allocno hard registers with SET and\n@@ -258,7 +261,7 @@ finish_allocno_hard_regs (void)\n        allocno_hard_regs_vec.iterate (i, &hv);\n        i++)\n     ira_free (hv);\n-  htab_delete (allocno_hard_regs_htab);\n+  allocno_hard_regs_htab.dispose ();\n   allocno_hard_regs_vec.release ();\n }\n "}, {"sha": "5f998f7aefb9c49b9308132bc17d7b5ab0198ead", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"hash-table.h\"\n #include \"hard-reg-set.h\"\n #include \"rtl.h\"\n #include \"expr.h\"\n@@ -131,35 +132,41 @@ typedef const struct cost_classes *const_cost_classes_t;\n /* Info about cost classes for each pseudo.  */\n static cost_classes_t *regno_cost_classes;\n \n-/* Returns hash value for cost classes info V.  */\n-static hashval_t\n-cost_classes_hash (const void *v)\n+/* Helper for cost_classes hashing.  */\n+\n+struct cost_classes_hasher\n {\n-  const_cost_classes_t hv = (const_cost_classes_t) v;\n+  typedef cost_classes value_type;\n+  typedef cost_classes compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n \n+/* Returns hash value for cost classes info HV.  */\n+inline hashval_t\n+cost_classes_hasher::hash (const value_type *hv)\n+{\n   return iterative_hash (&hv->classes, sizeof (enum reg_class) * hv->num, 0);\n }\n \n-/* Compares cost classes info V1 and V2.  */\n-static int\n-cost_classes_eq (const void *v1, const void *v2)\n+/* Compares cost classes info HV1 and HV2.  */\n+inline bool\n+cost_classes_hasher::equal (const value_type *hv1, const compare_type *hv2)\n {\n-  const_cost_classes_t hv1 = (const_cost_classes_t) v1;\n-  const_cost_classes_t hv2 = (const_cost_classes_t) v2;\n-\n   return hv1->num == hv2->num && memcmp (hv1->classes, hv2->classes,\n \t\t\t\t\t sizeof (enum reg_class) * hv1->num);\n }\n \n /* Delete cost classes info V from the hash table.  */\n-static void\n-cost_classes_del (void *v)\n+inline void\n+cost_classes_hasher::remove (value_type *v)\n {\n   ira_free (v);\n }\n \n /* Hash table of unique cost classes.  */\n-static htab_t cost_classes_htab;\n+static hash_table <cost_classes_hasher> cost_classes_htab;\n \n /* Map allocno class -> cost classes for pseudo of given allocno\n    class.  */\n@@ -180,8 +187,7 @@ initiate_regno_cost_classes (void)\n \t  sizeof (cost_classes_t) * N_REG_CLASSES);\n   memset (cost_classes_mode_cache, 0,\n \t  sizeof (cost_classes_t) * MAX_MACHINE_MODE);\n-  cost_classes_htab\n-    = htab_create (200, cost_classes_hash, cost_classes_eq, cost_classes_del);\n+  cost_classes_htab.create (200);\n }\n \n /* Create new cost classes from cost classes FROM and set up members\n@@ -229,7 +235,7 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n   cost_classes_t classes_ptr;\n   enum reg_class cl;\n   int i;\n-  PTR *slot;\n+  cost_classes **slot;\n   HARD_REG_SET temp, temp2;\n   bool exclude_p;\n \n@@ -255,7 +261,7 @@ setup_regno_cost_classes_by_aclass (int regno, enum reg_class aclass)\n \t    }\n \t  classes.classes[classes.num++] = cl;\n \t}\n-      slot = htab_find_slot (cost_classes_htab, &classes, INSERT);\n+      slot = cost_classes_htab.find_slot (&classes, INSERT);\n       if (*slot == NULL)\n \t{\n \t  classes_ptr = setup_cost_classes (&classes);\n@@ -279,7 +285,7 @@ setup_regno_cost_classes_by_mode (int regno, enum machine_mode mode)\n   cost_classes_t classes_ptr;\n   enum reg_class cl;\n   int i;\n-  PTR *slot;\n+  cost_classes **slot;\n   HARD_REG_SET temp;\n \n   if ((classes_ptr = cost_classes_mode_cache[mode]) == NULL)\n@@ -294,7 +300,7 @@ setup_regno_cost_classes_by_mode (int regno, enum machine_mode mode)\n \t    continue;\n \t  classes.classes[classes.num++] = cl;\n \t}\n-      slot = htab_find_slot (cost_classes_htab, &classes, INSERT);\n+      slot = cost_classes_htab.find_slot (&classes, INSERT);\n       if (*slot == NULL)\n \t{\n \t  classes_ptr = setup_cost_classes (&classes);\n@@ -312,7 +318,7 @@ static void\n finish_regno_cost_classes (void)\n {\n   ira_free (regno_cost_classes);\n-  htab_delete (cost_classes_htab);\n+  cost_classes_htab.dispose ();\n }\n \n \f"}, {"sha": "73200e199b25998a6b727482af5fbb0724c97738", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -50,7 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"flags.h\"\n #include \"df.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"except.h\"\n #include \"params.h\"\n #include \"regs.h\"\n@@ -424,52 +424,55 @@ invariant_expr_equal_p (rtx insn1, rtx e1, rtx insn2, rtx e2)\n   return true;\n }\n \n-/* Returns hash value for invariant expression entry E.  */\n-\n-static hashval_t\n-hash_invariant_expr (const void *e)\n+struct invariant_expr_hasher : typed_free_remove <invariant_expr_entry>\n {\n-  const struct invariant_expr_entry *const entry =\n-    (const struct invariant_expr_entry *) e;\n+  typedef invariant_expr_entry value_type;\n+  typedef invariant_expr_entry compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Returns hash value for invariant expression entry ENTRY.  */\n \n+inline hashval_t\n+invariant_expr_hasher::hash (const value_type *entry)\n+{\n   return entry->hash;\n }\n \n-/* Compares invariant expression entries E1 and E2.  */\n+/* Compares invariant expression entries ENTRY1 and ENTRY2.  */\n \n-static int\n-eq_invariant_expr (const void *e1, const void *e2)\n+inline bool\n+invariant_expr_hasher::equal (const value_type *entry1,\n+\t\t\t      const compare_type *entry2)\n {\n-  const struct invariant_expr_entry *const entry1 =\n-    (const struct invariant_expr_entry *) e1;\n-  const struct invariant_expr_entry *const entry2 =\n-    (const struct invariant_expr_entry *) e2;\n-\n   if (entry1->mode != entry2->mode)\n     return 0;\n \n   return invariant_expr_equal_p (entry1->inv->insn, entry1->expr,\n \t\t\t\t entry2->inv->insn, entry2->expr);\n }\n \n+typedef hash_table <invariant_expr_hasher> invariant_htab_type;\n+\n /* Checks whether invariant with value EXPR in machine mode MODE is\n    recorded in EQ.  If this is the case, return the invariant.  Otherwise\n    insert INV to the table for this expression and return INV.  */\n \n static struct invariant *\n-find_or_insert_inv (htab_t eq, rtx expr, enum machine_mode mode,\n+find_or_insert_inv (invariant_htab_type eq, rtx expr, enum machine_mode mode,\n \t\t    struct invariant *inv)\n {\n   hashval_t hash = hash_invariant_expr_1 (inv->insn, expr);\n   struct invariant_expr_entry *entry;\n   struct invariant_expr_entry pentry;\n-  PTR *slot;\n+  invariant_expr_entry **slot;\n \n   pentry.expr = expr;\n   pentry.inv = inv;\n   pentry.mode = mode;\n-  slot = htab_find_slot_with_hash (eq, &pentry, hash, INSERT);\n-  entry = (struct invariant_expr_entry *) *slot;\n+  slot = eq.find_slot_with_hash (&pentry, hash, INSERT);\n+  entry = *slot;\n \n   if (entry)\n     return entry->inv;\n@@ -488,7 +491,7 @@ find_or_insert_inv (htab_t eq, rtx expr, enum machine_mode mode,\n    hash table of the invariants.  */\n \n static void\n-find_identical_invariants (htab_t eq, struct invariant *inv)\n+find_identical_invariants (invariant_htab_type eq, struct invariant *inv)\n {\n   unsigned depno;\n   bitmap_iterator bi;\n@@ -525,13 +528,13 @@ merge_identical_invariants (void)\n {\n   unsigned i;\n   struct invariant *inv;\n-  htab_t eq = htab_create (invariants.length (),\n-\t\t\t   hash_invariant_expr, eq_invariant_expr, free);\n+  invariant_htab_type eq;\n+  eq.create (invariants.length ());\n \n   FOR_EACH_VEC_ELT (invariants, i, inv)\n     find_identical_invariants (eq, inv);\n \n-  htab_delete (eq);\n+  eq.dispose ();\n }\n \n /* Determines the basic blocks inside LOOP that are always executed and"}, {"sha": "3248b56c0a5d36a30e6f6143b82d056dec834e12", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -60,7 +60,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"diagnostic-core.h\"\n #include \"df.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"dumpfile.h\"\n \n /* Possible return values of iv_get_reaching_def.  */\n@@ -106,9 +106,35 @@ static struct rtx_iv ** iv_ref_table;\n \n static struct loop *current_loop;\n \n+/* Hashtable helper.  */\n+\n+struct biv_entry_hasher : typed_free_remove <biv_entry>\n+{\n+  typedef biv_entry value_type;\n+  typedef rtx_def compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Returns hash value for biv B.  */\n+\n+inline hashval_t\n+biv_entry_hasher::hash (const value_type *b)\n+{\n+  return b->regno;\n+}\n+\n+/* Compares biv B and register R.  */\n+\n+inline bool\n+biv_entry_hasher::equal (const value_type *b, const compare_type *r)\n+{\n+  return b->regno == REGNO (r);\n+}\n+\n /* Bivs of the current loop.  */\n \n-static htab_t bivs;\n+static hash_table <biv_entry_hasher> bivs;\n \n static bool iv_analyze_op (rtx, rtx, struct rtx_iv *);\n \n@@ -243,24 +269,9 @@ clear_iv_info (void)\n \t}\n     }\n \n-  htab_empty (bivs);\n-}\n-\n-/* Returns hash value for biv B.  */\n-\n-static hashval_t\n-biv_hash (const void *b)\n-{\n-  return ((const struct biv_entry *) b)->regno;\n+  bivs.empty ();\n }\n \n-/* Compares biv B and register R.  */\n-\n-static int\n-biv_eq (const void *b, const void *r)\n-{\n-  return ((const struct biv_entry *) b)->regno == REGNO ((const_rtx) r);\n-}\n \n /* Prepare the data for an induction variable analysis of a LOOP.  */\n \n@@ -277,7 +288,7 @@ iv_analysis_loop_init (struct loop *loop)\n   if (clean_slate)\n     {\n       df_set_flags (DF_EQ_NOTES + DF_DEFER_INSN_RESCAN);\n-      bivs = htab_create (10, biv_hash, biv_eq, free);\n+      bivs.create (10);\n       clean_slate = false;\n     }\n   else\n@@ -837,8 +848,7 @@ record_iv (df_ref def, struct rtx_iv *iv)\n static bool\n analyzed_for_bivness_p (rtx def, struct rtx_iv *iv)\n {\n-  struct biv_entry *biv =\n-    (struct biv_entry *) htab_find_with_hash (bivs, def, REGNO (def));\n+  struct biv_entry *biv = bivs.find_with_hash (def, REGNO (def));\n \n   if (!biv)\n     return false;\n@@ -851,7 +861,7 @@ static void\n record_biv (rtx def, struct rtx_iv *iv)\n {\n   struct biv_entry *biv = XNEW (struct biv_entry);\n-  void **slot = htab_find_slot_with_hash (bivs, def, REGNO (def), INSERT);\n+  biv_entry **slot = bivs.find_slot_with_hash (def, REGNO (def), INSERT);\n \n   biv->regno = REGNO (def);\n   biv->iv = *iv;\n@@ -1293,11 +1303,10 @@ iv_analysis_done (void)\n       clear_iv_info ();\n       clean_slate = true;\n       df_finish_pass (true);\n-      htab_delete (bivs);\n+      bivs.dispose ();\n       free (iv_ref_table);\n       iv_ref_table = NULL;\n       iv_ref_table_size = 0;\n-      bivs = NULL;\n     }\n }\n "}, {"sha": "41d9e5f0fadbe2407d4f9d1936fa31d6930c54ce", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 78, "deletions": 67, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -28,7 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"params.h\"\n #include \"expr.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"recog.h\"\n #include \"target.h\"\n #include \"dumpfile.h\"\n@@ -102,16 +102,70 @@ struct var_to_expand\n                                       var_expansions[REUSE_EXPANSION - 1].  */\n };\n \n+/* Hashtable helper for iv_to_split.  */\n+\n+struct iv_split_hasher : typed_free_remove <iv_to_split>\n+{\n+  typedef iv_to_split value_type;\n+  typedef iv_to_split compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+\n+/* A hash function for information about insns to split.  */\n+\n+inline hashval_t\n+iv_split_hasher::hash (const value_type *ivts)\n+{\n+  return (hashval_t) INSN_UID (ivts->insn);\n+}\n+\n+/* An equality functions for information about insns to split.  */\n+\n+inline bool\n+iv_split_hasher::equal (const value_type *i1, const compare_type *i2)\n+{\n+  return i1->insn == i2->insn;\n+}\n+\n+/* Hashtable helper for iv_to_split.  */\n+\n+struct var_expand_hasher : typed_free_remove <var_to_expand>\n+{\n+  typedef var_to_expand value_type;\n+  typedef var_to_expand compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Return a hash for VES.  */\n+\n+inline hashval_t\n+var_expand_hasher::hash (const value_type *ves)\n+{\n+  return (hashval_t) INSN_UID (ves->insn);\n+}\n+\n+/* Return true if I1 and I2 refer to the same instruction.  */\n+\n+inline bool\n+var_expand_hasher::equal (const value_type *i1, const compare_type *i2)\n+{\n+  return i1->insn == i2->insn;\n+}\n+\n /* Information about optimization applied in\n    the unrolled loop.  */\n \n struct opt_info\n {\n-  htab_t insns_to_split;           /* A hashtable of insns to split.  */\n+  hash_table <iv_split_hasher> insns_to_split; /* A hashtable of insns to\n+\t\t\t\t\t\t  split.  */\n   struct iv_to_split *iv_to_split_head; /* The first iv to split.  */\n   struct iv_to_split **iv_to_split_tail; /* Pointer to the tail of the list.  */\n-  htab_t insns_with_var_to_expand; /* A hashtable of insns with accumulators\n-                                      to expand.  */\n+  hash_table <var_expand_hasher> insns_with_var_to_expand; /* A hashtable of\n+\t\t\t\t\tinsns with accumulators to expand.  */\n   struct var_to_expand *var_to_expand_head; /* The first var to expand.  */\n   struct var_to_expand **var_to_expand_tail; /* Pointer to the tail of the list.  */\n   unsigned first_new_block;        /* The first basic block that was\n@@ -1585,45 +1639,6 @@ unroll_loop_stupid (struct loop *loop)\n \t     nunroll, num_loop_insns (loop));\n }\n \n-/* A hash function for information about insns to split.  */\n-\n-static hashval_t\n-si_info_hash (const void *ivts)\n-{\n-  return (hashval_t) INSN_UID (((const struct iv_to_split *) ivts)->insn);\n-}\n-\n-/* An equality functions for information about insns to split.  */\n-\n-static int\n-si_info_eq (const void *ivts1, const void *ivts2)\n-{\n-  const struct iv_to_split *const i1 = (const struct iv_to_split *) ivts1;\n-  const struct iv_to_split *const i2 = (const struct iv_to_split *) ivts2;\n-\n-  return i1->insn == i2->insn;\n-}\n-\n-/* Return a hash for VES, which is really a \"var_to_expand *\".  */\n-\n-static hashval_t\n-ve_info_hash (const void *ves)\n-{\n-  return (hashval_t) INSN_UID (((const struct var_to_expand *) ves)->insn);\n-}\n-\n-/* Return true if IVTS1 and IVTS2 (which are really both of type\n-   \"var_to_expand *\") refer to the same instruction.  */\n-\n-static int\n-ve_info_eq (const void *ivts1, const void *ivts2)\n-{\n-  const struct var_to_expand *const i1 = (const struct var_to_expand *) ivts1;\n-  const struct var_to_expand *const i2 = (const struct var_to_expand *) ivts2;\n-\n-  return i1->insn == i2->insn;\n-}\n-\n /* Returns true if REG is referenced in one nondebug insn in LOOP.\n    Set *DEBUG_USES to the number of debug insns that reference the\n    variable.  */\n@@ -1908,8 +1923,8 @@ analyze_insns_in_loop (struct loop *loop)\n   rtx insn;\n   struct iv_to_split *ivts = NULL;\n   struct var_to_expand *ves = NULL;\n-  PTR *slot1;\n-  PTR *slot2;\n+  iv_to_split **slot1;\n+  var_to_expand **slot2;\n   vec<edge> edges = get_loop_exit_edges (loop);\n   edge exit;\n   bool can_apply = false;\n@@ -1920,8 +1935,7 @@ analyze_insns_in_loop (struct loop *loop)\n \n   if (flag_split_ivs_in_unroller)\n     {\n-      opt_info->insns_to_split = htab_create (5 * loop->num_nodes,\n-\t\t\t\t\t      si_info_hash, si_info_eq, free);\n+      opt_info->insns_to_split.create (5 * loop->num_nodes);\n       opt_info->iv_to_split_head = NULL;\n       opt_info->iv_to_split_tail = &opt_info->iv_to_split_head;\n     }\n@@ -1942,9 +1956,7 @@ analyze_insns_in_loop (struct loop *loop)\n   if (flag_variable_expansion_in_unroller\n       && can_apply)\n     {\n-      opt_info->insns_with_var_to_expand = htab_create (5 * loop->num_nodes,\n-\t\t\t\t\t\t\tve_info_hash,\n-\t\t\t\t\t\t\tve_info_eq, free);\n+      opt_info->insns_with_var_to_expand.create (5 * loop->num_nodes);\n       opt_info->var_to_expand_head = NULL;\n       opt_info->var_to_expand_tail = &opt_info->var_to_expand_head;\n     }\n@@ -1960,25 +1972,25 @@ analyze_insns_in_loop (struct loop *loop)\n         if (!INSN_P (insn))\n           continue;\n \n-        if (opt_info->insns_to_split)\n+        if (opt_info->insns_to_split.is_created ())\n           ivts = analyze_iv_to_split_insn (insn);\n \n         if (ivts)\n           {\n-            slot1 = htab_find_slot (opt_info->insns_to_split, ivts, INSERT);\n+            slot1 = opt_info->insns_to_split.find_slot (ivts, INSERT);\n \t    gcc_assert (*slot1 == NULL);\n             *slot1 = ivts;\n \t    *opt_info->iv_to_split_tail = ivts;\n \t    opt_info->iv_to_split_tail = &ivts->next;\n             continue;\n           }\n \n-        if (opt_info->insns_with_var_to_expand)\n+        if (opt_info->insns_with_var_to_expand.is_created ())\n           ves = analyze_insn_to_expand_var (loop, insn);\n \n         if (ves)\n           {\n-            slot2 = htab_find_slot (opt_info->insns_with_var_to_expand, ves, INSERT);\n+            slot2 = opt_info->insns_with_var_to_expand.find_slot (ves, INSERT);\n \t    gcc_assert (*slot2 == NULL);\n             *slot2 = ves;\n \t    *opt_info->var_to_expand_tail = ves;\n@@ -2356,7 +2368,7 @@ apply_opt_in_copies (struct opt_info *opt_info,\n   gcc_assert (!unrolling || rewrite_original_loop);\n \n   /* Allocate the basic variables (i0).  */\n-  if (opt_info->insns_to_split)\n+  if (opt_info->insns_to_split.is_created ())\n     for (ivts = opt_info->iv_to_split_head; ivts; ivts = ivts->next)\n       allocate_basic_variable (ivts);\n \n@@ -2388,12 +2400,11 @@ apply_opt_in_copies (struct opt_info *opt_info,\n           ve_templ.insn = orig_insn;\n \n           /* Apply splitting iv optimization.  */\n-          if (opt_info->insns_to_split)\n+          if (opt_info->insns_to_split.is_created ())\n             {\n \t      maybe_strip_eq_note_for_split_iv (opt_info, insn);\n \n-              ivts = (struct iv_to_split *)\n-\t\thtab_find (opt_info->insns_to_split, &ivts_templ);\n+              ivts = opt_info->insns_to_split.find (&ivts_templ);\n \n               if (ivts)\n                 {\n@@ -2406,10 +2417,10 @@ apply_opt_in_copies (struct opt_info *opt_info,\n                 }\n             }\n           /* Apply variable expansion optimization.  */\n-          if (unrolling && opt_info->insns_with_var_to_expand)\n+          if (unrolling && opt_info->insns_with_var_to_expand.is_created ())\n             {\n               ves = (struct var_to_expand *)\n-\t\thtab_find (opt_info->insns_with_var_to_expand, &ve_templ);\n+\t\topt_info->insns_with_var_to_expand.find (&ve_templ);\n               if (ves)\n                 {\n \t\t  gcc_assert (GET_CODE (PATTERN (insn))\n@@ -2426,7 +2437,7 @@ apply_opt_in_copies (struct opt_info *opt_info,\n \n   /* Initialize the variable expansions in the loop preheader\n      and take care of combining them at the loop exit.  */\n-  if (opt_info->insns_with_var_to_expand)\n+  if (opt_info->insns_with_var_to_expand.is_created ())\n     {\n       for (ves = opt_info->var_to_expand_head; ves; ves = ves->next)\n \tinsert_var_expansion_initialization (ves, opt_info->loop_preheader);\n@@ -2455,12 +2466,12 @@ apply_opt_in_copies (struct opt_info *opt_info,\n  \t    continue;\n \n           ivts_templ.insn = orig_insn;\n-          if (opt_info->insns_to_split)\n+          if (opt_info->insns_to_split.is_created ())\n             {\n \t      maybe_strip_eq_note_for_split_iv (opt_info, orig_insn);\n \n               ivts = (struct iv_to_split *)\n-\t\thtab_find (opt_info->insns_to_split, &ivts_templ);\n+\t\topt_info->insns_to_split.find (&ivts_templ);\n               if (ivts)\n                 {\n                   if (!delta)\n@@ -2479,15 +2490,15 @@ apply_opt_in_copies (struct opt_info *opt_info,\n static void\n free_opt_info (struct opt_info *opt_info)\n {\n-  if (opt_info->insns_to_split)\n-    htab_delete (opt_info->insns_to_split);\n-  if (opt_info->insns_with_var_to_expand)\n+  if (opt_info->insns_to_split.is_created ())\n+    opt_info->insns_to_split.dispose ();\n+  if (opt_info->insns_with_var_to_expand.is_created ())\n     {\n       struct var_to_expand *ves;\n \n       for (ves = opt_info->var_to_expand_head; ves; ves = ves->next)\n \tves->var_expansions.release ();\n-      htab_delete (opt_info->insns_with_var_to_expand);\n+      opt_info->insns_with_var_to_expand.dispose ();\n     }\n   free (opt_info);\n }"}, {"sha": "c4daa30c5816ba4a54f43deecb32409995ff5219", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -49,8 +49,19 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"streamer-hooks.h\"\n \n+struct freeing_string_slot_hasher : string_slot_hasher\n+{\n+  static inline void remove (value_type *);\n+};\n+\n+inline void\n+freeing_string_slot_hasher::remove (value_type *v)\n+{\n+  free (v);\n+}\n+\n /* The table to hold the file names.  */\n-static htab_t file_name_hash_table;\n+static hash_table <freeing_string_slot_hasher> file_name_hash_table;\n \n \n /* Check that tag ACTUAL has one of the given values.  NUM_TAGS is the\n@@ -94,14 +105,14 @@ lto_input_data_block (struct lto_input_block *ib, void *addr, size_t length)\n static const char *\n canon_file_name (const char *string)\n {\n-  void **slot;\n+  string_slot **slot;\n   struct string_slot s_slot;\n   size_t len = strlen (string);\n \n   s_slot.s = string;\n   s_slot.len = len;\n \n-  slot = htab_find_slot (file_name_hash_table, &s_slot, INSERT);\n+  slot = file_name_hash_table.find_slot (&s_slot, INSERT);\n   if (*slot == NULL)\n     {\n       char *saved_string;\n@@ -117,7 +128,7 @@ canon_file_name (const char *string)\n     }\n   else\n     {\n-      struct string_slot *old_slot = (struct string_slot *) *slot;\n+      struct string_slot *old_slot = *slot;\n       return old_slot->s;\n     }\n }\n@@ -1137,8 +1148,7 @@ void\n lto_reader_init (void)\n {\n   lto_streamer_init ();\n-  file_name_hash_table = htab_create (37, hash_string_slot_node,\n-\t\t\t\t      eq_string_slot_node, free);\n+  file_name_hash_table.create (37);\n }\n \n "}, {"sha": "ad620c66d3b53759f7bdcc1323474faa60f7dde7", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -77,8 +77,7 @@ create_output_block (enum lto_section_type section_type)\n \n   clear_line_info (ob);\n \n-  ob->string_hash_table = htab_create (37, hash_string_slot_node,\n-\t\t\t\t       eq_string_slot_node, NULL);\n+  ob->string_hash_table.create (37);\n   gcc_obstack_init (&ob->obstack);\n \n   return ob;\n@@ -92,7 +91,7 @@ destroy_output_block (struct output_block *ob)\n {\n   enum lto_section_type section_type = ob->section_type;\n \n-  htab_delete (ob->string_hash_table);\n+  ob->string_hash_table.dispose ();\n \n   free (ob->main_stream);\n   free (ob->string_stream);"}, {"sha": "89320381b6e4dce160532cd51a80213d8cca2d91", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -253,28 +253,33 @@ print_lto_report (const char *s)\n \n \n #ifdef LTO_STREAMER_DEBUG\n-static htab_t tree_htab;\n-\n struct tree_hash_entry\n {\n   tree key;\n   intptr_t value;\n };\n \n-static hashval_t\n-hash_tree (const void *p)\n+struct tree_entry_hasher : typed_noop_remove <tree_hash_entry>\n+{\n+  typedef tree_hash_entry value_type;\n+  typedef tree_hash_entry compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+tree_entry_hasher::hash (const value_type *e)\n {\n-  const struct tree_hash_entry *e = (const struct tree_hash_entry *) p;\n   return htab_hash_pointer (e->key);\n }\n \n-static int\n-eq_tree (const void *p1, const void *p2)\n+inline bool\n+tree_entry_hasher::equal (const value_type *e1, const compare_type *e2)\n {\n-  const struct tree_hash_entry *e1 = (const struct tree_hash_entry *) p1;\n-  const struct tree_hash_entry *e2 = (const struct tree_hash_entry *) p2;\n   return (e1->key == e2->key);\n }\n+\n+static hash_table <tree_hash_entry> tree_htab;\n #endif\n \n /* Initialization common to the LTO reader and writer.  */\n@@ -289,7 +294,7 @@ lto_streamer_init (void)\n   streamer_check_handled_ts_structures ();\n \n #ifdef LTO_STREAMER_DEBUG\n-  tree_htab = htab_create (31, hash_tree, eq_tree, NULL);\n+  tree_htab.create (31);\n #endif\n }\n \n@@ -324,8 +329,7 @@ lto_orig_address_map (tree t, intptr_t orig_t)\n \n   ent.key = t;\n   ent.value = orig_t;\n-  slot\n-    = (struct tree_hash_entry **) htab_find_slot (tree_htab, &ent, INSERT);\n+  slot = tree_htab.find_slot (&ent, INSERT);\n   gcc_assert (!*slot);\n   *slot = XNEW (struct tree_hash_entry);\n   **slot = ent;\n@@ -342,8 +346,7 @@ lto_orig_address_get (tree t)\n   struct tree_hash_entry **slot;\n \n   ent.key = t;\n-  slot\n-    = (struct tree_hash_entry **) htab_find_slot (tree_htab, &ent, NO_INSERT);\n+  slot = tree_htab.find_slot (&ent, NO_INSERT);\n   return (slot ? (*slot)->value : 0);\n }\n \n@@ -357,11 +360,10 @@ lto_orig_address_remove (tree t)\n   struct tree_hash_entry **slot;\n \n   ent.key = t;\n-  slot\n-    = (struct tree_hash_entry **) htab_find_slot (tree_htab, &ent, NO_INSERT);\n+  slot = tree_htab.find_slot (&ent, NO_INSERT);\n   gcc_assert (slot);\n   free (*slot);\n-  htab_clear_slot (tree_htab, (PTR *)slot);\n+  tree_htab.clear_slot (slot);\n }\n #endif\n "}, {"sha": "e0db8b10a70f87f3a7eb7882f79d7bf502e47845", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_LTO_STREAMER_H\n \n #include \"plugin-api.h\"\n+#include \"hash-table.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"target.h\"\n@@ -627,6 +628,50 @@ struct lto_simple_output_block\n   struct lto_output_stream *main_stream;\n };\n \n+/* String hashing.  */\n+\n+struct string_slot\n+{\n+  const char *s;\n+  int len;\n+  unsigned int slot_num;\n+};\n+\n+/* Hashtable helpers.  */\n+\n+struct string_slot_hasher : typed_noop_remove <string_slot>\n+{\n+  typedef string_slot value_type;\n+  typedef string_slot compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Returns a hash code for DS.  Adapted from libiberty's htab_hash_string\n+   to support strings that may not end in '\\0'.  */\n+\n+inline hashval_t\n+string_slot_hasher::hash (const value_type *ds)\n+{\n+  hashval_t r = ds->len;\n+  int i;\n+\n+  for (i = 0; i < ds->len; i++)\n+     r = r * 67 + (unsigned)ds->s[i] - 113;\n+  return r;\n+}\n+\n+/* Returns nonzero if DS1 and DS2 are equal.  */\n+\n+inline bool\n+string_slot_hasher::equal (const value_type *ds1, const compare_type *ds2)\n+{\n+  if (ds1->len == ds2->len)\n+    return memcmp (ds1->s, ds2->s, ds1->len) == 0;\n+\n+  return 0;\n+}\n+\n /* Data structure holding all the data and descriptors used when writing\n    an LTO file.  */\n struct output_block\n@@ -645,7 +690,7 @@ struct output_block\n \n   /* The hash table that contains the set of strings we have seen so\n      far and the indexes assigned to them.  */\n-  htab_t string_hash_table;\n+  hash_table <string_slot_hasher> string_hash_table;\n \n   /* The current cgraph_node that we are currently serializing.  Null\n      if we are serializing something else.  */"}, {"sha": "45e79ccc1667c0d84b3480db6a49e82d1dfc4c99", "filename": "gcc/passes.c", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"line-map.h\"\n+#include \"hash-table.h\"\n #include \"input.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n@@ -579,27 +580,33 @@ struct pass_registry\n   struct opt_pass *pass;\n };\n \n+/* Helper for pass_registry hash table.  */\n+\n+struct pass_registry_hasher : typed_noop_remove <pass_registry>\n+{\n+  typedef pass_registry value_type;\n+  typedef pass_registry compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n /* Pass registry hash function.  */\n \n-static hashval_t\n-passr_hash (const void *p)\n+inline hashval_t\n+pass_registry_hasher::hash (const value_type *s)\n {\n-  const struct pass_registry *const s = (const struct pass_registry *const) p;\n   return htab_hash_string (s->unique_name);\n }\n \n /* Hash equal function  */\n \n-static int\n-passr_eq (const void *p1, const void *p2)\n+inline bool\n+pass_registry_hasher::equal (const value_type *s1, const compare_type *s2)\n {\n-  const struct pass_registry *const s1 = (const struct pass_registry *const) p1;\n-  const struct pass_registry *const s2 = (const struct pass_registry *const) p2;\n-\n   return !strcmp (s1->unique_name, s2->unique_name);\n }\n \n-static htab_t name_to_pass_map = NULL;\n+static hash_table <pass_registry_hasher> name_to_pass_map;\n \n /* Register PASS with NAME.  */\n \n@@ -609,11 +616,11 @@ register_pass_name (struct opt_pass *pass, const char *name)\n   struct pass_registry **slot;\n   struct pass_registry pr;\n \n-  if (!name_to_pass_map)\n-    name_to_pass_map = htab_create (256, passr_hash, passr_eq, NULL);\n+  if (!name_to_pass_map.is_created ())\n+    name_to_pass_map.create (256);\n \n   pr.unique_name = name;\n-  slot = (struct pass_registry **) htab_find_slot (name_to_pass_map, &pr, INSERT);\n+  slot = name_to_pass_map.find_slot (&pr, INSERT);\n   if (!*slot)\n     {\n       struct pass_registry *new_pr;\n@@ -634,10 +641,9 @@ static vec<char_ptr> pass_tab = vNULL;\n \n /* Callback function for traversing NAME_TO_PASS_MAP.  */\n \n-static int\n-pass_traverse (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+passes_pass_traverse (pass_registry **p, void *data ATTRIBUTE_UNUSED)\n {\n-  struct pass_registry **p = (struct pass_registry **)slot;\n   struct opt_pass *pass = (*p)->pass;\n \n   gcc_assert (pass->static_pass_number > 0);\n@@ -658,7 +664,7 @@ create_pass_tab (void)\n     return;\n \n   pass_tab.safe_grow_cleared (passes_by_id_size + 1);\n-  htab_traverse (name_to_pass_map, pass_traverse, NULL);\n+  name_to_pass_map.traverse <void *, passes_pass_traverse> (NULL);\n }\n \n static bool override_gate_status (struct opt_pass *, tree, bool);\n@@ -743,8 +749,7 @@ get_pass_by_name (const char *name)\n   struct pass_registry **slot, pr;\n \n   pr.unique_name = name;\n-  slot = (struct pass_registry **) htab_find_slot (name_to_pass_map,\n-                                                   &pr, NO_INSERT);\n+  slot = name_to_pass_map.find_slot (&pr, NO_INSERT);\n \n   if (!slot || !*slot)\n     return NULL;"}, {"sha": "b269dfa3971a72d3758bbd85a553c56386e7cedf", "filename": "gcc/plugin.c", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"diagnostic-core.h\"\n #include \"tree.h\"\n #include \"tree-pass.h\"\n@@ -50,9 +51,36 @@ static const char *plugin_event_name_init[] =\n \n const char **plugin_event_name = plugin_event_name_init;\n \n+/* Event hashtable helpers.  */\n+\n+struct event_hasher : typed_noop_remove <const char *>\n+{\n+  typedef const char *value_type;\n+  typedef const char *compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Helper function for the event hash table that hashes the entry V.  */\n+\n+inline hashval_t\n+event_hasher::hash (const value_type *v)\n+{\n+  return htab_hash_string (*v);\n+}\n+\n+/* Helper function for the event hash table that compares the name of an\n+   existing entry (S1) with the given string (S2).  */\n+\n+inline bool\n+event_hasher::equal (const value_type *s1, const compare_type *s2)\n+{\n+  return !strcmp (*s1, *s2);\n+}\n+\n /* A hash table to map event names to the position of the names in the\n    plugin_event_name table.  */\n-static htab_t event_tab;\n+static hash_table <event_hasher> event_tab;\n \n /* Keep track of the limit of allocated events and space ready for\n    allocating events.  */\n@@ -312,41 +340,31 @@ register_plugin_info (const char* name, struct plugin_info *info)\n   plugin->help = info->help;\n }\n \n-/* Helper function for the event hash table that compares the name of an\n-   existing entry (E1) with the given string (S2).  */\n-\n-static int\n-htab_event_eq (const void *e1, const void *s2)\n-{\n-  const char *s1= *(const char * const *) e1;\n-  return !strcmp (s1, (const char *) s2);\n-}\n-\n /* Look up the event id for NAME.  If the name is not found, return -1\n    if INSERT is NO_INSERT.  */\n \n int\n get_named_event_id (const char *name, enum insert_option insert)\n {\n-  void **slot;\n+  const char ***slot;\n \n-  if (!event_tab)\n+  if (!event_tab.is_created ())\n     {\n       int i;\n \n-      event_tab = htab_create (150, htab_hash_string, htab_event_eq, NULL);\n+      event_tab.create (150);\n       for (i = 0; i < event_last; i++)\n \t{\n-\t  slot = htab_find_slot (event_tab, plugin_event_name[i], INSERT);\n+\t  slot = event_tab.find_slot (&plugin_event_name[i], INSERT);\n \t  gcc_assert (*slot == HTAB_EMPTY_ENTRY);\n \t  *slot = &plugin_event_name[i];\n \t}\n     }\n-  slot = htab_find_slot (event_tab, name, insert);\n+  slot = event_tab.find_slot (&name, insert);\n   if (slot == NULL)\n     return -1;\n   if (*slot != HTAB_EMPTY_ENTRY)\n-    return (const char **) *slot - &plugin_event_name[0];\n+    return *slot - &plugin_event_name[0];\n \n   if (event_last >= event_horizon)\n     {\n@@ -368,8 +386,7 @@ get_named_event_id (const char *name, enum insert_option insert)\n \t\t\t\t\t plugin_callbacks, event_horizon);\n \t}\n       /* All the pointers in the hash table will need to be updated.  */\n-      htab_delete (event_tab);\n-      event_tab = NULL;\n+      event_tab.dispose ();\n     }\n   else\n     *slot = &plugin_event_name[event_last];"}, {"sha": "aeffc14435eda175aac26a2b225abcdc0da66fed", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"diagnostic-core.h\"\n \n+#include \"hash-table.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"tm_p.h\"\n@@ -87,9 +88,6 @@ static struct\n    type 'struct expr', and for each expression there is a single linked\n    list of occurrences.  */\n \n-/* The table itself.  */\n-static htab_t expr_table;\n-\n /* Expression elements in the hash table.  */\n struct expr\n {\n@@ -103,6 +101,56 @@ struct expr\n   struct occr *avail_occr;\n };\n \n+/* Hashtable helpers.  */\n+\n+struct expr_hasher : typed_noop_remove <expr>\n+{\n+  typedef expr value_type;\n+  typedef expr compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+\n+/* Hash expression X.\n+   DO_NOT_RECORD_P is a boolean indicating if a volatile operand is found\n+   or if the expression contains something we don't want to insert in the\n+   table.  */\n+\n+static hashval_t\n+hash_expr (rtx x, int *do_not_record_p)\n+{\n+  *do_not_record_p = 0;\n+  return hash_rtx (x, GET_MODE (x), do_not_record_p,\n+\t\t   NULL,  /*have_reg_qty=*/false);\n+}\n+\n+/* Callback for hashtab.\n+   Return the hash value for expression EXP.  We don't actually hash\n+   here, we just return the cached hash value.  */\n+\n+inline hashval_t\n+expr_hasher::hash (const value_type *exp)\n+{\n+  return exp->hash;\n+}\n+\n+/* Callback for hashtab.\n+   Return nonzero if exp1 is equivalent to exp2.  */\n+\n+inline bool\n+expr_hasher::equal (const value_type *exp1, const compare_type *exp2)\n+{\n+  int equiv_p = exp_equiv_p (exp1->expr, exp2->expr, 0, true);\n+\n+  gcc_assert (!equiv_p || exp1->hash == exp2->hash);\n+  return equiv_p;\n+}\n+\n+/* The table itself.  */\n+static hash_table <expr_hasher> expr_table;\n+\f\n+\n static struct obstack expr_obstack;\n \n /* Occurrence of an expression.\n@@ -183,11 +231,8 @@ static void reset_opr_set_tables (void);\n \n /* Hash table support.  */\n static hashval_t hash_expr (rtx, int *);\n-static hashval_t hash_expr_for_htab (const void *);\n-static int expr_equiv_p (const void *, const void *);\n static void insert_expr_in_table (rtx, rtx);\n static struct expr *lookup_expr_in_table (rtx);\n-static int dump_hash_table_entry (void **, void *);\n static void dump_hash_table (FILE *);\n \n /* Helpers for eliminate_partially_redundant_load.  */\n@@ -234,8 +279,7 @@ alloc_mem (void)\n      make the hash table too small, but unnecessarily making it too large\n      also doesn't help.  The i/4 is a gcse.c relic, and seems like a\n      reasonable choice.  */\n-  expr_table = htab_create (MAX (i / 4, 13),\n-\t\t\t    hash_expr_for_htab, expr_equiv_p, NULL);\n+  expr_table.create (MAX (i / 4, 13));\n \n   /* We allocate everything on obstacks because we often can roll back\n      the whole obstack to some point.  Freeing obstacks is very fast.  */\n@@ -262,7 +306,7 @@ free_mem (void)\n {\n   free (uid_cuid);\n \n-  htab_delete (expr_table);\n+  expr_table.dispose ();\n \n   obstack_free (&expr_obstack, NULL);\n   obstack_free (&occr_obstack, NULL);\n@@ -273,45 +317,6 @@ free_mem (void)\n }\n \f\n \n-/* Hash expression X.\n-   DO_NOT_RECORD_P is a boolean indicating if a volatile operand is found\n-   or if the expression contains something we don't want to insert in the\n-   table.  */\n-\n-static hashval_t\n-hash_expr (rtx x, int *do_not_record_p)\n-{\n-  *do_not_record_p = 0;\n-  return hash_rtx (x, GET_MODE (x), do_not_record_p,\n-\t\t   NULL,  /*have_reg_qty=*/false);\n-}\n-\n-/* Callback for hashtab.\n-   Return the hash value for expression EXP.  We don't actually hash\n-   here, we just return the cached hash value.  */\n-\n-static hashval_t\n-hash_expr_for_htab (const void *expp)\n-{\n-  const struct expr *const exp = (const struct expr *) expp;\n-  return exp->hash;\n-}\n-\n-/* Callback for hashtab.\n-   Return nonzero if exp1 is equivalent to exp2.  */\n-\n-static int\n-expr_equiv_p (const void *exp1p, const void *exp2p)\n-{\n-  const struct expr *const exp1 = (const struct expr *) exp1p;\n-  const struct expr *const exp2 = (const struct expr *) exp2p;\n-  int equiv_p = exp_equiv_p (exp1->expr, exp2->expr, 0, true);\n-\n-  gcc_assert (!equiv_p || exp1->hash == exp2->hash);\n-  return equiv_p;\n-}\n-\f\n-\n /* Insert expression X in INSN in the hash TABLE.\n    If it is already present, record it as the last occurrence in INSN's\n    basic block.  */\n@@ -343,8 +348,7 @@ insert_expr_in_table (rtx x, rtx insn)\n   cur_expr->hash = hash;\n   cur_expr->avail_occr = NULL;\n \n-  slot = (struct expr **) htab_find_slot_with_hash (expr_table, cur_expr,\n-\t\t\t\t\t\t    hash, INSERT);\n+  slot = expr_table.find_slot_with_hash (cur_expr, hash, INSERT);\n \n   if (! (*slot))\n     /* The expression isn't found, so insert it.  */\n@@ -412,8 +416,7 @@ lookup_expr_in_table (rtx pat)\n   tmp_expr->hash = hash;\n   tmp_expr->avail_occr = NULL;\n \n-  slot = (struct expr **) htab_find_slot_with_hash (expr_table, tmp_expr,\n-                                                    hash, INSERT);\n+  slot = expr_table.find_slot_with_hash (tmp_expr, hash, INSERT);\n   obstack_free (&expr_obstack, tmp_expr);\n \n   if (!slot)\n@@ -427,18 +430,17 @@ lookup_expr_in_table (rtx pat)\n    expression hash table to FILE.  */\n \n /* This helper is called via htab_traverse.  */\n-static int\n-dump_hash_table_entry (void **slot, void *filep)\n+int\n+dump_expr_hash_table_entry (expr **slot, FILE *file)\n {\n-  struct expr *expr = (struct expr *) *slot;\n-  FILE *file = (FILE *) filep;\n+  struct expr *exprs = *slot;\n   struct occr *occr;\n \n   fprintf (file, \"expr: \");\n-  print_rtl (file, expr->expr);\n-  fprintf (file,\"\\nhashcode: %u\\n\", expr->hash);\n+  print_rtl (file, exprs->expr);\n+  fprintf (file,\"\\nhashcode: %u\\n\", exprs->hash);\n   fprintf (file,\"list of occurrences:\\n\");\n-  occr = expr->avail_occr;\n+  occr = exprs->avail_occr;\n   while (occr)\n     {\n       rtx insn = occr->insn;\n@@ -455,13 +457,13 @@ dump_hash_table (FILE *file)\n {\n   fprintf (file, \"\\n\\nexpression hash table\\n\");\n   fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n-           (long) htab_size (expr_table),\n-           (long) htab_elements (expr_table),\n-           htab_collisions (expr_table));\n-  if (htab_elements (expr_table) > 0)\n+           (long) expr_table.size (),\n+           (long) expr_table.elements (),\n+           expr_table.collisions ());\n+  if (expr_table.elements () > 0)\n     {\n       fprintf (file, \"\\n\\ntable entries:\\n\");\n-      htab_traverse (expr_table, dump_hash_table_entry, file);\n+      expr_table.traverse <FILE *, dump_expr_hash_table_entry> (file);\n     }\n   fprintf (file, \"\\n\");\n }\n@@ -1223,13 +1225,13 @@ eliminate_partially_redundant_loads (void)\n    marked for later deletion.  */\n \n /* This helper is called via htab_traverse.  */\n-static int\n-delete_redundant_insns_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+delete_redundant_insns_1 (expr **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  struct expr *expr = (struct expr *) *slot;\n+  struct expr *exprs = *slot;\n   struct occr *occr;\n \n-  for (occr = expr->avail_occr; occr != NULL; occr = occr->next)\n+  for (occr = exprs->avail_occr; occr != NULL; occr = occr->next)\n     {\n       if (occr->deleted_p && dbg_cnt (gcse2_delete))\n \t{\n@@ -1251,7 +1253,7 @@ delete_redundant_insns_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n static void\n delete_redundant_insns (void)\n {\n-  htab_traverse (expr_table, delete_redundant_insns_1, NULL);\n+  expr_table.traverse <void *, delete_redundant_insns_1> (NULL);\n   if (dump_file)\n     fprintf (dump_file, \"\\n\");\n }\n@@ -1277,7 +1279,7 @@ gcse_after_reload_main (rtx f ATTRIBUTE_UNUSED)\n   if (dump_file)\n     dump_hash_table (dump_file);\n \n-  if (htab_elements (expr_table) > 0)\n+  if (expr_table.elements () > 0)\n     {\n       eliminate_partially_redundant_loads ();\n       delete_redundant_insns ();"}, {"sha": "10ccee274fb4df2e088f9af0a494f10d0073d94f", "filename": "gcc/sese.c", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"tree-pretty-print.h\"\n #include \"tree-flow.h\"\n #include \"cfgloop.h\"\n@@ -46,20 +47,50 @@ debug_rename_elt (rename_map_elt elt)\n \n /* Helper function for debug_rename_map.  */\n \n-static int\n-debug_rename_map_1 (void **slot, void *s ATTRIBUTE_UNUSED)\n+int\n+debug_rename_map_1 (rename_map_elt_s **slot, void *s ATTRIBUTE_UNUSED)\n {\n-  struct rename_map_elt_s *entry = (struct rename_map_elt_s *) *slot;\n+  struct rename_map_elt_s *entry = *slot;\n   debug_rename_elt (entry);\n   return 1;\n }\n+\f\n+\n+/* Hashtable helpers.  */\n+\n+struct rename_map_hasher : typed_free_remove <rename_map_elt_s>\n+{\n+  typedef rename_map_elt_s value_type;\n+  typedef rename_map_elt_s compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Computes a hash function for database element ELT.  */\n+\n+inline hashval_t\n+rename_map_hasher::hash (const value_type *elt)\n+{\n+  return SSA_NAME_VERSION (elt->old_name);\n+}\n+\n+/* Compares database elements E1 and E2.  */\n+\n+inline bool\n+rename_map_hasher::equal (const value_type *elt1, const compare_type *elt2)\n+{\n+  return (elt1->old_name == elt2->old_name);\n+}\n+\n+typedef hash_table <rename_map_hasher> rename_map_type;\n+\f\n \n /* Print to stderr all the elements of RENAME_MAP.  */\n \n DEBUG_FUNCTION void\n-debug_rename_map (htab_t rename_map)\n+debug_rename_map (rename_map_type rename_map)\n {\n-  htab_traverse (rename_map, debug_rename_map_1, NULL);\n+  rename_map.traverse <void *, debug_rename_map_1> (NULL);\n }\n \n /* Computes a hash function for database element ELT.  */\n@@ -365,34 +396,34 @@ get_false_edge_from_guard_bb (basic_block bb)\n /* Returns the expression associated to OLD_NAME in RENAME_MAP.  */\n \n static tree\n-get_rename (htab_t rename_map, tree old_name)\n+get_rename (rename_map_type rename_map, tree old_name)\n {\n   struct rename_map_elt_s tmp;\n-  PTR *slot;\n+  rename_map_elt_s **slot;\n \n   gcc_assert (TREE_CODE (old_name) == SSA_NAME);\n   tmp.old_name = old_name;\n-  slot = htab_find_slot (rename_map, &tmp, NO_INSERT);\n+  slot = rename_map.find_slot (&tmp, NO_INSERT);\n \n   if (slot && *slot)\n-    return ((rename_map_elt) *slot)->expr;\n+    return (*slot)->expr;\n \n   return NULL_TREE;\n }\n \n /* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).  */\n \n static void\n-set_rename (htab_t rename_map, tree old_name, tree expr)\n+set_rename (rename_map_type rename_map, tree old_name, tree expr)\n {\n   struct rename_map_elt_s tmp;\n-  PTR *slot;\n+  rename_map_elt_s **slot;\n \n   if (old_name == expr)\n     return;\n \n   tmp.old_name = old_name;\n-  slot = htab_find_slot (rename_map, &tmp, INSERT);\n+  slot = rename_map.find_slot (&tmp, INSERT);\n \n   if (!slot)\n     return;\n@@ -410,7 +441,8 @@ set_rename (htab_t rename_map, tree old_name, tree expr)\n    is set when the code generation cannot continue.  */\n \n static bool\n-rename_uses (gimple copy, htab_t rename_map, gimple_stmt_iterator *gsi_tgt,\n+rename_uses (gimple copy, rename_map_type rename_map,\n+\t     gimple_stmt_iterator *gsi_tgt,\n \t     sese region, loop_p loop, vec<tree> iv_map,\n \t     bool *gloog_error)\n {\n@@ -516,7 +548,7 @@ rename_uses (gimple copy, htab_t rename_map, gimple_stmt_iterator *gsi_tgt,\n \n static void\n graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n-\t\t\t\thtab_t rename_map,\n+\t\t\t\trename_map_type rename_map,\n \t\t\t\tvec<tree> iv_map, sese region,\n \t\t\t\tbool *gloog_error)\n {\n@@ -584,14 +616,14 @@ copy_bb_and_scalar_dependences (basic_block bb, sese region,\n \t\t\t\tbool *gloog_error)\n {\n   basic_block new_bb = split_edge (next_e);\n-  htab_t rename_map = htab_create (10, rename_map_elt_info,\n-\t\t\t\t   eq_rename_map_elts, free);\n+  rename_map_type rename_map;\n+  rename_map.create (10);\n \n   next_e = single_succ_edge (new_bb);\n   graphite_copy_stmts_from_block (bb, new_bb, rename_map, iv_map, region,\n \t\t\t\t  gloog_error);\n   remove_phi_nodes (new_bb);\n-  htab_delete (rename_map);\n+  rename_map.dispose ();\n \n   return next_e;\n }"}, {"sha": "cc28a994a6a29be7921f187b1bf788ece2844aa5", "filename": "gcc/sese.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -257,7 +257,6 @@ typedef struct rename_map_elt_s\n } *rename_map_elt;\n \n \n-extern void debug_rename_map (htab_t);\n extern hashval_t rename_map_elt_info (const void *);\n extern int eq_rename_map_elts (const void *, const void *);\n "}, {"sha": "df7567074085855c0d2bf89ca79f209d1e96f6b6", "filename": "gcc/store-motion.c", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"intl.h\"\n #include \"tree-pass.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"df.h\"\n #include \"dbgcnt.h\"\n \n@@ -90,9 +90,6 @@ struct st_expr\n /* Head of the list of load/store memory refs.  */\n static struct st_expr * store_motion_mems = NULL;\n \n-/* Hashtable for the load/store memory refs.  */\n-static htab_t store_motion_mems_table = NULL;\n-\n /* These bitmaps will hold the local dataflow properties per basic block.  */\n static sbitmap *st_kill, *st_avloc, *st_antloc, *st_transp;\n \n@@ -108,22 +105,32 @@ static int num_stores;\n /* Contains the edge_list returned by pre_edge_lcm.  */\n static struct edge_list *edge_list;\n \n-static hashval_t\n-pre_st_expr_hash (const void *p)\n+/* Hashtable helpers.  */\n+\n+struct st_expr_hasher : typed_noop_remove <st_expr>\n+{\n+  typedef st_expr value_type;\n+  typedef st_expr compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+st_expr_hasher::hash (const value_type *x)\n {\n   int do_not_record_p = 0;\n-  const struct st_expr *const x = (const struct st_expr *) p;\n   return hash_rtx (x->pattern, GET_MODE (x->pattern), &do_not_record_p, NULL, false);\n }\n \n-static int\n-pre_st_expr_eq (const void *p1, const void *p2)\n+inline bool\n+st_expr_hasher::equal (const value_type *ptr1, const compare_type *ptr2)\n {\n-  const struct st_expr *const ptr1 = (const struct st_expr *) p1,\n-    *const ptr2 = (const struct st_expr *) p2;\n   return exp_equiv_p (ptr1->pattern, ptr2->pattern, 0, true);\n }\n \n+/* Hashtable for the load/store memory refs.  */\n+static hash_table <st_expr_hasher> store_motion_mems_table;\n+\n /* This will search the st_expr list for a matching expression. If it\n    doesn't find one, we create one and initialize it.  */\n \n@@ -133,16 +140,16 @@ st_expr_entry (rtx x)\n   int do_not_record_p = 0;\n   struct st_expr * ptr;\n   unsigned int hash;\n-  void **slot;\n+  st_expr **slot;\n   struct st_expr e;\n \n   hash = hash_rtx (x, GET_MODE (x), &do_not_record_p,\n \t\t   NULL,  /*have_reg_qty=*/false);\n \n   e.pattern = x;\n-  slot = htab_find_slot_with_hash (store_motion_mems_table, &e, hash, INSERT);\n+  slot = store_motion_mems_table.find_slot_with_hash (&e, hash, INSERT);\n   if (*slot)\n-    return (struct st_expr *)*slot;\n+    return *slot;\n \n   ptr = XNEW (struct st_expr);\n \n@@ -176,9 +183,8 @@ free_st_expr_entry (struct st_expr * ptr)\n static void\n free_store_motion_mems (void)\n {\n-  if (store_motion_mems_table)\n-    htab_delete (store_motion_mems_table);\n-  store_motion_mems_table = NULL;\n+  if (store_motion_mems_table.is_created ())\n+    store_motion_mems_table.dispose ();\n \n   while (store_motion_mems)\n     {\n@@ -645,8 +651,7 @@ compute_store_table (void)\n   unsigned int max_gcse_regno = max_reg_num ();\n \n   store_motion_mems = NULL;\n-  store_motion_mems_table = htab_create (13, pre_st_expr_hash,\n-\t\t\t\t\t pre_st_expr_eq, NULL);\n+  store_motion_mems_table.create (13);\n   last_set_in = XCNEWVEC (int, max_gcse_regno);\n   already_set = XNEWVEC (int, max_gcse_regno);\n \n@@ -708,8 +713,7 @@ compute_store_table (void)\n       if (! ptr->avail_stores)\n \t{\n \t  *prev_next_ptr_ptr = ptr->next;\n-\t  htab_remove_elt_with_hash (store_motion_mems_table,\n-\t\t\t\t     ptr, ptr->hash_index);\n+\t  store_motion_mems_table.remove_elt_with_hash (ptr, ptr->hash_index);\n \t  free_st_expr_entry (ptr);\n \t}\n       else\n@@ -1142,8 +1146,7 @@ one_store_motion_pass (void)\n   num_stores = compute_store_table ();\n   if (num_stores == 0)\n     {\n-      htab_delete (store_motion_mems_table);\n-      store_motion_mems_table = NULL;\n+      store_motion_mems_table.dispose ();\n       end_alias_analysis ();\n       return 0;\n     }"}, {"sha": "5cb828659109a8b4f694eca4acf5eb6d3189c7a4", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 117, "deletions": 80, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -20,6 +20,7 @@\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"tree-flow.h\"\n@@ -879,47 +880,29 @@ typedef struct tm_log_entry\n   tree save_var;\n } *tm_log_entry_t;\n \n-/* The actual log.  */\n-static htab_t tm_log;\n-\n-/* Addresses to log with a save/restore sequence.  These should be in\n-   dominator order.  */\n-static vec<tree> tm_log_save_addresses;\n-\n-/* Map for an SSA_NAME originally pointing to a non aliased new piece\n-   of memory (malloc, alloc, etc).  */\n-static htab_t tm_new_mem_hash;\n \n-enum thread_memory_type\n-  {\n-    mem_non_local = 0,\n-    mem_thread_local,\n-    mem_transaction_local,\n-    mem_max\n-  };\n+/* Log entry hashtable helpers.  */\n \n-typedef struct tm_new_mem_map\n+struct log_entry_hasher\n {\n-  /* SSA_NAME being dereferenced.  */\n-  tree val;\n-  enum thread_memory_type local_new_memory;\n-} tm_new_mem_map_t;\n+  typedef tm_log_entry value_type;\n+  typedef tm_log_entry compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n \n /* Htab support.  Return hash value for a `tm_log_entry'.  */\n-static hashval_t\n-tm_log_hash (const void *p)\n+inline hashval_t\n+log_entry_hasher::hash (const value_type *log)\n {\n-  const struct tm_log_entry *log = (const struct tm_log_entry *) p;\n   return iterative_hash_expr (log->addr, 0);\n }\n \n /* Htab support.  Return true if two log entries are the same.  */\n-static int\n-tm_log_eq (const void *p1, const void *p2)\n+inline bool\n+log_entry_hasher::equal (const value_type *log1, const compare_type *log2)\n {\n-  const struct tm_log_entry *log1 = (const struct tm_log_entry *) p1;\n-  const struct tm_log_entry *log2 = (const struct tm_log_entry *) p2;\n-\n   /* FIXME:\n \n      rth: I suggest that we get rid of the component refs etc.\n@@ -943,29 +926,77 @@ tm_log_eq (const void *p1, const void *p2)\n }\n \n /* Htab support.  Free one tm_log_entry.  */\n-static void\n-tm_log_free (void *p)\n+inline void\n+log_entry_hasher::remove (value_type *lp)\n {\n-  struct tm_log_entry *lp = (struct tm_log_entry *) p;\n   lp->stmts.release ();\n   free (lp);\n }\n \n+\n+/* The actual log.  */\n+static hash_table <log_entry_hasher> tm_log;\n+\n+/* Addresses to log with a save/restore sequence.  These should be in\n+   dominator order.  */\n+static vec<tree> tm_log_save_addresses;\n+\n+enum thread_memory_type\n+  {\n+    mem_non_local = 0,\n+    mem_thread_local,\n+    mem_transaction_local,\n+    mem_max\n+  };\n+\n+typedef struct tm_new_mem_map\n+{\n+  /* SSA_NAME being dereferenced.  */\n+  tree val;\n+  enum thread_memory_type local_new_memory;\n+} tm_new_mem_map_t;\n+\n+/* Hashtable helpers.  */\n+\n+struct tm_mem_map_hasher : typed_free_remove <tm_new_mem_map_t>\n+{\n+  typedef tm_new_mem_map_t value_type;\n+  typedef tm_new_mem_map_t compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+tm_mem_map_hasher::hash (const value_type *v)\n+{\n+  return (intptr_t)v->val >> 4;\n+}\n+\n+inline bool\n+tm_mem_map_hasher::equal (const value_type *v, const compare_type *c)\n+{\n+  return v->val == c->val;\n+}\n+\n+/* Map for an SSA_NAME originally pointing to a non aliased new piece\n+   of memory (malloc, alloc, etc).  */\n+static hash_table <tm_mem_map_hasher> tm_new_mem_hash;\n+\n /* Initialize logging data structures.  */\n static void\n tm_log_init (void)\n {\n-  tm_log = htab_create (10, tm_log_hash, tm_log_eq, tm_log_free);\n-  tm_new_mem_hash = htab_create (5, struct_ptr_hash, struct_ptr_eq, free);\n+  tm_log.create (10);\n+  tm_new_mem_hash.create (5);\n   tm_log_save_addresses.create (5);\n }\n \n /* Free logging data structures.  */\n static void\n tm_log_delete (void)\n {\n-  htab_delete (tm_log);\n-  htab_delete (tm_new_mem_hash);\n+  tm_log.dispose ();\n+  tm_new_mem_hash.dispose ();\n   tm_log_save_addresses.release ();\n }\n \n@@ -1006,11 +1037,11 @@ transaction_invariant_address_p (const_tree mem, basic_block region_entry_block)\n static void\n tm_log_add (basic_block entry_block, tree addr, gimple stmt)\n {\n-  void **slot;\n+  tm_log_entry **slot;\n   struct tm_log_entry l, *lp;\n \n   l.addr = addr;\n-  slot = htab_find_slot (tm_log, &l, INSERT);\n+  slot = tm_log.find_slot (&l, INSERT);\n   if (!*slot)\n     {\n       tree type = TREE_TYPE (addr);\n@@ -1051,7 +1082,7 @@ tm_log_add (basic_block entry_block, tree addr, gimple stmt)\n       size_t i;\n       gimple oldstmt;\n \n-      lp = (struct tm_log_entry *) *slot;\n+      lp = *slot;\n \n       /* If we're generating a save/restore sequence, we don't care\n \t about statements.  */\n@@ -1153,10 +1184,10 @@ tm_log_emit_stmt (tree addr, gimple stmt)\n static void\n tm_log_emit (void)\n {\n-  htab_iterator hi;\n+  hash_table <log_entry_hasher>::iterator hi;\n   struct tm_log_entry *lp;\n \n-  FOR_EACH_HTAB_ELEMENT (tm_log, lp, tm_log_entry_t, hi)\n+  FOR_EACH_HASH_TABLE_ELEMENT (tm_log, lp, tm_log_entry_t, hi)\n     {\n       size_t i;\n       gimple stmt;\n@@ -1198,7 +1229,7 @@ tm_log_emit_saves (basic_block entry_block, basic_block bb)\n   for (i = 0; i < tm_log_save_addresses.length (); ++i)\n     {\n       l.addr = tm_log_save_addresses[i];\n-      lp = (struct tm_log_entry *) *htab_find_slot (tm_log, &l, NO_INSERT);\n+      lp = *(tm_log.find_slot (&l, NO_INSERT));\n       gcc_assert (lp->save_var != NULL);\n \n       /* We only care about variables in the current transaction.  */\n@@ -1234,7 +1265,7 @@ tm_log_emit_restores (basic_block entry_block, basic_block bb)\n   for (i = tm_log_save_addresses.length () - 1; i >= 0; i--)\n     {\n       l.addr = tm_log_save_addresses[i];\n-      lp = (struct tm_log_entry *) *htab_find_slot (tm_log, &l, NO_INSERT);\n+      lp = *(tm_log.find_slot (&l, NO_INSERT));\n       gcc_assert (lp->save_var != NULL);\n \n       /* We only care about variables in the current transaction.  */\n@@ -1271,7 +1302,7 @@ thread_private_new_memory (basic_block entry_block, tree x)\n {\n   gimple stmt = NULL;\n   enum tree_code code;\n-  void **slot;\n+  tm_new_mem_map_t **slot;\n   tm_new_mem_map_t elt, *elt_p;\n   tree val = x;\n   enum thread_memory_type retval = mem_transaction_local;\n@@ -1285,8 +1316,8 @@ thread_private_new_memory (basic_block entry_block, tree x)\n \n   /* Look in cache first.  */\n   elt.val = x;\n-  slot = htab_find_slot (tm_new_mem_hash, &elt, INSERT);\n-  elt_p = (tm_new_mem_map_t *) *slot;\n+  slot = tm_new_mem_hash.find_slot (&elt, INSERT);\n+  elt_p = *slot;\n   if (elt_p)\n     return elt_p->local_new_memory;\n \n@@ -3146,6 +3177,35 @@ typedef struct tm_memop\n   tree addr;\n } *tm_memop_t;\n \n+/* TM memory operation hashtable helpers.  */\n+\n+struct tm_memop_hasher : typed_free_remove <tm_memop>\n+{\n+  typedef tm_memop value_type;\n+  typedef tm_memop compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Htab support.  Return a hash value for a `tm_memop'.  */\n+inline hashval_t\n+tm_memop_hasher::hash (const value_type *mem)\n+{\n+  tree addr = mem->addr;\n+  /* We drill down to the SSA_NAME/DECL for the hash, but equality is\n+     actually done with operand_equal_p (see tm_memop_eq).  */\n+  if (TREE_CODE (addr) == ADDR_EXPR)\n+    addr = TREE_OPERAND (addr, 0);\n+  return iterative_hash_expr (addr, 0);\n+}\n+\n+/* Htab support.  Return true if two tm_memop's are the same.  */\n+inline bool\n+tm_memop_hasher::equal (const value_type *mem1, const compare_type *mem2)\n+{\n+  return operand_equal_p (mem1->addr, mem2->addr, 0);\n+}\n+\n /* Sets for solving data flow equations in the memory optimization pass.  */\n struct tm_memopt_bitmaps\n {\n@@ -3178,7 +3238,7 @@ static bitmap_obstack tm_memopt_obstack;\n /* Unique counter for TM loads and stores. Loads and stores of the\n    same address get the same ID.  */\n static unsigned int tm_memopt_value_id;\n-static htab_t tm_memopt_value_numbers;\n+static hash_table <tm_memop_hasher> tm_memopt_value_numbers;\n \n #define STORE_AVAIL_IN(BB) \\\n   ((struct tm_memopt_bitmaps *) ((BB)->aux))->store_avail_in\n@@ -3201,43 +3261,20 @@ static htab_t tm_memopt_value_numbers;\n #define BB_VISITED_P(BB) \\\n   ((struct tm_memopt_bitmaps *) ((BB)->aux))->visited_p\n \n-/* Htab support.  Return a hash value for a `tm_memop'.  */\n-static hashval_t\n-tm_memop_hash (const void *p)\n-{\n-  const struct tm_memop *mem = (const struct tm_memop *) p;\n-  tree addr = mem->addr;\n-  /* We drill down to the SSA_NAME/DECL for the hash, but equality is\n-     actually done with operand_equal_p (see tm_memop_eq).  */\n-  if (TREE_CODE (addr) == ADDR_EXPR)\n-    addr = TREE_OPERAND (addr, 0);\n-  return iterative_hash_expr (addr, 0);\n-}\n-\n-/* Htab support.  Return true if two tm_memop's are the same.  */\n-static int\n-tm_memop_eq (const void *p1, const void *p2)\n-{\n-  const struct tm_memop *mem1 = (const struct tm_memop *) p1;\n-  const struct tm_memop *mem2 = (const struct tm_memop *) p2;\n-\n-  return operand_equal_p (mem1->addr, mem2->addr, 0);\n-}\n-\n /* Given a TM load/store in STMT, return the value number for the address\n    it accesses.  */\n \n static unsigned int\n tm_memopt_value_number (gimple stmt, enum insert_option op)\n {\n   struct tm_memop tmpmem, *mem;\n-  void **slot;\n+  tm_memop **slot;\n \n   gcc_assert (is_tm_load (stmt) || is_tm_store (stmt));\n   tmpmem.addr = gimple_call_arg (stmt, 0);\n-  slot = htab_find_slot (tm_memopt_value_numbers, &tmpmem, op);\n+  slot = tm_memopt_value_numbers.find_slot (&tmpmem, op);\n   if (*slot)\n-    mem = (struct tm_memop *) *slot;\n+    mem = *slot;\n   else if (op == INSERT)\n     {\n       mem = XNEW (struct tm_memop);\n@@ -3295,11 +3332,11 @@ dump_tm_memopt_set (const char *set_name, bitmap bits)\n   fprintf (dump_file, \"TM memopt: %s: [\", set_name);\n   EXECUTE_IF_SET_IN_BITMAP (bits, 0, i, bi)\n     {\n-      htab_iterator hi;\n-      struct tm_memop *mem;\n+      hash_table <tm_memop_hasher>::iterator hi;\n+      struct tm_memop *mem = NULL;\n \n       /* Yeah, yeah, yeah.  Whatever.  This is just for debugging.  */\n-      FOR_EACH_HTAB_ELEMENT (tm_memopt_value_numbers, mem, tm_memop_t, hi)\n+      FOR_EACH_HASH_TABLE_ELEMENT (tm_memopt_value_numbers, mem, tm_memop_t, hi)\n \tif (mem->value_id == i)\n \t  break;\n       gcc_assert (mem->value_id == i);\n@@ -3734,7 +3771,7 @@ execute_tm_memopt (void)\n   vec<basic_block> bbs;\n \n   tm_memopt_value_id = 0;\n-  tm_memopt_value_numbers = htab_create (10, tm_memop_hash, tm_memop_eq, free);\n+  tm_memopt_value_numbers.create (10);\n \n   for (region = all_tm_regions; region; region = region->next)\n     {\n@@ -3768,10 +3805,10 @@ execute_tm_memopt (void)\n       tm_memopt_free_sets (bbs);\n       bbs.release ();\n       bitmap_obstack_release (&tm_memopt_obstack);\n-      htab_empty (tm_memopt_value_numbers);\n+      tm_memopt_value_numbers.empty ();\n     }\n \n-  htab_delete (tm_memopt_value_numbers);\n+  tm_memopt_value_numbers.dispose ();\n   return 0;\n }\n "}, {"sha": "b236cabd8dff6b5389d267c13c4a4f91c6f097ba", "filename": "gcc/tree-browser.c", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"tree.h\"\n #include \"tree-pretty-print.h\"\n \n@@ -94,14 +95,45 @@ static tree TB_next_expr (tree);\n static tree TB_up_expr (tree);\n static tree TB_first_in_bind (tree);\n static tree TB_last_in_bind (tree);\n-static int  TB_parent_eq (const void *, const void *);\n static tree TB_history_prev (void);\n \n /* FIXME: To be declared in a .h file.  */\n void browse_tree (tree);\n \n+/* Hashtable helpers.  */\n+struct tree_upper_hasher : typed_noop_remove <tree_node>\n+{\n+  typedef tree_node value_type;\n+  typedef tree_node compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+tree_upper_hasher::hash (const value_type *v)\n+{\n+  return pointer_hash <value_type>::hash (v);\n+}\n+\n+inline bool\n+tree_upper_hasher::equal (const value_type *parent, const compare_type *node)\n+{\n+  if (parent == NULL || node == NULL)\n+    return 0;\n+\n+  if (EXPR_P (parent))\n+    {\n+      int n = TREE_OPERAND_LENGTH (parent);\n+      int i;\n+      for (i = 0; i < n; i++)\n+\tif (node == TREE_OPERAND (parent, i))\n+\t  return true;\n+    }\n+  return false;\n+}\n+\n /* Static variables.  */\n-static htab_t TB_up_ht;\n+static hash_table <tree_upper_hasher> TB_up_ht;\n static vec<tree, va_gc> *TB_history_stack;\n static int TB_verbose = 1;\n \n@@ -134,7 +166,7 @@ browse_tree (tree begin)\n \n   /* Store in a hashtable information about previous and upper statements.  */\n   {\n-    TB_up_ht = htab_create (1023, htab_hash_pointer, &TB_parent_eq, NULL);\n+    TB_up_ht.create (1023);\n     TB_update_up (head);\n   }\n \n@@ -612,7 +644,7 @@ browse_tree (tree begin)\n     }\n \n  ret:;\n-  htab_delete (TB_up_ht);\n+  TB_up_ht.dispose ();\n   return;\n }\n \n@@ -658,7 +690,7 @@ TB_up_expr (tree node)\n   if (node == NULL_TREE)\n     return NULL_TREE;\n \n-  res = (tree) htab_find (TB_up_ht, node);\n+  res = TB_up_ht.find (node);\n   return res;\n }\n \n@@ -724,7 +756,7 @@ store_child_info (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t\t  void *data ATTRIBUTE_UNUSED)\n {\n   tree node;\n-  void **slot;\n+  tree_node **slot;\n \n   node = *tp;\n \n@@ -736,37 +768,15 @@ store_child_info (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n       for (i = 0; i < n; i++)\n \t{\n \t  tree op = TREE_OPERAND (node, i);\n-\t  slot = htab_find_slot (TB_up_ht, op, INSERT);\n-\t  *slot = (void *) node;\n+\t  slot = TB_up_ht.find_slot (op, INSERT);\n+\t  *slot = node;\n \t}\n     }\n \n   /* Never stop walk_tree.  */\n   return NULL_TREE;\n }\n \n-/* Function used in TB_up_ht.  */\n-\n-static int\n-TB_parent_eq (const void *p1, const void *p2)\n-{\n-  const_tree const node = (const_tree)p2;\n-  const_tree const parent = (const_tree) p1;\n-\n-  if (p1 == NULL || p2 == NULL)\n-    return 0;\n-\n-  if (EXPR_P (parent))\n-    {\n-      int n = TREE_OPERAND_LENGTH (parent);\n-      int i;\n-      for (i = 0; i < n; i++)\n-\tif (node == TREE_OPERAND (parent, i))\n-\t  return 1;\n-    }\n-  return 0;\n-}\n-\n /* Update information about upper expressions in the hash table.  */\n \n static void"}, {"sha": "c5c25a742bcb003d29cf77c41d3b73362264c0b0", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"tm_p.h\"\n@@ -87,7 +88,36 @@ struct locus_discrim_map\n   location_t locus;\n   int discriminator;\n };\n-static htab_t discriminator_per_locus;\n+\n+/* Hashtable helpers.  */\n+\n+struct locus_descrim_hasher : typed_free_remove <locus_discrim_map>\n+{\n+  typedef locus_discrim_map value_type;\n+  typedef locus_discrim_map compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Trivial hash function for a location_t.  ITEM is a pointer to\n+   a hash table entry that maps a location_t to a discriminator.  */\n+\n+inline hashval_t\n+locus_descrim_hasher::hash (const value_type *item)\n+{\n+  return item->locus;\n+}\n+\n+/* Equality function for the locus-to-discriminator map.  A and B\n+   point to the two hash table entries to compare.  */\n+\n+inline bool\n+locus_descrim_hasher::equal (const value_type *a, const compare_type *b)\n+{\n+  return a->locus == b->locus;\n+}\n+\n+static hash_table <locus_descrim_hasher> discriminator_per_locus;\n \n /* Basic blocks and flowgraphs.  */\n static void make_blocks (gimple_seq);\n@@ -99,8 +129,6 @@ static void make_cond_expr_edges (basic_block);\n static void make_gimple_switch_edges (basic_block);\n static void make_goto_expr_edges (basic_block);\n static void make_gimple_asm_edges (basic_block);\n-static unsigned int locus_map_hash (const void *);\n-static int locus_map_eq (const void *, const void *);\n static void assign_discriminator (location_t, basic_block);\n static edge gimple_redirect_edge_and_branch (edge, basic_block);\n static edge gimple_try_redirect_by_replacing_jump (edge, basic_block);\n@@ -201,11 +229,10 @@ build_gimple_cfg (gimple_seq seq)\n   group_case_labels ();\n \n   /* Create the edges of the flowgraph.  */\n-  discriminator_per_locus = htab_create (13, locus_map_hash, locus_map_eq,\n-                                         free);\n+  discriminator_per_locus.create (13);\n   make_edges ();\n   cleanup_dead_labels ();\n-  htab_delete (discriminator_per_locus);\n+  discriminator_per_locus.dispose ();\n }\n \n static unsigned int\n@@ -675,26 +702,6 @@ make_edges (void)\n   fold_cond_expr_cond ();\n }\n \n-/* Trivial hash function for a location_t.  ITEM is a pointer to\n-   a hash table entry that maps a location_t to a discriminator.  */\n-\n-static unsigned int\n-locus_map_hash (const void *item)\n-{\n-  return ((const struct locus_discrim_map *) item)->locus;\n-}\n-\n-/* Equality function for the locus-to-discriminator map.  VA and VB\n-   point to the two hash table entries to compare.  */\n-\n-static int\n-locus_map_eq (const void *va, const void *vb)\n-{\n-  const struct locus_discrim_map *a = (const struct locus_discrim_map *) va;\n-  const struct locus_discrim_map *b = (const struct locus_discrim_map *) vb;\n-  return a->locus == b->locus;\n-}\n-\n /* Find the next available discriminator value for LOCUS.  The\n    discriminator distinguishes among several basic blocks that\n    share a common locus, allowing for more accurate sample-based\n@@ -708,9 +715,7 @@ next_discriminator_for_locus (location_t locus)\n \n   item.locus = locus;\n   item.discriminator = 0;\n-  slot = (struct locus_discrim_map **)\n-      htab_find_slot_with_hash (discriminator_per_locus, (void *) &item,\n-                                (hashval_t) locus, INSERT);\n+  slot = discriminator_per_locus.find_slot_with_hash (&item, locus, INSERT);\n   gcc_assert (slot);\n   if (*slot == HTAB_EMPTY_ENTRY)\n     {"}, {"sha": "ee545682f98fb3c882624bee46841ceb7d8bb8f8", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"tree-pass.h\"\n #include \"tree-ssa-propagate.h\"\n+#include \"tree-hasher.h\"\n \n \n /* For each complex ssa name, a lattice value.  We're interested in finding\n@@ -53,7 +54,7 @@ static vec<complex_lattice_t> complex_lattice_values;\n \n /* For each complex variable, a pair of variables for the components exists in\n    the hashtable.  */\n-static htab_t complex_variable_components;\n+static int_tree_htab_type complex_variable_components;\n \n /* For each complex SSA_NAME, a pair of ssa names for the components.  */\n static vec<tree> complex_ssa_name_components;\n@@ -65,7 +66,7 @@ cvc_lookup (unsigned int uid)\n {\n   struct int_tree_map *h, in;\n   in.uid = uid;\n-  h = (struct int_tree_map *) htab_find_with_hash (complex_variable_components, &in, uid);\n+  h = complex_variable_components.find_with_hash (&in, uid);\n   return h ? h->to : NULL;\n }\n \n@@ -75,14 +76,13 @@ static void\n cvc_insert (unsigned int uid, tree to)\n {\n   struct int_tree_map *h;\n-  void **loc;\n+  int_tree_map **loc;\n \n   h = XNEW (struct int_tree_map);\n   h->uid = uid;\n   h->to = to;\n-  loc = htab_find_slot_with_hash (complex_variable_components, h,\n-\t\t\t\t  uid, INSERT);\n-  *(struct int_tree_map **) loc = h;\n+  loc = complex_variable_components.find_slot_with_hash (h, uid, INSERT);\n+  *loc = h;\n }\n \n /* Return true if T is not a zero constant.  In the case of real values,\n@@ -1604,8 +1604,7 @@ tree_lower_complex (void)\n   init_parameter_lattice_values ();\n   ssa_propagate (complex_visit_stmt, complex_visit_phi);\n \n-  complex_variable_components = htab_create (10,  int_tree_map_hash,\n-\t\t\t\t\t     int_tree_map_eq, free);\n+  complex_variable_components.create (10);\n \n   complex_ssa_name_components.create (2 * num_ssa_names);\n   complex_ssa_name_components.safe_grow_cleared (2 * num_ssa_names);\n@@ -1626,7 +1625,7 @@ tree_lower_complex (void)\n \n   gsi_commit_edge_inserts ();\n \n-  htab_delete (complex_variable_components);\n+  complex_variable_components.dispose ();\n   complex_ssa_name_components.release ();\n   complex_lattice_values.release ();\n   return 0;"}, {"sha": "56132e15702a4cf8e5bd3e355960f7788e6dee99", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n@@ -193,20 +194,42 @@ struct finally_tree_node\n   gimple parent;\n };\n \n+/* Hashtable helpers.  */\n+\n+struct finally_tree_hasher : typed_free_remove <finally_tree_node>\n+{\n+  typedef finally_tree_node value_type;\n+  typedef finally_tree_node compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+finally_tree_hasher::hash (const value_type *v)\n+{\n+  return (intptr_t)v->child.t >> 4;\n+}\n+\n+inline bool\n+finally_tree_hasher::equal (const value_type *v, const compare_type *c)\n+{\n+  return v->child.t == c->child.t;\n+}\n+\n /* Note that this table is *not* marked GTY.  It is short-lived.  */\n-static htab_t finally_tree;\n+static hash_table <finally_tree_hasher> finally_tree;\n \n static void\n record_in_finally_tree (treemple child, gimple parent)\n {\n   struct finally_tree_node *n;\n-  void **slot;\n+  finally_tree_node **slot;\n \n   n = XNEW (struct finally_tree_node);\n   n->child = child;\n   n->parent = parent;\n \n-  slot = htab_find_slot (finally_tree, n, INSERT);\n+  slot = finally_tree.find_slot (n, INSERT);\n   gcc_assert (!*slot);\n   *slot = n;\n }\n@@ -285,7 +308,7 @@ outside_finally_tree (treemple start, gimple target)\n   do\n     {\n       n.child = start;\n-      p = (struct finally_tree_node *) htab_find (finally_tree, &n);\n+      p = finally_tree.find (&n);\n       if (!p)\n \treturn true;\n       start.g = p->parent;\n@@ -2102,7 +2125,7 @@ lower_eh_constructs (void)\n   if (bodyp == NULL)\n     return 0;\n \n-  finally_tree = htab_create (31, struct_ptr_hash, struct_ptr_eq, free);\n+  finally_tree.create (31);\n   eh_region_may_contain_throw_map = BITMAP_ALLOC (NULL);\n   memset (&null_state, 0, sizeof (null_state));\n \n@@ -2120,7 +2143,7 @@ lower_eh_constructs (void)\n      didn't change its value, and we don't have to re-set the function.  */\n   gcc_assert (bodyp == gimple_body (current_function_decl));\n \n-  htab_delete (finally_tree);\n+  finally_tree.dispose ();\n   BITMAP_FREE (eh_region_may_contain_throw_map);\n   eh_seq = NULL;\n "}, {"sha": "01fe3633182346357b57fb2453213df248f50610", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -282,12 +282,6 @@ struct int_tree_map {\n   tree to;\n };\n \n-extern unsigned int int_tree_map_hash (const void *);\n-extern int int_tree_map_eq (const void *, const void *);\n-\n-extern unsigned int uid_decl_map_hash (const void *);\n-extern int uid_decl_map_eq (const void *, const void *);\n-\n #define num_ssa_names (vec_safe_length (cfun->gimple_df->ssa_names))\n #define ssa_name(i) ((*cfun->gimple_df->ssa_names)[(i)])\n "}, {"sha": "e403c9fcbe462e55b167a740a40f646791548643", "filename": "gcc/tree-hasher.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-hasher.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-hasher.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-hasher.h?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -0,0 +1,55 @@\n+/* Hash Table Helper for Trees\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Lawrence Crowl <crowl@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_HASHER_H\n+#define GCC_TREE_HASHER_H 1\n+\n+#include \"hash-table.h\"\n+#include \"tree-flow.h\"\n+\n+/* Hashtable helpers.  */\n+\n+struct int_tree_hasher : typed_free_remove <int_tree_map>\n+{\n+  typedef int_tree_map value_type;\n+  typedef int_tree_map compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Hash a UID in a int_tree_map.  */\n+\n+inline hashval_t\n+int_tree_hasher::hash (const value_type *item)\n+{\n+  return item->uid;\n+}\n+\n+/* Return true if the uid in both int tree maps are equal.  */\n+\n+inline bool\n+int_tree_hasher::equal (const value_type *a, const compare_type *b)\n+{\n+  return (a->uid == b->uid);\n+}\n+\n+typedef hash_table <int_tree_hasher> int_tree_htab_type;\n+\n+#endif /* GCC_TREE_HASHER_H  */"}, {"sha": "088fc4629700f915fd673493e93bcf1337febaeb", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 142, "deletions": 122, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"langhooks.h\"\n #include \"tree-vectorizer.h\"\n+#include \"tree-hasher.h\"\n \n /* This pass tries to distribute iterations of loops into several threads.\n    The implementation is straightforward -- for each loop we test whether its\n@@ -176,36 +177,44 @@ struct reduction_info\n \t\t\t\t   operation.  */\n };\n \n-/* Equality and hash functions for hashtab code.  */\n+/* Reduction info hashtable helpers.  */\n \n-static int\n-reduction_info_eq (const void *aa, const void *bb)\n+struct reduction_hasher : typed_free_remove <reduction_info>\n {\n-  const struct reduction_info *a = (const struct reduction_info *) aa;\n-  const struct reduction_info *b = (const struct reduction_info *) bb;\n+  typedef reduction_info value_type;\n+  typedef reduction_info compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Equality and hash functions for hashtab code.  */\n \n+inline bool\n+reduction_hasher::equal (const value_type *a, const compare_type *b)\n+{\n   return (a->reduc_phi == b->reduc_phi);\n }\n \n-static hashval_t\n-reduction_info_hash (const void *aa)\n+inline hashval_t\n+reduction_hasher::hash (const value_type *a)\n {\n-  const struct reduction_info *a = (const struct reduction_info *) aa;\n-\n   return a->reduc_version;\n }\n \n+typedef hash_table <reduction_hasher> reduction_info_table_type;\n+\n+\n static struct reduction_info *\n-reduction_phi (htab_t reduction_list, gimple phi)\n+reduction_phi (reduction_info_table_type reduction_list, gimple phi)\n {\n   struct reduction_info tmpred, *red;\n \n-  if (htab_elements (reduction_list) == 0 || phi == NULL)\n+  if (reduction_list.elements () == 0 || phi == NULL)\n     return NULL;\n \n   tmpred.reduc_phi = phi;\n   tmpred.reduc_version = gimple_uid (phi);\n-  red = (struct reduction_info *) htab_find (reduction_list, &tmpred);\n+  red = reduction_list.find (&tmpred);\n \n   return red;\n }\n@@ -220,25 +229,32 @@ struct name_to_copy_elt\n \t\t\t   value.  */\n };\n \n-/* Equality and hash functions for hashtab code.  */\n+/* Name copies hashtable helpers.  */\n \n-static int\n-name_to_copy_elt_eq (const void *aa, const void *bb)\n+struct name_to_copy_hasher : typed_free_remove <name_to_copy_elt>\n {\n-  const struct name_to_copy_elt *a = (const struct name_to_copy_elt *) aa;\n-  const struct name_to_copy_elt *b = (const struct name_to_copy_elt *) bb;\n+  typedef name_to_copy_elt value_type;\n+  typedef name_to_copy_elt compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Equality and hash functions for hashtab code.  */\n \n+inline bool\n+name_to_copy_hasher::equal (const value_type *a, const compare_type *b)\n+{\n   return a->version == b->version;\n }\n \n-static hashval_t\n-name_to_copy_elt_hash (const void *aa)\n+inline hashval_t\n+name_to_copy_hasher::hash (const value_type *a)\n {\n-  const struct name_to_copy_elt *a = (const struct name_to_copy_elt *) aa;\n-\n   return (hashval_t) a->version;\n }\n \n+typedef hash_table <name_to_copy_hasher> name_to_copy_table_type;\n+\n /* A transformation matrix, which is a self-contained ROWSIZE x COLSIZE\n    matrix.  Rather than use floats, we simply keep a single DENOMINATOR that\n    represents the denominator for every element in the matrix.  */\n@@ -445,11 +461,11 @@ loop_has_blocks_with_irreducible_flag (struct loop *loop)\n    right before GSI.  */\n \n static tree\n-take_address_of (tree obj, tree type, edge entry, htab_t decl_address,\n-\t\t gimple_stmt_iterator *gsi)\n+take_address_of (tree obj, tree type, edge entry,\n+\t\t int_tree_htab_type decl_address, gimple_stmt_iterator *gsi)\n {\n   int uid;\n-  void **dslot;\n+  int_tree_map **dslot;\n   struct int_tree_map ielt, *nielt;\n   tree *var_p, name, addr;\n   gimple stmt;\n@@ -472,7 +488,7 @@ take_address_of (tree obj, tree type, edge entry, htab_t decl_address,\n      on it.  */\n   uid = DECL_UID (TREE_OPERAND (TREE_OPERAND (*var_p, 0), 0));\n   ielt.uid = uid;\n-  dslot = htab_find_slot_with_hash (decl_address, &ielt, uid, INSERT);\n+  dslot = decl_address.find_slot_with_hash (&ielt, uid, INSERT);\n   if (!*dslot)\n     {\n       if (gsi == NULL)\n@@ -490,7 +506,7 @@ take_address_of (tree obj, tree type, edge entry, htab_t decl_address,\n       *dslot = nielt;\n     }\n   else\n-    name = ((struct int_tree_map *) *dslot)->to;\n+    name = (*dslot)->to;\n \n   /* Express the address in terms of the canonical SSA name.  */\n   TREE_OPERAND (*var_p, 0) = name;\n@@ -517,15 +533,14 @@ take_address_of (tree obj, tree type, edge entry, htab_t decl_address,\n    for reduction described in SLOT, and place it at the preheader of\n    the loop described in DATA.  */\n \n-static int\n-initialize_reductions (void **slot, void *data)\n+int\n+initialize_reductions (reduction_info **slot, struct loop *loop)\n {\n   tree init, c;\n   tree bvar, type, arg;\n   edge e;\n \n-  struct reduction_info *const reduc = (struct reduction_info *) *slot;\n-  struct loop *loop = (struct loop *) data;\n+  struct reduction_info *const reduc = *slot;\n \n   /* Create initialization in preheader:\n      reduction_variable = initialization value of reduction.  */\n@@ -567,7 +582,7 @@ struct elv_data\n {\n   struct walk_stmt_info info;\n   edge entry;\n-  htab_t decl_address;\n+  int_tree_htab_type decl_address;\n   gimple_stmt_iterator *gsi;\n   bool changed;\n   bool reset;\n@@ -657,7 +672,7 @@ eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n \n static void\n eliminate_local_variables_stmt (edge entry, gimple_stmt_iterator *gsi,\n-\t\t\t\thtab_t decl_address)\n+\t\t\t\tint_tree_htab_type decl_address)\n {\n   struct elv_data dta;\n   gimple stmt = gsi_stmt (*gsi);\n@@ -709,8 +724,8 @@ eliminate_local_variables (edge entry, edge exit)\n   unsigned i;\n   gimple_stmt_iterator gsi;\n   bool has_debug_stmt = false;\n-  htab_t decl_address = htab_create (10, int_tree_map_hash, int_tree_map_eq,\n-\t\t\t\t     free);\n+  int_tree_htab_type decl_address;\n+  decl_address.create (10);\n   basic_block entry_bb = entry->src;\n   basic_block exit_bb = exit->dest;\n \n@@ -734,7 +749,7 @@ eliminate_local_variables (edge entry, edge exit)\n \t  if (gimple_debug_bind_p (gsi_stmt (gsi)))\n \t    eliminate_local_variables_stmt (entry, &gsi, decl_address);\n \n-  htab_delete (decl_address);\n+  decl_address.dispose ();\n   body.release ();\n }\n \n@@ -773,25 +788,25 @@ expr_invariant_in_region_p (edge entry, edge exit, tree expr)\n    duplicated, storing the copies in DECL_COPIES.  */\n \n static tree\n-separate_decls_in_region_name (tree name,\n-\t\t\t       htab_t name_copies, htab_t decl_copies,\n-\t\t\t       bool copy_name_p)\n+separate_decls_in_region_name (tree name, name_to_copy_table_type name_copies,\n+\t\t\t       int_tree_htab_type decl_copies, bool copy_name_p)\n {\n   tree copy, var, var_copy;\n   unsigned idx, uid, nuid;\n   struct int_tree_map ielt, *nielt;\n   struct name_to_copy_elt elt, *nelt;\n-  void **slot, **dslot;\n+  name_to_copy_elt **slot;\n+  int_tree_map **dslot;\n \n   if (TREE_CODE (name) != SSA_NAME)\n     return name;\n \n   idx = SSA_NAME_VERSION (name);\n   elt.version = idx;\n-  slot = htab_find_slot_with_hash (name_copies, &elt, idx,\n-\t\t\t\t   copy_name_p ? INSERT : NO_INSERT);\n+  slot = name_copies.find_slot_with_hash (&elt, idx,\n+\t\t\t\t\t  copy_name_p ? INSERT : NO_INSERT);\n   if (slot && *slot)\n-    return ((struct name_to_copy_elt *) *slot)->new_name;\n+    return (*slot)->new_name;\n \n   if (copy_name_p)\n     {\n@@ -814,7 +829,7 @@ separate_decls_in_region_name (tree name,\n \n   uid = DECL_UID (var);\n   ielt.uid = uid;\n-  dslot = htab_find_slot_with_hash (decl_copies, &ielt, uid, INSERT);\n+  dslot = decl_copies.find_slot_with_hash (&ielt, uid, INSERT);\n   if (!*dslot)\n     {\n       var_copy = create_tmp_var (TREE_TYPE (var), get_name (var));\n@@ -828,7 +843,7 @@ separate_decls_in_region_name (tree name,\n          it again.  */\n       nuid = DECL_UID (var_copy);\n       ielt.uid = nuid;\n-      dslot = htab_find_slot_with_hash (decl_copies, &ielt, nuid, INSERT);\n+      dslot = decl_copies.find_slot_with_hash (&ielt, nuid, INSERT);\n       gcc_assert (!*dslot);\n       nielt = XNEW (struct int_tree_map);\n       nielt->uid = nuid;\n@@ -851,7 +866,8 @@ separate_decls_in_region_name (tree name,\n \n static void\n separate_decls_in_region_stmt (edge entry, edge exit, gimple stmt,\n-\t\t\t       htab_t name_copies, htab_t decl_copies)\n+\t\t\t       name_to_copy_table_type name_copies,\n+\t\t\t       int_tree_htab_type decl_copies)\n {\n   use_operand_p use;\n   def_operand_p def;\n@@ -889,15 +905,17 @@ separate_decls_in_region_stmt (edge entry, edge exit, gimple stmt,\n    replacement decls are stored in DECL_COPIES.  */\n \n static bool\n-separate_decls_in_region_debug (gimple stmt, htab_t name_copies,\n-\t\t\t\thtab_t decl_copies)\n+separate_decls_in_region_debug (gimple stmt,\n+\t\t\t\tname_to_copy_table_type name_copies,\n+\t\t\t\tint_tree_htab_type decl_copies)\n {\n   use_operand_p use;\n   ssa_op_iter oi;\n   tree var, name;\n   struct int_tree_map ielt;\n   struct name_to_copy_elt elt;\n-  void **slot, **dslot;\n+  name_to_copy_elt **slot;\n+  int_tree_map **dslot;\n \n   if (gimple_debug_bind_p (stmt))\n     var = gimple_debug_bind_get_var (stmt);\n@@ -909,7 +927,7 @@ separate_decls_in_region_debug (gimple stmt, htab_t name_copies,\n     return true;\n   gcc_assert (DECL_P (var) && SSA_VAR_P (var));\n   ielt.uid = DECL_UID (var);\n-  dslot = htab_find_slot_with_hash (decl_copies, &ielt, ielt.uid, NO_INSERT);\n+  dslot = decl_copies.find_slot_with_hash (&ielt, ielt.uid, NO_INSERT);\n   if (!dslot)\n     return true;\n   if (gimple_debug_bind_p (stmt))\n@@ -924,15 +942,15 @@ separate_decls_in_region_debug (gimple stmt, htab_t name_copies,\n       continue;\n \n     elt.version = SSA_NAME_VERSION (name);\n-    slot = htab_find_slot_with_hash (name_copies, &elt, elt.version, NO_INSERT);\n+    slot = name_copies.find_slot_with_hash (&elt, elt.version, NO_INSERT);\n     if (!slot)\n       {\n \tgimple_debug_bind_reset_value (stmt);\n \tupdate_stmt (stmt);\n \tbreak;\n       }\n \n-    SET_USE (use, ((struct name_to_copy_elt *) *slot)->new_name);\n+    SET_USE (use, (*slot)->new_name);\n   }\n \n   return false;\n@@ -941,12 +959,11 @@ separate_decls_in_region_debug (gimple stmt, htab_t name_copies,\n /* Callback for htab_traverse.  Adds a field corresponding to the reduction\n    specified in SLOT. The type is passed in DATA.  */\n \n-static int\n-add_field_for_reduction (void **slot, void *data)\n+int\n+add_field_for_reduction (reduction_info **slot, tree type)\n {\n \n-  struct reduction_info *const red = (struct reduction_info *) *slot;\n-  tree const type = (tree) data;\n+  struct reduction_info *const red = *slot;\n   tree var = SSA_NAME_VAR (gimple_assign_lhs (red->reduc_stmt));\n   tree field = build_decl (gimple_location (red->reduc_stmt),\n \t\t\t   FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n@@ -961,11 +978,10 @@ add_field_for_reduction (void **slot, void *data)\n /* Callback for htab_traverse.  Adds a field corresponding to a ssa name\n    described in SLOT. The type is passed in DATA.  */\n \n-static int\n-add_field_for_name (void **slot, void *data)\n+int\n+add_field_for_name (name_to_copy_elt **slot, tree type)\n {\n-  struct name_to_copy_elt *const elt = (struct name_to_copy_elt *) *slot;\n-  tree type = (tree) data;\n+  struct name_to_copy_elt *const elt = *slot;\n   tree name = ssa_name (elt->version);\n   tree field = build_decl (UNKNOWN_LOCATION,\n \t\t\t   FIELD_DECL, SSA_NAME_IDENTIFIER (name),\n@@ -984,11 +1000,10 @@ add_field_for_name (void **slot, void *data)\n    The phi's result will be stored in NEW_PHI field of the\n    reduction's data structure.  */\n \n-static int\n-create_phi_for_local_result (void **slot, void *data)\n+int\n+create_phi_for_local_result (reduction_info **slot, struct loop *loop)\n {\n-  struct reduction_info *const reduc = (struct reduction_info *) *slot;\n-  const struct loop *const loop = (const struct loop *) data;\n+  struct reduction_info *const reduc = *slot;\n   edge e;\n   gimple new_phi;\n   basic_block store_bb;\n@@ -1034,11 +1049,10 @@ struct clsn_data\n    DATA annotates the place in memory the atomic operation relates to,\n    and the basic block it needs to be generated in.  */\n \n-static int\n-create_call_for_reduction_1 (void **slot, void *data)\n+int\n+create_call_for_reduction_1 (reduction_info **slot, struct clsn_data *clsn_data)\n {\n-  struct reduction_info *const reduc = (struct reduction_info *) *slot;\n-  struct clsn_data *const clsn_data = (struct clsn_data *) data;\n+  struct reduction_info *const reduc = *slot;\n   gimple_stmt_iterator gsi;\n   tree type = TREE_TYPE (PHI_RESULT (reduc->reduc_phi));\n   tree load_struct;\n@@ -1087,23 +1101,24 @@ create_call_for_reduction_1 (void **slot, void *data)\n    LD_ST_DATA describes the shared data structure where\n    shared data is stored in and loaded from.  */\n static void\n-create_call_for_reduction (struct loop *loop, htab_t reduction_list,\n+create_call_for_reduction (struct loop *loop,\n+\t\t\t   reduction_info_table_type reduction_list,\n \t\t\t   struct clsn_data *ld_st_data)\n {\n-  htab_traverse (reduction_list, create_phi_for_local_result, loop);\n+  reduction_list.traverse <struct loop *, create_phi_for_local_result> (loop);\n   /* Find the fallthru edge from GIMPLE_OMP_CONTINUE.  */\n   ld_st_data->load_bb = FALLTHRU_EDGE (loop->latch)->dest;\n-  htab_traverse (reduction_list, create_call_for_reduction_1, ld_st_data);\n+  reduction_list\n+    .traverse <struct clsn_data *, create_call_for_reduction_1> (ld_st_data);\n }\n \n /* Callback for htab_traverse.  Loads the final reduction value at the\n    join point of all threads, and inserts it in the right place.  */\n \n-static int\n-create_loads_for_reductions (void **slot, void *data)\n+int\n+create_loads_for_reductions (reduction_info **slot, struct clsn_data *clsn_data)\n {\n-  struct reduction_info *const red = (struct reduction_info *) *slot;\n-  struct clsn_data *const clsn_data = (struct clsn_data *) data;\n+  struct reduction_info *const red = *slot;\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n   tree type = TREE_TYPE (gimple_assign_lhs (red->reduc_stmt));\n@@ -1137,7 +1152,7 @@ create_loads_for_reductions (void **slot, void *data)\n    REDUCTION_LIST describes the list of reductions that the\n    loads should be generated for.  */\n static void\n-create_final_loads_for_reduction (htab_t reduction_list,\n+create_final_loads_for_reduction (reduction_info_table_type reduction_list,\n \t\t\t\t  struct clsn_data *ld_st_data)\n {\n   gimple_stmt_iterator gsi;\n@@ -1151,7 +1166,8 @@ create_final_loads_for_reduction (htab_t reduction_list,\n   gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n   SSA_NAME_DEF_STMT (ld_st_data->load) = stmt;\n \n-  htab_traverse (reduction_list, create_loads_for_reductions, ld_st_data);\n+  reduction_list\n+    .traverse <struct clsn_data *, create_loads_for_reductions> (ld_st_data);\n \n }\n \n@@ -1161,11 +1177,10 @@ create_final_loads_for_reduction (htab_t reduction_list,\n   The reduction is specified in SLOT. The store information is\n   passed in DATA.  */\n \n-static int\n-create_stores_for_reduction (void **slot, void *data)\n+int\n+create_stores_for_reduction (reduction_info **slot, struct clsn_data *clsn_data)\n {\n-  struct reduction_info *const red = (struct reduction_info *) *slot;\n-  struct clsn_data *const clsn_data = (struct clsn_data *) data;\n+  struct reduction_info *const red = *slot;\n   tree t;\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n@@ -1183,11 +1198,11 @@ create_stores_for_reduction (void **slot, void *data)\n    store to a field of STORE in STORE_BB for the ssa name and its duplicate\n    specified in SLOT.  */\n \n-static int\n-create_loads_and_stores_for_name (void **slot, void *data)\n+int\n+create_loads_and_stores_for_name (name_to_copy_elt **slot,\n+\t\t\t\t  struct clsn_data *clsn_data)\n {\n-  struct name_to_copy_elt *const elt = (struct name_to_copy_elt *) *slot;\n-  struct clsn_data *const clsn_data = (struct clsn_data *) data;\n+  struct name_to_copy_elt *const elt = *slot;\n   tree t;\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n@@ -1244,17 +1259,18 @@ create_loads_and_stores_for_name (void **slot, void *data)\n    in LOOP.  */\n \n static void\n-separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n+separate_decls_in_region (edge entry, edge exit,\n+\t\t\t  reduction_info_table_type reduction_list,\n \t\t\t  tree *arg_struct, tree *new_arg_struct,\n \t\t\t  struct clsn_data *ld_st_data)\n \n {\n   basic_block bb1 = split_edge (entry);\n   basic_block bb0 = single_pred (bb1);\n-  htab_t name_copies = htab_create (10, name_to_copy_elt_hash,\n-\t\t\t\t    name_to_copy_elt_eq, free);\n-  htab_t decl_copies = htab_create (10, int_tree_map_hash, int_tree_map_eq,\n-\t\t\t\t    free);\n+  name_to_copy_table_type name_copies;\n+  name_copies.create (10);\n+  int_tree_htab_type decl_copies;\n+  decl_copies.create (10);\n   unsigned i;\n   tree type, type_name, nvar;\n   gimple_stmt_iterator gsi;\n@@ -1320,7 +1336,7 @@ separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n \n   body.release ();\n \n-  if (htab_elements (name_copies) == 0 && htab_elements (reduction_list) == 0)\n+  if (name_copies.elements () == 0 && reduction_list.elements () == 0)\n     {\n       /* It may happen that there is nothing to copy (if there are only\n          loop carried and external variables in the loop).  */\n@@ -1336,12 +1352,11 @@ separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n \t\t\t      type);\n       TYPE_NAME (type) = type_name;\n \n-      htab_traverse (name_copies, add_field_for_name, type);\n-      if (reduction_list && htab_elements (reduction_list) > 0)\n+      name_copies.traverse <tree, add_field_for_name> (type);\n+      if (reduction_list.is_created () && reduction_list.elements () > 0)\n \t{\n \t  /* Create the fields for reductions.  */\n-\t  htab_traverse (reduction_list, add_field_for_reduction,\n-                         type);\n+\t  reduction_list.traverse <tree, add_field_for_reduction> (type);\n \t}\n       layout_type (type);\n \n@@ -1355,24 +1370,26 @@ separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n       ld_st_data->store_bb = bb0;\n       ld_st_data->load_bb = bb1;\n \n-      htab_traverse (name_copies, create_loads_and_stores_for_name,\n-\t\t     ld_st_data);\n+      name_copies\n+\t.traverse <struct clsn_data *, create_loads_and_stores_for_name>\n+\t\t  (ld_st_data);\n \n       /* Load the calculation from memory (after the join of the threads).  */\n \n-      if (reduction_list && htab_elements (reduction_list) > 0)\n+      if (reduction_list.is_created () && reduction_list.elements () > 0)\n \t{\n-\t  htab_traverse (reduction_list, create_stores_for_reduction,\n-                        ld_st_data);\n+\t  reduction_list\n+\t    .traverse <struct clsn_data *, create_stores_for_reduction>\n+\t\t      (ld_st_data);\n \t  clsn_data.load = make_ssa_name (nvar, NULL);\n \t  clsn_data.load_bb = exit->dest;\n \t  clsn_data.store = ld_st_data->store;\n \t  create_final_loads_for_reduction (reduction_list, &clsn_data);\n \t}\n     }\n \n-  htab_delete (decl_copies);\n-  htab_delete (name_copies);\n+  decl_copies.dispose ();\n+  name_copies.dispose ();\n }\n \n /* Bitmap containing uids of functions created by parallelization.  We cannot\n@@ -1461,7 +1478,9 @@ create_loop_fn (location_t loc)\n    REDUCTION_LIST describes the reductions in LOOP.  */\n \n static void\n-transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit)\n+transform_to_exit_first_loop (struct loop *loop,\n+\t\t\t      reduction_info_table_type reduction_list,\n+\t\t\t      tree nit)\n {\n   basic_block *bbs, *nbbs, ex_bb, orig_header;\n   unsigned n;\n@@ -1530,7 +1549,7 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n          PHI_RESULT of this phi is the resulting value of the reduction\n          variable when exiting the loop.  */\n \n-      if (htab_elements (reduction_list) > 0)\n+      if (reduction_list.elements () > 0)\n \t{\n \t  struct reduction_info *red;\n \n@@ -1708,7 +1727,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n    REDUCTION_LIST describes the reductions existent in the LOOP.  */\n \n static void\n-gen_parallel_loop (struct loop *loop, htab_t reduction_list,\n+gen_parallel_loop (struct loop *loop, reduction_info_table_type reduction_list,\n \t\t   unsigned n_threads, struct tree_niter_desc *niter)\n {\n   loop_iterator li;\n@@ -1834,8 +1853,8 @@ gen_parallel_loop (struct loop *loop, htab_t reduction_list,\n   transform_to_exit_first_loop (loop, reduction_list, nit);\n \n   /* Generate initializations for reductions.  */\n-  if (htab_elements (reduction_list) > 0)\n-    htab_traverse (reduction_list, initialize_reductions, loop);\n+  if (reduction_list.elements () > 0)\n+    reduction_list.traverse <struct loop *, initialize_reductions> (loop);\n \n   /* Eliminate the references to local variables from the loop.  */\n   gcc_assert (single_exit (loop));\n@@ -1855,7 +1874,7 @@ gen_parallel_loop (struct loop *loop, htab_t reduction_list,\n     loc = gimple_location (cond_stmt);\n   parallel_head = create_parallel_loop (loop, create_loop_fn (loc), arg_struct,\n \t\t\t\t\tnew_arg_struct, n_threads, loc);\n-  if (htab_elements (reduction_list) > 0)\n+  if (reduction_list.elements () > 0)\n     create_call_for_reduction (loop, reduction_list, &clsn_data);\n \n   scev_reset ();\n@@ -1902,9 +1921,10 @@ loop_has_vector_phi_nodes (struct loop *loop ATTRIBUTE_UNUSED)\n    and PHI, insert it to the REDUCTION_LIST.  */\n \n static void\n-build_new_reduction (htab_t reduction_list, gimple reduc_stmt, gimple phi)\n+build_new_reduction (reduction_info_table_type reduction_list,\n+\t\t     gimple reduc_stmt, gimple phi)\n {\n-  PTR *slot;\n+  reduction_info **slot;\n   struct reduction_info *new_reduction;\n \n   gcc_assert (reduc_stmt);\n@@ -1923,24 +1943,24 @@ build_new_reduction (htab_t reduction_list, gimple reduc_stmt, gimple phi)\n   new_reduction->reduc_phi = phi;\n   new_reduction->reduc_version = SSA_NAME_VERSION (gimple_phi_result (phi));\n   new_reduction->reduction_code = gimple_assign_rhs_code (reduc_stmt);\n-  slot = htab_find_slot (reduction_list, new_reduction, INSERT);\n+  slot = reduction_list.find_slot (new_reduction, INSERT);\n   *slot = new_reduction;\n }\n \n /* Callback for htab_traverse.  Sets gimple_uid of reduc_phi stmts.  */\n \n-static int\n-set_reduc_phi_uids (void **slot, void *data ATTRIBUTE_UNUSED)\n+int\n+set_reduc_phi_uids (reduction_info **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  struct reduction_info *const red = (struct reduction_info *) *slot;\n+  struct reduction_info *const red = *slot;\n   gimple_set_uid (red->reduc_phi, red->reduc_version);\n   return 1;\n }\n \n /* Detect all reductions in the LOOP, insert them into REDUCTION_LIST.  */\n \n static void\n-gather_scalar_reductions (loop_p loop, htab_t reduction_list)\n+gather_scalar_reductions (loop_p loop, reduction_info_table_type reduction_list)\n {\n   gimple_stmt_iterator gsi;\n   loop_vec_info simple_loop_info;\n@@ -1972,7 +1992,7 @@ gather_scalar_reductions (loop_p loop, htab_t reduction_list)\n   /* As gimple_uid is used by the vectorizer in between vect_analyze_loop_form\n      and destroy_loop_vec_info, we can set gimple_uid of reduc_phi stmts\n      only now.  */\n-  htab_traverse (reduction_list, set_reduc_phi_uids, NULL);\n+  reduction_list.traverse <void *, set_reduc_phi_uids> (NULL);\n }\n \n /* Try to initialize NITER for code generation part.  */\n@@ -2001,7 +2021,8 @@ try_get_loop_niter (loop_p loop, struct tree_niter_desc *niter)\n    REDUCTION_LIST describes the reductions.  */\n \n static bool\n-try_create_reduction_list (loop_p loop, htab_t reduction_list)\n+try_create_reduction_list (loop_p loop,\n+\t\t\t   reduction_info_table_type reduction_list)\n {\n   edge exit = single_dom_exit (loop);\n   gimple_stmt_iterator gsi;\n@@ -2032,7 +2053,7 @@ try_create_reduction_list (loop_p loop, htab_t reduction_list)\n \t      fprintf (dump_file,\n \t\t       \"  checking if it a part of reduction pattern:  \\n\");\n \t    }\n-\t  if (htab_elements (reduction_list) == 0)\n+\t  if (reduction_list.elements () == 0)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file,\n@@ -2106,7 +2127,7 @@ parallelize_loops (void)\n   struct loop *loop;\n   struct tree_niter_desc niter_desc;\n   loop_iterator li;\n-  htab_t reduction_list;\n+  reduction_info_table_type reduction_list;\n   struct obstack parloop_obstack;\n   HOST_WIDE_INT estimated;\n   LOC loop_loc;\n@@ -2118,13 +2139,12 @@ parallelize_loops (void)\n     return false;\n \n   gcc_obstack_init (&parloop_obstack);\n-  reduction_list = htab_create (10, reduction_info_hash,\n-\t\t\t\t     reduction_info_eq, free);\n+  reduction_list.create (10);\n   init_stmt_vec_info_vec ();\n \n   FOR_EACH_LOOP (li, loop, 0)\n     {\n-      htab_empty (reduction_list);\n+      reduction_list.empty ();\n       if (dump_file && (dump_flags & TDF_DETAILS))\n       {\n         fprintf (dump_file, \"Trying loop %d as candidate\\n\",loop->num);\n@@ -2204,7 +2224,7 @@ parallelize_loops (void)\n     }\n \n   free_stmt_vec_info_vec ();\n-  htab_delete (reduction_list);\n+  reduction_list.dispose ();\n   obstack_free (&parloop_obstack, NULL);\n \n   /* Parallelization will cause new function calls to be inserted through"}, {"sha": "d5dde5fedb70dba0a239a411ae6124abbbc0b6e0", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 71, "deletions": 25, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -256,6 +256,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"gimple-pretty-print.h\"\n #include \"tree-flow.h\"\n #include \"cfgloop.h\"\n@@ -317,15 +318,15 @@ new_scev_info_str (basic_block instantiated_below, tree var)\n \n /* Computes a hash function for database element ELT.  */\n \n-static hashval_t\n+static inline hashval_t\n hash_scev_info (const void *elt)\n {\n   return SSA_NAME_VERSION (((const struct scev_info_str *) elt)->var);\n }\n \n /* Compares database elements E1 and E2.  */\n \n-static int\n+static inline int\n eq_scev_info (const void *e1, const void *e2)\n {\n   const struct scev_info_str *elt1 = (const struct scev_info_str *) e1;\n@@ -343,6 +344,39 @@ del_scev_info (void *e)\n   ggc_free (e);\n }\n \n+/* Hashtable helpers.  */\n+\n+struct scev_info_hasher\n+{\n+  typedef scev_info_str value_type;\n+  typedef scev_info_str compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n+\n+inline hashval_t\n+scev_info_hasher::hash (const value_type *elt)\n+{\n+  return hash_scev_info (elt);\n+}\n+\n+inline bool\n+scev_info_hasher::equal (const value_type *elt1, const compare_type *elt2)\n+{\n+  return eq_scev_info (elt1, elt2);\n+}\n+\n+/* Deletes database element E.  */\n+\n+inline void\n+scev_info_hasher::remove (value_type *e)\n+{\n+  del_scev_info (e);\n+}\n+\n+typedef hash_table <scev_info_hasher> scev_info_hash_table_type;\n+\n /* Get the scalar evolution of VAR for INSTANTIATED_BELOW basic block.\n    A first query on VAR returns chrec_not_analyzed_yet.  */\n \n@@ -2048,14 +2082,14 @@ analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n    INSTANTIATED_BELOW block.  */\n \n static tree\n-get_instantiated_value (htab_t cache, basic_block instantiated_below,\n-\t\t\ttree version)\n+get_instantiated_value (scev_info_hash_table_type cache,\n+\t\t\tbasic_block instantiated_below, tree version)\n {\n   struct scev_info_str *info, pattern;\n \n   pattern.var = version;\n   pattern.instantiated_below = instantiated_below;\n-  info = (struct scev_info_str *) htab_find (cache, &pattern);\n+  info = cache.find (&pattern);\n \n   if (info)\n     return info->chrec;\n@@ -2067,19 +2101,19 @@ get_instantiated_value (htab_t cache, basic_block instantiated_below,\n    INSTANTIATED_BELOW to VAL.  */\n \n static void\n-set_instantiated_value (htab_t cache, basic_block instantiated_below,\n-\t\t\ttree version, tree val)\n+set_instantiated_value (scev_info_hash_table_type cache,\n+\t\t\tbasic_block instantiated_below, tree version, tree val)\n {\n   struct scev_info_str *info, pattern;\n-  PTR *slot;\n+  scev_info_str **slot;\n \n   pattern.var = version;\n   pattern.instantiated_below = instantiated_below;\n-  slot = htab_find_slot (cache, &pattern, INSERT);\n+  slot = cache.find_slot (&pattern, INSERT);\n \n   if (!*slot)\n     *slot = new_scev_info_str (instantiated_below, version);\n-  info = (struct scev_info_str *) *slot;\n+  info = *slot;\n   info->chrec = val;\n }\n \n@@ -2114,7 +2148,7 @@ loop_closed_phi_def (tree var)\n }\n \n static tree instantiate_scev_r (basic_block, struct loop *, struct loop *,\n-\t\t\t\ttree, bool, htab_t, int);\n+\t\t\t\ttree, bool, scev_info_hash_table_type, int);\n \n /* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n    and EVOLUTION_LOOP, that were left under a symbolic form.\n@@ -2134,7 +2168,8 @@ static tree\n instantiate_scev_name (basic_block instantiate_below,\n \t\t       struct loop *evolution_loop, struct loop *inner_loop,\n \t\t       tree chrec,\n-\t\t       bool fold_conversions, htab_t cache, int size_expr)\n+\t\t       bool fold_conversions, scev_info_hash_table_type cache,\n+\t\t       int size_expr)\n {\n   tree res;\n   struct loop *def_loop;\n@@ -2236,7 +2271,8 @@ static tree\n instantiate_scev_poly (basic_block instantiate_below,\n \t\t       struct loop *evolution_loop, struct loop *,\n \t\t       tree chrec,\n-\t\t       bool fold_conversions, htab_t cache, int size_expr)\n+\t\t       bool fold_conversions, scev_info_hash_table_type cache,\n+\t\t       int size_expr)\n {\n   tree op1;\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n@@ -2282,7 +2318,8 @@ instantiate_scev_binary (basic_block instantiate_below,\n \t\t\t struct loop *evolution_loop, struct loop *inner_loop,\n \t\t\t tree chrec, enum tree_code code,\n \t\t\t tree type, tree c0, tree c1,\n-\t\t\t bool fold_conversions, htab_t cache, int size_expr)\n+\t\t\t bool fold_conversions, scev_info_hash_table_type cache,\n+\t\t\t int size_expr)\n {\n   tree op1;\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop, inner_loop,\n@@ -2341,7 +2378,8 @@ static tree\n instantiate_array_ref (basic_block instantiate_below,\n \t\t       struct loop *evolution_loop, struct loop *inner_loop,\n \t\t       tree chrec,\n-\t\t       bool fold_conversions, htab_t cache, int size_expr)\n+\t\t       bool fold_conversions, scev_info_hash_table_type cache,\n+\t\t       int size_expr)\n {\n   tree res;\n   tree index = TREE_OPERAND (chrec, 1);\n@@ -2380,7 +2418,8 @@ instantiate_scev_convert (basic_block instantiate_below,\n \t\t\t  struct loop *evolution_loop, struct loop *inner_loop,\n \t\t\t  tree chrec,\n \t\t\t  tree type, tree op,\n-\t\t\t  bool fold_conversions, htab_t cache, int size_expr)\n+\t\t\t  bool fold_conversions,\n+\t\t\t  scev_info_hash_table_type cache, int size_expr)\n {\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n \t\t\t\t inner_loop, op,\n@@ -2429,7 +2468,8 @@ instantiate_scev_not (basic_block instantiate_below,\n \t\t      struct loop *evolution_loop, struct loop *inner_loop,\n \t\t      tree chrec,\n \t\t      enum tree_code code, tree type, tree op,\n-\t\t      bool fold_conversions, htab_t cache, int size_expr)\n+\t\t      bool fold_conversions, scev_info_hash_table_type cache,\n+\t\t      int size_expr)\n {\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n \t\t\t\t inner_loop, op,\n@@ -2478,7 +2518,8 @@ static tree\n instantiate_scev_3 (basic_block instantiate_below,\n \t\t    struct loop *evolution_loop, struct loop *inner_loop,\n \t\t    tree chrec,\n-\t\t    bool fold_conversions, htab_t cache, int size_expr)\n+\t\t    bool fold_conversions, scev_info_hash_table_type cache,\n+\t\t    int size_expr)\n {\n   tree op1, op2;\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n@@ -2526,7 +2567,8 @@ static tree\n instantiate_scev_2 (basic_block instantiate_below,\n \t\t    struct loop *evolution_loop, struct loop *inner_loop,\n \t\t    tree chrec,\n-\t\t    bool fold_conversions, htab_t cache, int size_expr)\n+\t\t    bool fold_conversions, scev_info_hash_table_type cache,\n+\t\t    int size_expr)\n {\n   tree op1;\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n@@ -2566,7 +2608,8 @@ static tree\n instantiate_scev_1 (basic_block instantiate_below,\n \t\t    struct loop *evolution_loop, struct loop *inner_loop,\n \t\t    tree chrec,\n-\t\t    bool fold_conversions, htab_t cache, int size_expr)\n+\t\t    bool fold_conversions, scev_info_hash_table_type cache,\n+\t\t    int size_expr)\n {\n   tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n \t\t\t\t inner_loop, TREE_OPERAND (chrec, 0),\n@@ -2599,7 +2642,8 @@ static tree\n instantiate_scev_r (basic_block instantiate_below,\n \t\t    struct loop *evolution_loop, struct loop *inner_loop,\n \t\t    tree chrec,\n-\t\t    bool fold_conversions, htab_t cache, int size_expr)\n+\t\t    bool fold_conversions, scev_info_hash_table_type cache,\n+\t\t    int size_expr)\n {\n   /* Give up if the expression is larger than the MAX that we allow.  */\n   if (size_expr++ > PARAM_VALUE (PARAM_SCEV_MAX_EXPR_SIZE))\n@@ -2705,7 +2749,8 @@ instantiate_scev (basic_block instantiate_below, struct loop *evolution_loop,\n \t\t  tree chrec)\n {\n   tree res;\n-  htab_t cache = htab_create (10, hash_scev_info, eq_scev_info, del_scev_info);\n+  scev_info_hash_table_type cache;\n+  cache.create (10);\n \n   if (dump_file && (dump_flags & TDF_SCEV))\n     {\n@@ -2727,7 +2772,7 @@ instantiate_scev (basic_block instantiate_below, struct loop *evolution_loop,\n       fprintf (dump_file, \"))\\n\");\n     }\n \n-  htab_delete (cache);\n+  cache.dispose ();\n \n   return res;\n }\n@@ -2740,10 +2785,11 @@ instantiate_scev (basic_block instantiate_below, struct loop *evolution_loop,\n tree\n resolve_mixers (struct loop *loop, tree chrec)\n {\n-  htab_t cache = htab_create (10, hash_scev_info, eq_scev_info, del_scev_info);\n+  scev_info_hash_table_type cache;\n+  cache.create (10);\n   tree ret = instantiate_scev_r (block_before_loop (loop), loop, NULL,\n \t\t\t\t chrec, true, cache, 0);\n-  htab_delete (cache);\n+  cache.dispose ();\n   return ret;\n }\n "}, {"sha": "23a4f142783519ef6639e4db7b2baf0580e51192", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -74,6 +74,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"alloc-pool.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n@@ -269,18 +270,44 @@ static alloc_pool link_pool;\n /* Base (tree) -> Vector (vec<access_p> *) map.  */\n static struct pointer_map_t *base_access_vec;\n \n+/* Candidate hash table helpers.  */\n+\n+struct uid_decl_hasher : typed_noop_remove <tree_node>\n+{\n+  typedef tree_node value_type;\n+  typedef tree_node compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Hash a tree in a uid_decl_map.  */\n+\n+inline hashval_t\n+uid_decl_hasher::hash (const value_type *item)\n+{\n+  return item->decl_minimal.uid;\n+}\n+\n+/* Return true if the DECL_UID in both trees are equal.  */\n+\n+inline bool\n+uid_decl_hasher::equal (const value_type *a, const compare_type *b)\n+{\n+  return (a->decl_minimal.uid == b->decl_minimal.uid);\n+}\n+\n /* Set of candidates.  */\n static bitmap candidate_bitmap;\n-static htab_t candidates;\n+static hash_table <uid_decl_hasher> candidates;\n \n /* For a candidate UID return the candidates decl.  */\n \n static inline tree\n candidate (unsigned uid)\n {\n- struct tree_decl_minimal t;\n- t.uid = uid;\n- return (tree) htab_find_with_hash (candidates, &t, uid);\n+ tree_node t;\n+ t.decl_minimal.uid = uid;\n+ return candidates.find_with_hash (&t, static_cast <hashval_t> (uid));\n }\n \n /* Bitmap of candidates which we should try to entirely scalarize away and\n@@ -611,8 +638,7 @@ static void\n sra_initialize (void)\n {\n   candidate_bitmap = BITMAP_ALLOC (NULL);\n-  candidates = htab_create (vec_safe_length (cfun->local_decls) / 2,\n-\t\t\t    uid_decl_map_hash, uid_decl_map_eq, NULL);\n+  candidates.create (vec_safe_length (cfun->local_decls) / 2);\n   should_scalarize_away_bitmap = BITMAP_ALLOC (NULL);\n   cannot_scalarize_away_bitmap = BITMAP_ALLOC (NULL);\n   gcc_obstack_init (&name_obstack);\n@@ -642,7 +668,7 @@ static void\n sra_deinitialize (void)\n {\n   BITMAP_FREE (candidate_bitmap);\n-  htab_delete (candidates);\n+  candidates.dispose ();\n   BITMAP_FREE (should_scalarize_away_bitmap);\n   BITMAP_FREE (cannot_scalarize_away_bitmap);\n   free_alloc_pool (access_pool);\n@@ -659,9 +685,9 @@ static void\n disqualify_candidate (tree decl, const char *reason)\n {\n   if (bitmap_clear_bit (candidate_bitmap, DECL_UID (decl)))\n-    htab_clear_slot (candidates,\n-\t\t     htab_find_slot_with_hash (candidates, decl,\n-\t\t\t\t\t       DECL_UID (decl), NO_INSERT));\n+    candidates.clear_slot (candidates.find_slot_with_hash (decl,\n+\t\t\t\t\t\t\t   DECL_UID (decl),\n+\t\t\t\t\t\t\t   NO_INSERT));\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1680,7 +1706,7 @@ maybe_add_sra_candidate (tree var)\n {\n   tree type = TREE_TYPE (var);\n   const char *msg;\n-  void **slot;\n+  tree_node **slot;\n \n   if (!AGGREGATE_TYPE_P (type)) \n     {\n@@ -1728,8 +1754,8 @@ maybe_add_sra_candidate (tree var)\n     }\n \n   bitmap_set_bit (candidate_bitmap, DECL_UID (var));\n-  slot = htab_find_slot_with_hash (candidates, var, DECL_UID (var), INSERT);\n-  *slot = (void *) var;\n+  slot = candidates.find_slot_with_hash (var, DECL_UID (var), INSERT);\n+  *slot = var;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -3587,7 +3613,7 @@ find_param_candidates (void)\n        parm = DECL_CHAIN (parm))\n     {\n       tree type = TREE_TYPE (parm);\n-      void **slot;\n+      tree_node **slot;\n \n       count++;\n \n@@ -3626,9 +3652,8 @@ find_param_candidates (void)\n \tcontinue;\n \n       bitmap_set_bit (candidate_bitmap, DECL_UID (parm));\n-      slot = htab_find_slot_with_hash (candidates, parm,\n-\t\t\t\t       DECL_UID (parm), INSERT);\n-      *slot = (void *) parm;\n+      slot = candidates.find_slot_with_hash (parm, DECL_UID (parm), INSERT);\n+      *slot = parm;\n \n       ret = true;\n       if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "602289d78865a0af6efb37a35b2b19773e4eda8f", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 94, "deletions": 74, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n@@ -101,15 +102,6 @@ struct edge_info\n   vec<cond_equivalence> cond_equivalences;\n };\n \n-/* Hash table with expressions made available during the renaming process.\n-   When an assignment of the form X_i = EXPR is found, the statement is\n-   stored in this table.  If the same expression EXPR is later found on the\n-   RHS of another statement, it is replaced with X_i (thus performing\n-   global redundancy elimination).  Similarly as we pass through conditionals\n-   we record the conditional itself as having either a true or false value\n-   in this table.  */\n-static htab_t avail_exprs;\n-\n /* Stack of available expressions in AVAIL_EXPRs.  Each block pushes any\n    expressions it enters into the hash table along with a marker entry\n    (null).  When we finish processing the block, we pop off entries and\n@@ -140,6 +132,81 @@ struct expr_hash_elt\n   struct expr_hash_elt *stamp;\n };\n \n+/* Hashtable helpers.  */\n+\n+static bool hashable_expr_equal_p (const struct hashable_expr *,\n+\t\t\t\t   const struct hashable_expr *);\n+static void free_expr_hash_elt (void *);\n+\n+struct expr_elt_hasher\n+{\n+  typedef expr_hash_elt value_type;\n+  typedef expr_hash_elt compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n+\n+inline hashval_t\n+expr_elt_hasher::hash (const value_type *p)\n+{\n+  return p->hash;\n+}\n+\n+inline bool\n+expr_elt_hasher::equal (const value_type *p1, const compare_type *p2)\n+{\n+  gimple stmt1 = p1->stmt;\n+  const struct hashable_expr *expr1 = &p1->expr;\n+  const struct expr_hash_elt *stamp1 = p1->stamp;\n+  gimple stmt2 = p2->stmt;\n+  const struct hashable_expr *expr2 = &p2->expr;\n+  const struct expr_hash_elt *stamp2 = p2->stamp;\n+\n+  /* This case should apply only when removing entries from the table.  */\n+  if (stamp1 == stamp2)\n+    return true;\n+\n+  /* FIXME tuples:\n+     We add stmts to a hash table and them modify them. To detect the case\n+     that we modify a stmt and then search for it, we assume that the hash\n+     is always modified by that change.\n+     We have to fully check why this doesn't happen on trunk or rewrite\n+     this in a more  reliable (and easier to understand) way. */\n+  if (((const struct expr_hash_elt *)p1)->hash\n+      != ((const struct expr_hash_elt *)p2)->hash)\n+    return false;\n+\n+  /* In case of a collision, both RHS have to be identical and have the\n+     same VUSE operands.  */\n+  if (hashable_expr_equal_p (expr1, expr2)\n+      && types_compatible_p (expr1->type, expr2->type))\n+    {\n+      /* Note that STMT1 and/or STMT2 may be NULL.  */\n+      return ((stmt1 ? gimple_vuse (stmt1) : NULL_TREE)\n+\t      == (stmt2 ? gimple_vuse (stmt2) : NULL_TREE));\n+    }\n+\n+  return false;\n+}\n+\n+/* Delete an expr_hash_elt and reclaim its storage.  */\n+\n+inline void\n+expr_elt_hasher::remove (value_type *element)\n+{\n+  free_expr_hash_elt (element);\n+}\n+\n+/* Hash table with expressions made available during the renaming process.\n+   When an assignment of the form X_i = EXPR is found, the statement is\n+   stored in this table.  If the same expression EXPR is later found on the\n+   RHS of another statement, it is replaced with X_i (thus performing\n+   global redundancy elimination).  Similarly as we pass through conditionals\n+   we record the conditional itself as having either a true or false value\n+   in this table.  */\n+static hash_table <expr_elt_hasher> avail_exprs;\n+\n /* Stack of dest,src pairs that need to be restored during finalization.\n \n    A NULL entry is used to mark the end of pairs which need to be\n@@ -169,9 +236,7 @@ static struct opt_stats_d opt_stats;\n static void optimize_stmt (basic_block, gimple_stmt_iterator);\n static tree lookup_avail_expr (gimple, bool);\n static hashval_t avail_expr_hash (const void *);\n-static hashval_t real_avail_expr_hash (const void *);\n-static int avail_expr_eq (const void *, const void *);\n-static void htab_statistics (FILE *, htab_t);\n+static void htab_statistics (FILE *, hash_table <expr_elt_hasher>);\n static void record_cond (cond_equivalence *);\n static void record_const_or_copy (tree, tree);\n static void record_equality (tree, tree);\n@@ -722,7 +787,7 @@ tree_ssa_dominator_optimize (void)\n   memset (&opt_stats, 0, sizeof (opt_stats));\n \n   /* Create our hash tables.  */\n-  avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free_expr_hash_elt);\n+  avail_exprs.create (1024);\n   avail_exprs_stack.create (20);\n   const_and_copies_stack.create (20);\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n@@ -830,7 +895,7 @@ tree_ssa_dominator_optimize (void)\n   loop_optimizer_finalize ();\n \n   /* Delete our main hashtable.  */\n-  htab_delete (avail_exprs);\n+  avail_exprs.dispose ();\n \n   /* And finalize the dominator walker.  */\n   fini_walk_dominator_tree (&walk_data);\n@@ -935,7 +1000,7 @@ remove_local_expressions_from_table (void)\n   while (avail_exprs_stack.length () > 0)\n     {\n       expr_hash_elt_t victim = avail_exprs_stack.pop ();\n-      void **slot;\n+      expr_hash_elt **slot;\n \n       if (victim == NULL)\n \tbreak;\n@@ -949,10 +1014,9 @@ remove_local_expressions_from_table (void)\n           print_expr_hash_elt (dump_file, victim);\n         }\n \n-      slot = htab_find_slot_with_hash (avail_exprs,\n-\t\t\t\t       victim, victim->hash, NO_INSERT);\n-      gcc_assert (slot && *slot == (void *) victim);\n-      htab_clear_slot (avail_exprs, slot);\n+      slot = avail_exprs.find_slot_with_hash (victim, victim->hash, NO_INSERT);\n+      gcc_assert (slot && *slot == victim);\n+      avail_exprs.clear_slot (slot);\n     }\n }\n \n@@ -1203,12 +1267,12 @@ debug_dominator_optimization_stats (void)\n /* Dump statistics for the hash table HTAB.  */\n \n static void\n-htab_statistics (FILE *file, htab_t htab)\n+htab_statistics (FILE *file, hash_table <expr_elt_hasher> htab)\n {\n   fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n-\t   (long) htab_size (htab),\n-\t   (long) htab_elements (htab),\n-\t   htab_collisions (htab));\n+\t   (long) htab.size (),\n+\t   (long) htab.elements (),\n+\t   htab.collisions ());\n }\n \n \n@@ -1220,15 +1284,14 @@ static void\n record_cond (cond_equivalence *p)\n {\n   struct expr_hash_elt *element = XCNEW (struct expr_hash_elt);\n-  void **slot;\n+  expr_hash_elt **slot;\n \n   initialize_hash_element_from_expr (&p->cond, p->value, element);\n \n-  slot = htab_find_slot_with_hash (avail_exprs, (void *)element,\n-\t\t\t\t   element->hash, INSERT);\n+  slot = avail_exprs.find_slot_with_hash (element, element->hash, INSERT);\n   if (*slot == NULL)\n     {\n-      *slot = (void *) element;\n+      *slot = element;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n         {\n@@ -2404,7 +2467,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n static tree\n lookup_avail_expr (gimple stmt, bool insert)\n {\n-  void **slot;\n+  expr_hash_elt **slot;\n   tree lhs;\n   tree temp;\n   struct expr_hash_elt element;\n@@ -2432,8 +2495,8 @@ lookup_avail_expr (gimple stmt, bool insert)\n     return NULL_TREE;\n \n   /* Finally try to find the expression in the main expression hash table.  */\n-  slot = htab_find_slot_with_hash (avail_exprs, &element, element.hash,\n-\t\t\t\t   (insert ? INSERT : NO_INSERT));\n+  slot = avail_exprs.find_slot_with_hash (&element, element.hash,\n+\t\t\t\t\t  (insert ? INSERT : NO_INSERT));\n   if (slot == NULL)\n     {\n       free_expr_hash_elt_contents (&element);\n@@ -2444,7 +2507,7 @@ lookup_avail_expr (gimple stmt, bool insert)\n       struct expr_hash_elt *element2 = XNEW (struct expr_hash_elt);\n       *element2 = element;\n       element2->stamp = element2;\n-      *slot = (void *) element2;\n+      *slot = element2;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n         {\n@@ -2511,49 +2574,6 @@ avail_expr_hash (const void *p)\n   return val;\n }\n \n-static hashval_t\n-real_avail_expr_hash (const void *p)\n-{\n-  return ((const struct expr_hash_elt *)p)->hash;\n-}\n-\n-static int\n-avail_expr_eq (const void *p1, const void *p2)\n-{\n-  gimple stmt1 = ((const struct expr_hash_elt *)p1)->stmt;\n-  const struct hashable_expr *expr1 = &((const struct expr_hash_elt *)p1)->expr;\n-  const struct expr_hash_elt *stamp1 = ((const struct expr_hash_elt *)p1)->stamp;\n-  gimple stmt2 = ((const struct expr_hash_elt *)p2)->stmt;\n-  const struct hashable_expr *expr2 = &((const struct expr_hash_elt *)p2)->expr;\n-  const struct expr_hash_elt *stamp2 = ((const struct expr_hash_elt *)p2)->stamp;\n-\n-  /* This case should apply only when removing entries from the table.  */\n-  if (stamp1 == stamp2)\n-    return true;\n-\n-  /* FIXME tuples:\n-     We add stmts to a hash table and them modify them. To detect the case\n-     that we modify a stmt and then search for it, we assume that the hash\n-     is always modified by that change.\n-     We have to fully check why this doesn't happen on trunk or rewrite\n-     this in a more  reliable (and easier to understand) way. */\n-  if (((const struct expr_hash_elt *)p1)->hash\n-      != ((const struct expr_hash_elt *)p2)->hash)\n-    return false;\n-\n-  /* In case of a collision, both RHS have to be identical and have the\n-     same VUSE operands.  */\n-  if (hashable_expr_equal_p (expr1, expr2)\n-      && types_compatible_p (expr1->type, expr2->type))\n-    {\n-      /* Note that STMT1 and/or STMT2 may be NULL.  */\n-      return ((stmt1 ? gimple_vuse (stmt1) : NULL_TREE)\n-\t      == (stmt2 ? gimple_vuse (stmt2) : NULL_TREE));\n-    }\n-\n-  return false;\n-}\n-\n /* PHI-ONLY copy and constant propagation.  This pass is meant to clean\n    up degenerate PHIs created by or exposed by jump threading.  */\n "}, {"sha": "83a52a0482c3bdc1a152a50c5f3baa28073e75b1", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"gimple-pretty-print.h\"\n@@ -53,19 +54,41 @@ static void  verify_live_on_entry (tree_live_info_p);\n    ssa_name or variable, and vice versa.  */\n \n \n+/* Hashtable helpers.  */\n+\n+struct tree_int_map_hasher : typed_noop_remove <tree_int_map>\n+{\n+  typedef tree_int_map value_type;\n+  typedef tree_int_map compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+inline hashval_t\n+tree_int_map_hasher::hash (const value_type *v)\n+{\n+  return tree_map_base_hash (v);\n+}\n+\n+inline bool\n+tree_int_map_hasher::equal (const value_type *v, const compare_type *c)\n+{\n+  return tree_int_map_eq (v, c);\n+}\n+\n+\n /* This routine will initialize the basevar fields of MAP.  */\n \n static void\n var_map_base_init (var_map map)\n {\n   int x, num_part;\n   tree var;\n-  htab_t tree_to_index;\n+  hash_table <tree_int_map_hasher> tree_to_index;\n   struct tree_int_map *m, *mapstorage;\n \n   num_part = num_var_partitions (map);\n-  tree_to_index = htab_create (num_part, tree_map_base_hash,\n-\t\t\t       tree_int_map_eq, NULL);\n+  tree_to_index.create (num_part);\n   /* We can have at most num_part entries in the hash tables, so it's\n      enough to allocate so many map elements once, saving some malloc\n      calls.  */\n@@ -91,8 +114,7 @@ var_map_base_init (var_map map)\n \t   underlying decl.  */\n \tm->base.from = TREE_TYPE (var);\n       /* If base variable hasn't been seen, set it up.  */\n-      slot = (struct tree_int_map **) htab_find_slot (tree_to_index,\n-\t\t\t\t\t\t      m, INSERT);\n+      slot = tree_to_index.find_slot (m, INSERT);\n       if (!*slot)\n \t{\n \t  baseindex = m - mapstorage;\n@@ -108,7 +130,7 @@ var_map_base_init (var_map map)\n   map->num_basevars = m - mapstorage;\n \n   free (mapstorage);\n-  htab_delete (tree_to_index);\n+  tree_to_index. dispose ();\n }\n \n "}, {"sha": "7cfe80d921355f034d9a9347be4663a62ac66fdd", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -75,7 +75,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"insn-config.h\"\n #include \"pointer-set.h\"\n-#include \"hashtab.h\"\n+#include \"hash-table.h\"\n #include \"tree-chrec.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"cfgloop.h\"\n@@ -236,6 +236,33 @@ typedef struct iv_use *iv_use_p;\n \n typedef struct iv_cand *iv_cand_p;\n \n+/* Hashtable helpers.  */\n+\n+struct iv_inv_expr_hasher : typed_free_remove <iv_inv_expr_ent>\n+{\n+  typedef iv_inv_expr_ent value_type;\n+  typedef iv_inv_expr_ent compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Hash function for loop invariant expressions.  */\n+\n+inline hashval_t\n+iv_inv_expr_hasher::hash (const value_type *expr)\n+{\n+  return expr->hash;\n+}\n+\n+/* Hash table equality function for expressions.  */\n+\n+inline bool\n+iv_inv_expr_hasher::equal (const value_type *expr1, const compare_type *expr2)\n+{\n+  return expr1->hash == expr2->hash\n+\t && operand_equal_p (expr1->expr, expr2->expr, 0);\n+}\n+\n struct ivopts_data\n {\n   /* The currently optimized loop.  */\n@@ -255,7 +282,7 @@ struct ivopts_data\n \n   /* The hashtable of loop invariant expressions created\n      by ivopt.  */\n-  htab_t inv_expr_tab;\n+  hash_table <iv_inv_expr_hasher> inv_expr_tab;\n \n   /* Loop invariant expression id.  */\n   int inv_expr_id;\n@@ -814,30 +841,6 @@ niter_for_single_dom_exit (struct ivopts_data *data)\n   return niter_for_exit (data, exit);\n }\n \n-/* Hash table equality function for expressions.  */\n-\n-static int\n-htab_inv_expr_eq (const void *ent1, const void *ent2)\n-{\n-  const struct iv_inv_expr_ent *expr1 =\n-      (const struct iv_inv_expr_ent *)ent1;\n-  const struct iv_inv_expr_ent *expr2 =\n-      (const struct iv_inv_expr_ent *)ent2;\n-\n-  return expr1->hash == expr2->hash\n-\t && operand_equal_p (expr1->expr, expr2->expr, 0);\n-}\n-\n-/* Hash function for loop invariant expressions.  */\n-\n-static hashval_t\n-htab_inv_expr_hash (const void *ent)\n-{\n-  const struct iv_inv_expr_ent *expr =\n-      (const struct iv_inv_expr_ent *)ent;\n-  return expr->hash;\n-}\n-\n /* Initializes data structures used by the iv optimization pass, stored\n    in DATA.  */\n \n@@ -852,8 +855,7 @@ tree_ssa_iv_optimize_init (struct ivopts_data *data)\n   data->niters = NULL;\n   data->iv_uses.create (20);\n   data->iv_candidates.create (20);\n-  data->inv_expr_tab = htab_create (10, htab_inv_expr_hash,\n-                                    htab_inv_expr_eq, free);\n+  data->inv_expr_tab.create (10);\n   data->inv_expr_id = 0;\n   decl_rtl_to_reset.create (20);\n }\n@@ -3850,8 +3852,7 @@ get_expr_id (struct ivopts_data *data, tree expr)\n \n   ent.expr = expr;\n   ent.hash = iterative_hash_expr (expr, 0);\n-  slot = (struct iv_inv_expr_ent **) htab_find_slot (data->inv_expr_tab,\n-                                                     &ent, INSERT);\n+  slot = data->inv_expr_tab.find_slot (&ent, INSERT);\n   if (*slot)\n     return (*slot)->id;\n \n@@ -6653,7 +6654,7 @@ free_loop_data (struct ivopts_data *data)\n \n   decl_rtl_to_reset.truncate (0);\n \n-  htab_empty (data->inv_expr_tab);\n+  data->inv_expr_tab.empty ();\n   data->inv_expr_id = 0;\n }\n \n@@ -6671,7 +6672,7 @@ tree_ssa_iv_optimize_finalize (struct ivopts_data *data)\n   decl_rtl_to_reset.release ();\n   data->iv_uses.release ();\n   data->iv_candidates.release ();\n-  htab_delete (data->inv_expr_tab);\n+  data->inv_expr_tab.dispose ();\n }\n \n /* Returns true if the loop body BODY includes any function calls.  */"}, {"sha": "739e48e432bd72502e19adc650cf11443d527567", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"tm.h\"\n #include \"ggc.h\"\n #include \"tree.h\"\n@@ -1239,8 +1240,15 @@ struct name_to_bb\n   basic_block bb;\n };\n \n-/* The hash table for remembering what we've seen.  */\n-static htab_t seen_ssa_names;\n+/* Hashtable helpers.  */\n+\n+struct ssa_names_hasher : typed_free_remove <name_to_bb>\n+{\n+  typedef name_to_bb value_type;\n+  typedef name_to_bb compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n \n /* Used for quick clearing of the hash-table when we see calls.\n    Hash entries with phase < nt_call_phase are invalid.  */\n@@ -1250,27 +1258,28 @@ static unsigned int nt_call_phase;\n static struct pointer_set_t *nontrap_set;\n \n /* The hash function.  */\n-static hashval_t\n-name_to_bb_hash (const void *p)\n+\n+inline hashval_t\n+ssa_names_hasher::hash (const value_type *n)\n {\n-  const struct name_to_bb *n = (const struct name_to_bb *) p;\n   return n->ssa_name_ver ^ (((hashval_t) n->store) << 31)\n          ^ (n->offset << 6) ^ (n->size << 3);\n }\n \n /* The equality function of *P1 and *P2.  */\n-static int\n-name_to_bb_eq (const void *p1, const void *p2)\n-{\n-  const struct name_to_bb *n1 = (const struct name_to_bb *)p1;\n-  const struct name_to_bb *n2 = (const struct name_to_bb *)p2;\n \n+inline bool\n+ssa_names_hasher::equal (const value_type *n1, const compare_type *n2)\n+{\n   return n1->ssa_name_ver == n2->ssa_name_ver\n          && n1->store == n2->store\n          && n1->offset == n2->offset\n          && n1->size == n2->size;\n }\n \n+/* The hash table for remembering what we've seen.  */\n+static hash_table <ssa_names_hasher> seen_ssa_names;\n+\n /* We see the expression EXP in basic block BB.  If it's an interesting\n    expression (an MEM_REF through an SSA_NAME) possibly insert the\n    expression into the set NONTRAP or the hash table of seen expressions.\n@@ -1289,7 +1298,7 @@ add_or_mark_expr (basic_block bb, tree exp,\n     {\n       tree name = TREE_OPERAND (exp, 0);\n       struct name_to_bb map;\n-      void **slot;\n+      name_to_bb **slot;\n       struct name_to_bb *n2bb;\n       basic_block found_bb = 0;\n \n@@ -1302,8 +1311,8 @@ add_or_mark_expr (basic_block bb, tree exp,\n       map.offset = tree_low_cst (TREE_OPERAND (exp, 1), 0);\n       map.size = size;\n \n-      slot = htab_find_slot (seen_ssa_names, &map, INSERT);\n-      n2bb = (struct name_to_bb *) *slot;\n+      slot = seen_ssa_names.find_slot (&map, INSERT);\n+      n2bb = *slot;\n       if (n2bb && n2bb->phase >= nt_call_phase)\n         found_bb = n2bb->bb;\n \n@@ -1413,8 +1422,7 @@ get_non_trapping (void)\n \n   nt_call_phase = 0;\n   nontrap = pointer_set_create ();\n-  seen_ssa_names = htab_create (128, name_to_bb_hash, name_to_bb_eq,\n-\t\t\t\tfree);\n+  seen_ssa_names.create (128);\n   /* We're going to do a dominator walk, so ensure that we have\n      dominance information.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n@@ -1431,7 +1439,7 @@ get_non_trapping (void)\n   init_walk_dominator_tree (&walk_data);\n   walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n   fini_walk_dominator_tree (&walk_data);\n-  htab_delete (seen_ssa_names);\n+  seen_ssa_names.dispose ();\n \n   clear_aux_for_blocks ();\n   return nontrap;"}, {"sha": "bea0c28ad4588b65303cdf3b87f30a8b6b931f91", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"hash-table.h\"\n #include \"tree-flow.h\"\n #include \"tree-pass.h\"\n #include \"domwalk.h\"\n@@ -111,9 +112,33 @@ struct decl_stridxlist_map\n   struct stridxlist list;\n };\n \n+/* stridxlist hashtable helpers.  */\n+\n+struct stridxlist_hasher : typed_noop_remove <decl_stridxlist_map>\n+{\n+  typedef decl_stridxlist_map value_type;\n+  typedef decl_stridxlist_map compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n+/* Hash a from tree in a decl_stridxlist_map.  */\n+\n+inline hashval_t\n+stridxlist_hasher::hash (const value_type *item)\n+{\n+  return DECL_UID (item->base.from);\n+}\n+\n+inline bool\n+stridxlist_hasher::equal (const value_type *v, const compare_type *c)\n+{\n+  return tree_map_base_eq (&v->base, &c->base);\n+}\n+\n /* Hash table for mapping decls to a chained list of offset -> idx\n    mappings.  */\n-static htab_t decl_to_stridxlist_htab;\n+static hash_table <stridxlist_hasher> decl_to_stridxlist_htab;\n \n /* Obstack for struct stridxlist and struct decl_stridxlist_map.  */\n static struct obstack stridx_obstack;\n@@ -128,14 +153,6 @@ struct laststmt_struct\n   int stridx;\n } laststmt;\n \n-/* Hash a from tree in a decl_stridxlist_map.  */\n-\n-static unsigned int\n-decl_to_stridxlist_hash (const void *item)\n-{\n-  return DECL_UID (((const struct decl_stridxlist_map *) item)->base.from);\n-}\n-\n /* Helper function for get_stridx.  */\n \n static int\n@@ -146,16 +163,15 @@ get_addr_stridx (tree exp)\n   struct stridxlist *list;\n   tree base;\n \n-  if (decl_to_stridxlist_htab == NULL)\n+  if (!decl_to_stridxlist_htab.is_created ())\n     return 0;\n \n   base = get_addr_base_and_unit_offset (exp, &off);\n   if (base == NULL || !DECL_P (base))\n     return 0;\n \n   ent.base.from = base;\n-  e = (struct decl_stridxlist_map *)\n-      htab_find_with_hash (decl_to_stridxlist_htab, &ent, DECL_UID (base));\n+  e = decl_to_stridxlist_htab.find_with_hash (&ent, DECL_UID (base));\n   if (e == NULL)\n     return 0;\n \n@@ -234,7 +250,7 @@ unshare_strinfo_vec (void)\n static int *\n addr_stridxptr (tree exp)\n {\n-  void **slot;\n+  decl_stridxlist_map **slot;\n   struct decl_stridxlist_map ent;\n   struct stridxlist *list;\n   HOST_WIDE_INT off;\n@@ -243,19 +259,18 @@ addr_stridxptr (tree exp)\n   if (base == NULL_TREE || !DECL_P (base))\n     return NULL;\n \n-  if (decl_to_stridxlist_htab == NULL)\n+  if (!decl_to_stridxlist_htab.is_created ())\n     {\n-      decl_to_stridxlist_htab\n-\t= htab_create (64, decl_to_stridxlist_hash, tree_map_base_eq, NULL);\n+      decl_to_stridxlist_htab.create (64);\n       gcc_obstack_init (&stridx_obstack);\n     }\n   ent.base.from = base;\n-  slot = htab_find_slot_with_hash (decl_to_stridxlist_htab, &ent,\n-\t\t\t\t   DECL_UID (base), INSERT);\n+  slot = decl_to_stridxlist_htab.find_slot_with_hash (&ent, DECL_UID (base),\n+\t\t\t\t\t\t      INSERT);\n   if (*slot)\n     {\n       int i;\n-      list = &((struct decl_stridxlist_map *)*slot)->list;\n+      list = &(*slot)->list;\n       for (i = 0; i < 16; i++)\n \t{\n \t  if (list->offset == off)\n@@ -273,7 +288,7 @@ addr_stridxptr (tree exp)\n       struct decl_stridxlist_map *e\n \t= XOBNEW (&stridx_obstack, struct decl_stridxlist_map);\n       e->base.from = base;\n-      *slot = (void *) e;\n+      *slot = e;\n       list = &e->list;\n     }\n   list->next = NULL;\n@@ -1985,11 +2000,10 @@ tree_ssa_strlen (void)\n \n   ssa_ver_to_stridx.release ();\n   free_alloc_pool (strinfo_pool);\n-  if (decl_to_stridxlist_htab)\n+  if (decl_to_stridxlist_htab.is_created ())\n     {\n       obstack_free (&stridx_obstack, NULL);\n-      htab_delete (decl_to_stridxlist_htab);\n-      decl_to_stridxlist_htab = NULL;\n+      decl_to_stridxlist_htab.dispose ();\n     }\n   laststmt.stmt = NULL;\n   laststmt.len = NULL_TREE;"}, {"sha": "1fbc524e57fb30cc5048f129cb231ca015f64e8a", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -265,11 +265,6 @@ associate_equivalences_with_edges (void)\n    subtree rooted at the block where we record the equivalency.  */\n static vec<tree> equiv_stack;\n \n-/* Global hash table implementing a mapping from invariant values\n-   to a list of SSA_NAMEs which have the same value.  We might be\n-   able to reuse tree-vn for this code.  */\n-static htab_t equiv;\n-\n /* Main structure for recording equivalences into our hash table.  */\n struct equiv_hash_elt\n {\n@@ -280,77 +275,90 @@ struct equiv_hash_elt\n   vec<tree> equivalences;\n };\n \n-static void uncprop_enter_block (struct dom_walk_data *, basic_block);\n-static void uncprop_leave_block (struct dom_walk_data *, basic_block);\n-static void uncprop_into_successor_phis (basic_block);\n+/* Value to ssa name equivalence hashtable helpers.  */\n \n-/* Hashing and equality routines for the hash table.  */\n+struct val_ssa_equiv_hasher\n+{\n+  typedef equiv_hash_elt value_type;\n+  typedef equiv_hash_elt compare_type;\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+  static inline void remove (value_type *);\n+};\n \n-static hashval_t\n-equiv_hash (const void *p)\n+inline hashval_t\n+val_ssa_equiv_hasher::hash (const value_type *p)\n {\n-  tree const value = ((const struct equiv_hash_elt *)p)->value;\n+  tree const value = p->value;\n   return iterative_hash_expr (value, 0);\n }\n \n-static int\n-equiv_eq (const void *p1, const void *p2)\n+inline bool\n+val_ssa_equiv_hasher::equal (const value_type *p1, const compare_type *p2)\n {\n-  tree value1 = ((const struct equiv_hash_elt *)p1)->value;\n-  tree value2 = ((const struct equiv_hash_elt *)p2)->value;\n+  tree value1 = p1->value;\n+  tree value2 = p2->value;\n \n   return operand_equal_p (value1, value2, 0);\n }\n \n /* Free an instance of equiv_hash_elt.  */\n \n-static void\n-equiv_free (void *p)\n+inline void\n+val_ssa_equiv_hasher::remove (value_type *elt)\n {\n-  struct equiv_hash_elt *elt = (struct equiv_hash_elt *) p;\n   elt->equivalences.release ();\n   free (elt);\n }\n \n+/* Global hash table implementing a mapping from invariant values\n+   to a list of SSA_NAMEs which have the same value.  We might be\n+   able to reuse tree-vn for this code.  */\n+static hash_table <val_ssa_equiv_hasher> val_ssa_equiv;\n+\n+static void uncprop_enter_block (struct dom_walk_data *, basic_block);\n+static void uncprop_leave_block (struct dom_walk_data *, basic_block);\n+static void uncprop_into_successor_phis (basic_block);\n+\n /* Remove the most recently recorded equivalency for VALUE.  */\n \n static void\n remove_equivalence (tree value)\n {\n-  struct equiv_hash_elt equiv_hash_elt, *equiv_hash_elt_p;\n-  void **slot;\n+  struct equiv_hash_elt an_equiv_elt, *an_equiv_elt_p;\n+  equiv_hash_elt **slot;\n \n-  equiv_hash_elt.value = value;\n-  equiv_hash_elt.equivalences.create (0);\n+  an_equiv_elt.value = value;\n+  an_equiv_elt.equivalences.create (0);\n \n-  slot = htab_find_slot (equiv, &equiv_hash_elt, NO_INSERT);\n+  slot = val_ssa_equiv.find_slot (&an_equiv_elt, NO_INSERT);\n \n-  equiv_hash_elt_p = (struct equiv_hash_elt *) *slot;\n-  equiv_hash_elt_p->equivalences.pop ();\n+  an_equiv_elt_p = *slot;\n+  an_equiv_elt_p->equivalences.pop ();\n }\n \n /* Record EQUIVALENCE = VALUE into our hash table.  */\n \n static void\n record_equiv (tree value, tree equivalence)\n {\n-  struct equiv_hash_elt *equiv_hash_elt;\n-  void **slot;\n+  equiv_hash_elt *an_equiv_elt_p;\n+  equiv_hash_elt **slot;\n \n-  equiv_hash_elt = XNEW (struct equiv_hash_elt);\n-  equiv_hash_elt->value = value;\n-  equiv_hash_elt->equivalences.create (0);\n+  an_equiv_elt_p = XNEW (struct equiv_hash_elt);\n+  an_equiv_elt_p->value = value;\n+  an_equiv_elt_p->equivalences.create (0);\n \n-  slot = htab_find_slot (equiv, equiv_hash_elt, INSERT);\n+  slot = val_ssa_equiv.find_slot (an_equiv_elt_p, INSERT);\n \n   if (*slot == NULL)\n-    *slot = (void *) equiv_hash_elt;\n+    *slot = an_equiv_elt_p;\n   else\n-     free (equiv_hash_elt);\n+     free (an_equiv_elt_p);\n \n-  equiv_hash_elt = (struct equiv_hash_elt *) *slot;\n+  an_equiv_elt_p = *slot;\n \n-  equiv_hash_elt->equivalences.safe_push (equivalence);\n+  an_equiv_elt_p->equivalences.safe_push (equivalence);\n }\n \n /* Main driver for un-cprop.  */\n@@ -364,7 +372,7 @@ tree_ssa_uncprop (void)\n   associate_equivalences_with_edges ();\n \n   /* Create our global data structures.  */\n-  equiv = htab_create (1024, equiv_hash, equiv_eq, equiv_free);\n+  val_ssa_equiv.create (1024);\n   equiv_stack.create (2);\n \n   /* We're going to do a dominator walk, so ensure that we have\n@@ -392,7 +400,7 @@ tree_ssa_uncprop (void)\n   /* EQUIV_STACK should already be empty at this point, so we just\n      need to empty elements out of the hash table, free EQUIV_STACK,\n      and cleanup the AUX field on the edges.  */\n-  htab_delete (equiv);\n+  val_ssa_equiv.dispose ();\n   equiv_stack.release ();\n   FOR_EACH_BB (bb)\n     {\n@@ -463,8 +471,8 @@ uncprop_into_successor_phis (basic_block bb)\n \t  gimple phi = gsi_stmt (gsi);\n \t  tree arg = PHI_ARG_DEF (phi, e->dest_idx);\n \t  tree res = PHI_RESULT (phi);\n-\t  struct equiv_hash_elt equiv_hash_elt;\n-\t  void **slot;\n+\t  equiv_hash_elt an_equiv_elt;\n+\t  equiv_hash_elt **slot;\n \n \t  /* If the argument is not an invariant, and refers to the same\n \t     underlying variable as the PHI result, then there's no\n@@ -475,13 +483,13 @@ uncprop_into_successor_phis (basic_block bb)\n \t    continue;\n \n \t  /* Lookup this argument's value in the hash table.  */\n-\t  equiv_hash_elt.value = arg;\n-\t  equiv_hash_elt.equivalences.create (0);\n-\t  slot = htab_find_slot (equiv, &equiv_hash_elt, NO_INSERT);\n+\t  an_equiv_elt.value = arg;\n+\t  an_equiv_elt.equivalences.create (0);\n+\t  slot = val_ssa_equiv.find_slot (&an_equiv_elt, NO_INSERT);\n \n \t  if (slot)\n \t    {\n-\t      struct equiv_hash_elt *elt = (struct equiv_hash_elt *) *slot;\n+\t      struct equiv_hash_elt *elt = *slot;\n \t      int j;\n \n \t      /* Walk every equivalence with the same value.  If we find"}, {"sha": "15a9176689282fb995d46f37a4a6dd7f28cac0be", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a8fb1a1de7c34fc788ccca21f3a15980bbce093/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=4a8fb1a1de7c34fc788ccca21f3a15980bbce093", "patch": "@@ -1046,42 +1046,6 @@ verify_ssa (bool check_modified_stmt)\n   internal_error (\"verify_ssa failed\");\n }\n \n-/* Return true if the uid in both int tree maps are equal.  */\n-\n-int\n-int_tree_map_eq (const void *va, const void *vb)\n-{\n-  const struct int_tree_map *a = (const struct int_tree_map *) va;\n-  const struct int_tree_map *b = (const struct int_tree_map *) vb;\n-  return (a->uid == b->uid);\n-}\n-\n-/* Hash a UID in a int_tree_map.  */\n-\n-unsigned int\n-int_tree_map_hash (const void *item)\n-{\n-  return ((const struct int_tree_map *)item)->uid;\n-}\n-\n-/* Return true if the DECL_UID in both trees are equal.  */\n-\n-int\n-uid_decl_map_eq (const void *va, const void *vb)\n-{\n-  const_tree a = (const_tree) va;\n-  const_tree b = (const_tree) vb;\n-  return (a->decl_minimal.uid == b->decl_minimal.uid);\n-}\n-\n-/* Hash a tree in a uid_decl_map.  */\n-\n-unsigned int\n-uid_decl_map_hash (const void *item)\n-{\n-  return ((const_tree)item)->decl_minimal.uid;\n-}\n-\n /* Return true if the DECL_UID in both trees are equal.  */\n \n static int"}]}