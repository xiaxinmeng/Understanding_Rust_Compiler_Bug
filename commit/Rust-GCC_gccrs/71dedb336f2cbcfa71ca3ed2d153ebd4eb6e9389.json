{"sha": "71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkZWRiMzM2ZjJjYmNmYTcxY2EzZWQyZDE1M2ViZDRlYjZlOTM4OQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-03-01T23:39:59Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-03-01T23:39:59Z"}, "message": "PR middle-end/79692 - [7 Regression] -Wformat-overflow false positive\n\ngcc/ChangeLog:\n\n\tPR middle-end/79692\n\t* gimple-ssa-sprintf.c\n\t(directive::known_width_and_precision): New function.\n\t(format_integer): Use it.\n\t(get_mpfr_format_length): Consider the full range of precision\n\twhen computing %g output with the # flag.  Set the likely byte\n\tcount to 3 rather than 1 when precision is indeterminate.\n\t(format_floating): Correct the lower bound of precision.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/79692\n\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Add test cases.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-10.c: Correct %#g.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-15.c: New test.\n\t* gcc.dg/tree-ssa/builtin-snprintf-3.c: Ditto.\n\nFrom-SVN: r245822", "tree": {"sha": "28ec2ca75443c8ea750c038f35b7ff911bc6d702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28ec2ca75443c8ea750c038f35b7ff911bc6d702"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "538d7dba84ff54f8be6632797f4e636d7af0a734", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/538d7dba84ff54f8be6632797f4e636d7af0a734", "html_url": "https://github.com/Rust-GCC/gccrs/commit/538d7dba84ff54f8be6632797f4e636d7af0a734"}], "stats": {"total": 479, "additions": 441, "deletions": 38}, "files": [{"sha": "4f44086608112d384396eff95eac1691c0461f58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "patch": "@@ -1,3 +1,14 @@\n+2017-03-01  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/79692\n+\t* gimple-ssa-sprintf.c\n+\t(directive::known_width_and_precision): New function.\n+\t(format_integer): Use it.\n+\t(get_mpfr_format_length): Consider the full range of precision\n+\twhen computing %g output with the # flag.  Set the likely byte\n+\tcount to 3 rather than 1 when precision is indeterminate.\n+\t(format_floating): Correct the lower bound of precision.\n+\n 2017-03-01  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* doc/invoke.texi: Document default code model for 64-bit Linux."}, {"sha": "0448b2127bed1d3770fba5b7f01fe03342e97705", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 132, "deletions": 32, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "patch": "@@ -692,6 +692,16 @@ struct directive\n   {\n     get_int_range (arg, integer_type_node, prec, prec + 1, false, -1);\n   }\n+\n+  /* Return true if both width and precision are known to be\n+     either constant or in some range, false otherwise.  */\n+  bool known_width_and_precision () const\n+  {\n+    return ((width[1] < 0\n+\t     || (unsigned HOST_WIDE_INT)width[1] <= target_int_max ())\n+\t    && (prec[1] < 0\n+\t\t|| (unsigned HOST_WIDE_INT)prec[1] < target_int_max ()));\n+  }\n };\n \n /* Return the logarithm of X in BASE.  */\n@@ -1180,10 +1190,10 @@ format_integer (const directive &dir, tree arg)\n \t  /* As a special case, a precision of zero with a zero argument\n \t     results in zero bytes except in base 8 when the '#' flag is\n \t     specified, and for signed conversions in base 8 and 10 when\n-\t     flags when either the space or '+' flag has been specified\n-\t     when it results in just one byte (with width having the normal\n-\t     effect).  This must extend to the case of a specified precision\n-\t     with an unknown value because it can be zero.  */\n+\t     either the space or '+' flag has been specified and it results\n+\t     in just one byte (with width having the normal effect).  This\n+\t     must extend to the case of a specified precision with\n+\t     an unknown value because it can be zero.  */\n \t  res.range.min = ((base == 8 && dir.get_flag ('#')) || maybesign);\n \t  if (res.range.min == 0 && dir.prec[0] != dir.prec[1])\n \t    {\n@@ -1254,10 +1264,12 @@ format_integer (const directive &dir, tree arg)\n \t  argmax = wide_int_to_tree (argtype, max);\n \n \t  /* Set KNOWNRANGE if the argument is in a known subrange\n-\t     of the directive's type (KNOWNRANGE may be reset below).  */\n+\t     of the directive's type and neither width nor precision\n+\t     is unknown.  (KNOWNRANGE may be reset below).  */\n \t  res.knownrange\n-\t    = (!tree_int_cst_equal (TYPE_MIN_VALUE (dirtype), argmin)\n-\t       || !tree_int_cst_equal (TYPE_MAX_VALUE (dirtype), argmax));\n+\t    = ((!tree_int_cst_equal (TYPE_MIN_VALUE (dirtype), argmin)\n+\t\t|| !tree_int_cst_equal (TYPE_MAX_VALUE (dirtype), argmax))\n+\t       && dir.known_width_and_precision ());\n \n \t  res.argmin = argmin;\n \t  res.argmax = argmax;\n@@ -1421,12 +1433,12 @@ get_mpfr_format_length (mpfr_ptr x, const char *flags, HOST_WIDE_INT prec,\n \n   HOST_WIDE_INT p = prec;\n \n-  if (spec == 'G')\n+  if (spec == 'G' && !strchr (flags, '#'))\n     {\n-      /* For G/g, precision gives the maximum number of significant\n-\t digits which is bounded by LDBL_MAX_10_EXP, or, for a 128\n-\t bit IEEE extended precision, 4932.  Using twice as much\n-\t here should be more than sufficient for any real format.  */\n+      /* For G/g without the pound flag, precision gives the maximum number\n+\t of significant digits which is bounded by LDBL_MAX_10_EXP, or, for\n+\t a 128 bit IEEE extended precision, 4932.  Using twice as much here\n+\t should be more than sufficient for any real format.  */\n       if ((IEEE_MAX_10_EXP * 2) < prec)\n \tprec = IEEE_MAX_10_EXP * 2;\n       p = prec;\n@@ -1609,7 +1621,12 @@ format_floating (const directive &dir)\n \t/* Compute the upper bound for -TYPE_MAX.  */\n \tres.range.max = format_floating_max (type, 'f', dir.prec[1]);\n \n-\tres.range.likely = res.range.min;\n+\t/* The minimum output with unknown precision is a single byte\n+\t   (e.g., \"0\") but the more likely output is 3 bytes (\"0.0\").  */\n+\tif (dir.prec[0] < 0 && dir.prec[1] > 0)\n+\t  res.range.likely = 3;\n+\telse\n+\t  res.range.likely = res.range.min;\n \n \t/* The unlikely maximum accounts for the longest multibyte\n \t   decimal point character.  */\n@@ -1625,10 +1642,43 @@ format_floating (const directive &dir)\n \t/* The %g output depends on precision and the exponent of\n \t   the argument.  Since the value of the argument isn't known\n \t   the lower bound on the range of bytes (not counting flags\n-\t   or width) is 1.  */\n-\tres.range.min = flagmin;\n-\tres.range.max = format_floating_max (type, 'g', dir.prec[1]);\n-\tres.range.likely = res.range.max;\n+\t   or width) is 1 plus radix (i.e., either \"0\" or \"0.\" for\n+\t   \"%g\" and \"%#g\", respectively, with a zero argument).  */\n+\tres.range.min = flagmin + radix;\n+\n+\tchar spec = 'g';\n+\tHOST_WIDE_INT maxprec = dir.prec[1];\n+\tif (radix && maxprec)\n+\t  {\n+\t    /* When the pound flag (radix) is set, trailing zeros aren't\n+\t       trimmed and so the longest output is the same as for %e,\n+\t       except with precision minus 1 (as specified in C11).  */\n+\t    spec = 'e';\n+\t    if (maxprec > 0)\n+\t      --maxprec;\n+\t    else if (maxprec < 0)\n+\t      maxprec = 5;\n+\t  }\n+\n+\tres.range.max = format_floating_max (type, spec, maxprec);\n+\n+\t/* The likely output is either the maximum computed above\n+\t   minus 1 (assuming the maximum is positive) when precision\n+\t   is known (or unspecified), or the same minimum as for %e\n+\t   (which is computed for a non-negative argument).  Unlike\n+\t   for the other specifiers above the likely output isn't\n+\t   the minimum because for %g that's 1 which is unlikely.  */\n+\tif (dir.prec[1] < 0\n+\t    || (unsigned HOST_WIDE_INT)dir.prec[1] < target_int_max ())\n+\t  res.range.likely = res.range.max - 1;\n+\telse\n+\t  {\n+\t    HOST_WIDE_INT minprec = 6 + !radix /* decimal point */;\n+\t    res.range.likely = (flagmin\n+\t\t\t\t+ radix\n+\t\t\t\t+ minprec\n+\t\t\t\t+ 2 /* e+ */ + 2);\n+\t  }\n \n \t/* The unlikely maximum accounts for the longest multibyte\n \t   decimal point character.  */\n@@ -1657,24 +1707,63 @@ format_floating (const directive &dir, tree arg)\n \n   HOST_WIDE_INT prec[] = { dir.prec[0], dir.prec[1] };\n \n+  /* For an indeterminate precision the lower bound must be assumed\n+     to be zero.  */\n   if (TOUPPER (dir.specifier) == 'A')\n     {\n+      /* Get the number of fractional decimal digits needed to represent\n+\t the argument without a loss of accuracy.  */\n+      tree type = arg ? TREE_TYPE (arg) :\n+\t(dir.modifier == FMT_LEN_L || dir.modifier == FMT_LEN_ll\n+\t ? long_double_type_node : double_type_node);\n+\n+      unsigned fmtprec\n+\t= REAL_MODE_FORMAT (TYPE_MODE (type))->p;\n+\n+      /* The precision of the IEEE 754 double format is 53.\n+\t The precision of all other GCC binary double formats\n+\t is 56 or less.  */\n+      unsigned maxprec = fmtprec <= 56 ? 13 : 15;\n+\n       /* For %a, leave the minimum precision unspecified to let\n \t MFPR trim trailing zeros (as it and many other systems\n \t including Glibc happen to do) and set the maximum\n \t precision to reflect what it would be with trailing zeros\n \t present (as Solaris and derived systems do).  */\n-      if (prec[0] < 0)\n-\tprec[0] = -1;\n-      if (prec[1] < 0)\n+      if (dir.prec[1] < 0)\n \t{\n-          unsigned fmtprec\n-\t    = REAL_MODE_FORMAT (TYPE_MODE (TREE_TYPE (arg)))->p;\n-\n-\t       /* The precision of the IEEE 754 double format is 53.\n-\t     The precision of all other GCC binary double formats\n-\t     is 56 or less.  */\n-\t  prec[1] = fmtprec <= 56 ? 13 : 15;\n+\t  /* Both bounds are negative implies that precision has\n+\t     not been specified.  */\n+\t  prec[0] = maxprec;\n+\t  prec[1] = -1;\n+\t}\n+      else if (dir.prec[0] < 0)\n+\t{\n+\t  /* With a negative lower bound and a non-negative upper\n+\t     bound set the minimum precision to zero and the maximum\n+\t     to the greater of the maximum precision (i.e., with\n+\t     trailing zeros present) and the specified upper bound.  */\n+\t  prec[0] = 0;\n+\t  prec[1] = dir.prec[1] < maxprec ? maxprec : dir.prec[1];\n+\t}\n+    }\n+  else if (dir.prec[0] < 0)\n+    {\n+      if (dir.prec[1] < 0)\n+\t{\n+\t  /* A precision in a strictly negative range is ignored and\n+\t     the default of 6 is used instead.  */\n+\t  prec[0] = prec[1] = 6;\n+\t}\n+      else\n+\t{\n+\t  /* For a precision in a partly negative range, the lower bound\n+\t     must be assumed to be zero and the new upper bound is the\n+\t     greater of 6 (the default precision used when the specified\n+\t     precision is negative) and the upper bound of the specified\n+\t     range.  */\n+\t  prec[0] = 0;\n+\t  prec[1] = dir.prec[1] < 6 ? 6 : dir.prec[1];\n \t}\n     }\n \n@@ -1734,12 +1823,23 @@ format_floating (const directive &dir, tree arg)\n       res.range.max = tmp;\n     }\n \n-  res.knownrange = true;\n+  /* The range is known unless either width or precision is unknown.  */\n+  res.knownrange = dir.known_width_and_precision ();\n+\n+  /* For the same floating point constant, unless width or precision\n+     is unknown, use the longer output as the likely maximum since\n+     with round to nearest either is equally likely.  Otheriwse, when\n+     precision is unknown, use the greater of the minimum and 3 as\n+     the likely output (for \"0.0\" since zero precision is unlikely).  */\n+  if (res.knownrange)\n+    res.range.likely = res.range.max;\n+  else if (res.range.min < 3\n+\t   && dir.prec[0] < 0\n+\t   && (unsigned HOST_WIDE_INT)dir.prec[1] == target_int_max ())\n+    res.range.likely = 3;\n+  else\n+    res.range.likely = res.range.min;\n \n-  /* For the same floating point constant use the longer output\n-     as the likely maximum since with round to nearest either is\n-     equally likely.  */\n-  res.range.likely = res.range.max;\n   res.range.unlikely = res.range.max;\n \n   if (res.range.max > 2 && (prec[0] != 0 || prec[1] != 0))"}, {"sha": "59264c2d4ef8762bc1303e3df1d704676f695f91", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "patch": "@@ -1,3 +1,11 @@\n+2017-03-01  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/79692\n+\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Add test cases.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-10.c: Correct %#g.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-15.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-snprintf-3.c: Ditto.\n+\n 2017-03-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/invsize-2.c: New test."}, {"sha": "e481955ab7326d39a4da0514761c723fd8839295", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-3.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-3.c?ref=71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "patch": "@@ -0,0 +1,77 @@\n+/* Verify the lower and upper bounds of floating directives with\n+   precision whose range crosses zero.\n+  { do-do compile }\n+  { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+static const double x = 1.23456789;\n+\n+/* All calls to failure_range must be eliminated.  */\n+extern void failure_range (int, int, int);\n+\n+/* All calls to verify_{lo,hi}_bound must be retained.  */\n+extern void verify_lo_bound (int, int);\n+extern void verify_hi_bound (int, int);\n+\n+int test_a (int p)\n+{\n+  if (p < -1 || 3 < p)\n+    p = -1;\n+\n+  int n = __builtin_snprintf (0, 0, \"%.*A\", p, x);\n+  if (n < 6 || 25 < n)\n+    failure_range ('A', 6, 25);\n+\n+  if (n == 6) verify_lo_bound ('A', 6);\n+  if (n == 25) verify_hi_bound ('A', 25);\n+\n+  return n;\n+}\n+\n+int test_e (int p)\n+{\n+  if (p < -1 || 3 < p)\n+    p = -1;\n+\n+  int n = __builtin_snprintf (0, 0, \"%.*E\", p, x);\n+  if (n < 5 || 17 < n)\n+    failure_range ('E', 5, 17);\n+\n+  if (n == 5) verify_lo_bound ('E', 5);\n+  if (n == 17) verify_hi_bound ('E', 17);\n+\n+  return n;\n+}\n+\n+int test_f (int p)\n+{\n+  if (p < -1 || 3 < p)\n+    p = -1;\n+\n+  int n = __builtin_snprintf (0, 0, \"%.*F\", p, x);\n+  if (n < 1 || 13 < n)\n+    failure_range ('F', 1, 13);\n+\n+  if (n == 1) verify_lo_bound ('F', 1);\n+  if (n == 13) verify_hi_bound ('F', 13);\n+\n+  return n;\n+}\n+\n+int test_g (int p)\n+{\n+  if (p < -1 || 3 < p)\n+    p = -1;\n+\n+  int n = __builtin_snprintf (0, 0, \"%.*G\", p, x);\n+  if (n < 1 || 12 < n)\n+    failure_range ('G', 1, 12);\n+\n+  if (n == 1) verify_lo_bound ('G', 1);\n+  if (n == 12) verify_hi_bound ('G', 12);\n+\n+  return n;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"snprintf\" 4 \"optimized\"} }\n+   { dg-final { scan-tree-dump-not \"failure_range\" \"optimized\"} }\n+   { dg-final { scan-tree-dump-times \"verify_\" 8 \"optimized\"} } */"}, {"sha": "8a13f33d2a1e9ef25b2472835f2bb320a0d051c0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c?ref=71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "patch": "@@ -7,7 +7,7 @@\n    The test is compiled with warnings disabled to make sure the absence\n    of optimizations does not depend on the presence of warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fprintf-return-value -fdump-tree-optimized -ftrack-macro-expansion=0 -w\" } */\n+/* { dg-options \"-O2 -fprintf-return-value -fdump-tree-optimized -w\" } */\n \n #ifndef LINE\n # define LINE 0\n@@ -243,6 +243,14 @@ RNG (6,  6,  7, \"%La\",      0.0L)   /* Glibc output: \"0x0p+0\"  */\n RNG (6,  6,  7, \"%La\",      ld)\n RNG (6,  6,  7, \"%.4096La\", ld)\n \n+/* Verify that the pound flag with unknown precision prevents the %g\n+   directive from trimming trailing zeros as it otherwise does.  As\n+   a consequence, the result must be assumed to be as large as\n+   precision.  */\n+RNG (1,  315,  316, \"%#.*g\", i, d);\n+RNG (1, 4095, 4096, \"%#.*g\", i, d);\n+RNG (1, 4095, 4096, \"%#.*g\", i, 0.0);\n+\n /* Verify that the result of formatting an unknown string isn't optimized\n    into a non-negative range.  The string could be longer that 4,095 bytes,\n    resulting in the formatting function having undefined behavior (and\n@@ -282,7 +290,7 @@ RNG (0,  6,   8, \"%s%ls\", \"1\", L\"2\");\n \n /*  Only conditional calls to must_not_eliminate must be made (with\n     any probability):\n-    { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\]:\\n *must_not_eliminate\" 124 \"optimized\" { target { ilp32 || lp64 } } } }\n-    { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\]:\\n *must_not_eliminate\" 93 \"optimized\" { target { { ! ilp32 } && { ! lp64 } } } } }\n+    { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\]:\\n *must_not_eliminate\" 127 \"optimized\" { target { ilp32 || lp64 } } } }\n+    { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\]:\\n *must_not_eliminate\" 96 \"optimized\" { target { { ! ilp32 } && { ! lp64 } } } } }\n     No unconditional calls to abort should be made:\n     { dg-final { scan-tree-dump-not \";\\n *must_not_eliminate\" \"optimized\" } } */"}, {"sha": "1213e89f7bb0b2c19d715c81a5cef0f07830364e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-10.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-10.c?ref=71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "patch": "@@ -239,9 +239,11 @@ void test_g_va (va_list va)\n   T (\"%g\");         /* { dg-warning \"between 1 and 13 bytes\" } */\n   T (\"%+g\");        /* { dg-warning \"between 2 and 13 bytes\" } */\n   T (\"% g\");        /* { dg-warning \"between 2 and 13 bytes\" } */\n-  T (\"%#g\");        /* { dg-warning \"between 1 and 13 bytes\" } */\n-  T (\"%#+g\");       /* { dg-warning \"between 2 and 13 bytes\" } */\n-  T (\"%# g\");       /* { dg-warning \"between 2 and 13 bytes\" } */\n+\n+  /* The pound flag means the radix character is always present.  */\n+  T (\"%#g\");        /* { dg-warning \"between 2 and 13 bytes\" } */\n+  T (\"%#+g\");       /* { dg-warning \"between 3 and 13 bytes\" } */\n+  T (\"%# g\");       /* { dg-warning \"between 3 and 13 bytes\" } */\n \n   T (\"%.g\");        /* { dg-warning \"between 1 and 7 bytes\" } */\n   T (\"%.0g\");       /* { dg-warning \"between 1 and 7 bytes\" } */"}, {"sha": "c38a656bc7be6ce6072d123e2be77aae4847ef25", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-15.c", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-15.c?ref=71dedb336f2cbcfa71ca3ed2d153ebd4eb6e9389", "patch": "@@ -0,0 +1,197 @@\n+/* PR middle-end/79692 - -Wformat-overflow false positive on an integer\n+   directive with unknown width\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wformat-overflow=1 -ftrack-macro-expansion=0\" }\n+   { dg-require-effective-target int32plus } */\n+\n+typedef __SIZE_TYPE__  size_t;\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-INT_MAX - 1)\n+\n+/* When debugging, define LINE to the line number of the test case to exercise\n+   and avoid exercising any of the others.  The buffer and objsize macros\n+   below make use of LINE to avoid warnings for other lines.  */\n+#ifndef LINE\n+# define LINE 0\n+#endif\n+\n+void sink (char*, char*);\n+\n+int dummy_sprintf (char*, const char*, ...);\n+\n+char buffer [1024];\n+extern char *ptr;\n+\n+int int_range (int min, int max)\n+{\n+  extern int int_value (void);\n+  int n = int_value ();\n+  return n < min || max < n ? min : n;\n+}\n+\n+unsigned uint_range (unsigned min, unsigned max)\n+{\n+  extern unsigned uint_value (void);\n+  unsigned n = uint_value ();\n+  return n < min || max < n ? min : n;\n+}\n+\n+/* Evaluate to an array of SIZE characters when non-negative, or to\n+   a pointer to an unknown object otherwise.  */\n+#define buffer(size)\t\t\t\t\t\\\n+  ((0 <= size) ? buffer + sizeof buffer - (size) : ptr)\n+\n+/* Helper to expand function to either __builtin_f or dummy_f to\n+   make debugging GCC easy.  */\n+#define FUNC(f)\t\t\t\t\t\t\t\\\n+  ((!LINE || LINE == __LINE__) ? __builtin_ ## f : dummy_ ## f)\n+\n+/* Macro to verify that calls to __builtin_sprintf (i.e., with no size\n+   argument) issue diagnostics by correctly determining the size of\n+   the destination buffer.  */\n+#define T(size, ...)\t\t\t\t\t\t\\\n+  (FUNC (sprintf) (buffer (size),  __VA_ARGS__),\t\t\\\n+   sink (buffer, ptr))\n+\n+/* Return a signed integer in the range [MIN, MAX].  */\n+#define R(min, max)  int_range (min, max)\n+\n+void test_unknown_width_integer (int w, int i)\n+{\n+  T (10, \"%*d\", w, i);\n+  T (10, \"%*d\", w, R (0, 12345));\n+\n+  T (10, \"%*i\", w, i);\n+  T (10, \"%*i\", w, R (0, 12345));\n+\n+  T (10, \"%*o\", w, i);\n+  T (10, \"%*o\", w, R (0, 12345));\n+\n+  T (10, \"%*i\", w, i);\n+  T (10, \"%*i\", w, R (0, 12345));\n+}\n+\n+void test_unknown_width_floating (int w, double d)\n+{\n+  T ( 7, \"%*a\", w, d);\n+  T (21, \"%*a\", w, 3.141);\n+\n+  T (12, \"%*e\",  w, d);    /* { dg-warning \"writing a terminating nul\" } */\n+  T (12, \"%#*e\", w, d);    /* { dg-warning \"writing a terminating nul\" } */\n+  T (13, \"%*e\",  w, d);\n+  T (13, \"%#*e\", w, d);\n+  T (13, \"%*e\",  w, 3.141);\n+\n+  T ( 8, \"%*f\",  w, d);   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 8, \"%#*f\", w, d);   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 9, \"%*f\",  w, d);\n+  T ( 9, \"%#*f\", w, d);\n+  T ( 9, \"%*f\",  w, 3.141);\n+  T ( 9, \"%#*f\", w, 3.141);\n+\n+  T (12, \"%*g\", w, d);   /* { dg-warning \"may write a terminating nul\" } */\n+  T (13, \"%*g\", w, d);\n+  T (13, \"%*g\", w, 3.141);\n+}\n+\n+void test_unknown_precision_integer (int p, int i, double d)\n+{\n+  T (10, \"%.*d\", p, i);\n+  T (10, \"%.*d\", p, R (0, 12345));\n+\n+  T (10, \"%.*i\", p, i);\n+  T (10, \"%.*i\", p, R (0, 12345));\n+\n+  T (10, \"%.*o\", p, i);\n+  T (10, \"%.*o\", p, R (0, 12345));\n+\n+  T (10, \"%.*i\", p, i);\n+  T (10, \"%.*i\", p, R (0, 12345));\n+}\n+\n+void test_unknown_precision_floating (int p, double d)\n+{\n+  T ( 7, \"%.*a\", p, d);\n+  T (21, \"%.*a\", p, 3.141);\n+\n+  /* \"%.0e\", 0.0 results in 5 bytes: \"0e+00\"  */\n+  T ( 5, \"%.*e\",  p, d);      /* { dg-warning \"writing a terminating nul\" } */\n+  /* \"%#.0e\", 0.0 results in 6 bytes: \"0.e+00\"  */\n+  T ( 6, \"%#.*e\", p, d);      /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 6, \"%.*e\",  p, d);\n+  T ( 6, \"%.*e\",  p, 3.141);\n+  T ( 6, \"%#.*e\", p, 3.141);  /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 7, \"%#.*e\", p, 3.141);\n+\n+  /* \"%.0f\", 0.0 results in 1 byte: \"0\" but precision of at least 1\n+     is likely, resulting in \"0.0\".  */\n+  T ( 3, \"%.*f\",  p, d);   /* { dg-warning \"may write a terminating nul\" } */\n+  /* \"%#.0f\", 0.0 results in 2 bytes: \"0.\" but precision of at least 1\n+     is likely, resulting in \"0.0\".  */\n+  T ( 3, \"%#.*f\", p, d);   /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 4, \"%.*f\",  p, d);\n+  T ( 4, \"%#.*f\", p, d);\n+  T ( 3, \"%.*f\",  p, 3.141); /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 4, \"%.*f\",  p, 3.141);\n+  T ( 3, \"%#.*f\", p, 3.141); /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 4, \"%#.*f\", p, 3.141);\n+\n+  T (12, \"%.*g\",  p, d);   /* { dg-warning \"may write a terminating nul\" } */\n+  T (12, \"%#.*g\", p, d);   /* { dg-warning \"may write a terminating nul\" } */\n+  T (13, \"%.*g\",  p, d);\n+  T (13, \"%#.*g\", p, d);\n+  T ( 6, \"%#.*g\", R (-1, 0), d);/* { dg-warning \"may write a terminating nul\" } */\n+  T ( 7, \"%#.*g\", R (-1, 0), d);\n+  T ( 6, \"%#.*g\", R ( 0, 0), d);/* { dg-warning \"may write a terminating nul\" } */\n+  T ( 7, \"%#.*g\", R ( 0, 0), d);\n+  T ( 6, \"%#.*g\", R ( 0, 1), d);/* { dg-warning \"may write a terminating nul\" } */\n+  T ( 7, \"%#.*g\", R ( 0, 1), d);\n+  T ( 3, \"%.*g\",  p, 3.141); /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 4, \"%.*g\",  p, 3.141);\n+  T ( 3, \"%#.*g\", p, 3.141); /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 4, \"%#.*g\", p, 3.141);\n+}\n+\n+\n+void test_unknown_width_and_precision_integer (int w, int p, int i)\n+{\n+  T (10, \"%*.*d\", w, p, i);\n+  T (10, \"%*.*d\", w, p, R (0, 12345));\n+\n+  T (10, \"%*.*i\", w, p, i);\n+  T (10, \"%*.*i\", w, p, R (0, 12345));\n+\n+  T (10, \"%*.*o\", w, p, i);\n+  T (10, \"%*.*o\", w, p, R (0, 12345));\n+\n+  T (10, \"%*.*i\", w, p, i);\n+  T (10, \"%*.*i\", w, p, R (0, 12345));\n+}\n+\n+void test_unknown_width_and_precision_floating (int w, int p, double d)\n+{\n+  T ( 7, \"%*.*a\", w, p, d);\n+  T (21, \"%*.*a\", w, p, 3.141);\n+\n+  /* \"%0.0e\", 0.0 results in 5 bytes: \"0e+00\"  */\n+  T ( 5, \"%*.*e\",  w, p, d);   /* { dg-warning \"writing a terminating nul\" } */\n+  /* \"%#0.0e\", 0.0 results in 6 bytes: \"0.e+00\"  */\n+  T ( 6, \"%#*.*e\", w, p, d);   /* { dg-warning \"writing a terminating nul\" } */\n+  T ( 6, \"%*.*e\",  w, p, d);\n+  T ( 6, \"%*.*e\",  w, p, 3.141);\n+  T ( 6, \"%#*.*e\", w, p, 3.141);/* { dg-warning \"writing a terminating nul\" } */\n+  T ( 7, \"%#*.*e\", w, p, 3.141);\n+\n+  T ( 3, \"%*.*f\",  w, p, d);  /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 3, \"%#*.*f\", w, p, d);  /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 4, \"%*.*f\",  w, p, d);\n+  T ( 4, \"%*.*f\",  w, p, 3.141);\n+  T ( 4, \"%#*.*f\", w, p, 3.141);\n+\n+  T (13, \"%*.*g\",  w, p, d);\n+  T (13, \"%#*.*g\", w, p, d);\n+  T (13, \"%*.*g\",  w, p, 3.141);\n+  T (13, \"%#*.*g\", w, p, 3.141);\n+}"}]}