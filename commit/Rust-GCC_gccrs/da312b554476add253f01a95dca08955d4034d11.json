{"sha": "da312b554476add253f01a95dca08955d4034d11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEzMTJiNTU0NDc2YWRkMjUzZjAxYTk1ZGNhMDg5NTVkNDAzNGQxMQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-02-02T19:39:47Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-02-02T19:39:47Z"}, "message": "* cpp.texi, invoke.texi: Update -Wtraditional documentation.\n\nFrom-SVN: r39414", "tree": {"sha": "402372cd6ab7f0a80af9a8e19ef20279467fb1ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/402372cd6ab7f0a80af9a8e19ef20279467fb1ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da312b554476add253f01a95dca08955d4034d11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da312b554476add253f01a95dca08955d4034d11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da312b554476add253f01a95dca08955d4034d11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da312b554476add253f01a95dca08955d4034d11/comments", "author": null, "committer": null, "parents": [{"sha": "2ca46e8a7073bd6beea8f3749348b8b54c528e42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca46e8a7073bd6beea8f3749348b8b54c528e42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ca46e8a7073bd6beea8f3749348b8b54c528e42"}], "stats": {"total": 84, "additions": 66, "deletions": 18}, "files": [{"sha": "9c80dcd26658b1be2cd6e6599278e20d5eb0b889", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da312b554476add253f01a95dca08955d4034d11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da312b554476add253f01a95dca08955d4034d11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da312b554476add253f01a95dca08955d4034d11", "patch": "@@ -1,3 +1,7 @@\n+2001-02-02  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpp.texi, invoke.texi: Update -Wtraditional documentation.\n+\n 2001-02-02  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/sh/sh.c (output_far_jump): Don't use braf on SH1.  Emit"}, {"sha": "6086e26bddc17a20e579bed8f62cc7bc9b6c6968", "filename": "gcc/cpp.texi", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da312b554476add253f01a95dca08955d4034d11/gcc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da312b554476add253f01a95dca08955d4034d11/gcc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpp.texi?ref=da312b554476add253f01a95dca08955d4034d11", "patch": "@@ -3313,6 +3313,39 @@ Requests @samp{-Wcomment}, @samp{-Wtrigraphs}, and @samp{-Wwhite-space}\n Warn about certain constructs that behave differently in traditional and\n ISO C@.\n \n+@itemize @bullet\n+@item\n+Macro parameters that appear within string literals in the macro body.\n+In traditional C macro replacement takes place within string literals,\n+but does not in ISO C.\n+\n+@item\n+In traditional C, some preprocessor directives did not exist.\n+Traditional preprocessors would only consider a line to be a directive\n+if the @samp{#} appeared in column 1 on the line.  Therefore\n+@samp{-Wtraditional} warns about directives that traditional C\n+understands but would ignore because the @samp{#} does not appear as the\n+first character on the line.  It also suggests you hide directives like\n+@samp{#pragma} not understood by traditional C by indenting them.  Some\n+traditional implementations would not recognise @samp{#elif}, so it\n+suggests avoiding it altogether.\n+\n+@item\n+A function-like macro that appears without arguments.\n+\n+@item\n+The unary plus operator.\n+\n+@item\n+The `U' integer constant suffix.  (Traditonal C does support the `L'\n+suffix on integer constants.)  Note, these suffixes appear in macros\n+defined in the system headers of most modern systems, e.g. the _MIN/_MAX\n+macros in limits.h.  Use of these macros can lead to spurious warnings\n+as they do not necessarily reflect whether the code in question is any\n+less portable to traditional C given that suitable backup definitions\n+are provided.\n+@end itemize\n+\n @item -Wundef\n @findex -Wundef\n Warn if an undefined identifier is evaluated in an @samp{#if} directive."}, {"sha": "beec0e767cfe7ea22e3aae5df0c7ef6de4431056", "filename": "gcc/invoke.texi", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da312b554476add253f01a95dca08955d4034d11/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da312b554476add253f01a95dca08955d4034d11/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=da312b554476add253f01a95dca08955d4034d11", "patch": "@@ -2068,9 +2068,35 @@ ISO C.\n \n @itemize @bullet\n @item\n-Macro arguments occurring within string constants in the macro body.\n-These would substitute the argument in traditional C, but are part of\n-the constant in ISO C.\n+Macro parameters that appear within string literals in the macro body.\n+In traditional C macro replacement takes place within string literals,\n+but does not in ISO C.\n+\n+@item\n+In traditional C, some preprocessor directives did not exist.\n+Traditional preprocessors would only consider a line to be a directive\n+if the @samp{#} appeared in column 1 on the line.  Therefore\n+@samp{-Wtraditional} warns about directives that traditional C\n+understands but would ignore because the @samp{#} does not appear as the\n+first character on the line.  It also suggests you hide directives like\n+@samp{#pragma} not understood by traditional C by indenting them.  Some\n+traditional implementations would not recognise @samp{#elif}, so it\n+suggests avoiding it altogether.\n+\n+@item\n+A function-like macro that appears without arguments.\n+\n+@item\n+The unary plus operator.\n+\n+@item\n+The `U' integer constant suffix, or the `F' or `L' floating point\n+constant suffixes.  (Traditonal C does support the `L' suffix on integer\n+constants.)  Note, these suffixes appear in macros defined in the system\n+headers of most modern systems, e.g. the _MIN/_MAX macros in limits.h.\n+Use of these macros can lead to spurious warnings as they do not\n+necessarily reflect whether the code in question is any less portable to\n+traditional C given that suitable backup definitions are provided.\n \n @item\n A function declared external in one block and then used after the end of\n@@ -2092,12 +2118,6 @@ typically represent bit patterns, are not warned about.\n @item\n Usage of ISO string concatenation is detected.\n \n-@item\n-A function macro appears without arguments.\n-\n-@item\n-The unary plus operator.\n-\n @item\n Initialization of automatic aggregates.\n \n@@ -2111,15 +2131,6 @@ omitted.  This is done under the assumption that the zero initializer in\n user code appears conditioned on e.g. @code{__STDC__} to avoid missing\n initializer warnings and relies on default initialization to zero in the\n traditional C case.\n-\n-@item\n-The `U' integer constant suffix, or the `F' or `L' floating point\n-constant suffixes.  (Traditonal C does support the `L' suffix on integer\n-constants.)  Note, these suffixes appear in macros defined in the system\n-headers of most modern systems, e.g. the _MIN/_MAX macros in limits.h.\n-Use of these macros can lead to spurious warnings as they do not\n-necessarily reflect whether the code in question is any less portable to\n-traditional C given that suitable backup definitions are provided.\n @end itemize\n \n @item -Wundef"}]}