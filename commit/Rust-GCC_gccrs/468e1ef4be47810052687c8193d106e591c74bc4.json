{"sha": "468e1ef4be47810052687c8193d106e591c74bc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY4ZTFlZjRiZTQ3ODEwMDUyNjg3YzgxOTNkMTA2ZTU5MWM3NGJjNA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-09-20T19:34:44Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-09-20T19:34:44Z"}, "message": "[PR87054] fix unaligned access\n\nBuilding an ADDR_EXPR uses the canonical type to build the pointer\ntype, but then, as we dereference it, we lose track of lax alignment\nknown to apply to the dereferenced object.  This might not be a\nproblem in general, but it is when the compiler implicitly introduces\naddress taking and dereferencing, as it does for asm statements, and\nas it may do in some loop optimizations.\n\nFrom: Richard Biener <rguenther@suse.de>\nfor  gcc/ChangeLog\n\n\tPR middle-end/87054\n\t* gimplify.c (gimplify_expr): Retain alignment of\n\taddressable lvalue in dereference.\n\nFrom: Alexandre Oliva <oliva@adacore.com>\nfor  gcc/testsuite/ChangeLog\n\n\tPR middle-end/87054\n\t* gcc.dg/pr87054.c: New.\n\nFrom-SVN: r264450", "tree": {"sha": "420d98d2ccab135a9a94d7371b6f9f0f1ae6acd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/420d98d2ccab135a9a94d7371b6f9f0f1ae6acd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/468e1ef4be47810052687c8193d106e591c74bc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468e1ef4be47810052687c8193d106e591c74bc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/468e1ef4be47810052687c8193d106e591c74bc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/468e1ef4be47810052687c8193d106e591c74bc4/comments", "author": null, "committer": null, "parents": [{"sha": "894f597f8fb8693a5d0f5834e98a8ccebbbb9106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894f597f8fb8693a5d0f5834e98a8ccebbbb9106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/894f597f8fb8693a5d0f5834e98a8ccebbbb9106"}], "stats": {"total": 48, "additions": 47, "deletions": 1}, "files": [{"sha": "361dfc468a1712dffb58657cd18a3c16bfe5a19a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468e1ef4be47810052687c8193d106e591c74bc4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468e1ef4be47810052687c8193d106e591c74bc4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=468e1ef4be47810052687c8193d106e591c74bc4", "patch": "@@ -1,3 +1,9 @@\n+2018-09-20  Richard Biener <rguenther@suse.de>\n+\n+\tPR middle-end/87054\n+\t* gimplify.c (gimplify_expr): Retain alignment of\n+\taddressable lvalue in dereference.\n+\n 2018-09-20  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR bootstrap/87013"}, {"sha": "509fc2f3f5be20985558e8b4f2e94a7cbf814567", "filename": "gcc/gimplify.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468e1ef4be47810052687c8193d106e591c74bc4/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468e1ef4be47810052687c8193d106e591c74bc4/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=468e1ef4be47810052687c8193d106e591c74bc4", "patch": "@@ -12538,9 +12538,15 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       /* An lvalue will do.  Take the address of the expression, store it\n \t in a temporary, and replace the expression with an INDIRECT_REF of\n \t that temporary.  */\n+      tree ref_alias_type = reference_alias_ptr_type (*expr_p);\n+      unsigned int ref_align = get_object_alignment (*expr_p);\n+      tree ref_type = TREE_TYPE (*expr_p);\n       tmp = build_fold_addr_expr_loc (input_location, *expr_p);\n       gimplify_expr (&tmp, pre_p, post_p, is_gimple_reg, fb_rvalue);\n-      *expr_p = build_simple_mem_ref (tmp);\n+      if (TYPE_ALIGN (ref_type) != ref_align)\n+\tref_type = build_aligned_type (ref_type, ref_align);\n+      *expr_p = build2 (MEM_REF, ref_type,\n+\t\t\ttmp, build_zero_cst (ref_alias_type));\n     }\n   else if ((fallback & fb_rvalue) && is_gimple_reg_rhs_or_call (*expr_p))\n     {"}, {"sha": "a0a08a4d499856a1cb8712b3851c66a01e566cb5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468e1ef4be47810052687c8193d106e591c74bc4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468e1ef4be47810052687c8193d106e591c74bc4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=468e1ef4be47810052687c8193d106e591c74bc4", "patch": "@@ -1,3 +1,8 @@\n+2018-09-20  Alexandre Oliva <oliva@adacore.com>\n+\n+\tPR middle-end/87054\n+\t* gcc.dg/pr87054.c: New.\n+\n 2018-09-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/87288"}, {"sha": "4ca2b62d2c7c97516c7032dd3f253cde4986127e", "filename": "gcc/testsuite/gcc.dg/pr87054.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/468e1ef4be47810052687c8193d106e591c74bc4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87054.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/468e1ef4be47810052687c8193d106e591c74bc4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87054.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr87054.c?ref=468e1ef4be47810052687c8193d106e591c74bc4", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+\n+#ifndef T\n+# ifdef __SSE__\n+#  define T __int128\n+# else\n+#  define T long\n+# endif\n+#endif\n+#ifndef R\n+# ifdef __SSE__\n+#  define R \"x\"\n+# else\n+#  define R \"r\"\n+# endif\n+#endif\n+\n+\n+typedef T A; // #define T to long or __int128\n+struct B { char d; A c; } __attribute__((packed));\n+struct B b[50]; // many elements to avoid loop unrolling\n+\n+int main () {\n+  int i;\n+  for (i = 0; i < sizeof(b) / sizeof(*b); i++) {\n+    asm (\"\" : \"+\" R (b[i].c)); // #define R to \"r\" on ppc or \"x\" on x86_64\n+  }\n+}"}]}