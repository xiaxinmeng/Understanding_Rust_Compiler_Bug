{"sha": "d9206abba7e6ac0328cafb3f3556c17220101024", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkyMDZhYmJhN2U2YWMwMzI4Y2FmYjNmMzU1NmMxNzIyMDEwMTAyNA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2020-06-03T18:07:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-16T09:17:58Z"}, "message": "[Ada] Ada2020: AI12-0107 convention of By_Protected_Procedure\n\ngcc/ada/\n\n\t* exp_attr.adb (Has_By_Protected_Procedure_Prefixed_View): New\n\tsubprogram.\n\t(Expand_Access_To_Protected_Op): Adding support for prefixed\n\tclass-wide view with By_Protected_Procedure convention.\n\t* sem_attr.adb (Get_Convention): New subprogram.\n\t(Get_Kind): Adapted to use Get_Convention.\n\t* sem_ch4.adb (Try_By_Protected_Procedure_Prefixed_View): New\n\tsubprogram.\n\t(Analyze_Selected_Component): Invoke\n\tTry_By_Protected_Procedure_Prefixed_View.\n\t* sem_util.ads (Is_By_Protected_Procedure): New subprogram.\n\t* sem_util.adb (Is_By_Protected_Procedure): New subprogram.", "tree": {"sha": "35a94ff1a9ff533796e5ce59755b4490d0bade8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35a94ff1a9ff533796e5ce59755b4490d0bade8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9206abba7e6ac0328cafb3f3556c17220101024", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9206abba7e6ac0328cafb3f3556c17220101024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9206abba7e6ac0328cafb3f3556c17220101024", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9206abba7e6ac0328cafb3f3556c17220101024/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4a99831f4fee023e50f4116318e678757bdf4ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4a99831f4fee023e50f4116318e678757bdf4ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4a99831f4fee023e50f4116318e678757bdf4ed"}], "stats": {"total": 223, "additions": 203, "deletions": 20}, "files": [{"sha": "08c711800e918ca804da19b47b5744c36a1d2107", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 94, "deletions": 16, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9206abba7e6ac0328cafb3f3556c17220101024/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9206abba7e6ac0328cafb3f3556c17220101024/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=d9206abba7e6ac0328cafb3f3556c17220101024", "patch": "@@ -941,7 +941,30 @@ package body Exp_Attr is\n    is\n       --  The value of the attribute_reference is a record containing two\n       --  fields: an access to the protected object, and an access to the\n-      --  subprogram itself. The prefix is a selected component.\n+      --  subprogram itself. The prefix is an identifier or a selected\n+      --  component.\n+\n+      function Has_By_Protected_Procedure_Prefixed_View return Boolean;\n+      --  Determine whether Pref denotes the prefixed class-wide interface\n+      --  view of a procedure with synchronization kind By_Protected_Procedure.\n+\n+      ----------------------------------------------\n+      -- Has_By_Protected_Procedure_Prefixed_View --\n+      ----------------------------------------------\n+\n+      function Has_By_Protected_Procedure_Prefixed_View return Boolean is\n+      begin\n+         return Nkind (Pref) = N_Selected_Component\n+           and then Nkind (Prefix (Pref)) in N_Has_Entity\n+           and then Present (Entity (Prefix (Pref)))\n+           and then Is_Class_Wide_Type (Etype (Entity (Prefix (Pref))))\n+           and then (Is_Synchronized_Interface (Etype (Entity (Prefix (Pref))))\n+                       or else\n+                     Is_Protected_Interface (Etype (Entity (Prefix (Pref)))))\n+           and then Is_By_Protected_Procedure (Entity (Selector_Name (Pref)));\n+      end Has_By_Protected_Procedure_Prefixed_View;\n+\n+      --  Local variables\n \n       Loc     : constant Source_Ptr := Sloc (N);\n       Agg     : Node_Id;\n@@ -1015,6 +1038,23 @@ package body Exp_Attr is\n                 Attribute_Name => Name_Address);\n          end if;\n \n+      elsif Has_By_Protected_Procedure_Prefixed_View then\n+         Obj_Ref :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix => Relocate_Node (Prefix (Pref)),\n+               Attribute_Name => Name_Address);\n+\n+         --  Analyze the object address with expansion disabled. Required\n+         --  because its expansion would displace the pointer to the object,\n+         --  which is not correct at this stage since the object type is a\n+         --  class-wide interface type and we are dispatching a call to a\n+         --  thunk (which would erroneously displace the pointer again).\n+\n+         Expander_Mode_Save_And_Set (False);\n+         Analyze (Obj_Ref);\n+         Set_Analyzed (Obj_Ref);\n+         Expander_Mode_Restore;\n+\n       --  Case where the prefix is not an entity name. Find the\n       --  version of the protected operation to be called from\n       --  outside the protected object.\n@@ -1031,26 +1071,64 @@ package body Exp_Attr is\n                Attribute_Name => Name_Address);\n       end if;\n \n-      Sub_Ref :=\n-        Make_Attribute_Reference (Loc,\n-          Prefix         => Sub,\n-          Attribute_Name => Name_Access);\n+      if Has_By_Protected_Procedure_Prefixed_View then\n+         declare\n+            Ctrl_Tag  : Node_Id := Duplicate_Subexpr (Prefix (Pref));\n+            Prim_Addr : Node_Id;\n+            Subp      : constant Entity_Id := Entity (Selector_Name (Pref));\n+            Typ       : constant Entity_Id :=\n+                          Etype (Etype (Entity (Prefix (Pref))));\n+         begin\n+            --  The target subprogram is a thunk; retrieve its address from\n+            --  its secondary dispatch table slot.\n+\n+            Build_Get_Prim_Op_Address (Loc,\n+              Typ      => Typ,\n+              Tag_Node => Ctrl_Tag,\n+              Position => DT_Position (Subp),\n+              New_Node => Prim_Addr);\n+\n+            --  Mark the access to the target subprogram as an access to the\n+            --  dispatch table and perform an unchecked type conversion to such\n+            --  access type. This is required to allow the backend to properly\n+            --  identify and handle the access to the dispatch table slot on\n+            --  targets where the dispatch table contains descriptors (instead\n+            --  of pointers).\n+\n+            Set_Is_Dispatch_Table_Entity (Acc);\n+            Sub_Ref := Unchecked_Convert_To (Acc, Prim_Addr);\n+            Analyze (Sub_Ref);\n+\n+            Agg :=\n+              Make_Aggregate (Loc,\n+                Expressions => New_List (Obj_Ref, Sub_Ref));\n+         end;\n+\n+      --  Common case\n \n-      --  We set the type of the access reference to the already generated\n-      --  access_to_subprogram type, and declare the reference analyzed, to\n-      --  prevent further expansion when the enclosing aggregate is analyzed.\n+      else\n+         Sub_Ref :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => Sub,\n+             Attribute_Name => Name_Access);\n \n-      Set_Etype (Sub_Ref, Acc);\n-      Set_Analyzed (Sub_Ref);\n+         --  We set the type of the access reference to the already generated\n+         --  access_to_subprogram type, and declare the reference analyzed,\n+         --  to prevent further expansion when the enclosing aggregate is\n+         --  analyzed.\n \n-      Agg :=\n-        Make_Aggregate (Loc,\n-          Expressions => New_List (Obj_Ref, Sub_Ref));\n+         Set_Etype (Sub_Ref, Acc);\n+         Set_Analyzed (Sub_Ref);\n \n-      --  Sub_Ref has been marked as analyzed, but we still need to make sure\n-      --  Sub is correctly frozen.\n+         Agg :=\n+           Make_Aggregate (Loc,\n+             Expressions => New_List (Obj_Ref, Sub_Ref));\n \n-      Freeze_Before (N, Entity (Sub));\n+         --  Sub_Ref has been marked as analyzed, but we still need to make\n+         --  sure Sub is correctly frozen.\n+\n+         Freeze_Before (N, Entity (Sub));\n+      end if;\n \n       Rewrite (N, Agg);\n       Analyze_And_Resolve (N, E_T);"}, {"sha": "78da069ba102bfbc780bcbbb0d7b1617bd0bc11d", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9206abba7e6ac0328cafb3f3556c17220101024/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9206abba7e6ac0328cafb3f3556c17220101024/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=d9206abba7e6ac0328cafb3f3556c17220101024", "patch": "@@ -650,7 +650,8 @@ package body Sem_Attr is\n             --  tracked value. If the scope is a loop or block, indicate that\n             --  value tracking is disabled for the enclosing subprogram.\n \n-            function Get_Kind (E : Entity_Id) return Entity_Kind;\n+            function Get_Convention (E : Entity_Id) return Convention_Id;\n+            function Get_Kind       (E : Entity_Id) return Entity_Kind;\n             --  Distinguish between access to regular/protected subprograms\n \n             ------------------------\n@@ -666,13 +667,33 @@ package body Sem_Attr is\n                end if;\n             end Check_Local_Access;\n \n+            --------------------\n+            -- Get_Convention --\n+            --------------------\n+\n+            function Get_Convention (E : Entity_Id) return Convention_Id is\n+            begin\n+               --  Restrict handling by_protected_procedure access subprograms\n+               --  to source entities; required to avoid building access to\n+               --  subprogram types with convention protected when building\n+               --  dispatch tables.\n+\n+               if Comes_From_Source (P)\n+                 and then Is_By_Protected_Procedure (E)\n+               then\n+                  return Convention_Protected;\n+               else\n+                  return Convention (E);\n+               end if;\n+            end Get_Convention;\n+\n             --------------\n             -- Get_Kind --\n             --------------\n \n             function Get_Kind (E : Entity_Id) return Entity_Kind is\n             begin\n-               if Convention (E) = Convention_Protected then\n+               if Get_Convention (E) = Convention_Protected then\n                   return E_Access_Protected_Subprogram_Type;\n                else\n                   return E_Access_Subprogram_Type;\n@@ -717,7 +738,7 @@ package body Sem_Attr is\n                   Acc_Type := Create_Itype (Get_Kind (Entity (P)), N);\n                   Set_Is_Public (Acc_Type, False);\n                   Set_Etype (Acc_Type, Acc_Type);\n-                  Set_Convention (Acc_Type, Convention (Entity (P)));\n+                  Set_Convention (Acc_Type, Get_Convention (Entity (P)));\n                   Set_Directly_Designated_Type (Acc_Type, Entity (P));\n                   Set_Etype (N, Acc_Type);\n                   Freeze_Before (N, Acc_Type);\n@@ -732,7 +753,7 @@ package body Sem_Attr is\n                      Acc_Type := Create_Itype (Get_Kind (It.Nam), N);\n                      Set_Is_Public (Acc_Type, False);\n                      Set_Etype (Acc_Type, Acc_Type);\n-                     Set_Convention (Acc_Type, Convention (It.Nam));\n+                     Set_Convention (Acc_Type, Get_Convention (It.Nam));\n                      Set_Directly_Designated_Type (Acc_Type, It.Nam);\n                      Add_One_Interp (N, Acc_Type, Acc_Type);\n                      Freeze_Before (N, Acc_Type);"}, {"sha": "8c9a0bf4dfb8e75d2533d54f8d68d9321d3ef4db", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9206abba7e6ac0328cafb3f3556c17220101024/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9206abba7e6ac0328cafb3f3556c17220101024/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=d9206abba7e6ac0328cafb3f3556c17220101024", "patch": "@@ -4476,6 +4476,13 @@ package body Sem_Ch4 is\n       --  Check whether prefix includes a dereference, explicit or implicit,\n       --  at any recursive level.\n \n+      function Try_By_Protected_Procedure_Prefixed_View return Boolean;\n+      --  Return True if N is an access attribute whose prefix is a prefixed\n+      --  class-wide (synchronized or protected) interface view for which some\n+      --  interpretation is a procedure with synchronization kind By_Protected\n+      --  _Procedure, and collect all its interpretations (since it may be an\n+      --  overloaded interface primitive); otherwise return False.\n+\n       --------------------------------\n       -- Find_Component_In_Instance --\n       --------------------------------\n@@ -4597,6 +4604,65 @@ package body Sem_Ch4 is\n          end if;\n       end Has_Dereference;\n \n+      ----------------------------------------------\n+      -- Try_By_Protected_Procedure_Prefixed_View --\n+      ----------------------------------------------\n+\n+      function Try_By_Protected_Procedure_Prefixed_View return Boolean is\n+         Candidate : Node_Id := Empty;\n+         Elmt      : Elmt_Id;\n+         Prim      : Node_Id;\n+\n+      begin\n+         if Nkind (Parent (N)) = N_Attribute_Reference\n+           and then Nam_In (Attribute_Name (Parent (N)),\n+                      Name_Access,\n+                      Name_Unchecked_Access,\n+                      Name_Unrestricted_Access)\n+           and then Is_Class_Wide_Type (Prefix_Type)\n+           and then (Is_Synchronized_Interface (Prefix_Type)\n+                       or else Is_Protected_Interface (Prefix_Type))\n+         then\n+            --  If we have not found yet any interpretation then mark this\n+            --  one as the first interpretation (cf. Add_One_Interp).\n+\n+            if No (Etype (Sel)) then\n+               Set_Etype (Sel, Any_Type);\n+            end if;\n+\n+            Elmt := First_Elmt (Primitive_Operations (Etype (Prefix_Type)));\n+            while Present (Elmt) loop\n+               Prim := Node (Elmt);\n+\n+               if Chars (Prim) = Chars (Sel)\n+                 and then Is_By_Protected_Procedure (Prim)\n+               then\n+                  Candidate := New_Copy (Prim);\n+\n+                  --  Skip the controlling formal; required to check type\n+                  --  conformance of the target access to protected type\n+                  --  (see Conforming_Types).\n+\n+                  Set_First_Entity (Candidate,\n+                    Next_Entity (First_Entity (Prim)));\n+\n+                  Add_One_Interp (Sel, Candidate, Etype (Prim));\n+                  Set_Etype (N, Etype (Prim));\n+               end if;\n+\n+               Next_Elmt (Elmt);\n+            end loop;\n+         end if;\n+\n+         --  Propagate overloaded attribute\n+\n+         if Present (Candidate) and then Is_Overloaded (Sel) then\n+            Set_Is_Overloaded (N);\n+         end if;\n+\n+         return Present (Candidate);\n+      end Try_By_Protected_Procedure_Prefixed_View;\n+\n    --  Start of processing for Analyze_Selected_Component\n \n    begin\n@@ -4892,6 +4958,9 @@ package body Sem_Ch4 is\n                   return;\n                end if;\n \n+            elsif Try_By_Protected_Procedure_Prefixed_View then\n+               return;\n+\n             elsif Try_Object_Operation (N) then\n                return;\n             end if;"}, {"sha": "228cca21711695c982994a6bdd0b27e9c8c7aafc", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9206abba7e6ac0328cafb3f3556c17220101024/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9206abba7e6ac0328cafb3f3556c17220101024/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d9206abba7e6ac0328cafb3f3556c17220101024", "patch": "@@ -14565,6 +14565,17 @@ package body Sem_Util is\n                   Is_RTE (Root_Type (Under), RO_WW_Super_String));\n    end Is_Bounded_String;\n \n+   -------------------------------\n+   -- Is_By_Protected_Procedure --\n+   -------------------------------\n+\n+   function Is_By_Protected_Procedure (Id : Entity_Id) return Boolean is\n+   begin\n+      return Ekind (Id) = E_Procedure\n+        and then Present (Get_Rep_Pragma (Id, Name_Implemented))\n+        and then Implementation_Kind (Id) = Name_By_Protected_Procedure;\n+   end Is_By_Protected_Procedure;\n+\n    ---------------------\n    -- Is_CCT_Instance --\n    ---------------------"}, {"sha": "9e62170e8f6c908bea8c590def02bfd70d81cc60", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9206abba7e6ac0328cafb3f3556c17220101024/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9206abba7e6ac0328cafb3f3556c17220101024/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d9206abba7e6ac0328cafb3f3556c17220101024", "patch": "@@ -1640,6 +1640,10 @@ package Sem_Util is\n    --  True if T is a bounded string type. Used to make sure \"=\" composes\n    --  properly for bounded string types.\n \n+   function Is_By_Protected_Procedure (Id : Entity_Id) return Boolean;\n+   --  Determine whether entity Id denotes a procedure with synchronization\n+   --  kind By_Protected_Procedure.\n+\n    function Is_Constant_Bound (Exp : Node_Id) return Boolean;\n    --  Exp is the expression for an array bound. Determines whether the\n    --  bound is a compile-time known value, or a constant entity, or an"}]}