{"sha": "1212cfad09378bc85860a7de22dde0cf7a19fd01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIxMmNmYWQwOTM3OGJjODU4NjBhN2RlMjJkZGUwY2Y3YTE5ZmQwMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-24T11:44:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-31T06:22:45Z"}, "message": "Improve var-tracking dataflow iteration order\n\nThis builds upon the rev_post_order_and_mark_dfs_back_seme improvements\nand makes vt_find_locations iterate over the dataflow problems for\neach toplevel SCC separately, improving memory locality and avoiding\nto process nodes after the SCC before the SCC itself stabilized.\n\nOn the asan_interceptors.cc testcase this for example reduces the\nnumber of visited blocks from 3751 to 2867.  For stage3-gcc\nthis reduces the number of visited blocks by ~4%.\n\n2020-07-28  Richard Biener  <rguenther@suse.de>\n\n\tPR debug/78288\n\t* var-tracking.c (vt_find_locations): Use\n\trev_post_order_and_mark_dfs_back_seme and separately iterate\n\tover toplevel SCCs.", "tree": {"sha": "db2fc19d73115779ac2b55366eef77bb86fa5977", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db2fc19d73115779ac2b55366eef77bb86fa5977"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1212cfad09378bc85860a7de22dde0cf7a19fd01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1212cfad09378bc85860a7de22dde0cf7a19fd01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1212cfad09378bc85860a7de22dde0cf7a19fd01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1212cfad09378bc85860a7de22dde0cf7a19fd01/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e61a2056335ca7d4e2009823efae4ee2dc950ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e61a2056335ca7d4e2009823efae4ee2dc950ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e61a2056335ca7d4e2009823efae4ee2dc950ee"}], "stats": {"total": 274, "additions": 151, "deletions": 123}, "files": [{"sha": "743f5dcecf68246936b992a73af9bbb97f3c9bcb", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 151, "deletions": 123, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1212cfad09378bc85860a7de22dde0cf7a19fd01/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1212cfad09378bc85860a7de22dde0cf7a19fd01/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=1212cfad09378bc85860a7de22dde0cf7a19fd01", "patch": "@@ -7084,164 +7084,191 @@ vt_find_locations (void)\n      so that the data-flow runs faster.  */\n   rc_order = XNEWVEC (int, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);\n   bb_order = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-  pre_and_rev_post_order_compute (NULL, rc_order, false);\n-  for (i = 0; i < n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS; i++)\n+  auto_bitmap exit_bbs;\n+  bitmap_set_bit (exit_bbs, EXIT_BLOCK);\n+  auto_vec<std::pair<int, int> > toplevel_scc_extents;\n+  int n = rev_post_order_and_mark_dfs_back_seme\n+    (cfun, single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)), exit_bbs, true,\n+     rc_order, &toplevel_scc_extents);\n+  for (i = 0; i < n; i++)\n     bb_order[rc_order[i]] = i;\n-  free (rc_order);\n \n   in_worklist = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   in_pending = sbitmap_alloc (last_basic_block_for_fn (cfun));\n   bitmap_clear (in_worklist);\n \n-  FOR_EACH_BB_FN (bb, cfun)\n-    pending->insert (bb_order[bb->index], bb);\n-  bitmap_ones (in_pending);\n-\n-  while (success && !pending->empty ())\n-    {\n-      std::swap (worklist, pending);\n-      std::swap (in_worklist, in_pending);\n+  /* We're performing the dataflow iteration independently over the\n+     toplevel SCCs plus leading non-cyclic entry blocks and separately\n+     over the tail.  That ensures best memory locality and the least\n+     number of visited blocks.  */\n+  unsigned extent = 0;\n+  int curr_start = -1;\n+  int curr_end = -1;\n+  do\n+    {\n+      curr_start = curr_end + 1;\n+      if (toplevel_scc_extents.length () <= extent)\n+\tcurr_end = n - 1;\n+      else\n+\tcurr_end = toplevel_scc_extents[extent++].second;\n \n-      while (!worklist->empty ())\n+      for (int i = curr_start; i <= curr_end; ++i)\n \t{\n-\t  bool changed;\n-\t  edge_iterator ei;\n-\t  int oldinsz, oldoutsz;\n+\t  pending->insert (i, BASIC_BLOCK_FOR_FN (cfun, rc_order[i]));\n+\t  bitmap_set_bit (in_pending, rc_order[i]);\n+\t}\n \n-\t  bb = worklist->extract_min ();\n-\t  bitmap_clear_bit (in_worklist, bb->index);\n+      while (success && !pending->empty ())\n+\t{\n+\t  std::swap (worklist, pending);\n+\t  std::swap (in_worklist, in_pending);\n \n-\t  if (VTI (bb)->in.vars)\n+\t  while (!worklist->empty ())\n \t    {\n-\t      htabsz -= (shared_hash_htab (VTI (bb)->in.vars)->size ()\n-\t\t\t + shared_hash_htab (VTI (bb)->out.vars)->size ());\n-\t      oldinsz = shared_hash_htab (VTI (bb)->in.vars)->elements ();\n-\t      oldoutsz = shared_hash_htab (VTI (bb)->out.vars)->elements ();\n-\t    }\n-\t  else\n-\t    oldinsz = oldoutsz = 0;\n+\t      bool changed;\n+\t      edge_iterator ei;\n+\t      int oldinsz, oldoutsz;\n \n-\t  if (MAY_HAVE_DEBUG_BIND_INSNS)\n-\t    {\n-\t      dataflow_set *in = &VTI (bb)->in, *first_out = NULL;\n-\t      bool first = true, adjust = false;\n+\t      bb = worklist->extract_min ();\n+\t      bitmap_clear_bit (in_worklist, bb->index);\n \n-\t      /* Calculate the IN set as the intersection of\n-\t\t predecessor OUT sets.  */\n+\t      if (VTI (bb)->in.vars)\n+\t\t{\n+\t\t  htabsz -= (shared_hash_htab (VTI (bb)->in.vars)->size ()\n+\t\t\t     + shared_hash_htab (VTI (bb)->out.vars)->size ());\n+\t\t  oldinsz = shared_hash_htab (VTI (bb)->in.vars)->elements ();\n+\t\t  oldoutsz = shared_hash_htab (VTI (bb)->out.vars)->elements ();\n+\t\t}\n+\t      else\n+\t\toldinsz = oldoutsz = 0;\n \n-\t      dataflow_set_clear (in);\n-\t      dst_can_be_shared = true;\n+\t      if (MAY_HAVE_DEBUG_BIND_INSNS)\n+\t\t{\n+\t\t  dataflow_set *in = &VTI (bb)->in, *first_out = NULL;\n+\t\t  bool first = true, adjust = false;\n \n-\t      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t\tif (!VTI (e->src)->flooded)\n-\t\t  gcc_assert (bb_order[bb->index]\n-\t\t\t      <= bb_order[e->src->index]);\n-\t\telse if (first)\n-\t\t  {\n-\t\t    dataflow_set_copy (in, &VTI (e->src)->out);\n-\t\t    first_out = &VTI (e->src)->out;\n-\t\t    first = false;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    dataflow_set_merge (in, &VTI (e->src)->out);\n-\t\t    adjust = true;\n-\t\t  }\n+\t\t  /* Calculate the IN set as the intersection of\n+\t\t     predecessor OUT sets.  */\n \n-\t      if (adjust)\n-\t\t{\n-\t\t  dataflow_post_merge_adjust (in, &VTI (bb)->permp);\n+\t\t  dataflow_set_clear (in);\n+\t\t  dst_can_be_shared = true;\n \n-\t\t  if (flag_checking)\n-\t\t    /* Merge and merge_adjust should keep entries in\n-\t\t       canonical order.  */\n-\t\t    shared_hash_htab (in->vars)\n-\t\t      ->traverse <dataflow_set *,\n-\t\t\t\t  canonicalize_loc_order_check> (in);\n+\t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t\t    if (!VTI (e->src)->flooded)\n+\t\t      gcc_assert (bb_order[bb->index]\n+\t\t\t\t  <= bb_order[e->src->index]);\n+\t\t    else if (first)\n+\t\t      {\n+\t\t\tdataflow_set_copy (in, &VTI (e->src)->out);\n+\t\t\tfirst_out = &VTI (e->src)->out;\n+\t\t\tfirst = false;\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tdataflow_set_merge (in, &VTI (e->src)->out);\n+\t\t\tadjust = true;\n+\t\t      }\n \n-\t\t  if (dst_can_be_shared)\n+\t\t  if (adjust)\n \t\t    {\n-\t\t      shared_hash_destroy (in->vars);\n-\t\t      in->vars = shared_hash_copy (first_out->vars);\n-\t\t    }\n-\t\t}\n+\t\t      dataflow_post_merge_adjust (in, &VTI (bb)->permp);\n \n-\t      VTI (bb)->flooded = true;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Calculate the IN set as union of predecessor OUT sets.  */\n-\t      dataflow_set_clear (&VTI (bb)->in);\n-\t      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t\tdataflow_set_union (&VTI (bb)->in, &VTI (e->src)->out);\n-\t    }\n+\t\t      if (flag_checking)\n+\t\t\t/* Merge and merge_adjust should keep entries in\n+\t\t\t   canonical order.  */\n+\t\t\tshared_hash_htab (in->vars)\n+\t\t\t  ->traverse <dataflow_set *,\n+\t\t\t\t      canonicalize_loc_order_check> (in);\n \n-\t  changed = compute_bb_dataflow (bb);\n-\t  n_blocks_processed++;\n-\t  htabsz += (shared_hash_htab (VTI (bb)->in.vars)->size ()\n-\t\t     + shared_hash_htab (VTI (bb)->out.vars)->size ());\n+\t\t      if (dst_can_be_shared)\n+\t\t\t{\n+\t\t\t  shared_hash_destroy (in->vars);\n+\t\t\t  in->vars = shared_hash_copy (first_out->vars);\n+\t\t\t}\n+\t\t    }\n \n-\t  if (htabmax && htabsz > htabmax)\n-\t    {\n-\t      if (MAY_HAVE_DEBUG_BIND_INSNS)\n-\t\tinform (DECL_SOURCE_LOCATION (cfun->decl),\n-\t\t\t\"variable tracking size limit exceeded with \"\n-\t\t\t\"%<-fvar-tracking-assignments%>, retrying without\");\n+\t\t  VTI (bb)->flooded = true;\n+\t\t}\n \t      else\n-\t\tinform (DECL_SOURCE_LOCATION (cfun->decl),\n-\t\t\t\"variable tracking size limit exceeded\");\n-\t      success = false;\n-\t      break;\n-\t    }\n+\t\t{\n+\t\t  /* Calculate the IN set as union of predecessor OUT sets.  */\n+\t\t  dataflow_set_clear (&VTI (bb)->in);\n+\t\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t\t    dataflow_set_union (&VTI (bb)->in, &VTI (e->src)->out);\n+\t\t}\n \n-\t  if (changed)\n-\t    {\n-\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t      changed = compute_bb_dataflow (bb);\n+\t      n_blocks_processed++;\n+\t      htabsz += (shared_hash_htab (VTI (bb)->in.vars)->size ()\n+\t\t\t + shared_hash_htab (VTI (bb)->out.vars)->size ());\n+\n+\t      if (htabmax && htabsz > htabmax)\n \t\t{\n-\t\t  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t\t    continue;\n+\t\t  if (MAY_HAVE_DEBUG_BIND_INSNS)\n+\t\t    inform (DECL_SOURCE_LOCATION (cfun->decl),\n+\t\t\t    \"variable tracking size limit exceeded with \"\n+\t\t\t    \"%<-fvar-tracking-assignments%>, retrying without\");\n+\t\t  else\n+\t\t    inform (DECL_SOURCE_LOCATION (cfun->decl),\n+\t\t\t    \"variable tracking size limit exceeded\");\n+\t\t  success = false;\n+\t\t  break;\n+\t\t}\n \n-\t\t  /* Iterate to an earlier block in RPO in the next\n-\t\t     round, iterate to the same block immediately.  */\n-\t\t  if (bb_order[e->dest->index] < bb_order[bb->index])\n+\t      if (changed)\n+\t\t{\n+\t\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t    {\n-\t\t      if (!bitmap_bit_p (in_pending, e->dest->index))\n+\t\t      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t\t\tcontinue;\n+\n+\t\t      /* Iterate to an earlier block in RPO in the next\n+\t\t\t round, iterate to the same block immediately.  */\n+\t\t      if (bb_order[e->dest->index] < bb_order[bb->index])\n \t\t\t{\n-\t\t\t  /* Send E->DEST to next round.  */\n-\t\t\t  bitmap_set_bit (in_pending, e->dest->index);\n-\t\t\t  pending->insert (bb_order[e->dest->index],\n-\t\t\t\t\t   e->dest);\n+\t\t\t  gcc_assert (bb_order[e->dest->index] >= curr_start);\n+\t\t\t  if (!bitmap_bit_p (in_pending, e->dest->index))\n+\t\t\t    {\n+\t\t\t      /* Send E->DEST to next round.  */\n+\t\t\t      bitmap_set_bit (in_pending, e->dest->index);\n+\t\t\t      pending->insert (bb_order[e->dest->index],\n+\t\t\t\t\t       e->dest);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else if (bb_order[e->dest->index] <= curr_end\n+\t\t\t       && !bitmap_bit_p (in_worklist, e->dest->index))\n+\t\t\t{\n+\t\t\t  /* Add E->DEST to current round or delay\n+\t\t\t     processing if it is in the next SCC.  */\n+\t\t\t  bitmap_set_bit (in_worklist, e->dest->index);\n+\t\t\t  worklist->insert (bb_order[e->dest->index],\n+\t\t\t\t\t    e->dest);\n \t\t\t}\n-\t\t    }\n-\t\t  else if (!bitmap_bit_p (in_worklist, e->dest->index))\n-\t\t    {\n-\t\t      /* Add E->DEST to current round.  */\n-\t\t      bitmap_set_bit (in_worklist, e->dest->index);\n-\t\t      worklist->insert (bb_order[e->dest->index],\n-\t\t\t\t\te->dest);\n \t\t    }\n \t\t}\n-\t    }\n \n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"BB %i: in %i (was %i), out %i (was %i), rem %i + %i, tsz %i\\n\",\n-\t\t     bb->index,\n-\t\t     (int)shared_hash_htab (VTI (bb)->in.vars)->size (),\n-\t\t     oldinsz,\n-\t\t     (int)shared_hash_htab (VTI (bb)->out.vars)->size (),\n-\t\t     oldoutsz,\n-\t\t     (int)worklist->nodes (), (int)pending->nodes (), htabsz);\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"BB %i IN:\\n\", bb->index);\n-\t      dump_dataflow_set (&VTI (bb)->in);\n-\t      fprintf (dump_file, \"BB %i OUT:\\n\", bb->index);\n-\t      dump_dataflow_set (&VTI (bb)->out);\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"BB %i: in %i (was %i), out %i (was %i), rem %i + %i, \"\n+\t\t\t \"tsz %i\\n\", bb->index,\n+\t\t\t (int)shared_hash_htab (VTI (bb)->in.vars)->size (),\n+\t\t\t oldinsz,\n+\t\t\t (int)shared_hash_htab (VTI (bb)->out.vars)->size (),\n+\t\t\t oldoutsz,\n+\t\t\t (int)worklist->nodes (), (int)pending->nodes (),\n+\t\t\t htabsz);\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"BB %i IN:\\n\", bb->index);\n+\t\t  dump_dataflow_set (&VTI (bb)->in);\n+\t\t  fprintf (dump_file, \"BB %i OUT:\\n\", bb->index);\n+\t\t  dump_dataflow_set (&VTI (bb)->out);\n+\t\t}\n \t    }\n \t}\n     }\n+  while (curr_end != n - 1);\n \n   statistics_counter_event (cfun, \"compute_bb_dataflow times\",\n \t\t\t    n_blocks_processed);\n@@ -7250,6 +7277,7 @@ vt_find_locations (void)\n     FOR_EACH_BB_FN (bb, cfun)\n       gcc_assert (VTI (bb)->flooded);\n \n+  free (rc_order);\n   free (bb_order);\n   delete worklist;\n   delete pending;"}]}