{"sha": "d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNiMWVmN2E4M2MwYzBjZDViMjBhMWRkMTcxNGI4NjhmM2QyYjQ0Mg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-06-08T18:45:57Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-06-08T18:45:57Z"}, "message": "analyzer: bitfield fixes [PR99212]\n\nThis patch verifies the previous fix for bitfield sizes by implementing\nenough support for bitfields in the analyzer to get the test cases to pass.\n\nThe patch implements support in the analyzer for reading from a\nBIT_FIELD_REF, and support for folding BIT_AND_EXPR of a mask, to handle\nthe cases generated in tests.\n\nThe existing bitfields tests in data-model-1.c turned out to rely on\nundefined behavior, in that they were assigning values to a signed\nbitfield that were outside of the valid range of values.  I believe that\nthat's why we were seeing target-specific differences in the test\nresults (PR analyzer/99212).  The patch updates the test to remove the\nundefined behaviors.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/99212\n\t* region-model-manager.cc\n\t(region_model_manager::maybe_fold_binop): Add support for folding\n\tBIT_AND_EXPR of compound_svalue and a mask constant.\n\t* region-model.cc (region_model::get_rvalue_1): Implement\n\tBIT_FIELD_REF in terms of...\n\t(region_model::get_rvalue_for_bits): New function.\n\t* region-model.h (region_model::get_rvalue_for_bits): New decl.\n\t* store.cc (bit_range::from_mask): New function.\n\t(selftest::test_bit_range_intersects_p): New selftest.\n\t(selftest::assert_bit_range_from_mask_eq): New.\n\t(ASSERT_BIT_RANGE_FROM_MASK_EQ): New macro.\n\t(selftest::assert_no_bit_range_from_mask_eq): New.\n\t(ASSERT_NO_BIT_RANGE_FROM_MASK): New macro.\n\t(selftest::test_bit_range_from_mask): New selftest.\n\t(selftest::analyzer_store_cc_tests): Call the new selftests.\n\t* store.h (bit_range::intersects_p): New.\n\t(bit_range::from_mask): New decl.\n\t(concrete_binding::get_bit_range): New accessor.\n\t(store_manager::get_concrete_binding): New overload taking\n\tconst bit_range &.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/99212\n\t* gcc.dg/analyzer/bitfields-1.c: New test.\n\t* gcc.dg/analyzer/data-model-1.c (struct sbits): Make bitfields\n\texplicitly signed.\n\t(test_44): Update test values assigned to the bits to ones that\n\tfit in the range of the bitfield type.  Remove xfails.\n\t(test_45): Remove xfails.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "f8f2d0a02b74927b5aa1472eaf06f76d7f6389ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8f2d0a02b74927b5aa1472eaf06f76d7f6389ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c957d38044d7eb6a45f57a8a9f707c3c0a798e9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c957d38044d7eb6a45f57a8a9f707c3c0a798e9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c957d38044d7eb6a45f57a8a9f707c3c0a798e9f"}], "stats": {"total": 493, "additions": 469, "deletions": 24}, "files": [{"sha": "0ca0c8ad02e10e676fdb0294c5692c5858e03886", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "patch": "@@ -480,9 +480,49 @@ region_model_manager::maybe_fold_binop (tree type, enum tree_code op,\n       break;\n     case BIT_AND_EXPR:\n       if (cst1)\n-\tif (zerop (cst1) && INTEGRAL_TYPE_P (type))\n-\t  /* \"(ARG0 & 0)\" -> \"0\".  */\n-\t  return get_or_create_constant_svalue (build_int_cst (type, 0));\n+\t{\n+\t  if (zerop (cst1) && INTEGRAL_TYPE_P (type))\n+\t    /* \"(ARG0 & 0)\" -> \"0\".  */\n+\t    return get_or_create_constant_svalue (build_int_cst (type, 0));\n+\n+\t  /* Support masking out bits from a compound_svalue, as this\n+\t     is generated when accessing bitfields.  */\n+\t  if (const compound_svalue *compound_sval\n+\t\t= arg0->dyn_cast_compound_svalue ())\n+\t    {\n+\t      const binding_map &map = compound_sval->get_map ();\n+\t      unsigned HOST_WIDE_INT mask = TREE_INT_CST_LOW (cst1);\n+\t      /* If \"mask\" is a contiguous range of set bits, see if the\n+\t\t compound_sval has a value for those bits.  */\n+\t      bit_range bits (0, 0);\n+\t      if (bit_range::from_mask (mask, &bits))\n+\t\t{\n+\t\t  const concrete_binding *conc\n+\t\t    = get_store_manager ()->get_concrete_binding (bits,\n+\t\t\t\t\t\t\t\t  BK_direct);\n+\t\t  if (const svalue *sval = map.get (conc))\n+\t\t    {\n+\t\t      /* We have a value;\n+\t\t\t shift it by the correct number of bits.  */\n+\t\t      const svalue *lhs = get_or_create_cast (type, sval);\n+\t\t      HOST_WIDE_INT bit_offset\n+\t\t\t= bits.get_start_bit_offset ().to_shwi ();\n+\t\t      tree shift_amt = build_int_cst (type, bit_offset);\n+\t\t      const svalue *shift_sval\n+\t\t\t= get_or_create_constant_svalue (shift_amt);\n+\t\t      const svalue *shifted_sval\n+\t\t\t= get_or_create_binop (type,\n+\t\t\t\t\t       LSHIFT_EXPR,\n+\t\t\t\t\t       lhs, shift_sval);\n+\t\t      /* Reapply the mask (needed for negative\n+\t\t\t signed bitfields).  */\n+\t\t      return get_or_create_binop (type,\n+\t\t\t\t\t\t  BIT_AND_EXPR,\n+\t\t\t\t\t\t  shifted_sval, arg1);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n       break;\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_AND_EXPR:"}, {"sha": "0d363fb15d352be258a4eb4f187603eac4b778da", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "patch": "@@ -1357,7 +1357,18 @@ region_model::get_rvalue_1 (path_var pv, region_model_context *ctxt)\n       break;\n \n     case BIT_FIELD_REF:\n-      return m_mgr->get_or_create_unknown_svalue (TREE_TYPE (pv.m_tree));\n+      {\n+\ttree expr = pv.m_tree;\n+\ttree op0 = TREE_OPERAND (expr, 0);\n+\tconst region *reg = get_lvalue (op0, ctxt);\n+\ttree num_bits = TREE_OPERAND (expr, 1);\n+\ttree first_bit_offset = TREE_OPERAND (expr, 2);\n+\tgcc_assert (TREE_CODE (num_bits) == INTEGER_CST);\n+\tgcc_assert (TREE_CODE (first_bit_offset) == INTEGER_CST);\n+\tbit_range bits (TREE_INT_CST_LOW (first_bit_offset),\n+\t\t\tTREE_INT_CST_LOW (num_bits));\n+\treturn get_rvalue_for_bits (TREE_TYPE (expr), reg, bits);\n+      }\n \n     case SSA_NAME:\n     case VAR_DECL:\n@@ -1686,6 +1697,58 @@ region_model::deref_rvalue (const svalue *ptr_sval, tree ptr_tree,\n   return m_mgr->get_symbolic_region (ptr_sval);\n }\n \n+/* Attempt to get BITS within any value of REG, as TYPE.\n+   In particular, extract values from compound_svalues for the case\n+   where there's a concrete binding at BITS.\n+   Return an unknown svalue if we can't handle the given case.  */\n+\n+const svalue *\n+region_model::get_rvalue_for_bits (tree type,\n+\t\t\t\t   const region *reg,\n+\t\t\t\t   const bit_range &bits)\n+{\n+  const svalue *sval = get_store_value (reg);\n+  if (const compound_svalue *compound_sval = sval->dyn_cast_compound_svalue ())\n+    {\n+      const binding_map &map = compound_sval->get_map ();\n+      binding_map result_map;\n+      for (auto iter : map)\n+\t{\n+\t  const binding_key *key = iter.first;\n+\t  if (const concrete_binding *conc_key\n+\t      = key->dyn_cast_concrete_binding ())\n+\t    {\n+\t      /* Ignore concrete bindings outside BITS.  */\n+\t      if (!conc_key->get_bit_range ().intersects_p (bits))\n+\t\tcontinue;\n+\t      if ((conc_key->get_start_bit_offset ()\n+\t\t   < bits.get_start_bit_offset ())\n+\t\t  || (conc_key->get_next_bit_offset ()\n+\t\t      > bits.get_next_bit_offset ()))\n+\t\t{\n+\t\t  /* If we have any concrete keys that aren't fully within BITS,\n+\t\t     then bail out.  */\n+\t\t  return m_mgr->get_or_create_unknown_svalue (type);\n+\t\t}\n+\t      const concrete_binding *offset_conc_key\n+\t\t    = m_mgr->get_store_manager ()->get_concrete_binding\n+\t\t\t(conc_key->get_start_bit_offset ()\n+\t\t\t   - bits.get_start_bit_offset (),\n+\t\t\t conc_key->get_size_in_bits (),\n+\t\t\t conc_key->get_kind ());\n+\t\t  const svalue *sval = iter.second;\n+\t\t  result_map.put (offset_conc_key, sval);\n+\t    }\n+\t  else\n+\t    /* If we have any symbolic keys we can't get it as bits.  */\n+\t    return m_mgr->get_or_create_unknown_svalue (type);\n+\t}\n+      return m_mgr->get_or_create_compound_svalue (type, result_map);\n+    }\n+\n+  return m_mgr->get_or_create_unknown_svalue (type);\n+}\n+\n /* A subclass of pending_diagnostic for complaining about writes to\n    constant regions of memory.  */\n "}, {"sha": "5e43e547199858ab46ef1790aa678a2fa3a7175d", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "patch": "@@ -509,6 +509,10 @@ class region_model\n   const region *deref_rvalue (const svalue *ptr_sval, tree ptr_tree,\n \t\t\t       region_model_context *ctxt);\n \n+  const svalue *get_rvalue_for_bits (tree type,\n+\t\t\t\t     const region *reg,\n+\t\t\t\t     const bit_range &bits);\n+\n   void set_value (const region *lhs_reg, const svalue *rhs_sval,\n \t\t  region_model_context *ctxt);\n   void set_value (tree lhs, tree rhs, region_model_context *ctxt);"}, {"sha": "699de94cdb0456081eff028f3436b44e00f2972c", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "patch": "@@ -259,6 +259,64 @@ bit_range::cmp (const bit_range &br1, const bit_range &br2)\n   return wi::cmpu (br1.m_size_in_bits, br2.m_size_in_bits);\n }\n \n+/* If MASK is a contiguous range of set bits, write them\n+   to *OUT and return true.\n+   Otherwise return false.  */\n+\n+bool\n+bit_range::from_mask (unsigned HOST_WIDE_INT mask, bit_range *out)\n+{\n+  unsigned iter_bit_idx = 0;\n+  unsigned HOST_WIDE_INT iter_bit_mask = 1;\n+\n+  /* Find the first contiguous run of set bits in MASK.  */\n+\n+  /* Find first set bit in MASK.  */\n+  while (iter_bit_idx < HOST_BITS_PER_WIDE_INT)\n+    {\n+      if (mask & iter_bit_mask)\n+\tbreak;\n+      iter_bit_idx++;\n+      iter_bit_mask <<= 1;\n+    }\n+  if (iter_bit_idx == HOST_BITS_PER_WIDE_INT)\n+    /* MASK is zero.  */\n+    return false;\n+\n+  unsigned first_set_iter_bit_idx = iter_bit_idx;\n+  unsigned num_set_bits = 1;\n+  iter_bit_idx++;\n+  iter_bit_mask <<= 1;\n+\n+  /* Find next unset bit in MASK.  */\n+  while (iter_bit_idx < HOST_BITS_PER_WIDE_INT)\n+    {\n+      if (!(mask & iter_bit_mask))\n+\tbreak;\n+      num_set_bits++;\n+      iter_bit_idx++;\n+      iter_bit_mask <<= 1;\n+    }\n+  if (iter_bit_idx == HOST_BITS_PER_WIDE_INT)\n+    {\n+      *out = bit_range (first_set_iter_bit_idx, num_set_bits);\n+      return true;\n+    }\n+\n+  /* We now have the first contiguous run of set bits in MASK.\n+     Fail if any other bits are set.  */\n+  while (iter_bit_idx < HOST_BITS_PER_WIDE_INT)\n+    {\n+      if (mask & iter_bit_mask)\n+\treturn false;\n+      iter_bit_idx++;\n+      iter_bit_mask <<= 1;\n+    }\n+\n+  *out = bit_range (first_set_iter_bit_idx, num_set_bits);\n+  return true;\n+}\n+\n /* class concrete_binding : public binding_key.  */\n \n /* Implementation of binding_key::dump_to_pp vfunc for concrete_binding.  */\n@@ -2448,6 +2506,132 @@ store::loop_replay_fixup (const store *other_store,\n \n namespace selftest {\n \n+/* Verify that bit_range::intersects_p works as expected.  */\n+\n+static void\n+test_bit_range_intersects_p ()\n+{\n+  bit_range b0 (0, 1);\n+  bit_range b1 (1, 1);\n+  bit_range b2 (2, 1);\n+  bit_range b3 (3, 1);\n+  bit_range b4 (4, 1);\n+  bit_range b5 (5, 1);\n+  bit_range b6 (6, 1);\n+  bit_range b7 (7, 1);\n+  bit_range b1_to_6 (1, 6);\n+  bit_range b0_to_7 (0, 8);\n+  bit_range b3_to_5 (3, 3);\n+  bit_range b6_to_7 (6, 2);\n+\n+  /* self-intersection is true.  */\n+  ASSERT_TRUE (b0.intersects_p (b0));\n+  ASSERT_TRUE (b7.intersects_p (b7));\n+  ASSERT_TRUE (b1_to_6.intersects_p (b1_to_6));\n+  ASSERT_TRUE (b0_to_7.intersects_p (b0_to_7));\n+\n+  ASSERT_FALSE (b0.intersects_p (b1));\n+  ASSERT_FALSE (b1.intersects_p (b0));\n+  ASSERT_FALSE (b0.intersects_p (b7));\n+  ASSERT_FALSE (b7.intersects_p (b0));\n+\n+  ASSERT_TRUE (b0_to_7.intersects_p (b0));\n+  ASSERT_TRUE (b0_to_7.intersects_p (b7));\n+  ASSERT_TRUE (b0.intersects_p (b0_to_7));\n+  ASSERT_TRUE (b7.intersects_p (b0_to_7));\n+\n+  ASSERT_FALSE (b0.intersects_p (b1_to_6));\n+  ASSERT_FALSE (b1_to_6.intersects_p (b0));\n+  ASSERT_TRUE (b1.intersects_p (b1_to_6));\n+  ASSERT_TRUE (b1_to_6.intersects_p (b1));\n+  ASSERT_TRUE (b1_to_6.intersects_p (b6));\n+  ASSERT_FALSE (b1_to_6.intersects_p (b7));\n+\n+  ASSERT_TRUE (b1_to_6.intersects_p (b0_to_7));\n+  ASSERT_TRUE (b0_to_7.intersects_p (b1_to_6));\n+\n+  ASSERT_FALSE (b3_to_5.intersects_p (b6_to_7));\n+  ASSERT_FALSE (b6_to_7.intersects_p (b3_to_5));\n+}\n+\n+/* Implementation detail of ASSERT_BIT_RANGE_FROM_MASK_EQ.  */\n+\n+static void\n+assert_bit_range_from_mask_eq (const location &loc,\n+\t\t\t       unsigned HOST_WIDE_INT mask,\n+\t\t\t       const bit_range &expected)\n+{\n+  bit_range actual (0, 0);\n+  bool ok = bit_range::from_mask (mask, &actual);\n+  ASSERT_TRUE_AT (loc, ok);\n+  ASSERT_EQ_AT (loc, actual, expected);\n+}\n+\n+/* Assert that bit_range::from_mask (MASK) returns true, and writes\n+   out EXPECTED_BIT_RANGE.  */\n+\n+#define ASSERT_BIT_RANGE_FROM_MASK_EQ(MASK, EXPECTED_BIT_RANGE) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  assert_bit_range_from_mask_eq (SELFTEST_LOCATION, MASK,\t\t\\\n+\t\t\t\t EXPECTED_BIT_RANGE);\t\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Implementation detail of ASSERT_NO_BIT_RANGE_FROM_MASK.  */\n+\n+static void\n+assert_no_bit_range_from_mask_eq (const location &loc,\n+\t\t\t\t  unsigned HOST_WIDE_INT mask)\n+{\n+  bit_range actual (0, 0);\n+  bool ok = bit_range::from_mask (mask, &actual);\n+  ASSERT_FALSE_AT (loc, ok);\n+}\n+\n+/* Assert that bit_range::from_mask (MASK) returns false.  */\n+\n+#define ASSERT_NO_BIT_RANGE_FROM_MASK(MASK) \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  assert_no_bit_range_from_mask_eq (SELFTEST_LOCATION, MASK);\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Verify that bit_range::from_mask works as expected.  */\n+\n+static void\n+test_bit_range_from_mask ()\n+{\n+  /* Should fail on zero.  */\n+  ASSERT_NO_BIT_RANGE_FROM_MASK (0);\n+\n+  /* Verify 1-bit masks.  */\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (1, bit_range (0, 1));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (2, bit_range (1, 1));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (4, bit_range (2, 1));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (8, bit_range (3, 1));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (16, bit_range (4, 1));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (32, bit_range (5, 1));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (64, bit_range (6, 1));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (128, bit_range (7, 1));\n+\n+  /* Verify N-bit masks starting at bit 0.  */\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (3, bit_range (0, 2));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (7, bit_range (0, 3));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (15, bit_range (0, 4));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (31, bit_range (0, 5));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (63, bit_range (0, 6));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (127, bit_range (0, 7));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (255, bit_range (0, 8));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (0xffff, bit_range (0, 16));\n+\n+  /* Various other tests. */\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (0x30, bit_range (4, 2));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (0x700, bit_range (8, 3));\n+  ASSERT_BIT_RANGE_FROM_MASK_EQ (0x600, bit_range (9, 2));\n+\n+  /* Multiple ranges of set bits should fail.  */\n+  ASSERT_NO_BIT_RANGE_FROM_MASK (0x101);\n+  ASSERT_NO_BIT_RANGE_FROM_MASK (0xf0f0f0f0);\n+}\n+\n /* Implementation detail of ASSERT_OVERLAP.  */\n \n static void\n@@ -2546,6 +2730,8 @@ test_binding_key_overlap ()\n void\n analyzer_store_cc_tests ()\n {\n+  test_bit_range_intersects_p ();\n+  test_bit_range_from_mask ();\n   test_binding_key_overlap ();\n }\n "}, {"sha": "7bd2824dba9f283fd7a4e3c2188948fa7f53390f", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "patch": "@@ -297,8 +297,16 @@ struct bit_range\n \t    && m_size_in_bits == other.m_size_in_bits);\n   }\n \n+  bool intersects_p (const bit_range &other) const\n+  {\n+    return (get_start_bit_offset () < other.get_next_bit_offset ()\n+\t    && other.get_start_bit_offset () < get_next_bit_offset ());\n+  }\n+\n   static int cmp (const bit_range &br1, const bit_range &br2);\n \n+  static bool from_mask (unsigned HOST_WIDE_INT mask, bit_range *out);\n+\n   bit_offset_t m_start_bit_offset;\n   bit_size_t m_size_in_bits;\n };\n@@ -338,6 +346,8 @@ class concrete_binding : public binding_key\n   const concrete_binding *dyn_cast_concrete_binding () const FINAL OVERRIDE\n   { return this; }\n \n+  const bit_range &get_bit_range () const { return m_bit_range; }\n+\n   bit_offset_t get_start_bit_offset () const\n   {\n     return m_bit_range.m_start_bit_offset;\n@@ -739,6 +749,14 @@ class store_manager\n   get_concrete_binding (bit_offset_t start_bit_offset,\n \t\t\tbit_offset_t size_in_bits,\n \t\t\tenum binding_kind kind);\n+  const concrete_binding *\n+  get_concrete_binding (const bit_range &bits,\n+\t\t\tenum binding_kind kind)\n+  {\n+    return get_concrete_binding (bits.get_start_bit_offset (),\n+\t\t\t\t bits.m_size_in_bits,\n+\t\t\t\t kind);\n+  }\n   const symbolic_binding *\n   get_symbolic_binding (const region *region,\n \t\t\tenum binding_kind kind);"}, {"sha": "8bbe76bdbf3ebdee5a3df204af9be6186df571d7", "filename": "gcc/testsuite/gcc.dg/analyzer/bitfields-1.c", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fbitfields-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fbitfields-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fbitfields-1.c?ref=d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "patch": "@@ -0,0 +1,144 @@\n+#include \"analyzer-decls.h\"\n+\n+typedef unsigned char u8;\n+typedef unsigned __INT16_TYPE__ u16;\n+typedef unsigned __INT32_TYPE__ u32;\n+\n+struct st1\n+{\n+  u16 nonzero_offset;\n+  unsigned int f0 : 1;\n+  unsigned int f1 : 1;\n+  unsigned int f2 : 1;\n+  unsigned int f3 : 1;\n+  unsigned int f4 : 1;\n+  unsigned int f5 : 1;\n+  unsigned int f6 : 1;\n+  unsigned int f7 : 1;\n+};\n+\n+void test_1 (void)\n+{\n+  struct st1 s;\n+  s.f0 = 0;\n+  __analyzer_eval (s.f0 == 0); /* { dg-warning \"TRUE\" } */\n+  s.f0 = 1;\n+  __analyzer_eval (s.f0 == 1); /* { dg-warning \"TRUE\" } */\n+\n+  s.f1 = 0;\n+  __analyzer_eval (s.f1 == 0); /* { dg-warning \"TRUE\" } */\n+  s.f1 = 1;\n+  __analyzer_eval (s.f1 == 1); /* { dg-warning \"TRUE\" } */\n+\n+  /* etc  */\n+\n+  s.f6 = 0;\n+  __analyzer_eval (s.f6 == 0); /* { dg-warning \"TRUE\" } */\n+  s.f6 = 1;\n+  __analyzer_eval (s.f6 == 1); /* { dg-warning \"TRUE\" } */\n+\n+  s.f7 = 0;\n+  __analyzer_eval (s.f7 == 0); /* { dg-warning \"TRUE\" } */\n+  s.f7 = 1;\n+  __analyzer_eval (s.f7 == 1); /* { dg-warning \"TRUE\" } */\n+};\n+\n+void test_2 (_Bool v0, _Bool v1, _Bool v2, _Bool v3,\n+\t     _Bool v4, _Bool v5, _Bool v6, _Bool v7)\n+{\n+  struct st1 s;\n+  s.f0 = v0;\n+  s.f1 = v1;\n+  s.f2 = v2;\n+  s.f3 = v3;\n+  s.f4 = v4;\n+  s.f5 = v5;\n+  s.f6 = v6;\n+  s.f7 = v7;\n+\n+  __analyzer_eval (s.f0 == v0); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (s.f1 == v1); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (s.f2 == v2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (s.f3 == v3); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (s.f4 == v4); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (s.f5 == v5); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (s.f6 == v6); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (s.f7 == v7); /* { dg-warning \"TRUE\" } */\n+};\n+\n+struct st3\n+{\n+  unsigned int f01 : 2;\n+  unsigned int f23 : 2;\n+  unsigned int f34 : 2;\n+  unsigned int f56 : 2;\n+};\n+\n+void test_3 (void)\n+{\n+  struct st3 s;\n+  s.f01 = 0;\n+  __analyzer_eval (s.f01 == 0); /* { dg-warning \"TRUE\" } */\n+  s.f01 = 1;\n+  __analyzer_eval (s.f01 == 1); /* { dg-warning \"TRUE\" } */\n+  s.f01 = 2;\n+  __analyzer_eval (s.f01 == 2); /* { dg-warning \"TRUE\" } */\n+  s.f01 = 3;\n+  __analyzer_eval (s.f01 == 3); /* { dg-warning \"TRUE\" } */\n+\n+  /* etc  */\n+\n+  s.f56 = 0;\n+  __analyzer_eval (s.f56 == 0); /* { dg-warning \"TRUE\" } */\n+  s.f56 = 1;\n+  __analyzer_eval (s.f56 == 1); /* { dg-warning \"TRUE\" } */\n+  s.f56 = 2;\n+  __analyzer_eval (s.f56 == 2); /* { dg-warning \"TRUE\" } */\n+  s.f56 = 3;\n+  __analyzer_eval (s.f56 == 3); /* { dg-warning \"TRUE\" } */\n+};\n+\n+/* A signed bitfield.  */\n+\n+struct st4\n+{\n+  signed int f012 : 3;\n+  signed int f345 : 3;\n+};\n+\n+void test_4 (void)\n+{\n+  struct st4 s;\n+  s.f345 = -4;\n+  __analyzer_eval (s.f345 == -4); /* { dg-warning \"TRUE\" } */\n+  s.f345 = -3;\n+  __analyzer_eval (s.f345 == -3); /* { dg-warning \"TRUE\" } */\n+  s.f345 = -2;\n+  __analyzer_eval (s.f345 == -2); /* { dg-warning \"TRUE\" } */\n+  s.f345 = -1;\n+  __analyzer_eval (s.f345 == -1); /* { dg-warning \"TRUE\" } */\n+  s.f345 = 0;\n+  __analyzer_eval (s.f345 == 0); /* { dg-warning \"TRUE\" } */\n+  s.f345 = 1;\n+  __analyzer_eval (s.f345 == 1); /* { dg-warning \"TRUE\" } */\n+  s.f345 = 2;\n+  __analyzer_eval (s.f345 == 2); /* { dg-warning \"TRUE\" } */\n+  s.f345 = 3;\n+  __analyzer_eval (s.f345 == 3); /* { dg-warning \"TRUE\" } */\n+};\n+\n+/* A zero bitfield to break up padding.  */\n+\n+struct st5\n+{\n+  unsigned f0 : 5;\n+  unsigned :0;\n+  unsigned f1 : 16;\n+};\n+\n+void test_5 (void)\n+{\n+  struct st5 s;\n+  s.f1 = 0xcafe;\n+  __analyzer_eval (s.f1 == 0xcafe); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "4a62a0e2bbc3ecae84fe14cd9136ade21ee03916", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-1.c", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c?ref=d3b1ef7a83c0c0cd5b20a1dd1714b868f3d2b442", "patch": "@@ -934,24 +934,20 @@ void test_43 (void)\n \n struct sbits\n {\n-  int b0 : 1;\n-  int b123 : 3;\n-  int b456 : 3;\n-  int b7 : 1;\n+  signed int b0 : 1;\n+  signed int b123 : 3;\n+  signed int b456 : 3;\n+  signed int b7 : 1;\n };\n \n void test_44 (void)\n {\n   struct sbits bits;\n-  bits.b0 = 1;\n-  __analyzer_eval (bits.b0 == 1); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"FALSE\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail): ^^^^\n+  bits.b0 = -1;\n+  __analyzer_eval (bits.b0 == -1); /* { dg-warning \"TRUE\" } */\n \n-  bits.b456 = 5;\n-  __analyzer_eval (bits.b456 == 5); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"FALSE\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail): ^^^^\n+  bits.b456 = -4;\n+  __analyzer_eval (bits.b456 == -4); /* { dg-warning \"TRUE\" } */\n };\n \n struct ubits\n@@ -962,20 +958,14 @@ struct ubits\n   unsigned int b7 : 1;\n };\n \n-/* FIXME: this requires BIT_FIELD_REF to work.  */\n-\n void test_45 (void)\n {\n   struct ubits bits;\n   bits.b0 = 1;\n-  __analyzer_eval (bits.b0 == 1); /* { dg-warning \"TRUE\" \"desired, PR99212\" { xfail { ! { cris-*-* } } } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo, PR99212\" { target { *-*-* } xfail { cris-*-* } } .-1 } */\n-  // TODO(xfail): ^^^^\n+  __analyzer_eval (bits.b0 == 1); /* { dg-warning \"TRUE\" } */\n \n   bits.b456 = 5;\n-  __analyzer_eval (bits.b456 == 5); /* { dg-warning \"TRUE\" \"desired\" { xfail *-*-* } } */\n-  /* { dg-warning \"UNKNOWN\" \"status quo\" { target *-*-* } .-1 } */\n-  // TODO(xfail): ^^^^\n+  __analyzer_eval (bits.b456 == 5); /* { dg-warning \"TRUE\" } */\n };\n \n extern const char *char_ptr;"}]}