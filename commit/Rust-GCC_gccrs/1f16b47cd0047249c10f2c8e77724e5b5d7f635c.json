{"sha": "1f16b47cd0047249c10f2c8e77724e5b5d7f635c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYxNmI0N2NkMDA0NzI0OWMxMGYyYzhlNzc3MjRlNWI1ZDdmNjM1Yw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-05-07T23:15:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-05-07T23:15:50Z"}, "message": "re PR debug/35896 (gfortran TLS symbols broken with debug info)\n\n\tPR debug/35896\n\t* dwarf2out.c (dw_expand_expr, common_check): Removed.\n\t(fortran_common): New function.\n\t(gen_variable_die): Call fortran_common instead of common_check,\n\tadjust for it returning tree instead of rtx.    Formatting.\n\nFrom-SVN: r135060", "tree": {"sha": "b3e8eca2b616b9513f95e8b042eb93844425725b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3e8eca2b616b9513f95e8b042eb93844425725b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f16b47cd0047249c10f2c8e77724e5b5d7f635c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f16b47cd0047249c10f2c8e77724e5b5d7f635c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f16b47cd0047249c10f2c8e77724e5b5d7f635c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f16b47cd0047249c10f2c8e77724e5b5d7f635c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4218dc2db0ce983bbf9c00be37d424177504e175", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4218dc2db0ce983bbf9c00be37d424177504e175", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4218dc2db0ce983bbf9c00be37d424177504e175"}], "stats": {"total": 185, "additions": 49, "deletions": 136}, "files": [{"sha": "1498db30288c9c61b09dbae1850510077ee90ecf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f16b47cd0047249c10f2c8e77724e5b5d7f635c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f16b47cd0047249c10f2c8e77724e5b5d7f635c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f16b47cd0047249c10f2c8e77724e5b5d7f635c", "patch": "@@ -3,6 +3,12 @@\n \t* tree-parloops.c (create_parallel_loop): Set OMP_RETURN_NOWAIT\n \ton OMP_RETURN for OMP_FOR.\n \n+\tPR debug/35896\n+\t* dwarf2out.c (dw_expand_expr, common_check): Removed.\n+\t(fortran_common): New function.\n+\t(gen_variable_die): Call fortran_common instead of common_check,\n+\tadjust for it returning tree instead of rtx.  Formatting.\n+\n 2008-05-07  Kenneth Zadeck  <zadeck@naturalbridge.com>\n \n         PATCH rtl/7335"}, {"sha": "861d3b3b1dee5534bb8ba4e09655b5cdeebc4a2d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 43, "deletions": 136, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f16b47cd0047249c10f2c8e77724e5b5d7f635c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f16b47cd0047249c10f2c8e77724e5b5d7f635c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=1f16b47cd0047249c10f2c8e77724e5b5d7f635c", "patch": "@@ -10527,63 +10527,6 @@ rtl_for_decl_init (tree init, tree type)\n   return rtl;\n }\n \n-/* This is a specialized subset of expand_expr to evaluate a DECL_VALUE_EXPR.\n-   We stop if we find decls that haven't been expanded, or if the expression is\n-   getting so complex we won't be able to represent it anyway.  Returns NULL on\n-   failure.  */\n-\n-static rtx\n-dw_expand_expr (tree expr)\n-{\n-  switch (TREE_CODE (expr))\n-  {\n-  case VAR_DECL:\n-  case PARM_DECL:\n-    if (DECL_HAS_VALUE_EXPR_P (expr))\n-      return dw_expand_expr (DECL_VALUE_EXPR (expr));\n-    /* FALLTHRU */\n- \n-  case CONST_DECL:\n-  case RESULT_DECL:\n-    return DECL_RTL_IF_SET (expr);\n- \n-  case INTEGER_CST:\n-    return expand_expr (expr, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);\n-\n-  case COMPONENT_REF:\n-  case ARRAY_REF:\n-  case ARRAY_RANGE_REF:\n-  case BIT_FIELD_REF:\n-  {\n-    enum machine_mode mode;\n-    HOST_WIDE_INT bitsize, bitpos;\n-    tree offset, tem;\n-    int volatilep = 0, unsignedp = 0;\n-    rtx x;\n-\n-    tem = get_inner_reference (expr, &bitsize, &bitpos, &offset,\n-                               &mode, &unsignedp, &volatilep, true);\n- \n-    x = dw_expand_expr (tem);\n-    if (x == NULL || !MEM_P (x))\n-       return NULL;\n-    if (offset != NULL)\n-      {\n-        if (!host_integerp (offset, 0))\n-          return NULL;\n-        x = adjust_address_nv (x, mode, tree_low_cst (offset, 0));\n-      }\n-    if (bitpos != 0)\n-      x = adjust_address_nv (x, mode, bitpos / BITS_PER_UNIT);\n-\n-    return x;\n-  }\n- \n-  default:\n-    return NULL;\n-  }\n-}\n-\n /* Generate RTL for the variable DECL to represent its location.  */\n \n static rtx\n@@ -10820,86 +10763,50 @@ secname_for_decl (const_tree decl)\n    If so, the rtx for the SYMBOL_REF for the COMMON block is returned, and the\n    value is the offset into the common block for the symbol.  */\n \n-static rtx\n-common_check (tree decl, HOST_WIDE_INT *value)\n+static tree\n+fortran_common (tree decl, HOST_WIDE_INT *value)\n {\n-  rtx home;\n-  rtx sym_addr;\n-  rtx res = NULL_RTX;\n- \n+  tree val_expr, cvar;\n+  enum machine_mode mode;\n+  HOST_WIDE_INT bitsize, bitpos;\n+  tree offset;\n+  int volatilep = 0, unsignedp = 0;\n+\n   /* If the decl isn't a VAR_DECL, or if it isn't public or static, or if\n      it does not have a value (the offset into the common area), or if it\n      is thread local (as opposed to global) then it isn't common, and shouldn't\n      be handled as such.  */\n   if (TREE_CODE (decl) != VAR_DECL\n-      || !TREE_PUBLIC(decl)\n-      || !TREE_STATIC(decl)\n-      || !DECL_HAS_VALUE_EXPR_P(decl)\n-      || DECL_THREAD_LOCAL_P (decl)\n-      || !is_fortran())\n-    return NULL;\n-\n-  home = DECL_RTL (decl);\n-  if (home == NULL_RTX || GET_CODE (home) != MEM)\n-    return NULL;\n-\n-  sym_addr = dw_expand_expr (DECL_VALUE_EXPR (decl));\n-  if (sym_addr == NULL_RTX || GET_CODE (sym_addr) != MEM)\n-    return NULL;\n+      || !TREE_PUBLIC (decl)\n+      || !TREE_STATIC (decl)\n+      || !DECL_HAS_VALUE_EXPR_P (decl)\n+      || !is_fortran ())\n+    return NULL_TREE;\n \n-  sym_addr = XEXP (sym_addr, 0);\n-  if (GET_CODE (sym_addr) == CONST)\n-    sym_addr = XEXP (sym_addr, 0);\n-  if ((GET_CODE (sym_addr) == SYMBOL_REF || GET_CODE (sym_addr) == PLUS)\n-      && DECL_INITIAL (decl) == 0)\n-    {\n- \n-      /* We have a sym that will go into a common area, meaning that it\n-         will get storage reserved with a .comm/.lcomm assembler pseudo-op.\n+  val_expr = DECL_VALUE_EXPR (decl);\n+  if (TREE_CODE (val_expr) != COMPONENT_REF)\n+    return NULL_TREE;\n \n-         Determine name of common area this symbol will be an offset into,\n-         and offset into that area.  Also retrieve the decl for the area\n-         that the symbol is offset into.  */\n-      tree cdecl = NULL;\n+  cvar = get_inner_reference (val_expr, &bitsize, &bitpos, &offset,\n+\t\t\t      &mode, &unsignedp, &volatilep, true);\n \n-      switch (GET_CODE (sym_addr))\n-        {\n-        case PLUS:\n-          if (GET_CODE (XEXP (sym_addr, 0)) == CONST_INT)\n-            {\n-              res = XEXP (sym_addr, 1);\n-              *value = INTVAL (XEXP (sym_addr, 0));\n-              cdecl = SYMBOL_REF_DECL (XEXP (sym_addr, 1));\n-            }\n-          else\n-            {\n-              res = XEXP (sym_addr, 0);\n-              *value = INTVAL (XEXP (sym_addr, 1));\n-              cdecl = SYMBOL_REF_DECL (XEXP (sym_addr, 0));\n-             }\n-          break;\n-\n-        case SYMBOL_REF:\n-          res = sym_addr;\n-          *value = 0;\n-          cdecl = SYMBOL_REF_DECL (sym_addr);\n-          break;\n-\n-        default:\n-          error (\"common symbol debug info is not structured as \"\n-                 \"symbol+offset\");\n-        }\n+  if (cvar == NULL_TREE\n+      || TREE_CODE (cvar) != VAR_DECL\n+      || DECL_ARTIFICIAL (cvar)\n+      || !TREE_PUBLIC (cvar))\n+    return NULL_TREE;\n \n-      /* Check area common symbol is offset into.  If this is not public, then\n-         it is not a symbol in a common block.  It must be a .lcomm symbol, not\n-         a .comm symbol.  */\n-      if (cdecl == NULL || !TREE_PUBLIC(cdecl))\n-        res = NULL_RTX;\n+  *value = 0;\n+  if (offset != NULL)\n+    {\n+      if (!host_integerp (offset, 0))\n+\treturn NULL_TREE;\n+      *value = tree_low_cst (offset, 0);\n     }\n-  else\n-    res = NULL_RTX;\n+  if (bitpos != 0)\n+    *value += bitpos / BITS_PER_UNIT;\n \n-  return res;\n+  return cvar;\n }\n \n \n@@ -12800,7 +12707,7 @@ static void\n gen_variable_die (tree decl, dw_die_ref context_die)\n {\n   HOST_WIDE_INT off;\n-  rtx csym;\n+  tree com_decl;\n   dw_die_ref var_die;\n   tree origin = decl_ultimate_origin (decl);\n   dw_die_ref old_die = lookup_decl_die (decl);\n@@ -12826,31 +12733,31 @@ gen_variable_die (tree decl, dw_die_ref context_die)\n \t\t\t && DECL_COMDAT (decl) && !TREE_ASM_WRITTEN (decl))\n \t\t     || class_or_namespace_scope_p (context_die));\n \n-  csym = common_check (decl, &off);\n+  com_decl = fortran_common (decl, &off);\n \n   /* Symbol in common gets emitted as a child of the common block, in the form\n      of a data member.\n \n      ??? This creates a new common block die for every common block symbol.\n      Better to share same common block die for all symbols in that block.  */\n-  if (csym)\n+  if (com_decl)\n     {\n-      tree blok;\n+      tree field;\n       dw_die_ref com_die;\n-      const char *cnam = targetm.strip_name_encoding(XSTR (csym, 0));\n-      dw_loc_descr_ref loc = mem_loc_descriptor (csym, dw_val_class_addr,\n-                                                 VAR_INIT_STATUS_INITIALIZED);\n+      const char *cnam = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (com_decl));\n+      dw_loc_descr_ref loc = loc_descriptor_from_tree (com_decl);\n \n-      blok = (tree) TREE_OPERAND (DECL_VALUE_EXPR (decl), 0);\n+      field = TREE_OPERAND (DECL_VALUE_EXPR (decl), 0);\n       var_die = new_die (DW_TAG_common_block, context_die, decl);\n-      add_name_and_src_coords_attributes (var_die, blok);\n+      add_name_and_src_coords_attributes (var_die, field);\n       add_AT_flag (var_die, DW_AT_external, 1);\n       add_AT_loc (var_die, DW_AT_location, loc);\n       com_die = new_die (DW_TAG_member, var_die, decl);\n       add_name_and_src_coords_attributes (com_die, decl);\n       add_type_attribute (com_die, TREE_TYPE (decl), TREE_READONLY (decl),\n-      TREE_THIS_VOLATILE (decl), context_die);\n-      add_AT_loc (com_die, DW_AT_data_member_location, int_loc_descriptor(off));\n+\t\t\t  TREE_THIS_VOLATILE (decl), context_die);\n+      add_AT_loc (com_die, DW_AT_data_member_location,\n+\t\t  int_loc_descriptor (off));\n       add_pubname_string (cnam, var_die); /* ??? needed? */\n       return;\n     }"}]}