{"sha": "4fd0b1760dcdbadac9514858a6f96a51dc25226d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZkMGIxNzYwZGNkYmFkYWM5NTE0ODU4YTZmOTZhNTFkYzI1MjI2ZA==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-10-06T20:50:22Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-10-06T20:50:22Z"}, "message": "remove dead code in computation of alias sets\n\n2015-10-06  Aditya Kumar  <aditya.k7@samsung.com>\n                Sebastian Pop  <s.pop@samsung.com>\n\n                * graphite-poly.c (new_poly_dr): Remove dr_base_object_set.\n                Do not set PDR_BASE_OBJECT_SET.\n                * graphite-poly.h (poly_dr): Same.\n                (PDR_BASE_OBJECT_SET): Remove.\n                (new_poly_dr): Update decl.\n                * graphite-sese-to-poly.c (build_poly_dr): Update call to\n                new_poly_dr.\n                (write_alias_graph_to_ascii_dimacs): Remove.\n                (write_alias_graph_to_ascii_dot): Remove.\n                (write_alias_graph_to_ascii_ecc): Remove.\n                (dr_same_base_object_p): Remove.\n                (build_alias_set_optimal_p): Rename build_alias_set.  Remove dead\n                code.\n                (build_base_obj_set_for_drs): Remove.\n                (dump_alias_graphs): Remove.\n                (build_scop_drs): Remove dead code.\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r228543", "tree": {"sha": "e8dc90074e523cf80eec29a84f307a64f1d14508", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8dc90074e523cf80eec29a84f307a64f1d14508"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fd0b1760dcdbadac9514858a6f96a51dc25226d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd0b1760dcdbadac9514858a6f96a51dc25226d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fd0b1760dcdbadac9514858a6f96a51dc25226d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fd0b1760dcdbadac9514858a6f96a51dc25226d/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21ba0ceaa5895cd93ae5d090458e8f7b5f5803aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21ba0ceaa5895cd93ae5d090458e8f7b5f5803aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21ba0ceaa5895cd93ae5d090458e8f7b5f5803aa"}], "stats": {"total": 307, "additions": 40, "deletions": 267}, "files": [{"sha": "fe1eea0d9dc06bdfaaac48573f2cd78fe92fdb2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd0b1760dcdbadac9514858a6f96a51dc25226d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd0b1760dcdbadac9514858a6f96a51dc25226d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fd0b1760dcdbadac9514858a6f96a51dc25226d", "patch": "@@ -1,3 +1,23 @@\n+2015-10-06  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* graphite-poly.c (new_poly_dr): Remove dr_base_object_set.\n+\tDo not set PDR_BASE_OBJECT_SET.\n+\t* graphite-poly.h (poly_dr): Same.\n+\t(PDR_BASE_OBJECT_SET): Remove.\n+\t(new_poly_dr): Update decl.\n+\t* graphite-sese-to-poly.c (build_poly_dr): Update call to\n+\tnew_poly_dr.\n+\t(write_alias_graph_to_ascii_dimacs): Remove.\n+\t(write_alias_graph_to_ascii_dot): Remove.\n+\t(write_alias_graph_to_ascii_ecc): Remove.\n+\t(dr_same_base_object_p): Remove.\n+\t(build_alias_set_optimal_p): Rename build_alias_set.  Remove dead\n+\tcode.\n+\t(build_base_obj_set_for_drs): Remove.\n+\t(dump_alias_graphs): Remove.\n+\t(build_scop_drs): Remove dead code.\n+\n 2015-10-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \t    Peter Bergner  <bergner@vnet.ibm.com>\n "}, {"sha": "7de0e8114e6424a4aea6fb2a6f9044bc782f789f", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd0b1760dcdbadac9514858a6f96a51dc25226d/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd0b1760dcdbadac9514858a6f96a51dc25226d/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=4fd0b1760dcdbadac9514858a6f96a51dc25226d", "patch": "@@ -136,15 +136,14 @@ apply_poly_transforms (scop_p scop)\n    NB_SUBSCRIPTS.  */\n \n void\n-new_poly_dr (poly_bb_p pbb, int dr_base_object_set,\n-\t     enum poly_dr_type type, data_reference_p cdr, graphite_dim_t nb_subscripts,\n+new_poly_dr (poly_bb_p pbb, enum poly_dr_type type, data_reference_p cdr,\n+\t     graphite_dim_t nb_subscripts,\n \t     isl_map *acc, isl_set *subscript_sizes)\n {\n   static int id = 0;\n   poly_dr_p pdr = XNEW (struct poly_dr);\n \n   PDR_ID (pdr) = id++;\n-  PDR_BASE_OBJECT_SET (pdr) = dr_base_object_set;\n   PDR_NB_REFS (pdr) = 1;\n   PDR_PBB (pdr) = pbb;\n   pdr->accesses = acc;"}, {"sha": "3c4353df14073783dc954df5a94d215d8adb8218", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd0b1760dcdbadac9514858a6f96a51dc25226d/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd0b1760dcdbadac9514858a6f96a51dc25226d/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=4fd0b1760dcdbadac9514858a6f96a51dc25226d", "patch": "@@ -182,10 +182,6 @@ struct poly_dr\n   isl_map *accesses;\n   isl_set *subscript_sizes;\n \n-  /* Data reference's base object set number, we must assure 2 pdrs are in the\n-     same base object set before dependency checking.  */\n-  int dr_base_object_set;\n-\n   /* The number of subscripts.  */\n   graphite_dim_t nb_subscripts;\n };\n@@ -196,10 +192,9 @@ struct poly_dr\n #define PDR_PBB(PDR) (PDR->pbb)\n #define PDR_TYPE(PDR) (PDR->type)\n #define PDR_ACCESSES(PDR) (NULL)\n-#define PDR_BASE_OBJECT_SET(PDR) (PDR->dr_base_object_set)\n #define PDR_NB_SUBSCRIPTS(PDR) (PDR->nb_subscripts)\n \n-void new_poly_dr (poly_bb_p, int, enum poly_dr_type, data_reference_p,\n+void new_poly_dr (poly_bb_p, enum poly_dr_type, data_reference_p,\n \t\t  graphite_dim_t, isl_map *, isl_set *);\n void free_poly_dr (poly_dr_p);\n void debug_pdr (poly_dr_p, int);"}, {"sha": "235c9117d06203ab2f6a4febd1c7f7435e0cc724", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 17, "deletions": 258, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fd0b1760dcdbadac9514858a6f96a51dc25226d/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fd0b1760dcdbadac9514858a6f96a51dc25226d/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=4fd0b1760dcdbadac9514858a6f96a51dc25226d", "patch": "@@ -1065,7 +1065,6 @@ pdr_add_data_dimensions (isl_set *subscript_sizes, scop_p scop,\n static void\n build_poly_dr (data_reference_p dr, poly_bb_p pbb)\n {\n-  int dr_base_object_set;\n   isl_map *acc;\n   isl_set *subscript_sizes;\n   scop_p scop = PBB_SCOP (pbb);\n@@ -1100,131 +1099,21 @@ build_poly_dr (data_reference_p dr, poly_bb_p pbb)\n     subscript_sizes = pdr_add_data_dimensions (subscript_sizes, scop, dr);\n   }\n \n-  gcc_assert (dr->aux);\n-  dr_base_object_set = ((base_alias_pair *)(dr->aux))->base_obj_set;\n-\n-  new_poly_dr (pbb, dr_base_object_set,\n+  new_poly_dr (pbb,\n \t       DR_IS_READ (dr) ? PDR_READ : PDR_WRITE,\n \t       dr, DR_NUM_DIMENSIONS (dr), acc, subscript_sizes);\n }\n \n-/* Write to FILE the alias graph of data references in DIMACS format.  */\n-\n-static inline bool\n-write_alias_graph_to_ascii_dimacs (FILE *file, char *comment,\n-\t\t\t\t   vec<data_reference_p> drs)\n-{\n-  int num_vertex = drs.length ();\n-  int edge_num = 0;\n-  data_reference_p dr1, dr2;\n-  int i, j;\n-\n-  if (num_vertex == 0)\n-    return true;\n-\n-  FOR_EACH_VEC_ELT (drs, i, dr1)\n-    for (j = i + 1; drs.iterate (j, &dr2); j++)\n-      if (dr_may_alias_p (dr1, dr2, true))\n-\tedge_num++;\n-\n-  fprintf (file, \"$\\n\");\n-\n-  if (comment)\n-    fprintf (file, \"c %s\\n\", comment);\n-\n-  fprintf (file, \"p edge %d %d\\n\", num_vertex, edge_num);\n-\n-  FOR_EACH_VEC_ELT (drs, i, dr1)\n-    for (j = i + 1; drs.iterate (j, &dr2); j++)\n-      if (dr_may_alias_p (dr1, dr2, true))\n-\tfprintf (file, \"e %d %d\\n\", i + 1, j + 1);\n+/* Compute alias-sets for all data references in DRS.  */\n \n-  return true;\n-}\n-\n-/* Write to FILE the alias graph of data references in DOT format.  */\n-\n-static inline bool\n-write_alias_graph_to_ascii_dot (FILE *file, char *comment,\n-\t\t\t\tvec<data_reference_p> drs)\n-{\n-  int num_vertex = drs.length ();\n-  data_reference_p dr1, dr2;\n-  int i, j;\n-\n-  if (num_vertex == 0)\n-    return true;\n-\n-  fprintf (file, \"$\\n\");\n-\n-  if (comment)\n-    fprintf (file, \"c %s\\n\", comment);\n-\n-  /* First print all the vertices.  */\n-  FOR_EACH_VEC_ELT (drs, i, dr1)\n-    fprintf (file, \"n%d;\\n\", i);\n-\n-  FOR_EACH_VEC_ELT (drs, i, dr1)\n-    for (j = i + 1; drs.iterate (j, &dr2); j++)\n-      if (dr_may_alias_p (dr1, dr2, true))\n-\tfprintf (file, \"n%d n%d\\n\", i, j);\n-\n-  return true;\n-}\n-\n-/* Write to FILE the alias graph of data references in ECC format.  */\n-\n-static inline bool\n-write_alias_graph_to_ascii_ecc (FILE *file, char *comment,\n-\t\t\t\tvec<data_reference_p> drs)\n-{\n-  int num_vertex = drs.length ();\n-  data_reference_p dr1, dr2;\n-  int i, j;\n-\n-  if (num_vertex == 0)\n-    return true;\n-\n-  fprintf (file, \"$\\n\");\n-\n-  if (comment)\n-    fprintf (file, \"c %s\\n\", comment);\n-\n-  FOR_EACH_VEC_ELT (drs, i, dr1)\n-    for (j = i + 1; drs.iterate (j, &dr2); j++)\n-      if (dr_may_alias_p (dr1, dr2, true))\n-\tfprintf (file, \"%d %d\\n\", i, j);\n-\n-  return true;\n-}\n-\n-/* Check if DR1 and DR2 are in the same object set.  */\n-\n-static bool\n-dr_same_base_object_p (const struct data_reference *dr1,\n-\t\t       const struct data_reference *dr2)\n-{\n-  return operand_equal_p (DR_BASE_OBJECT (dr1), DR_BASE_OBJECT (dr2), 0);\n-}\n-\n-/* Uses DFS component number as representative of alias-sets. Also tests for\n-   optimality by verifying if every connected component is a clique. Returns\n-   true (1) if the above test is true, and false (0) otherwise.  */\n-\n-static int\n-build_alias_set_optimal_p (vec<data_reference_p> drs)\n+static void\n+build_alias_set (vec<data_reference_p> drs)\n {\n   int num_vertices = drs.length ();\n   struct graph *g = new_graph (num_vertices);\n   data_reference_p dr1, dr2;\n   int i, j;\n-  int num_connected_components;\n-  int v_indx1, v_indx2, num_vertices_in_component;\n   int *all_vertices;\n-  int *vertices;\n-  struct graph_edge *e;\n-  int this_component_is_clique;\n-  int all_components_are_cliques = 1;\n \n   FOR_EACH_VEC_ELT (drs, i, dr1)\n     for (j = i+1; drs.iterate (j, &dr2); j++)\n@@ -1235,103 +1124,25 @@ build_alias_set_optimal_p (vec<data_reference_p> drs)\n \t}\n \n   all_vertices = XNEWVEC (int, num_vertices);\n-  vertices = XNEWVEC (int, num_vertices);\n   for (i = 0; i < num_vertices; i++)\n     all_vertices[i] = i;\n \n-  num_connected_components = graphds_dfs (g, all_vertices, num_vertices,\n-\t\t\t\t\t  NULL, true, NULL);\n-  for (i = 0; i < g->n_vertices; i++)\n-    {\n-      data_reference_p dr = drs[i];\n-      base_alias_pair *bap;\n-\n-      gcc_assert (dr->aux);\n-      bap = (base_alias_pair *)(dr->aux);\n-\n-      bap->alias_set = XNEW (int);\n-      *(bap->alias_set) = g->vertices[i].component + 1;\n-    }\n-\n-  /* Verify if the DFS numbering results in optimal solution.  */\n-  for (i = 0; i < num_connected_components; i++)\n-    {\n-      num_vertices_in_component = 0;\n-      /* Get all vertices whose DFS component number is the same as i.  */\n-      for (j = 0; j < num_vertices; j++)\n-\tif (g->vertices[j].component == i)\n-\t  vertices[num_vertices_in_component++] = j;\n-\n-      /* Now test if the vertices in 'vertices' form a clique, by testing\n-\t for edges among each pair.  */\n-      this_component_is_clique = 1;\n-      for (v_indx1 = 0; v_indx1 < num_vertices_in_component; v_indx1++)\n-\t{\n-\t  for (v_indx2 = v_indx1+1; v_indx2 < num_vertices_in_component; v_indx2++)\n-\t    {\n-\t      /* Check if the two vertices are connected by iterating\n-\t\t through all the edges which have one of these are source.  */\n-\t      e = g->vertices[vertices[v_indx2]].pred;\n-\t      while (e)\n-\t\t{\n-\t\t  if (e->src == vertices[v_indx1])\n-\t\t    break;\n-\t\t  e = e->pred_next;\n-\t\t}\n-\t      if (!e)\n-\t\t{\n-\t\t  this_component_is_clique = 0;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (!this_component_is_clique)\n-\t    all_components_are_cliques = 0;\n-\t}\n-    }\n-\n+  graphds_dfs (g, all_vertices, num_vertices, NULL, true, NULL);\n   free (all_vertices);\n-  free (vertices);\n-  free_graph (g);\n-  return all_components_are_cliques;\n-}\n \n-/* Group each data reference in DRS with its base object set num.  */\n-\n-static void\n-build_base_obj_set_for_drs (vec<data_reference_p> drs)\n-{\n-  int num_vertex = drs.length ();\n-  struct graph *g = new_graph (num_vertex);\n-  data_reference_p dr1, dr2;\n-  int i, j;\n-  int *queue;\n-\n-  FOR_EACH_VEC_ELT (drs, i, dr1)\n-    for (j = i + 1; drs.iterate (j, &dr2); j++)\n-      if (dr_same_base_object_p (dr1, dr2))\n-\t{\n-\t  add_edge (g, i, j);\n-\t  add_edge (g, j, i);\n-\t}\n-\n-  queue = XNEWVEC (int, num_vertex);\n-  for (i = 0; i < num_vertex; i++)\n-    queue[i] = i;\n-\n-  graphds_dfs (g, queue, num_vertex, NULL, true, NULL);\n+  data_reference_p dr;\n+  FOR_EACH_VEC_ELT (drs, i, dr)\n+    dr->aux = XNEW (base_alias_pair);\n \n   for (i = 0; i < g->n_vertices; i++)\n     {\n       data_reference_p dr = drs[i];\n-      base_alias_pair *bap;\n-\n-      gcc_assert (dr->aux);\n-      bap = (base_alias_pair *)(dr->aux);\n-\n-      bap->base_obj_set = g->vertices[i].component + 1;\n+      base_alias_pair *bap = (base_alias_pair *)(dr->aux);\n+      bap->alias_set = XNEW (int);\n+      int c = g->vertices[i].component + 1;\n+      *(bap->alias_set) = c;\n     }\n \n-  free (queue);\n   free_graph (g);\n }\n \n@@ -1348,48 +1159,12 @@ build_pbb_drs (poly_bb_p pbb)\n     build_poly_dr (dr, pbb);\n }\n \n-/* Dump to file the alias graphs for the data references in DRS.  */\n-\n-static void\n-dump_alias_graphs (vec<data_reference_p> drs)\n-{\n-  char comment[100];\n-  FILE *file_dimacs, *file_ecc, *file_dot;\n-\n-  file_dimacs = fopen (\"/tmp/dr_alias_graph_dimacs\", \"ab\");\n-  if (file_dimacs)\n-    {\n-      snprintf (comment, sizeof (comment), \"%s %s\", main_input_filename,\n-\t\tcurrent_function_name ());\n-      write_alias_graph_to_ascii_dimacs (file_dimacs, comment, drs);\n-      fclose (file_dimacs);\n-    }\n-\n-  file_ecc = fopen (\"/tmp/dr_alias_graph_ecc\", \"ab\");\n-  if (file_ecc)\n-    {\n-      snprintf (comment, sizeof (comment), \"%s %s\", main_input_filename,\n-\t\tcurrent_function_name ());\n-      write_alias_graph_to_ascii_ecc (file_ecc, comment, drs);\n-      fclose (file_ecc);\n-    }\n-\n-  file_dot = fopen (\"/tmp/dr_alias_graph_dot\", \"ab\");\n-  if (file_dot)\n-    {\n-      snprintf (comment, sizeof (comment), \"%s %s\", main_input_filename,\n-\t\tcurrent_function_name ());\n-      write_alias_graph_to_ascii_dot (file_dot, comment, drs);\n-      fclose (file_dot);\n-    }\n-}\n-\n /* Build data references in SCOP.  */\n \n static void\n build_scop_drs (scop_p scop)\n {\n-  int i, j;\n+  int i;\n   poly_bb_p pbb;\n \n   /* Remove all the PBBs that do not have data references: these basic\n@@ -1403,32 +1178,16 @@ build_scop_drs (scop_p scop)\n \ti--;\n       }\n \n-  data_reference_p dr;\n   auto_vec<data_reference_p, 3> drs;\n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    for (j = 0; GBB_DATA_REFS (PBB_BLACK_BOX (pbb)).iterate (j, &dr); j++)\n-      drs.safe_push (dr);\n+    drs.safe_splice (GBB_DATA_REFS (PBB_BLACK_BOX (pbb)));\n \n-  FOR_EACH_VEC_ELT (drs, i, dr)\n-    dr->aux = XNEW (base_alias_pair);\n-\n-  if (!build_alias_set_optimal_p (drs))\n-    {\n-      /* TODO: Add support when building alias set is not optimal.  */\n-      ;\n-    }\n-\n-  build_base_obj_set_for_drs (drs);\n-\n-  /* When debugging, enable the following code.  This cannot be used\n-     in production compilers.  */\n-  if (0)\n-    dump_alias_graphs (drs);\n-\n-  drs.release ();\n+  build_alias_set (drs);\n \n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n     build_pbb_drs (pbb);\n+\n+  drs.release ();\n }\n \n /* Analyze all the data references of STMTS and add them to the"}]}