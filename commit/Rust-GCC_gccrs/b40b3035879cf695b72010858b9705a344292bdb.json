{"sha": "b40b3035879cf695b72010858b9705a344292bdb", "node_id": "C_kwDOANBUbNoAKGI0MGIzMDM1ODc5Y2Y2OTViNzIwMTA4NThiOTcwNWEzNDQyOTJiZGI", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-20T20:53:37Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-22T18:48:29Z"}, "message": "Add range-ops support for builtin functions.\n\nConvert CFN_BUILT_IN_CONSTANT_P as first POC.\n\n\t* gimple-range-fold.cc\n\t(fold_using_range::range_of_builtin_int_call): Remove case for\n\tCFN_BUILT_IN_CONSTANT_P.\n\t* gimple-range-op.cc (gimple_range_op_handler::supported_p):\n\tCheck if a call also creates a range-op object.\n\t(gimple_range_op_handler): Also check builtin calls.\n\t(class cfn_constant_float_p): New.  Float CFN_BUILT_IN_CONSTANT_P.\n\t(class cfn_constant_p): New.  Integral CFN_BUILT_IN_CONSTANT_P.\n\t(gimple_range_op_handler::maybe_builtin_call): Set arguments and\n\thandler for supported built-in calls.\n\t* gimple-range-op.h (maybe_builtin_call): New prototype.", "tree": {"sha": "95ba68b08dc3d79bc073f63687f5d7fd13693ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95ba68b08dc3d79bc073f63687f5d7fd13693ddf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b40b3035879cf695b72010858b9705a344292bdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40b3035879cf695b72010858b9705a344292bdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b40b3035879cf695b72010858b9705a344292bdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40b3035879cf695b72010858b9705a344292bdb/comments", "author": null, "committer": null, "parents": [{"sha": "2f92f685da2ef9e82ee6262519919180df8f2dd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f92f685da2ef9e82ee6262519919180df8f2dd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f92f685da2ef9e82ee6262519919180df8f2dd9"}], "stats": {"total": 122, "additions": 97, "deletions": 25}, "files": [{"sha": "63a1f517d288d9cfc9b6b2e2e611f42ac1ad7046", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40b3035879cf695b72010858b9705a344292bdb/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40b3035879cf695b72010858b9705a344292bdb/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=b40b3035879cf695b72010858b9705a344292bdb", "patch": "@@ -944,23 +944,6 @@ fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n \n   switch (func)\n     {\n-    case CFN_BUILT_IN_CONSTANT_P:\n-      {\n-\targ = gimple_call_arg (call, 0);\n-\tValue_Range tmp (TREE_TYPE (arg));\n-\tif (src.get_operand (tmp, arg) && tmp.singleton_p ())\n-\t  {\n-\t    r.set (build_one_cst (type), build_one_cst (type));\n-\t    return true;\n-\t  }\n-\tif (cfun->after_inlining)\n-\t  {\n-\t    r.set_zero (type);\n-\t    return true;\n-\t  }\n-\tbreak;\n-      }\n-\n     case CFN_BUILT_IN_SIGNBIT:\n       {\n \targ = gimple_call_arg (call, 0);"}, {"sha": "bcc4c3d778ca90ba4376258f1a95b6f9a279be1e", "filename": "gcc/gimple-range-op.cc", "status": "modified", "additions": 96, "deletions": 8, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40b3035879cf695b72010858b9705a344292bdb/gcc%2Fgimple-range-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40b3035879cf695b72010858b9705a344292bdb/gcc%2Fgimple-range-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.cc?ref=b40b3035879cf695b72010858b9705a344292bdb", "patch": "@@ -123,7 +123,11 @@ gimple_range_op_handler::supported_p (gimple *s)\n {\n   enum tree_code code;\n   tree type = get_code_and_type (s, code);\n-  return (type && range_op_handler (code, type));\n+  if (type && range_op_handler (code, type))\n+    return true;\n+  if (is_a <gcall *> (s) && gimple_range_op_handler (s))\n+    return true;\n+  return false;\n }\n \n // Construct a handler object for statement S.\n@@ -133,6 +137,8 @@ gimple_range_op_handler::gimple_range_op_handler (gimple *s)\n   enum tree_code code;\n   tree type = get_code_and_type (s, code);\n   m_stmt = s;\n+  m_op1 = NULL_TREE;\n+  m_op2 = NULL_TREE;\n   if (type)\n     set_op_handler (code, type);\n \n@@ -142,7 +148,7 @@ gimple_range_op_handler::gimple_range_op_handler (gimple *s)\n \tcase GIMPLE_COND:\n \t  m_op1 = gimple_cond_lhs (m_stmt);\n \t  m_op2 = gimple_cond_rhs (m_stmt);\n-\t  break;\n+\t  return;\n \tcase GIMPLE_ASSIGN:\n \t  m_op1 = gimple_range_base_of_assignment (m_stmt);\n \t  if (m_op1 && TREE_CODE (m_op1) == MEM_REF)\n@@ -158,14 +164,15 @@ gimple_range_op_handler::gimple_range_op_handler (gimple *s)\n \t    }\n \t  if (gimple_num_ops (m_stmt) >= 3)\n \t    m_op2 = gimple_assign_rhs2 (m_stmt);\n-\t  else\n-\t    m_op2 = NULL_TREE;\n-\t  break;\n+\t  return;\n \tdefault:\n-\t  m_op1 = NULL_TREE;\n-\t  m_op2 = NULL_TREE;\n-\t  break;\n+\t  gcc_unreachable ();\n+\t  return;\n       }\n+  // If no range-op table entry handled this stmt, check for other supported\n+  // statements.\n+  if (is_a <gcall *> (m_stmt))\n+    maybe_builtin_call ();\n }\n \n // Calculate what we can determine of the range of this unary\n@@ -247,3 +254,84 @@ gimple_range_op_handler::calc_op2 (vrange &r, const vrange &lhs_range,\n     }\n   return op2_range (r, type, lhs_range, op1_range);\n }\n+\n+// --------------------------------------------------------------------\n+\n+// Implement range operator for float CFN_BUILT_IN_CONSTANT_P.\n+class cfn_constant_float_p : public range_operator_float\n+{\n+public:\n+  using range_operator_float::fold_range;\n+  virtual bool fold_range (irange &r, tree type, const frange &lh,\n+\t\t\t   const irange &, relation_kind) const\n+  {\n+    if (lh.singleton_p ())\n+      {\n+\tr.set (build_one_cst (type), build_one_cst (type));\n+\treturn true;\n+      }\n+    if (cfun->after_inlining)\n+      {\n+\tr.set_zero (type);\n+\treturn true;\n+      }\n+    return false;\n+  }\n+} op_cfn_constant_float_p;\n+\n+// Implement range operator for integral CFN_BUILT_IN_CONSTANT_P.\n+class cfn_constant_p : public range_operator\n+{\n+public:\n+  using range_operator::fold_range;\n+  virtual bool fold_range (irange &r, tree type, const irange &lh,\n+\t\t\t   const irange &, relation_kind) const\n+  {\n+    if (lh.singleton_p ())\n+      {\n+\tr.set (build_one_cst (type), build_one_cst (type));\n+\treturn true;\n+      }\n+    if (cfun->after_inlining)\n+      {\n+\tr.set_zero (type);\n+\treturn true;\n+      }\n+    return false;\n+  }\n+} op_cfn_constant_p;\n+\n+// Set up a gimple_range_op_handler for any built in function which can be\n+// supported via range-ops.\n+\n+void\n+gimple_range_op_handler::maybe_builtin_call ()\n+{\n+  gcc_checking_assert (is_a <gcall *> (m_stmt));\n+\n+  gcall *call = as_a <gcall *> (m_stmt);\n+  combined_fn func = gimple_call_combined_fn (call);\n+  if (func == CFN_LAST)\n+    return;\n+  tree type = gimple_range_type (call);\n+  gcc_checking_assert (type);\n+  if (!Value_Range::supports_type_p (type))\n+    return;\n+\n+  switch (func)\n+    {\n+    case CFN_BUILT_IN_CONSTANT_P:\n+      m_op1 = gimple_call_arg (call, 0);\n+      m_valid = true;\n+      if (irange::supports_p (TREE_TYPE (m_op1)))\n+\tm_int = &op_cfn_constant_p;\n+      else if (frange::supports_p (TREE_TYPE (m_op1)))\n+\tm_float = &op_cfn_constant_float_p;\n+      else\n+\tm_valid = false;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}"}, {"sha": "68764198bc0605a657d573225700ef2447fc4816", "filename": "gcc/gimple-range-op.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40b3035879cf695b72010858b9705a344292bdb/gcc%2Fgimple-range-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40b3035879cf695b72010858b9705a344292bdb/gcc%2Fgimple-range-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.h?ref=b40b3035879cf695b72010858b9705a344292bdb", "patch": "@@ -38,6 +38,7 @@ class gimple_range_op_handler : public range_op_handler\n   bool calc_op1 (vrange &r, const vrange &lhs_range, const vrange &op2_range);\n   bool calc_op2 (vrange &r, const vrange &lhs_range, const vrange &op1_range);\n private:\n+  void maybe_builtin_call ();\n   gimple *m_stmt;\n   tree m_op1, m_op2;\n };"}]}