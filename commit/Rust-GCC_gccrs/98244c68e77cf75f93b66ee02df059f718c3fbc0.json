{"sha": "98244c68e77cf75f93b66ee02df059f718c3fbc0", "node_id": "C_kwDOANBUbNoAKDk4MjQ0YzY4ZTc3Y2Y3NWY5M2I2NmVlMDJkZjA1OWY3MThjM2ZiYzA", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-11-04T19:08:06Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-11-05T17:15:19Z"}, "message": "Abstract ranger cache update list.\n\nMake it more efficient by removing the call to vec::contains.\n\n\tPR tree-optimization/102943\n\t* gimple-range-cache.cc (class update_list): New.\n\t(update_list::add): Replace add_to_update.\n\t(update_list::pop): New.\n\t(ranger_cache::ranger_cache): Adjust.\n\t(ranger_cache::~ranger_cache): Adjust.\n\t(ranger_cache::add_to_update): Delete.\n\t(ranger_cache::propagate_cache): Adjust to new class.\n\t(ranger_cache::propagate_updated_value): Ditto.\n\t(ranger_cache::fill_block_cache): Ditto.\n\t* gimple-range-cache.h (class ranger_cache): Adjust to update class.", "tree": {"sha": "2495475ee19889024e88e4c8bfbdf730b3698ea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2495475ee19889024e88e4c8bfbdf730b3698ea6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98244c68e77cf75f93b66ee02df059f718c3fbc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98244c68e77cf75f93b66ee02df059f718c3fbc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98244c68e77cf75f93b66ee02df059f718c3fbc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98244c68e77cf75f93b66ee02df059f718c3fbc0/comments", "author": null, "committer": null, "parents": [{"sha": "a79fe53d6ce6074d083e925b6b19773e45817405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79fe53d6ce6074d083e925b6b19773e45817405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a79fe53d6ce6074d083e925b6b19773e45817405"}], "stats": {"total": 133, "additions": 100, "deletions": 33}, "files": [{"sha": "e5591bab0ef98292faa2e8378707ef85d0b3e060", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 99, "deletions": 30, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98244c68e77cf75f93b66ee02df059f718c3fbc0/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98244c68e77cf75f93b66ee02df059f718c3fbc0/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=98244c68e77cf75f93b66ee02df059f718c3fbc0", "patch": "@@ -754,14 +754,96 @@ temporal_cache::set_always_current (tree name)\n \n // --------------------------------------------------------------------------\n \n+// This class provides an abstraction of a list of blocks to be updated\n+// by the cache.  It is currently a stack but could be changed.  It also\n+// maintains a list of blocks which have failed propagation, and does not\n+// enter any of those blocks into the list.\n+\n+// A vector over the BBs is maintained, and an entry of 0 means it is not in\n+// a list.  Otherwise, the entry is the next block in the list. -1 terminates\n+// the list.  m_head points to the top of the list, -1 if the list is empty.\n+\n+class update_list\n+{\n+public:\n+  update_list ();\n+  ~update_list ();\n+  void add (basic_block bb);\n+  basic_block pop ();\n+  inline bool empty_p () { return m_update_head == -1; }\n+  inline void clear_failures () { bitmap_clear (m_propfail); }\n+  inline void propagation_failed (basic_block bb)\n+\t\t\t\t  { bitmap_set_bit (m_propfail, bb->index); }\n+private:\n+  vec<int> m_update_list;\n+  int m_update_head;\n+  bitmap m_propfail;\n+};\n+\n+// Create an update list.\n+\n+update_list::update_list ()\n+{\n+  m_update_list.create (0);\n+  m_update_list.safe_grow_cleared (last_basic_block_for_fn (cfun) + 64);\n+  m_update_head = -1;\n+  m_propfail = BITMAP_ALLOC (NULL);\n+}\n+\n+// Destroy an update list.\n+\n+update_list::~update_list ()\n+{\n+  m_update_list.release ();\n+  BITMAP_FREE (m_propfail);\n+}\n+\n+// Add BB to the list of blocks to update, unless it's already in the list.\n+\n+void\n+update_list::add (basic_block bb)\n+{\n+  int i = bb->index;\n+  // If propagation has failed for BB, or its already in the list, don't\n+  // add it again.\n+  if ((unsigned)i >= m_update_list.length ())\n+    m_update_list.safe_grow_cleared (i + 64);\n+  if (!m_update_list[i] && !bitmap_bit_p (m_propfail, i))\n+    {\n+      if (empty_p ())\n+\t{\n+\t  m_update_head = i;\n+\t  m_update_list[i] = -1;\n+\t}\n+      else\n+\t{\n+\t  gcc_checking_assert (m_update_head > 0);\n+\t  m_update_list[i] = m_update_head;\n+\t  m_update_head = i;\n+\t}\n+    }\n+}\n+\n+// Remove a block from the list.\n+\n+basic_block\n+update_list::pop ()\n+{\n+  gcc_checking_assert (!empty_p ());\n+  basic_block bb = BASIC_BLOCK_FOR_FN (cfun, m_update_head);\n+  int pop = m_update_head;\n+  m_update_head = m_update_list[pop];\n+  m_update_list[pop] = 0;\n+  return bb;\n+}\n+\n+// --------------------------------------------------------------------------\n+\n ranger_cache::ranger_cache (int not_executable_flag)\n \t\t\t\t\t\t: m_gori (not_executable_flag)\n {\n   m_workback.create (0);\n   m_workback.safe_grow_cleared (last_basic_block_for_fn (cfun));\n-  m_update_list.create (0);\n-  m_update_list.safe_grow_cleared (last_basic_block_for_fn (cfun));\n-  m_update_list.truncate (0);\n   m_temporal = new temporal_cache;\n   // If DOM info is available, spawn an oracle as well.\n   if (dom_info_available_p (CDI_DOMINATORS))\n@@ -779,17 +861,16 @@ ranger_cache::ranger_cache (int not_executable_flag)\n       if (bb)\n \tm_gori.exports (bb);\n     }\n-  m_propfail = BITMAP_ALLOC (NULL);\n+  m_update = new update_list ();\n }\n \n ranger_cache::~ranger_cache ()\n {\n-  BITMAP_FREE (m_propfail);\n+  delete m_update;\n   if (m_oracle)\n     delete m_oracle;\n   delete m_temporal;\n   m_workback.release ();\n-  m_update_list.release ();\n }\n \n // Dump the global caches to file F.  if GORI_DUMP is true, dump the\n@@ -1029,17 +1110,6 @@ ranger_cache::block_range (irange &r, basic_block bb, tree name, bool calc)\n   return m_on_entry.get_bb_range (r, name, bb);\n }\n \n-// Add BB to the list of blocks to update, unless it's already in the list.\n-\n-void\n-ranger_cache::add_to_update (basic_block bb)\n-{\n-  // If propagation has failed for BB, or its already in the list, don't\n-  // add it again.\n-  if (!bitmap_bit_p (m_propfail, bb->index) &&  !m_update_list.contains (bb))\n-    m_update_list.quick_push (bb);\n-}\n-\n // If there is anything in the propagation update_list, continue\n // processing NAME until the list of blocks is empty.\n \n@@ -1053,16 +1123,15 @@ ranger_cache::propagate_cache (tree name)\n   int_range_max current_range;\n   int_range_max e_range;\n \n-  gcc_checking_assert (bitmap_empty_p (m_propfail));\n   // Process each block by seeing if its calculated range on entry is\n   // the same as its cached value. If there is a difference, update\n   // the cache to reflect the new value, and check to see if any\n   // successors have cache entries which may need to be checked for\n   // updates.\n \n-  while (m_update_list.length () > 0)\n+  while (!m_update->empty_p ())\n     {\n-      bb = m_update_list.pop ();\n+      bb = m_update->pop ();\n       gcc_checking_assert (m_on_entry.bb_range_p (name, bb));\n       m_on_entry.get_bb_range (current_range, name, bb);\n \n@@ -1097,7 +1166,7 @@ ranger_cache::propagate_cache (tree name)\n \t  bool ok_p = m_on_entry.set_bb_range (name, bb, new_range);\n \t  // If the cache couldn't set the value, mark it as failed.\n \t  if (!ok_p)\n-\t    bitmap_set_bit (m_propfail, bb->index);\n+\t    m_update->propagation_failed (bb);\n \t  if (DEBUG_RANGE_CACHE) \n \t    {\n \t      if (!ok_p)\n@@ -1119,7 +1188,7 @@ ranger_cache::propagate_cache (tree name)\n \t      {\n \t\tif (DEBUG_RANGE_CACHE) \n \t\t  fprintf (dump_file, \" bb%d\",e->dest->index);\n-\t\tadd_to_update (e->dest);\n+\t\tm_update->add (e->dest);\n \t      }\n \t  if (DEBUG_RANGE_CACHE) \n \t    fprintf (dump_file, \"\\n\");\n@@ -1131,7 +1200,7 @@ ranger_cache::propagate_cache (tree name)\n       print_generic_expr (dump_file, name, TDF_SLIM);\n       fprintf (dump_file, \"\\n\");\n     }\n-  bitmap_clear (m_propfail);\n+  m_update->clear_failures ();\n }\n \n // Check to see if an update to the value for NAME in BB has any effect\n@@ -1146,7 +1215,7 @@ ranger_cache::propagate_updated_value (tree name, basic_block bb)\n   edge_iterator ei;\n \n   // The update work list should be empty at this point.\n-  gcc_checking_assert (m_update_list.length () == 0);\n+  gcc_checking_assert (m_update->empty_p ());\n   gcc_checking_assert (bb);\n \n   if (DEBUG_RANGE_CACHE)\n@@ -1160,12 +1229,12 @@ ranger_cache::propagate_updated_value (tree name, basic_block bb)\n       // Only update active cache entries.\n       if (m_on_entry.bb_range_p (name, e->dest))\n \t{\n-\t  add_to_update (e->dest);\n+\t  m_update->add (e->dest);\n \t  if (DEBUG_RANGE_CACHE)\n \t    fprintf (dump_file, \" UPDATE: bb%d\", e->dest->index);\n \t}\n     }\n-    if (m_update_list.length () != 0)\n+    if (!m_update->empty_p ())\n       {\n \tif (DEBUG_RANGE_CACHE)\n \t  fprintf (dump_file, \"\\n\");\n@@ -1205,7 +1274,7 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n   m_workback.quick_push (bb);\n   undefined.set_undefined ();\n   m_on_entry.set_bb_range (name, bb, undefined);\n-  gcc_checking_assert (m_update_list.length () == 0);\n+  gcc_checking_assert (m_update->empty_p ());\n \n   if (DEBUG_RANGE_CACHE)\n     {\n@@ -1235,7 +1304,7 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t  // If the pred block is the def block add this BB to update list.\n \t  if (pred == def_bb)\n \t    {\n-\t      add_to_update (node);\n+\t      m_update->add (node);\n \t      continue;\n \t    }\n \n@@ -1255,7 +1324,7 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t    {\n \t      if (DEBUG_RANGE_CACHE)\n \t\tfprintf (dump_file, \"nonnull: update \");\n-\t      add_to_update (node);\n+\t      m_update->add (node);\n \t    }\n \n \t  // If the pred block already has a range, or if it can contribute\n@@ -1270,7 +1339,7 @@ ranger_cache::fill_block_cache (tree name, basic_block bb, basic_block def_bb)\n \t\t}\n \t      if (!r.undefined_p () || m_gori.has_edge_range_p (name, e))\n \t\t{\n-\t\t  add_to_update (node);\n+\t\t  m_update->add (node);\n \t\t  if (DEBUG_RANGE_CACHE)\n \t\t    fprintf (dump_file, \"update. \");\n \t\t}"}, {"sha": "49c13d1e85fa8b1fab717711ddd30e4acfeee05f", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98244c68e77cf75f93b66ee02df059f718c3fbc0/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98244c68e77cf75f93b66ee02df059f718c3fbc0/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=98244c68e77cf75f93b66ee02df059f718c3fbc0", "patch": "@@ -114,17 +114,15 @@ class ranger_cache : public range_query\n   ssa_global_cache m_globals;\n   block_range_cache m_on_entry;\n   class temporal_cache *m_temporal;\n-  void add_to_update (basic_block bb);\n   void fill_block_cache (tree name, basic_block bb, basic_block def_bb);\n   void propagate_cache (tree name);\n \n   void range_of_def (irange &r, tree name, basic_block bb = NULL);\n   void entry_range (irange &r, tree expr, basic_block bb);\n   void exit_range (irange &r, tree expr, basic_block bb);\n \n-  bitmap m_propfail;\n   vec<basic_block> m_workback;\n-  vec<basic_block> m_update_list;\n+  class update_list *m_update;\n };\n \n #endif // GCC_SSA_RANGE_CACHE_H"}]}