{"sha": "31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFlMGFiMWY3Njk5ZTNlZDFiZjRiNDdlYzA3MDEzNDhkMGRkN2MyYw==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "2000-09-05T01:01:12Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-09-05T01:01:12Z"}, "message": "In include:\n\n        * dyn-string.h: Adjust formatting.\n        (dyn_string_insert_char): New macro.  New declaration.\n\nIn libiberty:\n\n        * cp-demangle.c (ANONYMOUS_NAMESPACE_PREFIX): New macro.\n        (substitution_def): Remove template_parm_number.\n        (NOT_TEMPLATE_PARM): Remove.\n        (result_insert_string): New macro.\n        (result_insert): Likewise.\n        (result_insert_char): Likewise.\n        (substitution_add): Remove last parameter.  Don't store template\n        parm number.\n        (BFT_NO_RETURN_TYPE): Define as NULL.\n        (demangle_encoding): Adjust call to demangle_bare_function_type.\n        (demangle_name): Adjust substitution.  Adjust call to\n        substitution_add.\n        (demangle_prefix): Adjust call to substitution_add.\n        (demangle_identifier): Handle anonymous namespaces.\n        (demangle_operator_name): Change demangling of vendor-extended\n        operator to match ABI changes.\n        (demangle_type_ptr): Change parameters.  Make recursive.  Handle\n        substitutions here.\n        (demangle_type): Adjust calls to demangle_template_param,\n        substitution_add, and demangle_type_ptr.  Fix substitution of\n        templated types.\n        (demangle_function_type): Change parameter to a pointer.\n        (demangle_bare_function_type): Likewise.  Adjust insertion point.\n        (demangle_template_param): Remove last parameter.\n        (demangle_expr_primary): Remove unused variable.  Adjust call to\n        demangle_template_param.\n        (is_mangled_char): Accept `$' and `.'.\n        * cplus-dem.c (gnu_new_abi_symbol_characters): Add '$' and '.'.\n        * dyn-string.c (dyn_string_insert_char): New function.\n\nFrom-SVN: r36148", "tree": {"sha": "080c4c809c23cab4fbada302cee7e2c74c17d4b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/080c4c809c23cab4fbada302cee7e2c74c17d4b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/comments", "author": null, "committer": null, "parents": [{"sha": "c9672d45dcdb6b6ba564450539c5b46ab8384b2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9672d45dcdb6b6ba564450539c5b46ab8384b2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9672d45dcdb6b6ba564450539c5b46ab8384b2f"}], "stats": {"total": 434, "additions": 286, "deletions": 148}, "files": [{"sha": "5a541b610bcc77f71cec947741aa26a5c264ffe6", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "patch": "@@ -1,3 +1,8 @@\n+2000-09-04  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* dyn-string.h: Adjust formatting. \n+\t(dyn_string_insert_char): New macro.  New declaration.\n+\n 2000-08-28  Jason Merrill  <jason@redhat.com>\n \n \t* md5.h: New file."}, {"sha": "67f7ab7d36e43619766c6e9a50f23669af2e5b72", "filename": "include/dyn-string.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/include%2Fdyn-string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/include%2Fdyn-string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdyn-string.h?ref=31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "patch": "@@ -59,6 +59,7 @@ typedef struct dyn_string\n #define dyn_string_prepend_cstr         __cxa_dyn_string_prepend_cstr\n #define dyn_string_insert               __cxa_dyn_string_insert\n #define dyn_string_insert_cstr          __cxa_dyn_string_insert_cstr\n+#define dyn_string_insert_char          __cxa_dyn_string_insert_char\n #define dyn_string_append               __cxa_dyn_string_append\n #define dyn_string_append_cstr          __cxa_dyn_string_append_cstr\n #define dyn_string_append_char          __cxa_dyn_string_append_char\n@@ -82,11 +83,10 @@ extern int dyn_string_insert            PARAMS ((dyn_string_t, int,\n \t\t\t\t\t\t dyn_string_t));\n extern int dyn_string_insert_cstr       PARAMS ((dyn_string_t, int,\n \t\t\t\t\t\t const char *));\n+extern int dyn_string_insert_char       PARAMS ((dyn_string_t, int, int));\n extern int dyn_string_append            PARAMS ((dyn_string_t, dyn_string_t));\n-extern int dyn_string_append_cstr   \n-                                        PARAMS ((dyn_string_t, const char *));\n-extern int dyn_string_append_char\n-                                        PARAMS ((dyn_string_t, int));\n+extern int dyn_string_append_cstr       PARAMS ((dyn_string_t, const char *));\n+extern int dyn_string_append_char       PARAMS ((dyn_string_t, int));\n extern int dyn_string_substring         PARAMS ((dyn_string_t, \n \t\t\t\t\t\t dyn_string_t, int, int));\n extern int dyn_string_eq                PARAMS ((dyn_string_t, dyn_string_t));"}, {"sha": "0ee0abfda901c8efa9f73912ead99b9e285fc1ac", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "patch": "@@ -1,3 +1,35 @@\n+2000-09-03  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* cp-demangle.c (ANONYMOUS_NAMESPACE_PREFIX): New macro.\n+\t(substitution_def): Remove template_parm_number.\n+\t(NOT_TEMPLATE_PARM): Remove.\n+\t(result_insert_string): New macro.\n+\t(result_insert): Likewise.\n+\t(result_insert_char): Likewise.\n+\t(substitution_add): Remove last parameter.  Don't store template\n+\tparm number. \n+\t(BFT_NO_RETURN_TYPE): Define as NULL.\n+\t(demangle_encoding): Adjust call to demangle_bare_function_type.\n+\t(demangle_name): Adjust substitution.  Adjust call to\n+\tsubstitution_add. \n+\t(demangle_prefix): Adjust call to substitution_add.\n+\t(demangle_identifier): Handle anonymous namespaces.\n+\t(demangle_operator_name): Change demangling of vendor-extended\n+\toperator to match ABI changes.\n+\t(demangle_type_ptr): Change parameters.  Make recursive.  Handle\n+\tsubstitutions here.  \n+\t(demangle_type): Adjust calls to demangle_template_param,\n+\tsubstitution_add, and demangle_type_ptr.  Fix substitution of\n+\ttemplated types.\n+\t(demangle_function_type): Change parameter to a pointer.\n+\t(demangle_bare_function_type): Likewise.  Adjust insertion point.\n+\t(demangle_template_param): Remove last parameter.\n+\t(demangle_expr_primary): Remove unused variable.  Adjust call to\n+\tdemangle_template_param. \n+\t(is_mangled_char): Accept `$' and `.'.\n+\t* cplus-dem.c (gnu_new_abi_symbol_characters): Add '$' and '.'.\n+\t* dyn-string.c (dyn_string_insert_char): New function.\n+\n 2000-08-31  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* testsuite/demangle-expected: Add nine tests for"}, {"sha": "f6e58342ed208508a71318ef8beb04d6f304ecf4", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 220, "deletions": 143, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "patch": "@@ -62,6 +62,10 @@\n   (((CHAR) >= 'a' && (CHAR) <= 'z')                                     \\\n    || ((CHAR) >= 'A' && (CHAR) <= 'Z'))\n \n+/* The prefix prepended by GCC to an identifier represnting the\n+   anonymous namespace.  */\n+#define ANONYMOUS_NAMESPACE_PREFIX \"_GLOBAL_\"\n+\n /* If flag_verbose is zero, some simplifications will be made to the\n    output to make it easier to read and supress details that are\n    generally not of interest to the average C++ programmer.\n@@ -92,17 +96,10 @@ struct substitution_def\n   /* The demangled text of the substitution.  */\n   dyn_string_t text;\n \n-  /* The template parameter that this represents, indexed from zero.\n-     If this is not a template paramter number, the value is\n-     NOT_TEMPLATE_PARM.  */\n-  int template_parm_number;\n-\n   /* Whether this substitution represents a template item.  */\n   int template_p : 1;\n };\n \n-#define NOT_TEMPLATE_PARM (-1)\n-\n /* Data structure representing a template argument list.  */\n \n struct template_arg_list_def\n@@ -206,7 +203,7 @@ static string_list_t result_pop\n static int substitution_start\n   PARAMS ((demangling_t));\n static status_t substitution_add\n-  PARAMS ((demangling_t, int, int, int));\n+  PARAMS ((demangling_t, int, int));\n static dyn_string_t substitution_get\n   PARAMS ((demangling_t, int, int *));\n #ifdef CP_DEMANGLE_DEBUG\n@@ -288,6 +285,22 @@ static void demangling_delete\n   (dyn_string_append_char (&(DM)->result->string, (CHAR))               \\\n    ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n \n+/* Inserts a dyn_string_t to the demangled result at position POS.  */\n+#define result_insert_string(DM, POS, STRING)                           \\\n+  (dyn_string_insert (&(DM)->result->string, (POS), (STRING))           \\\n+   ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n+\n+/* Inserts NUL-terminated string CSTR to the demangled result at\n+   position POS.  */\n+#define result_insert(DM, POS, CSTR)                                    \\\n+  (dyn_string_insert_cstr (&(DM)->result->string, (POS), (CSTR))        \\\n+   ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n+\n+/* Inserts character CHAR to the demangled result at position POS.  */\n+#define result_insert_char(DM, POS, CHAR)                               \\\n+  (dyn_string_insert_char (&(DM)->result->string, (POS), (CHAR))        \\\n+   ? STATUS_OK : STATUS_ALLOCATION_FAILED)\n+\n /* The length of the current demangled result.  */\n #define result_length(DM)                                               \\\n   dyn_string_length (&(DM)->result->string)\n@@ -458,19 +471,13 @@ substitution_start (dm)\n \n /* Adds the suffix of the current demangled result of DM starting at\n    START_POSITION as a potential substitution.  If TEMPLATE_P is\n-   non-zero, this potential substitution is a template-id.  \n-\n-   If TEMPLATE_PARM_NUMBER is not NOT_TEMPLATE_PARM, the substitution\n-   is for that particular <template-param>, and is distinct from other\n-   otherwise-identical types and other <template-param>s with\n-   different indices.  */\n+   non-zero, this potential substitution is a template-id.  */\n \n static status_t\n-substitution_add (dm, start_position, template_p, template_parm_number)\n+substitution_add (dm, start_position, template_p)\n      demangling_t dm;\n      int start_position;\n      int template_p;\n-     int template_parm_number;\n {\n   dyn_string_t result = result_string (dm);\n   dyn_string_t substitution = dyn_string_new (0);\n@@ -513,7 +520,6 @@ substitution_add (dm, start_position, template_p, template_parm_number)\n   i = dm->num_substitutions++;\n   dm->substitutions[i].text = substitution;\n   dm->substitutions[i].template_p = template_p;\n-  dm->substitutions[i].template_parm_number = template_parm_number;\n \n #ifdef CP_DEMANGLE_DEBUG\n   substitutions_print (dm, stderr);\n@@ -815,23 +821,23 @@ static status_t demangle_special_name\n static status_t demangle_ctor_dtor_name\n   PARAMS ((demangling_t));\n static status_t demangle_type_ptr\n-  PARAMS ((demangling_t));\n+  PARAMS ((demangling_t, int *, int));\n static status_t demangle_type\n   PARAMS ((demangling_t));\n static status_t demangle_CV_qualifiers\n   PARAMS ((demangling_t, dyn_string_t));\n static status_t demangle_builtin_type\n   PARAMS ((demangling_t));\n static status_t demangle_function_type\n-  PARAMS ((demangling_t, int));\n+  PARAMS ((demangling_t, int *));\n static status_t demangle_bare_function_type\n-  PARAMS ((demangling_t, int));\n+  PARAMS ((demangling_t, int *));\n static status_t demangle_class_enum_type\n   PARAMS ((demangling_t, int *));\n static status_t demangle_array_type\n   PARAMS ((demangling_t));\n static status_t demangle_template_param\n-  PARAMS ((demangling_t, int *));\n+  PARAMS ((demangling_t));\n static status_t demangle_template_args\n   PARAMS ((demangling_t));\n static status_t demangle_literal\n@@ -859,7 +865,7 @@ static status_t cp_demangle_type\n \n /* When passed to demangle_bare_function_type, indicates that the\n    function's return type is not encoded before its parameter types.  */\n-#define BFT_NO_RETURN_TYPE    -1\n+#define BFT_NO_RETURN_TYPE    NULL\n \n /* Check that the next character is C.  If so, consume it.  If not,\n    return an error.  */\n@@ -937,7 +943,7 @@ demangle_encoding (dm)\n \t    /* Template functions have their return type encoded.  The\n \t       return type should be inserted at start_position.  */\n \t    RETURN_IF_ERROR \n-\t      (demangle_bare_function_type (dm, start_position));\n+\t      (demangle_bare_function_type (dm, &start_position));\n \t  else\n \t    /* Non-template functions don't have their return type\n \t       encoded.  */\n@@ -974,6 +980,7 @@ demangle_name (dm, template_p)\n {\n   int start = substitution_start (dm);\n   char peek = peek_char (dm);\n+  int is_std_substitution = 0;\n \n   DEMANGLE_TRACE (\"name\", dm);\n \n@@ -998,6 +1005,7 @@ demangle_name (dm, template_p)\n \t  (void) next_char (dm);\n \t  RETURN_IF_ERROR (result_append (dm, \"std::\"));\n \t  RETURN_IF_ERROR (demangle_unqualified_name (dm));\n+\t  is_std_substitution = 1;\n \t}\n       else\n \t{\n@@ -1007,11 +1015,11 @@ demangle_name (dm, template_p)\n \t If so, then we just demangled an <unqualified-template-name>.  */\n       if (peek_char (dm) == 'I') \n \t{\n-\t  /* The template name is a substitution candidate, unless it\n-             was already a back-substitution.  */\n-\t  if (peek != 'S')\n-\t    RETURN_IF_ERROR (substitution_add (dm, start, 0, \n-\t\t\t\t\t       NOT_TEMPLATE_PARM));\n+\t  /* A template name of the form std::<unqualified-name> is a\n+             substitution candidate.  */\n+\t  if (is_std_substitution)\n+\t    RETURN_IF_ERROR (substitution_add (dm, start, 0));\n+\t  /* Demangle the <template-args> here.  */\n \t  RETURN_IF_ERROR (demangle_template_args (dm));\n \t  *template_p = 1;\n \t}\n@@ -1029,8 +1037,7 @@ demangle_name (dm, template_p)\n       if (peek_char (dm) == 'I')\n \t{\n \t  /* Add a substitution for the unqualified template name.  */\n-\t  RETURN_IF_ERROR (substitution_add (dm, start, 0, \n-\t\t\t\t\t     NOT_TEMPLATE_PARM));\n+\t  RETURN_IF_ERROR (substitution_add (dm, start, 0));\n \n \t  RETURN_IF_ERROR (demangle_template_args (dm));\n \t  *template_p = 1;\n@@ -1185,8 +1192,7 @@ demangle_prefix (dm, template_p)\n       if (peek != 'S'\n \t  && peek_char (dm) != 'E')\n \t/* Add a new substitution for the prefix thus far.  */\n-\tRETURN_IF_ERROR (substitution_add (dm, start, *template_p, \n-\t\t\t\t\t   NOT_TEMPLATE_PARM));\n+\tRETURN_IF_ERROR (substitution_add (dm, start, *template_p));\n     }\n }\n \n@@ -1353,6 +1359,29 @@ demangle_identifier (dm, length, identifier)\n \treturn STATUS_ALLOCATION_FAILED;\n     }\n \n+  /* GCC encodes anonymous namespaces using a `_GLOBAL_[_.$]N.'\n+     followed by the source file name and some random characters.\n+     Unless we're in strict mode, decipher these names appropriately.  */\n+  if (!flag_strict)\n+    {\n+      char *name = dyn_string_buf (identifier);\n+      int prefix_length = strlen (ANONYMOUS_NAMESPACE_PREFIX);\n+\n+      /* Compare the first, fixed part.  */\n+      if (strncmp (name, ANONYMOUS_NAMESPACE_PREFIX, prefix_length) == 0)\n+        {\n+\t  name += prefix_length;\n+\t  /* The next character might be a period, an underscore, or\n+\t     dollar sign, depending on the target architecture's\n+\t     assembler's capabilities.  After that comes an `N'.  */\n+\t  if ((*name == '.' || *name == '_' || *name == '$')\n+\t      && *(name + 1) == 'N')\n+\t    /* This looks like the anonymous namespace identifier.\n+\t       Replace it with something comprehensible.  */\n+\t    dyn_string_copy_cstr (identifier, \"(anonymous namespace)\");\n+\t}\n+    }\n+\n   return STATUS_OK;\n }\n \n@@ -1411,7 +1440,7 @@ demangle_identifier (dm, length, identifier)\n                   ::= qu        # ?\n                   ::= sz        # sizeof \n                   ::= cv <type> # cast        \n-                  ::= vx <source-name>  # vendor extended operator  */\n+\t\t  ::= v [0-9] <source-name>  # vendor extended operator  */\n \n static status_t\n demangle_operator_name (dm, short_name, num_args)\n@@ -1491,10 +1520,10 @@ demangle_operator_name (dm, short_name, num_args)\n \n   DEMANGLE_TRACE (\"operator-name\", dm);\n \n-  /* Is this a vendor extended operator?  */\n-  if (c0 == 'v' && c1 == 'x')\n+  /* Is this a vendor-extended operator?  */\n+  if (c0 == 'v' && IS_DIGIT (c1))\n     {\n-      RETURN_IF_ERROR (result_append (dm, \"operator\"));\n+      RETURN_IF_ERROR (result_append (dm, \"operator \"));\n       RETURN_IF_ERROR (demangle_source_name (dm));\n       *num_args = 0;\n       return STATUS_OK;\n@@ -1832,111 +1861,151 @@ demangle_ctor_dtor_name (dm)\n    a pointer to data or pointer to function to construct the right\n    output syntax.  C++'s pointer syntax is hairy.  \n \n+   This function adds substitution candidates for every nested\n+   pointer/reference type it processes, including the outermost, final\n+   type, assuming the substitution starts at SUBSTITUTION_START in the\n+   demangling result.  For example, if this function demangles\n+   `PP3Foo', it will add a substitution for `Foo', `Foo*', and\n+   `Foo**', in that order.\n+\n+   *INSERT_POS is a quantity used internally, when this function calls\n+   itself recursively, to figure out where to insert pointer\n+   punctuation on the way up.  On entry to this function, INSERT_POS\n+   should point to a temporary value, but that value need not be\n+   initialized.\n+\n      <type> ::= P <type>\n             ::= R <type>\n             ::= <pointer-to-member-type>\n \n      <pointer-to-member-type> ::= M </class/ type> </member/ type>  */\n \n static status_t\n-demangle_type_ptr (dm)\n+demangle_type_ptr (dm, insert_pos, substitution_start)\n      demangling_t dm;\n+     int *insert_pos;\n+     int substitution_start;\n {\n   char next;\n   status_t status;\n-\n-  /* Collect pointer symbols into this string.  */\n-  dyn_string_t symbols = dyn_string_new (10);\n+  int is_substitution_candidate = 1;\n \n   DEMANGLE_TRACE (\"type*\", dm);\n \n-  if (symbols == NULL)\n-    return STATUS_ALLOCATION_FAILED;\n-\n   /* Scan forward, collecting pointers and references into symbols,\n      until we hit something else.  Then emit the type.  */\n-  while (1)\n+  next = peek_char (dm);\n+  if (next == 'P')\n     {\n-      next = peek_char (dm);\n-      if (next == 'P')\n-\t{\n-\t  if (!dyn_string_append_char (symbols, '*'))\n-\t    return STATUS_ALLOCATION_FAILED;\n-\t  advance_char (dm);\n-\t}\n-      else if (next == 'R')\n-\t{\n-\t  if (!dyn_string_append_char (symbols, '&'))\n-\t    return STATUS_ALLOCATION_FAILED;\n-\t  advance_char (dm);\n-\t}\n-      else if (next == 'M')\n-\t{\n-\t  /* Pointer-to-member.  */\n-\t  dyn_string_t class_type;\n-\n-\t  /* Eat the 'M'.  */\n-\t  advance_char (dm);\n-\n-\t  /* Capture the type of which this is a pointer-to-member.  */\n-\t  RETURN_IF_ERROR (result_push (dm));\n-\t  RETURN_IF_ERROR (demangle_type (dm));\n-\t  class_type = (dyn_string_t) result_pop (dm);\n-\n-\t  /* Build the pointer-to-member notation.  It comes before\n-\t     other pointer and reference qualifiers -- */\n-\t  if (!dyn_string_prepend_cstr (symbols, \"::*\"))\n-\t    return STATUS_ALLOCATION_FAILED;\n-\t  if (!dyn_string_prepend (symbols, class_type))\n-\t    return STATUS_ALLOCATION_FAILED;\n-\t  dyn_string_delete (class_type);\n-\n-\t  if (peek_char (dm) == 'F')\n-\t    continue;\n-\n-\t  /* Demangle the type of the pointed-to member.  */\n+      /* A pointer.  Snarf the `P'.  */\n+      advance_char (dm);\n+      /* Demangle the underlying type.  */\n+      RETURN_IF_ERROR (demangle_type_ptr (dm, insert_pos, \n+\t\t\t\t\t  substitution_start));\n+      /* Insert an asterisk where we're told to; it doesn't\n+\t necessarily go at the end.  */\n+      RETURN_IF_ERROR (result_insert_char (dm, *insert_pos, '*'));\n+    }\n+  else if (next == 'R')\n+    {\n+      /* A reference.  Snarf the `R'.  */\n+      advance_char (dm);\n+      /* Demangle the underlying type.  */\n+      RETURN_IF_ERROR (demangle_type_ptr (dm, insert_pos, \n+\t\t\t\t\t  substitution_start));\n+      /* Insert an ampersand where we're told to; it doesn't\n+\t necessarily go at the end.  */\n+      RETURN_IF_ERROR (result_insert_char (dm, *insert_pos, '&'));\n+    }\n+  else if (next == 'M')\n+    {\n+      /* A pointer-to-member.  */\n+      dyn_string_t class_type;\n+      \n+      /* Eat the 'M'.  */\n+      advance_char (dm);\n+      \n+      /* Capture the type of which this is a pointer-to-member.  */\n+      RETURN_IF_ERROR (result_push (dm));\n+      RETURN_IF_ERROR (demangle_type (dm));\n+      class_type = (dyn_string_t) result_pop (dm);\n+      \n+      if (peek_char (dm) == 'F')\n+\t/* A pointer-to-member function.  We want output along the\n+\t   lines of `void (C::*) (int, int)'.  Demangle the function\n+\t   type, which would in this case give `void () (int, int)'\n+\t   and set *insert_pos to the spot between the first\n+\t   parentheses.  */\n+\tstatus = demangle_type_ptr (dm, insert_pos, substitution_start);\n+      else\n+        {\n+\t  /* A pointer-to-member variable.  Demangle the type of the\n+             pointed-to member.  */\n \t  status = demangle_type (dm);\n \t  /* Make it pretty.  */\n \t  if (STATUS_NO_ERROR (status))\n \t    status = result_append_space (dm);\n-\t  /* Add the pointer-to-member syntax, and other pointer and\n-\t     reference symbols.  */\n-\t  if (STATUS_NO_ERROR (status))\n-\t    status = result_append_string (dm, symbols);\n-\t  /* Clean up.  */\n-\t  dyn_string_delete (symbols);\n-\n-\t  RETURN_IF_ERROR (status);\n-\t  return STATUS_OK;\n+\t  /* The pointer-to-member notation (e.g. `C::*') follows the\n+             member's type.  */\n+\t  *insert_pos = result_length (dm);\n \t}\n-      else if (next == 'F')\n-\t{\n-\t  /* Ooh, tricky, a pointer-to-function.  */\n-\t  int position = result_length (dm);\n-\t  status = result_append_char (dm, '(');\n-\t  if (STATUS_NO_ERROR (status))\n-\t    status = result_append_string (dm, symbols);\n-\t  if (STATUS_NO_ERROR (status))\n-\t    status = result_append_char (dm, ')');\n-\t  dyn_string_delete (symbols);\n-\t  RETURN_IF_ERROR (status);\n \n-\t  RETURN_IF_ERROR (demangle_function_type (dm, position));\n-\t  return STATUS_OK;\n-\t}\n-      else\n-\t{\n-\t  /* No more pointer or reference tokens.  Finish up.  */\n-\t  status = demangle_type (dm);\n+      /* Build the pointer-to-member notation.  */\n+      if (STATUS_NO_ERROR (status))\n+\tstatus = result_insert (dm, *insert_pos, \"::*\");\n+      if (STATUS_NO_ERROR (status))\n+\tstatus = result_insert_string (dm, *insert_pos, class_type);\n+      /* There may be additional levels of (pointer or reference)\n+\t indirection in this type.  If so, the `*' and `&' should be\n+\t added after the pointer-to-member notation (e.g. `C::*&' for\n+\t a reference to a pointer-to-member of class C).  */\n+      *insert_pos += dyn_string_length (class_type) + 3;\n \n-\t  if (STATUS_NO_ERROR (status))\n-\t    status = result_append_string (dm, symbols);\n-\t  dyn_string_delete (symbols);\n+      /* Clean up. */\n+      dyn_string_delete (class_type);\n \n-\t  RETURN_IF_ERROR (status);\n-\t  return STATUS_OK;\n-\t}\n+      RETURN_IF_ERROR (status);\n+    }\n+  else if (next == 'F')\n+    {\n+      /* Ooh, tricky, a pointer-to-function.  When we demangle the\n+\t function type, the return type should go at the very\n+\t beginning.  */\n+      *insert_pos = result_length (dm);\n+      /* The parentheses indicate this is a function pointer or\n+\t reference type.  */\n+      RETURN_IF_ERROR (result_append (dm, \"()\"));\n+      /* Now demangle the function type.  The return type will be\n+\t inserted before the `()', and the argument list will go after\n+\t it.  */\n+      RETURN_IF_ERROR (demangle_function_type (dm, insert_pos));\n+      /* We should now have something along the lines of \n+\t `void () (int, int)'.  The pointer or reference characters\n+\t have to inside the first set of parentheses.  *insert_pos has\n+\t already been updated to point past the end of the return\n+\t type.  Move it one character over so it points inside the\n+\t `()'.  */\n+      ++(*insert_pos);\n+    }\n+  else\n+    {\n+      /* No more pointer or reference tokens; this is therefore a\n+\t pointer to data.  Finish up by demangling the underlying\n+\t type.  */\n+      RETURN_IF_ERROR (demangle_type (dm));\n+      /* The pointer or reference characters follow the underlying\n+\t type, as in `int*&'.  */\n+      *insert_pos = result_length (dm);\n+      /* Because of the production <type> ::= <substitution>,\n+\t demangle_type will already have added the underlying type as\n+\t a substitution candidate.  Don't do it again.  */\n+      is_substitution_candidate = 0;\n     }\n+  \n+  if (is_substitution_candidate)\n+    RETURN_IF_ERROR (substitution_add (dm, substitution_start, 0));\n+  \n+  return STATUS_OK;\n }\n \n /* Demangles and emits a <type>.  \n@@ -1965,7 +2034,7 @@ demangle_type (dm)\n   char peek_next;\n   int template_p = 0;\n   template_arg_list_t old_arg_list = current_template_arg_list (dm);\n-  int template_parm = NOT_TEMPLATE_PARM;\n+  int insert_pos;\n \n   /* A <type> can be a <substitution>; therefore, this <type> is a\n      substitution candidate unless a special condition holds (see\n@@ -2040,7 +2109,7 @@ demangle_type (dm)\n \t/* It's either a <template-param> or a\n \t   <template-template-param>.  In either case, demangle the\n \t   `T' token first.  */\n-\tRETURN_IF_ERROR (demangle_template_param (dm, &template_parm));\n+\tRETURN_IF_ERROR (demangle_template_param (dm));\n \n \t/* Check for a template argument list; if one is found, it's a\n \t     <template-template-param> ::= <template-param>\n@@ -2050,8 +2119,7 @@ demangle_type (dm)\n \t    /* Add a substitution candidate.  The template parameter\n \t       `T' token is a substitution candidate by itself,\n \t       without the template argument list.  */\n-\t    RETURN_IF_ERROR (substitution_add (dm, start, template_p, \n-\t\t\t\t\t       template_parm));\n+\t    RETURN_IF_ERROR (substitution_add (dm, start, template_p));\n \n \t    /* Now demangle the template argument list.  */\n \t    RETURN_IF_ERROR (demangle_template_args (dm));\n@@ -2077,23 +2145,27 @@ demangle_type (dm)\n \t       them.  */\n \t    if (peek_char (dm) == 'I')\n \t      RETURN_IF_ERROR (demangle_template_args (dm));\n-\n-\t    /* A substitution token is not itself a substitution\n-\t       candidate.  */\n-\t    is_substitution_candidate = 0;\n+\t    else\n+\t      /* A substitution token is not itself a substitution\n+\t\t candidate.  (However, if the substituted template is\n+\t\t instantiated, the resulting type is.)  */\n+\t      is_substitution_candidate = 0;\n \t  }\n \telse\n \t  /* While the special substitution token itself is not a\n \t     substitution candidate, the <class-enum-type> is, so\n \t     don't clear is_substitution_candidate.  */\n-\t  demangle_class_enum_type (dm, &template_p);\n+\t  RETURN_IF_ERROR (demangle_class_enum_type (dm, &template_p));\n \n \tbreak;\n \n       case 'P':\n       case 'R':\n       case 'M':\n-\tRETURN_IF_ERROR (demangle_type_ptr (dm));\n+\tRETURN_IF_ERROR (demangle_type_ptr (dm, &insert_pos, start));\n+\t/* demangle_type_ptr adds all applicable substitution\n+\t   candidates.  */\n+\tis_substitution_candidate = 0;\n \tbreak;\n \n       case 'C':\n@@ -2111,7 +2183,7 @@ demangle_type (dm)\n \tbreak;\n \n       case 'U':\n-\t/* Vendor extended type qualifier.  */\n+\t/* Vendor-extended type qualifier.  */\n \tadvance_char (dm);\n \tRETURN_IF_ERROR (demangle_source_name (dm));\n \tRETURN_IF_ERROR (result_append_char (dm, ' '));\n@@ -2127,7 +2199,7 @@ demangle_type (dm)\n        <template-param>, pass its index since from the point of\n        substitutions; a <template-param> token is a substitution\n        candidate distinct from the type that is substituted for it.  */\n-    RETURN_IF_ERROR (substitution_add (dm, start, template_p, template_parm));\n+    RETURN_IF_ERROR (substitution_add (dm, start, template_p));\n \n   /* Pop off template argument lists added during mangling of this\n      type.  */\n@@ -2266,16 +2338,18 @@ demangle_CV_qualifiers (dm, qualifiers)\n     }\n }\n \n-/* Demangles and emits a <function-type> FUNCTION_NAME_POS is the\n+/* Demangles and emits a <function-type>.  *FUNCTION_NAME_POS is the\n    position in the result string of the start of the function\n-   identifier, at which the function's return type will be inserted.  \n+   identifier, at which the function's return type will be inserted;\n+   *FUNCTION_NAME_POS is updated to position past the end of the\n+   function's return type.\n \n     <function-type> ::= F [Y] <bare-function-type> E  */\n \n static status_t\n demangle_function_type (dm, function_name_pos)\n      demangling_t dm;\n-     int function_name_pos;\n+     int *function_name_pos;\n {\n   DEMANGLE_TRACE (\"function-type\", dm);\n   RETURN_IF_ERROR (demangle_char (dm, 'F'));  \n@@ -2301,7 +2375,7 @@ demangle_function_type (dm, function_name_pos)\n static status_t\n demangle_bare_function_type (dm, return_type_pos)\n      demangling_t dm;\n-     int return_type_pos;\n+     int *return_type_pos;\n {\n   /* Sequence is the index of the current function parameter, counting\n      from zero.  The value -1 denotes the return type.  */\n@@ -2326,10 +2400,16 @@ demangle_bare_function_type (dm, return_type_pos)\n \n \t  /* Add a space to the end of the type.  Insert the return\n              type where we've been asked to. */\n-\t  if (!dyn_string_append_space (return_type) \n-\t      || !dyn_string_insert (result_string (dm), return_type_pos, \n-\t\t\t\t     return_type))\n+\t  if (!dyn_string_append_space (return_type))\n \t    status = STATUS_ALLOCATION_FAILED;\n+\t  if (STATUS_NO_ERROR (status))\n+\t    {\n+\t      if (!dyn_string_insert (result_string (dm), *return_type_pos, \n+\t\t\t\t      return_type))\n+\t\tstatus = STATUS_ALLOCATION_FAILED;\n+\t      else\n+\t\t*return_type_pos += dyn_string_length (return_type);\n+\t    }\n \n \t  dyn_string_delete (return_type);\n \t  RETURN_IF_ERROR (status);\n@@ -2436,16 +2516,14 @@ demangle_array_type (dm)\n   return STATUS_OK;\n }\n \n-/* Demangles and emits a <template-param>.  The zero-indexed position\n-   in the parameter list is placed in *TEMPLATE_PARM_NUMBER.  \n+/* Demangles and emits a <template-param>.  \n \n     <template-param> ::= T_       # first template parameter\n                      ::= T <parameter-2 number> _  */\n \n static status_t\n-demangle_template_param (dm, template_parm_number)\n+demangle_template_param (dm)\n      demangling_t dm;\n-     int *template_parm_number;\n {\n   int parm_number;\n   template_arg_list_t current_arg_list = current_template_arg_list (dm);\n@@ -2475,7 +2553,6 @@ demangle_template_param (dm, template_parm_number)\n     return \"Template parameter number out of bounds.\";\n   RETURN_IF_ERROR (result_append_string (dm, (dyn_string_t) arg));\n \n-  *template_parm_number = parm_number;\n   return STATUS_OK;\n }\n \n@@ -2784,12 +2861,11 @@ demangle_expr_primary (dm)\n      demangling_t dm;\n {\n   char peek = peek_char (dm);\n-  int unused;\n \n   DEMANGLE_TRACE (\"expr-primary\", dm);\n \n   if (peek == 'T')\n-    RETURN_IF_ERROR (demangle_template_param (dm, &unused));\n+    RETURN_IF_ERROR (demangle_template_param (dm));\n   else if (peek == 'L')\n     {\n       /* Consume the `L'.  */\n@@ -2826,7 +2902,7 @@ demangle_expr_primary (dm)\n                     ::= So   # ::std::basic_ostream<char,  \n                                                     std::char_traits<char> >\n                     ::= Sd   # ::std::basic_iostream<char, \n-                                                     std::char_traits<char> >\n+                                                    std::char_traits<char> >\n */\n \n static status_t\n@@ -3297,7 +3373,8 @@ static void print_usage\n \n /* Non-zero if CHAR is a character than can occur in a mangled name.  */\n #define is_mangled_char(CHAR)                                           \\\n-  (IS_ALPHA (CHAR) || IS_DIGIT (CHAR) || (CHAR) == '_')\n+  (IS_ALPHA (CHAR) || IS_DIGIT (CHAR)                                   \\\n+   || (CHAR) == '_' || (CHAR) == '.' || (CHAR) == '$')\n \n /* The name of this program, as invoked.  */\n const char* program_name;"}, {"sha": "e00f787e75c72f1acd61e4ab0bc5c6b842729c59", "filename": "libiberty/cplus-dem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/libiberty%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/libiberty%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcplus-dem.c?ref=31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "patch": "@@ -4853,7 +4853,7 @@ hp_symbol_characters ()\n static const char *\n gnu_new_abi_symbol_characters ()\n {\n-  return \"_\";\n+  return \"_$.\";\n }\n \n "}, {"sha": "34f88ade96d31d663bc69802e4c8f5bf4072a313", "filename": "libiberty/dyn-string.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/libiberty%2Fdyn-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c/libiberty%2Fdyn-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fdyn-string.c?ref=31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "patch": "@@ -305,6 +305,30 @@ dyn_string_insert_cstr (dest, pos, src)\n   return 1;\n }\n \n+/* Inserts character C into DEST starting at position POS.  DEST is\n+   expanded as necessary.  Returns 1 on success.  On failure,\n+   RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0.  */\n+\n+int\n+dyn_string_insert_char (dest, pos, c)\n+     dyn_string_t dest;\n+     int pos;\n+     int c;\n+{\n+  int i;\n+\n+  if (dyn_string_resize (dest, dest->length + 1) == NULL)\n+    return 0;\n+  /* Make room for the insertion.  Be sure to copy the NUL.  */\n+  for (i = dest->length; i >= pos; --i)\n+    dest->s[i + 1] = dest->s[i];\n+  /* Add the new character.  */\n+  dest->s[pos] = c;\n+  /* Compute the new length.  */\n+  ++dest->length;\n+  return 1;\n+}\n+     \n /* Append S to DS, resizing DS if necessary.  Returns 1 on success.\n    On failure, if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and\n    returns 0.  */"}]}