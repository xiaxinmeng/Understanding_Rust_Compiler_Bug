{"sha": "3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I0OGNjYmM4OWFlZjRlMjRmNWY0NmU0ZjkwY2M3OTNlZDQzZGYyOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-04-18T11:45:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-04-18T11:45:09Z"}, "message": "re PR tree-optimization/19431 (missed optimization with ifs and deferencing)\n\n2007-04-18  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/19431\n\tPR tree-optimization/21463\n\t* tree-pass.h (pass_phiprop): Declare.\n\t* passes.c (init_optimization_passes): New phiprop pass.\n\t* tree-ssa-forwprop.c (struct phiprop_d): New structure.\n\t(phivn_valid_p): New helper function.\n\t(phiprop_insert_phi): Likewise.\n\t(propagate_with_phi): Likewise.\n\t(tree_ssa_phiprop): New propagator propagating loads\n\tthrough phi nodes if profitable.\n\n\t* gcc.c-torture/execute/20070212-1.c: New testcase.\n\t* gcc.c-torture/execute/20070212-2.c: Likewise.\n\t* gcc.c-torture/execute/20070212-3.c: Likewise.\n\t* gcc.dg/tree-ssa/pr19431.c: Likewise.\n\t* gcc.dg/tree-ssa/pr21463.c: Likewise.\n\t* g++.dg/tree-ssa/pr21463.C: Likewise.\n\t* g++.dg/tree-ssa/pr30738.C: Likewise.\n\nFrom-SVN: r123946", "tree": {"sha": "23793781d436a1c62b25d540d256d241df35a7e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23793781d436a1c62b25d540d256d241df35a7e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "383862e8129603b9e8a65bb3d5c5b20e75026495", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/383862e8129603b9e8a65bb3d5c5b20e75026495", "html_url": "https://github.com/Rust-GCC/gccrs/commit/383862e8129603b9e8a65bb3d5c5b20e75026495"}], "stats": {"total": 487, "additions": 487, "deletions": 0}, "files": [{"sha": "fdde4316d49549c8da21f8831e28233a3f3ec7bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -1,3 +1,16 @@\n+2007-04-18  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/19431\n+\tPR tree-optimization/21463\n+\t* tree-pass.h (pass_phiprop): Declare.\n+\t* passes.c (init_optimization_passes): New phiprop pass.\n+\t* tree-ssa-forwprop.c (struct phiprop_d): New structure.\n+\t(phivn_valid_p): New helper function.\n+\t(phiprop_insert_phi): Likewise.\n+\t(propagate_with_phi): Likewise.\n+\t(tree_ssa_phiprop): New propagator propagating loads\n+\tthrough phi nodes if profitable.\n+\n 2007-04-18  Dorit Nuzman  <dorit@il.ibm.com>\n \n \t* tree-vect-analyze.c (process_use): New function."}, {"sha": "11b11981fdd868baba7b10ca47ded050da93fa98", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -524,6 +524,7 @@ init_optimization_passes (void)\n \n       /* Initial scalar cleanups.  */\n       NEXT_PASS (pass_ccp);\n+      NEXT_PASS (pass_phiprop);\n       NEXT_PASS (pass_fre);\n       NEXT_PASS (pass_dce);\n       NEXT_PASS (pass_forwprop);"}, {"sha": "bcea2252ec5911cf4def88db60d0616b120d59b0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -1,3 +1,15 @@\n+2007-04-18  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/19431\n+\tPR tree-optimization/21463\n+\t* gcc.c-torture/execute/20070212-1.c: New testcase.\n+\t* gcc.c-torture/execute/20070212-2.c: Likewise.\n+\t* gcc.c-torture/execute/20070212-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr19431.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr21463.c: Likewise.\n+\t* g++.dg/tree-ssa/pr21463.C: Likewise.\n+\t* g++.dg/tree-ssa/pr30738.C: Likewise.\n+\n 2007-04-17  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/31513"}, {"sha": "6d6ee93ba4423491c4cd7212b9e614882e0dc872", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr21463.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr21463.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr21463.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr21463.C?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt1\" } */\n+\n+template<class T> static inline const T &ref_max(const T &a, const T &b)\n+{ return a<b ? b : a; }\n+template<class T> static inline const T &ref_min(const T &a, const T &b)\n+{ return a<b ? a : b; }\n+\n+template<class T> struct foo_t {\n+\tT a0, a1;\n+\tT bar_ref(const T b, const T c) {\n+\t\treturn ref_max(ref_min(a0, c), ref_min(ref_max(a1, c), b));\n+\t}\n+};\n+\n+template struct foo_t<int>;\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 2 \"phiopt1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 2 \"phiopt1\" } } */\n+/* { dg-final { cleanup-tree-dump \"phiopt1\" } } */"}, {"sha": "b9d735e814dd545e206443b16389f7ff9dc94d9d", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr30738.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr30738.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr30738.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr30738.C?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt1\" } */\n+\n+template <class T>\n+static inline const T&\n+min_ref (const T &x, const T &y)\n+{\n+  return x < y ? x : y;\n+}\n+\n+int test_min_ref (int x, int y)\n+{\n+  return min_ref (x, y);\n+}\n+\n+/* { dg-final { scan-tree-dump \"MIN_EXPR\" \"phiopt1\" } } */\n+/* { dg-final { cleanup-tree-dump \"phiopt1\" } } */"}, {"sha": "efda7f9cf66867f256f5d0e34a683951f41aeb14", "filename": "gcc/testsuite/gcc.c-torture/execute/20070212-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070212-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070212-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070212-1.c?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -0,0 +1,26 @@\n+struct f\n+{\n+  int i;\n+};\n+\n+int g(int i, int c, struct f *ff, int *p)\n+{\n+  int *t;\n+  if (c)\n+   t = &i;\n+  else\n+   t = &ff->i;\n+  *p = 0;\n+  return *t;\n+}\n+\n+extern void abort(void);\n+\n+int main()\n+{\n+  struct f f;\n+  f.i = 1;\n+  if (g(5, 0, &f, &f.i) != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "a107d0efb93c822e26adcd66973185f5344a6ffa", "filename": "gcc/testsuite/gcc.c-torture/execute/20070212-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070212-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070212-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070212-2.c?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -0,0 +1,19 @@\n+int f(int k, int i1, int j1)\n+{\n+  int *f1;\n+  if(k)\n+   f1 = &i1;\n+  else\n+   f1 = &j1;\n+  i1 = 0;\n+  return *f1;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  if (f(1, 1, 2) != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "174be2bd90a197669cf570ee2fb3fd8bba6c5f29", "filename": "gcc/testsuite/gcc.c-torture/execute/20070212-3.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070212-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070212-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20070212-3.c?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -0,0 +1,30 @@\n+struct foo { int i; int j; };\n+\n+int bar (struct foo *k, int k2, int f, int f2)\n+{\n+  int *p, *q;\n+  int res;\n+  if (f)\n+    p = &k->i;\n+  else\n+    p = &k->j;\n+  res = *p;\n+  k->i = 1;\n+  if (f2)\n+    q = p;\n+  else\n+    q = &k2;\n+  return res + *q;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  struct foo k;\n+  k.i = 0;\n+  k.j = 1;\n+  if (bar (&k, 1, 1, 1) != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "4334648ce64f96c9d019579ccf7d8bb7a7af6554", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr19431.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+/* We want this optimized as\n+<bb 2>:\n+  if (k != 0) goto <L2>; else goto <L3>;\n+\n+<L3>:;\n+  i1 = j1;\n+\n+<L2>:;\n+  return i1;\n+\n+  This requires that i1 and j1 are changed into registers after they\n+  no longer have their address taken.  */\n+\n+int f(int k, int i1, int j1)\n+{\n+  int *f1;\n+  if(k)\n+   f1 = &i1;\n+  else\n+   f1 = &j1;\n+  return *f1;\n+}\n+\n+/* { dg-final { scan-tree-dump \"i1 = j1\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"return i1;\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "f490bf61e5aef8f746cf6293fea0e63a8acea92a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr21463.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21463.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21463.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr21463.c?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiprop\" } */\n+\n+struct f\n+{\n+  int i;\n+};\n+\n+int g(int i, int c, struct f *ff, int g)\n+{\n+  int *t;\n+  if (c)\n+    t = &i;\n+  else\n+    t = &ff->i;\n+  return *t;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"\\\\*t\" \"phiprop\" } } */\n+/* { dg-final { cleanup-tree-dump \"phiprop\" } } */"}, {"sha": "1b92f8c98072ea91c1d0e4d2980515cfc420c616", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -285,6 +285,7 @@ extern struct tree_opt_pass pass_warn_function_return;\n extern struct tree_opt_pass pass_warn_function_noreturn;\n extern struct tree_opt_pass pass_phiopt;\n extern struct tree_opt_pass pass_forwprop;\n+extern struct tree_opt_pass pass_phiprop;\n extern struct tree_opt_pass pass_dse;\n extern struct tree_opt_pass pass_nrv;\n extern struct tree_opt_pass pass_mark_used_blocks;"}, {"sha": "4e7f19f62c8dc70eddc98e3cd026a16a691b2b89", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b48ccbc89aef4e24f5f46e4f90cc793ed43df29/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=3b48ccbc89aef4e24f5f46e4f90cc793ed43df29", "patch": "@@ -1059,3 +1059,302 @@ struct tree_opt_pass pass_forwprop = {\n   | TODO_verify_ssa,\t\t/* todo_flags_finish */\n   0\t\t\t\t/* letter */\n };\n+\n+\n+/* Structure to keep track of the value of a dereferenced PHI result\n+   and the set of virtual operands used for that dereference.  */\n+\n+struct phiprop_d\n+{\n+  tree value;\n+  tree vop_stmt;\n+};\n+\n+/* Verify if the value recorded for NAME in PHIVN is still valid at\n+   the start of basic block BB.  */\n+\n+static bool\n+phivn_valid_p (struct phiprop_d *phivn, tree name, basic_block bb)\n+{\n+  tree vop_stmt = phivn[SSA_NAME_VERSION (name)].vop_stmt;\n+  ssa_op_iter ui;\n+  tree vuse;\n+\n+  /* The def stmts of all virtual uses need to be post-dominated\n+     by bb.  */\n+  FOR_EACH_SSA_TREE_OPERAND (vuse, vop_stmt, ui, SSA_OP_VUSE)\n+    {\n+      tree use_stmt;\n+      imm_use_iterator ui2;\n+      bool ok = true;\n+\n+      FOR_EACH_IMM_USE_STMT (use_stmt, ui2, vuse)\n+\t{\n+\t  /* If BB does not dominate a VDEF, the value is invalid.  */\n+\t  if (((TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+\t        && !ZERO_SSA_OPERANDS (use_stmt, SSA_OP_VDEF))\n+\t       || TREE_CODE (use_stmt) == PHI_NODE)\n+\t      && !dominated_by_p (CDI_DOMINATORS, bb_for_stmt (use_stmt), bb))\n+\t    {\n+\t      ok = false;\n+\t      BREAK_FROM_IMM_USE_STMT (ui2);\n+\t    }\n+\t}\n+      if (!ok)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Insert a new phi node for the dereference of PHI at basic_block\n+   BB with the virtual operands from USE_STMT.  */\n+\n+static tree\n+phiprop_insert_phi (basic_block bb, tree phi, tree use_stmt,\n+\t\t    struct phiprop_d *phivn, size_t n)\n+{\n+  tree res, new_phi;\n+  edge_iterator ei;\n+  edge e;\n+\n+  /* Build a new PHI node to replace the definition of\n+     the indirect reference lhs.  */\n+  res = GIMPLE_STMT_OPERAND (use_stmt, 0);\n+  SSA_NAME_DEF_STMT (res) = new_phi = create_phi_node (res, bb);\n+\n+  /* Add PHI arguments for each edge inserting loads of the\n+     addressable operands.  */\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      tree old_arg, new_var, tmp;\n+\n+      old_arg = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+      while (TREE_CODE (old_arg) == SSA_NAME\n+\t     && (SSA_NAME_VERSION (old_arg) >= n\n+\t         || phivn[SSA_NAME_VERSION (old_arg)].value == NULL_TREE))\n+\t{\n+\t  tree def_stmt = SSA_NAME_DEF_STMT (old_arg);\n+\t  old_arg = GIMPLE_STMT_OPERAND (def_stmt, 1);\n+\t}\n+\n+      if (TREE_CODE (old_arg) == SSA_NAME)\n+\t/* Reuse a formely created dereference.  */\n+\tnew_var = phivn[SSA_NAME_VERSION (old_arg)].value;\n+      else\n+\t{\n+\t  old_arg = TREE_OPERAND (old_arg, 0);\n+\t  new_var = create_tmp_var (TREE_TYPE (old_arg), NULL);\n+\t  tmp = build2 (GIMPLE_MODIFY_STMT, void_type_node,\n+\t\t\tNULL_TREE, unshare_expr (old_arg));\n+\t  if (TREE_CODE (TREE_TYPE (old_arg)) == COMPLEX_TYPE\n+\t      || TREE_CODE (TREE_TYPE (old_arg)) == VECTOR_TYPE)\n+\t    DECL_GIMPLE_REG_P (new_var) = 1;\n+\t  add_referenced_var (new_var);\n+\t  new_var = make_ssa_name (new_var, tmp);\n+\t  GIMPLE_STMT_OPERAND (tmp, 0) = new_var;\n+\n+\t  bsi_insert_on_edge (e, tmp);\n+\n+\t  update_stmt (tmp);\n+\t  mark_symbols_for_renaming (tmp);\n+\t}\n+\n+      add_phi_arg (new_phi, new_var, e);\n+    }\n+\n+  update_stmt (new_phi);\n+\n+  return res;\n+}\n+\n+/* Propagate between the phi node arguments of PHI in BB and phi result\n+   users.  For now this matches\n+        # p_2 = PHI <&x, &y>\n+      <Lx>:;\n+\tp_3 = p_2;\n+\tz_2 = *p_3;\n+   and converts it to\n+\t# z_2 = PHI <x, y>\n+      <Lx>:;\n+   Returns true if a transformation was done and edge insertions\n+   need to be committed.  Global data PHIVN and N is used to track\n+   past transformation results.  We need to be especially careful here\n+   with aliasing issues as we are moving memory reads.  */\n+\n+static bool\n+propagate_with_phi (basic_block bb, tree phi, struct phiprop_d *phivn, size_t n)\n+{\n+  tree ptr = PHI_RESULT (phi);\n+  tree use_stmt, res = NULL_TREE;\n+  block_stmt_iterator bsi;\n+  imm_use_iterator ui;\n+  use_operand_p arg_p, use;\n+  ssa_op_iter i;\n+  bool phi_inserted;\n+\n+  if (MTAG_P (SSA_NAME_VAR (ptr))\n+      || !POINTER_TYPE_P (TREE_TYPE (ptr))\n+      || !is_gimple_reg_type (TREE_TYPE (TREE_TYPE (ptr))))\n+    return false;\n+\n+  /* Check if we can \"cheaply\" dereference all phi arguments.  */\n+  FOR_EACH_PHI_ARG (arg_p, phi, i, SSA_OP_USE)\n+    {\n+      tree arg = USE_FROM_PTR (arg_p);\n+      /* Walk the ssa chain until we reach a ssa name we already\n+\t created a value for or we reach a definition of the form\n+\t ssa_name_n = &var;  */\n+      while (TREE_CODE (arg) == SSA_NAME\n+\t     && !SSA_NAME_IS_DEFAULT_DEF (arg)\n+\t     && (SSA_NAME_VERSION (arg) >= n\n+\t         || phivn[SSA_NAME_VERSION (arg)].value == NULL_TREE))\n+\t{\n+\t  tree def_stmt = SSA_NAME_DEF_STMT (arg);\n+\t  if (TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT)\n+\t    return false;\n+\t  arg = GIMPLE_STMT_OPERAND (def_stmt, 1);\n+\t}\n+      if ((TREE_CODE (arg) != ADDR_EXPR\n+\t   /* Avoid to have to decay *&a to a[0] later.  */\n+\t   || !is_gimple_reg_type (TREE_TYPE (TREE_OPERAND (arg, 0))))\n+\t  && !(TREE_CODE (arg) == SSA_NAME\n+\t       && phivn[SSA_NAME_VERSION (arg)].value != NULL_TREE\n+\t       && phivn_valid_p (phivn, arg, bb)))\n+\treturn false;\n+    }\n+\n+  /* Find a dereferencing use.  First follow (single use) ssa\n+     copy chains for ptr.  */\n+  while (single_imm_use (ptr, &use, &use_stmt)\n+\t && TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+\t && GIMPLE_STMT_OPERAND (use_stmt, 1) == ptr\n+\t && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 0)) == SSA_NAME)\n+    ptr = GIMPLE_STMT_OPERAND (use_stmt, 0);\n+\n+  /* Replace the first dereference of *ptr if there is one and if we\n+     can move the loads to the place of the ptr phi node.  */\n+  phi_inserted = false;\n+  FOR_EACH_IMM_USE_STMT (use_stmt, ui, ptr)\n+    {\n+      ssa_op_iter ui2;\n+      tree vuse;\n+\n+      /* Check whether this is a load of *ptr.  */\n+      if (!(TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+\t    && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 0)) == SSA_NAME \n+\t    && TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == INDIRECT_REF\n+\t    && TREE_OPERAND (GIMPLE_STMT_OPERAND (use_stmt, 1), 0) == ptr\n+\t    /* We cannot replace a load that may throw or is volatile.  */\n+\t    && !tree_can_throw_internal (use_stmt)))\n+\tcontinue;\n+\n+      /* Check if we can move the loads.  The def stmts of all virtual uses\n+\t need to be post-dominated by bb.  */\n+      FOR_EACH_SSA_TREE_OPERAND (vuse, use_stmt, ui2, SSA_OP_VUSE)\n+\t{\n+\t  tree def_stmt = SSA_NAME_DEF_STMT (vuse);\n+\t  if (!SSA_NAME_IS_DEFAULT_DEF (vuse)\n+\t      && (bb_for_stmt (def_stmt) == bb\n+\t\t  || !dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t      bb, bb_for_stmt (def_stmt))))\n+\t    goto next;\n+\t}\n+\n+      /* Found a proper dereference.  Insert a phi node if this\n+\t is the first load transformation.  */\n+      if (!phi_inserted)\n+\t{\n+\t  res = phiprop_insert_phi (bb, phi, use_stmt, phivn, n);\n+\n+\t  /* Remember the value we created for *ptr.  */\n+\t  phivn[SSA_NAME_VERSION (ptr)].value = res;\n+\t  phivn[SSA_NAME_VERSION (ptr)].vop_stmt = use_stmt;\n+\n+\t  /* Remove old stmt.  The phi is taken care of by DCE, if we\n+\t     want to delete it here we also have to delete all intermediate\n+\t     copies.  */\n+\t  bsi = bsi_for_stmt (use_stmt);\n+\t  bsi_remove (&bsi, 0);\n+\n+\t  phi_inserted = true;\n+\t}\n+      else\n+\t{\n+\t  /* Further replacements are easy, just make a copy out of the\n+\t     load.  */\n+\t  GIMPLE_STMT_OPERAND (use_stmt, 1) = res;\n+\t  update_stmt (use_stmt);\n+\t}\n+\n+next:;\n+      /* Continue searching for a proper dereference.  */\n+    }\n+\n+  return phi_inserted;\n+}\n+\n+/* Helper walking the dominator tree starting from BB and processing\n+   phi nodes with global data PHIVN and N.  */\n+\n+static bool\n+tree_ssa_phiprop_1 (basic_block bb, struct phiprop_d *phivn, size_t n)\n+{\n+  bool did_something = false; \n+  basic_block son;\n+  tree phi;\n+\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    did_something |= propagate_with_phi (bb, phi, phivn, n);\n+\n+  for (son = first_dom_son (CDI_DOMINATORS, bb);\n+       son;\n+       son = next_dom_son (CDI_DOMINATORS, son))\n+    did_something |= tree_ssa_phiprop_1 (son, phivn, n);\n+\n+  return did_something;\n+}\n+\n+/* Main entry for phiprop pass.  */\n+\n+static unsigned int\n+tree_ssa_phiprop (void)\n+{\n+  struct phiprop_d *phivn;\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  phivn = XCNEWVEC (struct phiprop_d, num_ssa_names);\n+\n+  if (tree_ssa_phiprop_1 (ENTRY_BLOCK_PTR, phivn, num_ssa_names))\n+    bsi_commit_edge_inserts ();\n+\n+  free (phivn);\n+\n+  return 0;\n+}\n+\n+static bool\n+gate_phiprop (void)\n+{\n+  return 1;\n+}\n+\n+struct tree_opt_pass pass_phiprop = {\n+  \"phiprop\",\t\t\t/* name */\n+  gate_phiprop,\t\t\t/* gate */\n+  tree_ssa_phiprop,\t\t/* execute */\n+  NULL,\t\t\t\t/* sub */\n+  NULL,\t\t\t\t/* next */\n+  0,\t\t\t\t/* static_pass_number */\n+  TV_TREE_FORWPROP,\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t/* properties_required */\n+  0,\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func\n+  | TODO_ggc_collect\n+  | TODO_update_ssa\n+  | TODO_verify_ssa,\t\t/* todo_flags_finish */\n+  0\t\t\t\t/* letter */\n+};"}]}