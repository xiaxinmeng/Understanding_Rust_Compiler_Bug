{"sha": "7cae975e66fef11bcb7d165cd399efae6e0b807b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NhZTk3NWU2NmZlZjExYmNiN2QxNjVjZDM5OWVmYWU2ZTBiODA3Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-04-29T17:24:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-04-29T17:24:37Z"}, "message": "emit-rtl.c (operand_subword): Religiously mask and sign-extend from 32-bits to HOST_WIDE_INT.\n\n        * emit-rtl.c (operand_subword): Religiously mask and sign-extend\n        from 32-bits to HOST_WIDE_INT.\n\nFrom-SVN: r26699", "tree": {"sha": "249cc9b85abd467b0262af2410f2a2ec1a9a2c12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/249cc9b85abd467b0262af2410f2a2ec1a9a2c12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cae975e66fef11bcb7d165cd399efae6e0b807b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cae975e66fef11bcb7d165cd399efae6e0b807b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cae975e66fef11bcb7d165cd399efae6e0b807b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cae975e66fef11bcb7d165cd399efae6e0b807b/comments", "author": null, "committer": null, "parents": [{"sha": "b56a20f600d16002e02c5e3b622b3a736c011cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b56a20f600d16002e02c5e3b622b3a736c011cbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b56a20f600d16002e02c5e3b622b3a736c011cbf"}], "stats": {"total": 70, "additions": 42, "deletions": 28}, "files": [{"sha": "5f6fdc662ac48444074e752e633dd35398828aba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cae975e66fef11bcb7d165cd399efae6e0b807b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cae975e66fef11bcb7d165cd399efae6e0b807b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cae975e66fef11bcb7d165cd399efae6e0b807b", "patch": "@@ -1,3 +1,7 @@\n+Thu Apr 29 17:23:59 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* emit-rtl.c (operand_subword): Religiously mask and sign-extend\n+\tfrom 32-bits to HOST_WIDE_INT.\n \n Thu Apr 29 15:58:52 1999  Robert Lipe  <robertlipe@usa.net>\n "}, {"sha": "b1e2d3dca01c6adfe120836c5545835cda16d7e1", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cae975e66fef11bcb7d165cd399efae6e0b807b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cae975e66fef11bcb7d165cd399efae6e0b807b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=7cae975e66fef11bcb7d165cd399efae6e0b807b", "patch": "@@ -1273,24 +1273,35 @@ operand_subword (op, i, validate_address, mode)\n \n       /* We handle 32-bit and >= 64-bit words here.  Note that the order in\n \t which the words are written depends on the word endianness.\n-\n \t ??? This is a potential portability problem and should\n-\t be fixed at some point.  */\n+\t be fixed at some point.\n+\n+\t We must excercise caution with the sign bit.  By definition there\n+\t are 32 significant bits in K; there may be more in a HOST_WIDE_INT.\n+\t Consider a host with a 32-bit long and a 64-bit HOST_WIDE_INT.\n+\t So we explicitly mask and sign-extend as necessary.  */\n       if (BITS_PER_WORD == 32)\n-\treturn GEN_INT ((HOST_WIDE_INT) k[i]);\n-#if HOST_BITS_PER_WIDE_INT > 32\n+\t{\n+\t  val = k[i];\n+\t  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+\t  return GEN_INT (val);\n+\t}\n+#if HOST_BITS_PER_WIDE_INT >= 64\n       else if (BITS_PER_WORD >= 64 && i == 0)\n-\treturn GEN_INT ((((HOST_WIDE_INT) k[! WORDS_BIG_ENDIAN]) << 32)\n-\t\t\t| (HOST_WIDE_INT) k[WORDS_BIG_ENDIAN]);\n+\t{\n+\t  val = k[! WORDS_BIG_ENDIAN];\n+\t  val = (((val & 0xffffffff) ^ 0x80000000) - 0x80000000) << 32;\n+\t  val |= (HOST_WIDE_INT) k[WORDS_BIG_ENDIAN] & 0xffffffff;\n+\t  return GEN_INT (val);\n+\t}\n #endif\n       else if (BITS_PER_WORD == 16)\n \t{\n-\t  long value;\n-\t  value = k[i >> 1];\n-\t  if ((i & 0x1) == !WORDS_BIG_ENDIAN)\n-\t    value >>= 16;\n-\t  value &= 0xffff;\n-\t  return GEN_INT ((HOST_WIDE_INT) value);\n+\t  val = k[i >> 1];\n+\t  if ((i & 1) == !WORDS_BIG_ENDIAN)\n+\t    val >>= 16;\n+\t  val &= 0xffff;\n+\t  return GEN_INT (val);\n \t}\n       else\n \tabort ();\n@@ -1307,7 +1318,13 @@ operand_subword (op, i, validate_address, mode)\n     REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n \n     if (BITS_PER_WORD == 32)\n-      return GEN_INT ((HOST_WIDE_INT) k[i]);\n+      {\n+\tval = k[i];\n+\tval = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+\treturn GEN_INT (val);\n+      }\n+    else\n+      abort ();\n   }\n #else /* no REAL_ARITHMETIC */\n   if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n@@ -1345,25 +1362,18 @@ operand_subword (op, i, validate_address, mode)\n       REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n       REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n \n-      /* If 32 bits is an entire word for the target, but not for the host,\n-\t then sign-extend on the host so that the number will look the same\n-\t way on the host that it would on the target.  See for instance\n-\t simplify_unary_operation.  The #if is needed to avoid compiler\n-\t warnings.  */\n-\n-#if HOST_BITS_PER_LONG > 32\n-      if (BITS_PER_WORD < HOST_BITS_PER_LONG && BITS_PER_WORD == 32\n-\t  && (l & ((long) 1 << 31)))\n-\tl |= ((long) (-1) << 32);\n-#endif\n+      /* Sign extend from known 32-bit value to HOST_WIDE_INT.  */\n+      val = l;\n+      val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n \n       if (BITS_PER_WORD == 16)\n \t{\n-\t  if ((i & 0x1) == !WORDS_BIG_ENDIAN)\n-\t    l >>= 16;\n-\t  l &= 0xffff;\n+\t  if ((i & 1) == !WORDS_BIG_ENDIAN)\n+\t    val >>= 16;\n+\t  val &= 0xffff;\n \t}\n-      return GEN_INT ((HOST_WIDE_INT) l);\n+\n+      return GEN_INT (val);\n     }\n #else\n   if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT"}]}