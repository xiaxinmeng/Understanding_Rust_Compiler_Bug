{"sha": "1833192f30abf95ec0124033882e6bcb64552e6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgzMzE5MmYzMGFiZjk1ZWMwMTI0MDMzODgyZTZiY2I2NDU1MmU2Zg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2009-10-14T16:24:11Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2009-10-14T16:24:11Z"}, "message": "params.def (PARAM_IRA_LOOP_RESERVED_REGS): New.\n\n2009-09-26  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* params.def (PARAM_IRA_LOOP_RESERVED_REGS): New.\n\t* params.h (IRA_LOOP_RESERVED_REGS): New\n\t* tree-pass.h (pass_subregs_of_mode_init,\n\tpass_subregs_of_mode_finish): Remove.\n\t* passes.c (pass_subregs_of_mode_init,\n\tpass_subregs_of_mode_finish): Remove.\n\t(pass_reginfo_init): Move before loop optimizations.\n\t* config/i386/i386.h (STACK_REG_COVER_CLASS): Define.\n\t* common.opt (fira-loop-pressure): New.\n\t* toplev.h (flag_ira_loop_pressure): New.\n\t* rtl.h (init_subregs_of_mode, finish_subregs_of_mode): New\n\texternals.\n\t* reginfo.c (init_subregs_of_mode, finish_subregs_of_mode):\n\tMake external and void type functions.\n\t(gate_subregs_of_mode_init, pass_subregs_of_mode_init,\n\tpass_subregs_of_mode_finish): Remove.\n\t* ira-costs.c (init_costs): Call init_subregs_of_mode.\n\t* regmove.c: Include ira.h.\n\t(regmove_optimize): Call ira_set_pseudo_classes after IRA based\n\tregister pressure calculation in loops.\n\t* loop-invariant.c: Include REGS_H and ira.h.\n\t(struct loop_data): New members max_reg_pressure, regs_ref, and\n\tregs_live.\n\t(struct invariant): New member orig_regno.\n\t(curr_loop): New variable.\n\t(find_exits): Initialize regs_ref and regs_live.\n\t(create_new_invariant): Initialize orig_regno.\n\t(get_cover_class_and_nregs): New.\n\t(get_inv_cost): Make aregs_needed an array.  Use regs_needed as an\n\tarray.  Add code for flag_ira_loop_pressure.\n\t(gain_for_invariant): Make new_regs an array.  Add code for\n\tflag_ira_loop_pressure.\n\t(best_gain_for_invariant): Ditto.\n\t(set_move_mark): New parameter gain.  Use it for debugging output.\n\t(find_invariants_to_move): Make regs_needed and new_regs an array.\n\tAdd code for flag_ira_loop_pressure.\n\t(move_invariant_reg): Set up orig_regno.\n\t(move_invariants): Set up reg classes for pseudos for\n\tflag_ira_loop_pressure.\n\t(free_loop_data): Clear regs_ref and regs_live.\n\t(curr_regs_live, curr_reg_pressure, regs_set, n_regs_set,\n\tget_regno_cover_class, change_pressure, mark_regno_live,\n\tmark_regno_death, mark_reg_store, mark_reg_clobber,\n\tmark_reg_death, mark_ref_regs, calculate_loop_reg_pressure): New.\n\t(move_loop_invariants): Calculate pressure.  Initialize curr_loop.\n\t* ira.c (ira): Call ira_set_pseudo_classes after IRA based\n\tregister pressure calculation in loops if new regs were added.\n\tCall finish_subregs_of_mode.\n\t* opts.c (decode_options): Set up flag_ira_loop_pressure.\n\t* Makefile.in (loop-invariant.o): Add ira.h.\n\t(regmove.o): Ditto.\n\t* doc/invoke.texi (-fira-loop-pressure, ira-loop-reserved-regs):\n\tDescribe.\n\t* doc/tm.texi (STACK_REG_COVER_CLASS): Describe.\n\nFrom-SVN: r152770", "tree": {"sha": "793540b6a00bb42653fb0e372d22502ee7bdf535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/793540b6a00bb42653fb0e372d22502ee7bdf535"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1833192f30abf95ec0124033882e6bcb64552e6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1833192f30abf95ec0124033882e6bcb64552e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1833192f30abf95ec0124033882e6bcb64552e6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1833192f30abf95ec0124033882e6bcb64552e6f/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/200c8750d65ebebc8a0d6f6f77a7f02b5a4a8ef3"}], "stats": {"total": 809, "additions": 695, "deletions": 114}, "files": [{"sha": "79906edfcc3df66207596459c94f72398749f240", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -1,3 +1,60 @@\n+2009-09-26  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* params.def (PARAM_IRA_LOOP_RESERVED_REGS): New.\n+\t* params.h (IRA_LOOP_RESERVED_REGS): New\n+\t* tree-pass.h (pass_subregs_of_mode_init,\n+\tpass_subregs_of_mode_finish): Remove.\n+\t* passes.c (pass_subregs_of_mode_init,\n+\tpass_subregs_of_mode_finish): Remove.\n+\t(pass_reginfo_init): Move before loop optimizations.\n+\t* config/i386/i386.h (STACK_REG_COVER_CLASS): Define.\n+\t* common.opt (fira-loop-pressure): New.\n+\t* toplev.h (flag_ira_loop_pressure): New.\n+\t* rtl.h (init_subregs_of_mode, finish_subregs_of_mode): New\n+\texternals.\n+\t* reginfo.c (init_subregs_of_mode, finish_subregs_of_mode):\n+\tMake external and void type functions.\n+\t(gate_subregs_of_mode_init, pass_subregs_of_mode_init,\n+\tpass_subregs_of_mode_finish): Remove.\n+\t* ira-costs.c (init_costs): Call init_subregs_of_mode.\n+\t* regmove.c: Include ira.h.\n+\t(regmove_optimize): Call ira_set_pseudo_classes after IRA based\n+\tregister pressure calculation in loops.\n+\t* loop-invariant.c: Include REGS_H and ira.h.\n+\t(struct loop_data): New members max_reg_pressure, regs_ref, and\n+\tregs_live.\n+\t(struct invariant): New member orig_regno.\n+\t(curr_loop): New variable.\n+\t(find_exits): Initialize regs_ref and regs_live.\n+\t(create_new_invariant): Initialize orig_regno.\n+\t(get_cover_class_and_nregs): New.\n+\t(get_inv_cost): Make aregs_needed an array.  Use regs_needed as an\n+\tarray.  Add code for flag_ira_loop_pressure.\n+\t(gain_for_invariant): Make new_regs an array.  Add code for\n+\tflag_ira_loop_pressure.\n+\t(best_gain_for_invariant): Ditto.\n+\t(set_move_mark): New parameter gain.  Use it for debugging output.\n+\t(find_invariants_to_move): Make regs_needed and new_regs an array.\n+\tAdd code for flag_ira_loop_pressure.\n+\t(move_invariant_reg): Set up orig_regno.\n+\t(move_invariants): Set up reg classes for pseudos for\n+\tflag_ira_loop_pressure.\n+\t(free_loop_data): Clear regs_ref and regs_live.\n+\t(curr_regs_live, curr_reg_pressure, regs_set, n_regs_set,\n+\tget_regno_cover_class, change_pressure, mark_regno_live,\n+\tmark_regno_death, mark_reg_store, mark_reg_clobber,\n+\tmark_reg_death, mark_ref_regs, calculate_loop_reg_pressure): New.\n+\t(move_loop_invariants): Calculate pressure.  Initialize curr_loop.\n+\t* ira.c (ira): Call ira_set_pseudo_classes after IRA based\n+\tregister pressure calculation in loops if new regs were added.\n+\tCall finish_subregs_of_mode.\n+\t* opts.c (decode_options): Set up flag_ira_loop_pressure.\n+\t* Makefile.in (loop-invariant.o): Add ira.h.\n+\t(regmove.o): Ditto.\n+\t* doc/invoke.texi (-fira-loop-pressure, ira-loop-reserved-regs):\n+\tDescribe.\n+\t* doc/tm.texi (STACK_REG_COVER_CLASS): Describe.\n+\t\n 2009-10-14  Richard Guenther  <rguenther@suse.de>\n \n \t* lto-symtab.c (lto_symtab_compatible): Fold in ..."}, {"sha": "3d24ac35ca30963afa727fccdab74dd7bde2d347", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -3076,9 +3076,9 @@ loop-iv.o : loop-iv.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(BASIC_BLOCK_H) \\\n    hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H) \\\n    output.h intl.h $(TOPLEV_H) $(DF_H) $(HASHTAB_H)\n loop-invariant.o : loop-invariant.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n-   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) $(RECOG_H) coretypes.h \\\n-   $(TM_H) $(TM_P_H) $(FUNCTION_H) $(FLAGS_H) $(DF_H) $(OBSTACK_H) output.h \\\n-   $(HASHTAB_H) $(EXCEPT_H) $(PARAMS_H)\n+   $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(EXPR_H) $(RECOG_H) \\\n+   coretypes.h $(TM_H) $(TM_P_H) $(FUNCTION_H) $(FLAGS_H) $(DF_H) \\\n+   $(OBSTACK_H) output.h $(HASHTAB_H) $(EXCEPT_H) $(PARAMS_H) $(REGS_H) ira.h\n cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) output.h \\\n    coretypes.h $(TM_H) cfghooks.h $(OBSTACK_H) $(TREE_FLOW_H)\n@@ -3192,7 +3192,7 @@ ira.o: ira.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H)\\\n    $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) $(FUNCTION_H) \\\n-   $(EXPR_H) $(BASIC_BLOCK_H) $(TOPLEV_H) $(TM_P_H) $(EXCEPT_H) reload.h\n+   $(EXPR_H) $(BASIC_BLOCK_H) $(TOPLEV_H) $(TM_P_H) $(EXCEPT_H) ira.h reload.h\n combine-stack-adj.o : combine-stack-adj.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) insn-config.h $(TIMEVAR_H) $(TREE_PASS_H) \\\n    $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) $(FUNCTION_H) \\"}, {"sha": "b57234a92abc1858533201049ed3749bf3a3898f", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -717,6 +717,11 @@ fira-coalesce\n Common Report Var(flag_ira_coalesce) Init(0)\n Do optimistic coalescing.\n \n+fira-loop-pressure\n+Common Report Var(flag_ira_loop_pressure)\n+Use IRA based register pressure calculation\n+in RTL loop optimizations.\n+\n fira-share-save-slots\n Common Report Var(flag_ira_share_save_slots) Init(1)\n Share slots for saving different hard registers."}, {"sha": "33a50771471bf32a815677293139680cd98ea742", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -873,6 +873,9 @@ enum target_cpu_default\n    || ((MODE) == DFmode && (!TARGET_SSE2 || !TARGET_SSE_MATH))  \\\n    || (MODE) == XFmode)\n \n+/* Cover class containing the stack registers.  */\n+#define STACK_REG_COVER_CLASS FLOAT_REGS\n+\n /* Number of actual hardware registers.\n    The hardware registers are assigned numbers for the compiler\n    from 0 to just below FIRST_PSEUDO_REGISTER."}, {"sha": "ddcde711c2037ba487c7147dd9575baf7fb48df8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -346,7 +346,8 @@ Objective-C and Objective-C++ Dialects}.\n -finline-small-functions -fipa-cp -fipa-cp-clone -fipa-matrix-reorg -fipa-pta @gol\n -fipa-pure-const -fipa-reference -fipa-struct-reorg @gol\n -fipa-type-escape -fira-algorithm=@var{algorithm} @gol\n--fira-region=@var{region} -fira-coalesce -fno-ira-share-save-slots @gol\n+-fira-region=@var{region} -fira-coalesce @gol\n+-fira-loop-pressure -fno-ira-share-save-slots @gol\n -fno-ira-share-spill-slots -fira-verbose=@var{n} @gol\n -fivopts -fkeep-inline-functions -fkeep-static-consts @gol\n -floop-block -floop-interchange -floop-strip-mine -fgraphite-identity @gol\n@@ -5719,7 +5720,8 @@ invoking @option{-O2} on programs that use computed gotos.\n Optimize yet more.  @option{-O3} turns on all optimizations specified\n by @option{-O2} and also turns on the @option{-finline-functions},\n @option{-funswitch-loops}, @option{-fpredictive-commoning},\n-@option{-fgcse-after-reload} and @option{-ftree-vectorize} options.\n+@option{-fgcse-after-reload}, @option{-ftree-vectorize} and\n+@option{-fira-loop-pressure} options.\n \n @item -O0\n @opindex O0\n@@ -6216,6 +6218,14 @@ give the best results in most cases and for most architectures.\n Do optimistic register coalescing.  This option might be profitable for\n architectures with big regular register files.\n \n+@item -fira-loop-pressure\n+@opindex fira-loop-pressure\n+Use IRA to evaluate register pressure in loops for decision to move\n+loop invariants.  Usage of this option usually results in generation\n+of faster and smaller code but can slow compiler down.\n+\n+This option is enabled at level @option{-O3}.\n+\n @item -fno-ira-share-save-slots\n @opindex fno-ira-share-save-slots\n Switch off sharing stack slots used for saving call used hard\n@@ -8387,6 +8397,14 @@ lower quality register allocation algorithm will be used.  The\n algorithm do not use pseudo-register conflicts.  The default value of\n the parameter is 2000.\n \n+@item ira-loop-reserved-regs\n+IRA can be used to evaluate more accurate register pressure in loops\n+for decision to move loop invariants (see @option{-O3}).  The number\n+of available registers reserved for some other purposes is described\n+by this parameter.  The default value of the parameter is 2 which is\n+minimal number of registers needed for execution of typical\n+instruction.  This value is the best found from numerous experiments.\n+\n @item loop-invariant-max-bbs-in-loop\n Loop invariant motion can be very expensive, both in compile time and\n in amount of needed compile time memory, with very large loops.  Loops"}, {"sha": "57e2b76fa50690194e349a44ff0bd4bf8fb30035", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -2349,6 +2349,11 @@ with it, as well as defining these macros.\n Define this if the machine has any stack-like registers.\n @end defmac\n \n+@defmac STACK_REG_COVER_CLASS\n+This is a cover class containing the stack registers.  Define this if\n+the machine has any stack-like registers.\n+@end defmac\n+\n @defmac FIRST_STACK_REG\n The number of the first stack-like register.  This one is the top\n of the stack."}, {"sha": "4b9d29f1db173392f865c776724641305f3a9701", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -1665,6 +1665,7 @@ ira_finish_costs_once (void)\n static void\n init_costs (void)\n {\n+  init_subregs_of_mode ();\n   costs = (struct costs *) ira_allocate (max_struct_costs_size\n \t\t\t\t\t * cost_elements_num);\n   pref_buffer"}, {"sha": "962d0994c36a28509c502a73ad9e9da7e7188ae4", "filename": "gcc/ira.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -3132,6 +3132,9 @@ ira (FILE *f)\n      epilogue thus changing register elimination offsets.  */\n   current_function_is_leaf = leaf_function_p ();\n \n+  if (resize_reg_info () && flag_ira_loop_pressure)\n+    ira_set_pseudo_classes (ira_dump_file);\n+\n   rebuild_p = update_equiv_regs ();\n \n #ifndef IRA_NO_OBSTACK\n@@ -3158,7 +3161,6 @@ ira (FILE *f)\n     }\n \n   max_regno_before_ira = allocated_reg_info_size = max_reg_num ();\n-  resize_reg_info ();\n   ira_setup_eliminable_regset ();\n       \n   ira_overall_cost = ira_reg_cost = ira_mem_cost = 0;\n@@ -3272,6 +3274,8 @@ ira (FILE *f)\n \n   reload_completed = !reload (get_insns (), ira_conflicts_p);\n \n+  finish_subregs_of_mode ();\n+\n   timevar_pop (TV_RELOAD);\n \n   timevar_push (TV_IRA);"}, {"sha": "7fb6cf05fd45d0b2f3d02454ffcc637cfa8a7e84", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 569, "deletions": 41, "changes": 610, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -39,9 +39,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"hard-reg-set.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n-#include \"hard-reg-set.h\"\n #include \"obstack.h\"\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n@@ -54,13 +54,21 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"except.h\"\n #include \"params.h\"\n+#include \"regs.h\"\n+#include \"ira.h\"\n \n /* The data stored for the loop.  */\n \n struct loop_data\n {\n   struct loop *outermost_exit;\t/* The outermost exit of the loop.  */\n   bool has_call;\t\t/* True if the loop contains a call.  */\n+  /* Maximal register pressure inside loop for given register class\n+     (defined only for the cover classes).  */\n+  int max_reg_pressure[N_REG_CLASSES];\n+  /* Loop regs referenced and live pseudo-registers.  */\n+  bitmap_head regs_ref;\n+  bitmap_head regs_live;\n };\n \n #define LOOP_DATA(LOOP) ((struct loop_data *) (LOOP)->aux)\n@@ -100,6 +108,10 @@ struct invariant\n      value.  */\n   rtx reg;\n \n+  /* If we moved the invariant out of the loop, the original regno\n+     that contained its value.  */\n+  int orig_regno;\n+\n   /* The definition of the invariant.  */\n   struct def *def;\n \n@@ -126,6 +138,9 @@ struct invariant\n   unsigned stamp;\n };\n \n+/* Currently processed loop.  */\n+static struct loop *curr_loop;\n+\n /* Table of invariants indexed by the df_ref uid field.  */\n \n static unsigned int invariant_table_size = 0;\n@@ -615,7 +630,12 @@ find_exits (struct loop *loop, basic_block *body,\n \t}\n     }\n \n-  loop->aux = xcalloc (1, sizeof (struct loop_data));\n+  if (loop->aux == NULL)\n+    {\n+      loop->aux = xcalloc (1, sizeof (struct loop_data));\n+      bitmap_initialize (&LOOP_DATA (loop)->regs_ref, &reg_obstack);\n+      bitmap_initialize (&LOOP_DATA (loop)->regs_live, &reg_obstack);\n+    }\n   LOOP_DATA (loop)->outermost_exit = outermost_exit;\n   LOOP_DATA (loop)->has_call = has_call;\n }\n@@ -696,6 +716,7 @@ create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n \n   inv->move = false;\n   inv->reg = NULL_RTX;\n+  inv->orig_regno = -1;\n   inv->stamp = 0;\n   inv->insn = insn;\n \n@@ -982,14 +1003,46 @@ free_use_list (struct use *use)\n     }\n }\n \n+/* Return cover class and number of hard registers (through *NREGS)\n+   for destination of INSN. */\n+static enum reg_class\n+get_cover_class_and_nregs (rtx insn, int *nregs)\n+{\n+  rtx reg;\n+  enum reg_class cover_class;\n+  rtx set = single_set (insn);\n+  \n+  /* Considered invariant insns have only one set.  */\n+  gcc_assert (set != NULL_RTX);\n+  reg = SET_DEST (set);\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+  if (MEM_P (reg))\n+    {\n+      *nregs = 0;\n+      cover_class = NO_REGS;\n+    }\n+  else\n+    {\n+      if (! REG_P (reg))\n+\treg = NULL_RTX;\n+      if (reg == NULL_RTX)\n+\tcover_class = GENERAL_REGS;\n+      else\n+\tcover_class = reg_cover_class (REGNO (reg));\n+      *nregs = ira_reg_class_nregs[cover_class][GET_MODE (SET_SRC (set))];\n+    }\n+  return cover_class;\n+}\n+\n /* Calculates cost and number of registers needed for moving invariant INV\n    out of the loop and stores them to *COST and *REGS_NEEDED.  */\n \n static void\n get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n {\n-  int acomp_cost;\n-  unsigned aregs_needed;\n+  int i, acomp_cost;\n+  unsigned aregs_needed[N_REG_CLASSES];\n   unsigned depno;\n   struct invariant *dep;\n   bitmap_iterator bi;\n@@ -998,13 +1051,30 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n   inv = VEC_index (invariant_p, invariants, inv->eqto);\n \n   *comp_cost = 0;\n-  *regs_needed = 0;\n+  if (! flag_ira_loop_pressure)\n+    regs_needed[0] = 0;\n+  else\n+    {\n+      for (i = 0; i < ira_reg_class_cover_size; i++)\n+\tregs_needed[ira_reg_class_cover[i]] = 0;\n+    }\n+\n   if (inv->move\n       || inv->stamp == actual_stamp)\n     return;\n   inv->stamp = actual_stamp;\n \n-  (*regs_needed)++;\n+  if (! flag_ira_loop_pressure)\n+    regs_needed[0]++;\n+  else\n+    {\n+      int nregs;\n+      enum reg_class cover_class;\n+\n+      cover_class = get_cover_class_and_nregs (inv->insn, &nregs);\n+      regs_needed[cover_class] += nregs;\n+    }\n+\n   if (!inv->cheap_address\n       || inv->def->n_addr_uses < inv->def->n_uses)\n     (*comp_cost) += inv->cost;\n@@ -1029,19 +1099,35 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n        on floating point constants is unlikely to ever occur.  */\n     rtx set = single_set (inv->insn);\n     if (set\n-       && IS_STACK_MODE (GET_MODE (SET_SRC (set)))\n-       && constant_pool_constant_p (SET_SRC (set)))\n-      (*regs_needed) += 2;\n+\t&& IS_STACK_MODE (GET_MODE (SET_SRC (set)))\n+\t&& constant_pool_constant_p (SET_SRC (set)))\n+      {\n+\tif (flag_ira_loop_pressure)\n+\t  regs_needed[STACK_REG_COVER_CLASS] += 2;\n+\telse\n+\t  regs_needed[0] += 2;\n+      }\n   }\n #endif\n \n   EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, depno, bi)\n     {\n+      bool check_p;\n+\n       dep = VEC_index (invariant_p, invariants, depno);\n \n-      get_inv_cost (dep, &acomp_cost, &aregs_needed);\n+      get_inv_cost (dep, &acomp_cost, aregs_needed);\n \n-      if (aregs_needed\n+      if (! flag_ira_loop_pressure)\n+\tcheck_p = aregs_needed[0] != 0;\n+      else\n+\t{\n+\t  for (i = 0; i < ira_reg_class_cover_size; i++)\n+\t    if (aregs_needed[ira_reg_class_cover[i]] != 0)\n+\t      break;\n+\t  check_p = i < ira_reg_class_cover_size;\n+\t}\n+      if (check_p\n \t  /* We need to check always_executed, since if the original value of\n \t     the invariant may be preserved, we may need to keep it in a\n \t     separate register.  TODO check whether the register has an\n@@ -1051,10 +1137,26 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \t{\n \t  /* If this is a single use, after moving the dependency we will not\n \t     need a new register.  */\n-\t  aregs_needed--;\n+\t  if (! flag_ira_loop_pressure)\n+\t    aregs_needed[0]--;\n+\t  else\n+\t    {\n+\t      int nregs;\n+\t      enum reg_class cover_class;\n+\n+\t      cover_class = get_cover_class_and_nregs (inv->insn, &nregs);\n+\t      aregs_needed[cover_class] -= nregs;\n+\t    }\n \t}\n \n-      (*regs_needed) += aregs_needed;\n+      if (! flag_ira_loop_pressure)\n+\tregs_needed[0] += aregs_needed[0];\n+      else\n+\t{\n+\t  for (i = 0; i < ira_reg_class_cover_size; i++)\n+\t    regs_needed[ira_reg_class_cover[i]]\n+\t      += aregs_needed[ira_reg_class_cover[i]];\n+\t}\n       (*comp_cost) += acomp_cost;\n     }\n }\n@@ -1066,15 +1168,62 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n \n static int\n gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n-\t\t    unsigned new_regs, unsigned regs_used, bool speed)\n+\t\t    unsigned *new_regs, unsigned regs_used, bool speed)\n {\n   int comp_cost, size_cost;\n \n-  get_inv_cost (inv, &comp_cost, regs_needed);\n   actual_stamp++;\n \n-  size_cost = (estimate_reg_pressure_cost (new_regs + *regs_needed, regs_used, speed)\n-\t       - estimate_reg_pressure_cost (new_regs, regs_used, speed));\n+  get_inv_cost (inv, &comp_cost, regs_needed);\n+\n+  if (! flag_ira_loop_pressure)\n+    {\n+      size_cost = (estimate_reg_pressure_cost (new_regs[0] + regs_needed[0],\n+\t\t\t\t\t       regs_used, speed)\n+\t\t   - estimate_reg_pressure_cost (new_regs[0],\n+\t\t\t\t\t\t regs_used, speed));\n+    }\n+  else\n+    {\n+      int i;\n+      enum reg_class cover_class;\n+\n+      for (i = 0; i < ira_reg_class_cover_size; i++)\n+\t{\n+\t  cover_class = ira_reg_class_cover[i];\n+\t  if ((int) new_regs[cover_class]\n+\t      + (int) regs_needed[cover_class]\n+\t      + LOOP_DATA (curr_loop)->max_reg_pressure[cover_class]\n+\t      + IRA_LOOP_RESERVED_REGS\n+\t      > ira_available_class_regs[cover_class])\n+\t    break;\n+\t}\n+      if (i < ira_reg_class_cover_size)\n+\t/* There will be register pressure excess and we want not to\n+\t   make this loop invariant motion.  All loop invariants with\n+\t   non-positive gains will be rejected in function\n+\t   find_invariants_to_move.  Therefore we return the negative\n+\t   number here.\n+\n+\t   One could think that this rejects also expensive loop\n+\t   invariant motions and this will hurt code performance.\n+\t   However numerous experiments with different heuristics\n+\t   taking invariant cost into account did not confirm this\n+\t   assumption.  There are possible explanations for this\n+\t   result:\n+           o probably all expensive invariants were already moved out\n+             of the loop by PRE and gimple invariant motion pass.\n+           o expensive invariant execution will be hidden by insn\n+             scheduling or OOO processor hardware because usually such\n+             invariants have a lot of freedom to be executed\n+             out-of-order.\n+\t   Another reason for ignoring invariant cost vs spilling cost\n+\t   heuristics is also in difficulties to evaluate accurately\n+\t   spill cost at this stage.  */\n+\treturn -1;\n+      else\n+\tsize_cost = 0;\n+    }\n \n   return comp_cost - size_cost;\n }\n@@ -1087,11 +1236,11 @@ gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n \n static int\n best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n-\t\t\t unsigned new_regs, unsigned regs_used, bool speed)\n+\t\t\t unsigned *new_regs, unsigned regs_used, bool speed)\n {\n   struct invariant *inv;\n-  int gain = 0, again;\n-  unsigned aregs_needed, invno;\n+  int i, gain = 0, again;\n+  unsigned aregs_needed[N_REG_CLASSES], invno;\n \n   for (invno = 0; VEC_iterate (invariant_p, invariants, invno, inv); invno++)\n     {\n@@ -1102,13 +1251,20 @@ best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n       if (inv->eqto != inv->invno)\n \tcontinue;\n \n-      again = gain_for_invariant (inv, &aregs_needed, new_regs, regs_used,\n+      again = gain_for_invariant (inv, aregs_needed, new_regs, regs_used,\n       \t\t\t\t  speed);\n       if (again > gain)\n \t{\n \t  gain = again;\n \t  *best = inv;\n-\t  *regs_needed = aregs_needed;\n+\t  if (! flag_ira_loop_pressure)\n+\t    regs_needed[0] = aregs_needed[0];\n+\t  else\n+\t    {\n+\t      for (i = 0; i < ira_reg_class_cover_size; i++)\n+\t\tregs_needed[ira_reg_class_cover[i]]\n+\t\t  = aregs_needed[ira_reg_class_cover[i]];\n+\t    }\n \t}\n     }\n \n@@ -1118,7 +1274,7 @@ best_gain_for_invariant (struct invariant **best, unsigned *regs_needed,\n /* Marks invariant INVNO and all its dependencies for moving.  */\n \n static void\n-set_move_mark (unsigned invno)\n+set_move_mark (unsigned invno, int gain)\n {\n   struct invariant *inv = VEC_index (invariant_p, invariants, invno);\n   bitmap_iterator bi;\n@@ -1131,11 +1287,18 @@ set_move_mark (unsigned invno)\n   inv->move = true;\n \n   if (dump_file)\n-    fprintf (dump_file, \"Decided to move invariant %d\\n\", invno);\n+    {\n+      if (gain >= 0)\n+\tfprintf (dump_file, \"Decided to move invariant %d -- gain %d\\n\",\n+\t\t invno, gain);\n+      else\n+\tfprintf (dump_file, \"Decided to move dependent invariant %d\\n\",\n+\t\t invno);\n+    };\n \n   EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, invno, bi)\n     {\n-      set_move_mark (invno);\n+      set_move_mark (invno, -1);\n     }\n }\n \n@@ -1144,32 +1307,54 @@ set_move_mark (unsigned invno)\n static void\n find_invariants_to_move (bool speed)\n {\n-  unsigned i, regs_used, regs_needed = 0, new_regs;\n+  int gain;\n+  unsigned i, regs_used, regs_needed[N_REG_CLASSES], new_regs[N_REG_CLASSES];\n   struct invariant *inv = NULL;\n-  unsigned int n_regs = DF_REG_SIZE (df);\n \n   if (!VEC_length (invariant_p, invariants))\n     return;\n \n-  /* We do not really do a good job in estimating number of registers used;\n-     we put some initial bound here to stand for induction variables etc.\n-     that we do not detect.  */\n-  regs_used = 2;\n-\n-  for (i = 0; i < n_regs; i++)\n+  if (flag_ira_loop_pressure)\n+    /* REGS_USED is actually never used when the flag is on.  */ \n+    regs_used = 0;\n+  else\n+    /* We do not really do a good job in estimating number of\n+       registers used; we put some initial bound here to stand for\n+       induction variables etc.  that we do not detect.  */\n     {\n-      if (!DF_REGNO_FIRST_DEF (i) && DF_REGNO_LAST_USE (i))\n+      unsigned int n_regs = DF_REG_SIZE (df);\n+\n+      regs_used = 2;\n+      \n+      for (i = 0; i < n_regs; i++)\n \t{\n-\t  /* This is a value that is used but not changed inside loop.  */\n-\t  regs_used++;\n+\t  if (!DF_REGNO_FIRST_DEF (i) && DF_REGNO_LAST_USE (i))\n+\t    {\n+\t      /* This is a value that is used but not changed inside loop.  */\n+\t      regs_used++;\n+\t    }\n \t}\n     }\n \n-  new_regs = 0;\n-  while (best_gain_for_invariant (&inv, &regs_needed, new_regs, regs_used, speed) > 0)\n+  if (! flag_ira_loop_pressure)\n+    new_regs[0] = regs_needed[0] = 0;\n+  else\n     {\n-      set_move_mark (inv->invno);\n-      new_regs += regs_needed;\n+      for (i = 0; (int) i < ira_reg_class_cover_size; i++)\n+\tnew_regs[ira_reg_class_cover[i]] = 0;\n+    }\n+  while ((gain = best_gain_for_invariant (&inv, regs_needed,\n+\t\t\t\t\t  new_regs, regs_used, speed)) > 0)\n+    {\n+      set_move_mark (inv->invno, gain);\n+      if (! flag_ira_loop_pressure)\n+\tnew_regs[0] += regs_needed[0];\n+      else\n+\t{\n+\t  for (i = 0; (int) i < ira_reg_class_cover_size; i++)\n+\t    new_regs[ira_reg_class_cover[i]]\n+\t      += regs_needed[ira_reg_class_cover[i]];\n+\t}\n     }\n }\n \n@@ -1186,11 +1371,13 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n   rtx reg, set, dest, note;\n   struct use *use;\n   bitmap_iterator bi;\n+  int regno;\n \n   if (inv->reg)\n     return true;\n   if (!repr->move)\n     return false;\n+  regno = -1;\n   /* If this is a representative of the class of equivalent invariants,\n      really move the invariant.  Otherwise just replace its use with\n      the register used for the representative.  */\n@@ -1211,7 +1398,12 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n \t would not be dominated by it, we may just move it (TODO).  Otherwise we\n \t need to create a temporary register.  */\n       set = single_set (inv->insn);\n-      dest = SET_DEST (set);\n+      reg = dest = SET_DEST (set);\n+      if (GET_CODE (reg) == SUBREG)\n+\treg = SUBREG_REG (reg);\n+      if (REG_P (reg))\n+\tregno = REGNO (reg);\n+\n       reg = gen_reg_rtx_and_attrs (dest);\n \n       /* Try replacing the destination by a new pseudoregister.  */\n@@ -1237,13 +1429,15 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n       if (!move_invariant_reg (loop, repr->invno))\n \tgoto fail;\n       reg = repr->reg;\n+      regno = repr->orig_regno;\n       set = single_set (inv->insn);\n       emit_insn_after (gen_move_insn (SET_DEST (set), reg), inv->insn);\n       delete_insn (inv->insn);\n     }\n \n \n   inv->reg = reg;\n+  inv->orig_regno = regno;\n \n   /* Replace the uses we know to be dominated.  It saves work for copy\n      propagation, and also it is necessary so that dependent invariants\n@@ -1266,6 +1460,7 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n     fprintf (dump_file, \"Failed to move invariant %d\\n\", invno);\n   inv->move = false;\n   inv->reg = NULL_RTX;\n+  inv->orig_regno = -1;\n \n   return false;\n }\n@@ -1281,6 +1476,21 @@ move_invariants (struct loop *loop)\n \n   for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n     move_invariant_reg (loop, i);\n+  if (flag_ira_loop_pressure && resize_reg_info ())\n+    {\n+      for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n+\tif (inv->reg != NULL_RTX)\n+\t  {\n+\t    if (inv->orig_regno >= 0)\n+\t      setup_reg_classes (REGNO (inv->reg),\n+\t\t\t\t reg_preferred_class (inv->orig_regno),\n+\t\t\t\t reg_alternate_class (inv->orig_regno),\n+\t\t\t\t reg_cover_class (inv->orig_regno));\n+\t    else\n+\t      setup_reg_classes (REGNO (inv->reg),\n+\t\t\t\t GENERAL_REGS, NO_REGS, GENERAL_REGS);\n+\t  }\n+    }\n }\n \n /* Initializes invariant motion data.  */\n@@ -1346,10 +1556,317 @@ free_loop_data (struct loop *loop)\n {\n   struct loop_data *data = LOOP_DATA (loop);\n \n+  bitmap_clear (&LOOP_DATA (loop)->regs_ref);\n+  bitmap_clear (&LOOP_DATA (loop)->regs_live);\n   free (data);\n   loop->aux = NULL;\n }\n \n+\f\n+\n+/* Registers currently living.  */\n+static bitmap_head curr_regs_live;\n+\n+/* Current reg pressure for each cover class.  */\n+static int curr_reg_pressure[N_REG_CLASSES];\n+\n+/* Record all regs that are set in any one insn.  Communication from\n+   mark_reg_{store,clobber} and global_conflicts.  Asm can refer to\n+   all hard-registers.  */\n+static rtx regs_set[(FIRST_PSEUDO_REGISTER > MAX_RECOG_OPERANDS\n+\t\t     ? FIRST_PSEUDO_REGISTER : MAX_RECOG_OPERANDS) * 2];\n+/* Number of regs stored in the previous array.  */\n+static int n_regs_set;\n+\n+/* Return cover class and number of needed hard registers (through\n+   *NREGS) of register REGNO.  */ \n+static enum reg_class\n+get_regno_cover_class (int regno, int *nregs)\n+{\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      enum reg_class cover_class = reg_cover_class (regno);\n+\n+      *nregs = ira_reg_class_nregs[cover_class][PSEUDO_REGNO_MODE (regno)];\n+      return cover_class;\n+    }\n+  else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno)\n+\t   && ! TEST_HARD_REG_BIT (eliminable_regset, regno))\n+    {\n+      *nregs = 1;\n+      return ira_class_translate[REGNO_REG_CLASS (regno)];\n+    }\n+  else\n+    {\n+      *nregs = 0;\n+      return NO_REGS;\n+    }\n+}\n+\n+/* Increase (if INCR_P) or decrease current register pressure for\n+   register REGNO.  */\n+static void\n+change_pressure (int regno, bool incr_p)\n+{\n+  int nregs;\n+  enum reg_class cover_class;\n+\n+  cover_class = get_regno_cover_class (regno, &nregs);\n+  if (! incr_p)\n+    curr_reg_pressure[cover_class] -= nregs;\n+  else\n+    {\n+      curr_reg_pressure[cover_class] += nregs;\n+      if (LOOP_DATA (curr_loop)->max_reg_pressure[cover_class]\n+\t  < curr_reg_pressure[cover_class])\n+\tLOOP_DATA (curr_loop)->max_reg_pressure[cover_class]\n+\t  = curr_reg_pressure[cover_class];\n+    }\n+}\n+\n+/* Mark REGNO birth.  */\n+static void\n+mark_regno_live (int regno)\n+{\n+  struct loop *loop;\n+\n+  for (loop = curr_loop;\n+       loop != current_loops->tree_root;\n+       loop = loop_outer (loop))\n+    bitmap_set_bit (&LOOP_DATA (loop)->regs_live, regno);\n+  if (bitmap_bit_p (&curr_regs_live, regno))\n+    return;\n+  bitmap_set_bit (&curr_regs_live, regno);\n+  change_pressure (regno, true);\n+}\n+\n+/* Mark REGNO death.  */\n+static void\n+mark_regno_death (int regno)\n+{\n+  if (! bitmap_bit_p (&curr_regs_live, regno))\n+    return;\n+  bitmap_clear_bit (&curr_regs_live, regno);\n+  change_pressure (regno, false);\n+}\n+\n+/* Mark setting register REG.  */\n+static void\n+mark_reg_store (rtx reg, const_rtx setter ATTRIBUTE_UNUSED,\n+\t\tvoid *data ATTRIBUTE_UNUSED)\n+{\n+  int regno;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  if (! REG_P (reg))\n+    return;\n+\n+  regs_set[n_regs_set++] = reg;\n+\n+  regno = REGNO (reg);\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    mark_regno_live (regno);\n+  else\n+    {\n+      int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n+\n+      while (regno < last)\n+\t{\n+\t  mark_regno_live (regno);\n+\t  regno++;\n+\t}\n+    }\n+}\n+\n+/* Mark clobbering register REG.  */\n+static void\n+mark_reg_clobber (rtx reg, const_rtx setter, void *data)\n+{\n+  if (GET_CODE (setter) == CLOBBER)\n+    mark_reg_store (reg, setter, data);\n+}\n+\n+/* Mark register REG death.  */\n+static void\n+mark_reg_death (rtx reg)\n+{\n+  int regno = REGNO (reg);\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    mark_regno_death (regno);\n+  else\n+    {\n+      int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n+\n+      while (regno < last)\n+\t{\n+\t  mark_regno_death (regno);\n+\t  regno++;\n+\t}\n+    }\n+}\n+\n+/* Mark occurrence of registers in X for the current loop.  */\n+static void\n+mark_ref_regs (rtx x)\n+{\n+  RTX_CODE code;\n+  int i;\n+  const char *fmt;\n+\n+  if (!x)\n+    return;\n+\n+  code = GET_CODE (x);\n+  if (code == REG)\n+    {\n+      struct loop *loop;\n+      \n+      for (loop = curr_loop;\n+\t   loop != current_loops->tree_root;\n+\t   loop = loop_outer (loop))\n+\tbitmap_set_bit (&LOOP_DATA (loop)->regs_ref, REGNO (x));\n+      return;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      mark_ref_regs (XEXP (x, i));\n+    else if (fmt[i] == 'E')\n+      {\n+\tint j;\n+\t\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  mark_ref_regs (XVECEXP (x, i, j));\n+      }\n+}\n+\n+/* Calculate register pressure in the loops.  */\n+static void\n+calculate_loop_reg_pressure (void)\n+{\n+  int i;\n+  unsigned int j;\n+  bitmap_iterator bi;\n+  basic_block bb;\n+  rtx insn, link;\n+  struct loop *loop, *parent;\n+  loop_iterator li;\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    if (loop->aux == NULL)\n+      {\n+\tloop->aux = xcalloc (1, sizeof (struct loop_data));\n+\tbitmap_initialize (&LOOP_DATA (loop)->regs_ref, &reg_obstack);\n+\tbitmap_initialize (&LOOP_DATA (loop)->regs_live, &reg_obstack);\n+      }\n+  ira_setup_eliminable_regset ();\n+  bitmap_initialize (&curr_regs_live, &reg_obstack);\n+  FOR_EACH_BB (bb)\n+    {\n+      curr_loop = bb->loop_father;\n+      if (curr_loop == current_loops->tree_root)\n+\tcontinue;\n+\n+      for (loop = curr_loop;\n+\t   loop != current_loops->tree_root;\n+\t   loop = loop_outer (loop))\n+\tbitmap_ior_into (&LOOP_DATA (loop)->regs_live, DF_LR_IN (bb));\n+\n+      bitmap_copy (&curr_regs_live, DF_LR_IN (bb));\n+      for (i = 0; i < ira_reg_class_cover_size; i++)\n+\tcurr_reg_pressure[ira_reg_class_cover[i]] = 0;\n+      EXECUTE_IF_SET_IN_BITMAP (&curr_regs_live, 0, j, bi)\n+\tchange_pressure (j, true);\n+\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  if (! INSN_P (insn))\n+\t    continue;\n+\n+\t  mark_ref_regs (PATTERN (insn));\n+\t  n_regs_set = 0;\n+\t  note_stores (PATTERN (insn), mark_reg_clobber, NULL);\n+\t  \n+\t  /* Mark any registers dead after INSN as dead now.  */\n+\t  \n+\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t    if (REG_NOTE_KIND (link) == REG_DEAD)\n+\t      mark_reg_death (XEXP (link, 0));\n+\t  \n+\t  /* Mark any registers set in INSN as live,\n+\t     and mark them as conflicting with all other live regs.\n+\t     Clobbers are processed again, so they conflict with\n+\t     the registers that are set.  */\n+\t  \n+\t  note_stores (PATTERN (insn), mark_reg_store, NULL);\n+\t  \n+#ifdef AUTO_INC_DEC\n+\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t    if (REG_NOTE_KIND (link) == REG_INC)\n+\t      mark_reg_store (XEXP (link, 0), NULL_RTX, NULL);\n+#endif\n+\t  while (n_regs_set-- > 0)\n+\t    {\n+\t      rtx note = find_regno_note (insn, REG_UNUSED,\n+\t\t\t\t\t  REGNO (regs_set[n_regs_set]));\n+\t      if (! note)\n+\t\tcontinue;\n+\t      \n+\t      mark_reg_death (XEXP (note, 0));\n+\t    }\n+\t}\n+    }\n+  bitmap_clear (&curr_regs_live);\n+  if (flag_ira_region == IRA_REGION_MIXED\n+      || flag_ira_region == IRA_REGION_ALL)\n+    FOR_EACH_LOOP (li, loop, 0)\n+      {\n+\tEXECUTE_IF_SET_IN_BITMAP (&LOOP_DATA (loop)->regs_live, 0, j, bi)\n+\t  if (! bitmap_bit_p (&LOOP_DATA (loop)->regs_ref, j))\n+\t    {\n+\t      enum reg_class cover_class;\n+\t      int nregs;\n+\n+\t      cover_class = get_regno_cover_class (j, &nregs);\n+\t      LOOP_DATA (loop)->max_reg_pressure[cover_class] -= nregs;\n+\t    }\n+      }\n+  if (dump_file == NULL)\n+    return;\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      parent = loop_outer (loop);\n+      fprintf (dump_file, \"\\n  Loop %d (parent %d, header bb%d, depth %d)\\n\",\n+\t       loop->num, (parent == NULL ? -1 : parent->num),\n+\t       loop->header->index, loop_depth (loop));\n+      fprintf (dump_file, \"\\n    ref. regnos:\");\n+      EXECUTE_IF_SET_IN_BITMAP (&LOOP_DATA (loop)->regs_ref, 0, j, bi)\n+\tfprintf (dump_file, \" %d\", j);\n+      fprintf (dump_file, \"\\n    live regnos:\");\n+      EXECUTE_IF_SET_IN_BITMAP (&LOOP_DATA (loop)->regs_live, 0, j, bi)\n+\tfprintf (dump_file, \" %d\", j);\n+      fprintf (dump_file, \"\\n    Pressure:\");\n+      for (i = 0; (int) i < ira_reg_class_cover_size; i++)\n+\t{\n+\t  enum reg_class cover_class;\n+\t  \n+\t  cover_class = ira_reg_class_cover[i];\n+\t  if (LOOP_DATA (loop)->max_reg_pressure[cover_class] == 0)\n+\t    continue;\n+\t  fprintf (dump_file, \" %s=%d\", reg_class_names[cover_class],\n+\t\t   LOOP_DATA (loop)->max_reg_pressure[cover_class]);\n+\t}\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+\f\n+\n /* Move the invariants out of the loops.  */\n \n void\n@@ -1358,10 +1875,17 @@ move_loop_invariants (void)\n   struct loop *loop;\n   loop_iterator li;\n \n+  if (flag_ira_loop_pressure)\n+    {\n+      df_analyze ();\n+      ira_set_pseudo_classes (dump_file);\n+      calculate_loop_reg_pressure ();\n+    }\n   df_set_flags (DF_EQ_NOTES + DF_DEFER_INSN_RESCAN);\n   /* Process the loops, innermost first.  */\n   FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n+      curr_loop = loop;\n       /* move_single_loop_invariants for very large loops\n \t is time consuming and might need a lot of memory.  */\n       if (loop->num_nodes <= (unsigned) LOOP_INVARIANT_MAX_BBS_IN_LOOP)\n@@ -1373,6 +1897,10 @@ move_loop_invariants (void)\n       free_loop_data (loop);\n     }\n \n+  if (flag_ira_loop_pressure)\n+    /* There is no sense to keep this info because it was most\n+       probably outdated by subsequent passes.  */\n+    free_reg_info ();\n   free (invariant_table);\n   invariant_table = NULL;\n   invariant_table_size = 0;"}, {"sha": "c69a399768fa0dcd0021781b5e358a38d0d1ca00", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -917,6 +917,7 @@ decode_options (unsigned int argc, const char **argv)\n   flag_ipa_cp_clone = opt3;\n   if (flag_ipa_cp_clone)\n     flag_ipa_cp = 1;\n+  flag_ira_loop_pressure = opt3;\n \n   /* Just -O1/-O0 optimizations.  */\n   opt1_max = (optimize <= 1);"}, {"sha": "21cfbdc7fec1da541f88a794421f292a2cbe1d21", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -719,6 +719,11 @@ DEFPARAM (PARAM_IRA_MAX_CONFLICT_TABLE_SIZE,\n \t  \"max size of conflict table in MB\",\n \t  1000, 0, 0)\n \n+DEFPARAM (PARAM_IRA_LOOP_RESERVED_REGS,\n+\t  \"ira-loop-reserved-regs\",\n+\t  \"The number of registers in each class kept unused by loop invariant motion\",\n+\t  2, 0, 0)\n+\n /* Switch initialization conversion will refuse to create arrays that are\n    bigger than this parameter times the number of switch branches.  */\n "}, {"sha": "56db145e1f6c2b95521f682955798456896980e4", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -160,6 +160,8 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_IRA_MAX_LOOPS_NUM)\n #define IRA_MAX_CONFLICT_TABLE_SIZE \\\n   PARAM_VALUE (PARAM_IRA_MAX_CONFLICT_TABLE_SIZE)\n+#define IRA_LOOP_RESERVED_REGS \\\n+  PARAM_VALUE (PARAM_IRA_LOOP_RESERVED_REGS)\n #define SWITCH_CONVERSION_BRANCH_RATIO \\\n   PARAM_VALUE (PARAM_SWITCH_CONVERSION_BRANCH_RATIO)\n #define LOOP_INVARIANT_MAX_BBS_IN_LOOP \\"}, {"sha": "2d11c1f69878b56d2d0cdf69d655892b989ebe00", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -943,6 +943,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_rtl_store_motion);\n       NEXT_PASS (pass_cse_after_global_opts);\n       NEXT_PASS (pass_rtl_ifcvt);\n+      NEXT_PASS (pass_reginfo_init);\n       /* Perform loop optimizations.  It might be better to do them a bit\n \t sooner, but we want the profile feedback to work more\n \t efficiently.  */\n@@ -962,7 +963,6 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_cse2);\n       NEXT_PASS (pass_rtl_dse1);\n       NEXT_PASS (pass_rtl_fwprop_addr);\n-      NEXT_PASS (pass_reginfo_init);\n       NEXT_PASS (pass_inc_dec);\n       NEXT_PASS (pass_initialize_regs);\n       NEXT_PASS (pass_ud_rtl_dce);\n@@ -978,10 +978,8 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_mode_switching);\n       NEXT_PASS (pass_match_asm_constraints);\n       NEXT_PASS (pass_sms);\n-      NEXT_PASS (pass_subregs_of_mode_init);\n       NEXT_PASS (pass_sched);\n       NEXT_PASS (pass_ira);\n-      NEXT_PASS (pass_subregs_of_mode_finish);\n       NEXT_PASS (pass_postreload);\n \t{\n \t  struct opt_pass **p = &pass_postreload.pass.sub;"}, {"sha": "96e9bd9437a978d8151bfd9a10eac87937ce6b6a", "filename": "gcc/reginfo.c", "status": "modified", "additions": 8, "deletions": 61, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -904,6 +904,9 @@ struct reg_pref\n    run.  */\n static struct reg_pref *reg_pref;\n \n+/* Current size of reg_info.  */\n+static int reg_info_size;\n+\n /* Return the reg_class in which pseudo reg number REGNO is best allocated.\n    This function is sometimes called before the info has been computed.\n    When that happens, just return GENERAL_REGS, which is innocuous.  */\n@@ -937,9 +940,6 @@ reg_cover_class (int regno)\n \n \f\n \n-/* Current size of reg_info.  */\n-static int reg_info_size;\n-\n /* Allocate space for reg info.  */\n static void\n allocate_reg_info (void)\n@@ -1040,6 +1040,7 @@ setup_reg_classes (int regno,\n {\n   if (reg_pref == NULL)\n     return;\n+  gcc_assert (reg_info_size == max_reg_num ());\n   reg_pref[regno].prefclass = prefclass;\n   reg_pref[regno].altclass = altclass;\n   reg_pref[regno].coverclass = coverclass;\n@@ -1321,7 +1322,7 @@ find_subregs_of_mode (rtx x)\n     }\n }\n \n-static unsigned int\n+void\n init_subregs_of_mode (void)\n {\n   basic_block bb;\n@@ -1336,8 +1337,6 @@ init_subregs_of_mode (void)\n     FOR_BB_INSNS (bb, insn)\n     if (INSN_P (insn))\n       find_subregs_of_mode (PATTERN (insn));\n-\n-  return 0;\n }\n \n /* Return 1 if REGNO has had an invalid mode change in CLASS from FROM\n@@ -1367,74 +1366,22 @@ invalid_mode_change_p (unsigned int regno,\n   return false;\n }\n \n-static unsigned int\n+void\n finish_subregs_of_mode (void)\n {\n   htab_delete (subregs_of_mode);\n   subregs_of_mode = 0;\n-  return 0;\n }\n #else\n-static unsigned int\n+void\n init_subregs_of_mode (void)\n {\n-  return 0;\n }\n-static unsigned int\n+void\n finish_subregs_of_mode (void)\n {\n-  return 0;\n }\n \n #endif /* CANNOT_CHANGE_MODE_CLASS */\n \n-static bool\n-gate_subregs_of_mode_init (void)\n-{\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-  return true;\n-#else\n-  return false;\n-#endif\n-}\n-\n-struct rtl_opt_pass pass_subregs_of_mode_init =\n-{\n- {\n-  RTL_PASS,\n-  \"subregs_of_mode_init\",               /* name */\n-  gate_subregs_of_mode_init,            /* gate */\n-  init_subregs_of_mode,                 /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n-};\n-\n-struct rtl_opt_pass pass_subregs_of_mode_finish =\n-{\n- {\n-  RTL_PASS,\n-  \"subregs_of_mode_finish\",               /* name */\n-  gate_subregs_of_mode_init,            /* gate */\n-  finish_subregs_of_mode,               /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n-};\n-\n-\n #include \"gt-reginfo.h\""}, {"sha": "4d45d5d1beb99bdf4342ae7d62758ee6db5d21aa", "filename": "gcc/regmove.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n #include \"df.h\"\n+#include \"ira.h\"\n \n static int optimize_reg_copy_1 (rtx, rtx, rtx);\n static void optimize_reg_copy_2 (rtx, rtx, rtx);\n@@ -1226,6 +1227,9 @@ regmove_optimize (void)\n   df_note_add_problem ();\n   df_analyze ();\n \n+  if (flag_ira_loop_pressure)\n+    ira_set_pseudo_classes (dump_file);\n+\n   regstat_init_n_sets_and_refs ();\n   regstat_compute_ri ();\n \n@@ -1248,6 +1252,8 @@ regmove_optimize (void)\n     }\n   regstat_free_n_sets_and_refs ();\n   regstat_free_ri ();\n+  if (flag_ira_loop_pressure)\n+    free_reg_info ();\n   return 0;\n }\n "}, {"sha": "68cd4665c5fe4631788a854e5003e3b7fce8c257", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -1930,6 +1930,8 @@ extern void init_move_cost (enum machine_mode);\n extern bool resize_reg_info (void);\n /* Free up register info memory.  */\n extern void free_reg_info (void);\n+extern void init_subregs_of_mode (void);\n+extern void finish_subregs_of_mode (void);\n \n /* recog.c */\n extern rtx extract_asm_operands (rtx);"}, {"sha": "88ab7e8ecf0edbc245330ff856020e1cd948e242", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -142,6 +142,7 @@ extern int flag_unroll_all_loops;\n extern int flag_unswitch_loops;\n extern int flag_cprop_registers;\n extern int time_report;\n+extern int flag_ira_loop_pressure;\n extern int flag_ira_coalesce;\n extern int flag_ira_move_spills;\n extern int flag_ira_share_save_slots;"}, {"sha": "8b8b3c4816f07f778e8e06c1eab1d9b2d0ebee72", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1833192f30abf95ec0124033882e6bcb64552e6f/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=1833192f30abf95ec0124033882e6bcb64552e6f", "patch": "@@ -497,8 +497,6 @@ extern struct rtl_opt_pass pass_cse2;\n extern struct rtl_opt_pass pass_df_initialize_opt;\n extern struct rtl_opt_pass pass_df_initialize_no_opt;\n extern struct rtl_opt_pass pass_reginfo_init;\n-extern struct rtl_opt_pass pass_subregs_of_mode_init;\n-extern struct rtl_opt_pass pass_subregs_of_mode_finish;\n extern struct rtl_opt_pass pass_inc_dec;\n extern struct rtl_opt_pass pass_stack_ptr_mod;\n extern struct rtl_opt_pass pass_initialize_regs;"}]}