{"sha": "db1c2a89db09c8fe140ed3e65a707a08737e3b41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIxYzJhODlkYjA5YzhmZTE0MGVkM2U2NWE3MDdhMDg3MzdlM2I0MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-08-14T16:55:33Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-08-14T17:54:53Z"}, "message": "c++: Yet more name-lookup api simplification\n\nThis patch deals with LOOKUP_HIDDEN, which originally meant 'find\nhidden friends', but it's being pressed into service for not ignoring\nlambda-relevant internals.  However these two functions are different.\n(a) hidden friends can occur in block scope (very uncommon) and (b) it\nhad the semantics of stopping after the innermost enclosing\nnamepspace.  That's really suspect for the lambda case, but not\nrelevant there because we never get to namespace scope (I think).\nAnyway, I've split the flag into two and adjusted the lambda callers\nto just search block scope.  These two flags are added to the\nLOOK_want enum class, which allows dropping another parameter from the\nname lookup routines.\n\nThe remaining LOOKUP_$FOO flags in cp-tree.h are, I think, now all\nrelated to features of overload resolution, conversion operators and\nreference binding.  Nothing to do with /name/ lookup.\n\n\tgcc/cp/\n\t* cp-tree.h (LOOKUP_HIDDEN): Delete.\n\t(LOOKUP_PREFER_RVALUE): Adjust initializer.\n\t* name-lookup.h (enum class LOOK_want): Add HIDDEN_FRIEND and\n\tHIDDEN_LAMBDA flags.\n\t(lookup_name_real): Drop flags parm.\n\t(lookup_qualified_name): Drop find_hidden parm.\n\t* name-lookup.c (class name_lookup): Drop hidden field, adjust\n\tctors.\n\t(name_lookup::add_overload): Check want for hiddenness.\n\t(name_lookup::process_binding): Likewise.\n\t(name_lookup::search_unqualified): Likewise.\n\t(identifier_type_value_1): Adjust lookup_name_real call.\n\t(set_decl_namespace): Adjust name_lookup ctor.\n\t(qualify_lookup): Drop flags parm, use want for hiddenness.\n\t(lookup_qualified_name): Drop find_hidden parm.\n\t(lookup_name_real_1): Drop flags parm, adjust qualify_lookup\n\tcalls.\n\t(lookup_name_real): Drop flags parm.\n\t(lookup_name_nonclass, lookup_name): Adjust lookup_name_real\n\tcalls.\n\t(lookup_type_scope_1): Adjust qualify_lookup calls.\n\t* call.c (build_operator_new_call): Adjust lookup_name_real call.\n\t(add_operator_candidates): Likewise.\n\t* coroutines.cc (morph_fn_to_coro): Adjust lookup_qualified_name\n\tcall.\n\t* parser.c (cp_parser_lookup_name): Adjust lookup_name_real calls.\n\t* pt.c (check_explicit_specialization): Adjust\n\tlookup_qualified_name call.\n\t(deduction_guides_for): Likewise.\n\t(tsubst_friend_class): Adjust lookup_name_real call.\n\t(lookup_init_capture_pack): Likewise.\n\t(tsubst_expr): Likewise, don't look in namespaces.\n\t* semantics.c (capture_decltype): Adjust lookup_name_real.  Don't\n\tlook in namespaces.\n\tlibcc1/\n\t* libcp1plugin.cc (plugin_build_dependent_exp): Adjust\n\tlookup_name_real call.", "tree": {"sha": "e439889780d093caf396a363abc171c2ec293bc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e439889780d093caf396a363abc171c2ec293bc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db1c2a89db09c8fe140ed3e65a707a08737e3b41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db1c2a89db09c8fe140ed3e65a707a08737e3b41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db1c2a89db09c8fe140ed3e65a707a08737e3b41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db1c2a89db09c8fe140ed3e65a707a08737e3b41/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "320054784250e572cb75d6f69ab44b2330d61d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/320054784250e572cb75d6f69ab44b2330d61d8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/320054784250e572cb75d6f69ab44b2330d61d8b"}], "stats": {"total": 115, "additions": 54, "deletions": 61}, "files": [{"sha": "8c03fcaf74b3c6b81984bc71b1919fa3b924da5e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=db1c2a89db09c8fe140ed3e65a707a08737e3b41", "patch": "@@ -4704,7 +4704,7 @@ build_operator_new_call (tree fnname, vec<tree, va_gc> **args,\n        up in the global scope.\n \n      we disregard block-scope declarations of \"operator new\".  */\n-  fns = lookup_name_real (fnname, LOOK_where::NAMESPACE, LOOK_want::NORMAL, 0);\n+  fns = lookup_name_real (fnname, LOOK_where::NAMESPACE, LOOK_want::NORMAL);\n   fns = lookup_arg_dependent (fnname, fns, *args);\n \n   if (align_arg)\n@@ -5983,7 +5983,7 @@ add_operator_candidates (z_candidate **candidates,\n   if (!memonly)\n     {\n       tree fns = lookup_name_real (fnname, LOOK_where::BLOCK_NAMESPACE,\n-\t\t\t\t   LOOK_want::NORMAL, 0);\n+\t\t\t\t   LOOK_want::NORMAL);\n       fns = lookup_arg_dependent (fnname, fns, arglist);\n       add_candidates (fns, NULL_TREE, arglist, NULL_TREE,\n \t\t      NULL_TREE, false, NULL_TREE, NULL_TREE,"}, {"sha": "898b88b70756402217c6e66b12beb7b05d41f7c7", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=db1c2a89db09c8fe140ed3e65a707a08737e3b41", "patch": "@@ -4311,7 +4311,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \t  tree std_nt = lookup_qualified_name (std_node,\n \t\t\t\t\t       get_identifier (\"nothrow\"),\n \t\t\t\t\t       LOOK_want::NORMAL,\n-\t\t\t\t\t       /*complain=*/true, false);\n+\t\t\t\t\t       /*complain=*/true);\n \t  if (!std_nt || std_nt == error_mark_node)\n \t    error_at (fn_start, \"%qE is provided by %qT but %<std::nothrow%> \"\n \t\t      \"cannot be found\", grooaf, promise_type);"}, {"sha": "047585740191a9ab62d54f300918b69e480c6978", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=db1c2a89db09c8fe140ed3e65a707a08737e3b41", "patch": "@@ -5567,14 +5567,10 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define LOOKUP_DESTRUCTOR (1 << 5)\n /* Do not permit references to bind to temporaries.  */\n #define LOOKUP_NO_TEMP_BIND (1 << 6)\n-/* Return friend declarations and un-declared builtin functions.\n-   (Normally, these entities are registered in the symbol table, but\n-   not found by lookup.)  */\n-#define LOOKUP_HIDDEN (1 << 7)\n /* We're trying to treat an lvalue as an rvalue.  */\n /* FIXME remove when we extend the P1825 semantics to all standard modes, the\n    C++20 approach uses IMPLICIT_RVALUE_P instead.  */\n-#define LOOKUP_PREFER_RVALUE (LOOKUP_HIDDEN << 1)\n+#define LOOKUP_PREFER_RVALUE (LOOKUP_NO_TEMP_BIND << 1)\n /* We're inside an init-list, so narrowing conversions are ill-formed.  */\n #define LOOKUP_NO_NARROWING (LOOKUP_PREFER_RVALUE << 1)\n /* We're looking up a constructor for list-initialization.  */"}, {"sha": "4753dc529e62d28c59604af7429a7285febc232b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=db1c2a89db09c8fe140ed3e65a707a08737e3b41", "patch": "@@ -165,7 +165,6 @@ class name_lookup\n   tree value;\t/* A (possibly ambiguous) set of things found.  */\n   tree type;\t/* A type that has been found.  */\n   LOOK_want want;  /* What kind of entity we want.  */\n-  bool hidden;\t/* Allow hidden  */\n \n   bool deduping; /* Full deduping is needed because using declarations\n \t\t    are in play.  */\n@@ -179,9 +178,9 @@ class name_lookup\n   static name_lookup *active;\n \n public:\n-  name_lookup (tree n, LOOK_want w = LOOK_want::NORMAL, bool h = false)\n+  name_lookup (tree n, LOOK_want w = LOOK_want::NORMAL)\n   : name (n), value (NULL_TREE), type (NULL_TREE),\n-    want (w), hidden (h),\n+    want (w),\n     deduping (false), scopes (NULL), previous (NULL)\n   {\n     preserve_state ();\n@@ -420,7 +419,7 @@ name_lookup::add_overload (tree fns)\n   if (!deduping && TREE_CODE (fns) == OVERLOAD)\n     {\n       tree probe = fns;\n-      if (!hidden)\n+      if (!bool (want & LOOK_want::HIDDEN_FRIEND))\n \tprobe = ovl_skip_hidden (probe);\n       if (probe && TREE_CODE (probe) == OVERLOAD\n \t  && OVL_DEDUP_P (probe))\n@@ -489,12 +488,12 @@ name_lookup::process_binding (tree new_val, tree new_type)\n   /* Did we really see a type? */\n   if (new_type\n       && ((want & LOOK_want::TYPE_NAMESPACE) == LOOK_want::NAMESPACE\n-\t  || (!hidden\n+\t  || (!bool (want & LOOK_want::HIDDEN_FRIEND)\n \t      && DECL_LANG_SPECIFIC (new_type)\n \t      && DECL_ANTICIPATED (new_type))))\n     new_type = NULL_TREE;\n \n-  if (new_val && !hidden)\n+  if (new_val && !bool (want & LOOK_want::HIDDEN_FRIEND))\n     new_val = ovl_skip_hidden (new_val);\n \n   /* Do we really see a value? */\n@@ -718,13 +717,13 @@ name_lookup::search_unqualified (tree scope, cp_binding_level *level)\n       if (scope == global_namespace)\n \tbreak;\n \n-      /* If looking for hidden names, we only look in the innermost\n+      /* If looking for hidden friends, we only look in the innermost\n \t namespace scope.  [namespace.memdef]/3 If a friend\n \t declaration in a non-local class first declares a class,\n \t function, class template or function template the friend is a\n \t member of the innermost enclosing namespace.  See also\n \t [basic.lookup.unqual]/7 */\n-      if (hidden)\n+      if (bool (want & LOOK_want::HIDDEN_FRIEND))\n \tbreak;\n     }\n \n@@ -3744,7 +3743,7 @@ identifier_type_value_1 (tree id)\n     return REAL_IDENTIFIER_TYPE_VALUE (id);\n   /* Have to search for it. It must be on the global level, now.\n      Ask lookup_name not to return non-types.  */\n-  id = lookup_name_real (id, LOOK_where::BLOCK_NAMESPACE, LOOK_want::TYPE, 0);\n+  id = lookup_name_real (id, LOOK_where::BLOCK_NAMESPACE, LOOK_want::TYPE);\n   if (id)\n     return TREE_TYPE (id);\n   return NULL_TREE;\n@@ -4818,7 +4817,8 @@ set_decl_namespace (tree decl, tree scope, bool friendp)\n      children.  */\n   tree old = NULL_TREE;\n   {\n-    name_lookup lookup (DECL_NAME (decl), LOOK_want::NORMAL, true);\n+    name_lookup lookup (DECL_NAME (decl),\n+\t\t\tLOOK_want::NORMAL | LOOK_want::HIDDEN_FRIEND);\n     if (!lookup.search_qualified (scope, /*usings=*/false))\n       /* No old declaration at all.  */\n       goto not_found;\n@@ -5217,7 +5217,7 @@ cp_namespace_decls (tree ns)\n    lookup_type_scope.  */\n \n static bool\n-qualify_lookup (tree val, LOOK_want want, int flags)\n+qualify_lookup (tree val, LOOK_want want)\n {\n   if (val == NULL_TREE)\n     return false;\n@@ -5238,7 +5238,7 @@ qualify_lookup (tree val, LOOK_want want, int flags)\n     return false;\n \n   /* Look through lambda things that we shouldn't be able to see.  */\n-  if (!(flags & LOOKUP_HIDDEN) && is_lambda_ignored_entity (val))\n+  if (!bool (want & LOOK_want::HIDDEN_LAMBDA) && is_lambda_ignored_entity (val))\n     return false;\n \n   return true;\n@@ -5995,14 +5995,13 @@ suggest_alternative_in_scoped_enum (tree name, tree scoped_enum)\n    neither a class-type nor a namespace a diagnostic is issued.  */\n \n tree\n-lookup_qualified_name (tree scope, tree name, LOOK_want want, bool complain,\n-\t\t       bool find_hidden /*=false*/)\n+lookup_qualified_name (tree scope, tree name, LOOK_want want, bool complain)\n {\n   tree t = NULL_TREE;\n \n   if (TREE_CODE (scope) == NAMESPACE_DECL)\n     {\n-      name_lookup lookup (name, want, find_hidden);\n+      name_lookup lookup (name, want);\n \n       if (qualified_namespace_lookup (scope, &lookup))\n \tt = lookup.value;\n@@ -6021,9 +6020,9 @@ lookup_qualified_name (tree scope, tree name, LOOK_want want, bool complain,\n /* Wrapper for the above that takes a string argument.  The function name is\n    not at the beginning of the line to keep this wrapper out of etags.  */\n \n-tree lookup_qualified_name (tree t, const char *p, LOOK_want w, bool c, bool fh)\n+tree lookup_qualified_name (tree t, const char *p, LOOK_want w, bool c)\n {\n-  return lookup_qualified_name (t, get_identifier (p), w, c, fh);\n+  return lookup_qualified_name (t, get_identifier (p), w, c);\n }\n \n /* [namespace.qual]\n@@ -6424,7 +6423,7 @@ innermost_non_namespace_value (tree name)\n    namespace or type.  */\n \n static tree\n-lookup_name_real_1 (tree name, LOOK_where where, LOOK_want want, int flags)\n+lookup_name_real_1 (tree name, LOOK_where where, LOOK_want want)\n {\n   tree val = NULL_TREE;\n \n@@ -6480,10 +6479,10 @@ lookup_name_real_1 (tree name, LOOK_where where, LOOK_want want, int flags)\n \t  continue;\n \n \t/* If this is the kind of thing we're looking for, we're done.  */\n-\tif (qualify_lookup (iter->value, want, flags))\n+\tif (qualify_lookup (iter->value, want))\n \t  binding = iter->value;\n \telse if (bool (want & LOOK_want::TYPE)\n-\t\t && qualify_lookup (iter->type, want, flags))\n+\t\t && qualify_lookup (iter->type, want))\n \t  binding = iter->type;\n \telse\n \t  binding = NULL_TREE;\n@@ -6548,7 +6547,7 @@ lookup_name_real_1 (tree name, LOOK_where where, LOOK_want want, int flags)\n   /* Now lookup in namespace scopes.  */\n   if (!val && bool (where & LOOK_where::NAMESPACE))\n     {\n-      name_lookup lookup (name, want, flags & LOOKUP_HIDDEN);\n+      name_lookup lookup (name, want);\n       if (lookup.search_unqualified\n \t  (current_decl_namespace (), current_binding_level))\n \tval = lookup.value;\n@@ -6564,32 +6563,30 @@ lookup_name_real_1 (tree name, LOOK_where where, LOOK_want want, int flags)\n /* Wrapper for lookup_name_real_1.  */\n \n tree\n-lookup_name_real (tree name, LOOK_where where, LOOK_want want, int flags)\n+lookup_name_real (tree name, LOOK_where where, LOOK_want want)\n {\n-  tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = lookup_name_real_1 (name, where, want, flags);\n+  tree ret = lookup_name_real_1 (name, where, want);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n \n tree\n lookup_name_nonclass (tree name)\n {\n-  return lookup_name_real (name, LOOK_where::BLOCK_NAMESPACE,\n-\t\t\t   LOOK_want::NORMAL, 0);\n+  return lookup_name_real (name, LOOK_where::BLOCK_NAMESPACE, LOOK_want::NORMAL);\n }\n \n tree\n lookup_name (tree name)\n {\n-  return lookup_name_real (name, LOOK_where::ALL, LOOK_want::NORMAL, 0);\n+  return lookup_name_real (name, LOOK_where::ALL, LOOK_want::NORMAL);\n }\n \n tree\n lookup_name (tree name, LOOK_want want)\n {\n-  return lookup_name_real (name, LOOK_where::ALL, want, 0);\n+  return lookup_name_real (name, LOOK_where::ALL, want);\n }\n \n /* Look up NAME for type used in elaborated name specifier in\n@@ -6637,13 +6634,13 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n \t     typedef struct C {} C;\n \t   correctly.  */\n \tif (tree type = iter->type)\n-\t  if (qualify_lookup (type, LOOK_want::TYPE, false)\n+\t  if (qualify_lookup (type, LOOK_want::TYPE)\n \t      && (scope != ts_current\n \t\t  || LOCAL_BINDING_P (iter)\n \t\t  || DECL_CONTEXT (type) == iter->scope->this_entity))\n \t    return type;\n \n-\tif (qualify_lookup (iter->value, LOOK_want::TYPE, false)\n+\tif (qualify_lookup (iter->value, LOOK_want::TYPE)\n \t    && (scope != ts_current\n \t\t|| !INHERITED_VALUE_BINDING_P (iter)))\n \t  return iter->value;\n@@ -6664,11 +6661,11 @@ lookup_type_scope_1 (tree name, tag_scope scope)\n     {\n       /* If this is the kind of thing we're looking for, we're done.  */\n       if (tree type = MAYBE_STAT_TYPE (*slot))\n-\tif (qualify_lookup (type, LOOK_want::TYPE, false))\n+\tif (qualify_lookup (type, LOOK_want::TYPE))\n \t  return type;\n \n       if (tree decl = MAYBE_STAT_DECL (*slot))\n-\tif (qualify_lookup (decl, LOOK_want::TYPE, false))\n+\tif (qualify_lookup (decl, LOOK_want::TYPE))\n \t  return decl;\n     }\n "}, {"sha": "e43a04c1d6ea1152887b7645d0350c7238a41d90", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=db1c2a89db09c8fe140ed3e65a707a08737e3b41", "patch": "@@ -306,6 +306,9 @@ enum class LOOK_want\n   TYPE = 1 << 1,  /* We only want TYPE_DECLS.  */\n   NAMESPACE = 1 << 2,  /* We only want NAMESPACE_DECLS.  */\n \n+  HIDDEN_FRIEND = 1 << 3, /* See hidden friends.  */\n+  HIDDEN_LAMBDA = 1 << 4,  /* See lambda-ignored entities.  */\n+\n   TYPE_NAMESPACE = TYPE | NAMESPACE,  /* Either NAMESPACE or TYPE.  */\n };\n constexpr LOOK_want operator| (LOOK_want a, LOOK_want b)\n@@ -317,7 +320,7 @@ constexpr LOOK_want operator& (LOOK_want a, LOOK_want b)\n   return LOOK_want (unsigned (a) & unsigned (b));\n }\n \n-extern tree lookup_name_real (tree, LOOK_where, LOOK_want, int flags);\n+extern tree lookup_name_real (tree, LOOK_where, LOOK_want);\n extern tree lookup_type_scope (tree, tag_scope);\n extern tree get_namespace_binding (tree ns, tree id);\n extern void set_global_binding (tree decl);\n@@ -330,10 +333,10 @@ extern tree lookup_name (tree name);\n extern tree lookup_name (tree name, LOOK_want);\n extern tree lookup_qualified_name (tree scope, tree name,\n \t\t\t\t   LOOK_want = LOOK_want::NORMAL,\n-\t\t\t\t   bool = true, /*hidden*/bool = false);\n+\t\t\t\t   bool = true);\n extern tree lookup_qualified_name (tree scope, const char *name,\n \t\t\t\t   LOOK_want = LOOK_want::NORMAL,\n-\t\t\t\t   bool = true, bool = false);\n+\t\t\t\t   bool = true);\n extern tree lookup_name_nonclass (tree);\n extern bool is_local_extern (tree);\n extern bool pushdecl_class_level (tree);"}, {"sha": "641cedbe3f87370c23df817debd11c52ccd55769", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=db1c2a89db09c8fe140ed3e65a707a08737e3b41", "patch": "@@ -28462,16 +28462,15 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t\t\t    template-name after -> or ., only\n \t\t\t\t    consider class templates.  */\n \t\t\t\t : is_template ? LOOK_want::TYPE\n-\t\t\t\t : prefer_type_arg (tag_type), 0);\n+\t\t\t\t : prefer_type_arg (tag_type));\n       parser->object_scope = object_type;\n       parser->qualifying_scope = NULL_TREE;\n     }\n   else\n     {\n       decl = lookup_name_real (name, LOOK_where::ALL,\n \t\t\t       is_namespace ? LOOK_want::NAMESPACE\n-\t\t\t       : prefer_type_arg (tag_type),\n-\t\t\t       0);\n+\t\t\t       : prefer_type_arg (tag_type));\n       parser->qualifying_scope = NULL_TREE;\n       parser->object_scope = NULL_TREE;\n     }"}, {"sha": "74c745a2c5dadd92981bcbf90b349284e96669f7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=db1c2a89db09c8fe140ed3e65a707a08737e3b41", "patch": "@@ -2999,9 +2999,10 @@ check_explicit_specialization (tree declarator,\n \t      if (fns == error_mark_node)\n \t\t/* If lookup fails, look for a friend declaration so we can\n \t\t   give a better diagnostic.  */\n-\t\tfns = lookup_qualified_name (CP_DECL_CONTEXT (decl), dname,\n-\t\t\t\t\t     LOOK_want::NORMAL, /*complain*/true,\n-\t\t\t\t\t     /*hidden*/true);\n+\t\tfns = (lookup_qualified_name\n+\t\t       (CP_DECL_CONTEXT (decl), dname,\n+\t\t\tLOOK_want::NORMAL | LOOK_want::HIDDEN_FRIEND,\n+\t\t\t/*complain*/true));\n \n \t      if (fns == error_mark_node || !is_overloaded_fn (fns))\n \t\t{\n@@ -11184,7 +11185,7 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n     }\n \n   tmpl = lookup_name_real (DECL_NAME (friend_tmpl), LOOK_where::CLASS_NAMESPACE,\n-\t\t\t   LOOK_want::NORMAL, LOOKUP_HIDDEN);\n+\t\t\t   LOOK_want::NORMAL | LOOK_want::HIDDEN_FRIEND);\n \n   if (tmpl && DECL_CLASS_TEMPLATE_P (tmpl))\n     {\n@@ -17834,8 +17835,7 @@ lookup_init_capture_pack (tree decl)\n   for (int i = 0; i < len; ++i)\n     {\n       tree ename = vec ? make_ith_pack_parameter_name (cname, i) : cname;\n-      tree elt = lookup_name_real (ename, LOOK_where::ALL, LOOK_want::NORMAL,\n-\t\t\t\t   LOOKUP_NORMAL);\n+      tree elt = lookup_name_real (ename, LOOK_where::ALL, LOOK_want::NORMAL);\n       if (vec)\n \tTREE_VEC_ELT (vec, i) = elt;\n       else\n@@ -17940,10 +17940,9 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t    tree inst;\n \t    if (!DECL_PACK_P (decl))\n \t      {\n-\t\tinst = lookup_name_real (DECL_NAME (decl),\n-\t\t\t\t\t LOOK_where::BLOCK_NAMESPACE,\n-\t\t\t\t\t LOOK_want::NORMAL,\n-\t\t\t\t\t LOOKUP_HIDDEN);\n+\t\tinst = (lookup_name_real\n+\t\t\t(DECL_NAME (decl), LOOK_where::BLOCK,\n+\t\t\t LOOK_want::NORMAL | LOOK_want::HIDDEN_LAMBDA));\n \t\tgcc_assert (inst != decl && is_capture_proxy (inst));\n \t      }\n \t    else if (is_normal_capture_proxy (decl))\n@@ -28726,8 +28725,7 @@ deduction_guides_for (tree tmpl, tsubst_flags_t complain)\n     {\n       guides = lookup_qualified_name (CP_DECL_CONTEXT (tmpl),\n \t\t\t\t      dguide_name (tmpl),\n-\t\t\t\t      LOOK_want::NORMAL, /*complain*/false,\n-\t\t\t\t      /*hidden*/false);\n+\t\t\t\t      LOOK_want::NORMAL, /*complain*/false);\n       if (guides == error_mark_node)\n \tguides = NULL_TREE;\n     }"}, {"sha": "da452c58daaf7e74a908e190eeca6b7aa427d08b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1c2a89db09c8fe140ed3e65a707a08737e3b41/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=db1c2a89db09c8fe140ed3e65a707a08737e3b41", "patch": "@@ -10322,8 +10322,8 @@ static tree\n capture_decltype (tree decl)\n {\n   tree lam = CLASSTYPE_LAMBDA_EXPR (DECL_CONTEXT (current_function_decl));\n-  tree cap = lookup_name_real (DECL_NAME (decl), LOOK_where::BLOCK_NAMESPACE,\n-\t\t\t       LOOK_want::NORMAL, LOOKUP_HIDDEN);\n+  tree cap = lookup_name_real (DECL_NAME (decl), LOOK_where::BLOCK,\n+\t\t\t       LOOK_want::NORMAL | LOOK_want::HIDDEN_LAMBDA);\n   tree type;\n \n   if (cap && is_capture_proxy (cap))"}, {"sha": "e30cb8c024bafcf5ac8e735d0e1aa522fca776b3", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db1c2a89db09c8fe140ed3e65a707a08737e3b41/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db1c2a89db09c8fe140ed3e65a707a08737e3b41/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=db1c2a89db09c8fe140ed3e65a707a08737e3b41", "patch": "@@ -2653,7 +2653,7 @@ plugin_build_dependent_expr (cc1_plugin::connection *self,\n   tree res = identifier;\n   if (!scope)\n     res = lookup_name_real (res, LOOK_where::BLOCK_NAMESPACE,\n-\t\t\t    LOOK_want::NORMAL, 0);\n+\t\t\t    LOOK_want::NORMAL);\n   else if (!TYPE_P (scope) || !dependent_scope_p (scope))\n     {\n       res = lookup_qualified_name (scope, res, LOOK_want::NORMAL, true);"}]}