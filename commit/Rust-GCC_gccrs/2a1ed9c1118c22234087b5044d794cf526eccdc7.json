{"sha": "2a1ed9c1118c22234087b5044d794cf526eccdc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmExZWQ5YzExMThjMjIyMzQwODdiNTA0NGQ3OTRjZjUyNmVjY2RjNw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-02-21T23:53:36Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-02-21T23:53:36Z"}, "message": "[multiple changes]\n\nThu Feb 17 14:30:37 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* jcf-write.c (generate_bytecode_insns): Don't generate empty\n \t`finally' clauses.\n\nThu Feb 17 13:20:58 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* jcf-parse.c (load_class): Call `fatal' if no file containing\n\tthe target class are found.\n\nFrom-SVN: r32095", "tree": {"sha": "424b297b151611bab940b1e6ad26e5096b801614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/424b297b151611bab940b1e6ad26e5096b801614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a1ed9c1118c22234087b5044d794cf526eccdc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1ed9c1118c22234087b5044d794cf526eccdc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a1ed9c1118c22234087b5044d794cf526eccdc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1ed9c1118c22234087b5044d794cf526eccdc7/comments", "author": null, "committer": null, "parents": [{"sha": "47ee9bcb614d58ea60d228bb11563d7df4d279ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ee9bcb614d58ea60d228bb11563d7df4d279ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ee9bcb614d58ea60d228bb11563d7df4d279ec"}], "stats": {"total": 76, "additions": 48, "deletions": 28}, "files": [{"sha": "8b631e0625a069c1730b9e49d0feda042fe2469f", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ed9c1118c22234087b5044d794cf526eccdc7/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ed9c1118c22234087b5044d794cf526eccdc7/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=2a1ed9c1118c22234087b5044d794cf526eccdc7", "patch": "@@ -28,6 +28,16 @@ Wed Nov 03 02:16:00 PST 1999  Pekka Nikander  <pekka.nikander@hut.fi>\n \t* jv-scan.c (help): Likewise.\n \t* jcf-dump.c (help): Likewise.\n \n+Thu Feb 17 14:30:37 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* jcf-write.c (generate_bytecode_insns): Don't generate empty\n+ \t`finally' clauses.\n+\n+Thu Feb 17 13:20:58 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* jcf-parse.c (load_class): Call `fatal' if no file containing\n+\tthe target class are found.\n+\n 2000-02-16  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* Makefile.in (PARSE_C, PARSE_SCAN_C): Move dependencies on"}, {"sha": "a10f605cb753ce257dfb1cee3e379f45828ffd98", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ed9c1118c22234087b5044d794cf526eccdc7/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ed9c1118c22234087b5044d794cf526eccdc7/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=2a1ed9c1118c22234087b5044d794cf526eccdc7", "patch": "@@ -526,18 +526,7 @@ load_class (class_or_name, verbose)\n     name = DECL_NAME (TYPE_NAME (class_or_name));\n \n   if (read_class (name) == 0 && verbose)\n-    {\n-      error (\"Cannot find file for class %s.\",\n-\t     IDENTIFIER_POINTER (name));\n-      if (TREE_CODE (class_or_name) == RECORD_TYPE)\n-\tTYPE_SIZE (class_or_name) = error_mark_node;\n-#if 0\n-      /* FIXME: what to do here?  */\n-      if (!strcmp (classpath, DEFAULT_CLASS_PATH))\n-\tfatal (\"giving up\");\n-#endif\n-      return;\n-    }\n+    fatal (\"Cannot find file for class %s.\", IDENTIFIER_POINTER (name));\n }\n \n /* Parse a source file when JCF refers to a source file.  */"}, {"sha": "45552d3d47aabab9bc305240f7a93e078d33f383", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ed9c1118c22234087b5044d794cf526eccdc7/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ed9c1118c22234087b5044d794cf526eccdc7/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=2a1ed9c1118c22234087b5044d794cf526eccdc7", "patch": "@@ -2297,31 +2297,52 @@ generate_bytecode_insns (exp, target, state)\n       break;\n     case TRY_FINALLY_EXPR:\n       {\n+\tstruct jcf_block *finished_label, *finally_label, *start_label;\n+\tstruct jcf_handler *handler;\n+\tint worthwhile_finally = 1;\n \ttree try_block = TREE_OPERAND (exp, 0);\n \ttree finally = TREE_OPERAND (exp, 1);\n-\tstruct jcf_block *finished_label = gen_jcf_label (state);\n-\tstruct jcf_block *finally_label = gen_jcf_label (state);\n-\tstruct jcf_block *start_label = get_jcf_label_here (state);\n-\ttree return_link = build_decl (VAR_DECL, NULL_TREE,\n-\t\t\t\t       return_address_type_node);\n-\ttree exception_type = build_pointer_type (throwable_type_node);\n-\ttree exception_decl = build_decl (VAR_DECL, NULL_TREE, exception_type);\n-\tstruct jcf_handler *handler;\n+\ttree return_link, exception_type, exception_decl;\n \n-\tfinally_label->pc = PENDING_CLEANUP_PC;\n-\tfinally_label->next = state->labeled_blocks;\n-\tstate->labeled_blocks = finally_label;\n-\tstate->num_finalizers++;\n+\t/* If the finally clause happens to be empty, set a flag so we\n+           remember to just skip it. */\n+\tif (BLOCK_EXPR_BODY (finally) == empty_stmt_node)\n+\t  worthwhile_finally = 0;\n+\n+\tif (worthwhile_finally)\n+\t  {\n+\t    return_link = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t      return_address_type_node);\n+\t    exception_type = build_pointer_type (throwable_type_node);\n+\t    exception_decl = build_decl (VAR_DECL, NULL_TREE, exception_type);\n+\n+\t    finished_label = gen_jcf_label (state);\n+\t    finally_label = gen_jcf_label (state);\n+\t    start_label = get_jcf_label_here (state);\n+\t    finally_label->pc = PENDING_CLEANUP_PC;\n+\t    finally_label->next = state->labeled_blocks;\n+\t    state->labeled_blocks = finally_label;\n+\t    state->num_finalizers++;\n+\t  }\n \n \tgenerate_bytecode_insns (try_block, target, state);\n-\tif (state->labeled_blocks != finally_label)\n-\t  abort();\n-\tstate->labeled_blocks = finally_label->next;\n-\temit_jsr (finally_label, state);\n+\n+\tif (worthwhile_finally)\n+\t  {\n+\t    if (state->labeled_blocks != finally_label)\n+\t      abort();\n+\t    state->labeled_blocks = finally_label->next;\n+\t    emit_jsr (finally_label, state);\n+\t  }\n+\n \tif (CAN_COMPLETE_NORMALLY (try_block))\n \t  emit_goto (finished_label, state);\n \n \t/* Handle exceptions. */\n+\n+\tif (!worthwhile_finally)\n+\t  break;\n+\n \tlocalvar_alloc (return_link, state);\n \thandler = alloc_handler (start_label, NULL_PTR, state);\n \thandler->end_label = handler->handler_label;"}]}