{"sha": "1d4b96e007641088199133bb37a13338eb4fb2ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ0Yjk2ZTAwNzY0MTA4ODE5OTEzM2JiMzdhMTMzMzhlYjRmYjJmZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-12T10:55:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-12T10:55:37Z"}, "message": "decl.c (gnat_to_gnu_entity): Create IMPORTED_DECL nodes to describe the subprogram renamings which are...\n\n2015-11-12  Pierre-Marie de Rodat  <derodat@adacore.com>\n\n        * gcc-interface/decl.c (gnat_to_gnu_entity): Create\n        IMPORTED_DECL nodes to describe the subprogram renamings which\n        are relevant at debug time.\n        * gcc-interface/gigi.h (get_debug_scope): Add declaration.\n        * gcc-interface/trans.c (Identifier_to_gnu): Consider\n        N_Defining_Operator_Symbol as valid entities.\n        (gnat_to_gnu): Handle N_Defining_Operator_Symbol the same way as\n        other entities.  Introduce a specific handling for\n        N_Subprogram_Renaming_Declaration: call gnat_to_gnu_entity on\n        the entity defined for relevant ones.\n        (process_decls): Process subprogram renaming declarations during\n        the second pass only.\n        * gcc-interface/utils.c (get_debug_scope): Make it external.\n        Consider N_Defining_Operator_Symbol as valid entities.\n        (gnat_write_global_declarations): Output debugging information\n        for top-level imported declarations.\n        * gcc-interface/Makefile.in: Fix typo.\n\nFrom-SVN: r230227", "tree": {"sha": "34ae13ea914b1a19196c1f49ae686f6b549cc8aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34ae13ea914b1a19196c1f49ae686f6b549cc8aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d4b96e007641088199133bb37a13338eb4fb2ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d4b96e007641088199133bb37a13338eb4fb2ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d4b96e007641088199133bb37a13338eb4fb2ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d4b96e007641088199133bb37a13338eb4fb2ff/comments", "author": null, "committer": null, "parents": [{"sha": "81501d2b45d990aaab9c0c3b85a13b4315ed567e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81501d2b45d990aaab9c0c3b85a13b4315ed567e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81501d2b45d990aaab9c0c3b85a13b4315ed567e"}], "stats": {"total": 104, "additions": 99, "deletions": 5}, "files": [{"sha": "2afdfa2acfd50c9127c55a6bfc0191650ea2f4dc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1d4b96e007641088199133bb37a13338eb4fb2ff", "patch": "@@ -1,3 +1,25 @@\n+2015-11-12  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Create\n+\tIMPORTED_DECL nodes to describe the subprogram renamings which\n+\tare relevant at debug time.\n+\t* gcc-interface/gigi.h (get_debug_scope): Add declaration.\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Consider\n+\tN_Defining_Operator_Symbol as valid entities.\n+\t(gnat_to_gnu): Handle N_Defining_Operator_Symbol the same way as\n+\tother entities.  Introduce a specific handling for\n+\tN_Subprogram_Renaming_Declaration: call gnat_to_gnu_entity on\n+\tthe entity defined for relevant ones.\n+\t(process_decls): Process subprogram renaming declarations during\n+\tthe second pass only.\n+\t* gcc-interface/utils.c (get_debug_scope): Make it external.\n+\tConsider N_Defining_Operator_Symbol as valid entities.\n+\t(gnat_write_global_declarations): Output debugging information\n+\tfor top-level imported declarations.\n+\t* gcc-interface/Makefile.in: Fix typo.\n+\n+2015-11-12  Emmanuel Briot  <briot@adacore.com>\n+\n 2015-11-12  Emmanuel Briot  <briot@adacore.com>\n \n \t* s-os_lib.ads: Documentation update."}, {"sha": "c2750faeb219e587ff3aca5c149e13a109d1faba", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=1d4b96e007641088199133bb37a13338eb4fb2ff", "patch": "@@ -148,7 +148,7 @@ GCC_CFLAGS = $(INTERNAL_CFLAGS) $(T_CFLAGS) $(CFLAGS)\n \n # We don't use cross-make.  Instead we use the tools from the build tree,\n # if they are available.\n-# program_transform_name and objdir are set by configure.ac.\n+# program_transform_name and objdir are set by configure.in.\n program_transform_name =\n objdir = .\n "}, {"sha": "59754b6bc49cf347cbf95fdbc0d96fb8e6756250", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=1d4b96e007641088199133bb37a13338eb4fb2ff", "patch": "@@ -4131,6 +4131,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   of its type, so we must elaborate that type now.  */\n \tif (Present (Alias (gnat_entity)))\n \t  {\n+\t    const Entity_Id gnat_renamed = Renamed_Object (gnat_entity);\n+\n \t    if (Ekind (Alias (gnat_entity)) == E_Enumeration_Literal)\n \t      gnat_to_gnu_entity (Etype (Alias (gnat_entity)), NULL_TREE, 0);\n \n@@ -4143,6 +4145,33 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      if (Is_Itype (Etype (gnat_temp)))\n \t\tgnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, 0);\n \n+\t    /* Materialize renamed subprograms in the debugging information\n+\t       when the renamed object is compile time known.  We can consider\n+\t       such renamings as imported declarations.\n+\n+\t       Because the parameters in generics instantiation are generally\n+\t       materialized as renamings, we ofter end up having both the\n+\t       renamed subprogram and the renaming in the same context and with\n+\t       the same name: in this case, renaming is both useless debug-wise\n+\t       and potentially harmful as name resolution in the debugger could\n+\t       return twice the same entity!  So avoid this case.  */\n+\t    if (debug_info_p && !artificial_p\n+\t\t&& !(get_debug_scope (gnat_entity, NULL)\n+\t\t       == get_debug_scope (gnat_renamed, NULL)\n+\t\t     && Name_Equals (Chars (gnat_entity),\n+\t\t\t\t     Chars (gnat_renamed)))\n+\t\t&& Present (gnat_renamed)\n+\t\t&& (Ekind (gnat_renamed) == E_Function\n+\t\t    || Ekind (gnat_renamed) == E_Procedure)\n+\t\t&& gnu_decl != NULL_TREE\n+\t\t&& TREE_CODE (gnu_decl) == FUNCTION_DECL)\n+\t      {\n+\t\ttree decl = build_decl (input_location, IMPORTED_DECL,\n+\t\t\t\t\tgnu_entity_name, void_type_node);\n+\t\tIMPORTED_DECL_ASSOCIATED_DECL (decl) = gnu_decl;\n+\t\tgnat_pushdecl (decl, gnat_entity);\n+\t      }\n+\n \t    break;\n \t  }\n "}, {"sha": "e6fff1e777cd06d3455e575dde16fca756715257", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=1d4b96e007641088199133bb37a13338eb4fb2ff", "patch": "@@ -1004,6 +1004,11 @@ extern bool renaming_from_generic_instantiation_p (Node_Id gnat_node);\n    don't have a GNU translation.  */\n extern void process_deferred_decl_context (bool force);\n \n+/* Return the innermost scope, starting at GNAT_NODE, we are be interested in\n+   the debug info, or Empty if there is no such scope.  If not NULL, set\n+   IS_SUBPROGRAM to whether the returned entity is a subprogram.  */\n+extern Entity_Id get_debug_scope (Node_Id gnat_node, bool *is_subprogram);\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif"}, {"sha": "b23cc51109265aa300620301804156f1b0c2f314", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1d4b96e007641088199133bb37a13338eb4fb2ff", "patch": "@@ -1027,7 +1027,8 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      original type. Similarly, a class-wide type is equivalent to a subtype of\n      itself. Finally, if the types are Itypes, one may be a copy of the other,\n      which is also legal.  */\n-  gnat_temp = (Nkind (gnat_node) == N_Defining_Identifier\n+  gnat_temp = ((Nkind (gnat_node) == N_Defining_Identifier\n+\t\t|| Nkind (gnat_node) == N_Defining_Operator_Symbol)\n \t       ? gnat_node : Entity (gnat_node));\n   gnat_temp_type = Etype (gnat_temp);\n \n@@ -5694,6 +5695,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Expanded_Name:\n     case N_Operator_Symbol:\n     case N_Defining_Identifier:\n+    case N_Defining_Operator_Symbol:\n       gnu_result = Identifier_to_gnu (gnat_node, &gnu_result_type);\n \n       /* If atomic access is required on the RHS, build the atomic load.  */\n@@ -5957,13 +5959,39 @@ gnat_to_gnu (Node_Id gnat_node)\n \t}\n       break;\n \n+    case N_Subprogram_Renaming_Declaration:\n+      {\n+\tconst Node_Id gnat_renaming = Defining_Entity (gnat_node);\n+\tconst Node_Id gnat_renamed = Renamed_Entity (gnat_renaming);\n+\n+\tgnu_result = alloc_stmt_list ();\n+\n+\t/* Materializing renamed subprograms will only benefit the debugging\n+\t   information as they aren't referenced in the generated code.  So\n+\t   skip them when they aren't needed.  Avoid doing this if:\n+\n+\t     - there is a freeze node: in this case the renamed entity is not\n+\t       elaborated yet;\n+\t     - the renamed subprogram is intrinsic: it will not be available in\n+\t       the debugging information (note that both or only one of the\n+\t       renaming and the renamed subprograms can be intrinsic).  */\n+\tif (No (Freeze_Node (gnat_renaming))\n+\t    && Needs_Debug_Info (gnat_renaming)\n+\t    && Present (gnat_renamed)\n+\t    && (Ekind (gnat_renamed) == E_Function\n+\t\t|| Ekind (gnat_renamed) == E_Procedure)\n+\t    && !Is_Intrinsic_Subprogram (gnat_renaming)\n+\t    && !Is_Intrinsic_Subprogram (gnat_renamed))\n+\t  gnat_to_gnu_entity (gnat_renaming, gnat_to_gnu (gnat_renamed), 1);\n+\tbreak;\n+      }\n+\n     case N_Implicit_Label_Declaration:\n       gnat_to_gnu_entity (Defining_Entity (gnat_node), NULL_TREE, 1);\n       gnu_result = alloc_stmt_list ();\n       break;\n \n     case N_Number_Declaration:\n-    case N_Subprogram_Renaming_Declaration:\n     case N_Package_Renaming_Declaration:\n       /* These are fully handled in the front end.  */\n       /* ??? For package renamings, find a way to use GENERIC namespaces so\n@@ -8553,6 +8581,12 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t\t     || Nkind (gnat_decl) == N_Protected_Body_Stub)\n \t      ;\n \n+\t    /* Renamed subprograms may not be elaborated yet at this point\n+\t       since renamings do not trigger freezing.  Wait for the second\n+\t       pass to take care of them.  */\n+\t    else if (Nkind (gnat_decl) == N_Subprogram_Renaming_Declaration)\n+\t      ;\n+\n \t    else\n \t      add_stmt (gnat_to_gnu (gnat_decl));\n \t  }\n@@ -8581,6 +8615,9 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \n \t    else if (Nkind (gnat_decl) == N_Freeze_Entity)\n \t      process_decls (Actions (gnat_decl), Empty, Empty, false, true);\n+\n+\t    else if (Nkind (gnat_decl) == N_Subprogram_Renaming_Declaration)\n+\t      add_stmt (gnat_to_gnu (gnat_decl));\n \t  }\n }\n \f"}, {"sha": "b032ae03df7b61f8e26ccb10b8fbdca160b98fce", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4b96e007641088199133bb37a13338eb4fb2ff/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=1d4b96e007641088199133bb37a13338eb4fb2ff", "patch": "@@ -585,15 +585,16 @@ gnat_set_type_context (tree type, tree context)\n    the debug info, or Empty if there is no such scope.  If not NULL, set\n    IS_SUBPROGRAM to whether the returned entity is a subprogram.  */\n \n-static Entity_Id\n+Entity_Id\n get_debug_scope (Node_Id gnat_node, bool *is_subprogram)\n {\n   Entity_Id gnat_entity;\n \n   if (is_subprogram)\n     *is_subprogram = false;\n \n-  if (Nkind (gnat_node) == N_Defining_Identifier)\n+  if (Nkind (gnat_node) == N_Defining_Identifier\n+      || Nkind (gnat_node) == N_Defining_Operator_Symbol)\n     gnat_entity = Scope (gnat_node);\n   else\n     return Empty;"}]}