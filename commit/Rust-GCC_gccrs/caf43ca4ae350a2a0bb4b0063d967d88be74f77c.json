{"sha": "caf43ca4ae350a2a0bb4b0063d967d88be74f77c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FmNDNjYTRhZTM1MGEyYTBiYjRiMDA2M2Q5NjdkODhiZTc0Zjc3Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-19T04:02:45Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-19T04:02:45Z"}, "message": "tree.c (no_linkage_helper): Remove.\n\n\t* tree.c (no_linkage_helper): Remove.\n\t(no_linkage_check): Don't use walk_tree_without_duplicates.\n\nFrom-SVN: r84909", "tree": {"sha": "ad0f2bb288c516d5a8a649cbf9df5bdcf2b622c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad0f2bb288c516d5a8a649cbf9df5bdcf2b622c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caf43ca4ae350a2a0bb4b0063d967d88be74f77c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf43ca4ae350a2a0bb4b0063d967d88be74f77c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caf43ca4ae350a2a0bb4b0063d967d88be74f77c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf43ca4ae350a2a0bb4b0063d967d88be74f77c/comments", "author": null, "committer": null, "parents": [{"sha": "3a7e11a39d267754f7be3260e502fa31409c55b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a7e11a39d267754f7be3260e502fa31409c55b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a7e11a39d267754f7be3260e502fa31409c55b5"}], "stats": {"total": 77, "additions": 55, "deletions": 22}, "files": [{"sha": "66c54805df15345d7fef332422d172ba701eae14", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf43ca4ae350a2a0bb4b0063d967d88be74f77c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf43ca4ae350a2a0bb4b0063d967d88be74f77c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=caf43ca4ae350a2a0bb4b0063d967d88be74f77c", "patch": "@@ -10,6 +10,9 @@\n \n 2004-07-18  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* tree.c (no_linkage_helper): Remove.\n+\t(no_linkage_check): Don't use walk_tree_without_duplicates.\n+\n \t* mangle.c (write_expression): Issue a sorry for zero-operand\n \tfunctional casts.\n "}, {"sha": "f334e721ecc2d62aba83092a4b691319a26da3f2", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 52, "deletions": 22, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caf43ca4ae350a2a0bb4b0063d967d88be74f77c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caf43ca4ae350a2a0bb4b0063d967d88be74f77c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=caf43ca4ae350a2a0bb4b0063d967d88be74f77c", "patch": "@@ -42,7 +42,6 @@ static int list_hash_eq (const void *, const void *);\n static hashval_t list_hash_pieces (tree, tree, tree);\n static hashval_t list_hash (const void *);\n static cp_lvalue_kind lvalue_p_1 (tree, int);\n-static tree no_linkage_helper (tree *, int *, void *);\n static tree mark_local_for_remap_r (tree *, int *, void *);\n static tree cp_unsave_r (tree *, int *, void *);\n static tree build_target_expr (tree, tree);\n@@ -1068,38 +1067,69 @@ find_tree (tree t, tree x)\n   return walk_tree_without_duplicates (&t, find_tree_r, x);\n }\n \n-/* Passed to walk_tree.  Checks for the use of types with no linkage.  */\n-\n-static tree\n-no_linkage_helper (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t   void *data ATTRIBUTE_UNUSED)\n-{\n-  tree t = *tp;\n-\n-  if (TYPE_P (t)\n-      && (CLASS_TYPE_P (t) || TREE_CODE (t) == ENUMERAL_TYPE)\n-      && (decl_function_context (TYPE_MAIN_DECL (t))\n-\t  || TYPE_ANONYMOUS_P (t)))\n-    return t;\n-\n-  return NULL_TREE;\n-}\n-\n /* Check if the type T depends on a type with no linkage and if so, return\n    it.  */\n \n tree\n no_linkage_check (tree t)\n {\n+  tree r;\n+\n   /* There's no point in checking linkage on template functions; we\n      can't know their complete types.  */\n   if (processing_template_decl)\n     return NULL_TREE;\n \n-  t = walk_tree_without_duplicates (&t, no_linkage_helper, NULL);\n-  if (t != error_mark_node)\n-    return t;\n-  return NULL_TREE;\n+  switch (TREE_CODE (t))\n+    {\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+\tgoto ptrmem;\n+      /* Fall through.  */\n+    case UNION_TYPE:\n+      if (!CLASS_TYPE_P (t))\n+\treturn NULL_TREE;\n+      /* Fall through.  */\n+    case ENUMERAL_TYPE:\n+      if (decl_function_context (TYPE_MAIN_DECL (t))\n+\t  || TYPE_ANONYMOUS_P (t))\n+\treturn t;\n+      return NULL_TREE;\n+\n+    case ARRAY_TYPE:\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      return no_linkage_check (TREE_TYPE (t));\n+\n+    case OFFSET_TYPE:\n+    ptrmem:\n+      r = no_linkage_check (TYPE_PTRMEM_POINTED_TO_TYPE (t));\n+      if (r)\n+\treturn r;\n+      return no_linkage_check (TYPE_PTRMEM_CLASS_TYPE (t));\n+\n+    case METHOD_TYPE:\n+      r = no_linkage_check (TYPE_METHOD_BASETYPE (t));\n+      if (r)\n+\treturn r;\n+      /* Fall through.  */\n+    case FUNCTION_TYPE:\n+      {\n+\ttree parm;\n+\tfor (parm = TYPE_ARG_TYPES (t); \n+\t     parm && parm != void_list_node; \n+\t     parm = TREE_CHAIN (parm))\n+\t  {\n+\t    r = no_linkage_check (TREE_VALUE (parm));\n+\t    if (r)\n+\t      return r;\n+\t  }\n+\treturn no_linkage_check (TREE_TYPE (t));\n+      }\n+\n+    default:\n+      return NULL_TREE;\n+    }\n }\n \n #ifdef GATHER_STATISTICS"}]}