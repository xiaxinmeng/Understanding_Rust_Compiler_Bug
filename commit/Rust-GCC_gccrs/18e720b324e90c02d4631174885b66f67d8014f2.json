{"sha": "18e720b324e90c02d4631174885b66f67d8014f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThlNzIwYjMyNGU5MGMwMmQ0NjMxMTc0ODg1YjY2ZjY3ZDgwMTRmMg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2000-12-20T17:19:39Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-12-20T17:19:39Z"}, "message": "Support scheduling across extended basic blocks\n\nFrom-SVN: r38400", "tree": {"sha": "6792bf552c4e374a8b4a117207dec07374ea6a0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6792bf552c4e374a8b4a117207dec07374ea6a0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18e720b324e90c02d4631174885b66f67d8014f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e720b324e90c02d4631174885b66f67d8014f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18e720b324e90c02d4631174885b66f67d8014f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e720b324e90c02d4631174885b66f67d8014f2/comments", "author": null, "committer": null, "parents": [{"sha": "fd7bcd6f0571ef7f5fb87c713b7a612252497056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7bcd6f0571ef7f5fb87c713b7a612252497056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd7bcd6f0571ef7f5fb87c713b7a612252497056"}], "stats": {"total": 478, "additions": 474, "deletions": 4}, "files": [{"sha": "1f19a8099baabd414161d9d0ca28ae7b1de8fbc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18e720b324e90c02d4631174885b66f67d8014f2", "patch": "@@ -1,5 +1,22 @@\n 2000-12-20  Bernd Schmidt  <bernds@redhat.com>\n \n+\t* Makefile.in (OBJS): Add sched-ebb.o.\n+\t(sched-ebb.o): New rule.\n+\t(sched-vis.o): Depend on hard-reg-set.h and $(BASIC_BLOCK_H).\n+\t(haifa-sched.o): Depend on insn-flags.h.\n+\t* haifa-sched.c: Include \"insn-flags.h\".\n+\t(priority): Don't access BLOCK_NUM, use the new contributes_to_priority\n+\tcallback.\n+\t* rtl.h (schedule_ebbs): Declare.\n+\t* sched-int.h (struct sched_info): Add new members\n+\tcontributes_to_priority and compute_jump_reg_dependencies.\n+\t* sched-rgn.c (contributes_to_priority, compute_jump_reg_dependencies):\n+\tNew functions.\n+\t(region_sched_info): Add them.\n+\t* sched-vis.c: Include \"hard-reg-set.h\" and \"basic-block.h\".\n+\t* sched-ebb.c: New file.\n+\t* sched-deps.c (sched_analyze_insn): Add code to handle JUMP_INSNs.\n+\n \t* flow.c (ior_reg_cond, and_reg_cond, elim_reg_cond): Properly\n \thandle all relational operators.\n "}, {"sha": "1f6e9252d6c8f829826594ea1e2d3f5cc207476d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=18e720b324e90c02d4631174885b66f67d8014f2", "patch": "@@ -738,7 +738,7 @@ OBJS = diagnostic.o version.o tree.o print-tree.o stor-layout.o fold-const.o  \\\n  mbchar.o splay-tree.o graph.o sbitmap.o resource.o hash.o predict.o\t      \\\n  lists.o ggc-common.o $(GGC) stringpool.o simplify-rtx.o ssa.o bb-reorder.o   \\\n  sibcall.o conflict.o timevar.o ifcvt.o dominance.o dependence.o dce.o \\\n- sched-vis.o sched-deps.o sched-rgn.o hashtab.o\n+ sched-vis.o sched-deps.o sched-rgn.o sched-ebb.o hashtab.o\n \n BACKEND = toplev.o libbackend.a\n \n@@ -1457,15 +1457,18 @@ regmove.o : regmove.c $(CONFIG_H) system.h $(RTL_H) insn-config.h \\\n    $(EXPR_H) insn-flags.h $(BASIC_BLOCK_H) toplev.h\n haifa-sched.o : haifa-sched.c $(CONFIG_H) system.h $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n-   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h\n+   $(INSN_ATTR_H) insn-flags.h toplev.h $(RECOG_H) except.h\n sched-deps.o : haifa-sched.c $(CONFIG_H) system.h $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h\n sched-rgn.o : haifa-sched.c $(CONFIG_H) system.h $(RTL_H) sched-int.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n    $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h\n+sched-ebb.o : sched-ebb.c $(CONFIG_H) system.h $(RTL_H) sched-int.h \\\n+   $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h function.h \\\n+   $(INSN_ATTR_H) toplev.h $(RECOG_H) except.h\n sched-vis.o : sched-vis.c $(CONFIG_H) system.h $(RTL_H) sched-int.h \\\n-   $(INSN_ATTR_H) $(REGS_H)\n+   hard-reg-set.h $(BASIC_BLOCK_H) $(INSN_ATTR_H) $(REGS_H)\n final.o : final.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h intl.h \\\n    $(REGS_H) $(RECOG_H) conditions.h insn-config.h $(INSN_ATTR_H) function.h \\\n    real.h output.h hard-reg-set.h insn-flags.h insn-codes.h gstab.h except.h \\"}, {"sha": "349897419ec40c003c5771474ddc98862136a4db", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=18e720b324e90c02d4631174885b66f67d8014f2", "patch": "@@ -144,6 +144,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"flags.h\"\n #include \"insn-config.h\"\n #include \"insn-attr.h\"\n+#include \"insn-flags.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"recog.h\"\n@@ -740,7 +741,7 @@ priority (insn)\n \t    next = XEXP (link, 0);\n \n \t    /* Critical path is meaningful in block boundaries only.  */\n-\t    if (BLOCK_NUM (next) != BLOCK_NUM (insn))\n+\t    if (! (*current_sched_info->contributes_to_priority) (next, insn))\n \t      continue;\n \n \t    next_priority = insn_cost (insn, link, next) + priority (next);"}, {"sha": "ce35cd8315c442c3200c8a05a223f3891c73c9df", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=18e720b324e90c02d4631174885b66f67d8014f2", "patch": "@@ -1754,6 +1754,7 @@ extern void dump_combine_total_stats\tPARAMS ((FILE *));\n /* In sched.c. */\n #ifdef BUFSIZ\n extern void schedule_insns\t\tPARAMS ((FILE *));\n+extern void schedule_ebbs\t\tPARAMS ((FILE *));\n #endif\n extern void fix_sched_param\t\tPARAMS ((const char *, const char *));\n "}, {"sha": "396b519b164dab5c57caae29e355a474b21c5d06", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=18e720b324e90c02d4631174885b66f67d8014f2", "patch": "@@ -913,6 +913,53 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t  sched_analyze_2 (deps, XEXP (link, 0), insn);\n       }\n \n+  if (GET_CODE (insn) == JUMP_INSN)\n+    {\n+      rtx next, u, pending, pending_mem;\n+      next = next_nonnote_insn (insn);\n+      if (next && GET_CODE (next) == BARRIER)\n+\t{\n+\t  for (i = 0; i < maxreg; i++)\n+\t    {\n+\t      for (u = deps->reg_last_sets[i]; u; u = XEXP (u, 1))\n+\t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t      for (u = deps->reg_last_clobbers[i]; u; u = XEXP (u, 1))\n+\t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t      for (u = deps->reg_last_uses[i]; u; u = XEXP (u, 1))\n+\t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  regset_head tmp;\n+\t  INIT_REG_SET (&tmp);\n+\n+\t  (*current_sched_info->compute_jump_reg_dependencies) (insn, &tmp);\n+\t  EXECUTE_IF_SET_IN_REG_SET \n+\t    (&tmp, 0, i,\n+\t    {\n+\t      for (u = deps->reg_last_sets[i]; u; u = XEXP (u, 1))\n+\t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+\t      deps->reg_last_uses[i]\n+\t\t= alloc_INSN_LIST (insn, deps->reg_last_uses[i]);\n+\t    });\n+\n+\t  CLEAR_REG_SET (&tmp);\n+\t}\n+      pending = deps->pending_write_insns;\n+      pending_mem = deps->pending_write_mems;\n+      while (pending)\n+\t{\n+\t  add_dependence (insn, XEXP (pending, 0), 0);\n+\n+\t  pending = XEXP (pending, 1);\n+\t  pending_mem = XEXP (pending_mem, 1);\n+\t}\n+\n+      for (u = deps->last_pending_memory_flush; u; u = XEXP (u, 1))\n+\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n+    }\n+\n   /* If there is a {LOOP,EHREGION}_{BEG,END} note in the middle of a basic\n      block, then we must be sure that no instructions are scheduled across it.\n      Otherwise, the reg_n_refs info (which depends on loop_depth) would"}, {"sha": "1ff7cea79f5d5a840664d4746488e8ec2a764b52", "filename": "gcc/sched-ebb.c", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=18e720b324e90c02d4631174885b66f67d8014f2", "patch": "@@ -0,0 +1,365 @@\n+/* Instruction scheduling pass.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n+   and currently maintained by, Jim Wilson (wilson@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to the Free\n+the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\f\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"toplev.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"regs.h\"\n+#include \"function.h\"\n+#include \"flags.h\"\n+#include \"insn-config.h\"\n+#include \"insn-attr.h\"\n+#include \"except.h\"\n+#include \"toplev.h\"\n+#include \"recog.h\"\n+#include \"sched-int.h\"\n+\f\n+/* The number of insns to be scheduled in total.  */\n+static int target_n_insns;\n+/* The number of insns scheduled so far.  */\n+static int sched_n_insns;\n+\n+/* Implementations of the sched_info functions for region scheduling.  */\n+static void init_ready_list PARAMS ((struct ready_list *));\n+static int can_schedule_ready_p PARAMS ((rtx));\n+static int new_ready PARAMS ((rtx));\n+static int schedule_more_p PARAMS ((void));\n+static const char *print_insn PARAMS ((rtx, int));\n+static int rank PARAMS ((rtx, rtx));\n+static int contributes_to_priority PARAMS ((rtx, rtx));\n+static void compute_jump_reg_dependencies PARAMS ((rtx, regset));\n+static void schedule_ebb PARAMS ((rtx, rtx));\n+\n+/* Return nonzero if there are more insns that should be scheduled.  */\n+\n+static int\n+schedule_more_p ()\n+{\n+  return sched_n_insns < target_n_insns;\n+}\n+\n+/* Add all insns that are initially ready to the ready list READY.  Called\n+   once before scheduling a set of insns.  */\n+\n+static void\n+init_ready_list (ready)\n+     struct ready_list *ready;\n+{\n+  rtx prev_head = current_sched_info->prev_head;\n+  rtx next_tail = current_sched_info->next_tail;\n+  rtx insn;\n+\n+  target_n_insns = 0;\n+  sched_n_insns = 0;\n+\n+#if 0\n+  /* Print debugging information.  */\n+  if (sched_verbose >= 5)\n+    debug_dependencies ();\n+#endif\n+\n+  /* Initialize ready list with all 'ready' insns in target block.\n+     Count number of insns in the target block being scheduled.  */\n+  for (insn = NEXT_INSN (prev_head); insn != next_tail; insn = NEXT_INSN (insn))\n+    {\n+      rtx next;\n+\n+      if (! INSN_P (insn))\n+\tcontinue;\n+      next = NEXT_INSN (insn);\n+\n+      if (INSN_DEP_COUNT (insn) == 0\n+\t  && (SCHED_GROUP_P (next) == 0 || ! INSN_P (next)))\n+\tready_add (ready, insn);\n+      if (!(SCHED_GROUP_P (insn)))\n+\ttarget_n_insns++;\n+    }\n+}\n+\n+/* Called after taking INSN from the ready list.  Returns nonzero if this\n+   insn can be scheduled, nonzero if we should silently discard it.  */\n+\n+static int\n+can_schedule_ready_p (insn)\n+     rtx insn ATTRIBUTE_UNUSED;\n+{\n+  sched_n_insns++;\n+  return 1;\n+}\n+\n+/* Called after INSN has all its dependencies resolved.  Return nonzero\n+   if it should be moved to the ready list or the queue, or zero if we\n+   should silently discard it.  */\n+static int\n+new_ready (next)\n+     rtx next ATTRIBUTE_UNUSED;\n+{\n+  return 1;\n+}\n+\n+/* Return a string that contains the insn uid and optionally anything else\n+   necessary to identify this insn in an output.  It's valid to use a\n+   static buffer for this.  The ALIGNED parameter should cause the string\n+   to be formatted so that multiple output lines will line up nicely.  */\n+\n+static const char *\n+print_insn (insn, aligned)\n+     rtx insn;\n+     int aligned ATTRIBUTE_UNUSED;\n+{\n+  static char tmp[80];\n+\n+  sprintf (tmp, \"%4d\", INSN_UID (insn));\n+  return tmp;\n+}\n+\n+/* Compare priority of two insns.  Return a positive number if the second\n+   insn is to be preferred for scheduling, and a negative one if the first\n+   is to be preferred.  Zero if they are equally good.  */\n+\n+static int\n+rank (insn1, insn2)\n+     rtx insn1 ATTRIBUTE_UNUSED, insn2 ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n+/* NEXT is an instruction that depends on INSN (a backward dependence);\n+   return nonzero if we should include this dependence in priority\n+   calculations.  */\n+\n+static int\n+contributes_to_priority (next, insn)\n+     rtx next ATTRIBUTE_UNUSED, insn ATTRIBUTE_UNUSED;\n+{\n+  return 1;\n+}\n+\n+/* INSN is a JUMP_INSN.  Store the set of registers that must be considered\n+   to be set by this jump in SET.  */\n+\n+static void\n+compute_jump_reg_dependencies (insn, set)\n+     rtx insn;\n+     regset set;\n+{\n+  basic_block b = BLOCK_FOR_INSN (insn);\n+  edge e;\n+  for (e = b->succ; e; e = e->succ_next)\n+    if ((e->flags & EDGE_FALLTHRU) == 0)\n+      {\n+\tbitmap_operation (set, set, e->dest->global_live_at_start,\n+\t\t\t  BITMAP_IOR);\n+      }\n+}\n+\n+/* Used in schedule_insns to initialize current_sched_info for scheduling\n+   regions (or single basic blocks).  */\n+\n+static struct sched_info ebb_sched_info =\n+{\n+  init_ready_list,\n+  can_schedule_ready_p,\n+  schedule_more_p,\n+  new_ready,\n+  rank,\n+  print_insn,\n+  contributes_to_priority,\n+  compute_jump_reg_dependencies,\n+\n+  NULL, NULL,\n+  NULL, NULL,\n+  0\n+};\n+\f\n+/* Schedule a single extended basic block, defined by the boundaries HEAD\n+   and TAIL.  */\n+\n+static void\n+schedule_ebb (head, tail)\n+     rtx head, tail;\n+{\n+  int n_insns;\n+  struct deps tmp_deps;\n+\n+  if (no_real_insns_p (head, tail))\n+    return;\n+\n+  init_deps_global ();\n+\n+  /* Compute LOG_LINKS.  */\n+  init_deps (&tmp_deps);\n+  sched_analyze (&tmp_deps, head, tail);\n+  free_deps (&tmp_deps);\n+\n+  /* Compute INSN_DEPEND.  */\n+  compute_forward_dependences (head, tail);\n+\n+  /* Set priorities.  */\n+  n_insns = set_priorities (head, tail);\n+\n+  current_sched_info->prev_head = PREV_INSN (head);\n+  current_sched_info->next_tail = NEXT_INSN (tail);\n+\n+  if (write_symbols != NO_DEBUG)\n+    {\n+      save_line_notes (0, head, tail);\n+      rm_line_notes (head, tail);\n+    }\n+\n+  /* rm_other_notes only removes notes which are _inside_ the\n+     block---that is, it won't remove notes before the first real insn\n+     or after the last real insn of the block.  So if the first insn\n+     has a REG_SAVE_NOTE which would otherwise be emitted before the\n+     insn, it is redundant with the note before the start of the\n+     block, and so we have to take it out.\n+\n+     FIXME: Probably the same thing should be done with REG_SAVE_NOTEs\n+     referencing NOTE_INSN_SETJMP at the end of the block.  */\n+  if (INSN_P (head))\n+    {\n+      rtx note;\n+\n+      for (note = REG_NOTES (head); note; note = XEXP (note, 1))\n+\tif (REG_NOTE_KIND (note) == REG_SAVE_NOTE)\n+\t  {\n+\t    if (INTVAL (XEXP (note, 0)) != NOTE_INSN_SETJMP)\n+\t      {\n+\t\tremove_note (head, note);\n+\t\tnote = XEXP (note, 1);\n+\t\tremove_note (head, note);\n+\t      }\n+\t    else\n+\t      note = XEXP (note, 1);\n+\t  }\n+    }\n+\n+  /* Remove remaining note insns from the block, save them in\n+     note_list.  These notes are restored at the end of\n+     schedule_block ().  */\n+  rm_other_notes (head, tail);\n+\n+  current_sched_info->queue_must_finish_empty = 1;\n+\n+  schedule_block (-1, n_insns);\n+\n+  /* Sanity check: verify that all region insns were scheduled.  */\n+  if (sched_n_insns != n_insns)\n+    abort ();\n+  head = current_sched_info->head;\n+  tail = current_sched_info->tail;\n+\n+  if (write_symbols != NO_DEBUG)\n+    restore_line_notes (0, head, tail);\n+\n+  finish_deps_global ();\n+}\n+\n+/* The one entry point in this file.  DUMP_FILE is the dump file for\n+   this pass.  */\n+\n+void\n+schedule_ebbs (dump_file)\n+     FILE *dump_file;\n+{\n+  int i;\n+\n+  /* Taking care of this degenerate case makes the rest of\n+     this code simpler.  */\n+  if (n_basic_blocks == 0)\n+    return;\n+\n+  sched_init (dump_file);\n+\n+  current_sched_info = &ebb_sched_info;\n+\n+  allocate_reg_life_data ();\n+  compute_bb_for_insn (get_max_uid ());\n+\n+  /* Schedule every region in the subroutine.  */\n+  for (i = 0; i < n_basic_blocks; i++)\n+    { \n+      rtx head = BASIC_BLOCK (i)->head;\n+      rtx tail;\n+\n+      for (;;)\n+\t{\n+\t  basic_block b = BASIC_BLOCK (i);\n+\t  edge e;\n+\t  tail = b->end;\n+\t  if (i + 1 == n_basic_blocks\n+\t      || GET_CODE (BLOCK_HEAD (i + 1)) == CODE_LABEL)\n+\t    break;\n+\t  for (e = b->succ; e; e = e->succ_next)\n+\t    if ((e->flags & EDGE_FALLTHRU) != 0)\n+\t      break;\n+\t  if (! e)\n+\t    break;\n+\t  if (GET_CODE (tail) == JUMP_INSN)\n+\t    {\n+\t      rtx x = find_reg_note (tail, REG_BR_PROB, 0);\n+\t      if (x)\n+\t\t{\n+\t\t  int pred_val = INTVAL (XEXP (x, 0));\n+\t\t  if (pred_val > REG_BR_PROB_BASE / 2)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\n+\t  i++;\n+\t}\n+\n+      /* Blah.  We should fix the rest of the code not to get confused by\n+\t a note or two.  */\n+      while (head != tail)\n+\t{\n+\t  if (GET_CODE (head) == NOTE)\n+\t    head = NEXT_INSN (head);\n+\t  else if (GET_CODE (tail) == NOTE)\n+\t    tail = PREV_INSN (tail);\n+\t  else if (GET_CODE (head) == CODE_LABEL)\n+\t    head = NEXT_INSN (head);\n+\t  else\n+\t    break;\n+\t}\n+\n+      schedule_ebb (head, tail);\n+    }\n+\n+  /* It doesn't make much sense to try and update life information here - we\n+     probably messed up even the flow graph.  */\n+\n+  /* Reposition the prologue and epilogue notes in case we moved the\n+     prologue/epilogue insns.  */\n+  if (reload_completed)\n+    reposition_prologue_and_epilogue_notes (get_insns ());\n+\n+  if (write_symbols != NO_DEBUG)\n+    rm_redundant_line_notes ();\n+\n+  sched_finish ();\n+}"}, {"sha": "f59f3a84fb3bbab45751b898b583330989b85642", "filename": "gcc/sched-int.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=18e720b324e90c02d4631174885b66f67d8014f2", "patch": "@@ -115,6 +115,13 @@ struct sched_info\n      static buffer for this.  The ALIGNED parameter should cause the string\n      to be formatted so that multiple output lines will line up nicely.  */\n   const char *(*print_insn) PARAMS ((rtx, int));\n+  /* Return nonzero if an insn should be included in priority\n+     calculations.  */\n+  int (*contributes_to_priority) PARAMS ((rtx, rtx));\n+  /* Called when computing dependencies for a JUMP_INSN.  This function\n+     should store the set of registers that must be considered as set by\n+     the jump in the regset.  */\n+  void (*compute_jump_reg_dependencies) PARAMS ((rtx, regset));\n \n   /* The boundaries of the set of insns to be scheduled.  */\n   rtx prev_head, next_tail;"}, {"sha": "db4cc877b36127d1fafa14b089568582e94e3c7b", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=18e720b324e90c02d4631174885b66f67d8014f2", "patch": "@@ -2042,6 +2042,8 @@ static int new_ready PARAMS ((rtx));\n static int schedule_more_p PARAMS ((void));\n static const char *rgn_print_insn PARAMS ((rtx, int));\n static int rgn_rank PARAMS ((rtx, rtx));\n+static int contributes_to_priority PARAMS ((rtx, rtx));\n+static void compute_jump_reg_dependencies PARAMS ((rtx, regset));\n \n /* Return nonzero if there are more insns that should be scheduled.  */\n \n@@ -2302,6 +2304,29 @@ rgn_rank (insn1, insn2)\n   return 0;\n }\n \n+/* NEXT is an instruction that depends on INSN (a backward dependence);\n+   return nonzero if we should include this dependence in priority\n+   calculations.  */\n+\n+static int\n+contributes_to_priority (next, insn)\n+     rtx next, insn;\n+{\n+  return BLOCK_NUM (next) == BLOCK_NUM (insn);\n+}\n+\n+/* INSN is a JUMP_INSN.  Store the set of registers that must be considered\n+   to be set by this jump in SET.  */\n+\n+static void\n+compute_jump_reg_dependencies (insn, set)\n+     rtx insn ATTRIBUTE_UNUSED;\n+     regset set ATTRIBUTE_UNUSED;\n+{\n+  /* Nothing to do here, since we postprocess jumps in\n+     add_branch_dependences.  */\n+}\n+\n /* Used in schedule_insns to initialize current_sched_info for scheduling\n    regions (or single basic blocks).  */\n \n@@ -2313,6 +2338,8 @@ static struct sched_info region_sched_info =\n   new_ready,\n   rgn_rank,\n   rgn_print_insn,\n+  contributes_to_priority,\n+  compute_jump_reg_dependencies,\n \n   NULL, NULL,\n   NULL, NULL,"}, {"sha": "764876c92954f977fe6fb5b18ec30a94fa650e55", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e720b324e90c02d4631174885b66f67d8014f2/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=18e720b324e90c02d4631174885b66f67d8014f2", "patch": "@@ -27,6 +27,8 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"rtl.h\"\n #include \"tm_p.h\"\n #include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n #include \"insn-attr.h\"\n #include \"sched-int.h\"\n "}]}