{"sha": "da2c02192bfb2849b893b0c71e1b007db6426b7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEyYzAyMTkyYmZiMjg0OWI4OTNiMGM3MWUxYjAwN2RiNjQyNmI3Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "1999-11-01T12:57:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1999-11-01T12:57:38Z"}, "message": "regclass.c (record_reg_classes): In matching case, recompute costs since the direction of movement is different.\n\n\t* regclass.c (record_reg_classes): In matching case, recompute\n\tcosts since the direction of movement is different.\n\nFrom-SVN: r30319", "tree": {"sha": "72c8057bcf13f26641ce774f9aaf5b65d87f2810", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72c8057bcf13f26641ce774f9aaf5b65d87f2810"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da2c02192bfb2849b893b0c71e1b007db6426b7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da2c02192bfb2849b893b0c71e1b007db6426b7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da2c02192bfb2849b893b0c71e1b007db6426b7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da2c02192bfb2849b893b0c71e1b007db6426b7c/comments", "author": null, "committer": null, "parents": [{"sha": "ffa669ea3c0d3d4a01bda872b40064151970f5aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa669ea3c0d3d4a01bda872b40064151970f5aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa669ea3c0d3d4a01bda872b40064151970f5aa"}], "stats": {"total": 59, "additions": 47, "deletions": 12}, "files": [{"sha": "b1ea4581f7c9462b2c085c1f32642e7c2d487f0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da2c02192bfb2849b893b0c71e1b007db6426b7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da2c02192bfb2849b893b0c71e1b007db6426b7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da2c02192bfb2849b893b0c71e1b007db6426b7c", "patch": "@@ -1,3 +1,7 @@\n+Mon Nov  1 08:03:15 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* regclass.c (record_reg_classes): In matching case, recompute\n+\tcosts since the direction of movement is different.\n \n Sun Oct 31 23:57:07 1999  Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "46e61d2d33418ad442ec0ea68cab23828fb08cdd", "filename": "gcc/regclass.c", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da2c02192bfb2849b893b0c71e1b007db6426b7c/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da2c02192bfb2849b893b0c71e1b007db6426b7c/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=da2c02192bfb2849b893b0c71e1b007db6426b7c", "patch": "@@ -1160,6 +1160,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n       int alt_fail = 0;\n       int alt_cost = 0;\n       enum reg_class classes[MAX_RECOG_OPERANDS];\n+      int allows_mem[MAX_RECOG_OPERANDS];\n       int class;\n \n       for (i = 0; i < n_ops; i++)\n@@ -1168,12 +1169,12 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t  rtx op = ops[i];\n \t  enum machine_mode mode = modes[i];\n \t  int allows_addr = 0;\n-\t  int allows_mem = 0;\n \t  int win = 0;\n \t  unsigned char c;\n \n \t  /* Initially show we know nothing about the register class.  */\n \t  classes[i] = NO_REGS;\n+\t  allows_mem[i] = 0;\n \n \t  /* If this operand has no constraints at all, we can conclude \n \t     nothing about it since anything is valid.  */\n@@ -1196,8 +1197,12 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \n \t  if (p[0] >= '0' && p[0] <= '0' + i && (p[1] == ',' || p[1] == 0))\n \t    {\n+\t      /* Copy class and whether memory is allowed from the matching\n+\t\t alternative.  Then perform any needed cost computations\n+\t\t and/or adjustments.  */\n \t      j = p[0] - '0';\n \t      classes[i] = classes[j];\n+\t      allows_mem[i] = allows_mem[j];\n \n \t      if (GET_CODE (op) != REG || REGNO (op) < FIRST_PSEUDO_REGISTER)\n \t\t{\n@@ -1233,12 +1238,38 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t\t}\n \t      else\n \t\t{\n-\t\t  /* The costs of this operand are the same as that of the\n-\t\t     other operand.  However, if we cannot tie them, this\n-\t\t     alternative needs to do a copy, which is one\n-\t\t     instruction.  */\n+\t\t  /* The costs of this operand are not the same as the other\n+\t\t     operand since move costs are not symmetric.  Moreover,\n+\t\t     if we cannot tie them, this alternative needs to do a\n+\t\t     copy, which is one instruction.  */\n+\n+\t\t  struct costs *pp = &this_op_costs[i];\n+\n+\t\t  for (class = 0; class < N_REG_CLASSES; class++)\n+\t\t    pp->cost[class]\n+\t\t      = (recog_data.operand_type[i] == OP_IN\n+\t\t\t ? may_move_cost[class][(int) classes[i]]\n+\t\t\t : move_cost[(int) classes[i]][class]);\n+\t\t  \n+\t\t  /* If the alternative actually allows memory, make things\n+\t\t     a bit cheaper since we won't need an extra insn to\n+\t\t     load it.  */\n+\n+\t\t  pp->mem_cost\n+\t\t    = (MEMORY_MOVE_COST (mode, classes[i], \n+\t\t\t\t\t recog_data.operand_type[i] == OP_IN)\n+\t\t       - allows_mem[i]);\n+\n+\t\t  /* If we have assigned a class to this register in our\n+\t\t     first pass, add a cost to this alternative corresponding\n+\t\t     to what we would add if this register were not in the\n+\t\t     appropriate class.  */\n+\n+\t\t  if (prefclass)\n+\t\t    alt_cost\n+\t\t      += (may_move_cost[(unsigned char) prefclass[REGNO (op)]]\n+\t\t\t  [(int) classes[i]]);\n \n-\t\t  this_op_costs[i] = this_op_costs[j];\n \t\t  if (REGNO (ops[i]) != REGNO (ops[j])\n \t\t      && ! find_reg_note (insn, REG_DEAD, op))\n \t\t    alt_cost += 2;\n@@ -1287,7 +1318,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t      case 'm':  case 'o':  case 'V':\n \t\t/* It doesn't seem worth distinguishing between offsettable\n \t\t   and non-offsettable addresses here.  */\n-\t\tallows_mem = 1;\n+\t\tallows_mem[i] = 1;\n \t\tif (GET_CODE (op) == MEM)\n \t\t  win = 1;\n \t\tbreak;\n@@ -1388,7 +1419,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n #endif\n \t\t\t))\n \t\t  win = 1;\n-\t\tallows_mem = 1;\n+\t\tallows_mem[i] = 1;\n \t      case 'r':\n \t\tclasses[i]\n \t\t  = reg_class_subunion[(int) classes[i]][(int) GENERAL_REGS];\n@@ -1448,7 +1479,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t\t  pp->mem_cost\n \t\t    = (MEMORY_MOVE_COST (mode, classes[i], \n \t\t\t\t\t recog_data.operand_type[i] == OP_IN)\n-\t\t       - allows_mem);\n+\t\t       - allows_mem[i]);\n \n \t\t  /* If we have assigned a class to this register in our\n \t\t     first pass, add a cost to this alternative corresponding\n@@ -1486,7 +1517,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t  /* The only other way this alternative can be used is if this is a\n \t     constant that could be placed into memory.  */\n \n-\t  else if (CONSTANT_P (op) && (allows_addr || allows_mem))\n+\t  else if (CONSTANT_P (op) && (allows_addr || allows_mem[i]))\n \t    alt_cost += MEMORY_MOVE_COST (mode, classes[i], 1);\n \t  else\n \t    alt_fail = 1;\n@@ -1530,9 +1561,9 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t  int nr;\n \n \t  if (regno >= FIRST_PSEUDO_REGISTER && prefclass != 0\n-\t      && (reg_class_size[(unsigned char)prefclass[regno]]\n+\t      && (reg_class_size[(unsigned char) prefclass[regno]]\n \t\t  == CLASS_MAX_NREGS (prefclass[regno], mode)))\n-\t    op_costs[i].cost[(unsigned char)prefclass[regno]] = -1;\n+\t    op_costs[i].cost[(unsigned char) prefclass[regno]] = -1;\n \t  else if (regno < FIRST_PSEUDO_REGISTER)\n \t    for (class = 0; class < N_REG_CLASSES; class++)\n \t      if (TEST_HARD_REG_BIT (reg_class_contents[class], regno)"}]}