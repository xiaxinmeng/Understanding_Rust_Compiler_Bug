{"sha": "5bb1b56949670af2cbbdc4b6d769978515a979cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJiMWI1Njk0OTY3MGFmMmNiYmRjNGI2ZDc2OTk3ODUxNWE5NzljYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-03T20:17:16Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-03T20:17:16Z"}, "message": "cp-tree.h (finish_globally_qualified_member_call_expr): Rename to ...\n\n\t* cp-tree.h (finish_globally_qualified_member_call_expr):\n\tRename to ...\n\t(finish_qualified_call_expr).\n\t* semantics.c: Likewise.\n\t* parse.y (primary): Use it.\n\t* method.c (hack_identifier): Remove redundant code.\n\t* init.c (resolve_offset_ref): Call convert_from_reference to\n \thandle members of reference type.  Improve error recovery.\n\nFrom-SVN: r22224", "tree": {"sha": "28e2aedc4e9b35486b54be81eba8c1f68016e8eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28e2aedc4e9b35486b54be81eba8c1f68016e8eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bb1b56949670af2cbbdc4b6d769978515a979cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb1b56949670af2cbbdc4b6d769978515a979cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb1b56949670af2cbbdc4b6d769978515a979cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb1b56949670af2cbbdc4b6d769978515a979cb/comments", "author": null, "committer": null, "parents": [{"sha": "c6a54ad592ca215acc85adff4d616d91c0e7be63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6a54ad592ca215acc85adff4d616d91c0e7be63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6a54ad592ca215acc85adff4d616d91c0e7be63"}], "stats": {"total": 47, "additions": 24, "deletions": 23}, "files": [{"sha": "0c15675c736003230fbbe67240f800b45ba11d6c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bb1b56949670af2cbbdc4b6d769978515a979cb/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bb1b56949670af2cbbdc4b6d769978515a979cb/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=5bb1b56949670af2cbbdc4b6d769978515a979cb", "patch": "@@ -1798,7 +1798,9 @@ resolve_offset_ref (exp)\n \t  || (TREE_CODE (base) == NOP_EXPR\n \t      && TREE_OPERAND (base, 0) == error_mark_node)))\n     {\n-      tree basetype_path, access;\n+      tree basetype_path;\n+      tree access;\n+      tree expr;\n \n       if (TREE_CODE (exp) == OFFSET_REF && TREE_CODE (type) == OFFSET_TYPE)\n \tbasetype = TYPE_OFFSET_BASETYPE (type);\n@@ -1816,36 +1818,35 @@ resolve_offset_ref (exp)\n \t convert_pointer_to will bash it.  */\n       access = compute_access (basetype_path, member);\n       addr = convert_pointer_to (basetype, base);\n-      if (access == access_public_node)\n-\treturn build (COMPONENT_REF, TREE_TYPE (member),\n-\t\t      build_indirect_ref (addr, NULL_PTR), member);\n-      if (access == access_protected_node)\n-\t{\n-\t  cp_error_at (\"member `%D' is protected\", member);\n-\t  error (\"in this context\");\n-\t  return error_mark_node;\n-\t}\n-      if (access == access_private_node)\n+\n+      /* Issue errors if there was an access violation.  */\n+      if (access != access_public_node)\n \t{\n-\t  cp_error_at (\"member `%D' is private\", member);\n-\t  error (\"in this context\");\n-\t  return error_mark_node;\n-\t}\n-      my_friendly_abort (55);\n+\t  cp_error_at (\"member `%D' is %s\", \n+\t\t       access == access_private_node \n+\t\t       ? \"private\" : \"protected\",\n+\t\t       member);\n+\t  cp_error (\"in this context\");\n+\t} \n+\n+      /* Even in the case of illegal access, we form the\n+\t COMPONENT_REF; that will allow better error recovery than\n+\t just feeding back error_mark_node.  */\n+      expr = build (COMPONENT_REF, TREE_TYPE (member),\n+\t\t    build_indirect_ref (addr, NULL_PTR), member);\n+      return convert_from_reference (expr);\n     }\n \n   /* Ensure that we have an object.  */\n   if (TREE_CODE (base) == NOP_EXPR\n       && TREE_OPERAND (base, 0) == error_mark_node)\n     addr = error_mark_node;\n   else\n-    {\n-      /* If this is a reference to a member function, then return the\n-\t address of the member function (which may involve going\n-\t through the object's vtable), otherwise, return an expression\n-\t for the dereferenced pointer-to-member construct.  */\n-      addr = build_unary_op (ADDR_EXPR, base, 0);\n-    }\n+    /* If this is a reference to a member function, then return the\n+       address of the member function (which may involve going\n+       through the object's vtable), otherwise, return an expression\n+       for the dereferenced pointer-to-member construct.  */\n+    addr = build_unary_op (ADDR_EXPR, base, 0);\n \n   if (TREE_CODE (TREE_TYPE (member)) == OFFSET_TYPE)\n     {"}]}