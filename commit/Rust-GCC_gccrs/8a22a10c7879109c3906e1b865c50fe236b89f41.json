{"sha": "8a22a10c7879109c3906e1b865c50fe236b89f41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEyMmExMGM3ODc5MTA5YzM5MDZlMWI4NjVjNTBmZTIzNmI4OWY0MQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-16T15:14:36Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-17T00:07:40Z"}, "message": "Range_on_edge in ranger_cache should return true for all ranges.\n\nRange_on_edge was implemented in the cache to always return a range, but\nonly returned true when the edge actally changed the range.\nReturn true with any range that can be calculated.\n\n\t* gimple-range-cache.cc (ranger_cache::range_on_edge): Always return\n\ttrue when a range can be calculated.\n\t* gimple-range.cc (gimple_ranger::dump_bb): Check has_edge_range_p.", "tree": {"sha": "9ed502f14d93c4c7faf5bc29a22cfb907580c8fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ed502f14d93c4c7faf5bc29a22cfb907580c8fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a22a10c7879109c3906e1b865c50fe236b89f41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a22a10c7879109c3906e1b865c50fe236b89f41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a22a10c7879109c3906e1b865c50fe236b89f41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a22a10c7879109c3906e1b865c50fe236b89f41/comments", "author": null, "committer": null, "parents": [{"sha": "487be9201c96d0a5c7c325339bc9c4916e933ed8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/487be9201c96d0a5c7c325339bc9c4916e933ed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/487be9201c96d0a5c7c325339bc9c4916e933ed8"}], "stats": {"total": 17, "additions": 7, "deletions": 10}, "files": [{"sha": "cc2b7092dadd87d76ac15d7611ac012e18822ed1", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a22a10c7879109c3906e1b865c50fe236b89f41/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a22a10c7879109c3906e1b865c50fe236b89f41/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=8a22a10c7879109c3906e1b865c50fe236b89f41", "patch": "@@ -978,8 +978,7 @@ ranger_cache::range_of_expr (irange &r, tree name, gimple *stmt)\n }\n \n \n-// Implement range_on_edge. Return TRUE if the edge generates a range,\n-// otherwise false.. but still return a range.\n+// Implement range_on_edge.  Always return the best available range.\n \n  bool\n  ranger_cache::range_on_edge (irange &r, edge e, tree expr)\n@@ -989,14 +988,11 @@ ranger_cache::range_of_expr (irange &r, tree name, gimple *stmt)\n       exit_range (r, expr, e->src);\n       int_range_max edge_range;\n       if (m_gori.outgoing_edge_range_p (edge_range, e, expr, *this))\n-\t{\n-\t  r.intersect (edge_range);\n-\t  return true;\n-\t}\n+\tr.intersect (edge_range);\n+      return true;\n     }\n-  else\n-    get_tree_range (r, expr, NULL);\n-  return false;\n+\n+  return get_tree_range (r, expr, NULL);\n }\n \n "}, {"sha": "efb919f159554b68a0e8c980cef17afe70bf3844", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a22a10c7879109c3906e1b865c50fe236b89f41/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a22a10c7879109c3906e1b865c50fe236b89f41/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=8a22a10c7879109c3906e1b865c50fe236b89f41", "patch": "@@ -1394,7 +1394,8 @@ gimple_ranger::dump_bb (FILE *f, basic_block bb)\n       for (x = 1; x < num_ssa_names; x++)\n \t{\n \t  tree name = gimple_range_ssa_p (ssa_name (x));\n-\t  if (name && m_cache.range_on_edge (range, e, name))\n+\t  if (name && gori ().has_edge_range_p (name, e)\n+\t      && m_cache.range_on_edge (range, e, name))\n \t    {\n \t      gimple *s = SSA_NAME_DEF_STMT (name);\n \t      // Only print the range if this is the def block, or"}]}