{"sha": "519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5Y2FjNGE3YTZjYTVhMmU0ODcxYmIwNWYzYTRjODU0MjZlODI0OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-11-06T16:22:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-11-06T16:22:45Z"}, "message": "cfgloopanal.c (get_loop_hot_path): New function.\n\n\t* cfgloopanal.c (get_loop_hot_path): New function.\n\t* tree-ssa-lop-ivcanon.c (struct loop_size): Add CONSTANT_IV,\n\tNUM_NON_PURE_CALLS_ON_HOT_PATH, NUM_PURE_CALLS_ON_HOT_PATH,\n\tNUM_BRANCHES_ON_HOT_PATH.\n\t(tree_estimate_loop_size): Compute the new values.\n\t(try_unroll_loop_completely): Disable unrolling of loops with only\n\tcalls or too many branches.\n\t(tree_unroll_loops_completely): Deal also with outer loops of hot loops.\n\t* cfgloop.h (get_loop_hot_path): Declare.\n\t* params.def (PARAM_MAX_PEEL_BRANCHES): New parameters.\n\t* invoke.texi (max-peel-branches): Document.\n\n\t* gcc.dg/tree-ssa/loop-1.c: Make to look like a good unroling candidate still.\n\t* gcc.dg/tree-ssa/loop-23.c: Likewise.\n\t* gcc.dg/tree-ssa/cunroll-1.c: Unrolling now happens early.\n\t* gcc.dg/tree-prof/unroll-1.c: Remove confused dg-options.\n\nFrom-SVN: r193246", "tree": {"sha": "f6fbb89a772fc389ce8c8e8e32cde9cbd8d3a80a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6fbb89a772fc389ce8c8e8e32cde9cbd8d3a80a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "html_url": "https://github.com/Rust-GCC/gccrs/commit/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/comments", "author": null, "committer": null, "parents": [{"sha": "425b784f2c51079216d60b3e6a921470408326f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425b784f2c51079216d60b3e6a921470408326f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/425b784f2c51079216d60b3e6a921470408326f6"}], "stats": {"total": 257, "additions": 218, "deletions": 39}, "files": [{"sha": "5cd62b3d640e32d4bb8800a7c6c97e052c97a8ad", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "patch": "@@ -714,6 +714,7 @@ extern void doloop_optimize_loops (void);\n extern void move_loop_invariants (void);\n extern bool finite_loop_p (struct loop *);\n extern void scale_loop_profile (struct loop *loop, int scale, int iteration_bound);\n+extern VEC (basic_block, heap) * get_loop_hot_path (const struct loop *loop);\n \n /* Returns the outermost loop of the loop nest that contains LOOP.*/\n static inline struct loop *"}, {"sha": "ba7c262663521968cb1b7fa50bfec58d1cfe165c", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "patch": "@@ -483,3 +483,36 @@ single_likely_exit (struct loop *loop)\n   VEC_free (edge, heap, exits);\n   return found;\n }\n+\n+\n+/* Gets basic blocks of a LOOP.  Header is the 0-th block, rest is in dfs\n+   order against direction of edges from latch.  Specially, if\n+   header != latch, latch is the 1-st block.  */\n+\n+VEC (basic_block, heap) *\n+get_loop_hot_path (const struct loop *loop)\n+{\n+  basic_block bb = loop->header;\n+  VEC (basic_block, heap) *path = NULL;\n+  bitmap visited = BITMAP_ALLOC (NULL);\n+\n+  while (true)\n+    {\n+      edge_iterator ei;\n+      edge e;\n+      edge best = NULL;\n+\n+      VEC_safe_push (basic_block, heap, path, bb);\n+      bitmap_set_bit (visited, bb->index);\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+        if ((!best || e->probability > best->probability)\n+\t    && !loop_exit_edge_p (loop, e)\n+\t    && !bitmap_bit_p (visited, e->dest->index))\n+\t  best = e;\n+      if (!best || best->dest == loop->header)\n+\tbreak;\n+      bb = best->dest;\n+    }\n+  BITMAP_FREE (visited);\n+  return path;\n+}"}, {"sha": "73363a1a5a6c07de6333ad13a6e75b016ec1245d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "patch": "@@ -9085,6 +9085,9 @@ the loop code is peeled.\n @item max-peel-times\n The maximum number of peelings of a single loop.\n \n+@item max-peel-branches\n+The maximum number of branches on the hot path through the peeled sequence.\n+\n @item max-completely-peeled-insns\n The maximum number of insns of a completely peeled loop.\n "}, {"sha": "0ceb8a262630730074dba3cf794c7c2f439300e8", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "patch": "@@ -291,6 +291,11 @@ DEFPARAM(PARAM_MAX_PEEL_TIMES,\n \t\"max-peel-times\",\n \t\"The maximum number of peelings of a single loop\",\n \t16, 0, 0)\n+/* The maximum number of peelings of a single loop that is peeled completely.  */\n+DEFPARAM(PARAM_MAX_PEEL_BRANCHES,\n+\t\"max-peel-branches\",\n+\t\"The maximum number of branches on the path through the peeled sequence\",\n+\t32, 0, 0)\n /* The maximum number of insns of a peeled loop.  */\n DEFPARAM(PARAM_MAX_COMPLETELY_PEELED_INSNS,\n \t\"max-completely-peeled-insns\","}, {"sha": "be75f5374fd441aad791ed2b6cc4cbced01575fc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "patch": "@@ -1,3 +1,10 @@\n+2012-11-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-1.c: Make to look like a good unroling candidate still.\n+\t* gcc.dg/tree-ssa/loop-23.c: Likewise.\n+\t* gcc.dg/tree-ssa/cunroll-1.c: Unrolling now happens early.\n+\t* gcc.dg/tree-prof/unroll-1.c: Remove confused dg-options.\n+\n 2012-11-06  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* const-uniq-1.c: Expand regex to match AIX XCOFF labels."}, {"sha": "0b6e2ea13a8ee56eb427713c2156c7d2a15e7e6c", "filename": "gcc/testsuite/gcc.dg/tree-prof/unroll-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Funroll-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Funroll-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Funroll-1.c?ref=519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "patch": "@@ -21,4 +21,3 @@ main()\n }\n /* { dg-final-use { scan-rtl-dump \"Considering unrolling loop with constant number of iterations\" \"loop2_unroll\" } } */\n /* { dg-final-use { cleanup-rtl-dump \"Not unrolling loop, doesn't roll\" } } */\n-/* { dg-options \"-O3 -fdump-rtl-loop2_unroll -funroll-loops -fno-peel-loops\" } */"}, {"sha": "37d5ba10334653dbd3027c0811144b15e74e0037", "filename": "gcc/testsuite/gcc.dg/tree-ssa/cunroll-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcunroll-1.c?ref=519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -fdump-tree-cunroll-details\" } */\n+/* { dg-options \"-O3 -fdump-tree-cunrolli-details\" } */\n int a[2];\n test(int c)\n { \n@@ -10,4 +10,4 @@ test(int c)\n /* Array bounds says the loop will not roll much.  */\n /* { dg-final { scan-tree-dump \"Unrolled loop 1 completely .duplicated 1 times..\" \"cunroll\"} } */\n /* { dg-final { scan-tree-dump \"Last iteration exit edge was proved true.\" \"cunroll\"} } */\n-/* { dg-final { cleanup-tree-dump \"cunroll\" } } */\n+/* { dg-final { cleanup-tree-dump \"cunrolli\" } } */"}, {"sha": "35ff0be60facf2d1558d6d70f8745ce3d9c8f105", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-1.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c?ref=519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "patch": "@@ -17,13 +17,16 @@\n    to the load from the GOT this also contains the name of the funtion so for\n    each call the function name would appear twice.  */\n /* { dg-options \"-O1 -ftree-loop-ivcanon -funroll-loops -fdump-tree-ivcanon-details -fdump-tree-cunroll-details -fdump-tree-optimized -mno-relax-pic-calls\" { target mips*-*-* } } */\n-\n-void xxx(void)\n+__attribute__ ((pure))\n+int foo (int x);\n+int xxx(void)\n {\n   int x = 45;\n+  int sum;\n \n   while (x >>= 1)\n-    foo ();\n+    sum += foo (x) * 2;\n+  return sum;\n }\n \n /* We should be able to find out that the loop iterates four times and unroll it completely.  */"}, {"sha": "466d1758d1fed5f9c52f41bb7a42003a4a1f2ea6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-23.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-23.c?ref=519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "patch": "@@ -1,24 +1,27 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -funroll-loops -fdump-tree-cunroll-details\" } */\n \n-void bla(int);\n+__attribute__ ((pure))\n+int bla(int);\n \n-void foo(void)\n+int foo(void)\n {\n   int i;\n+  int sum;\n \n   /* This loop used to appear to be too large for unrolling.  */\n   for (i = 0; i < 4; i++)\n     {\n-      bla (i);\n-      bla (2*i);\n-      bla (3*i);\n-      bla (4*i);\n-      bla (5*i);\n-      bla (6*i);\n-      bla (7*i);\n-      bla (8*i);\n+      sum += bla (i);\n+      sum += bla (2*i);\n+      sum += bla (3*i);\n+      sum += bla (4*i);\n+      sum += bla (5*i);\n+      sum += bla (6*i);\n+      sum += bla (7*i);\n+      sum += bla (8*i);\n     }\n+  return sum;\n }\n \n /* { dg-final { scan-tree-dump-times \"Unrolled loop 1 completely\" 1 \"cunroll\" } } */"}, {"sha": "601223b3dda254a2dbf981dbc3a6330c47f0e9eb", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 148, "deletions": 23, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/519cac4a7a6ca5a2e4871bb05f3a4c85426e8248/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=519cac4a7a6ca5a2e4871bb05f3a4c85426e8248", "patch": "@@ -140,6 +140,20 @@ struct loop_size\n      instructions after exit are not executed.  */\n   int last_iteration;\n   int last_iteration_eliminated_by_peeling;\n+  \n+  /* If some IV computation will become constant.  */\n+  bool constant_iv;\n+\n+  /* Number of call stmts that are not a builtin and are pure or const\n+     present on the hot path.  */\n+  int num_pure_calls_on_hot_path;\n+  /* Number of call stmts that are not a builtin and are not pure nor const\n+     present on the hot path.  */\n+  int num_non_pure_calls_on_hot_path;\n+  /* Number of statements other than calls in the loop.  */\n+  int non_call_stmts_on_hot_path;\n+  /* Number of branches seen on the hot path.  */\n+  int num_branches_on_hot_path;\n };\n \n /* Return true if OP in STMT will be constant after peeling LOOP.  */\n@@ -188,7 +202,11 @@ constant_after_peeling (tree op, gimple stmt, struct loop *loop)\n   return true;\n }\n \n-/* Computes an estimated number of insns in LOOP, weighted by WEIGHTS.\n+/* Computes an estimated number of insns in LOOP.\n+   EXIT (if non-NULL) is an exite edge that will be eliminated in all but last\n+   iteration of the loop.\n+   EDGE_TO_CANCEL (if non-NULL) is an non-exit edge eliminated in the last iteration\n+   of loop.\n    Return results in SIZE, estimate benefits for complete unrolling exiting by EXIT.  */\n \n static void\n@@ -198,11 +216,17 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n   gimple_stmt_iterator gsi;\n   unsigned int i;\n   bool after_exit;\n+  VEC (basic_block, heap) *path = get_loop_hot_path (loop);\n \n   size->overall = 0;\n   size->eliminated_by_peeling = 0;\n   size->last_iteration = 0;\n   size->last_iteration_eliminated_by_peeling = 0;\n+  size->num_pure_calls_on_hot_path = 0;\n+  size->num_non_pure_calls_on_hot_path = 0;\n+  size->non_call_stmts_on_hot_path = 0;\n+  size->num_branches_on_hot_path = 0;\n+  size->constant_iv = 0;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Estimating sizes for loop %i\\n\", loop->num);\n@@ -221,6 +245,8 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n \t  gimple stmt = gsi_stmt (gsi);\n \t  int num = estimate_num_insns (stmt, &eni_size_weights);\n \t  bool likely_eliminated = false;\n+\t  bool likely_eliminated_last = false;\n+\t  bool likely_eliminated_peeled = false;\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -231,11 +257,21 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n \t  /* Look for reasons why we might optimize this stmt away. */\n \n \t  /* Exit conditional.  */\n-\t  if (exit && body[i] == exit->src && stmt == last_stmt (exit->src))\n+\t  if (exit && body[i] == exit->src\n+\t\t   && stmt == last_stmt (exit->src))\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t        fprintf (dump_file, \"   Exit condition will be eliminated.\\n\");\n-\t      likely_eliminated = true;\n+\t        fprintf (dump_file, \"   Exit condition will be eliminated \"\n+\t\t\t \"in peeled copies.\\n\");\n+\t      likely_eliminated_peeled = true;\n+\t    }\n+\t  else if (edge_to_cancel && body[i] == edge_to_cancel->src\n+\t\t   && stmt == last_stmt (edge_to_cancel->src))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t        fprintf (dump_file, \"   Exit condition will be eliminated \"\n+\t\t\t \"in last copy.\\n\");\n+\t      likely_eliminated_last = true;\n \t    }\n \t  /* Sets of IV variables  */\n \t  else if (gimple_code (stmt) == GIMPLE_ASSIGN\n@@ -249,36 +285,72 @@ tree_estimate_loop_size (struct loop *loop, edge exit, edge edge_to_cancel, stru\n \t  /* Assignments of IV variables.  */\n \t  else if (gimple_code (stmt) == GIMPLE_ASSIGN\n \t\t   && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n-\t\t   && constant_after_peeling (gimple_assign_rhs1 (stmt), stmt,loop)\n+\t\t   && constant_after_peeling (gimple_assign_rhs1 (stmt), stmt, loop)\n \t\t   && (gimple_assign_rhs_class (stmt) != GIMPLE_BINARY_RHS\n \t\t       || constant_after_peeling (gimple_assign_rhs2 (stmt),\n \t\t       \t\t\t\t  stmt, loop)))\n \t    {\n+\t      size->constant_iv = true;\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t        fprintf (dump_file, \"   Constant expression will be folded away.\\n\");\n \t      likely_eliminated = true;\n \t    }\n \t  /* Conditionals.  */\n-\t  else if (gimple_code (stmt) == GIMPLE_COND\n-\t\t   && constant_after_peeling (gimple_cond_lhs (stmt), stmt, loop)\n-\t\t   && constant_after_peeling (gimple_cond_rhs (stmt), stmt, loop))\n+\t  else if ((gimple_code (stmt) == GIMPLE_COND\n+\t\t    && constant_after_peeling (gimple_cond_lhs (stmt), stmt, loop)\n+\t\t    && constant_after_peeling (gimple_cond_rhs (stmt), stmt, loop))\n+\t\t   || (gimple_code (stmt) == GIMPLE_SWITCH\n+\t\t       && constant_after_peeling (gimple_switch_index (stmt), stmt, loop)))\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t        fprintf (dump_file, \"   Constant conditional.\\n\");\n \t      likely_eliminated = true;\n \t    }\n \n \t  size->overall += num;\n-\t  if (likely_eliminated)\n+\t  if (likely_eliminated || likely_eliminated_peeled)\n \t    size->eliminated_by_peeling += num;\n \t  if (!after_exit)\n \t    {\n \t      size->last_iteration += num;\n-\t      if (likely_eliminated)\n+\t      if (likely_eliminated || likely_eliminated_last)\n \t\tsize->last_iteration_eliminated_by_peeling += num;\n \t    }\n \t}\n     }\n+  while (VEC_length (basic_block, path))\n+    {\n+      basic_block bb = VEC_pop (basic_block, path);\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  if (gimple_code (stmt) == GIMPLE_CALL)\n+\t    {\n+\t      int flags = gimple_call_flags (stmt);\n+\t      tree decl = gimple_call_fndecl (stmt);\n+\n+\t      if (decl && DECL_IS_BUILTIN (decl)\n+\t\t  && is_inexpensive_builtin (decl))\n+\t\t;\n+\t      else if (flags & (ECF_PURE | ECF_CONST))\n+\t\tsize->num_pure_calls_on_hot_path++;\n+\t      else\n+\t\tsize->num_non_pure_calls_on_hot_path++;\n+\t      size->num_branches_on_hot_path ++;\n+\t    }\n+\t  else if (gimple_code (stmt) != GIMPLE_CALL\n+\t\t   && gimple_code (stmt) != GIMPLE_DEBUG)\n+\t    size->non_call_stmts_on_hot_path++;\n+\t  if (((gimple_code (stmt) == GIMPLE_COND\n+\t        && (!constant_after_peeling (gimple_cond_lhs (stmt), stmt, loop)\n+\t\t    || constant_after_peeling (gimple_cond_rhs (stmt), stmt, loop)))\n+\t       || (gimple_code (stmt) == GIMPLE_SWITCH\n+\t\t   && !constant_after_peeling (gimple_switch_index (stmt), stmt, loop)))\n+\t      && (!exit || bb != exit->src))\n+\t    size->num_branches_on_hot_path++;\n+\t}\n+    }\n+  VEC_free (basic_block, heap, path);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"size: %i-%i, last_iteration: %i-%i\\n\", size->overall,\n     \t     size->eliminated_by_peeling, size->last_iteration,\n@@ -644,34 +716,85 @@ try_unroll_loop_completely (struct loop *loop,\n \t\t   (int) unr_insns);\n \t}\n \n+      /* If the code is going to shrink, we don't need to be extra cautious\n+\t on guessing if the unrolling is going to be profitable.  */\n+      if (unr_insns\n+\t  /* If there is IV variable that will become constant, we save\n+\t     one instruction in the loop prologue we do not account\n+\t     otherwise.  */\n+\t  <= ninsns + (size.constant_iv != false))\n+\t;\n       /* We unroll only inner loops, because we do not consider it profitable\n \t otheriwse.  We still can cancel loopback edge of not rolling loop;\n \t this is always a good idea.  */\n-      if (loop->inner && unr_insns > ninsns)\n+      else if (ul == UL_NO_GROWTH)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Not unrolling loop %d: size would grow.\\n\",\n+\t\t     loop->num);\n+\t  return false;\n+\t}\n+      /* Outer loops tend to be less interesting candidates for complette\n+\t unrolling unless we can do a lot of propagation into the inner loop\n+\t body.  For now we disable outer loop unrolling when the code would\n+\t grow.  */\n+      else if (loop->inner)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d:\"\n+\t    fprintf (dump_file, \"Not unrolling loop %d: \"\n \t\t     \"it is not innermost and code would grow.\\n\",\n \t\t     loop->num);\n \t  return false;\n \t}\n-\n-      if (unr_insns > ninsns\n-\t  && (unr_insns\n-\t      > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS)))\n+      /* If there is call on a hot path through the loop, then\n+\t there is most probably not much to optimize.  */\n+      else if (size.num_non_pure_calls_on_hot_path)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d \"\n-\t\t     \"(--param max-completely-peeled-insns limit reached).\\n\",\n+\t    fprintf (dump_file, \"Not unrolling loop %d: \"\n+\t\t     \"contains call and code would grow.\\n\",\n \t\t     loop->num);\n \t  return false;\n \t}\n-\n-      if (ul == UL_NO_GROWTH\n-\t  && unr_insns > ninsns)\n+      /* If there is pure/const call in the function, then we\n+\t can still optimize the unrolled loop body if it contains\n+\t some other interesting code than the calls and code\n+\t storing or cumulating the return value.  */\n+      else if (size.num_pure_calls_on_hot_path\n+\t       /* One IV increment, one test, one ivtmp store\n+\t\t  and one usefull stmt.  That is about minimal loop\n+\t\t  doing pure call.  */\n+\t       && (size.non_call_stmts_on_hot_path\n+\t\t   <= 3 + size.num_pure_calls_on_hot_path))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Not unrolling loop %d: size would grow.\\n\",\n+\t    fprintf (dump_file, \"Not unrolling loop %d: \"\n+\t\t     \"contains just pure calls and code would grow.\\n\",\n+\t\t     loop->num);\n+\t  return false;\n+\t}\n+      /* Complette unrolling is major win when control flow is removed and\n+\t one big basic block is created.  If the loop contains control flow\n+\t the optimization may still be a win because of eliminating the loop\n+\t overhead but it also may blow the branch predictor tables.\n+\t Limit number of branches on the hot path through the peeled\n+\t sequence.  */\n+      else if (size.num_branches_on_hot_path * (int)n_unroll\n+\t       > PARAM_VALUE (PARAM_MAX_PEEL_BRANCHES))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Not unrolling loop %d: \"\n+\t\t     \" number of branches on hot path in the unrolled sequence\"\n+\t\t     \" reach --param max-peel-branches limit.\\n\",\n+\t\t     loop->num);\n+\t  return false;\n+\t}\n+      else if (unr_insns\n+\t       > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Not unrolling loop %d: \"\n+\t\t     \"(--param max-completely-peeled-insns limit reached).\\n\",\n \t\t     loop->num);\n \t  return false;\n \t}\n@@ -689,6 +812,8 @@ try_unroll_loop_completely (struct loop *loop,\n \t{\n           free_original_copy_tables ();\n \t  free (wont_exit);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Failed to duplicate the loop\\n\");\n \t  return false;\n \t}\n \n@@ -968,7 +1093,7 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t{\n \t  struct loop *loop_father = loop_outer (loop);\n \n-\t  if (may_increase_size && optimize_loop_for_speed_p (loop)\n+\t  if (may_increase_size && optimize_loop_nest_for_speed_p (loop)\n \t      /* Unroll outermost loops only if asked to do so or they do\n \t\t not cause code growth.  */\n \t      && (unroll_outer || loop_outer (loop_father)))"}]}