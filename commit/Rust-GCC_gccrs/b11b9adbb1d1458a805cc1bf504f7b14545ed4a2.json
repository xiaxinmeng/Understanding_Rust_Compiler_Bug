{"sha": "b11b9adbb1d1458a805cc1bf504f7b14545ed4a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjExYjlhZGJiMWQxNDU4YTgwNWNjMWJmNTA0ZjdiMTQ1NDVlZDRhMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-11T03:04:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-11T03:04:57Z"}, "message": "tree-ssa-threadupdate.c (mark_threaded_blocks): Truncate jump threading paths first, then perform PHI node checks if applicable.\n\n       * tree-ssa-threadupdate.c (mark_threaded_blocks): Truncate jump\n        threading paths first, then perform PHI node checks if applicable.\n\nFrom-SVN: r204659", "tree": {"sha": "4af2947b7146d03f44f8afafe633821b43f3b823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4af2947b7146d03f44f8afafe633821b43f3b823"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b11b9adbb1d1458a805cc1bf504f7b14545ed4a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11b9adbb1d1458a805cc1bf504f7b14545ed4a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b11b9adbb1d1458a805cc1bf504f7b14545ed4a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11b9adbb1d1458a805cc1bf504f7b14545ed4a2/comments", "author": null, "committer": null, "parents": [{"sha": "eef5b2855b9f72f1dccc9250aa818cb374d0f72e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef5b2855b9f72f1dccc9250aa818cb374d0f72e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eef5b2855b9f72f1dccc9250aa818cb374d0f72e"}], "stats": {"total": 89, "additions": 49, "deletions": 40}, "files": [{"sha": "ea7d382357a66848c1c6cb4d03eaa46af0b390d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b9adbb1d1458a805cc1bf504f7b14545ed4a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b9adbb1d1458a805cc1bf504f7b14545ed4a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b11b9adbb1d1458a805cc1bf504f7b14545ed4a2", "patch": "@@ -1,3 +1,8 @@\n+2013-11-08  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (mark_threaded_blocks): Truncate jump\n+\tthreading paths first, then perform PHI node checks if applicable.\n+\n 2013-11-10  Karlson2k  <k2k@narod.ru>\n             Kai Tietz  <ktietz@redhat.com>\n "}, {"sha": "ac0d2d3bdd6323a611c3ed5c9bc6fdde2706f231", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b9adbb1d1458a805cc1bf504f7b14545ed4a2/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b9adbb1d1458a805cc1bf504f7b14545ed4a2/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=b11b9adbb1d1458a805cc1bf504f7b14545ed4a2", "patch": "@@ -1269,46 +1269,6 @@ mark_threaded_blocks (bitmap threaded_blocks)\n       bitmap_set_bit (tmp, e->dest->index);\n     }\n \n-  /* If we have a joiner block (J) which has two successors S1 and S2 and\n-     we are threading though S1 and the final destination of the thread\n-     is S2, then we must verify that any PHI nodes in S2 have the same\n-     PHI arguments for the edge J->S2 and J->S1->...->S2.\n-\n-     We used to detect this prior to registering the jump thread, but\n-     that prohibits propagation of edge equivalences into non-dominated\n-     PHI nodes as the equivalency test might occur before propagation.\n-\n-     This works for now, but will need improvement as part of the FSA\n-     optimization.\n-\n-     Note since we've moved the thread request data to the edges,\n-     we have to iterate on those rather than the threaded_edges vector.  */\n-  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)\n-    {\n-      bb = BASIC_BLOCK (i);\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t{\n-\t  if (e->aux)\n-\t    {\n-\t      vec<jump_thread_edge *> *path = THREAD_PATH (e);\n-\t      bool have_joiner = ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK);\n-\n-\t      if (have_joiner)\n-\t\t{\n-\t\t  basic_block joiner = e->dest;\n-\t\t  edge final_edge = path->last ()->e;\n-\t\t  basic_block final_dest = final_edge->dest;\n-\t\t  edge e2 = find_edge (joiner, final_dest);\n-\n-\t\t  if (e2 && !phi_args_equal_on_edges (e2, final_edge))\n-\t\t    {\n-\t\t      delete_jump_thread_path (path);\n-\t\t      e->aux = NULL;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n \n \n   /* If optimizing for size, only thread through block if we don't have\n@@ -1398,6 +1358,50 @@ mark_threaded_blocks (bitmap threaded_blocks)\n \t}\n     }\n \n+  /* If we have a joiner block (J) which has two successors S1 and S2 and\n+     we are threading though S1 and the final destination of the thread\n+     is S2, then we must verify that any PHI nodes in S2 have the same\n+     PHI arguments for the edge J->S2 and J->S1->...->S2.\n+\n+     We used to detect this prior to registering the jump thread, but\n+     that prohibits propagation of edge equivalences into non-dominated\n+     PHI nodes as the equivalency test might occur before propagation.\n+\n+     This must also occur after we truncate any jump threading paths\n+     as this scenario may only show up after truncation.\n+\n+     This works for now, but will need improvement as part of the FSA\n+     optimization.\n+\n+     Note since we've moved the thread request data to the edges,\n+     we have to iterate on those rather than the threaded_edges vector.  */\n+  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)\n+    {\n+      bb = BASIC_BLOCK (i);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  if (e->aux)\n+\t    {\n+\t      vec<jump_thread_edge *> *path = THREAD_PATH (e);\n+\t      bool have_joiner = ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK);\n+\n+\t      if (have_joiner)\n+\t\t{\n+\t\t  basic_block joiner = e->dest;\n+\t\t  edge final_edge = path->last ()->e;\n+\t\t  basic_block final_dest = final_edge->dest;\n+\t\t  edge e2 = find_edge (joiner, final_dest);\n+\n+\t\t  if (e2 && !phi_args_equal_on_edges (e2, final_edge))\n+\t\t    {\n+\t\t      delete_jump_thread_path (path);\n+\t\t      e->aux = NULL;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   BITMAP_FREE (tmp);\n }\n "}]}