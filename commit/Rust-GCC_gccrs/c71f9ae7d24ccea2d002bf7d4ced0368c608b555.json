{"sha": "c71f9ae7d24ccea2d002bf7d4ced0368c608b555", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcxZjlhZTdkMjRjY2VhMmQwMDJiZjdkNGNlZDAzNjhjNjA4YjU1NQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2002-03-11T10:44:27Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2002-03-11T10:44:27Z"}, "message": "mmix.c (mmix_expand_builtin_va_arg): Do all computations on trees.\n\n\t* config/mmix/mmix.c (mmix_expand_builtin_va_arg): Do all\n\tcomputations on trees.\n\nFrom-SVN: r50567", "tree": {"sha": "75d37cfc4dc8eb63387b03703dfd5b57b1773fb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75d37cfc4dc8eb63387b03703dfd5b57b1773fb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c71f9ae7d24ccea2d002bf7d4ced0368c608b555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c71f9ae7d24ccea2d002bf7d4ced0368c608b555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c71f9ae7d24ccea2d002bf7d4ced0368c608b555", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c71f9ae7d24ccea2d002bf7d4ced0368c608b555/comments", "author": null, "committer": null, "parents": [{"sha": "5ddec02e71243ad4f96d11c58a280b42e7bc8b2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ddec02e71243ad4f96d11c58a280b42e7bc8b2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ddec02e71243ad4f96d11c58a280b42e7bc8b2e"}], "stats": {"total": 93, "additions": 62, "deletions": 31}, "files": [{"sha": "8bd8b905f83bc897be4cde5a63e062f34b14b42f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f9ae7d24ccea2d002bf7d4ced0368c608b555/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f9ae7d24ccea2d002bf7d4ced0368c608b555/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c71f9ae7d24ccea2d002bf7d4ced0368c608b555", "patch": "@@ -1,3 +1,8 @@\n+2002-03-11  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* config/mmix/mmix.c (mmix_expand_builtin_va_arg): Do all\n+\tcomputations on trees.\n+\n 2002-03-10  Richard Henderson  <rth@redhat.com>\n \n \t* reload.c (copy_replacements_1): New."}, {"sha": "6fe02275c6cc6729462e9c95ed3b5d593e67976b", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c71f9ae7d24ccea2d002bf7d4ced0368c608b555/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c71f9ae7d24ccea2d002bf7d4ced0368c608b555/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=c71f9ae7d24ccea2d002bf7d4ced0368c608b555", "patch": "@@ -1246,17 +1246,31 @@ mmix_expand_builtin_va_arg (valist, type)\n      tree valist;\n      tree type;\n {\n-  tree addr_tree, t;\n-  HOST_WIDE_INT align;\n-  HOST_WIDE_INT rounded_size;\n+  tree ptr_size = size_int (BITS_PER_WORD / BITS_PER_UNIT);\n+  tree addr_tree, type_size = NULL;\n+  tree align, alignm1;\n+  tree rounded_size;\n   rtx addr;\n \n   /* Compute the rounded size of the type.  */\n-  align = PARM_BOUNDARY / BITS_PER_UNIT;\n-  rounded_size = (((int_size_in_bytes (type) + align - 1) / align) * align);\n \n   /* Get AP.  */\n   addr_tree = valist;\n+  align = size_int (PARM_BOUNDARY / BITS_PER_UNIT);\n+  alignm1 = size_int (PARM_BOUNDARY / BITS_PER_UNIT - 1);\n+  if (type == error_mark_node\n+      || (type_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (type))) == NULL\n+      || TREE_OVERFLOW (type_size))\n+    /* Presumable an error; the size isn't computable.  A message has\n+       supposedly been emitted elsewhere.  */\n+    rounded_size = size_zero_node;\n+  else\n+    rounded_size = fold (build (MULT_EXPR, sizetype,\n+\t\t\t\tfold (build (TRUNC_DIV_EXPR, sizetype,\n+\t\t\t\t\t     fold (build (PLUS_EXPR, sizetype,\n+\t\t\t\t\t\t\t  type_size, alignm1)),\n+\t\t\t\t\t     align)),\n+\t\t\t\talign));\n \n  if (AGGREGATE_TYPE_P (type)\n      && GET_MODE_UNIT_SIZE (TYPE_MODE (type)) < 8\n@@ -1271,38 +1285,50 @@ mmix_expand_builtin_va_arg (valist, type)\n \tcheaper than a wider memory access on MMIX.)  */\n      addr_tree\n        = build (PLUS_EXPR, TREE_TYPE (addr_tree), addr_tree,\n-\t\tbuild_int_2 ((BITS_PER_WORD / BITS_PER_UNIT)\n-\t\t\t     - GET_MODE_UNIT_SIZE (TYPE_MODE (type)), 0));\n+\t\tsize_int ((BITS_PER_WORD / BITS_PER_UNIT)\n+\t\t\t  - GET_MODE_UNIT_SIZE (TYPE_MODE (type))));\n    }\n- else\n+ else if (!integer_zerop (rounded_size))\n    {\n-    HOST_WIDE_INT adj;\n-    adj = TREE_INT_CST_LOW (TYPE_SIZE (type)) / BITS_PER_UNIT;\n-    if (rounded_size > align)\n-      adj = rounded_size;\n-\n-    addr_tree = build (PLUS_EXPR, TREE_TYPE (addr_tree), addr_tree,\n-\t\t       build_int_2 (rounded_size - adj, 0));\n-\n-    /* If this type is larger than what fits in a register, then it is\n-       passed by reference.  */\n-    if (rounded_size > BITS_PER_WORD / BITS_PER_UNIT)\n-      {\n-\ttree type_ptr = build_pointer_type (type);\n-\taddr_tree = build1 (INDIRECT_REF, type_ptr, addr_tree);\n-      }\n-  }\n+     /* If the size is less than a register, the we need to pad the\n+        address by adding the difference.  */\n+     tree addend\n+       = fold (build (COND_EXPR, sizetype,\n+\t\t      fold (build (GT_EXPR, sizetype,\n+\t\t\t\t   rounded_size,\n+\t\t\t\t   align)),\n+\t\t      size_zero_node,\n+\t\t      fold (build (MINUS_EXPR, sizetype,\n+\t\t\t\t   rounded_size,\n+\t\t\t\t   type_size))));\n+     tree addr_tree1\n+       = fold (build (PLUS_EXPR, TREE_TYPE (addr_tree), addr_tree, addend));\n+\n+     /* If this type is larger than what fits in a register, then it is\n+\tpassed by reference.  */\n+     addr_tree\n+       = fold (build (COND_EXPR, TREE_TYPE (addr_tree1),\n+\t\t      fold (build (GT_EXPR, sizetype,\n+\t\t\t\t   rounded_size,\n+\t\t\t\t   ptr_size)),\n+\t\t      build1 (INDIRECT_REF, build_pointer_type (type),\n+\t\t\t      addr_tree1),\n+\t\t      addr_tree1));\n+   }\n \n   addr = expand_expr (addr_tree, NULL_RTX, Pmode, EXPAND_NORMAL);\n   addr = copy_to_reg (addr);\n \n-  /* Compute new value for AP.  For MMIX, it is always advanced by the\n-     size of a register.  */\n-  t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n-\t     build (PLUS_EXPR, TREE_TYPE (valist), valist,\n-\t\t    build_int_2 (BITS_PER_WORD / BITS_PER_UNIT, 0)));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+  if (!integer_zerop (rounded_size))\n+    {\n+      /* Compute new value for AP.  For MMIX, it is always advanced by the\n+\t size of a register.  */\n+      tree t = build (MODIFY_EXPR, TREE_TYPE (valist), valist,\n+\t\t      build (PLUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t\t     ptr_size));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n \n   return addr;\n }"}]}