{"sha": "fe1e7d0e9b7479f13b84670ac3b56cf5244d877c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUxZTdkMGU5Yjc0NzlmMTNiODQ2NzBhYzNiNTZjZjUyNDRkODc3Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-04-19T19:27:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-04-19T19:27:09Z"}, "message": "re PR tree-optimization/80426 (wrong manipulation of range based on INT_MIN)\n\n\tPR tree-optimization/80426\n\t* tree-vrp.c (extract_range_from_binary_expr_1): For an additive\n\toperation on symbolic operands, also compute the overflow for the\n\tinvariant part when the operation degenerates into a negation.\n\n\tPR tree-optimization/80426\n\t* gcc.c-torture/execute/20170419-1.c: New test.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r247007", "tree": {"sha": "e92d2d185b565e9dbbadd2eab3b245262ecb273f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e92d2d185b565e9dbbadd2eab3b245262ecb273f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c/comments", "author": null, "committer": null, "parents": [{"sha": "52744dd73c677f0fcbf80249af7b4163f72c3326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52744dd73c677f0fcbf80249af7b4163f72c3326", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52744dd73c677f0fcbf80249af7b4163f72c3326"}], "stats": {"total": 67, "additions": 65, "deletions": 2}, "files": [{"sha": "de76f8a83f467e31eeb3ea81cd6bbbcea0f2dfbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe1e7d0e9b7479f13b84670ac3b56cf5244d877c", "patch": "@@ -1,3 +1,11 @@\n+2017-04-19  Eric Botcazou  <ebotcazou@adacore.com>\n+            Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/80426\n+\t* tree-vrp.c (extract_range_from_binary_expr_1): For an additive\n+\toperation on symbolic operands, also compute the overflow for the\n+\tinvariant part when the operation degenerates into a negation.\n+\n 2017-04-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/80461"}, {"sha": "7c306a683e9c74326a64e7bb7fe9a35b994be7a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe1e7d0e9b7479f13b84670ac3b56cf5244d877c", "patch": "@@ -1,3 +1,8 @@\n+2017-04-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR tree-optimization/80426\n+\t* gcc.c-torture/execute/20170419-1.c: New test.\n+\n 2017-04-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/80461"}, {"sha": "f59dbc7a0578ea20277a7360ea7d2273a777c337", "filename": "gcc/testsuite/gcc.c-torture/execute/20170429-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20170429-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20170429-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20170429-1.c?ref=fe1e7d0e9b7479f13b84670ac3b56cf5244d877c", "patch": "@@ -0,0 +1,24 @@\n+/* PR tree-optimization/80426 */\n+/* Testcase by <ishiura-compiler@ml.kwansei.ac.jp> */\n+\n+#define INT_MAX 0x7fffffff\n+#define INT_MIN (-INT_MAX-1)\n+\n+int x;\n+\n+int main (void)\n+{\n+  volatile int a = 0;\n+  volatile int b = -INT_MAX;\n+  int j;\n+\n+  for(j = 0; j < 18; j += 1) {\n+    x = ( (a == 0) != (b - (int)(INT_MIN) ) );\n+  }\n+\n+  if (x != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "697cd88502ebdf0c02b6ee0961668e743ba0ca96", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe1e7d0e9b7479f13b84670ac3b56cf5244d877c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=fe1e7d0e9b7479f13b84670ac3b56cf5244d877c", "patch": "@@ -2461,7 +2461,20 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  else if (min_op0)\n \t    wmin = min_op0;\n \t  else if (min_op1)\n-\t    wmin = minus_p ? wi::neg (min_op1) : min_op1;\n+\t    {\n+\t      if (minus_p)\n+\t\t{\n+\t\t  wmin = wi::neg (min_op1);\n+\n+\t\t  /* Check for overflow.  */\n+\t\t  if (sgn == SIGNED && wi::neg_p (min_op1) && wi::neg_p (wmin))\n+\t\t    min_ovf = 1;\n+\t\t  else if (sgn == UNSIGNED && wi::ne_p (min_op1, 0))\n+\t\t    min_ovf = -1;\n+\t\t}\n+\t      else\n+\t\twmin = min_op1;\n+\t    }\n \t  else\n \t    wmin = wi::shwi (0, prec);\n \n@@ -2489,7 +2502,20 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t  else if (max_op0)\n \t    wmax = max_op0;\n \t  else if (max_op1)\n-\t    wmax = minus_p ? wi::neg (max_op1) : max_op1;\n+\t    {\n+\t      if (minus_p)\n+\t\t{\n+\t\t  wmax = wi::neg (max_op1);\n+\n+\t\t  /* Check for overflow.  */\n+\t\t  if (sgn == SIGNED && wi::neg_p (max_op1) && wi::neg_p (wmax))\n+\t\t    max_ovf = 1;\n+\t\t  else if (sgn == UNSIGNED && wi::ne_p (max_op1, 0))\n+\t\t    max_ovf = -1;\n+\t\t}\n+\t      else\n+\t\twmax = max_op1;\n+\t    }\n \t  else\n \t    wmax = wi::shwi (0, prec);\n "}]}