{"sha": "e3783e8274f7fc016571db56b094e2de0ef5e327", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM3ODNlODI3NGY3ZmMwMTY1NzFkYjU2YjA5NGUyZGUwZWY1ZTMyNw==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2012-08-30T10:17:04Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2012-08-30T10:17:04Z"}, "message": "re PR target/54252 (Bad alignment code generated for Neon loads)\n\nFix PR target/54252\n\n2012-08-29  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n\t    Richard Earnshaw  <richard.earnshaw@arm.com>\n\n\tPR target/54252\n\t* config/arm/arm.c (neon_dereference_pointer): Adjust nelems by\n\telement size. Use elem_type from the formal parameter. New parameter\n\tfcode.\n\t(neon_expand_args): Adjust call to neon_dereference_pointer.\n\n\n\nCo-Authored-By: Richard Earnshaw <rearnsha@arm.com>\n\nFrom-SVN: r190800", "tree": {"sha": "2b61475065519a54bc50167a19e2c1ddf8d8b179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b61475065519a54bc50167a19e2c1ddf8d8b179"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3783e8274f7fc016571db56b094e2de0ef5e327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3783e8274f7fc016571db56b094e2de0ef5e327", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3783e8274f7fc016571db56b094e2de0ef5e327", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3783e8274f7fc016571db56b094e2de0ef5e327/comments", "author": null, "committer": null, "parents": [{"sha": "d53591084b51210385fb7ad2ea4d9441d6b0356c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d53591084b51210385fb7ad2ea4d9441d6b0356c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d53591084b51210385fb7ad2ea4d9441d6b0356c"}], "stats": {"total": 78, "additions": 48, "deletions": 30}, "files": [{"sha": "40a2444c1d8f68c83725dba7d4e29b862de5b4bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3783e8274f7fc016571db56b094e2de0ef5e327/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3783e8274f7fc016571db56b094e2de0ef5e327/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3783e8274f7fc016571db56b094e2de0ef5e327", "patch": "@@ -1,3 +1,12 @@\n+2012-08-29  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+\t    Richard Earnshaw  <richard.earnshaw@arm.com>\n+\n+\tPR target/54252\n+\t* config/arm/arm.c (neon_dereference_pointer): Adjust nelems by\n+\telement size. Use elem_type from the formal parameter. New parameter\n+\tfcode.\n+\t(neon_expand_args): Adjust call to neon_dereference_pointer.\n+\n 2012-08-29  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cfg.c (dump_bb_info): Print a newline if there were no edges to dump."}, {"sha": "381f05525fb7c7164f80bde895bb3931df37efeb", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3783e8274f7fc016571db56b094e2de0ef5e327/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3783e8274f7fc016571db56b094e2de0ef5e327/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e3783e8274f7fc016571db56b094e2de0ef5e327", "patch": "@@ -20351,12 +20351,13 @@ typedef enum {\n    and return an expression for the accessed memory.\n \n    The intrinsic function operates on a block of registers that has\n-   mode REG_MODE.  This block contains vectors of type TYPE_MODE.\n-   The function references the memory at EXP in mode MEM_MODE;\n-   this mode may be BLKmode if no more suitable mode is available.  */\n+   mode REG_MODE.  This block contains vectors of type TYPE_MODE.  The\n+   function references the memory at EXP of type TYPE and in mode\n+   MEM_MODE; this mode may be BLKmode if no more suitable mode is\n+   available.  */\n \n static tree\n-neon_dereference_pointer (tree exp, enum machine_mode mem_mode,\n+neon_dereference_pointer (tree exp, tree type, enum machine_mode mem_mode,\n \t\t\t  enum machine_mode reg_mode,\n \t\t\t  neon_builtin_type_mode type_mode)\n {\n@@ -20374,18 +20375,18 @@ neon_dereference_pointer (tree exp, enum machine_mode mem_mode,\n   gcc_assert (reg_size % vector_size == 0);\n   nvectors = reg_size / vector_size;\n \n+  /* Work out the type of each element.  */\n+  gcc_assert (POINTER_TYPE_P (type));\n+  elem_type = TREE_TYPE (type);\n+\n   /* Work out how many elements are being loaded or stored.\n      MEM_MODE == REG_MODE implies a one-to-one mapping between register\n      and memory elements; anything else implies a lane load or store.  */\n   if (mem_mode == reg_mode)\n-    nelems = vector_size * nvectors;\n+    nelems = vector_size * nvectors / int_size_in_bytes (elem_type);\n   else\n     nelems = nvectors;\n \n-  /* Work out the type of each element.  */\n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (exp)));\n-  elem_type = TREE_TYPE (TREE_TYPE (exp));\n-\n   /* Create a type that describes the full access.  */\n   upper_bound = build_int_cst (size_type_node, nelems - 1);\n   array_type = build_array_type (elem_type, build_index_type (upper_bound));\n@@ -20399,12 +20400,14 @@ neon_dereference_pointer (tree exp, enum machine_mode mem_mode,\n static rtx\n arm_expand_neon_args (rtx target, int icode, int have_retval,\n \t\t      neon_builtin_type_mode type_mode,\n-\t\t      tree exp, ...)\n+\t\t      tree exp, int fcode, ...)\n {\n   va_list ap;\n   rtx pat;\n   tree arg[NEON_MAX_BUILTIN_ARGS];\n   rtx op[NEON_MAX_BUILTIN_ARGS];\n+  tree arg_type;\n+  tree formals;\n   enum machine_mode tmode = insn_data[icode].operand[0].mode;\n   enum machine_mode mode[NEON_MAX_BUILTIN_ARGS];\n   enum machine_mode other_mode;\n@@ -20417,7 +20420,9 @@ arm_expand_neon_args (rtx target, int icode, int have_retval,\n \t  || !(*insn_data[icode].operand[0].predicate) (target, tmode)))\n     target = gen_reg_rtx (tmode);\n \n-  va_start (ap, exp);\n+  va_start (ap, fcode);\n+\n+  formals = TYPE_ARG_TYPES (TREE_TYPE (arm_builtin_decls[fcode]));\n \n   for (;;)\n     {\n@@ -20430,12 +20435,15 @@ arm_expand_neon_args (rtx target, int icode, int have_retval,\n           opno = argc + have_retval;\n           mode[argc] = insn_data[icode].operand[opno].mode;\n           arg[argc] = CALL_EXPR_ARG (exp, argc);\n+\t  arg_type = TREE_VALUE (formals);\n           if (thisarg == NEON_ARG_MEMORY)\n             {\n               other_mode = insn_data[icode].operand[1 - opno].mode;\n-              arg[argc] = neon_dereference_pointer (arg[argc], mode[argc],\n-                                                    other_mode, type_mode);\n+              arg[argc] = neon_dereference_pointer (arg[argc], arg_type,\n+\t\t\t\t\t\t    mode[argc], other_mode,\n+\t\t\t\t\t\t    type_mode);\n             }\n+\n           op[argc] = expand_normal (arg[argc]);\n \n           switch (thisarg)\n@@ -20472,6 +20480,7 @@ arm_expand_neon_args (rtx target, int icode, int have_retval,\n             }\n \n           argc++;\n+\t  formals = TREE_CHAIN (formals);\n         }\n     }\n \n@@ -20554,7 +20563,7 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n     case NEON_UNOP:\n     case NEON_CONVERT:\n     case NEON_DUPLANE:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT, NEON_ARG_STOP);\n \n     case NEON_BINOP:\n@@ -20564,89 +20573,89 @@ arm_expand_neon_builtin (int fcode, tree exp, rtx target)\n     case NEON_SCALARMULH:\n     case NEON_SHIFTINSERT:\n     case NEON_LOGICBINOP:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n         NEON_ARG_STOP);\n \n     case NEON_TERNOP:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n         NEON_ARG_CONSTANT, NEON_ARG_STOP);\n \n     case NEON_GETLANE:\n     case NEON_FIXCONV:\n     case NEON_SHIFTIMM:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT, NEON_ARG_CONSTANT,\n         NEON_ARG_STOP);\n \n     case NEON_CREATE:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n \n     case NEON_DUP:\n     case NEON_SPLIT:\n     case NEON_REINTERP:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n \n     case NEON_COMBINE:\n     case NEON_VTBL:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n \n     case NEON_RESULTPAIR:\n-      return arm_expand_neon_args (target, icode, 0, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 0, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n         NEON_ARG_STOP);\n \n     case NEON_LANEMUL:\n     case NEON_LANEMULL:\n     case NEON_LANEMULH:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n         NEON_ARG_CONSTANT, NEON_ARG_STOP);\n \n     case NEON_LANEMAC:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n         NEON_ARG_CONSTANT, NEON_ARG_CONSTANT, NEON_ARG_STOP);\n \n     case NEON_SHIFTACC:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n         NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n         NEON_ARG_CONSTANT, NEON_ARG_STOP);\n \n     case NEON_SCALARMAC:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n \tNEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n         NEON_ARG_CONSTANT, NEON_ARG_STOP);\n \n     case NEON_SELECT:\n     case NEON_VTBX:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n \tNEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG, NEON_ARG_COPY_TO_REG,\n         NEON_ARG_STOP);\n \n     case NEON_LOAD1:\n     case NEON_LOADSTRUCT:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n \tNEON_ARG_MEMORY, NEON_ARG_STOP);\n \n     case NEON_LOAD1LANE:\n     case NEON_LOADSTRUCTLANE:\n-      return arm_expand_neon_args (target, icode, 1, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 1, type_mode, exp, fcode,\n \tNEON_ARG_MEMORY, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n \tNEON_ARG_STOP);\n \n     case NEON_STORE1:\n     case NEON_STORESTRUCT:\n-      return arm_expand_neon_args (target, icode, 0, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 0, type_mode, exp, fcode,\n \tNEON_ARG_MEMORY, NEON_ARG_COPY_TO_REG, NEON_ARG_STOP);\n \n     case NEON_STORE1LANE:\n     case NEON_STORESTRUCTLANE:\n-      return arm_expand_neon_args (target, icode, 0, type_mode, exp,\n+      return arm_expand_neon_args (target, icode, 0, type_mode, exp, fcode,\n \tNEON_ARG_MEMORY, NEON_ARG_COPY_TO_REG, NEON_ARG_CONSTANT,\n \tNEON_ARG_STOP);\n     }"}]}