{"sha": "d08d49885a1a07dd93fa036e37412324e8b710bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA4ZDQ5ODg1YTFhMDdkZDkzZmEwMzZlMzc0MTIzMjRlOGI3MTBiZg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2009-07-27T09:24:41Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-07-27T09:24:41Z"}, "message": "re PR libfortran/40863 (Build failure in libgfortran)\n\n2009-07-27  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/40863\n        * c99_functions.c: Define complex I, if not defined.\n        Create prototypes for C99 functions to silence warnings.\n        * gfortran.map: Add missing functions to GFORTRAN_C99_1.0\n        and new GFORTRAN_C99_1.1.\n\nFrom-SVN: r150107", "tree": {"sha": "178e2dda764f0a27af158a04fb042f24fd7fd347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/178e2dda764f0a27af158a04fb042f24fd7fd347"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d08d49885a1a07dd93fa036e37412324e8b710bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08d49885a1a07dd93fa036e37412324e8b710bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d08d49885a1a07dd93fa036e37412324e8b710bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08d49885a1a07dd93fa036e37412324e8b710bf/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b89636ea4caf4f0c911c4149fac09d24e0e29c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b89636ea4caf4f0c911c4149fac09d24e0e29c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b89636ea4caf4f0c911c4149fac09d24e0e29c4"}], "stats": {"total": 433, "additions": 332, "deletions": 101}, "files": [{"sha": "aec14276fbeb4b8724b4206095559f0267ee743b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d49885a1a07dd93fa036e37412324e8b710bf/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d49885a1a07dd93fa036e37412324e8b710bf/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d08d49885a1a07dd93fa036e37412324e8b710bf", "patch": "@@ -1,3 +1,11 @@\n+2009-07-27  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/40863\n+\t* c99_functions.c: Define complex I, if not defined.\n+\tCreate prototypes for C99 functions to silence warnings.\n+\t* gfortran.map: Add missing functions to GFORTRAN_C99_1.0\n+\tand new GFORTRAN_C99_1.1.\n+\n 2009-07-25  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/33197"}, {"sha": "4b7a1ed7c4716e0052eb5421fbcbf90fe574021e", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d49885a1a07dd93fa036e37412324e8b710bf/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d49885a1a07dd93fa036e37412324e8b710bf/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=d08d49885a1a07dd93fa036e37412324e8b710bf", "patch": "@@ -1206,13 +1206,20 @@ GFORTRAN_C99_1.0 {\n     jnf;\n     lgamma;\n     lgammaf;\n+    llround;\n+    llroundf;\n+    llroundl;\n     log10f;\n     log10l;\n     logf;\n+    lround;\n+    lroundf;\n+    lroundl;\n     nextafterf;\n     powf;\n     round;\n     roundf;\n+    roundl;\n     scalbn;\n     scalbnf;\n     sinf;\n@@ -1228,3 +1235,25 @@ GFORTRAN_C99_1.0 {\n     y1f;\n     ynf;\n };\n+\n+GFORTRAN_C99_1.1 {\n+  global:\n+    cacos;\n+    cacosf;\n+    cacosh;\n+    cacoshf;\n+    cacoshl;\n+    cacosl;\n+    casin;\n+    casinf;\n+    casinh;\n+    casinhf;\n+    casinhl;\n+    casinl;\n+    catan;\n+    catanf;\n+    catanh;\n+    catanhf;\n+    catanhl;\n+    catanl;\n+} GFORTRAN_C99_1.0;"}, {"sha": "03bcbfedaa642de6c3633115979f5282b602ef10", "filename": "libgfortran/intrinsics/c99_functions.c", "status": "modified", "additions": 295, "deletions": 101, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d49885a1a07dd93fa036e37412324e8b710bf/libgfortran%2Fintrinsics%2Fc99_functions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d49885a1a07dd93fa036e37412324e8b710bf/libgfortran%2Fintrinsics%2Fc99_functions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fc99_functions.c?ref=d08d49885a1a07dd93fa036e37412324e8b710bf", "patch": "@@ -54,27 +54,28 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define cabsl __gfc_cabsl\n #endif\n \n-/* Prototypes to silence -Wstrict-prototypes -Wmissing-prototypes.  */\n-\n-float cabsf(float complex);\n-double cabs(double complex);\n-long double cabsl(long double complex);\n-\n-float cargf(float complex);\n-double carg(double complex);\n-long double cargl(long double complex);\n+/* On a C99 system \"I\" (with I*I = -1) should be defined in complex.h;\n+   if not, we define a fallback version here.  */\n+#ifndef I\n+# if defined(_Imaginary_I)\n+#   define I _Imaginary_I\n+# elif defined(_Complex_I)\n+#   define I _Complex_I\n+# else\n+#   define I (1.0fi)\n+# endif\n+#endif\n \n-float complex clog10f(float complex);\n-double complex clog10(double complex);\n-long double complex clog10l(long double complex);\n+/* Prototypes are included to silence -Wstrict-prototypes\n+   -Wmissing-prototypes.  */\n \n \n /* Wrappers for systems without the various C99 single precision Bessel\n    functions.  */\n \n #if defined(HAVE_J0) && ! defined(HAVE_J0F)\n #define HAVE_J0F 1\n-extern float j0f (float);\n+float j0f (float);\n \n float\n j0f (float x)\n@@ -85,7 +86,7 @@ j0f (float x)\n \n #if defined(HAVE_J1) && !defined(HAVE_J1F)\n #define HAVE_J1F 1\n-extern float j1f (float);\n+float j1f (float);\n \n float j1f (float x)\n {\n@@ -95,7 +96,7 @@ float j1f (float x)\n \n #if defined(HAVE_JN) && !defined(HAVE_JNF)\n #define HAVE_JNF 1\n-extern float jnf (int, float);\n+float jnf (int, float);\n \n float\n jnf (int n, float x)\n@@ -106,7 +107,7 @@ jnf (int n, float x)\n \n #if defined(HAVE_Y0) && !defined(HAVE_Y0F)\n #define HAVE_Y0F 1\n-extern float y0f (float);\n+float y0f (float);\n \n float\n y0f (float x)\n@@ -117,7 +118,7 @@ y0f (float x)\n \n #if defined(HAVE_Y1) && !defined(HAVE_Y1F)\n #define HAVE_Y1F 1\n-extern float y1f (float);\n+float y1f (float);\n \n float\n y1f (float x)\n@@ -128,7 +129,7 @@ y1f (float x)\n \n #if defined(HAVE_YN) && !defined(HAVE_YNF)\n #define HAVE_YNF 1\n-extern float ynf (int, float);\n+float ynf (int, float);\n \n float\n ynf (int n, float x)\n@@ -142,7 +143,7 @@ ynf (int n, float x)\n \n #if defined(HAVE_ERF) && !defined(HAVE_ERFF)\n #define HAVE_ERFF 1\n-extern float erff (float);\n+float erff (float);\n \n float\n erff (float x)\n@@ -153,7 +154,7 @@ erff (float x)\n \n #if defined(HAVE_ERFC) && !defined(HAVE_ERFCF)\n #define HAVE_ERFCF 1\n-extern float erfcf (float);\n+float erfcf (float);\n \n float\n erfcf (float x)\n@@ -165,14 +166,18 @@ erfcf (float x)\n \n #ifndef HAVE_ACOSF\n #define HAVE_ACOSF 1\n+float acosf (float x);\n+\n float\n-acosf(float x)\n+acosf (float x)\n {\n-  return (float) acos(x);\n+  return (float) acos (x);\n }\n #endif\n \n #if HAVE_ACOSH && !HAVE_ACOSHF\n+float acoshf (float x);\n+\n float\n acoshf (float x)\n {\n@@ -182,14 +187,18 @@ acoshf (float x)\n \n #ifndef HAVE_ASINF\n #define HAVE_ASINF 1\n+float asinf (float x);\n+\n float\n-asinf(float x)\n+asinf (float x)\n {\n-  return (float) asin(x);\n+  return (float) asin (x);\n }\n #endif\n \n #if HAVE_ASINH && !HAVE_ASINHF\n+float asinhf (float x);\n+\n float\n asinhf (float x)\n {\n@@ -199,23 +208,29 @@ asinhf (float x)\n \n #ifndef HAVE_ATAN2F\n #define HAVE_ATAN2F 1\n+float atan2f (float y, float x);\n+\n float\n-atan2f(float y, float x)\n+atan2f (float y, float x)\n {\n-  return (float) atan2(y, x);\n+  return (float) atan2 (y, x);\n }\n #endif\n \n #ifndef HAVE_ATANF\n #define HAVE_ATANF 1\n+float atanf (float x);\n+\n float\n-atanf(float x)\n+atanf (float x)\n {\n-  return (float) atan(x);\n+  return (float) atan (x);\n }\n #endif\n \n #if HAVE_ATANH && !HAVE_ATANHF\n+float atanhf (float x);\n+\n float\n atanhf (float x)\n {\n@@ -225,69 +240,85 @@ atanhf (float x)\n \n #ifndef HAVE_CEILF\n #define HAVE_CEILF 1\n+float ceilf (float x);\n+\n float\n-ceilf(float x)\n+ceilf (float x)\n {\n-  return (float) ceil(x);\n+  return (float) ceil (x);\n }\n #endif\n \n #ifndef HAVE_COPYSIGNF\n #define HAVE_COPYSIGNF 1\n+float copysignf (float x, float y);\n+\n float\n-copysignf(float x, float y)\n+copysignf (float x, float y)\n {\n-  return (float) copysign(x, y);\n+  return (float) copysign (x, y);\n }\n #endif\n \n #ifndef HAVE_COSF\n #define HAVE_COSF 1\n+float cosf (float x);\n+\n float\n-cosf(float x)\n+cosf (float x)\n {\n-  return (float) cos(x);\n+  return (float) cos (x);\n }\n #endif\n \n #ifndef HAVE_COSHF\n #define HAVE_COSHF 1\n+float coshf (float x);\n+\n float\n-coshf(float x)\n+coshf (float x)\n {\n-  return (float) cosh(x);\n+  return (float) cosh (x);\n }\n #endif\n \n #ifndef HAVE_EXPF\n #define HAVE_EXPF 1\n+float expf (float x);\n+\n float\n-expf(float x)\n+expf (float x)\n {\n-  return (float) exp(x);\n+  return (float) exp (x);\n }\n #endif\n \n #ifndef HAVE_FABSF\n #define HAVE_FABSF 1\n+float fabsf (float x);\n+\n float\n-fabsf(float x)\n+fabsf (float x)\n {\n-  return (float) fabs(x);\n+  return (float) fabs (x);\n }\n #endif\n \n #ifndef HAVE_FLOORF\n #define HAVE_FLOORF 1\n+float floorf (float x);\n+\n float\n-floorf(float x)\n+floorf (float x)\n {\n-  return (float) floor(x);\n+  return (float) floor (x);\n }\n #endif\n \n #ifndef HAVE_FMODF\n #define HAVE_FMODF 1\n+float fmodf (float x, float y);\n+\n float\n fmodf (float x, float y)\n {\n@@ -297,111 +328,135 @@ fmodf (float x, float y)\n \n #ifndef HAVE_FREXPF\n #define HAVE_FREXPF 1\n+float frexpf (float x, int *exp);\n+\n float\n-frexpf(float x, int *exp)\n+frexpf (float x, int *exp)\n {\n-  return (float) frexp(x, exp);\n+  return (float) frexp (x, exp);\n }\n #endif\n \n #ifndef HAVE_HYPOTF\n #define HAVE_HYPOTF 1\n+float hypotf (float x, float y);\n+\n float\n-hypotf(float x, float y)\n+hypotf (float x, float y)\n {\n-  return (float) hypot(x, y);\n+  return (float) hypot (x, y);\n }\n #endif\n \n #ifndef HAVE_LOGF\n #define HAVE_LOGF 1\n+float logf (float x);\n+\n float\n-logf(float x)\n+logf (float x)\n {\n-  return (float) log(x);\n+  return (float) log (x);\n }\n #endif\n \n #ifndef HAVE_LOG10F\n #define HAVE_LOG10F 1\n+float log10f (float x);\n+\n float\n-log10f(float x)\n+log10f (float x)\n {\n-  return (float) log10(x);\n+  return (float) log10 (x);\n }\n #endif\n \n #ifndef HAVE_SCALBN\n #define HAVE_SCALBN 1\n+double scalbn (double x, int y);\n+\n double\n-scalbn(double x, int y)\n+scalbn (double x, int y)\n {\n #if (FLT_RADIX == 2) && defined(HAVE_LDEXP)\n   return ldexp (x, y);\n #else\n-  return x * pow(FLT_RADIX, y);\n+  return x * pow (FLT_RADIX, y);\n #endif\n }\n #endif\n \n #ifndef HAVE_SCALBNF\n #define HAVE_SCALBNF 1\n+float scalbnf (float x, int y);\n+\n float\n-scalbnf(float x, int y)\n+scalbnf (float x, int y)\n {\n-  return (float) scalbn(x, y);\n+  return (float) scalbn (x, y);\n }\n #endif\n \n #ifndef HAVE_SINF\n #define HAVE_SINF 1\n+float sinf (float x);\n+\n float\n-sinf(float x)\n+sinf (float x)\n {\n-  return (float) sin(x);\n+  return (float) sin (x);\n }\n #endif\n \n #ifndef HAVE_SINHF\n #define HAVE_SINHF 1\n+float sinhf (float x);\n+\n float\n-sinhf(float x)\n+sinhf (float x)\n {\n-  return (float) sinh(x);\n+  return (float) sinh (x);\n }\n #endif\n \n #ifndef HAVE_SQRTF\n #define HAVE_SQRTF 1\n+float sqrtf (float x);\n+\n float\n-sqrtf(float x)\n+sqrtf (float x)\n {\n-  return (float) sqrt(x);\n+  return (float) sqrt (x);\n }\n #endif\n \n #ifndef HAVE_TANF\n #define HAVE_TANF 1\n+float tanf (float x);\n+\n float\n-tanf(float x)\n+tanf (float x)\n {\n-  return (float) tan(x);\n+  return (float) tan (x);\n }\n #endif\n \n #ifndef HAVE_TANHF\n #define HAVE_TANHF 1\n+float tanhf (float x);\n+\n float\n-tanhf(float x)\n+tanhf (float x)\n {\n-  return (float) tanh(x);\n+  return (float) tanh (x);\n }\n #endif\n \n #ifndef HAVE_TRUNC\n #define HAVE_TRUNC 1\n+double trunc (double x);\n+\n double\n-trunc(double x)\n+trunc (double x)\n {\n   if (!isfinite (x))\n     return x;\n@@ -415,8 +470,10 @@ trunc(double x)\n \n #ifndef HAVE_TRUNCF\n #define HAVE_TRUNCF 1\n+float truncf (float x);\n+\n float\n-truncf(float x)\n+truncf (float x)\n {\n   return (float) trunc (x);\n }\n@@ -427,15 +484,17 @@ truncf(float x)\n /* This is a portable implementation of nextafterf that is intended to be\n    independent of the floating point format or its in memory representation.\n    This implementation works correctly with denormalized values.  */\n+float nextafterf (float x, float y);\n+\n float\n-nextafterf(float x, float y)\n+nextafterf (float x, float y)\n {\n   /* This variable is marked volatile to avoid excess precision problems\n      on some platforms, including IA-32.  */\n   volatile float delta;\n   float absx, denorm_min;\n \n-  if (isnan(x) || isnan(y))\n+  if (isnan (x) || isnan (y))\n     return x + y;\n   if (x == y)\n     return x;\n@@ -490,10 +549,12 @@ nextafterf(float x, float y)\n #ifndef HAVE_POWF\n #define HAVE_POWF 1\n #endif\n+float powf (float x, float y);\n+\n float\n-powf(float x, float y)\n+powf (float x, float y)\n {\n-  return (float) pow(x, y);\n+  return (float) pow (x, y);\n }\n #endif\n \n@@ -503,27 +564,29 @@ powf(float x, float y)\n \n #if !defined(HAVE_ROUNDL)\n #define HAVE_ROUNDL 1\n+long double roundl (long double x);\n+\n #if defined(HAVE_CEILL)\n /* Round to nearest integral value.  If the argument is halfway between two\n    integral values then round away from zero.  */\n \n long double\n-roundl(long double x)\n+roundl (long double x)\n {\n    long double t;\n    if (!isfinite (x))\n      return (x);\n \n    if (x >= 0.0)\n     {\n-      t = ceill(x);\n+      t = ceill (x);\n       if (t - x > 0.5)\n \tt -= 1.0;\n       return (t);\n     } \n    else \n     {\n-      t = ceill(-x);\n+      t = ceill (-x);\n       if (t + x > 0.5)\n \tt -= 1.0;\n       return (-t);\n@@ -533,7 +596,7 @@ roundl(long double x)\n \n /* Poor version of roundl for system that don't have ceill.  */\n long double\n-roundl(long double x)\n+roundl (long double x)\n {\n   if (x > DBL_MAX || x < -DBL_MAX)\n     {\n@@ -546,7 +609,7 @@ roundl(long double x)\n     }\n   else\n     /* Use round().  */\n-    return round((double) x);\n+    return round ((double) x);\n }\n \n #endif\n@@ -556,24 +619,25 @@ roundl(long double x)\n #define HAVE_ROUND 1\n /* Round to nearest integral value.  If the argument is halfway between two\n    integral values then round away from zero.  */\n+double round (double x);\n \n double\n-round(double x)\n+round (double x)\n {\n    double t;\n    if (!isfinite (x))\n      return (x);\n \n    if (x >= 0.0) \n     {\n-      t = floor(x);\n+      t = floor (x);\n       if (t - x <= -0.5)\n \tt += 1.0;\n       return (t);\n     } \n    else \n     {\n-      t = floor(-x);\n+      t = floor (-x);\n       if (t + x <= -0.5)\n \tt += 1.0;\n       return (-t);\n@@ -585,24 +649,25 @@ round(double x)\n #define HAVE_ROUNDF 1\n /* Round to nearest integral value.  If the argument is halfway between two\n    integral values then round away from zero.  */\n+float roundf (float x);\n \n float\n-roundf(float x)\n+roundf (float x)\n {\n    float t;\n    if (!isfinite (x))\n      return (x);\n \n    if (x >= 0.0) \n     {\n-      t = floorf(x);\n+      t = floorf (x);\n       if (t - x <= -0.5)\n \tt += 1.0;\n       return (t);\n     } \n    else \n     {\n-      t = floorf(-x);\n+      t = floorf (-x);\n       if (t + x <= -0.5)\n \tt += 1.0;\n       return (-t);\n@@ -615,6 +680,8 @@ roundf(float x)\n \n #if !defined(HAVE_LROUNDF) && defined(HAVE_ROUNDF)\n #define HAVE_LROUNDF 1\n+long int lroundf (float x);\n+\n long int\n lroundf (float x)\n {\n@@ -624,6 +691,8 @@ lroundf (float x)\n \n #if !defined(HAVE_LROUND) && defined(HAVE_ROUND)\n #define HAVE_LROUND 1\n+long int lround (double x);\n+\n long int\n lround (double x)\n {\n@@ -633,6 +702,8 @@ lround (double x)\n \n #if !defined(HAVE_LROUNDL) && defined(HAVE_ROUNDL)\n #define HAVE_LROUNDL 1\n+long int lroundl (long double x);\n+\n long int\n lroundl (long double x)\n {\n@@ -642,6 +713,8 @@ lroundl (long double x)\n \n #if !defined(HAVE_LLROUNDF) && defined(HAVE_ROUNDF)\n #define HAVE_LLROUNDF 1\n+long long int llroundf (float x);\n+\n long long int\n llroundf (float x)\n {\n@@ -651,6 +724,8 @@ llroundf (float x)\n \n #if !defined(HAVE_LLROUND) && defined(HAVE_ROUND)\n #define HAVE_LLROUND 1\n+long long int llround (double x);\n+\n long long int\n llround (double x)\n {\n@@ -660,6 +735,8 @@ llround (double x)\n \n #if !defined(HAVE_LLROUNDL) && defined(HAVE_ROUNDL)\n #define HAVE_LLROUNDL 1\n+long long int llroundl (long double x);\n+\n long long int\n llroundl (long double x)\n {\n@@ -672,8 +749,10 @@ llroundl (long double x)\n #define HAVE_LOG10L 1\n /* log10 function for long double variables. The version provided here\n    reduces the argument until it fits into a double, then use log10.  */\n+long double log10l (long double x);\n+\n long double\n-log10l(long double x)\n+log10l (long double x)\n {\n #if LDBL_MAX_EXP > DBL_MAX_EXP\n   if (x > DBL_MAX)\n@@ -699,7 +778,7 @@ log10l(long double x)\n       if (x < 0x1p-4093L) { p2_result += 4093; x /= 0x1p-4093L; }\n       if (x < 0x1p-2045L) { p2_result += 2045; x /= 0x1p-2045L; }\n       if (x < 0x1p-1021L) { p2_result += 1021; x /= 0x1p-1021L; }\n-      val = fabs(log10 ((double) x));\n+      val = fabs (log10 ((double) x));\n       return (- val - p2_result * .30102999566398119521373889472449302L);\n     }\n #endif\n@@ -710,6 +789,8 @@ log10l(long double x)\n \n #ifndef HAVE_FLOORL\n #define HAVE_FLOORL 1\n+long double floorl (long double x);\n+\n long double\n floorl (long double x)\n {\n@@ -736,6 +817,8 @@ floorl (long double x)\n \n #ifndef HAVE_FMODL\n #define HAVE_FMODL 1\n+long double fmodl (long double x, long double y);\n+\n long double\n fmodl (long double x, long double y)\n {\n@@ -751,6 +834,8 @@ fmodl (long double x, long double y)\n \n #if !defined(HAVE_CABSF)\n #define HAVE_CABSF 1\n+float cabsf (float complex z);\n+\n float\n cabsf (float complex z)\n {\n@@ -760,6 +845,8 @@ cabsf (float complex z)\n \n #if !defined(HAVE_CABS)\n #define HAVE_CABS 1\n+double cabs (double complex z);\n+\n double\n cabs (double complex z)\n {\n@@ -769,6 +856,8 @@ cabs (double complex z)\n \n #if !defined(HAVE_CABSL) && defined(HAVE_HYPOTL)\n #define HAVE_CABSL 1\n+long double cabsl (long double complex z);\n+\n long double\n cabsl (long double complex z)\n {\n@@ -779,6 +868,8 @@ cabsl (long double complex z)\n \n #if !defined(HAVE_CARGF)\n #define HAVE_CARGF 1\n+float cargf (float complex z);\n+\n float\n cargf (float complex z)\n {\n@@ -788,6 +879,8 @@ cargf (float complex z)\n \n #if !defined(HAVE_CARG)\n #define HAVE_CARG 1\n+double carg (double complex z);\n+\n double\n carg (double complex z)\n {\n@@ -797,6 +890,8 @@ carg (double complex z)\n \n #if !defined(HAVE_CARGL) && defined(HAVE_ATAN2L)\n #define HAVE_CARGL 1\n+long double cargl (long double complex z);\n+\n long double\n cargl (long double complex z)\n {\n@@ -808,6 +903,8 @@ cargl (long double complex z)\n /* exp(z) = exp(a)*(cos(b) + i sin(b))  */\n #if !defined(HAVE_CEXPF)\n #define HAVE_CEXPF 1\n+float complex cexpf (float complex z);\n+\n float complex\n cexpf (float complex z)\n {\n@@ -823,6 +920,8 @@ cexpf (float complex z)\n \n #if !defined(HAVE_CEXP)\n #define HAVE_CEXP 1\n+double complex cexp (double complex z);\n+\n double complex\n cexp (double complex z)\n {\n@@ -838,6 +937,8 @@ cexp (double complex z)\n \n #if !defined(HAVE_CEXPL) && defined(HAVE_COSL) && defined(HAVE_SINL) && defined(EXPL)\n #define HAVE_CEXPL 1\n+long double complex cexpl (long double complex z);\n+\n long double complex\n cexpl (long double complex z)\n {\n@@ -855,6 +956,8 @@ cexpl (long double complex z)\n /* log(z) = log (cabs(z)) + i*carg(z)  */\n #if !defined(HAVE_CLOGF)\n #define HAVE_CLOGF 1\n+float complex clogf (float complex z);\n+\n float complex\n clogf (float complex z)\n {\n@@ -867,6 +970,8 @@ clogf (float complex z)\n \n #if !defined(HAVE_CLOG)\n #define HAVE_CLOG 1\n+double complex clog (double complex z);\n+\n double complex\n clog (double complex z)\n {\n@@ -879,6 +984,8 @@ clog (double complex z)\n \n #if !defined(HAVE_CLOGL) && defined(HAVE_LOGL) && defined(HAVE_CABSL) && defined(HAVE_CARGL)\n #define HAVE_CLOGL 1\n+long double complex clogl (long double complex z);\n+\n long double complex\n clogl (long double complex z)\n {\n@@ -893,6 +1000,8 @@ clogl (long double complex z)\n /* log10(z) = log10 (cabs(z)) + i*carg(z)  */\n #if !defined(HAVE_CLOG10F)\n #define HAVE_CLOG10F 1\n+float complex clog10f (float complex z);\n+\n float complex\n clog10f (float complex z)\n {\n@@ -905,6 +1014,8 @@ clog10f (float complex z)\n \n #if !defined(HAVE_CLOG10)\n #define HAVE_CLOG10 1\n+double complex clog10 (double complex z);\n+\n double complex\n clog10 (double complex z)\n {\n@@ -917,6 +1028,8 @@ clog10 (double complex z)\n \n #if !defined(HAVE_CLOG10L) && defined(HAVE_LOG10L) && defined(HAVE_CABSL) && defined(HAVE_CARGL)\n #define HAVE_CLOG10L 1\n+long double complex clog10l (long double complex z);\n+\n long double complex\n clog10l (long double complex z)\n {\n@@ -931,6 +1044,8 @@ clog10l (long double complex z)\n /* pow(base, power) = cexp (power * clog (base))  */\n #if !defined(HAVE_CPOWF)\n #define HAVE_CPOWF 1\n+float complex cpowf (float complex base, float complex power);\n+\n float complex\n cpowf (float complex base, float complex power)\n {\n@@ -940,6 +1055,8 @@ cpowf (float complex base, float complex power)\n \n #if !defined(HAVE_CPOW)\n #define HAVE_CPOW 1\n+double complex cpow (double complex base, double complex power);\n+\n double complex\n cpow (double complex base, double complex power)\n {\n@@ -949,6 +1066,8 @@ cpow (double complex base, double complex power)\n \n #if !defined(HAVE_CPOWL) && defined(HAVE_CEXPL) && defined(HAVE_CLOGL)\n #define HAVE_CPOWL 1\n+long double complex cpowl (long double complex base, long double complex power);\n+\n long double complex\n cpowl (long double complex base, long double complex power)\n {\n@@ -960,6 +1079,8 @@ cpowl (long double complex base, long double complex power)\n /* sqrt(z).  Algorithm pulled from glibc.  */\n #if !defined(HAVE_CSQRTF)\n #define HAVE_CSQRTF 1\n+float complex csqrtf (float complex z);\n+\n float complex\n csqrtf (float complex z)\n {\n@@ -1013,6 +1134,8 @@ csqrtf (float complex z)\n \n #if !defined(HAVE_CSQRT)\n #define HAVE_CSQRT 1\n+double complex csqrt (double complex z);\n+\n double complex\n csqrt (double complex z)\n {\n@@ -1066,6 +1189,8 @@ csqrt (double complex z)\n \n #if !defined(HAVE_CSQRTL) && defined(HAVE_COPYSIGNL) && defined(HAVE_SQRTL) && defined(HAVE_FABSL) && defined(HAVE_HYPOTL)\n #define HAVE_CSQRTL 1\n+long double complex csqrtl (long double complex z);\n+\n long double complex\n csqrtl (long double complex z)\n {\n@@ -1121,6 +1246,8 @@ csqrtl (long double complex z)\n /* sinh(a + i b) = sinh(a) cos(b) + i cosh(a) sin(b)  */\n #if !defined(HAVE_CSINHF)\n #define HAVE_CSINHF 1\n+float complex csinhf (float complex a);\n+\n float complex\n csinhf (float complex a)\n {\n@@ -1136,6 +1263,8 @@ csinhf (float complex a)\n \n #if !defined(HAVE_CSINH)\n #define HAVE_CSINH 1\n+double complex csinh (double complex a);\n+\n double complex\n csinh (double complex a)\n {\n@@ -1151,6 +1280,8 @@ csinh (double complex a)\n \n #if !defined(HAVE_CSINHL) && defined(HAVE_COSL) && defined(HAVE_COSHL) && defined(HAVE_SINL) && defined(HAVE_SINHL)\n #define HAVE_CSINHL 1\n+long double complex csinhl (long double complex a);\n+\n long double complex\n csinhl (long double complex a)\n {\n@@ -1168,6 +1299,8 @@ csinhl (long double complex a)\n /* cosh(a + i b) = cosh(a) cos(b) + i sinh(a) sin(b)  */\n #if !defined(HAVE_CCOSHF)\n #define HAVE_CCOSHF 1\n+float complex ccoshf (float complex a);\n+\n float complex\n ccoshf (float complex a)\n {\n@@ -1183,6 +1316,8 @@ ccoshf (float complex a)\n \n #if !defined(HAVE_CCOSH)\n #define HAVE_CCOSH 1\n+double complex ccosh (double complex a);\n+\n double complex\n ccosh (double complex a)\n {\n@@ -1198,6 +1333,8 @@ ccosh (double complex a)\n \n #if !defined(HAVE_CCOSHL) && defined(HAVE_COSL) && defined(HAVE_COSHL) && defined(HAVE_SINL) && defined(HAVE_SINHL)\n #define HAVE_CCOSHL 1\n+long double complex ccoshl (long double complex a);\n+\n long double complex\n ccoshl (long double complex a)\n {\n@@ -1215,6 +1352,8 @@ ccoshl (long double complex a)\n /* tanh(a + i b) = (tanh(a) + i tan(b)) / (1 + i tanh(a) tan(b))  */\n #if !defined(HAVE_CTANHF)\n #define HAVE_CTANHF 1\n+float complex ctanhf (float complex a);\n+\n float complex\n ctanhf (float complex a)\n {\n@@ -1232,6 +1371,7 @@ ctanhf (float complex a)\n \n #if !defined(HAVE_CTANH)\n #define HAVE_CTANH 1\n+double complex ctanh (double complex a);\n double complex\n ctanh (double complex a)\n {\n@@ -1249,6 +1389,8 @@ ctanh (double complex a)\n \n #if !defined(HAVE_CTANHL) && defined(HAVE_TANL) && defined(HAVE_TANHL)\n #define HAVE_CTANHL 1\n+long double complex ctanhl (long double complex a);\n+\n long double complex\n ctanhl (long double complex a)\n {\n@@ -1268,6 +1410,8 @@ ctanhl (long double complex a)\n /* sin(a + i b) = sin(a) cosh(b) + i cos(a) sinh(b)  */\n #if !defined(HAVE_CSINF)\n #define HAVE_CSINF 1\n+float complex csinf (float complex a);\n+\n float complex\n csinf (float complex a)\n {\n@@ -1283,6 +1427,8 @@ csinf (float complex a)\n \n #if !defined(HAVE_CSIN)\n #define HAVE_CSIN 1\n+double complex csin (double complex a);\n+\n double complex\n csin (double complex a)\n {\n@@ -1298,6 +1444,8 @@ csin (double complex a)\n \n #if !defined(HAVE_CSINL) && defined(HAVE_COSL) && defined(HAVE_COSHL) && defined(HAVE_SINL) && defined(HAVE_SINHL)\n #define HAVE_CSINL 1\n+long double complex csinl (long double complex a);\n+\n long double complex\n csinl (long double complex a)\n {\n@@ -1315,6 +1463,8 @@ csinl (long double complex a)\n /* cos(a + i b) = cos(a) cosh(b) - i sin(a) sinh(b)  */\n #if !defined(HAVE_CCOSF)\n #define HAVE_CCOSF 1\n+float complex ccosf (float complex a);\n+\n float complex\n ccosf (float complex a)\n {\n@@ -1330,6 +1480,8 @@ ccosf (float complex a)\n \n #if !defined(HAVE_CCOS)\n #define HAVE_CCOS 1\n+double complex ccos (double complex a);\n+\n double complex\n ccos (double complex a)\n {\n@@ -1345,6 +1497,8 @@ ccos (double complex a)\n \n #if !defined(HAVE_CCOSL) && defined(HAVE_COSL) && defined(HAVE_COSHL) && defined(HAVE_SINL) && defined(HAVE_SINHL)\n #define HAVE_CCOSL 1\n+long double complex ccosl (long double complex a);\n+\n long double complex\n ccosl (long double complex a)\n {\n@@ -1362,6 +1516,8 @@ ccosl (long double complex a)\n /* tan(a + i b) = (tan(a) + i tanh(b)) / (1 - i tan(a) tanh(b))  */\n #if !defined(HAVE_CTANF)\n #define HAVE_CTANF 1\n+float complex ctanf (float complex a);\n+\n float complex\n ctanf (float complex a)\n {\n@@ -1379,6 +1535,8 @@ ctanf (float complex a)\n \n #if !defined(HAVE_CTAN)\n #define HAVE_CTAN 1\n+double complex ctan (double complex a);\n+\n double complex\n ctan (double complex a)\n {\n@@ -1396,6 +1554,8 @@ ctan (double complex a)\n \n #if !defined(HAVE_CTANL) && defined(HAVE_TANL) && defined(HAVE_TANHL)\n #define HAVE_CTANL 1\n+long double complex ctanl (long double complex a);\n+\n long double complex\n ctanl (long double complex a)\n {\n@@ -1417,6 +1577,8 @@ ctanl (long double complex a)\n \n #if !defined(HAVE_CASINF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n #define HAVE_CASINF 1\n+complex float casinf (complex float z);\n+\n complex float\n casinf (complex float z)\n {\n@@ -1427,6 +1589,8 @@ casinf (complex float z)\n \n #if !defined(HAVE_CASIN) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n #define HAVE_CASIN 1\n+complex double casin (complex double z);\n+\n complex double\n casin (complex double z)\n {\n@@ -1437,6 +1601,8 @@ casin (complex double z)\n \n #if !defined(HAVE_CASINL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n #define HAVE_CASINL 1\n+complex long double casinl (complex long double z);\n+\n complex long double\n casinl (complex long double z)\n {\n@@ -1450,17 +1616,21 @@ casinl (complex long double z)\n \n #if !defined(HAVE_CACOSF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n #define HAVE_CACOSF 1\n+complex float cacosf (complex float z);\n+\n complex float\n cacosf (complex float z)\n {\n-  return -I*clogf (z + I*csqrtf(1.0f-z*z));\n+  return -I*clogf (z + I*csqrtf (1.0f-z*z));\n }\n #endif\n \n \n-complex double\n #if !defined(HAVE_CACOS) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n #define HAVE_CACOS 1\n+complex double cacos (complex double z);\n+\n+complex double\n cacos (complex double z)\n {\n   return -I*clog (z + I*csqrt (1.0-z*z));\n@@ -1470,6 +1640,8 @@ cacos (complex double z)\n \n #if !defined(HAVE_CACOSL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n #define HAVE_CACOSL 1\n+complex long double cacosl (complex long double z);\n+\n complex long double\n cacosl (complex long double z)\n {\n@@ -1483,6 +1655,8 @@ cacosl (complex long double z)\n \n #if !defined(HAVE_CATANF) && defined(HAVE_CLOGF)\n #define HAVE_CACOSF 1\n+complex float catanf (complex float z);\n+\n complex float\n catanf (complex float z)\n {\n@@ -1493,6 +1667,8 @@ catanf (complex float z)\n \n #if !defined(HAVE_CATAN) && defined(HAVE_CLOG)\n #define HAVE_CACOS 1\n+complex double catan (complex double z);\n+\n complex double\n catan (complex double z)\n {\n@@ -1503,6 +1679,8 @@ catan (complex double z)\n \n #if !defined(HAVE_CATANL) && defined(HAVE_CLOGL)\n #define HAVE_CACOSL 1\n+complex long double catanl (complex long double z);\n+\n complex long double\n catanl (complex long double z)\n {\n@@ -1516,6 +1694,8 @@ catanl (complex long double z)\n \n #if !defined(HAVE_CASINHF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n #define HAVE_CASINHF 1\n+complex float casinhf (complex float z);\n+\n complex float\n casinhf (complex float z)\n {\n@@ -1526,6 +1706,8 @@ casinhf (complex float z)\n \n #if !defined(HAVE_CASINH) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n #define HAVE_CASINH 1\n+complex double casinh (complex double z);\n+\n complex double\n casinh (complex double z)\n {\n@@ -1536,6 +1718,8 @@ casinh (complex double z)\n \n #if !defined(HAVE_CASINHL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n #define HAVE_CASINHL 1\n+complex long double casinhl (complex long double z);\n+\n complex long double\n casinhl (complex long double z)\n {\n@@ -1549,6 +1733,8 @@ casinhl (complex long double z)\n \n #if !defined(HAVE_CACOSHF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n #define HAVE_CACOSHF 1\n+complex float cacoshf (complex float z);\n+\n complex float\n cacoshf (complex float z)\n {\n@@ -1559,6 +1745,8 @@ cacoshf (complex float z)\n \n #if !defined(HAVE_CACOSH) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n #define HAVE_CACOSH 1\n+complex double cacosh (complex double z);\n+\n complex double\n cacosh (complex double z)\n {\n@@ -1569,6 +1757,8 @@ cacosh (complex double z)\n \n #if !defined(HAVE_CACOSHL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n #define HAVE_CACOSHL 1\n+complex long double cacoshl (complex long double z);\n+\n complex long double\n cacoshl (complex long double z)\n {\n@@ -1582,6 +1772,8 @@ cacoshl (complex long double z)\n \n #if !defined(HAVE_CATANHF) && defined(HAVE_CLOGF)\n #define HAVE_CATANHF 1\n+complex float catanhf (complex float z);\n+\n complex float\n catanhf (complex float z)\n {\n@@ -1592,6 +1784,8 @@ catanhf (complex float z)\n \n #if !defined(HAVE_CATANH) && defined(HAVE_CLOG)\n #define HAVE_CATANH 1\n+complex double catanh (complex double z);\n+\n complex double\n catanh (complex double z)\n {\n@@ -1601,6 +1795,8 @@ catanh (complex double z)\n \n #if !defined(HAVE_CATANHL) && defined(HAVE_CLOGL)\n #define HAVE_CATANHL 1\n+complex long double catanhl (complex long double z);\n+\n complex long double\n catanhl (complex long double z)\n {\n@@ -1611,8 +1807,7 @@ catanhl (complex long double z)\n \n #if !defined(HAVE_TGAMMA)\n #define HAVE_TGAMMA 1\n-\n-extern double tgamma (double); \n+double tgamma (double); \n \n /* Fallback tgamma() function. Uses the algorithm from\n    http://www.netlib.org/specfun/gamma and references therein.  */\n@@ -1652,7 +1847,7 @@ tgamma (double x)\n   static double eps = 0;\n   \n   if (eps == 0)\n-    eps = nextafter(1., 2.) - 1.;\n+    eps = nextafter (1., 2.) - 1.;\n \n   parity = 0;\n   fact = 1;\n@@ -1665,14 +1860,14 @@ tgamma (double x)\n   if (y <= 0)\n     {\n       y = -x;\n-      y1 = trunc(y);\n+      y1 = trunc (y);\n       res = y - y1;\n \n       if (res != 0)\n \t{\n-\t  if (y1 != trunc(y1*0.5l)*2)\n+\t  if (y1 != trunc (y1*0.5l)*2)\n \t    parity = 1;\n-\t  fact = -PI / sin(PI*res);\n+\t  fact = -PI / sin (PI*res);\n \t  y = y + 1;\n \t}\n       else\n@@ -1730,8 +1925,8 @@ tgamma (double x)\n \t    sum = sum / ysq + c[i];\n \n \t  sum = sum/y - y + SQRTPI;\n-\t  sum = sum + (y - 0.5) * log(y);\n-\t  res = exp(sum);\n+\t  sum = sum + (y - 0.5) * log (y);\n+\t  res = exp (sum);\n \t}\n       else\n \treturn x < 0 ? xnan : xinf;\n@@ -1750,8 +1945,7 @@ tgamma (double x)\n \n #if !defined(HAVE_LGAMMA)\n #define HAVE_LGAMMA 1\n-\n-extern double lgamma (double); \n+double lgamma (double); \n \n /* Fallback lgamma() function. Uses the algorithm from\n    http://www.netlib.org/specfun/algama and references therein, \n@@ -1818,17 +2012,17 @@ lgamma (double y)\n   double corr, res, xden, xm1, xm2, xm4, xnum, ysq;\n \n   if (eps == 0)\n-    eps = __builtin_nextafter(1., 2.) - 1.;\n+    eps = __builtin_nextafter (1., 2.) - 1.;\n \n   if ((y > 0) && (y <= xbig))\n     {\n       if (y <= eps)\n-\tres = -log(y);\n+\tres = -log (y);\n       else if (y <= 1.5)\n \t{\n \t  if (y < PNT68)\n \t    {\n-\t      corr = -log(y);\n+\t      corr = -log (y);\n \t      xm1 = y;\n \t    }\n \t  else\n@@ -1896,7 +2090,7 @@ lgamma (double y)\n \t\tres = res / ysq + c[i];\n \t    }\n \t  res = res/y;\n-\t  corr = log(y);\n+\t  corr = log (y);\n \t  res = res + SQRTPI - 0.5*corr;\n \t  res = res + y*(corr-1);\n \t}\n@@ -1921,7 +2115,7 @@ lgamma (double y)\n \n #if defined(HAVE_TGAMMA) && !defined(HAVE_TGAMMAF)\n #define HAVE_TGAMMAF 1\n-extern float tgammaf (float);\n+float tgammaf (float);\n \n float\n tgammaf (float x)\n@@ -1932,7 +2126,7 @@ tgammaf (float x)\n \n #if defined(HAVE_LGAMMA) && !defined(HAVE_LGAMMAF)\n #define HAVE_LGAMMAF 1\n-extern float lgammaf (float);\n+float lgammaf (float);\n \n float\n lgammaf (float x)"}]}