{"sha": "5e4900c7f4945f48d9660d2682bbbcce40ec9603", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU0OTAwYzdmNDk0NWY0OGQ5NjYwZDI2ODJiYmJjY2U0MGVjOTYwMw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "2000-02-10T21:09:52Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2000-02-10T21:09:52Z"}, "message": "Fix ia64 compiler problem with gcc.c-torture/compile/920410-1.c.\n\n\t* expmed.c (store_bit_field): If op0 and fieldmode are the same size,\n\tthen store directly into op0.\n\nFrom-SVN: r31903", "tree": {"sha": "2bfa992d7cec6eee185fab9dd3f25a4da4b83169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bfa992d7cec6eee185fab9dd3f25a4da4b83169"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e4900c7f4945f48d9660d2682bbbcce40ec9603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e4900c7f4945f48d9660d2682bbbcce40ec9603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e4900c7f4945f48d9660d2682bbbcce40ec9603", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e4900c7f4945f48d9660d2682bbbcce40ec9603/comments", "author": null, "committer": null, "parents": [{"sha": "c2939b5700388b67a717e22580f2ac5c9314797e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2939b5700388b67a717e22580f2ac5c9314797e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2939b5700388b67a717e22580f2ac5c9314797e"}], "stats": {"total": 57, "additions": 29, "deletions": 28}, "files": [{"sha": "ccda7cdd4ba3bcac2898cc3fb40bd8c0d0072ac5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4900c7f4945f48d9660d2682bbbcce40ec9603/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4900c7f4945f48d9660d2682bbbcce40ec9603/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e4900c7f4945f48d9660d2682bbbcce40ec9603", "patch": "@@ -1,5 +1,8 @@\n Thu Feb 10 12:56:47 2000  Jim Wilson  <wilson@cygnus.com>\n \n+\t* expmed.c (store_bit_field): If op0 and fieldmode are the same size,\n+\tthen store directly into op0.\n+\n \t* calls.c (expand_call): When emitting a NOTE_INSN_SETJMP, search for\n \tthe CALL_INSN, and emit the note immediately after it.\n "}, {"sha": "6f31b8d9eb6d7da49b77662078bed8a721a94c24", "filename": "gcc/expmed.c", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e4900c7f4945f48d9660d2682bbbcce40ec9603/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e4900c7f4945f48d9660d2682bbbcce40ec9603/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=5e4900c7f4945f48d9660d2682bbbcce40ec9603", "patch": "@@ -291,16 +291,18 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   if (flag_force_mem)\n     value = force_not_mem (value);\n \n-  /* Note that the adjustment of BITPOS above has no effect on whether\n-     BITPOS is 0 in a REG bigger than a word.  */\n-  if (GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD\n+  if ((GET_MODE_SIZE (fieldmode) >= UNITS_PER_WORD\n+       || (GET_MODE_SIZE (GET_MODE (op0)) == GET_MODE_SIZE (fieldmode)\n+\t   && GET_MODE_SIZE (fieldmode) != 0))\n       && (GET_CODE (op0) != MEM\n \t  || ! SLOW_UNALIGNED_ACCESS (fieldmode, align)\n \t  || (offset * BITS_PER_UNIT % bitsize == 0\n \t      && align % GET_MODE_SIZE (fieldmode) == 0))\n-      && bitpos == 0 && bitsize == GET_MODE_BITSIZE (fieldmode))\n+      && (BYTES_BIG_ENDIAN ? bitpos + bitsize == unit : bitpos == 0)\n+      && bitsize == GET_MODE_BITSIZE (fieldmode))\n     {\n       /* Storing in a full-word or multi-word field in a register\n+\t can be done with just SUBREG.  Also, storing in the entire object\n \t can be done with just SUBREG.  */\n       if (GET_MODE (op0) != fieldmode)\n \t{\n@@ -332,10 +334,11 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   if (GET_CODE (op0) != MEM\n       && (BYTES_BIG_ENDIAN ? bitpos + bitsize == unit : bitpos == 0)\n       && bitsize == GET_MODE_BITSIZE (fieldmode)\n-      && (GET_MODE (op0) == fieldmode\n-\t  || (movstrict_optab->handlers[(int) fieldmode].insn_code\n-\t      != CODE_FOR_nothing)))\n+      && (movstrict_optab->handlers[(int) fieldmode].insn_code\n+\t  != CODE_FOR_nothing))\n     {\n+      int icode = movstrict_optab->handlers[(int) fieldmode].insn_code;\n+\n       /* Get appropriate low part of the value being stored.  */\n       if (GET_CODE (value) == CONST_INT || GET_CODE (value) == REG)\n \tvalue = gen_lowpart (fieldmode, value);\n@@ -344,30 +347,25 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t\t || GET_CODE (value) == CONST))\n \tvalue = convert_to_mode (fieldmode, value, 0);\n \n-      if (GET_MODE (op0) == fieldmode)\n-\temit_move_insn (op0, value);\n-      else\n+      if (! (*insn_data[icode].operand[1].predicate) (value, fieldmode))\n+\tvalue = copy_to_mode_reg (fieldmode, value);\n+\n+      if (GET_CODE (op0) == SUBREG)\n \t{\n-\t  int icode = movstrict_optab->handlers[(int) fieldmode].insn_code;\n-\t  if (! (*insn_data[icode].operand[1].predicate) (value, fieldmode))\n-\t    value = copy_to_mode_reg (fieldmode, value);\n+\t  if (GET_MODE (SUBREG_REG (op0)) == fieldmode\n+\t      || GET_MODE_CLASS (fieldmode) == MODE_INT\n+\t      || GET_MODE_CLASS (fieldmode) == MODE_PARTIAL_INT)\n+\t    op0 = SUBREG_REG (op0);\n+\t  else\n+\t    /* Else we've got some float mode source being extracted into\n+\t       a different float mode destination -- this combination of\n+\t       subregs results in Severe Tire Damage.  */\n+\t    abort ();\n+\t}\n \n-\t  if (GET_CODE (op0) == SUBREG)\n-\t    {\n-\t      if (GET_MODE (SUBREG_REG (op0)) == fieldmode\n-\t\t  || GET_MODE_CLASS (fieldmode) == MODE_INT\n-\t\t  || GET_MODE_CLASS (fieldmode) == MODE_PARTIAL_INT)\n-\t\top0 = SUBREG_REG (op0);\n-\t      else\n-\t\t/* Else we've got some float mode source being extracted into\n-\t\t   a different float mode destination -- this combination of\n-\t\t   subregs results in Severe Tire Damage.  */\n-\t\tabort ();\n-\t    }\n+      emit_insn (GEN_FCN (icode)\n+\t\t (gen_rtx_SUBREG (fieldmode, op0, offset), value));\n \n-\t  emit_insn (GEN_FCN (icode)\n-\t\t     (gen_rtx_SUBREG (fieldmode, op0, offset), value));\n-\t}\n       return value;\n     }\n "}]}