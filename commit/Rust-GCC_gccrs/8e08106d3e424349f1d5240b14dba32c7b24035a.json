{"sha": "8e08106d3e424349f1d5240b14dba32c7b24035a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUwODEwNmQzZTQyNDM0OWYxZDUyNDBiMTRkYmEzMmM3YjI0MDM1YQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-06-16T18:40:41Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-06-16T18:40:41Z"}, "message": "Use REG_SET macros\n\nFrom-SVN: r14250", "tree": {"sha": "7152aac86a8e6785646d9495a2de01b86387dcd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7152aac86a8e6785646d9495a2de01b86387dcd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e08106d3e424349f1d5240b14dba32c7b24035a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e08106d3e424349f1d5240b14dba32c7b24035a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e08106d3e424349f1d5240b14dba32c7b24035a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e08106d3e424349f1d5240b14dba32c7b24035a/comments", "author": null, "committer": null, "parents": [{"sha": "119f2738a65cad2dd277c5c86cd10efb3f503d73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/119f2738a65cad2dd277c5c86cd10efb3f503d73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/119f2738a65cad2dd277c5c86cd10efb3f503d73"}], "stats": {"total": 39, "additions": 12, "deletions": 27}, "files": [{"sha": "f563637b413058f29f08e739c100a78cc6ed49ac", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08106d3e424349f1d5240b14dba32c7b24035a/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08106d3e424349f1d5240b14dba32c7b24035a/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=8e08106d3e424349f1d5240b14dba32c7b24035a", "patch": "@@ -357,8 +357,7 @@ save_call_clobbered_regs (insn_mode)\n     {\n       regset regs_live = basic_block_live_at_start[b];\n       rtx prev_block_last = PREV_INSN (basic_block_head[b]);\n-      REGSET_ELT_TYPE bit;\n-      int offset, i, j;\n+      int i, j;\n       int regno;\n \n       /* Compute hard regs live at start of block -- this is the"}, {"sha": "5e32b5ce1fa96392b855515c3d415b9f01b62878", "filename": "gcc/combine.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08106d3e424349f1d5240b14dba32c7b24035a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08106d3e424349f1d5240b14dba32c7b24035a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8e08106d3e424349f1d5240b14dba32c7b24035a", "patch": "@@ -740,8 +740,7 @@ set_nonzero_bits_and_sign_copies (x, set)\n       && REGNO (x) >= FIRST_PSEUDO_REGISTER\n       /* If this register is undefined at the start of the file, we can't\n \t say what its contents were.  */\n-      && ! (basic_block_live_at_start[0][REGNO (x) / REGSET_ELT_BITS]\n-\t    & ((REGSET_ELT_TYPE) 1 << (REGNO (x) % REGSET_ELT_BITS)))\n+      && ! REGNO_REG_SET_P (basic_block_live_at_start[0], REGNO (x))\n       && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n     {\n       if (set == 0 || GET_CODE (set) == CLOBBER)\n@@ -2367,8 +2366,7 @@ try_combine (i3, i2, i1)\n \t    regno = REGNO (i2dest);\n \t    REG_N_SETS (regno)--;\n \t    if (REG_N_SETS (regno) == 0\n-\t\t&& ! (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n-\t\t      & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))))\n+\t\t&& ! REGNO_REG_SET_P (basic_block_live_at_start[0], regno))\n \t      REG_N_REFS (regno) = 0;\n \t  }\n       }\n@@ -2390,8 +2388,7 @@ try_combine (i3, i2, i1)\n \t  {\n \t    REG_N_SETS (regno)--;\n \t    if (REG_N_SETS (regno) == 0\n-\t\t&& ! (basic_block_live_at_start[0][regno / REGSET_ELT_BITS]\n-\t\t      & ((REGSET_ELT_TYPE) 1 << (regno % REGSET_ELT_BITS))))\n+\t\t&& ! REGNO_REG_SET_P (basic_block_live_at_start[0], regno))\n \t      REG_N_REFS (regno) = 0;\n \t  }\n       }\n@@ -10626,8 +10623,7 @@ reg_dead_at_p (reg, insn)\n     }\n \n   for (i = reg_dead_regno; i < reg_dead_endregno; i++)\n-    if (basic_block_live_at_start[block][i / REGSET_ELT_BITS]\n-\t& ((REGSET_ELT_TYPE) 1 << (i % REGSET_ELT_BITS)))\n+    if (REGNO_REG_SET_P (basic_block_live_at_start[block], i))\n       return 0;\n \n   return 1;"}, {"sha": "83cb08f4cfb3897ee5ecc6c30e77442d3ac0bc6d", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08106d3e424349f1d5240b14dba32c7b24035a/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08106d3e424349f1d5240b14dba32c7b24035a/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=8e08106d3e424349f1d5240b14dba32c7b24035a", "patch": "@@ -1181,8 +1181,7 @@ update_equiv_regs ()\n \t\t       && GET_CODE (insn) == INSN\n \t\t       && REG_BASIC_BLOCK (regno) < 0)\n \t\t{\n-\t\t  int l, offset;\n-\t\t  REGSET_ELT_TYPE bit;\n+\t\t  int l;\n \n \t\t  emit_insn_before (copy_rtx (PATTERN (equiv_insn)), insn);\n \t\t  REG_NOTES (PREV_INSN (insn)) = REG_NOTES (equiv_insn);\n@@ -1202,11 +1201,8 @@ update_equiv_regs ()\n \t\t  if (block >= 0 && insn == basic_block_head[block])\n \t\t    basic_block_head[block] = PREV_INSN (insn);\n \n-\t\t  offset = regno / REGSET_ELT_BITS;\n-\t\t  bit = ((REGSET_ELT_TYPE) 1\n-\t\t\t << (regno % REGSET_ELT_BITS));\n \t\t  for (l = 0; l < n_basic_blocks; l++)\n-\t\t    basic_block_live_at_start[l][offset] &= ~ bit;\n+\t\t    CLEAR_REGNO_REG_SET (basic_block_live_at_start[l], regno);\n \t\t}\n \t    }\n \t}\n@@ -1253,11 +1249,7 @@ block_alloc (b)\n \n   /* Initialize table of hardware registers currently live.  */\n \n-#ifdef HARD_REG_SET\n-  regs_live = *basic_block_live_at_start[b];\n-#else\n-  COPY_HARD_REG_SET (regs_live, basic_block_live_at_start[b]);\n-#endif\n+  REG_SET_TO_HARD_REG_SET (regs_live, basic_block_live_at_start[b]);\n \n   /* This loop scans the instructions of the basic block\n      and assigns quantities to registers."}, {"sha": "ca61d9731f403b440a17baab4120c2360cd48e65", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08106d3e424349f1d5240b14dba32c7b24035a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08106d3e424349f1d5240b14dba32c7b24035a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8e08106d3e424349f1d5240b14dba32c7b24035a", "patch": "@@ -2092,9 +2092,8 @@ reload (first, global, dumpfile)\n \n   if (! frame_pointer_needed)\n     for (i = 0; i < n_basic_blocks; i++)\n-      basic_block_live_at_start[i][HARD_FRAME_POINTER_REGNUM / REGSET_ELT_BITS]\n-\t&= ~ ((REGSET_ELT_TYPE) 1 << (HARD_FRAME_POINTER_REGNUM\n-\t\t\t\t      % REGSET_ELT_BITS));\n+      CLEAR_REGNO_REG_SET (basic_block_live_at_start[i],\n+\t\t\t   HARD_FRAME_POINTER_REGNUM);\n \n   /* Come here (with failure set nonzero) if we can't get enough spill regs\n      and we decide not to abort about it.  */"}, {"sha": "8b714688005704d90abc0840680e7aee293f2e15", "filename": "gcc/sched.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08106d3e424349f1d5240b14dba32c7b24035a/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08106d3e424349f1d5240b14dba32c7b24035a/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=8e08106d3e424349f1d5240b14dba32c7b24035a", "patch": "@@ -3436,9 +3436,8 @@ schedule_block (b, file)\n \n   if (reload_completed == 0)\n     {\n-      bcopy ((char *) basic_block_live_at_start[b], (char *) bb_live_regs,\n-\t     regset_bytes);\n-      bzero ((char *) bb_dead_regs, regset_bytes);\n+      COPY_REG_SET (bb_live_regs, basic_block_live_at_start[b]);\n+      CLEAR_REG_SET (bb_dead_regs);\n \n       if (b == 0)\n \t{"}]}