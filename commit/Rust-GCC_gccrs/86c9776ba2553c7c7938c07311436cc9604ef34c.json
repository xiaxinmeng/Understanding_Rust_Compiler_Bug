{"sha": "86c9776ba2553c7c7938c07311436cc9604ef34c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZjOTc3NmJhMjU1M2M3Yzc5MzhjMDczMTE0MzZjYzk2MDRlZjM0Yw==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2001-03-19T23:00:18Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2001-03-19T23:00:18Z"}, "message": "ArrayList.java: Remove RCS keywords from comments\n\n    * java/util/ArrayList.java: Remove RCS keywords from comments\n    * java/util/BasicMapEntry.java: idem\n    * java/util/Dictionary.java: idem\n    * java/util/HashSet.java: idem\n\n    * java/util/EventObject.java: reindent\n    * java/util/Properties.java: idem\n    * java/util/SortedMap.java: idem\n\n    * java/util/Enumeration.java: Merge with Classpath\n    * java/util/EventListener.java: idem\n    * java/util/Observable.java: idem\n    * java/util/Observer.java: idem\n    * java/util/Stack.java: idem\n\nFrom-SVN: r40639", "tree": {"sha": "7dec6e26617e4428705145d0bc5c6d8cefc82726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7dec6e26617e4428705145d0bc5c6d8cefc82726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86c9776ba2553c7c7938c07311436cc9604ef34c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c9776ba2553c7c7938c07311436cc9604ef34c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86c9776ba2553c7c7938c07311436cc9604ef34c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86c9776ba2553c7c7938c07311436cc9604ef34c/comments", "author": null, "committer": null, "parents": [{"sha": "80fc2e84d95714c998b2855250b3d440f38620aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80fc2e84d95714c998b2855250b3d440f38620aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80fc2e84d95714c998b2855250b3d440f38620aa"}], "stats": {"total": 1335, "additions": 802, "deletions": 533}, "files": [{"sha": "7e1049b8d2500f515c2cf53c8512497d1101a43b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -1,3 +1,20 @@\n+2001-03-19  Mark Wielaard <mark@klomp.org>\n+\n+\t* java/util/ArrayList.java: Remove RCS keywords from comments\n+\t* java/util/BasicMapEntry.java: idem\n+\t* java/util/Dictionary.java: idem\n+\t* java/util/HashSet.java: idem\n+\n+\t* java/util/EventObject.java: reindent\n+\t* java/util/Properties.java: idem\n+\t* java/util/SortedMap.java: idem\n+\n+\t* java/util/Enumeration.java: Merge with Classpath\n+\t* java/util/EventListener.java: idem\n+\t* java/util/Observable.java: idem\n+\t* java/util/Observer.java: idem\n+\t* java/util/Stack.java: idem\n+\n 2001-03-17  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/natString.cc (rehash): Don't bother with memset;"}, {"sha": "d6b663414a43259833199b7cc9859fa5bde93d61", "filename": "libjava/java/util/ArrayList.java", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FArrayList.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FArrayList.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FArrayList.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -40,7 +40,6 @@\n  * to or removing from the end of a list, checking the size, &c.\n  *\n  * @author        Jon A. Zeppieri\n- * @version       $Id: ArrayList.java,v 1.12 2000/12/17 07:54:39 cbj Exp $\n  * @see           java.util.AbstractList\n  * @see           java.util.List\n  */"}, {"sha": "f858cb4ebd979cbfb19be787d5de6cb95477a064", "filename": "libjava/java/util/BasicMapEntry.java", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FBasicMapEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FBasicMapEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBasicMapEntry.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -33,8 +33,6 @@\n  * Hashtable.\n  *\n  * @author      Jon Zeppieri\n- * @version     $Revision: 1.5 $\n- * @modified    $Id: BasicMapEntry.java,v 1.5 2000/10/26 10:19:00 bryce Exp $\n  */\n class BasicMapEntry implements Map.Entry\n {"}, {"sha": "7530e0833512745e173e340ba10f21fcc7590707", "filename": "libjava/java/util/Dictionary.java", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FDictionary.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FDictionary.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FDictionary.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -40,8 +40,6 @@ class which is Hashtable's superclass\n  * in the Collections framework.\n  *\n  * @author      Jon Zeppieri\n- * @version     $Revision: 1.4 $\n- * @modified    $Id: Dictionary.java,v 1.4 2000/10/26 10:19:00 bryce Exp $\n  */\n public abstract class Dictionary extends Object\n {"}, {"sha": "66624bd3ab63472be0defa451b27943dd7d4f0b9", "filename": "libjava/java/util/Enumeration.java", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FEnumeration.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FEnumeration.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEnumeration.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -1,24 +1,65 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Enumeration.java -- Interface for enumerating lists of objects\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n package java.util;\n- \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date August 25, 1998.\n- */\n+\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1.\n  * Status:  Believed complete and correct\n  */\n- \n+\n+/**\n+ * Interface for lists of objects that can be returned in sequence. Successive\n+ * objects are obtained by the nextElement method.\n+ * <p>\n+ * As of Java 1.2, the Iterator interface provides the same functionality, but\n+ * with shorter method names and a new optional method to remove items from the\n+ * list. If writing for 1.2, consider using Iterator instead. Enumerations over\n+ * the new collections classes, for use with legacy APIs that require them, can\n+ * be obtained by the enumeration method in class Collections.\n+ *\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date August 25, 1998.\n+ */\n public interface Enumeration\n {\n-  public boolean hasMoreElements();\n-  public Object nextElement() throws NoSuchElementException;\n+  /**\n+   * Tests whether there are elements remaining in the enumeration.\n+   *\n+   * @return true if there is at least one more element in the enumeration,\n+   *   that is, if the next call to nextElement will not throw a\n+   *   NoSuchElementException.\n+   */\n+  boolean hasMoreElements();\n+\n+  /**\n+   * Obtain the next element in the enumeration.\n+   *\n+   * @return the next element in the enumeration\n+   * @exception NoSuchElementException if there are no more elements\n+   */\n+  Object nextElement() throws NoSuchElementException;\n }"}, {"sha": "387e9d1a1963ff439213bb9c2844e2d3c2371d42", "filename": "libjava/java/util/EventListener.java", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FEventListener.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FEventListener.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEventListener.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -1,24 +1,47 @@\n-// EventListener.java - Listen for events from event source.\n+/* An interface that all event listener interfaces must extend\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-   This file is part of libgcj.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n- \n package java.util;\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date December 12, 1998\n- */\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * Status:  Believed complete and correct.\n  */\n \n+/**\n+ * Empty interface that is implemented by classes that need to receive\n+ * events. Subinterfaces define methods that can be called to fire an\n+ * event notification. Normally the name of these subinterfaces end in\n+ * <code>Listener</code> and all method described by the subinterface\n+ * take as argument an subclass of <code>EventObject</code>.\n+ *\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date December 12, 1998\n+ */\n public interface EventListener\n {\n }"}, {"sha": "baf927cae037a6db1cf5e4044cda1dddd1ce602a", "filename": "libjava/java/util/EventObject.java", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FEventObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FEventObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FEventObject.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -1,28 +1,28 @@\n /* EventObject.java - Represent events fired by objects.\n    Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n \n-   This file is part of GNU Classpath.\n+This file is part of GNU Classpath.\n \n-   GNU Classpath is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-   GNU Classpath is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with GNU Classpath; see the file COPYING.  If not, write to the\n-   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-   02111-1307 USA.\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n \n-   As a special exception, if you link this library with other files to\n-   produce an executable, this library does not by itself cause the\n-   resulting executable to be covered by the GNU General Public License.\n-   This exception does not however invalidate any other reasons why the\n-   executable file might be covered by the GNU General Public License. */\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n \n package java.util;"}, {"sha": "2b5c31dc7fc64106178ee6d5da43f430b51f50c1", "filename": "libjava/java/util/HashSet.java", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FHashSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FHashSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashSet.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -45,8 +45,6 @@\n  * HashSet is a part of the JDK1.2 Collections API.\n  *\n  * @author      Jon Zeppieri\n- * @version     $Revision: 1.3 $\n- * @modified    $Id: HashSet.java,v 1.3 2001/02/15 05:12:05 bryce Exp $\n  */\n public class HashSet extends AbstractSet\n   implements Set, Cloneable, Serializable"}, {"sha": "5d4d49f7f88554941aa27cbbc9f722adc1a934c1", "filename": "libjava/java/util/Observable.java", "status": "modified", "additions": 90, "deletions": 33, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FObservable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FObservable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FObservable.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -1,30 +1,49 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* java.util.Observable\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n- \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 2, 1998.\n- */\n+\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n- \n+\n+/**\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date September 2, 1998.\n+ */\n public class Observable\n {\n-  /* tracks whether this object has changed */\n+  /** tracks whether this object has changed */\n   private boolean changed;\n \n   /* list of the Observers registered as interested in this Observable */\n-  private Vector observerVec;\n+  private Vector observers;\n \n   /* TBD: This might be better implemented as an Observer[]\n    * but that would mean writing more code rather than making use of\n@@ -34,63 +53,101 @@\n    * we may decide to make the tradeoff and reimplement with an Observer[].\n    */\n \n+  /**\n+   * Constructs an Observable with zero Observers.\n+   */\n   public Observable()\n   {\n     changed = false;\n-    observerVec = new Vector();\n+    observers = new Vector();\n   }\n \n-  public synchronized void addObserver(Observer obs)\n+  /**\n+   * Adds an Observer. If the observer was already added this method does\n+   * nothing.\n+   *\n+   * @param observer Observer to add.\n+   */\n+  public synchronized void addObserver(Observer observer)\n   {\n-    // JDK 1.2 spec says not to add this if it is already there\n-    if (!observerVec.contains(obs))\n-      observerVec.addElement(obs);\n+    if (!observers.contains(observer))\n+      observers.addElement(observer);\n   }\n \n+  /**\n+   * Reset this Observable's state to unchanged.\n+   */\n   protected synchronized void clearChanged()\n   {\n     changed = false;\n   }\n \n+  /**\n+   * @return Number of Observers for this Observable.\n+   */\n   public synchronized int countObservers()\n   {\n-    return observerVec.size();\n+    return observers.size();\n   }\n \n-  public synchronized void deleteObserver(Observer obs)\n+  /**\n+   * Deletes an Observer of this Observable.\n+   *\n+   * @param victim Observer to delete.\n+   */\n+  public synchronized void deleteObserver(Observer victim)\n   {\n-    observerVec.removeElement(obs);\n+    observers.removeElement(victim);\n   }\n \n+  /**\n+   * Deletes all Observers of this Observable.\n+   */\n   public synchronized void deleteObservers()\n   {\n-    observerVec.removeAllElements();\n+    observers.removeAllElements();\n   }\n \n+  /**\n+   * @return Whether or not this Observable has changed.\n+   */\n   public synchronized boolean hasChanged()\n   {\n     return changed;\n   }\n \n+  /**\n+   * If the Observable has actually changed then tell all Observers about it,\n+   * then resets state to unchanged.\n+   */\n   public void notifyObservers()\n   {\n     notifyObservers(null);\n   }\n \n-  public void notifyObservers(Object arg)\n+  /**\n+   * If the Observable has actually changed then tell all Observers about it,\n+   * then resets state to unchanged. \n+   * Note that though the order of notification is unspecified in subclasses,\n+   * in Observable it is in the order of registration.\n+   *\n+   * @param obj Arguement to Observer's update method.\n+   */\n+  public void notifyObservers(Object obj)\n   {\n-    if (changed)\n-      {\n-\t/* The JDK 1.2 spec states that though the order of notification\n-\t * is unspecified in subclasses, in Observable it is in the order\n-\t * of registration.\n-\t */\n-        for (int i = 0, numObs = observerVec.size(); i < numObs; i++)\n-          ((Observer) (observerVec.elementAt(i))).update(this, arg);\n-        changed = false;\n-      }\n+    if (!hasChanged())\n+      return;\n+    Vector ob1 = (Vector) observers.clone();\n+\n+    for (int i = 0; i < ob1.size(); i++)\n+      ((Observer) ob1.elementAt(i)).update(this, obj);\n+\n+    clearChanged();\n   }\n \n+  /**\n+   * Marks this Observable as having changed.\n+   */\n   protected synchronized void setChanged()\n   {\n     changed = true;"}, {"sha": "67197986a904cc94777846c5184b8bde32325e72", "filename": "libjava/java/util/Observer.java", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FObserver.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FObserver.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FObserver.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -1,24 +1,48 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Implemented when a class wants to be informed of changes in Observable\n+   objects.\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n- \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date August 25, 1998.\n- */\n+\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct\n  */\n- \n+\n+/**\n+ * Interface that is implemented when a class wants to be informed of changes\n+ * in Observable objects.\n+ *\n+ * @see java.util.Observable\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date August 25, 1998.\n+ */\n public interface Observer\n {\n-  public void update(Observable observed, Object arg);\n+  public void update(Observable observable, Object arg);\n }"}, {"sha": "dc679faf126aad768dca7118b9bc80d0074440a1", "filename": "libjava/java/util/Properties.java", "status": "modified", "additions": 458, "deletions": 408, "changes": 866, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FProperties.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FProperties.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FProperties.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -62,427 +62,477 @@\n  *\n  * @see PropertyResourceBundle\n  * @author Jochen Hoenicke */\n-public class Properties extends Hashtable {\n-    /**\n-     * The property list that contains default values for any keys not\n-     * in this property list.  \n-     */\n-    protected Properties defaults;\n+public class Properties extends Hashtable\n+{\n+  /**\n+   * The property list that contains default values for any keys not\n+   * in this property list.  \n+   */\n+  protected Properties defaults;\n+\n+  private static final long serialVersionUID = 4112578634029874840L;\n \n-    private static final long serialVersionUID = 4112578634029874840L;\n+  /**\n+   * Creates a new empty property list.\n+   */\n+  public Properties()\n+  {\n+    this.defaults = null;\n+  }\n \n-    /**\n-     * Creates a new empty property list.\n-     */\n-    public Properties() {\n-        this.defaults = null;\n-    }\n+  /**\n+   * Create a new empty property list with the specified default values.\n+   * @param defaults a Properties object containing the default values.\n+   */\n+  public Properties(Properties defaults)\n+  {\n+    this.defaults = defaults;\n+  }\n+\n+  /**\n+   * Reads a property list from an input stream.  The stream should\n+   * have the following format: <br>\n+   *\n+   * An empty line or a line starting with <code>#</code> or\n+   * <code>!</code> is ignored.  An backslash (<code>\\</code>) at the\n+   * end of the line makes the line continueing on the next line\n+   * (but make sure there is no whitespace after the backslash).\n+   * Otherwise, each line describes a key/value pair. <br>\n+   *\n+   * The chars up to the first whitespace, = or : are the key.  You\n+   * can include this caracters in the key, if you precede them with\n+   * a backslash (<code>\\</code>). The key is followed by optional\n+   * whitespaces, optionally one <code>=</code> or <code>:</code>,\n+   * and optionally some more whitespaces.  The rest of the line is\n+   * the resource belonging to the key. <br>\n+   *\n+   * Escape sequences <code>\\t, \\n, \\r, \\\\, \\\", \\', \\!, \\#, \\ </code>(a\n+   * space), and unicode characters with the\n+   * <code>\\</code><code>u</code>xxxx notation are detected, and \n+   * converted to the corresponding single character. <br>\n+   *\n+   * <pre>\n+   * # This is a comment\n+   * key     = value\n+   * k\\:5      \\ a string starting with space and ending with newline\\n\n+   * # This is a multiline specification; note that the value contains\n+   * # no white space.\n+   * weekdays: Sunday,Monday,Tuesday,Wednesday,\\\n+   *           Thursday,Friday,Saturday\n+   * # The safest way to include a space at the end of a value:\n+   * label   = Name:\\<code></code>u0020\n+   * </pre>\n+   *\n+   * @param in the input stream\n+   * @exception IOException if an error occured when reading\n+   * from the input.  */\n+  public void load(InputStream inStream) throws IOException\n+  {\n+    BufferedReader reader =\n+      new BufferedReader(new InputStreamReader(inStream));\n+    String line;\n     \n-    /**\n-     * Create a new empty property list with the specified default values.\n-     * @param defaults a Properties object containing the default values.\n-     */\n-    public Properties(Properties defaults) {\n-        this.defaults = defaults;\n-    }\n+    while ((line = reader.readLine()) != null)\n+      {\n+\tchar c = 0;\n+\tint pos = 0;\n+\twhile (pos < line.length()\n+\t       && Character.isWhitespace(c = line.charAt(pos)))\n+\t  pos++;\n \n-    /**\n-     * Reads a property list from an input stream.  The stream should\n-     * have the following format: <br>\n-     *\n-     * An empty line or a line starting with <code>#</code> or\n-     * <code>!</code> is ignored.  An backslash (<code>\\</code>) at the\n-     * end of the line makes the line continueing on the next line\n-     * (but make sure there is no whitespace after the backslash).\n-     * Otherwise, each line describes a key/value pair. <br>\n-     *\n-     * The chars up to the first whitespace, = or : are the key.  You\n-     * can include this caracters in the key, if you precede them with\n-     * a backslash (<code>\\</code>). The key is followed by optional\n-     * whitespaces, optionally one <code>=</code> or <code>:</code>,\n-     * and optionally some more whitespaces.  The rest of the line is\n-     * the resource belonging to the key. <br>\n-     *\n-     * Escape sequences <code>\\t, \\n, \\r, \\\\, \\\", \\', \\!, \\#, \\ </code>(a\n-     * space), and unicode characters with the\n-     * <code>\\</code><code>u</code>xxxx notation are detected, and \n-     * converted to the corresponding single character. <br>\n-     *\n-     * <pre>\n-     * # This is a comment\n-     * key     = value\n-     * k\\:5      \\ a string starting with space and ending with newline\\n\n-     * # This is a multiline specification; note that the value contains\n-     * # no white space.\n-     * weekdays: Sunday,Monday,Tuesday,Wednesday,\\\n-     *           Thursday,Friday,Saturday\n-     * # The safest way to include a space at the end of a value:\n-     * label   = Name:\\<code></code>u0020\n-     * </pre>\n-     *\n-     * @param in the input stream\n-     * @exception IOException if an error occured when reading\n-     * from the input.  */\n-    public void load(InputStream inStream) throws IOException {\n-        BufferedReader reader = \n-            new BufferedReader(new InputStreamReader(inStream));\n-        String line;\n-        while ((line = reader.readLine()) != null) {\n-            char c = 0;\n-            int pos = 0;\n-            while (pos < line.length()\n-                   && Character.isWhitespace(c = line.charAt(pos)))\n-                pos++;\n+\t// If line is empty or begins with a comment character,\n+\t// skip this line.\n+\tif (pos == line.length() || c == '#' || c == '!')\n+\t  continue;\n \n-            // If line is empty or begins with a comment character,\n-            // skip this line.\n-            if (pos == line.length() || c == '#' || c == '!')\n-                continue;\n+\t// The characaters up to the next Whitespace, ':', or '='\n+\t// describe the key.  But look for escape sequences.\n+\tStringBuffer key = new StringBuffer();\n+\twhile (pos < line.length()\n+\t       && !Character.isWhitespace(c = line.charAt(pos++))\n+\t       && c != '=' && c != ':')\n+\t  {\n+\t    if (c == '\\\\')\n+\t      {\n+\t\tif (pos == line.length())\n+\t\t  {\n+\t\t    // The line continues on the next line.\n+\t\t    line = reader.readLine();\n+\t\t    pos = 0;\n+\t\t    while (pos < line.length()\n+\t\t\t   && Character.isWhitespace(c = line.charAt(pos)))\n+\t\t      pos++;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    c = line.charAt(pos++);\n+\t\t    switch (c)\n+\t\t      {\n+\t\t      case 'n':\n+\t\t\tkey.append('\\n');\n+\t\t\tbreak;\n+\t\t      case 't':\n+\t\t\tkey.append('\\t');\n+\t\t\tbreak;\n+\t\t      case 'r':\n+\t\t\tkey.append('\\r');\n+\t\t\tbreak;\n+\t\t      case 'u':\n+\t\t\tif (pos + 4 <= line.length())\n+\t\t\t  {\n+\t\t\t    char uni = (char) Integer.parseInt\n+\t\t\t      (line.substring(pos, pos + 4), 16);\n+\t\t\t    key.append(uni);\n+\t\t\t  }\t// else throw exception?\n+\t\t\tbreak;\n+\t\t      default:\n+\t\t\tkey.append(c);\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    else\n+\t      key.append(c);\n+\t  }\n \n-            // The characaters up to the next Whitespace, ':', or '='\n-            // describe the key.  But look for escape sequences.\n-            StringBuffer key = new StringBuffer();\n-            while (pos < line.length() \n-                   && !Character.isWhitespace(c = line.charAt(pos++))\n-                   && c != '=' && c != ':') {\n-                if (c == '\\\\') {\n-                    if (pos == line.length()) {\n-                        // The line continues on the next line.\n-                        line = reader.readLine();\n-                        pos = 0;\n-                        while (pos < line.length()\n-                               && Character.isWhitespace(c = line.charAt(pos)))\n-                            pos++;\n-                    } else {\n-                        c = line.charAt(pos++);\n-                        switch (c) {\n-                        case 'n':\n-                            key.append('\\n');\n-                            break;\n-                        case 't':\n-                            key.append('\\t');\n-                            break;\n-                        case 'r':\n-                            key.append('\\r');\n-                            break;\n-                        case 'u':\n-                            if (pos+4 <= line.length()) {\n-                                char uni = (char) Integer.parseInt\n-                                    (line.substring(pos, pos+4), 16);\n-                                key.append(uni);\n-                            } // else throw exception?\n-                            break;\n-\t\t\tdefault:\n-                            key.append(c);\n-                            break;\n-                        }\n-                    }\n-                } else \n-                    key.append(c);\n-            }\n-            \n-            boolean isDelim = (c == ':' || c == '=');\n-            while (pos < line.length()\n-                   && Character.isWhitespace(c = line.charAt(pos)))\n-                pos++;\n+\tboolean isDelim = (c == ':' || c == '=');\n+\twhile (pos < line.length()\n+\t       && Character.isWhitespace(c = line.charAt(pos)))\n+\t  pos++;\n \n-            if (!isDelim && (c == ':' || c == '=')) {\n-                pos++;\n-                while (pos < line.length()\n-                       && Character.isWhitespace(c = line.charAt(pos)))\n-                    pos++;\n-            }\n+\tif (!isDelim && (c == ':' || c == '='))\n+\t  {\n+\t    pos++;\n+\t    while (pos < line.length()\n+\t\t   && Character.isWhitespace(c = line.charAt(pos)))\n+\t      pos++;\n+\t  }\n \n-            StringBuffer element = new StringBuffer(line.length()-pos);\n-            while (pos < line.length()) {\n-                c = line.charAt(pos++);\n-                if (c == '\\\\') {\n-                    if (pos == line.length()) {\n-                        // The line continues on the next line.\n-                        line = reader.readLine();\n-                        pos = 0;\n-                        while (pos < line.length()\n-                               && Character.isWhitespace(c = line.charAt(pos)))\n-                            pos++;\n-\t\t\telement.ensureCapacity(line.length()-pos+element.length());\n-                    } else {\n-                        c = line.charAt(pos++);\n-                        switch (c) {\n-                        case 'n':\n-                            element.append('\\n');\n-                            break;\n-                        case 't':\n-                            element.append('\\t');\n-                            break;\n-                        case 'r':\n-                            element.append('\\r');\n-                            break;\n-                        case 'u':\n-                            if (pos+4 <= line.length()) {\n-                                char uni = (char) Integer.parseInt\n-                                    (line.substring(pos, pos+4), 16);\n-                                element.append(uni);\n-                            } // else throw exception?\n-                            break;\n-\t\t\tdefault:\n-                            element.append(c);\n-                            break;\n-                        }\n-                    }\n-                } else \n-                    element.append(c);\n-            }\n-            put(key.toString(), element.toString());\n-        }\n-    }\n+\tStringBuffer element = new StringBuffer(line.length() - pos);\n+\twhile (pos < line.length())\n+\t  {\n+\t    c = line.charAt(pos++);\n+\t    if (c == '\\\\')\n+\t      {\n+\t\tif (pos == line.length())\n+\t\t  {\n+\t\t    // The line continues on the next line.\n+\t\t    line = reader.readLine();\n+\t\t    pos = 0;\n+\t\t    while (pos < line.length()\n+\t\t\t   && Character.isWhitespace(c = line.charAt(pos)))\n+\t\t      pos++;\n+\t\t    element.ensureCapacity(line.length() - pos +\n+\t\t\t\t\t   element.length());\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    c = line.charAt(pos++);\n+\t\t    switch (c)\n+\t\t      {\n+\t\t      case 'n':\n+\t\t\telement.append('\\n');\n+\t\t\tbreak;\n+\t\t      case 't':\n+\t\t\telement.append('\\t');\n+\t\t\tbreak;\n+\t\t      case 'r':\n+\t\t\telement.append('\\r');\n+\t\t\tbreak;\n+\t\t      case 'u':\n+\t\t\tif (pos + 4 <= line.length())\n+\t\t\t  {\n+\t\t\t    char uni = (char) Integer.parseInt\n+\t\t\t      (line.substring(pos, pos + 4), 16);\n+\t\t\t    element.append(uni);\n+\t\t\t  }\t// else throw exception?\n+\t\t\tbreak;\n+\t\t      default:\n+\t\t\telement.append(c);\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    else\n+\t      element.append(c);\n+\t  }\n+\tput(key.toString(), element.toString());\n+      }\n+  }\n \n-    /**\n-     * Calls <code>store(OutputStream out, String header)</code> and\n-     * ignores the IOException that may be thrown.\n-     * @deprecated use store instead.\n-     * @exception ClassCastException if this property contains any key or\n-     * value that isn't a string.\n-     */\n-    public void save(OutputStream out, String header) {\n-        try {\n-            store(out,header);\n-        } catch (IOException ex) {\n-        }\n-    }\n-    \n-    /**\n-     * Writes the key/value pairs to the given output stream. <br>\n-     *\n-     * If header is not null, this method writes a comment containing\n-     * the header as first line to the stream.  The next line (or first\n-     * line if header is null) contains a comment with the current date.\n-     * Afterwards the key/value pairs are written to the stream in the\n-     * following format. <br>\n-     *\n-     * Each line has the form <code>key = value</code>.  Newlines,\n-     * Returns and tabs are written as <code>\\n,\\t,\\r</code> resp.\n-     * The characters <code>\\, !, #, =</code> and <code>:</code> are\n-     * preceeded by a backslash.  Spaces are preceded with a backslash,\n-     * if and only if they are at the beginning of the key.  Characters\n-     * that are not in the ascii range 33 to 127 are written in the\n-     * <code>\\</code><code>u</code>xxxx Form.\n-     *\n-     * @param out the output stream\n-     * @param header the header written in the first line, may be null.\n-     * @exception ClassCastException if this property contains any key or\n-     * value that isn't a string.\n-     */\n-    public void store(OutputStream out, String header) throws IOException {\n-        PrintWriter writer = new PrintWriter(out);\n-        if (header != null)\n-            writer.println(\"#\"+header);\n-        writer.println(\"#\"+new Date().toString());\n-        list(writer);\n-\twriter.flush();\n-    }\n-    \n-    /**\n-     * Adds the given key/value pair to this properties.  This calls\n-     * the hashtable method put.\n-     * @param key the key for this property\n-     * @param value the value for this property\n-     * @return The old value for the given key.\n-     * @since JDK1.2 */\n-    public Object setProperty(String key, String value) {\n-        return put(key,value);\n-    }\n+  /**\n+   * Calls <code>store(OutputStream out, String header)</code> and\n+   * ignores the IOException that may be thrown.\n+   * @deprecated use store instead.\n+   * @exception ClassCastException if this property contains any key or\n+   * value that isn't a string.\n+   */\n+  public void save(OutputStream out, String header)\n+  {\n+    try\n+      {\n+\tstore(out, header);\n+      }\n+    catch (IOException ex)\n+      {\n+      }\n+  }\n+\n+  /**\n+   * Writes the key/value pairs to the given output stream. <br>\n+   *\n+   * If header is not null, this method writes a comment containing\n+   * the header as first line to the stream.  The next line (or first\n+   * line if header is null) contains a comment with the current date.\n+   * Afterwards the key/value pairs are written to the stream in the\n+   * following format. <br>\n+   *\n+   * Each line has the form <code>key = value</code>.  Newlines,\n+   * Returns and tabs are written as <code>\\n,\\t,\\r</code> resp.\n+   * The characters <code>\\, !, #, =</code> and <code>:</code> are\n+   * preceeded by a backslash.  Spaces are preceded with a backslash,\n+   * if and only if they are at the beginning of the key.  Characters\n+   * that are not in the ascii range 33 to 127 are written in the\n+   * <code>\\</code><code>u</code>xxxx Form.\n+   *\n+   * @param out the output stream\n+   * @param header the header written in the first line, may be null.\n+   * @exception ClassCastException if this property contains any key or\n+   * value that isn't a string.\n+   */\n+  public void store(OutputStream out, String header) throws IOException\n+  {\n+    PrintWriter writer = new PrintWriter(out);\n+    if (header != null)\n+      writer.println(\"#\" + header);\n+    writer.println(\"#\" + new Date().toString());\n+    list(writer);\n+    writer.flush();\n+  }\n+\n+  /**\n+   * Adds the given key/value pair to this properties.  This calls\n+   * the hashtable method put.\n+   * @param key the key for this property\n+   * @param value the value for this property\n+   * @return The old value for the given key.\n+   * @since JDK1.2 */\n+  public Object setProperty(String key, String value)\n+  {\n+    return put(key, value);\n+  }\n \n-    /**\n-     * Gets the property with the specified key in this property list.\n-     * If the key is not found, the default property list is searched.\n-     * If the property is not found in default or the default of\n-     * default, null is returned.\n-     * @param key The key for this property.\n-     * @param defaulValue A default value\n-     * @return The value for the given key, or null if not found. \n-     * @exception ClassCastException if this property contains any key or\n-     * value that isn't a string.\n-     */\n-    public String getProperty(String key) {\n-        return getProperty(key, null);\n-    }\n+  /**\n+   * Gets the property with the specified key in this property list.\n+   * If the key is not found, the default property list is searched.\n+   * If the property is not found in default or the default of\n+   * default, null is returned.\n+   * @param key The key for this property.\n+   * @param defaulValue A default value\n+   * @return The value for the given key, or null if not found. \n+   * @exception ClassCastException if this property contains any key or\n+   * value that isn't a string.\n+   */\n+  public String getProperty(String key)\n+  {\n+    return getProperty(key, null);\n+  }\n \n-    /**\n-     * Gets the property with the specified key in this property list.  If\n-     * the key is not found, the default property list is searched.  If the\n-     * property is not found in default or the default of default, the \n-     * specified defaultValue is returned.\n-     * @param key The key for this property.\n-     * @param defaulValue A default value\n-     * @return The value for the given key.\n-     * @exception ClassCastException if this property contains any key or\n-     * value that isn't a string.\n-     */\n-    public String getProperty(String key, String defaultValue) {\n-        Properties prop = this;\n-        // Eliminate tail recursion.\n-        do {\n-            String value = (String) prop.get(key);\n-            if (value != null)\n-                return value;\n-            prop = prop.defaults;\n-        } while (prop != null);\n-        return defaultValue;\n-    }\n+  /**\n+   * Gets the property with the specified key in this property list.  If\n+   * the key is not found, the default property list is searched.  If the\n+   * property is not found in default or the default of default, the \n+   * specified defaultValue is returned.\n+   * @param key The key for this property.\n+   * @param defaulValue A default value\n+   * @return The value for the given key.\n+   * @exception ClassCastException if this property contains any key or\n+   * value that isn't a string.\n+   */\n+  public String getProperty(String key, String defaultValue)\n+  {\n+    Properties prop = this;\n+    // Eliminate tail recursion.\n+    do\n+      {\n+\tString value = (String) prop.get(key);\n+\tif (value != null)\n+\t  return value;\n+\tprop = prop.defaults;\n+      }\n+    while (prop != null);\n+    return defaultValue;\n+  }\n \n-    private final void addHashEntries (Hashtable base) {\n-        if (defaults != null)\n-\t    defaults.addHashEntries(base);\n-\tEnumeration keys = keys ();\n-\twhile (keys.hasMoreElements())\n-\t    base.put(keys.nextElement(), base);\n-    }\n+  private final void addHashEntries(Hashtable base)\n+  {\n+    if (defaults != null)\n+      defaults.addHashEntries(base);\n+    Enumeration keys = keys();\n+    while (keys.hasMoreElements())\n+      base.put(keys.nextElement(), base);\n+  }\n \n-    /**\n-     * Returns an enumeration of all keys in this property list, including\n-     * the keys in the default property list.\n-     */\n-    public Enumeration propertyNames () {\n-        // We make a new Hashtable that holds all the keys.  Then we\n-        // return an enumeration for this hash.  We do this because we\n-        // don't want modifications to be reflected in the enumeration\n-        // (per JCL), and because there doesn't seem to be a\n-        // particularly better way to ensure that duplicates are\n-        // ignored.\n-        Hashtable t = new Hashtable ();\n-\taddHashEntries (t);\n-\treturn t.keys();\n-    }\n+  /**\n+   * Returns an enumeration of all keys in this property list, including\n+   * the keys in the default property list.\n+   */\n+  public Enumeration propertyNames()\n+  {\n+    // We make a new Hashtable that holds all the keys.  Then we\n+    // return an enumeration for this hash.  We do this because we\n+    // don't want modifications to be reflected in the enumeration\n+    // (per JCL), and because there doesn't seem to be a\n+    // particularly better way to ensure that duplicates are\n+    // ignored.\n+    Hashtable t = new Hashtable();\n+    addHashEntries(t);\n+    return t.keys();\n+  }\n \n-    /**\n-     * Formats a key/value pair for output in a properties file.\n-     * See store for a description of the format.\n-     * @param key the key.\n-     * @param value the value.\n-     * @see #store\n-     */\n-    private String formatForOutput(String key, String value) {\n-\t// This is a simple approximation of the expected line size.\n-        StringBuffer result = new StringBuffer(key.length()+value.length()+16);\n-        boolean head = true;\n-        for (int i=0; i< key.length(); i++) {\n-            char c = key.charAt(i);\n-            switch (c) {\n-            case '\\n':\n-                result.append(\"\\\\n\");\n-                break;\n-            case '\\r':\n-                result.append(\"\\\\r\");\n-                break;\n-            case '\\t':\n-                result.append(\"\\\\t\");\n-                break;\n-            case '\\\\':\n-                result.append(\"\\\\\\\\\");\n-                break;\n-            case '!':\n-                result.append(\"\\\\!\");\n-                break;\n-            case '#':\n-                result.append(\"\\\\#\");\n-                break;\n-            case '=':\n-                result.append(\"\\\\=\");\n-                break;\n-            case ':':\n-                result.append(\"\\\\:\");\n-                break;\n-\t    case ' ':\n-\t        result.append(\"\\\\ \");\n-\t\tbreak;\n-            default:\n-                if (c < 32 || c > '~') {\n-                    String hex = Integer.toHexString(c);\n-                    result.append(\"\\\\u0000\".substring(0, 6-hex.length()));\n-                    result.append(hex);\n-                } else\n-                    result.append(c);\n-            }\n-            if (c != 32)\n-                head = false;\n-        }\n-        result.append('=');\n-        head=true;\n-        for (int i=0; i< value.length(); i++) {\n-            char c = value.charAt(i);\n-            switch (c) {\n-            case '\\n':\n-                result.append(\"\\\\n\");\n-                break;\n-            case '\\r':\n-                result.append(\"\\\\r\");\n-                break;\n-            case '\\t':\n-                result.append(\"\\\\t\");\n-                break;\n-            case '\\\\':\n-                result.append(\"\\\\\\\\\");\n-                break;\n-            case '!':\n-                result.append(\"\\\\!\");\n-                break;\n-            case '#':\n-                result.append(\"\\\\#\");\n-                break;\n-\t    case ' ':\n-\t\tresult.append(head ? \"\\\\ \": \" \");\n-\t\tbreak;\n-            default:\n-                if (c < 32 || c > '~') {\n-                    String hex = Integer.toHexString(c);\n-                    result.append(\"\\\\u0000\".substring(0, 6-hex.length()));\n-                    result.append(hex);\n-                } else\n-                    result.append(c);\n-            }\n-            if (c != 32)\n-                head = false;\n-        }\n-        return result.toString();\n-    }\n+  /**\n+   * Formats a key/value pair for output in a properties file.\n+   * See store for a description of the format.\n+   * @param key the key.\n+   * @param value the value.\n+   * @see #store\n+   */\n+  private String formatForOutput(String key, String value)\n+  {\n+    // This is a simple approximation of the expected line size.\n+    StringBuffer result =\n+      new StringBuffer(key.length() + value.length() + 16);\n+    boolean head = true;\n+    for (int i = 0; i < key.length(); i++)\n+      {\n+\tchar c = key.charAt(i);\n+\tswitch (c)\n+\t  {\n+\t  case '\\n':\n+\t    result.append(\"\\\\n\");\n+\t    break;\n+\t  case '\\r':\n+\t    result.append(\"\\\\r\");\n+\t    break;\n+\t  case '\\t':\n+\t    result.append(\"\\\\t\");\n+\t    break;\n+\t  case '\\\\':\n+\t    result.append(\"\\\\\\\\\");\n+\t    break;\n+\t  case '!':\n+\t    result.append(\"\\\\!\");\n+\t    break;\n+\t  case '#':\n+\t    result.append(\"\\\\#\");\n+\t    break;\n+\t  case '=':\n+\t    result.append(\"\\\\=\");\n+\t    break;\n+\t  case ':':\n+\t    result.append(\"\\\\:\");\n+\t    break;\n+\t  case ' ':\n+\t    result.append(\"\\\\ \");\n+\t    break;\n+\t  default:\n+\t    if (c < 32 || c > '~')\n+\t      {\n+\t\tString hex = Integer.toHexString(c);\n+\t\tresult.append(\"\\\\u0000\".substring(0, 6 - hex.length()));\n+\t\tresult.append(hex);\n+\t      }\n+\t    else\n+\t        result.append(c);\n+\t  }\n+\tif (c != 32)\n+\t  head = false;\n+      }\n+    result.append('=');\n+    head = true;\n+    for (int i = 0; i < value.length(); i++)\n+      {\n+\tchar c = value.charAt(i);\n+\tswitch (c)\n+\t  {\n+\t  case '\\n':\n+\t    result.append(\"\\\\n\");\n+\t    break;\n+\t  case '\\r':\n+\t    result.append(\"\\\\r\");\n+\t    break;\n+\t  case '\\t':\n+\t    result.append(\"\\\\t\");\n+\t    break;\n+\t  case '\\\\':\n+\t    result.append(\"\\\\\\\\\");\n+\t    break;\n+\t  case '!':\n+\t    result.append(\"\\\\!\");\n+\t    break;\n+\t  case '#':\n+\t    result.append(\"\\\\#\");\n+\t    break;\n+\t  case ' ':\n+\t    result.append(head ? \"\\\\ \" : \" \");\n+\t    break;\n+\t  default:\n+\t    if (c < 32 || c > '~')\n+\t      {\n+\t\tString hex = Integer.toHexString(c);\n+\t\tresult.append(\"\\\\u0000\".substring(0, 6 - hex.length()));\n+\t\tresult.append(hex);\n+\t      }\n+\t    else\n+\t      result.append(c);\n+\t  }\n+\tif (c != 32)\n+\t  head = false;\n+      }\n+    return result.toString();\n+  }\n \n-    /**\n-     * Writes the key/value pairs to the given print stream.  They are\n-     * written in the way, described in the method store.\n-     * @param out the stream, where the key/value pairs are written to.\n-     * @exception ClassCastException if this property contains any key or\n-     * value that isn't a string.\n-     * @see #store\n-     */\n-    public void list(PrintStream out) {\n-        Enumeration keys = keys();\n-        Enumeration elts = elements();\n-        while (keys.hasMoreElements()) {\n-            String key = (String) keys.nextElement();\n-            String elt = (String) elts.nextElement();\n-            String output = formatForOutput(key,elt);\n-            out.println(output);\n-        }\n-    }\n+  /**\n+   * Writes the key/value pairs to the given print stream.  They are\n+   * written in the way, described in the method store.\n+   * @param out the stream, where the key/value pairs are written to.\n+   * @exception ClassCastException if this property contains any key or\n+   * value that isn't a string.\n+   * @see #store\n+   */\n+  public void list(PrintStream out)\n+  {\n+    Enumeration keys = keys();\n+    Enumeration elts = elements();\n+    while (keys.hasMoreElements())\n+      {\n+\tString key = (String) keys.nextElement();\n+\tString elt = (String) elts.nextElement();\n+\tString output = formatForOutput(key, elt);\n+\tout.println(output);\n+      }\n+  }\n \n-    /**\n-     * Writes the key/value pairs to the given print writer.  They are\n-     * written in the way, described in the method store.\n-     * @param out the writer, where the key/value pairs are written to.\n-     * @exception ClassCastException if this property contains any key or\n-     * value that isn't a string.\n-     * @see #store\n-     * @see #list(java.io.PrintStream)\n-     * @since JDK1.1\n-     */\n-    public void list(PrintWriter out) {\n-        Enumeration keys = keys();\n-        Enumeration elts = elements();\n-        while (keys.hasMoreElements()) {\n-            String key = (String) keys.nextElement();\n-            String elt = (String) elts.nextElement();\n-            String output = formatForOutput(key,elt);\n-            out.println(output);\n-        }\n-    }\n+  /**\n+   * Writes the key/value pairs to the given print writer.  They are\n+   * written in the way, described in the method store.\n+   * @param out the writer, where the key/value pairs are written to.\n+   * @exception ClassCastException if this property contains any key or\n+   * value that isn't a string.\n+   * @see #store\n+   * @see #list(java.io.PrintStream)\n+   * @since JDK1.1\n+   */\n+  public void list(PrintWriter out)\n+  {\n+    Enumeration keys = keys();\n+    Enumeration elts = elements();\n+    while (keys.hasMoreElements())\n+      {\n+\tString key = (String) keys.nextElement();\n+\tString elt = (String) elts.nextElement();\n+\tString output = formatForOutput(key, elt);\n+\tout.println(output);\n+      }\n+  }\n }"}, {"sha": "2de57a175ac7c3765e528d81b0dfa9ac404ab3eb", "filename": "libjava/java/util/SortedMap.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FSortedMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FSortedMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FSortedMap.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -30,7 +30,8 @@\n \n package java.util;\n \n-public interface SortedMap extends Map {\n+public interface SortedMap extends Map\n+{\n   Comparator comparator();\n   Object firstKey();\n   SortedMap headMap(Object toKey);"}, {"sha": "8647fa48b087e3c266aa82675cdd0aeec9281a91", "filename": "libjava/java/util/Stack.java", "status": "modified", "additions": 92, "deletions": 29, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FStack.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86c9776ba2553c7c7938c07311436cc9604ef34c/libjava%2Fjava%2Futil%2FStack.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FStack.java?ref=86c9776ba2553c7c7938c07311436cc9604ef34c", "patch": "@@ -1,42 +1,89 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Stack.java - Class that provides a Last In First Out (LIFO)\n+   datatype, known more commonly as a Stack\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n \n-/**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date August 20, 1998.\n- */\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct\n  */\n \n+/**\n+ * Stack provides a Last In First Out (LIFO) data type, commonly known\n+ * as a Stack.  \n+ *\n+ * Stack itself extends Vector and provides the additional methods\n+ * for stack manipulation (push, pop, peek). \n+ *\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @date August 20, 1998.\n+ */\n public class Stack extends Vector\n {\n   // Could use Vector methods internally for the following methods\n   // but have used Vector fields directly for efficiency (i.e. this\n   // often reduces out duplicate bounds checking).\n \n-  public boolean empty()\n+  private static final long serialVersionUID = 1224463164541339165L;\n+\n+  /**\n+   * This constructor creates a new Stack, initially empty\n+   */\n+  public Stack()\n   {\n-    return elementCount == 0;\n+    super();\n   }\n \n-  public synchronized Object peek()\n+  /**\n+   * Pushes an Object onto the top of the stack.  This method is effectively\n+   * the same as addElement(item)\n+   *\n+   * @param item the Object to push onto the stack\n+   * @returns the Object pushed onto the stack\n+   * @see java.util.Vector#addElement(java.util.Object)\n+   */\n+  public Object push(Object item)\n   {\n-    if (elementCount == 0)\n-      throw new EmptyStackException();\n+    // When growing the Stack, use the Vector routines in case more\n+    // memory is needed.\n+    // Note: spec indicates that this method *always* returns obj passed in!\n \n-    return elementData[elementCount - 1];\n+    addElement(item);\n+    return item;\n   }\n \n+  /**\n+   * Pops an item from the stack and returns it.  The item popped is\n+   * removed from the Stack\n+   *\n+   * @returns the Object popped from the stack\n+   */\n   public synchronized Object pop()\n   {\n     if (elementCount == 0)\n@@ -49,28 +96,44 @@ public synchronized Object pop()\n     return obj;\n   }\n \n-  public Object push(Object obj)\n+  /**\n+   * Returns the top Object on the stack without removing it\n+   *\n+   * @returns the top Object on the stack\n+   */\n+  public synchronized Object peek()\n   {\n-    // When growing the Stack, use the Vector routines in case more\n-    // memory is needed.\n-    // Note: spec indicates that this method *always* returns obj passed in!\n+    if (elementCount == 0)\n+      throw new EmptyStackException();\n \n-    addElement(obj);\n-    return obj;\n+    return elementData[elementCount - 1];\n   }\n \n-  public synchronized int search(Object obj)\n+  /**\n+   * Tests if the stack is empty\n+   *\n+   * @returns true if the stack contains no items, false otherwise\n+   */\n+  public boolean empty()\n   {\n-    // Return the position of obj on the stack as measured from the top;\n-    // i.e. the top element is 1, the next element down is 2, etc.\n-    // If obj is not on the stack, return -1\n+    return elementCount == 0;\n+  }\n \n+  /**\n+   * Returns the position of an Object on the stack, with the top\n+   * most Object being at position 1, and each Object deeper in the\n+   * stack at depth + 1\n+   *\n+   * @param o The object to search for\n+   * @returns The 1 based depth of the Object, or -1 if the Object \n+   * is not on the stack.\n+   */\n+  public synchronized int search(Object o)\n+  {\n     for (int i = elementCount-1; i >=0; --i)\n-      if (elementData[i].equals(obj))\n-\treturn elementCount - i;\n+      if (elementData[i].equals(o))\n+        return elementCount - i;\n \n     return -1;\n   }\n-\n-  private static final long serialVersionUID = 1224463164541339165L;\n }"}]}