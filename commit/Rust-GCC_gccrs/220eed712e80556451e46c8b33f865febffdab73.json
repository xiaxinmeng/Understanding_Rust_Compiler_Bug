{"sha": "220eed712e80556451e46c8b33f865febffdab73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIwZWVkNzEyZTgwNTU2NDUxZTQ2YzhiMzNmODY1ZmViZmZkYWI3Mw==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1990-03-30T02:41:07Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1990-03-30T02:41:07Z"}, "message": "entered into RCS\n\nFrom-SVN: r10", "tree": {"sha": "f839f56aedd69acc7185e00d39aa319c92d1407e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f839f56aedd69acc7185e00d39aa319c92d1407e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/220eed712e80556451e46c8b33f865febffdab73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220eed712e80556451e46c8b33f865febffdab73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/220eed712e80556451e46c8b33f865febffdab73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220eed712e80556451e46c8b33f865febffdab73/comments", "author": null, "committer": null, "parents": [{"sha": "a5eca796056811719d7ab36624d406c686a07ed4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5eca796056811719d7ab36624d406c686a07ed4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5eca796056811719d7ab36624d406c686a07ed4"}], "stats": {"total": 462, "additions": 462, "deletions": 0}, "files": [{"sha": "0edd8d67915e257c6228033fd1e658f33cb0c851", "filename": "gcc/ginclude/math-3300.h", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220eed712e80556451e46c8b33f865febffdab73/gcc%2Fginclude%2Fmath-3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220eed712e80556451e46c8b33f865febffdab73/gcc%2Fginclude%2Fmath-3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fmath-3300.h?ref=220eed712e80556451e46c8b33f865febffdab73", "patch": "@@ -0,0 +1,462 @@\n+/******************************************************************\\\n+*\t\t\t\t\t\t\t\t   *\n+*  <math-68881.h>\t\tlast modified: 18 May 1989.\t   *\n+*\t\t\t\t\t\t\t\t   *\n+*  Copyright (C) 1989 by Matthew Self.\t\t\t\t   *\n+*  You may freely distribute verbatim copies of this software\t   *\n+*  provided that this copyright notice is retained in all copies.  *\n+*  You may distribute modifications to this software under the     *\n+*  conditions above if you also clearly note such modifications    *\n+*  with their author and date.\t\t\t   \t     \t   *\n+*\t\t\t\t\t\t\t\t   *\n+*  Note:  errno is not set to EDOM when domain errors occur for    *\n+*  most of these functions.  Rather, it is assumed that the\t   *\n+*  68881's OPERR exception will be enabled and handled\t\t   *\n+*  appropriately by the\toperating system.  Similarly, overflow\t   *\n+*  and underflow do not set errno to ERANGE.\t\t\t   *\n+*\t\t\t\t\t\t\t\t   *\n+*  Send bugs to Matthew Self (self@bayes.arc.nasa.gov).\t\t   *\n+*\t\t\t\t\t\t\t\t   *\n+\\******************************************************************/\n+\n+#include <errno.h>\n+\n+#ifndef HUGE_VAL\n+#define HUGE_VAL\t\t\t\t\t\t\t\\\n+({\t\t\t\t\t\t\t\t\t\\\n+  double huge_val;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  __asm (\"fmove%.d %#0x7ff0000000000000,%0\"\t/* Infinity */\t\t\\\n+\t : \"=f\" (huge_val)\t\t\t\t\t\t\\\n+\t : /* no inputs */);\t\t\t\t\t\t\\\n+  huge_val;\t\t\t\t\t\t\t\t\\\n+})\n+#endif\n+\n+__inline static const double sin (double x)\n+{\n+  double value;\n+\n+  __asm (\"fsin%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double cos (double x)\n+{\n+  double value;\n+\n+  __asm (\"fcos%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double tan (double x)\n+{\n+  double value;\n+\n+  __asm (\"ftan%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double asin (double x)\n+{\n+  double value;\n+\n+  __asm (\"fasin%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double acos (double x)\n+{\n+  double value;\n+\n+  __asm (\"facos%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double atan (double x)\n+{\n+  double value;\n+\n+  __asm (\"fatan%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double atan2 (double y, double x)\n+{\n+  double pi, pi_over_2;\n+\n+  __asm (\"fmovecr%.x %#0,%0\"\t\t/* extended precision pi */\n+\t : \"=f\" (pi)\n+\t : /* no inputs */ );\n+  __asm (\"fscale%.b %#-1,%0\"\t\t/* no loss of accuracy */\n+\t : \"=f\" (pi_over_2)\n+\t : \"0\" (pi));\n+  if (x > 0)\n+    {\n+      if (y > 0)\n+\t{\n+\t  if (x > y)\n+\t    return atan (y / x);\n+\t  else\n+\t    return pi_over_2 - atan (x / y);\n+\t}\n+      else\n+\t{\n+\t  if (x > -y)\n+\t    return atan (y / x);\n+\t  else\n+\t    return - pi_over_2 - atan (x / y);\n+\t}\n+    }\n+  else\n+    {\n+      if (y > 0)\n+\t{\n+\t  if (-x > y)\n+\t    return pi + atan (y / x);\n+\t  else\n+\t    return pi_over_2 - atan (x / y);\n+\t}\n+      else\n+\t{\n+\t  if (-x > -y)\n+\t    return - pi + atan (y / x);\n+\t  else if (y < 0)\n+\t    return - pi_over_2 - atan (x / y);\n+\t  else\n+\t    {\n+\t      double value;\n+\n+\t      errno = EDOM;\n+\t      __asm (\"fmove%.d %#0x7fffffffffffffff,%0\" \t/* quiet NaN */\n+\t\t     : \"=f\" (value)\n+\t\t     : /* no inputs */);\n+\t      return value;\n+\t    }\n+\t}\n+    }\n+}\n+\n+__inline static const double sinh (double x)\n+{\n+  double value;\n+\n+  __asm (\"fsinh%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double cosh (double x)\n+{\n+  double value;\n+\n+  __asm (\"fcosh%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double tanh (double x)\n+{\n+  double value;\n+\n+  __asm (\"ftanh%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double atanh (double x)\n+{\n+  double value;\n+\n+  __asm (\"fatanh%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double exp (double x)\n+{\n+  double value;\n+\n+  __asm (\"fetox%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double expm1 (double x)\n+{\n+  double value;\n+\n+  __asm (\"fetoxm1%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double log (double x)\n+{\n+  double value;\n+\n+  __asm (\"flogn%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double log1p (double x)\n+{\n+  double value;\n+\n+  __asm (\"flognp1%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double log10 (double x)\n+{\n+  double value;\n+\n+  __asm (\"flog10%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double sqrt (double x)\n+{\n+  double value;\n+\n+  __asm (\"fsqrt%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double pow (const double x, const double y)\n+{\n+  if (x > 0)\n+    return exp (y * log (x));\n+  else if (x == 0)\n+    {\n+      if (y > 0)\n+\treturn 0.0;\n+      else\n+\t{\n+\t  double value;\n+\n+\t  errno = EDOM;\n+\t  __asm (\"fmove%.d %#0x7fffffffffffffff,%0\"\t\t/* quiet NaN */\n+\t\t : \"=f\" (value)\n+\t\t : /* no inputs */);\n+\t  return value;\n+\t}\n+    }\n+  else\n+    {\n+      double temp;\n+\n+      __asm (\"fintrz%.x %1,%0\"\n+\t     : \"=f\" (temp)\t\t\t/* integer-valued float */\n+\t     : \"f\" (y));\n+      if (y == temp)\n+        {\n+\t  int i = (int) y;\n+\t  \n+\t  if (i & 1 == 0)\t\t\t/* even */\n+\t    return exp (y * log (x));\n+\t  else\n+\t    return - exp (y * log (x));\n+        }\n+      else\n+        {\n+\t  double value;\n+\n+\t  errno = EDOM;\n+\t  __asm (\"fmove%.d %#0x7fffffffffffffff,%0\"\t\t/* quiet NaN */\n+\t\t : \"=f\" (value)\n+\t\t : /* no inputs */);\n+\t  return value;\n+        }\n+    }\n+}\n+\n+__inline static const double fabs (double x)\n+{\n+  double value;\n+\n+  __asm (\"fabs%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double ceil (double x)\n+{\n+  int rounding_mode, round_up;\n+  double value;\n+\n+  __asm volatile (\"fmove%.l %%fpcr,%0\"\n+\t\t  : \"=dm\" (rounding_mode)\n+\t\t  : /* no inputs */ );\n+  round_up = rounding_mode | 0x30;\n+  __asm volatile (\"fmove%.l %0,%%fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (round_up));\n+  __asm volatile (\"fint%.x %1,%0\"\n+\t\t  : \"=f\" (value)\n+\t\t  : \"f\" (x));\n+  __asm volatile (\"fmove%.l %0,%%fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (rounding_mode));\n+  return value;\n+}\n+\n+__inline static const double floor (double x)\n+{\n+  int rounding_mode, round_down;\n+  double value;\n+\n+  __asm volatile (\"fmove%.l %%fpcr,%0\"\n+\t\t  : \"=dm\" (rounding_mode)\n+\t\t  : /* no inputs */ );\n+  round_down = (rounding_mode & ~0x10)\n+\t\t| 0x20;\n+  __asm volatile (\"fmove%.l %0,%%fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (round_down));\n+  __asm volatile (\"fint%.x %1,%0\"\n+\t\t  : \"=f\" (value)\n+\t\t  : \"f\" (x));\n+  __asm volatile (\"fmove%.l %0,%%fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (rounding_mode));\n+  return value;\n+}\n+\n+__inline static const double rint (double x)\n+{\n+  int rounding_mode, round_nearest;\n+  double value;\n+\n+  __asm volatile (\"fmove%.l %%fpcr,%0\"\n+\t\t  : \"=dm\" (rounding_mode)\n+\t\t  : /* no inputs */ );\n+  round_nearest = rounding_mode & ~0x30;\n+  __asm volatile (\"fmove%.l %0,%%fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (round_nearest));\n+  __asm volatile (\"fint%.x %1,%0\"\n+\t\t  : \"=f\" (value)\n+\t\t  : \"f\" (x));\n+  __asm volatile (\"fmove%.l %0,%%fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (rounding_mode));\n+  return value;\n+}\n+\n+__inline static const double fmod (double x, double y)\n+{\n+  double value;\n+\n+  __asm (\"fmod%.x %2,%0\"\n+\t : \"=f\" (value)\n+\t : \"0\" (x),\n+\t   \"f\" (y));\n+  return value;\n+}\n+\n+__inline static const double drem (double x, double y)\n+{\n+  double value;\n+\n+  __asm (\"frem%.x %2,%0\"\n+\t : \"=f\" (value)\n+\t : \"0\" (x),\n+\t   \"f\" (y));\n+  return value;\n+}\n+\n+__inline static const double scalb (double x, int n)\n+{\n+  double value;\n+\n+  __asm (\"fscale%.l %2,%0\"\n+\t : \"=f\" (value)\n+\t : \"0\" (x),\n+\t   \"dmi\" (n));\n+  return value;\n+}\n+\n+__inline static double logb (double x)\n+{\n+  double exponent;\n+\n+  __asm (\"fgetexp%.x %1,%0\"\n+\t : \"=f\" (exponent)\n+\t : \"f\" (x));\n+  return exponent;\n+}\n+\n+__inline static const double ldexp (double x, int n)\n+{\n+  double value;\n+\n+  __asm (\"fscale%.l %2,%0\"\n+\t : \"=f\" (value)\n+\t : \"0\" (x),\n+\t   \"dmi\" (n));\n+  return value;\n+}\n+\n+__inline static double frexp (double x, int *exp)\n+{\n+  double float_exponent;\n+  int int_exponent;\n+  double mantissa;\n+\n+  __asm (\"fgetexp%.x %1,%0\"\n+\t : \"=f\" (float_exponent) \t/* integer-valued float */\n+\t : \"f\" (x));\n+  int_exponent = (int) float_exponent;\n+  __asm (\"fgetman%.x %1,%0\"\n+\t : \"=f\" (mantissa)\t\t/* 1.0 <= mantissa < 2.0 */\n+\t : \"f\" (x));\n+  if (mantissa != 0)\n+    {\n+      __asm (\"fscale%.b %#-1,%0\"\n+\t     : \"=f\" (mantissa)\t\t/* mantissa /= 2.0 */\n+\t     : \"0\" (mantissa));\n+      int_exponent += 1;\n+    }\n+  *exp = int_exponent;\n+  return mantissa;\n+}\n+\n+__inline static double modf (double x, double *ip)\n+{\n+  double temp;\n+\n+  __asm (\"fintrz%.x %1,%0\"\n+\t : \"=f\" (temp)\t\t\t/* integer-valued float */\n+\t : \"f\" (x));\n+  *ip = temp;\n+  return x - temp;\n+}\n+"}]}