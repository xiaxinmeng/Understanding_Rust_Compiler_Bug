{"sha": "5680076c75fcecc23414bba2fd1585bb264f6f63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY4MDA3NmM3NWZjZWNjMjM0MTRiYmEyZmQxNTg1YmIyNjRmNmY2Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-09T21:51:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-09T21:51:41Z"}, "message": "Add port done awhile ago for the ARC cpu.\n\n        * arc/arc.h: New file.\n        * arc/arc.c: New file.\n        * arc/arc.md: New file.\n        * arc/initfini.c: New file.\n        * arc/lib1funcs.asm: New file.\n        * arc/t-arc: New file.\n        * arc/xm-arc.h: New file.\n        * ginclude/va-arc.h: New file.\n        * ginclude/stdarg.h: Include va-arc.h ifdef __arc__.\n        * ginclude/varargs.h: Likewise.\n        * Makefile.in (USER_H): Add va-arc.h.\n        * configure.in (arc-*-elf*): Recognize.\n        * longlong.h: Add ARC support.\nMostly so I can test changes in snapshot scripts.\n\n        * expr.c (clear_storage): Use CONST0_RTX instead of const0_rtx.\n        when clearing non-BLKmode data.\nFixes sparc problem.\n\nFrom-SVN: r15187", "tree": {"sha": "bc1fc1d9b4918634297867f80c3808a6f655844d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc1fc1d9b4918634297867f80c3808a6f655844d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5680076c75fcecc23414bba2fd1585bb264f6f63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5680076c75fcecc23414bba2fd1585bb264f6f63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5680076c75fcecc23414bba2fd1585bb264f6f63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5680076c75fcecc23414bba2fd1585bb264f6f63/comments", "author": null, "committer": null, "parents": [{"sha": "e90d5e5777bdcc2dde1f51b96bec050653a94eb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90d5e5777bdcc2dde1f51b96bec050653a94eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90d5e5777bdcc2dde1f51b96bec050653a94eb1"}], "stats": {"total": 1630, "additions": 1630, "deletions": 0}, "files": [{"sha": "0894f79151ad9908575a353bbd409b5d32467974", "filename": "gcc/config/arc/arc.md", "status": "added", "additions": 1630, "deletions": 0, "changes": 1630, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5680076c75fcecc23414bba2fd1585bb264f6f63/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5680076c75fcecc23414bba2fd1585bb264f6f63/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=5680076c75fcecc23414bba2fd1585bb264f6f63", "patch": "@@ -0,0 +1,1630 @@\n+;; Machine description of the ARC cpu for GNU C compiler\n+;; Copyright (C) 1994, 1997 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;; ??? This is an old port, and is undoubtedly suffering from bit rot.\n+\f\n+;; Insn type.  Used to default other attribute values.\n+\n+(define_attr \"type\"\n+  \"move,load,store,cmove,unary,binary,compare,shift,mul,uncond_branch,branch,call,call_no_delay_slot,multi,misc\"\n+  (const_string \"binary\"))\n+\n+;; Length (in # of insns, long immediate constants counted too).\n+;; ??? There's a nasty interaction between the conditional execution fsm\n+;; and insn lengths: insns with shimm values cannot be conditionally executed.\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"type\" \"load\")\n+\t (if_then_else (match_operand 1 \"long_immediate_loadstore_operand\" \"\")\n+\t\t       (const_int 2) (const_int 1))\n+\n+\t (eq_attr \"type\" \"store\")\n+\t (if_then_else (match_operand 0 \"long_immediate_loadstore_operand\" \"\")\n+\t\t       (const_int 2) (const_int 1))\n+\n+\t (eq_attr \"type\" \"move,unary,compare\")\n+\t (if_then_else (match_operand 1 \"long_immediate_operand\" \"\")\n+\t\t       (const_int 2) (const_int 1))\n+\n+\t (eq_attr \"type\" \"binary,mul\")\n+\t (if_then_else (match_operand 2 \"long_immediate_operand\" \"\")\n+\t\t       (const_int 2) (const_int 1))\n+\n+\t (eq_attr \"type\" \"cmove\")\n+\t (if_then_else (match_operand 2 \"register_operand\" \"\")\n+\t\t       (const_int 1) (const_int 2))\n+\n+\t (eq_attr \"type\" \"multi\") (const_int 2)\n+\t]\n+\n+\t(const_int 1)))\n+\n+;; The length here is the length of a single asm.  Unfortunately it might be\n+;; 1 or 2 so we must allow for 2.  That's ok though.  How often will users\n+;; lament asm's not being put in delay slots?\n+(define_asm_attributes\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"type\" \"multi\")])\n+\n+;; Condition codes: this one is used by final_prescan_insn to speed up\n+;; conditionalizing instructions.  It saves having to scan the rtl to see if\n+;; it uses or alters the condition codes.\n+\n+;; USE: This insn uses the condition codes (eg: a conditional branch).\n+;; CANUSE: This insn can use the condition codes (for conditional execution).\n+;; SET: All condition codes are set by this insn.\n+;; SET_ZN: the Z and N flags are set by this insn.\n+;; SET_ZNC: the Z, N, and C flags are set by this insn.\n+;; CLOB: The condition codes are set to unknown values by this insn.\n+;; NOCOND: This insn can't use and doesn't affect the condition codes.\n+\n+(define_attr \"cond\" \"use,canuse,set,set_zn,set_znc,clob,nocond\"\n+  (cond [(and (eq_attr \"type\" \"unary,binary,move\")\n+\t      (eq_attr \"length\" \"1\"))\n+\t (const_string \"canuse\")\n+\n+\t (eq_attr \"type\" \"compare\")\n+\t (const_string \"set\")\n+\n+\t (eq_attr \"type\" \"cmove,branch\")\n+\t (const_string \"use\")\n+\n+\t (eq_attr \"type\" \"multi,misc\")\n+\t (const_string \"clob\")\n+\t ]\n+\n+\t (const_string \"nocond\")))\n+\f\n+;; Delay slots.\n+\n+(define_attr \"in_delay_slot\" \"false,true\"\n+  (cond [(eq_attr \"type\" \"uncond_branch,branch,call,call_no_delay_slot,multi\")\n+\t (const_string \"false\")\n+\t ]\n+\n+\t (if_then_else (eq_attr \"length\" \"1\")\n+\t\t       (const_string \"true\")\n+\t\t       (const_string \"false\"))))\n+\n+(define_delay (eq_attr \"type\" \"call\")\n+  [(eq_attr \"in_delay_slot\" \"true\")\n+   (eq_attr \"in_delay_slot\" \"true\")\n+   (eq_attr \"in_delay_slot\" \"true\")])\n+\n+(define_delay (eq_attr \"type\" \"branch,uncond_branch\")\n+  [(eq_attr \"in_delay_slot\" \"true\")\n+   (eq_attr \"in_delay_slot\" \"true\")\n+   (eq_attr \"in_delay_slot\" \"true\")])\n+\f   \n+;; Function units of the ARC\n+\n+;; (define_function_unit {name} {num-units} {n-users} {test}\n+;;                       {ready-delay} {issue-delay} [{conflict-list}])\n+\n+;; 1) A conditional jump cannot immediately follow the insn setting the flags.\n+;; This isn't a complete solution as it doesn't come with guarantees.  That\n+;; is done in the branch patterns and in arc_print_operand.  This exists to\n+;; avoid inserting a nop when we can.\n+(define_function_unit \"compare\" 1 0 (eq_attr \"type\" \"compare\") 2 2 [(eq_attr \"type\" \"branch\")])\n+\n+;; 2) References to loaded registers should wait a cycle.\n+\n+;; Memory with load-delay of 1 (i.e., 2 cycle load).\n+(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 2 0)\n+\n+;; Units that take one cycle do not need to be specified.\n+\f\n+;; Move instructions.\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (QImode, operands[1]);\n+}\")\n+\n+(define_insn \"*movqi_insn\"\n+  [(set (match_operand:QI 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:QI 1 \"move_src_operand\" \"rI,Ji,m,r\"))]\n+;; ??? Needed?\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\"\n+  \"@\n+   mov%? %0,%1\n+   mov%? %0,%1\n+   ldb%U1%V1 %0,%1\n+   stb%U0%V0 %1,%0\"\n+  [(set_attr \"type\" \"move,move,load,store\")])\n+\n+;; ??? This may never match since there's no cmpqi insn.\n+\n+(define_insn \"*movqi_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (sign_extend:SI (match_operand:QI 1 \"move_src_operand\" \"rIJi\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:QI 0 \"move_dest_operand\" \"=r\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"mov%?.f %0,%1\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"cond\" \"set_zn\")])\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (HImode, operands[1]);\n+}\")\n+\n+(define_insn \"*movhi_insn\"\n+  [(set (match_operand:HI 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:HI 1 \"move_src_operand\" \"rI,Ji,m,r\"))]\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\"\n+  \"@\n+   mov%? %0,%1\n+   mov%? %0,%1\n+   ldw%U1%V1 %0,%1\n+   stw%U0%V0 %1,%0\"\n+  [(set_attr \"type\" \"move,move,load,store\")])\n+\n+;; ??? Will this ever match?\n+\n+(define_insn \"*movhi_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (sign_extend:SI (match_operand:HI 1 \"move_src_operand\" \"rIJi\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:HI 0 \"move_dest_operand\" \"=r\")\n+\t(match_dup 1))]\n+;; ??? Needed?\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\"\n+  \"mov%?.f %0,%1\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"cond\" \"set_zn\")])\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (SImode, operands[1]);\n+}\")\n+\n+(define_insn \"*movsi_insn\"\n+  [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:SI 1 \"move_src_operand\" \"rI,GJi,m,r\"))]\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\"\n+  \"@\n+   mov%? %0,%1\n+   mov%? %0,%S1\n+   ld%U1%V1 %0,%1\n+   st%U0%V0 %1,%0\"\n+  [(set_attr \"type\" \"move,move,load,store\")])\n+\n+(define_insn \"*movsi_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (match_operand:SI 1 \"move_src_operand\" \"rIJi\")\n+\t\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"move_dest_operand\" \"=r\")\n+\t(match_dup 1))]\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\"\n+  \"mov%?.f %0,%S1\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"cond\" \"set_zn\")])\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (DImode, operands[1]);\n+}\")\n+\n+(define_insn \"*movdi_insn\"\n+  [(set (match_operand:DI 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:DI 1 \"move_double_src_operand\" \"r,HK,m,r\"))]\n+  \"register_operand (operands[0], DImode)\n+   || register_operand (operands[1], DImode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0 :\n+      /* We normally copy the low-numbered register first.  However, if\n+\t the first register operand 0 is the same as the second register of\n+\t operand 1, we must copy in the opposite order.  */\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"mov %R0,%R1\\;mov %0,%1\\\";\n+      else\n+\treturn \\\"mov %0,%1\\;mov %R0,%R1\\\";\n+    case 1 :\n+      return \\\"mov %0,%L1\\;mov %R0,%H1\\\";\n+    case 2 :\n+      /* If the low-address word is used in the address, we must load it\n+\t last.  Otherwise, load it first.  Note that we cannot have\n+\t auto-increment in that case since the address register is known to be\n+\t dead.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands [1], 0))\n+\t  return \\\"ld%V1 %R0,%R1\\;ld%V1 %0,%1\\\";\n+      else\n+\t  return \\\"ld%V1 %0,%1\\;ld%V1 %R0,%R1\\\";\n+    case 3 :\n+      return \\\"st%V0 %1,%0\\;st%V0 %R1,%R0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,move,load,store\")\n+   ;; ??? The ld/st values could be 4 if it's [reg,bignum].\n+   (set_attr \"length\" \"2,4,2,2\")])\n+\n+;(define_expand \"movdi\"\n+;  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+;\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+;  \"\"\n+;  \"\n+;{\n+;  /* Flow doesn't understand that this is effectively a DFmode move.\n+;     It doesn't know that all of `operands[0]' is set.  */\n+;  emit_insn (gen_rtx (CLOBBER, VOIDmode, operands[0]));\n+;\n+;  /* Emit insns that movsi_insn can handle.  */\n+;  emit_insn (gen_movsi (operand_subword (operands[0], 0, 0, DImode),\n+;\t\t\toperand_subword (operands[1], 0, 0, DImode)));\n+;  emit_insn (gen_movsi (operand_subword (operands[0], 1, 0, DImode),\n+;\t\t\toperand_subword (operands[1], 1, 0, DImode)));\n+;  DONE;\n+;}\")\n+\f\n+;; Floating point move insns.\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = force_const_mem (SFmode, operands[1]);\n+#endif\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (SFmode, operands[1]);\n+}\")\n+\n+(define_insn \"*movsf_insn\"\n+  [(set (match_operand:SF 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:SF 1 \"move_src_operand\" \"r,E,m,r\"))]\n+  \"register_operand (operands[0], SFmode)\n+   || register_operand (operands[1], SFmode)\"\n+  \"@\n+   mov%? %0,%1\n+   mov%? %0,%1 ; %A1\n+   ld%U1%V1 %0,%1\n+   st%U0%V0 %1,%0\"\n+  [(set_attr \"type\" \"move,move,load,store\")])\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+\n+#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = force_const_mem (DFmode, operands[1]);\n+#endif\n+\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (DFmode, operands[1]);\n+}\")\n+\n+(define_insn \"*movdf_insn\"\n+  [(set (match_operand:DF 0 \"move_dest_operand\" \"=r,r,r,m\")\n+\t(match_operand:DF 1 \"move_double_src_operand\" \"r,E,m,r\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0 :\n+      /* We normally copy the low-numbered register first.  However, if\n+\t the first register operand 0 is the same as the second register of\n+\t operand 1, we must copy in the opposite order.  */\n+      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+\treturn \\\"mov %R0,%R1\\;mov %0,%1\\\";\n+      else\n+\treturn \\\"mov %0,%1\\;mov %R0,%R1\\\";\n+    case 1 :\n+      return \\\"mov %0,%L1\\;mov %R0,%H1 ; %A1\\\";\n+    case 2 :\n+      /* If the low-address word is used in the address, we must load it\n+\t last.  Otherwise, load it first.  Note that we cannot have\n+\t auto-increment in that case since the address register is known to be\n+\t dead.  */\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands [1], 0))\n+\treturn \\\"ld%V1 %R0,%R1\\;ld%V1 %0,%1\\\";\n+      else\n+\treturn \\\"ld%V1 %0,%1\\;ld%V1 %R0,%R1\\\";\n+    case 3 :\n+      return \\\"st%V0 %1,%0\\;st%V0 %R1,%R0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move,move,load,store\")\n+   ;; ??? The ld/st values could be 4 if it's [reg,bignum].\n+   (set_attr \"length\" \"2,4,2,2\")])\n+\n+;(define_expand \"movdf\"\n+;  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+;\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+;  \"\"\n+;  \"\n+;{\n+;  /* Flow doesn't understand that this is effectively a DFmode move.\n+;     It doesn't know that all of `operands[0]' is set.  */\n+;  emit_insn (gen_rtx (CLOBBER, VOIDmode, operands[0]));\n+;\n+;  /* Emit insns that movsi_insn can handle.  */\n+;  emit_insn (gen_movsi (operand_subword (operands[0], 0, 0, DFmode),\n+;\t\t\toperand_subword (operands[1], 0, 0, DFmode)));\n+;  emit_insn (gen_movsi (operand_subword (operands[0], 1, 0, DFmode),\n+;\t\t\toperand_subword (operands[1], 1, 0, DFmode)));\n+;  DONE;\n+;}\")\n+\f\n+;; Load/Store with update instructions.\n+;;\n+;; Some of these we can get by using pre-decrement or pre-increment, but the\n+;; hardware can also do cases where the increment is not the size of the\n+;; object.\n+;;\n+;; In all these cases, we use operands 0 and 1 for the register being\n+;; incremented because those are the operands that local-alloc will\n+;; tie and these are the pair most likely to be tieable (and the ones\n+;; that will benefit the most).\n+;;\n+;; We use match_operator here because we need to know whether the memory\n+;; object is volatile or not.\n+\n+(define_insn \"*loadqi_update\"\n+  [(set (match_operand:QI 3 \"register_operand\" \"=r,r\")\n+\t(match_operator:QI 4 \"load_update_operand\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")]))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ldb.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"load,load\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"*load_zeroextendqisi_update\"\n+  [(set (match_operand:SI 3 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operator:QI 4 \"load_update_operand\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")])))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ldb.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"load,load\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"*load_signextendqisi_update\"\n+  [(set (match_operand:SI 3 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operator:QI 4 \"load_update_operand\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")])))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ldb.x.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"load,load\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"*storeqi_update\"\n+  [(set (match_operator:QI 4 \"store_update_operand\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0\")\n+\t  (match_operand:SI 2 \"short_immediate_operand\" \"I\")])\n+\t(match_operand:QI 3 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"stb.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"*loadhi_update\"\n+  [(set (match_operand:HI 3 \"register_operand\" \"=r,r\")\n+\t(match_operator:HI 4 \"load_update_operand\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")]))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ldw.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"load,load\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"*load_zeroextendhisi_update\"\n+  [(set (match_operand:SI 3 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operator:HI 4 \"load_update_operand\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")])))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ldw.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"load,load\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"*load_signextendhisi_update\"\n+  [(set (match_operand:SI 3 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operator:HI 4 \"load_update_operand\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")])))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ldw.x.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"load,load\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"*storehi_update\"\n+  [(set (match_operator:HI 4 \"store_update_operand\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0\")\n+\t  (match_operand:SI 2 \"short_immediate_operand\" \"I\")])\n+\t(match_operand:HI 3 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"stw.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"*loadsi_update\"\n+  [(set (match_operand:SI 3 \"register_operand\" \"=r,r\")\n+\t(match_operator:SI 4 \"load_update_operand\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")]))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ld.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"load,load\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"*storesi_update\"\n+  [(set (match_operator:SI 4 \"store_update_operand\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0\")\n+\t  (match_operand:SI 2 \"short_immediate_operand\" \"I\")])\n+\t(match_operand:SI 3 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"st.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"*loadsf_update\"\n+  [(set (match_operand:SF 3 \"register_operand\" \"=r,r\")\n+\t(match_operator:SF 4 \"load_update_operand\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")]))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"ld.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"load,load\")\n+   (set_attr \"length\" \"1,2\")])\n+\n+(define_insn \"*storesf_update\"\n+  [(set (match_operator:SF 4 \"store_update_operand\"\n+\t [(match_operand:SI 1 \"register_operand\" \"0\")\n+\t  (match_operand:SI 2 \"short_immediate_operand\" \"I\")])\n+\t(match_operand:SF 3 \"register_operand\" \"r\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"st.a%V4 %3,[%0,%2]\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"1\")])\n+\f\n+;; Conditional move instructions.\n+\n+(define_expand \"movsicc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"\")\n+\t\t      (match_operand:SI 3 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx ccreg = gen_rtx (REG,\n+\t\t       SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n+\t\t       61);\n+\n+  operands[1] = gen_rtx (code, VOIDmode, ccreg, const0_rtx);\n+}\")\n+\n+;(define_expand \"movdicc\"\n+;  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+;\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+;\t\t      (match_operand:DI 2 \"nonmemory_operand\" \"\")\n+;\t\t      (match_operand:DI 3 \"register_operand\" \"\")))]\n+;  \"0 /* ??? this would work better if we had cmpdi */\"\n+;  \"\n+;{\n+;  enum rtx_code code = GET_CODE (operands[1]);\n+;  rtx ccreg = gen_rtx (REG,\n+;\t\t       SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n+;\t\t       61);\n+;\n+;  operands[1] = gen_rtx (code, VOIDmode, ccreg, const0_rtx);\n+;}\")\n+\n+(define_expand \"movsfcc\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+\t\t      (match_operand:SF 2 \"nonmemory_operand\" \"\")\n+\t\t      (match_operand:SF 3 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx ccreg = gen_rtx (REG,\n+\t\t       SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n+\t\t       61);\n+\n+  operands[1] = gen_rtx (code, VOIDmode, ccreg, const0_rtx);\n+}\")\n+\n+;(define_expand \"movdfcc\"\n+;  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+;\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+;\t\t      (match_operand:DF 2 \"nonmemory_operand\" \"\")\n+;\t\t      (match_operand:DF 3 \"register_operand\" \"\")))]\n+;  \"0 /* ??? can generate less efficient code if constants involved */\"\n+;  \"\n+;{\n+;  enum rtx_code code = GET_CODE (operands[1]);\n+;  rtx ccreg = gen_rtx (REG,\n+;\t\t       SELECT_CC_MODE (code, arc_compare_op0, arc_compare_op1),\n+;\t\t       61);\n+;\n+;  operands[1] = gen_rtx (code, VOIDmode, ccreg, const0_rtx);\n+;}\")\n+\n+(define_insn \"*movsicc_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"rJi\")\n+\t\t      (match_operand:SI 3 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"mov.%d1 %0,%S2\"\n+  [(set_attr \"type\" \"cmove\")])\n+\n+; ??? This doesn't properly handle constants.\n+;(define_insn \"*movdicc_insn\"\n+;  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+;\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+;\t\t      (match_operand:DI 2 \"nonmemory_operand\" \"r,Ji\")\n+;\t\t      (match_operand:DI 3 \"register_operand\" \"0,0\")))]\n+;  \"0\"\n+;  \"*\n+;{\n+;  switch (which_alternative)\n+;    {\n+;    case 0 :\n+;      /* We normally copy the low-numbered register first.  However, if\n+;\t the first register operand 0 is the same as the second register of\n+;\t operand 1, we must copy in the opposite order.  */\n+;      if (REGNO (operands[0]) == REGNO (operands[2]) + 1)\n+;\treturn \\\"mov.%d1 %R0,%R2\\;mov.%d1 %0,%2\\\";\n+;      else\n+;\treturn \\\"mov.%d1 %0,%2\\;mov.%d1 %R0,%R2\\\";\n+;    case 1 :\n+;      return \\\"mov.%d1 %0,%2\\;mov.%d1 %R0,%R2\\\";\n+;    }\n+;}\"\n+;  [(set_attr \"type\" \"cmove,cmove\")\n+;   (set_attr \"length\" \"2,4\")])\n+\n+(define_insn \"*movsfcc_insn\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,r\")\n+\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+\t\t      (match_operand:SF 2 \"nonmemory_operand\" \"r,E\")\n+\t\t      (match_operand:SF 3 \"register_operand\" \"0,0\")))]\n+  \"\"\n+  \"@\n+   mov.%d1 %0,%2\n+   mov.%d1 %0,%2 ; %A2\"\n+  [(set_attr \"type\" \"cmove,cmove\")])\n+\n+;(define_insn \"*movdfcc_insn\"\n+;  [(set (match_operand:DF 0 \"register_operand\" \"=r,r\")\n+;\t(if_then_else (match_operand 1 \"comparison_operator\" \"\")\n+;\t\t      (match_operand:DF 2 \"nonmemory_operand\" \"r,E\")\n+;\t\t      (match_operand:DF 3 \"register_operand\" \"0,0\")))]\n+;  \"0\"\n+;  \"*\n+;{\n+;  switch (which_alternative)\n+;    {\n+;    case 0 :\n+;      /* We normally copy the low-numbered register first.  However, if\n+;\t the first register operand 0 is the same as the second register of\n+;\t operand 1, we must copy in the opposite order.  */\n+;      if (REGNO (operands[0]) == REGNO (operands[2]) + 1)\n+;\treturn \\\"mov.%d1 %R0,%R2\\;mov.%d1 %0,%2\\\";\n+;      else\n+;\treturn \\\"mov.%d1 %0,%2\\;mov.%d1 %R0,%R2\\\";\n+;    case 1 :\n+;      return \\\"mov.%d1 %0,%L2\\;mov.%d1 %R0,%H2 ; %A2\\\";\n+;    }\n+;}\"\n+;  [(set_attr \"type\" \"cmove,cmove\")\n+;   (set_attr \"length\" \"2,4\")])\n+\f\n+;; Zero extension instructions.\n+;; ??? We don't support volatile memrefs here, but I'm not sure why.\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   extb%? %0,%1\n+   ldb%U1 %0,%1\"\n+  [(set_attr \"type\" \"unary,load\")])\n+\n+(define_insn \"*zero_extendqihi2_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI (match_dup 1)))]\n+  \"\"\n+  \"extb%?.f %0,%1\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"cond\" \"set_zn\")])\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   extb%? %0,%1\n+   ldb%U1 %0,%1\"\n+  [(set_attr \"type\" \"unary,load\")])\n+\n+(define_insn \"*zero_extendqisi2_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_dup 1)))]\n+  \"\"\n+  \"extb%?.f %0,%1\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"cond\" \"set_zn\")])\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   extw%? %0,%1\n+   ldw%U1 %0,%1\"\n+  [(set_attr \"type\" \"unary,load\")])\n+\n+(define_insn \"*zero_extendhisi2_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"r\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (match_dup 1)))]\n+  \"\"\n+  \"extw%?.f %0,%1\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"cond\" \"set_zn\")])\n+\f\n+;; Sign extension instructions.\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   sexb%? %0,%1\n+   ldb.x%U1 %0,%1\"\n+  [(set_attr \"type\" \"unary,load\")])\n+\n+(define_insn \"*extendqihi2_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (match_dup 1)))]\n+  \"\"\n+  \"sexb%?.f %0,%1\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"cond\" \"set_zn\")])\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   sexb%? %0,%1\n+   ldb.x%U1 %0,%1\"\n+  [(set_attr \"type\" \"unary,load\")])\n+\n+(define_insn \"*extendqisi2_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_dup 1)))]\n+  \"\"\n+  \"sexb%?.f %0,%1\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"cond\" \"set_zn\")])\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n+  \"\"\n+  \"@\n+   sexw%? %0,%1\n+   ldw.x%U1 %0,%1\"\n+  [(set_attr \"type\" \"unary,load\")])\n+\n+(define_insn \"*extendhisi2_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (match_dup 1)))]\n+  \"\"\n+  \"sexw%?.f %0,%1\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"cond\" \"set_zn\")])\n+\f\n+;; Arithmetic instructions.\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))]\n+  \"\"\n+  \"add%? %0,%1,%2\")\n+\n+(define_insn \"*addsi3_set_cc_insn\"\n+  [(set (reg:CC 61) (compare:CC\n+\t\t     (plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\"))\n+\t\t     (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"\"\n+  \"add%?.f %0,%1,%2\"\n+  [(set_attr \"cond\" \"set\")])\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"nonmemory_operand\" \"%r\")\n+\t\t (match_operand:DI 2 \"nonmemory_operand\" \"ri\")))\n+   (clobber (reg:CC 61))]\n+  \"\"\n+  \"*\n+{\n+  rtx op2 = operands[2];\n+\n+  if (GET_CODE (op2) == CONST_INT)\n+    {\n+      int sign = INTVAL (op2);\n+      if (sign < 0)\n+\treturn \\\"add.f %L0,%L1,%2\\;adc %H0,%H1,-1\\\";\n+      else\n+\treturn \\\"add.f %L0,%L1,%2\\;adc %H0,%H1,0\\\";\n+    }\n+  else\n+    return \\\"add.f %L0,%L1,%L2\\;adc %H0,%H1,%H2\\\";\n+}\"\n+  [(set_attr \"length\" \"2\")])\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))]\n+  \"\"\n+  \"sub%? %0,%1,%2\")\n+\n+(define_insn \"*subsi3_set_cc_insn\"\n+  [(set (reg:CC 61) (compare:CC\n+\t\t     (minus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\"))\n+\t\t     (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(minus:SI (match_dup 1)\n+\t\t  (match_dup 2)))]\n+  \"\"\n+  \"sub%?.f %0,%1,%2\"\n+  [(set_attr \"cond\" \"set\")])\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"nonmemory_operand\" \"r\")\n+\t\t  (match_operand:DI 2 \"nonmemory_operand\" \"ri\")))\n+   (clobber (reg:CC 61))]\n+  \"\"\n+  \"*\n+{\n+  rtx op2 = operands[2];\n+\n+  if (GET_CODE (op2) == CONST_INT)\n+    {\n+      int sign = INTVAL (op2);\n+      if (sign < 0)\n+\treturn \\\"sub.f %L0,%L1,%2\\;sbc %H0,%H1,-1\\\";\n+      else\n+\treturn \\\"sub.f %L0,%L1,%2\\;sbc %H0,%H1,0\\\";\n+    }\n+  else\n+    return \\\"sub.f %L0,%L1,%L2\\;sbc %H0,%H1,%H2\\\";\n+}\"\n+  [(set_attr \"length\" \"2\")])\n+\f\n+;; Boolean instructions.\n+;;\n+;; We don't define the DImode versions as expand_binop does a good enough job.\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))]\n+  \"\"\n+  \"and%? %0,%1,%2\")\n+\n+(define_insn \"*andsi3_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"\"\n+  \"and%?.f %0,%1,%2\"\n+  [(set_attr \"cond\" \"set_zn\")])\n+\n+(define_insn \"*bicsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(and:SI (match_operand:SI 1 \"nonmemory_operand\" \"r,r,I,J\")\n+\t\t(not:SI (match_operand:SI 2 \"nonmemory_operand\" \"rI,J,r,r\"))))]\n+  \"\"\n+  \"bic%? %0,%1,%2\"\n+  [(set_attr \"length\" \"1,2,1,2\")])\n+\n+(define_insn \"*bicsi3_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t\t       (not:SI (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))\n+\t\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(and:SI (match_dup 1)\n+\t\t(not:SI (match_dup 2))))]\n+  \"\"\n+  \"bic%?.f %0,%1,%2\"\n+  [(set_attr \"cond\" \"set_zn\")])\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))]\n+  \"\"\n+  \"or%? %0,%1,%2\")\n+\n+(define_insn \"*iorsi3_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (ior:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ior:SI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"\"\n+  \"or%?.f %0,%1,%2\"\n+  [(set_attr \"cond\" \"set_zn\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))]\n+  \"\"\n+  \"xor%? %0,%1,%2\")\n+\n+(define_insn \"*xorsi3_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CCZN\n+\t\t       (xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(xor:SI (match_dup 1)\n+\t\t(match_dup 2)))]\n+  \"\"\n+  \"xor%?.f %0,%1,%2\"\n+  [(set_attr \"cond\" \"set_zn\")])\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sub%? %0,0,%1\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"*negsi2_set_cc_insn\"\n+  [(set (reg:CC 61) (compare:CC\n+\t\t     (neg:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t     (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_dup 1)))]\n+  \"\"\n+  \"sub%?.f %0,0,%1\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"cond\" \"set\")])\n+\n+(define_insn \"negdi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:SI 61))]\n+  \"\"\n+  \"sub.f %L0,0,%L1\\;sbc %H0,0,%H1\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor%? %0,%1,-1\"\n+  [(set_attr \"type\" \"unary\")])\n+\n+(define_insn \"*one_cmplsi2_set_cc_insn\"\n+  [(set (reg:CCZN 61) (compare:CC\n+\t\t       (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t       (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_dup 1)))]\n+  \"\"\n+  \"xor%?.f %0,%1,-1\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"cond\" \"set_zn\")])\n+\f\n+;; Shift instructions.\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! TARGET_SHIFTER)\n+    {\n+      emit_insn (gen_rtx\n+\t\t (PARALLEL, VOIDmode,\n+\t\t  gen_rtvec (2,\n+\t\t\t     gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t\t      gen_rtx (ASHIFT, SImode, operands[1], operands[2])),\n+\t\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)))));\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! TARGET_SHIFTER)\n+    {\n+      emit_insn (gen_rtx\n+\t\t (PARALLEL, VOIDmode,\n+\t\t  gen_rtvec (2,\n+\t\t\t     gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t\t      gen_rtx (ASHIFTRT, SImode, operands[1], operands[2])),\n+\t\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)))));\n+      DONE;\n+    }\n+}\")\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (! TARGET_SHIFTER)\n+    {\n+      emit_insn (gen_rtx\n+\t\t (PARALLEL, VOIDmode,\n+\t\t  gen_rtvec (2,\n+\t\t\t     gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t\t      gen_rtx (LSHIFTRT, SImode, operands[1], operands[2])),\n+\t\t\t     gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, SImode, 0)))));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"*ashlsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"nonmemory_operand\" \"r,r,I,J\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"rI,J,r,r\")))]\n+  \"TARGET_SHIFTER\"\n+  \"asl%? %0,%1,%2\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"1,2,1,2\")])\n+\n+(define_insn \"*ashrsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"nonmemory_operand\" \"r,r,I,J\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"rI,J,r,r\")))]\n+  \"TARGET_SHIFTER\"\n+  \"asr%? %0,%1,%2\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"1,2,1,2\")])\n+\n+(define_insn \"*lshrsi3_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"nonmemory_operand\" \"r,r,I,J\")\n+\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"rI,J,r,r\")))]\n+  \"TARGET_SHIFTER\"\n+  \"lsr%? %0,%1,%2\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"1,2,1,2\")])\n+\n+(define_insn \"*shift_si3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 3 \"shift_operator\"\n+\t\t\t   [(match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")]))\n+   (clobber (match_scratch:SI 4 \"=&r\"))]\n+  \"! TARGET_SHIFTER\"\n+  \"* return output_shift (operands);\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"8\")])\n+\f\n+;; Compare instructions.\n+;; This controls RTL generation and register allocation.\n+\n+;; We generate RTL for comparisons and branches by having the cmpxx \n+;; patterns store away the operands.  Then, the scc and bcc patterns\n+;; emit RTL for both the compare and the branch.\n+\n+(define_expand \"cmpsi\"\n+  [(set (reg:CC 61)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  arc_compare_op0 = operands[0];\n+  arc_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+;; ??? We may be able to relax this a bit by adding a new constant 'K' for 0.\n+;; This assumes sub.f 0,symbol,0 is a valid insn.\n+;; Note that \"sub.f 0,r0,1\" is an 8 byte insn.  To avoid unnecessarily\n+;; creating 8 byte insns we duplicate %1 in the destination reg of the insn\n+;; if it's a small constant.\n+\n+(define_insn \"*cmpsi_cc_insn\"\n+  [(set (reg:CC 61)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"r,I,J\")))]\n+  \"\"\n+  \"@\n+   sub.f 0,%0,%1\n+   sub.f %1,%0,%1\n+   sub.f 0,%0,%1\"\n+  [(set_attr \"type\" \"compare,compare,compare\")])\n+\n+(define_insn \"*cmpsi_cczn_insn\"\n+  [(set (reg:CCZN 61)\n+\t(compare:CCZN (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n+\t\t      (match_operand:SI 1 \"nonmemory_operand\" \"r,I,J\")))]\n+  \"\"\n+  \"@\n+   sub.f 0,%0,%1\n+   sub.f %1,%0,%1\n+   sub.f 0,%0,%1\"\n+  [(set_attr \"type\" \"compare,compare,compare\")])\n+\n+(define_insn \"*cmpsi_ccznc_insn\"\n+  [(set (reg:CCZNC 61)\n+\t(compare:CCZNC (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n+\t\t       (match_operand:SI 1 \"nonmemory_operand\" \"r,I,J\")))]\n+  \"\"\n+  \"@\n+   sub.f 0,%0,%1\n+   sub.f %1,%0,%1\n+   sub.f 0,%0,%1\"\n+  [(set_attr \"type\" \"compare,compare,compare\")])\n+\n+;; Next come the scc insns.\n+\n+(define_expand \"seq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (EQ, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ne:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (NE, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"sgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(gt:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GT, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"sle\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(le:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LE, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"sge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ge:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GE, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"slt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lt:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LT, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"sgtu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(gtu:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GTU, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"sleu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(leu:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LEU, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"sgeu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(geu:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GEU, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"sltu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ltu:SI (match_dup 1) (const_int 0)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LTU, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_insn \"*scc_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"comparison_operator\" [(reg 61) (const_int 0)]))]\n+  \"\"\n+  \"mov %0,1\\;sub.%D1 %0,%0,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; ??? Look up negscc insn.  See pa.md for example.\n+(define_insn \"*neg_scc_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(neg:SI (match_operator:SI 1 \"comparison_operator\"\n+\t\t [(reg 61) (const_int 0)])))]\n+  \"\"\n+  \"mov %0,-1\\;sub.%D1 %0,%0,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"*not_scc_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operator:SI 1 \"comparison_operator\"\n+\t\t [(reg 61) (const_int 0)])))]\n+  \"\"\n+  \"mov %0,1\\;sub.%d1 %0,%0,%0\"\n+  [(set_attr \"type\" \"unary\")\n+   (set_attr \"length\" \"2\")])\n+\f\n+;; These control RTL generation for conditional jump insns\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (EQ, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (NE, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GT, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LE, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GE, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LT, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GTU, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LEU, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (GEU, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (match_dup 1) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_compare_reg (LTU, arc_compare_op0, arc_compare_op1);\n+}\")\n+\n+;; Now match both normal and inverted jump.\n+\n+(define_insn \"*branch_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"proper_comparison_operator\"\n+\t\t\t\t      [(reg 61) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if (arc_ccfsm_branch_deleted_p ())\n+    {\n+      arc_ccfsm_record_branch_deleted ();\n+      return \\\"; branch deleted, next insns conditionalized\\\";\n+    }\n+  else\n+    return \\\"%~b%d1%# %l0\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"*rev_branch_insn\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"proper_comparison_operator\"\n+\t\t\t\t      [(reg 61) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"REVERSIBLE_CC_MODE (GET_MODE (XEXP (operands[1], 0)))\"\n+  \"*\n+{\n+  if (arc_ccfsm_branch_deleted_p ())\n+    {\n+      arc_ccfsm_record_branch_deleted ();\n+      return \\\"; branch deleted, next insns conditionalized\\\";\n+    }\n+  else\n+    return \\\"%~b%D1%# %l0\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")])\n+\f\n+;; Unconditional and other jump instructions.\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"b%* %l0\"\n+  [(set_attr \"type\" \"uncond_branch\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"j%* %a0\"\n+  [(set_attr \"type\" \"uncond_branch\")])\n+ \n+;; Implement a switch statement.\n+;; This wouldn't be necessary in the non-pic case if we could distinguish\n+;; label refs of the jump table from other label refs.  The problem is that\n+;; label refs are output as \"%st(.LL42)\" but we don't want the %st - we want\n+;; the real address since it's the address of the table.\n+\n+(define_expand \"casesi\"\n+  [(set (match_dup 5)\n+\t(minus:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t  (match_operand:SI 1 \"nonmemory_operand\" \"\")))\n+   (set (reg:CC 61)\n+\t(compare:CC (match_dup 5)\n+\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (gtu (reg:CC 61)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 4 \"\" \"\"))\n+\t\t      (pc)))\n+   (parallel\n+    [(set (pc)\n+\t  (mem:SI (plus:SI (mult:SI (match_dup 5)\n+\t\t\t\t    (const_int 4))\n+\t\t\t   (label_ref (match_operand 3 \"\" \"\")))))\n+     (clobber (match_scratch:SI 6 \"\"))\n+     (clobber (match_scratch:SI 7 \"\"))])]\n+  \"\"\n+  \"\n+{\n+  operands[5] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_insn \"*casesi_insn\"\n+  [(set (pc)\n+\t(mem:SI (plus:SI (mult:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t\t  (const_int 4))\n+\t\t\t (label_ref (match_operand 1 \"\" \"\")))))\n+   (clobber (match_scratch:SI 2 \"=r\"))\n+   (clobber (match_scratch:SI 3 \"=r\"))]\n+  \"\"\n+  \"*\n+{\n+  output_asm_insn (\\\"mov %2,%1\\\", operands);\n+  if (TARGET_SHIFTER)\n+    output_asm_insn (\\\"asl %3,%0,2\\\", operands);\n+  else\n+    output_asm_insn (\\\"asl %3,%0\\;asl %3,%3\\\", operands);\n+  output_asm_insn (\\\"ld %2,[%2,%3]\\\", operands);\n+  output_asm_insn (\\\"j.nd %a2\\\", operands);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"uncond_branch\")\n+   (set_attr \"length\" \"6\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"0 /* disabled -> using casesi now */\"\n+  \"j%* %a0\"\n+  [(set_attr \"type\" \"uncond_branch\")])\n+\n+(define_expand \"call\"\n+  ;; operands[1] is stack_size_rtx\n+  ;; operands[2] is next_arg_register\n+  [(parallel [(call (match_operand:SI 0 \"call_operand\" \"\")\n+\t\t    (match_operand 1 \"\" \"\"))\n+\t     (clobber (reg:SI 31))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*call_via_reg\"\n+  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI 31))]\n+  \"\"\n+  \"lr blink,[status]\\;j.d %0\\;add blink,blink,2\"\n+  [(set_attr \"type\" \"call_no_delay_slot\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_insn \"*call_via_label\"\n+  [(call (mem:SI (match_operand:SI 0 \"call_address_operand\" \"\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI 31))]\n+  \"\"\n+  ; The %~ is necessary in case this insn gets conditionalized and the previous\n+  ; insn is the cc setter.\n+  \"%~bl%!%* %0\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"cond\" \"canuse\")])\n+\n+(define_expand \"call_value\"\n+  ;; operand 2 is stack_size_rtx\n+  ;; operand 3 is next_arg_register\n+  [(parallel [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t\t   (call (match_operand:SI 1 \"call_operand\" \"\")\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t     (clobber (reg:SI 31))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*call_value_via_reg\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI 31))]\n+  \"\"\n+  \"lr blink,[status]\\;j.d %1\\;add blink,blink,2\"\n+  [(set_attr \"type\" \"call_no_delay_slot\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_insn \"*call_value_via_label\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:SI (match_operand:SI 1 \"call_address_operand\" \"\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI 31))]\n+  \"\"\n+  ; The %~ is necessary in case this insn gets conditionalized and the previous\n+  ; insn is the cc setter.\n+  \"%~bl%!%* %1\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"cond\" \"canuse\")])\n+\f\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\" \"misc\")])\n+\n+;; Special pattern to flush the icache.\n+;; ??? Not sure what to do here.  Some ARC's are known to support this.\n+\n+(define_insn \"flush_icache\"\n+  [(unspec_volatile [(match_operand 0 \"memory_operand\" \"m\")] 0)]\n+  \"\"\n+  \"* return \\\"\\\";\"\n+  [(set_attr \"type\" \"misc\")])\n+\f\n+;; Split up troublesome insns for better scheduling.\n+\f\n+;; Peepholes go at the end."}]}