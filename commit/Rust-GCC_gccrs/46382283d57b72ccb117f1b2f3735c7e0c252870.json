{"sha": "46382283d57b72ccb117f1b2f3735c7e0c252870", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYzODIyODNkNTdiNzJjY2IxMTdmMWIyZjM3MzVjN2UwYzI1Mjg3MA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2005-04-10T04:00:53Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2005-04-10T04:00:53Z"}, "message": "re PR target/20126 (Inlined memcmp makes one argument null on entry)\n\ngcc/ChangeLog:\nPR target/20126\n* loop.c (loop_givs_rescan): If replacement of DEST_ADDR failed,\nset the original address pseudo to the correct value before the\noriginal insn, if possible, and leave the insn alone, otherwise\ncreate a new pseudo, set it and replace it in the insn.\n* recog.c (validate_change_maybe_volatile): New.\n* recog.h (validate_change_maybe_volatile): Declare.\ngcc/testsuite/ChangeLog:\n* gcc.dg/pr20126.c: New.\n\nFrom-SVN: r97939", "tree": {"sha": "24485e56e8b36a8e92b4e868e76b61bc02192114", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24485e56e8b36a8e92b4e868e76b61bc02192114"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46382283d57b72ccb117f1b2f3735c7e0c252870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46382283d57b72ccb117f1b2f3735c7e0c252870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46382283d57b72ccb117f1b2f3735c7e0c252870", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46382283d57b72ccb117f1b2f3735c7e0c252870/comments", "author": null, "committer": null, "parents": [{"sha": "f7d7d3b779b8ade7cef279492981705ee9b5a577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d7d3b779b8ade7cef279492981705ee9b5a577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d7d3b779b8ade7cef279492981705ee9b5a577"}], "stats": {"total": 133, "additions": 130, "deletions": 3}, "files": [{"sha": "872e432d37a9fc92a1774a34296e277c2e12dd65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46382283d57b72ccb117f1b2f3735c7e0c252870", "patch": "@@ -1,3 +1,13 @@\n+2005-04-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR target/20126\n+\t* loop.c (loop_givs_rescan): If replacement of DEST_ADDR failed,\n+\tset the original address pseudo to the correct value before the\n+\toriginal insn, if possible, and leave the insn alone, otherwise\n+\tcreate a new pseudo, set it and replace it in the insn.\n+\t* recog.c (validate_change_maybe_volatile): New.\n+\t* recog.h (validate_change_maybe_volatile): Declare.\n+\n 2005-04-09  Caroline Tice  <ctice@apple.com>\n \n \t* bb-reorder.c (find_rarely_executed_basic_blocks_and_crossing_edges):"}, {"sha": "f432e68e5927d04b7529f0f7033a1cac79977168", "filename": "gcc/loop.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=46382283d57b72ccb117f1b2f3735c7e0c252870", "patch": "@@ -5476,9 +5476,31 @@ loop_givs_rescan (struct loop *loop, struct iv_class *bl, rtx *reg_map)\n \tmark_reg_pointer (v->new_reg, 0);\n \n       if (v->giv_type == DEST_ADDR)\n-\t/* Store reduced reg as the address in the memref where we found\n-\t   this giv.  */\n-\tvalidate_change (v->insn, v->location, v->new_reg, 0);\n+\t{\n+\t  /* Store reduced reg as the address in the memref where we found\n+\t     this giv.  */\n+\t  if (validate_change_maybe_volatile (v->insn, v->location,\n+\t\t\t\t\t      v->new_reg))\n+\t    /* Yay, it worked!  */;\n+\t  /* Not replaceable; emit an insn to set the original\n+\t     giv reg from the reduced giv.  */\n+\t  else if (REG_P (*v->location))\n+\t    loop_insn_emit_before (loop, 0, v->insn,\n+\t\t\t\t   gen_move_insn (*v->location,\n+\t\t\t\t\t\t  v->new_reg));\n+\t  else\n+\t    {\n+\t      /* If it wasn't a reg, create a pseudo and use that.  */\n+\t      rtx reg, seq;\n+\t      start_sequence ();\n+\t      reg = force_reg (v->mode, *v->location);\n+\t      seq = get_insns ();\n+\t      end_sequence ();\n+\t      loop_insn_emit_before (loop, 0, v->insn, seq);\n+\t      if (!validate_change_maybe_volatile (v->insn, v->location, reg))\n+\t\tgcc_unreachable ();\n+\t    }\n+\t}\n       else if (v->replaceable)\n \t{\n \t  reg_map[REGNO (v->dest_reg)] = v->new_reg;"}, {"sha": "836ebb3eabd08c0a5eae4a60cc1e6b4c587da4c0", "filename": "gcc/recog.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=46382283d57b72ccb117f1b2f3735c7e0c252870", "patch": "@@ -235,6 +235,46 @@ validate_change (rtx object, rtx *loc, rtx new, int in_group)\n     return apply_change_group ();\n }\n \n+\n+/* Function to be passed to for_each_rtx to test whether a piece of\n+   RTL contains any mem/v.  */\n+static int\n+volatile_mem_p (rtx *x, void *data ATTRIBUTE_UNUSED)\n+{\n+  return (MEM_P (*x) && MEM_VOLATILE_P (*x));\n+}\n+\n+/* Same as validate_change, but doesn't support groups, and it accepts\n+   volatile mems if they're already present in the original insn.  */\n+\n+int\n+validate_change_maybe_volatile (rtx object, rtx *loc, rtx new)\n+{\n+  int result;\n+\n+  if (validate_change (object, loc, new, 0))\n+    return 1;\n+\n+  if (volatile_ok\n+      /* If there isn't a volatile MEM, there's nothing we can do.  */\n+      || !for_each_rtx (&PATTERN (object), volatile_mem_p, 0)\n+      /* Make sure we're not adding or removing volatile MEMs.  */\n+      || for_each_rtx (loc, volatile_mem_p, 0)\n+      || for_each_rtx (&new, volatile_mem_p, 0)\n+      || !insn_invalid_p (object))\n+    return 0;\n+\n+  volatile_ok = 1;\n+\n+  gcc_assert (!insn_invalid_p (object));\n+\n+  result = validate_change (object, loc, new, 0);\n+\n+  volatile_ok = 0;\n+\n+  return result;\n+}\n+\n /* This subroutine of apply_change_group verifies whether the changes to INSN\n    were valid; i.e. whether INSN can still be recognized.  */\n "}, {"sha": "e8b25e65ce1f3bb663d2a6df35d58038ccdac6a6", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=46382283d57b72ccb117f1b2f3735c7e0c252870", "patch": "@@ -74,6 +74,7 @@ extern void init_recog_no_volatile (void);\n extern int check_asm_operands (rtx);\n extern int asm_operand_ok (rtx, const char *);\n extern int validate_change (rtx, rtx *, rtx, int);\n+extern int validate_change_maybe_volatile (rtx, rtx *, rtx);\n extern int insn_invalid_p (rtx);\n extern void confirm_change_group (void);\n extern int apply_change_group (void);"}, {"sha": "fea25c4a5adae3124657494652a3cab87789e493", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46382283d57b72ccb117f1b2f3735c7e0c252870", "patch": "@@ -1,3 +1,7 @@\n+2005-04-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* gcc.dg/pr20126.c: New.\n+\n 2005-04-09  Bud Davis  <bdavis@gfortran.org>\n             Steven G. Kargl <kargls@comcast.net>\n "}, {"sha": "257832ab18a5b2bca9d090b376b79617f6e6afb0", "filename": "gcc/testsuite/gcc.dg/pr20126.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20126.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46382283d57b72ccb117f1b2f3735c7e0c252870/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20126.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20126.c?ref=46382283d57b72ccb117f1b2f3735c7e0c252870", "patch": "@@ -0,0 +1,50 @@\n+/* dg-do run */\n+/* dg-options \"-O2\" */\n+\n+/* PR target/20126 was not really target-specific, but rather a loop's\n+   failure to take into account the possibility that a DEST_ADDR giv\n+   replacement might fail, such as when you attempt to replace a REG\n+   with a PLUS in one of the register_operands of cmpstrqi_rex_1.  */\n+\n+extern void abort (void);\n+\n+typedef struct { int a; char b[3]; } S;\n+S c = { 2, \"aa\" }, d = { 2, \"aa\" };\n+\n+void *\n+bar (const void *x, int y, int z)\n+{\n+  return (void *) 0;\n+}\n+\n+int\n+foo (S *x, S *y)\n+{\n+  const char *e, *f, *g;\n+  int h;\n+\n+  h = y->a;\n+  f = y->b;\n+  e = x->b;\n+\n+  if (h == 1)\n+    return bar (e, *f, x->a) != 0;\n+\n+  g = e + x->a - h;\n+  while (e <= g)\n+    {\n+      const char *t = e + 1;\n+      if (__builtin_memcmp (e, f, h) == 0)\n+        return 1;\n+      e = t;\n+    }\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  if (foo (&c, &d) != 1)\n+    abort ();\n+  return 0;\n+}"}]}