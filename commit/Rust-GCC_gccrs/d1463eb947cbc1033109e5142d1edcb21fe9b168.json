{"sha": "d1463eb947cbc1033109e5142d1edcb21fe9b168", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE0NjNlYjk0N2NiYzEwMzMxMDllNTE0MmQxZWRjYjIxZmU5YjE2OA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-09-12T16:01:02Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-09-12T16:01:02Z"}, "message": "Fix suggestions for non-trivial Wformat type cases (PR c/72858)\n\ngcc/c-family/ChangeLog:\n\tPR c/72858\n\t* c-format.c (argument_parser::check_argument_type): Add params\n\t\"type_start\" and \"conversion_char\".  Use the former to generate\n\toffset_to_type_start and pass it and conversion_char to\n\tcheck_format_types.\n\t(check_format_info_main): Capture the start of the type\n\tinformation as \"type_start\", and pass it an format_char\n\tto arg_parser.check_argument_type.\n\t(check_format_types): Provide an example in the leading comment.\n\tAdd params \"offset_to_type_start\" and \"conversion_char\"; pass\n\tthem to format_type_warning calls.\n\t(test_get_modifier_for_format_len): Likewise.\n\t(matching_type_p): New function.\n\t(get_format_for_type): Add param \"conversion_char\" and move\n\timplementation into...\n\t(get_format_for_type_1): ...new function, called twice.\n\tUse new function matching_type_p rather than checking for\n\tTYPE_CANONICAL equality.\n\t(get_corrected_substring): New function.\n\t(format_type_warning): Provide an example in the leading comment.\n\tAdd params \"offset_to_type_start\" and \"conversion_char\".  Replace\n\tcall to get_format_for_type with call to get_corrected_substring\n\tand move rejection of hints for widths/precisions there.\n\t(assert_format_for_type_streq): Add param \"conversion_char\".\n\t(ASSERT_FORMAT_FOR_TYPE_STREQ): Add param CONVERSION_CHAR.\n\t(test_get_format_for_type_printf): Add conversion chars to the\n\ttests, adding coverage for various combinations of integer\n\tvs double conversions, and for preserving octal and hexadecimal\n\tconversions.\n\t(test_get_format_for_type_scanf): Add conversion chars to the\n\ttests.\n\ngcc/testsuite/ChangeLog:\n\tPR c/72858\n\t* gcc.dg/format/diagnostic-ranges.c: Update expected suggestions\n\tto preserve conversion chars, and to preserve prefix information.\n\t* gcc.dg/format/pr72858.c: New test case.\n\nFrom-SVN: r240095", "tree": {"sha": "6a245d08d2a9d5e8e29c972d3106de14df2314a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a245d08d2a9d5e8e29c972d3106de14df2314a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1463eb947cbc1033109e5142d1edcb21fe9b168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1463eb947cbc1033109e5142d1edcb21fe9b168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1463eb947cbc1033109e5142d1edcb21fe9b168", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1463eb947cbc1033109e5142d1edcb21fe9b168/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5e8037ba97f4b333d7e55aad3f76bfe1c7d28239", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8037ba97f4b333d7e55aad3f76bfe1c7d28239", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e8037ba97f4b333d7e55aad3f76bfe1c7d28239"}], "stats": {"total": 879, "additions": 816, "deletions": 63}, "files": [{"sha": "8ba99f29bf4b18e8b02a7ac753ade2e55cd65fbe", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1463eb947cbc1033109e5142d1edcb21fe9b168/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1463eb947cbc1033109e5142d1edcb21fe9b168/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d1463eb947cbc1033109e5142d1edcb21fe9b168", "patch": "@@ -1,3 +1,37 @@\n+2016-09-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/72858\n+\t* c-format.c (argument_parser::check_argument_type): Add params\n+\t\"type_start\" and \"conversion_char\".  Use the former to generate\n+\toffset_to_type_start and pass it and conversion_char to\n+\tcheck_format_types.\n+\t(check_format_info_main): Capture the start of the type\n+\tinformation as \"type_start\", and pass it an format_char\n+\tto arg_parser.check_argument_type.\n+\t(check_format_types): Provide an example in the leading comment.\n+\tAdd params \"offset_to_type_start\" and \"conversion_char\"; pass\n+\tthem to format_type_warning calls.\n+\t(test_get_modifier_for_format_len): Likewise.\n+\t(matching_type_p): New function.\n+\t(get_format_for_type): Add param \"conversion_char\" and move\n+\timplementation into...\n+\t(get_format_for_type_1): ...new function, called twice.\n+\tUse new function matching_type_p rather than checking for\n+\tTYPE_CANONICAL equality.\n+\t(get_corrected_substring): New function.\n+\t(format_type_warning): Provide an example in the leading comment.\n+\tAdd params \"offset_to_type_start\" and \"conversion_char\".  Replace\n+\tcall to get_format_for_type with call to get_corrected_substring\n+\tand move rejection of hints for widths/precisions there.\n+\t(assert_format_for_type_streq): Add param \"conversion_char\".\n+\t(ASSERT_FORMAT_FOR_TYPE_STREQ): Add param CONVERSION_CHAR.\n+\t(test_get_format_for_type_printf): Add conversion chars to the\n+\ttests, adding coverage for various combinations of integer\n+\tvs double conversions, and for preserving octal and hexadecimal\n+\tconversions.\n+\t(test_get_format_for_type_scanf): Add conversion chars to the\n+\ttests.\n+\n 2016-09-10  Tom de Vries  <tom@codesourcery.com>\n \n \tPR C/71602"}, {"sha": "bf39ee06e79f2bd98c961ff885ffd8d13c7615ac", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 360, "deletions": 58, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1463eb947cbc1033109e5142d1edcb21fe9b168/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1463eb947cbc1033109e5142d1edcb21fe9b168/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=d1463eb947cbc1033109e5142d1edcb21fe9b168", "patch": "@@ -994,12 +994,16 @@ static const format_flag_spec *get_flag_spec (const format_flag_spec *,\n \n static void check_format_types (const substring_loc &fmt_loc,\n \t\t\t\tformat_wanted_type *,\n-\t\t\t\tconst format_kind_info *fki);\n+\t\t\t\tconst format_kind_info *fki,\n+\t\t\t\tint offset_to_type_start,\n+\t\t\t\tchar conversion_char);\n static void format_type_warning (const substring_loc &fmt_loc,\n \t\t\t\t source_range *param_range,\n \t\t\t\t format_wanted_type *, tree,\n \t\t\t\t tree,\n-\t\t\t\t const format_kind_info *fki);\n+\t\t\t\t const format_kind_info *fki,\n+\t\t\t\t int offset_to_type_start,\n+\t\t\t\t char conversion_char);\n \n /* Decode a format type from a string, returning the type, or\n    format_type_error if not valid, in which case the caller should print an\n@@ -1779,7 +1783,9 @@ class argument_parser\n \t\t       tree &params,\n \t\t       const int alloc_flag,\n \t\t       const char * const format_start,\n-\t\t       location_t fmt_param_loc);\n+\t\t       const char * const type_start,\n+\t\t       location_t fmt_param_loc,\n+\t\t       char conversion_char);\n \n  private:\n   const function_format_info *const info;\n@@ -2552,7 +2558,9 @@ check_argument_type (const format_char_info *fci,\n \t\t     tree &params,\n \t\t     const int alloc_flag,\n \t\t     const char * const format_start,\n-\t\t     location_t fmt_param_loc)\n+\t\t     const char * const type_start,\n+\t\t     location_t fmt_param_loc,\n+\t\t     char conversion_char)\n {\n   if (info->first_arg_num == 0)\n     return true;\n@@ -2658,7 +2666,10 @@ check_argument_type (const format_char_info *fci,\n       substring_loc fmt_loc (fmt_param_loc, TREE_TYPE (format_string_cst),\n \t\t\t     offset_to_format_end,\n \t\t\t     offset_to_format_start, offset_to_format_end);\n-      check_format_types (fmt_loc, first_wanted_type, fki);\n+      ptrdiff_t offset_to_type_start = type_start - orig_format_chars;\n+      check_format_types (fmt_loc, first_wanted_type, fki,\n+\t\t\t  offset_to_type_start,\n+\t\t\t  conversion_char);\n     }\n \n   return true;\n@@ -2737,6 +2748,13 @@ check_format_info_main (format_check_results *res,\n \n       arg_parser.handle_alloc_chars ();\n \n+      /* The rest of the conversion specification is the length modifier\n+\t (if any), and the conversion specifier, so this is where the\n+\t type information starts.  If we need to issue a suggestion\n+\t about a type mismatch, then we should preserve everything up\n+\t to here. */\n+      const char *type_start = format_chars;\n+\n       /* Read any length modifier, if this kind of format has them.  */\n       const length_modifier len_modifier\n \t= arg_parser.read_any_length_modifier ();\n@@ -2794,7 +2812,9 @@ check_format_info_main (format_check_results *res,\n \t\t\t\t\t   suppressed,\n \t\t\t\t\t   arg_num, params,\n \t\t\t\t\t   alloc_flag,\n-\t\t\t\t\t   format_start, fmt_param_loc))\n+\t\t\t\t\t   format_start, type_start,\n+\t\t\t\t\t   fmt_param_loc,\n+\t\t\t\t\t   format_char))\n \treturn;\n     }\n \n@@ -2814,11 +2834,58 @@ check_format_info_main (format_check_results *res,\n }\n \n /* Check the argument types from a single format conversion (possibly\n-   including width and precision arguments).  FMT_LOC is the\n-   location of the format conversion.  */\n+   including width and precision arguments).\n+\n+   FMT_LOC is the location of the format conversion.\n+\n+   TYPES is a singly-linked list expressing the parts of the format\n+   conversion that expect argument types, and the arguments they\n+   correspond to.\n+\n+   OFFSET_TO_TYPE_START is the offset within the execution-charset encoded\n+   format string to where type information begins for the conversion\n+   (the length modifier and conversion specifier).\n+\n+   CONVERSION_CHAR is the user-provided conversion specifier.\n+\n+   For example, given:\n+\n+     sprintf (d, \"before %-+*.*lld after\", arg3, arg4, arg5);\n+\n+   then FMT_LOC covers this range:\n+\n+     sprintf (d, \"before %-+*.*lld after\", arg3, arg4, arg5);\n+                         ^^^^^^^^^\n+\n+   and TYPES in this case is a three-entry singly-linked list consisting of:\n+   (1) the check for the field width here:\n+         sprintf (d, \"before %-+*.*lld after\", arg3, arg4, arg5);\n+                                ^              ^^^^\n+       against arg3, and\n+   (2) the check for the field precision here:\n+         sprintf (d, \"before %-+*.*lld after\", arg3, arg4, arg5);\n+                                 ^^                  ^^^^\n+       against arg4, and\n+   (3) the check for the length modifier and conversion char here:\n+         sprintf (d, \"before %-+*.*lld after\", arg3, arg4, arg5);\n+                                   ^^^                     ^^^^\n+       against arg5.\n+\n+   OFFSET_TO_TYPE_START is 13, the offset to the \"lld\" within the\n+   STRING_CST:\n+\n+                  0000000000111111111122\n+                  0123456789012345678901\n+     sprintf (d, \"before %-+*.*lld after\", arg3, arg4, arg5);\n+                               ^ ^\n+                               | ` CONVERSION_CHAR: 'd'\n+                               type starts here.  */\n+\n static void\n check_format_types (const substring_loc &fmt_loc,\n-\t\t    format_wanted_type *types, const format_kind_info *fki)\n+\t\t    format_wanted_type *types, const format_kind_info *fki,\n+\t\t    int offset_to_type_start,\n+\t\t    char conversion_char)\n {\n   for (; types != 0; types = types->next)\n     {\n@@ -2845,7 +2912,8 @@ check_format_types (const substring_loc &fmt_loc,\n       cur_param = types->param;\n       if (!cur_param)\n         {\n-\t  format_type_warning (fmt_loc, NULL, types, wanted_type, NULL, fki);\n+\t  format_type_warning (fmt_loc, NULL, types, wanted_type, NULL, fki,\n+\t\t\t       offset_to_type_start, conversion_char);\n           continue;\n         }\n \n@@ -2930,7 +2998,8 @@ check_format_types (const substring_loc &fmt_loc,\n \t  else\n \t    {\n \t      format_type_warning (fmt_loc, param_range_ptr,\n-\t\t\t\t   types, wanted_type, orig_cur_type, fki);\n+\t\t\t\t   types, wanted_type, orig_cur_type, fki,\n+\t\t\t\t   offset_to_type_start, conversion_char);\n \t      break;\n \t    }\n \t}\n@@ -2999,7 +3068,8 @@ check_format_types (const substring_loc &fmt_loc,\n \tcontinue;\n       /* Now we have a type mismatch.  */\n       format_type_warning (fmt_loc, param_range_ptr, types,\n-\t\t\t   wanted_type, orig_cur_type, fki);\n+\t\t\t   wanted_type, orig_cur_type, fki,\n+\t\t\t   offset_to_type_start, conversion_char);\n     }\n }\n \n@@ -3064,16 +3134,47 @@ test_get_modifier_for_format_len ()\n \n #endif /* CHECKING_P */\n \n-/* Generate a string containing the format string that should be\n-   used to format arguments of type ARG_TYPE within FKI (effectively\n-   the inverse of the checking code).\n+/* Determine if SPEC_TYPE and ARG_TYPE are sufficiently similar for a\n+   format_type_detail using SPEC_TYPE to be offered as a suggestion for\n+   Wformat type errors where the argument has type ARG_TYPE.  */\n+\n+static bool\n+matching_type_p (tree spec_type, tree arg_type)\n+{\n+  gcc_assert (spec_type);\n+  gcc_assert (arg_type);\n+\n+  spec_type = TYPE_CANONICAL (spec_type);\n+  arg_type = TYPE_CANONICAL (arg_type);\n+\n+  if (TREE_CODE (spec_type) == INTEGER_TYPE\n+      && TREE_CODE (arg_type) == INTEGER_TYPE\n+      && (TYPE_UNSIGNED (spec_type)\n+\t  ? spec_type == c_common_unsigned_type (arg_type)\n+\t  : spec_type == c_common_signed_type (arg_type)))\n+    return true;\n+\n+  return spec_type == arg_type;\n+}\n+\n+/* Subroutine of get_format_for_type.\n+\n+   Generate a string containing the length modifier and conversion specifier\n+   that should be used to format arguments of type ARG_TYPE within FKI\n+   (effectively the inverse of the checking code).\n+\n+   If CONVERSION_CHAR is not zero (the first pass), the resulting suggestion\n+   is required to use it, for correcting bogus length modifiers.\n+   If CONVERSION_CHAR is zero (the second pass), then allow any suggestion\n+   that matches ARG_TYPE.\n \n    If successful, returns a non-NULL string which should be freed\n-   by the called.\n+   by the caller.\n    Otherwise, returns NULL.  */\n \n static char *\n-get_format_for_type (const format_kind_info *fki, tree arg_type)\n+get_format_for_type_1 (const format_kind_info *fki, tree arg_type,\n+\t\t       char conversion_char)\n {\n   gcc_assert (arg_type);\n \n@@ -3082,6 +3183,10 @@ get_format_for_type (const format_kind_info *fki, tree arg_type)\n        spec->format_chars;\n        spec++)\n     {\n+      if (conversion_char)\n+\tif (!strchr (spec->format_chars, conversion_char))\n+\t  continue;\n+\n       tree effective_arg_type = deref_n_times (arg_type,\n \t\t\t\t\t       spec->pointer_count);\n       if (!effective_arg_type)\n@@ -3091,24 +3196,176 @@ get_format_for_type (const format_kind_info *fki, tree arg_type)\n \t  const format_type_detail *ftd = &spec->types[i];\n \t  if (!ftd->type)\n \t    continue;\n-\t  if (TYPE_CANONICAL (*ftd->type)\n-\t      == TYPE_CANONICAL (effective_arg_type))\n+\t  if (matching_type_p (*ftd->type, effective_arg_type))\n \t    {\n \t      const char *len_modifier\n \t\t= get_modifier_for_format_len (fki->length_char_specs,\n \t\t\t\t\t       (enum format_lengths)i);\n \t      if (!len_modifier)\n \t\tlen_modifier = \"\";\n \n-\t      return xasprintf (\"%%%s%c\",\n-\t\t\t\tlen_modifier,\n-\t\t\t\tspec->format_chars[0]);\n+\t      if (conversion_char)\n+\t\t/* We found a match, using the given conversion char - the\n+\t\t   length modifier was incorrect (or absent).\n+\t\t   Provide a suggestion using the conversion char with the\n+\t\t   correct length modifier for the type.  */\n+\t\treturn xasprintf (\"%s%c\", len_modifier, conversion_char);\n+\t      else\n+\t\t/* 2nd pass: no match was possible using the user-provided\n+\t\t   conversion char, but we do have a match without using it.\n+\t\t   Provide a suggestion using the first conversion char\n+\t\t   listed for the given type.  */\n+\t\treturn xasprintf (\"%s%c\", len_modifier, spec->format_chars[0]);\n \t    }\n \t}\n    }\n+\n   return NULL;\n }\n \n+/* Generate a string containing the length modifier and conversion specifier\n+   that should be used to format arguments of type ARG_TYPE within FKI\n+   (effectively the inverse of the checking code).\n+\n+   If successful, returns a non-NULL string which should be freed\n+   by the caller.\n+   Otherwise, returns NULL.  */\n+\n+static char *\n+get_format_for_type (const format_kind_info *fki, tree arg_type,\n+\t\t     char conversion_char)\n+{\n+  gcc_assert (arg_type);\n+  gcc_assert (conversion_char);\n+\n+  /* First pass: look for a format_char_info containing CONVERSION_CHAR\n+     If we find one, then presumably the length modifier was incorrect\n+     (or absent).  */\n+  char *result = get_format_for_type_1 (fki, arg_type, conversion_char);\n+  if (result)\n+    return result;\n+\n+  /* Second pass: we didn't find a match for CONVERSION_CHAR, so try\n+     matching just on the type. */\n+  return get_format_for_type_1 (fki, arg_type, '\\0');\n+}\n+\n+/* Attempt to get a string for use as a replacement fix-it hint for the\n+   source range in FMT_LOC.\n+\n+   Preserve all of the text within the range of FMT_LOC up to\n+   OFFSET_TO_TYPE_START, replacing the rest with an appropriate\n+   length modifier and conversion specifier for ARG_TYPE, attempting\n+   to keep the user-provided CONVERSION_CHAR if possible.\n+\n+   For example, given a long vs long long mismatch for arg5 here:\n+\n+    000000000111111111122222222223333333333|\n+    123456789012345678901234567890123456789` column numbers\n+                   0000000000111111111122|\n+                   0123456789012345678901` string offsets\n+                          V~~~~~~~~ : range of FMT_LOC, from cols 23-31\n+      sprintf (d, \"before %-+*.*lld after\", arg3, arg4, arg5);\n+                                ^ ^\n+                                | ` CONVERSION_CHAR: 'd'\n+                                type starts here\n+\n+   where OFFSET_TO_TYPE_START is 13 (the offset to the \"lld\" within the\n+   STRING_CST), where the user provided:\n+     %-+*.*lld\n+   the result (assuming \"long\" argument 5) should be:\n+     %-+*.*ld\n+\n+   If successful, returns a non-NULL string which should be freed\n+   by the caller.\n+   Otherwise, returns NULL.  */\n+\n+static char *\n+get_corrected_substring (const substring_loc &fmt_loc,\n+\t\t\t format_wanted_type *type, tree arg_type,\n+\t\t\t const format_kind_info *fki,\n+\t\t\t int offset_to_type_start, char conversion_char)\n+{\n+  /* Attempt to provide hints for argument types, but not for field widths\n+     and precisions.  */\n+  if (!arg_type)\n+    return NULL;\n+  if (type->kind != CF_KIND_FORMAT)\n+    return NULL;\n+\n+  /* Locate the current code within the source range, rejecting\n+     any awkward cases where the format string occupies more than\n+     one line.\n+     Lookup the place where the type starts (including any length\n+     modifiers), getting it as the caret location.  */\n+  substring_loc type_loc (fmt_loc);\n+  type_loc.set_caret_index (offset_to_type_start);\n+\n+  location_t fmt_substring_loc;\n+  const char *err = type_loc.get_location (&fmt_substring_loc);\n+  if (err)\n+    return NULL;\n+\n+  source_range fmt_substring_range\n+    = get_range_from_loc (line_table, fmt_substring_loc);\n+\n+  expanded_location caret\n+    = expand_location_to_spelling_point (fmt_substring_loc);\n+  expanded_location start\n+    = expand_location_to_spelling_point (fmt_substring_range.m_start);\n+  expanded_location finish\n+    = expand_location_to_spelling_point (fmt_substring_range.m_finish);\n+  if (caret.file != start.file)\n+    return NULL;\n+  if (start.file != finish.file)\n+    return NULL;\n+  if (caret.line != start.line)\n+    return NULL;\n+  if (start.line != finish.line)\n+    return NULL;\n+  if (start.column > caret.column)\n+    return NULL;\n+  if (start.column > finish.column)\n+    return NULL;\n+  if (caret.column > finish.column)\n+    return NULL;\n+\n+  int line_width;\n+  const char *line = location_get_source_line (start.file, start.line,\n+\t\t\t\t\t       &line_width);\n+  if (line == NULL)\n+    return NULL;\n+\n+  /* If we got this far, then we have the line containing the\n+     existing conversion specification.\n+\n+     Generate a trimmed copy, containing the prefix part of the conversion\n+     specification, up to the (but not including) the length modifier.\n+     In the above example, this would be \"%-+*.*\".  */\n+  const char *current_content = line + start.column - 1;\n+  int length_up_to_type = caret.column - start.column;\n+  char *prefix = xstrndup (current_content, length_up_to_type);\n+\n+  /* Now attempt to generate a suggestion for the rest of the specification\n+     (length modifier and conversion char), based on ARG_TYPE and\n+     CONVERSION_CHAR.\n+     In the above example, this would be \"ld\".  */\n+  char *format_for_type = get_format_for_type (fki, arg_type, conversion_char);\n+  if (!format_for_type)\n+    {\n+      free (prefix);\n+      return NULL;\n+    }\n+\n+  /* Success.  Generate the resulting suggestion for the whole range of\n+     FMT_LOC by concatenating the two strings.\n+     In the above example, this would be \"%-+*.*ld\".  */\n+  char *result = concat (prefix, format_for_type, NULL);\n+  free (format_for_type);\n+  free (prefix);\n+  return result;\n+}\n+\n /* Give a warning about a format argument of different type from that expected.\n    The range of the diagnostic is taken from WHOLE_FMT_LOC; the caret location\n    is based on the location of the char at TYPE->offset_loc.\n@@ -3118,13 +3375,36 @@ get_format_for_type (const format_kind_info *fki, tree arg_type)\n    precision\"), the placement in the format string, a possibly more\n    friendly name of WANTED_TYPE, and the number of pointer dereferences\n    are taken from TYPE.  ARG_TYPE is the type of the actual argument,\n-   or NULL if it is missing.  */\n+   or NULL if it is missing.\n+\n+   OFFSET_TO_TYPE_START is the offset within the execution-charset encoded\n+   format string to where type information begins for the conversion\n+   (the length modifier and conversion specifier).\n+   CONVERSION_CHAR is the user-provided conversion specifier.\n+\n+   For example, given a type mismatch for argument 5 here:\n+\n+    00000000011111111112222222222333333333344444444445555555555|\n+    12345678901234567890123456789012345678901234567890123456789` column numbers\n+                   0000000000111111111122|\n+                   0123456789012345678901` offsets within STRING_CST\n+                          V~~~~~~~~ : range of WHOLE_FMT_LOC, from cols 23-31\n+      sprintf (d, \"before %-+*.*lld after\", int_expr, int_expr, long_expr);\n+                                ^ ^                             ^~~~~~~~~\n+                                | ` CONVERSION_CHAR: 'd'        *PARAM_RANGE\n+                                type starts here\n+\n+   OFFSET_TO_TYPE_START is 13, the offset to the \"lld\" within the\n+   STRING_CST.  */\n+\n static void\n format_type_warning (const substring_loc &whole_fmt_loc,\n \t\t     source_range *param_range,\n \t\t     format_wanted_type *type,\n \t\t     tree wanted_type, tree arg_type,\n-\t\t     const format_kind_info *fki)\n+\t\t     const format_kind_info *fki,\n+\t\t     int offset_to_type_start,\n+\t\t     char conversion_char)\n {\n   enum format_specifier_kind kind = type->kind;\n   const char *wanted_type_name = type->wanted_type_name;\n@@ -3171,18 +3451,18 @@ format_type_warning (const substring_loc &whole_fmt_loc,\n   substring_loc fmt_loc (whole_fmt_loc);\n   fmt_loc.set_caret_index (type->offset_loc - 1);\n \n-  /* Attempt to provide hints for argument types, but not for field widths\n-     and precisions.  */\n-  char *format_for_type = NULL;\n-  if (arg_type && kind == CF_KIND_FORMAT)\n-    format_for_type = get_format_for_type (fki, arg_type);\n+  /* Get a string for use as a replacement fix-it hint for the range in\n+     fmt_loc, or NULL.  */\n+  char *corrected_substring\n+    = get_corrected_substring (fmt_loc, type, arg_type, fki,\n+\t\t\t       offset_to_type_start, conversion_char);\n \n   if (wanted_type_name)\n     {\n       if (arg_type)\n \tformat_warning_at_substring\n \t  (fmt_loc, param_range,\n-\t   format_for_type, OPT_Wformat_,\n+\t   corrected_substring, OPT_Wformat_,\n \t   \"%s %<%s%.*s%> expects argument of type %<%s%s%>, \"\n \t   \"but argument %d has type %qT\",\n \t   gettext (kind_descriptions[kind]),\n@@ -3192,7 +3472,7 @@ format_type_warning (const substring_loc &whole_fmt_loc,\n       else\n \tformat_warning_at_substring\n \t  (fmt_loc, param_range,\n-\t   format_for_type, OPT_Wformat_,\n+\t   corrected_substring, OPT_Wformat_,\n \t   \"%s %<%s%.*s%> expects a matching %<%s%s%> argument\",\n \t   gettext (kind_descriptions[kind]),\n \t   (kind == CF_KIND_FORMAT ? \"%\" : \"\"),\n@@ -3203,7 +3483,7 @@ format_type_warning (const substring_loc &whole_fmt_loc,\n       if (arg_type)\n \tformat_warning_at_substring\n \t  (fmt_loc, param_range,\n-\t   format_for_type, OPT_Wformat_,\n+\t   corrected_substring, OPT_Wformat_,\n \t   \"%s %<%s%.*s%> expects argument of type %<%T%s%>, \"\n \t   \"but argument %d has type %qT\",\n \t   gettext (kind_descriptions[kind]),\n@@ -3213,14 +3493,14 @@ format_type_warning (const substring_loc &whole_fmt_loc,\n       else\n \tformat_warning_at_substring\n \t  (fmt_loc, param_range,\n-\t   format_for_type, OPT_Wformat_,\n+\t   corrected_substring, OPT_Wformat_,\n \t   \"%s %<%s%.*s%> expects a matching %<%T%s%> argument\",\n \t   gettext (kind_descriptions[kind]),\n \t   (kind == CF_KIND_FORMAT ? \"%\" : \"\"),\n \t   format_length, format_start, wanted_type, p);\n     }\n \n-  free (format_for_type);\n+  free (corrected_substring);\n }\n \n \n@@ -3759,25 +4039,28 @@ get_info (const char *name)\n   return fki;\n }\n \n-/* Verify that get_format_for_type (FKI, TYPE) is EXPECTED_FORMAT.  */\n+/* Verify that get_format_for_type (FKI, TYPE, CONVERSION_CHAR)\n+   is EXPECTED_FORMAT.  */\n \n static void\n assert_format_for_type_streq (const location &loc, const format_kind_info *fki,\n-\t\t\t      const char *expected_format, tree type)\n+\t\t\t      const char *expected_format, tree type,\n+\t\t\t      char conversion_char)\n {\n   gcc_assert (fki);\n   gcc_assert (expected_format);\n   gcc_assert (type);\n \n-  char *actual_format = get_format_for_type (fki, type);\n+  char *actual_format = get_format_for_type (fki, type, conversion_char);\n   ASSERT_STREQ_AT (loc, expected_format, actual_format);\n   free (actual_format);\n }\n \n /* Selftests for get_format_for_type.  */\n \n-#define ASSERT_FORMAT_FOR_TYPE_STREQ(EXPECTED_FORMAT, TYPE) \\\n-  assert_format_for_type_streq (SELFTEST_LOCATION, (fki), (EXPECTED_FORMAT), (TYPE))\n+#define ASSERT_FORMAT_FOR_TYPE_STREQ(EXPECTED_FORMAT, TYPE, CONVERSION_CHAR) \\\n+  assert_format_for_type_streq (SELFTEST_LOCATION, (fki), (EXPECTED_FORMAT), \\\n+\t\t\t\t(TYPE), (CONVERSION_CHAR))\n \n /* Selftest for get_format_for_type for \"printf\"-style functions.  */\n \n@@ -3787,15 +4070,34 @@ test_get_format_for_type_printf ()\n   const format_kind_info *fki = get_info (\"gnu_printf\");\n   ASSERT_NE (fki, NULL);\n \n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%f\", double_type_node);\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%Lf\", long_double_type_node);\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%d\", integer_type_node);\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%o\", unsigned_type_node);\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%ld\", long_integer_type_node);\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%lo\", long_unsigned_type_node);\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%lld\", long_long_integer_type_node);\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%llo\", long_long_unsigned_type_node);\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%s\", build_pointer_type (char_type_node));\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"f\", double_type_node, 'i');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"Lf\", long_double_type_node, 'i');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"f\", double_type_node, 'o');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"Lf\", long_double_type_node, 'o');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"f\", double_type_node, 'x');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"Lf\", long_double_type_node, 'x');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"f\", double_type_node, 'X');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"Lf\", long_double_type_node, 'X');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"d\", integer_type_node, 'd');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"i\", integer_type_node, 'i');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"o\", integer_type_node, 'o');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"x\", integer_type_node, 'x');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"X\", integer_type_node, 'X');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"d\", unsigned_type_node, 'd');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"i\", unsigned_type_node, 'i');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"o\", unsigned_type_node, 'o');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"x\", unsigned_type_node, 'x');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"X\", unsigned_type_node, 'X');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"ld\", long_integer_type_node, 'd');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"li\", long_integer_type_node, 'i');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"lx\", long_integer_type_node, 'x');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"lo\", long_unsigned_type_node, 'o');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"lx\", long_unsigned_type_node, 'x');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"lld\", long_long_integer_type_node, 'd');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"lli\", long_long_integer_type_node, 'i');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"llo\", long_long_unsigned_type_node, 'o');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"llx\", long_long_unsigned_type_node, 'x');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"s\", build_pointer_type (char_type_node), 'i');\n }\n \n /* Selftest for get_format_for_type for \"scanf\"-style functions.  */\n@@ -3805,18 +4107,18 @@ test_get_format_for_type_scanf ()\n {\n   const format_kind_info *fki = get_info (\"gnu_scanf\");\n   ASSERT_NE (fki, NULL);\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%d\", build_pointer_type (integer_type_node));\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%u\", build_pointer_type (unsigned_type_node));\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%ld\",\n-\t\t\t\tbuild_pointer_type (long_integer_type_node));\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%lu\",\n-\t\t\t\tbuild_pointer_type (long_unsigned_type_node));\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"d\", build_pointer_type (integer_type_node), 'd');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"u\", build_pointer_type (unsigned_type_node), 'u');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"ld\",\n+\t\t\t\tbuild_pointer_type (long_integer_type_node), 'd');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"lu\",\n+\t\t\t\tbuild_pointer_type (long_unsigned_type_node), 'u');\n   ASSERT_FORMAT_FOR_TYPE_STREQ\n-    (\"%lld\", build_pointer_type (long_long_integer_type_node));\n+    (\"lld\", build_pointer_type (long_long_integer_type_node), 'd');\n   ASSERT_FORMAT_FOR_TYPE_STREQ\n-    (\"%llu\", build_pointer_type (long_long_unsigned_type_node));\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%e\", build_pointer_type (float_type_node));\n-  ASSERT_FORMAT_FOR_TYPE_STREQ (\"%le\", build_pointer_type (double_type_node));\n+    (\"llu\", build_pointer_type (long_long_unsigned_type_node), 'u');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"e\", build_pointer_type (float_type_node), 'e');\n+  ASSERT_FORMAT_FOR_TYPE_STREQ (\"le\", build_pointer_type (double_type_node), 'e');\n }\n \n #undef ASSERT_FORMAT_FOR_TYPE_STREQ"}, {"sha": "10936ada31ff863c70574fbad4b0e1ea0e0d3400", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1463eb947cbc1033109e5142d1edcb21fe9b168/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1463eb947cbc1033109e5142d1edcb21fe9b168/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d1463eb947cbc1033109e5142d1edcb21fe9b168", "patch": "@@ -1,3 +1,10 @@\n+2016-09-12  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/72858\n+\t* gcc.dg/format/diagnostic-ranges.c: Update expected suggestions\n+\tto preserve conversion chars, and to preserve prefix information.\n+\t* gcc.dg/format/pr72858.c: New test case.\n+\n 2016-09-11  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* gfortran.dg/pr77507.f90: Move to ..."}, {"sha": "e5e6ade6bbe343f118fcb27851d54b12a385f086", "filename": "gcc/testsuite/gcc.dg/format/diagnostic-ranges.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1463eb947cbc1033109e5142d1edcb21fe9b168/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fdiagnostic-ranges.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1463eb947cbc1033109e5142d1edcb21fe9b168/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fdiagnostic-ranges.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fdiagnostic-ranges.c?ref=d1463eb947cbc1033109e5142d1edcb21fe9b168", "patch": "@@ -30,7 +30,7 @@ void test_mismatching_types (const char *msg)\n /* { dg-begin-multiline-output \"\" }\n    printf(\"hello %i\", (long)0);\n                  ~^\n-                 %ld\n+                 %li\n    { dg-end-multiline-output \"\" } */\n }\n \n@@ -88,7 +88,7 @@ void test_hex (const char *msg)\n /* { dg-begin-multiline-output \"\" }\n    printf(\"hello \\x25\\x69\", msg);\n                  ~~~~^~~~\n-                 %s\n+                 \\x25s\n    { dg-end-multiline-output \"\" } */\n }\n \n@@ -102,7 +102,7 @@ void test_oct (const char *msg)\n /* { dg-begin-multiline-output \"\" }\n    printf(\"hello \\045\\151\", msg);\n                  ~~~~^~~~\n-                 %s\n+                 \\045s\n    { dg-end-multiline-output \"\" } */\n }\n \n@@ -121,7 +121,7 @@ void test_multiple (const char *msg)\n /* { dg-begin-multiline-output \"\" }\n    printf(\"prefix\"  \"\\x25\"  \"\\151\"  \"suffix\",\n                      ~~~~~~~~^~~~\n-                     %s\n+                     \\x25\"  \"s\n   { dg-end-multiline-output \"\" } */\n }\n \n@@ -267,7 +267,7 @@ void test_non_contiguous_strings (void)\n   /* { dg-begin-multiline-output \"\" }\n    __builtin_printf(\" %\" \"d \", 0.5);\n                       ~~~~^\n-                      %f\n+                      %\" \"f\n    { dg-end-multiline-output \"\" } */\n }\n "}, {"sha": "d8d0499b7785487fc2b114cda1c6a501b1d397d8", "filename": "gcc/testsuite/gcc.dg/format/pr72858.c", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1463eb947cbc1033109e5142d1edcb21fe9b168/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fpr72858.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1463eb947cbc1033109e5142d1edcb21fe9b168/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fpr72858.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fpr72858.c?ref=d1463eb947cbc1033109e5142d1edcb21fe9b168", "patch": "@@ -0,0 +1,410 @@\n+/* { dg-options \"-Wformat -fdiagnostics-show-caret\" } */\n+\n+#include \"format.h\"\n+\n+/* Various format tests, some containing type mismatches.  Verify that for\n+   the type mismatch cases that we offer \"good\" suggestions.  Specifically,\n+   any suggestions should preserve flags characters, field width and precision,\n+   and, if possible, the conversion specifier character, whilst giving a\n+   corrected length modifier appropriate to the argument type.  */\n+\n+/* Tests of \"x\" without a length modifier, with various param types.\n+   Suggestions should preserve the \"x\" for integer arguments.  */\n+\n+void\n+test_x (char *d,\n+\tint iexpr, unsigned int uiexpr,\n+\tlong lexpr, unsigned long ulexpr,\n+\tlong long llexpr, unsigned long long ullexpr,\n+\tfloat fexpr, double dexpr, long double ldexpr,\n+\tvoid *ptr)\n+{\n+  /* Integer arguments.  */\n+\n+  sprintf (d, \" %-8x \", iexpr);\n+  sprintf (d, \" %-8x \", uiexpr);\n+\n+  sprintf (d, \" %-8x \", lexpr); /* { dg-warning \"20: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'long int'\" } */\n+/* TODO: ideally would also underline \"lexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8x \", lexpr);\n+                 ~~~^\n+                 %-8lx\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8x \", ulexpr); /* { dg-warning \"20: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'long unsigned int'\" } */\n+/* TODO: ideally would also underline \"lexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8x \", ulexpr);\n+                 ~~~^\n+                 %-8lx\n+   { dg-end-multiline-output \"\" } */\n+\n+  sprintf (d, \" %-8x \", llexpr); /* { dg-warning \"20: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'long long int'\" } */\n+/* TODO: ideally would also underline \"lexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8x \", llexpr);\n+                 ~~~^\n+                 %-8llx\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8x \", ullexpr); /* { dg-warning \"20: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'long long unsigned int'\" } */\n+/* TODO: ideally would also underline \"lexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8x \", ullexpr);\n+                 ~~~^\n+                 %-8llx\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Floating-point arguments.  */\n+\n+  sprintf (d, \" %-8x \", fexpr); /* { dg-warning \"20: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'double'\" } */\n+/* TODO: ideally would also underline \"fexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8x \", fexpr);\n+                 ~~~^\n+                 %-8f\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8x \", dexpr); /* { dg-warning \"20: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'double'\" } */\n+/* TODO: ideally would also underline \"dexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8x \", dexpr);\n+                 ~~~^\n+                 %-8f\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8x \", ldexpr); /* { dg-warning \"20: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'long double'\" } */\n+/* TODO: ideally would also underline \"ldexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8x \", ldexpr);\n+                 ~~~^\n+                 %-8Lf\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Pointer.  */\n+  sprintf (d, \" %-8x \", ptr); /* { dg-warning \"20: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'void \\\\*'\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8x \", ptr);\n+                 ~~~^\n+                 %-8p\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Something unrecognized.  */\n+  struct s { int i; };\n+  struct s s;\n+  sprintf (d, \" %-8x \", s); /* { dg-warning \"20: format '%x' expects argument of type 'unsigned int', but argument 3 has type 'struct s'\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8x \", s);\n+                 ~~~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Tests of \"x\" with \"l\", with various param types.\n+   Suggestions should preserve the \"x\" for integer arguments.  */\n+\n+void\n+test_lx (char *d,\n+\t int iexpr, unsigned int uiexpr,\n+\t long lexpr, unsigned long ulexpr,\n+\t long long llexpr, unsigned long long ullexpr,\n+\t float fexpr, double dexpr, long double ldexpr)\n+{\n+  /* Integer arguments.  */\n+\n+  sprintf (d, \" %-8lx \", iexpr); /* { dg-warning \"21: format '%lx' expects argument of type 'long unsigned int', but argument 3 has type 'int'\" } */\n+/* TODO: ideally would also underline \"iexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lx \", iexpr);\n+                 ~~~~^\n+                 %-8x\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8lx \", uiexpr); /* { dg-warning \"21: format '%lx' expects argument of type 'long unsigned int', but argument 3 has type 'unsigned int'\" } */\n+/* TODO: ideally would also underline \"uiexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lx \", uiexpr);\n+                 ~~~~^\n+                 %-8x\n+   { dg-end-multiline-output \"\" } */\n+\n+  sprintf (d, \" %-8lx \", lexpr);\n+  sprintf (d, \" %-8lx \", ulexpr);\n+\n+  sprintf (d, \" %-8lx \", llexpr); /* { dg-warning \"21: format '%lx' expects argument of type 'long unsigned int', but argument 3 has type 'long long int'\" } */\n+/* TODO: ideally would also underline \"llexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lx \", llexpr);\n+                 ~~~~^\n+                 %-8llx\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8lx \", ullexpr); /* { dg-warning \"21: format '%lx' expects argument of type 'long unsigned int', but argument 3 has type 'long long unsigned int'\" } */\n+/* TODO: ideally would also underline \"ullexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lx \", ullexpr);\n+                 ~~~~^\n+                 %-8llx\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Floating-point arguments.  */\n+\n+  sprintf (d, \" %-8lx \", fexpr); /* { dg-warning \"21: format '%lx' expects argument of type 'long unsigned int', but argument 3 has type 'double'\" } */\n+/* TODO: ideally would also underline \"fexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lx \", fexpr);\n+                 ~~~~^\n+                 %-8f\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8lx \", dexpr); /* { dg-warning \"21: format '%lx' expects argument of type 'long unsigned int', but argument 3 has type 'double'\" } */\n+/* TODO: ideally would also underline \"dexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lx \", dexpr);\n+                 ~~~~^\n+                 %-8f\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8lx \", ldexpr); /* { dg-warning \"21: format '%lx' expects argument of type 'long unsigned int', but argument 3 has type 'long double'\" } */\n+/* TODO: ideally would also underline \"ldexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lx \", ldexpr);\n+                 ~~~~^\n+                 %-8Lf\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Tests of \"o\" without a length modifier, with various param types.\n+   Suggestions should preserve the \"o\" for integer arguments.  */\n+\n+void\n+test_o (char *d,\n+\tint iexpr, unsigned int uiexpr,\n+\tlong lexpr, unsigned long ulexpr,\n+\tlong long llexpr, unsigned long long ullexpr)\n+{\n+  /* Integer arguments.  */\n+\n+  sprintf (d, \" %-8o \", iexpr);\n+  sprintf (d, \" %-8o \", uiexpr);\n+\n+  sprintf (d, \" %-8o \", lexpr); /* { dg-warning \"20: format '%o' expects argument of type 'unsigned int', but argument 3 has type 'long int'\" } */\n+/* TODO: ideally would also underline \"lexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8o \", lexpr);\n+                 ~~~^\n+                 %-8lo\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8o \", ulexpr); /* { dg-warning \"20: format '%o' expects argument of type 'unsigned int', but argument 3 has type 'long unsigned int'\" } */\n+/* TODO: ideally would also underline \"lexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8o \", ulexpr);\n+                 ~~~^\n+                 %-8lo\n+   { dg-end-multiline-output \"\" } */\n+\n+  sprintf (d, \" %-8o \", llexpr); /* { dg-warning \"20: format '%o' expects argument of type 'unsigned int', but argument 3 has type 'long long int'\" } */\n+/* TODO: ideally would also underline \"lexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8o \", llexpr);\n+                 ~~~^\n+                 %-8llo\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8o \", ullexpr); /* { dg-warning \"20: format '%o' expects argument of type 'unsigned int', but argument 3 has type 'long long unsigned int'\" } */\n+/* TODO: ideally would also underline \"lexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8o \", ullexpr);\n+                 ~~~^\n+                 %-8llo\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Tests of \"o\" with \"l\", with various param types.\n+   Suggestions should preserve the \"o\" for integer arguments.  */\n+\n+void\n+test_lo (char *d,\n+\tint iexpr, unsigned int uiexpr,\n+\tlong lexpr, unsigned long ulexpr,\n+\tlong long llexpr, unsigned long long ullexpr)\n+{\n+  /* Integer arguments.  */\n+\n+  sprintf (d, \" %-8lo \", iexpr); /* { dg-warning \"21: format '%lo' expects argument of type 'long unsigned int', but argument 3 has type 'int'\" } */\n+/* TODO: ideally would also underline \"iexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lo \", iexpr);\n+                 ~~~~^\n+                 %-8o\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8lo \", uiexpr); /* { dg-warning \"21: format '%lo' expects argument of type 'long unsigned int', but argument 3 has type 'unsigned int'\" } */\n+/* TODO: ideally would also underline \"uiexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lo \", uiexpr);\n+                 ~~~~^\n+                 %-8o\n+   { dg-end-multiline-output \"\" } */\n+\n+  sprintf (d, \" %-8lo \", lexpr);\n+  sprintf (d, \" %-8lo \", ulexpr);\n+\n+  sprintf (d, \" %-8lo \", llexpr); /* { dg-warning \"21: format '%lo' expects argument of type 'long unsigned int', but argument 3 has type 'long long int'\" } */\n+/* TODO: ideally would also underline \"llexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lo \", llexpr);\n+                 ~~~~^\n+                 %-8llo\n+   { dg-end-multiline-output \"\" } */\n+  sprintf (d, \" %-8lo \", ullexpr); /* { dg-warning \"21: format '%lo' expects argument of type 'long unsigned int', but argument 3 has type 'long long unsigned int'\" } */\n+/* TODO: ideally would also underline \"ullexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8lo \", ullexpr);\n+                 ~~~~^\n+                 %-8llo\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Tests of \"e\" without a length modifier, with various param types.\n+   Suggestions should preserve the \"e\" for float  arguments.  */\n+\n+void\n+test_e (char *d, int iexpr, float fexpr, double dexpr, long double ldexpr)\n+{\n+  /* Integer arguments.  */\n+\n+  sprintf (d, \" %-8e \", iexpr); /* { dg-warning \"20: format '%e' expects argument of type 'double', but argument 3 has type 'int'\" } */\n+/* TODO: ideally would also underline \"iexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8e \", iexpr);\n+                 ~~~^\n+                 %-8d\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Floating-point arguments.  */\n+\n+  sprintf (d, \" %-8e \", fexpr);\n+  sprintf (d, \" %-8e \", dexpr);\n+  sprintf (d, \" %-8e \", ldexpr); /* { dg-warning \"20: format '%e' expects argument of type 'double', but argument 3 has type 'long double'\" } */\n+/* TODO: ideally would also underline \"ldexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8e \", ldexpr);\n+                 ~~~^\n+                 %-8Le\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Tests of \"e\" with \"L\", with various param types.\n+   Suggestions should preserve the \"e\" for float  arguments.  */\n+\n+void\n+test_Le (char *d, int iexpr, float fexpr, double dexpr, long double ldexpr)\n+{\n+  /* Integer arguments.  */\n+\n+  sprintf (d, \" %-8Le \", iexpr); /* { dg-warning \"21: format '%Le' expects argument of type 'long double', but argument 3 has type 'int'\" } */\n+/* TODO: ideally would also underline \"iexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8Le \", iexpr);\n+                 ~~~~^\n+                 %-8d\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Floating-point arguments.  */\n+\n+  sprintf (d, \" %-8Le \", fexpr); /* { dg-warning \"21: format '%Le' expects argument of type 'long double', but argument 3 has type 'double'\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8Le \", fexpr);\n+                 ~~~~^\n+                 %-8e\n+   { dg-end-multiline-output \"\" } */\n+\n+  sprintf (d, \" %-8Le \", dexpr); /* { dg-warning \"21: format '%Le' expects argument of type 'long double', but argument 3 has type 'double'\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8Le \", dexpr);\n+                 ~~~~^\n+                 %-8e\n+   { dg-end-multiline-output \"\" } */\n+\n+  sprintf (d, \" %-8Le \", ldexpr);\n+}\n+\n+/* Tests of \"E\" without a length modifier, with various param types.\n+   Suggestions should preserve the \"E\" for floating-point arguments.  */\n+\n+void\n+test_E (char *d, int iexpr, float fexpr, double dexpr, long double ldexpr)\n+{\n+  /* Integer arguments.  */\n+\n+  sprintf (d, \" %-8E \", iexpr); /* { dg-warning \"20: format '%E' expects argument of type 'double', but argument 3 has type 'int'\" } */\n+/* TODO: ideally would also underline \"iexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8E \", iexpr);\n+                 ~~~^\n+                 %-8d\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Floating-point arguments.  */\n+\n+  sprintf (d, \" %-8E \", fexpr);\n+  sprintf (d, \" %-8E \", dexpr);\n+  sprintf (d, \" %-8E \", ldexpr); /* { dg-warning \"20: format '%E' expects argument of type 'double', but argument 3 has type 'long double'\" } */\n+/* TODO: ideally would also underline \"ldexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8E \", ldexpr);\n+                 ~~~^\n+                 %-8LE\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Tests of \"E\" with \"L\", with various param types.\n+   Suggestions should preserve the \"E\" for floating-point arguments.  */\n+\n+void\n+test_LE (char *d, int iexpr, float fexpr, double dexpr, long double ldexpr)\n+{\n+  /* Integer arguments.  */\n+\n+  sprintf (d, \" %-8LE \", iexpr); /* { dg-warning \"21: format '%LE' expects argument of type 'long double', but argument 3 has type 'int'\" } */\n+/* TODO: ideally would also underline \"iexpr\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8LE \", iexpr);\n+                 ~~~~^\n+                 %-8d\n+   { dg-end-multiline-output \"\" } */\n+\n+  sprintf (d, \" %-8LE \", fexpr); /* { dg-warning \"21: format '%LE' expects argument of type 'long double', but argument 3 has type 'double'\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8LE \", fexpr);\n+                 ~~~~^\n+                 %-8E\n+   { dg-end-multiline-output \"\" } */\n+\n+  sprintf (d, \" %-8LE \", dexpr); /* { dg-warning \"21: format '%LE' expects argument of type 'long double', but argument 3 has type 'double'\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \" %-8LE \", dexpr);\n+                 ~~~~^\n+                 %-8E\n+   { dg-end-multiline-output \"\" } */\n+\n+  sprintf (d, \" %-8LE \", ldexpr);\n+}\n+\n+/* Test of a suggestion for a conversion specification containing\n+   all features (flags, width, precision, length modifier), where\n+   all the other arguments have mismatching types.  */\n+\n+void\n+test_everything (char *d, long lexpr)\n+{\n+  sprintf (d, \"before %-+*.*lld after\", lexpr, lexpr, lexpr); /* { dg-warning \"26: field width specifier '\\\\*' expects argument of type 'int', but argument 3 has type 'long int'\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \"before %-+*.*lld after\", lexpr, lexpr, lexpr);\n+                       ~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* { dg-warning \"28: field precision specifier '\\\\.\\\\*' expects argument of type 'int', but argument 4 has type 'long int'\" \"\" { target *-*-* } 392 } */\n+  /* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \"before %-+*.*lld after\", lexpr, lexpr, lexpr);\n+                       ~~~~~^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* { dg-warning \"31: format '%lld' expects argument of type 'long long int', but argument 5 has type 'long int'\" \"\" { target *-*-* } 392 } */\n+  /* { dg-begin-multiline-output \"\" }\n+   sprintf (d, \"before %-+*.*lld after\", lexpr, lexpr, lexpr);\n+                       ~~~~~~~~^\n+                       %-+*.*ld\n+   { dg-end-multiline-output \"\" } */\n+}"}]}