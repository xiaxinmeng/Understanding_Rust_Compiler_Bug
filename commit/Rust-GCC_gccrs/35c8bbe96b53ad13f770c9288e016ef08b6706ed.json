{"sha": "35c8bbe96b53ad13f770c9288e016ef08b6706ed", "node_id": "C_kwDOANBUbNoAKDM1YzhiYmU5NmI1M2FkMTNmNzcwYzkyODhlMDE2ZWYwOGI2NzA2ZWQ", "commit": {"author": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2021-11-26T03:14:21Z"}, "committer": {"name": "Siddhesh Poyarekar", "email": "siddhesh@gotplt.org", "date": "2021-11-26T18:03:56Z"}, "message": "tree-object-size: Replace magic numbers with enums\n\nA simple cleanup to allow inserting dynamic size code more easily.\n\ngcc/ChangeLog:\n\n\t* tree-object-size.c: New enum.\n\t(object_sizes, computed, addr_object_size,\n\tcompute_builtin_object_size, expr_object_size, call_object_size,\n\tmerge_object_sizes, plus_stmt_object_size,\n\tcollect_object_sizes_for, init_object_sizes, fini_object_sizes,\n\tobject_sizes_execute): Replace magic numbers with enums.\n\nSigned-off-by: Siddhesh Poyarekar <siddhesh@gotplt.org>", "tree": {"sha": "a4a9d2e93db79860ed5da7db809312846d8fbf04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4a9d2e93db79860ed5da7db809312846d8fbf04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35c8bbe96b53ad13f770c9288e016ef08b6706ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c8bbe96b53ad13f770c9288e016ef08b6706ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35c8bbe96b53ad13f770c9288e016ef08b6706ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c8bbe96b53ad13f770c9288e016ef08b6706ed/comments", "author": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "siddhesh", "id": 158582, "node_id": "MDQ6VXNlcjE1ODU4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/siddhesh", "html_url": "https://github.com/siddhesh", "followers_url": "https://api.github.com/users/siddhesh/followers", "following_url": "https://api.github.com/users/siddhesh/following{/other_user}", "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}", "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions", "organizations_url": "https://api.github.com/users/siddhesh/orgs", "repos_url": "https://api.github.com/users/siddhesh/repos", "events_url": "https://api.github.com/users/siddhesh/events{/privacy}", "received_events_url": "https://api.github.com/users/siddhesh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b41be002eda047093bbf4757cb65ffb4d525cc35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b41be002eda047093bbf4757cb65ffb4d525cc35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b41be002eda047093bbf4757cb65ffb4d525cc35"}], "stats": {"total": 59, "additions": 34, "deletions": 25}, "files": [{"sha": "5e93bb74f926b9071ba96bc60e97b8a75162b3e5", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35c8bbe96b53ad13f770c9288e016ef08b6706ed/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35c8bbe96b53ad13f770c9288e016ef08b6706ed/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=35c8bbe96b53ad13f770c9288e016ef08b6706ed", "patch": "@@ -45,6 +45,13 @@ struct object_size_info\n   unsigned int *stack, *tos;\n };\n \n+enum\n+{\n+  OST_SUBOBJECT = 1,\n+  OST_MINIMUM = 2,\n+  OST_END = 4,\n+};\n+\n static tree compute_object_offset (const_tree, const_tree);\n static bool addr_object_size (struct object_size_info *,\n \t\t\t      const_tree, int, unsigned HOST_WIDE_INT *);\n@@ -67,10 +74,10 @@ static void check_for_plus_in_loops_1 (struct object_size_info *, tree,\n    the subobject (innermost array or field with address taken).\n    object_sizes[2] is lower bound for number of bytes till the end of\n    the object and object_sizes[3] lower bound for subobject.  */\n-static vec<unsigned HOST_WIDE_INT> object_sizes[4];\n+static vec<unsigned HOST_WIDE_INT> object_sizes[OST_END];\n \n /* Bitmaps what object sizes have been computed already.  */\n-static bitmap computed[4];\n+static bitmap computed[OST_END];\n \n /* Maximum value of offset we consider to be addition.  */\n static unsigned HOST_WIDE_INT offset_limit;\n@@ -227,11 +234,11 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n     {\n       unsigned HOST_WIDE_INT sz;\n \n-      if (!osi || (object_size_type & 1) != 0\n+      if (!osi || (object_size_type & OST_SUBOBJECT) != 0\n \t  || TREE_CODE (TREE_OPERAND (pt_var, 0)) != SSA_NAME)\n \t{\n \t  compute_builtin_object_size (TREE_OPERAND (pt_var, 0),\n-\t\t\t\t       object_size_type & ~1, &sz);\n+\t\t\t\t       object_size_type & ~OST_SUBOBJECT, &sz);\n \t}\n       else\n \t{\n@@ -266,7 +273,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n     }\n   else if (DECL_P (pt_var))\n     {\n-      pt_var_size = decl_init_size (pt_var, object_size_type & 2);\n+      pt_var_size = decl_init_size (pt_var, object_size_type & OST_MINIMUM);\n       if (!pt_var_size)\n \treturn false;\n     }\n@@ -287,7 +294,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n     {\n       tree var;\n \n-      if (object_size_type & 1)\n+      if (object_size_type & OST_SUBOBJECT)\n \t{\n \t  var = TREE_OPERAND (ptr, 0);\n \n@@ -528,7 +535,7 @@ bool\n compute_builtin_object_size (tree ptr, int object_size_type,\n \t\t\t     unsigned HOST_WIDE_INT *psize)\n {\n-  gcc_assert (object_size_type >= 0 && object_size_type <= 3);\n+  gcc_assert (object_size_type >= 0 && object_size_type < OST_END);\n \n   /* Set to unknown and overwrite just before returning if the size\n      could be determined.  */\n@@ -546,7 +553,7 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \n   if (computed[object_size_type] == NULL)\n     {\n-      if (optimize || object_size_type & 1)\n+      if (optimize || object_size_type & OST_SUBOBJECT)\n \treturn false;\n \n       /* When not optimizing, rather than failing, make a small effort\n@@ -586,8 +593,8 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \"Computing %s %sobject size for \",\n-\t\t   (object_size_type & 2) ? \"minimum\" : \"maximum\",\n-\t\t   (object_size_type & 1) ? \"sub\" : \"\");\n+\t\t   (object_size_type & OST_MINIMUM) ? \"minimum\" : \"maximum\",\n+\t\t   (object_size_type & OST_SUBOBJECT) ? \"sub\" : \"\");\n \t  print_generic_expr (dump_file, ptr, dump_flags);\n \t  fprintf (dump_file, \":\\n\");\n \t}\n@@ -620,7 +627,7 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \t     terminate, it could take a long time.  If a pointer is\n \t     increasing this way, we need to assume 0 object size.\n \t     E.g. p = &buf[0]; while (cond) p = p + 4;  */\n-\t  if (object_size_type & 2)\n+\t  if (object_size_type & OST_MINIMUM)\n \t    {\n \t      osi.depths = XCNEWVEC (unsigned int, num_ssa_names);\n \t      osi.stack = XNEWVEC (unsigned int, num_ssa_names);\n@@ -679,8 +686,9 @@ compute_builtin_object_size (tree ptr, int object_size_type,\n \t\tfprintf (dump_file,\n \t\t\t \": %s %sobject size \"\n \t\t\t HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\",\n-\t\t\t (object_size_type & 2) ? \"minimum\" : \"maximum\",\n-\t\t\t (object_size_type & 1) ? \"sub\" : \"\",\n+\t\t\t ((object_size_type & OST_MINIMUM) ? \"minimum\"\n+\t\t\t  : \"maximum\"),\n+\t\t\t (object_size_type & OST_SUBOBJECT) ? \"sub\" : \"\",\n \t\t\t object_sizes[object_size_type][i]);\n \t      }\n \t}\n@@ -718,7 +726,7 @@ expr_object_size (struct object_size_info *osi, tree ptr, tree value)\n   else\n     bytes = unknown (object_size_type);\n \n-  if ((object_size_type & 2) == 0)\n+  if ((object_size_type & OST_MINIMUM) == 0)\n     {\n       if (object_sizes[object_size_type][varno] < bytes)\n \tobject_sizes[object_size_type][varno] = bytes;\n@@ -748,7 +756,7 @@ call_object_size (struct object_size_info *osi, tree ptr, gcall *call)\n \n   bytes = alloc_object_size (call, object_size_type);\n \n-  if ((object_size_type & 2) == 0)\n+  if ((object_size_type & OST_MINIMUM) == 0)\n     {\n       if (object_sizes[object_size_type][varno] < bytes)\n \tobject_sizes[object_size_type][varno] = bytes;\n@@ -804,7 +812,7 @@ merge_object_sizes (struct object_size_info *osi, tree dest, tree orig,\n     orig_bytes = (offset > orig_bytes)\n \t\t ? HOST_WIDE_INT_0U : orig_bytes - offset;\n \n-  if ((object_size_type & 2) == 0)\n+  if ((object_size_type & OST_MINIMUM) == 0)\n     {\n       if (object_sizes[object_size_type][varno] < orig_bytes)\n \t{\n@@ -882,7 +890,7 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple *stmt)\n   else\n     bytes = unknown (object_size_type);\n \n-  if ((object_size_type & 2) == 0)\n+  if ((object_size_type & OST_MINIMUM) == 0)\n     {\n       if (object_sizes[object_size_type][varno] < bytes)\n \tobject_sizes[object_size_type][varno] = bytes;\n@@ -968,7 +976,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n       if (bitmap_set_bit (osi->visited, varno))\n \t{\n \t  object_sizes[object_size_type][varno]\n-\t    = (object_size_type & 2) ? -1 : 0;\n+\t    = (object_size_type & OST_MINIMUM) ? -1 : 0;\n \t}\n       else\n \t{\n@@ -1238,7 +1246,7 @@ init_object_sizes (void)\n   if (computed[0])\n     return;\n \n-  for (object_size_type = 0; object_size_type <= 3; object_size_type++)\n+  for (object_size_type = 0; object_size_type < OST_END; object_size_type++)\n     {\n       object_sizes[object_size_type].safe_grow (num_ssa_names, true);\n       computed[object_size_type] = BITMAP_ALLOC (NULL);\n@@ -1255,7 +1263,7 @@ fini_object_sizes (void)\n {\n   int object_size_type;\n \n-  for (object_size_type = 0; object_size_type <= 3; object_size_type++)\n+  for (object_size_type = 0; object_size_type < OST_END; object_size_type++)\n     {\n       object_sizes[object_size_type].release ();\n       BITMAP_FREE (computed[object_size_type]);\n@@ -1302,7 +1310,7 @@ object_sizes_execute (function *fun, bool insert_min_max_p)\n \t\t{\n \t\t  unsigned HOST_WIDE_INT object_size_type = tree_to_uhwi (ost);\n \t\t  tree ptr = gimple_call_arg (call, 0);\n-\t\t  if ((object_size_type == 1 || object_size_type == 3)\n+\t\t  if ((object_size_type & OST_SUBOBJECT)\n \t\t      && (TREE_CODE (ptr) == ADDR_EXPR\n \t\t\t  || TREE_CODE (ptr) == SSA_NAME))\n \t\t    {\n@@ -1315,7 +1323,8 @@ object_sizes_execute (function *fun, bool insert_min_max_p)\n \t\t\t  tree tem = make_ssa_name (type);\n \t\t\t  gimple_call_set_lhs (call, tem);\n \t\t\t  enum tree_code code\n-\t\t\t    = object_size_type == 1 ? MIN_EXPR : MAX_EXPR;\n+\t\t\t    = (object_size_type & OST_MINIMUM\n+\t\t\t       ? MAX_EXPR : MIN_EXPR);\n \t\t\t  tree cst = build_int_cstu (type, bytes);\n \t\t\t  gimple *g\n \t\t\t    = gimple_build_assign (lhs, code, tem, cst);\n@@ -1336,11 +1345,11 @@ object_sizes_execute (function *fun, bool insert_min_max_p)\n \t\t{\n \t\t  unsigned HOST_WIDE_INT object_size_type = tree_to_uhwi (ost);\n \n-\t\t  if (object_size_type < 2)\n+\t\t  if (object_size_type & OST_MINIMUM)\n+\t\t    result = build_zero_cst (size_type_node);\n+\t\t  else if (object_size_type < OST_END)\n \t\t    result = fold_convert (size_type_node,\n \t\t\t\t\t   integer_minus_one_node);\n-\t\t  else if (object_size_type < 4)\n-\t\t    result = build_zero_cst (size_type_node);\n \t\t}\n \n \t      if (!result)"}]}