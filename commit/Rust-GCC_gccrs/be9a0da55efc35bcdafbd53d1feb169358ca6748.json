{"sha": "be9a0da55efc35bcdafbd53d1feb169358ca6748", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU5YTBkYTU1ZWZjMzViY2RhZmJkNTNkMWZlYjE2OTM1OGNhNjc0OA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2014-05-13T10:09:54Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2014-05-13T10:09:54Z"}, "message": "tree-ssa-loop-ivopts.c (contain_complex_addr_expr): New.\n\n\n\t* tree-ssa-loop-ivopts.c (contain_complex_addr_expr): New.\n\t(alloc_iv): Lower base expressions containing ADDR_EXPR.\n\n\t* gcc.dg/tree-ssa/ivopts-lower_base.c: New test.\n\nFrom-SVN: r210356", "tree": {"sha": "f71216c1f9690aa1df1c1f66975c5cf592832eff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f71216c1f9690aa1df1c1f66975c5cf592832eff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be9a0da55efc35bcdafbd53d1feb169358ca6748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be9a0da55efc35bcdafbd53d1feb169358ca6748", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be9a0da55efc35bcdafbd53d1feb169358ca6748", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be9a0da55efc35bcdafbd53d1feb169358ca6748/comments", "author": null, "committer": null, "parents": [{"sha": "73d9ac6a6a221b0bf3f2246004f323a1a353a3aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73d9ac6a6a221b0bf3f2246004f323a1a353a3aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73d9ac6a6a221b0bf3f2246004f323a1a353a3aa"}], "stats": {"total": 116, "additions": 105, "deletions": 11}, "files": [{"sha": "a6cb773cd0bafabe400c08a78cf774d4c0ed2d9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be9a0da55efc35bcdafbd53d1feb169358ca6748/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be9a0da55efc35bcdafbd53d1feb169358ca6748/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be9a0da55efc35bcdafbd53d1feb169358ca6748", "patch": "@@ -1,3 +1,8 @@\n+2014-05-13  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (contain_complex_addr_expr): New.\n+\t(alloc_iv): Lower base expressions containing ADDR_EXPR.\n+\n 2014-05-13  Ian Bolton  <ian.bolton@arm.com>\n \n \t* config/aarch64/aarch64-protos.h"}, {"sha": "1428a133a7c21e7c6366b0ad059cfa846b835d65", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be9a0da55efc35bcdafbd53d1feb169358ca6748/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be9a0da55efc35bcdafbd53d1feb169358ca6748/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=be9a0da55efc35bcdafbd53d1feb169358ca6748", "patch": "@@ -1,3 +1,7 @@\n+2014-05-13  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/ivopts-lower_base.c: New test.\n+\n 2014-05-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/61060"}, {"sha": "3b2b81f46a4d7d41685b5159e76ce7ae63c09d49", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ivopts-lower_base.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be9a0da55efc35bcdafbd53d1feb169358ca6748/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-lower_base.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be9a0da55efc35bcdafbd53d1feb169358ca6748/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-lower_base.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fivopts-lower_base.c?ref=be9a0da55efc35bcdafbd53d1feb169358ca6748", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#define MAX_NUM\t(256)\n+\n+void\n+sort_pointers (size_t n, void **pointers, void **work)\n+{\n+  typedef unsigned char digit_t;\n+  unsigned int count[MAX_NUM];\n+  int big_endian_p;\n+  size_t i;\n+  size_t j;\n+\n+  if ((sizeof (void *) / sizeof (digit_t)) % 2 != 0)\n+    abort ();\n+\n+  for (i = 0, j = 0; i < sizeof (size_t); ++i)\n+    {\n+      j *= MAX_NUM;\n+      j += i;\n+    }\n+\n+  big_endian_p = (((char *)&j)[0] == 0);\n+  for (i = 0; i < sizeof (void *) / sizeof (digit_t); ++i)\n+    {\n+      digit_t *digit;\n+      digit_t *bias;\n+      digit_t *top;\n+      unsigned int *countp;\n+      void **pointerp;\n+\n+      if (big_endian_p)\n+\tj = sizeof (void *) / sizeof (digit_t) - i;\n+      else\n+\tj = i;\n+\n+      memset (count, 0, MAX_NUM * sizeof (unsigned int));\n+      bias = ((digit_t *) pointers) + j;\n+      top = ((digit_t *) (pointers + n)) + j;\n+      for (digit = bias;\n+\t   digit < top;\n+\t   digit += sizeof (void *) / sizeof (digit_t))\n+\t++count[*digit];\n+\n+      for (countp = count + 1; countp < count + MAX_NUM; ++countp)\n+\t*countp += countp[-1];\n+\n+      for (pointerp = pointers + n - 1; pointerp >= pointers; --pointerp)\n+\twork[--count[((digit_t *) pointerp)[j]]] = *pointerp;\n+\n+      pointerp = pointers;\n+      pointers = work;\n+      work = pointerp;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"base \\[^\\\\n\\]*&MEM\\\\\\[\" \"ivopts\" } }  */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } }  */"}, {"sha": "b24463df40813b44e9784f3c85d79966595aec39", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be9a0da55efc35bcdafbd53d1feb169358ca6748/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be9a0da55efc35bcdafbd53d1feb169358ca6748/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=be9a0da55efc35bcdafbd53d1feb169358ca6748", "patch": "@@ -928,36 +928,60 @@ determine_base_object (tree expr)\n     }\n }\n \n+/* Return true if address expression with non-DECL_P operand appears\n+   in EXPR.  */\n+\n+static bool\n+contain_complex_addr_expr (tree expr)\n+{\n+  bool res = false;\n+\n+  STRIP_NOPS (expr);\n+  switch (TREE_CODE (expr))\n+    {\n+    case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      res |= contain_complex_addr_expr (TREE_OPERAND (expr, 0));\n+      res |= contain_complex_addr_expr (TREE_OPERAND (expr, 1));\n+      break;\n+\n+    case ADDR_EXPR:\n+      return (!DECL_P (TREE_OPERAND (expr, 0)));\n+\n+    default:\n+      return false;\n+    }\n+\n+  return res;\n+}\n+\n /* Allocates an induction variable with given initial value BASE and step STEP\n    for loop LOOP.  */\n \n static struct iv *\n alloc_iv (tree base, tree step)\n {\n-  tree base_object = base;\n+  tree expr = base;\n   struct iv *iv = XCNEW (struct iv);\n   gcc_assert (step != NULL_TREE);\n \n-  /* Lower all address expressions except ones with DECL_P as operand.\n+  /* Lower address expression in base except ones with DECL_P as operand.\n      By doing this:\n        1) More accurate cost can be computed for address expressions;\n        2) Duplicate candidates won't be created for bases in different\n           forms, like &a[0] and &a.  */\n-  STRIP_NOPS (base_object);\n-  if (TREE_CODE (base_object) == ADDR_EXPR\n-      && !DECL_P (TREE_OPERAND (base_object, 0)))\n+  STRIP_NOPS (expr);\n+  if ((TREE_CODE (expr) == ADDR_EXPR && !DECL_P (TREE_OPERAND (expr, 0)))\n+      || contain_complex_addr_expr (expr))\n     {\n       aff_tree comb;\n-      widest_int size;\n-      base_object = get_inner_reference_aff (TREE_OPERAND (base_object, 0),\n-\t\t\t\t\t     &comb, &size);\n-      gcc_assert (base_object != NULL_TREE);\n-      base_object = build_fold_addr_expr (base_object);\n+      tree_to_aff_combination (expr, TREE_TYPE (base), &comb);\n       base = fold_convert (TREE_TYPE (base), aff_combination_to_tree (&comb));\n     }\n \n   iv->base = base;\n-  iv->base_object = determine_base_object (base_object);\n+  iv->base_object = determine_base_object (base);\n   iv->step = step;\n   iv->biv_p = false;\n   iv->have_use_for = false;"}]}