{"sha": "306219a28de461c81501a32d77d3e0b1cce832c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA2MjE5YTI4ZGU0NjFjODE1MDFhMzJkNzdkM2UwYjFjY2U4MzJjOA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-01-29T19:38:00Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-01-29T19:38:00Z"}, "message": "tree.h (struct tree_memory_tag): Add aliases member.\n\n2007-01-28  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree.h (struct tree_memory_tag): Add aliases member.\n\t(MTAG_ALIASES): New macro.\n\t* tree-ssa-alias.c (alias_bitmap_obstack): New variable.\n\t(add_may_alias): Remove pointer-set. Update for may_aliases being\n\ta bitmap. \n\t(mark_aliases_call_clobbered): Update for may_aliases being a\n\tbitmap.\n\t(compute_tag_properties): Ditto.\n\t(create_partition_for): Ditto.\n\t(compute_memory_partitions): Ditto.\n\t(dump_may_aliases_for): Ditto.\n\t(is_aliased_with): Ditto.\n\t(add_may_alias_for_new_tag): Ditto.\n\t(rewrite_alias_set_for): Rewrite for may_aliases being a bitmap.\n\t(compute_is_aliased): New function.\n\t(compute_may_aliases): Call compute_is_aliased).\n\t(init_alias_info): Initialize alias_bitmap_obstack.\n\t(union_alias_set_into): New function.\n\t(compute_flow_sensitive_aliasing): Use union_aliases_into.\n\t(have_common_aliases_p): Rewrite to take two bitmaps and use\n\tintersection.\n\t(compute_flow_insensitive_aliasing): Stop using pointer-sets.\n\tUpdate for bitmaps.\n\t(finalize_ref_all_pointers): Update for add_may_alias changes.\n\t(new_type_alias): Ditto.\n\t* tree-flow-inline.h (may_aliases): Return a bitmap.\n\t* tree-dfa.c (dump_variable): Check for MTAG_P'ness.\n\t* tree-ssa.c (verify_flow_insensitive_alias_info): Update for\n\tmay_aliases being a bitmap.\n\t* tree-flow.h (struct var_ann_d): Remove may_aliases member.\n\tmay_aliases now returns a bitmap.\n\t* tree-ssa-structalias.c (merge_smts_into): Update for may_aliases\n\tbeing a bitmap.\n\t* tree-ssa-operands.c (add_virtual_operand): Update for\n\tmay_aliases being a bitmap.\n\nFrom-SVN: r121302", "tree": {"sha": "7897072edfc0eae9bd0cdbca19fba28cbf0e59c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7897072edfc0eae9bd0cdbca19fba28cbf0e59c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/306219a28de461c81501a32d77d3e0b1cce832c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/306219a28de461c81501a32d77d3e0b1cce832c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/306219a28de461c81501a32d77d3e0b1cce832c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/306219a28de461c81501a32d77d3e0b1cce832c8/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "acd724f62a7599bec3e40cdc5a02f961f64358d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd724f62a7599bec3e40cdc5a02f961f64358d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acd724f62a7599bec3e40cdc5a02f961f64358d3"}], "stats": {"total": 396, "additions": 222, "deletions": 174}, "files": [{"sha": "f389a62056a3acdff849e0909e731a3342642a10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=306219a28de461c81501a32d77d3e0b1cce832c8", "patch": "@@ -1,3 +1,41 @@\n+2007-01-28  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree.h (struct tree_memory_tag): Add aliases member.\n+\t(MTAG_ALIASES): New macro.\n+\t* tree-ssa-alias.c (alias_bitmap_obstack): New variable.\n+\t(add_may_alias): Remove pointer-set. Update for may_aliases being\n+\ta bitmap. \n+\t(mark_aliases_call_clobbered): Update for may_aliases being a\n+\tbitmap.\n+\t(compute_tag_properties): Ditto.\n+\t(create_partition_for): Ditto.\n+\t(compute_memory_partitions): Ditto.\n+\t(dump_may_aliases_for): Ditto.\n+\t(is_aliased_with): Ditto.\n+\t(add_may_alias_for_new_tag): Ditto.\n+\t(rewrite_alias_set_for): Rewrite for may_aliases being a bitmap.\n+\t(compute_is_aliased): New function.\n+\t(compute_may_aliases): Call compute_is_aliased).\n+\t(init_alias_info): Initialize alias_bitmap_obstack.\n+\t(union_alias_set_into): New function.\n+\t(compute_flow_sensitive_aliasing): Use union_aliases_into.\n+\t(have_common_aliases_p): Rewrite to take two bitmaps and use\n+\tintersection.\n+\t(compute_flow_insensitive_aliasing): Stop using pointer-sets.\n+\tUpdate for bitmaps.\n+\t(finalize_ref_all_pointers): Update for add_may_alias changes.\n+\t(new_type_alias): Ditto.\n+\t* tree-flow-inline.h (may_aliases): Return a bitmap.\n+\t* tree-dfa.c (dump_variable): Check for MTAG_P'ness.\n+\t* tree-ssa.c (verify_flow_insensitive_alias_info): Update for\n+\tmay_aliases being a bitmap.\n+\t* tree-flow.h (struct var_ann_d): Remove may_aliases member.\n+\tmay_aliases now returns a bitmap.\n+\t* tree-ssa-structalias.c (merge_smts_into): Update for may_aliases\n+\tbeing a bitmap.\n+\t* tree-ssa-operands.c (add_virtual_operand): Update for\n+\tmay_aliases being a bitmap.\n+\t\n 2007-01-29  Daniel Berlin  <dberlin@dberlin.org>\n \n \tPR tree-optimization/30630"}, {"sha": "f49c1adb54d11141df27bcc2ae671418ed9674a4", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=306219a28de461c81501a32d77d3e0b1cce832c8", "patch": "@@ -383,7 +383,7 @@ dump_variable (FILE *file, tree var)\n       print_generic_expr (file, gimple_default_def (cfun, var), dump_flags);\n     }\n \n-  if (may_aliases (var))\n+  if (MTAG_P (var) && may_aliases (var))\n     {\n       fprintf (file, \", may aliases: \");\n       dump_may_aliases_for (file, var);"}, {"sha": "64be7685b638f7c7dad325e0ee8ff38b9dc450b2", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=306219a28de461c81501a32d77d3e0b1cce832c8", "patch": "@@ -303,13 +303,12 @@ bb_for_stmt (tree t)\n   return ann ? ann->bb : NULL;\n }\n \n-/* Return the may_aliases varray for variable VAR, or NULL if it has\n+/* Return the may_aliases bitmap for variable VAR, or NULL if it has\n    no may aliases.  */\n-static inline VEC(tree, gc) *\n+static inline bitmap\n may_aliases (tree var)\n {\n-  var_ann_t ann = var_ann (var);\n-  return ann ? ann->may_aliases : NULL;\n+  return MTAG_ALIASES (var);\n }\n \n /* Return the line number for EXPR, or return -1 if we have no line"}, {"sha": "19efacd5ca21966d55d014244d8a99b56865b114", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=306219a28de461c81501a32d77d3e0b1cce832c8", "patch": "@@ -266,11 +266,6 @@ struct var_ann_d GTY(())\n      to convert to hash table?  */\n   tree symbol_mem_tag;\n \n-  /* Variables that may alias this variable.  This may only be set on\n-     memory tags (NAME_MEMORY_TAG or TYPE_MEMORY_TAG).  FIXME, move to\n-     struct tree_memory_tag.  */\n-  VEC(tree, gc) *may_aliases;\n-\n   /* Used when going out of SSA form to indicate which partition this\n      variable represents storage for.  */\n   unsigned partition;\n@@ -431,7 +426,7 @@ extern void set_bb_for_stmt (tree, basic_block);\n static inline bool noreturn_call_p (tree);\n static inline void update_stmt (tree);\n static inline bool stmt_modified_p (tree);\n-static inline VEC(tree, gc) *may_aliases (tree);\n+static inline bitmap may_aliases (tree);\n static inline int get_lineno (tree);\n static inline const char *get_filename (tree);\n static inline bool is_exec_stmt (tree);"}, {"sha": "e3fe52abb5535df2347abd177927ff1e4a8ddb96", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 151, "deletions": 139, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=306219a28de461c81501a32d77d3e0b1cce832c8", "patch": "@@ -90,6 +90,7 @@ struct alias_stats_d\n \n /* Local variables.  */\n static struct alias_stats_d alias_stats;\n+static bitmap_obstack alias_bitmap_obstack;\n \n /* Local functions.  */\n static void compute_flow_insensitive_aliasing (struct alias_info *);\n@@ -99,7 +100,7 @@ static bool may_alias_p (tree, HOST_WIDE_INT, tree, HOST_WIDE_INT, bool);\n static tree create_memory_tag (tree type, bool is_type_tag);\n static tree get_smt_for (tree, struct alias_info *);\n static tree get_nmt_for (tree);\n-static void add_may_alias (tree, tree, struct pointer_set_t *);\n+static void add_may_alias (tree, tree);\n static struct alias_info *init_alias_info (void);\n static void delete_alias_info (struct alias_info *);\n static void compute_flow_sensitive_aliasing (struct alias_info *);\n@@ -194,19 +195,21 @@ static void\n mark_aliases_call_clobbered (tree tag, VEC (tree, heap) **worklist,\n \t\t\t     VEC (int, heap) **worklist2)\n {\n+  bitmap aliases;\n+  bitmap_iterator bi;\n   unsigned int i;\n-  VEC (tree, gc) *ma;\n   tree entry;\n   var_ann_t ta = var_ann (tag);\n \n   if (!MTAG_P (tag))\n     return;\n-  ma = may_aliases (tag);\n-  if (!ma)\n+  aliases = may_aliases (tag);\n+  if (!aliases)\n     return;\n \n-  for (i = 0; VEC_iterate (tree, ma, i, entry); i++)\n+  EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n     {\n+      entry = referenced_var (i);\n       if (!unmodifiable_var_p (entry))\n \t{\n \t  add_to_worklist (entry, worklist, worklist2, ta->escape_mask);\n@@ -264,7 +267,8 @@ compute_tag_properties (void)\n       changed = false;      \n       for (k = 0; VEC_iterate (tree, taglist, k, tag); k++)\n \t{\n-\t  VEC (tree, gc) *ma;\n+\t  bitmap ma;\n+\t  bitmap_iterator bi;\n \t  unsigned int i;\n \t  tree entry;\n \t  bool tagcc = is_call_clobbered (tag);\n@@ -277,8 +281,9 @@ compute_tag_properties (void)\n \t  if (!ma)\n \t    continue;\n \n-\t  for (i = 0; VEC_iterate (tree, ma, i, entry); i++)\n+\t  EXECUTE_IF_SET_IN_BITMAP (ma, 0, i, bi)\n \t    {\n+\t      entry = referenced_var (i);\n \t      /* Call clobbered entries cause the tag to be marked\n \t\t call clobbered.  */\n \t      if (!tagcc && is_call_clobbered (entry))\n@@ -508,8 +513,9 @@ sort_mp_info (VEC(mp_info_t,heap) *list)\n static void\n create_partition_for (mp_info_t mp_p)\n {\n+  bitmap_iterator bi;\n   tree mpt, sym;\n-  VEC(tree,gc) *aliases;\n+  bitmap aliases;\n   unsigned i;\n \n   if (mp_p->num_vops <= (long) MAX_ALIASED_VOPS)\n@@ -556,11 +562,12 @@ create_partition_for (mp_info_t mp_p)\n   else\n     {\n       aliases = may_aliases (mp_p->var);\n-      gcc_assert (VEC_length (tree, aliases) > 1);\n+      gcc_assert (!bitmap_empty_p (aliases));\n \n       mpt = NULL_TREE;\n-      for (i = 0; VEC_iterate (tree, aliases, i, sym); i++)\n+      EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n \t{\n+\t  sym = referenced_var (i);\n \t  /* Only set the memory partition for aliased symbol SYM if\n \t     SYM does not belong to another partition.  */\n \t  if (memory_partition (sym) == NULL_TREE)\n@@ -614,11 +621,10 @@ rewrite_alias_set_for (tree tag, bitmap new_aliases)\n   else\n     {\n       /* Create a new alias set for TAG with the new partitions.  */\n-      var_ann_t ann;\n \n-      ann = var_ann (tag);\n-      for (i = 0; VEC_iterate (tree, ann->may_aliases, i, sym); i++)\n+      EXECUTE_IF_SET_IN_BITMAP (MTAG_ALIASES (tag), 0, i, bi)\n \t{\n+\t  sym = referenced_var (i);\n \t  mpt = memory_partition (sym);\n \t  if (mpt)\n \t    bitmap_set_bit (new_aliases, DECL_UID (mpt));\n@@ -627,9 +633,7 @@ rewrite_alias_set_for (tree tag, bitmap new_aliases)\n \t}\n \n       /* Rebuild the may-alias array for TAG.  */\n-      VEC_free (tree, gc, ann->may_aliases);\n-      EXECUTE_IF_SET_IN_BITMAP (new_aliases, 0, i, bi)\n-\tVEC_safe_push (tree, gc, ann->may_aliases, referenced_var (i));\n+      bitmap_copy (MTAG_ALIASES (tag), new_aliases);\n     }\n }\n \n@@ -691,7 +695,10 @@ compute_memory_partitions (void)\n       /* Each reference to VAR will produce as many VOPs as elements\n \t exist in its alias set.  */\n       mp.var = var;\n-      mp.num_vops = VEC_length (tree, may_aliases (var));\n+      if (!may_aliases (var))\n+\tmp.num_vops = 0;\n+      else\n+\tmp.num_vops = bitmap_count_bits (may_aliases (var));\n \n       /* No point grouping singleton alias sets.  */\n       if (mp.num_vops <= 1)\n@@ -769,6 +776,43 @@ compute_memory_partitions (void)\n   timevar_pop (TV_MEMORY_PARTITIONING);\n }\n \n+/* This function computes the value of the is_aliased bit for\n+   variables.  is_aliased is true for any variable that is in an\n+   alias bitmap.  */\n+\n+static void\n+compute_is_aliased (void)\n+{\n+  referenced_var_iterator rvi;\n+  tree tag;\n+  bitmap aliased_vars = BITMAP_ALLOC (NULL);\n+  bitmap_iterator bi;\n+  unsigned int i;\n+  \n+  /* Add is_aliased for all vars pointed to by the symbol tags.  */\n+  FOR_EACH_REFERENCED_VAR (tag, rvi)\n+    {\n+      bitmap aliases;\n+      if (TREE_CODE (tag) != SYMBOL_MEMORY_TAG\n+\t  && TREE_CODE (tag) != NAME_MEMORY_TAG)\n+\tcontinue;\n+      aliases = MTAG_ALIASES (tag);\n+      if (!aliases)\n+\tcontinue;\n+      \n+      bitmap_ior_into (aliased_vars, aliases);\t  \n+    }\n+  \n+  EXECUTE_IF_SET_IN_BITMAP (aliased_vars, 0, i, bi)\n+    {\n+      tree var = referenced_var (i);\n+      \n+      var_ann (var)->is_aliased = true;\n+    }\n+  \n+  BITMAP_FREE (aliased_vars);\n+}\n+\n \n /* Compute may-alias information for every variable referenced in function\n    FNDECL.\n@@ -937,6 +981,9 @@ compute_may_aliases (void)\n       dump_alias_info (dump_file);\n     }\n \n+  /* Set up is_aliased flags. */\n+  compute_is_aliased ();\n+  \n   /* Deallocate memory used by aliasing data structures.  */\n   delete_alias_info (ai);\n \n@@ -1112,7 +1159,9 @@ init_alias_info (void)\n   if (gimple_aliases_computed_p (cfun))\n     {\n       unsigned i;\n-  \n+      \n+      bitmap_obstack_release (&alias_bitmap_obstack);\n+      \n       /* Similarly, clear the set of addressable variables.  In this\n \t case, we can just clear the set because addressability is\n \t only computed here.  */\n@@ -1124,7 +1173,9 @@ init_alias_info (void)\n \t  var_ann_t ann = var_ann (var);\n \t  \n \t  ann->is_aliased = 0;\n-\t  ann->may_aliases = NULL;\n+\n+\t  if (MTAG_P (var))\n+\t    MTAG_ALIASES (var) = NULL;\n \n \t  /* Since we are about to re-discover call-clobbered\n \t     variables, clear the call-clobbered flag.  Variables that\n@@ -1180,6 +1231,7 @@ init_alias_info (void)\n \n   /* Next time, we will need to reset alias information.  */\n   cfun->gimple_df->aliases_computed_p = true;\n+  bitmap_obstack_initialize (&alias_bitmap_obstack);\n \n   return ai;\n }\n@@ -1331,6 +1383,21 @@ create_name_tags (void)\n   VEC_free (tree, heap, with_ptvars);\n }\n \n+/* Union the alias set SET into the may-aliases for TAG */\n+\n+static void\n+union_alias_set_into (tree tag, bitmap set)\n+{\n+  bitmap ma = MTAG_ALIASES (tag);\n+  \n+  if (bitmap_empty_p (set))\n+    return;\n+  \n+  if (!ma)\n+    ma = MTAG_ALIASES (tag) = BITMAP_ALLOC (&alias_bitmap_obstack);\n+  bitmap_ior_into (ma, set);\n+}\n+\n \n /* For every pointer P_i in AI->PROCESSED_PTRS, create may-alias sets for\n    the name memory tag (NMT) associated with P_i.  If P_i escapes, then its\n@@ -1358,46 +1425,50 @@ compute_flow_sensitive_aliasing (struct alias_info *ai)\n \n   for (i = 0; VEC_iterate (tree, ai->processed_ptrs, i, ptr); i++)\n     {\n-      unsigned j;\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n       tree tag = symbol_mem_tag (SSA_NAME_VAR (ptr));\n-      bitmap_iterator bi;\n \n       /* Set up aliasing information for PTR's name memory tag (if it has\n \t one).  Note that only pointers that have been dereferenced will\n \t have a name memory tag.  */\n       if (pi->name_mem_tag && pi->pt_vars)\n-\tEXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j, bi)\n-\t  {\n-\t    add_may_alias (pi->name_mem_tag, referenced_var (j), NULL);\n-\t    if (j != DECL_UID (tag))\n-\t      add_may_alias (tag, referenced_var (j), NULL);\n-\t  }\n+\t{\n+\t  if (!bitmap_empty_p (pi->pt_vars))\n+\t    {\n+\t      union_alias_set_into (pi->name_mem_tag, pi->pt_vars);\n+\t      union_alias_set_into (tag, pi->pt_vars);\n+\t      bitmap_clear_bit (MTAG_ALIASES (tag), DECL_UID (tag));\n+\t    \n+\t      /* It may be the case that this the tag uid was the only\n+\t\t bit we had set in the aliases list, and in this case,\n+\t\t we don't want to keep an empty bitmap, as this\n+\t\t asserts in tree-ssa-operands.c .  */\n+\t      if (bitmap_empty_p (MTAG_ALIASES (tag)))\n+\t\tBITMAP_FREE (MTAG_ALIASES (tag));\n+\t    }\n+\t}\n     }\n }\n \n \n-/* Return TRUE if at least one symbol in TAG's alias set is also\n-   present in SET1.  */\n+/* Return TRUE if at least one symbol in TAG2's alias set is also\n+   present in TAG1's alias set.  */\n \n static bool\n-have_common_aliases_p (struct pointer_set_t *set1, tree tag2)\n+have_common_aliases_p (bitmap tag1aliases, bitmap tag2aliases)\n {\n-  unsigned i;\n-  VEC(tree,gc) *aliases2;\n \n-  if (set1 == NULL)\n+  /* This is the old behavior of have_common_aliases_p, which is to\n+     return false if both sets are empty, or one set is and the other\n+     isn't.  */\n+     if ((tag1aliases == NULL && tag2aliases != NULL)\n+      || (tag2aliases == NULL && tag1aliases != NULL)\n+      || (tag1aliases == NULL && tag2aliases == NULL))\n     return false;\n \n-  aliases2 = may_aliases (tag2);\n-  for (i = 0; i < VEC_length (tree, aliases2); i++)\n-    if (pointer_set_contains (set1, VEC_index (tree, aliases2, i)))\n-      return true;\n-\n-  return false;\n+  return bitmap_intersect_p (tag1aliases, tag2aliases);\n }\n \n-\n /* Compute type-based alias sets.  Traverse all the pointers and\n    addressable variables found in setup_pointers_and_addressables.\n    \n@@ -1412,20 +1483,11 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n {\n   size_t i;\n \n-  /* Initialize pointer sets to keep track of duplicates in alias\n-     sets.  */\n-  for (i = 0; i < ai->num_pointers; i++)\n-    {\n-      tree tag = symbol_mem_tag (ai->pointers[i]->var);\n-      var_ann (tag)->common.aux = NULL;\n-    }\n-\n   /* For every pointer P, determine which addressable variables may alias\n      with P's symbol memory tag.  */\n   for (i = 0; i < ai->num_pointers; i++)\n     {\n       size_t j;\n-      struct pointer_set_t *already_added;\n       struct alias_map_d *p_map = ai->pointers[i];\n       tree tag = symbol_mem_tag (p_map->var);\n       tree var;\n@@ -1434,13 +1496,6 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n       if (PTR_IS_REF_ALL (p_map->var))\n \tcontinue;\n \n-      /* Retrieve or create the set of symbols that have already been\n-\t added to TAG's alias set.  */\n-      if (var_ann (tag)->common.aux == NULL)\n-\tvar_ann (tag)->common.aux = (void *) pointer_set_create ();\n-\n-      already_added = (struct pointer_set_t *) var_ann (tag)->common.aux;\n-\n       for (j = 0; j < ai->num_addressable_vars; j++)\n \t{\n \t  struct alias_map_d *v_map;\n@@ -1470,7 +1525,7 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t\t\t  || get_subvars_for_var (var) == NULL);\n \n \t      /* Add VAR to TAG's may-aliases set.  */\n-\t      add_may_alias (tag, var, already_added);\n+\t      add_may_alias (tag, var);\n \t    }\n \t}\n     }\n@@ -1498,20 +1553,18 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n   for (i = 0; i < ai->num_pointers; i++)\n     {\n       size_t j;\n-      struct pointer_set_t *set1;\n       struct alias_map_d *p_map1 = ai->pointers[i];\n       tree tag1 = symbol_mem_tag (p_map1->var);\n+      bitmap may_aliases1 = MTAG_ALIASES (tag1);\n \n       if (PTR_IS_REF_ALL (p_map1->var))\n \tcontinue;\n \n-      set1 = (struct pointer_set_t *) var_ann (tag1)->common.aux;\n-\n       for (j = i + 1; j < ai->num_pointers; j++)\n \t{\n \t  struct alias_map_d *p_map2 = ai->pointers[j];\n \t  tree tag2 = symbol_mem_tag (p_map2->var);\n-\t  VEC(tree,gc) *may_aliases2 = may_aliases (tag2);\n+\t  bitmap may_aliases2 = may_aliases (tag2);\n \n \t  if (PTR_IS_REF_ALL (p_map2->var))\n \t    continue;\n@@ -1522,37 +1575,21 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \n \t  /* The two pointers may alias each other.  If they already have\n \t     symbols in common, do nothing.  */\n-\t  if (have_common_aliases_p (set1, tag2))\n+\t  if (have_common_aliases_p (may_aliases1, may_aliases2))\n \t    continue;\n \n-\t  if (set1 == NULL)\n+\t  if (may_aliases2 && !bitmap_empty_p (may_aliases2))\n \t    {\n-\t      set1 = pointer_set_create ();\n-\t      var_ann (tag1)->common.aux = (void *) set1;\n-\t    }\n-\n-\t  if (VEC_length (tree, may_aliases2) > 0)\n-\t    {\n-\t      unsigned k;\n-\t      tree sym;\n-\n-\t      /* Add all the aliases for TAG2 into TAG1's alias set.  */\n-\t      for (k = 0; VEC_iterate (tree, may_aliases2, k, sym); k++)\n-\t\tadd_may_alias (tag1, sym, set1);\n+\t      union_alias_set_into (tag1, may_aliases2);\n \t    }\n \t  else\n \t    {\n \t      /* Since TAG2 does not have any aliases of its own, add\n \t\t TAG2 itself to the alias set of TAG1.  */\n-\t      add_may_alias (tag1, tag2, set1);\n+\t      add_may_alias (tag1, tag2);\n \t    }\n \t}\n \n-      if (set1)\n-\t{\n-\t  pointer_set_destroy (set1);\n-\t  var_ann (tag1)->common.aux = NULL;\n-\t}\n     }\n }\n \n@@ -1570,14 +1607,13 @@ static void\n finalize_ref_all_pointers (struct alias_info *ai)\n {\n   size_t i;\n-  struct pointer_set_t *already_added = pointer_set_create ();\n \n   /* First add the real call-clobbered variables.  */\n   for (i = 0; i < ai->num_addressable_vars; i++)\n     {\n       tree var = ai->addressable_vars[i]->var;\n       if (is_call_clobbered (var))\n-\tadd_may_alias (ai->ref_all_symbol_mem_tag, var, already_added);\n+\tadd_may_alias (ai->ref_all_symbol_mem_tag, var);\n     }\n \n   /* Then add the call-clobbered pointer memory tags.  See\n@@ -1589,10 +1625,9 @@ finalize_ref_all_pointers (struct alias_info *ai)\n \tcontinue;\n       tag = symbol_mem_tag (ptr);\n       if (is_call_clobbered (tag))\n-\tadd_may_alias (ai->ref_all_symbol_mem_tag, tag, already_added);\n+\tadd_may_alias (ai->ref_all_symbol_mem_tag, tag);\n     }\n \n-  pointer_set_destroy (already_added);\n }\n \n \n@@ -1960,15 +1995,11 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n }\n \n \n-/* Add ALIAS to the set of variables that may alias VAR.  If\n-   ALREADY_ADDED is given, it is used to avoid adding the same alias\n-   more than once to VAR's alias set.  */\n+/* Add ALIAS to the set of variables that may alias VAR.  */\n \n static void\n-add_may_alias (tree var, tree alias, struct pointer_set_t *already_added)\n+add_may_alias (tree var, tree alias)\n {\n-  var_ann_t v_ann = get_var_ann (var);\n-  var_ann_t a_ann = get_var_ann (alias);\n \n   /* Don't allow self-referential aliases.  */\n   gcc_assert (var != alias);\n@@ -1984,15 +2015,10 @@ add_may_alias (tree var, tree alias, struct pointer_set_t *already_added)\n   gcc_assert (TREE_CODE (var) == SYMBOL_MEMORY_TAG\n               || TREE_CODE (var) == NAME_MEMORY_TAG);\n \n-  if (v_ann->may_aliases == NULL)\n-    v_ann->may_aliases = VEC_alloc (tree, gc, 2);\n-\n-  /* Avoid adding duplicates.  */\n-  if (already_added && pointer_set_insert (already_added, alias))\n-    return;\n-\n-  VEC_safe_push (tree, gc, v_ann->may_aliases, alias);\n-  a_ann->is_aliased = 1;\n+  if (MTAG_ALIASES (var) == NULL)\n+    MTAG_ALIASES (var) = BITMAP_ALLOC (&alias_bitmap_obstack);\n+  \n+  bitmap_set_bit (MTAG_ALIASES (var), DECL_UID (alias));\n }\n \n \n@@ -2506,19 +2532,19 @@ debug_points_to_info (void)\n void\n dump_may_aliases_for (FILE *file, tree var)\n {\n-  VEC(tree, gc) *aliases;\n+  bitmap aliases;\n   \n-  if (TREE_CODE (var) == SSA_NAME)\n-    var = SSA_NAME_VAR (var);\n-\n-  aliases = var_ann (var)->may_aliases;\n+  aliases = MTAG_ALIASES (var);\n   if (aliases)\n     {\n-      size_t i;\n+      bitmap_iterator bi;\n+      unsigned int i;\n       tree al;\n+\n       fprintf (file, \"{ \");\n-      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+      EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n \t{\n+\t  al = referenced_var (i);\n \t  print_generic_expr (file, al, dump_flags);\n \t  fprintf (file, \" \");\n \t}\n@@ -2574,36 +2600,32 @@ may_be_aliased (tree var)\n }\n \n \n-/* Given two symbols return TRUE if one is in the alias set of the other.  */\n+/* Given two symbols return TRUE if one is in the alias set of the\n+   other.  */\n \n bool\n is_aliased_with (tree tag, tree sym)\n {\n-  size_t i;\n-  VEC(tree,gc) *aliases;\n-  tree al;\n+  bitmap aliases;\n \n-  if (var_ann (sym)->is_aliased)\n+  if (MTAG_P (tag))\n     {\n-      aliases = var_ann (tag)->may_aliases;\n+      aliases = MTAG_ALIASES (tag);\n \n       if (aliases == NULL)\n \treturn false;\n \n-      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n-\tif (al == sym)\n-\t  return true;\n+      return bitmap_bit_p (aliases, DECL_UID (sym));      \n     }\n   else\n     {\n-      aliases = var_ann (sym)->may_aliases;\n+      gcc_assert (MTAG_P (sym));\n+      aliases = MTAG_ALIASES (sym);\n \n       if (aliases == NULL)\n \treturn false;\n \n-      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n-\tif (al == tag)\n-\t  return true;\n+      return bitmap_bit_p (aliases, DECL_UID (tag));\n     }\n \n   return false;\n@@ -2619,37 +2641,27 @@ is_aliased_with (tree tag, tree sym)\n static tree\n add_may_alias_for_new_tag (tree tag, tree var)\n {\n-  VEC(tree,gc) *aliases;\n-  struct pointer_set_t *already_added;\n-  unsigned i;\n-  tree al;\n-\n-  aliases = may_aliases (var);\n+  bitmap aliases = NULL;\n+  \n+  if (MTAG_P (var))\n+    aliases = may_aliases (var);\n \n   /* Case 1: |aliases| == 1  */\n-  if (VEC_length (tree, aliases) == 1)\n+  if (aliases && bitmap_count_bits (aliases) == 1)\n     {\n-      tree ali = VEC_index (tree, aliases, 0);\n+      tree ali = referenced_var (bitmap_first_set_bit (aliases));\n       if (TREE_CODE (ali) == SYMBOL_MEMORY_TAG)\n         return ali;\n     }\n \n-  already_added = pointer_set_create ();\n-  for (i = 0; VEC_iterate (tree, may_aliases (tag), i, al); i++)\n-    pointer_set_insert (already_added, al);\n-\n   /* Case 2: |aliases| == 0  */\n   if (aliases == NULL)\n-    add_may_alias (tag, var, already_added);\n+    add_may_alias (tag, var);\n   else\n     {\n       /* Case 3: |aliases| > 1  */\n-      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n-        add_may_alias (tag, al, already_added);\n+      union_alias_set_into (tag, aliases);\n     }\n-\n-  pointer_set_destroy (already_added);\n-\n   return tag;\n }\n \n@@ -2736,7 +2748,7 @@ new_type_alias (tree ptr, tree var, tree expr)\n \t\t  /* Can happen only if 'Case 1' of add_may_alias_for_new_tag\n \t\t     took place.  Since more than one svar was found, we add \n \t\t     'ali' as one of the may_aliases of the new tag.  */ \n-\t\t  add_may_alias (tag, ali, NULL);\n+\t\t  add_may_alias (tag, ali);\n \t\t  ali = tag;\n \t\t}\n \t    }"}, {"sha": "aa56c197a25c77f079ec1a27f7e6436d3f6bf9aa", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=306219a28de461c81501a32d77d3e0b1cce832c8", "patch": "@@ -1441,7 +1441,7 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t\t     tree full_ref, HOST_WIDE_INT offset,\n \t\t     HOST_WIDE_INT size, bool for_clobber)\n {\n-  VEC(tree,gc) *aliases;\n+  bitmap aliases = NULL;\n   tree sym;\n   var_ann_t v_ann;\n   \n@@ -1479,7 +1479,8 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n   if (flags & opf_no_vops)\n     return;\n   \n-  aliases = v_ann->may_aliases;\n+  if (MTAG_P (var))\n+    aliases = MTAG_ALIASES (var);\n   if (aliases == NULL)\n     {\n       if (s_ann && !gimple_aliases_computed_p (cfun))\n@@ -1492,19 +1493,20 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n     }\n   else\n     {\n-      unsigned i;\n+      bitmap_iterator bi;\n+      unsigned int i;\n       tree al;\n       \n       /* The variable is aliased.  Add its aliases to the virtual\n \t operands.  */\n-      gcc_assert (VEC_length (tree, aliases) != 0);\n+      gcc_assert (!bitmap_empty_p (aliases));\n       \n       if (flags & opf_def)\n \t{\n \t  bool none_added = true;\n-\n-\t  for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+\t  EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n \t    {\n+\t      al = referenced_var (i);\n \t      if (!access_can_touch_variable (full_ref, al, offset, size))\n \t\tcontinue;\n \t      \n@@ -1534,14 +1536,15 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n       else\n \t{\n \t  bool none_added = true;\n-\t  for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+\t  EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n \t    {\n+\t      al = referenced_var (i);\n \t      if (!access_can_touch_variable (full_ref, al, offset, size))\n \t\tcontinue;\n \t      none_added = false;\n \t      append_vuse (al);\n \t    }\n-\n+\t  \n \t  /* Similarly, append a virtual uses for VAR itself, when\n \t     it is an alias tag.  */\n \t  if (v_ann->is_aliased || none_added)"}, {"sha": "0340a8039185316dd1abcc5b75fe46f88edc1ea5", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=306219a28de461c81501a32d77d3e0b1cce832c8", "patch": "@@ -4326,7 +4326,7 @@ merge_smts_into (tree p, varinfo_t vi)\n   unsigned int i;\n   bitmap_iterator bi;\n   tree smt;\n-  VEC(tree, gc) *aliases;\n+  bitmap aliases;\n   tree var = p;\n \n   if (TREE_CODE (p) == SSA_NAME)\n@@ -4350,15 +4350,9 @@ merge_smts_into (tree p, varinfo_t vi)\n \t    bitmap_set_bit (vi->finished_solution, i);\n \t}\n \n-      aliases = var_ann (smt)->may_aliases;\n+      aliases = MTAG_ALIASES (smt);\n       if (aliases)\n-\t{\n-\t  size_t k;\n-\t  tree al;\n-\t  for (k = 0; VEC_iterate (tree, aliases, k, al); k++)\n-\t    bitmap_set_bit (vi->finished_solution,\n-\t\t\t    DECL_UID (al));\n-\t}\n+        bitmap_ior_into (vi->finished_solution, aliases);\n     }\n }\n "}, {"sha": "6c35fee630830653e5374bd0864d18794c61b32e", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=306219a28de461c81501a32d77d3e0b1cce832c8", "patch": "@@ -380,17 +380,20 @@ verify_flow_insensitive_alias_info (void)\n \n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      size_t j;\n-      var_ann_t ann;\n-      VEC(tree,gc) *may_aliases;\n+      unsigned int j;\n+      bitmap aliases;\n       tree alias;\n+      bitmap_iterator bi;\n \n-      ann = var_ann (var);\n-      may_aliases = ann->may_aliases;\n+      if (!MTAG_P (var) || !MTAG_ALIASES (var))\n+\tcontinue;\n+      \n+      aliases = MTAG_ALIASES (var);\n \n-      for (j = 0; VEC_iterate (tree, may_aliases, j, alias); j++)\n+      EXECUTE_IF_SET_IN_BITMAP (aliases, 0, j, bi)\n \t{\n-\t  bitmap_set_bit (visited, DECL_UID (alias));\n+\t  alias = referenced_var (j);\n+\t  bitmap_set_bit (visited, j);\n \n \t  if (TREE_CODE (alias) != MEMORY_PARTITION_TAG\n \t      && !may_be_aliased (alias))"}, {"sha": "688319cf00807090d5dac540b99562d6337b91f2", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/306219a28de461c81501a32d77d3e0b1cce832c8/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=306219a28de461c81501a32d77d3e0b1cce832c8", "patch": "@@ -2439,10 +2439,14 @@ struct tree_decl_minimal GTY(())\n struct tree_memory_tag GTY(())\n {\n   struct tree_decl_minimal common;\n+\n+  bitmap GTY ((skip)) aliases;\n+\n   unsigned int is_global:1;\n };\n \n #define MTAG_GLOBAL(NODE) (TREE_MEMORY_TAG_CHECK (NODE)->mtag.is_global)\n+#define MTAG_ALIASES(NODE) (TREE_MEMORY_TAG_CHECK (NODE)->mtag.aliases)\n \n struct tree_struct_field_tag GTY(())\n {"}]}