{"sha": "7e854c00d04f2279ac12fe76bcd9d62f0e800223", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U4NTRjMDBkMDRmMjI3OWFjMTJmZTc2YmNkOWQ2MmYwZTgwMDIyMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2005-11-09T23:13:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-11-09T23:13:08Z"}, "message": "tree.c (build_qualified_type): Chain the new type to the original type's TYPE_NEXT_PTR_TO or TYPE_NEXT_REF_TO...\n\n\t* tree.c (build_qualified_type): Chain the new type to the original\n\ttype's TYPE_NEXT_PTR_TO or TYPE_NEXT_REF_TO linked lists if it is\n\ta POINTER_TYPE or a REFERENCE_TYPE respectively.\n\t(build_pointer_type_for_mode): Only return unqualified types.\n\t(build_reference_type_for_mode): Likewise.\n\nFrom-SVN: r106716", "tree": {"sha": "00f17cd91db2a763b171f4ef68a7c278f4adde9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00f17cd91db2a763b171f4ef68a7c278f4adde9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e854c00d04f2279ac12fe76bcd9d62f0e800223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e854c00d04f2279ac12fe76bcd9d62f0e800223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e854c00d04f2279ac12fe76bcd9d62f0e800223", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e854c00d04f2279ac12fe76bcd9d62f0e800223/comments", "author": null, "committer": null, "parents": [{"sha": "378e957760be0bd9d27e6d4121c9ed49b0295138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/378e957760be0bd9d27e6d4121c9ed49b0295138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/378e957760be0bd9d27e6d4121c9ed49b0295138"}], "stats": {"total": 38, "additions": 32, "deletions": 6}, "files": [{"sha": "b3e05f39c125c6509cb8b8f62e9a3a40eff0581a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e854c00d04f2279ac12fe76bcd9d62f0e800223/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e854c00d04f2279ac12fe76bcd9d62f0e800223/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e854c00d04f2279ac12fe76bcd9d62f0e800223", "patch": "@@ -1,3 +1,11 @@\n+2005-11-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree.c (build_qualified_type): Chain the new type to the original\n+\ttype's TYPE_NEXT_PTR_TO or TYPE_NEXT_REF_TO linked lists if it is\n+\ta POINTER_TYPE or a REFERENCE_TYPE respectively.\n+\t(build_pointer_type_for_mode): Only return unqualified types.\n+\t(build_reference_type_for_mode): Likewise.\n+\n 2005-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* Makefile.in (gnucompare): Do comparison of all files using one of"}, {"sha": "4edccd5c2322a8e63c7c7b08d76458b538e2e49a", "filename": "gcc/tree.c", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e854c00d04f2279ac12fe76bcd9d62f0e800223/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e854c00d04f2279ac12fe76bcd9d62f0e800223/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7e854c00d04f2279ac12fe76bcd9d62f0e800223", "patch": "@@ -3702,6 +3702,20 @@ build_qualified_type (tree type, int type_quals)\n     {\n       t = build_variant_type_copy (type);\n       set_type_quals (t, type_quals);\n+\n+      /* If it's a pointer type, the new variant points to the same type.  */\n+      if (TREE_CODE (type) == POINTER_TYPE)\n+\t{\n+\t  TYPE_NEXT_PTR_TO (t) = TYPE_NEXT_PTR_TO (type);\n+\t  TYPE_NEXT_PTR_TO (type) = t;\n+\t}\n+\n+      /* Same for a reference type.  */\n+      else if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t{\n+\t  TYPE_NEXT_REF_TO (t) = TYPE_NEXT_REF_TO (type);\n+\t  TYPE_NEXT_REF_TO (type) = t;\n+\t}\n     }\n \n   return t;\n@@ -4817,10 +4831,12 @@ build_pointer_type_for_mode (tree to_type, enum machine_mode mode,\n       && TREE_CODE (TYPE_POINTER_TO (to_type)) != POINTER_TYPE)\n     return TYPE_POINTER_TO (to_type);\n \n-  /* First, if we already have a type for pointers to TO_TYPE and it's\n-     the proper mode, use it.  */\n+  /* First, if we already have an unqualified type for pointers to TO_TYPE\n+     and it's the proper mode, use it.  */\n   for (t = TYPE_POINTER_TO (to_type); t; t = TYPE_NEXT_PTR_TO (t))\n-    if (TYPE_MODE (t) == mode && TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)\n+    if (TYPE_MODE (t) == mode\n+\t&& !TYPE_QUALS (t)\n+\t&& TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)\n       return t;\n \n   t = make_node (POINTER_TYPE);\n@@ -4866,10 +4882,12 @@ build_reference_type_for_mode (tree to_type, enum machine_mode mode,\n       && TREE_CODE (TYPE_REFERENCE_TO (to_type)) != REFERENCE_TYPE)\n     return TYPE_REFERENCE_TO (to_type);\n \n-  /* First, if we already have a type for pointers to TO_TYPE and it's\n-     the proper mode, use it.  */\n+  /* First, if we already have an unqualified type for references to TO_TYPE\n+     and it's the proper mode, use it.  */\n   for (t = TYPE_REFERENCE_TO (to_type); t; t = TYPE_NEXT_REF_TO (t))\n-    if (TYPE_MODE (t) == mode && TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)\n+    if (TYPE_MODE (t) == mode\n+\t&& !TYPE_QUALS (t)\n+\t&& TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)\n       return t;\n \n   t = make_node (REFERENCE_TYPE);"}]}