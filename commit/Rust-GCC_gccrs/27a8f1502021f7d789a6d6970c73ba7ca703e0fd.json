{"sha": "27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdhOGYxNTAyMDIxZjdkNzg5YTZkNjk3MGM3M2JhN2NhNzAzZTBmZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T10:59:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-10T10:59:13Z"}, "message": "[multiple changes]\n\n2013-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): For Address\n\tattribute, consider it to be set in source, because of aliasing\n\tconsiderations.\n\t(Analyze_Attribute_Definition_Clause): For the\n\tpurpose of warning on overlays, take into account the aspect case.\n\n2013-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cfdlli.ads, a-cfhase.ads, a-cforma.ads, a-cfhama.ads, a-cforse.ads,\n\ta-cofove.ads: Minor reformatting.\n\n2013-10-10  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat_ugn.texi: Remove obsolete mention to -laddr2line.\n\n2013-10-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Case_Expression):  Indicate that the\n\tgenerated variable used as a target of the expression needs\n\tno initialization.\n\n2013-10-10  Jose Ruiz  <ruiz@adacore.com>\n\n\t* exp_util.adb (Corresponding_Runtime_Package): Remove the condition\n\trelated to No_Dynamic_Attachment which was wrong. Protected types\n\twith interrupt handlers (when not using a restricted profile)\n\tare always treated as protected types with entries, regardless\n\tof the No_Dynamic_Attachment restriction.\n\t* exp_ch9.adb (Expand_N_Protected_Type_Declaration): Simplify the code\n\tusing the result of Corresponding_Runtime_Package.\n\t(Install_Private_Data_Declarations): When having\n\tstatic handlers and a non restricted profile, we use the\n\ttype Static_Interrupt_Protection always, so we removed an\n\textra wrong condition looking at the No_Dynamic_Attachment\n\trestriction. Simplify the code using the result of\n\tCorresponding_Runtime_Package.\n\t(Make_Initialize_Protection): Simplify the code using\n\tthe result of Corresponding_Runtime_Package.\n\t(Install_Private_Data_Declaration): The No_Dynamic_Attachment\n\trestriction has nothing to do with static handlers. Remove the extra\n\terroneous condition that was creating the wrong data type.\n\n2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_util.adb (Is_Object_Reference): Attribute\n\t'Old produces an object reference.\n\t* gnat_rm.texi: Define accessibility level of\n\tX'Update(...) result.\n\nFrom-SVN: r203348", "tree": {"sha": "3f2df5a2b7f062b2384a1346730a376b38996e70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f2df5a2b7f062b2384a1346730a376b38996e70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/comments", "author": null, "committer": null, "parents": [{"sha": "2fc07285591a7f3bf9700ea888d287b543f5659c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fc07285591a7f3bf9700ea888d287b543f5659c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fc07285591a7f3bf9700ea888d287b543f5659c"}], "stats": {"total": 334, "additions": 205, "deletions": 129}, "files": [{"sha": "9195cb018c58f2d9ecd7c138bdda8de518d6352c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -1,3 +1,54 @@\n+2013-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): For Address\n+\tattribute, consider it to be set in source, because of aliasing\n+\tconsiderations.\n+\t(Analyze_Attribute_Definition_Clause): For the\n+\tpurpose of warning on overlays, take into account the aspect case.\n+\n+2013-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cfdlli.ads, a-cfhase.ads, a-cforma.ads, a-cfhama.ads, a-cforse.ads,\n+\ta-cofove.ads: Minor reformatting.\n+\n+2013-10-10  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat_ugn.texi: Remove obsolete mention to -laddr2line.\n+\n+2013-10-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Case_Expression):  Indicate that the\n+\tgenerated variable used as a target of the expression needs\n+\tno initialization.\n+\n+2013-10-10  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* exp_util.adb (Corresponding_Runtime_Package): Remove the condition\n+\trelated to No_Dynamic_Attachment which was wrong. Protected types\n+\twith interrupt handlers (when not using a restricted profile)\n+\tare always treated as protected types with entries, regardless\n+\tof the No_Dynamic_Attachment restriction.\n+\t* exp_ch9.adb (Expand_N_Protected_Type_Declaration): Simplify the code\n+\tusing the result of Corresponding_Runtime_Package.\n+\t(Install_Private_Data_Declarations): When having\n+\tstatic handlers and a non restricted profile, we use the\n+\ttype Static_Interrupt_Protection always, so we removed an\n+\textra wrong condition looking at the No_Dynamic_Attachment\n+\trestriction. Simplify the code using the result of\n+\tCorresponding_Runtime_Package.\n+\t(Make_Initialize_Protection): Simplify the code using\n+\tthe result of Corresponding_Runtime_Package.\n+\t(Install_Private_Data_Declaration): The No_Dynamic_Attachment\n+\trestriction has nothing to do with static handlers. Remove the extra\n+\terroneous condition that was creating the wrong data type.\n+\n+2013-10-10  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_util.adb (Is_Object_Reference): Attribute\n+\t'Old produces an object reference.\n+\t* gnat_rm.texi: Define accessibility level of\n+\tX'Update(...) result.\n+\n 2013-10-10  Yannick Moy  <moy@adacore.com>\n \n \t* gnat_rm.texi, a-cfdlli.ads, a-cfhase.ads, a-cforma.ads, a-cfhama.ads,"}, {"sha": "b15b2425e4dc18b49761e097c9b659ddf688990c", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -51,7 +51,7 @@\n --      function Left  (Container : List; Position : Cursor) return List;\n --      function Right (Container : List; Position : Cursor) return List;\n \n---    See subprogram specifications that follow for details.\n+--    See subprogram specifications that follow for details\n \n generic\n    type Element_Type is private;"}, {"sha": "dbfcb82e9dc043bc2ce932449b98864e54c69a03", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -51,7 +51,7 @@\n --      function Left  (Container : Map; Position : Cursor) return Map;\n --      function Right (Container : Map; Position : Cursor) return Map;\n \n---    See detailed specifications for these subprograms.\n+--    See detailed specifications for these subprograms\n \n private with Ada.Containers.Hash_Tables;\n "}, {"sha": "c0103cbe0f44660bb60c145617621bcf35f9765d", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -51,7 +51,7 @@\n --      function Left  (Container : Set; Position : Cursor) return Set;\n --      function Right (Container : Set; Position : Cursor) return Set;\n \n---    See detailed specifications for these subprograms.\n+--    See detailed specifications for these subprograms\n \n private with Ada.Containers.Hash_Tables;\n "}, {"sha": "2ddbd90a1ab720f77b430a1442baed9a861135ac", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -53,7 +53,7 @@\n --      function Left  (Container : Map; Position : Cursor) return Map;\n --      function Right (Container : Map; Position : Cursor) return Map;\n \n---    See detailed specifications for these subprograms.\n+--    See detailed specifications for these subprograms\n \n private with Ada.Containers.Red_Black_Trees;\n "}, {"sha": "1d8cdf6678615ae8a0161f1cdfb57569a71d765b", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -52,7 +52,7 @@\n --      function Left  (Container : Set; Position : Cursor) return Set;\n --      function Right (Container : Set; Position : Cursor) return Set;\n \n---    See detailed specifications for these subprograms.\n+--    See detailed specifications for these subprograms\n \n private with Ada.Containers.Red_Black_Trees;\n "}, {"sha": "604ed8d356b78a19b3bba2889da07a0d0ff29c83", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -50,7 +50,7 @@\n --      function Left  (Container : Vector; Position : Cursor) return Vector;\n --      function Right (Container : Vector; Position : Cursor) return Vector;\n \n---    See detailed specifications for these subprograms.\n+--    See detailed specifications for these subprograms\n \n with Ada.Containers;\n use Ada.Containers;"}, {"sha": "234e206e926548ee71388ac760e5ba6b67e769c8", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -4891,6 +4891,7 @@ package body Exp_Ch4 is\n       Loc     : constant Source_Ptr := Sloc (N);\n       Typ     : constant Entity_Id  := Etype (N);\n       Cstmt   : Node_Id;\n+      Decl    : Node_Id;\n       Tnn     : Entity_Id;\n       Pnn     : Entity_Id;\n       Actions : List_Id;\n@@ -4967,10 +4968,15 @@ package body Exp_Ch4 is\n       end if;\n \n       Tnn := Make_Temporary (Loc, 'T');\n-      Append_To (Actions,\n-        Make_Object_Declaration (Loc,\n+\n+      --  Create declaration for target of expression, and indicate that it\n+      --  does not require initialization.\n+\n+      Decl :=  Make_Object_Declaration (Loc,\n           Defining_Identifier => Tnn,\n-          Object_Definition   => New_Occurrence_Of (Ttyp, Loc)));\n+          Object_Definition   => New_Occurrence_Of (Ttyp, Loc));\n+      Set_No_Initialization (Decl);\n+      Append_To (Actions, Decl);\n \n       --  Now process the alternatives\n "}, {"sha": "6f437923483b787041e13b46314fc1ba808b0ea4", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 107, "deletions": 111, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -8987,8 +8987,6 @@ package body Exp_Ch9 is\n                                      (Prot_Typ, Cdecls, Loc);\n \n          begin\n-            --  Could this be simplified using Corresponding_Runtime_Package???\n-\n             if Has_Attach_Handler (Prot_Typ) then\n                Ritem := First_Rep_Item (Prot_Typ);\n                while Present (Ritem) loop\n@@ -9000,47 +8998,40 @@ package body Exp_Ch9 is\n \n                   Next_Rep_Item (Ritem);\n                end loop;\n+            end if;\n \n-               if Restricted_Profile then\n-                  if Has_Entries (Prot_Typ) then\n-                     Protection_Subtype :=\n-                       New_Reference_To (RTE (RE_Protection_Entry), Loc);\n-                  else\n-                     Protection_Subtype :=\n-                       New_Reference_To (RTE (RE_Protection), Loc);\n-                  end if;\n-\n-               else\n-                  Protection_Subtype :=\n-                    Make_Subtype_Indication (Loc,\n-                       Subtype_Mark =>\n-                         New_Reference_To\n-                           (RTE (RE_Static_Interrupt_Protection), Loc),\n-                       Constraint =>\n-                         Make_Index_Or_Discriminant_Constraint (Loc,\n-                           Constraints => New_List (\n-                             Entry_Count_Expr,\n-                             Make_Integer_Literal (Loc, Num_Attach_Handler))));\n-               end if;\n+            --  Determine the proper protection type. There are two special\n+            --  cases: 1) when the protected type has dynamic interrupt\n+            --  handlers, and 2) when it has static handlers and we use a\n+            --  restricted profile.\n \n-            elsif Has_Interrupt_Handler (Prot_Typ)\n-              and then not Restriction_Active (No_Dynamic_Attachment)\n+            if Has_Attach_Handler (Prot_Typ)\n+              and then not Restricted_Profile\n             then\n                Protection_Subtype :=\n-                  Make_Subtype_Indication (Loc,\n+                 Make_Subtype_Indication (Loc,\n                     Subtype_Mark =>\n                       New_Reference_To\n-                        (RTE (RE_Dynamic_Interrupt_Protection), Loc),\n-                    Constraint   =>\n+                        (RTE (RE_Static_Interrupt_Protection), Loc),\n+                    Constraint =>\n                       Make_Index_Or_Discriminant_Constraint (Loc,\n-                        Constraints => New_List (Entry_Count_Expr)));\n-\n-            --  Type has explicit entries or generated primitive entry wrappers\n+                        Constraints => New_List (\n+                          Entry_Count_Expr,\n+                          Make_Integer_Literal (Loc, Num_Attach_Handler))));\n \n-            elsif Has_Entries (Prot_Typ)\n-              or else (Ada_Version >= Ada_2005\n-                        and then Present (Interface_List (N)))\n+            elsif Has_Interrupt_Handler (Prot_Typ)\n+              and then not Restriction_Active (No_Dynamic_Attachment)\n             then\n+               Protection_Subtype :=\n+                 Make_Subtype_Indication (Loc,\n+                 Subtype_Mark =>\n+                   New_Reference_To\n+                     (RTE (RE_Dynamic_Interrupt_Protection), Loc),\n+                 Constraint   =>\n+                   Make_Index_Or_Discriminant_Constraint (Loc,\n+                     Constraints => New_List (Entry_Count_Expr)));\n+\n+            else\n                case Corresponding_Runtime_Package (Prot_Typ) is\n                   when System_Tasking_Protected_Objects_Entries =>\n                      Protection_Subtype :=\n@@ -9056,13 +9047,13 @@ package body Exp_Ch9 is\n                      Protection_Subtype :=\n                        New_Reference_To (RTE (RE_Protection_Entry), Loc);\n \n+                  when System_Tasking_Protected_Objects =>\n+                     Protection_Subtype :=\n+                       New_Reference_To (RTE (RE_Protection), Loc);\n+\n                   when others =>\n                      raise Program_Error;\n                end case;\n-\n-            else\n-               Protection_Subtype :=\n-                 New_Reference_To (RTE (RE_Protection), Loc);\n             end if;\n \n             Object_Comp :=\n@@ -13095,7 +13086,6 @@ package body Exp_Ch9 is\n \n             if Has_Attach_Handler (Conc_Typ)\n               and then not Restricted_Profile\n-              and then not Restriction_Active (No_Dynamic_Attachment)\n             then\n                Prot_Typ := RE_Static_Interrupt_Protection;\n \n@@ -13104,27 +13094,20 @@ package body Exp_Ch9 is\n             then\n                Prot_Typ := RE_Dynamic_Interrupt_Protection;\n \n-            --  The type has explicit entries or generated primitive entry\n-            --  wrappers.\n-\n-            elsif Has_Entries (Conc_Typ)\n-              or else\n-                (Ada_Version >= Ada_2005\n-                  and then Present (Interface_List (Parent (Conc_Typ))))\n-            then\n+            else\n                case Corresponding_Runtime_Package (Conc_Typ) is\n                   when System_Tasking_Protected_Objects_Entries =>\n                      Prot_Typ := RE_Protection_Entries;\n \n                   when System_Tasking_Protected_Objects_Single_Entry =>\n                      Prot_Typ := RE_Protection_Entry;\n \n+                  when System_Tasking_Protected_Objects =>\n+                     Prot_Typ := RE_Protection;\n+\n                   when others =>\n                      raise Program_Error;\n                end case;\n-\n-            else\n-               Prot_Typ := RE_Protection;\n             end if;\n \n             --  Generate:\n@@ -13659,91 +13642,104 @@ package body Exp_Ch9 is\n          --  considered equivalent to a protected type with entries in the\n          --  context of dispatching select statements.\n \n-         if Has_Entry\n-           or else Has_Interfaces (Protect_Rec)\n-           or else\n-             ((Has_Attach_Handler (Ptyp) or else Has_Interrupt_Handler (Ptyp))\n-                and then not Restriction_Active (No_Dynamic_Attachment))\n-         then\n-            declare\n-               Pkg_Id : constant RTU_Id  :=\n-                          Corresponding_Runtime_Package (Ptyp);\n-\n-               Called_Subp : RE_Id;\n-\n-            begin\n-               case Pkg_Id is\n-                  when System_Tasking_Protected_Objects_Entries =>\n-                     Called_Subp := RE_Initialize_Protection_Entries;\n+         --  Protected types with interrupt handlers (when not using a\n+         --  restricted profile) are also considered equivalent to protected\n+         --  types with entries. The types which are used\n+         --  (Static_Interrupt_Protection and Dynamic_Interrupt_Protection)\n+         --  are derived from Protection_Entries.\n \n-                  when System_Tasking_Protected_Objects =>\n-                     Called_Subp := RE_Initialize_Protection;\n+         declare\n+            Pkg_Id : constant RTU_Id := Corresponding_Runtime_Package (Ptyp);\n+            Called_Subp : RE_Id;\n \n-                  when System_Tasking_Protected_Objects_Single_Entry =>\n-                     Called_Subp := RE_Initialize_Protection_Entry;\n+         begin\n+            case Pkg_Id is\n+               when System_Tasking_Protected_Objects_Entries =>\n+                  Called_Subp := RE_Initialize_Protection_Entries;\n \n-                  when others =>\n-                     raise Program_Error;\n-               end case;\n+                  --  Argument Compiler_Info\n \n-               if Has_Entry\n-                 or else not Restricted\n-                 or else Has_Interfaces (Protect_Rec)\n-               then\n                   Append_To (Args,\n                     Make_Attribute_Reference (Loc,\n                       Prefix         => Make_Identifier (Loc, Name_uInit),\n                       Attribute_Name => Name_Address));\n-               end if;\n \n-               --  Entry_Bodies parameter. This is a pointer to an array of\n-               --  pointers to the entry body procedures and barrier functions\n-               --  of the object. If the protected type has no entries this\n-               --  object will not exist, in this case, pass a null.\n+               when System_Tasking_Protected_Objects_Single_Entry =>\n+                  Called_Subp := RE_Initialize_Protection_Entry;\n \n-               if Has_Entry then\n-                  P_Arr := Entry_Bodies_Array (Ptyp);\n+                  --  Argument Compiler_Info\n \n                   Append_To (Args,\n                     Make_Attribute_Reference (Loc,\n-                      Prefix => New_Reference_To (P_Arr, Loc),\n-                      Attribute_Name => Name_Unrestricted_Access));\n+                      Prefix         => Make_Identifier (Loc, Name_uInit),\n+                      Attribute_Name => Name_Address));\n \n-                  if Pkg_Id = System_Tasking_Protected_Objects_Entries then\n+               when System_Tasking_Protected_Objects =>\n+                  Called_Subp := RE_Initialize_Protection;\n \n-                     --  Find index mapping function (clumsy but ok for now)\n+               when others =>\n+                     raise Program_Error;\n+            end case;\n \n-                     while Ekind (P_Arr) /= E_Function loop\n-                        Next_Entity (P_Arr);\n-                     end loop;\n+            --  Entry_Bodies parameter. This is a pointer to an array of\n+            --  pointers to the entry body procedures and barrier functions of\n+            --  the object. If the protected type has no entries this object\n+            --  will not exist, in this case, pass a null (it can happen when\n+            --  there are protected interrupt handlers or interfaces).\n \n-                     Append_To (Args,\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix         => New_Reference_To (P_Arr, Loc),\n-                         Attribute_Name => Name_Unrestricted_Access));\n-                  end if;\n+            if Has_Entry then\n+               P_Arr := Entry_Bodies_Array (Ptyp);\n \n-               elsif Pkg_Id =\n-                       System_Tasking_Protected_Objects_Single_Entry\n-               then\n-                  Append_To (Args, Make_Null (Loc));\n+               --  Argument Entry_Body (for single entry) or Entry_Bodies (for\n+               --  multiple entries).\n+\n+               Append_To (Args,\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix => New_Reference_To (P_Arr, Loc),\n+                            Attribute_Name => Name_Unrestricted_Access));\n+\n+               if Pkg_Id = System_Tasking_Protected_Objects_Entries then\n \n-               elsif Pkg_Id = System_Tasking_Protected_Objects_Entries then\n-                  Append_To (Args, Make_Null (Loc));\n-                  Append_To (Args, Make_Null (Loc));\n+                  --  Find index mapping function (clumsy but ok for now)\n+\n+                  while Ekind (P_Arr) /= E_Function loop\n+                     Next_Entity (P_Arr);\n+                  end loop;\n+\n+                  Append_To (Args,\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Reference_To (P_Arr, Loc),\n+                      Attribute_Name => Name_Unrestricted_Access));\n                end if;\n \n-               Append_To (L,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Reference_To (RTE (Called_Subp), Loc),\n-                   Parameter_Associations => Args));\n-            end;\n-         else\n+            elsif Pkg_Id = System_Tasking_Protected_Objects_Single_Entry then\n+               --  This is the case where we have a protected object with\n+               --  interfaces and no entries, and the single entry restriction\n+               --  is in effect. We pass a null pointer for the entry\n+               --  parameter because there is no actual entry.\n+\n+               Append_To (Args, Make_Null (Loc));\n+\n+            elsif Pkg_Id = System_Tasking_Protected_Objects_Entries then\n+               --  This is the case where we have a protected object with no\n+               --  entries and:\n+               --    - either interrupt handlers with non restricted profile,\n+               --    - or interfaces\n+               --  Note that the types which are used for interrupt handlers\n+               --  (Static/Dynamic_Interrupt_Protection) are derived from\n+               --  Protection_Entries. We pass two null pointers because there\n+               --  is no actual entry, and the initialization procedure needs\n+               --  both Entry_Bodies and Find_Body_Index.\n+\n+               Append_To (Args, Make_Null (Loc));\n+               Append_To (Args, Make_Null (Loc));\n+            end if;\n+\n             Append_To (L,\n               Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (RTE (RE_Initialize_Protection), Loc),\n+                Name => New_Reference_To (RTE (Called_Subp), Loc),\n                 Parameter_Associations => Args));\n-         end if;\n+         end;\n       end if;\n \n       if Has_Attach_Handler (Ptyp) then"}, {"sha": "795aaf417ad499238bfee90e7460558ee1448102", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -1631,10 +1631,15 @@ package body Exp_Util is\n             --  node to recognize this case.\n \n            or else Present (Interface_List (Parent (Typ)))\n-           or else\n-             (((Has_Attach_Handler (Typ) and then not Restricted_Profile)\n-                 or else Has_Interrupt_Handler (Typ))\n-               and then not Restriction_Active (No_Dynamic_Attachment))\n+\n+            --  Protected types with interrupt handlers (when not using a\n+            --  restricted profile) are also considered equivalent to\n+            --  protected types with entries. The types which are used\n+            --  (Static_Interrupt_Protection and Dynamic_Interrupt_Protection)\n+            --  are derived from Protection_Entries.\n+\n+           or else (Has_Attach_Handler (Typ) and then not Restricted_Profile)\n+           or else Has_Interrupt_Handler (Typ)\n          then\n             if Abort_Allowed\n               or else Restriction_Active (No_Entry_Queue) = False"}, {"sha": "3c46f641adc8441e24c8df2658963574e4bc5bc2", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -8829,6 +8829,8 @@ kept in mind when considering efficiency.\n \n The @code{Update} attribute cannot be applied to prefixes of a limited\n type, and cannot reference discriminants in the case of a record type.\n+The accessibility level of an Update attribute result object is defined\n+as for an aggregate.\n \n In the record case, no component can be mentioned more than once. In\n the array case, two overlapping ranges can appear in the aggregate,"}, {"sha": "49065727c0ffd90161d5bb89907f03e778bad223", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -21738,7 +21738,7 @@ end STB;\n @end smallexample\n \n @smallexample\n-$ gnatmake -g .\\stb -bargs -E -largs -lgnat -laddr2line -lintl\n+$ gnatmake -g .\\stb -bargs -E\n $ stb\n \n 0040149F in stb.p1 at stb.adb:8"}, {"sha": "f9e23f7dd87cdd8ca41b4eb2f14bd5cf53213493", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -1593,6 +1593,18 @@ package body Sem_Ch13 is\n                      goto Continue;\n                   end if;\n \n+                  --  For case of address aspect, we don't consider that we\n+                  --  know the entity is never set in the source, since it is\n+                  --  is likely aliasing is occurring.\n+\n+                  --  Note: one might think that the analysis of the resulting\n+                  --  attribute definition clause would take care of that, but\n+                  --  that's not the case since it won't be from source.\n+\n+                  if A_Id = Aspect_Address then\n+                     Set_Never_Set_In_Source (E, False);\n+                  end if;\n+\n                   --  Construct the attribute definition clause\n \n                   Aitem :=\n@@ -3474,15 +3486,17 @@ package body Sem_Ch13 is\n                   --  and alignment of the overlaying variable. We defer this\n                   --  check till after code generation to take full advantage\n                   --  of the annotation done by the back end. This entry is\n-                  --  only made if the address clause comes from source.\n+                  --  only made if the address clause comes from source or\n+                  --  from an aspect clause (which is still from source).\n \n                   --  If the entity has a generic type, the check will be\n                   --  performed in the instance if the actual type justifies\n                   --  it, and we do not insert the clause in the table to\n                   --  prevent spurious warnings.\n \n                   if Address_Clause_Overlay_Warnings\n-                    and then Comes_From_Source (N)\n+                       and then (Comes_From_Source (N)\n+                                  or else From_Aspect_Specification (N))\n                     and then Present (O_Ent)\n                     and then Is_Object (O_Ent)\n                   then"}, {"sha": "db09d05de27c4c0ff833d81f3bd88fe7d808de4b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27a8f1502021f7d789a6d6970c73ba7ca703e0fd/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=27a8f1502021f7d789a6d6970c73ba7ca703e0fd", "patch": "@@ -8863,10 +8863,12 @@ package body Sem_Util is\n             when N_Function_Call =>\n                return Etype (N) /= Standard_Void_Type;\n \n-            --  Attributes 'Input and 'Result produce objects\n+            --  Attributes 'Input, 'Old and 'Result produce objects\n \n             when N_Attribute_Reference =>\n-               return Nam_In (Attribute_Name (N), Name_Input, Name_Result);\n+               return\n+                 Nam_In\n+                   (Attribute_Name (N), Name_Input, Name_Old, Name_Result);\n \n             when N_Selected_Component =>\n                return"}]}