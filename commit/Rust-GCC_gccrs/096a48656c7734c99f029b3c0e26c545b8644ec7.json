{"sha": "096a48656c7734c99f029b3c0e26c545b8644ec7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk2YTQ4NjU2Yzc3MzRjOTlmMDI5YjNjMGUyNmM1NDViODY0NGVjNw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2013-09-04T23:52:48Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-09-04T23:52:48Z"}, "message": "re PR c++/24926 (gcc ignores access level violation for anonymous structs)\n\n/cp\n2013-09-04  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/24926\n\t* class.c (finish_struct_anon_r): New.\n\t(finish_struct_anon): Use it.\n\n/testsuite\n2013-09-04  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/24926\n\t* g++.dg/parse/access11.C: New.\n\nFrom-SVN: r202266", "tree": {"sha": "570076f0b7a08c8f4adb498a312cf967f8a21b35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/570076f0b7a08c8f4adb498a312cf967f8a21b35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/096a48656c7734c99f029b3c0e26c545b8644ec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096a48656c7734c99f029b3c0e26c545b8644ec7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/096a48656c7734c99f029b3c0e26c545b8644ec7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096a48656c7734c99f029b3c0e26c545b8644ec7/comments", "author": null, "committer": null, "parents": [{"sha": "c167bc5b7d51a6d582324040201106fab36723da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c167bc5b7d51a6d582324040201106fab36723da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c167bc5b7d51a6d582324040201106fab36723da"}], "stats": {"total": 178, "additions": 128, "deletions": 50}, "files": [{"sha": "be8258dcf3ec1fe685663d369601d99148bd11bf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/096a48656c7734c99f029b3c0e26c545b8644ec7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/096a48656c7734c99f029b3c0e26c545b8644ec7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=096a48656c7734c99f029b3c0e26c545b8644ec7", "patch": "@@ -1,3 +1,9 @@\n+2013-09-04  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/24926\n+\t* class.c (finish_struct_anon_r): New.\n+\t(finish_struct_anon): Use it.\n+\n 2013-09-04  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* cxx-pretty-print.h (cxx_pretty_printer::simple_type_specifier):"}, {"sha": "3d34b92cfb1b22ecc5cc4da5e34f775bd54a3fce", "filename": "gcc/cp/class.c", "status": "modified", "additions": 82, "deletions": 50, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/096a48656c7734c99f029b3c0e26c545b8644ec7/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/096a48656c7734c99f029b3c0e26c545b8644ec7/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=096a48656c7734c99f029b3c0e26c545b8644ec7", "patch": "@@ -2773,15 +2773,93 @@ warn_hidden (tree t)\n     }\n }\n \n+/* Recursive helper for finish_struct_anon.  */\n+\n+static void\n+finish_struct_anon_r (tree field, bool complain)\n+{\n+  bool is_union = TREE_CODE (TREE_TYPE (field)) == UNION_TYPE;\n+  tree elt = TYPE_FIELDS (TREE_TYPE (field));\n+  for (; elt; elt = DECL_CHAIN (elt))\n+    {\n+      /* We're generally only interested in entities the user\n+\t declared, but we also find nested classes by noticing\n+\t the TYPE_DECL that we create implicitly.  You're\n+\t allowed to put one anonymous union inside another,\n+\t though, so we explicitly tolerate that.  We use\n+\t TYPE_ANONYMOUS_P rather than ANON_AGGR_TYPE_P so that\n+\t we also allow unnamed types used for defining fields.  */\n+      if (DECL_ARTIFICIAL (elt)\n+\t  && (!DECL_IMPLICIT_TYPEDEF_P (elt)\n+\t      || TYPE_ANONYMOUS_P (TREE_TYPE (elt))))\n+\tcontinue;\n+\n+      if (TREE_CODE (elt) != FIELD_DECL)\n+\t{\n+\t  if (complain)\n+\t    {\n+\t      if (is_union)\n+\t\tpermerror (input_location,\n+\t\t\t   \"%q+#D invalid; an anonymous union can \"\n+\t\t\t   \"only have non-static data members\", elt);\n+\t      else\n+\t\tpermerror (input_location,\n+\t\t\t   \"%q+#D invalid; an anonymous struct can \"\n+\t\t\t   \"only have non-static data members\", elt);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      if (complain)\n+\t{\n+\t  if (TREE_PRIVATE (elt))\n+\t    {\n+\t      if (is_union)\n+\t\tpermerror (input_location,\n+\t\t\t   \"private member %q+#D in anonymous union\", elt);\n+\t      else\n+\t\tpermerror (input_location,\n+\t\t\t   \"private member %q+#D in anonymous struct\", elt);\n+\t    }\n+\t  else if (TREE_PROTECTED (elt))\n+\t    {\n+\t      if (is_union)\n+\t\tpermerror (input_location,\n+\t\t\t   \"protected member %q+#D in anonymous union\", elt);\n+\t      else\n+\t\tpermerror (input_location,\n+\t\t\t   \"protected member %q+#D in anonymous struct\", elt);\n+\t    }\n+\t}\n+\n+      TREE_PRIVATE (elt) = TREE_PRIVATE (field);\n+      TREE_PROTECTED (elt) = TREE_PROTECTED (field);\n+\n+      /* Recurse into the anonymous aggregates to handle correctly\n+\t access control (c++/24926):\n+\n+\t class A {\n+\t   union {\n+\t     union {\n+\t       int i;\n+\t     };\n+\t   };\n+\t };\n+\n+\t int j=A().i;  */\n+      if (DECL_NAME (elt) == NULL_TREE\n+\t  && ANON_AGGR_TYPE_P (TREE_TYPE (elt)))\n+\tfinish_struct_anon_r (elt, /*complain=*/false);\n+    }\n+}\n+\n /* Check for things that are invalid.  There are probably plenty of other\n    things we should check for also.  */\n \n static void\n finish_struct_anon (tree t)\n {\n-  tree field;\n-\n-  for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n+  for (tree field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n     {\n       if (TREE_STATIC (field))\n \tcontinue;\n@@ -2790,53 +2868,7 @@ finish_struct_anon (tree t)\n \n       if (DECL_NAME (field) == NULL_TREE\n \t  && ANON_AGGR_TYPE_P (TREE_TYPE (field)))\n-\t{\n-\t  bool is_union = TREE_CODE (TREE_TYPE (field)) == UNION_TYPE;\n-\t  tree elt = TYPE_FIELDS (TREE_TYPE (field));\n-\t  for (; elt; elt = DECL_CHAIN (elt))\n-\t    {\n-\t      /* We're generally only interested in entities the user\n-\t\t declared, but we also find nested classes by noticing\n-\t\t the TYPE_DECL that we create implicitly.  You're\n-\t\t allowed to put one anonymous union inside another,\n-\t\t though, so we explicitly tolerate that.  We use\n-\t\t TYPE_ANONYMOUS_P rather than ANON_AGGR_TYPE_P so that\n-\t\t we also allow unnamed types used for defining fields.  */\n-\t      if (DECL_ARTIFICIAL (elt)\n-\t\t  && (!DECL_IMPLICIT_TYPEDEF_P (elt)\n-\t\t      || TYPE_ANONYMOUS_P (TREE_TYPE (elt))))\n-\t\tcontinue;\n-\n-\t      if (TREE_CODE (elt) != FIELD_DECL)\n-\t\t{\n-\t\t  if (is_union)\n-\t\t    permerror (input_location, \"%q+#D invalid; an anonymous union can \"\n-\t\t\t       \"only have non-static data members\", elt);\n-\t\t  else\n-\t\t    permerror (input_location, \"%q+#D invalid; an anonymous struct can \"\n-\t\t\t       \"only have non-static data members\", elt);\n-\t\t  continue;\n-\t\t}\n-\n-\t      if (TREE_PRIVATE (elt))\n-\t\t{\n-\t\t  if (is_union)\n-\t\t    permerror (input_location, \"private member %q+#D in anonymous union\", elt);\n-\t\t  else\n-\t\t    permerror (input_location, \"private member %q+#D in anonymous struct\", elt);\n-\t\t}\n-\t      else if (TREE_PROTECTED (elt))\n-\t\t{\n-\t\t  if (is_union)\n-\t\t    permerror (input_location, \"protected member %q+#D in anonymous union\", elt);\n-\t\t  else\n-\t\t    permerror (input_location, \"protected member %q+#D in anonymous struct\", elt);\n-\t\t}\n-\n-\t      TREE_PRIVATE (elt) = TREE_PRIVATE (field);\n-\t      TREE_PROTECTED (elt) = TREE_PROTECTED (field);\n-\t    }\n-\t}\n+\tfinish_struct_anon_r (field, /*complain=*/true);\n     }\n }\n "}, {"sha": "176d9973f6ce8f8da68bcf1c74dede3ce15f9b6f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/096a48656c7734c99f029b3c0e26c545b8644ec7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/096a48656c7734c99f029b3c0e26c545b8644ec7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=096a48656c7734c99f029b3c0e26c545b8644ec7", "patch": "@@ -1,3 +1,8 @@\n+2013-09-04  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/24926\n+\t* g++.dg/parse/access11.C: New.\n+\n 2013-09-04  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* g++.dg/warn/weak1.C: Skip on AIX."}, {"sha": "7004fa76401c9a4cd71d00efd0028278fa55bef0", "filename": "gcc/testsuite/g++.dg/parse/access11.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/096a48656c7734c99f029b3c0e26c545b8644ec7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/096a48656c7734c99f029b3c0e26c545b8644ec7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess11.C?ref=096a48656c7734c99f029b3c0e26c545b8644ec7", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/24926\n+\n+class A {\n+  union {\n+    int i;       // { dg-error \"private\" }\n+  };\n+  union {\n+    int j;       // { dg-error \"private\" }\n+  }; \n+  union {\n+    union {\n+      int k;     // { dg-error \"private\" }\n+    };\n+    union {\n+      union {\n+\tint l;   // { dg-error \"private\" }\n+      };\n+      union {\n+\tint m;   // { dg-error \"private\" }\n+\tunion {\n+\t  int n; // { dg-error \"private\" }\n+\t  int o; // { dg-error \"private\" }\n+\t};\n+      };\n+    };\n+  };\n+};\n+\n+int a1 = A().i;  // { dg-error \"context\" }\n+int a2 = A().j;  // { dg-error \"context\" }\n+int a3 = A().k;  // { dg-error \"context\" }\n+int a4 = A().l;  // { dg-error \"context\" }\n+int a5 = A().m;  // { dg-error \"context\" }\n+int a6 = A().n;  // { dg-error \"context\" }\n+int a7 = A().o;  // { dg-error \"context\" }"}]}