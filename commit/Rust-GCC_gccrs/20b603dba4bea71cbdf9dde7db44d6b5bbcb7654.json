{"sha": "20b603dba4bea71cbdf9dde7db44d6b5bbcb7654", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBiNjAzZGJhNGJlYTcxY2JkZjlkZGU3ZGI0NGQ2YjViYmNiNzY1NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-19T04:53:51Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-19T04:53:51Z"}, "message": "compiler: stack allocate a buffer for non-escaping string ops\n    \n    For string concatenation, string to/from byte or rune slice\n    conversion, and int to string conversion, if the result does not\n    escape, we can allocate a small (32-element, or 4-byte for int to\n    string) buffer on stack, and pass it to the runtime function. If\n    the result fits in the buffer, it doesn't need to do a heap\n    allocation.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/182538\n\nFrom-SVN: r272468", "tree": {"sha": "94c81c934c43d4b35ea3289daae6945a9a07b296", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94c81c934c43d4b35ea3289daae6945a9a07b296"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654/comments", "author": null, "committer": null, "parents": [{"sha": "17f62b7e1fef0a04c738419b0108eeb89f6b7463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f62b7e1fef0a04c738419b0108eeb89f6b7463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17f62b7e1fef0a04c738419b0108eeb89f6b7463"}], "stats": {"total": 119, "additions": 101, "deletions": 18}, "files": [{"sha": "e62501f4dfb4d2f243d37a83ee58aac3b1888a22", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=20b603dba4bea71cbdf9dde7db44d6b5bbcb7654", "patch": "@@ -1,4 +1,4 @@\n-62d1b667f3e85f72a186b04aad36d701160a4611\n+0e4aa31b26a20b6a6a2ca102b85ba8c8b8cdf876\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "766864a535dfd6ae76fe4bc4aff556ebb6edda16", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 85, "deletions": 13, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=20b603dba4bea71cbdf9dde7db44d6b5bbcb7654", "patch": "@@ -3739,8 +3739,11 @@ Type_conversion_expression::do_flatten(Gogo*, Named_object*,\n       this->expr_ = Expression::make_temporary_reference(temp, this->location());\n     }\n \n-  // For interface conversion, decide if we can allocate on stack.\n-  if (this->type()->interface_type() != NULL)\n+  // For interface conversion and string to/from slice conversions,\n+  // decide if we can allocate on stack.\n+  if (this->type()->interface_type() != NULL\n+      || this->type()->is_string_type()\n+      || this->expr_->type()->is_string_type())\n     {\n       Node* n = Node::make_node(this);\n       if ((n->encoding() & ESCAPE_MASK) == Node::ESCAPE_NONE)\n@@ -3984,9 +3987,21 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n \t  return se->get_backend(context);\n \t}\n \n+      Expression* buf;\n+      if (this->no_escape_)\n+        {\n+          Type* byte_type = Type::lookup_integer_type(\"uint8\");\n+          Expression* buflen =\n+            Expression::make_integer_ul(4, NULL, loc);\n+          Type* array_type = Type::make_array_type(byte_type, buflen);\n+          buf = Expression::make_allocation(array_type, loc);\n+          buf->allocation_expression()->set_allocate_on_stack();\n+          buf->allocation_expression()->set_no_zero();\n+        }\n+      else\n+        buf = Expression::make_nil(loc);\n       Expression* i2s_expr =\n-          Runtime::make_call(Runtime::INTSTRING, loc, 2,\n-\t\t\t     Expression::make_nil(loc), this->expr_);\n+        Runtime::make_call(Runtime::INTSTRING, loc, 2, buf, this->expr_);\n       return Expression::make_cast(type, i2s_expr, loc)->get_backend(context);\n     }\n   else if (type->is_string_type() && expr_type->is_slice_type())\n@@ -4019,7 +4034,21 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n           go_assert(e->integer_type()->is_rune());\n           code = Runtime::SLICERUNETOSTRING;\n         }\n-      return Runtime::make_call(code, loc, 2, Expression::make_nil(loc),\n+\n+      Expression* buf;\n+      if (this->no_escape_)\n+        {\n+          Type* byte_type = Type::lookup_integer_type(\"uint8\");\n+          Expression* buflen =\n+            Expression::make_integer_ul(tmp_string_buf_size, NULL, loc);\n+          Type* array_type = Type::make_array_type(byte_type, buflen);\n+          buf = Expression::make_allocation(array_type, loc);\n+          buf->allocation_expression()->set_allocate_on_stack();\n+          buf->allocation_expression()->set_no_zero();\n+        }\n+      else\n+        buf = Expression::make_nil(loc);\n+      return Runtime::make_call(code, loc, 2, buf,\n \t\t\t\tthis->expr_)->get_backend(context);\n     }\n   else if (type->is_slice_type() && expr_type->is_string_type())\n@@ -4035,9 +4064,20 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n \t  go_assert(e->integer_type()->is_rune());\n \t  code = Runtime::STRINGTOSLICERUNE;\n \t}\n-      Expression* s2a = Runtime::make_call(code, loc, 2,\n-\t\t\t\t\t   Expression::make_nil(loc),\n-\t\t\t\t\t   this->expr_);\n+\n+      Expression* buf;\n+      if (this->no_escape_)\n+        {\n+          Expression* buflen =\n+            Expression::make_integer_ul(tmp_string_buf_size, NULL, loc);\n+          Type* array_type = Type::make_array_type(e, buflen);\n+          buf = Expression::make_allocation(array_type, loc);\n+          buf->allocation_expression()->set_allocate_on_stack();\n+          buf->allocation_expression()->set_no_zero();\n+        }\n+      else\n+        buf = Expression::make_nil(loc);\n+      Expression* s2a = Runtime::make_call(code, loc, 2, buf, this->expr_);\n       return Expression::make_unsafe_cast(type, s2a, loc)->get_backend(context);\n     }\n   else if (type->is_numeric_type())\n@@ -7428,7 +7468,35 @@ String_concat_expression::do_flatten(Gogo*, Named_object*,\n         tce->set_no_copy(true);\n     }\n \n-  Expression* nil_arg = Expression::make_nil(loc);\n+  Expression* buf = NULL;\n+  Node* n = Node::make_node(this);\n+  if ((n->encoding() & ESCAPE_MASK) == Node::ESCAPE_NONE)\n+    {\n+      size_t size = 0;\n+      for (Expression_list::iterator p = this->exprs_->begin();\n+           p != this->exprs_->end();\n+           ++p)\n+        {\n+          std::string s;\n+          if ((*p)->string_constant_value(&s))\n+            size += s.length();\n+        }\n+      // Make a buffer on stack if the result does not escape.\n+      // But don't do this if we know it won't fit.\n+      if (size < (size_t)tmp_string_buf_size)\n+        {\n+          Type* byte_type = Type::lookup_integer_type(\"uint8\");\n+          Expression* buflen =\n+            Expression::make_integer_ul(tmp_string_buf_size, NULL, loc);\n+          Expression::make_integer_ul(tmp_string_buf_size, NULL, loc);\n+          Type* array_type = Type::make_array_type(byte_type, buflen);\n+          buf = Expression::make_allocation(array_type, loc);\n+          buf->allocation_expression()->set_allocate_on_stack();\n+          buf->allocation_expression()->set_no_zero();\n+        }\n+    }\n+  if (buf == NULL)\n+    buf = Expression::make_nil(loc);\n   Expression* call;\n   switch (this->exprs_->size())\n     {\n@@ -7462,7 +7530,7 @@ String_concat_expression::do_flatten(Gogo*, Named_object*,\n \t    code = Runtime::CONCATSTRING5;\n \t    break;\n \t  }\n-\tcall = Runtime::make_call(code, loc, 2, nil_arg, arg);\n+\tcall = Runtime::make_call(code, loc, 2, buf, arg);\n       }\n       break;\n \n@@ -7473,7 +7541,7 @@ String_concat_expression::do_flatten(Gogo*, Named_object*,\n \t  Expression::make_slice_composite_literal(arg_type, this->exprs_,\n \t\t\t\t\t\t   loc);\n \tsce->set_storage_does_not_escape();\n-\tcall = Runtime::make_call(Runtime::CONCATSTRINGS, loc, 2, nil_arg,\n+\tcall = Runtime::make_call(Runtime::CONCATSTRINGS, loc, 2, buf,\n \t\t\t\t  sce);\n       }\n       break;\n@@ -14254,6 +14322,8 @@ Allocation_expression::do_copy()\n \t\t\t      this->location());\n   if (this->allocate_on_stack_)\n     alloc->set_allocate_on_stack();\n+  if (this->no_zero_)\n+    alloc->set_no_zero();\n   return alloc;\n }\n \n@@ -14279,10 +14349,12 @@ Allocation_expression::do_get_backend(Translate_context* context)\n       Named_object* fn = context->function();\n       go_assert(fn != NULL);\n       Bfunction* fndecl = fn->func_value()->get_or_make_decl(gogo, fn);\n-      Bexpression* zero = gogo->backend()->zero_expression(btype);\n+      Bexpression* init = (this->no_zero_\n+                           ? NULL\n+                           : gogo->backend()->zero_expression(btype));\n       Bvariable* temp =\n         gogo->backend()->temporary_variable(fndecl, context->bblock(), btype,\n-                                            zero, true, loc, &decl);\n+                                            init, true, loc, &decl);\n       Bexpression* ret = gogo->backend()->var_expression(temp, loc);\n       ret = gogo->backend()->address_expression(ret, loc);\n       ret = gogo->backend()->compound_expression(decl, ret, loc);"}, {"sha": "38dee04ca973e055a83e6838f1891fb0701229da", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=20b603dba4bea71cbdf9dde7db44d6b5bbcb7654", "patch": "@@ -1822,9 +1822,8 @@ class Type_conversion_expression : public Expression\n   // True if a string([]byte) conversion can reuse the backing store\n   // without copying.  Only used in string([]byte) conversion.\n   bool no_copy_;\n-  // True if a conversion to interface does not escape, so it does\n-  // not need a heap allocation.  Only used in type-to-interface\n-  // conversion.\n+  // True if a conversion does not escape.  Used in type-to-interface\n+  // conversions and slice-to/from-string conversions.\n   bool no_escape_;\n };\n \n@@ -3561,13 +3560,19 @@ class Allocation_expression : public Expression\n  public:\n   Allocation_expression(Type* type, Location location)\n     : Expression(EXPRESSION_ALLOCATION, location),\n-      type_(type), allocate_on_stack_(false)\n+      type_(type), allocate_on_stack_(false),\n+      no_zero_(false)\n   { }\n \n   void\n   set_allocate_on_stack()\n   { this->allocate_on_stack_ = true; }\n \n+  // Mark that the allocated memory doesn't need zeroing.\n+  void\n+  set_no_zero()\n+  { this->no_zero_ = true; }\n+\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -3596,6 +3601,8 @@ class Allocation_expression : public Expression\n   Type* type_;\n   // Whether or not this is a stack allocation.\n   bool allocate_on_stack_;\n+  // Whether we don't need to zero the allocated memory.\n+  bool no_zero_;\n };\n \n // A general composite literal.  This is lowered to a type specific\n@@ -4541,4 +4548,8 @@ class Numeric_constant\n   Type* type_;\n };\n \n+// Temporary buffer size for string conversions.\n+// Also known to the runtime as tmpStringBufSize in runtime/string.go.\n+static const int tmp_string_buf_size = 32;\n+\n #endif // !defined(GO_EXPRESSIONS_H)"}]}