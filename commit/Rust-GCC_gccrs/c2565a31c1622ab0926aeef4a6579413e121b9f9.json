{"sha": "c2565a31c1622ab0926aeef4a6579413e121b9f9", "node_id": "C_kwDOANBUbNoAKGMyNTY1YTMxYzE2MjJhYjA5MjZhZWVmNGE2NTc5NDEzZTEyMWI5Zjk", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-14T07:37:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-10-14T07:37:01Z"}, "message": "middle-end, c++, i386, libgcc: std::bfloat16_t and __bf16 arithmetic support\n\nHere is a complete patch to add std::bfloat16_t support on\nx86 (AArch64 and ARM left for later).  Almost no BFmode optabs\nare added by the patch, so for binops/unops it extends to SFmode\nfirst and then truncates back to BFmode.\nFor {HF,SF,DF,XF,TF}mode -> BFmode conversions libgcc has implementations\nof all those conversions so that we avoid double rounding, for\nBFmode -> {DF,XF,TF}mode conversions to avoid growing libgcc too much\nit emits BFmode -> SFmode conversion first and then converts to the even\nwider mode, neither step should be imprecise.\nFor BFmode -> HFmode, it first emits a precise BFmode -> SFmode conversion\nand then SFmode -> HFmode, because neither format is subset or superset\nof the other, while SFmode is superset of both.\nexpr.cc then contains a -ffast-math optimization of the BF -> SF and\nSF -> BF conversions if we don't optimize for space (and for the latter\nif -frounding-math isn't enabled either).\nFor x86, perhaps truncsfbf2 optab could be defined for TARGET_AVX512BF16\nbut IMNSHO should FAIL if !flag_finite_math || flag_rounding_math\n|| !flag_unsafe_math_optimizations, because I think the insn doesn't\nraise on sNaNs, hardcodes round to nearest and flushes denormals to zero.\nBy default (unless x86 -fexcess-precision=16) we use float excess\nprecision for BFmode, so truncate only on explicit casts and assignments.\nThe patch introduces a single __bf16 builtin - __builtin_nansf16b,\nbecause (__bf16) __builtin_nansf (\"\") will drop the sNaN into qNaN,\nand uses f16b suffix instead of bf16 because there would be ambiguity on\nlog vs. logb - __builtin_logbf16 could be either log with bf16 suffix\nor logb with f16 suffix.  In other cases libstdc++ should mostly use\n__builtin_*f for std::bfloat16_t overloads (we have a problem with\nstd::nextafter though but that one we have also for std::float16_t).\n\n2022-10-14  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* tree-core.h (enum tree_index): Add TI_BFLOAT16_TYPE.\n\t* tree.h (bfloat16_type_node): Define.\n\t* tree.cc (excess_precision_type): Promote bfloat16_type_mode\n\tlike float16_type_mode.\n\t(build_common_tree_nodes): Initialize bfloat16_type_node if\n\tBFmode is supported.\n\t* expmed.h (maybe_expand_shift): Declare.\n\t* expmed.cc (maybe_expand_shift): No longer static.\n\t* expr.cc (convert_mode_scalar): Don't ICE on BF -> HF or HF -> BF\n\tconversions.  If there is no optab, handle BF -> {DF,XF,TF,HF}\n\tconversions as separate BF -> SF -> {DF,XF,TF,HF} conversions, add\n\t-ffast-math generic implementation for BF -> SF and SF -> BF\n\tconversions.\n\t* builtin-types.def (BT_BFLOAT16, BT_FN_BFLOAT16_CONST_STRING): New.\n\t* builtins.def (BUILT_IN_NANSF16B): New builtin.\n\t* fold-const-call.cc (fold_const_call): Handle CFN_BUILT_IN_NANSF16B.\n\t* config/i386/i386.cc (classify_argument): Handle E_BCmode.\n\t(ix86_libgcc_floating_mode_supported_p): Also return true for BFmode\n\tfor -msse2.\n\t(ix86_mangle_type): Mangle BFmode as DF16b.\n\t(ix86_invalid_conversion, ix86_invalid_unary_op,\n\tix86_invalid_binary_op): Remove.\n\t(TARGET_INVALID_CONVERSION, TARGET_INVALID_UNARY_OP,\n\tTARGET_INVALID_BINARY_OP): Don't redefine.\n\t* config/i386/i386-builtins.cc (ix86_bf16_type_node): Remove.\n\t(ix86_register_bf16_builtin_type): Use bfloat16_type_node rather than\n\tix86_bf16_type_node, only create it if still NULL.\n\t* config/i386/i386-builtin-types.def (BFLOAT16): Likewise.\n\t* config/i386/i386.md (cbranchbf4, cstorebf4): New expanders.\ngcc/c-family/\n\t* c-cppbuiltin.cc (c_cpp_builtins): If bfloat16_type_node,\n\tpredefine __BFLT16_*__ macros and for C++23 also\n\t__STDCPP_BFLOAT16_T__.  Predefine bfloat16_type_node related\n\tmacros for -fbuilding-libgcc.\n\t* c-lex.cc (interpret_float): Handle CPP_N_BFLOAT16.\ngcc/c/\n\t* c-typeck.cc (convert_arguments): Don't promote __bf16 to\n\tdouble.\ngcc/cp/\n\t* cp-tree.h (extended_float_type_p): Return true for\n\tbfloat16_type_node.\n\t* typeck.cc (cp_compare_floating_point_conversion_ranks): Set\n\textended{1,2} if mv{1,2} is bfloat16_type_node.  Adjust comment.\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_bfloat16,\n\tcheck_effective_target_bfloat16_runtime, add_options_for_bfloat16):\n\tNew.\n\t* gcc.dg/torture/bfloat16-basic.c: New test.\n\t* gcc.dg/torture/bfloat16-builtin.c: New test.\n\t* gcc.dg/torture/bfloat16-builtin-issignaling-1.c: New test.\n\t* gcc.dg/torture/bfloat16-complex.c: New test.\n\t* gcc.dg/torture/builtin-issignaling-1.c: Allow to be includable\n\tfrom bfloat16-builtin-issignaling-1.c.\n\t* gcc.dg/torture/floatn-basic.h: Allow to be includable from\n\tbfloat16-basic.c.\n\t* gcc.target/i386/vect-bfloat16-typecheck_2.c: Adjust expected\n\tdiagnostics.\n\t* gcc.target/i386/sse2-bfloat16-scalar-typecheck.c: Likewise.\n\t* gcc.target/i386/vect-bfloat16-typecheck_1.c: Likewise.\n\t* g++.target/i386/bfloat_cpp_typecheck.C: Likewise.\nlibcpp/\n\t* include/cpplib.h (CPP_N_BFLOAT16): Define.\n\t* expr.cc (interpret_float_suffix): Handle bf16 and BF16 suffixes for\n\tC++.\nlibgcc/\n\t* config/i386/t-softfp (softfp_extensions): Add bfsf.\n\t(softfp_truncations): Add tfbf xfbf dfbf sfbf hfbf.\n\t(CFLAGS-extendbfsf2.c, CFLAGS-truncsfbf2.c, CFLAGS-truncdfbf2.c,\n\tCFLAGS-truncxfbf2.c, CFLAGS-trunctfbf2.c, CFLAGS-trunchfbf2.c): Add\n\t-msse2.\n\t* config/i386/libgcc-glibc.ver (GCC_13.0.0): Export\n\t__extendbfsf2 and __trunc{s,d,x,t,h}fbf2.\n\t* config/i386/sfp-machine.h (_FP_NANSIGN_B): Define.\n\t* config/i386/64/sfp-machine.h (_FP_NANFRAC_B): Define.\n\t* config/i386/32/sfp-machine.h (_FP_NANFRAC_B): Define.\n\t* soft-fp/brain.h: New file.\n\t* soft-fp/truncsfbf2.c: New file.\n\t* soft-fp/truncdfbf2.c: New file.\n\t* soft-fp/truncxfbf2.c: New file.\n\t* soft-fp/trunctfbf2.c: New file.\n\t* soft-fp/trunchfbf2.c: New file.\n\t* soft-fp/truncbfhf2.c: New file.\n\t* soft-fp/extendbfsf2.c: New file.\nlibiberty/\n\t* cp-demangle.h (D_BUILTIN_TYPE_COUNT): Increment.\n\t* cp-demangle.c (cplus_demangle_builtin_types): Add std::bfloat16_t\n\tentry.\n\t(cplus_demangle_type): Demangle DF16b.\n\t* testsuite/demangle-expected (_Z3xxxDF16b): New test.", "tree": {"sha": "0182fba3c78ebcdc1d59f6c1ca9605ee62da6fd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0182fba3c78ebcdc1d59f6c1ca9605ee62da6fd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2565a31c1622ab0926aeef4a6579413e121b9f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2565a31c1622ab0926aeef4a6579413e121b9f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2565a31c1622ab0926aeef4a6579413e121b9f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2565a31c1622ab0926aeef4a6579413e121b9f9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16ec267063c8ce60769888d4097bcd158410adc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ec267063c8ce60769888d4097bcd158410adc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16ec267063c8ce60769888d4097bcd158410adc8"}], "stats": {"total": 1648, "additions": 1339, "deletions": 309}, "files": [{"sha": "df3a88f2cf3e3a913220e512851bb87d4beb15a6", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -82,6 +82,9 @@ DEF_PRIMITIVE_TYPE (BT_UNWINDWORD, (*lang_hooks.types.type_for_mode)\n DEF_PRIMITIVE_TYPE (BT_FLOAT, float_type_node)\n DEF_PRIMITIVE_TYPE (BT_DOUBLE, double_type_node)\n DEF_PRIMITIVE_TYPE (BT_LONGDOUBLE, long_double_type_node)\n+DEF_PRIMITIVE_TYPE (BT_BFLOAT16, (bfloat16_type_node\n+\t\t\t\t  ? bfloat16_type_node\n+\t\t\t\t  : error_mark_node))\n DEF_PRIMITIVE_TYPE (BT_FLOAT16, (float16_type_node\n \t\t\t\t ? float16_type_node\n \t\t\t\t : error_mark_node))\n@@ -264,6 +267,7 @@ DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_CONST_STRING, BT_FLOAT, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_CONST_STRING, BT_DOUBLE, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_CONST_STRING,\n \t\t     BT_LONGDOUBLE, BT_CONST_STRING)\n+DEF_FUNCTION_TYPE_1 (BT_FN_BFLOAT16_CONST_STRING, BT_BFLOAT16, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT16_CONST_STRING, BT_FLOAT16, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT32_CONST_STRING, BT_FLOAT32, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT64_CONST_STRING, BT_FLOAT64, BT_CONST_STRING)"}, {"sha": "5f2e627d68bc7d37c1cb9ad7f50b0c6fee4e4658", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -514,6 +514,7 @@ DEF_GCC_BUILTIN        (BUILT_IN_NANSF, \"nansf\", BT_FN_FLOAT_CONST_STRING, ATTR_\n DEF_GCC_BUILTIN        (BUILT_IN_NANSL, \"nansl\", BT_FN_LONGDOUBLE_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_FLOATN_NX_BUILTINS (BUILT_IN_NANS, \"nans\", NAN_TYPE, ATTR_CONST_NOTHROW_NONNULL)\n #undef NAN_TYPE\n+DEF_GCC_BUILTIN        (BUILT_IN_NANSF16B, \"nansf16b\", BT_FN_BFLOAT16_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANSD32, \"nansd32\", BT_FN_DFLOAT32_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANSD64, \"nansd64\", BT_FN_DFLOAT64_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)\n DEF_GCC_BUILTIN        (BUILT_IN_NANSD128, \"nansd128\", BT_FN_DFLOAT128_CONST_STRING, ATTR_CONST_NOTHROW_NONNULL)"}, {"sha": "cdb658f6ac97a110aba6849f93432acde409544e", "filename": "gcc/c-family/c-cppbuiltin.cc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fc-family%2Fc-cppbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fc-family%2Fc-cppbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -1260,6 +1260,13 @@ c_cpp_builtins (cpp_reader *pfile)\n       builtin_define_float_constants (prefix, ggc_strdup (csuffix), \"%s\",\n \t\t\t\t      csuffix, FLOATN_NX_TYPE_NODE (i));\n     }\n+  if (bfloat16_type_node)\n+    {\n+      if (c_dialect_cxx () && cxx_dialect > cxx20)\n+\tcpp_define (pfile, \"__STDCPP_BFLOAT16_T__=1\");\n+      builtin_define_float_constants (\"BFLT16\", \"BF16\", \"%s\",\n+\t\t\t\t      \"BF16\", bfloat16_type_node);\n+    }\n \n   /* For float.h.  */\n   if (targetm.decimal_float_supported_p ())\n@@ -1370,6 +1377,12 @@ c_cpp_builtins (cpp_reader *pfile)\n \t      suffix[0] = 'l';\n \t      memcpy (float_h_prefix, \"LDBL\", 5);\n \t    }\n+\t  else if (bfloat16_type_node\n+\t\t   && mode == TYPE_MODE (bfloat16_type_node))\n+\t    {\n+\t      memcpy (suffix, \"bf16\", 5);\n+\t      memcpy (float_h_prefix, \"BFLT16\", 7);\n+\t    }\n \t  else\n \t    {\n \t      bool found_suffix = false;\n@@ -1396,22 +1409,28 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  machine_mode float16_type_mode = (float16_type_node\n \t\t\t\t\t    ? TYPE_MODE (float16_type_node)\n \t\t\t\t\t    : VOIDmode);\n+\t  machine_mode bfloat16_type_mode = (bfloat16_type_node\n+\t\t\t\t\t     ? TYPE_MODE (bfloat16_type_node)\n+\t\t\t\t\t     : VOIDmode);\n \t  switch (targetm.c.excess_precision\n \t\t    (EXCESS_PRECISION_TYPE_IMPLICIT))\n \t    {\n \t    case FLT_EVAL_METHOD_UNPREDICTABLE:\n \t    case FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE:\n \t      excess_precision = (mode == float16_type_mode\n+\t\t\t\t  || mode == bfloat16_type_mode\n \t\t\t\t  || mode == TYPE_MODE (float_type_node)\n \t\t\t\t  || mode == TYPE_MODE (double_type_node));\n \t      break;\n \n \t    case FLT_EVAL_METHOD_PROMOTE_TO_DOUBLE:\n \t      excess_precision = (mode == float16_type_mode\n+\t\t\t\t  || mode == bfloat16_type_mode\n \t\t\t\t  || mode == TYPE_MODE (float_type_node));\n \t      break;\n \t    case FLT_EVAL_METHOD_PROMOTE_TO_FLOAT:\n-\t      excess_precision = mode == float16_type_mode;\n+\t      excess_precision = (mode == float16_type_mode\n+\t\t\t\t  || mode == bfloat16_type_mode);\n \t      break;\n \t    case FLT_EVAL_METHOD_PROMOTE_TO_FLOAT16:\n \t      excess_precision = false;"}, {"sha": "89c65aca28a8438d25588b22ec86c01f5769dce3", "filename": "gcc/c-family/c-lex.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fc-family%2Fc-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fc-family%2Fc-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -1000,6 +1000,22 @@ interpret_float (const cpp_token *token, unsigned int flags,\n \t  pedwarn (input_location, OPT_Wpedantic,\n \t\t   \"non-standard suffix on floating constant\");\n       }\n+    else if ((flags & CPP_N_BFLOAT16) != 0)\n+      {\n+\ttype = bfloat16_type_node;\n+\tif (type == NULL_TREE)\n+\t  {\n+\t    error (\"unsupported non-standard suffix on floating constant\");\n+\t    return error_mark_node;\n+\t  }\n+\tif (!c_dialect_cxx ())\n+\t  pedwarn (input_location, OPT_Wpedantic,\n+\t\t   \"non-standard suffix on floating constant\");\n+\telse if (cxx_dialect < cxx23)\n+\t  pedwarn (input_location, OPT_Wpedantic,\n+\t\t   \"%<bf16%> or %<BF16%> suffix on floating constant only \"\n+\t\t   \"available with %<-std=c++2b%> or %<-std=gnu++2b%>\");\n+      }\n     else if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n       type = long_double_type_node;\n     else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL"}, {"sha": "fdb96c28c51424fb731c9a37f44d95488a35ab78", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -3678,6 +3678,9 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t\tpromote_float_arg = false;\n \t\tbreak;\n \t      }\n+\t  /* Don't promote __bf16 either.  */\n+\t  if (TYPE_MAIN_VARIANT (valtype) == bfloat16_type_node)\n+\t    promote_float_arg = false;\n \t}\n \n       if (type != NULL_TREE)"}, {"sha": "2c27a4e67b69248ad9a95f8aa0220e84f71bf583", "filename": "gcc/config/i386/i386-builtin-types.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -69,7 +69,7 @@ DEF_PRIMITIVE_TYPE (UINT16, short_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (INT64, long_long_integer_type_node)\n DEF_PRIMITIVE_TYPE (UINT64, long_long_unsigned_type_node)\n DEF_PRIMITIVE_TYPE (FLOAT16, ix86_float16_type_node)\n-DEF_PRIMITIVE_TYPE (BFLOAT16, ix86_bf16_type_node)\n+DEF_PRIMITIVE_TYPE (BFLOAT16, bfloat16_type_node)\n DEF_PRIMITIVE_TYPE (FLOAT, float_type_node)\n DEF_PRIMITIVE_TYPE (DOUBLE, double_type_node)\n DEF_PRIMITIVE_TYPE (FLOAT80, float80_type_node)"}, {"sha": "b5c651a1cab7ebb428434ad4488c4c7396c78b0a", "filename": "gcc/config/i386/i386-builtins.cc", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtins.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -126,7 +126,6 @@ BDESC_VERIFYS (IX86_BUILTIN_MAX,\n static GTY(()) tree ix86_builtin_type_tab[(int) IX86_BT_LAST_CPTR + 1];\n \n tree ix86_float16_type_node = NULL_TREE;\n-tree ix86_bf16_type_node = NULL_TREE;\n tree ix86_bf16_ptr_type_node = NULL_TREE;\n \n /* Retrieve an element from the above table, building some of\n@@ -1372,16 +1371,18 @@ ix86_register_float16_builtin_type (void)\n static void\n ix86_register_bf16_builtin_type (void)\n {\n-  ix86_bf16_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (ix86_bf16_type_node) = 16;\n-  SET_TYPE_MODE (ix86_bf16_type_node, BFmode);\n-  layout_type (ix86_bf16_type_node);\n+  if (bfloat16_type_node == NULL_TREE)\n+    {\n+      bfloat16_type_node = make_node (REAL_TYPE);\n+      TYPE_PRECISION (bfloat16_type_node) = 16;\n+      SET_TYPE_MODE (bfloat16_type_node, BFmode);\n+      layout_type (bfloat16_type_node);\n+    }\n \n   if (!maybe_get_identifier (\"__bf16\") && TARGET_SSE2)\n     {\n-      lang_hooks.types.register_builtin_type (ix86_bf16_type_node,\n-\t\t\t\t\t    \"__bf16\");\n-      ix86_bf16_ptr_type_node = build_pointer_type (ix86_bf16_type_node);\n+      lang_hooks.types.register_builtin_type (bfloat16_type_node, \"__bf16\");\n+      ix86_bf16_ptr_type_node = build_pointer_type (bfloat16_type_node);\n     }\n }\n "}, {"sha": "480db35f6cd6cbeea509ae4236f5794b4a00c422", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 3, "deletions": 60, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -2423,6 +2423,7 @@ classify_argument (machine_mode mode, const_tree type,\n       classes[1] = X86_64_SSEUP_CLASS;\n       return 2;\n     case E_HCmode:\n+    case E_BCmode:\n       classes[0] = X86_64_SSE_CLASS;\n       if (!(bit_offset % 64))\n \treturn 1;\n@@ -22428,7 +22429,7 @@ ix86_libgcc_floating_mode_supported_p (scalar_float_mode mode)\n      be defined by the C front-end for AVX512FP16 intrinsics.  We will\n      issue an error in ix86_expand_move for HFmode if AVX512FP16 isn't\n      enabled.  */\n-  return ((mode == HFmode && TARGET_SSE2)\n+  return (((mode == HFmode || mode == BFmode) && TARGET_SSE2)\n \t  ? true\n \t  : default_libgcc_floating_mode_supported_p (mode));\n }\n@@ -22731,7 +22732,7 @@ ix86_mangle_type (const_tree type)\n   switch (TYPE_MODE (type))\n     {\n     case E_BFmode:\n-      return \"u6__bf16\";\n+      return \"DF16b\";\n     case E_HFmode:\n       /* _Float16 is \"DF16_\".\n \t Align with clang's decision in https://reviews.llvm.org/D33719. */\n@@ -22747,55 +22748,6 @@ ix86_mangle_type (const_tree type)\n     }\n }\n \n-/* Return the diagnostic message string if conversion from FROMTYPE to\n-   TOTYPE is not allowed, NULL otherwise.  */\n-\n-static const char *\n-ix86_invalid_conversion (const_tree fromtype, const_tree totype)\n-{\n-  if (element_mode (fromtype) != element_mode (totype))\n-    {\n-      /* Do no allow conversions to/from BFmode scalar types.  */\n-      if (TYPE_MODE (fromtype) == BFmode)\n-\treturn N_(\"invalid conversion from type %<__bf16%>\");\n-      if (TYPE_MODE (totype) == BFmode)\n-\treturn N_(\"invalid conversion to type %<__bf16%>\");\n-    }\n-\n-  /* Conversion allowed.  */\n-  return NULL;\n-}\n-\n-/* Return the diagnostic message string if the unary operation OP is\n-   not permitted on TYPE, NULL otherwise.  */\n-\n-static const char *\n-ix86_invalid_unary_op (int op, const_tree type)\n-{\n-  /* Reject all single-operand operations on BFmode except for &.  */\n-  if (element_mode (type) == BFmode && op != ADDR_EXPR)\n-    return N_(\"operation not permitted on type %<__bf16%>\");\n-\n-  /* Operation allowed.  */\n-  return NULL;\n-}\n-\n-/* Return the diagnostic message string if the binary operation OP is\n-   not permitted on TYPE1 and TYPE2, NULL otherwise.  */\n-\n-static const char *\n-ix86_invalid_binary_op (int op ATTRIBUTE_UNUSED, const_tree type1,\n-\t\t\t   const_tree type2)\n-{\n-  /* Reject all 2-operand operations on BFmode.  */\n-  if (element_mode (type1) == BFmode\n-      || element_mode (type2) == BFmode)\n-    return N_(\"operation not permitted on type %<__bf16%>\");\n-\n-  /* Operation allowed.  */\n-  return NULL;\n-}\n-\n static GTY(()) tree ix86_tls_stack_chk_guard_decl;\n \n static tree\n@@ -24853,15 +24805,6 @@ ix86_libgcc_floating_mode_supported_p\n #undef TARGET_MANGLE_TYPE\n #define TARGET_MANGLE_TYPE ix86_mangle_type\n \n-#undef TARGET_INVALID_CONVERSION\n-#define TARGET_INVALID_CONVERSION ix86_invalid_conversion\n-\n-#undef TARGET_INVALID_UNARY_OP\n-#define TARGET_INVALID_UNARY_OP ix86_invalid_unary_op\n-\n-#undef TARGET_INVALID_BINARY_OP\n-#define TARGET_INVALID_BINARY_OP ix86_invalid_binary_op\n-\n #undef TARGET_STACK_PROTECT_GUARD\n #define TARGET_STACK_PROTECT_GUARD ix86_stack_protect_guard\n "}, {"sha": "6688d92b63c0d59935b8c80095607cacfbc18e59", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -1644,6 +1644,48 @@\n   DONE;\n })\n \n+(define_expand \"cbranchbf4\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(compare:CC (match_operand:BF 1 \"cmp_fp_expander_operand\")\n+\t\t    (match_operand:BF 2 \"cmp_fp_expander_operand\")))\n+   (set (pc) (if_then_else\n+\t      (match_operator 0 \"comparison_operator\"\n+\t       [(reg:CC FLAGS_REG)\n+\t\t(const_int 0)])\n+\t      (label_ref (match_operand 3))\n+\t      (pc)))]\n+  \"\"\n+{\n+  rtx op1 = gen_lowpart (HImode, operands[1]);\n+  if (CONST_INT_P (op1))\n+    op1 = simplify_const_unary_operation (FLOAT_EXTEND, SFmode,\n+\t\t\t\t\t  operands[1], BFmode);\n+  else\n+    {\n+      rtx t1 = gen_reg_rtx (SImode);\n+      emit_insn (gen_zero_extendhisi2 (t1, op1));\n+      emit_insn (gen_ashlsi3 (t1, t1, GEN_INT (16)));\n+      op1 = gen_lowpart (SFmode, t1);\n+    }\n+  rtx op2 = gen_lowpart (HImode, operands[2]);\n+  if (CONST_INT_P (op2))\n+    op2 = simplify_const_unary_operation (FLOAT_EXTEND, SFmode,\n+\t\t\t\t\t  operands[2], BFmode);\n+  else\n+    {\n+      rtx t2 = gen_reg_rtx (SImode);\n+      emit_insn (gen_zero_extendhisi2 (t2, op2));\n+      emit_insn (gen_ashlsi3 (t2, t2, GEN_INT (16)));\n+      op2 = gen_lowpart (SFmode, t2);\n+    }\n+  do_compare_rtx_and_jump (op1, op2, GET_CODE (operands[0]), 0,\n+\t\t\t   SFmode, NULL_RTX, NULL,\n+\t\t\t   as_a <rtx_code_label *> (operands[3]),\n+\t\t\t   /* Unfortunately this isn't propagated.  */\n+\t\t\t   profile_probability::even ());\n+  DONE;\n+})\n+\n (define_expand \"cstorehf4\"\n   [(set (reg:CC FLAGS_REG)\n \t(compare:CC (match_operand:HF 2 \"cmp_fp_expander_operand\")\n@@ -1659,6 +1701,45 @@\n   DONE;\n })\n \n+(define_expand \"cstorebf4\"\n+  [(set (reg:CC FLAGS_REG)\n+\t(compare:CC (match_operand:BF 2 \"cmp_fp_expander_operand\")\n+\t\t    (match_operand:BF 3 \"cmp_fp_expander_operand\")))\n+   (set (match_operand:QI 0 \"register_operand\")\n+\t(match_operator 1 \"comparison_operator\"\n+\t  [(reg:CC FLAGS_REG)\n+\t   (const_int 0)]))]\n+  \"\"\n+{\n+  rtx op1 = gen_lowpart (HImode, operands[2]);\n+  if (CONST_INT_P (op1))\n+    op1 = simplify_const_unary_operation (FLOAT_EXTEND, SFmode,\n+\t\t\t\t\t  operands[2], BFmode);\n+  else\n+    {\n+      rtx t1 = gen_reg_rtx (SImode);\n+      emit_insn (gen_zero_extendhisi2 (t1, op1));\n+      emit_insn (gen_ashlsi3 (t1, t1, GEN_INT (16)));\n+      op1 = gen_lowpart (SFmode, t1);\n+    }\n+  rtx op2 = gen_lowpart (HImode, operands[3]);\n+  if (CONST_INT_P (op2))\n+    op2 = simplify_const_unary_operation (FLOAT_EXTEND, SFmode,\n+\t\t\t\t\t  operands[3], BFmode);\n+  else\n+    {\n+      rtx t2 = gen_reg_rtx (SImode);\n+      emit_insn (gen_zero_extendhisi2 (t2, op2));\n+      emit_insn (gen_ashlsi3 (t2, t2, GEN_INT (16)));\n+      op2 = gen_lowpart (SFmode, t2);\n+    }\n+  rtx res = emit_store_flag_force (operands[0], GET_CODE (operands[1]),\n+\t\t\t\t   op1, op2, SFmode, 0, 1);\n+  if (!rtx_equal_p (res, operands[0]))\n+    emit_move_insn (operands[0], res);\n+  DONE;\n+})\n+\n (define_expand \"cstore<mode>4\"\n   [(set (reg:CC FLAGS_REG)\n \t(compare:CC (match_operand:MODEF 2 \"cmp_fp_expander_operand\")"}, {"sha": "e2607f09c1967efa7563b4a6bef438edbeab5ccf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -8741,6 +8741,8 @@ extended_float_type_p (tree type)\n   for (int i = 0; i < NUM_FLOATN_NX_TYPES; ++i)\n     if (type == FLOATN_TYPE_NODE (i))\n       return true;\n+  if (type == bfloat16_type_node)\n+    return true;\n   return false;\n }\n "}, {"sha": "da0e1427b977455da0ada30fb376977f1c0095f7", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -293,6 +293,10 @@ cp_compare_floating_point_conversion_ranks (tree t1, tree t2)\n       if (mv2 == FLOATN_NX_TYPE_NODE (i))\n \textended2 = i + 1;\n     }\n+  if (mv1 == bfloat16_type_node)\n+    extended1 = true;\n+  if (mv2 == bfloat16_type_node)\n+    extended2 = true;\n   if (extended2 && !extended1)\n     {\n       int ret = cp_compare_floating_point_conversion_ranks (t2, t1);\n@@ -390,7 +394,9 @@ cp_compare_floating_point_conversion_ranks (tree t1, tree t2)\n   if (cnt > 1 && mv2 == long_double_type_node)\n     return -2;\n   /* Otherwise, they have equal rank, but extended types\n-     (other than std::bfloat16_t) have higher subrank.  */\n+     (other than std::bfloat16_t) have higher subrank.\n+     std::bfloat16_t shouldn't have equal rank to any standard\n+     floating point type.  */\n   return 1;\n }\n "}, {"sha": "323565fea344ab5ab064984e77003bd37e35f913", "filename": "gcc/expmed.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fexpmed.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fexpmed.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -2705,7 +2705,7 @@ expand_shift (enum tree_code code, machine_mode mode, rtx shifted,\n \n /* Likewise, but return 0 if that cannot be done.  */\n \n-static rtx\n+rtx\n maybe_expand_shift (enum tree_code code, machine_mode mode, rtx shifted,\n \t\t    int amount, rtx target, int unsignedp)\n {"}, {"sha": "f50f3232ca02070f7323f23c7f20645e139654ba", "filename": "gcc/expmed.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -707,6 +707,8 @@ extern rtx expand_variable_shift (enum tree_code, machine_mode,\n \t\t\t\t  rtx, tree, rtx, int);\n extern rtx expand_shift (enum tree_code, machine_mode, rtx, poly_int64, rtx,\n \t\t\t int);\n+extern rtx maybe_expand_shift (enum tree_code, machine_mode, rtx, int, rtx,\n+\t\t\t       int);\n #ifdef GCC_OPTABS_H\n extern rtx expand_divmod (int, enum tree_code, machine_mode, rtx, rtx,\n \t\t\t  rtx, int, enum optab_methods = OPTAB_LIB_WIDEN);"}, {"sha": "4c892d69249607aa624d6539858a45b04a3bc09d", "filename": "gcc/expr.cc", "status": "modified", "additions": 149, "deletions": 1, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -344,7 +344,11 @@ convert_mode_scalar (rtx to, rtx from, int unsignedp)\n       gcc_assert ((GET_MODE_PRECISION (from_mode)\n \t\t   != GET_MODE_PRECISION (to_mode))\n \t\t  || (DECIMAL_FLOAT_MODE_P (from_mode)\n-\t\t      != DECIMAL_FLOAT_MODE_P (to_mode)));\n+\t\t      != DECIMAL_FLOAT_MODE_P (to_mode))\n+\t\t  || (REAL_MODE_FORMAT (from_mode) == &arm_bfloat_half_format\n+\t\t      && REAL_MODE_FORMAT (to_mode) == &ieee_half_format)\n+\t\t  || (REAL_MODE_FORMAT (to_mode) == &arm_bfloat_half_format\n+\t\t      && REAL_MODE_FORMAT (from_mode) == &ieee_half_format));\n \n       if (GET_MODE_PRECISION (from_mode) == GET_MODE_PRECISION (to_mode))\n \t/* Conversion between decimal float and binary float, same size.  */\n@@ -364,6 +368,150 @@ convert_mode_scalar (rtx to, rtx from, int unsignedp)\n \t  return;\n \t}\n \n+#ifdef HAVE_SFmode\n+      if (REAL_MODE_FORMAT (from_mode) == &arm_bfloat_half_format\n+\t  && REAL_MODE_FORMAT (SFmode) == &ieee_single_format)\n+\t{\n+\t  if (GET_MODE_PRECISION (to_mode) > GET_MODE_PRECISION (SFmode))\n+\t    {\n+\t      /* To cut down on libgcc size, implement\n+\t\t BFmode -> {DF,XF,TF}mode conversions by\n+\t\t BFmode -> SFmode -> {DF,XF,TF}mode conversions.  */\n+\t      rtx temp = gen_reg_rtx (SFmode);\n+\t      convert_mode_scalar (temp, from, unsignedp);\n+\t      convert_mode_scalar (to, temp, unsignedp);\n+\t      return;\n+\t    }\n+\t  if (REAL_MODE_FORMAT (to_mode) == &ieee_half_format)\n+\t    {\n+\t      /* Similarly, implement BFmode -> HFmode as\n+\t\t BFmode -> SFmode -> HFmode conversion where SFmode\n+\t\t has superset of BFmode values.  We don't need\n+\t\t to handle sNaNs by raising exception and turning\n+\t\t into into qNaN though, as that can be done in the\n+\t\t SFmode -> HFmode conversion too.  */\n+\t      rtx temp = gen_reg_rtx (SFmode);\n+\t      int save_flag_finite_math_only = flag_finite_math_only;\n+\t      flag_finite_math_only = true;\n+\t      convert_mode_scalar (temp, from, unsignedp);\n+\t      flag_finite_math_only = save_flag_finite_math_only;\n+\t      convert_mode_scalar (to, temp, unsignedp);\n+\t      return;\n+\t    }\n+\t  if (to_mode == SFmode\n+\t      && !HONOR_NANS (from_mode)\n+\t      && !HONOR_NANS (to_mode)\n+\t      && optimize_insn_for_speed_p ())\n+\t    {\n+\t      /* If we don't expect sNaNs, for BFmode -> SFmode we can just\n+\t\t shift the bits up.  */\n+\t      machine_mode fromi_mode, toi_mode;\n+\t      if (int_mode_for_size (GET_MODE_BITSIZE (from_mode),\n+\t\t\t\t     0).exists (&fromi_mode)\n+\t\t  && int_mode_for_size (GET_MODE_BITSIZE (to_mode),\n+\t\t\t\t\t0).exists (&toi_mode))\n+\t\t{\n+\t\t  start_sequence ();\n+\t\t  rtx fromi = lowpart_subreg (fromi_mode, from, from_mode);\n+\t\t  rtx tof = NULL_RTX;\n+\t\t  if (fromi)\n+\t\t    {\n+\t\t      rtx toi = gen_reg_rtx (toi_mode);\n+\t\t      convert_mode_scalar (toi, fromi, 1);\n+\t\t      toi\n+\t\t\t= maybe_expand_shift (LSHIFT_EXPR, toi_mode, toi,\n+\t\t\t\t\t      GET_MODE_PRECISION (to_mode)\n+\t\t\t\t\t      - GET_MODE_PRECISION (from_mode),\n+\t\t\t\t\t      NULL_RTX, 1);\n+\t\t      if (toi)\n+\t\t\t{\n+\t\t\t  tof = lowpart_subreg (to_mode, toi, toi_mode);\n+\t\t\t  if (tof)\n+\t\t\t    emit_move_insn (to, tof);\n+\t\t\t}\n+\t\t    }\n+\t\t  insns = get_insns ();\n+\t\t  end_sequence ();\n+\t\t  if (tof)\n+\t\t    {\n+\t\t      emit_insn (insns);\n+\t\t      return;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      if (REAL_MODE_FORMAT (from_mode) == &ieee_single_format\n+\t  && REAL_MODE_FORMAT (to_mode) == &arm_bfloat_half_format\n+\t  && !HONOR_NANS (from_mode)\n+\t  && !HONOR_NANS (to_mode)\n+\t  && !flag_rounding_math\n+\t  && optimize_insn_for_speed_p ())\n+\t{\n+\t  /* If we don't expect qNaNs nor sNaNs and can assume rounding\n+\t     to nearest, we can expand the conversion inline as\n+\t     (fromi + 0x7fff + ((fromi >> 16) & 1)) >> 16.  */\n+\t  machine_mode fromi_mode, toi_mode;\n+\t  if (int_mode_for_size (GET_MODE_BITSIZE (from_mode),\n+\t\t\t\t 0).exists (&fromi_mode)\n+\t      && int_mode_for_size (GET_MODE_BITSIZE (to_mode),\n+\t\t\t\t    0).exists (&toi_mode))\n+\t    {\n+\t      start_sequence ();\n+\t      rtx fromi = lowpart_subreg (fromi_mode, from, from_mode);\n+\t      rtx tof = NULL_RTX;\n+\t      do\n+\t\t{\n+\t\t  if (!fromi)\n+\t\t    break;\n+\t\t  int shift = (GET_MODE_PRECISION (from_mode)\n+\t\t\t       - GET_MODE_PRECISION (to_mode));\n+\t\t  rtx temp1\n+\t\t    = maybe_expand_shift (RSHIFT_EXPR, fromi_mode, fromi,\n+\t\t\t\t\t  shift, NULL_RTX, 1);\n+\t\t  if (!temp1)\n+\t\t    break;\n+\t\t  rtx temp2\n+\t\t    = expand_binop (fromi_mode, and_optab, temp1, const1_rtx,\n+\t\t\t\t    NULL_RTX, 1, OPTAB_DIRECT);\n+\t\t  if (!temp2)\n+\t\t    break;\n+\t\t  rtx temp3\n+\t\t    = expand_binop (fromi_mode, add_optab, fromi,\n+\t\t\t\t    gen_int_mode ((HOST_WIDE_INT_1U\n+\t\t\t\t\t\t   << (shift - 1)) - 1,\n+\t\t\t\t\t\t  fromi_mode), NULL_RTX,\n+\t\t\t\t    1, OPTAB_DIRECT);\n+\t\t  if (!temp3)\n+\t\t    break;\n+\t\t  rtx temp4\n+\t\t    = expand_binop (fromi_mode, add_optab, temp3, temp2,\n+\t\t\t\t    NULL_RTX, 1, OPTAB_DIRECT);\n+\t\t  if (!temp4)\n+\t\t    break;\n+\t\t  rtx temp5 = maybe_expand_shift (RSHIFT_EXPR, fromi_mode,\n+\t\t\t\t\t\t  temp4, shift, NULL_RTX, 1);\n+\t\t  if (!temp5)\n+\t\t    break;\n+\t\t  rtx temp6 = lowpart_subreg (toi_mode, temp5, fromi_mode);\n+\t\t  if (!temp6)\n+\t\t    break;\n+\t\t  tof = lowpart_subreg (to_mode, force_reg (toi_mode, temp6),\n+\t\t\t\t\ttoi_mode);\n+\t\t  if (tof)\n+\t\t    emit_move_insn (to, tof);\n+\t\t}\n+\t      while (0);\n+\t      insns = get_insns ();\n+\t      end_sequence ();\n+\t      if (tof)\n+\t\t{\n+\t\t  emit_insn (insns);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+#endif\n+\n       /* Otherwise use a libcall.  */\n       libcall = convert_optab_libfunc (tab, to_mode, from_mode);\n "}, {"sha": "7e0d6711ce24a595e4b86318986fa692e72b938f", "filename": "gcc/fold-const-call.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ffold-const-call.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ffold-const-call.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -1301,6 +1301,7 @@ fold_const_call (combined_fn fn, tree type, tree arg)\n \n     CASE_CFN_NANS:\n     CASE_FLT_FN_FLOATN_NX (CFN_BUILT_IN_NANS):\n+    case CFN_BUILT_IN_NANSF16B:\n     case CFN_BUILT_IN_NANSD32:\n     case CFN_BUILT_IN_NANSD64:\n     case CFN_BUILT_IN_NANSD128:"}, {"sha": "256712937d439a363137da68f0ec884577bba721", "filename": "gcc/testsuite/g++.target/i386/bfloat_cpp_typecheck.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fbfloat_cpp_typecheck.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fbfloat_cpp_typecheck.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fbfloat_cpp_typecheck.C?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -5,6 +5,6 @@ void foo (void)\n {\n   __bf16 (); /* { dg-bogus {invalid conversion to type '__bf16'} } */\n   __bf16 a = __bf16(); /* { dg-bogus {invalid conversion to type '__bf16'} } */\n-  __bf16 (0x1234); /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 (0.1); /* { dg-error {invalid conversion to type '__bf16'} } */\n+  __bf16 (0x1234); /* { dg-bogus {invalid conversion to type '__bf16'} } */\n+  __bf16 (0.1); /* { dg-bogus {invalid conversion to type '__bf16'} } */\n }"}, {"sha": "09e54d4470a7c689ab271eb478a7d27843f4eb4a", "filename": "gcc/testsuite/gcc.dg/torture/bfloat16-basic.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-basic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-basic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-basic.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,11 @@\n+/* Test __bf16.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options bfloat16 } */\n+/* { dg-require-effective-target bfloat16_runtime } */\n+\n+#define TYPE __bf16\n+#define CST(C) CONCAT (C, bf16)\n+#define CSTU(C) CONCAT (C, BF16)\n+\n+#include \"floatn-basic.h\""}, {"sha": "0e428db792bf8736c78c10e667664a6e2e974177", "filename": "gcc/testsuite/gcc.dg/torture/bfloat16-builtin-issignaling-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-builtin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-builtin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-builtin-issignaling-1.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,21 @@\n+/* Test __bf16 __builtin_issignaling.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options bfloat16 } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target bfloat16_runtime } */\n+/* { dg-additional-options \"-fsignaling-nans\" } */\n+/* Workaround for PR57484 on ia32: */\n+/* { dg-additional-options \"-msse2 -mfpmath=sse\" { target { ia32 && sse2_runtime } } } */\n+\n+#define CONCATX(X, Y) X ## Y\n+#define CONCAT(X, Y) CONCATX (X, Y)\n+\n+#define TYPE __bf16\n+#define CST(C) CONCAT (C, bf16)\n+#define FN(F) CONCAT (F, f16b)\n+#define NAN(x) ((__bf16) __builtin_nanf (x))\n+#define INF ((__bf16) __builtin_inff ())\n+#define EXT 0\n+\n+#include \"builtin-issignaling-1.c\""}, {"sha": "ce02f6f8b5b14e5dcbc66f4c670379116a757d55", "filename": "gcc/testsuite/gcc.dg/torture/bfloat16-builtin.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-builtin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-builtin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-builtin.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,47 @@\n+/* Test __bf16 built-in functions.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options bfloat16 } */\n+/* { dg-add-options ieee } */\n+/* { dg-require-effective-target bfloat16_runtime } */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+extern __bf16 test_type;\n+extern __typeof (__builtin_nansf16b (\"\")) test_type;\n+\n+volatile __bf16 inf_cst = (__bf16) __builtin_inff ();\n+volatile __bf16 huge_val_cst = (__bf16) __builtin_huge_valf ();\n+volatile __bf16 nan_cst = (__bf16) __builtin_nanf (\"\");\n+volatile __bf16 nans_cst = __builtin_nansf16b (\"\");\n+volatile __bf16 neg0 = -0.0bf16, neg1 = -1.0bf16, one = 1.0;\n+\n+int\n+main (void)\n+{\n+  volatile __bf16 r;\n+  if (!__builtin_isinf (inf_cst))\n+    abort ();\n+  if (!__builtin_isinf (huge_val_cst))\n+    abort ();\n+  if (inf_cst != huge_val_cst)\n+    abort ();\n+  if (!__builtin_isnan (nan_cst))\n+    abort ();\n+  if (!__builtin_isnan (nans_cst))\n+    abort ();\n+  r = __builtin_fabsf (neg1);\n+  if (r != 1.0bf16)\n+    abort ();\n+  r = __builtin_copysignf (one, neg0);\n+  if (r != neg1)\n+    abort ();\n+  r = __builtin_copysignf (inf_cst, neg1);\n+  if (r != -huge_val_cst)\n+    abort ();\n+  r = __builtin_copysignf (-inf_cst, one);\n+  if (r != huge_val_cst)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "fa27a774b625e796a3ccfa2721ee80a46f997496", "filename": "gcc/testsuite/gcc.dg/torture/bfloat16-complex.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbfloat16-complex.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,61 @@\n+/* Test __bf16 complex arithmetic.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+/* { dg-add-options bfloat16 } */\n+/* { dg-require-effective-target bfloat16_runtime } */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+volatile __bf16 a = 1.0bf16;\n+typedef _Complex float __cbf16 __attribute__((__mode__(__BC__)));\n+volatile __cbf16 b = __builtin_complex (2.0bf16, 3.0bf16);\n+volatile __cbf16 c = __builtin_complex (2.0bf16, 3.0bf16);\n+volatile __cbf16 d = __builtin_complex (2.0bf16, 3.0bf16);\n+\n+__cbf16\n+fn (__cbf16 arg)\n+{\n+  return arg / 4;\n+}\n+\n+int\n+main (void)\n+{\n+  volatile __cbf16 r;\n+  if (b != c)\n+    abort ();\n+  if (b != d)\n+    abort ();\n+  r = a + b;\n+  if (__real__ r != 3.0bf16 || __imag__ r != 3.0bf16)\n+    abort ();\n+  r += d;\n+  if (__real__ r != 5.0bf16 || __imag__ r != 6.0bf16)\n+    abort ();\n+  r -= a;\n+  if (__real__ r != 4.0bf16 || __imag__ r != 6.0bf16)\n+    abort ();\n+  r /= (a + a);\n+  if (__real__ r != 2.0bf16 || __imag__ r != 3.0bf16)\n+    abort ();\n+  r *= (a + a);\n+  if (__real__ r != 4.0bf16 || __imag__ r != 6.0bf16)\n+    abort ();\n+  r -= b;\n+  if (__real__ r != 2.0bf16 || __imag__ r != 3.0bf16)\n+    abort ();\n+  r *= r;\n+  if (__real__ r != -5.0bf16 || __imag__ r != 12.0bf16)\n+    abort ();\n+  /* Division may not be exact, so round result before comparing.  */\n+  r /= b;\n+  r += __builtin_complex (100.0bf16, 100.0bf16);\n+  r -= __builtin_complex (100.0bf16, 100.0bf16);\n+  if (r != b)\n+    abort ();\n+  r = fn (r);\n+  if (__real__ r != 0.5bf16 || __imag__ r != 0.75bf16)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "60125b2b65678c48d6398b902d7485da79439cb7", "filename": "gcc/testsuite/gcc.dg/torture/builtin-issignaling-1.c", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-issignaling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-issignaling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-issignaling-1.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -4,7 +4,7 @@\n /* Workaround for PR57484 on ia32: */\n /* { dg-additional-options \"-msse2 -mfpmath=sse\" { target { ia32 && sse2_runtime } } } */\n \n-#ifndef EXT\n+#if !defined(EXT) && !defined(TYPE)\n int\n f1 (void)\n {\n@@ -41,31 +41,42 @@ f6 (long double x)\n   return __builtin_issignaling (x);\n }\n #else\n-#define CONCATX(X, Y) X ## Y\n-#define CONCAT(X, Y) CONCATX (X, Y)\n-#define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n-#define CONCAT4(W, X, Y, Z) CONCAT (CONCAT (CONCAT (W, X), Y), Z)\n+#ifndef TYPE\n+# define CONCATX(X, Y) X ## Y\n+# define CONCAT(X, Y) CONCATX (X, Y)\n+# define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n+# define CONCAT4(W, X, Y, Z) CONCAT (CONCAT (CONCAT (W, X), Y), Z)\n \n-#if EXT\n-# define TYPE CONCAT3 (_Float, WIDTH, x)\n-# define CST(C) CONCAT4 (C, f, WIDTH, x)\n-# define FN(F) CONCAT4 (F, f, WIDTH, x)\n-#else\n-# define TYPE CONCAT (_Float, WIDTH)\n-# define CST(C) CONCAT3 (C, f, WIDTH)\n-# define FN(F) CONCAT3 (F, f, WIDTH)\n+# if EXT\n+#  define TYPE CONCAT3 (_Float, WIDTH, x)\n+#  define CST(C) CONCAT4 (C, f, WIDTH, x)\n+#  define FN(F) CONCAT4 (F, f, WIDTH, x)\n+# else\n+#  define TYPE CONCAT (_Float, WIDTH)\n+#  define CST(C) CONCAT3 (C, f, WIDTH)\n+#  define FN(F) CONCAT3 (F, f, WIDTH)\n+# endif\n+#endif\n+#ifndef NANS\n+# define NANS(x) FN (__builtin_nans) (x)\n+#endif\n+#ifndef NAN\n+# define NAN(x) FN (__builtin_nan) (x)\n+#endif\n+#ifndef INF\n+# define INF FN (__builtin_inf) ()\n #endif\n \n int\n f1 (void)\n {\n-  return __builtin_issignaling (FN (__builtin_nans) (\"\"));\n+  return __builtin_issignaling (NANS (\"\"));\n }\n \n int\n f2 (void)\n {\n-  return __builtin_issignaling (FN (__builtin_nan) (\"\"));\n+  return __builtin_issignaling (NAN (\"\"));\n }\n \n int\n@@ -118,10 +129,10 @@ main ()\n   if (!f6 (z))\n     __builtin_abort ();\n #else\n-  if (f4 (w) || !f4 (FN (__builtin_nans) (\"0x123\")) || f4 (CST (42.0)) || f4 (FN (__builtin_nan) (\"0x234\"))\n-      || f4 (FN (__builtin_inf) ()) || f4 (-FN (__builtin_inf) ()) || f4 (CST (-42.0)) || f4 (CST (-0.0)) || f4 (CST (0.0)))\n+  if (f4 (w) || !f4 (NANS (\"0x123\")) || f4 (CST (42.0)) || f4 (NAN (\"0x234\"))\n+      || f4 (INF) || f4 (-INF) || f4 (CST (-42.0)) || f4 (CST (-0.0)) || f4 (CST (0.0)))\n     __builtin_abort ();\n-  w = FN (__builtin_nans) (\"\");\n+  w = NANS (\"\");\n   asm volatile (\"\" : : : \"memory\");\n   if (!f4 (w))\n     __builtin_abort ();"}, {"sha": "6540b530994a795ade11c072a861e9a820cd9eb2", "filename": "gcc/testsuite/gcc.dg/torture/floatn-basic.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-basic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-basic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Ffloatn-basic.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -9,14 +9,16 @@\n #define CONCAT3(X, Y, Z) CONCAT (CONCAT (X, Y), Z)\n #define CONCAT4(W, X, Y, Z) CONCAT (CONCAT (CONCAT (W, X), Y), Z)\n \n-#if EXT\n-# define TYPE CONCAT3 (_Float, WIDTH, x)\n-# define CST(C) CONCAT4 (C, f, WIDTH, x)\n-# define CSTU(C) CONCAT4 (C, F, WIDTH, x)\n-#else\n-# define TYPE CONCAT (_Float, WIDTH)\n-# define CST(C) CONCAT3 (C, f, WIDTH)\n-# define CSTU(C) CONCAT3 (C, F, WIDTH)\n+#ifndef TYPE\n+# if EXT\n+#  define TYPE CONCAT3 (_Float, WIDTH, x)\n+#  define CST(C) CONCAT4 (C, f, WIDTH, x)\n+#  define CSTU(C) CONCAT4 (C, F, WIDTH, x)\n+# else\n+#  define TYPE CONCAT (_Float, WIDTH)\n+#  define CST(C) CONCAT3 (C, f, WIDTH)\n+#  define CSTU(C) CONCAT3 (C, F, WIDTH)\n+# endif\n #endif\n \n extern void exit (int);"}, {"sha": "d1a76db25e9258df0705acad1ad0f749ac548e63", "filename": "gcc/testsuite/gcc.target/i386/sse2-bfloat16-scalar-typecheck.c", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-bfloat16-scalar-typecheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-bfloat16-scalar-typecheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-bfloat16-scalar-typecheck.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -12,8 +12,8 @@ double is_a_double;\n \n float *float_ptr;\n \n-__bf16 foo1 (void) { return (__bf16) 0x1234; } /* { dg-error {invalid conversion to type '__bf16'} } */\n-__bf16 foo2 (void) { return (__bf16) (short) 0x1234; } /* { dg-error {invalid conversion to type '__bf16'} } */\n+__bf16 foo1 (void) { return (__bf16) 0x1234; }\n+__bf16 foo2 (void) { return (__bf16) (short) 0x1234; }\n \n __bf16 footest (__bf16 scalar0)\n {\n@@ -22,87 +22,87 @@ __bf16 footest (__bf16 scalar0)\n \n   __bf16 scalar1_1;\n   __bf16 scalar1_2 = glob_bfloat;\n-  __bf16 scalar1_3 = 0;   /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar1_4 = 0.1; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar1_5 = is_a_float; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar1_6 = is_an_int;  /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar1_7 = is_a_float16; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar1_8 = is_a_double; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar1_9 = is_a_short_int; /* { dg-error {invalid conversion to type '__bf16'} } */\n-\n-  int initi_1_1 = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  float initi_1_2 = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  _Float16 initi_1_3 = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  short initi_1_4 = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  double initi_1_5 = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n+  __bf16 scalar1_3 = 0;\n+  __bf16 scalar1_4 = 0.1;\n+  __bf16 scalar1_5 = is_a_float;\n+  __bf16 scalar1_6 = is_an_int;\n+  __bf16 scalar1_7 = is_a_float16;\n+  __bf16 scalar1_8 = is_a_double;\n+  __bf16 scalar1_9 = is_a_short_int;\n+\n+  int initi_1_1 = glob_bfloat;\n+  float initi_1_2 = glob_bfloat;\n+  _Float16 initi_1_3 = glob_bfloat;\n+  short initi_1_4 = glob_bfloat;\n+  double initi_1_5 = glob_bfloat;\n \n   __bf16 scalar2_1 = {};\n   __bf16 scalar2_2 = { glob_bfloat };\n-  __bf16 scalar2_3 = { 0 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar2_4 = { 0.1 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar2_5 = { is_a_float }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar2_6 = { is_an_int }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar2_7 = { is_a_float16 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar2_8 = { is_a_double }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __bf16 scalar2_9 = { is_a_short_int }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-\n-  int initi_2_1 = { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  float initi_2_2 = { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  _Float16 initi_2_3 = { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  short initi_2_4 = { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  double initi_2_5 = { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n+  __bf16 scalar2_3 = { 0 };\n+  __bf16 scalar2_4 = { 0.1 };\n+  __bf16 scalar2_5 = { is_a_float };\n+  __bf16 scalar2_6 = { is_an_int };\n+  __bf16 scalar2_7 = { is_a_float16 };\n+  __bf16 scalar2_8 = { is_a_double };\n+  __bf16 scalar2_9 = { is_a_short_int };\n+\n+  int initi_2_1 = { glob_bfloat };\n+  float initi_2_2 = { glob_bfloat };\n+  _Float16 initi_2_3 = { glob_bfloat };\n+  short initi_2_4 = { glob_bfloat };\n+  double initi_2_5 = { glob_bfloat };\n \n   /* Assignments.  */\n \n   glob_bfloat = glob_bfloat;\n-  glob_bfloat = 0;   /* { dg-error {invalid conversion to type '__bf16'} } */\n-  glob_bfloat = 0.1; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  glob_bfloat = is_a_float; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  glob_bfloat = is_an_int; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  glob_bfloat = is_a_float16; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  glob_bfloat = is_a_double; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  glob_bfloat = is_a_short_int; /* { dg-error {invalid conversion to type '__bf16'} } */\n-\n-  is_an_int = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  is_a_float = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  is_a_float16 = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  is_a_double = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  is_a_short_int = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n+  glob_bfloat = 0;\n+  glob_bfloat = 0.1;\n+  glob_bfloat = is_a_float;\n+  glob_bfloat = is_an_int;\n+  glob_bfloat = is_a_float16;\n+  glob_bfloat = is_a_double;\n+  glob_bfloat = is_a_short_int;\n+\n+  is_an_int = glob_bfloat;\n+  is_a_float = glob_bfloat;\n+  is_a_float16 = glob_bfloat;\n+  is_a_double = glob_bfloat;\n+  is_a_short_int = glob_bfloat;\n \n   /* Casting.  */\n \n   (void) glob_bfloat;\n   (__bf16) glob_bfloat;\n \n-  (int) glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  (float) glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  (_Float16) glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  (double) glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  (short) glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n+  (int) glob_bfloat;\n+  (float) glob_bfloat;\n+  (_Float16) glob_bfloat;\n+  (double) glob_bfloat;\n+  (short) glob_bfloat;\n \n-  (__bf16) is_an_int; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__bf16) is_a_float; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__bf16) is_a_float16; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__bf16) is_a_double; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__bf16) is_a_short_int; /* { dg-error {invalid conversion to type '__bf16'} } */\n+  (__bf16) is_an_int;\n+  (__bf16) is_a_float;\n+  (__bf16) is_a_float16;\n+  (__bf16) is_a_double;\n+  (__bf16) is_a_short_int;\n \n   /* Compound literals.  */\n \n   (__bf16) {};\n   (__bf16) { glob_bfloat };\n-  (__bf16) { 0 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__bf16) { 0.1 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__bf16) { is_a_float }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__bf16) { is_an_int }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__bf16) { is_a_float16 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__bf16) { is_a_double }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__bf16) { is_a_short_int }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-\n-  (int) { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  (float) { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  (_Float16) { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  (double) { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  (short) { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n+  (__bf16) { 0 };\n+  (__bf16) { 0.1 };\n+  (__bf16) { is_a_float };\n+  (__bf16) { is_an_int };\n+  (__bf16) { is_a_float16 };\n+  (__bf16) { is_a_double };\n+  (__bf16) { is_a_short_int };\n+\n+  (int) { glob_bfloat };\n+  (float) { glob_bfloat };\n+  (_Float16) { glob_bfloat };\n+  (double) { glob_bfloat };\n+  (short) { glob_bfloat };\n \n   /* Arrays and Structs.  */\n \n@@ -145,16 +145,16 @@ __bf16 footest (__bf16 scalar0)\n   bfloat_ptr = &bfloat_ptr3[1];\n \n   /* Simple comparison.  */\n-  scalar0 > glob_bfloat; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  glob_bfloat == scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0 > is_a_float; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  is_a_float == scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0 > 0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  0 == scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0 > 0.1; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  0.1 == scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0 > is_an_int; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  is_an_int == scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  scalar0 > glob_bfloat;\n+  glob_bfloat == scalar0;\n+  scalar0 > is_a_float;\n+  is_a_float == scalar0;\n+  scalar0 > 0;\n+  0 == scalar0;\n+  scalar0 > 0.1;\n+  0.1 == scalar0;\n+  scalar0 > is_an_int;\n+  is_an_int == scalar0;\n \n   /* Pointer comparison.  */\n \n@@ -174,41 +174,41 @@ __bf16 footest (__bf16 scalar0)\n   /* Conditional expressions.  */\n \n   0 ? scalar0 : scalar0;\n-  0 ? scalar0 : is_a_float; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  0 ? is_a_float : scalar0; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  0 ? scalar0 : 0; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  0 ? 0 : scalar0; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  0 ? 0.1 : scalar0; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  0 ? scalar0 : 0.1; /* { dg-error {invalid conversion from type '__bf16'} } */\n+  0 ? scalar0 : is_a_float;\n+  0 ? is_a_float : scalar0;\n+  0 ? scalar0 : 0;\n+  0 ? 0 : scalar0;\n+  0 ? 0.1 : scalar0;\n+  0 ? scalar0 : 0.1;\n   0 ? bfloat_ptr : bfloat_ptr2;\n   0 ? bfloat_ptr : float_ptr; /* { dg-warning {pointer type mismatch in conditional expression} } */\n   0 ? float_ptr : bfloat_ptr; /* { dg-warning {pointer type mismatch in conditional expression} } */\n \n-  scalar0 ? scalar0 : scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0 ? is_a_float : scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0 ? scalar0 : is_a_float; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0 ? is_a_float : is_a_float; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  scalar0 ? scalar0 : scalar0;\n+  scalar0 ? is_a_float : scalar0;\n+  scalar0 ? scalar0 : is_a_float;\n+  scalar0 ? is_a_float : is_a_float;\n \n   /* Unary operators.  */\n \n-  +scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  -scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  ~scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  !scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  +scalar0;\n+  -scalar0;\n+  ~scalar0; /* { dg-error {wrong type argument to bit-complement} } */\n+  !scalar0;\n   *scalar0; /* { dg-error {invalid type argument of unary '\\*'} } */\n-  __real scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  __imag scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  ++scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  --scalar0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0++; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0--; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  __real scalar0;\n+  __imag scalar0;\n+  ++scalar0;\n+  --scalar0;\n+  scalar0++;\n+  scalar0--;\n \n   /* Binary arithmetic operations.  */\n \n-  scalar0 = glob_bfloat + *bfloat_ptr; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0 = glob_bfloat + 0.1; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0 = glob_bfloat + 0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  scalar0 = glob_bfloat + is_a_float; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  scalar0 = glob_bfloat + *bfloat_ptr;\n+  scalar0 = glob_bfloat + 0.1;\n+  scalar0 = glob_bfloat + 0;\n+  scalar0 = glob_bfloat + is_a_float;\n \n   return scalar0;\n }"}, {"sha": "8bc3f4a7b8f27d76203f803c5ede205ed5864f14", "filename": "gcc/testsuite/gcc.target/i386/vect-bfloat16-typecheck_1.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-bfloat16-typecheck_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-bfloat16-typecheck_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-bfloat16-typecheck_1.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -48,20 +48,20 @@ __m128bf16 footest (__m128bf16 vector0)\n   __m128bf16 vector2_1 = {};\n   __m128bf16 vector2_2 = { glob_bfloat };\n   __m128bf16 vector2_3 = { glob_bfloat, glob_bfloat, glob_bfloat, glob_bfloat };\n-  __m128bf16 vector2_4 = { 0 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m128bf16 vector2_5 = { 0.1 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m128bf16 vector2_6 = { is_a_float16 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m128bf16 vector2_7 = { is_a_float }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m128bf16 vector2_8 = { is_an_int }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m128bf16 vector2_9 = { is_a_short_int }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m128bf16 vector2_10 = { 0.0, 0, is_a_short_int, is_a_float }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-\n-  __v8si initi_2_1 = { glob_bfloat };   /* { dg-error {invalid conversion from type '__bf16'} } */\n-  __m256 initi_2_2 = { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  __m128h initi_2_3 = { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  __m128 initi_2_4 = { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  __v4si initi_2_5 = { glob_bfloat };   /* { dg-error {invalid conversion from type '__bf16'} } */\n-  __v4hi initi_2_6 = { glob_bfloat };   /* { dg-error {invalid conversion from type '__bf16'} } */\n+  __m128bf16 vector2_4 = { 0 };\n+  __m128bf16 vector2_5 = { 0.1 };\n+  __m128bf16 vector2_6 = { is_a_float16 };\n+  __m128bf16 vector2_7 = { is_a_float };\n+  __m128bf16 vector2_8 = { is_an_int };\n+  __m128bf16 vector2_9 = { is_a_short_int };\n+  __m128bf16 vector2_10 = { 0.0, 0, is_a_short_int, is_a_float };\n+\n+  __v8si initi_2_1 = { glob_bfloat };\n+  __m256 initi_2_2 = { glob_bfloat };\n+  __m128h initi_2_3 = { glob_bfloat };\n+  __m128 initi_2_4 = { glob_bfloat };\n+  __v4si initi_2_5 = { glob_bfloat };\n+  __v4hi initi_2_6 = { glob_bfloat };\n \n   /* Assignments to/from vectors.  */\n \n@@ -85,25 +85,25 @@ __m128bf16 footest (__m128bf16 vector0)\n   /* Assignments to/from elements.  */\n \n   vector2_3[0] = glob_bfloat;\n-  vector2_3[0] = is_an_int; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  vector2_3[0] = is_a_short_int; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  vector2_3[0] = is_a_float; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  vector2_3[0] = is_a_float16; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  vector2_3[0] = 0; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  vector2_3[0] = 0.1; /* { dg-error {invalid conversion to type '__bf16'} } */\n+  vector2_3[0] = is_an_int;\n+  vector2_3[0] = is_a_short_int;\n+  vector2_3[0] = is_a_float;\n+  vector2_3[0] = is_a_float16;\n+  vector2_3[0] = 0;\n+  vector2_3[0] = 0.1;\n \n   glob_bfloat = vector2_3[0];\n-  is_an_int = vector2_3[0]; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  is_a_short_int = vector2_3[0]; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  is_a_float = vector2_3[0]; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  is_a_float16 = vector2_3[0]; /* { dg-error {invalid conversion from type '__bf16'} } */\n+  is_an_int = vector2_3[0];\n+  is_a_short_int = vector2_3[0];\n+  is_a_float = vector2_3[0];\n+  is_a_float16 = vector2_3[0];\n \n   /* Compound literals.  */\n \n   (__m128bf16) {};\n \n-  (__m128bf16) { 0 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__m128bf16) { 0.1 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n+  (__m128bf16) { 0 };\n+  (__m128bf16) { 0.1 };\n   (__m128bf16) { is_a_float_vec }; /* { dg-error {incompatible types when initializing type '__bf16' using type '__m256'} } */\n   (__m128bf16) { is_an_int_vec }; /* { dg-error {incompatible types when initializing type '__bf16' using type '__v8si'} } */\n   (__m128bf16) { is_a_float_pair }; /* { dg-error {incompatible types when initializing type '__bf16' using type '__m128'} } */\n@@ -186,16 +186,16 @@ __m128bf16 footest (__m128bf16 vector0)\n   bfloat_ptr = &bfloat_ptr3[1];\n \n   /* Simple comparison.  */\n-  vector0 > glob_bfloat_vec; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  glob_bfloat_vec == vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 > is_a_float_vec; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  is_a_float_vec == vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 > 0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  0 == vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 > 0.1; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  0.1 == vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 > is_an_int_vec; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  is_an_int_vec == vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  vector0 > glob_bfloat_vec;\n+  glob_bfloat_vec == vector0;\n+  vector0 > is_a_float_vec; /* { dg-error {comparing vectors with different element types} } */\n+  is_a_float_vec == vector0; /* { dg-error {comparing vectors with different element types} } */\n+  vector0 > 0;\n+  0 == vector0;\n+  vector0 > 0.1; /* { dg-error {conversion of scalar 'double' to vector '__m128bf16'} } */\n+  0.1 == vector0; /* { dg-error {conversion of scalar 'double' to vector '__m128bf16'} } */\n+  vector0 > is_an_int_vec; /* { dg-error {comparing vectors with different element types} } */\n+  is_an_int_vec == vector0; /* { dg-error {comparing vectors with different element types} } */\n \n   /* Pointer comparison.  */\n \n@@ -234,24 +234,24 @@ __m128bf16 footest (__m128bf16 vector0)\n \n   /* Unary operators.  */\n \n-  +vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  -vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  ~vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  !vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  +vector0;\n+  -vector0;\n+  ~vector0; /* { dg-error {wrong type argument to bit-complement} } */\n+  !vector0; /* { dg-error {wrong type argument to unary exclamation mark} } */\n   *vector0; /* { dg-error {invalid type argument of unary '\\*'} } */\n-  __real vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  __imag vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  ++vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  --vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0++; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0--; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  __real vector0; /* { dg-error {wrong type argument to __real} } */\n+  __imag vector0; /* { dg-error {wrong type argument to __imag} } */\n+  ++vector0;\n+  --vector0;\n+  vector0++;\n+  vector0--;\n \n   /* Binary arithmetic operations.  */\n \n-  vector0 = glob_bfloat_vec + *bfloat_ptr; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 = glob_bfloat_vec + 0.1; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 = glob_bfloat_vec + 0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 = glob_bfloat_vec + is_a_float_vec; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  vector0 = glob_bfloat_vec + *bfloat_ptr;\n+  vector0 = glob_bfloat_vec + 0.1; /* { dg-error {conversion of scalar 'double' to vector '__m128bf16'} } */\n+  vector0 = glob_bfloat_vec + 0;\n+  vector0 = glob_bfloat_vec + is_a_float_vec; /* { dg-error {invalid operands to binary \\+} } */\n \n   return vector0;\n }"}, {"sha": "2a8a535daae9574284a76cc3f4fe4fbd01425383", "filename": "gcc/testsuite/gcc.target/i386/vect-bfloat16-typecheck_2.c", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-bfloat16-typecheck_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-bfloat16-typecheck_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-bfloat16-typecheck_2.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -45,19 +45,19 @@ __m256bf16 footest (__m256bf16 vector0)\n   __m256bf16 vector2_1 = {};\n   __m256bf16 vector2_2 = { glob_bfloat };\n   __m256bf16 vector2_3 = { glob_bfloat, glob_bfloat, glob_bfloat, glob_bfloat };\n-  __m256bf16 vector2_4 = { 0 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m256bf16 vector2_5 = { 0.1 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m256bf16 vector2_6 = { is_a_float16 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m256bf16 vector2_7 = { is_a_float }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m256bf16 vector2_8 = { is_an_int }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m256bf16 vector2_9 = { is_a_short_int }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  __m256bf16 vector2_10 = { 0.0, 0, is_a_short_int, is_a_float }; /* { dg-error \"invalid conversion to type '__bf16'\" } */\n-\n-  __v8si initi_2_1 = { glob_bfloat };   /* { dg-error {invalid conversion from type '__bf16'} } */\n-  __m256 initi_2_2 = { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  __m256h initi_2_3 = { glob_bfloat }; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  __m256i initi_2_5 = { glob_bfloat };   /* { dg-error {invalid conversion from type '__bf16'} } */\n-  __v16hi initi_2_6 = { glob_bfloat };   /* { dg-error {invalid conversion from type '__bf16'} } */\n+  __m256bf16 vector2_4 = { 0 };\n+  __m256bf16 vector2_5 = { 0.1 };\n+  __m256bf16 vector2_6 = { is_a_float16 };\n+  __m256bf16 vector2_7 = { is_a_float };\n+  __m256bf16 vector2_8 = { is_an_int };\n+  __m256bf16 vector2_9 = { is_a_short_int };\n+  __m256bf16 vector2_10 = { 0.0, 0, is_a_short_int, is_a_float };\n+\n+  __v8si initi_2_1 = { glob_bfloat };\n+  __m256 initi_2_2 = { glob_bfloat };\n+  __m256h initi_2_3 = { glob_bfloat };\n+  __m256i initi_2_5 = { glob_bfloat };\n+  __v16hi initi_2_6 = { glob_bfloat };\n \n   /* Assignments to/from vectors.  */\n \n@@ -79,25 +79,25 @@ __m256bf16 footest (__m256bf16 vector0)\n   /* Assignments to/from elements.  */\n \n   vector2_3[0] = glob_bfloat;\n-  vector2_3[0] = is_an_int; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  vector2_3[0] = is_a_short_int; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  vector2_3[0] = is_a_float; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  vector2_3[0] = is_a_float16; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  vector2_3[0] = 0; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  vector2_3[0] = 0.1; /* { dg-error {invalid conversion to type '__bf16'} } */\n+  vector2_3[0] = is_an_int;\n+  vector2_3[0] = is_a_short_int;\n+  vector2_3[0] = is_a_float;\n+  vector2_3[0] = is_a_float16;\n+  vector2_3[0] = 0;\n+  vector2_3[0] = 0.1;\n \n   glob_bfloat = vector2_3[0];\n-  is_an_int = vector2_3[0]; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  is_a_short_int = vector2_3[0]; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  is_a_float = vector2_3[0]; /* { dg-error {invalid conversion from type '__bf16'} } */\n-  is_a_float16 = vector2_3[0]; /* { dg-error {invalid conversion from type '__bf16'} } */\n+  is_an_int = vector2_3[0];\n+  is_a_short_int = vector2_3[0];\n+  is_a_float = vector2_3[0];\n+  is_a_float16 = vector2_3[0];\n \n   /* Compound literals.  */\n \n   (__m256bf16) {};\n \n-  (__m256bf16) { 0 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n-  (__m256bf16) { 0.1 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n+  (__m256bf16) { 0 };\n+  (__m256bf16) { 0.1 };\n   (__m256bf16) { is_a_float_vec }; /* { dg-error {incompatible types when initializing type '__bf16' using type '__m256'} } */\n   (__m256bf16) { is_an_int_vec }; /* { dg-error {incompatible types when initializing type '__bf16' using type '__v8si'} } */\n   (__m256bf16) { is_a_long_int_pair }; /* { dg-error {incompatible types when initializing type '__bf16' using type '__m256i'} } */\n@@ -176,16 +176,16 @@ __m256bf16 footest (__m256bf16 vector0)\n   bfloat_ptr = &bfloat_ptr3[1];\n \n   /* Simple comparison.  */\n-  vector0 > glob_bfloat_vec; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  glob_bfloat_vec == vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 > is_a_float_vec; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  is_a_float_vec == vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 > 0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  0 == vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 > 0.1; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  0.1 == vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 > is_an_int_vec; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  is_an_int_vec == vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  vector0 > glob_bfloat_vec;\n+  glob_bfloat_vec == vector0;\n+  vector0 > is_a_float_vec; /* { dg-error {comparing vectors with different element types} } */\n+  is_a_float_vec == vector0; /* { dg-error {comparing vectors with different element types} } */\n+  vector0 > 0;\n+  0 == vector0;\n+  vector0 > 0.1; /* { dg-error {conversion of scalar 'double' to vector '__m256bf16'} } */\n+  0.1 == vector0; /* { dg-error {conversion of scalar 'double' to vector '__m256bf16'} } */\n+  vector0 > is_an_int_vec; /* { dg-error {comparing vectors with different element types} } */\n+  is_an_int_vec == vector0; /* { dg-error {comparing vectors with different element types} } */\n \n   /* Pointer comparison.  */\n \n@@ -224,24 +224,24 @@ __m256bf16 footest (__m256bf16 vector0)\n \n   /* Unary operators.  */\n \n-  +vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  -vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  ~vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  !vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  +vector0;\n+  -vector0;\n+  ~vector0; /* { dg-error {wrong type argument to bit-complement} } */\n+  !vector0; /* { dg-error {wrong type argument to unary exclamation mark} } */\n   *vector0; /* { dg-error {invalid type argument of unary '\\*'} } */\n-  __real vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  __imag vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  ++vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  --vector0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0++; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0--; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  __real vector0; /* { dg-error {wrong type argument to __real} } */\n+  __imag vector0; /* { dg-error {wrong type argument to __imag} } */\n+  ++vector0;\n+  --vector0;\n+  vector0++;\n+  vector0--;\n \n   /* Binary arithmetic operations.  */\n \n-  vector0 = glob_bfloat_vec + *bfloat_ptr; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 = glob_bfloat_vec + 0.1; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 = glob_bfloat_vec + 0; /* { dg-error {operation not permitted on type '__bf16'} } */\n-  vector0 = glob_bfloat_vec + is_a_float_vec; /* { dg-error {operation not permitted on type '__bf16'} } */\n+  vector0 = glob_bfloat_vec + *bfloat_ptr;\n+  vector0 = glob_bfloat_vec + 0.1; /* { dg-error {conversion of scalar 'double' to vector '__m256bf16'} } */\n+  vector0 = glob_bfloat_vec + 0;\n+  vector0 = glob_bfloat_vec + is_a_float_vec; /* { dg-error {invalid operands to binary \\+} } */\n \n   return vector0;\n }"}, {"sha": "8d45bc2427f34c6f1c5e8071d940d481b9047b2f", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -3416,6 +3416,22 @@ proc check_effective_target_base_quadfloat_support { } {\n     return 1\n }\n \n+# Return 1 if the target supports the __bf16 type, 0 otherwise.\n+\n+proc check_effective_target_bfloat16 {} {\n+    return [check_no_compiler_messages_nocache bfloat16 object {\n+\t__bf16 foo (__bf16 x) { return x + x; }\n+    } [add_options_for_bfloat16 \"\"]]\n+}\n+\n+proc check_effective_target_bfloat16_runtime {} {\n+    return [check_effective_target_bfloat16]\n+}\n+\n+proc add_options_for_bfloat16 { flags } {\n+    return \"$flags\"\n+}\n+\n # Return 1 if the target supports all four forms of fused multiply-add\n # (fma, fms, fnma, and fnms) for both float and double.\n "}, {"sha": "80b886cc3e4c924b0d3d06131eb4a8b589c443e6", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -665,6 +665,9 @@ enum tree_index {\n   TI_DOUBLE_TYPE,\n   TI_LONG_DOUBLE_TYPE,\n \n+  /* __bf16 type if supported (used in C++ as std::bfloat16_t).  */\n+  TI_BFLOAT16_TYPE,\n+\n   /* The _FloatN and _FloatNx types must be consecutive, and in the\n      same sequence as the corresponding complex types, which must also\n      be consecutive; _FloatN must come before _FloatNx; the order must"}, {"sha": "81a6ceaf1813832a3db37b11018895faa5c26294", "filename": "gcc/tree.cc", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -7711,7 +7711,7 @@ excess_precision_type (tree type)\n     = (flag_excess_precision == EXCESS_PRECISION_FAST\n        ? EXCESS_PRECISION_TYPE_FAST\n        : (flag_excess_precision == EXCESS_PRECISION_FLOAT16\n-\t  ? EXCESS_PRECISION_TYPE_FLOAT16 :EXCESS_PRECISION_TYPE_STANDARD));\n+\t  ? EXCESS_PRECISION_TYPE_FLOAT16 : EXCESS_PRECISION_TYPE_STANDARD));\n \n   enum flt_eval_method target_flt_eval_method\n     = targetm.c.excess_precision (requested_type);\n@@ -7736,6 +7736,9 @@ excess_precision_type (tree type)\n   machine_mode float16_type_mode = (float16_type_node\n \t\t\t\t    ? TYPE_MODE (float16_type_node)\n \t\t\t\t    : VOIDmode);\n+  machine_mode bfloat16_type_mode = (bfloat16_type_node\n+\t\t\t\t     ? TYPE_MODE (bfloat16_type_node)\n+\t\t\t\t     : VOIDmode);\n   machine_mode float_type_mode = TYPE_MODE (float_type_node);\n   machine_mode double_type_mode = TYPE_MODE (double_type_node);\n \n@@ -7747,16 +7750,19 @@ excess_precision_type (tree type)\n \tswitch (target_flt_eval_method)\n \t  {\n \t  case FLT_EVAL_METHOD_PROMOTE_TO_FLOAT:\n-\t    if (type_mode == float16_type_mode)\n+\t    if (type_mode == float16_type_mode\n+\t\t|| type_mode == bfloat16_type_mode)\n \t      return float_type_node;\n \t    break;\n \t  case FLT_EVAL_METHOD_PROMOTE_TO_DOUBLE:\n \t    if (type_mode == float16_type_mode\n+\t\t|| type_mode == bfloat16_type_mode\n \t\t|| type_mode == float_type_mode)\n \t      return double_type_node;\n \t    break;\n \t  case FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE:\n \t    if (type_mode == float16_type_mode\n+\t\t|| type_mode == bfloat16_type_mode\n \t\t|| type_mode == float_type_mode\n \t\t|| type_mode == double_type_mode)\n \t      return long_double_type_node;\n@@ -7774,16 +7780,19 @@ excess_precision_type (tree type)\n \tswitch (target_flt_eval_method)\n \t  {\n \t  case FLT_EVAL_METHOD_PROMOTE_TO_FLOAT:\n-\t    if (type_mode == float16_type_mode)\n+\t    if (type_mode == float16_type_mode\n+\t\t|| type_mode == bfloat16_type_mode)\n \t      return complex_float_type_node;\n \t    break;\n \t  case FLT_EVAL_METHOD_PROMOTE_TO_DOUBLE:\n \t    if (type_mode == float16_type_mode\n+\t\t|| type_mode == bfloat16_type_mode\n \t\t|| type_mode == float_type_mode)\n \t      return complex_double_type_node;\n \t    break;\n \t  case FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE:\n \t    if (type_mode == float16_type_mode\n+\t\t|| type_mode == bfloat16_type_mode\n \t\t|| type_mode == float_type_mode\n \t\t|| type_mode == double_type_mode)\n \t      return complex_long_double_type_node;\n@@ -9462,6 +9471,17 @@ build_common_tree_nodes (bool signed_char)\n       SET_TYPE_MODE (FLOATN_NX_TYPE_NODE (i), mode);\n     }\n   float128t_type_node = float128_type_node;\n+#ifdef HAVE_BFmode\n+  if (REAL_MODE_FORMAT (BFmode) == &arm_bfloat_half_format\n+      && targetm.scalar_mode_supported_p (BFmode)\n+      && targetm.libgcc_floating_mode_supported_p (BFmode))\n+    {\n+      bfloat16_type_node = make_node (REAL_TYPE);\n+      TYPE_PRECISION (bfloat16_type_node) = GET_MODE_PRECISION (BFmode);\n+      layout_type (bfloat16_type_node);\n+      SET_TYPE_MODE (bfloat16_type_node, BFmode);\n+    }\n+#endif\n \n   float_ptr_type_node = build_pointer_type (float_type_node);\n   double_ptr_type_node = build_pointer_type (double_type_node);"}, {"sha": "9af971cf401f40a80eef524ee9d5675f5bb6654d", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -4291,6 +4291,7 @@ tree_strip_any_location_wrapper (tree exp)\n #define float_type_node\t\t\tglobal_trees[TI_FLOAT_TYPE]\n #define double_type_node\t\tglobal_trees[TI_DOUBLE_TYPE]\n #define long_double_type_node\t\tglobal_trees[TI_LONG_DOUBLE_TYPE]\n+#define bfloat16_type_node\t\tglobal_trees[TI_BFLOAT16_TYPE]\n \n /* Nodes for particular _FloatN and _FloatNx types in sequence.  */\n #define FLOATN_TYPE_NODE(IDX)\t\tglobal_trees[TI_FLOATN_TYPE_FIRST + (IDX)]"}, {"sha": "5ee28c4c853a772d6b3766798adf9eab0c921c2a", "filename": "libcpp/expr.cc", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libcpp%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libcpp%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.cc?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -91,10 +91,10 @@ interpret_float_suffix (cpp_reader *pfile, const uchar *s, size_t len)\n   size_t orig_len = len;\n   const uchar *orig_s = s;\n   size_t flags;\n-  size_t f, d, l, w, q, i, fn, fnx, fn_bits;\n+  size_t f, d, l, w, q, i, fn, fnx, fn_bits, bf16;\n \n   flags = 0;\n-  f = d = l = w = q = i = fn = fnx = fn_bits = 0;\n+  f = d = l = w = q = i = fn = fnx = fn_bits = bf16 = 0;\n \n   /* The following decimal float suffixes, from TR 24732:2009, TS\n      18661-2:2015 and C2X, are supported:\n@@ -131,7 +131,8 @@ interpret_float_suffix (cpp_reader *pfile, const uchar *s, size_t len)\n      w, W - machine-specific type such as __float80 (GNU extension).\n      q, Q - machine-specific type such as __float128 (GNU extension).\n      fN, FN - _FloatN (TS 18661-3:2015).\n-     fNx, FNx - _FloatNx (TS 18661-3:2015).  */\n+     fNx, FNx - _FloatNx (TS 18661-3:2015).\n+     bf16, BF16 - std::bfloat16_t (ISO C++23).  */\n \n   /* Process decimal float suffixes, which are two letters starting\n      with d or D.  Order and case are significant.  */\n@@ -239,6 +240,19 @@ interpret_float_suffix (cpp_reader *pfile, const uchar *s, size_t len)\n \t\tfn++;\n \t    }\n \t  break;\n+\tcase 'b': case 'B':\n+\t  if (len > 2\n+\t      /* Except for bf16 / BF16 where case is significant.  */\n+\t      && s[1] == (s[0] == 'b' ? 'f' : 'F')\n+\t      && s[2] == '1'\n+\t      && s[3] == '6')\n+\t    {\n+\t      bf16++;\n+\t      len -= 3;\n+\t      s += 3;\n+\t      break;\n+\t    }\n+\t  return 0;\n \tcase 'd': case 'D': d++; break;\n \tcase 'l': case 'L': l++; break;\n \tcase 'w': case 'W': w++; break;\n@@ -257,7 +271,7 @@ interpret_float_suffix (cpp_reader *pfile, const uchar *s, size_t len)\n      of N larger than can be represented in the return value.  The\n      caller is responsible for rejecting _FloatN suffixes where\n      _FloatN is not supported on the chosen target.  */\n-  if (f + d + l + w + q + fn + fnx > 1 || i > 1)\n+  if (f + d + l + w + q + fn + fnx + bf16 > 1 || i > 1)\n     return 0;\n   if (fn_bits > CPP_FLOATN_MAX)\n     return 0;\n@@ -295,6 +309,7 @@ interpret_float_suffix (cpp_reader *pfile, const uchar *s, size_t len)\n \t     q ? CPP_N_MD_Q :\n \t     fn ? CPP_N_FLOATN | (fn_bits << CPP_FLOATN_SHIFT) :\n \t     fnx ? CPP_N_FLOATNX | (fn_bits << CPP_FLOATN_SHIFT) :\n+\t     bf16 ? CPP_N_BFLOAT16 :\n \t     CPP_N_DEFAULT));\n }\n "}, {"sha": "e97993e04bcb8ed0528b8a9269bf71253cf638c0", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -1275,6 +1275,7 @@ struct cpp_num\n #define CPP_N_USERDEF\t0x1000000 /* C++11 user-defined literal.  */\n \n #define CPP_N_SIZE_T\t0x2000000 /* C++23 size_t literal.  */\n+#define CPP_N_BFLOAT16\t0x4000000 /* std::bfloat16_t type.  */\n \n #define CPP_N_WIDTH_FLOATN_NX\t0xF0000000 /* _FloatN / _FloatNx value\n \t\t\t\t\t      of N, divided by 16.  */"}, {"sha": "7b59ff5b9096afb4d5ab0b465a7c43a0e3478427", "filename": "libgcc/config/i386/32/sfp-machine.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fconfig%2Fi386%2F32%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fconfig%2Fi386%2F32%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2F32%2Fsfp-machine.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -87,6 +87,7 @@\n #define _FP_DIV_MEAT_Q(R,X,Y)   _FP_DIV_MEAT_4_udiv(Q,R,X,Y)\n \n #define _FP_NANFRAC_H\t\t_FP_QNANBIT_H\n+#define _FP_NANFRAC_B\t\t_FP_QNANBIT_B\n #define _FP_NANFRAC_S\t\t_FP_QNANBIT_S\n #define _FP_NANFRAC_D\t\t_FP_QNANBIT_D, 0\n /* Even if XFmode is 12byte,  we have to pad it to"}, {"sha": "1c8e8a5024072fd5d17e0151763781355f579e5c", "filename": "libgcc/config/i386/64/sfp-machine.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fconfig%2Fi386%2F64%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fconfig%2Fi386%2F64%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2F64%2Fsfp-machine.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -14,6 +14,7 @@ typedef unsigned int UTItype __attribute__ ((mode (TI)));\n #define _FP_DIV_MEAT_Q(R,X,Y)   _FP_DIV_MEAT_2_udiv(Q,R,X,Y)\n \n #define _FP_NANFRAC_H\t\t_FP_QNANBIT_H\n+#define _FP_NANFRAC_B\t\t_FP_QNANBIT_B\n #define _FP_NANFRAC_S\t\t_FP_QNANBIT_S\n #define _FP_NANFRAC_D\t\t_FP_QNANBIT_D\n #define _FP_NANFRAC_E\t\t_FP_QNANBIT_E, 0"}, {"sha": "64c07d4f4c32c91fff403c6a3015efd832203bee", "filename": "libgcc/config/i386/libgcc-glibc.ver", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fconfig%2Fi386%2Flibgcc-glibc.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fconfig%2Fi386%2Flibgcc-glibc.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Flibgcc-glibc.ver?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -214,3 +214,13 @@ GCC_12.0.0 {\n   __trunctfhf2\n   __truncxfhf2\n }\n+\n+%inherit GCC_13.0.0 GCC_12.0.0\n+GCC_13.0.0 {\n+  __extendbfsf2\n+  __truncdfbf2\n+  __truncsfbf2\n+  __trunctfbf2\n+  __truncxfbf2\n+  __trunchfbf2\n+}"}, {"sha": "cc20c2c5f3eb385fbb5b3e791141c2963dc0937a", "filename": "libgcc/config/i386/sfp-machine.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fconfig%2Fi386%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fconfig%2Fi386%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fsfp-machine.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -18,6 +18,7 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n #define _FP_QNANNEGATEDP 0\n \n #define _FP_NANSIGN_H\t\t1\n+#define _FP_NANSIGN_B\t\t1\n #define _FP_NANSIGN_S\t\t1\n #define _FP_NANSIGN_D\t\t1\n #define _FP_NANSIGN_E\t\t1"}, {"sha": "69d0f8198229263f0b0f9ea80843de1c44b28eeb", "filename": "libgcc/config/i386/t-softfp", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fconfig%2Fi386%2Ft-softfp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fconfig%2Fi386%2Ft-softfp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ft-softfp?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -6,20 +6,27 @@ LIB2FUNCS_EXCLUDE += $(libgcc2-hf-functions)\n libgcc2-hf-extras = $(addsuffix .c, $(libgcc2-hf-functions))\n LIB2ADD += $(addprefix $(srcdir)/config/i386/, $(libgcc2-hf-extras))\n \n-softfp_extensions := hfsf hfdf hftf hfxf sfdf sftf dftf xftf\n-softfp_truncations := tfhf xfhf dfhf sfhf tfsf dfsf tfdf tfxf\n+softfp_extensions := hfsf hfdf hftf hfxf sfdf sftf dftf xftf bfsf\n+softfp_truncations := tfhf xfhf dfhf sfhf tfsf dfsf tfdf tfxf \\\n+\t\t      tfbf xfbf dfbf sfbf hfbf\n \n softfp_extras += eqhf2\n \n CFLAGS-extendhfsf2.c += -msse2\n CFLAGS-extendhfdf2.c += -msse2\n CFLAGS-extendhftf2.c += -msse2\n CFLAGS-extendhfxf2.c += -msse2\n+CFLAGS-extendbfsf2.c += -msse2\n \n CFLAGS-truncsfhf2.c += -msse2\n CFLAGS-truncdfhf2.c += -msse2\n CFLAGS-truncxfhf2.c += -msse2\n CFLAGS-trunctfhf2.c += -msse2\n+CFLAGS-truncsfbf2.c += -msse2\n+CFLAGS-truncdfbf2.c += -msse2\n+CFLAGS-truncxfbf2.c += -msse2\n+CFLAGS-trunctfbf2.c += -msse2\n+CFLAGS-trunchfbf2.c += -msse2\n \n CFLAGS-eqhf2.c += -msse2\n CFLAGS-_divhc3.c += -msse2"}, {"sha": "c8563ef8897e28dea3f26226eed9251ab9e57d5a", "filename": "libgcc/soft-fp/brain.h", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Fbrain.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Fbrain.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fbrain.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,172 @@\n+/* Software floating-point emulation.\n+   Definitions for Brain Floating Point format (bfloat16).\n+   Copyright (C) 1997-2022 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <https://www.gnu.org/licenses/>.  */\n+\n+#ifndef SOFT_FP_BRAIN_H\n+#define SOFT_FP_BRAIN_H\t1\n+\n+#if _FP_W_TYPE_SIZE < 32\n+# error \"Here's a nickel kid.  Go buy yourself a real computer.\"\n+#endif\n+\n+#define _FP_FRACTBITS_B\t\t(_FP_W_TYPE_SIZE)\n+\n+#define _FP_FRACTBITS_DW_B\t(_FP_W_TYPE_SIZE)\n+\n+#define _FP_FRACBITS_B\t\t8\n+#define _FP_FRACXBITS_B\t\t(_FP_FRACTBITS_B - _FP_FRACBITS_B)\n+#define _FP_WFRACBITS_B\t\t(_FP_WORKBITS + _FP_FRACBITS_B)\n+#define _FP_WFRACXBITS_B\t(_FP_FRACTBITS_B - _FP_WFRACBITS_B)\n+#define _FP_EXPBITS_B\t\t8\n+#define _FP_EXPBIAS_B\t\t127\n+#define _FP_EXPMAX_B\t\t255\n+\n+#define _FP_QNANBIT_B\t\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_B-2))\n+#define _FP_QNANBIT_SH_B\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_B-2+_FP_WORKBITS))\n+#define _FP_IMPLBIT_B\t\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_B-1))\n+#define _FP_IMPLBIT_SH_B\t((_FP_W_TYPE) 1 << (_FP_FRACBITS_B-1+_FP_WORKBITS))\n+#define _FP_OVERFLOW_B\t\t((_FP_W_TYPE) 1 << (_FP_WFRACBITS_B))\n+\n+#define _FP_WFRACBITS_DW_B\t(2 * _FP_WFRACBITS_B)\n+#define _FP_WFRACXBITS_DW_B\t(_FP_FRACTBITS_DW_B - _FP_WFRACBITS_DW_B)\n+#define _FP_HIGHBIT_DW_B\t\\\n+  ((_FP_W_TYPE) 1 << (_FP_WFRACBITS_DW_B - 1) % _FP_W_TYPE_SIZE)\n+\n+/* The implementation of _FP_MUL_MEAT_B and _FP_DIV_MEAT_B should be\n+   chosen by the target machine.  */\n+\n+typedef float BFtype __attribute__ ((mode (BF)));\n+\n+union _FP_UNION_B\n+{\n+  BFtype flt;\n+  struct _FP_STRUCT_LAYOUT\n+  {\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+    unsigned sign : 1;\n+    unsigned exp  : _FP_EXPBITS_B;\n+    unsigned frac : _FP_FRACBITS_B - (_FP_IMPLBIT_B != 0);\n+#else\n+    unsigned frac : _FP_FRACBITS_B - (_FP_IMPLBIT_B != 0);\n+    unsigned exp  : _FP_EXPBITS_B;\n+    unsigned sign : 1;\n+#endif\n+  } bits;\n+};\n+\n+#define FP_DECL_B(X)\t\t_FP_DECL (1, X)\n+#define FP_UNPACK_RAW_B(X, val)\t_FP_UNPACK_RAW_1 (B, X, (val))\n+#define FP_UNPACK_RAW_BP(X, val)\t_FP_UNPACK_RAW_1_P (B, X, (val))\n+#define FP_PACK_RAW_B(val, X)\t_FP_PACK_RAW_1 (B, (val), X)\n+#define FP_PACK_RAW_BP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_1_P (B, (val), X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_UNPACK_B(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1 (B, X, (val));\t\t\\\n+      _FP_UNPACK_CANONICAL (B, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_UNPACK_BP(X, val)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1_P (B, X, (val));\t\t\\\n+      _FP_UNPACK_CANONICAL (B, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_UNPACK_SEMIRAW_B(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1 (B, X, (val));\t\t\\\n+      _FP_UNPACK_SEMIRAW (B, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_UNPACK_SEMIRAW_BP(X, val)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_UNPACK_RAW_1_P (B, X, (val));\t\t\\\n+      _FP_UNPACK_SEMIRAW (B, 1, X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_PACK_B(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (B, 1, X);\t\t\\\n+      _FP_PACK_RAW_1 (B, (val), X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_PACK_BP(val, X)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_CANONICAL (B, 1, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_1_P (B, (val), X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_PACK_SEMIRAW_B(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (B, 1, X);\t\t\\\n+      _FP_PACK_RAW_1 (B, (val), X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_PACK_SEMIRAW_BP(val, X)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      _FP_PACK_SEMIRAW (B, 1, X);\t\t\\\n+      if (!FP_INHIBIT_RESULTS)\t\t\t\\\n+\t_FP_PACK_RAW_1_P (B, (val), X);\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define FP_TO_INT_B(r, X, rsz, rsg)\t_FP_TO_INT (B, 1, (r), X, (rsz), (rsg))\n+#define FP_TO_INT_ROUND_B(r, X, rsz, rsg)\t\\\n+  _FP_TO_INT_ROUND (B, 1, (r), X, (rsz), (rsg))\n+#define FP_FROM_INT_B(X, r, rs, rt)\t_FP_FROM_INT (B, 1, X, (r), (rs), rt)\n+\n+/* BFmode arithmetic is not implemented.  */\n+\n+#define _FP_FRAC_HIGH_B(X)\t_FP_FRAC_HIGH_1 (X)\n+#define _FP_FRAC_HIGH_RAW_B(X)\t_FP_FRAC_HIGH_1 (X)\n+#define _FP_FRAC_HIGH_DW_B(X)\t_FP_FRAC_HIGH_1 (X)\n+\n+#define FP_CMP_EQ_B(r, X, Y, ex)       _FP_CMP_EQ (B, 1, (r), X, Y, (ex))\n+\n+#endif /* !SOFT_FP_BRAIN_H */"}, {"sha": "c534a413ee6dfa7fc327d63820ec081b8784b6c6", "filename": "libgcc/soft-fp/extendbfsf2.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Fextendbfsf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Fextendbfsf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Fextendbfsf2.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,49 @@\n+/* Software floating-point emulation.\n+   Return an bfloat16 converted to IEEE single\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define FP_NO_EXACT_UNDERFLOW\n+#include \"soft-fp.h\"\n+#include \"brain.h\"\n+#include \"single.h\"\n+\n+SFtype\n+__extendbfsf2 (BFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_B (A);\n+  FP_DECL_S (R);\n+  SFtype r;\n+\n+  FP_INIT_EXCEPTIONS;\n+  FP_UNPACK_RAW_B (A, a);\n+  FP_EXTEND (S, B, 1, 1, R, A);\n+  FP_PACK_RAW_S (r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "6b6e6b4fa65abd38ec527eb306f4db217cf282ff", "filename": "libgcc/soft-fp/truncbfhf2.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftruncbfhf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftruncbfhf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ftruncbfhf2.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,75 @@\n+/* Software floating-point emulation.\n+   Truncate bfloat16 into IEEE half.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"soft-fp.h\"\n+#include \"half.h\"\n+#include \"brain.h\"\n+#include \"single.h\"\n+\n+/* BFtype and HFtype are unordered, neither is a superset or subset\n+   of each other.  Convert BFtype to SFtype (lossless) and then\n+   truncate to HFtype.  */\n+\n+HFtype\n+__truncbfhf2 (BFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_H (A);\n+  FP_DECL_S (B);\n+  FP_DECL_B (R);\n+  SFtype b;\n+  HFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  /* Optimize BFtype to SFtype conversion to simple left shift\n+     by 16 if possible, we don't need to raise exceptions on sNaN\n+     here as the SFtype to HFtype truncation should do that too.  */\n+  if (sizeof (BFtype) == 2\n+      && sizeof (unsigned short) == 2\n+      && sizeof (SFtype) == 4\n+      && sizeof (unsigned int) == 4)\n+    {\n+      union { BFtype a; unsigned short b; } u1;\n+      union { SFtype a; unsigned int b; } u2;\n+      u1.a = a;\n+      u2.b = (u1.b << 8) << 8;\n+      b = u2.a;\n+    }\n+  else\n+    {\n+      FP_UNPACK_RAW_B (A, a);\n+      FP_EXTEND (S, B, 1, 1, B, A);\n+      FP_PACK_RAW_S (b, B);\n+    }\n+  FP_UNPACK_SEMIRAW_S (B, b);\n+  FP_TRUNC (H, S, 1, 1, R, B);\n+  FP_PACK_SEMIRAW_H (r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "dfa0b2635140fd9d88a10ad2ac16fee9cef81906", "filename": "libgcc/soft-fp/truncdfbf2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftruncdfbf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftruncdfbf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ftruncdfbf2.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,52 @@\n+/* Software floating-point emulation.\n+   Truncate IEEE double into bfloat16.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"soft-fp.h\"\n+#include \"brain.h\"\n+#include \"double.h\"\n+\n+BFtype\n+__truncdfbf2 (DFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_D (A);\n+  FP_DECL_B (R);\n+  BFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_D (A, a);\n+#if _FP_W_TYPE_SIZE < _FP_FRACBITS_D\n+  FP_TRUNC (B, D, 1, 2, R, A);\n+#else\n+  FP_TRUNC (B, D, 1, 1, R, A);\n+#endif\n+  FP_PACK_SEMIRAW_B (r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "f3d650123ef7f8122103ecdceb37dcd3bce2673f", "filename": "libgcc/soft-fp/trunchfbf2.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftrunchfbf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftrunchfbf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ftrunchfbf2.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,58 @@\n+/* Software floating-point emulation.\n+   Truncate IEEE half into bfloat16.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"soft-fp.h\"\n+#include \"brain.h\"\n+#include \"half.h\"\n+#include \"single.h\"\n+\n+/* BFtype and HFtype are unordered, neither is a superset or subset\n+   of each other.  Convert HFtype to SFtype (lossless) and then\n+   truncate to BFtype.  */\n+\n+BFtype\n+__trunchfbf2 (HFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_H (A);\n+  FP_DECL_S (B);\n+  FP_DECL_B (R);\n+  SFtype b;\n+  BFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_RAW_H (A, a);\n+  FP_EXTEND (S, H, 1, 1, B, A);\n+  FP_PACK_RAW_S (b, B);\n+  FP_UNPACK_SEMIRAW_S (B, b);\n+  FP_TRUNC (B, S, 1, 1, R, B);\n+  FP_PACK_SEMIRAW_B (r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "ccd90b6a10714298a38df2b61732a3a2bd458787", "filename": "libgcc/soft-fp/truncsfbf2.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftruncsfbf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftruncsfbf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ftruncsfbf2.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,48 @@\n+/* Software floating-point emulation.\n+   Truncate IEEE single into bfloat16.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"soft-fp.h\"\n+#include \"brain.h\"\n+#include \"single.h\"\n+\n+BFtype\n+__truncsfbf2 (SFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_S (A);\n+  FP_DECL_B (R);\n+  BFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_S (A, a);\n+  FP_TRUNC (B, S, 1, 1, R, A);\n+  FP_PACK_SEMIRAW_B (r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "095c12ec2c3888d672df30a53026b8b9c97d736a", "filename": "libgcc/soft-fp/trunctfbf2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftrunctfbf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftrunctfbf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ftrunctfbf2.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,52 @@\n+/* Software floating-point emulation.\n+   Truncate IEEE quad into bfloat16.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <https://www.gnu.org/licenses/>.  */\n+\n+#include \"soft-fp.h\"\n+#include \"brain.h\"\n+#include \"quad.h\"\n+\n+BFtype\n+__trunctfbf2 (TFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_Q (A);\n+  FP_DECL_B (R);\n+  BFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_Q (A, a);\n+#if _FP_W_TYPE_SIZE < 64\n+  FP_TRUNC (B, Q, 1, 4, R, A);\n+#else\n+  FP_TRUNC (B, Q, 1, 2, R, A);\n+#endif\n+  FP_PACK_SEMIRAW_B (r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "fbff063be82a0b7daad544655cbacd8663951de3", "filename": "libgcc/soft-fp/truncxfbf2.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftruncxfbf2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libgcc%2Fsoft-fp%2Ftruncxfbf2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fsoft-fp%2Ftruncxfbf2.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -0,0 +1,52 @@\n+/* Software floating-point emulation.\n+   Truncate IEEE extended into bfloat16.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Lesser General Public\n+   License as published by the Free Software Foundation; either\n+   version 2.1 of the License, or (at your option) any later version.\n+\n+   In addition to the permissions in the GNU Lesser General Public\n+   License, the Free Software Foundation gives you unlimited\n+   permission to link the compiled version of this file into\n+   combinations with other programs, and to distribute those\n+   combinations without any restriction coming from the use of this\n+   file.  (The Lesser General Public License restrictions do apply in\n+   other respects; for example, they cover modification of the file,\n+   and distribution when not linked into a combine executable.)\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Lesser General Public License for more details.\n+\n+   You should have received a copy of the GNU Lesser General Public\n+   License along with the GNU C Library; if not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"soft-fp.h\"\n+#include \"brain.h\"\n+#include \"extended.h\"\n+\n+BFtype\n+__truncxfbf2 (XFtype a)\n+{\n+  FP_DECL_EX;\n+  FP_DECL_E (A);\n+  FP_DECL_B (R);\n+  BFtype r;\n+\n+  FP_INIT_ROUNDMODE;\n+  FP_UNPACK_SEMIRAW_E (A, a);\n+#if _FP_W_TYPE_SIZE < 64\n+  FP_TRUNC (B, E, 1, 4, R, A);\n+#else\n+  FP_TRUNC (B, E, 1, 2, R, A);\n+#endif\n+  FP_PACK_SEMIRAW_B (r, R);\n+  FP_HANDLE_EXCEPTIONS;\n+\n+  return r;\n+}"}, {"sha": "8413dcdc78573f2c30b992d0cdccea74e9b35758", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -2487,6 +2487,7 @@ cplus_demangle_builtin_types[D_BUILTIN_TYPE_COUNT] =\n   /* 33 */ { NL (\"decltype(nullptr)\"),\tNL (\"decltype(nullptr)\"),\n \t     D_PRINT_DEFAULT },\n   /* 34 */ { NL (\"_Float\"),\tNL (\"_Float\"),\t\tD_PRINT_FLOAT },\n+  /* 35 */ { NL (\"std::bfloat16_t\"), NL (\"std::bfloat16_t\"), D_PRINT_FLOAT },\n };\n \n CP_STATIC_IF_GLIBCPP_V3\n@@ -2751,11 +2752,22 @@ cplus_demangle_type (struct d_info *di)\n \n \tcase 'F':\n \t  /* DF<number>_ - _Float<number>.\n-\t     DF<number>x - _Float<number>x.  */\n+\t     DF<number>x - _Float<number>x\n+\t     DF16b - std::bfloat16_t.  */\n \t  {\n \t    int arg = d_number (di);\n \t    char buf[12];\n \t    char suffix = 0;\n+\t    if (d_peek_char (di) == 'b')\n+\t      {\n+\t\tif (arg != 16)\n+\t\t  return NULL;\n+\t\td_advance (di, 1);\n+\t\tret = d_make_builtin_type (di,\n+\t\t\t\t\t   &cplus_demangle_builtin_types[35]);\n+\t\tdi->expansion += ret->u.s_builtin.type->len;\n+\t\tbreak;\n+\t      }\n \t    if (d_peek_char (di) == 'x')\n \t      suffix = 'x';\n \t    if (!suffix && d_peek_char (di) != '_')"}, {"sha": "7f710be4a0134a2ba145e83ba3831f0e02b14447", "filename": "libiberty/cp-demangle.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libiberty%2Fcp-demangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libiberty%2Fcp-demangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.h?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -180,7 +180,7 @@ d_advance (struct d_info *di, int i)\n extern const struct demangle_operator_info cplus_demangle_operators[];\n #endif\n \n-#define D_BUILTIN_TYPE_COUNT (35)\n+#define D_BUILTIN_TYPE_COUNT (36)\n \n CP_STATIC_IF_GLIBCPP_V3\n const struct demangle_builtin_type_info"}, {"sha": "ee8fdfdd9cf7f3ecd0e5688d16b80ea0824e33a9", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2565a31c1622ab0926aeef4a6579413e121b9f9/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2565a31c1622ab0926aeef4a6579413e121b9f9/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=c2565a31c1622ab0926aeef4a6579413e121b9f9", "patch": "@@ -1249,6 +1249,10 @@ xxx\n _Z3xxxDF32xDF64xDF128xCDF32xVb\n xxx(_Float32x, _Float64x, _Float128x, _Float32x _Complex, bool volatile)\n xxx\n+--format=auto --no-params\n+_Z3xxxDF16b\n+xxx(std::bfloat16_t)\n+xxx\n # https://sourceware.org/bugzilla/show_bug.cgi?id=16817\n --format=auto --no-params\n _QueueNotification_QueueController__$4PPPPPPPM_A_INotice___Z"}]}