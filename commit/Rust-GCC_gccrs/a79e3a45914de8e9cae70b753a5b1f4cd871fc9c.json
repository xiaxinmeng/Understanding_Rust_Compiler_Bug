{"sha": "a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc5ZTNhNDU5MTRkZThlOWNhZTcwYjc1M2E1YjFmNGNkODcxZmM5Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-11-03T16:28:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-03T16:28:33Z"}, "message": "cselib.c (cselib_subst_to_values, [...]): Remove reference to CONST_DOUBLE_MEM in comment.\n\n\t* cselib.c (cselib_subst_to_values, case CONST_DOUBLE): Remove\n \treference to CONST_DOUBLE_MEM in comment.\n\t* emit-rtl.c (gen_rtx_CONST_DOUBLE): Remove one operand.\n\t(gen_rtx, case CONST_DOUBLE): Call it with one less operand.\n\t(init_emit_once): Don't clear CONST_DOUBLE_MEM.\n\t* function.c (pop_function_context_from): Don't call\n\trestore_varasm_status.\n\t* function.h (restore_varasm_status): Delete declaration.\n\t* gengenrtl.c (CONST_DOUBLE_FORMAT): Delete CONST_DOUBLE_MEM slot.\n\t* rtl.c: Likewise.\n\t* rtl.def (CONST_DOUBLE): Update comment.\n\t* rtl.h (CONST_DOUBLE_HIGH, CONST_DOUBLE_LOW): Update operand number.\n\t(CONST_DOUBLE_CHAIN): Likewise.\n\t(CONST_DOUBLE_MEM): Delete.\n\t(gen_rtx_CONST_DOUBLE): Update parameters.\n\t* varasm.c (struct varasm_status): x_pool_offset now HOST_WIDE_INT.\n\tRemove reference to CONST_DOUBLE_MEM.\n\t(const_alias_set): New variable.\n\t(immed_double_const): Change call to gen_rtx_CONST_DOUBLE.\n\t(immed_real_const_1): Adjust tests for 0, 1, and 2.\n\tDon't set CONST_DOUBLE_MEM.\n\t(clear_const_double_mem): Don't do anything with const_tiny_rtx.\n\t(output_constant_def): Don't look at TREE_CST_RTL if INTEGER_CST.\n\tPut constant in const_alias_set.\n\t(struct pool_constant): ALIGN now unsigned.\n\tOFFSET now HOST_WIDE_INT.\n\tDelete LABEL.\n\t(restore_varasm_status): Deleted.\n\t(mark_pool_constant): Mark desc->rtl.\n\t(force_const_mem): Rework to store rtl in hash table,\n\tnot CONST_DOUBLE_MEM.\n\tPut constant in const_alias_set.\n\t(find_pool_constant): Check desc->rtl.\n\t(mark_constants, mark_constant): Don't special-case CONST_DOUBLE.\n\t(init_varasm_once): Initialize const_alias_set.\n\nFrom-SVN: r46736", "tree": {"sha": "e4c4eeed512573bd6eb976e608911eb4c0cfb6f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4c4eeed512573bd6eb976e608911eb4c0cfb6f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/comments", "author": null, "committer": null, "parents": [{"sha": "d6b6783b3fcda81f149886129180bedadc852f17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b6783b3fcda81f149886129180bedadc852f17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6b6783b3fcda81f149886129180bedadc852f17"}], "stats": {"total": 371, "additions": 165, "deletions": 206}, "files": [{"sha": "239ac43c41018d1d2b9ffcf3e08824dab7383c9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "patch": "@@ -1,5 +1,41 @@\n Sat Nov  3 10:37:56 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* cselib.c (cselib_subst_to_values, case CONST_DOUBLE): Remove\n+ \treference to CONST_DOUBLE_MEM in comment.\n+\t* emit-rtl.c (gen_rtx_CONST_DOUBLE): Remove one operand.\n+\t(gen_rtx, case CONST_DOUBLE): Call it with one less operand.\n+\t(init_emit_once): Don't clear CONST_DOUBLE_MEM.\n+\t* function.c (pop_function_context_from): Don't call\n+\trestore_varasm_status.\n+\t* function.h (restore_varasm_status): Delete declaration.\n+\t* gengenrtl.c (CONST_DOUBLE_FORMAT): Delete CONST_DOUBLE_MEM slot.\n+\t* rtl.c: Likewise.\n+\t* rtl.def (CONST_DOUBLE): Update comment.\n+\t* rtl.h (CONST_DOUBLE_HIGH, CONST_DOUBLE_LOW): Update operand number.\n+\t(CONST_DOUBLE_CHAIN): Likewise.\n+\t(CONST_DOUBLE_MEM): Delete.\n+\t(gen_rtx_CONST_DOUBLE): Update parameters.\n+\t* varasm.c (struct varasm_status): x_pool_offset now HOST_WIDE_INT.\n+\tRemove reference to CONST_DOUBLE_MEM.\n+\t(const_alias_set): New variable.\n+\t(immed_double_const): Change call to gen_rtx_CONST_DOUBLE.\n+\t(immed_real_const_1): Adjust tests for 0, 1, and 2.\n+\tDon't set CONST_DOUBLE_MEM.\n+\t(clear_const_double_mem): Don't do anything with const_tiny_rtx.\n+\t(output_constant_def): Don't look at TREE_CST_RTL if INTEGER_CST.\n+\tPut constant in const_alias_set.\n+\t(struct pool_constant): ALIGN now unsigned.\n+\tOFFSET now HOST_WIDE_INT.\n+\tDelete LABEL.\n+\t(restore_varasm_status): Deleted.\n+\t(mark_pool_constant): Mark desc->rtl.\n+\t(force_const_mem): Rework to store rtl in hash table,\n+\tnot CONST_DOUBLE_MEM.\n+\tPut constant in const_alias_set.\n+\t(find_pool_constant): Check desc->rtl.\n+\t(mark_constants, mark_constant): Don't special-case CONST_DOUBLE.\n+\t(init_varasm_once): Initialize const_alias_set.\n+\n \t* expr.c (expand_expr, case ADDDR_EXPR): If at top level, don't call\n \tforce_const_mem.\n "}, {"sha": "a3120d2a8379c03755b43c8762660cca3e9cfca0", "filename": "gcc/cselib.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "patch": "@@ -793,8 +793,6 @@ cselib_subst_to_values (x)\n \t}\n       return e->u.val_rtx;\n \n-      /* CONST_DOUBLEs must be special-cased here so that we won't try to\n-\t look up the CONST_DOUBLE_MEM inside.  */\n     case CONST_DOUBLE:\n     case CONST_INT:\n       return x;"}, {"sha": "657e0b612cb6cdf0ed00b1adcf465e446480970f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "patch": "@@ -355,21 +355,19 @@ gen_rtx_CONST_INT (mode, arg)\n    only at run-time.  */\n \n rtx\n-gen_rtx_CONST_DOUBLE (mode, arg0, arg1, arg2)\n+gen_rtx_CONST_DOUBLE (mode, arg0, arg1)\n      enum machine_mode mode;\n-     rtx arg0;\n-     HOST_WIDE_INT arg1, arg2;\n+     HOST_WIDE_INT arg0, arg1;\n {\n   rtx r = rtx_alloc (CONST_DOUBLE);\n   int i;\n \n   PUT_MODE (r, mode);\n-  XEXP (r, 0) = arg0;\n-  X0EXP (r, 1) = NULL_RTX;\n+  X0EXP (r, 0) = NULL_RTX;\n+  XWINT (r, 1) = arg0;\n   XWINT (r, 2) = arg1;\n-  XWINT (r, 3) = arg2;\n \n-  for (i = GET_RTX_LENGTH (CONST_DOUBLE) - 1; i > 3; --i)\n+  for (i = GET_RTX_LENGTH (CONST_DOUBLE) - 1; i > 2; --i)\n     XWINT (r, i) = 0;\n \n   return r;\n@@ -516,10 +514,10 @@ gen_rtx VPARAMS ((enum rtx_code code, enum machine_mode mode, ...))\n \n     case CONST_DOUBLE:\n       {\n-\trtx arg0 = va_arg (p, rtx);\n+\tHOST_WIDE_INT arg0 = va_arg (p, HOST_WIDE_INT);\n \tHOST_WIDE_INT arg1 = va_arg (p, HOST_WIDE_INT);\n-\tHOST_WIDE_INT arg2 = va_arg (p, HOST_WIDE_INT);\n-        rt_val = gen_rtx_CONST_DOUBLE (mode, arg0, arg1, arg2);\n+\n+        rt_val = gen_rtx_CONST_DOUBLE (mode, arg0, arg1);\n       }\n       break;\n \n@@ -4683,7 +4681,6 @@ init_emit_once (line_numbers)\n \t    CONST_DOUBLE_HIGH (tem) = 0;\n \n \t  memcpy (&CONST_DOUBLE_LOW (tem), &u, sizeof u);\n-\t  CONST_DOUBLE_MEM (tem) = cc0_rtx;\n \t  CONST_DOUBLE_CHAIN (tem) = NULL_RTX;\n \t  PUT_MODE (tem, mode);\n "}, {"sha": "093e70ebe643ee9371db72a3685eaf8d929b97c1", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "patch": "@@ -386,7 +386,6 @@ pop_function_context_from (context)\n   reg_renumber = 0;\n \n   restore_emit_status (p);\n-  restore_varasm_status (p);\n \n   if (restore_lang_status)\n     (*restore_lang_status) (p);"}, {"sha": "dc1dbccc9c8f6162f41bda13bf3522841a39889e", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "patch": "@@ -597,7 +597,6 @@ extern void free_after_parsing\t\tPARAMS ((struct function *));\n extern void free_after_compilation\tPARAMS ((struct function *));\n \n extern void init_varasm_status\t\tPARAMS ((struct function *));\n-extern void restore_varasm_status\tPARAMS ((struct function *));\n extern void free_varasm_status\t\tPARAMS ((struct function *));\n extern void free_emit_status\t\tPARAMS ((struct function *));\n extern void free_stmt_status            PARAMS ((struct function *));"}, {"sha": "ad1bc7fce0639477f84e61c7af15e63ba1df49c9", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "patch": "@@ -71,19 +71,19 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #endif /* REAL_WIDTH */\n \n #if REAL_WIDTH == 1\n-# define CONST_DOUBLE_FORMAT\t\"e0ww\"\n+# define CONST_DOUBLE_FORMAT\t\"0ww\"\n #else\n # if REAL_WIDTH == 2\n-#  define CONST_DOUBLE_FORMAT\t\"e0ww\"\n+#  define CONST_DOUBLE_FORMAT\t\"0ww\"\n # else\n #  if REAL_WIDTH == 3\n-#   define CONST_DOUBLE_FORMAT\t\"e0www\"\n+#   define CONST_DOUBLE_FORMAT\t\"0www\"\n #  else\n #   if REAL_WIDTH == 4\n-#    define CONST_DOUBLE_FORMAT\t\"e0wwww\"\n+#    define CONST_DOUBLE_FORMAT\t\"0wwww\"\n #   else\n #    if REAL_WIDTH == 5\n-#     define CONST_DOUBLE_FORMAT\t\"e0wwwww\"\n+#     define CONST_DOUBLE_FORMAT\t\"0wwwww\"\n #    else\n #     define CONST_DOUBLE_FORMAT /* nothing - will cause syntax error */\n #    endif"}, {"sha": "3e73e4bf835456774c0576291dc214ec3e71d335", "filename": "gcc/rtl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "patch": "@@ -30,7 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Calculate the format for CONST_DOUBLE.  This depends on the relative\n    widths of HOST_WIDE_INT and REAL_VALUE_TYPE.\n \n-   We need to go out to e0wwwww, since REAL_ARITHMETIC assumes 16-bits\n+   We need to go out to 0wwwww, since REAL_ARITHMETIC assumes 16-bits\n    per element in REAL_VALUE_TYPE.\n \n    This is duplicated in gengenrtl.c.\n@@ -70,19 +70,19 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #endif /* REAL_WIDTH */\n \n #if REAL_WIDTH == 1\n-# define CONST_DOUBLE_FORMAT\t\"e0ww\"\n+# define CONST_DOUBLE_FORMAT\t\"0ww\"\n #else\n # if REAL_WIDTH == 2\n-#  define CONST_DOUBLE_FORMAT\t\"e0ww\"\n+#  define CONST_DOUBLE_FORMAT\t\"0ww\"\n # else\n #  if REAL_WIDTH == 3\n-#   define CONST_DOUBLE_FORMAT\t\"e0www\"\n+#   define CONST_DOUBLE_FORMAT\t\"0www\"\n #  else\n #   if REAL_WIDTH == 4\n-#    define CONST_DOUBLE_FORMAT\t\"e0wwww\"\n+#    define CONST_DOUBLE_FORMAT\t\"0wwww\"\n #   else\n #    if REAL_WIDTH == 5\n-#     define CONST_DOUBLE_FORMAT\t\"e0wwwww\"\n+#     define CONST_DOUBLE_FORMAT\t\"0wwwww\"\n #    else\n #     define CONST_DOUBLE_FORMAT\t/* nothing - will cause syntax error */\n #    endif"}, {"sha": "d85fb1431fb66b75b415355638ff0e54ed3cdcb4", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "patch": "@@ -560,10 +560,7 @@ DEF_RTL_EXPR(RESX, \"resx\", \"i\", 'x')\n DEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", 'o')\n \n /* numeric floating point constant.\n-   Operand 0 ('e') is the MEM that stores this constant in memory, or\n-   various other things (see comments at immed_double_const in\n-   varasm.c).\n-   Operand 1 ('0') is a chain of all CONST_DOUBLEs in use in the\n+   Operand 0 ('0') is a chain of all CONST_DOUBLEs in use in the\n    current function.\n    Remaining operands hold the actual value.  They are all 'w' and\n    there may be from 1 to 4; see rtl.c.  */"}, {"sha": "6260f57feea91291c3f6d92a55483d749fb354d7", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "patch": "@@ -804,15 +804,11 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n    For a float, the number of ints varies,\n     and CONST_DOUBLE_LOW is the one that should come first *in memory*.\n     So use &CONST_DOUBLE_LOW(r) as the address of an array of ints.  */\n-#define CONST_DOUBLE_LOW(r) XCWINT (r, 2, CONST_DOUBLE)\n-#define CONST_DOUBLE_HIGH(r) XCWINT (r, 3, CONST_DOUBLE)\n+#define CONST_DOUBLE_LOW(r) XCWINT (r, 1, CONST_DOUBLE)\n+#define CONST_DOUBLE_HIGH(r) XCWINT (r, 2, CONST_DOUBLE)\n \n /* Link for chain of all CONST_DOUBLEs in use in current function.  */\n-#define CONST_DOUBLE_CHAIN(r) XCEXP (r, 1, CONST_DOUBLE)\n-/* The MEM which represents this CONST_DOUBLE's value in memory,\n-   or const0_rtx if no MEM has been made for it yet,\n-   or cc0_rtx if it is not on the chain.  */\n-#define CONST_DOUBLE_MEM(r) XCEXP (r, 0, CONST_DOUBLE)\n+#define CONST_DOUBLE_CHAIN(r) XCEXP (r, 0, CONST_DOUBLE)\n \n /* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n    SUBREG_BYTE extracts the byte-number.  */\n@@ -1619,7 +1615,7 @@ extern rtx return_address_pointer_rtx;\n    add to this list, modify special_rtx in gengenrtl.c as well.  You\n    should also modify gen_rtx to use the special function.  */\n \n-extern rtx gen_rtx_CONST_DOUBLE PARAMS ((enum machine_mode, rtx,\n+extern rtx gen_rtx_CONST_DOUBLE PARAMS ((enum machine_mode,\n \t\t\t\t       HOST_WIDE_INT, HOST_WIDE_INT));\n extern rtx gen_rtx_CONST_INT PARAMS ((enum machine_mode, HOST_WIDE_INT));\n extern rtx gen_raw_REG PARAMS ((enum machine_mode, int));"}, {"sha": "ebdac3bced3bac1e6fb262eeca658138fd26480d", "filename": "gcc/varasm.c", "status": "modified", "additions": 105, "deletions": 168, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79e3a45914de8e9cae70b753a5b1f4cd871fc9c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=a79e3a45914de8e9cae70b753a5b1f4cd871fc9c", "patch": "@@ -96,13 +96,10 @@ struct varasm_status\n \n   /* Current offset in constant pool (does not include any machine-specific\n      header).  */\n-  int x_pool_offset;\n+  HOST_WIDE_INT x_pool_offset;\n \n   /* Chain of all CONST_DOUBLE rtx's constructed for the current function.\n-     They are chained through the CONST_DOUBLE_CHAIN.\n-     A CONST_DOUBLE rtx has CONST_DOUBLE_MEM != cc0_rtx iff it is on this chain.\n-     In that case, CONST_DOUBLE_MEM is either a MEM,\n-     or const0_rtx if no MEM has been made for this CONST_DOUBLE yet.  */\n+     They are chained through the CONST_DOUBLE_CHAIN.  */\n   rtx x_const_double_chain;\n };\n \n@@ -135,6 +132,15 @@ int size_directive_output;\n \n tree last_assemble_variable_decl;\n \n+/* RTX_UNCHANGING_P in a MEM can mean it is stored into, for initialization.\n+   So giving constant the alias set for the type will allow such\n+   initializations to appear to conflict with the load of the constant.  We\n+   avoid this by giving all constants an alias set for just constants.\n+   Since there will be no stores to that a alias set, nothing will ever\n+   conflict with them.  */\n+\n+static HOST_WIDE_INT const_alias_set;\n+\n static const char *strip_reg_name\tPARAMS ((const char *));\n static int contains_pointers_p\t\tPARAMS ((tree));\n static void assemble_real_1\t\tPARAMS ((PTR));\n@@ -2249,7 +2255,7 @@ immed_double_const (i0, i1, mode)\n \treturn r;\n \n   /* No; make a new one and add it to the chain.  */\n-  r = gen_rtx_CONST_DOUBLE (mode, const0_rtx, i0, i1);\n+  r = gen_rtx_CONST_DOUBLE (mode, i0, i1);\n \n   /* Don't touch const_double_chain if not inside any function.  */\n   if (current_function_decl != 0)\n@@ -2277,16 +2283,16 @@ immed_real_const_1 (d, mode)\n \n   u.d = d;\n \n-  /* Detect special cases.  */\n-  if (REAL_VALUES_IDENTICAL (dconst0, d))\n+  /* Detect special cases.  Check for NaN first, because some ports\n+     (specifically the i386) do not emit correct ieee-fp code by default, and\n+     thus will generate a core dump here if we pass a NaN to REAL_VALUES_EQUAL\n+     and if REAL_VALUES_EQUAL does a floating point comparison.  */\n+  if (! REAL_VALUE_ISNAN (d) && REAL_VALUES_IDENTICAL (dconst0, d))\n     return CONST0_RTX (mode);\n-\n-  /* Check for NaN first, because some ports (specifically the i386) do not\n-     emit correct ieee-fp code by default, and thus will generate a core\n-     dump here if we pass a NaN to REAL_VALUES_EQUAL and if REAL_VALUES_EQUAL\n-     does a floating point comparison.  */\n   else if (! REAL_VALUE_ISNAN (d) && REAL_VALUES_EQUAL (dconst1, d))\n     return CONST1_RTX (mode);\n+  else if (! REAL_VALUE_ISNAN (d) && REAL_VALUES_EQUAL (dconst2, d))\n+    return CONST2_RTX (mode);\n \n   if (sizeof u == sizeof (HOST_WIDE_INT))\n     return immed_double_const (u.i[0], 0, mode);\n@@ -2325,12 +2331,6 @@ immed_real_const_1 (d, mode)\n   else\n     CONST_DOUBLE_CHAIN (r) = NULL_RTX;\n \n-  /* Store const0_rtx in CONST_DOUBLE_MEM since this CONST_DOUBLE is on the\n-     chain, but has not been allocated memory.  Actual use of CONST_DOUBLE_MEM\n-     is only through force_const_mem.  */\n-\n-  CONST_DOUBLE_MEM (r) = const0_rtx;\n-\n   return r;\n }\n \n@@ -2352,25 +2352,13 @@ void\n clear_const_double_mem ()\n {\n   rtx r, next;\n-  enum machine_mode mode;\n-  int i;\n \n   for (r = const_double_chain; r; r = next)\n     {\n       next = CONST_DOUBLE_CHAIN (r);\n       CONST_DOUBLE_CHAIN (r) = 0;\n-      CONST_DOUBLE_MEM (r) = cc0_rtx;\n     }\n   const_double_chain = 0;\n-\n-  for (i = 0; i <= 2; i++)\n-    for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n-         mode = GET_MODE_WIDER_MODE (mode))\n-      {\n-\tr = const_tiny_rtx[i][(int) mode];\n-\tCONST_DOUBLE_CHAIN (r) = 0;\n-\tCONST_DOUBLE_MEM (r) = cc0_rtx;\n-      }\n }\n \f\n /* Given an expression EXP with a constant value,\n@@ -3292,8 +3280,9 @@ output_constant_def (exp, defer)\n   int found = 1;\n   int after_function = 0;\n   int labelno = -1;\n+  rtx rtl;\n \n-  if (TREE_CST_RTL (exp))\n+  if (TREE_CODE (exp) != INTEGER_CST && TREE_CST_RTL (exp))\n     return TREE_CST_RTL (exp);\n \n   /* Make sure any other constants whose addresses appear in EXP\n@@ -3328,16 +3317,21 @@ output_constant_def (exp, defer)\n       const_hash_table[hash] = desc;\n \n       /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n-      desc->rtl\n+      rtl = desc->rtl\n \t= gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n \t\t       gen_rtx_SYMBOL_REF (Pmode, desc->label));\n \n-      set_mem_attributes (desc->rtl, exp, 1);\n+      set_mem_attributes (rtl, exp, 1);\n+      set_mem_alias_set (rtl, 0);\n+      set_mem_alias_set (rtl, const_alias_set);\n \n       found = 0;\n     }\n+  else\n+    rtl = desc->rtl;\n \n-  TREE_CST_RTL (exp) = desc->rtl;\n+  if (TREE_CODE (exp) != INTEGER_CST)\n+    TREE_CST_RTL (exp) = rtl;\n \n   /* Optionally set flags or add text to the name to record information\n      such as that it is a function name.  If the name is changed, the macro\n@@ -3348,7 +3342,7 @@ output_constant_def (exp, defer)\n   if (! found)\n     {\n       ENCODE_SECTION_INFO (exp);\n-      desc->rtl = TREE_CST_RTL (exp);\n+      desc->rtl = rtl;\n       desc->label = XSTR (XEXP (desc->rtl, 0), 0);\n     }\n #endif\n@@ -3360,7 +3354,7 @@ output_constant_def (exp, defer)\n #endif\n \n   if (found\n-      && STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0))\n+      && STRING_POOL_ADDRESS_P (XEXP (rtl, 0))\n       && (!defer || defer_addressed_constants_flag || after_function))\n     {\n       defstr = (struct deferred_string **)\n@@ -3372,7 +3366,7 @@ output_constant_def (exp, defer)\n \t     remove it from deferred string hash table.  */\n \t  found = 0;\n \t  labelno = (*defstr)->labelno;\n-\t  STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0)) = 0;\n+\t  STRING_POOL_ADDRESS_P (XEXP (rtl, 0)) = 0;\n \t  htab_clear_slot (const_str_htab, (void **) defstr);\n \t}\n     }\n@@ -3383,8 +3377,9 @@ output_constant_def (exp, defer)\n     {\n       if (defer_addressed_constants_flag || after_function)\n \t{\n-\t  struct deferred_constant *p;\n-\t  p = (struct deferred_constant *) xmalloc (sizeof (struct deferred_constant));\n+\t  struct deferred_constant *p\n+\t    = (struct deferred_constant *)\n+\t      xmalloc (sizeof (struct deferred_constant));\n \n \t  p->exp = copy_constant (exp);\n \t  p->reloc = reloc;\n@@ -3425,13 +3420,13 @@ output_constant_def (exp, defer)\n \t\t  p->label = desc->label;\n \t\t  p->labelno = labelno;\n \t\t  *defstr = p;\n-\t\t  STRING_POOL_ADDRESS_P (XEXP (desc->rtl, 0)) = 1;\n+\t\t  STRING_POOL_ADDRESS_P (XEXP (rtl, 0)) = 1;\n \t\t}\n \t    }\n \t}\n     }\n \n-  return TREE_CST_RTL (exp);\n+  return rtl;\n }\n \n /* Now output assembler code to define the label for EXP,\n@@ -3494,12 +3489,11 @@ struct pool_constant\n {\n   struct constant_descriptor *desc;\n   struct pool_constant *next, *next_sym;\n-  const char *label;\n   rtx constant;\n   enum machine_mode mode;\n   int labelno;\n-  int align;\n-  int offset;\n+  unsigned int align;\n+  HOST_WIDE_INT offset;\n   int mark;\n };\n \n@@ -3530,23 +3524,6 @@ init_varasm_status (f)\n   p->x_const_double_chain = 0;\n }\n \n-/* Nested functions diddle with our const_double_chain via\n-   clear_const_double_mem and const_tiny_rtx.  Remove these\n-   entries from our const_double_chain.  */\n-\n-void\n-restore_varasm_status (f)\n-     struct function *f;\n-{\n-  rtx *p = &f->varasm->x_const_double_chain;\n-\n-  while (*p)\n-    if (CONST_DOUBLE_MEM (*p) == cc0_rtx)\n-      *p = CONST_DOUBLE_CHAIN (*p);\n-    else\n-      p = &CONST_DOUBLE_CHAIN (*p);\n-}\n-\n /* Mark PC for GC.  */\n \n static void\n@@ -3557,6 +3534,7 @@ mark_pool_constant (pc)\n     {\n       ggc_mark (pc);\n       ggc_mark_rtx (pc->constant);\n+      ggc_mark_rtx (pc->desc->rtl);\n       pc = pc->next;\n     }\n }\n@@ -3590,19 +3568,22 @@ free_varasm_status (f)\n   /* Clear out the hash tables.  */\n   for (i = 0; i < MAX_RTX_HASH_TABLE; ++i)\n     {\n-      struct constant_descriptor* cd;\n+      struct constant_descriptor *cd;\n \n       cd = p->x_const_rtx_hash_table[i];\n-      while (cd) {\n-\tstruct constant_descriptor* next = cd->next;\n-\tfree (cd);\n-\tcd = next;\n-      }\n+      while (cd)\n+\t{\n+\t  struct constant_descriptor *next = cd->next;\n+\n+\t  free (cd);\n+\t  cd = next;\n+\t}\n     }\n \n   free (p->x_const_rtx_hash_table);\n   free (p->x_const_rtx_sym_hash_table);\n   free (p);\n+\n   f->varasm = NULL;\n }\n \f\n@@ -3786,116 +3767,77 @@ force_const_mem (mode, x)\n   int hash;\n   struct constant_descriptor *desc;\n   char label[256];\n-  const char *found = 0;\n   rtx def;\n-\n-  /* If we want this CONST_DOUBLE in the same mode as it is in memory\n-     (this will always be true for floating CONST_DOUBLEs that have been\n-     placed in memory, but not for VOIDmode (integer) CONST_DOUBLEs),\n-     use the previous copy.  Otherwise, make a new one.  Note that in\n-     the unlikely event that this same CONST_DOUBLE is used in two different\n-     modes in an alternating fashion, we will allocate a lot of different\n-     memory locations, but this should be extremely rare.  */\n-\n-  if (GET_CODE (x) == CONST_DOUBLE\n-      && GET_CODE (CONST_DOUBLE_MEM (x)) == MEM\n-      && GET_MODE (CONST_DOUBLE_MEM (x)) == mode)\n-    return CONST_DOUBLE_MEM (x);\n+  struct pool_constant *pool;\n+  unsigned int align;\n \n   /* Compute hash code of X.  Search the descriptors for that hash code\n-     to see if any of them describes X.  If yes, the descriptor records\n-     the label number already assigned.  */\n-\n+     to see if any of them describes X.  If yes, we have an rtx to use.  */\n   hash = const_hash_rtx (mode, x);\n-\n   for (desc = const_rtx_hash_table[hash]; desc; desc = desc->next)\n     if (compare_constant_rtx (mode, x, desc))\n-      {\n-\tfound = desc->label;\n-\tbreak;\n-      }\n-\n-  if (found == 0)\n-    {\n-      struct pool_constant *pool;\n-      int align;\n-\n-      /* No constant equal to X is known to have been output.\n-\t Make a constant descriptor to enter X in the hash table.\n-\t Assign the label number and record it in the descriptor for\n-\t future calls to this function to find.  */\n-\n-      desc = record_constant_rtx (mode, x);\n-      desc->next = const_rtx_hash_table[hash];\n-      const_rtx_hash_table[hash] = desc;\n-\n-      /* Align the location counter as required by EXP's data type.  */\n-      align = GET_MODE_ALIGNMENT (mode == VOIDmode ? word_mode : mode);\n+      return desc->rtl;\n+\n+  /* No constant equal to X is known to have been output.\n+     Make a constant descriptor to enter X in the hash table\n+     and make a MEM for it.  */\n+  desc = record_constant_rtx (mode, x);\n+  desc->next = const_rtx_hash_table[hash];\n+  const_rtx_hash_table[hash] = desc;\n+  \n+  /* Align the location counter as required by EXP's data type.  */\n+  align = GET_MODE_ALIGNMENT (mode == VOIDmode ? word_mode : mode);\n #ifdef CONSTANT_ALIGNMENT\n-      align = CONSTANT_ALIGNMENT (make_tree (type_for_mode (mode, 0), x),\n-\t\t\t\t  align);\n+  align = CONSTANT_ALIGNMENT (make_tree (type_for_mode (mode, 0), x), align);\n #endif\n \n-      pool_offset += (align / BITS_PER_UNIT) - 1;\n-      pool_offset &= ~ ((align / BITS_PER_UNIT) - 1);\n-\n-      if (GET_CODE (x) == LABEL_REF)\n-\tLABEL_PRESERVE_P (XEXP (x, 0)) = 1;\n-\n-      /* Allocate a pool constant descriptor, fill it in, and chain it in.  */\n-\n-      pool = (struct pool_constant *) ggc_alloc (sizeof (struct pool_constant));\n-      pool->desc = desc;\n-      pool->constant = x;\n-      pool->mode = mode;\n-      pool->labelno = const_labelno;\n-      pool->align = align;\n-      pool->offset = pool_offset;\n-      pool->mark = 1;\n-      pool->next = 0;\n-\n-      if (last_pool == 0)\n-\tfirst_pool = pool;\n-      else\n-\tlast_pool->next = pool;\n-\n-      last_pool = pool;\n-      pool_offset += GET_MODE_SIZE (mode);\n-\n-      /* Create a string containing the label name, in LABEL.  */\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n-\n-      ++const_labelno;\n+  pool_offset += (align / BITS_PER_UNIT) - 1;\n+  pool_offset &= ~ ((align / BITS_PER_UNIT) - 1);\n+\n+  if (GET_CODE (x) == LABEL_REF)\n+    LABEL_PRESERVE_P (XEXP (x, 0)) = 1;\n+\n+  /* Allocate a pool constant descriptor, fill it in, and chain it in.  */\n+  pool = (struct pool_constant *) ggc_alloc (sizeof (struct pool_constant));\n+  pool->desc = desc;\n+  pool->constant = x;\n+  pool->mode = mode;\n+  pool->labelno = const_labelno;\n+  pool->align = align;\n+  pool->offset = pool_offset;\n+  pool->mark = 1;\n+  pool->next = 0;\n+\n+  if (last_pool == 0)\n+    first_pool = pool;\n+  else\n+    last_pool->next = pool;\n+  \n+  last_pool = pool;\n+  pool_offset += GET_MODE_SIZE (mode);\n \n-      desc->label = found = ggc_strdup (label);\n+  /* Create a string containing the label name, in LABEL.  */\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n \n-      /* Add label to symbol hash table.  */\n-      hash = SYMHASH (found);\n-      pool->label = found;\n-      pool->next_sym = const_rtx_sym_hash_table[hash];\n-      const_rtx_sym_hash_table[hash] = pool;\n-    }\n+  ++const_labelno;\n \n-  /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n+  /* Construct the SYMBOL_REF and the MEM.  */\n \n-  def = gen_rtx_MEM (mode, gen_rtx_SYMBOL_REF (Pmode, found));\n+  pool->desc->rtl = def\n+    = gen_rtx_MEM (mode, gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (label)));\n+  set_mem_alias_set (def, const_alias_set);\n   set_mem_attributes (def, type_for_mode (mode, 0), 1);\n   RTX_UNCHANGING_P (def) = 1;\n \n+  /* Add label to symbol hash table.  */\n+  hash = SYMHASH (XSTR (XEXP (def, 0), 0));\n+  pool->next_sym = const_rtx_sym_hash_table[hash];\n+  const_rtx_sym_hash_table[hash] = pool;\n+\n   /* Mark the symbol_ref as belonging to this constants pool.  */\n   CONSTANT_POOL_ADDRESS_P (XEXP (def, 0)) = 1;\n   current_function_uses_const_pool = 1;\n \n-  if (GET_CODE (x) == CONST_DOUBLE)\n-    {\n-      if (CONST_DOUBLE_MEM (x) == cc0_rtx)\n-\t{\n-\t  CONST_DOUBLE_CHAIN (x) = const_double_chain;\n-\t  const_double_chain = x;\n-\t}\n-      CONST_DOUBLE_MEM (x) = def;\n-    }\n-\n   return def;\n }\n \f\n@@ -3912,7 +3854,7 @@ find_pool_constant (f, addr)\n \n   for (pool = f->varasm->x_const_rtx_sym_hash_table[SYMHASH (label)]; pool;\n        pool = pool->next_sym)\n-    if (pool->label == label)\n+    if (XSTR (XEXP (pool->desc->rtl, 0), 0) == label)\n       return pool;\n \n   abort ();\n@@ -4131,10 +4073,6 @@ mark_constants (x)\n       mark_constant (&x, NULL);\n       return;\n     }\n-  /* Never search inside a CONST_DOUBLE, because CONST_DOUBLE_MEM may be\n-     a MEM, but does not constitute a use of that MEM.  */\n-  else if (GET_CODE (x) == CONST_DOUBLE)\n-    return;\n \n   /* Insns may appear inside a SEQUENCE.  Only check the patterns of\n      insns, not any notes that may be attached.  We don't want to mark\n@@ -4182,7 +4120,7 @@ mark_constants (x)\n \n /* Given a SYMBOL_REF CURRENT_RTX, mark it and all constants it refers\n    to as used.  Emit referenced deferred strings.  This function can\n-   be used with for_each_rtx () to mark all SYMBOL_REFs in an rtx.  */\n+   be used with for_each_rtx to mark all SYMBOL_REFs in an rtx.  */\n \n static int\n mark_constant (current_rtx, data)\n@@ -4193,10 +4131,7 @@ mark_constant (current_rtx, data)\n \n   if (x == NULL_RTX)\n     return 0;\n-  else if (GET_CODE(x) == CONST_DOUBLE)\n-    /* Never search inside a CONST_DOUBLE because CONST_DOUBLE_MEM may\n-       be a MEM but does not constitute a use of that MEM.  */\n-    return -1;\n+\n   else if (GET_CODE (x) == SYMBOL_REF)\n     {\n       if (CONSTANT_POOL_ADDRESS_P (x))\n@@ -5185,6 +5120,8 @@ init_varasm_once ()\n \t\tmark_const_hash_entry);\n   ggc_add_root (&const_str_htab, 1, sizeof const_str_htab,\n \t\tmark_const_str_htab);\n+\n+  const_alias_set = new_alias_set ();\n }\n \n /* Select a set of attributes for section NAME based on the properties"}]}