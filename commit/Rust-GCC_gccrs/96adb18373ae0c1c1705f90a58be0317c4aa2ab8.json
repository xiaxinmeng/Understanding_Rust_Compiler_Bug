{"sha": "96adb18373ae0c1c1705f90a58be0317c4aa2ab8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZhZGIxODM3M2FlMGMxYzE3MDVmOTBhNThiZTAzMTdjNGFhMmFiOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2012-06-15T16:51:25Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2012-06-15T16:51:25Z"}, "message": "arm.c (note_invalid_constants): Don't return a result.\n\n\t* arm.c (note_invalid_constants): Don't return a result.\n\t(arm_memory_load_p): Delete function.\n\t(arm_const_double_rtx): Delete iterator variable i;\n\t(fp_immediate_constant): Likewise.\n\t(fp_const_from_val): Likewise.\n\n\t* arm.c (arm_init_iwmmxt_builtins): Delete void_ftype_void.\n\nFrom-SVN: r188672", "tree": {"sha": "61e3226e2b8f3241abb99b2e6d32cc3c836146da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61e3226e2b8f3241abb99b2e6d32cc3c836146da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96adb18373ae0c1c1705f90a58be0317c4aa2ab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96adb18373ae0c1c1705f90a58be0317c4aa2ab8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96adb18373ae0c1c1705f90a58be0317c4aa2ab8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96adb18373ae0c1c1705f90a58be0317c4aa2ab8/comments", "author": null, "committer": null, "parents": [{"sha": "9e1a8dd161fc5c077f8497853f237dff486a392c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e1a8dd161fc5c077f8497853f237dff486a392c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e1a8dd161fc5c077f8497853f237dff486a392c"}], "stats": {"total": 69, "additions": 15, "deletions": 54}, "files": [{"sha": "bfd2fb11d45f2bb37c0f6d324cf377fb6e6cfb3b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96adb18373ae0c1c1705f90a58be0317c4aa2ab8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96adb18373ae0c1c1705f90a58be0317c4aa2ab8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96adb18373ae0c1c1705f90a58be0317c4aa2ab8", "patch": "@@ -1,3 +1,13 @@\n+2012-06-15  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (note_invalid_constants): Don't return a result.\n+\t(arm_memory_load_p): Delete function.\n+\t(arm_const_double_rtx): Delete iterator variable i;\n+\t(fp_immediate_constant): Likewise.\n+\t(fp_const_from_val): Likewise.\n+\n+\t* arm.c (arm_init_iwmmxt_builtins): Delete void_ftype_void.\n+\n 2012-06-15  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR c++/51033"}, {"sha": "bb04392cec31c3933bda468d050fba6091be074d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 5, "deletions": 54, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96adb18373ae0c1c1705f90a58be0317c4aa2ab8/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96adb18373ae0c1c1705f90a58be0317c4aa2ab8/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=96adb18373ae0c1c1705f90a58be0317c4aa2ab8", "patch": "@@ -117,7 +117,7 @@ static void push_minipool_barrier (rtx, HOST_WIDE_INT);\n static void push_minipool_fix (rtx, HOST_WIDE_INT, rtx *, enum machine_mode,\n \t\t\t       rtx);\n static void arm_reorg (void);\n-static bool note_invalid_constants (rtx, HOST_WIDE_INT, int);\n+static void note_invalid_constants (rtx, HOST_WIDE_INT, int);\n static unsigned long arm_compute_save_reg0_reg12_mask (void);\n static unsigned long arm_compute_save_reg_mask (void);\n static unsigned long arm_isr_value (tree);\n@@ -166,7 +166,6 @@ static bool arm_rtx_costs (rtx, int, int, int, int *, bool);\n static int arm_address_cost (rtx, bool);\n static int arm_register_move_cost (enum machine_mode, reg_class_t, reg_class_t);\n static int arm_memory_move_cost (enum machine_mode, reg_class_t, bool);\n-static bool arm_memory_load_p (rtx);\n static void arm_init_builtins (void);\n static void arm_init_iwmmxt_builtins (void);\n static rtx safe_vector_operand (rtx, enum machine_mode);\n@@ -8695,7 +8694,6 @@ int\n arm_const_double_rtx (rtx x)\n {\n   REAL_VALUE_TYPE r;\n-  int i;\n \n   if (!fp_consts_inited)\n     init_fp_table ();\n@@ -9745,41 +9743,6 @@ arm_return_in_msb (const_tree valtype)\n \t      || FIXED_POINT_TYPE_P (valtype)));\n }\n \n-/* Returns TRUE if INSN is an \"LDR REG, ADDR\" instruction.\n-   Use by the Cirrus Maverick code which has to workaround\n-   a hardware bug triggered by such instructions.  */\n-static bool\n-arm_memory_load_p (rtx insn)\n-{\n-  rtx body, lhs, rhs;;\n-\n-  if (insn == NULL_RTX || GET_CODE (insn) != INSN)\n-    return false;\n-\n-  body = PATTERN (insn);\n-\n-  if (GET_CODE (body) != SET)\n-    return false;\n-\n-  lhs = XEXP (body, 0);\n-  rhs = XEXP (body, 1);\n-\n-  lhs = REG_OR_SUBREG_RTX (lhs);\n-\n-  /* If the destination is not a general purpose\n-     register we do not have to worry.  */\n-  if (GET_CODE (lhs) != REG\n-      || REGNO_REG_CLASS (REGNO (lhs)) != GENERAL_REGS)\n-    return false;\n-\n-  /* As well as loads from memory we also have to react\n-     to loads of invalid constants which will be turned\n-     into loads from the minipool.  */\n-  return (GET_CODE (rhs) == MEM\n-\t  || GET_CODE (rhs) == SYMBOL_REF\n-\t  || note_invalid_constants (insn, -1, false));\n-}\n-\n /* Return TRUE if X references a SYMBOL_REF.  */\n int\n symbol_mentioned_p (rtx x)\n@@ -13245,13 +13208,10 @@ arm_const_double_by_immediates (rtx val)\n \n /* Scan INSN and note any of its operands that need fixing.\n    If DO_PUSHES is false we do not actually push any of the fixups\n-   needed.  The function returns TRUE if any fixups were needed/pushed.\n-   This is used by arm_memory_load_p() which needs to know about loads\n-   of constants that will be converted into minipool loads.  */\n-static bool\n+   needed.  */\n+static void\n note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n {\n-  bool result = false;\n   int opno;\n \n   extract_insn (insn);\n@@ -13260,7 +13220,7 @@ note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n     fatal_insn_not_found (insn);\n \n   if (recog_data.n_alternatives == 0)\n-    return false;\n+    return;\n \n   /* Fill in recog_op_alt with information about the constraints of\n      this insn.  */\n@@ -13285,7 +13245,6 @@ note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n \t      if (do_pushes)\n \t\tpush_minipool_fix (insn, address, recog_data.operand_loc[opno],\n \t\t\t\t   recog_data.operand_mode[opno], op);\n-\t      result = true;\n \t    }\n \t  else if (GET_CODE (op) == MEM\n \t\t   && GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n@@ -13308,12 +13267,11 @@ note_invalid_constants (rtx insn, HOST_WIDE_INT address, int do_pushes)\n \t\t\t\t     recog_data.operand_mode[opno], cop);\n \t\t}\n \n-\t      result = true;\n \t    }\n \t}\n     }\n \n-  return result;\n+  return;\n }\n \n /* Convert instructions to their cc-clobbering variant if possible, since\n@@ -13670,7 +13628,6 @@ const char *\n fp_immediate_constant (rtx x)\n {\n   REAL_VALUE_TYPE r;\n-  int i;\n \n   if (!fp_consts_inited)\n     init_fp_table ();\n@@ -13685,8 +13642,6 @@ fp_immediate_constant (rtx x)\n static const char *\n fp_const_from_val (REAL_VALUE_TYPE *r)\n {\n-  int i;\n-\n   if (!fp_consts_inited)\n     init_fp_table ();\n \n@@ -20494,10 +20449,6 @@ arm_init_iwmmxt_builtins (void)\n                                  long_long_unsigned_type_node,\n                                  integer_type_node, NULL_TREE);\n \n-   tree void_ftype_void\n-     = build_function_type_list (void_type_node,\n-                                 NULL_TREE);\n-\n    tree void_ftype_int\n      = build_function_type_list (void_type_node,\n                                  integer_type_node, NULL_TREE);"}]}