{"sha": "2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmExNzc3YWYyMjliYzVlOWU3MzhmZDViYjgyODVhYzBjMWUyNGE3ZA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-09-22T00:49:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-22T00:49:32Z"}, "message": "jump.c (jmp_uses_reg_or_mem): Deleted unused function.\n\n        * jump.c (jmp_uses_reg_or_mem): Deleted unused function.\n        (find_basic_blocks): Use computed_jump_p to determine if a\n        particular JUMP_INSN is a computed jump.\n        * reg-stack.c (find_blocks): Use computed_jump_p to determine\n        if a particular JUMP_INSN is a computed jump.\n        * rtlanal.c (jmp_uses_reg_or_mem): New function.\n        (computed_jump_p): Likewise.\n        * rtl.h (computed_jump_p): Declare.\n        * genattrtab.c (pc_rtx): Define and initialize.\n        * loop.c (loop_optimize): Always determine if the current\n        function has a computed jump.\n        (indirect_jump_in_function_p): Use computed_jump_p to determine\n        if a particular JUMP_INSN is a computed jump.\nGeneral (and haifa) cleanups.\n\nFrom-SVN: r15615", "tree": {"sha": "18e02cdfa9330785934ec403168033e5f85505e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18e02cdfa9330785934ec403168033e5f85505e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/comments", "author": null, "committer": null, "parents": [{"sha": "37842442c3a0fc8e10d227cd7af112fdd4ef14e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37842442c3a0fc8e10d227cd7af112fdd4ef14e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37842442c3a0fc8e10d227cd7af112fdd4ef14e7"}], "stats": {"total": 188, "additions": 133, "deletions": 55}, "files": [{"sha": "d08152910846a104cae106c92fb1a8d0eef1e645", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d", "patch": "@@ -1,5 +1,19 @@\n Sun Sep 21 17:45:45 1997  Jeffrey A Law  (law@cygnus.com)\n \n+\t* jump.c (jmp_uses_reg_or_mem): Deleted unused function.\n+\t(find_basic_blocks): Use computed_jump_p to determine if a\n+\tparticular JUMP_INSN is a computed jump.\n+\t* reg-stack.c (find_blocks): Use computed_jump_p to determine\n+\tif a particular JUMP_INSN is a computed jump.\n+\t* rtlanal.c (jmp_uses_reg_or_mem): New function.\n+\t(computed_jump_p): Likewise.\n+\t* rtl.h (computed_jump_p): Declare.\n+\t* genattrtab.c (pc_rtx): Define and initialize.\n+\t* loop.c (loop_optimize): Always determine if the current\n+\tfunction has a computed jump.\n+\t(indirect_jump_in_function_p): Use computed_jump_p to determine\n+\tif a particular JUMP_INSN is a computed jump.\n+\n \t* loop.c (fix_bct_param): Delete unused function.\n \t(check_bct_param): Likewise.\n "}, {"sha": "8e4f423b5adbfd58dc5b1699b3e6d53aec928402", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d", "patch": "@@ -483,6 +483,8 @@ struct attr_hash *attr_hash_table[RTL_HASH_SIZE];\n    codes are made.  */\n #define RTL_HASH(RTL) ((HOST_WIDE_INT) (RTL) & 0777777)\n \n+rtx pc_rtx;\n+\n /* Add an entry to the hash table for RTL with hash code HASHCODE.  */\n \n static void\n@@ -5573,6 +5575,11 @@ main (argc, argv)\n \n   init_rtl ();\n \n+  /* We don't use this, but it is referenced in rtlanal.c. \n+     Set it up correctly just in case someone tries to use it someday.  */\n+  pc_rtx = rtx_alloc (PC);\n+  PUT_MODE (pc_rtx, VOIDmode);\n+\n   /* Set up true and false rtx's */\n   true_rtx = rtx_alloc (CONST_INT);\n   XWINT (true_rtx, 0) = 1;"}, {"sha": "3bbe74198efba35ef7bcc025deedb6b8c267b17d", "filename": "gcc/loop.c", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d", "patch": "@@ -330,13 +330,14 @@ static void insert_bct ();\n /* Auxiliary function that inserts the bct pattern into the loop */\n static void instrument_loop_bct ();\n \n-/* Indirect_jump_in_function is computed once per function.  */\n-int indirect_jump_in_function = 0;\n-static int indirect_jump_in_function_p ();\n \n int loop_number ();\n #endif  /* HAIFA */\n \n+/* Indirect_jump_in_function is computed once per function.  */\n+int indirect_jump_in_function = 0;\n+static int indirect_jump_in_function_p ();\n+\n \f\n /* Relative gain of eliminating various kinds of operations.  */\n int add_cost;\n@@ -507,11 +508,9 @@ loop_optimize (f, dumpfile)\n   if (flag_unroll_loops && write_symbols != NO_DEBUG)\n     find_loop_tree_blocks ();\n \n-#ifdef HAIFA\n-  /* determine if the function has indirect jump. If it does,\n-     we cannot instrument loops in this function with bct */\n+  /* Determine if the function has indirect jump.  On some systems\n+     this prevents low overhead loop instructions from being used.  */\n   indirect_jump_in_function = indirect_jump_in_function_p (f);\n-#endif  /* HAIFA */\n \n   /* Now scan the loops, last ones first, since this means inner ones are done\n      before outer ones.  */\n@@ -7592,34 +7591,21 @@ loop_number (loop_start, loop_end)\n \n   return loop_num;\n }\n+#endif\t/* HAIFA */\n+\n+/* Scan the function and determine whether it has indirect (computed) jumps.\n \n-/* scan the function and determine whether it has indirect (computed) jump */\n+   This is taken mostly from flow.c; similar code exists elsewhere\n+   in the compiler.  It may be useful to put this into rtlanal.c.  */\n static int\n indirect_jump_in_function_p (start)\n      rtx start;\n {\n   rtx insn;\n   int is_indirect_jump = 0;\n \n-  for (insn = start; insn; insn = NEXT_INSN (insn)) {\n-    if (GET_CODE (insn) == JUMP_INSN) {\n-      if (GET_CODE (PATTERN (insn)) == SET) {\n-\trtx insn_work_code = XEXP (PATTERN (insn), 1);\n-\n-\tif (GET_CODE (insn_work_code) == LABEL_REF)\n-\t  continue;\n-\tif (GET_CODE (insn_work_code) == IF_THEN_ELSE) {\n-\t  rtx jump_target = XEXP (insn_work_code, 1);\n-\n-\t  if (jump_target == pc_rtx\n-\t     || (GET_CODE (jump_target) == (enum rtx_code)LABEL_REF))\n-\t    continue;\n-\t}\n-      }\n-      is_indirect_jump = 1;\n-    }\n-  }\n-  return is_indirect_jump;\n+  for (insn = start; insn; insn = NEXT_INSN (insn))\n+    if (computed_jump_p (insn))\n+      return 1;\n }\n-#endif\t/* HAIFA */\n /* END CYGNUS LOCAL haifa */"}, {"sha": "5b0c8abc14b4bd50f69250518370e39826f9174b", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d", "patch": "@@ -1351,34 +1351,8 @@ find_blocks (first)\n \n       if (GET_CODE (insn) == JUMP_INSN)\n \t{\n-\t  rtx pat = PATTERN (insn);\n-\t  int computed_jump = 0;\n-\t  rtx x;\n \n-\t  if (GET_CODE (pat) == PARALLEL)\n-\t    {\n-\t      int len = XVECLEN (pat, 0);\n-\t      int has_use_labelref = 0;\n-\t      int i;\n-\n-\t      for (i = len - 1; i >= 0; i--)\n-\t\tif (GET_CODE (XVECEXP (pat, 0, i)) == USE\n-\t\t    && GET_CODE (XEXP (XVECEXP (pat, 0, i), 0)) == LABEL_REF)\n-\t\t  has_use_labelref = 1;\n-\n-\t      if (! has_use_labelref)\n-\t\tfor (i = len - 1; i >= 0; i--)\n-\t\t  if (GET_CODE (XVECEXP (pat, 0, i)) == SET\n-\t\t      && SET_DEST (XVECEXP (pat, 0, i)) == pc_rtx\n-\t\t      && uses_reg_or_mem (SET_SRC (XVECEXP (pat, 0, i))))\n-\t\t    computed_jump = 1;\n-\t    }\n-\t  else if (GET_CODE (pat) == SET\n-\t\t   && SET_DEST (pat) == pc_rtx\n-\t\t   && uses_reg_or_mem (SET_SRC (pat)))\n-\t    computed_jump = 1;\n-\t\t    \n-\t  if (computed_jump)\n+\t  if (computed_jump_p (insn))\n \t    {\n \t      for (x = label_value_list; x; x = XEXP (x, 1))\n \t\trecord_label_references (insn,"}, {"sha": "f4d1db90141c3214d24b3dae19d7c6219a50c0ba", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d", "patch": "@@ -978,3 +978,4 @@ extern void init_alias_analysis\tPROTO((void));\n extern void end_alias_analysis\tPROTO((void));\n extern void mark_user_reg\tPROTO((rtx));\n extern void mark_reg_pointer\tPROTO((rtx, int));\n+extern int computed_jump_p\tPROTO((rtx));"}, {"sha": "069c5e8168c1ad3e88cec44fe5ff35be7b33e9f5", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=2a1777af229bc5e9e738fd5bb8285ac0c1e24a7d", "patch": "@@ -25,6 +25,10 @@ Boston, MA 02111-1307, USA.  */\n void note_stores ();\n int reg_set_p ();\n \n+\n+/* Forward declarations */\n+static int jmp_uses_reg_or_mem\t\tPROTO((rtx));\n+\n /* Bit flags that specify the machine subtype we are compiling for.\n    Bits are tested using macros TARGET_... defined in the tm.h file\n    and set by `-m...' switches.  Must be defined in rtlanal.c.  */\n@@ -1847,3 +1851,95 @@ replace_regs (x, reg_map, nregs, replace_dest)\n     }\n   return x;\n }\n+\n+\n+/* Return 1 if X, the SRC_SRC of  SET of (pc) contain a REG or MEM that is\n+   not in the constant pool and not in the condition of an IF_THEN_ELSE.  */\n+\n+static int\n+jmp_uses_reg_or_mem (x)\n+     rtx x;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  int i, j;\n+  char *fmt;\n+\n+  switch (code)\n+    {\n+    case CONST:\n+    case LABEL_REF:\n+    case PC:\n+      return 0;\n+\n+    case REG:\n+      return 1;\n+\n+    case MEM:\n+      return ! (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t\t&& CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)));\n+\n+    case IF_THEN_ELSE:\n+      return (jmp_uses_reg_or_mem (XEXP (x, 1))\n+\t      || jmp_uses_reg_or_mem (XEXP (x, 2)));\n+\n+    case PLUS:  case MINUS:  case MULT:\n+      return (jmp_uses_reg_or_mem (XEXP (x, 0))\n+\t      || jmp_uses_reg_or_mem (XEXP (x, 1)));\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e'\n+\t  && jmp_uses_reg_or_mem (XEXP (x, i)))\n+\treturn 1;\n+\n+      if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  if (jmp_uses_reg_or_mem (XVECEXP (x, i, j)))\n+\t    return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return nonzero if INSN is an indirect jump (aka computed jump).\n+\n+   Tablejumps and casesi insns are not considered indirect jumps;\n+   we can recognize them by a (use (lael_ref)).  */\n+\n+int\n+computed_jump_p (insn)\n+     rtx insn;\n+{\n+  int i;\n+  if (GET_CODE (insn) == JUMP_INSN)\n+    {\n+      rtx pat = PATTERN (insn);\n+      int computed_jump = 0;\n+\n+      if (GET_CODE (pat) == PARALLEL)\n+\t{\n+\t  int len = XVECLEN (pat, 0);\n+\t  int has_use_labelref = 0;\n+\n+\t  for (i = len - 1; i >= 0; i--)\n+\t    if (GET_CODE (XVECEXP (pat, 0, i)) == USE\n+\t\t&& (GET_CODE (XEXP (XVECEXP (pat, 0, i), 0))\n+\t\t    == LABEL_REF))\n+\t      has_use_labelref = 1;\n+\n+\t  if (! has_use_labelref)\n+\t    for (i = len - 1; i >= 0; i--)\n+\t      if (GET_CODE (XVECEXP (pat, 0, i)) == SET\n+\t\t  && SET_DEST (XVECEXP (pat, 0, i)) == pc_rtx\n+\t\t  && jmp_uses_reg_or_mem (SET_SRC (XVECEXP (pat, 0, 1))))\n+\t\treturn 1;\n+\t}\n+      else if (GET_CODE (pat) == SET\n+\t       && SET_DEST (pat) == pc_rtx\n+\t       && jmp_uses_reg_or_mem (SET_SRC (pat)))\n+\treturn 1;\n+    }\n+  return 0;\n+}"}]}