{"sha": "e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU4YTlhYTFmNmQyMzcxYjBjZmFmZjY3MTcyOWQ0ZjU2YzcyYjI4Yw==", "commit": {"author": {"name": "Ziemowit Laski", "email": "zlaski@apple.com", "date": "2005-05-17T20:05:24Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2005-05-17T20:05:24Z"}, "message": "Yet more Objective-C++...\n\n        * cp-objcp-common.h (cxx_get_alias_set): Move from\n        here...\n        (cxx_warn_unused_global_decl): Likewise.\n        (cp_expr_size): Likewise.\n        (cp_tree_size): Likewise.\n        (cp_var_mod_type_p): Likewise.\n        (cxx_initialize_diagnostics): Likewise.\n        (cxx_types_compatible_p): Likewise.\n        * cp-tree.h: to here.\n        (do_poplevel): Add.\n        * lex.c (D_OBJC): Add.\n        (init_reswords): Add.\n        * Make-lang.in (cp/pt.o): Add cp/cp-objcp-common.h.\n        * parser.c: Add c-common.h include.\n        * pt.c: Add c-common.h and cp-objcp-common.h includes.\n        (template_args_equal): Use objc_comptypes as well.\n        (tsubst_copy_and_build): Use objcp_tsubst_copy_and_build as well.\n        * semantics.c (do_poplevel): Remove static.\n\n        * decl.c (objc_mark_locals_volatile): Don't change decls that are\n        already ok.\n        * decl2.c (generate_ctor_or_dtor_function): Add code to initialize\n        Objective C++ early enough.\n        * lex.c (struct resword reswords): Add Objective-C++ support.\n        * parser.c (cp_lexer_get_preprocessor_token): Add Objective-C++.\n        (cp_parser_objc_message_receiver): Add.\n        (cp_parser_objc_message_args): Likewise.\n        (cp_parser_objc_message_expression): Likewise.\n        (cp_parser_objc_encode_expression): Likewise.\n        (cp_parser_objc_defs_expression): Likewise.\n        (cp_parser_objc_protocol_expression): Likewise.\n        (cp_parser_objc_selector_expression): Likewise.\n        (cp_parser_objc_expression): Likewise.\n        (cp_parser_objc_visibility_spec): Likewise.\n        (cp_parser_objc_method_type): Likewise.\n        (cp_parser_objc_protocol_qualifiers): Likewise.\n        (cp_parser_objc_typename): Likewise.\n        (cp_parser_objc_selector_p): Likewise.\n        (cp_parser_objc_selector): Likewise.\n        (cp_parser_objc_method_keyword_params): Likewise.\n        (cp_parser_objc_method_tail_params_opt): Likewise.\n        (cp_parser_objc_interstitial_code): Likewise.\n        (cp_parser_objc_method_signature): Likewise.\n        (cp_parser_objc_method_prototype_list): Likewise.\n        (cp_parser_objc_method_definition_list): Likewise.\n        (cp_parser_objc_class_ivars): Likewise.\n        (cp_parser_objc_identifier_list): Likewise.\n        (cp_parser_objc_alias_declaration): Likewise.\n        (cp_parser_objc_class_declaration): Likewise.\n        (cp_parser_objc_protocol_declaration): Likewise.\n        (cp_parser_objc_protocol_refs_opt): Likewise.\n        (cp_parser_objc_superclass_or_category): Likewise.\n        (cp_parser_objc_class_interface): Likewise.\n        (cp_parser_objc_class_implementation): Likewise.\n        (cp_parser_objc_end_implementation): Likewise.\n        (cp_parser_objc_declaration): Likewise.\n        (cp_parser_objc_try_catch_finally_statement): Likewise.\n        (cp_parser_objc_synchronized_statement): Likewise.\n        (cp_parser_objc_throw_statement): Likewise.\n        (cp_parser_objc_statement): Likewise.\n        (cp_parser_primary_expression): Add Objective-C++.\n        (cp_parser_statement): Likewise.\n        (cp_parser_declaration): Likewise.\n        (cp_parser_simple_type_specifier): Likewise.\n        (cp_parser_type_name): Likewise.\n        (cp_parser_parameter_declaration_list): Likewise.\n        (cp_parser_member_declaration) Likewise.\n        * tree.c: Include debug.h.\n        * typeck.c (composite_pointer_type): Add Objective-C++ support.\n        (finish_class_member_access_expr): Likewise.\n        (build_function_call): Allow objc to rewrite FUNCTION_DECLs.\n        (build_modify_expr): Allow objc to generate write barriers.\n\n        * Make-lang.in (cp/tree.o): Add debug.h.\n        * tree.c (lvalue_p_1, case CONST_DECL): Add.\n\nFrom-SVN: r99855", "tree": {"sha": "f0a3a7afbe4d1781460908fb5b17aa8fd11f5c47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0a3a7afbe4d1781460908fb5b17aa8fd11f5c47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/comments", "author": null, "committer": null, "parents": [{"sha": "b4838d2947d68ae454f83df6ec71e1e03fbb8408", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4838d2947d68ae454f83df6ec71e1e03fbb8408", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4838d2947d68ae454f83df6ec71e1e03fbb8408"}], "stats": {"total": 1454, "additions": 1431, "deletions": 23}, "files": [{"sha": "e67d716d007cd15123305bf3da4041e04302f81e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -1,3 +1,83 @@\n+2005-05-17  Mike Stump  <mrs@apple.com>\n+\n+\tYet more Objective-C++...\n+\t\n+\t* cp-objcp-common.h (cxx_get_alias_set): Move from\n+\there...\n+\t(cxx_warn_unused_global_decl): Likewise.\n+\t(cp_expr_size): Likewise.\n+\t(cp_tree_size): Likewise.\n+\t(cp_var_mod_type_p): Likewise.\n+\t(cxx_initialize_diagnostics): Likewise.\n+\t(cxx_types_compatible_p): Likewise.\n+\t* cp-tree.h: to here.\n+\t(do_poplevel): Add.\n+\t* lex.c (D_OBJC): Add.\n+\t(init_reswords): Add.\n+\t* Make-lang.in (cp/pt.o): Add cp/cp-objcp-common.h.\n+\t* parser.c: Add c-common.h include.\n+\t* pt.c: Add c-common.h and cp-objcp-common.h includes.\n+\t(template_args_equal): Use objc_comptypes as well.\n+\t(tsubst_copy_and_build): Use objcp_tsubst_copy_and_build as well.\n+\t* semantics.c (do_poplevel): Remove static.\n+\n+\t* decl.c (objc_mark_locals_volatile): Don't change decls that are\n+\talready ok.\n+\t* decl2.c (generate_ctor_or_dtor_function): Add code to initialize\n+\tObjective C++ early enough.\n+\t* lex.c (struct resword reswords): Add Objective-C++ support.\n+\t* parser.c (cp_lexer_get_preprocessor_token): Add Objective-C++.\n+\t(cp_parser_objc_message_receiver): Add.\n+\t(cp_parser_objc_message_args): Likewise.\n+\t(cp_parser_objc_message_expression): Likewise.\n+\t(cp_parser_objc_encode_expression): Likewise.\n+\t(cp_parser_objc_defs_expression): Likewise.\n+\t(cp_parser_objc_protocol_expression): Likewise.\n+\t(cp_parser_objc_selector_expression): Likewise.\n+\t(cp_parser_objc_expression): Likewise.\n+\t(cp_parser_objc_visibility_spec): Likewise.\n+\t(cp_parser_objc_method_type): Likewise.\n+\t(cp_parser_objc_protocol_qualifiers): Likewise.\n+\t(cp_parser_objc_typename): Likewise.\n+\t(cp_parser_objc_selector_p): Likewise.\n+\t(cp_parser_objc_selector): Likewise.\n+\t(cp_parser_objc_method_keyword_params): Likewise.\n+\t(cp_parser_objc_method_tail_params_opt): Likewise.\n+\t(cp_parser_objc_interstitial_code): Likewise.\n+\t(cp_parser_objc_method_signature): Likewise.\n+\t(cp_parser_objc_method_prototype_list): Likewise.\n+\t(cp_parser_objc_method_definition_list): Likewise.\n+\t(cp_parser_objc_class_ivars): Likewise.\n+\t(cp_parser_objc_identifier_list): Likewise.\n+\t(cp_parser_objc_alias_declaration): Likewise.\n+\t(cp_parser_objc_class_declaration): Likewise.\n+\t(cp_parser_objc_protocol_declaration): Likewise.\n+\t(cp_parser_objc_protocol_refs_opt): Likewise.\n+\t(cp_parser_objc_superclass_or_category): Likewise.\n+\t(cp_parser_objc_class_interface): Likewise.\n+\t(cp_parser_objc_class_implementation): Likewise.\n+\t(cp_parser_objc_end_implementation): Likewise.\n+\t(cp_parser_objc_declaration): Likewise.\n+\t(cp_parser_objc_try_catch_finally_statement): Likewise.\n+\t(cp_parser_objc_synchronized_statement): Likewise.\n+\t(cp_parser_objc_throw_statement): Likewise.\n+\t(cp_parser_objc_statement): Likewise.\n+\t(cp_parser_primary_expression): Add Objective-C++.\n+\t(cp_parser_statement): Likewise.\n+\t(cp_parser_declaration): Likewise.\n+\t(cp_parser_simple_type_specifier): Likewise.\n+\t(cp_parser_type_name): Likewise.\n+\t(cp_parser_parameter_declaration_list): Likewise.\n+\t(cp_parser_member_declaration) Likewise.\n+\t* tree.c: Include debug.h.\n+\t* typeck.c (composite_pointer_type): Add Objective-C++ support.\n+\t(finish_class_member_access_expr): Likewise.\n+\t(build_function_call): Allow objc to rewrite FUNCTION_DECLs.\n+\t(build_modify_expr): Allow objc to generate write barriers.\n+\n+\t* Make-lang.in (cp/tree.o): Add debug.h.\n+\t* tree.c (lvalue_p_1, case CONST_DECL): Add.\n+\n 2005-05-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/21454"}, {"sha": "3bef02f3a5858b50b0b87097abd38a90a28f3d3e", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -255,14 +255,14 @@ cp/method.o: cp/method.c $(CXX_TREE_H) $(TM_H) toplev.h $(RTL_H) $(EXPR_H) \\\n cp/cvt.o: cp/cvt.c $(CXX_TREE_H) $(TM_H) cp/decl.h flags.h toplev.h convert.h\n cp/search.o: cp/search.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H)\n cp/tree.o: cp/tree.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h $(RTL_H) \\\n-  insn-config.h integrate.h tree-inline.h real.h gt-cp-tree.h $(TARGET_H)\n+  insn-config.h integrate.h tree-inline.h real.h gt-cp-tree.h $(TARGET_H) debug.h\n cp/ptree.o: cp/ptree.c $(CXX_TREE_H) $(TM_H)\n cp/rtti.o: cp/rtti.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h convert.h\n cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) except.h toplev.h \\\n   cp/cfns.h $(EXPR_H) libfuncs.h tree-inline.h\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(RTL_H) flags.h $(EXPR_H) toplev.h \\\n   except.h $(TM_P_H)\n-cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h \\\n+cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/cp-objcp-common.h \\\n   toplev.h $(RTL_H) except.h tree-inline.h pointer-set.h gt-cp-pt.h\n cp/error.o: cp/error.c $(CXX_TREE_H) $(TM_H) toplev.h $(DIAGNOSTIC_H) \\\n   flags.h real.h $(LANGHOOKS_DEF_H) $(CXX_PRETTY_PRINT_H)"}, {"sha": "ca27351b02af3e9b427be6bbd5b5c37821f39c8c", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -22,16 +22,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_CP_OBJCP_COMMON\n #define GCC_CP_OBJCP_COMMON\n \n-/* In cp/cp-objcp-common.c.  */\n-\n-extern HOST_WIDE_INT cxx_get_alias_set (tree);\n-extern bool cxx_warn_unused_global_decl (tree);\n-extern tree cp_expr_size (tree);\n-extern size_t cp_tree_size (enum tree_code);\n-extern bool cp_var_mod_type_p (tree, tree);\n-extern void cxx_initialize_diagnostics (struct diagnostic_context *);\n-extern int cxx_types_compatible_p (tree, tree);\n-\n /* In cp/cp-lang.c and objcp/objcp-lang.c.  */\n \n extern tree objcp_tsubst_copy_and_build (tree, tree, tsubst_flags_t,"}, {"sha": "1a2399b878f1ec73c6d1b3b7e5c575ffcfddc2bd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -4063,6 +4063,7 @@ extern void pop_to_parent_deferring_access_checks\t(void);\n extern void perform_deferred_access_checks\t(void);\n extern void perform_or_defer_access_check\t(tree, tree);\n extern void init_cp_semantics                   (void);\n+extern tree do_poplevel\t\t\t\t(tree);\n extern void add_decl_expr\t\t\t(tree);\n extern tree finish_expr_stmt                    (tree);\n extern tree begin_if_stmt                       (void);\n@@ -4329,6 +4330,16 @@ extern tree mangle_ref_init_variable            (tree);\n /* in dump.c */\n extern bool cp_dump_tree                         (void *, tree);\n \n+/* In cp/cp-objcp-common.c.  */\n+\n+extern HOST_WIDE_INT cxx_get_alias_set (tree);\n+extern bool cxx_warn_unused_global_decl (tree);\n+extern tree cp_expr_size (tree);\n+extern size_t cp_tree_size (enum tree_code);\n+extern bool cp_var_mod_type_p (tree, tree);\n+extern void cxx_initialize_diagnostics (struct diagnostic_context *);\n+extern int cxx_types_compatible_p (tree, tree);\n+\n /* in cp-gimplify.c */\n extern int cp_gimplify_expr\t\t        (tree *, tree *, tree *);\n extern void cp_genericize\t\t\t(tree);"}, {"sha": "529cfd51b009f9e83419e05db39fd9ad1797deee", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -419,19 +419,32 @@ objc_mark_locals_volatile (void *enclosing_blk)\n   struct cp_binding_level *scope;\n \n   for (scope = current_binding_level;\n-       scope && scope != enclosing_blk && scope->kind == sk_block;\n+       scope && scope != enclosing_blk;\n        scope = scope->level_chain)\n     {\n       tree decl;\n \n       for (decl = scope->names; decl; decl = TREE_CHAIN (decl))\n         {\n-\t  if (TREE_CODE (decl) == VAR_DECL)\n+\t  /* Do not mess with variables that are 'static' or (already)\n+\t     'volatile'.  */\n+\t  if (!TREE_THIS_VOLATILE (decl) && !TREE_STATIC (decl)\n+\t      && (TREE_CODE (decl) == VAR_DECL\n+\t\t  || TREE_CODE (decl) == PARM_DECL))\n \t    {\n-              DECL_REGISTER (decl) = 0;\n-              TREE_THIS_VOLATILE (decl) = 1;\n+\t      TREE_TYPE (decl)\n+\t\t= build_qualified_type (TREE_TYPE (decl),\n+\t\t\t\t\t(TYPE_QUALS (TREE_TYPE (decl))\n+\t\t\t\t\t | TYPE_QUAL_VOLATILE));\n+\t      TREE_THIS_VOLATILE (decl) = 1;\n+\t      TREE_SIDE_EFFECTS (decl) = 1;\n+\t      DECL_REGISTER (decl) = 0;\n \t    }\n-        }\n+\t}\n+\n+      /* Do not climb up past the current function.  */\n+      if (scope->kind == sk_function_parms)\n+\tbreak;\n     }\n }\n "}, {"sha": "206cd6ba400b031704639d9516f32d923940aaf5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -2601,6 +2601,15 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority,\n      global constructors and destructors.  */\n   body = NULL_TREE;\n \n+  /* For Objective-C++, we may need to initialize metadata found in this module.\n+     This must be done _before_ any other static initializations.  */\n+  if (c_dialect_objc () && (priority == DEFAULT_INIT_PRIORITY)\n+      && constructor_p && objc_static_init_needed_p ())\n+    {\n+      body = start_objects (function_key, priority);\n+      static_ctors = objc_generate_static_init_call (static_ctors);\n+    }\n+\n   /* Call the static storage duration function with appropriate\n      arguments.  */\n   for (i = 0; VEC_iterate (tree, ssdf_decls, i, fndecl); ++i) "}, {"sha": "21fe2a135817f8665603c10985c385c6b5238f73", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -175,6 +175,7 @@ struct resword\n    _true_.  */\n #define D_EXT\t\t0x01\t/* GCC extension */\n #define D_ASM\t\t0x02\t/* in C99, but has a switch to turn it off */\n+#define D_OBJC\t\t0x04\t/* Objective C++ only */\n \n CONSTRAINT(ridbits_fit, RID_LAST_MODIFIER < sizeof(unsigned long) * CHAR_BIT);\n \n@@ -279,6 +280,31 @@ static const struct resword reswords[] =\n   { \"wchar_t\",          RID_WCHAR,\t0 },\n   { \"while\",\t\tRID_WHILE,\t0 },\n \n+  /* The remaining keywords are specific to Objective-C++.  NB:\n+     All of them will remain _disabled_, since they are context-\n+     sensitive.  */\n+\n+  /* These ObjC keywords are recognized only immediately after\n+     an '@'.  NB: The following C++ keywords double as\n+     ObjC keywords in this context: RID_CLASS, RID_PRIVATE,\n+     RID_PROTECTED, RID_PUBLIC, RID_THROW, RID_TRY and RID_CATCH.  */\n+  { \"compatibility_alias\", RID_AT_ALIAS,\tD_OBJC },\n+  { \"defs\",\t\tRID_AT_DEFS,\t\tD_OBJC },\n+  { \"encode\",\t\tRID_AT_ENCODE,\t\tD_OBJC },\n+  { \"end\",\t\tRID_AT_END,\t\tD_OBJC },\n+  { \"implementation\",\tRID_AT_IMPLEMENTATION,\tD_OBJC },\n+  { \"interface\",\tRID_AT_INTERFACE,\tD_OBJC },\n+  { \"protocol\",\t\tRID_AT_PROTOCOL,\tD_OBJC },\n+  { \"selector\",\t\tRID_AT_SELECTOR,\tD_OBJC },\n+  { \"finally\",\t\tRID_AT_FINALLY,\t\tD_OBJC },\n+  { \"synchronized\",\tRID_AT_SYNCHRONIZED,\tD_OBJC },\n+  /* These are recognized only in protocol-qualifier context.  */\n+  { \"bycopy\",\t\tRID_BYCOPY,\t\tD_OBJC },\n+  { \"byref\",\t\tRID_BYREF,\t\tD_OBJC },\n+  { \"in\",\t\tRID_IN,\t\t\tD_OBJC },\n+  { \"inout\",\t\tRID_INOUT,\t\tD_OBJC },\n+  { \"oneway\",\t\tRID_ONEWAY,\t\tD_OBJC },\n+  { \"out\",\t\tRID_OUT,\t\tD_OBJC },\n };\n \n void\n@@ -287,6 +313,7 @@ init_reswords (void)\n   unsigned int i;\n   tree id;\n   int mask = ((flag_no_asm ? D_ASM : 0)\n+\t      | D_OBJC\n \t      | (flag_no_gnu_keywords ? D_EXT : 0));\n \n   ridpointers = ggc_calloc ((int) RID_MAX, sizeof (tree));"}, {"sha": "7b58840cb3dd27311b268d08c26b26a3a9f1d71e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1233, "deletions": 2, "changes": 1235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -36,6 +36,7 @@\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"target.h\"\n+#include \"c-common.h\"\n \n \f\n /* The lexer.  */\n@@ -408,6 +409,23 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n \t mapped to `const'.  */\n       token->value = ridpointers[token->keyword];\n     }\n+  /* Handle Objective-C++ keywords.  */\n+  else if (token->type == CPP_AT_NAME)\n+    {\n+      token->type = CPP_KEYWORD;\n+      switch (C_RID_CODE (token->value))\n+\t{\n+\t/* Map 'class' to '@class', 'private' to '@private', etc.  */\n+\tcase RID_CLASS: token->keyword = RID_AT_CLASS; break;\n+\tcase RID_PRIVATE: token->keyword = RID_AT_PRIVATE; break;\n+\tcase RID_PROTECTED: token->keyword = RID_AT_PROTECTED; break;\n+\tcase RID_PUBLIC: token->keyword = RID_AT_PUBLIC; break;\n+\tcase RID_THROW: token->keyword = RID_AT_THROW; break;\n+\tcase RID_TRY: token->keyword = RID_AT_TRY; break;\n+\tcase RID_CATCH: token->keyword = RID_AT_CATCH; break;\n+\tdefault: token->keyword = C_RID_CODE (token->value);\n+\t}\n+    }\n   else\n     token->keyword = RID_MAX;\n }\n@@ -1642,6 +1660,35 @@ static bool cp_parser_extension_opt\n static void cp_parser_label_declaration\n   (cp_parser *);\n \n+/* Objective-C++ Productions */\n+\n+static tree cp_parser_objc_message_receiver\n+  (cp_parser *);\n+static tree cp_parser_objc_message_args\n+  (cp_parser *);\n+static tree cp_parser_objc_message_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_encode_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_defs_expression \n+  (cp_parser *);\n+static tree cp_parser_objc_protocol_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_selector_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_expression\n+  (cp_parser *);\n+static bool cp_parser_objc_selector_p\n+  (enum cpp_ttype);\n+static tree cp_parser_objc_selector\n+  (cp_parser *);\n+static tree cp_parser_objc_protocol_refs_opt\n+  (cp_parser *);\n+static void cp_parser_objc_declaration\n+  (cp_parser *);\n+static tree cp_parser_objc_statement\n+  (cp_parser *);\n+\n /* Utility Routines */\n \n static tree cp_parser_lookup_name\n@@ -2652,6 +2699,11 @@ cp_parser_translation_unit (cp_parser* parser)\n      ( compound-statement )\n      __builtin_va_arg ( assignment-expression , type-id )\n \n+   Objective-C++ Extension:\n+\n+   primary-expression:\n+     objc-expression\n+\n    literal:\n      __null\n \n@@ -2878,6 +2930,12 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_OFFSETOF:\n \t  return cp_parser_builtin_offsetof (parser);\n \n+\t  /* Objective-C++ expressions.  */\n+\tcase RID_AT_ENCODE:\n+\tcase RID_AT_PROTOCOL:\n+\tcase RID_AT_SELECTOR:\n+\t  return cp_parser_objc_expression (parser);\n+\n \tdefault:\n \t  cp_parser_error (parser, \"expected primary-expression\");\n \t  return error_mark_node;\n@@ -2926,6 +2984,11 @@ cp_parser_primary_expression (cp_parser *parser,\n \t       been issued.  */\n \t    if (ambiguous_p)\n \t      return error_mark_node;\n+\n+\t    /* In Objective-C++, an instance variable (ivar) may be preferred\n+\t       to whatever cp_parser_lookup_name() found.  */\n+\t    decl = objc_lookup_ivar (decl, id_expression);\n+\n \t    /* If name lookup gives us a SCOPE_REF, then the\n \t       qualifying scope was dependent.  Just propagate the\n \t       name.  */\n@@ -2976,6 +3039,11 @@ cp_parser_primary_expression (cp_parser *parser,\n \n       /* Anything else is an error.  */\n     default:\n+      /* ...unless we have an Objective-C++ message or string literal, that is.  */\n+      if (c_dialect_objc () \n+\t  && (token->type == CPP_OPEN_SQUARE || token->type == CPP_OBJC_STRING))\n+\treturn cp_parser_objc_expression (parser);\n+\n       cp_parser_error (parser, \"expected primary-expression\");\n       return error_mark_node;\n     }\n@@ -5954,6 +6022,15 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr)\n \t  statement = cp_parser_jump_statement (parser);\n \t  break;\n \n+\t  /* Objective-C++ exception-handling constructs.  */\n+\tcase RID_AT_TRY:\n+\tcase RID_AT_CATCH:\n+\tcase RID_AT_FINALLY:\n+\tcase RID_AT_SYNCHRONIZED:\n+\tcase RID_AT_THROW:\n+\t  statement = cp_parser_objc_statement (parser);\n+\t  break;\n+\n \tcase RID_TRY:\n \t  statement = cp_parser_try_block (parser);\n \t  break;\n@@ -6856,6 +6933,9 @@ cp_parser_declaration (cp_parser* parser)\n \t       /* An unnamed namespace definition.  */\n \t       || token2.type == CPP_OPEN_BRACE))\n     cp_parser_namespace_definition (parser);\n+  /* Objective-C++ declaration/definition.  */\n+  else if (c_dialect_objc () && OBJC_IS_AT_KEYWORD (token1.keyword))\n+    cp_parser_objc_declaration (parser);\n   /* We must have either a block declaration or a function\n      definition.  */\n   else\n@@ -9596,7 +9676,26 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n      followed by a \"<\".  That usually indicates that the user thought\n      that the type was a template.  */\n   if (type && type != error_mark_node)\n-    cp_parser_check_for_invalid_template_id (parser, TREE_TYPE (type));\n+    {\n+      /* As a last-ditch effort, see if TYPE is an Objective-C type.\n+\t If it is, then the '<'...'>' enclose protocol names rather than\n+\t template arguments, and so everything is fine.  */\n+      if (c_dialect_objc ()\n+\t  && (objc_is_id (type) || objc_is_class_name (type)))\n+\t{\n+\t  tree protos = cp_parser_objc_protocol_refs_opt (parser);\n+\t  tree qual_type = objc_get_protocol_qualified_type (type, protos);\n+\n+\t  /* Clobber the \"unqualified\" type previously entered into\n+\t     DECL_SPECS with the new, improved protocol-qualifed version.  */\n+\t  if (decl_specs)\n+\t    decl_specs->type = qual_type;\n+\n+\t  return qual_type;\n+\t}\n+\n+      cp_parser_check_for_invalid_template_id (parser, TREE_TYPE (type));\n+    } \n \n   return type;\n }\n@@ -9642,6 +9741,17 @@ cp_parser_type_name (cp_parser* parser)\n \n       /* Look up the type-name.  */\n       type_decl = cp_parser_lookup_name_simple (parser, identifier);\n+\n+      if (TREE_CODE (type_decl) != TYPE_DECL\n+\t  && (objc_is_id (identifier) || objc_is_class_name (identifier)))\n+\t{\n+\t  /* See if this is an Objective-C type.  */\n+\t  tree protos = cp_parser_objc_protocol_refs_opt (parser);\n+\t  tree type = objc_get_protocol_qualified_type (identifier, protos);\n+\t  if (type) \n+\t    type_decl = TYPE_NAME (type);\n+\t}\n+\n       /* Issue an error if we did not find a type-name.  */\n       if (TREE_CODE (type_decl) != TYPE_DECL)\n \t{\n@@ -11748,7 +11858,10 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n \n       /* Peek at the next token.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN)\n-\t  || cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+\t  || cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS)\n+\t  /* These are for Objective-C++ */\n+\t  || cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n+\t  || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n \t/* The parameter-declaration-list is complete.  */\n \tbreak;\n       else if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n@@ -13091,6 +13204,22 @@ cp_parser_member_declaration (cp_parser* parser)\n       return;\n     }\n \n+  /* Check for @defs.  */\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_DEFS))\n+    {\n+      tree ivar, member;\n+      tree ivar_chains = cp_parser_objc_defs_expression (parser);\n+      ivar = ivar_chains;\n+      while (ivar)\n+\t{\n+\t  member = ivar;\n+\t  ivar = TREE_CHAIN (member);\n+\t  TREE_CHAIN (member) = NULL_TREE;\n+\t  finish_member_declaration (member);\n+\t}\n+      return;\n+    }\n+\n   /* Parse the decl-specifier-seq.  */\n   cp_parser_decl_specifier_seq (parser,\n \t\t\t\tCP_PARSER_FLAGS_OPTIONAL,\n@@ -16052,7 +16181,1109 @@ cp_parser_allow_gnu_extensions_p (cp_parser* parser)\n {\n   return parser->allow_gnu_extensions_p;\n }\n+\f\n+/* Objective-C++ Productions */\n+\n+\n+/* Parse an Objective-C expression, which feeds into a primary-expression\n+   above.\n+\n+   objc-expression:\n+     objc-message-expression\n+     objc-string-literal\n+     objc-encode-expression\n+     objc-protocol-expression\n+     objc-selector-expression\n+\n+  Returns a tree representation of the expression.  */\n+\n+static tree\n+cp_parser_objc_expression (cp_parser* parser)\n+{\n+  /* Try to figure out what kind of declaration is present.  */\n+  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n+\n+  switch (kwd->type)\n+    {\n+    case CPP_OPEN_SQUARE:\n+      return cp_parser_objc_message_expression (parser);\n+\n+    case CPP_OBJC_STRING:\n+      kwd = cp_lexer_consume_token (parser->lexer);\n+      return objc_build_string_object (kwd->value);\n+\n+    case CPP_KEYWORD:\n+      switch (kwd->keyword)\n+\t{\n+\tcase RID_AT_ENCODE:\n+\t  return cp_parser_objc_encode_expression (parser);\n+\n+\tcase RID_AT_PROTOCOL:\n+\t  return cp_parser_objc_protocol_expression (parser);\n+\n+\tcase RID_AT_SELECTOR:\n+\t  return cp_parser_objc_selector_expression (parser);\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    default:\n+      error (\"misplaced `@%D' Objective-C++ construct\", kwd->value);\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+/* Parse an Objective-C message expression.\n+\n+   objc-message-expression:\n+     [ objc-message-receiver objc-message-args ]\n+\n+   Returns a representation of an Objective-C message.  */\n+\n+static tree\n+cp_parser_objc_message_expression (cp_parser* parser)\n+{\n+  tree receiver, messageargs;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '['.  */\n+  receiver = cp_parser_objc_message_receiver (parser);\n+  messageargs = cp_parser_objc_message_args (parser);\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, \"`]'\");\n+\n+  return objc_build_message_expr (build_tree_list (receiver, messageargs));\n+}\n+\n+/* Parse an objc-message-receiver.\n+\n+   objc-message-receiver:\n+     type-name\n+     expression\n+\n+  Returns a representation of the type or expression.  */\n+\n+static tree\n+cp_parser_objc_message_receiver (cp_parser* parser)\n+{\n+  tree rcv;\n+  bool class_scope_p, template_p;\n+\n+  /* An Objective-C message receiver may be either (1) a type\n+     or (2) an expression.  */\n+  cp_parser_parse_tentatively (parser);\n+  rcv = cp_parser_expression (parser, false);\n+\n+  if (cp_parser_parse_definitely (parser))\n+    return rcv;\n+\n+  /* Look for the optional `::' operator.  */\n+  cp_parser_global_scope_opt (parser, false);\n+  /* Look for the nested-name-specifier.  */\n+  cp_parser_nested_name_specifier_opt (parser,\n+\t\t\t\t       /*typename_keyword_p=*/true,\n+\t\t\t\t       /*check_dependency_p=*/true,\n+\t\t\t\t       /*type_p=*/true,\n+\t\t\t\t       /*is_declaration=*/true);\n+  class_scope_p = (parser->scope && TYPE_P (parser->scope));\n+  template_p = class_scope_p && cp_parser_optional_template_keyword (parser);\n+  /* Finally, look for the class-name.  */\n+  rcv = cp_parser_class_name (parser,\n+\t\t\t       class_scope_p,\n+\t\t\t       template_p,\n+\t\t\t       /*type_p=*/true,\n+\t\t\t       /*check_dependency_p=*/true,\n+\t\t\t       /*class_head_p=*/false,\n+\t\t\t       /*is_declaration=*/true);\n+\n+  return objc_get_class_reference (rcv);\n+}\n+\n+/* Parse the arguments and selectors comprising an Objective-C message.\n+\n+   objc-message-args:\n+     objc-selector\n+     objc-selector-args\n+     objc-selector-args , objc-comma-args\n+\n+   objc-selector-args:\n+     objc-selector [opt] : assignment-expression\n+     objc-selector-args objc-selector [opt] : assignment-expression\n+\n+   objc-comma-args:\n+     assignment-expression\n+     objc-comma-args , assignment-expression\n+\n+   Returns a TREE_LIST, with TREE_PURPOSE containing a list of\n+   selector arguments and TREE_VALUE containing a list of comma\n+   arguments.  */\n+\n+static tree\n+cp_parser_objc_message_args (cp_parser* parser)\n+{\n+  tree sel_args = NULL_TREE, addl_args = NULL_TREE;\n+  bool maybe_unary_selector_p = true;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n+    {\n+      tree selector = NULL_TREE, arg;\n+\n+      if (token->type != CPP_COLON)\n+\tselector = cp_parser_objc_selector (parser);\n+\n+      /* Detect if we have a unary selector.  */\n+      if (maybe_unary_selector_p\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\treturn build_tree_list (selector, NULL_TREE);\n+\n+      maybe_unary_selector_p = false;\n+      cp_parser_require (parser, CPP_COLON, \"`:'\");\n+      arg = cp_parser_assignment_expression (parser, false);\n+\n+      sel_args\n+\t= chainon (sel_args,\n+\t\t   build_tree_list (selector, arg));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  /* Handle non-selector arguments, if any. */\n+  while (token->type == CPP_COMMA)\n+    {\n+      tree arg;\n+\n+      cp_lexer_consume_token (parser->lexer);\n+      arg = cp_parser_assignment_expression (parser, false);\n+\n+      addl_args\n+\t= chainon (addl_args,\n+\t\t   build_tree_list (NULL_TREE, arg));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  return build_tree_list (sel_args, addl_args);\n+}\n+\n+/* Parse an Objective-C encode expression.\n+\n+   objc-encode-expression:\n+     @encode objc-typename\n+     \n+   Returns an encoded representation of the type argument.  */\n+\n+static tree\n+cp_parser_objc_encode_expression (cp_parser* parser)\n+{\n+  tree type;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@encode'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  type = complete_type (cp_parser_type_id (parser));\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\n+  if (!type)\n+    {\n+      error (\"`@encode' must specify a type as an argument\");\n+      return error_mark_node;\n+    }\n+\n+  return objc_build_encode_expr (type);\n+}\n+\n+/* Parse an Objective-C @defs expression.  */\n+\n+static tree\n+cp_parser_objc_defs_expression (cp_parser *parser)\n+{\n+  tree name;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@defs'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  name = cp_parser_identifier (parser);\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\n+  return objc_get_class_ivars (name);\n+}\n+\n+/* Parse an Objective-C protocol expression.\n+\n+  objc-protocol-expression:\n+    @protocol ( identifier )\n+\n+  Returns a representation of the protocol expression.  */\n+\n+static tree\n+cp_parser_objc_protocol_expression (cp_parser* parser)\n+{\n+  tree proto;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  proto = cp_parser_identifier (parser);\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\n+  return objc_build_protocol_expr (proto);\n+}\n+\n+/* Parse an Objective-C selector expression.\n+\n+   objc-selector-expression:\n+     @selector ( objc-method-signature )\n+\n+   objc-method-signature:\n+     objc-selector\n+     objc-selector-seq\n+\n+   objc-selector-seq:\n+     objc-selector :\n+     objc-selector-seq objc-selector :\n+\n+  Returns a representation of the method selector.  */\n+\n+static tree\n+cp_parser_objc_selector_expression (cp_parser* parser)\n+{\n+  tree sel_seq = NULL_TREE;\n+  bool maybe_unary_selector_p = true;\n+  cp_token *token;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@selector'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n+    {\n+      tree selector = NULL_TREE;\n+\n+      if (token->type != CPP_COLON)\n+\tselector = cp_parser_objc_selector (parser);\n+\n+      /* Detect if we have a unary selector.  */\n+      if (maybe_unary_selector_p\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\t{\n+\t  sel_seq = selector;\n+\t  goto finish_selector;\n+\t}\n+\n+      maybe_unary_selector_p = false;\n+      cp_parser_require (parser, CPP_COLON, \"`:'\");\n+\n+      sel_seq\n+\t= chainon (sel_seq,\n+\t\t   build_tree_list (selector, NULL_TREE));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+ finish_selector:\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\n+  return objc_build_selector_expr (sel_seq);\n+}\n+\n+/* Parse a list of identifiers.\n+\n+   objc-identifier-list:\n+     identifier\n+     objc-identifier-list , identifier\n+\n+   Returns a TREE_LIST of identifier nodes.  */\n+\n+static tree\n+cp_parser_objc_identifier_list (cp_parser* parser)\n+{\n+  tree list = build_tree_list (NULL_TREE, cp_parser_identifier (parser));\n+  cp_token *sep = cp_lexer_peek_token (parser->lexer);\n+\n+  while (sep->type == CPP_COMMA)\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+      list = chainon (list, \n+\t\t      build_tree_list (NULL_TREE,\n+\t\t\t\t       cp_parser_identifier (parser)));\n+      sep = cp_lexer_peek_token (parser->lexer);\n+    }\n+    \n+  return list;\n+}\n+\n+/* Parse an Objective-C alias declaration.\n+\n+   objc-alias-declaration:\n+     @compatibility_alias identifier identifier ;\n+\n+   This function registers the alias mapping with the Objective-C front-end.\n+   It returns nothing.  */\n+\n+static void\n+cp_parser_objc_alias_declaration (cp_parser* parser)\n+{\n+  tree alias, orig;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@compatibility_alias'.  */\n+  alias = cp_parser_identifier (parser);\n+  orig = cp_parser_identifier (parser);\n+  objc_declare_alias (alias, orig);\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+}\n+\n+/* Parse an Objective-C class forward-declaration.\n+\n+   objc-class-declaration:\n+     @class objc-identifier-list ;\n+\n+   The function registers the forward declarations with the Objective-C\n+   front-end.  It returns nothing.  */\n+\n+static void\n+cp_parser_objc_class_declaration (cp_parser* parser)\n+{\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@class'.  */\n+  objc_declare_class (cp_parser_objc_identifier_list (parser));\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+}\n+\n+/* Parse a list of Objective-C protocol references.\n+\n+   objc-protocol-refs-opt:\n+     objc-protocol-refs [opt]\n+\n+   objc-protocol-refs:\n+     < objc-identifier-list >\n+\n+   Returns a TREE_LIST of identifiers, if any.  */\n+\n+static tree\n+cp_parser_objc_protocol_refs_opt (cp_parser* parser)\n+{\n+  tree protorefs = NULL_TREE;\n+\n+  if(cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat '<'.  */\n+      protorefs = cp_parser_objc_identifier_list (parser);\n+      cp_parser_require (parser, CPP_GREATER, \"`>'\");\n+    }\n+\n+  return protorefs;\n+}\n+\n+/* Parse a Objective-C visibility specification.  */\n+\n+static void\n+cp_parser_objc_visibility_spec (cp_parser* parser)\n+{\n+  cp_token *vis = cp_lexer_peek_token (parser->lexer);\n+\n+  switch (vis->keyword)\n+    {\n+    case RID_AT_PRIVATE:\n+      objc_set_visibility (2);\n+      break;\n+    case RID_AT_PROTECTED:\n+      objc_set_visibility (0);\n+      break;\n+    case RID_AT_PUBLIC:\n+      objc_set_visibility (1);\n+      break;\n+    default:\n+      return;\n+    }\n \n+  /* Eat '@private'/'@protected'/'@public'.  */\n+  cp_lexer_consume_token (parser->lexer);\n+}\n+\n+/* Parse an Objective-C method type.  */\n+\n+static void\n+cp_parser_objc_method_type (cp_parser* parser)\n+{\n+  objc_set_method_type\n+   (cp_lexer_consume_token (parser->lexer)->type == CPP_PLUS\n+    ? PLUS_EXPR\n+    : MINUS_EXPR);\n+}\n+\n+/* Parse an Objective-C protocol qualifier.  */\n+\n+static tree\n+cp_parser_objc_protocol_qualifiers (cp_parser* parser)\n+{\n+  tree quals = NULL_TREE, node;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  node = token->value;\n+\n+  while (node && TREE_CODE (node) == IDENTIFIER_NODE\n+\t && (node == ridpointers [(int) RID_IN]\n+\t     || node == ridpointers [(int) RID_OUT]\n+\t     || node == ridpointers [(int) RID_INOUT]\n+\t     || node == ridpointers [(int) RID_BYCOPY]\n+             || node == ridpointers [(int) RID_BYREF]\n+\t     || node == ridpointers [(int) RID_ONEWAY]))\n+    {\n+      quals = tree_cons (NULL_TREE, node, quals);\n+      cp_lexer_consume_token (parser->lexer);\n+      token = cp_lexer_peek_token (parser->lexer);\n+      node = token->value;\n+    }\n+\n+  return quals;\n+}\n+\n+/* Parse an Objective-C typename.  */\n+\n+static tree\n+cp_parser_objc_typename (cp_parser* parser)\n+{\n+  tree typename = NULL_TREE;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      tree proto_quals, cp_type = NULL_TREE;\n+\n+      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n+      proto_quals = cp_parser_objc_protocol_qualifiers (parser);\n+\n+      /* An ObjC type name may consist of just protocol qualifiers, in which\n+\t case the type shall default to 'id'.  */\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n+\tcp_type = cp_parser_type_id (parser);\n+\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+      typename = build_tree_list (proto_quals, cp_type);\n+    }\n+\n+  return typename;\n+}\n+\n+/* Check to see if TYPE refers to an Objective-C selector name.  */\n+\n+static bool\n+cp_parser_objc_selector_p (enum cpp_ttype type)\n+{\n+  return (type == CPP_NAME || type == CPP_KEYWORD\n+\t  || type == CPP_AND_AND || type == CPP_AND_EQ || type == CPP_AND\n+\t  || type == CPP_OR || type == CPP_COMPL || type == CPP_NOT\n+\t  || type == CPP_NOT_EQ || type == CPP_OR_OR || type == CPP_OR_EQ\n+\t  || type == CPP_XOR || type == CPP_XOR_EQ);\n+}\n+\n+/* Parse an Objective-C selector.  */\n+\n+static tree\n+cp_parser_objc_selector (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_consume_token (parser->lexer);\n+  \n+  if (!cp_parser_objc_selector_p (token->type))\n+    {\n+      error (\"invalid Objective-C++ selector name\");\n+      return error_mark_node;\n+    }\n+\n+  /* C++ operator names are allowed to appear in ObjC selectors.  */\n+  switch (token->type)\n+    {\n+    case CPP_AND_AND: return get_identifier (\"and\");\n+    case CPP_AND_EQ: return get_identifier (\"and_eq\");\n+    case CPP_AND: return get_identifier (\"bitand\");\n+    case CPP_OR: return get_identifier (\"bitor\");\n+    case CPP_COMPL: return get_identifier (\"compl\");\n+    case CPP_NOT: return get_identifier (\"not\");\n+    case CPP_NOT_EQ: return get_identifier (\"not_eq\");\n+    case CPP_OR_OR: return get_identifier (\"or\");\n+    case CPP_OR_EQ: return get_identifier (\"or_eq\");\n+    case CPP_XOR: return get_identifier (\"xor\");\n+    case CPP_XOR_EQ: return get_identifier (\"xor_eq\");\n+    default: return token->value;\n+    }\n+}\n+\n+/* Parse an Objective-C params list.  */\n+\n+static tree\n+cp_parser_objc_method_keyword_params (cp_parser* parser)\n+{\n+  tree params = NULL_TREE;\n+  bool maybe_unary_selector_p = true;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n+    {\n+      tree selector = NULL_TREE, typename, identifier;\n+\n+      if (token->type != CPP_COLON)\n+\tselector = cp_parser_objc_selector (parser);\n+\n+      /* Detect if we have a unary selector.  */\n+      if (maybe_unary_selector_p\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\treturn selector;\n+\n+      maybe_unary_selector_p = false;\n+      cp_parser_require (parser, CPP_COLON, \"`:'\");\n+      typename = cp_parser_objc_typename (parser);\n+      identifier = cp_parser_identifier (parser);\n+\n+      params\n+\t= chainon (params,\n+\t\t   objc_build_keyword_decl (selector, \n+\t\t\t\t\t    typename,\n+\t\t\t\t\t    identifier));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  return params;\n+}\n+\n+/* Parse the non-keyword Objective-C params.  */\n+\n+static tree\n+cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp)\n+{\n+  tree params = make_node (TREE_LIST);\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  *ellipsisp = false;  /* Initially, assume no ellipsis.  */\n+\n+  while (token->type == CPP_COMMA)\n+    {\n+      cp_parameter_declarator *parmdecl;\n+      tree parm;\n+\n+      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+\n+      if (token->type == CPP_ELLIPSIS)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);  /* Eat '...'.  */\n+\t  *ellipsisp = true;\n+\t  break;\n+\t}\n+\n+      parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n+      parm = grokdeclarator (parmdecl->declarator,\n+\t\t\t     &parmdecl->decl_specifiers,\n+\t\t\t     PARM, /*initialized=*/0, \n+\t\t\t     /*attrlist=*/NULL);\n+\n+      chainon (params, build_tree_list (NULL_TREE, parm));\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  return params;\n+}\n+\n+/* Parse a linkage specification, a pragma, an extra semicolon or a block.  */\n+\n+static void\n+cp_parser_objc_interstitial_code (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  /* If the next token is `extern' and the following token is a string\n+     literal, then we have a linkage specification.  */\n+  if (token->keyword == RID_EXTERN\n+      && cp_parser_is_string_literal (cp_lexer_peek_nth_token (parser->lexer, 2)))\n+    cp_parser_linkage_specification (parser);\n+  /* Handle #pragma, if any.  */\n+  else if (token->type == CPP_PRAGMA)\n+    cp_lexer_handle_pragma (parser->lexer);\n+  /* Allow stray semicolons.  */\n+  else if (token->type == CPP_SEMICOLON)\n+    cp_lexer_consume_token (parser->lexer);\n+  /* Finally, try to parse a block-declaration, or a function-definition.  */\n+  else\n+    cp_parser_block_declaration (parser, /*statement_p=*/false);\n+}\n+\n+/* Parse a method signature.  */\n+\n+static tree\n+cp_parser_objc_method_signature (cp_parser* parser)\n+{\n+  tree rettype, kwdparms, optparms;\n+  bool ellipsis = false;\n+\n+  cp_parser_objc_method_type (parser);\n+  rettype = cp_parser_objc_typename (parser);\n+  kwdparms = cp_parser_objc_method_keyword_params (parser);\n+  optparms = cp_parser_objc_method_tail_params_opt (parser, &ellipsis);\n+\n+  return objc_build_method_signature (rettype, kwdparms, optparms, ellipsis);\n+}\n+\n+/* Pars an Objective-C method prototype list.  */\n+\n+static void\n+cp_parser_objc_method_prototype_list (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (token->keyword != RID_AT_END)\n+    {\n+      if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n+\t{\n+\t  objc_add_method_declaration\n+\t   (cp_parser_objc_method_signature (parser));\n+\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\t}\n+      else\n+\t/* Allow for interspersed non-ObjC++ code.  */\n+\tcp_parser_objc_interstitial_code (parser);\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n+  objc_finish_interface ();\n+}\n+\n+/* Parse an Objective-C method definition list.  */\n+\n+static void\n+cp_parser_objc_method_definition_list (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (token->keyword != RID_AT_END)\n+    {\n+      tree meth;\n+\n+      if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n+\t{\n+\t  push_deferring_access_checks (dk_deferred);\n+\t  objc_start_method_definition\n+\t   (cp_parser_objc_method_signature (parser));\n+\n+\t  /* For historical reasons, we accept an optional semicolon.  */\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\n+\t  perform_deferred_access_checks ();\n+\t  stop_deferring_access_checks ();\n+\t  meth = cp_parser_function_definition_after_declarator (parser,\n+\t\t\t\t\t\t\t\t false);\n+\t  pop_deferring_access_checks ();\n+\t  objc_finish_method_definition (meth);\n+\t}\n+      else\n+\t/* Allow for interspersed non-ObjC++ code.  */\n+\tcp_parser_objc_interstitial_code (parser);\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n+  objc_finish_implementation ();\n+}\n+\n+/* Parse Objective-C ivars.  */\n+\n+static void\n+cp_parser_objc_class_ivars (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  if (token->type != CPP_OPEN_BRACE)\n+    return;\t/* No ivars specified.  */\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '{'.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (token->type != CPP_CLOSE_BRACE)\n+    {\n+      cp_decl_specifier_seq declspecs;\n+      int decl_class_or_enum_p;\n+      tree prefix_attributes;\n+\n+      cp_parser_objc_visibility_spec (parser);\n+\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n+\tbreak;\n+\n+      cp_parser_decl_specifier_seq (parser,\n+\t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n+\t\t\t\t    &declspecs,\n+\t\t\t\t    &decl_class_or_enum_p);\n+      prefix_attributes = declspecs.attributes;\n+      declspecs.attributes = NULL_TREE;\n+\n+      /* Keep going until we hit the `;' at the end of the\n+\t declaration.  */\n+      while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+\t{\n+\t  tree width = NULL_TREE, attributes, first_attribute, decl;\n+\t  cp_declarator *declarator = NULL;\n+\t  int ctor_dtor_or_conv_p;\n+\n+\t  /* Check for a (possibly unnamed) bitfield declaration.  */\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t  if (token->type == CPP_COLON)\n+\t    goto eat_colon;\n+\n+\t  if (token->type == CPP_NAME\n+\t      && (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n+\t\t  == CPP_COLON))\n+\t    {\n+\t      /* Get the name of the bitfield.  */\n+\t      declarator = make_id_declarator (NULL_TREE,\n+\t\t\t\t\t       cp_parser_identifier (parser));\n+\n+\t     eat_colon:\n+\t      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n+\t      /* Get the width of the bitfield.  */\n+\t      width\n+\t\t= cp_parser_constant_expression (parser,\n+\t\t\t\t\t\t /*allow_non_constant=*/false,\n+\t\t\t\t\t\t NULL);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Parse the declarator.  */\n+\t      declarator \n+\t\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t\t&ctor_dtor_or_conv_p,\n+\t\t\t\t\t/*parenthesized_p=*/NULL,\n+\t\t\t\t\t/*member_p=*/false);\n+\t    }\n+\n+\t  /* Look for attributes that apply to the ivar.  */\n+\t  attributes = cp_parser_attributes_opt (parser);\n+\t  /* Remember which attributes are prefix attributes and\n+\t     which are not.  */\n+\t  first_attribute = attributes;\n+\t  /* Combine the attributes.  */\n+\t  attributes = chainon (prefix_attributes, attributes);\n+\n+\t  if (width)\n+\t    {\n+\t      /* Create the bitfield declaration.  */\n+\t      decl = grokbitfield (declarator, &declspecs, width);\n+\t      cplus_decl_attributes (&decl, attributes, /*flags=*/0);\n+\t    }\n+\t  else\n+\t    decl = grokfield (declarator, &declspecs, NULL_TREE,\n+\t\t\t      NULL_TREE, attributes);\n+\t  \n+\t  /* Add the instance variable.  */\n+\t  objc_add_instance_variable (decl);\n+\n+\t  /* Reset PREFIX_ATTRIBUTES.  */\n+\t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n+\t    attributes = TREE_CHAIN (attributes);\n+\t  if (attributes)\n+\t    TREE_CHAIN (attributes) = NULL_TREE;\n+\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\n+\t  if (token->type == CPP_COMMA)\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+\t      continue;\n+\t    }\n+\t  break;\n+\t}\n+\n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '}'.  */\n+  /* For historical reasons, we accept an optional semicolon.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+    cp_lexer_consume_token (parser->lexer);\n+}\n+\n+/* Parse an Objective-C protocol declaration.  */\n+\n+static void\n+cp_parser_objc_protocol_declaration (cp_parser* parser)\n+{\n+  tree proto, protorefs;\n+  cp_token *tok;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+    {\n+      error (\"identifier expected after `@protocol'\");\n+      goto finish;\n+    }\n+\n+  /* See if we have a foward declaration or a definition.  */\n+  tok = cp_lexer_peek_nth_token (parser->lexer, 2);\n+  \n+  /* Try a forward declaration first.  */\n+  if (tok->type == CPP_COMMA || tok->type == CPP_SEMICOLON)\n+    {\n+      objc_declare_protocols (cp_parser_objc_identifier_list (parser));\n+     finish: \n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+    } \n+\n+  /* Ok, we got a full-fledged definition (or at least should).  */\n+  else\n+    {\n+      proto = cp_parser_identifier (parser);\n+      protorefs = cp_parser_objc_protocol_refs_opt (parser);\n+      objc_start_protocol (proto, protorefs);\n+      cp_parser_objc_method_prototype_list (parser);\n+    }\n+}\n+\n+/* Parse an Objective-C superclass or category.  */\n+\n+static void\n+cp_parser_objc_superclass_or_category (cp_parser *parser, tree *super,\n+\t\t\t\t\t\t\t  tree *categ)\n+{\n+  cp_token *next = cp_lexer_peek_token (parser->lexer);\n+\n+  *super = *categ = NULL_TREE;\n+  if (next->type == CPP_COLON)\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n+      *super = cp_parser_identifier (parser);\n+    }\n+  else if (next->type == CPP_OPEN_PAREN)\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n+      *categ = cp_parser_identifier (parser);\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+    }\n+}\n+\n+/* Parse an Objective-C class interface.  */\n+\n+static void\n+cp_parser_objc_class_interface (cp_parser* parser)\n+{\n+  tree name, super, categ, protos;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@interface'.  */\n+  name = cp_parser_identifier (parser);\n+  cp_parser_objc_superclass_or_category (parser, &super, &categ);\n+  protos = cp_parser_objc_protocol_refs_opt (parser);\n+\n+  /* We have either a class or a category on our hands.  */\n+  if (categ)\n+    objc_start_category_interface (name, categ, protos);\n+  else\n+    {\n+      objc_start_class_interface (name, super, protos);\n+      /* Handle instance variable declarations, if any.  */\n+      cp_parser_objc_class_ivars (parser);\n+      objc_continue_interface ();\n+    }\n+\n+  cp_parser_objc_method_prototype_list (parser);\n+}\n+\n+/* Parse an Objective-C class implementation.  */\n+\n+static void\n+cp_parser_objc_class_implementation (cp_parser* parser)\n+{\n+  tree name, super, categ;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@implementation'.  */\n+  name = cp_parser_identifier (parser);\n+  cp_parser_objc_superclass_or_category (parser, &super, &categ);\n+\n+  /* We have either a class or a category on our hands.  */\n+  if (categ)\n+    objc_start_category_implementation (name, categ);\n+  else\n+    {\n+      objc_start_class_implementation (name, super);\n+      /* Handle instance variable declarations, if any.  */\n+      cp_parser_objc_class_ivars (parser);\n+      objc_continue_implementation ();\n+    }\n+\n+  cp_parser_objc_method_definition_list (parser);\n+}\n+\n+/* Consume the @end token and finish off the implementation.  */\n+\n+static void\n+cp_parser_objc_end_implementation (cp_parser* parser)\n+{\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n+  objc_finish_implementation ();\n+}\n+\n+/* Parse an Objective-C declaration.  */\n+\n+static void\n+cp_parser_objc_declaration (cp_parser* parser)\n+{\n+  /* Try to figure out what kind of declaration is present.  */\n+  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n+\n+  switch (kwd->keyword)\n+    {\n+    case RID_AT_ALIAS:\n+      cp_parser_objc_alias_declaration (parser);\n+      break;\n+    case RID_AT_CLASS:\n+      cp_parser_objc_class_declaration (parser);\n+      break;\n+    case RID_AT_PROTOCOL:\n+      cp_parser_objc_protocol_declaration (parser);\n+      break;\n+    case RID_AT_INTERFACE:\n+      cp_parser_objc_class_interface (parser);\n+      break;\n+    case RID_AT_IMPLEMENTATION:\n+      cp_parser_objc_class_implementation (parser);\n+      break;\n+    case RID_AT_END:\n+      cp_parser_objc_end_implementation (parser);\n+      break;\n+    default:\n+      error (\"misplaced `@%D' Objective-C++ construct\", kwd->value);\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+    }\n+}\n+\n+/* Parse an Objective-C try-catch-finally statement.\n+\n+   objc-try-catch-finally-stmt:\n+     @try compound-statement objc-catch-clause-seq [opt]\n+       objc-finally-clause [opt]\n+\n+   objc-catch-clause-seq:\n+     objc-catch-clause objc-catch-clause-seq [opt]\n+\n+   objc-catch-clause:\n+     @catch ( exception-declaration ) compound-statement\n+\n+   objc-finally-clause\n+     @finally compound-statement\n+\n+   Returns NULL_TREE.  */\n+\n+static tree\n+cp_parser_objc_try_catch_finally_statement (cp_parser *parser) {\n+  location_t location;\n+  tree stmt;\n+\n+  cp_parser_require_keyword (parser, RID_AT_TRY, \"`@try'\");\n+  location = cp_lexer_peek_token (parser->lexer)->location;\n+  /* NB: The @try block needs to be wrapped in its own STATEMENT_LIST\n+     node, lest it get absorbed into the surrounding block.  */\n+  stmt = push_stmt_list ();\n+  cp_parser_compound_statement (parser, NULL, false);\n+  objc_begin_try_stmt (location, pop_stmt_list (stmt));\n+  \n+  while (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_CATCH))\n+    {\n+      cp_parameter_declarator *parmdecl;\n+      tree parm;\n+\n+      cp_lexer_consume_token (parser->lexer);\n+      cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+      parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n+      parm = grokdeclarator (parmdecl->declarator,\n+\t\t\t     &parmdecl->decl_specifiers,\n+\t\t\t     PARM, /*initialized=*/0, \n+\t\t\t     /*attrlist=*/NULL);\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+      objc_begin_catch_clause (parm);\n+      cp_parser_compound_statement (parser, NULL, false);\n+      objc_finish_catch_clause ();\n+    }\n+\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_FINALLY))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      location = cp_lexer_peek_token (parser->lexer)->location;\n+      /* NB: The @finally block needs to be wrapped in its own STATEMENT_LIST\n+\t node, lest it get absorbed into the surrounding block.  */\n+      stmt = push_stmt_list ();\n+      cp_parser_compound_statement (parser, NULL, false);\n+      objc_build_finally_clause (location, pop_stmt_list (stmt));\n+    }\n+\n+  return objc_finish_try_stmt ();\n+}\n+\n+/* Parse an Objective-C synchronized statement.\n+\n+   objc-synchronized-stmt:\n+     @synchronized ( expression ) compound-statement\n+\n+   Returns NULL_TREE.  */\n+\n+static tree\n+cp_parser_objc_synchronized_statement (cp_parser *parser) {\n+  location_t location;\n+  tree lock, stmt;\n+\n+  cp_parser_require_keyword (parser, RID_AT_SYNCHRONIZED, \"`@synchronized'\");\n+\n+  location = cp_lexer_peek_token (parser->lexer)->location;\n+  cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n+  lock = cp_parser_expression (parser, false);\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n+\n+  /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n+     node, lest it get absorbed into the surrounding block.  */\n+  stmt = push_stmt_list ();\n+  cp_parser_compound_statement (parser, NULL, false);\n+\n+  return objc_build_synchronized (location, lock, pop_stmt_list (stmt));\n+}\n+\n+/* Parse an Objective-C throw statement.\n+\n+   objc-throw-stmt:\n+     @throw assignment-expression [opt] ;\n+\n+   Returns a constructed '@throw' statement.  */\n+\n+static tree\n+cp_parser_objc_throw_statement (cp_parser *parser) {\n+  tree expr = NULL_TREE;\n+\n+  cp_parser_require_keyword (parser, RID_AT_THROW, \"`@throw'\");\n+\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+    expr = cp_parser_assignment_expression (parser, false);\n+\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\n+  return objc_build_throw_stmt (expr);\n+}\n+\n+/* Parse an Objective-C statement.  */\n+\n+static tree\n+cp_parser_objc_statement (cp_parser * parser) {\n+  /* Try to figure out what kind of declaration is present.  */\n+  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n+\n+  switch (kwd->keyword)\n+    {\n+    case RID_AT_TRY:\n+      return cp_parser_objc_try_catch_finally_statement (parser);\n+    case RID_AT_SYNCHRONIZED:\n+      return cp_parser_objc_synchronized_statement (parser);\n+    case RID_AT_THROW:\n+      return cp_parser_objc_throw_statement (parser);\n+    default:\n+      error (\"misplaced `@%D' Objective-C++ construct\", kwd->value);\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+    }\n+\n+  return error_mark_node;\n+}\n \f\n /* The parser.  */\n "}, {"sha": "f5e3f8a7a32df32633715ce1266db8f30c731800", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -34,7 +34,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"pointer-set.h\"\n #include \"flags.h\"\n+#include \"c-common.h\"\n #include \"cp-tree.h\"\n+#include \"cp-objcp-common.h\"\n #include \"tree-inline.h\"\n #include \"decl.h\"\n #include \"output.h\"\n@@ -4024,7 +4026,24 @@ template_args_equal (tree ot, tree nt)\n     /* For member templates */\n     return TREE_CODE (ot) == TREE_VEC && comp_template_args (ot, nt);\n   else if (TYPE_P (nt))\n-    return TYPE_P (ot) && same_type_p (ot, nt);\n+    {\n+      int c1, c2;\n+\n+      if (!TYPE_P (ot))\n+\treturn 0;\n+\n+      /* We must handle ObjC types specially because they may differ\n+\t only in protocol qualifications (e.g., 'NSObject *' vs.\n+\t 'NSObject <Foo> *') that must be taken into account here.\n+\t See also cp/typeck.c:build_c_cast(), where a similar problem\n+\t arises.  We must call objc_comptypes() twice, since its\n+\t comparisons are _not_ symmetric.  */\n+      if ((c1 = objc_comptypes (ot, nt, 0)) >= 0\n+\t  && (c2 = objc_comptypes (nt, ot, 0)) >= 0)\n+\treturn (c1 && c2);\n+\n+      return same_type_p (ot, nt);\n+    }\n   else if (TREE_CODE (ot) == TREE_VEC || TYPE_P (ot))\n     return 0;\n   else\n@@ -8880,6 +8899,14 @@ tsubst_copy_and_build (tree t,\n       return t;\n \n     default:\n+      /* Handle Objective-C++ constructs, if appropriate.  */\n+      {\n+\ttree subst\n+\t  = objcp_tsubst_copy_and_build (t, args, complain,\n+\t\t\t\t\t in_decl, /*function_p=*/false);\n+\tif (subst)\n+\t  return subst;\n+      }\n       return tsubst_copy (t, args, complain, in_decl);\n     }\n "}, {"sha": "6955291d536168c60384c67d85c2430d97b9314d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -401,7 +401,7 @@ anon_aggr_type_p (tree node)\n \n /* Finish a scope.  */\n \n-static tree\n+tree\n do_poplevel (tree stmt_list)\n {\n   tree block = NULL;"}, {"sha": "114275cd419d69901ba7d4b90afaf98da0399e9a", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"integrate.h\"\n #include \"tree-inline.h\"\n+#include \"debug.h\"\n #include \"target.h\"\n \n static tree bot_manip (tree *, int *, void *);\n@@ -111,6 +112,7 @@ lvalue_p_1 (tree ref,\n     case STRING_CST:\n       return clk_ordinary;\n \n+    case CONST_DECL:\n     case VAR_DECL:\n       if (TREE_READONLY (ref) && ! TREE_STATIC (ref)\n \t  && DECL_LANG_SPECIFIC (ref)"}, {"sha": "319e8ad6e3564c79f0f0232dc8a4a0d145b19cd6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e58a9aa1f6d2371b0cfaff671729d4f56c72b28c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e58a9aa1f6d2371b0cfaff671729d4f56c72b28c", "patch": "@@ -514,10 +514,12 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n       class1 = TREE_TYPE (t1);\n       class2 = TREE_TYPE (t2);\n \n-      if (DERIVED_FROM_P (class1, class2))\n+      if (DERIVED_FROM_P (class1, class2) || \n+\t  (c_dialect_objc () && objc_comptypes (class1, class2, 0) == 1))\n \tt2 = (build_pointer_type \n \t      (cp_build_qualified_type (class1, TYPE_QUALS (class2))));\n-      else if (DERIVED_FROM_P (class2, class1))\n+      else if (DERIVED_FROM_P (class2, class1) ||\n+\t       (c_dialect_objc () && objc_comptypes (class2, class1, 0) == 1))\n \tt1 = (build_pointer_type \n \t      (cp_build_qualified_type (class2, TYPE_QUALS (class1))));\n       else\n@@ -1849,6 +1851,10 @@ finish_class_member_access_expr (tree object, tree name)\n   if (object == error_mark_node || name == error_mark_node)\n     return error_mark_node;\n \n+  /* If OBJECT is an ObjC class instance, we must obey ObjC access rules.  */\n+  if (!objc_is_public (object, name))\n+    return error_mark_node;\n+\n   object_type = TREE_TYPE (object);\n \n   if (processing_template_decl)\n@@ -2395,6 +2401,10 @@ build_function_call (tree function, tree params)\n   int is_method;\n   tree original = function;\n \n+  /* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF\n+     expressions, like those used for ObjC messenger dispatches.  */\n+  function = objc_rewrite_function_call (function, params);\n+\n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Strip such NOP_EXPRs, since FUNCTION is used in non-lvalue context.  */\n   if (TREE_CODE (function) == NOP_EXPR\n@@ -5441,6 +5451,14 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n   if (newrhs == error_mark_node)\n     return error_mark_node;\n \n+  if (c_dialect_objc () && flag_objc_gc)\n+    {\n+      result = objc_generate_write_barrier (lhs, modifycode, newrhs);\n+\n+      if (result)\n+\treturn result;\n+    }\n+\n   result = build2 (modifycode == NOP_EXPR ? MODIFY_EXPR : INIT_EXPR,\n \t\t   lhstype, lhs, newrhs);\n "}]}