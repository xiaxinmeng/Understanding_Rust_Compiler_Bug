{"sha": "a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFhNmUyNzEwMjNhMTIxYmYxZTBmZDNkZGY2MzMxYjBkMGM0YTkzNw==", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@google.com", "date": "2008-04-08T18:25:09Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2008-04-08T18:25:09Z"}, "message": "fold-canst.c (tree_call_nonnegative_warnv_p): New.\n\n2008-04-08  Rafael Espindola  <espindola@google.com>\n\n\t* fold-canst.c (tree_call_nonnegative_warnv_p): New.\n\t(tree_invalid_nonnegative_warnv_p): Use tree_call_nonnegative_warnv_p.\n\t* tree.h (tree_call_nonnegative_warnv_p): New.\n\nFrom-SVN: r134102", "tree": {"sha": "754086056f236b75db00acb1d0ab3dd483cb9212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/754086056f236b75db00acb1d0ab3dd483cb9212"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937/comments", "author": null, "committer": null, "parents": [{"sha": "581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581edf9260bddd3f0ce13e2f2b6758f6f638b22c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581edf9260bddd3f0ce13e2f2b6758f6f638b22c"}], "stats": {"total": 276, "additions": 151, "deletions": 125}, "files": [{"sha": "afa50f826a6e16efd7a39e011fb188f78af6988f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937", "patch": "@@ -1,3 +1,9 @@\n+2008-04-08  Rafael Espindola  <espindola@google.com>\n+\n+\t* fold-canst.c (tree_call_nonnegative_warnv_p): New.\n+\t(tree_invalid_nonnegative_warnv_p): Use tree_call_nonnegative_warnv_p.\n+\t* tree.h (tree_call_nonnegative_warnv_p): New.\n+\n 2008-04-08  Jan Hubicka  <jh@suse.cz>\n \n \t* function.c (free_after_compilation): Clear out regno_reg_rtx"}, {"sha": "26550b911698ca69af9f54c2809e60fe3a79a2a2", "filename": "gcc/fold-const.c", "status": "modified", "additions": 142, "deletions": 125, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937", "patch": "@@ -13996,6 +13996,140 @@ tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n   return false;\n }\n \n+/* Return true if T is known to be non-negative.  If the return\n+   value is based on the assumption that signed overflow is undefined,\n+   set *STRICT_OVERFLOW_P to true; otherwise, don't change\n+   *STRICT_OVERFLOW_P.  */\n+\n+bool\n+tree_call_nonnegative_warnv_p (enum tree_code code,  tree type, tree fndecl,\n+\t\t\t       tree arg0, tree arg1, bool *strict_overflow_p)\n+{\n+  if (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+    switch (DECL_FUNCTION_CODE (fndecl))\n+      {\n+\tCASE_FLT_FN (BUILT_IN_ACOS):\n+\tCASE_FLT_FN (BUILT_IN_ACOSH):\n+\tCASE_FLT_FN (BUILT_IN_CABS):\n+\tCASE_FLT_FN (BUILT_IN_COSH):\n+\tCASE_FLT_FN (BUILT_IN_ERFC):\n+\tCASE_FLT_FN (BUILT_IN_EXP):\n+\tCASE_FLT_FN (BUILT_IN_EXP10):\n+\tCASE_FLT_FN (BUILT_IN_EXP2):\n+\tCASE_FLT_FN (BUILT_IN_FABS):\n+\tCASE_FLT_FN (BUILT_IN_FDIM):\n+\tCASE_FLT_FN (BUILT_IN_HYPOT):\n+\tCASE_FLT_FN (BUILT_IN_POW10):\n+\tCASE_INT_FN (BUILT_IN_FFS):\n+\tCASE_INT_FN (BUILT_IN_PARITY):\n+\tCASE_INT_FN (BUILT_IN_POPCOUNT):\n+      case BUILT_IN_BSWAP32:\n+      case BUILT_IN_BSWAP64:\n+\t/* Always true.  */\n+\treturn true;\n+\n+\tCASE_FLT_FN (BUILT_IN_SQRT):\n+\t/* sqrt(-0.0) is -0.0.  */\n+\tif (!HONOR_SIGNED_ZEROS (TYPE_MODE (type)))\n+\t  return true;\n+\treturn tree_expr_nonnegative_warnv_p (arg0,\n+\t\t\t\t\t      strict_overflow_p);\n+\n+\tCASE_FLT_FN (BUILT_IN_ASINH):\n+\tCASE_FLT_FN (BUILT_IN_ATAN):\n+\tCASE_FLT_FN (BUILT_IN_ATANH):\n+\tCASE_FLT_FN (BUILT_IN_CBRT):\n+\tCASE_FLT_FN (BUILT_IN_CEIL):\n+\tCASE_FLT_FN (BUILT_IN_ERF):\n+\tCASE_FLT_FN (BUILT_IN_EXPM1):\n+\tCASE_FLT_FN (BUILT_IN_FLOOR):\n+\tCASE_FLT_FN (BUILT_IN_FMOD):\n+\tCASE_FLT_FN (BUILT_IN_FREXP):\n+\tCASE_FLT_FN (BUILT_IN_LCEIL):\n+\tCASE_FLT_FN (BUILT_IN_LDEXP):\n+\tCASE_FLT_FN (BUILT_IN_LFLOOR):\n+\tCASE_FLT_FN (BUILT_IN_LLCEIL):\n+\tCASE_FLT_FN (BUILT_IN_LLFLOOR):\n+\tCASE_FLT_FN (BUILT_IN_LLRINT):\n+\tCASE_FLT_FN (BUILT_IN_LLROUND):\n+\tCASE_FLT_FN (BUILT_IN_LRINT):\n+\tCASE_FLT_FN (BUILT_IN_LROUND):\n+\tCASE_FLT_FN (BUILT_IN_MODF):\n+\tCASE_FLT_FN (BUILT_IN_NEARBYINT):\n+\tCASE_FLT_FN (BUILT_IN_RINT):\n+\tCASE_FLT_FN (BUILT_IN_ROUND):\n+\tCASE_FLT_FN (BUILT_IN_SCALB):\n+\tCASE_FLT_FN (BUILT_IN_SCALBLN):\n+\tCASE_FLT_FN (BUILT_IN_SCALBN):\n+\tCASE_FLT_FN (BUILT_IN_SIGNBIT):\n+\tCASE_FLT_FN (BUILT_IN_SIGNIFICAND):\n+\tCASE_FLT_FN (BUILT_IN_SINH):\n+\tCASE_FLT_FN (BUILT_IN_TANH):\n+\tCASE_FLT_FN (BUILT_IN_TRUNC):\n+\t/* True if the 1st argument is nonnegative.  */\n+\treturn tree_expr_nonnegative_warnv_p (arg0,\n+\t\t\t\t\t      strict_overflow_p);\n+\n+\tCASE_FLT_FN (BUILT_IN_FMAX):\n+\t/* True if the 1st OR 2nd arguments are nonnegative.  */\n+\treturn (tree_expr_nonnegative_warnv_p (arg0,\n+\t\t\t\t\t       strict_overflow_p)\n+\t\t|| (tree_expr_nonnegative_warnv_p (arg1,\n+\t\t\t\t\t\t   strict_overflow_p)));\n+\n+\tCASE_FLT_FN (BUILT_IN_FMIN):\n+\t/* True if the 1st AND 2nd arguments are nonnegative.  */\n+\treturn (tree_expr_nonnegative_warnv_p (arg0,\n+\t\t\t\t\t       strict_overflow_p)\n+\t\t&& (tree_expr_nonnegative_warnv_p (arg1,\n+\t\t\t\t\t\t   strict_overflow_p)));\n+\n+\tCASE_FLT_FN (BUILT_IN_COPYSIGN):\n+\t/* True if the 2nd argument is nonnegative.  */\n+\treturn tree_expr_nonnegative_warnv_p (arg1,\n+\t\t\t\t\t      strict_overflow_p);\n+\n+\tCASE_FLT_FN (BUILT_IN_POWI):\n+\t/* True if the 1st argument is nonnegative or the second\n+\t   argument is an even integer.  */\n+\tif (TREE_CODE (arg1) == INTEGER_CST)\n+\t  {\n+\t    tree arg1 = arg1;\n+\t    if ((TREE_INT_CST_LOW (arg1) & 1) == 0)\n+\t      return true;\n+\t  }\n+\treturn tree_expr_nonnegative_warnv_p (arg0,\n+\t\t\t\t\t      strict_overflow_p);\n+\n+\tCASE_FLT_FN (BUILT_IN_POW):\n+\t/* True if the 1st argument is nonnegative or the second\n+\t   argument is an even integer valued real.  */\n+\tif (TREE_CODE (arg1) == REAL_CST)\n+\t  {\n+\t    REAL_VALUE_TYPE c;\n+\t    HOST_WIDE_INT n;\n+\n+\t    c = TREE_REAL_CST (arg1);\n+\t    n = real_to_integer (&c);\n+\t    if ((n & 1) == 0)\n+\t      {\n+\t\tREAL_VALUE_TYPE cint;\n+\t\treal_from_integer (&cint, VOIDmode, n,\n+\t\t\t\t   n < 0 ? -1 : 0, 0);\n+\t\tif (real_identical (&c, &cint))\n+\t\t  return true;\n+\t      }\n+\t  }\n+\treturn tree_expr_nonnegative_warnv_p (arg0,\n+\t\t\t\t\t      strict_overflow_p);\n+\n+      default:\n+\tbreak;\n+      }\n+  return tree_simple_nonnegative_warnv_p (code,\n+\t\t\t\t\t  type);\n+}\n+\n /* Return true if T is known to be non-negative.  If the return\n    value is based on the assumption that signed overflow is undefined,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n@@ -14045,133 +14179,16 @@ tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \n     case CALL_EXPR:\n       {\n-\ttree fndecl = get_callee_fndecl (t);\n-\tif (fndecl && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n-\t  switch (DECL_FUNCTION_CODE (fndecl))\n-\t    {\n-\t    CASE_FLT_FN (BUILT_IN_ACOS):\n-\t    CASE_FLT_FN (BUILT_IN_ACOSH):\n-\t    CASE_FLT_FN (BUILT_IN_CABS):\n-\t    CASE_FLT_FN (BUILT_IN_COSH):\n-\t    CASE_FLT_FN (BUILT_IN_ERFC):\n-\t    CASE_FLT_FN (BUILT_IN_EXP):\n-\t    CASE_FLT_FN (BUILT_IN_EXP10):\n-\t    CASE_FLT_FN (BUILT_IN_EXP2):\n-\t    CASE_FLT_FN (BUILT_IN_FABS):\n-\t    CASE_FLT_FN (BUILT_IN_FDIM):\n-\t    CASE_FLT_FN (BUILT_IN_HYPOT):\n-\t    CASE_FLT_FN (BUILT_IN_POW10):\n-\t    CASE_INT_FN (BUILT_IN_FFS):\n-\t    CASE_INT_FN (BUILT_IN_PARITY):\n-\t    CASE_INT_FN (BUILT_IN_POPCOUNT):\n-\t    case BUILT_IN_BSWAP32:\n-\t    case BUILT_IN_BSWAP64:\n-\t      /* Always true.  */\n-\t      return true;\n+\ttree arg0 = call_expr_nargs (t) > 0 ?  CALL_EXPR_ARG (t, 0) : NULL_TREE;\n+\ttree arg1 = call_expr_nargs (t) > 1 ?  CALL_EXPR_ARG (t, 1) : NULL_TREE;\n \n-\t    CASE_FLT_FN (BUILT_IN_SQRT):\n-\t      /* sqrt(-0.0) is -0.0.  */\n-\t      if (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (t))))\n-\t\treturn true;\n-\t      return tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n-\t\t\t\t\t\t    strict_overflow_p);\n-\n-\t    CASE_FLT_FN (BUILT_IN_ASINH):\n-\t    CASE_FLT_FN (BUILT_IN_ATAN):\n-\t    CASE_FLT_FN (BUILT_IN_ATANH):\n-\t    CASE_FLT_FN (BUILT_IN_CBRT):\n-\t    CASE_FLT_FN (BUILT_IN_CEIL):\n-\t    CASE_FLT_FN (BUILT_IN_ERF):\n-\t    CASE_FLT_FN (BUILT_IN_EXPM1):\n-\t    CASE_FLT_FN (BUILT_IN_FLOOR):\n-\t    CASE_FLT_FN (BUILT_IN_FMOD):\n-\t    CASE_FLT_FN (BUILT_IN_FREXP):\n-\t    CASE_FLT_FN (BUILT_IN_LCEIL):\n-\t    CASE_FLT_FN (BUILT_IN_LDEXP):\n-\t    CASE_FLT_FN (BUILT_IN_LFLOOR):\n-\t    CASE_FLT_FN (BUILT_IN_LLCEIL):\n-\t    CASE_FLT_FN (BUILT_IN_LLFLOOR):\n-\t    CASE_FLT_FN (BUILT_IN_LLRINT):\n-\t    CASE_FLT_FN (BUILT_IN_LLROUND):\n-\t    CASE_FLT_FN (BUILT_IN_LRINT):\n-\t    CASE_FLT_FN (BUILT_IN_LROUND):\n-\t    CASE_FLT_FN (BUILT_IN_MODF):\n-\t    CASE_FLT_FN (BUILT_IN_NEARBYINT):\n-\t    CASE_FLT_FN (BUILT_IN_RINT):\n-\t    CASE_FLT_FN (BUILT_IN_ROUND):\n-\t    CASE_FLT_FN (BUILT_IN_SCALB):\n-\t    CASE_FLT_FN (BUILT_IN_SCALBLN):\n-\t    CASE_FLT_FN (BUILT_IN_SCALBN):\n-\t    CASE_FLT_FN (BUILT_IN_SIGNBIT):\n-\t    CASE_FLT_FN (BUILT_IN_SIGNIFICAND):\n-\t    CASE_FLT_FN (BUILT_IN_SINH):\n-\t    CASE_FLT_FN (BUILT_IN_TANH):\n-\t    CASE_FLT_FN (BUILT_IN_TRUNC):\n-\t      /* True if the 1st argument is nonnegative.  */\n-\t      return tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n-\t\t\t\t\t\t    strict_overflow_p);\n-\n-\t    CASE_FLT_FN (BUILT_IN_FMAX):\n-\t      /* True if the 1st OR 2nd arguments are nonnegative.  */\n-\t      return (tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n-\t\t\t\t\t\t     strict_overflow_p)\n-\t\t      || (tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 1),\n-\t\t\t\t\t\t\t strict_overflow_p)));\n-\n-\t    CASE_FLT_FN (BUILT_IN_FMIN):\n-\t      /* True if the 1st AND 2nd arguments are nonnegative.  */\n-\t      return (tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n-\t\t\t\t\t\t     strict_overflow_p)\n-\t\t      && (tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 1),\n-\t\t\t\t\t\t\t strict_overflow_p)));\n-\n-\t    CASE_FLT_FN (BUILT_IN_COPYSIGN):\n-\t      /* True if the 2nd argument is nonnegative.  */\n-\t      return tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 1),\n-\t\t\t\t\t\t    strict_overflow_p);\n-\n-\t    CASE_FLT_FN (BUILT_IN_POWI):\n-\t      /* True if the 1st argument is nonnegative or the second\n-\t\t argument is an even integer.  */\n-\t      if (TREE_CODE (CALL_EXPR_ARG (t, 1)) == INTEGER_CST)\n-\t\t{\n-\t\t  tree arg1 = CALL_EXPR_ARG (t, 1);\n-\t\t  if ((TREE_INT_CST_LOW (arg1) & 1) == 0)\n-\t\t    return true;\n-\t\t}\n-\t      return tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n-\t\t\t\t\t\t    strict_overflow_p);\n-\n-\t    CASE_FLT_FN (BUILT_IN_POW):\n-\t      /* True if the 1st argument is nonnegative or the second\n-\t\t argument is an even integer valued real.  */\n-\t      if (TREE_CODE (CALL_EXPR_ARG (t, 1)) == REAL_CST)\n-\t\t{\n-\t\t  REAL_VALUE_TYPE c;\n-\t\t  HOST_WIDE_INT n;\n-\n-\t\t  c = TREE_REAL_CST (CALL_EXPR_ARG (t, 1));\n-\t\t  n = real_to_integer (&c);\n-\t\t  if ((n & 1) == 0)\n-\t\t    {\n-\t\t      REAL_VALUE_TYPE cint;\n-\t\t      real_from_integer (&cint, VOIDmode, n,\n-\t\t\t\t\t n < 0 ? -1 : 0, 0);\n-\t\t      if (real_identical (&c, &cint))\n-\t\t\treturn true;\n-\t\t    }\n-\t\t}\n-\t      return tree_expr_nonnegative_warnv_p (CALL_EXPR_ARG (t, 0),\n-\t\t\t\t\t\t    strict_overflow_p);\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\treturn tree_simple_nonnegative_warnv_p (TREE_CODE (t),\n-\t\t\t\t\t\t     TREE_TYPE (t));\n+\treturn tree_call_nonnegative_warnv_p (TREE_CODE (t),\n+\t\t\t\t\t      TREE_TYPE (t),\n+\t\t\t\t\t      get_callee_fndecl (t),\n+\t\t\t\t\t      arg0,\n+\t\t\t\t\t      arg1,\n+\t\t\t\t\t      strict_overflow_p);\n       }\n-      break;\n-\n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n     case GIMPLE_MODIFY_STMT:"}, {"sha": "6ad3d4d58de21be1b9cea7f4e2fd307a3b0a2a1f", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a1a6e271023a121bf1e0fd3ddf6331b0d0c4a937", "patch": "@@ -4846,6 +4846,9 @@ extern bool tree_binary_nonnegative_warnv_p (enum tree_code, tree, tree, tree,\n                                              bool *);\n extern bool tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p);\n extern bool tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p);\n+extern bool tree_call_nonnegative_warnv_p (enum tree_code code, tree, tree,\n+                                           tree, tree, bool *);\n+\n extern bool tree_expr_nonzero_warnv_p (tree, bool *);\n \n extern bool fold_real_zero_addition_p (const_tree, const_tree, int);"}]}