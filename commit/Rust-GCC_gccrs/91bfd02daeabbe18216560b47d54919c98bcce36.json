{"sha": "91bfd02daeabbe18216560b47d54919c98bcce36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFiZmQwMmRhZWFiYmUxODIxNjU2MGI0N2Q1NDkxOWM5OGJjY2UzNg==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2001-06-14T06:06:48Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2001-06-14T06:06:48Z"}, "message": "globals.cc: Define globals _GLIBCPP_mutex_init ()...\n\n\t* src/globals.cc: Define globals _GLIBCPP_mutex_init (),\n\t_GLIBCPP_mutex_address_init (), _GLIBCPP_once, _GLIBCPP_mutex\n\tand _GLIBCPP_mutex_address.\n\t* include/bits/stl_threads.h (_STL_mutex_lock): Use above to provide\n\tonce-only runtime initialization of _M_lock mutex when\n\t__GTHREAD_MUTEX_INIT_FUNCTION is defined.\n\t(__STL_MUTEX_INITIALIZER): Provide initializer for _STL_mutex_lock\n\tfor __GTHREAD_MUTEX_INIT_FUNCTION case.\n\nFrom-SVN: r43360", "tree": {"sha": "69f64e107f81355dfa627981137133c327e6cdf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69f64e107f81355dfa627981137133c327e6cdf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91bfd02daeabbe18216560b47d54919c98bcce36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bfd02daeabbe18216560b47d54919c98bcce36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91bfd02daeabbe18216560b47d54919c98bcce36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91bfd02daeabbe18216560b47d54919c98bcce36/comments", "author": null, "committer": null, "parents": [{"sha": "5ffd49b80090449894c03b350d2279d97d535de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ffd49b80090449894c03b350d2279d97d535de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ffd49b80090449894c03b350d2279d97d535de5"}], "stats": {"total": 102, "additions": 95, "deletions": 7}, "files": [{"sha": "2cf5c7015b42e7e2bfbc84b9d90321aa73655097", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bfd02daeabbe18216560b47d54919c98bcce36/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bfd02daeabbe18216560b47d54919c98bcce36/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=91bfd02daeabbe18216560b47d54919c98bcce36", "patch": "@@ -1,3 +1,16 @@\n+2001-06-13  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t(Approved by Mark and Benjamin.  Applied by Loren.)\n+\n+\t* src/globals.cc: Define globals _GLIBCPP_mutex_init (),\n+\t_GLIBCPP_mutex_address_init (), _GLIBCPP_once, _GLIBCPP_mutex\n+\tand _GLIBCPP_mutex_address.\n+\t* include/bits/stl_threads.h (_STL_mutex_lock): Use above to provide\n+\tonce-only runtime initialization of _M_lock mutex when\n+\t__GTHREAD_MUTEX_INIT_FUNCTION is defined.\n+\t(__STL_MUTEX_INITIALIZER): Provide initializer for _STL_mutex_lock\n+\tfor __GTHREAD_MUTEX_INIT_FUNCTION case.\n+\n 2001-06-13  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n \n \t* testsuite/26_numerics/slice_array_assignment.cc (main): New test."}, {"sha": "cdbf205df37316d60c0cd78b2b3facd1dc659a51", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bfd02daeabbe18216560b47d54919c98bcce36/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bfd02daeabbe18216560b47d54919c98bcce36/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=91bfd02daeabbe18216560b47d54919c98bcce36", "patch": "@@ -296,21 +296,62 @@ unsigned _STL_mutex_spin<__inst>::__max = _STL_mutex_spin<__inst>::__low_max;\n template <int __inst>\n unsigned _STL_mutex_spin<__inst>::__last = 0;\n \n+// GCC extension begin\n+#if defined(__STL_GTHREADS)\n+#if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n+extern __gthread_mutex_t _GLIBCPP_mutex;\n+extern __gthread_mutex_t *_GLIBCPP_mutex_address;\n+extern __gthread_once_t _GLIBCPP_once;\n+extern void _GLIBCPP_mutex_init (void);\n+extern void _GLIBCPP_mutex_address_init (void);\n+#endif\n+#endif\n+// GCC extension end\n+\n struct _STL_mutex_lock\n {\n // GCC extension begin\n #if defined(__STL_GTHREADS)\n+  // The class must be statically initialized with __STL_MUTEX_INITIALIZER.\n+#if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n+  volatile int _M_init_flag;\n+  __gthread_once_t _M_once;\n+#endif\n   __gthread_mutex_t _M_lock;\n-  void _M_initialize()\n-  {\n+  void _M_initialize() {\n #ifdef __GTHREAD_MUTEX_INIT\n-  // There should be no code in this path given the usage rules above.\n+    // There should be no code in this path given the usage rules above.\n #elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-    __GTHREAD_MUTEX_INIT_FUNCTION (&_M_lock);\n+    if (_M_init_flag) return;\n+    if (__gthread_once (&_GLIBCPP_once, _GLIBCPP_mutex_init) != 0\n+        && __gthread_active_p ())\n+      abort ();\n+    __gthread_mutex_lock (&_GLIBCPP_mutex);\n+    if (!_M_init_flag) {\n+\t// Even though we have a global lock, we use __gthread_once to be\n+\t// absolutely certain the _M_lock mutex is only initialized once on\n+\t// multiprocessor systems.\n+\t_GLIBCPP_mutex_address = &_M_lock;\n+\tif (__gthread_once (&_M_once, _GLIBCPP_mutex_address_init) != 0\n+\t    && __gthread_active_p ())\n+\t  abort ();\n+\t_M_init_flag = 1;\n+    }\n+    __gthread_mutex_unlock (&_GLIBCPP_mutex);\n #endif\n   }\n-  void _M_acquire_lock() { __gthread_mutex_lock(&_M_lock); }\n-  void _M_release_lock() { __gthread_mutex_unlock(&_M_lock); }\n+  void _M_acquire_lock() {\n+#if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n+    if (!_M_init_flag) _M_initialize();\n+#endif\n+    __gthread_mutex_lock(&_M_lock);\n+  }\n+  void _M_release_lock() {\n+#if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n+    if (!_M_init_flag) _M_initialize();\n+#endif\n+    __gthread_mutex_unlock(&_M_lock);\n+  }\n #else\n // GCC extension end\n #if defined(__STL_SGI_THREADS) || defined(__STL_WIN32THREADS)\n@@ -415,8 +456,13 @@ struct _STL_mutex_lock\n #if defined(__STL_GTHREADS)\n #ifdef __GTHREAD_MUTEX_INIT\n #define __STL_MUTEX_INITIALIZER = { __GTHREAD_MUTEX_INIT }\n+#elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n+#ifdef __GTHREAD_MUTEX_INIT_DEFAULT\n+#define __STL_MUTEX_INITIALIZER \\\n+  = { 0, __GTHREAD_ONCE_INIT, __GTHREAD_MUTEX_INIT_DEFAULT }\n #else\n-#define __STL_MUTEX_INITIALIZER\n+#define __STL_MUTEX_INITIALIZER = { 0, __GTHREAD_ONCE_INIT }\n+#endif\n #endif\n #else\n // GCC extension end"}, {"sha": "d70cc295407fe0208e730eefd2de97239269b46a", "filename": "libstdc++-v3/src/globals.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91bfd02daeabbe18216560b47d54919c98bcce36/libstdc%2B%2B-v3%2Fsrc%2Fglobals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91bfd02daeabbe18216560b47d54919c98bcce36/libstdc%2B%2B-v3%2Fsrc%2Fglobals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fglobals.cc?ref=91bfd02daeabbe18216560b47d54919c98bcce36", "patch": "@@ -25,6 +25,8 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n+#include \"bits/c++config.h\"\n+#include \"bits/gthr.h\"\n #include <fstream>\n #include <istream>\n #include <ostream>\n@@ -73,4 +75,31 @@ namespace std\n   fake_wfilebuf buf_wcin;\n   fake_wfilebuf buf_wcerr;\n #endif\n+\n+// Globals for once-only runtime initialization of mutex objects.  This\n+// allows static initialization of these objects on systems that need a\n+// function call to initialize a mutex.  For example, see stl_threads.h.\n+#if __GTHREADS\n+#ifdef __GTHREAD_MUTEX_INIT\n+// This path is not needed since static initialization of mutexs works\n+// on this platform.\n+#elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n+__gthread_once_t _GLIBCPP_once = __GTHREAD_ONCE_INIT;\n+__gthread_mutex_t _GLIBCPP_mutex;\n+__gthread_mutex_t *_GLIBCPP_mutex_address;\n+\n+// Once-only initializer function for _GLIBCPP_mutex.  \n+void\n+_GLIBCPP_mutex_init ()\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (&_GLIBCPP_mutex);\n+}\n+// Once-only initializer function for _GLIBCPP_mutex_address.  \n+void\n+_GLIBCPP_mutex_address_init ()\n+{\n+  __GTHREAD_MUTEX_INIT_FUNCTION (_GLIBCPP_mutex_address);\n+}\n+#endif\n+#endif\n }"}]}