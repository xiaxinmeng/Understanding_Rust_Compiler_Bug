{"sha": "174ec470afd5d68fe8469b1cb64a553a62349e1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc0ZWM0NzBhZmQ1ZDY4ZmU4NDY5YjFjYjY0YTU1M2E2MjM0OWUxYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-09-12T08:49:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-09-12T08:49:01Z"}, "message": "tree-loop-distribution.c (dot_rdg_1): Make graph prettier.\n\n2013-09-12  Richard Biener  <rguenther@suse.de>\n\n\t* tree-loop-distribution.c (dot_rdg_1): Make graph prettier.\n\t(dot_rdg): Use popen instead of system in optional code.\n\t(remaining_stmts, upstream_mem_writes): Remove global bitmaps.\n\t(already_processed_vertex_p): Adjust.\n\t(has_anti_or_output_dependence, predecessor_has_mem_write,\n\tmark_nodes_having_upstream_mem_writes, has_upstream_mem_writes,\n\trdg_flag_uses): Remove.\n\t(rdg_flag_vertex): Simplify.\n\t(rdg_flag_vertex_and_dependent): Rely on a correct RDG and\n\tremove recursion.\n\t(build_rdg_partition_for_component): Process the first vertex\n\tof a component only.\n\t(ldist_gen): Do not compute remaining_stmts or upstream_mem_writes.\n\n\t* gcc.dg/tree-ssa/ldist-4.c: Remove undefined behavior.  Adjust\n\texpected outcome and comment why that happens.\n\nFrom-SVN: r202516", "tree": {"sha": "1d43309f28d26aafbb93207e974cad04d16e8ea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d43309f28d26aafbb93207e974cad04d16e8ea9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/174ec470afd5d68fe8469b1cb64a553a62349e1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174ec470afd5d68fe8469b1cb64a553a62349e1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174ec470afd5d68fe8469b1cb64a553a62349e1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174ec470afd5d68fe8469b1cb64a553a62349e1b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "38c89763f9b8f4011f19b67bd4bb2d02a454cd41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38c89763f9b8f4011f19b67bd4bb2d02a454cd41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38c89763f9b8f4011f19b67bd4bb2d02a454cd41"}], "stats": {"total": 233, "additions": 53, "deletions": 180}, "files": [{"sha": "26b06d7443fb7152784af7e0a5c15b951fd72df2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174ec470afd5d68fe8469b1cb64a553a62349e1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174ec470afd5d68fe8469b1cb64a553a62349e1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=174ec470afd5d68fe8469b1cb64a553a62349e1b", "patch": "@@ -1,3 +1,19 @@\n+2013-09-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-loop-distribution.c (dot_rdg_1): Make graph prettier.\n+\t(dot_rdg): Use popen instead of system in optional code.\n+\t(remaining_stmts, upstream_mem_writes): Remove global bitmaps.\n+\t(already_processed_vertex_p): Adjust.\n+\t(has_anti_or_output_dependence, predecessor_has_mem_write,\n+\tmark_nodes_having_upstream_mem_writes, has_upstream_mem_writes,\n+\trdg_flag_uses): Remove.\n+\t(rdg_flag_vertex): Simplify.\n+\t(rdg_flag_vertex_and_dependent): Rely on a correct RDG and\n+\tremove recursion.\n+\t(build_rdg_partition_for_component): Process the first vertex\n+\tof a component only.\n+\t(ldist_gen): Do not compute remaining_stmts or upstream_mem_writes.\n+\n 2013-09-12  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (toc_relative_expr_p): Use add_cint_operand."}, {"sha": "da3f08d575327119e7c4c82c8963856af9039ca6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174ec470afd5d68fe8469b1cb64a553a62349e1b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174ec470afd5d68fe8469b1cb64a553a62349e1b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=174ec470afd5d68fe8469b1cb64a553a62349e1b", "patch": "@@ -1,3 +1,8 @@\n+2013-09-12  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ldist-4.c: Remove undefined behavior.  Adjust\n+\texpected outcome and comment why that happens.\n+\n 2013-09-11  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/58377"}, {"sha": "80626bdacac4f17d32dad5865d55d409fdcc5547", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-4.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174ec470afd5d68fe8469b1cb64a553a62349e1b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174ec470afd5d68fe8469b1cb64a553a62349e1b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-4.c?ref=174ec470afd5d68fe8469b1cb64a553a62349e1b", "patch": "@@ -10,20 +10,18 @@ int loop1 (int k)\n   a[0] = k;\n   for (i = 1; i < 100; i ++)\n     {\n-      for (j = 0; j < 100; j++)\n+      for (j = 1; j < 100; j++)\n \t{\n \t  a[j] = k * i;\n \t  b[i][j] = a[j-1] + k;\n \t}\n     }\n \n-  return b[100-1][0];\n+  return b[100-1][1];\n }\n \n-/* We used to distribute also innermost loops, but these could produce\n-   too much code in the outer loop, degrading performance of scalar\n-   code.  So this test was XFAILed because the cost model of the stand\n-   alone distribution pass has evolved.  Now it passes.  */\n-/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" { target ilp32 } } } */\n-/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 1 \"ldist\" { target lp64 } } } */\n+/* The current cost model fuses the two partitions because they have\n+   similar memory accesses.  */\n+/* { dg-final { scan-tree-dump \"similar memory accesses\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"distributed: split to 2 loops\" 0 \"ldist\" } } */\n /* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "43c3d911784383c5473afc2ec2061772ba596dd4", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 26, "deletions": 172, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174ec470afd5d68fe8469b1cb64a553a62349e1b/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174ec470afd5d68fe8469b1cb64a553a62349e1b/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=174ec470afd5d68fe8469b1cb64a553a62349e1b", "patch": "@@ -218,6 +218,9 @@ static void\n dot_rdg_1 (FILE *file, struct graph *rdg)\n {\n   int i;\n+  pretty_printer buffer;\n+  pp_needs_newline (&buffer) = false;\n+  buffer.buffer->stream = file;\n \n   fprintf (file, \"digraph RDG {\\n\");\n \n@@ -226,6 +229,11 @@ dot_rdg_1 (FILE *file, struct graph *rdg)\n       struct vertex *v = &(rdg->vertices[i]);\n       struct graph_edge *e;\n \n+      fprintf (file, \"%d [label=\\\"[%d] \", i, i);\n+      pp_gimple_stmt_1 (&buffer, RDGV_STMT (v), 0, TDF_SLIM);\n+      pp_flush (&buffer);\n+      fprintf (file, \"\\\"]\\n\");\n+\n       /* Highlight reads from memory.  */\n       if (RDG_MEM_READS_STMT (rdg, i))\n        fprintf (file, \"%d [style=filled, fillcolor=green]\\n\", i);\n@@ -268,16 +276,15 @@ dot_rdg_1 (FILE *file, struct graph *rdg)\n DEBUG_FUNCTION void\n dot_rdg (struct graph *rdg)\n {\n-  /* When debugging, enable the following code.  This cannot be used\n-     in production compilers because it calls \"system\".  */\n-#if 0\n-  FILE *file = fopen (\"/tmp/rdg.dot\", \"w\");\n-  gcc_assert (file != NULL);\n-\n+  /* When debugging, you may want to enable the following code.  */\n+#if 1\n+  FILE *file = popen(\"dot -Tx11\", \"w\");\n+  if (!file)\n+    return;\n   dot_rdg_1 (file, rdg);\n-  fclose (file);\n-\n-  system (\"dotty /tmp/rdg.dot &\");\n+  fflush (file);\n+  close (fileno (file));\n+  pclose (file);\n #else\n   dot_rdg_1 (stderr, rdg);\n #endif\n@@ -645,17 +652,6 @@ partition_has_writes (partition_t partition)\n   return partition->has_writes;\n }\n \n-/* If bit I is not set, it means that this node represents an\n-   operation that has already been performed, and that should not be\n-   performed again.  This is the subgraph of remaining important\n-   computations that is passed to the DFS algorithm for avoiding to\n-   include several times the same stores in different loops.  */\n-static bitmap remaining_stmts;\n-\n-/* A node of the RDG is marked in this bitmap when it has as a\n-   predecessor a node that writes to memory.  */\n-static bitmap upstream_mem_writes;\n-\n /* Returns true when DEF is an SSA_NAME defined in LOOP and used after\n    the LOOP.  */\n \n@@ -1080,140 +1076,12 @@ rdg_cannot_recompute_vertex_p (struct graph *rdg, int v)\n static inline bool\n already_processed_vertex_p (bitmap processed, int v)\n {\n-  return (bitmap_bit_p (processed, v)\n-\t  || !bitmap_bit_p (remaining_stmts, v));\n-}\n-\n-/* Returns NULL when there is no anti-dependence or output-dependence\n-   among the successors of vertex V, otherwise returns the edge with the\n-   dependency.  */\n-\n-static struct graph_edge *\n-has_anti_or_output_dependence (struct vertex *v)\n-{\n-  struct graph_edge *e;\n-\n-  if (v->succ)\n-    for (e = v->succ; e; e = e->succ_next)\n-      if (RDGE_TYPE (e) == anti_dd\n-\t  || RDGE_TYPE (e) == output_dd)\n-\treturn e;\n-\n-  return NULL;\n-}\n-\n-/* Returns true when V has an anti-dependence edge among its successors.  */\n-\n-static bool\n-predecessor_has_mem_write (struct graph *rdg, struct vertex *v)\n-{\n-  struct graph_edge *e;\n-\n-  if (v->pred)\n-    for (e = v->pred; e; e = e->pred_next)\n-      if (bitmap_bit_p (upstream_mem_writes, e->src)\n-\t  /* Don't consider flow channels: a write to memory followed\n-\t     by a read from memory.  These channels allow the split of\n-\t     the RDG in different partitions.  */\n-\t  && !RDG_MEM_WRITE_STMT (rdg, e->src))\n-\treturn true;\n-\n-  return false;\n-}\n-\n-/* Initializes the upstream_mem_writes bitmap following the\n-   information from RDG.  */\n-\n-static void\n-mark_nodes_having_upstream_mem_writes (struct graph *rdg)\n-{\n-  int v, x;\n-  bitmap seen = BITMAP_ALLOC (NULL);\n-\n-  for (v = rdg->n_vertices - 1; v >= 0; v--)\n-    if (!bitmap_bit_p (seen, v))\n-      {\n-\tunsigned i;\n-\tvec<int> nodes;\n-\tnodes.create (3);\n-\n-\tgraphds_dfs (rdg, &v, 1, &nodes, false, NULL);\n-\n-\tFOR_EACH_VEC_ELT (nodes, i, x)\n-\t  {\n-\t    if (!bitmap_set_bit (seen, x))\n-\t      continue;\n-\n-\t    if (RDG_MEM_WRITE_STMT (rdg, x)\n-\t\t|| predecessor_has_mem_write (rdg, &(rdg->vertices[x]))\n-\t\t/* In anti dependences the read should occur before\n-\t\t   the write, this is why both the read and the write\n-\t\t   should be placed in the same partition.  In output\n-\t\t   dependences the writes order need to be preserved.  */\n-\t\t|| has_anti_or_output_dependence (&(rdg->vertices[x])))\n-\t      bitmap_set_bit (upstream_mem_writes, x);\n-\t  }\n-\n-\tnodes.release ();\n-      }\n-}\n-\n-/* Returns true when vertex u has a memory write node as a predecessor\n-   in RDG.  */\n-\n-static bool\n-has_upstream_mem_writes (int u)\n-{\n-  return bitmap_bit_p (upstream_mem_writes, u);\n+  return bitmap_bit_p (processed, v);\n }\n \n static void rdg_flag_vertex_and_dependent (struct graph *, int, partition_t,\n \t\t\t\t\t   bitmap);\n \n-/* Flag the uses of U stopping following the information from\n-   upstream_mem_writes.  */\n-\n-static void\n-rdg_flag_uses (struct graph *rdg, int u, partition_t partition,\n-\t       bitmap processed)\n-{\n-  struct vertex *x = &(rdg->vertices[u]);\n-  gimple stmt = RDGV_STMT (x);\n-  struct graph_edge *anti_dep = has_anti_or_output_dependence (x);\n-\n-  /* Keep in the same partition the destination of an antidependence,\n-     because this is a store to the exact same location.  Putting this\n-     in another partition is bad for cache locality.  */\n-  if (anti_dep)\n-    {\n-      int v = anti_dep->dest;\n-\n-      if (!already_processed_vertex_p (processed, v))\n-\trdg_flag_vertex_and_dependent (rdg, v, partition, processed);\n-    }\n-\n-  if (is_gimple_assign (stmt) && has_upstream_mem_writes (u))\n-    {\n-      tree op0 = gimple_assign_lhs (stmt);\n-\n-      /* Scalar channels don't have enough space for transmitting data\n-\t between tasks, unless we add more storage by privatizing.  */\n-      if (is_gimple_reg (op0))\n-\t{\n-\t  use_operand_p use_p;\n-\t  imm_use_iterator iter;\n-\n-\t  FOR_EACH_IMM_USE_FAST (use_p, iter, op0)\n-\t    {\n-\t      int v = rdg_vertex_for_stmt (rdg, USE_STMT (use_p));\n-\n-\t      if (!already_processed_vertex_p (processed, v))\n-\t\trdg_flag_vertex_and_dependent (rdg, v, partition, processed);\n-\t    }\n-\t}\n-    }\n-}\n-\n /* Flag V from RDG as part of PARTITION, and also flag its loop number\n    in LOOPS.  */\n \n@@ -1229,10 +1097,7 @@ rdg_flag_vertex (struct graph *rdg, int v, partition_t partition)\n   bitmap_set_bit (partition->loops, loop->num);\n \n   if (rdg_cannot_recompute_vertex_p (rdg, v))\n-    {\n-      partition->has_writes = true;\n-      bitmap_clear_bit (remaining_stmts, v);\n-    }\n+    partition->has_writes = true;\n }\n \n /* Flag in the bitmap PARTITION the vertex V and all its predecessors.\n@@ -1247,14 +1112,11 @@ rdg_flag_vertex_and_dependent (struct graph *rdg, int v, partition_t partition,\n   nodes.create (3);\n   int x;\n \n-  bitmap_set_bit (processed, v);\n-  rdg_flag_uses (rdg, v, partition, processed);\n-  graphds_dfs (rdg, &v, 1, &nodes, false, remaining_stmts);\n-  rdg_flag_vertex (rdg, v, partition);\n+  graphds_dfs (rdg, &v, 1, &nodes, false, NULL);\n \n   FOR_EACH_VEC_ELT (nodes, i, x)\n-    if (!already_processed_vertex_p (processed, x))\n-      rdg_flag_vertex_and_dependent (rdg, x, partition, processed);\n+    if (bitmap_set_bit (processed, x))\n+      rdg_flag_vertex (rdg, x, partition);\n \n   nodes.release ();\n }\n@@ -1322,13 +1184,14 @@ rdg_flag_loop_exits (struct graph *rdg, partition_t partition,\n static partition_t\n build_rdg_partition_for_component (struct graph *rdg, rdgc c)\n {\n-  int i, v;\n   partition_t partition = partition_alloc (NULL, NULL);\n   bitmap processed = BITMAP_ALLOC (NULL);\n \n-  FOR_EACH_VEC_ELT (c->vertices, i, v)\n-    if (!already_processed_vertex_p (processed, v))\n-      rdg_flag_vertex_and_dependent (rdg, v, partition, processed);\n+  /* Flag the first vertex of the component and its dependent nodes.\n+     Other members of the component are included in its dependencies.\n+     ???  What do we need components for again?  To early merge initial\n+     vertices that are in a SCC of the RDG?  */\n+  rdg_flag_vertex_and_dependent (rdg, c->vertices[0], partition, processed);\n \n   rdg_flag_loop_exits (rdg, partition, processed);\n \n@@ -1777,13 +1640,8 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n   bitmap processed = BITMAP_ALLOC (NULL);\n   bool any_builtin;\n \n-  remaining_stmts = BITMAP_ALLOC (NULL);\n-  upstream_mem_writes = BITMAP_ALLOC (NULL);\n-\n   for (i = 0; i < rdg->n_vertices; i++)\n     {\n-      bitmap_set_bit (remaining_stmts, i);\n-\n       /* Save in OTHER_STORES all the memory writes that are not in\n \t STARTING_VERTICES.  */\n       if (RDG_MEM_WRITE_STMT (rdg, i))\n@@ -1804,7 +1662,6 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n \t}\n     }\n \n-  mark_nodes_having_upstream_mem_writes (rdg);\n   rdg_build_components (rdg, starting_vertices, &components);\n   rdg_build_partitions (rdg, components, &other_stores, &partitions,\n \t\t\tprocessed);\n@@ -1929,9 +1786,6 @@ ldist_gen (struct loop *loop, struct graph *rdg,\n \n  ldist_done:\n \n-  BITMAP_FREE (remaining_stmts);\n-  BITMAP_FREE (upstream_mem_writes);\n-\n   FOR_EACH_VEC_ELT (partitions, i, partition)\n     partition_free (partition);\n "}]}