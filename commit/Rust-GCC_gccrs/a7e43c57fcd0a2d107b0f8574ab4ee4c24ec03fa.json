{"sha": "a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdlNDNjNTdmY2QwYTJkMTA3YjBmODU3NGFiNGVlNGMyNGVjMDNmYQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2015-05-20T05:15:56Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2015-05-20T05:15:56Z"}, "message": "re PR tree-optimization/65447 (AArch64: iv-opt causes bad addressing)\n\n\n\tPR tree-optimization/65447\n\t* tree-ssa-loop-ivopts.c (struct iv_use): New fields.\n\t(dump_use, dump_uses): Support to dump sub use.\n\t(record_use): New parameters to support sub use.  Remove call to\n\tdump_use.\n\t(record_sub_use, record_group_use): New functions.\n\t(compute_max_addr_offset, split_all_small_groups): New functions.\n\t(group_address_uses, rewrite_use_address): New functions.\n\t(strip_offset): New declaration.\n\t(find_interesting_uses_address): Call record_group_use.\n\t(add_candidate): New assertion.\n\t(infinite_cost_p): Move definition forward.\n\t(add_costs): Check INFTY cost and return immediately.\n\t(get_computation_cost_at): Clear setup cost and dependent bitmap\n\tfor sub uses.\n\t(determine_use_iv_cost_address): Compute cost for sub uses.\n\t(rewrite_use_address_1): Rename from old rewrite_use_address.\n\t(free_loop_data): Free sub uses.\n\t(tree_ssa_iv_optimize_loop): Call group_address_uses.\n\n\tgcc/testsuite\n\tPR tree-optimization/65447\n\t* gcc.dg/tree-ssa/pr65447.c: New test.\n\nFrom-SVN: r223433", "tree": {"sha": "f2cef97967fa56aeda80daa5d70d0d2f7e50831e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2cef97967fa56aeda80daa5d70d0d2f7e50831e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa/comments", "author": null, "committer": null, "parents": [{"sha": "b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6875aac2b5a0e5e1b284e4934b0f12e8a2afdd0"}], "stats": {"total": 459, "additions": 439, "deletions": 20}, "files": [{"sha": "b1115f5ffd3799cfe1689f22ffa2f5847d6d0918", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa", "patch": "@@ -1,3 +1,25 @@\n+2015-05-20  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/65447\n+\t* tree-ssa-loop-ivopts.c (struct iv_use): New fields.\n+\t(dump_use, dump_uses): Support to dump sub use.\n+\t(record_use): New parameters to support sub use.  Remove call to\n+\tdump_use.\n+\t(record_sub_use, record_group_use): New functions.\n+\t(compute_max_addr_offset, split_all_small_groups): New functions.\n+\t(group_address_uses, rewrite_use_address): New functions.\n+\t(strip_offset): New declaration.\n+\t(find_interesting_uses_address): Call record_group_use.\n+\t(add_candidate): New assertion.\n+\t(infinite_cost_p): Move definition forward.\n+\t(add_costs): Check INFTY cost and return immediately.\n+\t(get_computation_cost_at): Clear setup cost and dependent bitmap\n+\tfor sub uses.\n+\t(determine_use_iv_cost_address): Compute cost for sub uses.\n+\t(rewrite_use_address_1): Rename from old rewrite_use_address.\n+\t(free_loop_data): Free sub uses.\n+\t(tree_ssa_iv_optimize_loop): Call group_address_uses.\n+\n 2015-05-20  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \t    Jim Wilson  <jim.wilson@linaro.org>\n "}, {"sha": "072d611ad8fdf4f3672eba756ca9de22a2ff2325", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa", "patch": "@@ -1,3 +1,8 @@\n+2015-05-20  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/65447\n+\t* gcc.dg/tree-ssa/pr65447.c: New test.\n+\n 2015-05-19  Nathan sidwell  <nathan@acm.org>\n \n \t* g++.dg/cpp0x/pr65954.C: New."}, {"sha": "c5bddbfba9209b787a33b58ebd289234365f66be", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr65447.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr65447.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr65447.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr65447.c?ref=a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+\n+void foo (double *p)\n+{\n+  int i;\n+  for (i = -20000; i < 200000; i+= 40)\n+    {\n+      p[i+0] = 1.0;\n+      p[i+1] = 1.0;\n+      p[i+2] = 1.0;\n+      p[i+3] = 1.0;\n+      p[i+4] = 1.0;\n+      p[i+5] = 1.0;\n+      p[i+6] = 1.0;\n+      p[i+7] = 1.0;\n+      p[i+8] = 1.0;\n+      p[i+9] = 1.0;\n+      p[i+10] = 1.0;\n+      p[i+11] = 1.0;\n+      p[i+12] = 1.0;\n+      p[i+13] = 1.0;\n+      p[i+14] = 1.0;\n+      p[i+15] = 1.0;\n+      p[i+16] = 1.0;\n+      p[i+17] = 1.0;\n+      p[i+18] = 1.0;\n+      p[i+19] = 1.0;\n+      p[i+20] = 1.0;\n+      p[i+21] = 1.0;\n+      p[i+22] = 1.0;\n+      p[i+23] = 1.0;\n+      p[i+24] = 1.0;\n+      p[i+25] = 1.0;\n+      p[i+26] = 1.0;\n+      p[i+27] = 1.0;\n+      p[i+28] = 1.0;\n+      p[i+29] = 1.0;\n+      p[i+30] = 1.0;\n+      p[i+31] = 1.0;\n+      p[i+32] = 1.0;\n+      p[i+33] = 1.0;\n+      p[i+34] = 1.0;\n+      p[i+35] = 1.0;\n+      p[i+36] = 1.0;\n+      p[i+37] = 1.0;\n+      p[i+38] = 1.0;\n+      p[i+39] = 1.0;\n+    }\n+}\n+\n+/* We should groups address type IV uses.  */\n+/* { dg-final { scan-tree-dump-not \"\\\\nuse 2\\\\n\" \"ivopts\" } }  */\n+/* { dg-final { cleanup-tree-dump \"ivopts\" } }  */"}, {"sha": "854d7baf10ae55746f3fd77bbb595d519c3e686c", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 358, "deletions": 20, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=a7e43c57fcd0a2d107b0f8574ab4ee4c24ec03fa", "patch": "@@ -226,6 +226,7 @@ struct cost_pair\n struct iv_use\n {\n   unsigned id;\t\t/* The id of the use.  */\n+  unsigned sub_id;\t/* The id of the sub use.  */\n   enum use_type type;\t/* Type of the use.  */\n   struct iv *iv;\t/* The induction variable it is based on.  */\n   gimple stmt;\t\t/* Statement in that it occurs.  */\n@@ -239,6 +240,11 @@ struct iv_use\n \n   struct iv_cand *selected;\n \t\t\t/* The selected candidate.  */\n+\n+  struct iv_use *next;\t/* The next sub use.  */\n+  tree addr_base;\t/* Base address with const offset stripped.  */\n+  unsigned HOST_WIDE_INT addr_offset;\n+\t\t\t/* Const offset stripped from base address.  */\n };\n \n /* The position where the iv is computed.  */\n@@ -556,7 +562,11 @@ dump_iv (FILE *file, struct iv *iv)\n void\n dump_use (FILE *file, struct iv_use *use)\n {\n-  fprintf (file, \"use %d\\n\", use->id);\n+  fprintf (file, \"use %d\", use->id);\n+  if (use->sub_id)\n+    fprintf (file, \".%d\", use->sub_id);\n+\n+  fprintf (file, \"\\n\");\n \n   switch (use->type)\n     {\n@@ -605,8 +615,12 @@ dump_uses (FILE *file, struct ivopts_data *data)\n   for (i = 0; i < n_iv_uses (data); i++)\n     {\n       use = iv_use (data, i);\n-\n-      dump_use (file, use);\n+      do\n+\t{\n+\t  dump_use (file, use);\n+\t  use = use->next;\n+\t}\n+      while (use);\n       fprintf (file, \"\\n\");\n     }\n }\n@@ -1327,33 +1341,88 @@ find_induction_variables (struct ivopts_data *data)\n   return true;\n }\n \n-/* Records a use of type USE_TYPE at *USE_P in STMT whose value is IV.  */\n+/* Records a use of type USE_TYPE at *USE_P in STMT whose value is IV.\n+   For address type use, ADDR_BASE is the stripped IV base, ADDR_OFFSET\n+   is the const offset stripped from IV base.  For uses of other types,\n+   ADDR_BASE and ADDR_OFFSET are zero by default.  */\n \n static struct iv_use *\n record_use (struct ivopts_data *data, tree *use_p, struct iv *iv,\n-\t    gimple stmt, enum use_type use_type)\n+\t    gimple stmt, enum use_type use_type, tree addr_base = NULL,\n+\t    unsigned HOST_WIDE_INT addr_offset = 0)\n {\n   struct iv_use *use = XCNEW (struct iv_use);\n \n   use->id = n_iv_uses (data);\n+  use->sub_id = 0;\n   use->type = use_type;\n   use->iv = iv;\n   use->stmt = stmt;\n   use->op_p = use_p;\n   use->related_cands = BITMAP_ALLOC (NULL);\n+  use->next = NULL;\n+  use->addr_base = addr_base;\n+  use->addr_offset = addr_offset;\n \n   /* To avoid showing ssa name in the dumps, if it was not reset by the\n      caller.  */\n   iv->ssa_name = NULL_TREE;\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_use (dump_file, use);\n-\n   data->iv_uses.safe_push (use);\n \n   return use;\n }\n \n+/* Records a sub use of type USE_TYPE at *USE_P in STMT whose value is IV.\n+   The sub use is recorded under the one whose use id is ID_GROUP.  */\n+\n+static struct iv_use *\n+record_sub_use (struct ivopts_data *data, tree *use_p,\n+\t\t    struct iv *iv, gimple stmt, enum use_type use_type,\n+\t\t    tree addr_base, unsigned HOST_WIDE_INT addr_offset,\n+\t\t    unsigned int id_group)\n+{\n+  struct iv_use *use = XCNEW (struct iv_use);\n+  struct iv_use *group = iv_use (data, id_group);\n+\n+  use->id = group->id;\n+  use->sub_id = 0;\n+  use->type = use_type;\n+  use->iv = iv;\n+  use->stmt = stmt;\n+  use->op_p = use_p;\n+  use->related_cands = NULL;\n+  use->addr_base = addr_base;\n+  use->addr_offset = addr_offset;\n+\n+  /* Sub use list is maintained in offset ascending order.  */\n+  if (addr_offset <= group->addr_offset)\n+    {\n+      use->related_cands = group->related_cands;\n+      group->related_cands = NULL;\n+      use->next = group;\n+      data->iv_uses[id_group] = use;\n+    }\n+  else\n+    {\n+      struct iv_use *pre;\n+      do\n+\t{\n+\t  pre = group;\n+\t  group = group->next;\n+\t}\n+      while (group && addr_offset > group->addr_offset);\n+      use->next = pre->next;\n+      pre->next = use;\n+    }\n+\n+  /* To avoid showing ssa name in the dumps, if it was not reset by the\n+     caller.  */\n+  iv->ssa_name = NULL_TREE;\n+\n+  return use;\n+}\n+\n /* Checks whether OP is a loop-level invariant and if so, records it.\n    NONLINEAR_USE is true if the invariant is used in a way we do not\n    handle specially.  */\n@@ -1838,6 +1907,50 @@ may_be_nonaddressable_p (tree expr)\n   return false;\n }\n \n+static tree\n+strip_offset (tree expr, unsigned HOST_WIDE_INT *offset);\n+\n+/* Record a use of type USE_TYPE at *USE_P in STMT whose value is IV.\n+   If there is an existing use which has same stripped iv base and step,\n+   this function records this one as a sub use to that; otherwise records\n+   it as a normal one.  */\n+\n+static struct iv_use *\n+record_group_use (struct ivopts_data *data, tree *use_p,\n+\t\t  struct iv *iv, gimple stmt, enum use_type use_type)\n+{\n+  unsigned int i;\n+  struct iv_use *use;\n+  tree addr_base;\n+  unsigned HOST_WIDE_INT addr_offset;\n+\n+  /* Only support sub use for address type uses, that is, with base\n+     object.  */\n+  if (!iv->base_object)\n+    return record_use (data, use_p, iv, stmt, use_type);\n+\n+  addr_base = strip_offset (iv->base, &addr_offset);\n+  for (i = 0; i < n_iv_uses (data); i++)\n+    {\n+      use = iv_use (data, i);\n+      if (use->type != USE_ADDRESS || !use->iv->base_object)\n+\tcontinue;\n+\n+      /* Check if it has the same stripped base and step.  */\n+      if (operand_equal_p (iv->base_object, use->iv->base_object, 0)\n+\t  && operand_equal_p (iv->step, use->iv->step, 0)\n+\t  && operand_equal_p (addr_base, use->addr_base, 0))\n+\tbreak;\n+    }\n+\n+  if (i == n_iv_uses (data))\n+    return record_use (data, use_p, iv, stmt,\n+\t\t       use_type, addr_base, addr_offset);\n+  else\n+    return record_sub_use (data, use_p, iv, stmt,\n+\t\t\t   use_type, addr_base, addr_offset, i);\n+}\n+\n /* Finds addresses in *OP_P inside STMT.  */\n \n static void\n@@ -1948,7 +2061,7 @@ find_interesting_uses_address (struct ivopts_data *data, gimple stmt, tree *op_p\n     }\n \n   civ = alloc_iv (base, step);\n-  record_use (data, op_p, civ, stmt, USE_ADDRESS);\n+  record_group_use (data, op_p, civ, stmt, USE_ADDRESS);\n   return;\n \n fail:\n@@ -2134,6 +2247,172 @@ find_interesting_uses (struct ivopts_data *data)\n   free (body);\n }\n \n+/* Compute maximum offset of [base + offset] addressing mode\n+   for memory reference represented by USE.  */\n+\n+static HOST_WIDE_INT\n+compute_max_addr_offset (struct iv_use *use)\n+{\n+  int width;\n+  rtx reg, addr;\n+  HOST_WIDE_INT i, off;\n+  unsigned list_index, num;\n+  addr_space_t as;\n+  machine_mode mem_mode, addr_mode;\n+  static vec<HOST_WIDE_INT> max_offset_list;\n+\n+  as = TYPE_ADDR_SPACE (TREE_TYPE (use->iv->base));\n+  mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));\n+\n+  num = max_offset_list.length ();\n+  list_index = (unsigned) as * MAX_MACHINE_MODE + (unsigned) mem_mode;\n+  if (list_index >= num)\n+    {\n+      max_offset_list.safe_grow (list_index + MAX_MACHINE_MODE);\n+      for (; num < max_offset_list.length (); num++)\n+\tmax_offset_list[num] = -1;\n+    }\n+\n+  off = max_offset_list[list_index];\n+  if (off != -1)\n+    return off;\n+\n+  addr_mode = targetm.addr_space.address_mode (as);\n+  reg = gen_raw_REG (addr_mode, LAST_VIRTUAL_REGISTER + 1);\n+  addr = gen_rtx_fmt_ee (PLUS, addr_mode, reg, NULL_RTX);\n+\n+  width = GET_MODE_BITSIZE (addr_mode) - 1;\n+  if (width > (HOST_BITS_PER_WIDE_INT - 1))\n+    width = HOST_BITS_PER_WIDE_INT - 1;\n+\n+  for (i = width; i > 0; i--)\n+    {\n+      off = ((unsigned HOST_WIDE_INT) 1 << i) - 1;\n+      XEXP (addr, 1) = gen_int_mode (off, addr_mode);\n+      if (memory_address_addr_space_p (mem_mode, addr, as))\n+\tbreak;\n+\n+      /* For some strict-alignment targets, the offset must be naturally\n+\t aligned.  Try an aligned offset if mem_mode is not QImode.  */\n+      off = ((unsigned HOST_WIDE_INT) 1 << i);\n+      if (off > GET_MODE_SIZE (mem_mode) && mem_mode != QImode)\n+\t{\n+\t  off -= GET_MODE_SIZE (mem_mode);\n+\t  XEXP (addr, 1) = gen_int_mode (off, addr_mode);\n+\t  if (memory_address_addr_space_p (mem_mode, addr, as))\n+\t    break;\n+\t}\n+    }\n+  if (i == 0)\n+    off = 0;\n+\n+  max_offset_list[list_index] = off;\n+  return off;\n+}\n+\n+/* Check if all small groups should be split.  Return true if and\n+   only if:\n+\n+     1) At least one groups contain two uses with different offsets.\n+     2) No group contains more than two uses with different offsets.\n+\n+   Return false otherwise.  We want to split such groups because:\n+\n+     1) Small groups don't have much benefit and may interfer with\n+\tgeneral candidate selection.\n+     2) Size for problem with only small groups is usually small and\n+\tgeneral algorithm can handle it well.\n+\n+   TODO -- Above claim may not hold when auto increment is supported.  */\n+\n+static bool\n+split_all_small_groups (struct ivopts_data *data)\n+{\n+  bool split_p = false;\n+  unsigned int i, n, distinct;\n+  struct iv_use *pre, *use;\n+\n+  n = n_iv_uses (data);\n+  for (i = 0; i < n; i++)\n+    {\n+      use = iv_use (data, i);\n+      if (!use->next)\n+\tcontinue;\n+\n+      distinct = 1;\n+      gcc_assert (use->type == USE_ADDRESS);\n+      for (pre = use, use = use->next; use; pre = use, use = use->next)\n+\t{\n+\t  if (pre->addr_offset != use->addr_offset)\n+\t    distinct++;\n+\n+\t  if (distinct > 2)\n+\t    return false;\n+\t}\n+      if (distinct == 2)\n+\tsplit_p = true;\n+    }\n+\n+  return split_p;\n+}\n+\n+/* For each group of address type uses, this function further groups\n+   these uses according to the maximum offset supported by target's\n+   [base + offset] addressing mode.  */\n+\n+static void\n+group_address_uses (struct ivopts_data *data)\n+{\n+  HOST_WIDE_INT max_offset = -1;\n+  unsigned int i, n, sub_id;\n+  struct iv_use *pre, *use;\n+  unsigned HOST_WIDE_INT addr_offset_first;\n+\n+  /* Reset max offset to split all small groups.  */\n+  if (split_all_small_groups (data))\n+    max_offset = 0;\n+\n+  n = n_iv_uses (data);\n+  for (i = 0; i < n; i++)\n+    {\n+      use = iv_use (data, i);\n+      if (!use->next)\n+\tcontinue;\n+\n+      gcc_assert (use->type == USE_ADDRESS);\n+      if (max_offset != 0)\n+\tmax_offset = compute_max_addr_offset (use);\n+\n+      while (use)\n+\t{\n+\t  sub_id = 0;\n+\t  addr_offset_first = use->addr_offset;\n+\t  /* Only uses with offset that can fit in offset part against\n+\t     the first use can be grouped together.  */\n+\t  for (pre = use, use = use->next;\n+\t       use && (use->addr_offset - addr_offset_first\n+\t\t       <= (unsigned HOST_WIDE_INT) max_offset);\n+\t       pre = use, use = use->next)\n+\t    {\n+\t      use->id = pre->id;\n+\t      use->sub_id = ++sub_id;\n+\t    }\n+\n+\t  /* Break the list and create new group.  */\n+\t  if (use)\n+\t    {\n+\t      pre->next = NULL;\n+\t      use->id = n_iv_uses (data);\n+\t      use->related_cands = BITMAP_ALLOC (NULL);\n+\t      data->iv_uses.safe_push (use);\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    dump_uses (dump_file, data);\n+}\n+\n /* Strips constant offsets from EXPR and stores them to OFFSET.  If INSIDE_ADDR\n    is true, assume we are inside an address.  If TOP_COMPREF is true, assume\n    we are at the top-level of the processed address.  */\n@@ -2557,6 +2836,8 @@ static void\n add_candidate (struct ivopts_data *data,\n \t       tree base, tree step, bool important, struct iv_use *use)\n {\n+  gcc_assert (use == NULL || use->sub_id == 0);\n+\n   if (ip_normal_pos (data->current_loop))\n     add_candidate_1 (data, base, step, important, IP_NORMAL, use, NULL);\n   if (ip_end_pos (data->current_loop)\n@@ -2786,11 +3067,22 @@ new_cost (unsigned runtime, unsigned complexity)\n   return cost;\n }\n \n+/* Returns true if COST is infinite.  */\n+\n+static bool\n+infinite_cost_p (comp_cost cost)\n+{\n+  return cost.cost == INFTY;\n+}\n+\n /* Adds costs COST1 and COST2.  */\n \n static comp_cost\n add_costs (comp_cost cost1, comp_cost cost2)\n {\n+  if (infinite_cost_p (cost1) || infinite_cost_p (cost2))\n+    return infinite_cost;\n+\n   cost1.cost += cost2.cost;\n   cost1.complexity += cost2.complexity;\n \n@@ -2819,14 +3111,6 @@ compare_costs (comp_cost cost1, comp_cost cost2)\n   return cost1.cost - cost2.cost;\n }\n \n-/* Returns true if COST is infinite.  */\n-\n-static bool\n-infinite_cost_p (comp_cost cost)\n-{\n-  return cost.cost == INFTY;\n-}\n-\n /* Sets cost of (USE, CANDIDATE) pair to COST and record that it depends\n    on invariants DEPENDS_ON and that the value used in expressing it\n    is VALUE, and in case of iv elimination the comparison operator is COMP.  */\n@@ -4301,7 +4585,15 @@ get_computation_cost_at (struct ivopts_data *data,\n       cost.cost += add_cost (data->speed, TYPE_MODE (ctype));\n     }\n \n-  if (inv_expr_id)\n+  /* Set of invariants depended on by sub use has already been computed\n+     for the first use in the group.  */\n+  if (use->sub_id)\n+    {\n+      cost.cost = 0;\n+      if (depends_on && *depends_on)\n+\tbitmap_clear (*depends_on);\n+    }\n+  else if (inv_expr_id)\n     {\n       *inv_expr_id =\n           get_loop_invariant_expr_id (data, ubase, cbase, ratio, address_p);\n@@ -4430,6 +4722,8 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n   bitmap depends_on;\n   bool can_autoinc;\n   int inv_expr_id = -1;\n+  struct iv_use *sub_use;\n+  comp_cost sub_cost;\n   comp_cost cost = get_computation_cost (data, use, cand, true, &depends_on,\n \t\t\t\t\t &can_autoinc, &inv_expr_id);\n \n@@ -4443,6 +4737,15 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n       else if (cand->pos == IP_AFTER_USE || cand->pos == IP_BEFORE_USE)\n \tcost = infinite_cost;\n     }\n+  for (sub_use = use->next;\n+       sub_use && !infinite_cost_p (cost);\n+       sub_use = sub_use->next)\n+    {\n+       sub_cost = get_computation_cost (data, sub_use, cand, true, &depends_on,\n+\t\t\t\t\t&can_autoinc, &inv_expr_id);\n+       cost = add_costs (cost, sub_cost);\n+    }\n+\n   set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE, ERROR_MARK,\n                    inv_expr_id);\n \n@@ -6586,8 +6889,8 @@ adjust_iv_update_pos (struct iv_cand *cand, struct iv_use *use)\n /* Rewrites USE (address that is an iv) using candidate CAND.  */\n \n static void\n-rewrite_use_address (struct ivopts_data *data,\n-\t\t     struct iv_use *use, struct iv_cand *cand)\n+rewrite_use_address_1 (struct ivopts_data *data,\n+\t\t       struct iv_use *use, struct iv_cand *cand)\n {\n   aff_tree aff;\n   gimple_stmt_iterator bsi = gsi_for_stmt (use->stmt);\n@@ -6622,6 +6925,28 @@ rewrite_use_address (struct ivopts_data *data,\n   *use->op_p = ref;\n }\n \n+/* Rewrites USE (address that is an iv) using candidate CAND.  If it's the\n+   first use of a group, rewrites sub uses in the group too.  */\n+\n+static void\n+rewrite_use_address (struct ivopts_data *data,\n+\t\t      struct iv_use *use, struct iv_cand *cand)\n+{\n+  struct iv_use *next;\n+\n+  gcc_assert (use->sub_id == 0);\n+  rewrite_use_address_1 (data, use, cand);\n+  update_stmt (use->stmt);\n+\n+  for (next = use->next; next != NULL; next = next->next)\n+    {\n+      rewrite_use_address_1 (data, next, cand);\n+      update_stmt (next->stmt);\n+    }\n+\n+  return;\n+}\n+\n /* Rewrites USE (the condition such that one of the arguments is an iv) using\n    candidate CAND.  */\n \n@@ -6897,6 +7222,18 @@ free_loop_data (struct ivopts_data *data)\n   for (i = 0; i < n_iv_uses (data); i++)\n     {\n       struct iv_use *use = iv_use (data, i);\n+      struct iv_use *pre = use, *sub = use->next;\n+\n+      while (sub)\n+\t{\n+\t  gcc_assert (sub->related_cands == NULL);\n+\t  gcc_assert (sub->n_map_members == 0 && sub->cost_map == NULL);\n+\n+\t  free (sub->iv);\n+\t  pre = sub;\n+\t  sub = sub->next;\n+\t  free (pre);\n+\t}\n \n       free (use->iv);\n       BITMAP_FREE (use->related_cands);\n@@ -7023,6 +7360,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n \n   /* Finds interesting uses (item 1).  */\n   find_interesting_uses (data);\n+  group_address_uses (data);\n   if (n_iv_uses (data) > MAX_CONSIDERED_USES)\n     goto finish;\n "}]}