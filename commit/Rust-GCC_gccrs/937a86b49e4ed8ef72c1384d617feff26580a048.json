{"sha": "937a86b49e4ed8ef72c1384d617feff26580a048", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM3YTg2YjQ5ZTRlZDhlZjcyYzEzODRkNjE3ZmVmZjI2NTgwYTA0OA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-11-12T17:18:37Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-11-12T17:18:37Z"}, "message": "PR middle-end/83688 - check if buffers may overlap when copying strings using sprintf\n\ngcc/ChangeLog:\n\n\tPR middle-end/83688\n\t* gimple-ssa-sprintf.c (format_result::alias_info): New struct.\n\t(directive::argno): New member.\n\t(format_result::aliases, format_result::alias_count): New data members.\n\t(format_result::append_alias): New member function.\n\t(fmtresult::dst_offset): New data member.\n\t(pass_sprintf_length::call_info::dst_origin): New data member.\n\t(pass_sprintf_length::call_info::dst_field, dst_offset): Same.\n\t(char_type_p, array_elt_at_offset, field_at_offset): New functions.\n\t(get_origin_and_offset): Same.\n\t(format_string): Call it.\n\t(format_directive): Call append_alias and set directive argument\n\tnumber.\n\t(maybe_warn_overlap): New function.\n\t(pass_sprintf_length::compute_format_length): Call it.\n\t(pass_sprintf_length::handle_gimple_call): Initialize new members.\n\t* gcc/tree-ssa-strlen.c (): Also enable when -Wrestrict is on.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/35503\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-23.c: New test.\n\nFrom-SVN: r278098", "tree": {"sha": "f247820d00501e7e2424408054361e5b8ea56067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f247820d00501e7e2424408054361e5b8ea56067"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/937a86b49e4ed8ef72c1384d617feff26580a048", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/937a86b49e4ed8ef72c1384d617feff26580a048", "html_url": "https://github.com/Rust-GCC/gccrs/commit/937a86b49e4ed8ef72c1384d617feff26580a048", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/937a86b49e4ed8ef72c1384d617feff26580a048/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "966e31a17b92d627dc323a77d363948012c3163d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/966e31a17b92d627dc323a77d363948012c3163d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/966e31a17b92d627dc323a77d363948012c3163d"}], "stats": {"total": 1455, "additions": 1335, "deletions": 120}, "files": [{"sha": "ddd9817690d485b0a07eaefdbbd8bcc4a31b650b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937a86b49e4ed8ef72c1384d617feff26580a048/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937a86b49e4ed8ef72c1384d617feff26580a048/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=937a86b49e4ed8ef72c1384d617feff26580a048", "patch": "@@ -1,3 +1,23 @@\n+2019-11-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/83688\n+\t* gimple-ssa-sprintf.c (format_result::alias_info): New struct.\n+\t(directive::argno): New member.\n+\t(format_result::aliases, format_result::alias_count): New data members.\n+\t(format_result::append_alias): New member function.\n+\t(fmtresult::dst_offset): New data member.\n+\t(pass_sprintf_length::call_info::dst_origin): New data member.\n+\t(pass_sprintf_length::call_info::dst_field, dst_offset): Same.\n+\t(char_type_p, array_elt_at_offset, field_at_offset): New functions.\n+\t(get_origin_and_offset): Same.\n+\t(format_string): Call it.\n+\t(format_directive): Call append_alias and set directive argument\n+\tnumber.\n+\t(maybe_warn_overlap): New function.\n+\t(pass_sprintf_length::compute_format_length): Call it.\n+\t(pass_sprintf_length::handle_gimple_call): Initialize new members.\n+\t* gcc/tree-ssa-strlen.c (): Also enable when -Wrestrict is on.\n+\n 2019-11-12  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \tPR rtl-optimization/92430"}, {"sha": "f6cd8e961dbe55d0f03b4eba52437bcef478670a", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 600, "deletions": 120, "changes": 720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937a86b49e4ed8ef72c1384d617feff26580a048/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937a86b49e4ed8ef72c1384d617feff26580a048/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=937a86b49e4ed8ef72c1384d617feff26580a048", "patch": "@@ -85,6 +85,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"vr-values.h\"\n #include \"tree-ssa-strlen.h\"\n+#include \"tree-dfa.h\"\n \n /* The likely worst case value of MB_LEN_MAX for the target, large enough\n    for UTF-8.  Ideally, this would be obtained by a target hook if it were\n@@ -105,9 +106,6 @@ namespace {\n \n static int warn_level;\n \n-struct call_info;\n-struct format_result;\n-\n /* The minimum, maximum, likely, and unlikely maximum number of bytes\n    of output either a formatting function or an individual directive\n    can result in.  */\n@@ -132,80 +130,6 @@ struct result_range\n   unsigned HOST_WIDE_INT unlikely;\n };\n \n-/* The result of a call to a formatted function.  */\n-\n-struct format_result\n-{\n-  /* Range of characters written by the formatted function.\n-     Setting the minimum to HOST_WIDE_INT_MAX disables all\n-     length tracking for the remainder of the format string.  */\n-  result_range range;\n-\n-  /* True when the range above is obtained from known values of\n-     directive arguments, or bounds on the amount of output such\n-     as width and precision, and not the result of  heuristics that\n-     depend on warning levels.  It's used to issue stricter diagnostics\n-     in cases where strings of unknown lengths are bounded by the arrays\n-     they are determined to refer to.  KNOWNRANGE must not be used for\n-     the return value optimization.  */\n-  bool knownrange;\n-\n-  /* True if no individual directive could fail or result in more than\n-     4095 bytes of output (the total NUMBER_CHARS_{MIN,MAX} might be\n-     greater).  Implementations are not required to handle directives\n-     that produce more than 4K bytes (leading to undefined behavior)\n-     and so when one is found it disables the return value optimization.\n-     Similarly, directives that can fail (such as wide character\n-     directives) disable the optimization.  */\n-  bool posunder4k;\n-\n-  /* True when a floating point directive has been seen in the format\n-     string.  */\n-  bool floating;\n-\n-  /* True when an intermediate result has caused a warning.  Used to\n-     avoid issuing duplicate warnings while finishing the processing\n-     of a call.  WARNED also disables the return value optimization.  */\n-  bool warned;\n-\n-  /* Preincrement the number of output characters by 1.  */\n-  format_result& operator++ ()\n-  {\n-    return *this += 1;\n-  }\n-\n-  /* Postincrement the number of output characters by 1.  */\n-  format_result operator++ (int)\n-  {\n-    format_result prev (*this);\n-    *this += 1;\n-    return prev;\n-  }\n-\n-  /* Increment the number of output characters by N.  */\n-  format_result& operator+= (unsigned HOST_WIDE_INT);\n-};\n-\n-format_result&\n-format_result::operator+= (unsigned HOST_WIDE_INT n)\n-{\n-  gcc_assert (n < HOST_WIDE_INT_MAX);\n-\n-  if (range.min < HOST_WIDE_INT_MAX)\n-    range.min += n;\n-\n-  if (range.max < HOST_WIDE_INT_MAX)\n-    range.max += n;\n-\n-  if (range.likely < HOST_WIDE_INT_MAX)\n-    range.likely += n;\n-\n-  if (range.unlikely < HOST_WIDE_INT_MAX)\n-    range.unlikely += n;\n-\n-  return *this;\n-}\n-\n /* Return the value of INT_MIN for the target.  */\n \n static inline HOST_WIDE_INT\n@@ -460,7 +384,7 @@ class fmtresult\n   /* Construct a FMTRESULT object with all counters initialized\n      to MIN.  KNOWNRANGE is set when MIN is valid.  */\n   fmtresult (unsigned HOST_WIDE_INT min = HOST_WIDE_INT_MAX)\n-  : argmin (), argmax (), nonstr (),\n+  : argmin (), argmax (), dst_offset (HOST_WIDE_INT_MIN), nonstr (),\n     knownrange (min < HOST_WIDE_INT_MAX),\n     mayfail (), nullp ()\n   {\n@@ -474,7 +398,7 @@ class fmtresult\n      KNOWNRANGE is set when both MIN and MAX are valid.   */\n   fmtresult (unsigned HOST_WIDE_INT min, unsigned HOST_WIDE_INT max,\n \t     unsigned HOST_WIDE_INT likely = HOST_WIDE_INT_MAX)\n-  : argmin (), argmax (), nonstr (),\n+  : argmin (), argmax (), dst_offset (HOST_WIDE_INT_MIN), nonstr (),\n     knownrange (min < HOST_WIDE_INT_MAX && max < HOST_WIDE_INT_MAX),\n     mayfail (), nullp ()\n   {\n@@ -497,6 +421,11 @@ class fmtresult\n   /* The range a directive's argument is in.  */\n   tree argmin, argmax;\n \n+  /* The starting offset into the destination of the formatted function\n+     call of the %s argument that points into (aliases with) the same\n+     destination array.  */\n+  HOST_WIDE_INT dst_offset;\n+\n   /* The minimum and maximum number of bytes that a directive\n      results in on output for an argument in the range above.  */\n   result_range range;\n@@ -620,14 +549,29 @@ static bool\n get_int_range (tree, HOST_WIDE_INT *, HOST_WIDE_INT *, bool, HOST_WIDE_INT,\n \t       const vr_values *);\n \n+struct call_info;\n+\n /* Description of a format directive.  A directive is either a plain\n    string or a conversion specification that starts with '%'.  */\n \n struct directive\n {\n+  directive (const call_info *inf, unsigned dno)\n+    : info (inf), dirno (dno), argno (), beg (), len (), flags (),\n+    width (), prec (),  modifier (), specifier (), arg (), fmtfunc ()\n+  { }\n+\n+  /* Reference to the info structure describing the call that this\n+     directive is a part of.  */\n+  const call_info *info;\n+\n   /* The 1-based directive number (for debugging).  */\n   unsigned dirno;\n \n+  /* The zero-based argument number of the directive's argument ARG in\n+     the function's argument list.  */\n+  unsigned argno;\n+\n   /* The first character of the directive and its length.  */\n   const char *beg;\n   size_t len;\n@@ -722,6 +666,130 @@ struct directive\n   }\n };\n \n+/* The result of a call to a formatted function.  */\n+\n+struct format_result\n+{\n+  format_result ()\n+    : range (), aliases (), alias_count (), knownrange (), posunder4k (),\n+    floating (), warned () { /* No-op.  */ }\n+\n+  ~format_result ()\n+  {\n+    XDELETEVEC (aliases);\n+  }\n+\n+  /* Range of characters written by the formatted function.\n+     Setting the minimum to HOST_WIDE_INT_MAX disables all\n+     length tracking for the remainder of the format string.  */\n+  result_range range;\n+\n+  struct alias_info\n+  {\n+    directive dir;          /* The directive that aliases the destination.  */\n+    HOST_WIDE_INT offset;   /* The offset at which it aliases it.  */\n+    result_range range;     /* The raw result of the directive.  */\n+  };\n+\n+  /* An array of directives whose pointer argument aliases a part\n+     of the destination object of the formatted function.  */\n+  alias_info *aliases;\n+  unsigned alias_count;\n+\n+  /* True when the range above is obtained from known values of\n+     directive arguments, or bounds on the amount of output such\n+     as width and precision, and not the result of  heuristics that\n+     depend on warning levels.  It's used to issue stricter diagnostics\n+     in cases where strings of unknown lengths are bounded by the arrays\n+     they are determined to refer to.  KNOWNRANGE must not be used for\n+     the return value optimization.  */\n+  bool knownrange;\n+\n+  /* True if no individual directive could fail or result in more than\n+     4095 bytes of output (the total NUMBER_CHARS_{MIN,MAX} might be\n+     greater).  Implementations are not required to handle directives\n+     that produce more than 4K bytes (leading to undefined behavior)\n+     and so when one is found it disables the return value optimization.\n+     Similarly, directives that can fail (such as wide character\n+     directives) disable the optimization.  */\n+  bool posunder4k;\n+\n+  /* True when a floating point directive has been seen in the format\n+     string.  */\n+  bool floating;\n+\n+  /* True when an intermediate result has caused a warning.  Used to\n+     avoid issuing duplicate warnings while finishing the processing\n+     of a call.  WARNED also disables the return value optimization.  */\n+  bool warned;\n+\n+  /* Preincrement the number of output characters by 1.  */\n+  format_result& operator++ ()\n+  {\n+    return *this += 1;\n+  }\n+\n+  /* Postincrement the number of output characters by 1.  */\n+  format_result operator++ (int)\n+  {\n+    format_result prev (*this);\n+    *this += 1;\n+    return prev;\n+  }\n+\n+  /* Increment the number of output characters by N.  */\n+  format_result& operator+= (unsigned HOST_WIDE_INT);\n+\n+  /* Add a directive to the sequence of those with potentially aliasing\n+     arguments.  */\n+  void append_alias (const directive &, HOST_WIDE_INT, const result_range &);\n+\n+private:\n+  /* Not copyable or assignable.  */\n+  format_result (format_result&);\n+  void operator= (format_result&);\n+};\n+\n+format_result&\n+format_result::operator+= (unsigned HOST_WIDE_INT n)\n+{\n+  gcc_assert (n < HOST_WIDE_INT_MAX);\n+\n+  if (range.min < HOST_WIDE_INT_MAX)\n+    range.min += n;\n+\n+  if (range.max < HOST_WIDE_INT_MAX)\n+    range.max += n;\n+\n+  if (range.likely < HOST_WIDE_INT_MAX)\n+    range.likely += n;\n+\n+  if (range.unlikely < HOST_WIDE_INT_MAX)\n+    range.unlikely += n;\n+\n+  return *this;\n+}\n+\n+void\n+format_result::append_alias (const directive &d, HOST_WIDE_INT off,\n+\t\t\t     const result_range &resrng)\n+{\n+  unsigned cnt = alias_count + 1;\n+  alias_info *ar = XNEWVEC (alias_info, cnt);\n+\n+  for (unsigned i = 0; i != alias_count; ++i)\n+    ar[i] = aliases[i];\n+\n+  ar[alias_count].dir = d;\n+  ar[alias_count].offset = off;\n+  ar[alias_count].range = resrng;\n+\n+  XDELETEVEC (aliases);\n+\n+  alias_count = cnt;\n+  aliases = ar;\n+}\n+\n /* Return the logarithm of X in BASE.  */\n \n static int\n@@ -803,39 +871,6 @@ tree_digits (tree x, int base, HOST_WIDE_INT prec, bool plus, bool prefix)\n   return res;\n }\n \n-/* Given the formatting result described by RES and NAVAIL, the number\n-   of available in the destination, return the range of bytes remaining\n-   in the destination.  */\n-\n-static inline result_range\n-bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n-{\n-  result_range range;\n-\n-  if (HOST_WIDE_INT_MAX <= navail)\n-    {\n-      range.min = range.max = range.likely = range.unlikely = navail;\n-      return range;\n-    }\n-\n-  /* The lower bound of the available range is the available size\n-     minus the maximum output size, and the upper bound is the size\n-     minus the minimum.  */\n-  range.max = res.range.min < navail ? navail - res.range.min : 0;\n-\n-  range.likely = res.range.likely < navail ? navail - res.range.likely : 0;\n-\n-  if (res.range.max < HOST_WIDE_INT_MAX)\n-    range.min = res.range.max < navail ? navail - res.range.max : 0;\n-  else\n-    range.min = range.likely;\n-\n-  range.unlikely = (res.range.unlikely < navail\n-\t\t    ? navail - res.range.unlikely : 0);\n-\n-  return range;\n-}\n-\n /* Description of a call to a formatted function.  */\n \n struct call_info\n@@ -849,6 +884,18 @@ struct call_info\n   /* Called built-in function code.  */\n   built_in_function fncode;\n \n+  /* The \"origin\" of the destination pointer argument, which is either\n+     the DECL of the destination buffer being written into or a pointer\n+     that points to it, plus some offset.  */\n+  tree dst_origin;\n+\n+  /* For a destination pointing to a struct array member, the offset of\n+     the member.  */\n+  HOST_WIDE_INT dst_field;\n+\n+  /* The offset into the destination buffer.  */\n+  HOST_WIDE_INT dst_offset;\n+\n   /* Format argument and format string extracted from it.  */\n   tree format;\n   const char *fmtstr;\n@@ -2146,6 +2193,240 @@ format_character (const directive &dir, tree arg, const vr_values *vr_values)\n   return res.adjust_for_width_or_precision (dir.width);\n }\n \n+/* Determine the offset *INDEX of the first byte of an array element of\n+   TYPE (possibly recursively) into which the byte offset OFF points.\n+   On success set *INDEX to the offset of the first byte and return type.\n+   Otherwise, if no such element can be found, return null.  */\n+\n+static tree\n+array_elt_at_offset (tree type, HOST_WIDE_INT off, HOST_WIDE_INT *index)\n+{\n+  gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n+\n+  tree eltype = type;\n+  while (TREE_CODE (TREE_TYPE (eltype)) == ARRAY_TYPE)\n+    eltype = TREE_TYPE (eltype);\n+\n+  if (TYPE_MODE (TREE_TYPE (eltype)) != TYPE_MODE (char_type_node))\n+    eltype = TREE_TYPE (eltype);\n+\n+  if (eltype == type)\n+    {\n+      *index = 0;\n+      return type;\n+    }\n+\n+  HOST_WIDE_INT typsz = int_size_in_bytes (type);\n+  HOST_WIDE_INT eltsz = int_size_in_bytes (eltype);\n+  if (off < typsz * eltsz)\n+    {\n+      *index = (off / eltsz) * eltsz;\n+      return TREE_CODE (eltype) == ARRAY_TYPE ? TREE_TYPE (eltype) : eltype;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Determine the offset *INDEX of the first byte of a struct member of TYPE\n+   (possibly recursively) into which the byte offset OFF points.  On success\n+   set *INDEX to the offset of the first byte and return true.  Otherwise,\n+   if no such member can be found, return false.  */\n+\n+static bool\n+field_at_offset (tree type, HOST_WIDE_INT off, HOST_WIDE_INT *index)\n+{\n+  gcc_assert (RECORD_OR_UNION_TYPE_P (type));\n+\n+  for (tree fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n+    {\n+      if (TREE_CODE (fld) != FIELD_DECL || DECL_ARTIFICIAL (fld))\n+\tcontinue;\n+\n+      tree fldtype = TREE_TYPE (fld);\n+      HOST_WIDE_INT fldoff = int_byte_position (fld);\n+\n+      /* If the size is not available the field is a flexible array\n+\t member.  Treat this case as success.  */\n+      tree typesize = TYPE_SIZE_UNIT (fldtype);\n+      HOST_WIDE_INT fldsize = (tree_fits_uhwi_p (typesize)\n+\t\t\t       ? tree_to_uhwi (typesize)\n+\t\t\t       : off);\n+\n+      if (fldoff + fldsize < off)\n+\tcontinue;\n+\n+      if (TREE_CODE (fldtype) == ARRAY_TYPE)\n+\t{\n+\t  HOST_WIDE_INT idx = 0;\n+\t  if (tree ft = array_elt_at_offset (fldtype, off, &idx))\n+\t    fldtype = ft;\n+\t  else\n+\t    break;\n+\n+\t  *index += idx;\n+\t  fldoff -= idx;\n+\t  off -= idx;\n+\t}\n+\n+      if (RECORD_OR_UNION_TYPE_P (fldtype))\n+\t{\n+\t  *index += fldoff;\n+\t  return field_at_offset (fldtype, off - fldoff, index);\n+\t}\n+\n+      *index += fldoff;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* For an expression X of pointer type, recursively try to find the same\n+   origin (object or pointer) as Y it references and return such an X.\n+   When X refers to a struct member, set *FLDOFF to the offset of the\n+   member from the beginning of the \"most derived\" object.  */\n+\n+static tree\n+get_origin_and_offset (tree x, HOST_WIDE_INT *fldoff, HOST_WIDE_INT *off)\n+{\n+  if (!x)\n+    return NULL_TREE;\n+\n+  switch (TREE_CODE (x))\n+    {\n+    case ADDR_EXPR:\n+      x = TREE_OPERAND (x, 0);\n+      return get_origin_and_offset (x, fldoff, off);\n+\n+    case ARRAY_REF:\n+      {\n+\ttree offset = TREE_OPERAND (x, 1);\n+\tHOST_WIDE_INT idx = (tree_fits_uhwi_p (offset)\n+\t\t\t     ? tree_to_uhwi (offset) : HOST_WIDE_INT_MAX);\n+\n+\ttree eltype = TREE_TYPE (x);\n+\tif (TREE_CODE (eltype) == INTEGER_TYPE)\n+\t  {\n+\t    if (off)\n+\t      *off = idx;\n+\t  }\n+\telse if (idx < HOST_WIDE_INT_MAX)\n+\t  *fldoff += idx * int_size_in_bytes (eltype);\n+\telse\n+\t  *fldoff = idx;\n+\n+\tx = TREE_OPERAND (x, 0);\n+\treturn get_origin_and_offset (x, fldoff, NULL);\n+      }\n+\n+    case MEM_REF:\n+      if (off)\n+\t{\n+\t  tree offset = TREE_OPERAND (x, 1);\n+\t  *off = (tree_fits_uhwi_p (offset)\n+\t\t  ? tree_to_uhwi (offset) : HOST_WIDE_INT_MAX);\n+\t}\n+\n+      x = TREE_OPERAND (x, 0);\n+\n+      if (off)\n+\t{\n+\t  tree xtype = TREE_TYPE (TREE_TYPE (x));\n+\n+\t  /* The byte offset of the most basic struct member the byte\n+\t     offset *OFF corresponds to, or for a (multidimensional)\n+\t     array member, the byte offset of the array element.  */\n+\t  HOST_WIDE_INT index = 0;\n+\n+\t  if ((RECORD_OR_UNION_TYPE_P (xtype)\n+\t       && field_at_offset (xtype, *off, &index))\n+\t      || (TREE_CODE (xtype) == ARRAY_TYPE\n+\t\t  && TREE_CODE (TREE_TYPE (xtype)) == ARRAY_TYPE\n+\t\t  && array_elt_at_offset (xtype, *off, &index)))\n+\t    {\n+\t      *fldoff += index;\n+\t      *off -= index;\n+\t      fldoff = NULL;\n+\t    }\n+\t}\n+\n+      return get_origin_and_offset (x, fldoff, NULL);\n+\n+    case COMPONENT_REF:\n+      {\n+\ttree fld = TREE_OPERAND (x, 1);\n+\t*fldoff += int_byte_position (fld);\n+\n+\tget_origin_and_offset (fld, fldoff, off);\n+\tx = TREE_OPERAND (x, 0);\n+\treturn get_origin_and_offset (x, fldoff, off);\n+      }\n+\n+    case SSA_NAME:\n+      {\n+\tgimple *def = SSA_NAME_DEF_STMT (x);\n+\tif (is_gimple_assign (def))\n+\t  {\n+\t    tree_code code = gimple_assign_rhs_code (def);\n+\t    if (code == ADDR_EXPR)\n+\t      {\n+\t\tx = gimple_assign_rhs1 (def);\n+\t\treturn get_origin_and_offset (x, fldoff, off);\n+\t      }\n+\n+\t    if (code == POINTER_PLUS_EXPR)\n+\t      {\n+\t\ttree offset = gimple_assign_rhs2 (def);\n+\t\tif (off)\n+\t\t  *off = (tree_fits_uhwi_p (offset)\n+\t\t\t  ? tree_to_uhwi (offset) : HOST_WIDE_INT_MAX);\n+\n+\t\tx = gimple_assign_rhs1 (def);\n+\t\treturn get_origin_and_offset (x, fldoff, NULL);\n+\t      }\n+\t    else if (code == VAR_DECL)\n+\t      {\n+\t\tx = gimple_assign_rhs1 (def);\n+\t\treturn get_origin_and_offset (x, fldoff, off);\n+\t      }\n+\t  }\n+\telse if (gimple_nop_p (def) && SSA_NAME_VAR (x))\n+\t  x = SSA_NAME_VAR (x);\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  return x;\n+}\n+\n+/* If ARG refers to the same (sub)object or array element as described\n+   by DST and DST_FLD, return the byte offset into the struct member or\n+   array element referenced by ARG.  Otherwise return HOST_WIDE_INT_MIN\n+   to indicate that ARG and DST do not refer to the same object.  */\n+\n+static HOST_WIDE_INT\n+alias_offset (tree arg, tree dst, HOST_WIDE_INT dst_fld)\n+{\n+  /* See if the argument refers to the same base object as the destination\n+     of the formatted function call, and if so, try to determine if they\n+     can alias.  */\n+  if (!arg || !dst || !ptr_derefs_may_alias_p (arg, dst))\n+    return HOST_WIDE_INT_MIN;\n+\n+  /* The two arguments may refer to the same object.  If they both refer\n+     to a struct member, see if the members are one and the same.  */\n+  HOST_WIDE_INT arg_off = 0, arg_fld = 0;\n+\n+  tree arg_orig = get_origin_and_offset (arg, &arg_fld, &arg_off);\n+\n+  if (arg_orig == dst && arg_fld == dst_fld)\n+    return arg_off;\n+\n+  return HOST_WIDE_INT_MIN;\n+}\n+\n /* Return the minimum and maximum number of characters formatted\n    by the '%s' format directive and its wide character form for\n    the argument ARG.  ARG can be null (for functions such as\n@@ -2156,6 +2437,17 @@ format_string (const directive &dir, tree arg, const vr_values *vr_values)\n {\n   fmtresult res;\n \n+  if (warn_restrict)\n+    {\n+      /* See if ARG might alias the destination of the call with\n+\t DST_ORIGIN and DST_FIELD.  If so, store the starting offset\n+\t so that the overlap can be determined for certain later,\n+\t when the amount of output of the call (including subsequent\n+\t directives) has been computed.  Otherwise, store HWI_MIN.  */\n+      res.dst_offset = alias_offset (arg, dir.info->dst_origin,\n+\t\t\t\t     dir.info->dst_field);\n+    }\n+\n   /* Compute the range the argument's length can be in.  */\n   int count_by = 1;\n   if (dir.specifier == 'S' || dir.modifier == FMT_LEN_l)\n@@ -2166,7 +2458,7 @@ format_string (const directive &dir, tree arg, const vr_values *vr_values)\n \n       /* Now that we have a suitable node, get the number of\n \t bytes it occupies.  */\n-      count_by = int_size_in_bytes (node); \n+      count_by = int_size_in_bytes (node);\n       gcc_checking_assert (count_by == 2 || count_by == 4);\n     }\n \n@@ -2698,6 +2990,39 @@ maybe_warn (substring_loc &dirloc, location_t argloc,\n \t\t  res.min, avail_range.min, avail_range.max);\n }\n \n+/* Given the formatting result described by RES and NAVAIL, the number\n+   of available in the destination, return the range of bytes remaining\n+   in the destination.  */\n+\n+static inline result_range\n+bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n+{\n+  result_range range;\n+\n+  if (HOST_WIDE_INT_MAX <= navail)\n+    {\n+      range.min = range.max = range.likely = range.unlikely = navail;\n+      return range;\n+    }\n+\n+  /* The lower bound of the available range is the available size\n+     minus the maximum output size, and the upper bound is the size\n+     minus the minimum.  */\n+  range.max = res.range.min < navail ? navail - res.range.min : 0;\n+\n+  range.likely = res.range.likely < navail ? navail - res.range.likely : 0;\n+\n+  if (res.range.max < HOST_WIDE_INT_MAX)\n+    range.min = res.range.max < navail ? navail - res.range.max : 0;\n+  else\n+    range.min = range.likely;\n+\n+  range.unlikely = (res.range.unlikely < navail\n+\t\t    ? navail - res.range.unlikely : 0);\n+\n+  return range;\n+}\n+\n /* Compute the length of the output resulting from the directive DIR\n    in a call described by INFO and update the overall result of the call\n    in *RES.  Return true if the directive has been handled.  */\n@@ -2796,6 +3121,12 @@ format_directive (const call_info &info,\n      NUL that's appended after the format string has been processed.  */\n   result_range avail_range = bytes_remaining (info.objsize, *res);\n \n+  /* If the argument aliases a part of the destination of the formatted\n+     call at offset FMTRES.DST_OFFSET append the directive and its result\n+     to the set of aliases for later processing.  */\n+  if (fmtres.dst_offset != HOST_WIDE_INT_MIN)\n+    res->append_alias (dir, fmtres.dst_offset, fmtres.range);\n+\n   bool warned = res->warned;\n \n   if (!warned)\n@@ -3081,6 +3412,10 @@ parse_directive (call_info &info,\n       return len - !*str;\n     }\n \n+  /* Set the directive argument's number to correspond to its position\n+     in the formatted function call's argument list.  */\n+  dir.argno = *argno;\n+\n   const char *pf = pcnt + 1;\n \n     /* POSIX numbered argument index or zero when none.  */\n@@ -3485,6 +3820,136 @@ parse_directive (call_info &info,\n   return dir.len;\n }\n \n+/* Diagnose overlap between destination and %s directive arguments.  */\n+\n+static void\n+maybe_warn_overlap (call_info &info, format_result *res)\n+{\n+  /* Two vectors of 1-based indices corresponding to either certainly\n+     or possibly aliasing arguments.  */\n+  auto_vec<int, 16> aliasarg[2];\n+\n+  /* Go through the array of potentially aliasing directives and collect\n+     argument numbers of those that do or may overlap the destination\n+     object given the full result.  */\n+  for (unsigned i = 0; i != res->alias_count; ++i)\n+    {\n+      const format_result::alias_info &alias = res->aliases[i];\n+\n+      enum { possible = -1, none = 0, certain = 1 } overlap = none;\n+\n+      /* If the precision is zero there is no overlap.  (This only\n+\t considers %s directives and ignores %n.)  */\n+      if (alias.dir.prec[0] == 0 && alias.dir.prec[1] == 0)\n+\tcontinue;\n+\n+      if (alias.offset == HOST_WIDE_INT_MAX\n+\t  || info.dst_offset == HOST_WIDE_INT_MAX)\n+\toverlap = possible;\n+      else if (alias.offset == info.dst_offset)\n+\toverlap = alias.dir.prec[0] == 0 ? possible : certain;\n+      else\n+\t{\n+\t  /* Determine overlap from the range of output and offsets\n+\t     into the same destination as the source, and rule out\n+\t     impossible overlap.  */\n+\t  unsigned HOST_WIDE_INT albeg = alias.offset;\n+\t  unsigned HOST_WIDE_INT dstbeg = info.dst_offset;\n+\n+\t  unsigned HOST_WIDE_INT alend = albeg + alias.range.min;\n+\t  unsigned HOST_WIDE_INT dstend = dstbeg + res->range.min - 1;\n+\n+\t  if ((albeg <= dstbeg && alend > dstbeg)\n+\t      || (albeg >= dstbeg && albeg < dstend))\n+\t    overlap = certain;\n+\t  else\n+\t    {\n+\t      alend = albeg + alias.range.max;\n+\t      if (alend < albeg)\n+\t\talend = HOST_WIDE_INT_M1U;\n+\n+\t      dstend = dstbeg + res->range.max - 1;\n+\t      if (dstend < dstbeg)\n+\t\tdstend = HOST_WIDE_INT_M1U;\n+\n+\t      if ((albeg >= dstbeg && albeg <= dstend)\n+\t\t  || (alend >= dstbeg && alend <= dstend))\n+\t\toverlap = possible;\n+\t    }\n+\t}\n+\n+      if (overlap == none)\n+\tcontinue;\n+\n+      /* Append the 1-based argument number.  */\n+      aliasarg[overlap != certain].safe_push (alias.dir.argno + 1);\n+\n+      /* Disable any kind of optimization.  */\n+      res->range.unlikely = HOST_WIDE_INT_M1U;\n+    }\n+\n+  tree arg0 = gimple_call_arg (info.callstmt, 0);\n+  location_t loc = gimple_location (info.callstmt);\n+\n+  bool aliaswarn = false;\n+\n+  unsigned ncertain = aliasarg[0].length ();\n+  unsigned npossible = aliasarg[1].length ();\n+  if (ncertain && npossible)\n+    {\n+      /* If there are multiple arguments that overlap, some certainly\n+\t and some possibly, handle both sets in a single diagnostic.  */\n+      aliaswarn\n+\t= warning_at (loc, OPT_Wrestrict,\n+\t\t      \"%qE arguments %Z and maybe %Z overlap destination \"\n+\t\t      \"object %qE\",\n+\t\t      info.func, aliasarg[0].address (), ncertain,\n+\t\t      aliasarg[1].address (), npossible,\n+\t\t      info.dst_origin);\n+    }\n+  else if (ncertain)\n+    {\n+      /* There is only one set of two or more arguments and they all\n+\t certainly overlap the destination.  */\n+      aliaswarn\n+\t= warning_n (loc, OPT_Wrestrict, ncertain,\n+\t\t     \"%qE argument %Z overlaps destination object %qE\",\n+\t\t     \"%qE arguments %Z overlap destination object %qE\",\n+\t\t     info.func, aliasarg[0].address (), ncertain,\n+\t\t     info.dst_origin);\n+    }\n+  else if (npossible)\n+    {\n+      /* There is only one set of two or more arguments and they all\n+\t may overlap (but need not).  */\n+      aliaswarn\n+\t= warning_n (loc, OPT_Wrestrict, npossible,\n+\t\t     \"%qE argument %Z may overlap destination object %qE\",\n+\t\t     \"%qE arguments %Z may overlap destination object %qE\",\n+\t\t     info.func, aliasarg[1].address (), npossible,\n+\t\t     info.dst_origin);\n+    }\n+\n+  if (aliaswarn)\n+    {\n+      res->warned = true;\n+\n+      if (info.dst_origin != arg0)\n+\t{\n+\t  /* If its location is different from the first argument of the call\n+\t     point either at the destination object itself or at the expression\n+\t     that was used to determine the overlap.  */\n+\t  loc = (DECL_P (info.dst_origin)\n+\t\t ? DECL_SOURCE_LOCATION (info.dst_origin)\n+\t\t : EXPR_LOCATION (info.dst_origin));\n+\t  if (loc != UNKNOWN_LOCATION)\n+\t    inform (loc,\n+\t\t    \"destination object referenced by %<restrict%>-qualified \"\n+\t\t    \"argument 1 was declared here\");\n+\t}\n+    }\n+}\n+\n /* Compute the length of the output resulting from the call to a formatted\n    output function described by INFO and store the result of the call in\n    *RES.  Issue warnings for detected past the end writes.  Return true\n@@ -3524,29 +3989,35 @@ compute_format_length (call_info &info, format_result *res, const vr_values *vr)\n   /* The variadic argument counter.  */\n   unsigned argno = info.argidx;\n \n+  bool success = true;\n+\n   for (const char *pf = info.fmtstr; ; ++dirno)\n     {\n-      directive dir = directive ();\n-      dir.dirno = dirno;\n+      directive dir (&info, dirno);\n \n       size_t n = parse_directive (info, dir, res, pf, &argno, vr);\n \n       /* Return failure if the format function fails.  */\n       if (!format_directive (info, res, dir, vr))\n \treturn false;\n \n-      /* Return success the directive is zero bytes long and it's\n-\t the last think in the format string (i.e., it's the terminating\n+      /* Return success when the directive is zero bytes long and it's\n+\t the last thing in the format string (i.e., it's the terminating\n \t nul, which isn't really a directive but handling it as one makes\n \t things simpler).  */\n       if (!n)\n-\treturn *pf == '\\0';\n+\t{\n+\t  success = *pf == '\\0';\n+\t  break;\n+\t}\n \n       pf += n;\n     }\n \n+  maybe_warn_overlap (info, res);\n+\n   /* The complete format string was processed (with or without warnings).  */\n-  return true;\n+  return success;\n }\n \n /* Return the size of the object referenced by the expression DEST if\n@@ -4187,9 +4658,18 @@ handle_printf_call (gimple_stmt_iterator *gsi, const vr_values *vr_values)\n   if (!info.fmtstr)\n     return false;\n \n+  if (warn_restrict)\n+    {\n+      /* Compute the origin of the destination pointer and its offset\n+\t from the base object/pointer if possible.  */\n+      info.dst_offset = 0;\n+      info.dst_origin = get_origin_and_offset (dstptr, &info.dst_field,\n+\t\t\t\t\t       &info.dst_offset);\n+    }\n+\n   /* The result is the number of bytes output by the formatted function,\n      including the terminating NUL.  */\n-  format_result res = format_result ();\n+  format_result res;\n \n   /* I/O functions with no destination argument (i.e., all forms of fprintf\n      and printf) may fail under any conditions.  Others (i.e., all forms of"}, {"sha": "460ca2bbacb79890e898559c7fdad8ed83922eb2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937a86b49e4ed8ef72c1384d617feff26580a048/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937a86b49e4ed8ef72c1384d617feff26580a048/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=937a86b49e4ed8ef72c1384d617feff26580a048", "patch": "@@ -1,3 +1,8 @@\n+2019-11-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/35503\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-23.c: New test.\n+\n 2019-11-12  Nathan Sidwell  <nathan@acm.org>\n \n \t* g++.dg/lookup/pr6936.C: Delete, identical to using38.C"}, {"sha": "98dfa1d3966b4aac6cf445f7f6bfc99e0444d212", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-23.c", "status": "added", "additions": 709, "deletions": 0, "changes": 709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937a86b49e4ed8ef72c1384d617feff26580a048/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937a86b49e4ed8ef72c1384d617feff26580a048/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-23.c?ref=937a86b49e4ed8ef72c1384d617feff26580a048", "patch": "@@ -0,0 +1,709 @@\n+/* PR tree-optimization/35503 - Warning about restricted pointers?\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wno-format-overflow -Wrestrict -ftrack-macro-expansion=0\" }\n+*/\n+\n+void sink (int);\n+\n+#define S10 \"0123456789\"\n+\n+extern char a2[2][22];\n+\n+#define T(d, ...) do {\t\t\t\t\t\\\n+    char a[22] = S10;\t\t\t\t\t\\\n+    sink (__builtin_sprintf ((d), __VA_ARGS__));\t\\\n+  } while (0)\n+\n+void test_ptr (char *d, int i)\n+{\n+  T (d, \"%s\", d);       /* { dg-warning \"argument 3 overlaps destination object 'd'\" } */\n+  T (d, \"%s\", d + 0);   /* { dg-warning \"overlaps\" } */\n+\n+  /* The following only overlaps if d[1] is non-zero.  */\n+  T (d, \"%s\", d + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", d + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", d + i);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d, \"%s\", &d[0]);   /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", &d[1]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &d[2]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &d[i]);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d + 0, \"%s\", d);   /* { dg-warning \"overlaps\" } */\n+  T (d + 1, \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (d + 2, \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (d + i, \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+\n+  T (&d[0], \"%s\", d);   /* { dg-warning \"overlaps\" } */\n+  T (&d[1], \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (&d[2], \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (&d[i], \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+\n+  const char *s = d;\n+\n+  T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n+}\n+\n+void test_ptr_plus (char *d, int i)\n+{\n+  const char *s = d;\n+\n+  T (d, \"%s\", s++);     /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s++);     /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s++);     /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s++);     /* { dg-warning \"may overlap\" } */\n+\n+  s += i;\n+  T (d, \"%s\", s);       /* { dg-warning \"may overlap\" } */\n+}\n+\n+void test_array_1_dim (int i)\n+{\n+  T (a, \"%s\", a);       /* { dg-warning \"overlaps\" } */\n+  T (a, \"%s\", a + 0);   /* { dg-warning \"overlaps\" } */\n+  T (a, \"%s\", a + 1);   /* { dg-warning \"overlaps\" } */\n+  T (a, \"%s\", a + 2);   /* { dg-warning \"overlaps\" } */\n+  T (a, \"%s\", a + i);   /* { dg-warning \"may overlap\" } */\n+\n+  T (a, \"%s\", &a[0]);   /* { dg-warning \"overlaps\" } */\n+  T (a, \"%s\", &a[1]);   /* { dg-warning \"overlaps\" } */\n+  T (a, \"%s\", &a[2]);   /* { dg-warning \"overlaps\" } */\n+  T (a, \"%s\", &a[i]);   /* { dg-warning \"may overlap\" } */\n+\n+  T (a + 0, \"%s\", a);   /* { dg-warning \"overlaps\" } */\n+  T (a + 1, \"%s\", a);   /* { dg-warning \"overlaps\" } */\n+  T (a + 2, \"%s\", a);   /* { dg-warning \"overlaps\" } */\n+  T (a + i, \"%s\", a);   /* { dg-warning \"may overlap\" } */\n+\n+  T (&a[0], \"%s\", a);   /* { dg-warning \"overlaps\" } */\n+  T (&a[1], \"%s\", a);   /* { dg-warning \"overlaps\" } */\n+  T (&a[2], \"%s\", a);   /* { dg-warning \"overlaps\" } */\n+  T (&a[i], \"%s\", a);   /* { dg-warning \"may overlap\" } */\n+}\n+\n+\n+void test_array_2_dim (int i)\n+{\n+  T (a2[0], \"%s\", a2[0]);       /* { dg-warning \"overlaps\" } */\n+  T (a2[0], \"%s\", a2[0] + 0);   /* { dg-warning \"overlaps\" } */\n+  T (a2[0], \"%s\", a2[0] + 1);   /* { dg-warning \"may overlap\" } */\n+  T (a2[0], \"%s\", a2[0] + 2);   /* { dg-warning \"may overlap\" } */\n+  T (a2[0], \"%s\", a2[0] + i);   /* { dg-warning \"may overlap\" } */\n+\n+  T (a2[0], \"%s\", &a2[0][0]);   /* { dg-warning \"overlaps\" } */\n+  T (a2[0], \"%s\", &a2[0][1]);   /* { dg-warning \"may overlap\" } */\n+  T (a2[0], \"%s\", &a2[0][2]);   /* { dg-warning \"may overlap\" } */\n+  T (a2[0], \"%s\", &a2[0][i]);   /* { dg-warning \"may overlap\" } */\n+\n+  T (a2[0] + 0, \"%s\", a2[0]);   /* { dg-warning \"overlaps\" } */\n+  T (a2[0] + 1, \"%s\", a2[0]);   /* { dg-warning \"may overlap\" } */\n+  T (a2[0] + 2, \"%s\", a2[0]);   /* { dg-warning \"may overlap\" } */\n+  T (a2[0] + i, \"%s\", a2[0]);   /* { dg-warning \"may overlap\" } */\n+\n+  T (&a2[0][0], \"%s\", a2[0]);   /* { dg-warning \"overlaps\" } */\n+  T (&a2[0][1], \"%s\", a2[0]);   /* { dg-warning \"may overlap\" } */\n+  T (&a2[0][2], \"%s\", a2[0]);   /* { dg-warning \"may overlap\" } */\n+  T (&a2[0][i], \"%s\", a2[0]);   /* { dg-warning \"may overlap\" } */\n+\n+\n+  T (a2[0], \"%s\", a2[1]);\n+  T (a2[0], \"%s\", a2[1] + 0);\n+  T (a2[0], \"%s\", a2[1] + 1);\n+  T (a2[0], \"%s\", a2[1] + 2);\n+  T (a2[0], \"%s\", a2[1] + i);\n+\n+  T (a2[0], \"%s\", &a2[1][0]);\n+  T (a2[0], \"%s\", &a2[1][1]);\n+  T (a2[0], \"%s\", &a2[1][2]);\n+\n+  /* a2[0] is represented as &a in Gimple, and &a2[1][i] as &a + _2,\n+     with _1 defined to something like 10 + _1, and _1 to i.  That\n+     makes it virtually impossible to reliably determine that the\n+     two pointers refer to distinct sub-arrays of the same multi-\n+     dimensional array.  */\n+  T (a2[0], \"%s\", &a2[1][i]);   /* { dg-bogus \"overlap\" \"\" { xfail *-*-* } } */\n+\n+  T (a2[0] + 0, \"%s\", a2[1]);\n+  T (a2[0] + 1, \"%s\", a2[1]);\n+  T (a2[0] + 2, \"%s\", a2[1]);\n+  T (a2[0] + i, \"%s\", a2[1]);\n+\n+  T (&a2[0][0], \"%s\", a2[1]);\n+  T (&a2[0][1], \"%s\", a2[1]);\n+  T (&a2[0][2], \"%s\", a2[1]);\n+  T (&a2[0][i], \"%s\", a2[1]);\n+\n+\n+  T (a2[1], \"%s\", a2[0]);\n+  T (a2[1], \"%s\", a2[0] + 0);\n+  T (a2[1], \"%s\", a2[0] + 1);\n+  T (a2[1], \"%s\", a2[0] + 2);\n+  T (a2[1], \"%s\", a2[0] + i);\n+\n+  T (a2[1], \"%s\", &a2[0][0]);\n+  T (a2[1], \"%s\", &a2[0][1]);\n+  T (a2[1], \"%s\", &a2[0][2]);\n+  T (a2[1], \"%s\", &a2[0][i]);\n+\n+  T (a2[1] + 0, \"%s\", a2[0]);\n+  T (a2[1] + 1, \"%s\", a2[0]);\n+  T (a2[1] + 2, \"%s\", a2[0]);\n+  T (a2[1] + i, \"%s\", a2[0]);\n+\n+  T (&a2[1][0], \"%s\", a2[0]);\n+  T (&a2[1][1], \"%s\", a2[0]);\n+  T (&a2[1][2], \"%s\", a2[0]);\n+  T (&a2[1][i], \"%s\", a2[0]);   /* { dg-bogus \"overlap\" \"\" { xfail *-*-* } } */\n+\n+\n+  T (a2[1], \"%s\", a2[1]);       /* { dg-warning \"overlaps\" } */\n+  T (a2[1], \"%s\", a2[1] + 0);   /* { dg-warning \"overlaps\" } */\n+  T (a2[1], \"%s\", a2[1] + 1);   /* { dg-warning \"may overlap\" } */\n+  T (a2[1], \"%s\", a2[1] + 2);   /* { dg-warning \"may overlap\" } */\n+  T (a2[1], \"%s\", a2[1] + i);   /* { dg-warning \"may overlap\" } */\n+\n+  T (a2[1], \"%s\", &a2[1][0]);   /* { dg-warning \"overlaps\" } */\n+  T (a2[1], \"%s\", &a2[1][1]);   /* { dg-warning \"may overlap\" } */\n+  T (a2[1], \"%s\", &a2[1][2]);   /* { dg-warning \"may overlap\" } */\n+  T (a2[1], \"%s\", &a2[1][i]);   /* { dg-warning \"may overlap\" \"\" { xfail *-*-* } } */\n+\n+  T (a2[1] + 0, \"%s\", a2[1]);   /* { dg-warning \"overlaps\" } */\n+  T (a2[1] + 1, \"%s\", a2[1]);   /* { dg-warning \"may overlap\" } */\n+  T (a2[1] + 2, \"%s\", a2[1]);   /* { dg-warning \"may overlap\" } */\n+  T (a2[1] + i, \"%s\", a2[1]);   /* { dg-warning \"may overlap\" } */\n+\n+  T (&a2[1][0], \"%s\", a2[1]);   /* { dg-warning \"overlaps\" } */\n+  T (&a2[1][1], \"%s\", a2[1]);   /* { dg-warning \"may overlap\" } */\n+  T (&a2[1][2], \"%s\", a2[1]);   /* { dg-warning \"may overlap\" } */\n+  T (&a2[1][i], \"%s\", a2[1]);   /* { dg-warning \"may overlap\" \"\" { xfail *-*-* } } */\n+}\n+\n+struct S {\n+  char a[4];\n+  char b[4];\n+};\n+\n+struct S2 {\n+  struct S s_1;\n+  struct S s_2;\n+  struct S sa3[3];\n+};\n+\n+struct S3 {\n+  struct S2 s2_1;\n+  struct S2 s2_2;\n+\n+  struct {\n+    struct {\n+      struct {\n+\tstruct S sa_3[3];\n+      } a_1[3];\n+    } a_2[3][3];\n+  } a_3[3][3][3];\n+\n+  char fa[];\n+};\n+\n+void test_struct_member_array (struct S3 *s3, int i)\n+{\n+  char *d = s3->s2_1.s_1.a;\n+\n+  T (d, \"%s\", d);       /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", d + 0);   /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", d + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", d + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", d + i);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d, \"%s\", &d[0]);   /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", &d[1]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &d[2]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &d[i]);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d + 0, \"%s\", d);   /* { dg-warning \"overlaps\" } */\n+  T (d + 1, \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (d + 2, \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (d + i, \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+\n+  T (&d[0], \"%s\", d);   /* { dg-warning \"overlaps\" } */\n+  T (&d[1], \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (&d[2], \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (&d[i], \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+\n+  const char *s = d;\n+\n+  T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n+\n+  s = s3->s2_1.s_1.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_1.s_2.a;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_1.s_2.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  d = s3->s2_1.s_1.b;\n+\n+  s = s3->s2_1.s_2.a;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_1.s_2.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_2.s_1.a;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_2.s_1.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_2.s_2.a;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_2.s_2.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  d = s3->s2_2.s_1.a;\n+\n+  s = s3->s2_1.s_1.a;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_1.s_1.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_2.s_1.a;\n+\n+  T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n+\n+  s = s3->s2_2.s_2.a;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_2.s_2.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  d = s3->s2_2.s_1.b;\n+\n+  s = s3->s2_1.s_1.a;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_1.s_1.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_2.s_1.a;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_2.s_1.b;\n+\n+  T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n+\n+  s = s3->s2_2.s_2.a;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = s3->s2_2.s_2.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+}\n+\n+void test_struct_member_array_array (struct S3 *s3, int i)\n+{\n+  char *d = s3->s2_1.sa3[0].a;\n+  char *s = s3->s2_1.sa3[0].a;\n+\n+  T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s + 0);   /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d, \"%s\", &s[0]);   /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", &s[1]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &s[2]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &s[i]);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d + 0, \"%s\", s);   /* { dg-warning \"overlaps\" } */\n+  T (d + 1, \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (d + 2, \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (d + i, \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+\n+  T (&d[0], \"%s\", s);   /* { dg-warning \"overlaps\" } */\n+  T (&d[1], \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (&d[2], \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (&d[i], \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+\n+  s = s3->s2_1.sa3[0].b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 0);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  T (d, \"%s\", &s[0]);\n+  T (d, \"%s\", &s[1]);\n+  T (d, \"%s\", &s[2]);\n+  T (d, \"%s\", &s[i]);\n+\n+  T (d + 0, \"%s\", s);\n+  T (d + 1, \"%s\", s);\n+  T (d + 2, \"%s\", s);\n+  T (d + i, \"%s\", s);\n+\n+  T (&d[0], \"%s\", s);\n+  T (&d[1], \"%s\", s);\n+  T (&d[2], \"%s\", s);\n+  T (&d[i], \"%s\", s);\n+}\n+\n+void test_struct_member_nested_array (struct S3 *s3, int i)\n+{\n+#define PFX(sfx) s3->a_3[i3_0][i3_1][i3_2]\t\\\n+    .a_2[i2_0][i2_1]\t\t\t\t\\\n+    .a_1[i1_0].sfx\n+\n+#define TT(d, s)\t\t\t\t\\\n+  T (PFX (d), \"%s\", PFX (s));\t\t\t\\\n+  T (PFX (d), \"%s\", &PFX (s)[0]);\t\t\\\n+  T (PFX (d), \"%s\", &PFX (s)[1]);\t\t\\\n+  T (PFX (d), \"%s\", &PFX (s)[2]);\t\t\\\n+  T (PFX (d), \"%s\", &PFX (s)[i])\t\t\\\n+\n+#define T1(i0)\tdo\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      enum {i1_0 = i0 };\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      TT (sa_3[0].a, sa_3[0].b); TT (sa_3[0].b, sa_3[0].a);\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      TT (sa_3[0].a, sa_3[1].a); TT (sa_3[0].a, sa_3[1].b);\t\\\n+      TT (sa_3[0].b, sa_3[1].a); TT (sa_3[0].b, sa_3[1].b);\t\\\n+    \t\t\t\t\t\t\t\t\\\n+      TT (sa_3[0].a, sa_3[2].a); TT (sa_3[0].a, sa_3[2].b);\t\\\n+      TT (sa_3[0].b, sa_3[2].a); TT (sa_3[0].b, sa_3[2].b);\t\\\n+\t\t\t\t\t\t\t\t\\\n+      TT (sa_3[1].a, sa_3[0].a); TT (sa_3[1].a, sa_3[0].b);\t\\\n+      TT (sa_3[1].b, sa_3[0].a); TT (sa_3[1].b, sa_3[0].b);\t\\\n+\t\t\t\t\t\t\t\t\\\n+      TT (sa_3[1].a, sa_3[1].b); TT (sa_3[1].b, sa_3[1].a);\t\\\n+\t\t\t\t\t\t\t\t\\\n+      TT (sa_3[1].a, sa_3[2].a); TT (sa_3[1].a, sa_3[2].b);\t\\\n+      TT (sa_3[1].b, sa_3[2].a); TT (sa_3[1].b, sa_3[2].b);\t\\\n+    } while (0)\n+\n+#define T2(i0, i1) do\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      enum { i2_0 = i0, i2_1 = i1 };\t\t\\\n+      T1 (0); T1 (1); T1 (2);\t\t\t\\\n+    } while (0)\n+\n+#define T3(i0, i1, i2) do\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      enum { i3_0 = i0, i3_1 = i1, i3_2 = i2 };\t\\\n+      T2 (0, 0); T2 (0, 1); T2 (0, 2);\t\t\\\n+      T2 (1, 0); T2 (1, 1); T2 (1, 2);\t\t\\\n+      T2 (2, 0); T2 (2, 1); T2 (2, 2);\t\t\\\n+    } while (0)\n+\n+#if 0\n+  /* These tests take forever and a day to compile.  Enable them only\n+     during the development of this feature but leave them otherwise\n+     disabled to avoid slowing everything down for others.  */\n+  T3 (0, 0, 0); T3 (0, 0, 1); T3 (0, 0, 2);\n+  T3 (0, 1, 0); T3 (0, 1, 1); T3 (0, 1, 2);\n+  T3 (0, 2, 0); T3 (0, 2, 1); T3 (0, 2, 2);\n+\n+  T3 (1, 0, 0); T3 (1, 0, 1); T3 (1, 0, 2);\n+  T3 (1, 1, 0); T3 (1, 1, 1); T3 (1, 1, 2);\n+  T3 (1, 2, 0); T3 (1, 2, 1); T3 (1, 2, 2);\n+\n+  T3 (2, 0, 0); T3 (2, 0, 1); T3 (2, 0, 2);\n+  T3 (2, 1, 0); T3 (2, 1, 1); T3 (2, 1, 2);\n+  T3 (2, 2, 0); T3 (2, 2, 1); T3 (2, 2, 2);\n+#endif\n+}\n+\n+void test_struct_member_flexarray (struct S3 *s3, int i, int j)\n+{\n+  char *d = s3->fa;\n+  char *s = s3->fa;\n+\n+  T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s + 0);   /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d, \"%s\", &s[0]);   /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", &s[1]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &s[2]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &s[i]);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d + 0, \"%s\", s);   /* { dg-warning \"overlaps\" } */\n+  T (d + 1, \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (d + 2, \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (d + i, \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+\n+  T (&d[0], \"%s\", s);   /* { dg-warning \"overlaps\" } */\n+  T (&d[1], \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (&d[2], \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (&d[i], \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+\n+  d = s3->fa + i;\n+  s = s3->fa + j;\n+\n+  T (d, \"%s\", s);       /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 0);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d, \"%s\", &s[0]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &s[1]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &s[2]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &s[i]);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d + 0, \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (d + 1, \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (d + 2, \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (d + j, \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+\n+  T (&d[0], \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (&d[1], \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (&d[2], \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+  T (&d[j], \"%s\", s);   /* { dg-warning \"may overlap\" } */\n+}\n+\n+union U\n+{\n+  struct S2 s2_1;\n+  struct S2 s2_2;\n+};\n+\n+void test_union_member_array (union U *un, int i)\n+{\n+  char *d = un->s2_1.s_1.a;\n+\n+  T (d, \"%s\", d);       /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", d + 0);   /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", d + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", d + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", d + i);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d, \"%s\", &d[0]);   /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", &d[1]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &d[2]);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", &d[i]);   /* { dg-warning \"may overlap\" } */\n+\n+  T (d + 0, \"%s\", d);   /* { dg-warning \"overlaps\" } */\n+  T (d + 1, \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (d + 2, \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (d + i, \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+\n+  T (&d[0], \"%s\", d);   /* { dg-warning \"overlaps\" } */\n+  T (&d[1], \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (&d[2], \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+  T (&d[i], \"%s\", d);   /* { dg-warning \"may overlap\" } */\n+\n+  const char *s = d;\n+\n+  T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n+\n+  s = un->s2_1.s_1.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = un->s2_1.s_2.a;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = un->s2_1.s_2.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+\n+  s = un->s2_2.s_1.a;\n+\n+  T (d, \"%s\", s);       /* { dg-warning \"overlaps\" } */\n+  T (d, \"%s\", s + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + 2);   /* { dg-warning \"may overlap\" } */\n+  T (d, \"%s\", s + i);   /* { dg-warning \"may overlap\" } */\n+\n+  s = un->s2_2.s_1.b;\n+\n+  T (d, \"%s\", s);\n+  T (d, \"%s\", s + 1);\n+  T (d, \"%s\", s + 2);\n+  T (d, \"%s\", s + i);\n+}\n+\n+void test_multiple_overlap (int i)\n+{\n+  {\n+    char a[3] = \"\";           /* { dg-message \"declared here\" } */\n+\n+    /* Both a3 and a4 definitely overlap the output even if the are\n+       empty because of the terminating nul.  */\n+    char *d = a;\n+    char *a3 = a + 0;\n+    char *a4 = a - 0;\n+\n+    T (d, \"%s%s\", a3, a4);    /* { dg-warning \"arguments 3, 4 overlap destination object .a.\" }*/\n+  }\n+\n+  {\n+    char a[4];                /* { dg-message \"declared here\" } */\n+\n+    /* a3 and a4 may overlap the output.  They will only not overlap\n+       it when a3 is empty, and a4 is at most chaeracter byte long.  */\n+    char *d = a;\n+    char *a3 = a + 2;\n+    char *a4 = a + 3;\n+\n+    T (d, \"%s%s\", a3, a4);    /* { dg-warning \"arguments 3, 4 may overlap destination object .a.\" }*/\n+  }\n+\n+  {\n+    char a[5];                /* { dg-message \"declared here\" } */\n+\n+    /* a3 certaibly overlaps the output, but a4 may or may not depending\n+       in the value of i.  */\n+    char *d = a;\n+    char *a3 = a + 0;\n+    char *a4 = a + i;\n+\n+    T (d, \"%s%s\", a3, a4);    /* { dg-warning \"arguments 3 and maybe 4 overlap destination object .a.\" }*/\n+  }\n+}\n+\n+void test_overlap_with_precision (char *d, int i, int j)\n+{\n+  /* None of the following is diagnosed because no copying takes place\n+     between the %s argument and the destination.  */\n+  T (d, \"%.0s\", d + 0);\n+  T (d, \"%.0s\", d + 1);\n+  T (d, \"%.0s\", d + 2);\n+  T (d, \"%.0s\", d + i);\n+\n+  T (d, \"%.1s\", d + 0);       /* { dg-warning \"overlaps\" } */\n+  /* Unlike the %.0s case the following deserves a warning because\n+     when d[1] isn't nul, it will be overwritten by the terminating\n+     nul added by sprintf.  */\n+  T (d, \"%.1s\", d + 1);       /* { dg-warning \"may overlap\" } */\n+  T (d, \"%.1s\", d + 2);\n+  T (d, \"%.1s\", d + i);       /* { dg-warning \"may overlap\" } */\n+\n+  T (d + 1, \"%.0s\", d);\n+  T (d + 2, \"%.0s\", d);\n+\n+  T (d + 1, \"%.1s\", d);       /* { dg-warning \"may overlap\" } */\n+  T (d + 2, \"%.1s\", d);\n+\n+  T (d + 2, \"%.1s\", d + 1);   /* { dg-warning \"may overlap\" } */\n+  T (d + 2, \"%.1s\", d + i);   /* { dg-warning \"may overlap\" } */\n+\n+  /* The following should be \"overlaps\" but tracking that the offset\n+     is the same variable doesn't seem worth the effort.  */\n+  T (d + i, \"%.1s\", d + i);   /* { dg-warning \"overlap\" } */\n+\n+  T (d + i, \"%.1s\", d + j);   /* { dg-warning \"may overlap\" } */\n+\n+  /* Exercise overlap with precison in the range [0, 1].  */\n+  if (i < 0 || 1 < i)\n+    i = 0;\n+\n+  T (d, \"%.*s\", i, d + 0);    /* { dg-warning \"may overlap\" } */\n+  T (d, \"%.*s\", i, d + 1);    /* { dg-warning \"may overlap\" } */\n+  T (d, \"%.*s\", i, d + 2);\n+  T (d, \"%.*s\", i, d + i);    /* { dg-warning \"may overlap\" \"\" { xfail *-*-* } } */\n+}"}, {"sha": "be0f37cc4d1260e87e18051ee9483a5b6c0b2a54", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/937a86b49e4ed8ef72c1384d617feff26580a048/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/937a86b49e4ed8ef72c1384d617feff26580a048/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=937a86b49e4ed8ef72c1384d617feff26580a048", "patch": "@@ -5344,6 +5344,7 @@ pass_strlen::gate (function *)\n {\n   return ((warn_format_overflow > 0\n \t   || warn_format_trunc > 0\n+\t   || warn_restrict > 0\n \t   || flag_optimize_strlen > 0\n \t   || flag_printf_return_value)\n \t  && optimize > 0);"}]}