{"sha": "c0cb50559966b5215b3b2901fed2d672f6594b5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBjYjUwNTU5OTY2YjUyMTViM2IyOTAxZmVkMmQ2NzJmNjU5NGI1Zg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2014-11-14T19:58:18Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2014-11-14T19:58:18Z"}, "message": "ipa-cp.c (ipcp_value_source): Converted to a template class.\n\n2014-11-14  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-cp.c (ipcp_value_source): Converted to a template class.  All\n\tusers converted to the same specialization as the using class/function\n\tor specialization on tree.\n\t(ipcp_value): Likewise.\n\t(ipcp_lattice): Likewise.\n\t(ipcp_agg_lattice): Now derived from tree specialization of\n\tipcp_lattice.\n\t(values_topo): Moved to new class value_topo_info.\n\t(ipa_lat_is_single_const): Turned into ipcp_lattice::is_single_const.\n\tUpdated all callers.\n\t(print_lattice): Turned into ipcp_lattice::print.  Updated all\n\tcallers.\n\t(value_topo_info): New class template.\n\t(ipa_topo_info): New field constants.  New constructor.\n\t(build_toporder_info): Do not clear stack_top, only checkign assert\n\tit.\n\t(set_lattice_to_bottom): Turned into ipcp_lattice::set_to_bottom.\n\tUpdated all callers.\n\t(set_lattice_contains_variable): Turned into\n\tipcp_lattice::set_contains_variable.  Updated all callers.\n\t(add_value_source): Turned into ipcp_value::add_source.  Updated all\n\tcallers.\n\t(allocate_and_init_ipcp_value): New function.\n\t(add_value_to_lattice): Turned into ipcp_lattice::add_value.  Last\n\tparameter got default a value.  Updated all callers.\n\t(add_scalar_value_to_lattice): Removed, users converted to using\n\tipcp_lattice::add_value with default value of the last parameter.\n\t(add_val_to_toposort): Turned to value_topo_info::add_val.  Updated\n\tall callers.\n\t(propagate_effects): Made method of value_topo_info.\n\t(cgraph_edge_brings_value_p): Now a template function.\n\t(get_info_about_necessary_edges): Likewise.\n\t(gather_edges_for_value): Likewise.\n\t(perhaps_add_new_callers): Likewise.\n\t(decide_about_value): Likewise.\n\t* ipa-prop.h (ipcp_lattice): Remove fowrward declaration.\n\nFrom-SVN: r217586", "tree": {"sha": "0207dbfe10892a75b0b88be3418e7221a914f3cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0207dbfe10892a75b0b88be3418e7221a914f3cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0cb50559966b5215b3b2901fed2d672f6594b5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0cb50559966b5215b3b2901fed2d672f6594b5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0cb50559966b5215b3b2901fed2d672f6594b5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0cb50559966b5215b3b2901fed2d672f6594b5f/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b907149be55a0266566acc5fb9d0a7cab2d794cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b907149be55a0266566acc5fb9d0a7cab2d794cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b907149be55a0266566acc5fb9d0a7cab2d794cb"}], "stats": {"total": 562, "additions": 331, "deletions": 231}, "files": [{"sha": "421a8bcc33dc8fbfb535d3c6ebb07f6c6f9a89a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cb50559966b5215b3b2901fed2d672f6594b5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cb50559966b5215b3b2901fed2d672f6594b5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0cb50559966b5215b3b2901fed2d672f6594b5f", "patch": "@@ -1,3 +1,42 @@\n+2014-11-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-cp.c (ipcp_value_source): Converted to a template class.  All\n+\tusers converted to the same specialization as the using class/function\n+\tor specialization on tree.\n+\t(ipcp_value): Likewise.\n+\t(ipcp_lattice): Likewise.\n+\t(ipcp_agg_lattice): Now derived from tree specialization of\n+\tipcp_lattice.\n+\t(values_topo): Moved to new class value_topo_info.\n+\t(ipa_lat_is_single_const): Turned into ipcp_lattice::is_single_const.\n+\tUpdated all callers.\n+\t(print_lattice): Turned into ipcp_lattice::print.  Updated all\n+\tcallers.\n+\t(value_topo_info): New class template.\n+\t(ipa_topo_info): New field constants.  New constructor.\n+\t(build_toporder_info): Do not clear stack_top, only checkign assert\n+\tit.\n+\t(set_lattice_to_bottom): Turned into ipcp_lattice::set_to_bottom.\n+\tUpdated all callers.\n+\t(set_lattice_contains_variable): Turned into\n+\tipcp_lattice::set_contains_variable.  Updated all callers.\n+\t(add_value_source): Turned into ipcp_value::add_source.  Updated all\n+\tcallers.\n+\t(allocate_and_init_ipcp_value): New function.\n+\t(add_value_to_lattice): Turned into ipcp_lattice::add_value.  Last\n+\tparameter got default a value.  Updated all callers.\n+\t(add_scalar_value_to_lattice): Removed, users converted to using\n+\tipcp_lattice::add_value with default value of the last parameter.\n+\t(add_val_to_toposort): Turned to value_topo_info::add_val.  Updated\n+\tall callers.\n+\t(propagate_effects): Made method of value_topo_info.\n+\t(cgraph_edge_brings_value_p): Now a template function.\n+\t(get_info_about_necessary_edges): Likewise.\n+\t(gather_edges_for_value): Likewise.\n+\t(perhaps_add_new_callers): Likewise.\n+\t(decide_about_value): Likewise.\n+\t* ipa-prop.h (ipcp_lattice): Remove fowrward declaration.\n+\n 2014-11-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* doc/install.texi (--with-diagnostics-color=): Document."}, {"sha": "e0acfaa82b07d9c240f220360e977dd051073144", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 292, "deletions": 229, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cb50559966b5215b3b2901fed2d672f6594b5f/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cb50559966b5215b3b2901fed2d672f6594b5f/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=c0cb50559966b5215b3b2901fed2d672f6594b5f", "patch": "@@ -134,61 +134,73 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-inline.h\"\n #include \"ipa-utils.h\"\n \n-struct ipcp_value;\n+template <typename valtype> class ipcp_value;\n \n /* Describes a particular source for an IPA-CP value.  */\n \n-struct ipcp_value_source\n+template <typename valtype>\n+class ipcp_value_source\n {\n+public:\n   /* Aggregate offset of the source, negative if the source is scalar value of\n      the argument itself.  */\n   HOST_WIDE_INT offset;\n   /* The incoming edge that brought the value.  */\n-  struct cgraph_edge *cs;\n+  cgraph_edge *cs;\n   /* If the jump function that resulted into his value was a pass-through or an\n      ancestor, this is the ipcp_value of the caller from which the described\n      value has been derived.  Otherwise it is NULL.  */\n-  struct ipcp_value *val;\n+  ipcp_value<valtype> *val;\n   /* Next pointer in a linked list of sources of a value.  */\n-  struct ipcp_value_source *next;\n+  ipcp_value_source *next;\n   /* If the jump function that resulted into his value was a pass-through or an\n      ancestor, this is the index of the parameter of the caller the jump\n      function references.  */\n   int index;\n };\n \n+/* Common ancestor for all ipcp_value instantiations.  */\n+\n+class ipcp_value_base\n+{\n+public:\n+  /* Time benefit and size cost that specializing the function for this value\n+     would bring about in this function alone.  */\n+  int local_time_benefit, local_size_cost;\n+  /* Time benefit and size cost that specializing the function for this value\n+     can bring about in it's callees (transitively).  */\n+  int prop_time_benefit, prop_size_cost;\n+};\n+\n /* Describes one particular value stored in struct ipcp_lattice.  */\n \n-struct ipcp_value\n+template <typename valtype>\n+class ipcp_value : public ipcp_value_base\n {\n-  /* The actual value for the given parameter.  This is either an IPA invariant\n-     or a TREE_BINFO describing a type that can be used for\n-     devirtualization.  */\n-  tree value;\n+public:\n+  /* The actual value for the given parameter.  */\n+  valtype value;\n   /* The list of sources from which this value originates.  */\n-  struct ipcp_value_source *sources;\n+  ipcp_value_source <valtype> *sources;\n   /* Next pointers in a linked list of all values in a lattice.  */\n-  struct ipcp_value *next;\n+  ipcp_value *next;\n   /* Next pointers in a linked list of values in a strongly connected component\n      of values. */\n-  struct ipcp_value *scc_next;\n+  ipcp_value *scc_next;\n   /* Next pointers in a linked list of SCCs of values sorted topologically\n      according their sources.  */\n-  struct ipcp_value  *topo_next;\n+  ipcp_value  *topo_next;\n   /* A specialized node created for this value, NULL if none has been (so far)\n      created.  */\n-  struct cgraph_node *spec_node;\n+  cgraph_node *spec_node;\n   /* Depth first search number and low link for topological sorting of\n      values.  */\n   int dfs, low_link;\n-  /* Time benefit and size cost that specializing the function for this value\n-     would bring about in this function alone.  */\n-  int local_time_benefit, local_size_cost;\n-  /* Time benefit and size cost that specializing the function for this value\n-     can bring about in it's callees (transitively).  */\n-  int prop_time_benefit, prop_size_cost;\n   /* True if this valye is currently on the topo-sort stack.  */\n   bool on_stack;\n+\n+  void add_source (cgraph_edge *cs, ipcp_value *src_val, int src_idx,\n+\t\t   HOST_WIDE_INT offset);\n };\n \n /* Lattice describing potential values of a formal parameter of a function, or\n@@ -197,25 +209,37 @@ struct ipcp_value\n    by a lattice with the bottom flag set.  In that case, values and\n    contains_variable flag should be disregarded.  */\n \n-struct ipcp_lattice\n+template <typename valtype>\n+class ipcp_lattice\n {\n+public:\n   /* The list of known values and types in this lattice.  Note that values are\n      not deallocated if a lattice is set to bottom because there may be value\n      sources referencing them.  */\n-  struct ipcp_value *values;\n+  ipcp_value<valtype> *values;\n   /* Number of known values and types in this lattice.  */\n   int values_count;\n   /* The lattice contains a variable component (in addition to values).  */\n   bool contains_variable;\n   /* The value of the lattice is bottom (i.e. variable and unusable for any\n      propagation).  */\n   bool bottom;\n+\n+  inline bool is_single_const ();\n+  inline bool set_to_bottom ();\n+  inline bool set_contains_variable ();\n+  bool add_value (valtype newval, cgraph_edge *cs,\n+\t\t  ipcp_value<valtype> *src_val = NULL,\n+\t\t  int src_idx = 0, HOST_WIDE_INT offset = -1);\n+  void print (FILE * f, bool dump_sources, bool dump_benefits);\n };\n \n-/* Lattice with an offset to describe a part of an aggregate.  */\n+/* Lattice of tree values with an offset to describe a part of an\n+   aggregate.  */\n \n-struct ipcp_agg_lattice : public ipcp_lattice\n+class ipcp_agg_lattice : public ipcp_lattice<tree>\n {\n+public:\n   /* Offset that is being described by this lattice. */\n   HOST_WIDE_INT offset;\n   /* Size so that we don't have to re-compute it every time we traverse the\n@@ -229,12 +253,13 @@ struct ipcp_agg_lattice : public ipcp_lattice\n    aggregates that are passed in the parameter or by a reference in a parameter\n    plus some other useful flags.  */\n \n-struct ipcp_param_lattices\n+class ipcp_param_lattices\n {\n+public:\n   /* Lattice describing the value of the parameter itself.  */\n-  struct ipcp_lattice itself;\n+  ipcp_lattice<tree> itself;\n   /* Lattices describing aggregate parts.  */\n-  struct ipcp_agg_lattice *aggs;\n+  ipcp_agg_lattice *aggs;\n   /* Number of aggregate lattices */\n   int aggs_count;\n   /* True if aggregate data were passed by reference (as opposed to by\n@@ -265,10 +290,6 @@ static gcov_type max_count;\n \n static long overall_size, max_new_size;\n \n-/* Head of the linked list of topologically sorted values. */\n-\n-static struct ipcp_value *values_topo;\n-\n /* Return the param lattices structure corresponding to the Ith formal\n    parameter of the function described by INFO.  */\n static inline struct ipcp_param_lattices *\n@@ -282,7 +303,7 @@ ipa_get_parm_lattices (struct ipa_node_params *info, int i)\n \n /* Return the lattice corresponding to the scalar value of the Ith formal\n    parameter of the function described by INFO.  */\n-static inline struct ipcp_lattice *\n+static inline ipcp_lattice<tree> *\n ipa_get_scalar_lat (struct ipa_node_params *info, int i)\n {\n   struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n@@ -292,12 +313,11 @@ ipa_get_scalar_lat (struct ipa_node_params *info, int i)\n /* Return whether LAT is a lattice with a single constant and without an\n    undefined value.  */\n \n-static inline bool\n-ipa_lat_is_single_const (struct ipcp_lattice *lat)\n+template <typename valtype>\n+inline bool\n+ipcp_lattice<valtype>::is_single_const ()\n {\n-  if (lat->bottom\n-      || lat->contains_variable\n-      || lat->values_count != 1)\n+  if (bottom || contains_variable || values_count != 1)\n     return false;\n   else\n     return true;\n@@ -325,34 +345,34 @@ print_ipcp_constant_value (FILE * f, tree v)\n \n /* Print a lattice LAT to F.  */\n \n-static void\n-print_lattice (FILE * f, struct ipcp_lattice *lat,\n-\t       bool dump_sources, bool dump_benefits)\n+template <typename valtype>\n+void\n+ipcp_lattice<valtype>::print (FILE * f, bool dump_sources, bool dump_benefits)\n {\n-  struct ipcp_value *val;\n+  ipcp_value<valtype> *val;\n   bool prev = false;\n \n-  if (lat->bottom)\n+  if (bottom)\n     {\n       fprintf (f, \"BOTTOM\\n\");\n       return;\n     }\n \n-  if (!lat->values_count && !lat->contains_variable)\n+  if (!values_count && !contains_variable)\n     {\n       fprintf (f, \"TOP\\n\");\n       return;\n     }\n \n-  if (lat->contains_variable)\n+  if (contains_variable)\n     {\n       fprintf (f, \"VARIABLE\");\n       prev = true;\n       if (dump_benefits)\n \tfprintf (f, \"\\n\");\n     }\n \n-  for (val = lat->values; val; val = val->next)\n+  for (val = values; val; val = val->next)\n     {\n       if (dump_benefits && prev)\n \tfprintf (f, \"               \");\n@@ -365,7 +385,7 @@ print_lattice (FILE * f, struct ipcp_lattice *lat,\n \n       if (dump_sources)\n \t{\n-\t  struct ipcp_value_source *s;\n+\t  ipcp_value_source<valtype> *s;\n \n \t  fprintf (f, \" [from:\");\n \t  for (s = val->sources; s; s = s->next)\n@@ -406,7 +426,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n \t  struct ipcp_agg_lattice *aglat;\n \t  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n \t  fprintf (f, \"    param [%d]: \", i);\n-\t  print_lattice (f, &plats->itself, dump_sources, dump_benefits);\n+\t  plats->itself.print (f, dump_sources, dump_benefits);\n \n \t  if (plats->virt_call)\n \t    fprintf (f, \"        virt_call flag set\\n\");\n@@ -422,7 +442,7 @@ print_all_lattices (FILE * f, bool dump_sources, bool dump_benefits)\n \t    {\n \t      fprintf (f, \"        %soffset \" HOST_WIDE_INT_PRINT_DEC \": \",\n \t\t       plats->aggs_by_ref ? \"ref \" : \"\", aglat->offset);\n-\t      print_lattice (f, aglat, dump_sources, dump_benefits);\n+\t      aglat->print (f, dump_sources, dump_benefits);\n \t    }\n \t}\n     }\n@@ -586,14 +606,43 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n   return true;\n }\n \n+template <typename valtype>\n+class value_topo_info\n+{\n+public:\n+  /* Head of the linked list of topologically sorted values. */\n+  ipcp_value<valtype> *values_topo;\n+  /* Stack for creating SCCs, represented by a linked list too.  */\n+  ipcp_value<valtype> *stack;\n+  /* Counter driving the algorithm in add_val_to_toposort.  */\n+  int dfs_counter;\n+\n+  value_topo_info () : values_topo (NULL), stack (NULL), dfs_counter (0)\n+  {}\n+  void add_val (ipcp_value<valtype> *cur_val);\n+  void propagate_effects ();\n+};\n+\n /* Arrays representing a topological ordering of call graph nodes and a stack\n-   of noes used during constant propagation.  */\n+   of nodes used during constant propagation and also data required to perform\n+   topological sort of values and propagation of benefits in the determined\n+   order.  */\n \n-struct ipa_topo_info\n+class ipa_topo_info\n {\n+public:\n+  /* Array with obtained topological order of cgraph nodes.  */\n   struct cgraph_node **order;\n+  /* Stack of cgraph nodes used during propagation within SCC until all values\n+     in the SCC stabilize.  */\n   struct cgraph_node **stack;\n   int nnodes, stack_top;\n+\n+  value_topo_info<tree> constants;\n+\n+  ipa_topo_info () : order(NULL), stack(NULL), nnodes(0), stack_top(0),\n+    constants ()\n+  {}\n };\n \n /* Allocate the arrays in TOPO and topologically sort the nodes into order.  */\n@@ -604,7 +653,7 @@ build_toporder_info (struct ipa_topo_info *topo)\n   topo->order = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n   topo->stack = XCNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n \n-  topo->stack_top = 0;\n+  gcc_checking_assert (topo->stack_top == 0);\n   topo->nnodes = ipa_reduced_postorder (topo->order, true, true, NULL);\n }\n \n@@ -652,22 +701,24 @@ pop_node_from_stack (struct ipa_topo_info *topo)\n /* Set lattice LAT to bottom and return true if it previously was not set as\n    such.  */\n \n-static inline bool\n-set_lattice_to_bottom (struct ipcp_lattice *lat)\n+template <typename valtype>\n+inline bool\n+ipcp_lattice<valtype>::set_to_bottom ()\n {\n-  bool ret = !lat->bottom;\n-  lat->bottom = true;\n+  bool ret = !bottom;\n+  bottom = true;\n   return ret;\n }\n \n /* Mark lattice as containing an unknown value and return true if it previously\n    was not marked as such.  */\n \n-static inline bool\n-set_lattice_contains_variable (struct ipcp_lattice *lat)\n+template <typename valtype>\n+inline bool\n+ipcp_lattice<valtype>::set_contains_variable ()\n {\n-  bool ret = !lat->contains_variable;\n-  lat->contains_variable = true;\n+  bool ret = !contains_variable;\n+  contains_variable = true;\n   return ret;\n }\n \n@@ -735,7 +786,7 @@ initialize_node_lattices (struct cgraph_node *node)\n \t  struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n \t  if (disable)\n \t    {\n-\t      set_lattice_to_bottom (&plats->itself);\n+\t      plats->itself.set_to_bottom ();\n \t      set_agg_lats_to_bottom (plats);\n \t    }\n \t  else\n@@ -864,15 +915,15 @@ ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n \tinput = info->known_vals[idx];\n       else\n \t{\n-\t  struct ipcp_lattice *lat;\n+\t  ipcp_lattice<tree> *lat;\n \n \t  if (!info->lattices)\n \t    {\n \t      gcc_checking_assert (!flag_ipa_cp);\n \t      return NULL_TREE;\n \t    }\n \t  lat = ipa_get_scalar_lat (info, idx);\n-\t  if (!ipa_lat_is_single_const (lat))\n+\t  if (!lat->is_single_const ())\n \t    return NULL_TREE;\n \t  input = lat->values->value;\n \t}\n@@ -906,7 +957,7 @@ ipcp_verify_propagated_values (void)\n \n       for (i = 0; i < count; i++)\n \t{\n-\t  struct ipcp_lattice *lat = ipa_get_scalar_lat (info, i);\n+\t  ipcp_lattice<tree> *lat = ipa_get_scalar_lat (info, i);\n \n \t  if (!lat->bottom\n \t      && !lat->contains_variable\n@@ -949,130 +1000,131 @@ values_equal_for_ipcp_p (tree x, tree y)\n     return operand_equal_p (x, y, 0);\n }\n \n-/* Add a new value source to VAL, marking that a value comes from edge CS and\n-   (if the underlying jump function is a pass-through or an ancestor one) from\n-   a caller value SRC_VAL of a caller parameter described by SRC_INDEX.  OFFSET\n-   is negative if the source was the scalar value of the parameter itself or\n-   the offset within an aggregate.  */\n+/* Add a new value source to the value represented by THIS, marking that a\n+   value comes from edge CS and (if the underlying jump function is a\n+   pass-through or an ancestor one) from a caller value SRC_VAL of a caller\n+   parameter described by SRC_INDEX.  OFFSET is negative if the source was the\n+   scalar value of the parameter itself or the offset within an aggregate.  */\n \n-static void\n-add_value_source (struct ipcp_value *val, struct cgraph_edge *cs,\n-\t\t  struct ipcp_value *src_val, int src_idx, HOST_WIDE_INT offset)\n+template <typename valtype>\n+void\n+ipcp_value<valtype>::add_source (cgraph_edge *cs, ipcp_value *src_val,\n+\t\t\t\t int src_idx, HOST_WIDE_INT offset)\n {\n-  struct ipcp_value_source *src;\n+  ipcp_value_source<valtype> *src;\n \n-  src = (struct ipcp_value_source *) pool_alloc (ipcp_sources_pool);\n+  src = new (pool_alloc (ipcp_sources_pool)) ipcp_value_source<valtype>;\n   src->offset = offset;\n   src->cs = cs;\n   src->val = src_val;\n   src->index = src_idx;\n \n-  src->next = val->sources;\n-  val->sources = src;\n+  src->next = sources;\n+  sources = src;\n }\n \n-/* Try to add NEWVAL to LAT, potentially creating a new struct ipcp_value for\n-   it.  CS, SRC_VAL SRC_INDEX and OFFSET are meant for add_value_source and\n-   have the same meaning.  */\n+/* Allocate a new ipcp_value holding a tree constant, initialize its value to\n+   SOURCE and clear all other fields.  */\n \n-static bool\n-add_value_to_lattice (struct ipcp_lattice *lat, tree newval,\n-\t\t      struct cgraph_edge *cs, struct ipcp_value *src_val,\n-\t\t      int src_idx, HOST_WIDE_INT offset)\n+static ipcp_value<tree> *\n+allocate_and_init_ipcp_value (tree source)\n {\n-  struct ipcp_value *val;\n+  ipcp_value<tree> *val;\n \n-  if (lat->bottom)\n+  val = new (pool_alloc (ipcp_values_pool)) ipcp_value<tree>;\n+  memset (val, 0, sizeof (*val));\n+  val->value = source;\n+  return val;\n+}\n+\n+/* Try to add NEWVAL to LAT, potentially creating a new ipcp_value for it.  CS,\n+   SRC_VAL SRC_INDEX and OFFSET are meant for add_source and have the same\n+   meaning.  OFFSET -1 means the source is scalar and not a part of an\n+   aggregate.  */\n+\n+template <typename valtype>\n+bool\n+ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n+\t\t\t\t  ipcp_value<valtype> *src_val,\n+\t\t\t\t  int src_idx, HOST_WIDE_INT offset)\n+{\n+  ipcp_value<valtype> *val;\n+\n+  if (bottom)\n     return false;\n \n-  for (val = lat->values; val; val = val->next)\n+  for (val = values; val; val = val->next)\n     if (values_equal_for_ipcp_p (val->value, newval))\n       {\n \tif (ipa_edge_within_scc (cs))\n \t  {\n-\t    struct ipcp_value_source *s;\n+\t    ipcp_value_source<valtype> *s;\n \t    for (s = val->sources; s ; s = s->next)\n \t      if (s->cs == cs)\n \t\tbreak;\n \t    if (s)\n \t      return false;\n \t  }\n \n-\tadd_value_source (val, cs, src_val, src_idx, offset);\n+\tval->add_source (cs, src_val, src_idx, offset);\n \treturn false;\n       }\n \n-  if (lat->values_count == PARAM_VALUE (PARAM_IPA_CP_VALUE_LIST_SIZE))\n+  if (values_count == PARAM_VALUE (PARAM_IPA_CP_VALUE_LIST_SIZE))\n     {\n       /* We can only free sources, not the values themselves, because sources\n \t of other values in this this SCC might point to them.   */\n-      for (val = lat->values; val; val = val->next)\n+      for (val = values; val; val = val->next)\n \t{\n \t  while (val->sources)\n \t    {\n-\t      struct ipcp_value_source *src = val->sources;\n+\t      ipcp_value_source<valtype> *src = val->sources;\n \t      val->sources = src->next;\n \t      pool_free (ipcp_sources_pool, src);\n \t    }\n \t}\n \n-      lat->values = NULL;\n-      return set_lattice_to_bottom (lat);\n+      values = NULL;\n+      return set_to_bottom ();\n     }\n \n-  lat->values_count++;\n-  val = (struct ipcp_value *) pool_alloc (ipcp_values_pool);\n-  memset (val, 0, sizeof (*val));\n-\n-  add_value_source (val, cs, src_val, src_idx, offset);\n-  val->value = newval;\n-  val->next = lat->values;\n-  lat->values = val;\n+  values_count++;\n+  val = allocate_and_init_ipcp_value (newval);\n+  val->add_source (cs, src_val, src_idx, offset);\n+  val->next = values;\n+  values = val;\n   return true;\n }\n \n-/* Like above but passes a special value of offset to distinguish that the\n-   origin is the scalar value of the parameter rather than a part of an\n-   aggregate.  */\n-\n-static inline bool\n-add_scalar_value_to_lattice (struct ipcp_lattice *lat, tree newval,\n-\t\t\t     struct cgraph_edge *cs,\n-\t\t\t     struct ipcp_value *src_val, int src_idx)\n-{\n-  return add_value_to_lattice (lat, newval, cs, src_val, src_idx, -1);\n-}\n-\n /* Propagate values through a pass-through jump function JFUNC associated with\n    edge CS, taking values from SRC_LAT and putting them into DEST_LAT.  SRC_IDX\n    is the index of the source parameter.  */\n \n static bool\n-propagate_vals_accross_pass_through (struct cgraph_edge *cs,\n-\t\t\t\t     struct ipa_jump_func *jfunc,\n-\t\t\t\t     struct ipcp_lattice *src_lat,\n-\t\t\t\t     struct ipcp_lattice *dest_lat,\n+propagate_vals_accross_pass_through (cgraph_edge *cs,\n+\t\t\t\t     ipa_jump_func *jfunc,\n+\t\t\t\t     ipcp_lattice<tree> *src_lat,\n+\t\t\t\t     ipcp_lattice<tree> *dest_lat,\n \t\t\t\t     int src_idx)\n {\n-  struct ipcp_value *src_val;\n+  ipcp_value<tree> *src_val;\n   bool ret = false;\n \n   /* Do not create new values when propagating within an SCC because if there\n      are arithmetic functions with circular dependencies, there is infinite\n      number of them and we would just make lattices bottom.  */\n   if ((ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR)\n       && ipa_edge_within_scc (cs))\n-    ret = set_lattice_contains_variable (dest_lat);\n+    ret = dest_lat->set_contains_variable ();\n   else\n     for (src_val = src_lat->values; src_val; src_val = src_val->next)\n       {\n \ttree cstval = ipa_get_jf_pass_through_result (jfunc, src_val->value);\n \n \tif (cstval)\n-\t  ret |= add_scalar_value_to_lattice (dest_lat, cstval, cs, src_val,\n-\t\t\t\t\t      src_idx);\n+\t  ret |= dest_lat->add_value (cstval, cs, src_val, src_idx);\n \telse\n-\t  ret |= set_lattice_contains_variable (dest_lat);\n+\t  ret |= dest_lat->set_contains_variable ();\n       }\n \n   return ret;\n@@ -1085,24 +1137,24 @@ propagate_vals_accross_pass_through (struct cgraph_edge *cs,\n static bool\n propagate_vals_accross_ancestor (struct cgraph_edge *cs,\n \t\t\t\t struct ipa_jump_func *jfunc,\n-\t\t\t\t struct ipcp_lattice *src_lat,\n-\t\t\t\t struct ipcp_lattice *dest_lat,\n+\t\t\t\t ipcp_lattice<tree> *src_lat,\n+\t\t\t\t ipcp_lattice<tree> *dest_lat,\n \t\t\t\t int src_idx)\n {\n-  struct ipcp_value *src_val;\n+  ipcp_value<tree> *src_val;\n   bool ret = false;\n \n   if (ipa_edge_within_scc (cs))\n-    return set_lattice_contains_variable (dest_lat);\n+    return dest_lat->set_contains_variable ();\n \n   for (src_val = src_lat->values; src_val; src_val = src_val->next)\n     {\n       tree t = ipa_get_jf_ancestor_result (jfunc, src_val->value);\n \n       if (t)\n-\tret |= add_scalar_value_to_lattice (dest_lat, t, cs, src_val, src_idx);\n+\tret |= dest_lat->add_value (t, cs, src_val, src_idx);\n       else\n-\tret |= set_lattice_contains_variable (dest_lat);\n+\tret |= dest_lat->set_contains_variable ();\n     }\n \n   return ret;\n@@ -1114,7 +1166,7 @@ propagate_vals_accross_ancestor (struct cgraph_edge *cs,\n static bool\n propagate_scalar_accross_jump_function (struct cgraph_edge *cs,\n \t\t\t\t\tstruct ipa_jump_func *jfunc,\n-\t\t\t\t\tstruct ipcp_lattice *dest_lat)\n+\t\t\t\t\tipcp_lattice<tree> *dest_lat)\n {\n   if (dest_lat->bottom)\n     return false;\n@@ -1128,17 +1180,17 @@ propagate_scalar_accross_jump_function (struct cgraph_edge *cs,\n \t{\n \t  val = ipa_binfo_from_known_type_jfunc (jfunc);\n \t  if (!val)\n-\t    return set_lattice_contains_variable (dest_lat);\n+\t    return dest_lat->set_contains_variable ();\n \t}\n       else\n \tval = ipa_get_jf_constant (jfunc);\n-      return add_scalar_value_to_lattice (dest_lat, val, cs, NULL, 0);\n+      return dest_lat->add_value (val, cs, NULL, 0);\n     }\n   else if (jfunc->type == IPA_JF_PASS_THROUGH\n \t   || jfunc->type == IPA_JF_ANCESTOR)\n     {\n       struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n-      struct ipcp_lattice *src_lat;\n+      ipcp_lattice<tree> *src_lat;\n       int src_idx;\n       bool ret;\n \n@@ -1149,13 +1201,13 @@ propagate_scalar_accross_jump_function (struct cgraph_edge *cs,\n \n       src_lat = ipa_get_scalar_lat (caller_info, src_idx);\n       if (src_lat->bottom)\n-\treturn set_lattice_contains_variable (dest_lat);\n+\treturn dest_lat->set_contains_variable ();\n \n       /* If we would need to clone the caller and cannot, do not propagate.  */\n       if (!ipcp_versionable_function_p (cs->caller)\n \t  && (src_lat->contains_variable\n \t      || (src_lat->values_count > 1)))\n-\treturn set_lattice_contains_variable (dest_lat);\n+\treturn dest_lat->set_contains_variable ();\n \n       if (jfunc->type == IPA_JF_PASS_THROUGH)\n \tret = propagate_vals_accross_pass_through (cs, jfunc, src_lat,\n@@ -1165,14 +1217,14 @@ propagate_scalar_accross_jump_function (struct cgraph_edge *cs,\n \t\t\t\t\t       src_idx);\n \n       if (src_lat->contains_variable)\n-\tret |= set_lattice_contains_variable (dest_lat);\n+\tret |= dest_lat->set_contains_variable ();\n \n       return ret;\n     }\n \n   /* TODO: We currently do not handle member method pointers in IPA-CP (we only\n      use it for indirect inlining), we should propagate them too.  */\n-  return set_lattice_contains_variable (dest_lat);\n+  return dest_lat->set_contains_variable ();\n }\n \n /* If DEST_PLATS already has aggregate items, check that aggs_by_ref matches\n@@ -1222,7 +1274,7 @@ merge_agg_lats_step (struct ipcp_param_lattices *dest_plats,\n \t  set_agg_lats_to_bottom (dest_plats);\n \t  return false;\n \t}\n-      *change |= set_lattice_contains_variable (**aglat);\n+      *change |= (**aglat)->set_contains_variable ();\n       *aglat = &(**aglat)->next;\n     }\n \n@@ -1273,7 +1325,7 @@ set_chain_of_aglats_contains_variable (struct ipcp_agg_lattice *aglat)\n   bool ret = false;\n   while (aglat)\n     {\n-      ret |= set_lattice_contains_variable (aglat);\n+      ret |= aglat->set_contains_variable ();\n       aglat = aglat->next;\n     }\n   return ret;\n@@ -1318,16 +1370,16 @@ merge_aggregate_lattices (struct cgraph_edge *cs,\n \t  dst_aglat = &(*dst_aglat)->next;\n \t  if (src_aglat->bottom)\n \t    {\n-\t      ret |= set_lattice_contains_variable (new_al);\n+\t      ret |= new_al->set_contains_variable ();\n \t      continue;\n \t    }\n \t  if (src_aglat->contains_variable)\n-\t    ret |= set_lattice_contains_variable (new_al);\n-\t  for (struct ipcp_value *val = src_aglat->values;\n+\t    ret |= new_al->set_contains_variable ();\n+\t  for (ipcp_value<tree> *val = src_aglat->values;\n \t       val;\n \t       val = val->next)\n-\t    ret |= add_value_to_lattice (new_al, val->value, cs, val, src_idx,\n-\t\t\t\t\t src_aglat->offset);\n+\t    ret |= new_al->add_value (val->value, cs, val, src_idx,\n+\t\t\t\t      src_aglat->offset);\n \t}\n       else if (dest_plats->aggs_bottom)\n \treturn true;\n@@ -1424,7 +1476,7 @@ propagate_aggs_accross_jump_function (struct cgraph_edge *cs,\n \t  if (merge_agg_lats_step (dest_plats, item->offset, val_size,\n \t\t\t\t   &aglat, pre_existing, &ret))\n \t    {\n-\t      ret |= add_value_to_lattice (*aglat, item->value, cs, NULL, 0, 0);\n+\t      ret |= (*aglat)->add_value (item->value, cs, NULL, 0, 0);\n \t      aglat = &(*aglat)->next;\n \t    }\n \t  else if (dest_plats->aggs_bottom)\n@@ -1828,7 +1880,7 @@ context_independent_aggregate_values (struct ipcp_param_lattices *plats)\n   for (struct ipcp_agg_lattice *aglat = plats->aggs;\n        aglat;\n        aglat = aglat->next)\n-    if (ipa_lat_is_single_const (aglat))\n+    if (aglat->is_single_const ())\n       {\n \tstruct ipa_agg_jf_item item;\n \titem.offset = aglat->offset;\n@@ -1869,11 +1921,11 @@ gather_context_independent_values (struct ipa_node_params *info,\n   for (i = 0; i < count ; i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-      struct ipcp_lattice *lat = &plats->itself;\n+      ipcp_lattice<tree> *lat = &plats->itself;\n \n-      if (ipa_lat_is_single_const (lat))\n+      if (lat->is_single_const ())\n \t{\n-\t  struct ipcp_value *val = lat->values;\n+\t  ipcp_value<tree> *val = lat->values;\n \t  if (TREE_CODE (val->value) != TREE_BINFO)\n \t    {\n \t      (*known_csts)[i] = val->value;\n@@ -1932,6 +1984,43 @@ agg_jmp_p_vec_for_t_vec (vec<ipa_agg_jump_function> known_aggs)\n   return ret;\n }\n \n+/* Perform time and size measurement of NODE with the context given in\n+   KNOWN_CSTS, KNOWN_BINFOS and KNOWN_AGGS, calculate the benefit and cost\n+   given BASE_TIME of the node without specialization, REMOVABLE_PARAMS_COST of\n+   all context-independent removable parameters and EST_MOVE_COST of estimated\n+   movement of the considered parameter and store it into VAL.  */\n+\n+static void\n+perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n+\t\t\t       vec<tree> known_binfos,\n+\t\t\t       vec<ipa_agg_jump_function_p> known_aggs_ptrs,\n+\t\t\t       int base_time, int removable_params_cost,\n+\t\t\t       int est_move_cost, ipcp_value_base *val)\n+{\n+  int time, size, time_benefit;\n+  inline_hints hints;\n+\n+  estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n+\t\t\t\t     known_aggs_ptrs, &size, &time,\n+\t\t\t\t     &hints);\n+  time_benefit = base_time - time\n+    + devirtualization_time_bonus (node, known_csts, known_binfos,\n+\t\t\t\t   known_aggs_ptrs)\n+    + hint_time_bonus (hints)\n+    + removable_params_cost + est_move_cost;\n+\n+  gcc_checking_assert (size >=0);\n+  /* The inliner-heuristics based estimates may think that in certain\n+     contexts some functions do not have any size at all but we want\n+     all specializations to have at least a tiny cost, not least not to\n+     divide by zero.  */\n+  if (size == 0)\n+    size = 1;\n+\n+  val->local_time_benefit = time_benefit;\n+  val->local_size_cost = size;\n+}\n+\n /* Iterate over known values of parameters of NODE and estimate the local\n    effects in terms of time and size they have.  */\n \n@@ -2013,8 +2102,8 @@ estimate_local_effects (struct cgraph_node *node)\n   for (i = 0; i < count ; i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-      struct ipcp_lattice *lat = &plats->itself;\n-      struct ipcp_value *val;\n+      ipcp_lattice<tree> *lat = &plats->itself;\n+      ipcp_value<tree> *val;\n       int emc;\n \n       if (lat->bottom\n@@ -2025,9 +2114,6 @@ estimate_local_effects (struct cgraph_node *node)\n \n       for (val = lat->values; val; val = val->next)\n \t{\n-\t  int time, size, time_benefit;\n-\t  inline_hints hints;\n-\n \t  if (TREE_CODE (val->value) != TREE_BINFO)\n \t    {\n \t      known_csts[i] = val->value;\n@@ -2043,22 +2129,9 @@ estimate_local_effects (struct cgraph_node *node)\n \t  else\n \t    continue;\n \n-\t  estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n-\t\t\t\t\t     known_aggs_ptrs, &size, &time,\n-\t\t\t\t\t     &hints);\n-\t  time_benefit = base_time - time\n-\t    + devirtualization_time_bonus (node, known_csts, known_binfos,\n-\t\t\t\t\t   known_aggs_ptrs)\n-\t    + hint_time_bonus (hints)\n-\t    + removable_params_cost + emc;\n-\n-\t  gcc_checking_assert (size >=0);\n-\t  /* The inliner-heuristics based estimates may think that in certain\n-\t     contexts some functions do not have any size at all but we want\n-\t     all specializations to have at least a tiny cost, not least not to\n-\t     divide by zero.  */\n-\t  if (size == 0)\n-\t    size = 1;\n+\t  perform_estimation_of_a_value (node, known_csts, known_binfos,\n+\t\t\t\t\t known_aggs_ptrs, base_time,\n+\t\t\t\t\t removable_params_cost, emc, val);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -2067,11 +2140,8 @@ estimate_local_effects (struct cgraph_node *node)\n \t      fprintf (dump_file, \" for \");\n \t      ipa_dump_param (dump_file, info, i);\n \t      fprintf (dump_file, \": time_benefit: %i, size: %i\\n\",\n-\t\t       time_benefit, size);\n+\t\t       val->local_time_benefit, val->local_size_cost);\n \t    }\n-\n-\t  val->local_time_benefit = time_benefit;\n-\t  val->local_size_cost = size;\n \t}\n       known_binfos[i] = NULL_TREE;\n       known_csts[i] = NULL_TREE;\n@@ -2089,33 +2159,24 @@ estimate_local_effects (struct cgraph_node *node)\n       ajf = &known_aggs[i];\n       for (aglat = plats->aggs; aglat; aglat = aglat->next)\n \t{\n-\t  struct ipcp_value *val;\n+\t  ipcp_value<tree> *val;\n \t  if (aglat->bottom || !aglat->values\n \t      /* If the following is true, the one value is in known_aggs.  */\n \t      || (!plats->aggs_contain_variable\n-\t\t  && ipa_lat_is_single_const (aglat)))\n+\t\t  && aglat->is_single_const ()))\n \t    continue;\n \n \t  for (val = aglat->values; val; val = val->next)\n \t    {\n-\t      int time, size, time_benefit;\n \t      struct ipa_agg_jf_item item;\n-\t      inline_hints hints;\n \n \t      item.offset = aglat->offset;\n \t      item.value = val->value;\n \t      vec_safe_push (ajf->items, item);\n \n-\t      estimate_ipcp_clone_size_and_time (node, known_csts, known_binfos,\n-\t\t\t\t\t\t known_aggs_ptrs, &size, &time,\n-\t\t\t\t\t\t &hints);\n-\t      time_benefit = base_time - time\n-\t\t+ devirtualization_time_bonus (node, known_csts, known_binfos,\n-\t\t\t\t\t       known_aggs_ptrs)\n-\t\t+ hint_time_bonus (hints);\n-\t      gcc_checking_assert (size >=0);\n-\t      if (size == 0)\n-\t\tsize = 1;\n+\t      perform_estimation_of_a_value (node, known_csts, known_binfos,\n+\t\t\t\t\t     known_aggs_ptrs, base_time,\n+\t\t\t\t\t     removable_params_cost, 0, val);\n \n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n@@ -2124,13 +2185,12 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t  fprintf (dump_file, \" for \");\n \t          ipa_dump_param (dump_file, info, i);\n \t\t  fprintf (dump_file, \"[%soffset: \" HOST_WIDE_INT_PRINT_DEC\n-\t\t\t\t       \"]: time_benefit: %i, size: %i\\n\",\n-\t\t\t\t       plats->aggs_by_ref ? \"ref \" : \"\",\n-\t\t\t\t       aglat->offset, time_benefit, size);\n+\t\t\t   \"]: time_benefit: %i, size: %i\\n\",\n+\t\t\t   plats->aggs_by_ref ? \"ref \" : \"\",\n+\t\t\t   aglat->offset,\n+\t\t\t   val->local_time_benefit, val->local_size_cost);\n \t\t}\n \n-\t      val->local_time_benefit = time_benefit;\n-\t      val->local_size_cost = size;\n \t      ajf->items->pop ();\n \t    }\n \t}\n@@ -2149,12 +2209,11 @@ estimate_local_effects (struct cgraph_node *node)\n /* Add value CUR_VAL and all yet-unsorted values it is dependent on to the\n    topological sort of values.  */\n \n-static void\n-add_val_to_toposort (struct ipcp_value *cur_val)\n+template <typename valtype>\n+void\n+value_topo_info<valtype>::add_val (ipcp_value<valtype> *cur_val)\n {\n-  static int dfs_counter = 0;\n-  static struct ipcp_value *stack;\n-  struct ipcp_value_source *src;\n+  ipcp_value_source<valtype> *src;\n \n   if (cur_val->dfs)\n     return;\n@@ -2172,7 +2231,7 @@ add_val_to_toposort (struct ipcp_value *cur_val)\n       {\n \tif (src->val->dfs == 0)\n \t  {\n-\t    add_val_to_toposort (src->val);\n+\t    add_val (src->val);\n \t    if (src->val->low_link < cur_val->low_link)\n \t      cur_val->low_link = src->val->low_link;\n \t  }\n@@ -2183,7 +2242,7 @@ add_val_to_toposort (struct ipcp_value *cur_val)\n \n   if (cur_val->dfs == cur_val->low_link)\n     {\n-      struct ipcp_value *v, *scc_list = NULL;\n+      ipcp_value<valtype> *v, *scc_list = NULL;\n \n       do\n \t{\n@@ -2205,27 +2264,27 @@ add_val_to_toposort (struct ipcp_value *cur_val)\n    they are not there yet.  */\n \n static void\n-add_all_node_vals_to_toposort (struct cgraph_node *node)\n+add_all_node_vals_to_toposort (cgraph_node *node, ipa_topo_info *topo)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n \n   for (i = 0; i < count ; i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-      struct ipcp_lattice *lat = &plats->itself;\n+      ipcp_lattice<tree> *lat = &plats->itself;\n       struct ipcp_agg_lattice *aglat;\n-      struct ipcp_value *val;\n+      ipcp_value<tree> *val;\n \n       if (!lat->bottom)\n \tfor (val = lat->values; val; val = val->next)\n-\t  add_val_to_toposort (val);\n+\t  topo->constants.add_val (val);\n \n       if (!plats->aggs_bottom)\n \tfor (aglat = plats->aggs; aglat; aglat = aglat->next)\n \t  if (!aglat->bottom)\n \t    for (val = aglat->values; val; val = val->next)\n-\t      add_val_to_toposort (val);\n+\t      topo->constants.add_val (val);\n     }\n }\n \n@@ -2271,7 +2330,7 @@ propagate_constants_topo (struct ipa_topo_info *topo)\n \t    struct cgraph_edge *cs;\n \n \t    estimate_local_effects (v);\n-\t    add_all_node_vals_to_toposort (v);\n+\t    add_all_node_vals_to_toposort (v, topo);\n \t    for (cs = v->callees; cs; cs = cs->next_callee)\n \t      if (!ipa_edge_within_scc (cs))\n \t\tpropagate_constants_accross_call (cs);\n@@ -2297,15 +2356,16 @@ safe_add (int a, int b)\n /* Propagate the estimated effects of individual values along the topological\n    from the dependent values to those they depend on.  */\n \n-static void\n-propagate_effects (void)\n+template <typename valtype>\n+void\n+value_topo_info<valtype>::propagate_effects ()\n {\n-  struct ipcp_value *base;\n+  ipcp_value<valtype> *base;\n \n   for (base = values_topo; base; base = base->topo_next)\n     {\n-      struct ipcp_value_source *src;\n-      struct ipcp_value *val;\n+      ipcp_value_source<valtype> *src;\n+      ipcp_value<valtype> *val;\n       int time = 0, size = 0;\n \n       for (val = base; val; val = val->scc_next)\n@@ -2374,7 +2434,7 @@ ipcp_propagate_stage (struct ipa_topo_info *topo)\n #ifdef ENABLE_CHECKING\n   ipcp_verify_propagated_values ();\n #endif\n-  propagate_effects ();\n+  topo->constants.propagate_effects ();\n \n   if (dump_file)\n     {\n@@ -2513,7 +2573,7 @@ get_clone_agg_value (struct cgraph_node *node, HOST_WIDE_INT offset,\n \n static bool\n cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n-\t\t\t    struct ipcp_value_source *src)\n+\t\t\t    ipcp_value_source<tree> *src)\n {\n   struct ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n   cgraph_node *real_dest = cs->callee->function_symbol ();\n@@ -2541,7 +2601,7 @@ cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (caller_info,\n \t\t\t\t\t\t\t\t src->index);\n       if (src->offset == -1)\n-\treturn (ipa_lat_is_single_const (&plats->itself)\n+\treturn (plats->itself.is_single_const ()\n \t\t&& values_equal_for_ipcp_p (src->val->value,\n \t\t\t\t\t    plats->itself.values->value));\n       else\n@@ -2550,7 +2610,7 @@ cgraph_edge_brings_value_p (struct cgraph_edge *cs,\n \t    return false;\n \t  for (aglat = plats->aggs; aglat; aglat = aglat->next)\n \t    if (aglat->offset == src->offset)\n-\t      return  (ipa_lat_is_single_const (aglat)\n+\t      return  (aglat->is_single_const ()\n \t\t       && values_equal_for_ipcp_p (src->val->value,\n \t\t\t\t\t\t   aglat->values->value));\n \t}\n@@ -2570,11 +2630,12 @@ get_next_cgraph_edge_clone (struct cgraph_edge *cs)\n    edge frequency and their number into *FREQUENCY and *CALLER_COUNT\n    respectively.  */\n \n+template <typename valtype>\n static bool\n-get_info_about_necessary_edges (struct ipcp_value *val, int *freq_sum,\n+get_info_about_necessary_edges (ipcp_value<valtype> *val, int *freq_sum,\n \t\t\t\tgcov_type *count_sum, int *caller_count)\n {\n-  struct ipcp_value_source *src;\n+  ipcp_value_source<valtype> *src;\n   int freq = 0, count = 0;\n   gcov_type cnt = 0;\n   bool hot = false;\n@@ -2604,10 +2665,11 @@ get_info_about_necessary_edges (struct ipcp_value *val, int *freq_sum,\n /* Return a vector of incoming edges that do bring value VAL.  It is assumed\n    their number is known and equal to CALLER_COUNT.  */\n \n+template <typename valtype>\n static vec<cgraph_edge *>\n-gather_edges_for_value (struct ipcp_value *val, int caller_count)\n+gather_edges_for_value (ipcp_value<valtype> *val, int caller_count)\n {\n-  struct ipcp_value_source *src;\n+  ipcp_value_source<valtype> *src;\n   vec<cgraph_edge *> ret;\n \n   ret.create (caller_count);\n@@ -2932,7 +2994,7 @@ copy_plats_to_inter (struct ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n     return vNULL;\n \n   for (struct ipcp_agg_lattice *aglat = plats->aggs; aglat; aglat = aglat->next)\n-    if (ipa_lat_is_single_const (aglat))\n+    if (aglat->is_single_const ())\n       {\n \tstruct ipa_agg_jf_item ti;\n \tti.offset = aglat->offset - offset;\n@@ -3385,10 +3447,11 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n    all other criteria such that they can be redirected the the special node.\n    This function can therefore redirect the final edge in a SCC.  */\n \n+template <typename valtype>\n static void\n-perhaps_add_new_callers (struct cgraph_node *node, struct ipcp_value *val)\n+perhaps_add_new_callers (cgraph_node *node, ipcp_value<valtype> *val)\n {\n-  struct ipcp_value_source *src;\n+  ipcp_value_source<valtype> *src;\n   gcov_type redirected_sum = 0;\n \n   for (src = val->sources; src; src = src->next)\n@@ -3464,9 +3527,10 @@ ipcp_val_in_agg_replacements_p (struct ipa_agg_replacement_value *aggvals,\n    otherwise it is stored at the given OFFSET of the parameter.  KNOWN_CSTS,\n    KNOWN_BINFOS and KNOWN_AGGS describe the other already known values.  */\n \n+template <typename valtype>\n static bool\n decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n-\t\t    struct ipcp_value *val, vec<tree> known_csts,\n+\t\t    ipcp_value<valtype> *val, vec<tree> known_csts,\n \t\t    vec<tree> known_binfos)\n {\n   struct ipa_agg_replacement_value *aggvals;\n@@ -3562,8 +3626,8 @@ decide_whether_version_node (struct cgraph_node *node)\n   for (i = 0; i < count ;i++)\n     {\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-      struct ipcp_lattice *lat = &plats->itself;\n-      struct ipcp_value *val;\n+      ipcp_lattice<tree> *lat = &plats->itself;\n+      ipcp_value<tree> *val;\n \n       if (!lat->bottom\n \t  && !known_csts[i]\n@@ -3575,13 +3639,13 @@ decide_whether_version_node (struct cgraph_node *node)\n       if (!plats->aggs_bottom)\n \t{\n \t  struct ipcp_agg_lattice *aglat;\n-\t  struct ipcp_value *val;\n+\t  ipcp_value<tree> *val;\n \t  for (aglat = plats->aggs; aglat; aglat = aglat->next)\n \t    if (!aglat->bottom && aglat->values\n \t\t/* If the following is false, the one value is in\n \t\t   known_aggs.  */\n \t\t&& (plats->aggs_contain_variable\n-\t\t    || !ipa_lat_is_single_const (aglat)))\n+\t\t    || !aglat->is_single_const ()))\n \t      for (val = aglat->values; val; val = val->next)\n \t\tret |= decide_about_value (node, i, aglat->offset, val,\n \t\t\t\t\t   known_csts, known_binfos);\n@@ -3740,9 +3804,9 @@ ipcp_driver (void)\n     symtab->add_edge_removal_hook (&ipcp_edge_removal_hook, NULL);\n \n   ipcp_values_pool = create_alloc_pool (\"IPA-CP values\",\n-\t\t\t\t\tsizeof (struct ipcp_value), 32);\n+\t\t\t\t\tsizeof (ipcp_value<tree>), 32);\n   ipcp_sources_pool = create_alloc_pool (\"IPA-CP value sources\",\n-\t\t\t\t\t sizeof (struct ipcp_value_source), 64);\n+\t\t\t\t\t sizeof (ipcp_value_source<tree>), 64);\n   ipcp_agg_lattice_pool = create_alloc_pool (\"IPA_CP aggregate lattices\",\n \t\t\t\t\t     sizeof (struct ipcp_agg_lattice),\n \t\t\t\t\t     32);\n@@ -3871,5 +3935,4 @@ ipa_cp_c_finalize (void)\n   max_count = 0;\n   overall_size = 0;\n   max_new_size = 0;\n-  values_topo = NULL;\n }"}, {"sha": "fdf4811773414314a26c811b09ae97d04357b217", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0cb50559966b5215b3b2901fed2d672f6594b5f/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0cb50559966b5215b3b2901fed2d672f6594b5f/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=c0cb50559966b5215b3b2901fed2d672f6594b5f", "patch": "@@ -348,8 +348,6 @@ struct ipa_param_descriptor\n   unsigned used : 1;\n };\n \n-struct ipcp_lattice;\n-\n /* ipa_node_params stores information related to formal parameters of functions\n    and some other information for interprocedural passes that operate on\n    parameters (such as ipa-cp).  */"}]}