{"sha": "032d1b710a0f42d3c6254a728292056b0626b933", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDMyZDFiNzEwYTBmNDJkM2M2MjU0YTcyODI5MjA1NmIwNjI2YjkzMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-11-24T20:25:58Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-11-24T20:25:58Z"}, "message": "sem_util.adb (Set_Debug_Info_Needed): For an E_Class_Wide_Subtype, also set the flag on the Equivalent_Type.\n\n\t* sem_util.adb (Set_Debug_Info_Needed): For an E_Class_Wide_Subtype,\n\talso set the flag on the Equivalent_Type.\n\t* gcc-interface/utils.c (finish_record_type): Replace DO_NOT_FINALIZE\n\tparameter with DEBUG_INFO_P.  Rename FIELDLIST into FIELD_LIST.\n\t(rest_of_record_type_compilation): Rename FIELDLIST into FIELD_LIST.\n\t(build_vms_descriptor32): Adjust call to finish_record_type.\n\t(build_vms_descriptor): Likewise.\n\t(build_unc_object_type): Likewise.\n\t* decl.c (gnat_to_gnu_entity): Adjust calls to finish_record_type and\n\tcomponents_to_record.\n\t(make_packable_type): Adjust call to finish_record_type.\n\t(maybe_pad_type): Likewise.  Tweak condition.\n\t(components_to_record): Likewise.  Replace DO_NOT_FINALIZE parameter\n\twith MAYBE_UNUSED.  Adjust recursive call.\n\t(create_variant_part_from): Adjust call to finish_record_type.  Do not\n\tcall rest_of_record_type_compilation on the new record types.\n\t* trans.c (gigi): Adjust call to finish_record_type.\n\t* gigi.h (finish_record_type): Adjust prototype and comment.\n\t(rest_of_record_type_compilation): Adjust comment.\n\nFrom-SVN: r154515", "tree": {"sha": "17496e30ebebba2f16ca43aa3a1477b44bb07915", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17496e30ebebba2f16ca43aa3a1477b44bb07915"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/032d1b710a0f42d3c6254a728292056b0626b933", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032d1b710a0f42d3c6254a728292056b0626b933", "html_url": "https://github.com/Rust-GCC/gccrs/commit/032d1b710a0f42d3c6254a728292056b0626b933", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032d1b710a0f42d3c6254a728292056b0626b933/comments", "author": null, "committer": null, "parents": [{"sha": "cbae498bb28dc9997ed129456abaa95fb0ed6758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbae498bb28dc9997ed129456abaa95fb0ed6758", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbae498bb28dc9997ed129456abaa95fb0ed6758"}], "stats": {"total": 211, "additions": 117, "deletions": 94}, "files": [{"sha": "336023162a1044c95371202c0fdb66ab49bc6ffd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=032d1b710a0f42d3c6254a728292056b0626b933", "patch": "@@ -1,3 +1,25 @@\n+2009-11-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_util.adb (Set_Debug_Info_Needed): For an E_Class_Wide_Subtype,\n+\talso set the flag on the Equivalent_Type.\n+\t* gcc-interface/utils.c (finish_record_type): Replace DO_NOT_FINALIZE\n+\tparameter with DEBUG_INFO_P.  Rename FIELDLIST into FIELD_LIST.\n+\t(rest_of_record_type_compilation): Rename FIELDLIST into FIELD_LIST.\n+\t(build_vms_descriptor32): Adjust call to finish_record_type.\n+\t(build_vms_descriptor): Likewise.\n+\t(build_unc_object_type): Likewise.\n+\t* decl.c (gnat_to_gnu_entity): Adjust calls to finish_record_type and\n+\tcomponents_to_record.\n+\t(make_packable_type): Adjust call to finish_record_type.\n+\t(maybe_pad_type): Likewise.  Tweak condition.\n+\t(components_to_record): Likewise.  Replace DO_NOT_FINALIZE parameter\n+\twith MAYBE_UNUSED.  Adjust recursive call.\n+\t(create_variant_part_from): Adjust call to finish_record_type.  Do not\n+\tcall rest_of_record_type_compilation on the new record types.\n+\t* trans.c (gigi): Adjust call to finish_record_type.\n+\t* gigi.h (finish_record_type): Adjust prototype and comment.\n+\t(rest_of_record_type_compilation): Adjust comment.\n+\n 2009-11-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_util.adb (Make_CW_Equivalent_Type): Do not mark the type as"}, {"sha": "8b4936ab6dc3b221d9c65f66a4e3ec98f20ecdbe", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 61, "deletions": 62, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=032d1b710a0f42d3c6254a728292056b0626b933", "patch": "@@ -1630,20 +1630,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gnu_field = create_field_decl (get_identifier (\"OBJECT\"),\n \t\t\t\t\t gnu_field_type, gnu_type, 1, 0, 0, 0);\n \n-\t  /* Do not finalize it until after the parallel type is added.  */\n-\t  finish_record_type (gnu_type, gnu_field, 0, true);\n+\t  /* Do not emit debug info until after the parallel type is added.  */\n+\t  finish_record_type (gnu_type, gnu_field, 0, false);\n \t  TYPE_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n \n \t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n \n-\t  /* Make the original array type a parallel type.  */\n-\t  if (debug_info_p\n-\t      && present_gnu_tree (Original_Array_Type (gnat_entity)))\n-\t    add_parallel_type (TYPE_STUB_DECL (gnu_type),\n-\t\t\t       gnat_to_gnu_type\n-\t\t\t       (Original_Array_Type (gnat_entity)));\n+\t  if (debug_info_p)\n+\t    {\n+\t      /* Make the original array type a parallel type.  */\n+\t      if (present_gnu_tree (Original_Array_Type (gnat_entity)))\n+\t\tadd_parallel_type (TYPE_STUB_DECL (gnu_type),\n+\t\t\t\t   gnat_to_gnu_type\n+\t\t\t\t   (Original_Array_Type (gnat_entity)));\n \n-\t  rest_of_record_type_compilation (gnu_type);\n+\t      rest_of_record_type_compilation (gnu_type);\n+\t    }\n \t}\n \n       /* If the type we are dealing with has got a smaller alignment than the\n@@ -1678,7 +1680,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gnu_field = create_field_decl (get_identifier (\"OBJECT\"),\n \t\t\t\t\t gnu_field_type, gnu_type, 1, 0, 0, 0);\n \n-\t  finish_record_type (gnu_type, gnu_field, 0, false);\n+\t  finish_record_type (gnu_type, gnu_field, 0, debug_info_p);\n \t  TYPE_PADDING_P (gnu_type) = 1;\n \n \t  relate_alias_sets (gnu_type, gnu_field_type, ALIAS_SET_COPY);\n@@ -1824,9 +1826,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Make sure we can put this into a register.  */\n \tTYPE_ALIGN (gnu_fat_type) = MIN (BIGGEST_ALIGNMENT, 2 * POINTER_SIZE);\n \n-\t/* Do not finalize this record type since the types of its fields\n-\t   are still incomplete at this point.  */\n-\tfinish_record_type (gnu_fat_type, tem, 0, true);\n+\t/* Do not emit debug info for this record type since the types of its\n+\t   fields are still incomplete at this point.  */\n+\tfinish_record_type (gnu_fat_type, tem, 0, false);\n \tTYPE_FAT_POINTER_P (gnu_fat_type) = 1;\n \n \t/* Build a reference to the template from a PLACEHOLDER_EXPR that\n@@ -1933,7 +1935,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    = chainon (gnu_template_fields, gnu_temp_fields[index]);\n \n \t/* Install all the fields into the template.  */\n-\tfinish_record_type (gnu_template_type, gnu_template_fields, 0, false);\n+\tfinish_record_type (gnu_template_type, gnu_template_fields, 0,\n+\t\t\t    debug_info_p);\n \tTYPE_READONLY (gnu_template_type) = 1;\n \n \t/* Now make the array of arrays and update the pointer to the array\n@@ -2393,7 +2396,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  gnu_field_list = gnu_field;\n \t\t}\n \n-\t      finish_record_type (gnu_bound_rec, gnu_field_list, 0, false);\n+\t      finish_record_type (gnu_bound_rec, gnu_field_list, 0, true);\n \t      add_parallel_type (TYPE_STUB_DECL (gnu_type), gnu_bound_rec);\n \t    }\n \n@@ -2867,8 +2870,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Add the fields into the record type and finish it up.  */\n \tcomponents_to_record (gnu_type, Component_List (record_definition),\n \t\t\t      gnu_field_list, packed, definition, NULL,\n-\t\t\t      false, all_rep, false, is_unchecked_union,\n-\t\t\t      debug_info_p);\n+\t\t\t      false, all_rep, is_unchecked_union,\n+\t\t\t      debug_info_p, false);\n \n \t/* If it is a tagged record force the type to BLKmode to insure that\n \t   these objects will always be put in memory.  Likewise for limited\n@@ -3188,9 +3191,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    && !present_gnu_tree (Etype (gnat_field)))\n \t\t  gnat_to_gnu_entity (Etype (gnat_field), NULL_TREE, 0);\n \n-\t      /* Do not finalize it since we're going to modify it below.  */\n+\t      /* Do not emit debug info for the type yet since we're going to\n+\t\t modify it below.  */\n \t      gnu_field_list = nreverse (gnu_field_list);\n-\t      finish_record_type (gnu_type, gnu_field_list, 2, true);\n+\t      finish_record_type (gnu_type, gnu_field_list, 2, false);\n \n \t      /* See the E_Record_Type case for the rationale.  */\n \t      if (Is_Tagged_Type (gnat_entity)\n@@ -3225,7 +3229,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t\t\t gnu_subtype_marker,\n \t\t\t\t\t\t\t 0, NULL_TREE,\n \t\t\t\t\t\t\t NULL_TREE, 0),\n-\t\t\t\t      0, false);\n+\t\t\t\t      0, true);\n \n \t\t  add_parallel_type (TYPE_STUB_DECL (gnu_type),\n \t\t\t\t     gnu_subtype_marker);\n@@ -3459,9 +3463,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  = MIN (BIGGEST_ALIGNMENT, 2 * POINTER_SIZE);\n \t\tTYPE_FAT_POINTER_P (gnu_type) = 1;\n \n-\t\t/* Do not finalize this record type since the types of\n-\t\t   its fields are incomplete.  */\n-\t\tfinish_record_type (gnu_type, fields, 0, true);\n+\t\t/* Do not emit debug info for this record type since the types\n+\t\t   of its fields are incomplete.  */\n+\t\tfinish_record_type (gnu_type, fields, 0, false);\n \n \t\tTYPE_OBJECT_RECORD_TYPE (gnu_old) = make_node (RECORD_TYPE);\n \t\tTYPE_NAME (TYPE_OBJECT_RECORD_TYPE (gnu_old))\n@@ -4074,7 +4078,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   stubbed since structures are incomplete for the back-end.  */\n \tif (gnu_field_list && Convention (gnat_entity) != Convention_Stubbed)\n \t  finish_record_type (gnu_return_type, nreverse (gnu_field_list),\n-\t\t\t      0, false);\n+\t\t\t      0, debug_info_p);\n \n \t/* If we have a CICO list but it has only one entry, we convert\n \t   this function into a function that simply returns that one\n@@ -6041,7 +6045,7 @@ make_packable_type (tree type, bool in_record)\n       field_list = new_field;\n     }\n \n-  finish_record_type (new_type, nreverse (field_list), 2, true);\n+  finish_record_type (new_type, nreverse (field_list), 2, false);\n   relate_alias_sets (new_type, type, ALIAS_SET_COPY);\n \n   /* If this is a padding record, we never want to make the size smaller\n@@ -6198,8 +6202,8 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t      orig_size, bitsize_zero_node, 1);\n   DECL_INTERNAL_P (field) = 1;\n \n-  /* Do not finalize it until after the auxiliary record is built.  */\n-  finish_record_type (record, field, 1, true);\n+  /* Do not emit debug info until after the auxiliary record is built.  */\n+  finish_record_type (record, field, 1, false);\n \n   /* Set the same size for its RM size if requested; otherwise reuse\n      the RM size of the original type.  */\n@@ -6208,9 +6212,9 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   /* Unless debugging information isn't being written for the input type,\n      write a record that shows what we are a subtype of and also make a\n      variable that indicates our size, if still variable.  */\n-  if (TYPE_NAME (record)\n-      && AGGREGATE_TYPE_P (type)\n-      && TREE_CODE (orig_size) != INTEGER_CST\n+  if (TREE_CODE (orig_size) != INTEGER_CST\n+      && TYPE_NAME (record)\n+      && TYPE_NAME (type)\n       && !(TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t   && DECL_IGNORED_P (TYPE_NAME (type))))\n     {\n@@ -6230,7 +6234,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t\t\t     build_reference_type (type),\n \t\t\t\t\t     marker, 0, NULL_TREE, NULL_TREE,\n \t\t\t\t\t     0),\n-\t\t\t  0, false);\n+\t\t\t  0, true);\n \n       add_parallel_type (TYPE_STUB_DECL (record), marker);\n \n@@ -6720,35 +6724,34 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n    with Component_Alignment of Storage_Unit, -2 if this is for a record\n    with a specified alignment.\n \n-   DEFINITION is true if we are defining this record.\n+   DEFINITION is true if we are defining this record type.\n \n    P_GNU_REP_LIST, if nonzero, is a pointer to a list to which each field\n    with a rep clause is to be added; in this case, that is all that should\n    be done with such fields.\n \n-   CANCEL_ALIGNMENT, if true, means the alignment should be zeroed before\n-   laying out the record.  This means the alignment only serves to force\n-   fields to be bitfields, but not require the record to be that aligned.\n-   This is used for variants.\n+   CANCEL_ALIGNMENT is true if the alignment should be zeroed before laying\n+   out the record.  This means the alignment only serves to force fields to\n+   be bitfields, but not to require the record to be that aligned.  This is\n+   used for variants.\n+\n+   ALL_REP is true if a rep clause is present for all the fields.\n \n-   ALL_REP, if true, means a rep clause was found for all the fields.  This\n-   simplifies the logic since we know we're not in the mixed case.\n+   UNCHECKED_UNION is true if we are building this type for a record with a\n+   Pragma Unchecked_Union.\n \n-   DO_NOT_FINALIZE, if true, means that the record type is expected to be\n-   modified afterwards so it will not be finalized here.\n+   DEBUG_INFO_P is true if we need to write debug information about the type.\n \n-   UNCHECKED_UNION, if true, means that we are building a type for a record\n-   with a Pragma Unchecked_Union.\n+   MAYBE_UNUSED is true if this type may be unused in the end; this doesn't\n+   mean that its contents may be unused as well, but only the container.  */\n \n-   DEBUG_INFO_P, if true, means that we need to write debug information for\n-   types that we may create in the process.  */\n \n static void\n components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t      tree gnu_field_list, int packed, bool definition,\n \t\t      tree *p_gnu_rep_list, bool cancel_alignment,\n-\t\t      bool all_rep, bool do_not_finalize,\n-\t\t      bool unchecked_union, bool debug_info_p)\n+\t\t      bool all_rep, bool unchecked_union, bool debug_info_p,\n+\t\t      bool maybe_unused)\n {\n   bool all_rep_and_size = all_rep && TYPE_SIZE (gnu_record_type);\n   bool layout_with_rep = false;\n@@ -6878,12 +6881,12 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t= TYPE_SIZE_UNIT (gnu_record_type);\n \t    }\n \n-\t  /* Add the fields into the record type for the variant.  Note that we\n-\t     defer finalizing it until after we are sure to really use it.  */\n+\t  /* Add the fields into the record type for the variant.  Note that\n+\t     we aren't sure to really use it at this point, see below.  */\n \t  components_to_record (gnu_variant_type, Component_List (variant),\n \t\t\t\tNULL_TREE, packed, definition,\n \t\t\t\t&gnu_our_rep_list, !all_rep_and_size, all_rep,\n-\t\t\t\ttrue, unchecked_union, debug_info_p);\n+\t\t\t\tunchecked_union, debug_info_p, true);\n \n \t  gnu_qual = choices_to_gnu (gnu_discr, Discrete_Choices (variant));\n \n@@ -6942,7 +6945,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t    }\n \n \t  finish_record_type (gnu_union_type, nreverse (gnu_variant_list),\n-\t\t\t      all_rep_and_size ? 1 : 0, false);\n+\t\t\t      all_rep_and_size ? 1 : 0, debug_info_p);\n \n \t  /* If GNU_UNION_TYPE is our record type, it means we must have an\n \t     Unchecked_Union with no fields.  Verify that and, if so, just\n@@ -7034,7 +7037,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \n       if (gnu_field_list)\n \t{\n-\t  finish_record_type (gnu_rep_type, gnu_our_rep_list, 1, false);\n+\t  finish_record_type (gnu_rep_type, gnu_our_rep_list, 1, debug_info_p);\n \t  gnu_field\n \t    = create_field_decl (get_identifier (\"REP\"), gnu_rep_type,\n \t\t\t\t gnu_record_type, 0, NULL_TREE, NULL_TREE, 1);\n@@ -7052,7 +7055,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n     TYPE_ALIGN (gnu_record_type) = 0;\n \n   finish_record_type (gnu_record_type, nreverse (gnu_field_list),\n-\t\t      layout_with_rep ? 1 : 0, do_not_finalize);\n+\t\t      layout_with_rep ? 1 : 0, debug_info_p && !maybe_unused);\n }\n \f\n /* Given GNU_SIZE, a GCC tree representing a size, return a Uint to be\n@@ -8141,12 +8144,10 @@ create_variant_part_from (tree old_variant_part, tree variant_list,\n \t  field_list = new_variant_subpart;\n \t}\n \n-      /* Finish up the new variant and create the field.  */\n-      finish_record_type (new_variant, nreverse (field_list), 2, true);\n+      /* Finish up the new variant and create the field.  No need for debug\n+\t info thanks to the XVS type.  */\n+      finish_record_type (new_variant, nreverse (field_list), 2, false);\n       compute_record_mode (new_variant);\n-      rest_of_record_type_compilation (new_variant);\n-\n-      /* No need for debug info thanks to the XVS type.  */\n       create_type_decl (TYPE_NAME (new_variant), new_variant, NULL,\n \t\t\ttrue, false, Empty);\n \n@@ -8160,12 +8161,10 @@ create_variant_part_from (tree old_variant_part, tree variant_list,\n       union_field_list = new_field;\n     }\n \n-  /* Finish up the union type and create the variant part.  */\n-  finish_record_type (new_union_type, union_field_list, 2, true);\n+  /* Finish up the union type and create the variant part.  No need for debug\n+     info thanks to the XVS type.  */\n+  finish_record_type (new_union_type, union_field_list, 2, false);\n   compute_record_mode (new_union_type);\n-  rest_of_record_type_compilation (new_union_type);\n-\n-  /* No need for debug info thanks to the XVS type.  */\n   create_type_decl (TYPE_NAME (new_union_type), new_union_type, NULL,\n \t\t    true, false, Empty);\n "}, {"sha": "1a0a834c91e47cb07d77949b1e44e15a34b57389", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=032d1b710a0f42d3c6254a728292056b0626b933", "patch": "@@ -522,22 +522,21 @@ extern tree make_dummy_type (Entity_Id gnat_type);\n /* Record TYPE as a builtin type for Ada.  NAME is the name of the type.  */\n extern void record_builtin_type (const char *name, tree type);\n \n-/* Given a record type RECORD_TYPE and a chain of FIELD_DECL nodes FIELDLIST,\n+/* Given a record type RECORD_TYPE and a list of FIELD_DECL nodes FIELD_LIST,\n    finish constructing the record or union type.  If REP_LEVEL is zero, this\n    record has no representation clause and so will be entirely laid out here.\n    If REP_LEVEL is one, this record has a representation clause and has been\n    laid out already; only set the sizes and alignment.  If REP_LEVEL is two,\n    this record is derived from a parent record and thus inherits its layout;\n-   only make a pass on the fields to finalize them.  If DO_NOT_FINALIZE is\n-   true, the record type is expected to be modified afterwards so it will\n-   not be sent to the back-end for finalization.  */\n-extern void finish_record_type (tree record_type, tree fieldlist,\n-                                int rep_level, bool do_not_finalize);\n-\n-/* Wrap up compilation of RECORD_TYPE, i.e. most notably output all\n-   the debug information associated with it.  It need not be invoked\n-   directly in most cases since finish_record_type takes care of doing\n-   so, unless explicitly requested not to through DO_NOT_FINALIZE.  */\n+   only make a pass on the fields to finalize them.  DEBUG_INFO_P is true if\n+   we need to write debug information about this type.  */\n+extern void finish_record_type (tree record_type, tree field_list,\n+\t\t\t\tint rep_level, bool debug_info_p);\n+\n+/* Wrap up compilation of RECORD_TYPE, i.e. output all the debug information\n+   associated with it.  It need not be invoked directly in most cases since\n+   finish_record_type takes care of doing so, but this can be necessary if\n+   a parallel type is to be attached to the record type.  */\n extern void rest_of_record_type_compilation (tree record_type);\n \n /* Append PARALLEL_TYPE on the chain of parallel types for decl.  */"}, {"sha": "afdc20afd6dc5c5b229db77136f8fb9291f196e8", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=032d1b710a0f42d3c6254a728292056b0626b933", "patch": "@@ -562,7 +562,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n \t  null_list = tree_cons (field, null_node, null_list);\n \t}\n \n-      finish_record_type (fdesc_type_node, nreverse (field_list), 0, true);\n+      finish_record_type (fdesc_type_node, nreverse (field_list), 0, false);\n       record_builtin_type (\"descriptor\", fdesc_type_node);\n       null_fdesc_node = gnat_build_constructor (fdesc_type_node, null_list);\n     }"}, {"sha": "4d1cd97e9dc74850d7cf48551b2c4ff0d99d45de", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=032d1b710a0f42d3c6254a728292056b0626b933", "patch": "@@ -560,19 +560,18 @@ record_builtin_type (const char *name, tree type)\n     debug_hooks->type_decl (type_decl, false);\n }\n \f\n-/* Given a record type RECORD_TYPE and a chain of FIELD_DECL nodes FIELDLIST,\n+/* Given a record type RECORD_TYPE and a list of FIELD_DECL nodes FIELD_LIST,\n    finish constructing the record or union type.  If REP_LEVEL is zero, this\n    record has no representation clause and so will be entirely laid out here.\n    If REP_LEVEL is one, this record has a representation clause and has been\n    laid out already; only set the sizes and alignment.  If REP_LEVEL is two,\n    this record is derived from a parent record and thus inherits its layout;\n-   only make a pass on the fields to finalize them.  If DO_NOT_FINALIZE is\n-   true, the record type is expected to be modified afterwards so it will\n-   not be sent to the back-end for finalization.  */\n+   only make a pass on the fields to finalize them.  DEBUG_INFO_P is true if\n+   we need to write debug information about this type.  */\n \n void\n-finish_record_type (tree record_type, tree fieldlist, int rep_level,\n-\t\t    bool do_not_finalize)\n+finish_record_type (tree record_type, tree field_list, int rep_level,\n+\t\t    bool debug_info_p)\n {\n   enum tree_code code = TREE_CODE (record_type);\n   tree name = TYPE_NAME (record_type);\n@@ -583,7 +582,7 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n   bool had_align = TYPE_ALIGN (record_type) != 0;\n   tree field;\n \n-  TYPE_FIELDS (record_type) = fieldlist;\n+  TYPE_FIELDS (record_type) = field_list;\n \n   /* Always attach the TYPE_STUB_DECL for a record type.  It is required to\n      generate debug info and have a parallel type.  */\n@@ -627,9 +626,9 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n      handled yet, and adjust DECL_NONADDRESSABLE_P accordingly.  */\n \n   if (code == QUAL_UNION_TYPE)\n-    fieldlist = nreverse (fieldlist);\n+    field_list = nreverse (field_list);\n \n-  for (field = fieldlist; field; field = TREE_CHAIN (field))\n+  for (field = field_list; field; field = TREE_CHAIN (field))\n     {\n       tree type = TREE_TYPE (field);\n       tree pos = bit_position (field);\n@@ -733,7 +732,7 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n     }\n \n   if (code == QUAL_UNION_TYPE)\n-    nreverse (fieldlist);\n+    nreverse (field_list);\n \n   if (rep_level < 2)\n     {\n@@ -764,24 +763,24 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n \t}\n     }\n \n-  if (!do_not_finalize)\n+  if (debug_info_p)\n     rest_of_record_type_compilation (record_type);\n }\n \n-/* Wrap up compilation of RECORD_TYPE, i.e. most notably output all\n-   the debug information associated with it.  It need not be invoked\n-   directly in most cases since finish_record_type takes care of doing\n-   so, unless explicitly requested not to through DO_NOT_FINALIZE.  */\n+/* Wrap up compilation of RECORD_TYPE, i.e. output all the debug information\n+   associated with it.  It need not be invoked directly in most cases since\n+   finish_record_type takes care of doing so, but this can be necessary if\n+   a parallel type is to be attached to the record type.  */\n \n void\n rest_of_record_type_compilation (tree record_type)\n {\n-  tree fieldlist = TYPE_FIELDS (record_type);\n+  tree field_list = TYPE_FIELDS (record_type);\n   tree field;\n   enum tree_code code = TREE_CODE (record_type);\n   bool var_size = false;\n \n-  for (field = fieldlist; field; field = TREE_CHAIN (field))\n+  for (field = field_list; field; field = TREE_CHAIN (field))\n     {\n       /* We need to make an XVE/XVU record if any field has variable size,\n \t whether or not the record does.  For example, if we have a union,\n@@ -2801,7 +2800,7 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n     }\n \n   TYPE_NAME (record_type) = create_concat_name (gnat_entity, \"DESC\");\n-  finish_record_type (record_type, field_list, 0, true);\n+  finish_record_type (record_type, field_list, 0, false);\n   return record_type;\n }\n \n@@ -3115,7 +3114,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n     }\n \n   TYPE_NAME (record64_type) = create_concat_name (gnat_entity, \"DESC64\");\n-  finish_record_type (record64_type, field_list64, 0, true);\n+  finish_record_type (record64_type, field_list64, 0, false);\n   return record64_type;\n }\n \n@@ -3527,7 +3526,7 @@ build_unc_object_type (tree template_type, tree object_type, tree name)\n   finish_record_type (type,\n \t\t      chainon (chainon (NULL_TREE, template_field),\n \t\t\t       array_field),\n-\t\t      0, false);\n+\t\t      0, true);\n \n   return type;\n }"}, {"sha": "cbcbc16588e853e4a8e40d7a623c763af6b547ce", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032d1b710a0f42d3c6254a728292056b0626b933/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=032d1b710a0f42d3c6254a728292056b0626b933", "patch": "@@ -10428,6 +10428,10 @@ package body Sem_Util is\n                end loop;\n             end;\n \n+            if Ekind (T) = E_Class_Wide_Subtype then\n+               Set_Debug_Info_Needed_If_Not_Set (Equivalent_Type (T));\n+            end if;\n+\n          elsif Is_Array_Type (T) then\n             Set_Debug_Info_Needed_If_Not_Set (Component_Type (T));\n "}]}