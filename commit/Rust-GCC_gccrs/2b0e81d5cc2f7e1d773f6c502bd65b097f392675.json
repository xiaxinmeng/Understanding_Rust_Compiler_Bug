{"sha": "2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "node_id": "C_kwDOANBUbNoAKDJiMGU4MWQ1Y2MyZjdlMWQ3NzNmNmM1MDJiZDY1YjA5N2YzOTI2NzU", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-10-31T10:11:28Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-11-01T21:44:36Z"}, "message": "c++: per-scope, per-signature lambda discriminators\n\nThis implements ABI-compliant lambda discriminators.  Not only do we\nhave per-scope counters, but we also distinguish by lambda signature.\nOnly lambdas with the same signature will need non-zero\ndiscriminators.  As the discriminator is signature-dependent, we have\nto process the lambda function's declaration before we can determine\nit.  For templated and generic lambdas the signature is that of the\nuninstantiated lambda -- not separate for each instantiation.\n\nWith this change, gcc and clang now produce the same lambda manglings\nfor all these testcases.\n\n\tgcc/cp/\n\t* cp-tree.h (LAMBDA_EXPR_SCOPE_SIG_DISCRIMINATOR): New.\n\t(struct tree_lambda_expr): Add discriminator_sig bitfield.\n\t(recrd_lambda_scope_sig_discriminator): Declare.\n\t* lambda.cc (struct lambda_sig_count): New.\n\t(lambda_discriminator): Add signature vector.\n\t(start_lambda_scope): Adjust.\n\t(compare_lambda_template_head, compare_lambda_sig): New.\n\t(record_lambda_scope_sig_discriminator): New.\n\t* mangle.cc (write_closure_type): Use the scope-sig discriminator for\n\tABI >= 18.  Emit abi mangling warning if needed.\n\t* module.cc (trees_out::core_vals): Stream the new discriminator.\n\t(trees_in::core_vals): Likewise.\n\t* parser.cc (cp_parser_lambda_declarator_opt): Call\n\trecord_lambda_scope_sig_discriminator.\n\t* pt.cc (tsubst_lambda_expr): Likewise.\n\tlibcc1/\n\t* libcp1plugin.cc (plugin_start_lambda_closure_class_type):\n\tInitialize the per-scope, per-signature discriminator.\n\tgcc/testsuite/\n\t* g++.dg/abi/lambda-sig1-18.C: New.\n\t* g++.dg/abi/lambda-sig1-18vs17.C: New.\n\t* g++.dg/cpp1y/lambda-mangle-1-18.C: New.", "tree": {"sha": "56bc63afdde5a1c5b0aef088a4dafdcb200c08c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56bc63afdde5a1c5b0aef088a4dafdcb200c08c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f8aac77e05d0ae0b7f242fd1aa344d36ff52ceb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f8aac77e05d0ae0b7f242fd1aa344d36ff52ceb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f8aac77e05d0ae0b7f242fd1aa344d36ff52ceb"}], "stats": {"total": 268, "additions": 265, "deletions": 3}, "files": [{"sha": "d13bb3d4c0eb3d9a6918763946af4f774c3112d2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "patch": "@@ -1501,9 +1501,12 @@ enum cp_lambda_default_capture_mode_type {\n   (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->extra_scope)\n \n /* Lambdas in the same extra scope might need a discriminating count.\n-   This is a single per-scope count.  */\n+   For ABI 17, we have single per-scope count, for ABI 18, we have\n+   per-scope, per-signature numbering.  */\n #define LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR(NODE) \\\n   (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->discriminator_scope)\n+#define LAMBDA_EXPR_SCOPE_SIG_DISCRIMINATOR(NODE) \\\n+  (((struct tree_lambda_expr *)LAMBDA_EXPR_CHECK (NODE))->discriminator_sig)\n \n /* During parsing of the lambda, a vector of capture proxies which need\n    to be pushed once we're done processing a nested lambda.  */\n@@ -1533,6 +1536,7 @@ struct GTY (()) tree_lambda_expr\n   location_t locus;\n   enum cp_lambda_default_capture_mode_type default_capture_mode : 2;\n   unsigned discriminator_scope : 15; // Per-scope discriminator\n+  unsigned discriminator_sig : 15; // Per-scope, per-signature discriminator\n };\n \n /* Non-zero if this template specialization has access violations that\n@@ -7783,6 +7787,7 @@ extern void start_lambda_scope\t\t\t(tree decl);\n extern void finish_lambda_scope\t\t\t(void);\n extern void record_lambda_scope\t\t\t(tree lambda);\n extern void record_lambda_scope_discriminator\t(tree lambda);\n+extern void record_lambda_scope_sig_discriminator (tree lambda, tree fn);\n extern tree start_lambda_function\t\t(tree fn, tree lambda_expr);\n extern void finish_lambda_function\t\t(tree body);\n extern bool regenerated_lambda_fn_p\t\t(tree);"}, {"sha": "c7a9268251b4b78896bd610f3016675ca15d3c13", "filename": "gcc/cp/lambda.cc", "status": "modified", "additions": 147, "deletions": 1, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Flambda.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Flambda.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.cc?ref=2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "patch": "@@ -1447,13 +1447,21 @@ is_lambda_ignored_entity (tree val)\n /* Lambdas that appear in variable initializer or default argument\n    scope get that in their mangling, so we need to record it.  Also,\n    multiple lambdas in the same scope may need a mangling\n-   discriminator.  Record in the same data structure.  */\n+   discriminator.  In ABI <= 17, there is a single per-scope sequence\n+   number.  In ABI >= 18, there are per-scope per-signature sequence\n+   numbers.  */\n+struct GTY(()) lambda_sig_count\n+{\n+  tree fn; // The lambda fn whose sig this is.\n+  unsigned count;\n+};\n struct GTY(()) lambda_discriminator\n {\n   tree scope;\n   unsigned nesting; // Inside a function, VAR_DECLs get the function\n   \t\t    // as scope. This counts that nesting.\n   unsigned count;   // The per-scope counter.\n+  vec<lambda_sig_count, va_gc> *discriminators; // Per-signature counters\n };\n // The current scope.\n static GTY(()) lambda_discriminator lambda_scope;\n@@ -1475,6 +1483,7 @@ start_lambda_scope (tree decl)\n       lambda_scope.scope = decl;\n       lambda_scope.nesting = 0;\n       lambda_scope.count = 0;\n+      lambda_scope.discriminators = nullptr;\n     }\n }\n \n@@ -1504,6 +1513,116 @@ record_lambda_scope (tree lambda)\n     }\n }\n \n+// Compare lambda template heads TMPL_A and TMPL_B, used for both\n+// templated lambdas, and template template parameters of said lambda.\n+\n+static bool\n+compare_lambda_template_head (tree tmpl_a, tree tmpl_b)\n+{\n+  // We only need one level of template parms\n+  tree inner_a = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (tmpl_a));\n+  tree inner_b = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (tmpl_b));\n+\n+  // We only compare explicit template parms, ignoring trailing\n+  // synthetic ones.\n+  int len_a = TREE_VEC_LENGTH (inner_a);\n+  int len_b = TREE_VEC_LENGTH (inner_b);\n+  \n+  for (int ix = 0, len = MAX (len_a, len_b); ix != len; ix++)\n+    {\n+      tree parm_a = NULL_TREE;\n+      if (ix < len_a)\n+\t{\n+\t  parm_a = TREE_VEC_ELT (inner_a, ix);\n+\t  if (parm_a == error_mark_node)\n+\t    return false;\n+\t  parm_a = TREE_VALUE (parm_a);\n+\t  if (DECL_VIRTUAL_P (parm_a))\n+\t    parm_a = NULL_TREE;\n+\t}\n+      \n+      tree parm_b = NULL_TREE;\n+      if (ix < len_b)\n+\t{\n+\t  parm_b = TREE_VEC_ELT (inner_b, ix);\n+\t  if (parm_b == error_mark_node)\n+\t    return false;\n+\t  parm_b = TREE_VALUE (parm_b);\n+\t  if (DECL_VIRTUAL_P (parm_b))\n+\t    parm_b = NULL_TREE;\n+\t}\n+\n+      if (!parm_a && !parm_b)\n+\t// we're done\n+\tbreak;\n+\n+      if (!(parm_a && parm_b))\n+\treturn false;\n+\n+      if (TREE_CODE (parm_a) != TREE_CODE (parm_b))\n+\treturn false;\n+\n+      if (TREE_CODE (parm_a) == PARM_DECL)\n+\t{\n+\t  if (TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm_a))\n+\t      != TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm_b)))\n+\t    return false;\n+\n+\t  if (!same_type_p (TREE_TYPE (parm_a), TREE_TYPE (parm_b)))\n+\t    return false;\n+\t}\n+      else \n+\t{\n+\t  if (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (parm_a))\n+\t      != TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (parm_b)))\n+\t    return false;\n+\n+\t  if (TREE_CODE (parm_a) != TEMPLATE_DECL)\n+\t    gcc_checking_assert (TREE_CODE (parm_a) == TYPE_DECL);\n+\t  else if (!compare_lambda_template_head (parm_a, parm_b))\n+\t    return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+// Compare lambda signatures FN_A and FN_B, they may be TEMPLATE_DECLs too.\n+\n+static bool\n+compare_lambda_sig (tree fn_a, tree fn_b)\n+{\n+  if (TREE_CODE (fn_a) == TEMPLATE_DECL\n+      && TREE_CODE (fn_b) == TEMPLATE_DECL)\n+    {\n+      if (!compare_lambda_template_head (fn_a, fn_b))\n+\treturn false;\n+      fn_a = DECL_TEMPLATE_RESULT (fn_a);\n+      fn_b = DECL_TEMPLATE_RESULT (fn_b);\n+    }\n+  else if (TREE_CODE (fn_a) == TEMPLATE_DECL\n+\t   || TREE_CODE (fn_b) == TEMPLATE_DECL)\n+    return false;\n+\n+  if (fn_a == error_mark_node\n+      || fn_b == error_mark_node)\n+    return false;\n+\n+  for (tree args_a = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (fn_a))),\n+\t args_b = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (fn_b)));\n+       args_a || args_b;\n+       args_a = TREE_CHAIN (args_a), args_b = TREE_CHAIN (args_b))\n+    {\n+      if (!args_a || !args_b)\n+\treturn false;\n+      // This check also deals with differing varadicness\n+      if (!same_type_p (TREE_VALUE (args_a), TREE_VALUE (args_b)))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n // Record the per-scope discriminator of LAMBDA.  If the extra scope\n // is empty, we must use the empty scope counter, which might not be\n // the live one.\n@@ -1517,6 +1636,33 @@ record_lambda_scope_discriminator (tree lambda)\n   LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR (lambda) = slot->count++;\n }\n \n+// Record the per-scope per-signature discriminator of LAMBDA.  If the\n+// extra scope is empty, we must use the empty scope counter, which\n+// might not be the live one.\n+\n+void\n+record_lambda_scope_sig_discriminator (tree lambda, tree fn)\n+{\n+  auto *slot = (vec_safe_is_empty (lambda_scope_stack)\n+\t\t|| LAMBDA_EXPR_EXTRA_SCOPE (lambda)\n+\t\t? &lambda_scope : lambda_scope_stack->begin ());\n+  gcc_checking_assert (LAMBDA_EXPR_EXTRA_SCOPE (lambda) == slot->scope);\n+\n+  // A linear search, we're not expecting this to be a big list, and\n+  // this avoids needing a signature hash function.\n+  lambda_sig_count *sig;\n+  if (unsigned ix = vec_safe_length (slot->discriminators))\n+    for (sig = slot->discriminators->begin (); ix--; sig++)\n+      if (compare_lambda_sig (fn, sig->fn))\n+\tgoto found;\n+  {\n+    lambda_sig_count init = {fn, 0};\n+    sig = vec_safe_push (slot->discriminators, init);\n+  }\n+ found:\n+  LAMBDA_EXPR_SCOPE_SIG_DISCRIMINATOR (lambda) = sig->count++;\n+}\n+\n tree\n start_lambda_function (tree fco, tree lambda_expr)\n {"}, {"sha": "e97428e8f30a1249a55da11f3f2e972fa75f5513", "filename": "gcc/cp/mangle.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Fmangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Fmangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.cc?ref=2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "patch": "@@ -1810,7 +1810,13 @@ write_closure_type_name (const tree type)\n \n   write_method_parms (parms, /*method_p=*/1, fn);\n   write_char ('E');\n-  write_compact_number (LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR (lambda));\n+  if ((LAMBDA_EXPR_SCOPE_SIG_DISCRIMINATOR (lambda)\n+       != LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR (lambda))\n+      && abi_warn_or_compat_version_crosses (18))\n+    G.need_abi_warning = true;\n+  write_compact_number (abi_version_at_least (18)\n+\t\t\t? LAMBDA_EXPR_SCOPE_SIG_DISCRIMINATOR (lambda)\n+\t\t\t: LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR (lambda));\n }\n \n /* Convert NUMBER to ascii using base BASE and generating at least"}, {"sha": "0e9af318ba48e987b9617f7212775848aa3c44d7", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "patch": "@@ -6328,6 +6328,7 @@ trees_out::core_vals (tree t)\n \t{\n \t  WU (((lang_tree_node *)t)->lambda_expression.default_capture_mode);\n \t  WU (((lang_tree_node *)t)->lambda_expression.discriminator_scope);\n+\t  WU (((lang_tree_node *)t)->lambda_expression.discriminator_sig);\n \t}\n       break;\n \n@@ -6820,6 +6821,7 @@ trees_in::core_vals (tree t)\n       RUC (cp_lambda_default_capture_mode_type,\n \t   ((lang_tree_node *)t)->lambda_expression.default_capture_mode);\n       RU (((lang_tree_node *)t)->lambda_expression.discriminator_scope);\n+      RU (((lang_tree_node *)t)->lambda_expression.discriminator_sig);\n       break;\n \n     case OVERLOAD:"}, {"sha": "fd59de491cd9ccaf4ef71d43dea257385d64abd1", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "patch": "@@ -11712,6 +11712,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n       fco = finish_fully_implicit_template (parser, fco);\n \n     finish_member_declaration (fco);\n+    record_lambda_scope_sig_discriminator (lambda_expr, fco);\n \n     obstack_free (&declarator_obstack, p);\n "}, {"sha": "c3fc56a13ffc8bccb6965083cf243db2ad18a837", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "patch": "@@ -19912,6 +19912,7 @@ tsubst_lambda_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  goto out;\n \t}\n       finish_member_declaration (inst);\n+      record_lambda_scope_sig_discriminator (r, inst);\n \n       tree fn = oldtmpl ? DECL_TEMPLATE_RESULT (inst) : inst;\n "}, {"sha": "88692edaaef04bf0f4a30d9072ba0fa7fea86dd0", "filename": "gcc/testsuite/g++.dg/abi/lambda-sig1-18.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1-18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1-18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1-18.C?ref=2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile { target c++20 } }\n+// { dg-options -fabi-version=18 }\n+\n+#include \"lambda-sig1.h\"\n+\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlfE_clEf:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlfE0_clEf:} } }\n+\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlTyfT_E_clIiEEDafS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlTyfT_E0_clIiEEDafS1_:} } }\n+\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlTyT_E_clIiEEDaS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj0EE2FnEvENKUlTyT_E0_clIiEEDaS1_:} } }\n+\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlfE_clEf:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlfE0_clEf:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlfE1_clEf:} } }\n+\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlTyfT_E_clIiEEDafS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlTyfT_E0_clIiEEDafS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlTyfT_E1_clIiEEDafS1_:} } }\n+\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlTyT_E_clIiEEDaS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlTyT_E0_clIiEEDaS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIfLj1EE2FnEvENKUlTyT_E1_clIiEEDaS1_:} } }\n+\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUliE_clEi:} } }\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUliE0_clEi:} } }\n+\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUlTyiT_E_clIiEEDaiS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUlTyiT_E0_clIiEEDaiS1_:} } }\n+\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUlTyT_E_clIiEEDaS1_:} } }\n+// { dg-final { scan-assembler {_ZZN1XIiLj0EE2FnEvENKUlTyT_E0_clIiEEDaS1_:} } }"}, {"sha": "b191fb3ab0fc6f806eb2475164e1e7afe377c4ac", "filename": "gcc/testsuite/g++.dg/abi/lambda-sig1-18vs17.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1-18vs17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1-18vs17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Flambda-sig1-18vs17.C?ref=2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "patch": "@@ -0,0 +1,40 @@\n+// { dg-do compile { target c++20 } }\n+// { dg-options {-fabi-version=18 -Wabi=17} }\n+\n+#include \"lambda-sig1.h\"\n+\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlfT_E7_clIiEEDafS1_'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlTyfT_E1_clIiEEDafS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlT_E5_clIiEEDaS1_'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlTyT_E1_clIiEEDaS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlfE6_cvPFvfEEv'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlfE1_cvPFvfEEv'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENUlfE6_4_FUNEf'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENUlfE1_4_FUNEf'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlfE6_clEf'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlfE1_clEf'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlfT_E4_clIiEEDafS1_'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlTyfT_E0_clIiEEDafS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlT_E2_clIiEEDaS1_'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlTyT_E0_clIiEEDaS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlfE3_cvPFvfEEv'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlfE0_cvPFvfEEv'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENUlfE3_4_FUNEf'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENUlfE0_4_FUNEf'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlfE3_clEf'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlfE0_clEf'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlfT_E1_clIiEEDafS1_'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlTyfT_E_clIiEEDafS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlT_E_clIiEEDaS1_'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlTyT_E_clIiEEDaS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlfE0_cvPFvfEEv'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlfE_cvPFvfEEv'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENUlfE0_4_FUNEf'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENUlfE_4_FUNEf'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj1EE2FnEvENKUlfE0_clEf'\\) and '-fabi-version=18' \\('_ZZN1XIfLj1EE2FnEvENKUlfE_clEf'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj0EE2FnEvENKUlfT_E4_clIiEEDafS1_'\\) and '-fabi-version=18' \\('_ZZN1XIfLj0EE2FnEvENKUlTyfT_E0_clIiEEDafS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj0EE2FnEvENKUlT_E2_clIiEEDaS1_'\\) and '-fabi-version=18' \\('_ZZN1XIfLj0EE2FnEvENKUlTyT_E0_clIiEEDaS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj0EE2FnEvENKUlfE3_cvPFvfEEv'\\) and '-fabi-version=18' \\('_ZZN1XIfLj0EE2FnEvENKUlfE0_cvPFvfEEv'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj0EE2FnEvENUlfE3_4_FUNEf'\\) and '-fabi-version=18' \\('_ZZN1XIfLj0EE2FnEvENUlfE0_4_FUNEf'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj0EE2FnEvENKUlfE3_clEf'\\) and '-fabi-version=18' \\('_ZZN1XIfLj0EE2FnEvENKUlfE0_clEf'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj0EE2FnEvENKUlfT_E1_clIiEEDafS1_'\\) and '-fabi-version=18' \\('_ZZN1XIfLj0EE2FnEvENKUlTyfT_E_clIiEEDafS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj0EE2FnEvENKUlT_E_clIiEEDaS1_'\\) and '-fabi-version=18' \\('_ZZN1XIfLj0EE2FnEvENKUlTyT_E_clIiEEDaS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj0EE2FnEvENKUlfE0_cvPFvfEEv'\\) and '-fabi-version=18' \\('_ZZN1XIfLj0EE2FnEvENKUlfE_cvPFvfEEv'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj0EE2FnEvENUlfE0_4_FUNEf'\\) and '-fabi-version=18' \\('_ZZN1XIfLj0EE2FnEvENUlfE_4_FUNEf'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIfLj0EE2FnEvENKUlfE0_clEf'\\) and '-fabi-version=18' \\('_ZZN1XIfLj0EE2FnEvENKUlfE_clEf'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIiLj0EE2FnEvENKUliT_E4_clIiEEDaiS1_'\\) and '-fabi-version=18' \\('_ZZN1XIiLj0EE2FnEvENKUlTyiT_E0_clIiEEDaiS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIiLj0EE2FnEvENKUlT_E2_clIiEEDaS1_'\\) and '-fabi-version=18' \\('_ZZN1XIiLj0EE2FnEvENKUlTyT_E0_clIiEEDaS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIiLj0EE2FnEvENKUliE3_cvPFviEEv'\\) and '-fabi-version=18' \\('_ZZN1XIiLj0EE2FnEvENKUliE0_cvPFviEEv'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIiLj0EE2FnEvENUliE3_4_FUNEi'\\) and '-fabi-version=18' \\('_ZZN1XIiLj0EE2FnEvENUliE0_4_FUNEi'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIiLj0EE2FnEvENKUliE3_clEi'\\) and '-fabi-version=18' \\('_ZZN1XIiLj0EE2FnEvENKUliE0_clEi'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIiLj0EE2FnEvENKUliT_E1_clIiEEDaiS1_'\\) and '-fabi-version=18' \\('_ZZN1XIiLj0EE2FnEvENKUlTyiT_E_clIiEEDaiS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIiLj0EE2FnEvENKUlT_E_clIiEEDaS1_'\\) and '-fabi-version=18' \\('_ZZN1XIiLj0EE2FnEvENKUlTyT_E_clIiEEDaS1_'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIiLj0EE2FnEvENKUliE0_cvPFviEEv'\\) and '-fabi-version=18' \\('_ZZN1XIiLj0EE2FnEvENKUliE_cvPFviEEv'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIiLj0EE2FnEvENUliE0_4_FUNEi'\\) and '-fabi-version=18' \\('_ZZN1XIiLj0EE2FnEvENUliE_4_FUNEi'\\) [^\\n]*\\n} }\n+// { dg-regexp {[^\\n]*lambda-sig1.h:[:0-9]* warning: the mangled name [^\\n]* \\('_ZZN1XIiLj0EE2FnEvENKUliE0_clEi'\\) and '-fabi-version=18' \\('_ZZN1XIiLj0EE2FnEvENKUliE_clEi'\\) [^\\n]*\\n} }"}, {"sha": "22ad15ea33cfe53ea9e9a67027cda22dd114ab2f", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1-18.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1-18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1-18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-mangle-1-18.C?ref=2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target c++14 } }\n+// { dg-additional-options -fabi-version=18 }\n+\n+// PRs 78621\n+\n+#include \"lambda-mangle-1.h\"\n+\n+// We erroneously mangled lambda auto parms as-if template parameters (T<n>_),\n+// rather than auto (Da). Fixed in abi version 11\n+\n+// ABI 18 uses per-scope per-signature lambda discriminator\n+\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRT_E_EOS0_S1_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRiRT_E_EOS1_S2_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlRT_R1XIiEE_EOS0_S1_:\" } }\n+// { dg-final { scan-assembler \"_Z7forwardIZ3FoovEUlPA5_T_E_EOS0_RS0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRT_E_EvS1_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRiRT_E_EvS2_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlRT_R1XIiEE_EvS1_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlPA5_T_E_EvRS0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3FoovEUlPfS1_E_EvRT_RT0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3FoovEUlPT_PT0_E_EvRS1_RS3_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIZ3FoovEUlPT_PT0_E_Z3FoovEUlS1_S3_E0_EvRS0_RS2_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsPfS3_E_EvRT_RT0_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsPT_PT0_E_EvRS3_RS5_:\" } }\n+// { dg-final { scan-assembler \"_Z3eatIPiZ3BarIsEvvEUlPsDpPT_E_EvRT_RT0_:\" } }"}, {"sha": "e232aaceef97a7d8f8da056ed60245b682d57678", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0e81d5cc2f7e1d773f6c502bd65b097f392675/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=2b0e81d5cc2f7e1d773f6c502bd65b097f392675", "patch": "@@ -1656,6 +1656,7 @@ plugin_start_closure_class_type (cc1_plugin::connection *self,\n   /* Instead of calling record_lambda_scope, do this:  */\n   LAMBDA_EXPR_EXTRA_SCOPE (lambda_expr) = extra_scope;\n   LAMBDA_EXPR_SCOPE_ONLY_DISCRIMINATOR (lambda_expr) = discriminator;\n+  LAMBDA_EXPR_SCOPE_SIG_DISCRIMINATOR (lambda_expr) = discriminator;\n \n   tree decl = TYPE_NAME (type);\n   determine_visibility (decl);"}]}