{"sha": "9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI3OWI1YmE0NTM4ZGE4MDQxZjA3NGRiM2Y1ZmNkOWU4ZWNmZjkzZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2020-01-02T21:51:07Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2020-01-02T21:51:07Z"}, "message": "compiler: split writing of equal and hash functions for types\n    \n    Separate the generation of type equality and hash functions, rather\n    than doing them in a single operation.\n    \n    This is almost entirely a pure refactoring in preparation for\n    generating hash functions only for types that are map keys.  The only\n    change in generated code is that for types that are the size of\n    numeric types, but not aligned like numeric types, such as [8]byte,\n    now use standard hash functions.  They previously used special-purpose\n    hash functions because they required special-purpose equal functions.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/212842\n\nFrom-SVN: r279847", "tree": {"sha": "5791199f9234d308eaee94877178b863d50880c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5791199f9234d308eaee94877178b863d50880c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/comments", "author": null, "committer": null, "parents": [{"sha": "45b6395b202b637cae76c73dce846e5eb1954870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b6395b202b637cae76c73dce846e5eb1954870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45b6395b202b637cae76c73dce846e5eb1954870"}], "stats": {"total": 906, "additions": 545, "deletions": 361}, "files": [{"sha": "5e00d4f79b1c300b049d9019a4637a0da7dc3100", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "patch": "@@ -1,4 +1,4 @@\n-393957c8b68e370504209eb901aa0c3874e256d4\n+b5c950fb98042fe434edca0c2403234692f25cd4\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ecb28e0594057ea3c042dd174ab580386f27d03c", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "patch": "@@ -6238,10 +6238,8 @@ Binary_expression::lower_array_comparison(Gogo* gogo,\n     return this->lower_compare_to_memcmp(gogo, inserter);\n \n   // Call the array comparison function.\n-  Named_object* hash_fn;\n-  Named_object* equal_fn;\n-  at->type_functions(gogo, this->left_->type()->named_type(), NULL, NULL,\n-\t\t     &hash_fn, &equal_fn);\n+  Named_object* equal_fn =\n+    at->equal_function(gogo, this->left_->type()->named_type(), NULL);\n \n   Location loc = this->location();\n "}, {"sha": "db533bbd321cf4474ad6f409f482812b7a61f268", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "patch": "@@ -2717,23 +2717,40 @@ Gogo::clear_file_scope()\n   this->current_file_imported_unsafe_ = false;\n }\n \n-// Queue up a type specific function for later writing.  These are\n-// written out in write_specific_type_functions, called after the\n+// Queue up a type-specific hash function for later writing.  These\n+// are written out in write_specific_type_functions, called after the\n // parse tree is lowered.\n \n void\n-Gogo::queue_specific_type_function(Type* type, Named_type* name, int64_t size,\n-\t\t\t\t   const std::string& hash_name,\n-\t\t\t\t   Function_type* hash_fntype,\n-\t\t\t\t   const std::string& equal_name,\n-\t\t\t\t   Function_type* equal_fntype)\n+Gogo::queue_hash_function(Type* type, Named_type* name, int64_t size,\n+\t\t\t  const std::string& hash_name,\n+\t\t\t  Function_type* hash_fntype)\n {\n   go_assert(!this->specific_type_functions_are_written_);\n   go_assert(!this->in_global_scope());\n+  Specific_type_function::Specific_type_function_kind kind =\n+    Specific_type_function::SPECIFIC_HASH;\n   Specific_type_function* tsf = new Specific_type_function(type, name, size,\n-\t\t\t\t\t\t\t   hash_name,\n-\t\t\t\t\t\t\t   hash_fntype,\n-\t\t\t\t\t\t\t   equal_name,\n+\t\t\t\t\t\t\t   kind, hash_name,\n+\t\t\t\t\t\t\t   hash_fntype);\n+  this->specific_type_functions_.push_back(tsf);\n+}\n+\n+// Queue up a type-specific equal function for later writing.  These\n+// are written out in write_specific_type_functions, called after the\n+// parse tree is lowered.\n+\n+void\n+Gogo::queue_equal_function(Type* type, Named_type* name, int64_t size,\n+\t\t\t   const std::string& equal_name,\n+\t\t\t   Function_type* equal_fntype)\n+{\n+  go_assert(!this->specific_type_functions_are_written_);\n+  go_assert(!this->in_global_scope());\n+  Specific_type_function::Specific_type_function_kind kind =\n+    Specific_type_function::SPECIFIC_EQUAL;\n+  Specific_type_function* tsf = new Specific_type_function(type, name, size,\n+\t\t\t\t\t\t\t   kind, equal_name,\n \t\t\t\t\t\t\t   equal_fntype);\n   this->specific_type_functions_.push_back(tsf);\n }\n@@ -2758,8 +2775,6 @@ class Specific_type_functions : public Traverse\n int\n Specific_type_functions::type(Type* t)\n {\n-  Named_object* hash_fn;\n-  Named_object* equal_fn;\n   switch (t->classification())\n     {\n     case Type::TYPE_NAMED:\n@@ -2768,7 +2783,10 @@ Specific_type_functions::type(Type* t)\n \tif (nt->is_alias())\n \t  return TRAVERSE_CONTINUE;\n \tif (t->needs_specific_type_functions(this->gogo_))\n-\t  t->type_functions(this->gogo_, nt, NULL, NULL, &hash_fn, &equal_fn);\n+\t  {\n+\t    t->equal_function(this->gogo_, nt, NULL);\n+\t    t->hash_function(this->gogo_, nt, NULL);\n+\t  }\n \n \t// If this is a struct type, we don't want to make functions\n \t// for the unnamed struct.\n@@ -2802,7 +2820,10 @@ Specific_type_functions::type(Type* t)\n     case Type::TYPE_STRUCT:\n     case Type::TYPE_ARRAY:\n       if (t->needs_specific_type_functions(this->gogo_))\n-\tt->type_functions(this->gogo_, NULL, NULL, NULL, &hash_fn, &equal_fn);\n+\t{\n+\t  t->equal_function(this->gogo_, NULL, NULL);\n+\t  t->hash_function(this->gogo_, NULL, NULL);\n+\t}\n       break;\n \n     default:\n@@ -2824,11 +2845,12 @@ Gogo::write_specific_type_functions()\n     {\n       Specific_type_function* tsf = this->specific_type_functions_.back();\n       this->specific_type_functions_.pop_back();\n-      tsf->type->write_specific_type_functions(this, tsf->name, tsf->size,\n-\t\t\t\t\t       tsf->hash_name,\n-\t\t\t\t\t       tsf->hash_fntype,\n-\t\t\t\t\t       tsf->equal_name,\n-\t\t\t\t\t       tsf->equal_fntype);\n+      if (tsf->kind == Specific_type_function::SPECIFIC_HASH)\n+\ttsf->type->write_hash_function(this, tsf->name, tsf->size,\n+\t\t\t\t       tsf->fnname, tsf->fntype);\n+      else\n+\ttsf->type->write_equal_function(this, tsf->name, tsf->size,\n+\t\t\t\t\ttsf->fnname, tsf->fntype);\n       delete tsf;\n     }\n   this->specific_type_functions_are_written_ = true;"}, {"sha": "cd4e38f4b95c54513e28c881974f28e616c1f62d", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "patch": "@@ -598,15 +598,21 @@ class Gogo\n     return p != this->var_deps_.end() ? p->second : NULL;\n   }\n \n-  // Queue up a type-specific function to be written out.  This is\n-  // used when a type-specific function is needed when not at the top\n-  // level.\n+  // Queue up a type-specific hash function to be written out.  This\n+  // is used when a type-specific hash function is needed when not at\n+  // top level.\n   void\n-  queue_specific_type_function(Type* type, Named_type* name, int64_t size,\n-\t\t\t       const std::string& hash_name,\n-\t\t\t       Function_type* hash_fntype,\n-\t\t\t       const std::string& equal_name,\n-\t\t\t       Function_type* equal_fntype);\n+  queue_hash_function(Type* type, Named_type* name, int64_t size,\n+\t\t      const std::string& hash_name,\n+\t\t      Function_type* hash_fntype);\n+\n+  // Queue up a type-specific equal function to be written out.  This\n+  // is used when a type-specific equal function is needed when not at\n+  // top level.\n+  void\n+  queue_equal_function(Type* type, Named_type* name, int64_t size,\n+\t\t       const std::string& equal_name,\n+\t\t       Function_type* equal_fntype);\n \n   // Write out queued specific type functions.\n   void\n@@ -871,11 +877,13 @@ class Gogo\n   std::string\n   stub_method_name(const Package*, const std::string& method_name);\n \n-  // Return the names of the hash and equality functions for TYPE.\n-  void\n-  specific_type_function_names(const Type*, const Named_type*,\n-\t\t\t       std::string* hash_name,\n-\t\t\t       std::string* equal_name);\n+  // Return the name of the hash function for TYPE.\n+  std::string\n+  hash_function_name(const Type*, const Named_type*);\n+\n+  // Return the name of the equal function for TYPE.\n+  std::string\n+  equal_function_name(const Type*, const Named_type*);\n \n   // Return the assembler name to use for a global variable.\n   std::string\n@@ -1059,22 +1067,21 @@ class Gogo\n   // Type used to queue writing a type specific function.\n   struct Specific_type_function\n   {\n+    enum Specific_type_function_kind { SPECIFIC_HASH, SPECIFIC_EQUAL };\n+\n     Type* type;\n     Named_type* name;\n     int64_t size;\n-    std::string hash_name;\n-    Function_type* hash_fntype;\n-    std::string equal_name;\n-    Function_type* equal_fntype;\n+    Specific_type_function_kind kind;\n+    std::string fnname;\n+    Function_type* fntype;\n \n     Specific_type_function(Type* atype, Named_type* aname, int64_t asize,\n-\t\t\t   const std::string& ahash_name,\n-\t\t\t   Function_type* ahash_fntype,\n-\t\t\t   const std::string& aequal_name,\n-\t\t\t   Function_type* aequal_fntype)\n-      : type(atype), name(aname), size(asize), hash_name(ahash_name),\n-\thash_fntype(ahash_fntype), equal_name(aequal_name),\n-\tequal_fntype(aequal_fntype)\n+\t\t\t   Specific_type_function_kind akind,\n+\t\t\t   const std::string afnname,\n+\t\t\t   Function_type* afntype)\n+      : type(atype), name(aname), size(asize), kind(akind),\n+\tfnname(afnname), fntype(afntype)\n     { }\n   };\n "}, {"sha": "959415a765527998575bb991a2c06b89929aef95", "filename": "gcc/go/gofrontend/names.cc", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fnames.cc?ref=9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "patch": "@@ -287,21 +287,30 @@ Gogo::stub_method_name(const Package* package, const std::string& mname)\n   return ret;\n }\n \n-// Return the names of the hash and equality functions for TYPE.  If\n-// NAME is not NULL it is the name of the type.  Set *HASH_NAME and\n-// *EQUAL_NAME.\n+// Return the name of the hash function for TYPE.  If NAME is not NULL\n+// it is the name of the type.\n \n-void\n-Gogo::specific_type_function_names(const Type* type, const Named_type* name,\n-\t\t\t\t   std::string *hash_name,\n-\t\t\t\t   std::string *equal_name)\n+std::string\n+Gogo::hash_function_name(const Type* type, const Named_type* name)\n+{\n+  const Type* rtype = type;\n+  if (name != NULL)\n+    rtype = name;\n+  std::string tname = rtype->mangled_name(this);\n+  return tname + \"..hash\";\n+}\n+\n+// Return the name of the equal function for TYPE.  If NAME is not\n+// NULL it is the name of the type.\n+\n+std::string\n+Gogo::equal_function_name(const Type* type, const Named_type* name)\n {\n   const Type* rtype = type;\n   if (name != NULL)\n     rtype = name;\n   std::string tname = rtype->mangled_name(this);\n-  *hash_name = tname + \"..hash\";\n-  *equal_name = tname + \"..eq\";\n+  return tname + \"..eq\";\n }\n \n // Return the assembler name to use for a global variable.  GO_NAME is"}, {"sha": "1004040e04ebd2117156ff58e114876b34d244d4", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 416, "deletions": 277, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "patch": "@@ -1722,7 +1722,7 @@ Type::needs_specific_type_functions(Gogo* gogo)\n       go_assert(saw_errors());\n       return false;\n     }\n-  // This switch matches the one in Type::type_functions.\n+  // This switch matches the one in Type::equal_function.\n   switch (size)\n     {\n     case 0:\n@@ -1740,139 +1740,70 @@ Type::needs_specific_type_functions(Gogo* gogo)\n     }\n }\n \n-// Set *HASH_FN and *EQUAL_FN to the runtime functions which compute a\n-// hash code for this type and which compare whether two values of\n-// this type are equal.  If NAME is not NULL it is the name of this\n-// type.  HASH_FNTYPE and EQUAL_FNTYPE are the types of these\n-// functions, for convenience; they may be NULL.\n+// Return the runtime function that computes the hash of this type.\n+// If NAME is not NULL it is the name of this type.  HASH_FNTYPE is\n+// the type of the hash function function, for convenience; it may be\n+// NULL.  This returns NULL if the type is not comparable.\n \n-void\n-Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n-\t\t     Function_type* equal_fntype, Named_object** hash_fn,\n-\t\t     Named_object** equal_fn)\n+Named_object*\n+Type::hash_function(Gogo* gogo, Named_type* name, Function_type* hash_fntype)\n {\n   // If the unaliased type is not a named type, then the type does not\n   // have a name after all.\n   if (name != NULL)\n     name = name->unalias()->named_type();\n \n   if (!this->is_comparable())\n-    {\n-      *hash_fn = NULL;\n-      *equal_fn = NULL;\n-      return;\n-    }\n+    return NULL;\n \n-  if (hash_fntype == NULL || equal_fntype == NULL)\n+  if (hash_fntype == NULL)\n     {\n       Location bloc = Linemap::predeclared_location();\n-\n       Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n       Type* void_type = Type::make_void_type();\n       Type* unsafe_pointer_type = Type::make_pointer_type(void_type);\n-\n-      if (hash_fntype == NULL)\n-\t{\n-\t  Typed_identifier_list* params = new Typed_identifier_list();\n-\t  params->push_back(Typed_identifier(\"key\", unsafe_pointer_type,\n-\t\t\t\t\t     bloc));\n-\t  params->push_back(Typed_identifier(\"seed\", uintptr_type, bloc));\n-\n-\t  Typed_identifier_list* results = new Typed_identifier_list();\n-\t  results->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n-\n-\t  hash_fntype = Type::make_function_type(NULL, params, results, bloc);\n-\t}\n-      if (equal_fntype == NULL)\n-\t{\n-\t  Typed_identifier_list* params = new Typed_identifier_list();\n-\t  params->push_back(Typed_identifier(\"key1\", unsafe_pointer_type,\n-\t\t\t\t\t     bloc));\n-\t  params->push_back(Typed_identifier(\"key2\", unsafe_pointer_type,\n-\t\t\t\t\t     bloc));\n-\n-\t  Typed_identifier_list* results = new Typed_identifier_list();\n-\t  results->push_back(Typed_identifier(\"\", Type::lookup_bool_type(),\n-\t\t\t\t\t      bloc));\n-\n-\t  equal_fntype = Type::make_function_type(NULL, params, results, bloc);\n-\t}\n+      Typed_identifier_list* params = new Typed_identifier_list();\n+      params->push_back(Typed_identifier(\"key\", unsafe_pointer_type, bloc));\n+      params->push_back(Typed_identifier(\"seed\", uintptr_type, bloc));\n+      Typed_identifier_list* results = new Typed_identifier_list();\n+      results->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n+      hash_fntype = Type::make_function_type(NULL, params, results, bloc);\n     }\n \n   const char* hash_fnname;\n-  const char* equal_fnname;\n   if (this->compare_is_identity(gogo))\n     {\n-      int64_t size, align;\n-      if (!this->backend_type_size(gogo, &size)\n-\t  || !this->backend_type_align(gogo, &align))\n+      int64_t size;\n+      if (!this->backend_type_size(gogo, &size))\n \t{\n \t  go_assert(saw_errors());\n-\t  return;\n+\t  return NULL;\n \t}\n-      bool build_functions = false;\n-      // This switch matches the one in Type::needs_specific_type_functions.\n-      // The alignment tests are because of the memequal functions,\n-      // which assume that the values are aligned as required for an\n-      // integer of that size.\n       switch (size)\n \t{\n \tcase 0:\n \t  hash_fnname = \"runtime.memhash0\";\n-\t  equal_fnname = \"runtime.memequal0\";\n \t  break;\n \tcase 1:\n \t  hash_fnname = \"runtime.memhash8\";\n-\t  equal_fnname = \"runtime.memequal8\";\n \t  break;\n \tcase 2:\n-\t  if (align < Type::memequal_align(gogo, 16))\n-\t    build_functions = true;\n-\t  else\n-\t    {\n-\t      hash_fnname = \"runtime.memhash16\";\n-\t      equal_fnname = \"runtime.memequal16\";\n-\t    }\n+\t  hash_fnname = \"runtime.memhash16\";\n \t  break;\n \tcase 4:\n-\t  if (align < Type::memequal_align(gogo, 32))\n-\t    build_functions = true;\n-\t  else\n-\t    {\n-\t      hash_fnname = \"runtime.memhash32\";\n-\t      equal_fnname = \"runtime.memequal32\";\n-\t    }\n+\t  hash_fnname = \"runtime.memhash32\";\n \t  break;\n \tcase 8:\n-\t  if (align < Type::memequal_align(gogo, 64))\n-\t    build_functions = true;\n-\t  else\n-\t    {\n-\t      hash_fnname = \"runtime.memhash64\";\n-\t      equal_fnname = \"runtime.memequal64\";\n-\t    }\n+\t  hash_fnname = \"runtime.memhash64\";\n \t  break;\n \tcase 16:\n-\t  if (align < Type::memequal_align(gogo, 128))\n-\t    build_functions = true;\n-\t  else\n-\t    {\n-\t      hash_fnname = \"runtime.memhash128\";\n-\t      equal_fnname = \"runtime.memequal128\";\n-\t    }\n+\t  hash_fnname = \"runtime.memhash128\";\n \t  break;\n \tdefault:\n-\t  build_functions = true;\n-\t  break;\n-\t}\n-      if (build_functions)\n-\t{\n-\t  // We don't have a built-in function for a type of this size\n-\t  // and alignment.  Build a function to use that calls the\n-\t  // generic hash/equality functions for identity, passing the size.\n-\t  this->specific_type_functions(gogo, name, size, hash_fntype,\n-\t\t\t\t\tequal_fntype, hash_fn, equal_fn);\n-\t  return;\n+\t  // We don't have a built-in function for a type of this\n+\t  // size.  Build a function to use that calls the generic\n+\t  // hash functions for identity, passing the size.\n+\t  return this->build_hash_function(gogo, name, size, hash_fntype);\n \t}\n     }\n   else\n@@ -1899,11 +1830,9 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \t    {\n \t    case 32:\n \t      hash_fnname = \"runtime.f32hash\";\n-\t      equal_fnname = \"runtime.f32equal\";\n \t      break;\n \t    case 64:\n \t      hash_fnname = \"runtime.f64hash\";\n-\t      equal_fnname = \"runtime.f64equal\";\n \t      break;\n \t    default:\n \t      go_unreachable();\n@@ -1915,11 +1844,9 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \t    {\n \t    case 64:\n \t      hash_fnname = \"runtime.c64hash\";\n-\t      equal_fnname = \"runtime.c64equal\";\n \t      break;\n \t    case 128:\n \t      hash_fnname = \"runtime.c128hash\";\n-\t      equal_fnname = \"runtime.c128equal\";\n \t      break;\n \t    default:\n \t      go_unreachable();\n@@ -1928,18 +1855,13 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \n \tcase Type::TYPE_STRING:\n \t  hash_fnname = \"runtime.strhash\";\n-\t  equal_fnname = \"runtime.strequal\";\n \t  break;\n \n \tcase Type::TYPE_STRUCT:\n-\t  {\n-\t    // This is a struct which can not be compared using a\n-\t    // simple identity function.  We need to build a function\n-\t    // for comparison.\n-\t    this->specific_type_functions(gogo, name, -1, hash_fntype,\n-\t\t\t\t\t  equal_fntype, hash_fn, equal_fn);\n-\t    return;\n-\t  }\n+\t  // This is a struct which can not be compared using a simple\n+\t  // identity function.  We need to build a function to\n+\t  // compute the hash.\n+\t  return this->build_hash_function(gogo, name, -1, hash_fntype);\n \n \tcase Type::TYPE_ARRAY:\n \t  if (this->is_slice_type())\n@@ -1952,24 +1874,16 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \t    {\n \t      // This is an array which can not be compared using a\n \t      // simple identity function.  We need to build a\n-\t      // function for comparison.\n-\t      this->specific_type_functions(gogo, name, -1, hash_fntype,\n-\t\t\t\t\t    equal_fntype, hash_fn, equal_fn);\n-\t      return;\n+\t      // function to compute the hash.\n+\t      return this->build_hash_function(gogo, name, -1, hash_fntype);\n \t    }\n \t  break;\n \n \tcase Type::TYPE_INTERFACE:\n \t  if (this->interface_type()->is_empty())\n-\t    {\n-\t      hash_fnname = \"runtime.nilinterhash\";\n-\t      equal_fnname = \"runtime.nilinterequal\";\n-\t    }\n+\t    hash_fnname = \"runtime.nilinterhash\";\n \t  else\n-\t    {\n-\t      hash_fnname = \"runtime.interhash\";\n-\t      equal_fnname = \"runtime.interequal\";\n-\t    }\n+\t    hash_fnname = \"runtime.interhash\";\n \t  break;\n \n \tcase Type::TYPE_NAMED:\n@@ -1983,90 +1897,70 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \n \n   Location bloc = Linemap::predeclared_location();\n-  *hash_fn = Named_object::make_function_declaration(hash_fnname, NULL,\n-\t\t\t\t\t\t     hash_fntype, bloc);\n-  (*hash_fn)->func_declaration_value()->set_asm_name(hash_fnname);\n-  *equal_fn = Named_object::make_function_declaration(equal_fnname, NULL,\n-\t\t\t\t\t\t      equal_fntype, bloc);\n-  (*equal_fn)->func_declaration_value()->set_asm_name(equal_fnname);\n+  Named_object *hash_fn = Named_object::make_function_declaration(hash_fnname,\n+\t\t\t\t\t\t\t\t  NULL,\n+\t\t\t\t\t\t\t\t  hash_fntype,\n+\t\t\t\t\t\t\t\t  bloc);\n+  hash_fn->func_declaration_value()->set_asm_name(hash_fnname);\n+  return hash_fn;\n }\n \n // A hash table mapping types to the specific hash functions.\n \n-Type::Type_functions Type::type_functions_table;\n+Type::Type_function Type::type_hash_functions_table;\n \n-// Handle a type function which is specific to a type: if SIZE == -1,\n-// this is a struct or array that can not use an identity comparison.\n-// Otherwise, it is a type that uses an identity comparison but is not\n-// one of the standard supported sizes.\n+// Build a hash function that is specific to a type: if SIZE == -1,\n+// this is a struct or array type that cannot use an identity\n+// comparison.  Otherwise, it is a type that uses an identity\n+// comparison but is not one of the standard supported sizes.\n \n-void\n-Type::specific_type_functions(Gogo* gogo, Named_type* name, int64_t size,\n-\t\t\t      Function_type* hash_fntype,\n-\t\t\t      Function_type* equal_fntype,\n-\t\t\t      Named_object** hash_fn,\n-\t\t\t      Named_object** equal_fn)\n-{\n-  Hash_equal_fn fnull(NULL, NULL);\n-  std::pair<Type*, Hash_equal_fn> val(name != NULL ? name : this, fnull);\n-  std::pair<Type_functions::iterator, bool> ins =\n-    Type::type_functions_table.insert(val);\n+Named_object*\n+Type::build_hash_function(Gogo* gogo, Named_type* name, int64_t size,\n+\t\t\t  Function_type* hash_fntype)\n+{\n+  std::pair<Type*, Named_object*> val(name != NULL ? name : this, NULL);\n+  std::pair<Type_function::iterator, bool> ins =\n+    Type::type_hash_functions_table.insert(val);\n   if (!ins.second)\n     {\n-      // We already have functions for this type\n-      *hash_fn = ins.first->second.first;\n-      *equal_fn = ins.first->second.second;\n-      return;\n+      // We already have a function for this type.\n+      return ins.first->second;\n     }\n \n-  std::string hash_name;\n-  std::string equal_name;\n-  gogo->specific_type_function_names(this, name, &hash_name, &equal_name);\n+  std::string hash_name = gogo->hash_function_name(this, name);\n \n   Location bloc = Linemap::predeclared_location();\n \n   const Package* package = NULL;\n   bool is_defined_elsewhere =\n     this->type_descriptor_defined_elsewhere(name, &package);\n+\n+  Named_object* hash_fn;\n   if (is_defined_elsewhere)\n-    {\n-      *hash_fn = Named_object::make_function_declaration(hash_name, package,\n-\t\t\t\t\t\t\t hash_fntype, bloc);\n-      *equal_fn = Named_object::make_function_declaration(equal_name, package,\n-\t\t\t\t\t\t\t  equal_fntype, bloc);\n-    }\n+    hash_fn = Named_object::make_function_declaration(hash_name, package,\n+\t\t\t\t\t\t      hash_fntype, bloc);\n   else\n-    {\n-      *hash_fn = gogo->declare_package_function(hash_name, hash_fntype, bloc);\n-      *equal_fn = gogo->declare_package_function(equal_name, equal_fntype,\n-\t\t\t\t\t\t bloc);\n-    }\n+    hash_fn = gogo->declare_package_function(hash_name, hash_fntype, bloc);\n \n-  ins.first->second.first = *hash_fn;\n-  ins.first->second.second = *equal_fn;\n+  ins.first->second = hash_fn;\n \n   if (!is_defined_elsewhere)\n     {\n       if (gogo->in_global_scope())\n-\tthis->write_specific_type_functions(gogo, name, size, hash_name,\n-\t\t\t\t\t    hash_fntype, equal_name,\n-\t\t\t\t\t    equal_fntype);\n+\tthis->write_hash_function(gogo, name, size, hash_name, hash_fntype);\n       else\n-\tgogo->queue_specific_type_function(this, name, size, hash_name,\n-\t\t\t\t\t   hash_fntype, equal_name,\n-\t\t\t\t\t   equal_fntype);\n+\tgogo->queue_hash_function(this, name, size, hash_name, hash_fntype);\n     }\n+\n+  return hash_fn;\n }\n \n-// Write the hash and equality functions for a type which needs to be\n-// written specially.\n+// Write the hash function for a type that needs it written specially.\n \n void\n-Type::write_specific_type_functions(Gogo* gogo, Named_type* name, int64_t size,\n-\t\t\t\t    const std::string& hash_name,\n-\t\t\t\t    Function_type* hash_fntype,\n-\t\t\t\t    const std::string& equal_name,\n-\t\t\t\t    Function_type* equal_fntype)\n+Type::write_hash_function(Gogo* gogo, Named_type* name, int64_t size,\n+\t\t\t  const std::string& hash_name,\n+\t\t\t  Function_type* hash_fntype)\n {\n   Location bloc = Linemap::predeclared_location();\n \n@@ -2086,13 +1980,11 @@ Type::write_specific_type_functions(Gogo* gogo, Named_type* name, int64_t size,\n   if (size != -1)\n     this->write_identity_hash(gogo, size);\n   else if (name != NULL && name->real_type()->named_type() != NULL)\n-    this->write_named_hash(gogo, name, hash_fntype, equal_fntype);\n+    this->write_named_hash(gogo, name, hash_fntype);\n   else if (this->struct_type() != NULL)\n-    this->struct_type()->write_hash_function(gogo, name, hash_fntype,\n-\t\t\t\t\t     equal_fntype);\n+    this->struct_type()->write_hash_function(gogo, name, hash_fntype);\n   else if (this->array_type() != NULL)\n-    this->array_type()->write_hash_function(gogo, name, hash_fntype,\n-\t\t\t\t\t    equal_fntype);\n+    this->array_type()->write_hash_function(gogo, name, hash_fntype);\n   else\n     go_unreachable();\n \n@@ -2103,32 +1995,8 @@ Type::write_specific_type_functions(Gogo* gogo, Named_type* name, int64_t size,\n   gogo->remove_shortcuts_in_block(b);\n   gogo->finish_function(bloc);\n \n-  Named_object *equal_fn = gogo->start_function(equal_name, equal_fntype,\n-\t\t\t\t\t\tfalse, bloc);\n-  equal_fn->func_value()->set_is_type_specific_function();\n-  gogo->start_block(bloc);\n-\n-  if (size != -1)\n-    this->write_identity_equal(gogo, size);\n-  else if (name != NULL && name->real_type()->named_type() != NULL)\n-    this->write_named_equal(gogo, name);\n-  else if (this->struct_type() != NULL)\n-    this->struct_type()->write_equal_function(gogo, name);\n-  else if (this->array_type() != NULL)\n-    this->array_type()->write_equal_function(gogo, name);\n-  else\n-    go_unreachable();\n-\n-  b = gogo->finish_block(bloc);\n-  gogo->add_block(b, bloc);\n-  gogo->lower_block(equal_fn, b);\n-  gogo->order_block(b);\n-  gogo->remove_shortcuts_in_block(b);\n-  gogo->finish_function(bloc);\n-\n-  // Build the function descriptors for the type descriptor to refer to.\n+  // Build the function descriptor for the type descriptor to refer to.\n   hash_fn->func_value()->descriptor(gogo, hash_fn);\n-  equal_fn->func_value()->descriptor(gogo, equal_fn);\n }\n \n // Write a hash function for a type that can use an identity hash but\n@@ -2184,6 +2052,336 @@ Type::write_identity_hash(Gogo* gogo, int64_t size)\n   gogo->add_statement(s);\n }\n \n+// Write a hash function that simply calls the hash function for a\n+// named type.  This is used when one named type is defined as\n+// another.  This ensures that this case works when the other named\n+// type is defined in another package and relies on calling hash\n+// functions defined only in that package.\n+\n+void\n+Type::write_named_hash(Gogo* gogo, Named_type* name,\n+\t\t       Function_type* hash_fntype)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  Named_type* base_type = name->real_type()->named_type();\n+  while (base_type->is_alias())\n+    {\n+      base_type = base_type->real_type()->named_type();\n+      go_assert(base_type != NULL);\n+    }\n+  go_assert(base_type != NULL);\n+\n+  // The pointer to the type we are going to hash.  This is an\n+  // unsafe.Pointer.\n+  Named_object* key_arg = gogo->lookup(\"key\", NULL);\n+  go_assert(key_arg != NULL);\n+\n+  // The seed argument to the hash function.\n+  Named_object* seed_arg = gogo->lookup(\"seed\", NULL);\n+  go_assert(seed_arg != NULL);\n+\n+  Named_object* hash_fn = name->real_type()->hash_function(gogo, base_type,\n+\t\t\t\t\t\t\t   hash_fntype);\n+\n+  // Call the hash function for the base type.\n+  Expression* key_ref = Expression::make_var_reference(key_arg, bloc);\n+  Expression* seed_ref = Expression::make_var_reference(seed_arg, bloc);\n+  Expression_list* args = new Expression_list();\n+  args->push_back(key_ref);\n+  args->push_back(seed_ref);\n+  Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n+  Expression* call = Expression::make_call(func, args, false, bloc);\n+\n+  // Return the hash of the base type.\n+  Expression_list* vals = new Expression_list();\n+  vals->push_back(call);\n+  Statement* s = Statement::make_return_statement(vals, bloc);\n+  gogo->add_statement(s);\n+}\n+\n+// Return the runtime function that compares whether two values of\n+// this type are equal.  If NAME is not NULL it is the name of this\n+// type.  EQUAL_FNTYPE is the type of the equality function, for\n+// convenience; it may be NULL.  This returns NULL if the type is not\n+// comparable.\n+\n+Named_object*\n+Type::equal_function(Gogo* gogo, Named_type* name, Function_type* equal_fntype)\n+{\n+  // If the unaliased type is not a named type, then the type does not\n+  // have a name after all.\n+  if (name != NULL)\n+    name = name->unalias()->named_type();\n+\n+  if (!this->is_comparable())\n+    return NULL;\n+\n+  if (equal_fntype == NULL)\n+    {\n+      Location bloc = Linemap::predeclared_location();\n+      Type* void_type = Type::make_void_type();\n+      Type* unsafe_pointer_type = Type::make_pointer_type(void_type);\n+      Typed_identifier_list* params = new Typed_identifier_list();\n+      params->push_back(Typed_identifier(\"key1\", unsafe_pointer_type, bloc));\n+      params->push_back(Typed_identifier(\"key2\", unsafe_pointer_type, bloc));\n+      Typed_identifier_list* results = new Typed_identifier_list();\n+      results->push_back(Typed_identifier(\"\", Type::lookup_bool_type(), bloc));\n+      equal_fntype = Type::make_function_type(NULL, params, results, bloc);\n+    }\n+\n+  const char* equal_fnname;\n+  if (this->compare_is_identity(gogo))\n+    {\n+      int64_t size, align;\n+      if (!this->backend_type_size(gogo, &size)\n+\t  || !this->backend_type_align(gogo, &align))\n+\t{\n+\t  go_assert(saw_errors());\n+\t  return NULL;\n+\t}\n+      bool build_function = false;\n+      // This switch matches the one in Type::needs_specific_type_functions.\n+      // The alignment tests are because of the memequal functions,\n+      // which assume that the values are aligned as required for an\n+      // integer of that size.\n+      switch (size)\n+\t{\n+\tcase 0:\n+\t  equal_fnname = \"runtime.memequal0\";\n+\t  break;\n+\tcase 1:\n+\t  equal_fnname = \"runtime.memequal8\";\n+\t  break;\n+\tcase 2:\n+\t  if (align < Type::memequal_align(gogo, 16))\n+\t    build_function = true;\n+\t  else\n+\t    equal_fnname = \"runtime.memequal16\";\n+\t  break;\n+\tcase 4:\n+\t  if (align < Type::memequal_align(gogo, 32))\n+\t    build_function = true;\n+\t  else\n+\t    equal_fnname = \"runtime.memequal32\";\n+\t  break;\n+\tcase 8:\n+\t  if (align < Type::memequal_align(gogo, 64))\n+\t    build_function = true;\n+\t  else\n+\t    equal_fnname = \"runtime.memequal64\";\n+\t  break;\n+\tcase 16:\n+\t  if (align < Type::memequal_align(gogo, 128))\n+\t    build_function = true;\n+\t  else\n+\t    equal_fnname = \"runtime.memequal128\";\n+\t  break;\n+\tdefault:\n+\t  build_function = true;\n+\t  break;\n+\t}\n+      if (build_function)\n+\t{\n+\t  // We don't have a built-in function for a type of this size\n+\t  // and alignment.  Build a function to use that calls the\n+\t  // generic equality functions for identity, passing the size.\n+\t  return this->build_equal_function(gogo, name, size, equal_fntype);\n+\t}\n+    }\n+  else\n+    {\n+      switch (this->base()->classification())\n+\t{\n+\tcase Type::TYPE_ERROR:\n+\tcase Type::TYPE_VOID:\n+\tcase Type::TYPE_NIL:\n+\tcase Type::TYPE_FUNCTION:\n+\tcase Type::TYPE_MAP:\n+\t  // For these types is_comparable should have returned false.\n+\t  go_unreachable();\n+\n+\tcase Type::TYPE_BOOLEAN:\n+\tcase Type::TYPE_INTEGER:\n+\tcase Type::TYPE_POINTER:\n+\tcase Type::TYPE_CHANNEL:\n+\t  // For these types compare_is_identity should have returned true.\n+\t  go_unreachable();\n+\n+\tcase Type::TYPE_FLOAT:\n+\t  switch (this->float_type()->bits())\n+\t    {\n+\t    case 32:\n+\t      equal_fnname = \"runtime.f32equal\";\n+\t      break;\n+\t    case 64:\n+\t      equal_fnname = \"runtime.f64equal\";\n+\t      break;\n+\t    default:\n+\t      go_unreachable();\n+\t    }\n+\t  break;\n+\n+\tcase Type::TYPE_COMPLEX:\n+\t  switch (this->complex_type()->bits())\n+\t    {\n+\t    case 64:\n+\t      equal_fnname = \"runtime.c64equal\";\n+\t      break;\n+\t    case 128:\n+\t      equal_fnname = \"runtime.c128equal\";\n+\t      break;\n+\t    default:\n+\t      go_unreachable();\n+\t    }\n+\t  break;\n+\n+\tcase Type::TYPE_STRING:\n+\t  equal_fnname = \"runtime.strequal\";\n+\t  break;\n+\n+\tcase Type::TYPE_STRUCT:\n+\t  // This is a struct which can not be compared using a simple\n+\t  // identity function.  We need to build a function for\n+\t  // comparison.\n+\t  return this->build_equal_function(gogo, name, -1, equal_fntype);\n+\n+\tcase Type::TYPE_ARRAY:\n+\t  if (this->is_slice_type())\n+\t    {\n+\t      // Type::is_compatible_for_comparison should have\n+\t      // returned false.\n+\t      go_unreachable();\n+\t    }\n+\t  else\n+\t    {\n+\t      // This is an array which can not be compared using a\n+\t      // simple identity function.  We need to build a\n+\t      // function for comparison.\n+\t      return this->build_equal_function(gogo, name, -1, equal_fntype);\n+\t    }\n+\t  break;\n+\n+\tcase Type::TYPE_INTERFACE:\n+\t  if (this->interface_type()->is_empty())\n+\t    equal_fnname = \"runtime.nilinterequal\";\n+\t  else\n+\t    equal_fnname = \"runtime.interequal\";\n+\t  break;\n+\n+\tcase Type::TYPE_NAMED:\n+\tcase Type::TYPE_FORWARD:\n+\t  go_unreachable();\n+\n+\tdefault:\n+\t  go_unreachable();\n+\t}\n+    }\n+\n+  Location bloc = Linemap::predeclared_location();\n+  Named_object* equal_fn =\n+    Named_object::make_function_declaration(equal_fnname, NULL, equal_fntype,\n+\t\t\t\t\t    bloc);\n+  equal_fn->func_declaration_value()->set_asm_name(equal_fnname);\n+  return equal_fn;\n+}\n+\n+// A hash table mapping types to the specific equal functions.\n+\n+Type::Type_function Type::type_equal_functions_table;\n+\n+// Build an equality function that is specific to a type: if SIZE ==\n+// -1, this is a struct or array type that cannot use an identity\n+// comparison.  Otherwise, it is a type that uses an identity\n+// comparison but is not one of the standard supported sizes or it is\n+// not aligned as needed.\n+\n+Named_object*\n+Type::build_equal_function(Gogo* gogo, Named_type* name, int64_t size,\n+\t\t\t   Function_type* equal_fntype)\n+{\n+  std::pair<Type*, Named_object*> val(name != NULL ? name : this, NULL);\n+  std::pair<Type_function::iterator, bool> ins =\n+    Type::type_equal_functions_table.insert(val);\n+  if (!ins.second)\n+    {\n+      // We already have a function for this type.\n+      return ins.first->second;\n+    }\n+\n+  std::string equal_name = gogo->equal_function_name(this, name);\n+\n+  Location bloc = Linemap::predeclared_location();\n+\n+  const Package* package = NULL;\n+  bool is_defined_elsewhere =\n+    this->type_descriptor_defined_elsewhere(name, &package);\n+\n+  Named_object* equal_fn;\n+  if (is_defined_elsewhere)\n+    equal_fn = Named_object::make_function_declaration(equal_name, package,\n+\t\t\t\t\t\t       equal_fntype, bloc);\n+  else\n+    equal_fn = gogo->declare_package_function(equal_name, equal_fntype, bloc);\n+\n+  ins.first->second = equal_fn;\n+\n+  if (!is_defined_elsewhere)\n+    {\n+      if (gogo->in_global_scope())\n+\tthis->write_equal_function(gogo, name, size, equal_name, equal_fntype);\n+      else\n+\tgogo->queue_equal_function(this, name, size, equal_name, equal_fntype);\n+    }\n+\n+  return equal_fn;\n+}\n+\n+// Write the equal function for a type that needs it written\n+// specially.\n+\n+void\n+Type::write_equal_function(Gogo* gogo, Named_type* name, int64_t size,\n+\t\t\t   const std::string& equal_name,\n+\t\t\t   Function_type* equal_fntype)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  if (gogo->specific_type_functions_are_written())\n+    {\n+      go_assert(saw_errors());\n+      return;\n+    }\n+\n+  go_assert(this->is_comparable());\n+\n+  Named_object* equal_fn = gogo->start_function(equal_name, equal_fntype,\n+\t\t\t\t\t\tfalse, bloc);\n+  equal_fn->func_value()->set_is_type_specific_function();\n+  gogo->start_block(bloc);\n+\n+  if (size != -1)\n+    this->write_identity_equal(gogo, size);\n+  else if (name != NULL && name->real_type()->named_type() != NULL)\n+    this->write_named_equal(gogo, name);\n+  else if (this->struct_type() != NULL)\n+    this->struct_type()->write_equal_function(gogo, name);\n+  else if (this->array_type() != NULL)\n+    this->array_type()->write_equal_function(gogo, name);\n+  else\n+    go_unreachable();\n+\n+  Block* b = gogo->finish_block(bloc);\n+  gogo->add_block(b, bloc);\n+  gogo->lower_block(equal_fn, b);\n+  gogo->order_block(b);\n+  gogo->remove_shortcuts_in_block(b);\n+  gogo->finish_function(bloc);\n+\n+  // Build the function descriptor for the type descriptor to refer to.\n+  equal_fn->func_value()->descriptor(gogo, equal_fn);\n+}\n+\n // Write an equality function for a type that can use an identity\n // equality comparison but is not one of the standard supported sizes.\n // For example, this would be used for the type [3]byte.  This builds\n@@ -2237,56 +2435,6 @@ Type::write_identity_equal(Gogo* gogo, int64_t size)\n   gogo->add_statement(s);\n }\n \n-// Write a hash function that simply calls the hash function for a\n-// named type.  This is used when one named type is defined as\n-// another.  This ensures that this case works when the other named\n-// type is defined in another package and relies on calling hash\n-// functions defined only in that package.\n-\n-void\n-Type::write_named_hash(Gogo* gogo, Named_type* name,\n-\t\t       Function_type* hash_fntype, Function_type* equal_fntype)\n-{\n-  Location bloc = Linemap::predeclared_location();\n-\n-  Named_type* base_type = name->real_type()->named_type();\n-  while (base_type->is_alias())\n-    {\n-      base_type = base_type->real_type()->named_type();\n-      go_assert(base_type != NULL);\n-    }\n-  go_assert(base_type != NULL);\n-\n-  // The pointer to the type we are going to hash.  This is an\n-  // unsafe.Pointer.\n-  Named_object* key_arg = gogo->lookup(\"key\", NULL);\n-  go_assert(key_arg != NULL);\n-\n-  // The seed argument to the hash function.\n-  Named_object* seed_arg = gogo->lookup(\"seed\", NULL);\n-  go_assert(seed_arg != NULL);\n-\n-  Named_object* hash_fn;\n-  Named_object* equal_fn;\n-  name->real_type()->type_functions(gogo, base_type, hash_fntype, equal_fntype,\n-\t\t\t\t    &hash_fn, &equal_fn);\n-\n-  // Call the hash function for the base type.\n-  Expression* key_ref = Expression::make_var_reference(key_arg, bloc);\n-  Expression* seed_ref = Expression::make_var_reference(seed_arg, bloc);\n-  Expression_list* args = new Expression_list();\n-  args->push_back(key_ref);\n-  args->push_back(seed_ref);\n-  Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n-  Expression* call = Expression::make_call(func, args, false, bloc);\n-\n-  // Return the hash of the base type.\n-  Expression_list* vals = new Expression_list();\n-  vals->push_back(call);\n-  Statement* s = Statement::make_return_statement(vals, bloc);\n-  gogo->add_statement(s);\n-}\n-\n // Write an equality function that simply calls the equality function\n // for a named type.  This is used when one named type is defined as\n // another.  This ensures that this case works when the other named\n@@ -2441,21 +2589,18 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   ++p;\n   go_assert(p->is_field_name(\"hashfn\"));\n   Function_type* hash_fntype = p->type()->function_type();\n-\n-  ++p;\n-  go_assert(p->is_field_name(\"equalfn\"));\n-  Function_type* equal_fntype = p->type()->function_type();\n-\n-  Named_object* hash_fn;\n-  Named_object* equal_fn;\n-  this->type_functions(gogo, name, hash_fntype, equal_fntype, &hash_fn,\n-\t\t       &equal_fn);\n+  Named_object* hash_fn = this->hash_function(gogo, name, hash_fntype);\n   if (hash_fn == NULL)\n     vals->push_back(Expression::make_cast(hash_fntype,\n \t\t\t\t\t  Expression::make_nil(bloc),\n \t\t\t\t\t  bloc));\n   else\n     vals->push_back(Expression::make_func_reference(hash_fn, NULL, bloc));\n+\n+  ++p;\n+  go_assert(p->is_field_name(\"equalfn\"));\n+  Function_type* equal_fntype = p->type()->function_type();\n+  Named_object* equal_fn = this->equal_function(gogo, name, equal_fntype);\n   if (equal_fn == NULL)\n     vals->push_back(Expression::make_cast(equal_fntype,\n \t\t\t\t\t  Expression::make_nil(bloc),\n@@ -6459,8 +6604,7 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \n void\n Struct_type::write_hash_function(Gogo* gogo, Named_type*,\n-\t\t\t\t Function_type* hash_fntype,\n-\t\t\t\t Function_type* equal_fntype)\n+\t\t\t\t Function_type* hash_fntype)\n {\n   Location bloc = Linemap::predeclared_location();\n \n@@ -6506,10 +6650,8 @@ Struct_type::write_hash_function(Gogo* gogo, Named_type*,\n       subkey = Expression::make_cast(key_arg_type, subkey, bloc);\n \n       // Get the hash function to use for the type of this field.\n-      Named_object* hash_fn;\n-      Named_object* equal_fn;\n-      pf->type()->type_functions(gogo, pf->type()->named_type(), hash_fntype,\n-\t\t\t\t equal_fntype, &hash_fn, &equal_fn);\n+      Named_object* hash_fn =\n+\tpf->type()->hash_function(gogo, pf->type()->named_type(), hash_fntype);\n \n       // Call the hash function for the field, passing retval as the seed.\n       ref = Expression::make_temporary_reference(retval, bloc);\n@@ -7306,8 +7448,7 @@ Array_type::do_hash_for_method(Gogo* gogo, int flags) const\n \n void\n Array_type::write_hash_function(Gogo* gogo, Named_type* name,\n-\t\t\t\tFunction_type* hash_fntype,\n-\t\t\t\tFunction_type* equal_fntype)\n+\t\t\t\tFunction_type* hash_fntype)\n {\n   Location bloc = Linemap::predeclared_location();\n \n@@ -7356,11 +7497,9 @@ Array_type::write_hash_function(Gogo* gogo, Named_type* name,\n   gogo->start_block(bloc);\n \n   // Get the hash function for the element type.\n-  Named_object* hash_fn;\n-  Named_object* equal_fn;\n-  this->element_type_->type_functions(gogo, this->element_type_->named_type(),\n-\t\t\t\t      hash_fntype, equal_fntype, &hash_fn,\n-\t\t\t\t      &equal_fn);\n+  Named_object* hash_fn =\n+    this->element_type_->hash_function(gogo, this->element_type_->named_type(),\n+\t\t\t\t       hash_fntype);\n \n   // Get a pointer to this element in the loop.\n   Expression* subkey = Expression::make_temporary_reference(key, bloc);"}, {"sha": "55c5912620ceef11cc77cba8687afb8b54347381", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9279b5ba4538da8041f074db3f5fcd9e8ecff93e/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "patch": "@@ -1053,19 +1053,27 @@ class Type\n   bool\n   needs_specific_type_functions(Gogo*);\n \n-  // Get the hash and equality functions for a type.\n+  // Get the equality function for a type.  Returns NULL if the type\n+  // is not comparable.\n+  Named_object*\n+  equal_function(Gogo*, Named_type* name, Function_type* equal_fntype);\n+\n+  // Get the hash function for a type.  Returns NULL if the type is\n+  // not comparable.\n+  Named_object*\n+  hash_function(Gogo*, Named_type* name, Function_type* hash_fntype);\n+\n+  // Write the equal function for a type.\n   void\n-  type_functions(Gogo*, Named_type* name, Function_type* hash_fntype,\n-\t\t Function_type* equal_fntype, Named_object** hash_fn,\n-\t\t Named_object** equal_fn);\n+  write_equal_function(Gogo*, Named_type*, int64_t size,\n+\t\t       const std::string& equal_name,\n+\t\t       Function_type* equal_fntype);\n \n-  // Write the hash and equality type functions.\n+  // Write the hash function for a type.\n   void\n-  write_specific_type_functions(Gogo*, Named_type*, int64_t size,\n-\t\t\t\tconst std::string& hash_name,\n-\t\t\t\tFunction_type* hash_fntype,\n-\t\t\t\tconst std::string& equal_name,\n-\t\t\t\tFunction_type* equal_fntype);\n+  write_hash_function(Gogo*, Named_type*, int64_t size,\n+\t\t      const std::string& hash_name,\n+\t\t      Function_type* hash_fntype);\n \n   // Return the alignment required by the memequalN function.\n   static int64_t memequal_align(Gogo*, int size);\n@@ -1274,13 +1282,15 @@ class Type\n   Expression*\n   gcprog_constructor(Gogo*, int64_t ptrsize, int64_t ptrdata);\n \n-  // Build the hash and equality type functions for a type which needs\n-  // specific functions.\n-  void\n-  specific_type_functions(Gogo*, Named_type*, int64_t size,\n-\t\t\t  Function_type* hash_fntype,\n-\t\t\t  Function_type* equal_fntype, Named_object** hash_fn,\n-\t\t\t  Named_object** equal_fn);\n+  // Build the hash function for a type that needs specific functions.\n+  Named_object*\n+  build_hash_function(Gogo*, Named_type*, int64_t size,\n+\t\t      Function_type* hash_fntype);\n+\n+  // Build the equal function for a type that needs specific functions.\n+  Named_object*\n+  build_equal_function(Gogo*, Named_type*, int64_t size,\n+\t\t       Function_type* equal_fntype);\n \n   void\n   write_identity_hash(Gogo*, int64_t size);\n@@ -1289,8 +1299,7 @@ class Type\n   write_identity_equal(Gogo*, int64_t size);\n \n   void\n-  write_named_hash(Gogo*, Named_type*, Function_type* hash_fntype,\n-\t\t   Function_type* equal_fntype);\n+  write_named_hash(Gogo*, Named_type*, Function_type* hash_fntype);\n \n   void\n   write_named_equal(Gogo*, Named_type*);\n@@ -1394,13 +1403,13 @@ class Type\n   // A list of builtin named types.\n   static std::vector<Named_type*> named_builtin_types;\n \n-  // A map from types which need specific type functions to the type\n-  // functions themselves.\n-  typedef std::pair<Named_object*, Named_object*> Hash_equal_fn;\n-  typedef Unordered_map_hash(const Type*, Hash_equal_fn, Type_hash_identical,\n-\t\t\t     Type_identical) Type_functions;\n+  // A map from types that need a specific hash or equality function\n+  // to the hash or equality function.\n+  typedef Unordered_map_hash(const Type*, Named_object*, Type_hash_identical,\n+\t\t\t     Type_identical) Type_function;\n \n-  static Type_functions type_functions_table;\n+  static Type_function type_hash_functions_table;\n+  static Type_function type_equal_functions_table;\n \n   // Cache for reusing existing pointer types; maps from pointed-to-type\n   // to pointer type.\n@@ -2619,7 +2628,7 @@ class Struct_type : public Type\n \n   // Write the hash function for this type.\n   void\n-  write_hash_function(Gogo*, Named_type*, Function_type*, Function_type*);\n+  write_hash_function(Gogo*, Named_type*, Function_type*);\n \n   // Write the equality function for this type.\n   void\n@@ -2806,7 +2815,7 @@ class Array_type : public Type\n \n   // Write the hash function for this type.\n   void\n-  write_hash_function(Gogo*, Named_type*, Function_type*, Function_type*);\n+  write_hash_function(Gogo*, Named_type*, Function_type*);\n \n   // Write the equality function for this type.\n   void"}]}