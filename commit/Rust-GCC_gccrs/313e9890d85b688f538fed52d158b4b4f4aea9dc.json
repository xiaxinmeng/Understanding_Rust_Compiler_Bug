{"sha": "313e9890d85b688f538fed52d158b4b4f4aea9dc", "node_id": "C_kwDOANBUbNoAKDMxM2U5ODkwZDg1YjY4OGY1MzhmZWQ1MmQxNThiNGI0ZjRhZWE5ZGM", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-14T13:29:58Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-03-14T15:34:50Z"}, "message": "parser: Allow parsing stmts without closing semicolon\n\nIn certain cases such as macro matching or macro expansion, it is\nimportant to allow the parser to return a valid statement even if no\nclosing semicolon is given. This commit adds an optional parameter to\nthe concerned functions to allow a lack of semicolon those special cases", "tree": {"sha": "1e6b8e44c8c9970894be9ff8b1dde0f727443a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e6b8e44c8c9970894be9ff8b1dde0f727443a3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/313e9890d85b688f538fed52d158b4b4f4aea9dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313e9890d85b688f538fed52d158b4b4f4aea9dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/313e9890d85b688f538fed52d158b4b4f4aea9dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/313e9890d85b688f538fed52d158b4b4f4aea9dc/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41f402f0b19c7e4f19f8d4d65d15223d2752f302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f402f0b19c7e4f19f8d4d65d15223d2752f302", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41f402f0b19c7e4f19f8d4d65d15223d2752f302"}], "stats": {"total": 136, "additions": 117, "deletions": 19}, "files": [{"sha": "f1313724ace07ed90e2a67913f8c3fef0822993c", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=313e9890d85b688f538fed52d158b4b4f4aea9dc", "patch": "@@ -479,7 +479,7 @@ MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n       break;\n \n     case AST::MacroFragSpec::STMT:\n-      parser.parse_stmt ();\n+      parser.parse_stmt (/* allow_no_semi */ true);\n       break;\n \n     case AST::MacroFragSpec::LIFETIME:\n@@ -506,6 +506,9 @@ MacroExpander::match_fragment (Parser<MacroInvocLexer> &parser,\n       return false;\n     }\n \n+  for (const auto &error : parser.get_errors ())\n+    error.emit_error ();\n+\n   // it matches if the parser did not produce errors trying to parse that type\n   // of item\n   return !parser.has_errors ();\n@@ -825,7 +828,7 @@ transcribe_many_stmts (Parser<MacroInvocLexer> &parser, TokenId &delimiter)\n   // transcriber is an expression, but since the macro call is followed by\n   // a semicolon, it's a valid ExprStmt\n   return parse_many (parser, delimiter, [&parser] () {\n-    auto stmt = parser.parse_stmt ();\n+    auto stmt = parser.parse_stmt (/* allow_no_semi */ true);\n     return AST::SingleASTNode (std::move (stmt));\n   });\n }"}, {"sha": "0bbd8fbf31b3cc5854b44fb1d42dcf904cf2f1e7", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=313e9890d85b688f538fed52d158b4b4f4aea9dc", "patch": "@@ -6034,9 +6034,10 @@ Parser<ManagedTokenSource>::parse_named_function_param (\n // Parses a statement (will further disambiguate any statement).\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::Stmt>\n-Parser<ManagedTokenSource>::parse_stmt ()\n+Parser<ManagedTokenSource>::parse_stmt (bool allow_no_semi)\n {\n   // quick exit for empty statement\n+  // FIXME: Can we have empty statements without semicolons? Just nothing?\n   const_TokenPtr t = lexer.peek_token ();\n   if (t->get_id () == SEMICOLON)\n     {\n@@ -6058,7 +6059,7 @@ Parser<ManagedTokenSource>::parse_stmt ()\n     {\n     case LET:\n       // let statement\n-      return parse_let_stmt (std::move (outer_attrs));\n+      return parse_let_stmt (std::move (outer_attrs), allow_no_semi);\n     case PUB:\n     case MOD:\n     case EXTERN_TOK:\n@@ -6113,15 +6114,16 @@ Parser<ManagedTokenSource>::parse_stmt ()\n       // TODO: find out how to disable gcc \"implicit fallthrough\" warning\n     default:\n       // fallback: expression statement\n-      return parse_expr_stmt (std::move (outer_attrs));\n+      return parse_expr_stmt (std::move (outer_attrs), allow_no_semi);\n       break;\n     }\n }\n \n // Parses a let statement.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::LetStmt>\n-Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs)\n+Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs,\n+\t\t\t\t\t    bool allow_no_semi)\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   skip_token (LET);\n@@ -6176,12 +6178,12 @@ Parser<ManagedTokenSource>::parse_let_stmt (AST::AttrVec outer_attrs)\n \t}\n     }\n \n-  if (!skip_token (SEMICOLON))\n+  if (!maybe_skip_token (SEMICOLON) && !allow_no_semi)\n     {\n       // skip after somewhere\n       return nullptr;\n-      /* TODO: how wise is it to ditch a mostly-valid let statement just because\n-       * a semicolon is missing? */\n+      /* TODO: how wise is it to ditch a mostly-valid let statement just\n+       * because a semicolon is missing? */\n     }\n \n   return std::unique_ptr<AST::LetStmt> (\n@@ -7016,7 +7018,8 @@ Parser<ManagedTokenSource>::parse_method ()\n  * block statement). */\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmt>\n-Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs)\n+Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs,\n+\t\t\t\t\t     bool allow_no_semi)\n {\n   /* potential thoughts - define new virtual method \"has_block()\" on expr. parse\n    * expr and then determine whether semicolon is needed as a result of this\n@@ -7055,7 +7058,8 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs)\n \t  }\n \telse\n \t  {\n-\t    return parse_expr_stmt_without_block (std::move (outer_attrs));\n+\t    return parse_expr_stmt_without_block (std::move (outer_attrs),\n+\t\t\t\t\t\t  allow_no_semi);\n \t  }\n       }\n       case UNSAFE: {\n@@ -7068,15 +7072,17 @@ Parser<ManagedTokenSource>::parse_expr_stmt (AST::AttrVec outer_attrs)\n \t  }\n \telse\n \t  {\n-\t    return parse_expr_stmt_without_block (std::move (outer_attrs));\n+\t    return parse_expr_stmt_without_block (std::move (outer_attrs),\n+\t\t\t\t\t\t  allow_no_semi);\n \t  }\n       }\n     default:\n       // not a parse expr with block, so must be expr without block\n       /* TODO: if possible, be more selective about possible expr without block\n        * initial tokens in order to prevent more syntactical errors at parse\n        * time. */\n-      return parse_expr_stmt_without_block (std::move (outer_attrs));\n+      return parse_expr_stmt_without_block (std::move (outer_attrs),\n+\t\t\t\t\t    allow_no_semi);\n     }\n }\n \n@@ -7192,7 +7198,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt_with_block (\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::ExprStmtWithoutBlock>\n Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n-  AST::AttrVec outer_attrs)\n+  AST::AttrVec outer_attrs, bool allow_no_semi)\n {\n   /* TODO: maybe move more logic for expr without block in here for better error\n    * handling */\n@@ -7217,7 +7223,7 @@ Parser<ManagedTokenSource>::parse_expr_stmt_without_block (\n     }\n \n   // skip semicolon at end that is required\n-  if (!skip_token (SEMICOLON))\n+  if (!maybe_skip_token (SEMICOLON) && !allow_no_semi)\n     {\n       // skip somewhere?\n       return nullptr;\n@@ -12219,6 +12225,18 @@ Parser<ManagedTokenSource>::skip_token (TokenId token_id)\n   return expect_token (token_id) != const_TokenPtr ();\n }\n \n+/* Checks if current token has inputted id - skips it and returns true if so,\n+ * returns false otherwise without diagnosing an error */\n+template <typename ManagedTokenSource>\n+bool\n+Parser<ManagedTokenSource>::maybe_skip_token (TokenId token_id)\n+{\n+  if (lexer.peek_token ()->get_id () != token_id)\n+    return false;\n+  else\n+    return skip_token (token_id);\n+}\n+\n /* Checks the current token - if id is same as expected, skips and returns it,\n  * otherwise diagnoses error and returns null. */\n template <typename ManagedTokenSource>"}, {"sha": "5fcb3052156a212c7fc08d43e03c1a81d859c500", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=313e9890d85b688f538fed52d158b4b4f4aea9dc", "patch": "@@ -88,8 +88,25 @@ struct ParseRestrictions\n template <typename ManagedTokenSource> class Parser\n {\n public:\n+  /**\n+   * Consume a token, reporting an error if it isn't the next token\n+   *\n+   * @param t ID of the token to consume\n+   *\n+   * @return true if the token was next, false if it wasn't found\n+   */\n   bool skip_token (TokenId t);\n \n+  /**\n+   * Same as `skip_token` but allows for failure without necessarily reporting\n+   * an error\n+   *\n+   * @param t ID of the token to consume\n+   *\n+   * @return true if the token was next, false if it wasn't found\n+   */\n+  bool maybe_skip_token (TokenId t);\n+\n   std::unique_ptr<AST::Expr>\n   parse_expr (AST::AttrVec outer_attrs = AST::AttrVec (),\n \t      ParseRestrictions restrictions = ParseRestrictions ());\n@@ -103,7 +120,20 @@ template <typename ManagedTokenSource> class Parser\n \n   std::unique_ptr<AST::Item> parse_item (bool called_from_statement);\n   std::unique_ptr<AST::Pattern> parse_pattern ();\n-  std::unique_ptr<AST::Stmt> parse_stmt ();\n+\n+  /**\n+   * Parse a statement\n+   *\n+   * Statement : ';'\n+   *    | Item\n+   *    | LetStatement\n+   *    | ExpressionStatement\n+   *    | MacroInvocationSemi\n+   *\n+   * @param allow_no_semi Allow the parser to not parse a semicolon after\n+   * \t\tthe statement without erroring out\n+   */\n+  std::unique_ptr<AST::Stmt> parse_stmt (bool allow_no_semi = false);\n   std::unique_ptr<AST::Type> parse_type ();\n   AST::PathInExpression parse_path_in_expression ();\n   std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n@@ -575,12 +605,25 @@ template <typename ManagedTokenSource> class Parser\n   AST::MaybeNamedParam parse_maybe_named_param (AST::AttrVec outer_attrs);\n \n   // Statement-related\n-  std::unique_ptr<AST::LetStmt> parse_let_stmt (AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs);\n+\n+  /**\n+   *Parse a let-statement\n+   * LetStatement :\n+   * \tOuterAttribute*\n+   * \t\t'let' PatternNoTopAlt ( ':' Type )? ('=' Expression )? ';'\n+   *\n+   * @param allow_no_semi Allow parsing a let-statement without expecting a\n+   * \t\tsemicolon to follow it\n+   */\n+  std::unique_ptr<AST::LetStmt> parse_let_stmt (AST::AttrVec outer_attrs,\n+\t\t\t\t\t\tbool allow_no_semi = false);\n+  std::unique_ptr<AST::ExprStmt> parse_expr_stmt (AST::AttrVec outer_attrs,\n+\t\t\t\t\t\t  bool allow_no_semi = false);\n   std::unique_ptr<AST::ExprStmtWithBlock>\n   parse_expr_stmt_with_block (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::ExprStmtWithoutBlock>\n-  parse_expr_stmt_without_block (AST::AttrVec outer_attrs);\n+  parse_expr_stmt_without_block (AST::AttrVec outer_attrs,\n+\t\t\t\t bool allow_no_semi = false);\n   ExprOrStmt parse_stmt_or_expr_without_block ();\n   ExprOrStmt parse_stmt_or_expr_with_block (AST::AttrVec outer_attrs);\n   ExprOrStmt parse_macro_invocation_maybe_semi (AST::AttrVec outer_attrs);"}, {"sha": "c297107d6f3f2b792fc1db8670357efca30fbd5e", "filename": "gcc/testsuite/rust/compile/macro18.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro18.rs?ref=313e9890d85b688f538fed52d158b4b4f4aea9dc", "patch": "@@ -0,0 +1,14 @@\n+// { dg-additional-options \"-w\" }\n+\n+macro_rules! take_stmt {\n+    ($s:stmt) => {\n+        $s;\n+    };\n+}\n+\n+fn main() -> i32 {\n+    take_stmt!(let complete = 15;);\n+    take_stmt!(let lacking = 14);\n+\n+    0\n+}"}, {"sha": "1bf9a2bfa9d388eaedb4f3b597a9542216dd0b45", "filename": "gcc/testsuite/rust/compile/macro19.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro19.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro19.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro19.rs?ref=313e9890d85b688f538fed52d158b4b4f4aea9dc", "patch": "@@ -0,0 +1,19 @@\n+// { dg-additional-options \"-w\" }\n+\n+macro_rules! call_without_semi {\n+    () => {\n+        f()\n+    };\n+    (block) => {{\n+        f()\n+    }};\n+}\n+\n+fn f() {}\n+\n+fn main() -> i32 {\n+    call_without_semi!();\n+    call_without_semi!(block);\n+\n+    0\n+}"}, {"sha": "a06a093dc30b9e7f6255f205c44f69e48dd2e7bb", "filename": "gcc/testsuite/rust/compile/macro9.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/313e9890d85b688f538fed52d158b4b4f4aea9dc/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fmacro9.rs?ref=313e9890d85b688f538fed52d158b4b4f4aea9dc", "patch": "@@ -12,6 +12,7 @@ fn main() -> i32 {\n     let b = add!(15);\n     let b = add!(15 14); // { dg-error \"Failed to match any rule within macro\" }\n     let b = add!(15, 14,); // { dg-error \"Failed to match any rule within macro\" }\n+                           // { dg-error \"found unexpected token\" \"\" { target *-*-* } .-1 }\n \n     0\n }"}]}