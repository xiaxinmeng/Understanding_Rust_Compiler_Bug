{"sha": "8729113865444cd9afe48970e6f813a982583eb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcyOTExMzg2NTQ0NGNkOWFmZTQ4OTcwZTZmODEzYTk4MjU4M2ViMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-26T23:01:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-26T23:01:42Z"}, "message": "(INTEGRAL_TYPE_P, FLOAT_TYPE_P): New macros.\n\nFrom-SVN: r4240", "tree": {"sha": "9d0b827e5518a732810c5790abe1460c0dead71f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d0b827e5518a732810c5790abe1460c0dead71f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8729113865444cd9afe48970e6f813a982583eb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8729113865444cd9afe48970e6f813a982583eb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8729113865444cd9afe48970e6f813a982583eb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8729113865444cd9afe48970e6f813a982583eb0/comments", "author": null, "committer": null, "parents": [{"sha": "87d348780e626fb90078658ef4d1ca3751773091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87d348780e626fb90078658ef4d1ca3751773091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87d348780e626fb90078658ef4d1ca3751773091"}], "stats": {"total": 15, "additions": 15, "deletions": 0}, "files": [{"sha": "556dac0ecfb0f667b5d59b90d7221b272778a034", "filename": "gcc/tree.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8729113865444cd9afe48970e6f813a982583eb0/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8729113865444cd9afe48970e6f813a982583eb0/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8729113865444cd9afe48970e6f813a982583eb0", "patch": "@@ -205,6 +205,21 @@ struct tree_common\n \t && (TREE_TYPE (EXP)\t\t\t\t\t\\\n \t     == TREE_TYPE (TREE_OPERAND (EXP, 0))))\t\t\\\n     (EXP) = TREE_OPERAND (EXP, 0);\n+\n+/* Nonzero if TYPE represents an integral type.  Note that we do not\n+   include COMPLEX types here.  */\n+\n+#define INTEGRAL_TYPE_P(TYPE)  \\\n+  (TREE_CODE (TYPE) == INTEGER_TYPE || TREE_CODE (TYPE) == ENUMERAL_TYPE  \\\n+   || TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == CHAR_TYPE)\n+\n+/* Nonzero if TYPE represents a floating-point type, including complex\n+   floating-point types.  */\n+\n+#define FLOAT_TYPE_P(TYPE)\t\t\\\n+  (TREE_CODE (TYPE) == REAL_TYPE\t\\\n+   || (TREE_CODE (TYPE) == COMPLEX_TYPE \\\n+       && TREE_CODE (TREE_TYPE (TYPE)) == REAL_TYPE))\n \f\n /* Define many boolean fields that all tree nodes have.  */\n "}]}