{"sha": "2c26d262eb40998040308a57d420849fd764ef53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMyNmQyNjJlYjQwOTk4MDQwMzA4YTU3ZDQyMDg0OWZkNzY0ZWY1Mw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-07-22T13:57:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-22T13:57:18Z"}, "message": "[Ada] Further fix non-stored discriminant in aggregate for GNATprove\n\nGNATprove expects discriminants appearing in aggregates and their types\nto be resolved to stored discriminants.  This extends the machinery that\nmakes sure this is the case for default initialization expressions so as\nto also handle component associations in these expressions.\n\n2019-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* sem_aggr.adb (Rewrite_Bound): Be prepared for discriminals\n\ttoo.\n\t(Rewrite_Range;): Minor tweak.\n\t(Resolve_Record_Aggregate): For a component with default\n\tinitialization whose expression is an array aggregate, also\n\trewrite the bounds of the component associations, if any.\n\nFrom-SVN: r273679", "tree": {"sha": "ad86ead6ecaf4265f5c0ca53de99abe66e94e43b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad86ead6ecaf4265f5c0ca53de99abe66e94e43b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c26d262eb40998040308a57d420849fd764ef53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c26d262eb40998040308a57d420849fd764ef53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c26d262eb40998040308a57d420849fd764ef53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c26d262eb40998040308a57d420849fd764ef53/comments", "author": null, "committer": null, "parents": [{"sha": "2418e23139edd33f1cab2158b46ac9bbd81b8bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2418e23139edd33f1cab2158b46ac9bbd81b8bd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2418e23139edd33f1cab2158b46ac9bbd81b8bd7"}], "stats": {"total": 52, "additions": 41, "deletions": 11}, "files": [{"sha": "202dfc7cacf10d724d9bd67e6a318d5d54f5e260", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c26d262eb40998040308a57d420849fd764ef53/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c26d262eb40998040308a57d420849fd764ef53/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2c26d262eb40998040308a57d420849fd764ef53", "patch": "@@ -1,3 +1,12 @@\n+2019-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_aggr.adb (Rewrite_Bound): Be prepared for discriminals\n+\ttoo.\n+\t(Rewrite_Range;): Minor tweak.\n+\t(Resolve_Record_Aggregate): For a component with default\n+\tinitialization whose expression is an array aggregate, also\n+\trewrite the bounds of the component associations, if any.\n+\n 2019-07-22  Gary Dismukes  <dismukes@adacore.com>\n \n \t* exp_ch5.adb (Expand_N_Case_Statement): In the case where a"}, {"sha": "7aacc5ff50bdea55ac6612a372c2ce8a4c250e5c", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c26d262eb40998040308a57d420849fd764ef53/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c26d262eb40998040308a57d420849fd764ef53/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=2c26d262eb40998040308a57d420849fd764ef53", "patch": "@@ -4264,8 +4264,15 @@ package body Sem_Aggr is\n             Expr_Disc : Node_Id)\n          is\n          begin\n-            if Nkind (Bound) = N_Identifier\n-              and then Entity (Bound) = Disc\n+            if Nkind (Bound) /= N_Identifier then\n+               return;\n+            end if;\n+\n+            --  We expect either the discriminant or the discriminal\n+\n+            if Entity (Bound) = Disc\n+              or else (Ekind (Entity (Bound)) = E_In_Parameter\n+                        and then Discriminal_Link (Entity (Bound)) = Disc)\n             then\n                Rewrite (Bound, New_Copy_Tree (Expr_Disc));\n             end if;\n@@ -4280,9 +4287,7 @@ package body Sem_Aggr is\n       --  Start of processing for Rewrite_Range\n \n       begin\n-         if Has_Discriminants (Root_Type)\n-           and then Nkind (Rge) = N_Range\n-         then\n+         if Has_Discriminants (Root_Type) and then Nkind (Rge) = N_Range then\n             Low := Low_Bound (Rge);\n             High := High_Bound (Rge);\n \n@@ -4903,7 +4908,9 @@ package body Sem_Aggr is\n                         --  Root record type whose discriminants may be used as\n                         --  bounds in range nodes.\n \n-                        Index : Node_Id;\n+                        Assoc  : Node_Id;\n+                        Choice : Node_Id;\n+                        Index  : Node_Id;\n \n                      begin\n                         --  Rewrite the range nodes occurring in the indexes\n@@ -4919,12 +4926,26 @@ package body Sem_Aggr is\n                         end loop;\n \n                         --  Rewrite the range nodes occurring as aggregate\n-                        --  bounds.\n+                        --  bounds and component associations.\n \n-                        if Nkind (Expr) = N_Aggregate\n-                          and then Present (Aggregate_Bounds (Expr))\n-                        then\n-                           Rewrite_Range (Rec_Typ, Aggregate_Bounds (Expr));\n+                        if Nkind (Expr) = N_Aggregate then\n+                           if Present (Aggregate_Bounds (Expr)) then\n+                              Rewrite_Range (Rec_Typ, Aggregate_Bounds (Expr));\n+                           end if;\n+\n+                           if Present (Component_Associations (Expr)) then\n+                              Assoc := First (Component_Associations (Expr));\n+                              while Present (Assoc) loop\n+                                 Choice := First (Choices (Assoc));\n+                                 while Present (Choice) loop\n+                                    Rewrite_Range (Rec_Typ, Choice);\n+\n+                                    Next (Choice);\n+                                 end loop;\n+\n+                                 Next (Assoc);\n+                              end loop;\n+                           end if;\n                         end if;\n                      end;\n                   end if;"}]}