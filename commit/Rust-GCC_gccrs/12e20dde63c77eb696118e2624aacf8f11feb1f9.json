{"sha": "12e20dde63c77eb696118e2624aacf8f11feb1f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJlMjBkZGU2M2M3N2ViNjk2MTE4ZTI2MjRhYWNmOGYxMWZlYjFmOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:21:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:21:23Z"}, "message": "Remove global call sets: reload.c\n\nThe inheritance code in find_equiv_reg can use clobbers_reg_p\nto test whether a call clobbers either of the equivalent registers.\n\nreload and find_reg use crtl->abi to test whether a register needs\nto be saved in the prologue before use.\n\nreload_as_needed can use full_and_partial_reg_clobbers and thus\navoid needing to keep its own record of which registers are part\ncall-clobbered.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* reload.c: Include function-abi.h.\n\t(find_equiv_reg): Use clobbers_reg_p to test whether either\n\tof the equivalent registers is clobbered by a call.\n\t* reload1.c: Include function-abi.h.\n\t(reg_reloaded_call_part_clobbered): Delete.\n\t(reload): Use crtl->abi to test which registers would need\n\tsaving in the prologue before use.\n\t(find_reg): Likewise.\n\t(emit_reload_insns): Remove code for reg_reloaded_call_part_clobbered.\n\t(reload_as_needed): Likewise.  Use full_and_partial_reg_clobbers\n\tinstead of call_used_or_fixed_regs | reg_reloaded_call_part_clobbered.\n\nFrom-SVN: r276333", "tree": {"sha": "baf1093742a2c8d72ba9e0becb9df4f9ce65a9bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baf1093742a2c8d72ba9e0becb9df4f9ce65a9bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12e20dde63c77eb696118e2624aacf8f11feb1f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e20dde63c77eb696118e2624aacf8f11feb1f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12e20dde63c77eb696118e2624aacf8f11feb1f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e20dde63c77eb696118e2624aacf8f11feb1f9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ce77f463d1d150e70a91807502d628492ca7ae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ce77f463d1d150e70a91807502d628492ca7ae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ce77f463d1d150e70a91807502d628492ca7ae5"}], "stats": {"total": 76, "additions": 30, "deletions": 46}, "files": [{"sha": "3887c43f1ffac623ca76dbf2f06c2d6fd81b816f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e20dde63c77eb696118e2624aacf8f11feb1f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e20dde63c77eb696118e2624aacf8f11feb1f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12e20dde63c77eb696118e2624aacf8f11feb1f9", "patch": "@@ -1,3 +1,17 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* reload.c: Include function-abi.h.\n+\t(find_equiv_reg): Use clobbers_reg_p to test whether either\n+\tof the equivalent registers is clobbered by a call.\n+\t* reload1.c: Include function-abi.h.\n+\t(reg_reloaded_call_part_clobbered): Delete.\n+\t(reload): Use crtl->abi to test which registers would need\n+\tsaving in the prologue before use.\n+\t(find_reg): Likewise.\n+\t(emit_reload_insns): Remove code for reg_reloaded_call_part_clobbered.\n+\t(reload_as_needed): Likewise.  Use full_and_partial_reg_clobbers\n+\tinstead of call_used_or_fixed_regs | reg_reloaded_call_part_clobbered.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* regrename.h (du_head::call_clobber_mask): New field."}, {"sha": "8582b4840ae03ad3889696772523def3d4c469da", "filename": "gcc/reload.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e20dde63c77eb696118e2624aacf8f11feb1f9/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e20dde63c77eb696118e2624aacf8f11feb1f9/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=12e20dde63c77eb696118e2624aacf8f11feb1f9", "patch": "@@ -106,6 +106,7 @@ a register with any other reload.  */\n #include \"reload.h\"\n #include \"addresses.h\"\n #include \"params.h\"\n+#include \"function-abi.h\"\n \n /* True if X is a constant that can be forced into the constant pool.\n    MODE is the mode of the operand, or VOIDmode if not known.  */\n@@ -6904,24 +6905,19 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t if either of the two is in a call-clobbered register, or memory.  */\n       if (CALL_P (p))\n \t{\n-\t  int i;\n-\n \t  if (goal_mem || need_stable_sp)\n \t    return 0;\n \n-\t  if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER)\n-\t    for (i = 0; i < nregs; ++i)\n-\t      if (call_used_or_fixed_reg_p (regno + i)\n-\t\t  || targetm.hard_regno_call_part_clobbered (0, regno + i,\n-\t\t\t\t\t\t\t     mode))\n-\t\treturn 0;\n+\t  function_abi callee_abi = insn_callee_abi (p);\n+\t  if (regno >= 0\n+\t      && regno < FIRST_PSEUDO_REGISTER\n+\t      && callee_abi.clobbers_reg_p (mode, regno))\n+\t    return 0;\n \n-\t  if (valueno >= 0 && valueno < FIRST_PSEUDO_REGISTER)\n-\t    for (i = 0; i < valuenregs; ++i)\n-\t      if (call_used_or_fixed_reg_p (valueno + i)\n-\t\t  || targetm.hard_regno_call_part_clobbered (0, valueno + i,\n-\t\t\t\t\t\t\t     mode))\n-\t\treturn 0;\n+\t  if (valueno >= 0\n+\t      && valueno < FIRST_PSEUDO_REGISTER\n+\t      && callee_abi.clobbers_reg_p (mode, valueno))\n+\t    return 0;\n \t}\n \n       if (INSN_P (p))"}, {"sha": "79a7ff6eb93d87635aa217dfc04a0a130d57a3b3", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12e20dde63c77eb696118e2624aacf8f11feb1f9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12e20dde63c77eb696118e2624aacf8f11feb1f9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=12e20dde63c77eb696118e2624aacf8f11feb1f9", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"except.h\"\n #include \"dumpfile.h\"\n #include \"rtl-iter.h\"\n+#include \"function-abi.h\"\n \n /* This file contains the reload pass of the compiler, which is\n    run after register allocation has been done.  It checks that\n@@ -120,11 +121,6 @@ static HARD_REG_SET reg_reloaded_valid;\n    This is only valid if reg_reloaded_contents is set and valid.  */\n static HARD_REG_SET reg_reloaded_dead;\n \n-/* Indicate whether the register's current value is one that is not\n-   safe to retain across a call, even for registers that are normally\n-   call-saved.  This is only meaningful for members of reg_reloaded_valid.  */\n-static HARD_REG_SET reg_reloaded_call_part_clobbered;\n-\n /* Number of spill-regs so far; number of valid elements of spill_regs.  */\n static int n_spills;\n \n@@ -795,7 +791,7 @@ reload (rtx_insn *first, int global)\n \n   if (crtl->saves_all_registers)\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      if (! call_used_or_fixed_reg_p (i)\n+      if (! crtl->abi->clobbers_full_reg_p (i)\n \t  && ! fixed_regs[i]\n \t  && ! LOCAL_REGNO (i))\n \tdf_set_regs_ever_live (i, true);\n@@ -1908,8 +1904,8 @@ find_reg (class insn_chain *chain, int order)\n \t\t  && (inv_reg_alloc_order[regno]\n \t\t      < inv_reg_alloc_order[best_reg])\n #else\n-\t\t  && call_used_or_fixed_reg_p (regno)\n-\t\t  && ! call_used_or_fixed_reg_p (best_reg)\n+\t\t  && crtl->abi->clobbers_full_reg_p (regno)\n+\t\t  && !crtl->abi->clobbers_full_reg_p (best_reg)\n #endif\n \t\t  ))\n \t    {\n@@ -4464,7 +4460,6 @@ reload_as_needed (int live_known)\n   reg_last_reload_reg = XCNEWVEC (rtx, max_regno);\n   INIT_REG_SET (&reg_has_output_reload);\n   CLEAR_HARD_REG_SET (reg_reloaded_valid);\n-  CLEAR_HARD_REG_SET (reg_reloaded_call_part_clobbered);\n \n   set_initial_elim_offsets ();\n \n@@ -4786,8 +4781,8 @@ reload_as_needed (int live_known)\n          be partially clobbered by the call.  */\n       else if (CALL_P (insn))\n \t{\n-\t  reg_reloaded_valid &= ~(call_used_or_fixed_regs\n-\t\t\t\t  | reg_reloaded_call_part_clobbered);\n+\t  reg_reloaded_valid\n+\t    &= ~insn_callee_abi (insn).full_and_partial_reg_clobbers ();\n \n \t  /* If this is a call to a setjmp-type function, we must not\n \t     reuse any reload reg contents across the call; that will\n@@ -8193,13 +8188,6 @@ emit_reload_insns (class insn_chain *chain)\n \t\t\t   : out_regno + k);\n \t\t      reg_reloaded_insn[regno + k] = insn;\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, regno + k);\n-\t\t      if (targetm.hard_regno_call_part_clobbered (0, regno + k,\n-\t\t\t\t\t\t\t\t  mode))\n-\t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n-\t\t\t\t\t  regno + k);\n-\t\t      else\n-\t\t\tCLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n-\t\t\t\t\t    regno + k);\n \t\t    }\n \t\t}\n \t    }\n@@ -8273,13 +8261,6 @@ emit_reload_insns (class insn_chain *chain)\n \t\t\t   : in_regno + k);\n \t\t      reg_reloaded_insn[regno + k] = insn;\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, regno + k);\n-\t\t      if (targetm.hard_regno_call_part_clobbered (0, regno + k,\n-\t\t\t\t\t\t\t\t  mode))\n-\t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n-\t\t\t\t\t  regno + k);\n-\t\t      else\n-\t\t\tCLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n-\t\t\t\t\t    regno + k);\n \t\t    }\n \t\t}\n \t    }\n@@ -8388,13 +8369,6 @@ emit_reload_insns (class insn_chain *chain)\n \t\t      reg_reloaded_insn[src_regno + k] = store_insn;\n \t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, src_regno + k);\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, src_regno + k);\n-\t\t      if (targetm.hard_regno_call_part_clobbered\n-\t\t\t  (0, src_regno + k, mode))\n-\t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n-\t\t\t\t\t  src_regno + k);\n-\t\t      else\n-\t\t\tCLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n-\t\t\t\t\t    src_regno + k);\n \t\t      SET_HARD_REG_BIT (reg_is_output_reload, src_regno + k);\n \t\t      if (note)\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_died, src_regno);"}]}