{"sha": "e3d616e3da1033aa9417bebf8005854cc4621d63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNkNjE2ZTNkYTEwMzNhYTk0MTdiZWJmODAwNTg1NGNjNDYyMWQ2Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-31T11:27:31Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-31T11:27:31Z"}, "message": "(force_to_mode): Add new parm JUST_SELECT; all callers changed.\n\nFrom-SVN: r6342", "tree": {"sha": "6e2f13fd5d19a3e356f55a1d17f9267f392c3afc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e2f13fd5d19a3e356f55a1d17f9267f392c3afc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3d616e3da1033aa9417bebf8005854cc4621d63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d616e3da1033aa9417bebf8005854cc4621d63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3d616e3da1033aa9417bebf8005854cc4621d63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d616e3da1033aa9417bebf8005854cc4621d63/comments", "author": null, "committer": null, "parents": [{"sha": "996c63d336382840179a82483595e6cb12b8819f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996c63d336382840179a82483595e6cb12b8819f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/996c63d336382840179a82483595e6cb12b8819f"}], "stats": {"total": 77, "additions": 44, "deletions": 33}, "files": [{"sha": "e75010faaef9b376597f3d976f99f3e1ec50ff1d", "filename": "gcc/combine.c", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3d616e3da1033aa9417bebf8005854cc4621d63/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3d616e3da1033aa9417bebf8005854cc4621d63/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=e3d616e3da1033aa9417bebf8005854cc4621d63", "patch": "@@ -376,7 +376,7 @@ static rtx make_extraction\tPROTO((enum machine_mode, rtx, int, rtx, int,\n static rtx make_compound_operation  PROTO((rtx, enum rtx_code));\n static int get_pos_from_mask\tPROTO((unsigned HOST_WIDE_INT, int *));\n static rtx force_to_mode\tPROTO((rtx, enum machine_mode,\n-\t\t\t\t       unsigned HOST_WIDE_INT, rtx));\n+\t\t\t\t       unsigned HOST_WIDE_INT, rtx, int));\n static rtx known_cond\t\tPROTO((rtx, enum rtx_code, rtx, rtx));\n static rtx make_field_assignment  PROTO((rtx));\n static rtx apply_distributive_law  PROTO((rtx));\n@@ -3203,7 +3203,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t  && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n \t  && subreg_lowpart_p (x))\n \treturn force_to_mode (SUBREG_REG (x), mode, GET_MODE_MASK (mode),\n-\t\t\t      NULL_RTX);\n+\t\t\t      NULL_RTX, 0);\n       break;\n \n     case NOT:\n@@ -4710,7 +4710,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t\t      ((HOST_WIDE_INT) 1 \n \t\t\t       << exact_log2 (GET_MODE_BITSIZE (GET_MODE (x))))\n \t\t\t      - 1,\n-\t\t\t      NULL_RTX));\n+\t\t\t      NULL_RTX, 0));\n #endif\n \n       break;\n@@ -5090,7 +5090,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t\t\t     len >= HOST_BITS_PER_WIDE_INT\n \t\t\t     ? GET_MODE_MASK (tmode)\n \t\t\t     : ((HOST_WIDE_INT) 1 << len) - 1,\n-\t\t\t     NULL_RTX);\n+\t\t\t     NULL_RTX, 0);\n \n       /* If this extraction is going into the destination of a SET, \n \t make a STRICT_LOW_PART unless we made a MEM.  */\n@@ -5234,7 +5234,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t\t\t   pos_rtx || len + orig_pos >= HOST_BITS_PER_WIDE_INT\n \t\t\t   ? GET_MODE_MASK (extraction_mode)\n \t\t\t   : (((HOST_WIDE_INT) 1 << len) - 1) << orig_pos,\n-\t\t\t   NULL_RTX);\n+\t\t\t   NULL_RTX, 0);\n \n   /* Adjust mode of POS_RTX, if needed.  If we want a wider mode, we\n      have to zero extend.  Otherwise, we can just use a SUBREG.  */\n@@ -5533,7 +5533,7 @@ make_compound_operation (x, in_code)\n \t  && subreg_lowpart_p (x))\n \t{\n \t  rtx newer = force_to_mode (tem, mode,\n-\t\t\t\t     GET_MODE_MASK (mode), NULL_RTX);\n+\t\t\t\t     GET_MODE_MASK (mode), NULL_RTX, 0);\n \n \t  /* If we have something other than a SUBREG, we might have\n \t     done an expansion, so rerun outselves.  */\n@@ -5600,16 +5600,22 @@ get_pos_from_mask (m, plen)\n    MODE.  If X is a CONST_INT, AND the CONST_INT with MASK.\n \n    Also, if REG is non-zero and X is a register equal in value to REG, \n-   replace X with REG.  */\n+   replace X with REG.\n+\n+   If JUST_SELECT is nonzero, don't optimize by noticing that bits in MASK\n+   are all off in X.  This is used when X will be complemented, by either\n+   NOT or XOR.  */\n \n static rtx\n-force_to_mode (x, mode, mask, reg)\n+force_to_mode (x, mode, mask, reg, just_select)\n      rtx x;\n      enum machine_mode mode;\n      unsigned HOST_WIDE_INT mask;\n      rtx reg;\n+     int just_select;\n {\n   enum rtx_code code = GET_CODE (x);\n+  int next_select = just_select || code == XOR || code == NOT;\n   enum machine_mode op_mode;\n   unsigned HOST_WIDE_INT fuller_mask, nonzero;\n   rtx op0, op1, temp;\n@@ -5621,6 +5627,7 @@ force_to_mode (x, mode, mask, reg)\n \t      && (code_to_optab[(int) code]->handlers[(int) mode].insn_code\n \t\t  != CODE_FOR_nothing))\n \t     ? mode : GET_MODE (x));\n+\n   /* It is not valid to do a right-shift in a narrower mode\n      than the one it came in with.  */\n   if ((code == LSHIFTRT || code == ASHIFTRT)\n@@ -5645,7 +5652,7 @@ force_to_mode (x, mode, mask, reg)\n   nonzero = nonzero_bits (x, mode);\n \n   /* If none of the bits in X are needed, return a zero.  */\n-  if ((nonzero & mask) == 0)\n+  if (! just_select && (nonzero & mask) == 0)\n     return const0_rtx;\n \n   /* If X is a CONST_INT, return a new one.  Do this here since the\n@@ -5686,7 +5693,7 @@ force_to_mode (x, mode, mask, reg)\n \t spanned the boundary of the MEM.  If we are now masking so it is\n \t within that boundary, we don't need the USE any more.  */\n       if ((mask & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n-\treturn force_to_mode (XEXP (x, 0), mode, mask, reg);\n+\treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n #endif\n \n     case SIGN_EXTEND:\n@@ -5695,7 +5702,7 @@ force_to_mode (x, mode, mask, reg)\n     case SIGN_EXTRACT:\n       x = expand_compound_operation (x);\n       if (GET_CODE (x) != code)\n-\treturn force_to_mode (x, mode, mask, reg);\n+\treturn force_to_mode (x, mode, mask, reg, next_select);\n       break;\n \n     case REG:\n@@ -5718,7 +5725,7 @@ force_to_mode (x, mode, mask, reg)\n \t\t\t& ~ GET_MODE_MASK (GET_MODE (SUBREG_REG (x)))))\n #endif\n \t      ))\n-\treturn force_to_mode (SUBREG_REG (x), mode, mask, reg);\n+\treturn force_to_mode (SUBREG_REG (x), mode, mask, reg, next_select);\n       break;\n \n     case AND:\n@@ -5756,7 +5763,7 @@ force_to_mode (x, mode, mask, reg)\n \t  && (INTVAL (XEXP (x, 1)) & ~ mask) != 0)\n \treturn force_to_mode (plus_constant (XEXP (x, 0),\n \t\t\t\t\t     INTVAL (XEXP (x, 1)) & mask),\n-\t\t\t      mode, mask, reg);\n+\t\t\t      mode, mask, reg, next_select);\n \n       /* ... fall through ... */\n \n@@ -5791,17 +5798,19 @@ force_to_mode (x, mode, mask, reg)\n \t  temp = gen_binary (GET_CODE (x), GET_MODE (x),\n \t\t\t     XEXP (XEXP (x, 0), 0), temp);\n \t  x = gen_binary (LSHIFTRT, GET_MODE (x), temp, XEXP (x, 1));\n-\t  return force_to_mode (x, mode, mask, reg);\n+\t  return force_to_mode (x, mode, mask, reg, next_select);\n \t}\n \n     binop:\n       /* For most binary operations, just propagate into the operation and\n \t change the mode if we have an operation of that mode.   */\n \n-      op0 = gen_lowpart_for_combine (op_mode, force_to_mode (XEXP (x, 0),\n-\t\t\t\t\t\t\t     mode, mask, reg));\n-      op1 = gen_lowpart_for_combine (op_mode, force_to_mode (XEXP (x, 1),\n-\t\t\t\t\t\t\t     mode, mask, reg));\n+      op0 = gen_lowpart_for_combine (op_mode,\n+\t\t\t\t     force_to_mode (XEXP (x, 0), mode, mask,\n+\t\t\t\t\t\t    reg, next_select));\n+      op1 = gen_lowpart_for_combine (op_mode,\n+\t\t\t\t     force_to_mode (XEXP (x, 1), mode, mask,\n+\t\t\t\t\t\t    reg, next_select));\n \n       /* If OP1 is a CONST_INT and X is an IOR or XOR, clear bits outside\n \t MASK since OP1 might have been sign-extended but we never want\n@@ -5844,7 +5853,7 @@ force_to_mode (x, mode, mask, reg)\n \n       op0 = gen_lowpart_for_combine (op_mode,\n \t\t\t\t     force_to_mode (XEXP (x, 0), op_mode,\n-\t\t\t\t\t\t    mask, reg));\n+\t\t\t\t\t\t    mask, reg, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n \tx =  gen_binary (code, op_mode, op0, XEXP (x, 1));\n@@ -5871,7 +5880,7 @@ force_to_mode (x, mode, mask, reg)\n \t      || (mask & ~ GET_MODE_MASK (op_mode)) != 0)\n \t    op_mode = GET_MODE (x);\n \n-\t  inner = force_to_mode (inner, op_mode, mask, reg);\n+\t  inner = force_to_mode (inner, op_mode, mask, reg, next_select);\n \n \t  if (GET_MODE (x) != op_mode || inner != XEXP (x, 0))\n \t    x = gen_binary (LSHIFTRT, op_mode, inner, XEXP (x, 1));\n@@ -5899,7 +5908,7 @@ force_to_mode (x, mode, mask, reg)\n \t all, even if it has a variable count.  */\n       if (mask == ((HOST_WIDE_INT) 1\n \t\t   << (GET_MODE_BITSIZE (GET_MODE (x)) - 1)))\n-\treturn force_to_mode (XEXP (x, 0), mode, mask, reg);\n+\treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n \n       /* If this is a shift by a constant, get a mask that contains those bits\n \t that are not copies of the sign bit.  We then have two cases:  If\n@@ -5925,7 +5934,7 @@ force_to_mode (x, mode, mask, reg)\n \t\t : GET_MODE_BITSIZE (GET_MODE (x)) - 1 - i);\n \n \t      if (GET_CODE (x) != ASHIFTRT)\n-\t\treturn force_to_mode (x, mode, mask, reg);\n+\t\treturn force_to_mode (x, mode, mask, reg, next_select);\n \t    }\n \t}\n \n@@ -5946,7 +5955,8 @@ force_to_mode (x, mode, mask, reg)\n \t  && GET_CODE (XEXP (x, 0)) == ASHIFT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t  && INTVAL (XEXP (XEXP (x, 0), 1)) == INTVAL (XEXP (x, 1)))\n-\treturn force_to_mode (XEXP (XEXP (x, 0), 0), mode, mask, reg);\n+\treturn force_to_mode (XEXP (XEXP (x, 0), 0), mode, mask,\n+\t\t\t      reg, next_select);\n \n       break;\n \n@@ -5965,7 +5975,7 @@ force_to_mode (x, mode, mask, reg)\n \t  if (temp)\n \t    SUBST (XEXP (x, 0),\n \t\t   force_to_mode (XEXP (x, 0), GET_MODE (x),\n-\t\t\t\t  INTVAL (temp), reg));\n+\t\t\t\t  INTVAL (temp), reg, next_select));\n \t}\n       break;\n \t\n@@ -5992,12 +6002,13 @@ force_to_mode (x, mode, mask, reg)\n \t  temp = gen_binary (XOR, GET_MODE (x), XEXP (XEXP (x, 0), 0), temp);\n \t  x = gen_binary (LSHIFTRT, GET_MODE (x), temp, XEXP (XEXP (x, 0), 1));\n \n-\t  return force_to_mode (x, mode, mask, reg);\n+\t  return force_to_mode (x, mode, mask, reg, next_select);\n \t}\n \n     unop:\n-      op0 = gen_lowpart_for_combine (op_mode, force_to_mode (XEXP (x, 0), mode,\n-\t\t\t\t\t\t\t     mask, reg));\n+      op0 = gen_lowpart_for_combine (op_mode,\n+\t\t\t\t     force_to_mode (XEXP (x, 0), mode, mask,\n+\t\t\t\t\t\t    reg, next_select));\n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n \tx = gen_unary (code, op_mode, op0);\n       break;\n@@ -6008,7 +6019,7 @@ force_to_mode (x, mode, mask, reg)\n \t in CONST.  */\n       if ((mask & ~ STORE_FLAG_VALUE) == 0 && XEXP (x, 0) == const0_rtx\n \t  && (nonzero_bits (XEXP (x, 0), mode) & ~ mask) == 0)\n-\treturn force_to_mode (XEXP (x, 0), mode, mask, reg);\n+\treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n \n       break;\n \n@@ -6019,11 +6030,11 @@ force_to_mode (x, mode, mask, reg)\n       SUBST (XEXP (x, 1),\n \t     gen_lowpart_for_combine (GET_MODE (x),\n \t\t\t\t      force_to_mode (XEXP (x, 1), mode,\n-\t\t\t\t\t\t     mask, reg)));\n+\t\t\t\t\t\t     mask, reg, next_select)));\n       SUBST (XEXP (x, 2),\n \t     gen_lowpart_for_combine (GET_MODE (x),\n \t\t\t\t      force_to_mode (XEXP (x, 2), mode,\n-\t\t\t\t\t\t     mask, reg)));\n+\t\t\t\t\t\t     mask, reg,next_select)));\n       break;\n     }\n \n@@ -6231,7 +6242,7 @@ make_field_assignment (x)\n \t\t       GET_MODE_BITSIZE (mode) >= HOST_BITS_PER_WIDE_INT\n \t\t       ? GET_MODE_MASK (mode)\n \t\t       : ((HOST_WIDE_INT) 1 << len) - 1,\n-\t\t       dest);\n+\t\t       dest, 0);\n \n   return gen_rtx_combine (SET, VOIDmode, assign, src);\n }\n@@ -6380,7 +6391,7 @@ simplify_and_const_int (x, mode, varop, constop)\n \n   /* Simplify VAROP knowing that we will be only looking at some of the\n      bits in it.  */\n-  varop = force_to_mode (varop, mode, constop, NULL_RTX);\n+  varop = force_to_mode (varop, mode, constop, NULL_RTX, 0);\n \n   /* If VAROP is a CLOBBER, we will fail so return it; if it is a\n      CONST_INT, we are done.  */\n@@ -8577,7 +8588,7 @@ simplify_comparison (code, pop0, pop1)\n \top0 = force_to_mode (op0, mode,\n \t\t\t     ((HOST_WIDE_INT) 1\n \t\t\t      << (GET_MODE_BITSIZE (mode) - 1)),\n-\t\t\t     NULL_RTX);\n+\t\t\t     NULL_RTX, 0);\n \n       /* Now try cases based on the opcode of OP0.  If none of the cases\n \t does a \"continue\", we exit this loop immediately after the"}]}