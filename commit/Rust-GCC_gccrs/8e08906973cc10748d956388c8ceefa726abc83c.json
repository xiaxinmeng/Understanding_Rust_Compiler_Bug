{"sha": "8e08906973cc10748d956388c8ceefa726abc83c", "node_id": "C_kwDOANBUbNoAKDhlMDg5MDY5NzNjYzEwNzQ4ZDk1NjM4OGM4Y2VlZmE3MjZhYmM4M2M", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-26T06:50:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-26T10:59:05Z"}, "message": "Remove uninit_analysis::use_cannot_happen\n\nAs written earlier uninit_analysis::use_cannot_happen is duplicate\nfunctionality implemented in a complement way, not adhering to\nthe idea of disproving a may-uninit use and eventually (I have not\nyet found a testcase it helps to avoid false positives) avoiding\nfalse positives because of this or different ways it imposes limits\non the predicate computations.\n\nThis patch removes it.\n\n\t* gimple-predicate-analysis.h\n\t(uninit_analysis::use_cannot_happen): Remove.\n\t* gimple-predicate-analysis.cc (can_be_invalidated_p): Remove.\n\t(uninit_analysis::use_cannot_happen): Likewise.\n\t(uninit_analysis::is_use_guarded): Do not call\n\tuse_cannot_happen.\n\t(dump_predicates): Remove.\n\t(simple_control_dep_chain): Remove edge overload.", "tree": {"sha": "2d7964057b6b1f5fee0911bc5d7ad15fdb29a2ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d7964057b6b1f5fee0911bc5d7ad15fdb29a2ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e08906973cc10748d956388c8ceefa726abc83c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e08906973cc10748d956388c8ceefa726abc83c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e08906973cc10748d956388c8ceefa726abc83c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e08906973cc10748d956388c8ceefa726abc83c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc1b5707faf0b607da06e9ec3437245aba69a255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc1b5707faf0b607da06e9ec3437245aba69a255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc1b5707faf0b607da06e9ec3437245aba69a255"}], "stats": {"total": 213, "additions": 0, "deletions": 213}, "files": [{"sha": "32542f93057142b3a59f11cd127ff0452edc1292", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08906973cc10748d956388c8ceefa726abc83c/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08906973cc10748d956388c8ceefa726abc83c/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=8e08906973cc10748d956388c8ceefa726abc83c", "patch": "@@ -209,32 +209,6 @@ dump_pred_chain (const pred_chain &chain)\n     }\n }\n \n-/* Dump the predicate chain PREDS for STMT, prefixed by MSG.  */\n-\n-static void\n-dump_predicates (gimple *stmt, const pred_chain_union &preds, const char *msg)\n-{\n-  fprintf (dump_file, \"%s\", msg);\n-  if (stmt)\n-    {\n-      print_gimple_stmt (dump_file, stmt, 0);\n-      fprintf (dump_file, \"is guarded by:\\n\");\n-    }\n-\n-  unsigned np = preds.length ();\n-  if (np > 1)\n-    fprintf (dump_file, \"OR (\");\n-  for (unsigned i = 0; i < np; i++)\n-    {\n-      dump_pred_chain (preds[i]);\n-      if (i < np - 1)\n-\tfprintf (dump_file, \", \");\n-      else if (i > 0)\n-\tfputc (')', dump_file);\n-    }\n-  fputc ('\\n', dump_file);\n-}\n-\n /* Dump the first NCHAINS elements of the DEP_CHAINS array into DUMP_FILE.  */\n \n static void\n@@ -1071,13 +1045,6 @@ simple_control_dep_chain (vec<edge>& chain, basic_block from, basic_block to)\n     }\n }\n \n-static void\n-simple_control_dep_chain (vec<edge>& chain, basic_block from, edge to)\n-{\n-  chain.safe_push (to);\n-  simple_control_dep_chain (chain, from, to->src);\n-}\n-\n /* Perform a DFS walk on predecessor edges to mark the region denoted\n    by the EXIT edge and DOM which dominates EXIT->src, including DOM.\n    Blocks in the region are marked with FLAG and added to BBS.  BBS is\n@@ -1242,180 +1209,6 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n   return found_cd_chain;\n }\n \n-/* Return true if PRED can be invalidated by any predicate in GUARD.  */\n-\n-static bool\n-can_be_invalidated_p (const pred_info &pred, const pred_chain &guard)\n-{\n-  if (dump_file && dump_flags & TDF_DETAILS)\n-    {\n-      fprintf (dump_file, \"Testing if predicate: \");\n-      dump_pred_info (pred);\n-      fprintf (dump_file, \"\\n...can be invalidated by a USE guard of: \");\n-      dump_pred_chain (guard);\n-      fputc ('\\n', dump_file);\n-    }\n-\n-  unsigned n = guard.length ();\n-  for (unsigned i = 0; i < n; ++i)\n-    {\n-      if (pred_neg_p (pred, guard[i]))\n-\t{\n-\t  if (dump_file && dump_flags & TDF_DETAILS)\n-\t    {\n-\t      fprintf (dump_file, \"  Predicate invalidated by: \");\n-\t      dump_pred_info (guard[i]);\n-\t      fputc ('\\n', dump_file);\n-\t    }\n-\t  return true;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n-/* Return true if all predicates in PREDS are invalidated by GUARD being\n-   true.  */\n-\n-static bool\n-can_be_invalidated_p (const pred_chain_union &preds, const pred_chain &guard)\n-{\n-  if (preds.is_empty ())\n-    return false;\n-\n-  if (dump_file && dump_flags & TDF_DETAILS)\n-    dump_predicates (NULL, preds,\n-\t\t     \"Testing if anything here can be invalidated: \");\n-\n-  for (unsigned i = 0; i < preds.length (); ++i)\n-    {\n-      const pred_chain &chain = preds[i];\n-      unsigned j;\n-      for (j = 0; j < chain.length (); ++j)\n-\tif (can_be_invalidated_p (chain[j], guard))\n-\t  break;\n-\n-      /* If we were unable to invalidate any predicate in C, then there\n-\t is a viable path from entry to the PHI where the PHI takes\n-\t an interesting value and continues to a use of the PHI.  */\n-      if (j == chain.length ())\n-\treturn false;\n-    }\n-  return true;\n-}\n-\n-/* Return true if none of the PHI arguments in OPNDS is used given\n-   the use guards in *THIS that guard the PHI's use.  */\n-\n-bool\n-uninit_analysis::use_cannot_happen (gphi *phi, unsigned opnds, const predicate &use_preds)\n-{\n-  if (!m_eval.phi_arg_set (phi))\n-    return false;\n-\n-  /* PHI_USE_GUARDS are OR'ed together.  If we have more than one\n-     possible guard, there's no way of knowing which guard was true.\n-     In that case compute the intersection of all use predicates\n-     and use that.  */\n-  const predicate &phi_use_guards = use_preds;\n-  const pred_chain *use_guard = &phi_use_guards.chain() [0];\n-  pred_chain phi_use_guard_intersection = vNULL;\n-  if (phi_use_guards.chain ().length () != 1)\n-    {\n-      phi_use_guard_intersection = use_guard->copy ();\n-      for (unsigned i = 1; i < phi_use_guards.chain ().length (); ++i)\n-\t{\n-\t  for (unsigned j = 0; j < phi_use_guard_intersection.length ();)\n-\t    {\n-\t      unsigned k;\n-\t      for (k = 0; k < phi_use_guards.chain ()[i].length (); ++k)\n-\t\tif (pred_equal_p (phi_use_guards.chain ()[i][k],\n-\t\t\t\t  phi_use_guard_intersection[j]))\n-\t\t  break;\n-\t      if (k == phi_use_guards.chain ()[i].length ())\n-\t\tphi_use_guard_intersection.unordered_remove (j);\n-\t      else\n-\t\tj++;\n-\t    }\n-\t}\n-      if (phi_use_guard_intersection.is_empty ())\n-\t{\n-\t  phi_use_guard_intersection.release ();\n-\t  return false;\n-\t}\n-      use_guard = &phi_use_guard_intersection;\n-    }\n-\n-  basic_block phi_bb = gimple_bb (phi);\n-  /* Find the closest dominating bb to be the control dependence root.  */\n-  basic_block cd_root = get_immediate_dominator (CDI_DOMINATORS, phi_bb);\n-  if (!cd_root)\n-    return false;\n-\n-  /* Look for the control dependencies of all the interesting operands\n-     and build guard predicates describing them.  */\n-  unsigned n = gimple_phi_num_args (phi);\n-  for (unsigned i = 0; i < n; ++i)\n-    {\n-      if (!MASK_TEST_BIT (opnds, i))\n-\tcontinue;\n-\n-      edge e = gimple_phi_arg_edge (phi, i);\n-      auto_vec<edge> dep_chains[MAX_NUM_CHAINS];\n-      auto_vec<edge, MAX_CHAIN_LEN + 1> cur_chain;\n-      unsigned num_chains = 0;\n-      unsigned num_calls = 0;\n-\n-      /* Build the control dependency chain for the PHI argument...  */\n-      if (!compute_control_dep_chain (cd_root,\n-\t\t\t\t      e->src, dep_chains, &num_chains,\n-\t\t\t\t      cur_chain, &num_calls))\n-\t{\n-\t  gcc_assert (num_chains == 0);\n-\t  /* If compute_control_dep_chain bailed out due to limits\n-\t     build a partial sparse path using dominators.  Collect\n-\t     only edges whose predicates are always true when reaching E.  */\n-\t  simple_control_dep_chain (dep_chains[0], cd_root, e);\n-\t  num_chains++;\n-\t}\n-      /* Update the chains with the phi operand edge.  */\n-      else if (EDGE_COUNT (e->src->succs) > 1)\n-\t{\n-\t  for (unsigned j = 0; j < num_chains; j++)\n-\t    dep_chains[j].safe_push (e);\n-\t}\n-\n-      if (DEBUG_PREDICATE_ANALYZER && dump_file)\n-\t{\n-\t  fprintf (dump_file, \"predicate::use_cannot_happen (...) \"\n-\t\t   \"dep_chains for arg %u:\\n\\t\", i);\n-\t  dump_dep_chains (dep_chains, num_chains);\n-\t}\n-\n-      /* ...and convert it into a set of predicates guarding its\n-\t definition.  */\n-      predicate def_preds;\n-      def_preds.init_from_control_deps (dep_chains, num_chains);\n-      if (def_preds.is_empty ())\n-\t/* If there's no predicate there's no basis to rule the use out.  */\n-\treturn false;\n-\n-      def_preds.simplify ();\n-      def_preds.normalize ();\n-\n-      /* Can the guard for this PHI argument be negated by the one\n-\t guarding the PHI use?  */\n-      if (!can_be_invalidated_p (def_preds.chain (), *use_guard))\n-\t{\n-\t  phi_use_guard_intersection.release ();\n-\t  return false;\n-\t}\n-    }\n-\n-  phi_use_guard_intersection.release ();\n-  return true;\n-}\n-\n /* Implemented simplifications:\n \n    1) ((x IOR y) != 0) AND (x != 0) is equivalent to (x != 0);\n@@ -2391,11 +2184,6 @@ uninit_analysis::is_use_guarded (gimple *use_stmt, basic_block use_bb,\n       return true;\n     }\n \n-  /* We might be able to prove that if the control dependencies for OPNDS\n-     are true, the control dependencies for USE_STMT can never be true.  */\n-  if (use_cannot_happen (phi, opnds, use_preds))\n-    return true;\n-\n   if (m_phi_def_preds.is_empty ())\n     {\n       /* Lazily initialize *THIS from PHI.  */"}, {"sha": "1ca6ab1f7e4ed1e4884178bb9f2ca373ccc36037", "filename": "gcc/gimple-predicate-analysis.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08906973cc10748d956388c8ceefa726abc83c/gcc%2Fgimple-predicate-analysis.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08906973cc10748d956388c8ceefa726abc83c/gcc%2Fgimple-predicate-analysis.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.h?ref=8e08906973cc10748d956388c8ceefa726abc83c", "patch": "@@ -137,7 +137,6 @@ class uninit_analysis\n   bool prune_phi_opnds (gphi *, unsigned, gphi *, tree, tree_code,\n \t\t\thash_set<gphi *> *, bitmap *);\n   bool overlap (gphi *, unsigned, hash_set<gphi *> *, const predicate &);\n-  bool use_cannot_happen (gphi *, unsigned, const predicate &);\n \n   void collect_phi_def_edges (gphi *, basic_block, vec<edge> *,\n \t\t\t      hash_set<gimple *> *);"}]}