{"sha": "3631be4865f1942115b43d7f30a232a6cfb9c4b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYzMWJlNDg2NWYxOTQyMTE1YjQzZDdmMzBhMjMyYTZjZmI5YzRiOA==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2009-01-29T21:56:17Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2009-01-29T21:56:17Z"}, "message": "ira-color.c (allocno_reload_assign): Update comments.\n\n2009-01-29  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* ira-color.c (allocno_reload_assign): Update comments.\n\t* regmove.c (regmove_optimize): Likewise.\n\n\t* ra.h: Removed.\n\nFrom-SVN: r143771", "tree": {"sha": "ae23a15f908b61c3c9a4de1c5edd23ad47e4e47a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae23a15f908b61c3c9a4de1c5edd23ad47e4e47a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3631be4865f1942115b43d7f30a232a6cfb9c4b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3631be4865f1942115b43d7f30a232a6cfb9c4b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3631be4865f1942115b43d7f30a232a6cfb9c4b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3631be4865f1942115b43d7f30a232a6cfb9c4b8/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "416ac4d45b958aca5851655c91c70ba6742e9651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/416ac4d45b958aca5851655c91c70ba6742e9651", "html_url": "https://github.com/Rust-GCC/gccrs/commit/416ac4d45b958aca5851655c91c70ba6742e9651"}], "stats": {"total": 242, "additions": 8, "deletions": 234}, "files": [{"sha": "4c928fcb45f417af281c58b9906672189b20cfa6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3631be4865f1942115b43d7f30a232a6cfb9c4b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3631be4865f1942115b43d7f30a232a6cfb9c4b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3631be4865f1942115b43d7f30a232a6cfb9c4b8", "patch": "@@ -1,3 +1,10 @@\n+2009-01-29  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* ira-color.c (allocno_reload_assign): Update comments.\n+\t* regmove.c (regmove_optimize): Likewise.\n+\n+\t* ra.h: Removed.\n+\n 2009-01-29  Robert Millan  <rmh@aybabtu.com>\n \n \t* gcc/config.gcc: Recognize GNU/kOpenSolaris (*-*-kopensolaris*-gnu)."}, {"sha": "fac5cd8218017bd382b3aba7b76151789e3813ba", "filename": "gcc/ira-color.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3631be4865f1942115b43d7f30a232a6cfb9c4b8/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3631be4865f1942115b43d7f30a232a6cfb9c4b8/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=3631be4865f1942115b43d7f30a232a6cfb9c4b8", "patch": "@@ -2772,8 +2772,7 @@ ira_mark_memory_move_deletion (int dst_regno, int src_regno)\n }\n \n /* Try to assign a hard register (except for FORBIDDEN_REGS) to\n-   allocno A and return TRUE in the case of success.  That is an\n-   analog of retry_global_alloc for IRA.  */\n+   allocno A and return TRUE in the case of success.  */\n static bool\n allocno_reload_assign (ira_allocno_t a, HARD_REG_SET forbidden_regs)\n {"}, {"sha": "4fe80c8555b505907b5e45f0025db45280afef6f", "filename": "gcc/ra.h", "status": "removed", "additions": 0, "deletions": 231, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/416ac4d45b958aca5851655c91c70ba6742e9651/gcc%2Fra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/416ac4d45b958aca5851655c91c70ba6742e9651/gcc%2Fra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.h?ref=416ac4d45b958aca5851655c91c70ba6742e9651", "patch": "@@ -1,231 +0,0 @@\n-/* Define per-register tables for data flow info and register allocation.\n-   Copyright (C) 2007 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_RA_H\n-#define GCC_RA_H\n-\n-#include \"regs.h\"\n-\n-struct allocno\n-{\n-  int reg;\n-  /* Gives the number of consecutive hard registers needed by that\n-     pseudo reg.  */\n-  int size;\n-\n-  /* Number of calls crossed by each allocno.  */\n-  int calls_crossed;\n-\n-  /* Estimated frequency of crossing call by each allocno.  */\n-  int freq_calls_crossed;\n-\n-  /* Number of calls that might throw crossed by each allocno.  */\n-  int throwing_calls_crossed;\n-\n-  /* Number of refs to each allocno.  */\n-  int n_refs;\n-\n-  /* Frequency of uses of each allocno.  */\n-  int freq;\n-\n-  /* Guess at live length of each allocno.\n-     This is actually the max of the live lengths of the regs.  */\n-  int live_length;\n-\n-  /* Set of hard regs conflicting with allocno N.  */\n-\n-  HARD_REG_SET hard_reg_conflicts;\n-\n-  /* Set of hard regs preferred by allocno N.\n-     This is used to make allocnos go into regs that are copied to or from them,\n-     when possible, to reduce register shuffling.  */\n-\n-  HARD_REG_SET hard_reg_preferences;\n-\n-  /* Similar, but just counts register preferences made in simple copy\n-     operations, rather than arithmetic.  These are given priority because\n-     we can always eliminate an insn by using these, but using a register\n-     in the above list won't always eliminate an insn.  */\n-\n-  HARD_REG_SET hard_reg_copy_preferences;\n-\n-  /* Similar to hard_reg_preferences, but includes bits for subsequent\n-     registers when an allocno is multi-word.  The above variable is used for\n-     allocation while this is used to build reg_someone_prefers, below.  */\n-\n-  HARD_REG_SET hard_reg_full_preferences;\n-\n-  /* Set of hard registers that some later allocno has a preference for.  */\n-\n-  HARD_REG_SET regs_someone_prefers;\n-\n-#ifdef EH_RETURN_DATA_REGNO\n-  /* Set to true if allocno can't be allocated in an eh register.  */\n-  unsigned int no_eh_reg:1;\n-#endif\n-\n-#ifdef STACK_REGS\n-  /* Set to true if allocno can't be allocated in the stack register.  */\n-  unsigned int no_stack_reg:1;\n-#endif\n-};\n-extern struct allocno *allocno;\n-\n-/* In ra-conflict.c  */\n-\n-/* Number of pseudo-registers which are candidates for allocation.  */\n-\n-extern int max_allocno;\n-\n-/* max_allocno by max_allocno compressed triangular bit matrix,\n-   recording whether two allocnos conflict (can't go in the same\n-   hardware register).  */\n-\n-extern HOST_WIDEST_FAST_INT *conflicts;\n-\n-/* Indexed by (pseudo) reg number, gives the allocno, or -1\n-   for pseudo registers which are not to be allocated.  */\n-\n-extern int *reg_allocno;\n-\n-/* Precalculated partial bit number in the compressed triangular bit matrix.\n-   For two allocnos, the final bit number is: partial_bitnum[LOW] + HIGH.  */\n-\n-extern HOST_WIDE_INT *partial_bitnum;\n-\n-/* Size in bits of the compressed triangular bit matrix.  */\n-\n-extern HOST_WIDE_INT max_bitnum;\n-\n-/* The pool to allocate the adjacency list elements from.  */\n-\n-extern alloc_pool adjacency_pool;\n-\n-/* The maximum number of neighbors stored in the neighbors vector before\n-   we have to chain in another vector.  */\n-\n-#define ADJACENCY_VEC_LENGTH 30\n-\n-/* Conflict graph adjacency list.  */\n-\n-typedef struct adjacency_list_d\n-{\n-  int neighbors[ADJACENCY_VEC_LENGTH];\n-  unsigned int index;\n-  struct adjacency_list_d *next;\n-} adjacency_t;\n-\n-extern adjacency_t **adjacency;\n-\n-/* Add NEIGHBOR to ALLOC_NO's adjacency list.  It is assumed the caller\n-   has already determined that NEIGHBOR is not already neighbor by\n-   checking the conflict bit matrix.  */\n-\n-static inline void\n-add_neighbor (int alloc_no, int neighbor)\n-{\n-  adjacency_t *adjlist = adjacency[alloc_no];\n-\n-  if (adjlist == NULL || adjlist->index == ADJACENCY_VEC_LENGTH)\n-    {\n-      adjacency_t *new_adj = (adjacency_t *) pool_alloc (adjacency_pool);\n-      new_adj->index = 0;\n-      new_adj->next = adjlist;\n-      adjlist = new_adj;\n-      adjacency[alloc_no] = adjlist;\n-    }\n-\n-  adjlist->neighbors[adjlist->index++] = neighbor;\n-}\n-\n-/* Iterator for adjacency lists.  */\n-\n-typedef struct adjacency_iterator_d\n-{\n-  adjacency_t *vec;\n-  unsigned int idx;\n-} adjacency_iter;\n-\n-/* Initialize a single adjacency list iterator.  */\n-\n-static inline int\n-adjacency_iter_init (adjacency_iter *ai, int allocno1)\n-{\n-  ai->vec = adjacency[allocno1];\n-  ai->idx = 0;\n-  return ai->vec != NULL;\n-}\n-\n-/* Test whether we have visited all of the neighbors.  */\n-\n-static inline int\n-adjacency_iter_done (adjacency_iter *ai)\n-{\n-  return ai->idx > ai->vec->index;\n-}\n-\n-/* Advance to the next neighbor in AI.  */\n-\n-static inline int\n-adjacency_iter_next (adjacency_iter *ai)\n-{\n-  unsigned int idx = ai->idx;\n-  int neighbor = ai->vec->neighbors[idx++];\n-  if (idx >= ai->vec->index && ai->vec->next != NULL)\n-    {\n-      ai->vec = ai->vec->next;\n-      ai->idx = 0;\n-    }\n-  else\n-    ai->idx = idx;\n-  return neighbor;\n-}\n-\n-/* Return the one basic block regno is used in.  If regno is used\n-   in more than one basic block or if it is unknown which block it\n-   is used in, return 0.  */\n-\n-static inline int\n-regno_basic_block (int regno)\n-{\n-  int block = REG_BASIC_BLOCK (regno);\n-  if (block < 0)\n-    block = 0;\n-  return block;\n-}\n-\n-extern void global_conflicts (void);\n-\n-/* In global.c  */\n-\n-/* Macro to visit all of IN_ALLOCNO's neighbors.  Neighbors are\n-   returned in OUT_ALLOCNO for each iteration of the loop.  */\n-\n-#define FOR_EACH_CONFLICT(IN_ALLOCNO, OUT_ALLOCNO, ITER)\t\t\\\n-  if (!adjacency || !adjacency_iter_init (&(ITER), (IN_ALLOCNO)))\t\\\n-    ;\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    for ((OUT_ALLOCNO) = adjacency_iter_next (&(ITER));\t\t\t\\\n-\t !adjacency_iter_done (&(ITER));\t\t\t\t\\\n-\t (OUT_ALLOCNO) = adjacency_iter_next (&(ITER)))\n-\n-extern void ra_init_live_subregs (bool, sbitmap *, int *, int, rtx);\n-extern bool conflict_p (int, int);\n-\n-#endif /* GCC_RA_H */"}, {"sha": "de8499cd92e45d0bbb16143771f9560a20ec75bc", "filename": "gcc/regmove.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3631be4865f1942115b43d7f30a232a6cfb9c4b8/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3631be4865f1942115b43d7f30a232a6cfb9c4b8/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=3631be4865f1942115b43d7f30a232a6cfb9c4b8", "patch": "@@ -1089,7 +1089,6 @@ regmove_optimize (rtx f, int nregs)\n \n   for (pass = 0; pass <= 2; pass++)\n     {\n-      /* We need fewer optimizations for IRA.  */\n       if (! flag_regmove && pass >= flag_expensive_optimizations)\n \tgoto done;\n "}]}