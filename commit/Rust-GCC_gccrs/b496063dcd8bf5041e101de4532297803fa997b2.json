{"sha": "b496063dcd8bf5041e101de4532297803fa997b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5NjA2M2RjZDhiZjUwNDFlMTAxZGU0NTMyMjk3ODAzZmE5OTdiMg==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2015-04-17T17:10:12Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-04-17T17:10:12Z"}, "message": "compiler: Escape analysis.\n\nBy Chris Manghane.\n\nComprises three changes to gofrontend repository:\n\ncompiler: Add escape information to export data.\n\ncompiler: Stack-allocate non-escaping variables.\n\nThis change allows variables initialized through make or new\nto be allocated on the stack via a temporary variable if they\ndo not escape their function. It also improves the analysis to\nconsider situations where variables escape in the standard\nlibrary and go testsuite such as:\n\n*nested composite literals and composite literal arguments\n*method receivers always escaping\n*escape via statements in closures referring to enclosing variables\n*escape via calls with multiple return results\n\ncompiler: Basic escape analysis for the go frontend.\n\nThis is an implementation of the algorithm described in\n\"Escape Analysis in Java\" by Choi et. al.\n\nIt relies on dataflow information to discover variable\nreferences to one another. Handles assignments to closures\nand association between closures variables and the variables\nof the enclosing scope.\n\nDataflow analysis does not discover references through range\nstatements e.g. for _, v := range a will not recognize that\nall values of v are references to a.\n\n\t* Make-lang.in (GO_OBJS): Add go/escape.o.\n\nFrom-SVN: r222188", "tree": {"sha": "d1dced696fcc3d7e6802d825c7ddf09b50b62bda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1dced696fcc3d7e6802d825c7ddf09b50b62bda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b496063dcd8bf5041e101de4532297803fa997b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b496063dcd8bf5041e101de4532297803fa997b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b496063dcd8bf5041e101de4532297803fa997b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b496063dcd8bf5041e101de4532297803fa997b2/comments", "author": null, "committer": null, "parents": [{"sha": "c10b5ea0d8b2b268fcb16ae9768dea61c7271735", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c10b5ea0d8b2b268fcb16ae9768dea61c7271735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c10b5ea0d8b2b268fcb16ae9768dea61c7271735"}], "stats": {"total": 4049, "additions": 3283, "deletions": 766}, "files": [{"sha": "e0268c685e260538e0c47c3bc0036209de10a535", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -1,3 +1,7 @@\n+2015-04-17  Chris Manghane  <cmang@google.com>\n+\n+\t* Make-lang.in (GO_OBJS): Add go/escape.o.\n+\n 2015-02-02  Ian Lance Taylor  <iant@google.com>\n \n \tPR go/64836"}, {"sha": "34470875cfdadeeb12687c931e5f22f26449d3af", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -51,6 +51,7 @@ go-warn = $(STRICT_WARN)\n GO_OBJS = \\\n \tgo/ast-dump.o \\\n \tgo/dataflow.o \\\n+\tgo/escape.o \\\n \tgo/export.o \\\n \tgo/expressions.o \\\n \tgo/go-backend.o \\"}, {"sha": "bf1d54ab26126bdb16089c98b11ddd9413bc0199", "filename": "gcc/go/gofrontend/dataflow.cc", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fdataflow.cc?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -169,8 +169,20 @@ Dataflow_traverse_statements::statement(Block* block, size_t* pindex,\n \t\t\t\t\tStatement *statement)\n {\n   Dataflow_traverse_assignment dta(this->dataflow_, statement);\n-  if (!statement->traverse_assignments(&dta))\n+\n+  // For thunk statements, make sure to traverse the call expression to\n+  // find any reference to a variable being used as an argument.\n+  if (!statement->traverse_assignments(&dta)\n+      || statement->thunk_statement() != NULL)\n     {\n+      // Case statements in selects will be lowered into temporaries at this\n+      // point so our dataflow analysis will miss references between a/c and ch\n+      // in case statements of the form a,c := <-ch.  Do a special dataflow\n+      // analysis for select statements here; the analysis for the blocks will\n+      // be handled as usual.\n+      if (statement->select_statement() != NULL)\n+\tstatement->select_statement()->analyze_dataflow(this->dataflow_);\n+\n       Dataflow_traverse_expressions dte(this->dataflow_, statement);\n       statement->traverse(block, pindex, &dte);\n     }\n@@ -195,12 +207,21 @@ Dataflow::Compare_vars::operator()(const Named_object* no1,\n     return false;\n   if (loc1 > loc2)\n     return true;\n+  if (Linemap::is_predeclared_location(loc1))\n+    return false;\n \n-  if (no1 == no2)\n+  if (no1 == no2\n+      || (no1->is_result_variable()\n+\t  && no2->is_result_variable())\n+      || ((no1->is_variable()\n+\t   && no1->var_value()->is_type_switch_var())\n+\t  && (no2->is_variable()\n+\t      && no2->var_value()->is_type_switch_var())))\n     return false;\n \n   // We can't have two variables with the same name in the same\n-  // location.\n+  // location unless they are type switch variables which share the same\n+  // fake location.\n   go_unreachable();\n }\n "}, {"sha": "7c8955bb8a5a4ab8f9377283f353667670d23d31", "filename": "gcc/go/gofrontend/escape.cc", "status": "added", "additions": 1481, "deletions": 0, "changes": 1481, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -0,0 +1,1481 @@\n+// escape.cc -- Go frontend escape analysis.\n+\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include <fstream>\n+\n+#include \"go-c.h\"\n+#include \"go-dump.h\"\n+#include \"go-optimize.h\"\n+#include \"types.h\"\n+#include \"statements.h\"\n+#include \"expressions.h\"\n+#include \"dataflow.h\"\n+#include \"gogo.h\"\n+#include \"escape.h\"\n+\n+// Class Node.\n+\n+Node::Node(Node_classification classification, Named_object* object)\n+  : classification_(classification), object_(object)\n+{\n+  // Give every node a unique ID for representation purposes.\n+  static int count;\n+  this->id_ = count++;\n+}\n+\n+Node::~Node()\n+{\n+}\n+\n+// Make a call node for FUNCTION.\n+\n+Node*\n+Node::make_call(Named_object* function)\n+{\n+  return new Call_node(function);\n+}\n+\n+// Make a connection node for OBJECT.\n+\n+Node*\n+Node::make_connection(Named_object* object, Escapement_lattice e)\n+{\n+  return new Connection_node(object, e);\n+}\n+\n+// Return this node's label, which will be the name seen in the graphical\n+// representation.\n+\n+const std::string&\n+Node::label()\n+{\n+  if (this->label_.empty())\n+    {\n+      this->label_ = \"[label=\\\"\";\n+      this->label_ += this->object_->name();\n+      this->label_ += \"\\\"]\";\n+    }\n+  return this->label_;\n+}\n+\n+// Class Call_node.\n+\n+Call_node::Call_node(Named_object* function)\n+  : Node(NODE_CALL, function)\n+{ go_assert(function->is_function() || function->is_function_declaration()); }\n+\n+const std::string&\n+Call_node::name()\n+{\n+  if (this->get_name().empty())\n+    {\n+      char buf[30];\n+      snprintf(buf, sizeof buf, \"CallNode%d\", this->id());\n+      this->set_name(std::string(buf));\n+    }\n+  return this->get_name();\n+}\n+\n+// Class Connection_node.\n+\n+const std::string&\n+Connection_node::name()\n+{\n+  if (this->get_name().empty())\n+    {\n+      char buf[30];\n+      snprintf(buf, sizeof buf, \"ConnectionNode%d\", this->id());\n+      this->set_name(std::string(buf));\n+    }\n+  return this->get_name();\n+}\n+\n+const std::string&\n+Connection_node::label()\n+{\n+  if (this->get_label().empty())\n+    {\n+      std::string label = \"[label=\\\"\";\n+      label += this->object()->name();\n+      label += \"\\\",color=\";\n+      switch (this->escape_state_)\n+      {\n+      case ESCAPE_GLOBAL:\n+\tlabel += \"red\";\n+\tbreak;\n+      case ESCAPE_ARG:\n+\tlabel += \"blue\";\n+\tbreak;\n+      case ESCAPE_NONE:\n+\tlabel += \"black\";\n+\tbreak;\n+      }\n+      label += \"]\";\n+      this->set_label(label);\n+    }\n+  return this->get_label();\n+}\n+\n+// Dump a connection node and its edges to a dump file.\n+\n+void\n+Connection_node::dump_connection(Connection_dump_context* cdc)\n+{\n+  cdc->write_string(this->name() + this->label());\n+  cdc->write_c_string(\"\\n\");\n+\n+  for (std::set<Node*>::const_iterator p = this->edges().begin();\n+       p != this->edges().end();\n+       ++p)\n+    {\n+      cdc->write_string(this->name());\n+      cdc->write_c_string(\"->\");\n+\n+      if ((*p)->object()->is_function())\n+\t{\n+\t  char buf[100];\n+\t  snprintf(buf, sizeof buf, \"dummy%d[lhead=cluster%d]\",\n+\t\t   (*p)->id(), (*p)->id());\n+\t  cdc->write_c_string(buf);\n+\t}\n+      else\n+\tcdc->write_string((*p)->name());\n+      cdc->write_c_string(\"\\n\");\n+    }\n+}\n+\n+// The -fgo-dump-calls flag to activate call graph dumps in GraphViz DOT format.\n+\n+Go_dump call_graph_dump_flag(\"calls\");\n+\n+// Class Call_dump_context.\n+\n+Call_dump_context::Call_dump_context(std::ostream* out)\n+  : ostream_(out), gogo_(NULL)\n+{ }\n+\n+// Dump files will be named %basename%.calls.dot\n+\n+const char* kCallDumpFileExtension = \".calls.dot\";\n+\n+// Dump the call graph in DOT format.\n+\n+void\n+Call_dump_context::dump(Gogo* gogo, const char* basename)\n+{\n+  std::ofstream* out = new std::ofstream();\n+  std::string dumpname(basename);\n+  dumpname += kCallDumpFileExtension;\n+  out->open(dumpname.c_str());\n+\n+  if (out->fail())\n+    {\n+      error(\"cannot open %s:%m, -fgo-dump-calls ignored\", dumpname.c_str());\n+      return;\n+    }\n+\n+  this->gogo_ = gogo;\n+  this->ostream_ = out;\n+\n+  this->write_string(\"digraph CallGraph {\\n\");\n+  std::set<Node*> call_graph = gogo->call_graph();\n+\n+  // Generate GraphViz nodes for each node.\n+  for (std::set<Node*>::const_iterator p = call_graph.begin();\n+       p != call_graph.end();\n+       ++p)\n+    {\n+      this->write_string((*p)->name() + (*p)->label());\n+      this->write_c_string(\"\\n\");\n+      \n+      // Generate a graphical representation of the caller-callee relationship.\n+      std::set<Node*> callees = (*p)->edges();\n+      for (std::set<Node*>::const_iterator ce = callees.begin();\n+\t   ce != callees.end();\n+\t   ++ce)\n+\t{\n+\t  this->write_string((*p)->name() + \"->\" + (*ce)->name());\n+\t  this->write_c_string(\"\\n\");\n+\t}\n+    }\n+  this->write_string(\"}\");\n+  out->close();\n+}\n+\n+// Dump the Call Graph of the program to the dump file.\n+\n+void Gogo::dump_call_graph(const char* basename)\n+{\n+  if (::call_graph_dump_flag.is_enabled())\n+    {\n+      Call_dump_context cdc;\n+      cdc.dump(this, basename);\n+    }\n+}\n+\n+// Implementation of String_dump interface.\n+\n+void\n+Call_dump_context::write_c_string(const char* s)\n+{\n+  this->ostream() << s;\n+}\n+\n+void\n+Call_dump_context::write_string(const std::string& s)\n+{\n+  this->ostream() << s;\n+}\n+\n+// The -fgo-dump-conns flag to activate connection graph dumps in\n+// GraphViz DOT format.\n+\n+Go_dump connection_graph_dump_flag(\"conns\");\n+\n+// Class Connection_dump_context.\n+\n+Connection_dump_context::Connection_dump_context(std::ostream* out)\n+  : ostream_(out), gogo_(NULL)\n+{ }\n+\n+// Dump files will be named %basename%.conns.dot\n+\n+const char* kConnectionDumpFileExtension = \".conns.dot\";\n+\n+// Dump the connection graph in DOT format.\n+\n+void\n+Connection_dump_context::dump(Gogo* gogo, const char* basename)\n+{\n+  std::ofstream* out = new std::ofstream();\n+  std::string dumpname(basename);\n+  dumpname += kConnectionDumpFileExtension;\n+  out->open(dumpname.c_str());\n+\n+  if (out->fail())\n+    {\n+      error(\"cannot open %s:%m, -fgo-dump-conns ignored\", dumpname.c_str());\n+      return;\n+    }\n+\n+  this->gogo_ = gogo;\n+  this->ostream_ = out;\n+\n+  this->write_string(\"digraph ConnectionGraph {\\n\");\n+  this->write_string(\"compound=true\\n\");\n+\n+  // Dump global objects.\n+  std::set<Node*> globals = this->gogo_->global_connections();\n+  this->write_c_string(\"subgraph globals{\\n\");\n+  this->write_c_string(\"label=\\\"NonLocalGraph\\\"\\n\");\n+  this->write_c_string(\"color=red\\n\");\n+  for (std::set<Node*>::const_iterator p1 = globals.begin();\n+       p1 != globals.end();\n+       ++p1)\n+    (*p1)->connection_node()->dump_connection(this);\n+  this->write_c_string(\"}\\n\");\n+\n+  std::set<Node*> roots = this->gogo_->connection_roots();\n+  for (std::set<Node*>::const_reverse_iterator p1 = roots.rbegin();\n+       p1 != roots.rend();\n+       ++p1)\n+    {\n+      std::set<Node*> objects = (*p1)->connection_node()->objects();\n+\n+      char buf[150];\n+      snprintf(buf, sizeof buf, \"subgraph cluster%d\", (*p1)->id());\n+      this->write_c_string(buf);\n+      this->write_string(\"{\\n\");\n+      snprintf(buf, sizeof buf, \"dummy%d[shape=point,style=invis]\\n\",\n+\t       (*p1)->id());\n+      this->write_c_string(buf);\n+      this->write_string(\"label = \\\"\" + (*p1)->object()->name() + \"\\\"\\n\");\n+\n+      for (std::set<Node*>::const_iterator p2 = objects.begin();\n+\t   p2 != objects.end();\n+\t   ++p2)\n+\t(*p2)->connection_node()->dump_connection(this);\n+\n+      this->write_string(\"}\\n\");\n+    }\n+  this->write_string(\"}\");\n+  out->close();\n+}\n+\n+void\n+Gogo::dump_connection_graphs(const char* basename)\n+{\n+  if (::connection_graph_dump_flag.is_enabled())\n+    {\n+      Connection_dump_context cdc;\n+      cdc.dump(this, basename);\n+    }\n+}\n+\n+// Implementation of String_dump interface.\n+\n+void\n+Connection_dump_context::write_c_string(const char* s)\n+{\n+  this->ostream() << s;\n+}\n+\n+void\n+Connection_dump_context::write_string(const std::string& s)\n+{\n+  this->ostream() << s;\n+}\n+\n+// A traversal class used to build a call graph for this program.\n+\n+class Build_call_graph : public Traverse\n+{\n+ public:\n+  Build_call_graph(Gogo* gogo)\n+    : Traverse(traverse_functions\n+\t       | traverse_expressions),\n+      gogo_(gogo), current_function_(NULL)\n+  { }\n+\n+  int\n+  function(Named_object*);\n+\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  // The IR.\n+  Gogo* gogo_;\n+  // The current function being traversed, for reference when traversing the\n+  // function body.\n+  Named_object* current_function_;\n+};\n+\n+// Add each function to the call graph and then traverse each function's\n+// body to find callee functions.\n+\n+int\n+Build_call_graph::function(Named_object* fn)\n+{\n+  this->gogo_->add_call_node(fn);\n+  go_assert(this->current_function_ == NULL);\n+  this->current_function_ = fn;\n+  fn->func_value()->traverse(this);\n+  this->current_function_ = NULL;\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Find function calls and add them as callees to CURRENT_FUNCTION.\n+\n+int\n+Build_call_graph::expression(Expression** pexpr)\n+{\n+  if (this->current_function_ == NULL)\n+    return TRAVERSE_CONTINUE;\n+\n+  Expression* expr = *pexpr;\n+  Named_object* fn;\n+  if (expr->call_expression() != NULL)\n+    {\n+      Func_expression* func = expr->call_expression()->fn()->func_expression();\n+      if (func == NULL)\n+\t{\n+\t  // This is probably a variable holding a function value or a closure.\n+\t  return TRAVERSE_CONTINUE;\n+\t}\n+      fn = func->named_object();\n+    }\n+  else if (expr->func_expression() != NULL)\n+    fn = expr->func_expression()->named_object();\n+  else\n+    return TRAVERSE_CONTINUE;\n+\n+  Node* caller = this->gogo_->lookup_call_node(this->current_function_);\n+  go_assert(caller != NULL);\n+\n+  // Create the callee here if it hasn't been seen yet.  This could also be a\n+  // function defined in another package.\n+  Node* callee = this->gogo_->add_call_node(fn);\n+  caller->add_edge(callee);\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Build the call graph.\n+\n+void\n+Gogo::build_call_graph()\n+{\n+  Build_call_graph build_calls(this);\n+  this->traverse(&build_calls);\n+}\n+\n+// A traversal class used to build a connection graph for each node in the\n+// call graph.\n+\n+class Build_connection_graphs : public Traverse\n+{\n+ public:\n+  Build_connection_graphs(Gogo* gogo)\n+    : Traverse(traverse_variables\n+\t       | traverse_statements),\n+      gogo_(gogo), dataflow_(new Dataflow), current_function_(NULL)\n+  {\n+    // Collect dataflow information for this program.\n+    this->dataflow_->initialize(this->gogo_);\n+  }\n+\n+  void\n+  set_current_function(Named_object* function)\n+  { this->current_function_ = function; }\n+\n+  int\n+  variable(Named_object*);\n+\n+  int\n+  statement(Block*, size_t*, Statement*);\n+\n+\n+ private:\n+  // Handle a call EXPR referencing OBJECT.\n+  void\n+  handle_call(Named_object* object, Expression* expr);\n+\n+  // Get the initialization values of a composite literal EXPR.\n+  Expression_list*\n+  get_composite_arguments(Expression* expr);\n+\n+  // Handle defining OBJECT as a composite literal EXPR.\n+  void\n+  handle_composite_literal(Named_object* object, Expression* expr);\n+\n+  // Resolve the outermost named object of EXPR if there is one.\n+  Named_object*\n+  resolve_var_reference(Expression* expr);\n+\n+  // The IR.\n+  Gogo* gogo_;\n+  // The Dataflow information for this program.\n+  Dataflow* dataflow_;\n+  // The current function whose connection graph is being built.\n+  Named_object* current_function_;\n+};\n+\n+// Given an expression, return the outermost Named_object that it refers to.\n+// This is used to model the simplification between assignments in our analysis.\n+\n+Named_object*\n+Build_connection_graphs::resolve_var_reference(Expression* expr)\n+{\n+  bool done = false;\n+  Expression* orig = expr;\n+  while (!done)\n+    {\n+      // The goal of this loop is to find the variable being referenced, p,\n+      // when the expression is:\n+      switch (expr->classification())\n+      {\n+      case Expression::EXPRESSION_UNARY:\n+\t// &p or *p\n+\texpr = expr->unary_expression()->operand();\n+\tbreak;\n+\n+      case Expression::EXPRESSION_ARRAY_INDEX:\n+\t// p[i][j]\n+\texpr = expr->array_index_expression()->array();\n+\tbreak;\n+\n+      case Expression::EXPRESSION_FIELD_REFERENCE:\n+\t// p.i.j\n+\torig = expr;\n+\texpr = expr->field_reference_expression()->expr();\n+\tbreak;\n+\n+      case Expression::EXPRESSION_RECEIVE:\n+\t// <- p\n+\texpr = expr->receive_expression()->channel();\n+\tbreak;\n+\n+      case Expression::EXPRESSION_BOUND_METHOD:\n+\t// p.c\n+\texpr = expr->bound_method_expression()->first_argument();\n+\tbreak;\n+\n+      case Expression::EXPRESSION_CALL:\n+\t// p.c()\n+\texpr = expr->call_expression()->fn();\n+\tbreak;\n+\n+      case Expression::EXPRESSION_TEMPORARY_REFERENCE:\n+\t// This is used after lowering, so try to retrieve the original\n+\t// expression that might have been lowered into a temporary statement.\n+\texpr = expr->temporary_reference_expression()->statement()->init();\n+\tif (expr == NULL)\n+\t  return NULL;\n+\tbreak;\n+\n+      case Expression::EXPRESSION_SET_AND_USE_TEMPORARY:\n+\texpr = expr->set_and_use_temporary_expression()->expression();\n+\tbreak;\n+\n+      case Expression::EXPRESSION_COMPOUND:\n+\t// p && q\n+\texpr = expr->compound_expression()->init();\n+\tbreak;\n+\n+      case Expression::EXPRESSION_CONDITIONAL:\n+\t// if p {\n+\texpr = expr->conditional_expression()->condition();\n+\tbreak;\n+\n+      case Expression::EXPRESSION_CONVERSION:\n+\t// T(p)\n+\texpr = expr->conversion_expression()->expr();\n+\tbreak;\n+\n+      case Expression::EXPRESSION_TYPE_GUARD:\n+\t// p.(T)\n+\texpr = expr->type_guard_expression()->expr();\n+\tbreak;\n+\n+      default:\n+\tdone = true;\n+\tbreak;\n+      }\n+    }\n+\n+  Var_expression* ve = expr->var_expression();\n+  if (ve != NULL)\n+    {\n+      Named_object* no = ve->named_object();\n+      go_assert(no->is_variable() || no->is_result_variable());\n+\n+      if (no->is_variable()\n+\t  && no->var_value()->is_closure()\n+\t  && this->current_function_->func_value()->needs_closure())\n+\t{\n+\t  // CURRENT_FUNCTION is a closure and NO is being set to a\n+\t  // variable in the enclosing function.\n+\t  Named_object* closure = this->current_function_;\n+\n+\t  // If NO is a closure variable, the expression is a field\n+\t  // reference to the enclosed variable.\n+\t  Field_reference_expression* fre =\n+\t    orig->deref()->field_reference_expression();\n+\t  if (fre == NULL)\n+\t    return NULL;\n+\n+\t  unsigned int closure_index = fre->field_index();\n+\t  no = closure->func_value()->enclosing_var(closure_index - 1);\n+\t}\n+      return no;\n+    }\n+  return NULL;\n+}\n+\n+// For a call that references OBJECT, associate the OBJECT argument with the\n+// appropriate call parameter.\n+\n+void\n+Build_connection_graphs::handle_call(Named_object* object, Expression* e)\n+{\n+  // Only call expression statements are interesting\n+  // e.g. 'func(var)' for which we can show var does not escape.\n+  Call_expression* ce = e->call_expression();\n+  if (ce == NULL || ce->args() == NULL)\n+    return;\n+  \n+  // If the function call that references OBJECT is unknown, we must be\n+  // conservative and assume every argument escapes.  A function call is unknown\n+  // if it is a call to a function stored in a variable or a call to an\n+  // interface method.\n+  if (ce->fn()->func_expression() == NULL)\n+    {\n+      for (Expression_list::const_iterator arg = ce->args()->begin();\n+\t   arg != ce->args()->end();\n+\t   ++arg)\n+\t{\n+\t  Named_object* arg_no = this->resolve_var_reference(*arg);\n+\t  if (arg_no != NULL)\n+\t    {\n+\t      Connection_node* arg_node =\n+\t\tthis->gogo_->add_connection_node(arg_no)->connection_node();\n+\t      arg_node->set_escape_state(Node::ESCAPE_ARG);\n+\t    }\n+\t}\n+      return;\n+    }\n+\n+  Named_object* callee = ce->fn()->func_expression()->named_object();\n+  Function_type* fntype;\n+  if (callee->is_function())\n+    fntype = callee->func_value()->type();\n+  else\n+    fntype = callee->func_declaration_value()->type();\n+\n+  Node* callee_node = this->gogo_->lookup_connection_node(callee);\n+  if (callee_node == NULL && callee->is_function())\n+    {\n+      // Might be a nested closure that hasn't been analyzed yet.\n+      Named_object* currfn = this->current_function_;\n+      callee_node = this->gogo_->add_connection_node(callee);\n+      this->current_function_ = callee;\n+      callee->func_value()->traverse(this);\n+      this->current_function_ = currfn;\n+    }\n+\n+  // First find which arguments OBJECT is to CALLEE.  Given a function call,\n+  // OBJECT could be an argument multiple times e.g. CALLEE(OBJECT, OBJECT).\n+  // TODO(cmang): This should be done by the Dataflow analysis so we don't have\n+  // to do it each time we see a function call.  FIXME.\n+  Expression_list* args = ce->args()->copy();\n+  if (fntype->is_varargs()\n+      && args->back()->slice_literal() != NULL)\n+    {\n+      // Is the function is varargs, the last argument is lowered into a slice\n+      // containing all original arguments.  We want to traverse the original\n+      // arguments here.\n+      Slice_construction_expression* sce = args->back()->slice_literal();\n+      for (Expression_list::const_iterator p = sce->vals()->begin();\n+\t   p != sce->vals()->end();\n+\t   ++p)\n+\t{\n+\t  if (*p != NULL)\n+\t    args->push_back(*p);\n+\t}\n+    }\n+\n+  // ARG_POSITION is just a counter used to keep track of the index in the list\n+  // of arguments to this call.  In a method call, the receiver will always be\n+  // the first argument.  When looking at the function type, it will not be the\n+  // first element in the parameter list; instead, the receiver will be\n+  // non-NULL.  For convenience, mark the position of the receiver argument\n+  // as negative.\n+  int arg_position = fntype->is_method() ? -1 : 0;\n+  std::list<int> positions;\n+  for (Expression_list::const_iterator p = args->begin();\n+       p != args->end();\n+       ++p, ++arg_position)\n+    {\n+      Expression* arg = *p;\n+\n+      // An argument might be a chain of method calls, some of which are\n+      // converted from value to pointer types.  Just remove the unary\n+      // conversion if it exists.\n+      if (arg->unary_expression() != NULL)\n+\targ = arg->unary_expression()->operand();\n+\n+      // The reference to OBJECT might be in a nested call argument.\n+      if (arg->call_expression() != NULL)\n+\tthis->handle_call(object, arg);\n+\n+      std::vector<Named_object*> objects;\n+      if (arg->is_composite_literal()\n+\t  || arg->heap_expression() != NULL)\n+\t{\n+\t  // For a call that has a composite literal as an argument, traverse\n+\t  // the initializers of the composite literal for extra objects to\n+\t  // associate with a parameter in this function.\n+\t  Expression_list* comp_args = this->get_composite_arguments(arg);\n+\t  if (comp_args == NULL)\n+\t    continue;\n+\n+\t  for (size_t i = 0; i < comp_args->size(); ++i)\n+\t    {\n+\t      Expression* comp_arg = comp_args->at(i);\n+\t      if (comp_arg == NULL)\n+\t\tcontinue;\n+\t      else if (comp_arg->is_composite_literal()\n+\t\t       || comp_arg->heap_expression() != NULL)\n+\t\t{\n+\t\t  // Of course, there are situations where a composite literal\n+\t\t  // initialization value is also a composite literal.\n+\t\t  Expression_list* nested_args =\n+\t\t    this->get_composite_arguments(comp_arg);\n+\t\t  if (nested_args != NULL)\n+\t\t    comp_args->append(nested_args);\n+\t\t}\n+\n+\t      Named_object* no = this->resolve_var_reference(comp_arg);\n+\t      if (no != NULL)\n+\t\tobjects.push_back(no);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  Named_object* arg_no = this->resolve_var_reference(arg);\n+\t  if (arg_no != NULL)\n+\t    objects.push_back(arg_no);\n+\t}\n+\n+      // There are no variables to consider for this parameter.\n+      if (objects.empty())\n+\tcontinue;\n+\n+      for (std::vector<Named_object*>::const_iterator p1 = objects.begin();\n+\t   p1 != objects.end();\n+\t   ++p1)\n+\t{\n+\t  // If CALLEE is defined in another package and we have imported escape\n+\t  // information about its parameters, update the escape state of this\n+\t  // argument appropriately. If there is no escape information for this\n+\t  // function, we have to assume all arguments escape.\n+\t  if (callee->package() != NULL\n+\t      || fntype->is_builtin())\n+\t    {\n+\t      Node::Escapement_lattice param_escape = Node::ESCAPE_NONE;\n+\t      if (fntype->has_escape_info())\n+\t\t{\n+\t\t  if (arg_position == -1)\n+\t\t    {\n+\t\t      // Use the escape info from the receiver.\n+\t\t      param_escape = fntype->receiver_escape_state();\n+\t\t    }\n+\t\t  else if (fntype->parameters() != NULL)\n+\t\t    {\n+\t\t      const Node::Escape_states* states =\n+\t\t\tfntype->parameter_escape_states();\n+\n+\t\t      int param_size = fntype->parameters()->size();\n+\t\t      if (arg_position >= param_size)\n+\t\t\t{\n+\t\t\t  go_assert(fntype->is_varargs());\n+\t\t\t  param_escape = states->back();\n+\t\t\t}\n+\t\t      else\n+\t\t\tparam_escape =\n+\t\t\t  fntype->parameter_escape_states()->at(arg_position);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tparam_escape = Node::ESCAPE_ARG;\n+\n+\t      Connection_node* arg_node =\n+\t\tthis->gogo_->add_connection_node(*p1)->connection_node();\n+\t      if (arg_node->escape_state() > param_escape)\n+\t\targ_node->set_escape_state(param_escape);\n+\t    }\n+\n+\t  if (*p1 == object)\n+\t    positions.push_back(arg_position);\n+\t}\n+    }\n+\n+  // If OBJECT was not found in CALLEE's arguments, OBJECT is likely a\n+  // subexpression of one of the arguments e.g. CALLEE(a[OBJECT]).  This call\n+  // does not give any useful information about whether OBJECT escapes.\n+  if (positions.empty())\n+    return;\n+\n+  // The idea here is to associate the OBJECT in the caller context with the\n+  // parameter in the callee context.  This also needs to consider varargs.\n+  // This only works with functions with arguments.\n+  if (!callee->is_function())\n+    return;\n+\n+  // Use the bindings in the callee to lookup the associated parameter.\n+  const Bindings* callee_bindings = callee->func_value()->block()->bindings();\n+\n+  // Next find the corresponding named parameters in the function signature.\n+  const Typed_identifier_list* params = fntype->parameters();\n+  for (std::list<int>::const_iterator pos = positions.begin();\n+       params != NULL && pos != positions.end();\n+       ++pos)\n+    {\n+      std::string param_name;\n+      bool param_is_interface = false;\n+      if (*pos >= 0 && params->size() <= static_cast<size_t>(*pos))\n+\t{\n+\t  // There were more arguments than there are parameters. This must be\n+\t  // varargs and the argument corresponds to the last parameter.\n+\t  go_assert(fntype->is_varargs());\n+\t  param_name = params->back().name();\n+\t}\n+      else if (*pos < 0)\n+\t{\n+\t  // We adjust the recorded position of method arguments by one to\n+\t  // account for the receiver, so *pos == -1 implies this is the\n+\t  // receiver and this must be a method call.\n+\t  go_assert(fntype->is_method() && fntype->receiver() != NULL);\n+\t  param_name = fntype->receiver()->name();\n+\t}\n+      else\n+\t{\n+\t  param_name = params->at(*pos).name();\n+\t  param_is_interface =\n+\t    (params->at(*pos).type()->interface_type() != NULL);\n+\t}\n+\n+      if (Gogo::is_sink_name(param_name) || param_name.empty())\n+\tcontinue;\n+\n+      // Get the object for the associated parameter in this binding.\n+      Named_object* param_no = callee_bindings->lookup_local(param_name);\n+      go_assert(param_no != NULL);\n+\n+      // Add an edge from ARG_NODE in the caller context to the PARAM_NODE in\n+      // the callee context.\n+      if (object->is_variable() && object->var_value()->is_closure())\n+\t{\n+\t  int position = *pos;\n+\t  if (fntype->is_method())\n+\t    ++position;\n+\n+\t  // Calling a function within a closure with a closure argument.\n+\t  // Resolve the real variable using the closure argument.\n+\t  object = this->resolve_var_reference(ce->args()->at(position));\n+\t}\n+\n+      Node* arg_node = this->gogo_->add_connection_node(object);\n+      Node* param_node = this->gogo_->add_connection_node(param_no);\n+\n+      // Act conservatively when an argument is converted into an interface\n+      // value.  FIXME.\n+      if (param_is_interface)\n+\tparam_node->connection_node()->set_escape_state(Node::ESCAPE_ARG);\n+      param_node->add_edge(arg_node);\n+    }\n+\n+  // This is a method call with one argument: the receiver.\n+  if (params == NULL)\n+    {\n+      go_assert(positions.size() == 1);\n+      std::string rcvr_name = fntype->receiver()->name();\n+      if (Gogo::is_sink_name(rcvr_name) || rcvr_name.empty())\n+\treturn;\n+\n+      Named_object* rcvr_no = callee_bindings->lookup_local(rcvr_name);\n+      Node* arg_node = this->gogo_->add_connection_node(object);\n+      Node* rcvr_node = this->gogo_->add_connection_node(rcvr_no);\n+      rcvr_node->add_edge(arg_node);\n+    }\n+}\n+\n+// Given a composite literal expression, return the initialization values.\n+// This is used to handle situations where call and composite literal\n+// expressions have nested composite literals as arguments/initializers.\n+\n+Expression_list*\n+Build_connection_graphs::get_composite_arguments(Expression* expr)\n+{\n+  // A heap expression is just any expression that takes the address of a\n+  // composite literal.\n+  if (expr->heap_expression() != NULL)\n+    expr = expr->heap_expression()->expr();\n+\n+  switch (expr->classification())\n+    {\n+    case Expression::EXPRESSION_STRUCT_CONSTRUCTION:\n+      return expr->struct_literal()->vals();\n+\n+    case Expression::EXPRESSION_FIXED_ARRAY_CONSTRUCTION:\n+      return expr->array_literal()->vals();\n+\n+    case Expression::EXPRESSION_SLICE_CONSTRUCTION:\n+      return expr->slice_literal()->vals();\n+\n+    case Expression::EXPRESSION_MAP_CONSTRUCTION:\n+      return expr->map_literal()->vals();\n+\n+    default:\n+      return NULL;\n+    }\n+}\n+\n+// Given an OBJECT defined as a composite literal EXPR, create edges between\n+// OBJECT and all variables referenced in EXPR.\n+\n+void\n+Build_connection_graphs::handle_composite_literal(Named_object* object,\n+\t\t\t\t\t\t  Expression* expr)\n+{\n+  Expression_list* args = this->get_composite_arguments(expr);\n+  if (args == NULL)\n+    return;\n+\n+  std::vector<Named_object*> composite_args;\n+  for (Expression_list::const_iterator p = args->begin();\n+       p != args->end();\n+       ++p)\n+    {\n+      if (*p == NULL)\n+\tcontinue;\n+      else if ((*p)->call_expression() != NULL)\n+\tthis->handle_call(object, *p);\n+      else if ((*p)->is_composite_literal()\n+\t       || (*p)->heap_expression() != NULL)\n+\tthis->handle_composite_literal(object, *p);\n+\n+      Named_object* no = this->resolve_var_reference(*p);\n+      if (no != NULL)\n+\tcomposite_args.push_back(no);\n+    }\n+\n+  Node* object_node = this->gogo_->add_connection_node(object);\n+  for (std::vector<Named_object*>::const_iterator p = composite_args.begin();\n+       p != composite_args.end();\n+       ++p)\n+    {\n+      Node* arg_node = this->gogo_->add_connection_node(*p);\n+      object_node->add_edge(arg_node);\n+    }\n+}\n+\n+// Create connection nodes for each variable in a called function.\n+\n+int\n+Build_connection_graphs::variable(Named_object* var)\n+{\n+  Node* var_node = this->gogo_->add_connection_node(var);\n+  Node* root = this->gogo_->lookup_connection_node(this->current_function_);\n+  go_assert(root != NULL);\n+\n+  // Add VAR to the set of objects in CURRENT_FUNCTION's connection graph.\n+  root->connection_node()->add_object(var_node);\n+\n+  // A function's results always escape.\n+  if (var->is_result_variable())\n+    var_node->connection_node()->set_escape_state(Node::ESCAPE_ARG);\n+\n+  // Create edges from a variable to its definitions.\n+  const Dataflow::Defs* defs = this->dataflow_->find_defs(var);\n+  if (defs != NULL)\n+    {\n+      for (Dataflow::Defs::const_iterator p = defs->begin();\n+\t   p != defs->end();\n+\t   ++p)\n+\t{\n+\t  if (p->val == NULL)\n+\t    continue;\n+\n+\t  if (p->val->func_expression() != NULL)\n+\t    {\n+\t      // VAR is being defined as a function object.\n+\t      Named_object* fn = p->val->func_expression()->named_object();\n+\t      Node* fn_node = this->gogo_->add_connection_node(fn);\n+\t      var_node->add_edge(fn_node);\n+\t    }\n+\t  else if(p->val->is_composite_literal()\n+\t\t  || p->val->heap_expression() != NULL)\n+\t    this->handle_composite_literal(var, p->val);\n+\n+\t  Named_object* ref = this->resolve_var_reference(p->val);\n+\t  if (ref == NULL)\n+\t    continue;\n+\n+\t  Node* ref_node = this->gogo_->add_connection_node(ref);\n+\t  var_node->add_edge(ref_node);\n+\t}\n+    }\n+\n+  // Create edges from a reference to a variable.\n+  const Dataflow::Refs* refs = this->dataflow_->find_refs(var);\n+  if (refs != NULL)\n+    {\n+      for (Dataflow::Refs::const_iterator p = refs->begin();\n+\t   p != refs->end();\n+\t   ++p)\n+\t{\n+\t  switch (p->statement->classification())\n+\t  {\n+\t  case Statement::STATEMENT_ASSIGNMENT:\n+\t    {\n+\t      Assignment_statement* assn =\n+\t\tp->statement->assignment_statement();\n+\t      Named_object* lhs_no = this->resolve_var_reference(assn->lhs());\n+\t      Named_object* rhs_no = this->resolve_var_reference(assn->rhs());\n+\n+\t      if (assn->rhs()->is_composite_literal()\n+\t\t  || assn->rhs()->heap_expression() != NULL)\n+\t\tthis->handle_composite_literal(var, assn->rhs());\n+\t      else if (assn->rhs()->call_result_expression() != NULL)\n+\t\t{\n+\t\t  // V's initialization will be a call result if\n+\t\t  // V, V1 := call(VAR).\n+\t\t  // There are no useful edges to make from V, but we want\n+\t\t  // to make sure we handle the call that references VAR.\n+\t\t  Expression* call =\n+\t\t    assn->rhs()->call_result_expression()->call();\n+\t\t  this->handle_call(var, call);\n+\t\t}\n+\t      else if (assn->rhs()->call_expression() != NULL)\n+\t\tthis->handle_call(var, assn->rhs());\n+\n+\t      // If there is no standalone variable on the rhs, this could be a\n+\t      // binary expression, which isn't interesting for analysis or a\n+\t      // composite literal or call expression, which we handled above.\n+\t      // If the underlying variable on the rhs isn't VAR then it is\n+\t      // likely an indexing expression where VAR is the index.\n+\t      if(lhs_no == NULL\n+\t\t || rhs_no == NULL\n+\t\t || rhs_no != var)\n+\t\tbreak;\n+\n+\t      var_node->connection_node()->set_escape_state(Node::ESCAPE_ARG);\n+\n+\t      Node* def_node = this->gogo_->add_connection_node(lhs_no);\n+\t      def_node->add_edge(var_node);\n+\t    }\n+\t    break;\n+\n+\t  case Statement::STATEMENT_SEND:\n+\t    {\n+\t      Send_statement* send = p->statement->send_statement();\n+\t      Named_object* chan_no = this->resolve_var_reference(send->channel());\n+\t      Named_object* val_no = resolve_var_reference(send->val());\n+\n+\t      if (chan_no == NULL || val_no == NULL)\n+\t\tbreak;\n+\n+\t      Node* chan_node = this->gogo_->add_connection_node(chan_no);\n+\t      Node* val_node = this->gogo_->add_connection_node(val_no);\n+\t      chan_node->add_edge(val_node);\n+\t    }\n+\t    break;\n+\n+\t  case Statement::STATEMENT_EXPRESSION:\n+\t    this->handle_call(var,\n+\t    \t\t      p->statement->expression_statement()->expr());\n+\t    break;\n+\n+\t  case Statement::STATEMENT_GO:\n+\t  case Statement::STATEMENT_DEFER:\n+\t    // Any variable referenced via a go or defer statement escapes to\n+\t    // a different goroutine.\n+\t    if (var_node->connection_node()->escape_state() > Node::ESCAPE_ARG)\n+\t      var_node->connection_node()->set_escape_state(Node::ESCAPE_ARG);\n+\t    this->handle_call(var, p->statement->thunk_statement()->call());\n+\t    break;\n+\n+\t  case Statement::STATEMENT_IF:\n+\t    {\n+\t      // If this is a reference via an if statement, it is interesting\n+\t      // if there is a function call in the condition.  References in\n+\t      // the then and else blocks would be discovered in an earlier\n+\t      // case.\n+\t      If_statement* if_stmt = p->statement->if_statement();\n+\t      Expression* cond = if_stmt->condition();\n+\t      if (cond->call_expression() != NULL)\n+\t\tthis->handle_call(var, cond);\n+\t      else if (cond->binary_expression() != NULL)\n+\t\t{\n+\t\t  Binary_expression* comp = cond->binary_expression();\n+\t\t  if (comp->left()->call_expression() != NULL)\n+\t\t    this->handle_call(var, comp->left());\n+\t\t  if (comp->right()->call_expression() != NULL)\n+\t\t    this->handle_call(var, comp->right());\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case Statement::STATEMENT_VARIABLE_DECLARATION:\n+\t    {\n+\t      // VAR could be referenced as the initialization for another\n+\t      // variable, V e.g. V := call(VAR) or V := &T{field: VAR}.\n+\t      Variable_declaration_statement* decl =\n+\t\tp->statement->variable_declaration_statement();\n+\t      Named_object* decl_no = decl->var();\n+\t      Variable* v = decl_no->var_value();\n+\n+\t      Expression* init = v->init();\n+\t      if (init == NULL)\n+\t\tbreak;\n+\n+\t      if (init->is_composite_literal()\n+\t\t  || init->heap_expression() != NULL)\n+\t\t{\n+\t\t  // Create edges between DECL_NO and each named object in the\n+\t\t  // composite literal.\n+\t\t  this->handle_composite_literal(decl_no, init);\n+\t\t}\n+\t      else if (init->call_result_expression() != NULL)\n+\t\t{\n+\t\t  // V's initialization will be a call result if\n+\t\t  // V, V1 := call(VAR).\n+\t\t  // There's no useful edges to make from V or V1, but we want\n+\t\t  // to make sure we handle the call that references VAR.\n+\t\t  Expression* call = init->call_result_expression()->call();\n+\t\t  this->handle_call(var, call);\n+\t\t}\n+\t      else if (init->call_expression() != NULL)\n+\t\tthis->handle_call(var, init);\n+\t    }\n+\t    break;\n+\n+\t  case Statement::STATEMENT_TEMPORARY:\n+\t    {\n+\t      // A call to a function with mutliple results that references VAR\n+\t      // will be lowered into a temporary at this point.  Make sure the\n+\t      // call that references VAR is handled.\n+\t      Expression* init = p->statement->temporary_statement()->init();\n+\t      if (init == NULL)\n+\t\tbreak;\n+\t      else if (init->call_result_expression() != NULL)\n+\t\t{\n+\t\t  Expression* call = init->call_result_expression()->call();\n+\t\t  this->handle_call(var, call);\n+\t\t}\n+\t    }\n+\n+\t  default:\n+\t    break;\n+\t  }\n+\t}\n+    }\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Traverse statements to find interesting references that might have not\n+// been recorded in the dataflow analysis.  For example, many statements\n+// in closures are not properly recorded during dataflow analysis.  This should\n+// handle all of the cases handled above in statements that reference a\n+// variable.  FIXME.\n+\n+int\n+Build_connection_graphs::statement(Block*, size_t*, Statement* s)\n+{\n+  switch(s->classification())\n+  {\n+  case Statement::STATEMENT_ASSIGNMENT:\n+    {\n+      Assignment_statement* assn = s->assignment_statement();\n+      Named_object* lhs_no = this->resolve_var_reference(assn->lhs());\n+\n+      if (lhs_no == NULL)\n+\tbreak;\n+\n+      if (assn->rhs()->func_expression() != NULL)\n+\t{\n+\t  Node* lhs_node = this->gogo_->add_connection_node(lhs_no);\n+\t  Named_object* fn = assn->rhs()->func_expression()->named_object();\n+\t  Node* fn_node = this->gogo_->add_connection_node(fn);\n+\t  lhs_node->add_edge(fn_node);\n+\t}\n+      else if (assn->rhs()->call_expression() != NULL)\n+\tthis->handle_call(lhs_no, assn->rhs()->call_expression());\n+      else\n+\t{\n+\t  Named_object* rhs_no = this->resolve_var_reference(assn->rhs());\n+\t  if (rhs_no != NULL)\n+\t    {\n+\t      Node* lhs_node = this->gogo_->add_connection_node(lhs_no);\n+\t      Node* rhs_node = this->gogo_->add_connection_node(rhs_no);\n+\t      lhs_node->add_edge(rhs_node);\n+\t    }\n+\t}\n+    }\n+    break;\n+\n+  case Statement::STATEMENT_SEND:\n+    {\n+      Send_statement* send = s->send_statement();\n+      Named_object* chan_no = this->resolve_var_reference(send->channel());\n+      Named_object* val_no = this->resolve_var_reference(send->val());\n+\n+      if (chan_no == NULL || val_no == NULL)\n+\tbreak;\n+\n+      Node* chan_node = this->gogo_->add_connection_node(chan_no);\n+      Node* val_node = this->gogo_->add_connection_node(val_no);\n+      chan_node->add_edge(val_node);\n+    }\n+    break;\n+\n+  case Statement::STATEMENT_EXPRESSION:\n+    {\n+      Expression* expr = s->expression_statement()->expr();\n+      if (expr->call_expression() != NULL)\n+\t{\n+\t  // It's not clear what variables we are trying to find references to\n+\t  // so just use the arguments to this call.\n+\t  Expression_list* args = expr->call_expression()->args();\n+\t  if (args == NULL)\n+\t    break;\n+\n+\t  for (Expression_list::const_iterator p = args->begin();\n+\t       p != args->end();\n+\t       ++p)\n+\t    {\n+\t      Named_object* no = this->resolve_var_reference(*p);\n+\t      if (no != NULL)\n+\t\tthis->handle_call(no, expr);\n+\t    }\n+\t}\n+    }\n+    break;\n+\n+  default:\n+    break;\n+  }\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Build the connection graphs for each function present in the call graph.\n+\n+void\n+Gogo::build_connection_graphs()\n+{\n+  Build_connection_graphs build_conns(this);\n+\n+  for (std::set<Node*>::const_iterator p = this->call_graph_.begin();\n+       p != this->call_graph_.end();\n+       ++p)\n+    {\n+      Named_object* func = (*p)->object();\n+      \n+      go_assert(func->is_function() || func->is_function_declaration());\n+      Function_type* fntype;\n+      if (func->is_function())\n+\tfntype = func->func_value()->type();\n+      else\n+\tfntype = func->func_declaration_value()->type();\n+      if (fntype->is_builtin())\n+\tcontinue;\n+\n+      this->add_connection_node(func);\n+      build_conns.set_current_function(func);\n+      if (func->is_function())\n+\t{\n+\t  // A pointer receiver of a method always escapes from the method.\n+\t  if (fntype->is_method() &&\n+\t      fntype->receiver()->type()->points_to() != NULL)\n+\t    {\n+\t      const Bindings* callee_bindings =\n+\t\tfunc->func_value()->block()->bindings();\n+\t      std::string rcvr_name = fntype->receiver()->name();\n+\t      if (Gogo::is_sink_name(rcvr_name) || rcvr_name.empty())\n+\t\treturn;\n+\n+\t      Named_object* rcvr_no = callee_bindings->lookup_local(rcvr_name);\n+\t      Node* rcvr_node = this->add_connection_node(rcvr_no);\n+\t      rcvr_node->connection_node()->set_escape_state(Node::ESCAPE_ARG);\n+\t    }\n+\t  func->func_value()->traverse(&build_conns);\n+\t}\n+    }\n+}\n+\n+void\n+Gogo::analyze_reachability()\n+{\n+  std::list<Node*> worklist;\n+\n+  // Run reachability analysis on all globally escaping objects.\n+  for (std::set<Node*>::const_iterator p = this->global_connections_.begin();\n+       p != this->global_connections_.end();\n+       ++p)\n+    worklist.push_back(*p);\n+\n+  while (!worklist.empty())\n+    {\n+      Node* m = worklist.front();\n+      worklist.pop_front();\n+\n+      for (std::set<Node*>::iterator n = m->edges().begin();\n+\t   n != m->edges().end();\n+\t   ++n)\n+\t{\n+\t  // If an object can be reached from a node with ESCAPE_GLOBAL,\n+\t  // it also must ESCAPE_GLOBAL.\n+\t  if ((*n)->connection_node()->escape_state() != Node::ESCAPE_GLOBAL)\n+\t    {\n+\t      (*n)->connection_node()->set_escape_state(Node::ESCAPE_GLOBAL);\n+\t      worklist.push_back(*n);\n+\t    }\n+\t}\n+    }\n+\n+  // Run reachability analysis on all objects that escape via arguments.\n+  for (Named_escape_nodes::const_iterator p =\n+\t this->named_connection_nodes_.begin();\n+       p != this->named_connection_nodes_.end();\n+       ++p)\n+    {\n+      if (p->second->connection_node()->escape_state() == Node::ESCAPE_ARG)\n+\tworklist.push_back(p->second);\n+    }\n+\n+  while (!worklist.empty())\n+    {\n+      Node* m = worklist.front();\n+      worklist.pop_front();\n+\n+      for (std::set<Node*>::iterator n = m->edges().begin();\n+\t   n != m->edges().end();\n+\t   ++n)\n+\t{\n+\t  // If an object can be reached from a node with ESCAPE_ARG,\n+\t  // it is ESCAPE_ARG or ESCAPE_GLOBAL.\n+\t  if ((*n)->connection_node()->escape_state() > Node::ESCAPE_ARG)\n+\t    {\n+\t      (*n)->connection_node()->set_escape_state(Node::ESCAPE_ARG);\n+\t      worklist.push_back(*n);\n+\t    }\n+\t}\n+    }  \n+}\n+\n+// Iterate over all functions analyzed in the analysis, recording escape\n+// information for each receiver and parameter.\n+\n+void\n+Gogo::mark_escaping_signatures()\n+{\n+  for (std::set<Node*>::const_iterator p = this->call_graph_.begin();\n+       p != this->call_graph_.end();\n+       ++p)\n+    {\n+      Named_object* fn = (*p)->object();\n+      if (!fn->is_function())\n+\tcontinue;\n+\n+      Function* func = fn->func_value();\n+      Function_type* fntype = func->type();\n+      const Bindings* bindings = func->block()->bindings();\n+\n+      // If this is a method, set the escape state of the receiver.\n+      if (fntype->is_method())\n+\t{\n+\t  std::string rcvr_name = fntype->receiver()->name();\n+\t  if (rcvr_name.empty() || Gogo::is_sink_name(rcvr_name))\n+\t    fntype->set_receiver_escape_state(Node::ESCAPE_NONE);\n+\t  else\n+\t    {\n+\t      Named_object* rcvr_no = bindings->lookup_local(rcvr_name);\n+\t      go_assert(rcvr_no != NULL);\n+\n+\t      Node* rcvr_node = this->lookup_connection_node(rcvr_no);\n+\t      if (rcvr_node != NULL)\n+\t\t{\n+\t\t  Node::Escapement_lattice e =\n+\t\t    rcvr_node->connection_node()->escape_state();\n+\t\t  fntype->set_receiver_escape_state(e);\n+\t\t}\n+\t      else\n+\t\tfntype->set_receiver_escape_state(Node::ESCAPE_NONE);\n+\t    }\n+\t  fntype->set_has_escape_info();\n+\t}\n+\n+      const Typed_identifier_list* params = fntype->parameters();\n+      if (params == NULL)\n+\tcontinue;\n+\n+      fntype->set_has_escape_info();\n+      Node::Escape_states* param_escape_states = new Node::Escape_states;\n+      for (Typed_identifier_list::const_iterator p1 = params->begin();\n+\t   p1 != params->end();\n+\t   ++p1)\n+\t{\n+\t  std::string param_name = p1->name();\n+\t  if (param_name.empty() || Gogo::is_sink_name(param_name))\n+\t    param_escape_states->push_back(Node::ESCAPE_NONE);\n+\t  else\n+\t    {\n+\t      Named_object* param_no = bindings->lookup_local(param_name);\n+\t      go_assert(param_no != NULL);\n+\n+\t      Node* param_node = this->lookup_connection_node(param_no);\n+\t      if (param_node == NULL)\n+\t\t{\n+\t\t  param_escape_states->push_back(Node::ESCAPE_NONE);\n+\t\t  continue;\n+\t\t}\n+\n+\t      Node::Escapement_lattice e =\n+\t\tparam_node->connection_node()->escape_state();\n+\t      param_escape_states->push_back(e);\n+\t    }\n+\t}\n+      go_assert(params->size() == param_escape_states->size());\n+      fntype->set_parameter_escape_states(param_escape_states);\n+    }\n+}\n+\n+class Optimize_allocations : public Traverse\n+{\n+ public:\n+  Optimize_allocations(Gogo* gogo)\n+    : Traverse(traverse_variables),\n+      gogo_(gogo)\n+  { }\n+\n+  int\n+  variable(Named_object*);\n+\n+ private:\n+  // The IR.\n+  Gogo* gogo_;\n+};\n+\n+// The -fgo-optimize-alloc flag activates this escape analysis.\n+\n+Go_optimize optimize_allocation_flag(\"allocs\");\n+\n+// Propagate escape information for each variable.\n+\n+int\n+Optimize_allocations::variable(Named_object* var)\n+{\n+  Node* var_node = this->gogo_->lookup_connection_node(var);\n+  if (var_node == NULL\n+      || var_node->connection_node()->escape_state() != Node::ESCAPE_NONE)\n+    return TRAVERSE_CONTINUE;\n+\n+  if (var->is_variable())\n+    {\n+      if (var->var_value()->is_address_taken())\n+      \tvar->var_value()->set_does_not_escape();\n+      if (var->var_value()->init() != NULL\n+\t  && var->var_value()->init()->allocation_expression() != NULL)\n+\t{\n+\t  Allocation_expression* alloc =\n+\t    var->var_value()->init()->allocation_expression();\n+\t  alloc->set_allocate_on_stack();\n+\t}\n+    }\n+  else if (var->is_result_variable()\n+\t   && var->result_var_value()->is_address_taken())\n+    var->result_var_value()->set_does_not_escape();\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Perform escape analysis on this program and optimize allocations using\n+// the derived information if -fgo-optimize-allocs.\n+\n+void\n+Gogo::optimize_allocations(const char** filenames)\n+{\n+  if (!::optimize_allocation_flag.is_enabled() || saw_errors())\n+    return;\n+\n+  // Build call graph for this program.\n+  this->build_call_graph();\n+\n+  // Dump the call graph for this program if -fgo-dump-calls is enabled.\n+  this->dump_call_graph(filenames[0]);\n+\n+  // Build the connection graphs for this program.\n+  this->build_connection_graphs();\n+\n+  // Dump the connection graphs if -fgo-dump-connections is enabled.\n+  this->dump_connection_graphs(filenames[0]);\n+\n+  // Given the connection graphs for this program, perform a reachability\n+  // analysis to determine what objects escape.\n+  this->analyze_reachability();\n+\n+  // Propagate escape information to variables and variable initializations.\n+  Optimize_allocations optimize_allocs(this);\n+  this->traverse(&optimize_allocs);\n+\n+  // Store escape information for a function's receivers and parameters in the\n+  // function's signature for use when exporting package information.\n+  this->mark_escaping_signatures();\n+}"}, {"sha": "42c79f61fad525def844bb15259d5e17ad7d3518", "filename": "gcc/go/gofrontend/escape.h", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fescape.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fescape.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.h?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -0,0 +1,310 @@\n+// escape.h -- Go frontend escape analysis.     -*- C++ -*-\n+\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_ESCAPE_H\n+#define GO_ESCAPE_H\n+\n+#include \"go-system.h\"\n+#include \"string-dump.h\"\n+\n+class Call_node;\n+class Connection_node;\n+class Connection_dump_context;\n+class Gogo;\n+class Named_object;\n+\n+// A basic escape analysis implementation for the Go frontend based on the\n+// algorithm from \"Escape Analysis for Java\" by Choi et. al in OOPSLA '99.\n+// This is a simplified version of the flow insensitive analysis with the goal\n+// of reducing the overhead cost of garbage collection by allocating objects\n+// on the stack when they do not escape the function they were created in.\n+//\n+// A major simplification is that the analysis only implements what Choi refers\n+// to as \"deferred edges\" which are used to used model assignments that copy\n+// references from one variable to another e.g. a := b.  It is unnecessary to\n+// consider assignments to the fields of an object because, in general, if a\n+// field of an object escapes and must be heap-allocated, there is no way to\n+// heap-allocate that escaping field without heap-allocating the entire object.\n+// That is, for some globally escaping object GVAR, if there is an assignment\n+// of the form GVAR = t.f such that field f of object t escapes, it is likely\n+// that t must be heap-allocated as well.  In the analysis, this assignment\n+// will be simplified to GVAR = t, which is imprecise but has the same effect.\n+\n+// This is a general graph node representing a named object used in a call graph\n+// or connection graph.  In a call graph, each named object is either a Function\n+// or Function_declaration representing a function called during the program\n+// execution (which isn't necessarily every function declared).  In a connection\n+// graph, there is a node for each node in the call graph, which forms the root\n+// of that connection graph.  Each connection graph root contains nodes whose\n+// objects are either variables used in the function defintion or are nested\n+// closures created within the function definition.  The connection graph is\n+// a way of modeling the connectivity between all objects created in a given\n+// function as well as understanding the relationship between input arguments\n+// in the caller and the formal parameters in the callee.\n+\n+class Node\n+{\n+ public:\n+  enum Node_classification\n+  {\n+    NODE_CALL,\n+    NODE_CONNECTION\n+  };\n+\n+  virtual ~Node();\n+\n+  // Make a call node for FUNCTION.\n+  static Node*\n+  make_call(Named_object* function);\n+\n+  // Make a connection node for OBJECT.\n+  // Note: values in this enum appear in export data, and therefore MUST NOT\n+  // change.\n+  enum Escapement_lattice\n+  {\n+    // ESCAPE_GLOBAL means that the object escapes all functions globally.\n+    ESCAPE_GLOBAL = 0,\n+    // ESCAPE_ARG with respect to a function means that the object escapes that\n+    // function it is created in via the function's arguments or results.\n+    ESCAPE_ARG = 1,\n+    // ESCAPE_NONE means that the object does not escape the function in which\n+    // it was created.\n+    ESCAPE_NONE = 2\n+  };\n+\n+  // A list of states usually corresponding to a list of function parameters.\n+  typedef std::vector<Escapement_lattice> Escape_states;\n+\n+  static Node*\n+  make_connection(Named_object* object, Escapement_lattice e);\n+\n+  // Return the node classification.\n+  Node_classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Return whether this is a call node.\n+  bool\n+  is_call() const\n+  { return this->classification_ == NODE_CALL; }\n+\n+  // Return whether this is a connection node.\n+  bool\n+  is_connection() const\n+  { return this->classification_ == NODE_CONNECTION; }\n+\n+  // If this is a connection node, return the Connection_node.\n+  // Otherwise, return NULL.\n+  Connection_node*\n+  connection_node()\n+  { return this->convert<Connection_node, NODE_CONNECTION>(); }\n+\n+  // Return this node's unique id.\n+  unsigned int\n+  id() const\n+  { return this->id_; }\n+\n+  // Return this node's generated name for GraphViz.\n+  virtual const std::string&\n+  name() = 0;\n+\n+  // Return this node's generated label for GraphViz.\n+  virtual const std::string&\n+  label();\n+\n+  // Return the object this node represents.\n+  Named_object*\n+  object() const\n+  { return this->object_; }\n+\n+  void\n+  add_edge(Node* v)\n+  { this->edges_.insert(v); }\n+\n+  const std::set<Node*>&\n+  edges() const\n+  { return this->edges_; }\n+\n+ protected:\n+  Node(Node_classification, Named_object* object);\n+\n+  const std::string&\n+  get_name() const\n+  { return this->name_; }\n+\n+  void\n+  set_name(const std::string& name)\n+  { this->name_ = name; }\n+\n+  const std::string&\n+  get_label() const\n+  { return this->label_; }\n+\n+  void\n+  set_label(const std::string& label)\n+  { this->label_ = label; }\n+\n+ private:\n+  template<typename Node_class,\n+\t   Node_classification node_classification>\n+  const Node_class*\n+  convert() const\n+  {\n+    return (this->classification_ == node_classification\n+\t    ? static_cast<const Node_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  template<typename Node_class,\n+\t   Node_classification node_classification>\n+  Node_class*\n+  convert()\n+  {\n+    return (this->classification_ == node_classification\n+\t    ? static_cast<Node_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  // The classification of this node.\n+  Node_classification classification_;\n+  // A unique ID for this node.\n+  unsigned int id_;\n+  // The name for this node e.g. \"Node<ID>\" used as a GraphViz identifier.\n+  std::string name_;\n+  // The label for this node in the GraphViz representation.\n+  std::string label_;\n+  // The object represented by this node.\n+  Named_object* object_;\n+  // A distinct set of nodes that this node has edges to.\n+  std::set<Node*> edges_;\n+};\n+\n+\n+// A node representing a function that might be called during program execution.\n+\n+class Call_node : public Node\n+{\n+ public:\n+  Call_node(Named_object* function);\n+\n+  const std::string&\n+  name();\n+};\n+\n+// A node representing an object in the connection graph built for each function\n+// in the call graph.\n+\n+class Connection_node : public Node\n+{\n+ public:\n+  Connection_node(Named_object* object, Escapement_lattice e)\n+    : Node(NODE_CONNECTION, object),\n+      escape_state_(e)\n+  { }\n+\n+  // Return this node's generated name for GraphViz.\n+  const std::string&\n+  name();\n+\n+  // Return this node's generated label for GraphViz.\n+  const std::string&\n+  label();\n+\n+  // Return the escape state for this node.\n+  Escapement_lattice\n+  escape_state() const\n+  { return this->escape_state_; }\n+\n+  // Set the escape state for this node.\n+  void\n+  set_escape_state(Escapement_lattice e)\n+  { this->escape_state_ = e; }\n+\n+  // Return the objects inside of this connection graph.\n+  // This is empty for all connection nodes that are not the root of a\n+  // connection graph.  Each node in the call graph is a root of a connection\n+  // graph.\n+  const std::set<Node*>&\n+  objects() const\n+  { return this->objects_; }\n+\n+  void\n+  add_object(Node* object)\n+  { this->objects_.insert(object); }\n+\n+  void\n+  dump_connection(Connection_dump_context*);\n+\n+ private:\n+  // The escapement of this node.\n+  Escapement_lattice escape_state_;\n+  // The set of nodes contained within this connection node.  If this node is\n+  // not a root of a connection graph, this will be empty.\n+  std::set<Node*> objects_;\n+};\n+\n+// This class implements fgo-dump-calls. The Call graph dump of a Go program.\n+\n+class Call_dump_context : public String_dump\n+{\n+ public:\n+  Call_dump_context(std::ostream* out = NULL);\n+\n+  // Initialize the dump context.\n+  void\n+  dump(Gogo*, const char* basename);\n+\n+  // Get dump output stream.\n+  std::ostream&\n+  ostream()\n+  { return *this->ostream_; }\n+\n+  // Implementation of String_dump interface.\n+  void\n+  write_c_string(const char*);\n+\n+  void\n+  write_string(const std::string&);\n+\n+ private:\n+  // Stream on output dump file.\n+  std::ostream* ostream_;\n+\n+  Gogo* gogo_;\n+};\n+\n+// This class implements fgo-dump-conns.  The connection graph dump of\n+// the functions called in a Go program.\n+\n+class Connection_dump_context : public String_dump\n+{\n+ public:\n+  Connection_dump_context(std::ostream* out = NULL);\n+\n+  // Initialize the dump context.\n+  void\n+  dump(Gogo*, const char* basename);\n+\n+  // Get dump output stream.\n+  std::ostream&\n+  ostream()\n+  { return *this->ostream_; }\n+\n+  // Implementation of String_dump interface.\n+  void\n+  write_c_string(const char*);\n+\n+  void\n+  write_string(const std::string&);\n+\n+ private:\n+  // Stream on output dump file.\n+  std::ostream* ostream_;\n+\n+  Gogo* gogo_;\n+};\n+\n+#endif // !defined(GO_ESCAPE_H)"}, {"sha": "e8617a1f9da9b4b85ca6815a26d0801930525bae", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -436,6 +436,17 @@ Export::write_type(const Type* type)\n     this->type_refs_[type] = index;\n }\n \n+// Export escape information.\n+\n+void\n+Export::write_escape(const Node::Escapement_lattice& e)\n+{\n+  char buf[30];\n+  snprintf(buf, sizeof buf, \"<escape %d>\", e);\n+  this->write_c_string(buf);\n+  return;\n+}\n+\n // Add the builtin types to the export table.\n \n void"}, {"sha": "92baa722c509d5cc85eb59e6fc90d31864ffed46", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -7,6 +7,7 @@\n #ifndef GO_EXPORT_H\n #define GO_EXPORT_H\n \n+#include \"escape.h\"\n #include \"string-dump.h\"\n \n struct sha1_ctx;\n@@ -161,6 +162,10 @@ class Export : public String_dump\n   void\n   write_type(const Type*);\n \n+  // Write out escape information.\n+  void\n+  write_escape(const Node::Escapement_lattice& e);\n+\n  private:\n   Export(const Export&);\n   Export& operator=(const Export&);"}, {"sha": "53edb99a2db2a4bb24454790b534983159905b06", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 119, "deletions": 667, "changes": 786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -3017,100 +3017,7 @@ Expression::make_iota()\n   return &iota_expression;\n }\n \n-// A type conversion expression.\n-\n-class Type_conversion_expression : public Expression\n-{\n- public:\n-  Type_conversion_expression(Type* type, Expression* expr,\n-\t\t\t     Location location)\n-    : Expression(EXPRESSION_CONVERSION, location),\n-      type_(type), expr_(expr), may_convert_function_types_(false)\n-  { }\n-\n-  // Return the type to which we are converting.\n-  Type*\n-  type() const\n-  { return this->type_; }\n-\n-  // Return the expression which we are converting.\n-  Expression*\n-  expr() const\n-  { return this->expr_; }\n-\n-  // Permit converting from one function type to another.  This is\n-  // used internally for method expressions.\n-  void\n-  set_may_convert_function_types()\n-  {\n-    this->may_convert_function_types_ = true;\n-  }\n-\n-  // Import a type conversion expression.\n-  static Expression*\n-  do_import(Import*);\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse);\n-\n-  Expression*\n-  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n-\n-  Expression*\n-  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n-\n-  bool\n-  do_is_constant() const;\n-\n-  bool\n-  do_is_immutable() const;\n-\n-  bool\n-  do_numeric_constant_value(Numeric_constant*) const;\n-\n-  bool\n-  do_string_constant_value(std::string*) const;\n-\n-  Type*\n-  do_type()\n-  { return this->type_; }\n-\n-  void\n-  do_determine_type(const Type_context*)\n-  {\n-    Type_context subcontext(this->type_, false);\n-    this->expr_->determine_type(&subcontext);\n-  }\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return new Type_conversion_expression(this->type_, this->expr_->copy(),\n-\t\t\t\t\t  this->location());\n-  }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context* context);\n-\n-  void\n-  do_export(Export*) const;\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n- private:\n-  // The type to convert to.\n-  Type* type_;\n-  // The expression to convert.\n-  Expression* expr_;\n-  // True if this is permitted to convert function types.  This is\n-  // used internally for method expressions.\n-  bool may_convert_function_types_;\n-};\n+// Class Type_conversion_expression.\n \n // Traversal.\n \n@@ -3300,6 +3207,15 @@ Type_conversion_expression::do_string_constant_value(std::string* val) const\n   return false;\n }\n \n+// Determine the resulting type of the conversion.\n+\n+void\n+Type_conversion_expression::do_determine_type(const Type_context*)\n+{\n+  Type_context subcontext(this->type_, false);\n+  this->expr_->determine_type(&subcontext);\n+}\n+\n // Check that types are convertible.\n \n void\n@@ -3750,6 +3666,19 @@ Unary_expression::do_flatten(Gogo* gogo, Named_object*,\n         }\n     }\n \n+  if (this->op_ == OPERATOR_AND)\n+    {\n+      if (this->expr_->var_expression() != NULL)\n+\t{\n+\t  Named_object* var = this->expr_->var_expression()->named_object();\n+\t  if (var->is_variable())\n+\t    this->escapes_ = var->var_value()->escapes();\n+\t  if (var->is_result_variable())\n+\t    this->escapes_ = var->result_var_value()->escapes();\n+\t}\n+      this->expr_->address_taken(this->escapes_);\n+    }\n+\n   if (this->create_temp_ && !this->expr_->is_variable())\n     {\n       Temporary_statement* temp =\n@@ -4070,10 +3999,7 @@ Unary_expression::do_check_types(Gogo*)\n \t    }\n \t}\n       else\n-        {\n-          this->expr_->address_taken(this->escapes_);\n-          this->expr_->issue_nil_check();\n-        }\n+\tthis->expr_->issue_nil_check();\n       break;\n \n     case OPERATOR_MULT:\n@@ -6360,13 +6286,15 @@ Bound_method_expression::create_thunk(Gogo* gogo, const Method* method,\n \n   Function_type* new_fntype = orig_fntype->copy_with_names();\n \n-  Named_object* new_no = gogo->start_function(Gogo::thunk_name(), new_fntype,\n+  std::string thunk_name = Gogo::thunk_name();\n+  Named_object* new_no = gogo->start_function(thunk_name, new_fntype,\n \t\t\t\t\t      false, loc);\n \n   Variable* cvar = new Variable(closure_type, NULL, false, false, false, loc);\n   cvar->set_is_used();\n   cvar->set_is_closure();\n-  Named_object* cp = Named_object::make_variable(\"$closure\", NULL, cvar);\n+  Named_object* cp = Named_object::make_variable(\"$closure\" + thunk_name,\n+\t\t\t\t\t\t NULL, cvar);\n   new_no->func_value()->set_closure_var(cp);\n \n   gogo->start_block(loc);\n@@ -8080,7 +8008,9 @@ Builtin_call_expression::do_copy()\n {\n   Call_expression* bce =\n     new Builtin_call_expression(this->gogo_, this->fn()->copy(),\n-\t\t\t\tthis->args()->copy(),\n+\t\t\t\t(this->args() == NULL\n+\t\t\t\t ? NULL\n+\t\t\t\t : this->args()->copy()),\n \t\t\t\tthis->is_varargs(),\n \t\t\t\tthis->location());\n \n@@ -9505,52 +9435,7 @@ Expression::make_call(Expression* fn, Expression_list* args, bool is_varargs,\n   return new Call_expression(fn, args, is_varargs, location);\n }\n \n-// A single result from a call which returns multiple results.\n-\n-class Call_result_expression : public Expression\n-{\n- public:\n-  Call_result_expression(Call_expression* call, unsigned int index)\n-    : Expression(EXPRESSION_CALL_RESULT, call->location()),\n-      call_(call), index_(index)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse*);\n-\n-  Type*\n-  do_type();\n-\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return new Call_result_expression(this->call_->call_expression(),\n-\t\t\t\t      this->index_);\n-  }\n-\n-  bool\n-  do_must_eval_in_order() const\n-  { return true; }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context*);\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n- private:\n-  // The underlying call expression.\n-  Expression* call_;\n-  // Which result we want.\n-  unsigned int index_;\n-};\n+// Class Call_result_expression.\n \n // Traverse a call result.\n \n@@ -9813,85 +9698,7 @@ Expression::make_index(Expression* left, Expression* start, Expression* end,\n   return new Index_expression(left, start, end, cap, location);\n }\n \n-// An array index.  This is used for both indexing and slicing.\n-\n-class Array_index_expression : public Expression\n-{\n- public:\n-  Array_index_expression(Expression* array, Expression* start,\n-\t\t\t Expression* end, Expression* cap, Location location)\n-    : Expression(EXPRESSION_ARRAY_INDEX, location),\n-      array_(array), start_(start), end_(end), cap_(cap), type_(NULL)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse*);\n-\n-  Expression*\n-  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n-\n-  Type*\n-  do_type();\n-\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return Expression::make_array_index(this->array_->copy(),\n-\t\t\t\t\tthis->start_->copy(),\n-\t\t\t\t\t(this->end_ == NULL\n-\t\t\t\t\t ? NULL\n-\t\t\t\t\t : this->end_->copy()),\n-\t\t\t\t\t(this->cap_ == NULL\n-\t\t\t\t\t ? NULL\n-\t\t\t\t\t : this->cap_->copy()),\n-\t\t\t\t\tthis->location());\n-  }\n-\n-  bool\n-  do_must_eval_subexpressions_in_order(int* skip) const\n-  {\n-    *skip = 1;\n-    return true;\n-  }\n-\n-  bool\n-  do_is_addressable() const;\n-\n-  void\n-  do_address_taken(bool escapes)\n-  { this->array_->address_taken(escapes); }\n-\n-  void\n-  do_issue_nil_check()\n-  { this->array_->issue_nil_check(); }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context*);\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-  \n- private:\n-  // The array we are getting a value from.\n-  Expression* array_;\n-  // The start or only index.\n-  Expression* start_;\n-  // The end index of a slice.  This may be NULL for a simple array\n-  // index, or it may be a nil expression for the length of the array.\n-  Expression* end_;\n-  // The capacity argument of a slice.  This may be NULL for an array index or\n-  // slice.\n-  Expression* cap_;\n-  // The type of the expression.\n-  Type* type_;\n-};\n+// Class Array_index_expression.\n \n // Array index traversal.\n \n@@ -11187,13 +10994,15 @@ Interface_field_reference_expression::create_thunk(Gogo* gogo,\n \n   Function_type* new_fntype = orig_fntype->copy_with_names();\n \n-  Named_object* new_no = gogo->start_function(Gogo::thunk_name(), new_fntype,\n+  std::string thunk_name = Gogo::thunk_name();\n+  Named_object* new_no = gogo->start_function(thunk_name, new_fntype,\n \t\t\t\t\t      false, loc);\n \n   Variable* cvar = new Variable(closure_type, NULL, false, false, false, loc);\n   cvar->set_is_used();\n   cvar->set_is_closure();\n-  Named_object* cp = Named_object::make_variable(\"$closure\", NULL, cvar);\n+  Named_object* cp = Named_object::make_variable(\"$closure\" + thunk_name,\n+\t\t\t\t\t\t NULL, cvar);\n   new_no->func_value()->set_closure_var(cp);\n \n   gogo->start_block(loc);\n@@ -11593,43 +11402,45 @@ Expression::make_selector(Expression* left, const std::string& name,\n   return new Selector_expression(left, name, location);\n }\n \n-// Implement the builtin function new.\n+// Class Allocation_expression.\n \n-class Allocation_expression : public Expression\n+int\n+Allocation_expression::do_traverse(Traverse* traverse)\n {\n- public:\n-  Allocation_expression(Type* type, Location location)\n-    : Expression(EXPRESSION_ALLOCATION, location),\n-      type_(type)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse)\n-  { return Type::traverse(this->type_, traverse); }\n-\n-  Type*\n-  do_type()\n-  { return Type::make_pointer_type(this->type_); }\n+  return Type::traverse(this->type_, traverse);\n+}\n \n-  void\n-  do_determine_type(const Type_context*)\n-  { }\n+Type*\n+Allocation_expression::do_type()\n+{\n+  return Type::make_pointer_type(this->type_);\n+}\n \n-  Expression*\n-  do_copy()\n-  { return new Allocation_expression(this->type_, this->location()); }\n+// Make a copy of an allocation expression.\n \n-  Bexpression*\n-  do_get_backend(Translate_context*);\n+Expression*\n+Allocation_expression::do_copy()\n+{\n+  Allocation_expression* alloc =\n+    new Allocation_expression(this->type_, this->location());\n+  if (this->allocate_on_stack_)\n+    alloc->set_allocate_on_stack();\n+  return alloc;\n+}\n \n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-  \n- private:\n-  // The type we are allocating.\n-  Type* type_;\n-};\n+Expression*\n+Allocation_expression::do_flatten(Gogo*, Named_object*,\n+\t\t\t\t  Statement_inserter* inserter)\n+{\n+  if (this->allocate_on_stack_)\n+    {\n+      this->stack_temp_ = Statement::make_temporary(this->type_, NULL,\n+\t\t\t\t\t\t    this->location());\n+      this->stack_temp_->set_is_address_taken();\n+      inserter->insert(this->stack_temp_);\n+    }\n+  return this;\n+}\n \n // Return the backend representation for an allocation expression.\n \n@@ -11638,6 +11449,15 @@ Allocation_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Location loc = this->location();\n+\n+  if (this->stack_temp_ != NULL)\n+    {\n+      Expression* ref =\n+\tExpression::make_temporary_reference(this->stack_temp_, loc);\n+      ref = Expression::make_unary(OPERATOR_AND, ref, loc);\n+      return ref->get_backend(context);\n+    }\n+\n   Bexpression* space = \n     gogo->allocate_memory(this->type_, loc)->get_backend(context);\n   Btype* pbtype = gogo->backend()->pointer_type(this->type_->get_backend(gogo));\n@@ -11663,80 +11483,7 @@ Expression::make_allocation(Type* type, Location location)\n   return new Allocation_expression(type, location);\n }\n \n-// Construct a struct.\n-\n-class Struct_construction_expression : public Expression\n-{\n- public:\n-  Struct_construction_expression(Type* type, Expression_list* vals,\n-\t\t\t\t Location location)\n-    : Expression(EXPRESSION_STRUCT_CONSTRUCTION, location),\n-      type_(type), vals_(vals), traverse_order_(NULL)\n-  { }\n-\n-  // Set the traversal order, used to ensure that we implement the\n-  // order of evaluation rules.  Takes ownership of the argument.\n-  void\n-  set_traverse_order(std::vector<int>* traverse_order)\n-  { this->traverse_order_ = traverse_order; }\n-\n-  // Return whether this is a constant initializer.\n-  bool\n-  is_constant_struct() const;\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse);\n-\n-  bool\n-  do_is_immutable() const;\n-\n-  Type*\n-  do_type()\n-  { return this->type_; }\n-\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  Expression*\n-  do_copy()\n-  {\n-    Struct_construction_expression* ret =\n-      new Struct_construction_expression(this->type_,\n-\t\t\t\t\t (this->vals_ == NULL\n-\t\t\t\t\t  ? NULL\n-\t\t\t\t\t  : this->vals_->copy()),\n-\t\t\t\t\t this->location());\n-    if (this->traverse_order_ != NULL)\n-      ret->set_traverse_order(this->traverse_order_);\n-    return ret;\n-  }\n-\n-  Expression*\n-  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n-\n-  Bexpression*\n-  do_get_backend(Translate_context*);\n-\n-  void\n-  do_export(Export*) const;\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n- private:\n-  // The type of the struct to construct.\n-  Type* type_;\n-  // The list of values, in order of the fields in the struct.  A NULL\n-  // entry means that the field should be zero-initialized.\n-  Expression_list* vals_;\n-  // If not NULL, the order in which to traverse vals_.  This is used\n-  // so that we implement the order of evaluation rules correctly.\n-  std::vector<int>* traverse_order_;\n-};\n+// Class Struct_construction_expression.\n \n // Traversal.\n \n@@ -12003,80 +11750,7 @@ Expression::make_struct_composite_literal(Type* type, Expression_list* vals,\n   return new Struct_construction_expression(type, vals, location);\n }\n \n-// Construct an array.  This class is not used directly; instead we\n-// use the child classes, Fixed_array_construction_expression and\n-// Slice_construction_expression.\n-\n-class Array_construction_expression : public Expression\n-{\n- protected:\n-  Array_construction_expression(Expression_classification classification,\n-\t\t\t\tType* type,\n-\t\t\t\tconst std::vector<unsigned long>* indexes,\n-\t\t\t\tExpression_list* vals, Location location)\n-    : Expression(classification, location),\n-      type_(type), indexes_(indexes), vals_(vals)\n-  { go_assert(indexes == NULL || indexes->size() == vals->size()); }\n-\n- public:\n-  // Return whether this is a constant initializer.\n-  bool\n-  is_constant_array() const;\n-\n-  // Return the number of elements.\n-  size_t\n-  element_count() const\n-  { return this->vals_ == NULL ? 0 : this->vals_->size(); }\n-\n-protected:\n-  virtual int\n-  do_traverse(Traverse* traverse);\n-\n-  bool\n-  do_is_immutable() const;\n-\n-  Type*\n-  do_type()\n-  { return this->type_; }\n-\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  void\n-  do_export(Export*) const;\n-\n-  // The indexes.\n-  const std::vector<unsigned long>*\n-  indexes()\n-  { return this->indexes_; }\n-\n-  // The list of values.\n-  Expression_list*\n-  vals()\n-  { return this->vals_; }\n-\n-  Expression*\n-  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n-\n-  // Get the backend constructor for the array values.\n-  Bexpression*\n-  get_constructor(Translate_context* context, Btype* btype);\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n- private:\n-  // The type of the array to construct.\n-  Type* type_;\n-  // The list of indexes into the array, one for each value.  This may\n-  // be NULL, in which case the indexes start at zero and increment.\n-  const std::vector<unsigned long>* indexes_;\n-  // The list of values.  This may be NULL if there are no values.\n-  Expression_list* vals_;\n-};\n+// Class Array_construction_expression.\n \n // Traversal.\n \n@@ -12332,34 +12006,14 @@ Array_construction_expression::do_dump_expression(\n \n }\n \n-// Construct a fixed array.\n-\n-class Fixed_array_construction_expression :\n-  public Array_construction_expression\n-{\n- public:\n-  Fixed_array_construction_expression(Type* type,\n-\t\t\t\t      const std::vector<unsigned long>* indexes,\n-\t\t\t\t      Expression_list* vals, Location location)\n-    : Array_construction_expression(EXPRESSION_FIXED_ARRAY_CONSTRUCTION,\n-\t\t\t\t    type, indexes, vals, location)\n-  { go_assert(type->array_type() != NULL && !type->is_slice_type()); }\n-\n- protected:\n-  Expression*\n-  do_copy()\n-  {\n-    return new Fixed_array_construction_expression(this->type(),\n-\t\t\t\t\t\t   this->indexes(),\n-\t\t\t\t\t\t   (this->vals() == NULL\n-\t\t\t\t\t\t    ? NULL\n-\t\t\t\t\t\t    : this->vals()->copy()),\n-\t\t\t\t\t\t   this->location());\n-  }\n+// Class Fixed_array_construction_expression.\n \n-  Bexpression*\n-  do_get_backend(Translate_context*);\n-};\n+Fixed_array_construction_expression::Fixed_array_construction_expression(\n+    Type* type, const std::vector<unsigned long>* indexes,\n+    Expression_list* vals, Location location)\n+  : Array_construction_expression(EXPRESSION_FIXED_ARRAY_CONSTRUCTION,\n+\t\t\t\t  type, indexes, vals, location)\n+{ go_assert(type->array_type() != NULL && !type->is_slice_type()); }\n \n // Return the backend representation for constructing a fixed array.\n \n@@ -12379,60 +12033,34 @@ Expression::make_array_composite_literal(Type* type, Expression_list* vals,\n   return new Fixed_array_construction_expression(type, NULL, vals, location);\n }\n \n-// Construct a slice.\n+// Class Slice_construction_expression.\n \n-class Slice_construction_expression : public Array_construction_expression\n+Slice_construction_expression::Slice_construction_expression(\n+  Type* type, const std::vector<unsigned long>* indexes,\n+  Expression_list* vals, Location location)\n+  : Array_construction_expression(EXPRESSION_SLICE_CONSTRUCTION,\n+\t\t\t\t  type, indexes, vals, location),\n+    valtype_(NULL)\n {\n- public:\n-  Slice_construction_expression(Type* type,\n-\t\t\t\tconst std::vector<unsigned long>* indexes,\n-\t\t\t\tExpression_list* vals, Location location)\n-    : Array_construction_expression(EXPRESSION_SLICE_CONSTRUCTION,\n-\t\t\t\t    type, indexes, vals, location),\n-      valtype_(NULL)\n-  {\n-    go_assert(type->is_slice_type());\n-\n-    unsigned long lenval;\n-    Expression* length;\n-    if (vals == NULL || vals->empty())\n-      lenval = 0;\n-    else\n-      {\n-\tif (this->indexes() == NULL)\n-\t  lenval = vals->size();\n-\telse\n-\t  lenval = indexes->back() + 1;\n-      }\n-    Type* int_type = Type::lookup_integer_type(\"int\");\n-    length = Expression::make_integer_ul(lenval, int_type, location);\n-    Type* element_type = type->array_type()->element_type();\n-    this->valtype_ = Type::make_array_type(element_type, length);\n-  }\n-\n- protected:\n-  // Note that taking the address of a slice literal is invalid.\n-\n-  int\n-  do_traverse(Traverse* traverse);\n+  go_assert(type->is_slice_type());\n \n-  Expression*\n-  do_copy()\n-  {\n-    return new Slice_construction_expression(this->type(), this->indexes(),\n-\t\t\t\t\t     (this->vals() == NULL\n-\t\t\t\t\t      ? NULL\n-\t\t\t\t\t      : this->vals()->copy()),\n-\t\t\t\t\t     this->location());\n-  }\n+  unsigned long lenval;\n+  Expression* length;\n+  if (vals == NULL || vals->empty())\n+    lenval = 0;\n+  else\n+    {\n+      if (this->indexes() == NULL)\n+\tlenval = vals->size();\n+      else\n+\tlenval = indexes->back() + 1;\n+    }\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+  length = Expression::make_integer_ul(lenval, int_type, location);\n+  Type* element_type = type->array_type()->element_type();\n+  this->valtype_ = Type::make_array_type(element_type, length);\n+}\n \n-  Bexpression*\n-  do_get_backend(Translate_context*);\n-\n- private:\n-  // The type of the values in this slice.\n-  Type* valtype_;\n-};\n \n // Traversal.\n \n@@ -12514,63 +12142,7 @@ Expression::make_slice_composite_literal(Type* type, Expression_list* vals,\n   return new Slice_construction_expression(type, NULL, vals, location);\n }\n \n-// Construct a map.\n-\n-class Map_construction_expression : public Expression\n-{\n- public:\n-  Map_construction_expression(Type* type, Expression_list* vals,\n-\t\t\t      Location location)\n-    : Expression(EXPRESSION_MAP_CONSTRUCTION, location),\n-      type_(type), vals_(vals), element_type_(NULL), constructor_temp_(NULL)\n-  { go_assert(vals == NULL || vals->size() % 2 == 0); }\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse);\n-\n-  Expression*\n-  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n-\n-  Type*\n-  do_type()\n-  { return this->type_; }\n-\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return new Map_construction_expression(this->type_,\n-\t\t\t\t\t   (this->vals_ == NULL\n-\t\t\t\t\t    ? NULL\n-\t\t\t\t\t    : this->vals_->copy()),\n-\t\t\t\t\t   this->location());\n-  }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context*);\n-\n-  void\n-  do_export(Export*) const;\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-  \n- private:\n-  // The type of the map to construct.\n-  Type* type_;\n-  // The list of values.\n-  Expression_list* vals_;\n-  // The type of the key-value pair struct for each map element.\n-  Struct_type* element_type_;\n-  // A temporary reference to the variable storing the constructor initializer.\n-  Temporary_statement* constructor_temp_;\n-};\n+// Class Map_construction_expression.\n \n // Traversal.\n \n@@ -13680,53 +13252,11 @@ Expression::make_type_guard(Expression* expr, Type* type,\n \n // Class Heap_expression.\n \n-// When you take the address of an escaping expression, it is allocated\n-// on the heap.  This class implements that.\n+// Return the type of the expression stored on the heap.\n \n-class Heap_expression : public Expression\n-{\n- public:\n-  Heap_expression(Expression* expr, Location location)\n-    : Expression(EXPRESSION_HEAP, location),\n-      expr_(expr)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse)\n-  { return Expression::traverse(&this->expr_, traverse); }\n-\n-  Type*\n-  do_type()\n-  { return Type::make_pointer_type(this->expr_->type()); }\n-\n-  void\n-  do_determine_type(const Type_context*)\n-  { this->expr_->determine_type_no_context(); }\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return Expression::make_heap_expression(this->expr_->copy(),\n-                                            this->location());\n-  }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context*);\n-\n-  // We only export global objects, and the parser does not generate\n-  // this in global scope.\n-  void\n-  do_export(Export*) const\n-  { go_unreachable(); }\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n- private:\n-  // The expression which is being put on the heap.\n-  Expression* expr_;\n-};\n+Type*\n+Heap_expression::do_type()\n+{ return Type::make_pointer_type(this->expr_->type()); }\n \n // Return the backend representation for allocating an expression on the heap.\n \n@@ -14964,48 +14494,7 @@ Expression::make_label_addr(Label* label, Location location)\n   return new Label_addr_expression(label, location);\n }\n \n-// Conditional expressions.\n-\n-class Conditional_expression : public Expression\n-{\n- public:\n-  Conditional_expression(Expression* cond, Expression* then_expr,\n-                         Expression* else_expr, Location location)\n-      : Expression(EXPRESSION_CONDITIONAL, location),\n-        cond_(cond), then_(then_expr), else_(else_expr)\n-  {}\n-\n- protected:\n-  int\n-  do_traverse(Traverse*);\n-\n-  Type*\n-  do_type();\n-\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return new Conditional_expression(this->cond_->copy(), this->then_->copy(),\n-                                      this->else_->copy(), this->location());\n-  }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context* context);\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n- private:\n-  // The condition to be checked.\n-  Expression* cond_;\n-  // The expression to execute if the condition is true.\n-  Expression* then_;\n-  // The expression to execute if the condition is false.\n-  Expression* else_;\n-};\n+// Class Conditional_expression.\n \n // Traversal.\n \n@@ -15084,44 +14573,7 @@ Expression::make_conditional(Expression* cond, Expression* then,\n   return new Conditional_expression(cond, then, else_expr, location);\n }\n \n-// Compound expressions.\n-\n-class Compound_expression : public Expression\n-{\n- public:\n-  Compound_expression(Expression* init, Expression* expr, Location location)\n-      : Expression(EXPRESSION_COMPOUND, location), init_(init), expr_(expr)\n-  {}\n-\n- protected:\n-  int\n-  do_traverse(Traverse*);\n-\n-  Type*\n-  do_type();\n-\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return new Compound_expression(this->init_->copy(), this->expr_->copy(),\n-                                   this->location());\n-  }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context* context);\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n- private:\n-  // The expression that is evaluated first and discarded.\n-  Expression* init_;\n-  // The expression that is evaluated and returned.\n-  Expression* expr_;\n-};\n+// Class Compound_expression.\n \n // Traversal.\n "}, {"sha": "0d7ad5ae8fe2e2e9e443b73b0b26aae857ef1908", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 786, "deletions": 0, "changes": 786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -31,19 +31,31 @@ class Var_expression;\n class Temporary_reference_expression;\n class Set_and_use_temporary_expression;\n class String_expression;\n+class Type_conversion_expression;\n class Unary_expression;\n class Binary_expression;\n class Call_expression;\n+class Call_result_expression;\n class Func_expression;\n class Func_descriptor_expression;\n class Unknown_expression;\n class Index_expression;\n+class Array_index_expression;\n class Map_index_expression;\n class Bound_method_expression;\n class Field_reference_expression;\n class Interface_field_reference_expression;\n+class Allocation_expression;\n+class Struct_construction_expression;\n+class Array_construction_expression;\n+class Fixed_array_construction_expression;\n+class Slice_construction_expression;\n+class Map_construction_expression;\n class Type_guard_expression;\n+class Heap_expression;\n class Receive_expression;\n+class Conditional_expression;\n+class Compound_expression;\n class Numeric_constant;\n class Named_object;\n class Export;\n@@ -553,6 +565,12 @@ class Expression\n   string_expression()\n   { return this->convert<String_expression, EXPRESSION_STRING>(); }\n \n+  // If this is a conversion expression, return the Type_conversion_expression\n+  // structure.  Otherwise, return NULL.\n+  Type_conversion_expression*\n+  conversion_expression()\n+  { return this->convert<Type_conversion_expression, EXPRESSION_CONVERSION>(); }\n+\n   // Return whether this is the expression nil.\n   bool\n   is_nil_expression() const\n@@ -582,6 +600,13 @@ class Expression\n   call_expression()\n   { return this->convert<Call_expression, EXPRESSION_CALL>(); }\n \n+  // If this is a call_result expression, return the Call_result_expression\n+  // structure.  Otherwise, return NULL.  This is a controlled dynamic\n+  // cast.\n+  Call_result_expression*\n+  call_result_expression()\n+  { return this->convert<Call_result_expression, EXPRESSION_CALL_RESULT>(); }\n+\n   // If this is an expression which refers to a function, return the\n   // Func_expression structure.  Otherwise, return NULL.\n   Func_expression*\n@@ -611,6 +636,13 @@ class Expression\n   index_expression()\n   { return this->convert<Index_expression, EXPRESSION_INDEX>(); }\n \n+  // If this is an expression which refers to indexing in a array,\n+  // return the Array_index_expression structure.  Otherwise, return\n+  // NULL.\n+  Array_index_expression*\n+  array_index_expression()\n+  { return this->convert<Array_index_expression, EXPRESSION_ARRAY_INDEX>(); }\n+\n   // If this is an expression which refers to indexing in a map,\n   // return the Map_index_expression structure.  Otherwise, return\n   // NULL.\n@@ -643,18 +675,78 @@ class Expression\n \t\t\t EXPRESSION_INTERFACE_FIELD_REFERENCE>();\n   }\n \n+  // If this is an allocation expression, return the Allocation_expression\n+  // structure.  Otherwise, return NULL.\n+  Allocation_expression*\n+  allocation_expression()\n+  { return this->convert<Allocation_expression, EXPRESSION_ALLOCATION>(); }\n+\n+  // If this is a struct composite literal, return the\n+  // Struct_construction_expression structure.  Otherwise, return NULL.\n+  Struct_construction_expression*\n+  struct_literal()\n+  {\n+    return this->convert<Struct_construction_expression,\n+\t\t\t EXPRESSION_STRUCT_CONSTRUCTION>();\n+  }\n+\n+  // If this is a array composite literal, return the\n+  // Array_construction_expression structure.  Otherwise, return NULL.\n+  Fixed_array_construction_expression*\n+  array_literal()\n+  {\n+    return this->convert<Fixed_array_construction_expression,\n+\t\t\t EXPRESSION_FIXED_ARRAY_CONSTRUCTION>();\n+  }\n+\n+  // If this is a slice composite literal, return the\n+  // Slice_construction_expression structure.  Otherwise, return NULL.\n+  Slice_construction_expression*\n+  slice_literal()\n+  {\n+    return this->convert<Slice_construction_expression,\n+\t\t\t EXPRESSION_SLICE_CONSTRUCTION>();\n+  }\n+\n+  // If this is a map composite literal, return the\n+  // Map_construction_expression structure.  Otherwise, return NULL.\n+  Map_construction_expression*\n+  map_literal()\n+  {\n+    return this->convert<Map_construction_expression,\n+\t\t\t EXPRESSION_MAP_CONSTRUCTION>();\n+  }\n+\n   // If this is a type guard expression, return the\n   // Type_guard_expression structure.  Otherwise, return NULL.\n   Type_guard_expression*\n   type_guard_expression()\n   { return this->convert<Type_guard_expression, EXPRESSION_TYPE_GUARD>(); }\n \n+  // If this is a heap expression, returhn the Heap_expression structure.\n+  // Otherwise, return NULL.\n+  Heap_expression*\n+  heap_expression()\n+  { return this->convert<Heap_expression, EXPRESSION_HEAP>(); }\n+\n   // If this is a receive expression, return the Receive_expression\n   // structure.  Otherwise, return NULL.\n   Receive_expression*\n   receive_expression()\n   { return this->convert<Receive_expression, EXPRESSION_RECEIVE>(); }\n \n+  // If this is a conditional expression, return the Conditional_expression\n+  // structure.  Otherwise, return NULL.\n+  Conditional_expression*\n+  conditional_expression()\n+  { return this->convert<Conditional_expression, EXPRESSION_CONDITIONAL>(); }\n+\n+  // If this is a compound expression, return the Compound_expression structure.\n+  // Otherwise, return NULL.\n+  Compound_expression*\n+  compound_expression()\n+  { return this->convert<Compound_expression, EXPRESSION_COMPOUND>(); }\n+\n   // Return true if this is a composite literal.\n   bool\n   is_composite_literal() const;\n@@ -1322,6 +1414,97 @@ class String_expression : public Expression\n   Type* type_;\n };\n \n+// A type conversion expression.\n+\n+class Type_conversion_expression : public Expression\n+{\n+ public:\n+  Type_conversion_expression(Type* type, Expression* expr,\n+\t\t\t     Location location)\n+    : Expression(EXPRESSION_CONVERSION, location),\n+      type_(type), expr_(expr), may_convert_function_types_(false)\n+  { }\n+\n+  // Return the type to which we are converting.\n+  Type*\n+  type() const\n+  { return this->type_; }\n+\n+  // Return the expression which we are converting.\n+  Expression*\n+  expr() const\n+  { return this->expr_; }\n+\n+  // Permit converting from one function type to another.  This is\n+  // used internally for method expressions.\n+  void\n+  set_may_convert_function_types()\n+  {\n+    this->may_convert_function_types_ = true;\n+  }\n+\n+  // Import a type conversion expression.\n+  static Expression*\n+  do_import(Import*);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  bool\n+  do_is_constant() const;\n+\n+  bool\n+  do_is_immutable() const;\n+\n+  bool\n+  do_numeric_constant_value(Numeric_constant*) const;\n+\n+  bool\n+  do_string_constant_value(std::string*) const;\n+\n+  Type*\n+  do_type()\n+  { return this->type_; }\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Type_conversion_expression(this->type_, this->expr_->copy(),\n+\t\t\t\t\t  this->location());\n+  }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n+\n+  void\n+  do_export(Export*) const;\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The type to convert to.\n+  Type* type_;\n+  // The expression to convert.\n+  Expression* expr_;\n+  // True if this is permitted to convert function types.  This is\n+  // used internally for method expressions.\n+  bool may_convert_function_types_;\n+};\n+\n // A Unary expression.\n \n class Unary_expression : public Expression\n@@ -1827,6 +2010,57 @@ class Call_expression : public Expression\n   bool is_flattened_;\n };\n \n+// A single result from a call which returns multiple results.\n+\n+class Call_result_expression : public Expression\n+{\n+ public:\n+  Call_result_expression(Call_expression* call, unsigned int index)\n+    : Expression(EXPRESSION_CALL_RESULT, call->location()),\n+      call_(call), index_(index)\n+  { }\n+\n+  Expression*\n+  call() const\n+  { return this->call_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Call_result_expression(this->call_->call_expression(),\n+\t\t\t\t      this->index_);\n+  }\n+\n+  bool\n+  do_must_eval_in_order() const\n+  { return true; }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The underlying call expression.\n+  Expression* call_;\n+  // Which result we want.\n+  unsigned int index_;\n+};\n+\n // An expression which represents a pointer to a function.\n \n class Func_expression : public Expression\n@@ -2074,6 +2308,95 @@ class Index_expression : public Parser_expression\n   bool is_lvalue_;\n };\n \n+// An array index.  This is used for both indexing and slicing.\n+\n+class Array_index_expression : public Expression\n+{\n+ public:\n+  Array_index_expression(Expression* array, Expression* start,\n+\t\t\t Expression* end, Expression* cap, Location location)\n+    : Expression(EXPRESSION_ARRAY_INDEX, location),\n+      array_(array), start_(start), end_(end), cap_(cap), type_(NULL)\n+  { }\n+\n+  // Return the array.\n+  Expression*\n+  array()\n+  { return this->array_; }\n+\n+  const Expression*\n+  array() const\n+  { return this->array_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_array_index(this->array_->copy(),\n+\t\t\t\t\tthis->start_->copy(),\n+\t\t\t\t\t(this->end_ == NULL\n+\t\t\t\t\t ? NULL\n+\t\t\t\t\t : this->end_->copy()),\n+\t\t\t\t\t(this->cap_ == NULL\n+\t\t\t\t\t ? NULL\n+\t\t\t\t\t : this->cap_->copy()),\n+\t\t\t\t\tthis->location());\n+  }\n+\n+  bool\n+  do_must_eval_subexpressions_in_order(int* skip) const\n+  {\n+    *skip = 1;\n+    return true;\n+  }\n+\n+  bool\n+  do_is_addressable() const;\n+\n+  void\n+  do_address_taken(bool escapes)\n+  { this->array_->address_taken(escapes); }\n+\n+  void\n+  do_issue_nil_check()\n+  { this->array_->issue_nil_check(); }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+  \n+ private:\n+  // The array we are getting a value from.\n+  Expression* array_;\n+  // The start or only index.\n+  Expression* start_;\n+  // The end index of a slice.  This may be NULL for a simple array\n+  // index, or it may be a nil expression for the length of the array.\n+  Expression* end_;\n+  // The capacity argument of a slice.  This may be NULL for an array index or\n+  // slice.\n+  Expression* cap_;\n+  // The type of the expression.\n+  Type* type_;\n+};\n+\n // An index into a map.\n \n class Map_index_expression : public Expression\n@@ -2456,6 +2779,327 @@ class Interface_field_reference_expression : public Expression\n   std::string name_;\n };\n \n+// Implement the builtin function new.\n+\n+class Allocation_expression : public Expression\n+{\n+ public:\n+  Allocation_expression(Type* type, Location location)\n+    : Expression(EXPRESSION_ALLOCATION, location),\n+      type_(type), allocate_on_stack_(false), stack_temp_(NULL)\n+  { }\n+\n+  void\n+  set_allocate_on_stack()\n+  { this->allocate_on_stack_ = true; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy();\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The type we are allocating.\n+  Type* type_;\n+  // Whether or not this is a stack allocation.\n+  bool allocate_on_stack_;\n+  // If this memory is stack allocated, it will use the address of STACK_TEMP.\n+  // Otherwise, STACK_TEMP is NULL.\n+  Temporary_statement* stack_temp_;\n+};\n+\n+// Construct a struct.\n+\n+class Struct_construction_expression : public Expression\n+{\n+ public:\n+  Struct_construction_expression(Type* type, Expression_list* vals,\n+\t\t\t\t Location location)\n+    : Expression(EXPRESSION_STRUCT_CONSTRUCTION, location),\n+      type_(type), vals_(vals), traverse_order_(NULL)\n+  { }\n+\n+  // Set the traversal order, used to ensure that we implement the\n+  // order of evaluation rules.  Takes ownership of the argument.\n+  void\n+  set_traverse_order(std::vector<int>* traverse_order)\n+  { this->traverse_order_ = traverse_order; }\n+\n+  // Return whether this is a constant initializer.\n+  bool\n+  is_constant_struct() const;\n+\n+  Expression_list*\n+  vals() const\n+  { return this->vals_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  bool\n+  do_is_immutable() const;\n+\n+  Type*\n+  do_type()\n+  { return this->type_; }\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    Struct_construction_expression* ret =\n+      new Struct_construction_expression(this->type_,\n+\t\t\t\t\t (this->vals_ == NULL\n+\t\t\t\t\t  ? NULL\n+\t\t\t\t\t  : this->vals_->copy()),\n+\t\t\t\t\t this->location());\n+    if (this->traverse_order_ != NULL)\n+      ret->set_traverse_order(this->traverse_order_);\n+    return ret;\n+  }\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n+\n+  void\n+  do_export(Export*) const;\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The type of the struct to construct.\n+  Type* type_;\n+  // The list of values, in order of the fields in the struct.  A NULL\n+  // entry means that the field should be zero-initialized.\n+  Expression_list* vals_;\n+  // If not NULL, the order in which to traverse vals_.  This is used\n+  // so that we implement the order of evaluation rules correctly.\n+  std::vector<int>* traverse_order_;\n+};\n+\n+// Construct an array.  This class is not used directly; instead we\n+// use the child classes, Fixed_array_construction_expression and\n+// Slice_construction_expression.\n+\n+class Array_construction_expression : public Expression\n+{\n+ protected:\n+  Array_construction_expression(Expression_classification classification,\n+\t\t\t\tType* type,\n+\t\t\t\tconst std::vector<unsigned long>* indexes,\n+\t\t\t\tExpression_list* vals, Location location)\n+    : Expression(classification, location),\n+      type_(type), indexes_(indexes), vals_(vals)\n+  { go_assert(indexes == NULL || indexes->size() == vals->size()); }\n+\n+ public:\n+  // Return whether this is a constant initializer.\n+  bool\n+  is_constant_array() const;\n+\n+  // Return the number of elements.\n+  size_t\n+  element_count() const\n+  { return this->vals_ == NULL ? 0 : this->vals_->size(); }\n+\n+  // The list of values.\n+  Expression_list*\n+  vals() const\n+  { return this->vals_; }\n+\n+protected:\n+  virtual int\n+  do_traverse(Traverse* traverse);\n+\n+  bool\n+  do_is_immutable() const;\n+\n+  Type*\n+  do_type()\n+  { return this->type_; }\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  void\n+  do_export(Export*) const;\n+\n+  // The indexes.\n+  const std::vector<unsigned long>*\n+  indexes()\n+  { return this->indexes_; }\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  // Get the backend constructor for the array values.\n+  Bexpression*\n+  get_constructor(Translate_context* context, Btype* btype);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The type of the array to construct.\n+  Type* type_;\n+  // The list of indexes into the array, one for each value.  This may\n+  // be NULL, in which case the indexes start at zero and increment.\n+  const std::vector<unsigned long>* indexes_;\n+  // The list of values.  This may be NULL if there are no values.\n+  Expression_list* vals_;\n+};\n+\n+// Construct a fixed array.\n+\n+class Fixed_array_construction_expression :\n+  public Array_construction_expression\n+{\n+ public:\n+  Fixed_array_construction_expression(Type* type,\n+\t\t\t\t      const std::vector<unsigned long>* indexes,\n+\t\t\t\t      Expression_list* vals, Location location);\n+\n+ protected:\n+  Expression*\n+  do_copy()\n+  {\n+    return new Fixed_array_construction_expression(this->type(),\n+\t\t\t\t\t\t   this->indexes(),\n+\t\t\t\t\t\t   (this->vals() == NULL\n+\t\t\t\t\t\t    ? NULL\n+\t\t\t\t\t\t    : this->vals()->copy()),\n+\t\t\t\t\t\t   this->location());\n+  }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n+};\n+\n+// Construct a slice.\n+\n+class Slice_construction_expression : public Array_construction_expression\n+{\n+ public:\n+  Slice_construction_expression(Type* type,\n+\t\t\t\tconst std::vector<unsigned long>* indexes,\n+\t\t\t\tExpression_list* vals, Location location);\n+ protected:\n+  // Note that taking the address of a slice literal is invalid.\n+\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Slice_construction_expression(this->type(), this->indexes(),\n+\t\t\t\t\t     (this->vals() == NULL\n+\t\t\t\t\t      ? NULL\n+\t\t\t\t\t      : this->vals()->copy()),\n+\t\t\t\t\t     this->location());\n+  }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n+\n+ private:\n+  // The type of the values in this slice.\n+  Type* valtype_;\n+};\n+\n+// Construct a map.\n+\n+class Map_construction_expression : public Expression\n+{\n+ public:\n+  Map_construction_expression(Type* type, Expression_list* vals,\n+\t\t\t      Location location)\n+    : Expression(EXPRESSION_MAP_CONSTRUCTION, location),\n+      type_(type), vals_(vals), element_type_(NULL), constructor_temp_(NULL)\n+  { go_assert(vals == NULL || vals->size() % 2 == 0); }\n+\n+  Expression_list*\n+  vals() const\n+  { return this->vals_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n+  Type*\n+  do_type()\n+  { return this->type_; }\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Map_construction_expression(this->type_,\n+\t\t\t\t\t   (this->vals_ == NULL\n+\t\t\t\t\t    ? NULL\n+\t\t\t\t\t    : this->vals_->copy()),\n+\t\t\t\t\t   this->location());\n+  }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n+\n+  void\n+  do_export(Export*) const;\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+  \n+ private:\n+  // The type of the map to construct.\n+  Type* type_;\n+  // The list of values.\n+  Expression_list* vals_;\n+  // The type of the key-value pair struct for each map element.\n+  Struct_type* element_type_;\n+  // A temporary reference to the variable storing the constructor initializer.\n+  Temporary_statement* constructor_temp_;\n+};\n+\n // A type guard expression.\n \n class Type_guard_expression : public Expression\n@@ -2514,6 +3158,58 @@ class Type_guard_expression : public Expression\n   Type* type_;\n };\n \n+// Class Heap_expression.\n+\n+// When you take the address of an escaping expression, it is allocated\n+// on the heap.  This class implements that.\n+\n+class Heap_expression : public Expression\n+{\n+ public:\n+  Heap_expression(Expression* expr, Location location)\n+    : Expression(EXPRESSION_HEAP, location),\n+      expr_(expr)\n+  { }\n+\n+  Expression*\n+  expr() const\n+  { return this->expr_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return Expression::traverse(&this->expr_, traverse); }\n+\n+  Type*\n+  do_type();\n+  void\n+  do_determine_type(const Type_context*)\n+  { this->expr_->determine_type_no_context(); }\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_heap_expression(this->expr_->copy(),\n+                                            this->location());\n+  }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context*);\n+\n+  // We only export global objects, and the parser does not generate\n+  // this in global scope.\n+  void\n+  do_export(Export*) const\n+  { go_unreachable(); }\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The expression which is being put on the heap.\n+  Expression* expr_;\n+};\n+\n // A receive expression.\n \n class Receive_expression : public Expression\n@@ -2574,6 +3270,96 @@ class Receive_expression : public Expression\n   Temporary_statement* temp_receiver_;\n };\n \n+// Conditional expressions.\n+\n+class Conditional_expression : public Expression\n+{\n+ public:\n+  Conditional_expression(Expression* cond, Expression* then_expr,\n+                         Expression* else_expr, Location location)\n+      : Expression(EXPRESSION_CONDITIONAL, location),\n+        cond_(cond), then_(then_expr), else_(else_expr)\n+  {}\n+\n+  Expression*\n+  condition() const\n+  { return this->cond_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Conditional_expression(this->cond_->copy(), this->then_->copy(),\n+                                      this->else_->copy(), this->location());\n+  }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The condition to be checked.\n+  Expression* cond_;\n+  // The expression to execute if the condition is true.\n+  Expression* then_;\n+  // The expression to execute if the condition is false.\n+  Expression* else_;\n+};\n+\n+// Compound expressions.\n+\n+class Compound_expression : public Expression\n+{\n+ public:\n+  Compound_expression(Expression* init, Expression* expr, Location location)\n+      : Expression(EXPRESSION_COMPOUND, location), init_(init), expr_(expr)\n+  {}\n+\n+  Expression*\n+  init() const\n+  { return this->init_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*);\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Compound_expression(this->init_->copy(), this->expr_->copy(),\n+                                   this->location());\n+  }\n+\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The expression that is evaluated first and discarded.\n+  Expression* init_;\n+  // The expression that is evaluated and returned.\n+  Expression* expr_;\n+};\n+\n // A numeric constant.  This is used both for untyped constants and\n // for constants that have a type.\n "}, {"sha": "98cf6501af624516a6d2a5512499526fbfee0492", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -110,6 +110,10 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n   if (only_check_syntax)\n     return;\n \n+  // Consider escape analysis information when deciding if a variable should\n+  // live on the heap or on the stack.\n+  ::gogo->optimize_allocations(filenames);\n+\n   // Export global identifiers as appropriate.\n   ::gogo->do_exports();\n "}, {"sha": "d7a3651fa321324b4f67a7699776eafea9fb9491", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 171, "deletions": 8, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -10,14 +10,15 @@\n \n #include \"go-c.h\"\n #include \"go-dump.h\"\n+#include \"go-optimize.h\"\n #include \"lex.h\"\n #include \"types.h\"\n #include \"statements.h\"\n #include \"expressions.h\"\n-#include \"dataflow.h\"\n #include \"runtime.h\"\n #include \"import.h\"\n #include \"export.h\"\n+#include \"escape.h\"\n #include \"backend.h\"\n #include \"gogo.h\"\n \n@@ -158,35 +159,57 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n   Function_type* new_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   new_type->set_is_varargs();\n   new_type->set_is_builtin();\n+  Node::Escape_states* new_escapes =\n+    new Node::Escape_states(1, Node::ESCAPE_NONE);\n+  new_type->set_parameter_escape_states(new_escapes);\n+  new_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"new\", NULL, new_type, loc);\n \n   Function_type* make_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   make_type->set_is_varargs();\n   make_type->set_is_builtin();\n+  Node::Escape_states* make_escapes =\n+    new Node::Escape_states(2, Node::ESCAPE_NONE);\n+  make_type->set_parameter_escape_states(make_escapes);\n+  make_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"make\", NULL, make_type, loc);\n \n   Typed_identifier_list* len_result = new Typed_identifier_list();\n   len_result->push_back(Typed_identifier(\"\", int_type, loc));\n   Function_type* len_type = Type::make_function_type(NULL, NULL, len_result,\n \t\t\t\t\t\t     loc);\n   len_type->set_is_builtin();\n+  Node::Escape_states* len_escapes =\n+    new Node::Escape_states(1, Node::ESCAPE_NONE);\n+  len_type->set_parameter_escape_states(len_escapes);\n+  len_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"len\", NULL, len_type, loc);\n \n   Typed_identifier_list* cap_result = new Typed_identifier_list();\n   cap_result->push_back(Typed_identifier(\"\", int_type, loc));\n   Function_type* cap_type = Type::make_function_type(NULL, NULL, len_result,\n \t\t\t\t\t\t     loc);\n   cap_type->set_is_builtin();\n+  Node::Escape_states* cap_escapes =\n+    new Node::Escape_states(1, Node::ESCAPE_NONE);\n+  cap_type->set_parameter_escape_states(cap_escapes);\n+  cap_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"cap\", NULL, cap_type, loc);\n \n   Function_type* print_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   print_type->set_is_varargs();\n   print_type->set_is_builtin();\n+  Node::Escape_states* print_escapes =\n+    new Node::Escape_states(1, Node::ESCAPE_NONE);\n+  print_type->set_parameter_escape_states(print_escapes);\n+  print_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"print\", NULL, print_type, loc);\n \n   print_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   print_type->set_is_varargs();\n   print_type->set_is_builtin();\n+  print_type->set_parameter_escape_states(print_escapes);\n+  print_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"println\", NULL, print_type, loc);\n \n   Type *empty = Type::make_empty_interface_type(loc);\n@@ -195,6 +218,10 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n   Function_type *panic_type = Type::make_function_type(NULL, panic_parms,\n \t\t\t\t\t\t       NULL, loc);\n   panic_type->set_is_builtin();\n+  Node::Escape_states* panic_escapes =\n+    new Node::Escape_states(1, Node::ESCAPE_ARG);\n+  panic_type->set_parameter_escape_states(panic_escapes);\n+  panic_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"panic\", NULL, panic_type, loc);\n \n   Typed_identifier_list* recover_result = new Typed_identifier_list();\n@@ -208,6 +235,10 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n   Function_type* close_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   close_type->set_is_varargs();\n   close_type->set_is_builtin();\n+  Node::Escape_states* close_escapes =\n+    new Node::Escape_states(1, Node::ESCAPE_NONE);\n+  close_type->set_parameter_escape_states(close_escapes);\n+  close_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"close\", NULL, close_type, loc);\n \n   Typed_identifier_list* copy_result = new Typed_identifier_list();\n@@ -216,31 +247,56 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n \t\t\t\t\t\t      copy_result, loc);\n   copy_type->set_is_varargs();\n   copy_type->set_is_builtin();\n+  Node::Escape_states* copy_escapes =\n+    new Node::Escape_states(2, Node::ESCAPE_NONE);\n+  copy_type->set_parameter_escape_states(copy_escapes);\n+  copy_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"copy\", NULL, copy_type, loc);\n \n   Function_type* append_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   append_type->set_is_varargs();\n   append_type->set_is_builtin();\n+  Node::Escape_states* append_escapes = new Node::Escape_states;\n+  append_escapes->push_back(Node::ESCAPE_ARG);\n+  append_escapes->push_back(Node::ESCAPE_NONE);\n+  append_type->set_parameter_escape_states(append_escapes);\n+  append_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"append\", NULL, append_type, loc);\n \n   Function_type* complex_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   complex_type->set_is_varargs();\n   complex_type->set_is_builtin();\n+  Node::Escape_states* complex_escapes =\n+    new Node::Escape_states(2, Node::ESCAPE_NONE);\n+  complex_type->set_parameter_escape_states(complex_escapes);\n+  complex_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"complex\", NULL, complex_type, loc);\n \n   Function_type* real_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   real_type->set_is_varargs();\n   real_type->set_is_builtin();\n+  Node::Escape_states* real_escapes =\n+    new Node::Escape_states(1, Node::ESCAPE_NONE);\n+  real_type->set_parameter_escape_states(real_escapes);\n+  real_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"real\", NULL, real_type, loc);\n \n   Function_type* imag_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   imag_type->set_is_varargs();\n   imag_type->set_is_builtin();\n+  Node::Escape_states* imag_escapes =\n+    new Node::Escape_states(1, Node::ESCAPE_NONE);\n+  imag_type->set_parameter_escape_states(imag_escapes);\n+  imag_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"imag\", NULL, imag_type, loc);\n \n   Function_type* delete_type = Type::make_function_type(NULL, NULL, NULL, loc);\n   delete_type->set_is_varargs();\n   delete_type->set_is_builtin();\n+  Node::Escape_states* delete_escapes =\n+    new Node::Escape_states(2, Node::ESCAPE_NONE);\n+  delete_type->set_parameter_escape_states(delete_escapes);\n+  delete_type->set_has_escape_info();\n   this->globals_->add_function_declaration(\"delete\", NULL, delete_type, loc);\n }\n \n@@ -1604,9 +1660,9 @@ Gogo::start_function(const std::string& name, Function_type* type,\n \n   Block* block = new Block(NULL, location);\n \n-  Function* enclosing = (at_top_level\n+  Named_object* enclosing = (at_top_level\n \t\t\t ? NULL\n-\t\t\t : this->functions_.back().function->func_value());\n+\t\t\t : this->functions_.back().function);\n \n   Function* function = new Function(type, enclosing, block, location);\n \n@@ -1904,6 +1960,74 @@ Gogo::add_label_reference(const std::string& label_name,\n \t\t\t\t   issue_goto_errors);\n }\n \n+// Add a function to the call graph.\n+\n+Node*\n+Gogo::add_call_node(Named_object* function)\n+{\n+  Node* call = this->lookup_call_node(function);\n+  if (call == NULL)\n+    {\n+      call = Node::make_call(function);\n+      this->call_graph_.insert(call);\n+      this->named_call_nodes_[function] = call;\n+    }\n+  return call;\n+}\n+\n+// Find the call node that represents FUNCTION.  Return NULL if it does not\n+// exist.\n+\n+Node*\n+Gogo::lookup_call_node(Named_object* function) const\n+{\n+  Named_escape_nodes::const_iterator p = this->named_call_nodes_.find(function);\n+  if (p == this->named_call_nodes_.end())\n+    return NULL;\n+  return p->second;\n+}\n+\n+// Add a connection node for OBJECT.\n+\n+Node*\n+Gogo::add_connection_node(Named_object* object)\n+{\n+  Node* connection = this->lookup_connection_node(object);\n+  if (connection == NULL)\n+    {\n+      connection = Node::make_connection(object, Node::ESCAPE_NONE);\n+\n+      // Each global variable is a part of the global connection graph.\n+      if (object->is_variable()\n+\t  && object->var_value()->is_global())\n+\t{\n+\t  connection->connection_node()->set_escape_state(Node::ESCAPE_GLOBAL);\n+\t  this->global_connections_.insert(connection);\n+\t}\n+\n+      // Each function declaration or definition is the root of its own\n+      // connection graph.  This means closures will have their own\n+      // connection graph that objects in the enclosing function might\n+      // refer to.\n+      if (object->is_function() || object->is_function_declaration())\n+\tthis->connection_roots_.insert(connection);\n+      this->named_connection_nodes_[object] = connection;\n+    }\n+  return connection;\n+}\n+\n+// Find the connection node for OBJECT.  Return NULL if it does not exist.\n+\n+Node*\n+Gogo::lookup_connection_node(Named_object* object) const\n+{\n+  Named_escape_nodes::const_iterator p =\n+    this->named_connection_nodes_.find(object);\n+  if (p == this->named_connection_nodes_.end())\n+    return NULL;\n+  return p->second;\n+}\n+\n // Return the current binding state.\n \n Bindings_snapshot*\n@@ -4455,7 +4579,7 @@ Gogo::convert_named_types_in_bindings(Bindings* bindings)\n \n // Class Function.\n \n-Function::Function(Function_type* type, Function* enclosing, Block* block,\n+Function::Function(Function_type* type, Named_object* enclosing, Block* block,\n \t\t   Location location)\n   : type_(type), enclosing_(enclosing), results_(NULL),\n     closure_var_(NULL), block_(block), location_(location), labels_(),\n@@ -4809,6 +4933,13 @@ Function::export_func_with_type(Export* exp, const std::string& name,\n       exp->write_c_string(\"(\");\n       const Typed_identifier* receiver = fntype->receiver();\n       exp->write_name(receiver->name());\n+\n+      if (fntype->has_escape_info())\n+        {\n+          exp->write_c_string(\" \");\n+          exp->write_escape(fntype->receiver_escape_state());\n+        }\n+\n       exp->write_c_string(\" \");\n       exp->write_type(receiver->type());\n       exp->write_c_string(\") \");\n@@ -4820,17 +4951,25 @@ Function::export_func_with_type(Export* exp, const std::string& name,\n   const Typed_identifier_list* parameters = fntype->parameters();\n   if (parameters != NULL)\n     {\n+      size_t i = 0;\n       bool is_varargs = fntype->is_varargs();\n       bool first = true;\n       for (Typed_identifier_list::const_iterator p = parameters->begin();\n \t   p != parameters->end();\n-\t   ++p)\n+\t   ++p, ++i)\n \t{\n \t  if (first)\n \t    first = false;\n \t  else\n \t    exp->write_c_string(\", \");\n \t  exp->write_name(p->name());\n+\n+\t  if (fntype->has_escape_info())\n+\t    {\n+\t      exp->write_c_string(\" \");\n+\t      exp->write_escape(fntype->parameter_escape_states()->at(i));\n+\t    }\n+\n \t  exp->write_c_string(\" \");\n \t  if (!is_varargs || p + 1 != parameters->end())\n \t    exp->write_type(p->type());\n@@ -4878,17 +5017,29 @@ Function::export_func_with_type(Export* exp, const std::string& name,\n void\n Function::import_func(Import* imp, std::string* pname,\n \t\t      Typed_identifier** preceiver,\n+\t\t      Node::Escapement_lattice* rcvr_escape,\n \t\t      Typed_identifier_list** pparameters,\n+\t\t      Node::Escape_states** pparam_escapes,\n \t\t      Typed_identifier_list** presults,\n-\t\t      bool* is_varargs)\n+\t\t      bool* is_varargs, bool* has_escape_info)\n {\n+  *has_escape_info = false;\n+\n   imp->require_c_string(\"func \");\n \n   *preceiver = NULL;\n+  *rcvr_escape = Node::ESCAPE_NONE;\n   if (imp->peek_char() == '(')\n     {\n       imp->require_c_string(\"(\");\n       std::string name = imp->read_name();\n+\n+      if (imp->match_c_string(\" <escape\")){\n+\t*has_escape_info = true;\n+\timp->require_c_string(\" \");\n+\t*rcvr_escape = imp->read_escape_info();\n+      }\n+\n       imp->require_c_string(\" \");\n       Type* rtype = imp->read_type();\n       *preceiver = new Typed_identifier(name, rtype, imp->location());\n@@ -4898,16 +5049,27 @@ Function::import_func(Import* imp, std::string* pname,\n   *pname = imp->read_identifier();\n \n   Typed_identifier_list* parameters;\n+  Node::Escape_states* param_escapes;\n   *is_varargs = false;\n   imp->require_c_string(\" (\");\n   if (imp->peek_char() == ')')\n-    parameters = NULL;\n+    {\n+      parameters = NULL;\n+      param_escapes = NULL;\n+    }\n   else\n     {\n       parameters = new Typed_identifier_list();\n+      param_escapes = new Node::Escape_states();\n       while (true)\n \t{\n \t  std::string name = imp->read_name();\n+\t  if (imp->match_c_string(\" <escape\")){\n+\t    *has_escape_info = true;\n+\t    imp->require_c_string(\" \");\n+\t    param_escapes->push_back(imp->read_escape_info());\n+\t  }\n+\n \t  imp->require_c_string(\" \");\n \n \t  if (imp->match_c_string(\"...\"))\n@@ -4929,6 +5091,7 @@ Function::import_func(Import* imp, std::string* pname,\n     }\n   imp->require_c_string(\")\");\n   *pparameters = parameters;\n+  *pparam_escapes = param_escapes;\n \n   Typed_identifier_list* results;\n   if (imp->peek_char() != ' ')\n@@ -5765,7 +5928,7 @@ Variable::Variable(Type* type, Expression* init, bool is_global,\n     type_from_init_tuple_(false), type_from_range_index_(false),\n     type_from_range_value_(false), type_from_chan_element_(false),\n     is_type_switch_var_(false), determined_type_(false),\n-    in_unique_section_(false)\n+    in_unique_section_(false), escapes_(true)\n {\n   go_assert(type != NULL || init != NULL);\n   go_assert(!is_parameter || init == NULL);"}, {"sha": "e30178d6c235adccefa15874e09f49e81dd1794b", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 129, "deletions": 10, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -7,6 +7,7 @@\n #ifndef GO_GOGO_H\n #define GO_GOGO_H\n \n+#include \"escape.h\"\n #include \"go-linemap.h\"\n \n class Traverse;\n@@ -125,6 +126,21 @@ class Gogo\n   linemap()\n   { return this->linemap_; }\n \n+  // Get the Call Graph.\n+  const std::set<Node*>&\n+  call_graph() const\n+  { return this->call_graph_; }\n+\n+  // Get the roots of each connection graph.\n+  const std::set<Node*>&\n+  connection_roots() const\n+  { return this->connection_roots_; }\n+\n+  // Get the nodes that escape globally.\n+  const std::set<Node*>&\n+  global_connections() const\n+  { return this->global_connections_; }\n+\n   // Get the package name.\n   const std::string&\n   package_name() const;\n@@ -345,6 +361,22 @@ class Gogo\n   add_label_reference(const std::string&, Location,\n \t\t      bool issue_goto_errors);\n \n+  // Add a FUNCTION to the call graph.\n+  Node*\n+  add_call_node(Named_object* function);\n+\n+  // Lookup the call node for FUNCTION.\n+  Node*\n+  lookup_call_node(Named_object* function) const;\n+\n+  // Add a connection node for OBJECT.\n+  Node*\n+  add_connection_node(Named_object* object);\n+\n+  // Lookup the connection node for OBJECT.\n+  Node*\n+  lookup_connection_node(Named_object* object) const;\n+\n   // Return a snapshot of the current binding state.\n   Bindings_snapshot*\n   bindings_snapshot(Location);\n@@ -544,6 +576,26 @@ class Gogo\n   void\n   check_return_statements();\n \n+  // Build call graph.\n+  void\n+  build_call_graph();\n+\n+  // Build connection graphs.\n+  void\n+  build_connection_graphs();\n+\n+  // Analyze reachability in the connection graphs.\n+  void\n+  analyze_reachability();\n+\n+  // Record escape information in function signatures for export data.\n+  void\n+  mark_escaping_signatures();\n+\n+  // Optimize variable allocation.\n+  void\n+  optimize_allocations(const char** filenames);\n+\n   // Do all exports.\n   void\n   do_exports();\n@@ -579,6 +631,14 @@ class Gogo\n   void\n   dump_ast(const char* basename);\n \n+  // Dump Call Graph if -fgo-dump-calls is set.\n+  void\n+  dump_call_graph(const char* basename);\n+\n+  // Dump Connection Graphs if -fgo-dump-connections is set.\n+  void\n+  dump_connection_graphs(const char* basename);\n+\n   // Convert named types to the backend representation.\n   void\n   convert_named_types();\n@@ -684,6 +744,10 @@ class Gogo\n   // where they were defined.\n   typedef Unordered_map(std::string, Location) File_block_names;\n \n+  // Type used to map named objects that refer to objects to the\n+  // node that represent them in the escape analysis graphs.\n+  typedef Unordered_map(Named_object*, Node*)  Named_escape_nodes;\n+\n   // Type used to queue writing a type specific function.\n   struct Specific_type_function\n   {\n@@ -716,6 +780,20 @@ class Gogo\n   // The global binding contour.  This includes the builtin functions\n   // and the package we are compiling.\n   Bindings* globals_;\n+  // The call graph for a program execution which represents the functions\n+  // encountered and the caller-callee relationship between the functions.\n+  std::set<Node*> call_graph_;\n+  // The nodes that form the roots of the connection graphs for each called\n+  // function and represent the connectivity relationship between all objects\n+  // in the function.\n+  std::set<Node*> connection_roots_;\n+  // All connection nodes that have an escape state of ESCAPE_GLOBAL are a part\n+  // of a special connection graph of only global variables.\n+  std::set<Node*> global_connections_;\n+  // Mapping from named objects to nodes in the call graph.\n+  Named_escape_nodes named_call_nodes_;\n+  // Mapping from named objects to nodes in a connection graph.\n+  Named_escape_nodes named_connection_nodes_;\n   // The list of names we have seen in the file block.\n   File_block_names file_block_names_;\n   // Mapping from import file names to packages.\n@@ -886,22 +964,22 @@ class Block\n class Function\n {\n  public:\n-  Function(Function_type* type, Function*, Block*, Location);\n+  Function(Function_type* type, Named_object*, Block*, Location);\n \n   // Return the function's type.\n   Function_type*\n   type() const\n   { return this->type_; }\n \n   // Return the enclosing function if there is one.\n-  Function*\n-  enclosing()\n+  Named_object*\n+  enclosing() const\n   { return this->enclosing_; }\n \n   // Set the enclosing function.  This is used when building thunks\n   // for functions which call recover.\n   void\n-  set_enclosing(Function* enclosing)\n+  set_enclosing(Named_object* enclosing)\n   {\n     go_assert(this->enclosing_ == NULL);\n     this->enclosing_ = enclosing;\n@@ -1152,8 +1230,11 @@ class Function\n   // Import a function.\n   static void\n   import_func(Import*, std::string* pname, Typed_identifier** receiver,\n+\t      Node::Escapement_lattice* rcvr_escape,\n \t      Typed_identifier_list** pparameters,\n-\t      Typed_identifier_list** presults, bool* is_varargs);\n+\t      Node::Escape_states** pparam_escapes,\n+\t      Typed_identifier_list** presults, bool* is_varargs,\n+\t      bool* has_escape_info);\n \n  private:\n   // Type for mapping from label names to Label objects.\n@@ -1169,7 +1250,7 @@ class Function\n   Function_type* type_;\n   // The enclosing function.  This is NULL when there isn't one, which\n   // is the normal case.\n-  Function* enclosing_;\n+  Named_object* enclosing_;\n   // The result variables, if any.\n   Results* results_;\n   // If there is a closure, this is the list of variables which appear\n@@ -1414,7 +1495,11 @@ class Variable\n   // Whether this variable should live in the heap.\n   bool\n   is_in_heap() const\n-  { return this->is_address_taken_ && !this->is_global_; }\n+  {\n+    return this->is_address_taken_ \n+      && this->escapes_\n+      && !this->is_global_;\n+  }\n \n   // Note that something takes the address of this variable.\n   void\n@@ -1432,6 +1517,16 @@ class Variable\n   set_non_escaping_address_taken()\n   { this->is_non_escaping_address_taken_ = true; }\n \n+  // Return whether this variable escapes the function it is declared in.\n+  bool\n+  escapes()\n+  { return this->escapes_; }\n+\n+  // Note that this variable does not escape the function it is declared in.\n+  void\n+  set_does_not_escape()\n+  { this->escapes_ = false; }\n+\n   // Get the source location of the variable's declaration.\n   Location\n   location() const\n@@ -1525,6 +1620,11 @@ class Variable\n     this->type_from_chan_element_ = false;\n   }\n \n+  // TRUE if this variable was created for a type switch clause.\n+  bool\n+  is_type_switch_var() const\n+  { return this->is_type_switch_var_; }\n+\n   // Note that this variable was created for a type switch clause.\n   void\n   set_is_type_switch_var()\n@@ -1609,7 +1709,7 @@ class Variable\n   bool is_used_ : 1;\n   // Whether something takes the address of this variable.  For a\n   // local variable this implies that the variable has to be on the\n-  // heap.\n+  // heap if it escapes from its function.\n   bool is_address_taken_ : 1;\n   // Whether something takes the address of this variable such that\n   // the address does not escape the function.\n@@ -1635,6 +1735,9 @@ class Variable\n   // True if this variable should be put in a unique section.  This is\n   // used for field tracking.\n   bool in_unique_section_ : 1;\n+  // Whether this variable escapes the function it is created in.  This is\n+  // true until shown otherwise.\n+  bool escapes_ : 1;\n };\n \n // A variable which is really the name for a function return value, or\n@@ -1647,7 +1750,7 @@ class Result_variable\n \t\t  Location location)\n     : type_(type), function_(function), index_(index), location_(location),\n       backend_(NULL), is_address_taken_(false),\n-      is_non_escaping_address_taken_(false)\n+      is_non_escaping_address_taken_(false), escapes_(true)\n   { }\n \n   // Get the type of the result variable.\n@@ -1690,11 +1793,24 @@ class Result_variable\n   void\n   set_non_escaping_address_taken()\n   { this->is_non_escaping_address_taken_ = true; }\n+  \n+  // Return whether this variable escapes the function it is declared in.\n+  bool\n+  escapes()\n+  { return this->escapes_; }\n+\n+  // Note that this variable does not escape the function it is declared in.\n+  void\n+  set_does_not_escape()\n+  { this->escapes_ = false; }\n \n   // Whether this variable should live in the heap.\n   bool\n   is_in_heap() const\n-  { return this->is_address_taken_; }\n+  {\n+    return this->is_address_taken_\n+      && this->escapes_;\n+  }\n \n   // Set the function.  This is used when cloning functions which call\n   // recover.\n@@ -1722,6 +1838,9 @@ class Result_variable\n   // Whether something takes the address of this variable such that\n   // the address does not escape the function.\n   bool is_non_escaping_address_taken_;\n+  // Whether this variable escapes the function it is created in.  This is\n+  // true until shown otherwise.\n+  bool escapes_;\n };\n \n // The value we keep for a named constant.  This lets us hold a type"}, {"sha": "1bb6ad8acf6709bd6c77ae34fe079ee6ac0e6a2b", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -502,16 +502,28 @@ Import::import_func(Package* package)\n {\n   std::string name;\n   Typed_identifier* receiver;\n+  Node::Escapement_lattice rcvr_escape;\n   Typed_identifier_list* parameters;\n+  Node::Escape_states* param_escapes;\n   Typed_identifier_list* results;\n   bool is_varargs;\n-  Function::import_func(this, &name, &receiver, &parameters, &results,\n-\t\t\t&is_varargs);\n+  bool has_escape_info;\n+  Function::import_func(this, &name, &receiver, &rcvr_escape, &parameters,\n+\t\t\t&param_escapes, &results, &is_varargs,\n+\t\t\t&has_escape_info);\n   Function_type *fntype = Type::make_function_type(receiver, parameters,\n \t\t\t\t\t\t   results, this->location_);\n   if (is_varargs)\n     fntype->set_is_varargs();\n \n+  if (has_escape_info)\n+    {\n+      if (fntype->is_method())\n+\tfntype->set_receiver_escape_state(rcvr_escape);\n+      fntype->set_parameter_escape_states(param_escapes);\n+      fntype->set_has_escape_info();\n+    }\n+\n   Location loc = this->location_;\n   Named_object* no;\n   if (fntype->is_method())\n@@ -762,6 +774,19 @@ Import::read_type()\n   return type;\n }\n \n+// Read escape info in the import stream.\n+\n+Node::Escapement_lattice\n+Import::read_escape_info()\n+{\n+  Stream* stream = this->stream_;\n+  this->require_c_string(\"<escape \");\n+\n+  int escape_value = stream->get_char() - '0';\n+  this->require_c_string(\">\");\n+  return Node::Escapement_lattice(escape_value);\n+}\n+\n // Register the builtin types.\n \n void"}, {"sha": "7aa1fc9b623781abb20dc93bd04a4cfbd5ea41dc", "filename": "gcc/go/gofrontend/import.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -7,6 +7,7 @@\n #ifndef GO_IMPORT_H\n #define GO_IMPORT_H\n \n+#include \"escape.h\"\n #include \"export.h\"\n #include \"go-linemap.h\"\n \n@@ -197,6 +198,10 @@ class Import\n   Type*\n   read_type();\n \n+  // Read escape information.\n+  Node::Escapement_lattice\n+  read_escape_info();\n+\n  private:\n   static Stream*\n   try_package_in_directory(const std::string&, Location);"}, {"sha": "a44145da23e644845ad679a09dcfde17cf4d834a", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 30, "deletions": 75, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -14,6 +14,7 @@\n #include \"backend.h\"\n #include \"statements.h\"\n #include \"ast-dump.h\"\n+#include \"dataflow.h\"\n \n // Class Statement.\n \n@@ -520,45 +521,7 @@ Statement::make_temporary(Type* type, Expression* init,\n   return new Temporary_statement(type, init, location);\n }\n \n-// An assignment statement.\n-\n-class Assignment_statement : public Statement\n-{\n- public:\n-  Assignment_statement(Expression* lhs, Expression* rhs,\n-\t\t       Location location)\n-    : Statement(STATEMENT_ASSIGNMENT, location),\n-      lhs_(lhs), rhs_(rhs)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse);\n-\n-  bool\n-  do_traverse_assignments(Traverse_assignments*);\n-\n-  void\n-  do_determine_types();\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  Statement*\n-  do_flatten(Gogo*, Named_object*, Block*, Statement_inserter*);\n-\n-  Bstatement*\n-  do_get_backend(Translate_context*);\n-\n-  void\n-  do_dump_statement(Ast_dump_context*) const;\n-\n- private:\n-  // Left hand side--the lvalue.\n-  Expression* lhs_;\n-  // Right hand side--the rvalue.\n-  Expression* rhs_;\n-};\n+// Class Assignment_statement.\n \n // Traversal.\n \n@@ -3150,41 +3113,7 @@ Statement::make_unnamed_label_statement(Unnamed_label* label)\n   return new Unnamed_label_statement(label);\n }\n \n-// An if statement.\n-\n-class If_statement : public Statement\n-{\n- public:\n-  If_statement(Expression* cond, Block* then_block, Block* else_block,\n-\t       Location location)\n-    : Statement(STATEMENT_IF, location),\n-      cond_(cond), then_block_(then_block), else_block_(else_block)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse*);\n-\n-  void\n-  do_determine_types();\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  bool\n-  do_may_fall_through() const;\n-\n-  Bstatement*\n-  do_get_backend(Translate_context*);\n-\n-  void\n-  do_dump_statement(Ast_dump_context*) const;\n-\n- private:\n-  Expression* cond_;\n-  Block* then_block_;\n-  Block* else_block_;\n-};\n+// Class If_statement.\n \n // Traversal.\n \n@@ -4676,7 +4605,6 @@ Select_clauses::Select_clause::lower(Gogo* gogo, Named_object* function,\n   // through here.\n   this->is_lowered_ = true;\n   this->val_ = NULL;\n-  this->var_ = NULL;\n }\n \n // Lower a default clause in a select statement.\n@@ -4840,6 +4768,22 @@ Select_clauses::Select_clause::check_types()\n     error_at(this->location(), \"invalid receive on send-only channel\");\n }\n \n+// Analyze the dataflow across each case statement.\n+\n+void\n+Select_clauses::Select_clause::analyze_dataflow(Dataflow* dataflow)\n+{\n+  if (this->is_default_)\n+    return;\n+\n+  // For a CommClause, the dataflow analysis should record a definition of\n+  // VAR and CLOSEDVAR\n+  if (this->var_ != NULL && !this->var_->is_sink())\n+    dataflow->add_def(this->var_, this->channel_, NULL, false);\n+  if (this->closedvar_ != NULL && !this->closedvar_->is_sink())\n+    dataflow->add_def(this->closedvar_, this->channel_, NULL, false);\n+}\n+\n // Whether this clause may fall through to the statement which follows\n // the overall select statement.\n \n@@ -4958,6 +4902,17 @@ Select_clauses::check_types()\n     p->check_types();\n }\n \n+// Analyze the dataflow across each case statement.\n+\n+void\n+Select_clauses::analyze_dataflow(Dataflow* dataflow)\n+{\n+  for (Clauses::iterator p = this->clauses_.begin();\n+       p != this->clauses_.end();\n+       ++p)\n+    p->analyze_dataflow(dataflow);\n+}\n+\n // Return whether these select clauses fall through to the statement\n // following the overall select statement.\n "}, {"sha": "cf847d04d17136faae0152a732c756cc419d5158", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -15,12 +15,14 @@ class Statement_inserter;\n class Block;\n class Function;\n class Unnamed_label;\n+class Assignment_statement;\n class Temporary_statement;\n class Variable_declaration_statement;\n class Expression_statement;\n class Return_statement;\n class Thunk_statement;\n class Label_statement;\n+class If_statement;\n class For_statement;\n class For_range_statement;\n class Switch_statement;\n@@ -45,6 +47,7 @@ class Bexpression;\n class Bstatement;\n class Bvariable;\n class Ast_dump_context;\n+class Dataflow;\n \n // This class is used to traverse assignments made by a statement\n // which makes assignments.\n@@ -331,6 +334,22 @@ class Statement\n   is_block_statement() const\n   { return this->classification_ == STATEMENT_BLOCK; }\n \n+  // If this is an assignment statement, return it.  Otherwise return\n+  // NULL.\n+  Assignment_statement*\n+  assignment_statement()\n+  {\n+    return this->convert<Assignment_statement, STATEMENT_ASSIGNMENT>();\n+  }\n+\n+  // If this is an temporary statement, return it.  Otherwise return\n+  // NULL.\n+  Temporary_statement*\n+  temporary_statement()\n+  {\n+    return this->convert<Temporary_statement, STATEMENT_TEMPORARY>();\n+  }\n+\n   // If this is a variable declaration statement, return it.\n   // Otherwise return NULL.\n   Variable_declaration_statement*\n@@ -363,6 +382,11 @@ class Statement\n   label_statement()\n   { return this->convert<Label_statement, STATEMENT_LABEL>(); }\n \n+  // If this is an if statement, return it.  Otherwise return NULL.\n+  If_statement*\n+  if_statement()\n+  { return this->convert<If_statement, STATEMENT_IF>(); }\n+\n   // If this is a for statement, return it.  Otherwise return NULL.\n   For_statement*\n   for_statement()\n@@ -385,6 +409,11 @@ class Statement\n   type_switch_statement()\n   { return this->convert<Type_switch_statement, STATEMENT_TYPE_SWITCH>(); }\n \n+  // If this is a send statement, return it.  Otherwise return NULL.\n+  Send_statement*\n+  send_statement()\n+  { return this->convert<Send_statement, STATEMENT_SEND>(); }\n+\n   // If this is a select statement, return it.  Otherwise return NULL.\n   Select_statement*\n   select_statement()\n@@ -507,6 +536,54 @@ class Statement\n   Location location_;\n };\n \n+// An assignment statement.\n+\n+class Assignment_statement : public Statement\n+{\n+ public:\n+  Assignment_statement(Expression* lhs, Expression* rhs,\n+\t\t       Location location)\n+    : Statement(STATEMENT_ASSIGNMENT, location),\n+      lhs_(lhs), rhs_(rhs)\n+  { }\n+\n+  Expression*\n+  lhs() const\n+  { return this->lhs_; }\n+\n+  Expression*\n+  rhs() const\n+  { return this->rhs_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Statement*\n+  do_flatten(Gogo*, Named_object*, Block*, Statement_inserter*);\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+\n+  void\n+  do_dump_statement(Ast_dump_context*) const;\n+\n+ private:\n+  // Left hand side--the lvalue.\n+  Expression* lhs_;\n+  // Right hand side--the rvalue.\n+  Expression* rhs_;\n+};\n+\n // A statement which creates and initializes a temporary variable.\n \n class Temporary_statement : public Statement\n@@ -697,6 +774,14 @@ class Send_statement : public Statement\n       channel_(channel), val_(val)\n   { }\n \n+  Expression*\n+  channel()\n+  { return this->channel_; }  \n+\n+  Expression*\n+  val()\n+  { return this->val_; }\n+\n  protected:\n   int\n   do_traverse(Traverse* traverse);\n@@ -775,6 +860,10 @@ class Select_clauses\n   void\n   check_types();\n \n+  // Analyze the dataflow across each case statement.\n+  void\n+  analyze_dataflow(Dataflow*);\n+\n   // Whether the select clauses may fall through to the statement\n   // which follows the overall select statement.\n   bool\n@@ -831,6 +920,10 @@ class Select_clauses\n     void\n     check_types();\n \n+    // Analyze the dataflow across each case statement.\n+    void\n+    analyze_dataflow(Dataflow*);\n+\n     // Return true if this is the default clause.\n     bool\n     is_default() const\n@@ -937,6 +1030,10 @@ class Select_statement : public Statement\n   Unnamed_label*\n   break_label();\n \n+  void\n+  analyze_dataflow(Dataflow* dataflow)\n+  { this->clauses_->analyze_dataflow(dataflow); }\n+\n  protected:\n   int\n   do_traverse(Traverse* traverse)\n@@ -1108,6 +1205,46 @@ class Label_statement : public Statement\n   Label* label_;\n };\n \n+// An if statement.\n+\n+class If_statement : public Statement\n+{\n+ public:\n+  If_statement(Expression* cond, Block* then_block, Block* else_block,\n+\t       Location location)\n+    : Statement(STATEMENT_IF, location),\n+      cond_(cond), then_block_(then_block), else_block_(else_block)\n+  { }\n+\n+  Expression*\n+  condition() const\n+  { return this->cond_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  bool\n+  do_may_fall_through() const;\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+\n+  void\n+  do_dump_statement(Ast_dump_context*) const;\n+\n+ private:\n+  Expression* cond_;\n+  Block* then_block_;\n+  Block* else_block_;\n+};\n+\n // A for statement.\n \n class For_statement : public Statement"}, {"sha": "042548f65f992c9c6abb58d0c6a876fa85a4c3b8", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b496063dcd8bf5041e101de4532297803fa997b2/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=b496063dcd8bf5041e101de4532297803fa997b2", "patch": "@@ -8,6 +8,7 @@\n #define GO_TYPES_H\n \n #include \"go-linemap.h\"\n+#include \"escape.h\"\n \n class Gogo;\n class Package;\n@@ -1778,14 +1779,24 @@ class Function_type : public Type\n     : Type(TYPE_FUNCTION),\n       receiver_(receiver), parameters_(parameters), results_(results),\n       location_(location), is_varargs_(false), is_builtin_(false),\n-      fnbtype_(NULL)\n+      has_escape_info_(false), fnbtype_(NULL), parameter_escape_states_(NULL)\n   { }\n \n   // Get the receiver.\n   const Typed_identifier*\n   receiver() const\n   { return this->receiver_; }\n \n+  // Get the escape state of the receiver.\n+  const Node::Escapement_lattice&\n+  receiver_escape_state() const\n+  { return this->receiver_escape_state_; }\n+\n+  // Set the escape state of the receiver.\n+  void\n+  set_receiver_escape_state(const Node::Escapement_lattice& e)\n+  { this->receiver_escape_state_ = e; }\n+\n   // Get the return names and types.\n   const Typed_identifier_list*\n   results() const\n@@ -1796,6 +1807,16 @@ class Function_type : public Type\n   parameters() const\n   { return this->parameters_; }\n \n+  // Get the escape states associated with each parameter.\n+  const Node::Escape_states*\n+  parameter_escape_states() const\n+  { return this->parameter_escape_states_; }\n+\n+  // Set the escape states of the parameters.\n+  void\n+  set_parameter_escape_states(Node::Escape_states* states)\n+  { this->parameter_escape_states_ = states; }\n+\n   // Whether this is a varargs function.\n   bool\n   is_varargs() const\n@@ -1806,6 +1827,11 @@ class Function_type : public Type\n   is_builtin() const\n   { return this->is_builtin_; }\n \n+  // Whether this contains escape information.\n+  bool\n+  has_escape_info() const\n+  { return this->has_escape_info_; }\n+\n   // The location where this type was defined.\n   Location\n   location() const\n@@ -1836,6 +1862,11 @@ class Function_type : public Type\n   set_is_builtin()\n   { this->is_builtin_ = true; }\n \n+  // Record that this has escape information.\n+  void\n+  set_has_escape_info()\n+  { this->has_escape_info_ = true; }\n+\n   // Import a function type.\n   static Function_type*\n   do_import(Import*);\n@@ -1947,9 +1978,16 @@ class Function_type : public Type\n   // Whether this is a special builtin function which can not simply\n   // be called.  This is used for len, cap, etc.\n   bool is_builtin_;\n+  // Whether escape information for the receiver and parameters has been\n+  // recorded.\n+  bool has_escape_info_;\n   // The backend representation of this type for backend function\n   // declarations and definitions.\n   Btype* fnbtype_;\n+  // The escape state of the receiver.\n+  Node::Escapement_lattice receiver_escape_state_;\n+  // The escape states of each parameter.\n+  Node::Escape_states* parameter_escape_states_;\n };\n \n // The type of a function's backend representation."}]}