{"sha": "eb698c5883ecbe510585bf6c37a9ae198577cea2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI2OThjNTg4M2VjYmU1MTA1ODViZjZjMzdhOWFlMTk4NTc3Y2VhMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-09-07T20:34:13Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-09-07T20:34:13Z"}, "message": "expr.c (expand_operands): New function to expand an operand pair.\n\n\n\t* expr.c (expand_operands): New function to expand an operand pair.\n\t(expand_expr): Call expand_operands whenever we need to expand both\n\toperands of a binary operator.\n\t(do_store_flag): Likewise for operands of comparison operations.\n\nFrom-SVN: r71179", "tree": {"sha": "9b2ed270edaa17237187e1b284596268edbe916e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b2ed270edaa17237187e1b284596268edbe916e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb698c5883ecbe510585bf6c37a9ae198577cea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb698c5883ecbe510585bf6c37a9ae198577cea2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb698c5883ecbe510585bf6c37a9ae198577cea2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb698c5883ecbe510585bf6c37a9ae198577cea2/comments", "author": null, "committer": null, "parents": [{"sha": "4f61b3b722d34b8cd37376bc1e21879c01296c1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f61b3b722d34b8cd37376bc1e21879c01296c1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f61b3b722d34b8cd37376bc1e21879c01296c1b"}], "stats": {"total": 111, "additions": 60, "deletions": 51}, "files": [{"sha": "33083458f24e19e744d993f85f66973f7b699a5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb698c5883ecbe510585bf6c37a9ae198577cea2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb698c5883ecbe510585bf6c37a9ae198577cea2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb698c5883ecbe510585bf6c37a9ae198577cea2", "patch": "@@ -1,3 +1,10 @@\n+2003-09-07  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* expr.c (expand_operands): New function to expand an operand pair.\n+\t(expand_expr): Call expand_operands whenever we need to expand both\n+\toperands of a binary operator.\n+\t(do_store_flag): Likewise for operands of comparison operations.\n+\n 2003-09-07  Roger Sayle  <roger@eyesopen.com>\n \n \t* combine.c (combine_simplify_rtx): Don't convert -(A*B) into"}, {"sha": "0538707f13e20c34b362252247f8785c10b6e9e5", "filename": "gcc/expr.c", "status": "modified", "additions": 53, "deletions": 51, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb698c5883ecbe510585bf6c37a9ae198577cea2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb698c5883ecbe510585bf6c37a9ae198577cea2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=eb698c5883ecbe510585bf6c37a9ae198577cea2", "patch": "@@ -164,6 +164,8 @@ static unsigned HOST_WIDE_INT highest_pow2_factor_for_type (tree, tree);\n \n static int is_aligning_offset (tree, tree);\n static rtx expand_increment (tree, int, int);\n+static void expand_operands (tree, tree, rtx, rtx*, rtx*,\n+\t\t\t     enum expand_modifier);\n static rtx do_store_flag (tree, rtx, enum machine_mode, int);\n #ifdef PUSH_ROUNDING\n static void emit_single_push_insn (enum machine_mode, rtx, tree);\n@@ -6523,6 +6525,30 @@ find_placeholder (tree exp, tree *plist)\n \n   return 0;\n }\n+\n+/* Subroutine of expand_expr.  Expand the two operands of a binary\n+   expression EXP0 and EXP1 placing the results in OP0 and OP1.\n+   The value may be stored in TARGET if TARGET is nonzero.  The\n+   MODIFIER argument is as documented by expand_expr.  */\n+\n+static void\n+expand_operands (tree exp0, tree exp1, rtx target, rtx *op0, rtx *op1,\n+\t\t enum expand_modifier modifier)\n+{\n+  if (! safe_from_p (target, exp1, 1))\n+    target = 0;\n+  if (operand_equal_p (exp0, exp1, 0))\n+    {\n+      *op0 = expand_expr (exp0, target, VOIDmode, modifier);\n+      *op1 = copy_rtx (*op0);\n+    }\n+  else\n+    {\n+      *op0 = expand_expr (exp0, target, VOIDmode, modifier);\n+      *op1 = expand_expr (exp1, NULL_RTX, VOIDmode, modifier);\n+    }\n+}\n+\n \f\n /* expand_expr: generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n@@ -6567,7 +6593,8 @@ find_placeholder (tree exp, tree *plist)\n    emit_block_move will be flagged with BLOCK_OP_CALL_PARM.  */\n \n rtx\n-expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier modifier)\n+expand_expr (tree exp, rtx target, enum machine_mode tmode,\n+\t     enum expand_modifier modifier)\n {\n   rtx op0, op1, temp;\n   tree type = TREE_TYPE (exp);\n@@ -8141,26 +8168,17 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n       if ((modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n \t  || mode != ptr_mode)\n \t{\n-\t  op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n-\t  if (! operand_equal_p (TREE_OPERAND (exp, 0),\n-\t\t\t\t TREE_OPERAND (exp, 1), 0))\n-\t    op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n-\t  else\n-\t    op1 = op0;\n+\t  expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t\t   subtarget, &op0, &op1, 0);\n \t  if (op0 == const0_rtx)\n \t    return op1;\n \t  if (op1 == const0_rtx)\n \t    return op0;\n \t  goto binop2;\n \t}\n \n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, modifier);\n-      if (! operand_equal_p (TREE_OPERAND (exp, 0),\n-\t\t\t     TREE_OPERAND (exp, 1), 0))\n-\top1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX,\n-\t\t\t   VOIDmode, modifier);\n-      else\n-\top1 = op0;\n+      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t       subtarget, &op0, &op1, modifier);\n       return simplify_gen_binary (PLUS, mode, op0, op1);\n \n     case MINUS_EXPR:\n@@ -8173,10 +8191,8 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n \t  && really_constant_p (TREE_OPERAND (exp, 0))\n \t  && really_constant_p (TREE_OPERAND (exp, 1)))\n \t{\n-\t  rtx op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode,\n-\t\t\t\t modifier);\n-\t  rtx op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode,\n-\t\t\t\t modifier);\n+\t  expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t\t   NULL_RTX, &op0, &op1, modifier);\n \n \t  /* If the last operand is a CONST_INT, use plus_constant of\n \t     the negated constant.  Else make the MINUS.  */\n@@ -8198,11 +8214,8 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n \t  || mode != ptr_mode)\n \tgoto binop;\n \n-      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n-\tsubtarget = 0;\n-\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, modifier);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, modifier);\n+      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t       subtarget, &op0, &op1, modifier);\n \n       /* Convert A - const to A + (-const).  */\n       if (GET_CODE (op1) == CONST_INT)\n@@ -8297,14 +8310,14 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n \t    {\n \t      if (this_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \t\t{\n-\t\t  op0 = expand_expr (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n-\t\t\t\t     NULL_RTX, VOIDmode, 0);\n \t\t  if (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)\n-\t\t    op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX,\n-\t\t\t\t       VOIDmode, 0);\n+\t\t    expand_operands (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n+\t\t\t\t     TREE_OPERAND (exp, 1),\n+\t\t\t\t     NULL_RTX, &op0, &op1, 0);\n \t\t  else\n-\t\t    op1 = expand_expr (TREE_OPERAND (TREE_OPERAND (exp, 1), 0),\n-\t\t\t\t       NULL_RTX, VOIDmode, 0);\n+\t\t    expand_operands (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n+\t\t\t\t     TREE_OPERAND (TREE_OPERAND (exp, 1), 0),\n+\t\t\t\t     NULL_RTX, &op0, &op1, 0);\n \t\t  goto binop2;\n \t\t}\n \t      else if (other_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing\n@@ -8333,28 +8346,22 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n \t\t}\n \t    }\n \t}\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n-      if (! operand_equal_p (TREE_OPERAND (exp, 0),\n-\t\t\t     TREE_OPERAND (exp, 1), 0))\n-\top1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n-      else\n-\top1 = op0;\n+      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t       subtarget, &op0, &op1, 0);\n       return expand_mult (mode, op0, op1, target, unsignedp);\n \n     case TRUNC_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n-\tsubtarget = 0;\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n       /* Possible optimization: compute the dividend with EXPAND_SUM\n \t then if the divisor is constant can optimize the case\n \t where some terms of the dividend have coeffs divisible by it.  */\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n+      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t       subtarget, &op0, &op1, 0);\n       return expand_divmod (0, code, mode, op0, op1, target, unsignedp);\n \n     case RDIV_EXPR:\n@@ -8376,12 +8383,10 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n     case FLOOR_MOD_EXPR:\n     case CEIL_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n-      if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n-\tsubtarget = 0;\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n+      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t       subtarget, &op0, &op1, 0);\n       return expand_divmod (1, code, mode, op0, op1, target, unsignedp);\n \n     case FIX_ROUND_EXPR:\n@@ -8450,8 +8455,8 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n \t  || (GET_CODE (target) == REG\n \t      && REGNO (target) < FIRST_PSEUDO_REGISTER))\n \ttarget = gen_reg_rtx (mode);\n-      op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n-      op0 = expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode, 0);\n+      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t       target, &op0, &op1, 0);\n \n       /* First try to do it with a special MIN or MAX instruction.\n \t If that does not win, use a conditional jump to select the proper\n@@ -9506,10 +9511,8 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n   /* Here to do an ordinary binary operator, generating an instruction\n      from the optab already placed in `this_optab'.  */\n  binop:\n-  if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n-    subtarget = 0;\n-  op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, 0);\n-  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n+  expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n+\t\t   subtarget, &op0, &op1, 0);\n  binop2:\n   if (modifier == EXPAND_STACK_PARM)\n     target = 0;\n@@ -10008,8 +10011,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n       || ! safe_from_p (subtarget, arg1, 1))\n     subtarget = 0;\n \n-  op0 = expand_expr (arg0, subtarget, VOIDmode, 0);\n-  op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+  expand_operands (arg0, arg1, subtarget, &op0, &op1, 0);\n \n   if (target == 0)\n     target = gen_reg_rtx (mode);"}]}