{"sha": "160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYwZTJlNGYyMzYxZGEwNmQ4Y2Q3M2FmZWE3YjUyN2IyOWQ0YzZhNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-07-09T12:12:29Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-09T12:12:29Z"}, "message": "gcov-io.h: Update documentation.\n\n\t* gcov-io.h: Update documentation.\n\t(GCOV_GRAPH_SUFFIX, GCOV_GRAPH_MAGIC): Rename to GCOV_NOTE_SUFFIX,\n\tGCOV_NOTE_MAGIC.\n\t(GCOV_DATA_SUFFIX, GCOV_NOTE_SUFFIX): Update.\n\t(GCOV_DATA_MAGIC, GCOV_NOTE_MAGIC): Make non-palindromic.\n\t(struct gcov_var): Change buffer's type. Add endian flag.\n\t(gcov_open): Remove mode in libgcov.\n\t(gcov_magic): Prototype.\n\t* gcov-io.c (from_file): New.\n\t(gcov_open): Clear endian flag.\n\t(gcov_magic): New.\n\t(gcov_write_bytes, gcov_read_bytes): Return gcov_unsigned_t\n\tpointers.\n\t(gcov_write_unsigned, gcov_write_counter, gcov_write_string,\n\tgcov_write_tag, gcov_write_length, gcov_write_tag_length): Update.\n\t(gcov_read_unsigned, gcov_read_counter, gcov_read_string): Update.\n\t* gcov-iov.c (main): Correct cast.\n\t* coverage.c (read_counts_file): Use gcov_magic. Remove endianness\n\tconversion.\n\t(gcov_begin_output): Use GCOV_NOTE_MAGIC.\n\t(coverage_init): Use GCOV_NOTE_SUFFIX.\n\t* libgcov.c (gcov_version_mismatch): Remove endianness conversion.\n\tRename to gcov_version, and return flag.\n\t(gcov_exit): Use gcov_version.\n\t(__gcov_init): Use gcov_version.\n\t* Makefile.in (coverageexts): Update.\n\t* gcov.c (print_version): Remove endianness conversion.\n\t(create_file_names): Use GCOV_NOTE_SUFFIX.\n\t(read_graph_file): Use gcov_magic.\n\t(read_count_file): Likewise.\n\t* gcov-dump.c (dump_file): Remove endianness conversion, use\n\tgcov_magic.\n\nFrom-SVN: r69137", "tree": {"sha": "5a33b5396c3ed82380adfbc9d86b6c3c8ad3bb59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a33b5396c3ed82380adfbc9d86b6c3c8ad3bb59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/comments", "author": null, "committer": null, "parents": [{"sha": "83599948cd3ebd43bccc33de73edda68cb48d354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83599948cd3ebd43bccc33de73edda68cb48d354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83599948cd3ebd43bccc33de73edda68cb48d354"}], "stats": {"total": 549, "additions": 279, "deletions": 270}, "files": [{"sha": "00ab6ca830733c743ee33a03d336465e68153e46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "patch": "@@ -1,3 +1,38 @@\n+2003-07-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcov-io.h: Update documentation.\n+\t(GCOV_GRAPH_SUFFIX, GCOV_GRAPH_MAGIC): Rename to GCOV_NOTE_SUFFIX,\n+\tGCOV_NOTE_MAGIC.\n+\t(GCOV_DATA_SUFFIX, GCOV_NOTE_SUFFIX): Update.\n+\t(GCOV_DATA_MAGIC, GCOV_NOTE_MAGIC): Make non-palindromic.\n+\t(struct gcov_var): Change buffer's type. Add endian flag.\n+\t(gcov_open): Remove mode in libgcov.\n+\t(gcov_magic): Prototype.\n+\t* gcov-io.c (from_file): New.\n+\t(gcov_open): Clear endian flag.\n+\t(gcov_magic): New.\n+\t(gcov_write_bytes, gcov_read_bytes): Return gcov_unsigned_t\n+\tpointers.\n+\t(gcov_write_unsigned, gcov_write_counter, gcov_write_string,\n+\tgcov_write_tag, gcov_write_length, gcov_write_tag_length): Update.\n+\t(gcov_read_unsigned, gcov_read_counter, gcov_read_string): Update.\n+\t* gcov-iov.c (main): Correct cast.\n+\t* coverage.c (read_counts_file): Use gcov_magic. Remove endianness\n+\tconversion.\n+\t(gcov_begin_output): Use GCOV_NOTE_MAGIC.\n+\t(coverage_init): Use GCOV_NOTE_SUFFIX.\n+\t* libgcov.c (gcov_version_mismatch): Remove endianness conversion.\n+\tRename to gcov_version, and return flag.\n+\t(gcov_exit): Use gcov_version.\n+\t(__gcov_init): Use gcov_version.\n+\t* Makefile.in (coverageexts): Update.\n+\t* gcov.c (print_version): Remove endianness conversion.\n+\t(create_file_names): Use GCOV_NOTE_SUFFIX.\n+\t(read_graph_file): Use gcov_magic.\n+\t(read_count_file): Likewise.\n+\t* gcov-dump.c (dump_file): Remove endianness conversion, use\n+\tgcov_magic.\n+\n 2003-07-09  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* configure.in (BUILD_PREFIX, BUILD_PREFIX_1): Set if enable"}, {"sha": "8d9ceb8fd9b61c71c2f91a3594d984a83c70d728", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "patch": "@@ -125,7 +125,7 @@ BOOT_CFLAGS = -g -O2\n # contain the optimization flags, as you normally want code coverage\n # without optimization.\n COVERAGE_FLAGS = @coverage_flags@\n-coverageexts = .{da,bbg}\n+coverageexts = .{gcda,gcno}\n \n # The warning flags are separate from BOOT_CFLAGS because people tend to\n # override optimization flags and we'd like them to still have warnings"}, {"sha": "0bc7a26cecb7cf8df8e62cb8196b871444b5f0c7", "filename": "gcc/coverage.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "patch": "@@ -150,8 +150,7 @@ static void\n read_counts_file (void)\n {\n   gcov_unsigned_t fn_ident = 0;\n-  gcov_unsigned_t version, checksum = -1;\n-  unsigned ix;\n+  gcov_unsigned_t checksum = -1;\n   counts_entry_t *summaried = NULL;\n   unsigned seen_summary = 0;\n   gcov_unsigned_t tag;\n@@ -160,24 +159,18 @@ read_counts_file (void)\n   if (!gcov_open (da_file_name, 1))\n     return;\n \n-  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n+  if (!gcov_magic (gcov_read_unsigned (), GCOV_DATA_MAGIC))\n     {\n       warning (\"`%s' is not a gcov data file\", da_file_name);\n       gcov_close ();\n       return;\n     }\n-  else if ((version = gcov_read_unsigned ()) != GCOV_VERSION)\n+  else if ((tag = gcov_read_unsigned ()) != GCOV_VERSION)\n     {\n-      char v[4], e[4];\n       gcov_unsigned_t required = GCOV_VERSION;\n \n-      for (ix = 4; ix--; required >>= 8, version >>= 8)\n-\t{\n-\t  v[ix] = version;\n-\t  e[ix] = required;\n-\t}\n       warning (\"`%s' is version `%.4s', expected version `%.4s'\",\n-\t       da_file_name, v, e);\n+ \t       da_file_name, (const char *)&tag, (const char *)&required);\n       gcov_close ();\n       return;\n     }\n@@ -446,7 +439,7 @@ coverage_begin_output (void)\n \t    error (\"cannot open %s\", bbg_file_name);\n \t  else\n \t    {\n-\t      gcov_write_unsigned (GCOV_GRAPH_MAGIC);\n+\t      gcov_write_unsigned (GCOV_NOTE_MAGIC);\n \t      gcov_write_unsigned (GCOV_VERSION);\n \t      gcov_write_unsigned (local_tick);\n \t    }\n@@ -897,9 +890,9 @@ coverage_init (const char *filename)\n   strcat (da_file_name, GCOV_DATA_SUFFIX);\n \n   /* Name of bbg file.  */\n-  bbg_file_name = (char *) xmalloc (len + strlen (GCOV_GRAPH_SUFFIX) + 1);\n+  bbg_file_name = (char *) xmalloc (len + strlen (GCOV_NOTE_SUFFIX) + 1);\n   strcpy (bbg_file_name, filename);\n-  strcat (bbg_file_name, GCOV_GRAPH_SUFFIX);\n+  strcat (bbg_file_name, GCOV_NOTE_SUFFIX);\n \n   read_counts_file ();\n }"}, {"sha": "f6902a119e8c4ec5bbe0bcfe436c1ce651feab33", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "patch": "@@ -155,33 +155,32 @@ dump_file (const char *filename)\n   /* magic */\n   {\n     unsigned magic = gcov_read_unsigned ();\n-    unsigned version = gcov_read_unsigned ();\n+    unsigned version;\n     const char *type = NULL;\n-    char e[4], v[4], m[4];\n-    unsigned expected = GCOV_VERSION;\n-    unsigned ix;\n-    int different = version != GCOV_VERSION;\n-\n-    if (magic == GCOV_DATA_MAGIC)\n+    int endianness = 0;\n+    \n+    if ((endianness = gcov_magic (magic, GCOV_DATA_MAGIC)))\n       type = \"data\";\n-    else if (magic == GCOV_GRAPH_MAGIC)\n-      type = \"graph\";\n+    else if ((endianness = gcov_magic (magic, GCOV_NOTE_MAGIC)))\n+      type = \"note\";\n     else\n       {\n \tprintf (\"%s:not a gcov file\\n\", filename);\n \tgcov_close ();\n \treturn;\n       }\n-    for (ix = 4; ix--; expected >>= 8, version >>= 8, magic >>= 8)\n+    version = gcov_read_unsigned ();\n+    \n+    printf (\"%s:%s:magic `%.4s':version `%.4s'%s\\n\", filename, type,\n+ \t    (const char *)&magic, (const char *)&version,\n+\t    endianness < 0 ? \" (swapped endianness)\" : \"\");\n+    if (version != GCOV_VERSION)\n       {\n-\te[ix] = expected;\n-\tv[ix] = version;\n-\tm[ix] = magic;\n+\tunsigned expected = GCOV_VERSION;\n+\t\n+\tprintf (\"%s:warning:current version is `%.4s'\\n\", filename,\n+\t\t(const char *)expected);\n       }\n-\n-    printf (\"%s:%s:magic `%.4s':version `%.4s'\\n\", filename, type, m, v);\n-    if (different)\n-      printf (\"%s:warning:current version is `%.4s'\\n\", filename, e);\n   }\n \n   /* stamp */"}, {"sha": "bce2d04e44a242a1c4888ba4370227660c8d6a8e", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 94, "deletions": 100, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "patch": "@@ -26,13 +26,25 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #if !IN_GCOV\n static void gcov_write_block (unsigned);\n-static unsigned char *gcov_write_bytes (unsigned);\n+static gcov_unsigned_t *gcov_write_bytes (unsigned);\n #endif\n-static const unsigned char *gcov_read_bytes (unsigned);\n+static const gcov_unsigned_t *gcov_read_bytes (unsigned);\n #if !IN_LIBGCOV\n static void gcov_allocate (unsigned);\n #endif\n \n+static inline gcov_unsigned_t from_file (gcov_unsigned_t value)\n+{\n+#if !IN_LIBGCOV\n+  if (gcov_var.endian)\n+    {\n+      value = (value >> 16) | (value << 16);\n+      value = ((value & 0xff00ff) << 8) | ((value >> 8) & 0xff00ff);\n+    }\n+#endif\n+  return value;\n+}\n+\n /* Open a gcov file. NAME is the name of the file to open and MODE\n    indicates whether a new file should be created, or an existing file\n    opened for modification. If MODE is >= 0 an existing file will be\n@@ -42,9 +54,15 @@ static void gcov_allocate (unsigned);\n    opening an existing file and <0 on creating a new one.  */\n \n GCOV_LINKAGE int\n+#if IN_LIBGCOV\n+gcov_open (const char *name)\n+#else\n gcov_open (const char *name, int mode)\n+#endif\n {\n-  int result = 1;\n+#if IN_LIBGCOV\n+  const int mode = 0;\n+#endif\n #if GCOV_LOCKED\n   struct flock s_flock;\n \n@@ -61,20 +79,22 @@ gcov_open (const char *name, int mode)\n   gcov_var.offset = gcov_var.length = 0;\n   gcov_var.overread = -4u;\n   gcov_var.error = 0;\n+#if !IN_LIBGCOV\n+  gcov_var.endian = 0;\n+#endif\n   if (mode >= 0)\n     gcov_var.file = fopen (name, \"r+b\");\n   if (gcov_var.file)\n     gcov_var.mode = 1;\n   else if (mode <= 0)\n     {\n-      result = -1;\n       gcov_var.file = fopen (name, \"w+b\");\n       if (gcov_var.file)\n-\tgcov_var.mode = -1;\n+\tgcov_var.mode = mode * 2 + 1;\n     }\n   if (!gcov_var.file)\n     return 0;\n-\n+  \n   setbuf (gcov_var.file, (char *)0);\n   \n #if GCOV_LOCKED\n@@ -83,7 +103,7 @@ gcov_open (const char *name, int mode)\n     continue;\n #endif\n \n-  return result;\n+  return 1;\n }\n \n /* Close the current gcov file. Flushes data to disk. Returns nonzero\n@@ -111,6 +131,27 @@ gcov_close (void)\n   return gcov_var.error;\n }\n \n+#if !IN_LIBGCOV\n+/* Check if MAGIC is EXPECTED. Use it to determine endianness of the\n+   file. Returns +1 for same endian, -1 for other endian and zero for\n+   not EXPECTED.  */\n+\n+GCOV_LINKAGE int\n+gcov_magic (gcov_unsigned_t magic, gcov_unsigned_t expected)\n+{\n+  if (magic == expected)\n+    return 1;\n+  magic = (magic >> 16) | (magic << 16);\n+  magic = ((magic & 0xff00ff) << 8) | ((magic >> 8) & 0xff00ff);\n+  if (magic == expected)\n+    {\n+      gcov_var.endian = 1;\n+      return -1;\n+    }\n+  return 0;\n+}\n+#endif\n+\n #if !IN_LIBGCOV\n static void\n gcov_allocate (unsigned length)\n@@ -142,12 +183,13 @@ gcov_write_block (unsigned size)\n /* Allocate space to write BYTES bytes to the gcov file. Return a\n    pointer to those bytes, or NULL on failure.  */\n \n-static unsigned char *\n+static gcov_unsigned_t *\n gcov_write_bytes (unsigned bytes)\n {\n-  char unsigned *result;\n+  gcov_unsigned_t *result;\n \n   GCOV_CHECK_WRITING ();\n+  GCOV_CHECK (!(bytes & 3));\n #if IN_LIBGCOV\n   if (gcov_var.offset >= GCOV_BLOCK_SIZE)\n     {\n@@ -162,7 +204,7 @@ gcov_write_bytes (unsigned bytes)\n   if (gcov_var.offset + bytes > gcov_var.alloc)\n     gcov_allocate (gcov_var.offset + bytes);\n #endif\n-  result = &gcov_var.buffer[gcov_var.offset];\n+  result = (gcov_unsigned_t *)&gcov_var.buffer[gcov_var.offset];\n   gcov_var.offset += bytes;\n   \n   return result;\n@@ -174,18 +216,9 @@ gcov_write_bytes (unsigned bytes)\n GCOV_LINKAGE void\n gcov_write_unsigned (gcov_unsigned_t value)\n {\n-  unsigned char *buffer = gcov_write_bytes (4);\n-  unsigned ix;\n+  gcov_unsigned_t *buffer = gcov_write_bytes (4);\n \n-  for (ix = 4; ix--; )\n-    {\n-      buffer[ix] = value;\n-      value >>= 8;\n-    }\n-  if (sizeof (value) > 4 && value)\n-    gcov_var.error = -1;\n-\n-  return;\n+  buffer[0] = value;\n }\n \n /* Write counter VALUE to coverage file.  Sets error flag\n@@ -195,17 +228,16 @@ gcov_write_unsigned (gcov_unsigned_t value)\n GCOV_LINKAGE void\n gcov_write_counter (gcov_type value)\n {\n-  unsigned char *buffer = gcov_write_bytes (8);\n-  unsigned ix;\n+  gcov_unsigned_t *buffer = gcov_write_bytes (8);\n \n-  for (ix = 8; ix--; )\n-    {\n-      buffer[ix] = value;\n-      value >>= 8;\n-    }\n-  if ((sizeof (value) > 8 && value) || value < 0)\n+  buffer[0] = (gcov_unsigned_t) value;\n+  if (sizeof (value) > sizeof (gcov_unsigned_t))\n+    buffer[1] = (gcov_unsigned_t) (value >> 32);\n+  else\n+    buffer[1] = 0;\n+  \n+  if (value < 0)\n     gcov_var.error = -1;\n-  return;\n }\n #endif /* IN_LIBGCOV */\n \n@@ -217,28 +249,20 @@ GCOV_LINKAGE void\n gcov_write_string (const char *string)\n {\n   unsigned length = 0;\n-  unsigned pad = 0;\n-  unsigned rem = 0;\n-  unsigned char *buffer;\n-  unsigned ix;\n-  unsigned value;\n+  unsigned alloc = 0;\n+  gcov_unsigned_t *buffer;\n \n   if (string)\n     {\n       length = strlen (string);\n-      rem = 4 - (length & 3);\n+      alloc = (length + 4) >> 2;\n     }\n   \n-  buffer = gcov_write_bytes (4 + length + rem);\n+  buffer = gcov_write_bytes (4 + alloc * 4);\n \n-  value = length;\n-  for (ix = 4; ix--; )\n-    {\n-      buffer[ix] = value;\n-      value >>= 8;\n-    }\n-  memcpy (buffer + 4, string, length);\n-  memcpy (buffer + 4 + length, &pad, rem);\n+  buffer[0] = alloc;\n+  buffer[alloc] = 0;\n+  memcpy (&buffer[1], string, length);\n }\n #endif\n \n@@ -250,15 +274,11 @@ GCOV_LINKAGE gcov_position_t\n gcov_write_tag (gcov_unsigned_t tag)\n {\n   gcov_position_t result = gcov_var.start + gcov_var.offset;\n-  unsigned char *buffer = gcov_write_bytes (8);\n-  unsigned ix;\n+  gcov_unsigned_t *buffer = gcov_write_bytes (8);\n \n-  for (ix = 4; ix--; )\n-    {\n-      buffer[ix] = tag;\n-      tag >>= 8;\n-    }\n-  memset (buffer + 4, 0, 4);\n+  buffer[0] = tag;\n+  buffer[1] = 0;\n+  \n   return result;\n }\n \n@@ -272,20 +292,15 @@ gcov_write_length (gcov_position_t position)\n {\n   unsigned offset;\n   gcov_unsigned_t length;\n-  unsigned char *buffer;\n-  unsigned ix;\n+  gcov_unsigned_t *buffer;\n \n   GCOV_CHECK_WRITING ();\n   GCOV_CHECK (position + 8 <= gcov_var.start + gcov_var.offset);\n   GCOV_CHECK (position >= gcov_var.start);\n   offset = position - gcov_var.start;\n   length = gcov_var.offset - offset - 8;\n-  buffer = &gcov_var.buffer[offset + 4];\n-  for (ix = 4; ix--; )\n-    {\n-      buffer[ix] = length;\n-      length >>= 8;\n-    }\n+  buffer = (gcov_unsigned_t *) &gcov_var.buffer[offset];\n+  buffer[1] = length;\n   if (gcov_var.offset >= GCOV_BLOCK_SIZE)\n     gcov_write_block (gcov_var.offset);\n }\n@@ -297,20 +312,10 @@ gcov_write_length (gcov_position_t position)\n GCOV_LINKAGE void\n gcov_write_tag_length (gcov_unsigned_t tag, gcov_unsigned_t length)\n {\n-  unsigned char *buffer = gcov_write_bytes (8);\n-  unsigned ix;\n+  gcov_unsigned_t *buffer = gcov_write_bytes (8);\n \n-  for (ix = 4; ix--; )\n-    {\n-      buffer[ix] = tag;\n-      tag >>= 8;\n-    }\n-  for (ix = 4; ix--; )\n-    {\n-      buffer[ix + 4] = length;\n-      length >>= 8;\n-    }\n-  return;\n+  buffer[0] = tag;\n+  buffer[1] = length;\n }\n \n /* Write a summary structure to the gcov file.  Return nonzero on\n@@ -340,13 +345,14 @@ gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n /* Return a pointer to read BYTES bytes from the gcov file. Returns\n    NULL on failure (read past EOF).  */\n \n-static const unsigned char *\n+static const gcov_unsigned_t *\n gcov_read_bytes (unsigned bytes)\n {\n-  const unsigned char *result;\n+  const gcov_unsigned_t *result;\n   unsigned excess = gcov_var.length - gcov_var.offset;\n   \n   GCOV_CHECK_READING ();\n+  GCOV_CHECK (!(bytes & 3));\n   if (excess < bytes)\n     {\n       gcov_var.start += gcov_var.offset;\n@@ -379,7 +385,7 @@ gcov_read_bytes (unsigned bytes)\n \t  return 0;\n \t}\n     }\n-  result = &gcov_var.buffer[gcov_var.offset];\n+  result = (gcov_unsigned_t *)&gcov_var.buffer[gcov_var.offset];\n   gcov_var.offset += bytes;\n   return result;\n }\n@@ -390,20 +396,12 @@ gcov_read_bytes (unsigned bytes)\n GCOV_LINKAGE gcov_unsigned_t\n gcov_read_unsigned (void)\n {\n-  gcov_unsigned_t value = 0;\n-  unsigned ix;\n-  const unsigned char *buffer = gcov_read_bytes (4);\n+  gcov_unsigned_t value;\n+  const gcov_unsigned_t *buffer = gcov_read_bytes (4);\n \n   if (!buffer)\n     return 0;\n-  for (ix = sizeof (value); ix < 4; ix++)\n-    if (buffer[ix])\n-      gcov_var.error = -1;\n-  for (ix = 0; ix != 4; ix++)\n-    {\n-      value <<= 8;\n-      value |= buffer[ix];\n-    }\n+  value = from_file (buffer[0]);\n   return value;\n }\n \n@@ -413,20 +411,17 @@ gcov_read_unsigned (void)\n GCOV_LINKAGE gcov_type\n gcov_read_counter (void)\n {\n-  gcov_type value = 0;\n-  unsigned ix;\n-  const unsigned char *buffer = gcov_read_bytes (8);\n+  gcov_type value;\n+  const gcov_unsigned_t *buffer = gcov_read_bytes (8);\n \n   if (!buffer)\n     return 0;\n-  for (ix = sizeof (value); ix < 8; ix++)\n-    if (buffer[ix])\n-      gcov_var.error = -1;\n-  for (ix = 0; ix != 8; ix++)\n-    {\n-      value <<= 8;\n-      value |= buffer[ix];\n-    }\n+  value = from_file (buffer[0]);\n+  if (sizeof (value) > sizeof (gcov_unsigned_t))\n+    value |= ((gcov_type) from_file (buffer[1])) << 32;\n+  else if (buffer[1])\n+    gcov_var.error = -1;\n+  \n   if (value < 0)\n     gcov_var.error = -1;\n   return value;\n@@ -445,7 +440,6 @@ gcov_read_string (void)\n   if (!length)\n     return 0;\n \n-  length += 4 - (length & 3);\n   return (const char *) gcov_read_bytes (length);\n }\n #endif"}, {"sha": "35c31b955fe5a683a5b5bb335025c06156620ce4", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 90, "deletions": 84, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "patch": "@@ -28,24 +28,25 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    This exception does not however invalidate any other reasons why\n    the executable file might be covered by the GNU General Public License.  */\n \n-/* Coverage information is held in two files.  A basic block graph\n-   file, which is generated by the compiler, and a counter file, which\n-   is generated by the program under test.  Both files use a similar\n-   structure.  We do not attempt to make these files backwards\n-   compatible with previous versions, as you only need coverage\n-   information when developing a program.  We do hold version\n-   information, so that mismatches can be detected, and we use a\n-   format that allows tools to skip information they do not understand\n-   or are not interested in.\n-\n-   Numbers are recorded in big endian unsigned binary form.  Either in\n-   32 or 64 bits.  Strings are stored with a length count and NUL\n-   terminator, and 0 to 3 bytes of zero padding up to the next 4 byte\n-   boundary.  Zero length and NULL strings are simply stored as a\n-   length of zero (they have no trailing NUL or padding).\n-\n-   \tint32:  byte3 byte2 byte1 byte0\n-\tint64:  byte7 byte6 byte5 byte4 byte3 byte2 byte1 byte0\n+/* Coverage information is held in two files.  A notes file, which is\n+   generated by the compiler, and a data file, which is generated\n+   by the program under test.  Both files use a similar structure.  We\n+   do not attempt to make these files backwards compatible with\n+   previous versions, as you only need coverage information when\n+   developing a program.  We do hold version information, so that\n+   mismatches can be detected, and we use a format that allows tools\n+   to skip information they do not understand or are not interested\n+   in.\n+\n+   Numbers are recorded in the 32 bit unsigned binary form of the\n+   endianness of the machine generating the file. 64 bit numbers are\n+   stored as two 32 bit numbers, the low part first.  Strings are\n+   stored as length rounded up to 4 followed by the string and then 1\n+   to 4 NUL bytes.  Zero length and NULL strings are simply stored as\n+   a length of zero (they have no trailing NUL or padding).\n+\n+   \tint32:  byte3 byte2 byte1 byte0 | byte0 byte1 byte2 byte3\n+\tint64:  int32:low int32:high\n \tstring: int32:0 | int32:length char* char:0 padding\n \tpadding: | char:0 | char:0 char:0 | char:0 char:0 char:0\n \titem: int32 | int64 | string\n@@ -54,31 +55,30 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    \tfile : int32:magic int32:version int32:stamp record*\n \n-   The magic ident is different for the bbg and the counter files.\n-   The version is the same for both files and is derived from gcc's\n-   version number. The stamp value is used to synchronize bbg and\n-   counter files and to synchronize merging within a counter file. It\n-   need not be an absolute time stamp, merely a ticker that increments\n-   fast enough and cycles slow enough to distinguish different\n-   compile/run/compile cycles.\n+   The magic ident is different for the notes and the data files.  The\n+   magic ident is used to determine the endianness of the file, when\n+   reading.  The version is the same for both files and is derived\n+   from gcc's version number. The stamp value is used to synchronize\n+   note and data files and to synchronize merging within a data\n+   file. It need not be an absolute time stamp, merely a ticker that\n+   increments fast enough and cycles slow enough to distinguish\n+   different compile/run/compile cycles.\n    \n-   Although the ident and version are formally 32 bit\n-   numbers, they are derived from 4 character ASCII strings.  The\n-   version number consists of the single character major version\n-   number, a two character minor version number (leading zero for\n-   versions less than 10), and a single character indicating the\n-   status of the release.  That will be 'e' experimental, 'p'\n-   prerelease and 'r' for release.  Because, by good fortune, these are\n-   in alphabetical order, string collating can be used to compare\n-   version strings, and because numbers are stored big endian, numeric\n-   comparison can be used when it is read as a 32 bit value.  Be aware\n-   that the 'e' designation will (naturally) be unstable and might be\n+   Although the ident and version are formally 32 bit numbers, they\n+   are derived from 4 character ASCII strings.  The version number\n+   consists of the single character major version number, a two\n+   character minor version number (leading zero for versions less than\n+   10), and a single character indicating the status of the release.\n+   That will be 'e' experimental, 'p' prerelease and 'r' for release.\n+   Because, by good fortune, these are in alphabetical order, string\n+   collating can be used to compare version strings.  Be aware that\n+   the 'e' designation will (naturally) be unstable and might be\n    incompatible with itself.  For gcc 3.4 experimental, it would be\n-   '304e' (0x33303465).  When the major version reaches 10, the letters\n-   A-Z will be used.  Assuming minor increments releases every 6\n-   months, we have to make a major increment every 50 years.  Assuming\n-   major increments releases every 5 years, we're ok for the next 155\n-   years -- good enough for me.\n+   '304e' (0x33303465).  When the major version reaches 10, the\n+   letters A-Z will be used.  Assuming minor increments releases every\n+   6 months, we have to make a major increment every 50 years.\n+   Assuming major increments releases every 5 years, we're ok for the\n+   next 155 years -- good enough for me.\n \n    A record has a tag, length and variable amount of data.\n \n@@ -87,21 +87,21 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \tdata: item*\n \n    Records are not nested, but there is a record hierarchy.  Tag\n-   numbers reflect this hierarchy.  Tags are unique across bbg and da\n-   files.  Some record types have a varying amount of data.  The LENGTH\n-   is usually used to determine how much data.  The tag value is split\n-   into 4 8-bit fields, one for each of four possible levels.  The\n-   most significant is allocated first.  Unused levels are zero.\n+   numbers reflect this hierarchy.  Tags are unique across note and\n+   data files.  Some record types have a varying amount of data.  The\n+   LENGTH is usually used to determine how much data.  The tag value\n+   is split into 4 8-bit fields, one for each of four possible levels.\n+   The most significant is allocated first.  Unused levels are zero.\n    Active levels are odd-valued, so that the LSB of the level is one.\n    A sub-level incorporates the values of its superlevels.  This\n    formatting allows you to determine the tag hierarchy, without\n    understanding the tags themselves, and is similar to the standard\n    section numbering used in technical documents.  Level values\n-   [1..3f] are used for common tags, values [41..9f] for the graph\n-   file and [a1..ff] for the counter file.\n+   [1..3f] are used for common tags, values [41..9f] for the notes\n+   file and [a1..ff] for the data file.\n \n    The basic block graph file contains the following records\n-   \tbbg:  unit function-graph*\n+   \tnote: unit function-graph*\n \tunit: header int32:checksum string:source\n \tfunction-graph: announce_function basic_blocks {arcs | lines}*\n \tannounce_function: header int32:ident int32:checksum\n@@ -130,7 +130,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    blocks they are for.\n \n    The data file contains the following records.\n-        da: {unit function-data* summary:object summary:program*}*\n+        data: {unit function-data* summary:object summary:program*}*\n \tunit: header int32:checksum\n         function-data:\tannounce_function arc_counts\n \tannounce_function: header int32:ident int32:checksum\n@@ -139,17 +139,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \tcount-summary:\tint32:num int32:runs int64:sum\n \t\t\tint64:max int64:sum_max\n \n-   The ANNOUNCE_FUNCTION record is the same as that in the BBG file,\n-   but without the source location.\n-   The ARC_COUNTS gives the counter values for those arcs that are\n-   instrumented.  The SUMMARY records give information about the whole\n-   object file and about the whole program.  The checksum is used for\n-   whole program summaries, and disambiguates different programs which\n-   include the same instrumented object file.  There may be several\n-   program summaries, each with a unique checksum.  The object\n-   summary's checkum is zero.  Note that the da file might contain\n-   information from several runs concatenated, or the data might be\n-   merged.\n+   The ANNOUNCE_FUNCTION record is the same as that in the note file,\n+   but without the source location.  The ARC_COUNTS gives the counter\n+   values for those arcs that are instrumented.  The SUMMARY records\n+   give information about the whole object file and about the whole\n+   program.  The checksum is used for whole program summaries, and\n+   disambiguates different programs which include the same\n+   instrumented object file.  There may be several program summaries,\n+   each with a unique checksum.  The object summary's checkum is zero.\n+   Note that the data file might contain information from several runs\n+   concatenated, or the data might be merged.\n \n    This file is included by both the compiler, gcov tools and the\n    runtime support library libgcov. IN_LIBGCOV and IN_GCOV are used to\n@@ -231,7 +230,7 @@ typedef HOST_WIDEST_INT gcov_type;\n \n /* Poison these, so they don't accidentally slip in.  */\n #pragma GCC poison gcov_write_string gcov_write_tag gcov_write_length\n-#pragma GCC poison gcov_read_string gcov_sync gcov_time\n+#pragma GCC poison gcov_read_string gcov_sync gcov_time gcov_magic\n \n #endif\n \n@@ -240,21 +239,21 @@ typedef HOST_WIDEST_INT gcov_type;\n #endif\n \n /* File suffixes.  */\n-#define GCOV_DATA_SUFFIX \".da\"\n-#define GCOV_GRAPH_SUFFIX \".bbg\"\n+#define GCOV_DATA_SUFFIX \".gcda\"\n+#define GCOV_NOTE_SUFFIX \".gcno\"\n \n-/* File magic.  */\n-#define GCOV_DATA_MAGIC  0x67636f76 /* \"gcov\" */\n-#define GCOV_GRAPH_MAGIC 0x67626267 /* \"gbbg\" */\n+/* File magic. Must not be palindromes.  */\n+#define GCOV_DATA_MAGIC ((gcov_unsigned_t)0x67636461) /* \"gcda\" */\n+#define GCOV_NOTE_MAGIC ((gcov_unsigned_t)0x67636e6f) /* \"gcno\" */\n \n /* gcov-iov.h is automatically generated by the makefile from\n    version.c, it looks like\n-   \t#define GCOV_VERSION ((unsigned)0x89abcdef)\n+   \t#define GCOV_VERSION ((gcov_unsigned_t)0x89abcdef)\n */\n #include \"gcov-iov.h\"\n \n /* The record tags.  Values [1..3f] are for tags which may be in either\n-   file.  Values [41..9f] for those in the bbg file and [a1..ff] for\n+   file.  Values [41..9f] for those in the note file and [a1..ff] for\n    the data file.  */\n \n #define GCOV_TAG_FUNCTION\t ((gcov_unsigned_t)0x01000000)\n@@ -374,7 +373,7 @@ struct gcov_ctr_info\n struct gcov_info\n {\n   gcov_unsigned_t version;\t/* expected version number */\n-  struct gcov_info *next;\t/* link to next, used by libgcc */\n+  struct gcov_info *next;\t/* link to next, used by libgcov */\n \n   gcov_unsigned_t stamp;\t/* uniquifying time stamp */\n   const char *filename;\t\t/* output file name */\n@@ -398,11 +397,11 @@ extern void __gcov_flush (void);\n /* The merge function that just sums the counters.  */\n extern void __gcov_merge_add (gcov_type *, unsigned);\n \n-/* The merge function to choose the most often value.  */\n+/* The merge function to choose the most common value.  */\n extern void __gcov_merge_single (gcov_type *, unsigned);\n \n-/* The merge function to choose the most often difference between consecutive\n-   values.  */\n+/* The merge function to choose the most common difference between\n+   consecutive values.  */\n extern void __gcov_merge_delta (gcov_type *, unsigned);\n #endif /* IN_LIBGCOV */\n \n@@ -425,24 +424,31 @@ GCOV_LINKAGE struct gcov_var\n      fit within this buffer and we always can transfer GCOV_BLOCK_SIZE\n      to and from the disk. libgcov never backtracks and only writes 4\n      or 8 byte objects.  */\n-  unsigned char buffer[GCOV_BLOCK_SIZE + 4];\n+  char buffer[GCOV_BLOCK_SIZE + 4] __attribute__ ((aligned (4)));\n #else\n+  int endian;\t\t\t/* Swap endianness.  */\n   /* Holds a variable length block, as the compiler can write\n      strings and needs to backtrack.  */\n   size_t alloc;\n-  unsigned char *buffer;\n+  char *buffer;\n #endif\n } gcov_var;\n \n-/* Functions for reading and writing gcov files. You can open a file\n-   for (1) reading or (2) writing or (3) reading then rewriting. When\n-   reading a file you may use the gcov_read_* functions, gcov_sync,\n-   gcov_position, & gcov_error. When writing a file you\n-   may use the gcov_write functions, gcov_seek & gcov_error. When a\n-   file is to be rewritten you use the functions for reading, then\n-   gcov_rewrite then the functions for writing.  Your file may become\n-   corrupted if you break these invariants.  */\n-GCOV_LINKAGE int gcov_open (const char */*name*/, int /*truncate*/);\n+/* Functions for reading and writing gcov files. In libgcov you can\n+   open the file for reading then writing. Elsewhere you can open the\n+   file either for reading or for writing. When reading a file you may\n+   use the gcov_read_* functions, gcov_sync, gcov_position, &\n+   gcov_error. When writing a file you may use the gcov_write\n+   functions, gcov_seek & gcov_error. When a file is to be rewritten\n+   you use the functions for reading, then gcov_rewrite then the\n+   functions for writing.  Your file may become corrupted if you break\n+   these invariants. */\n+#if IN_LIBGCOV\n+GCOV_LINKAGE int gcov_open (const char */*name*/);\n+#else\n+GCOV_LINKAGE int gcov_open (const char */*name*/, int /*direction*/);\n+GCOV_LINKAGE int gcov_magic (gcov_unsigned_t, gcov_unsigned_t);\n+#endif\n GCOV_LINKAGE int gcov_close (void);\n \n /* Available everywhere.  */"}, {"sha": "d6b39de3da1a95616f15babe79d8f127b17fee0a", "filename": "gcc/gcov-iov.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fgcov-iov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fgcov-iov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-iov.c?ref=160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "patch": "@@ -61,7 +61,7 @@ main (int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)\n   printf (\"/* Generated automatically by the program `%s'\\n\", argv[0]);\n   printf (\"   from `%s'.  */\\n\", version_string);\n   printf (\"\\n\");\n-  printf (\"#define GCOV_VERSION ((unsigned)%#08x)  /* %.4s */\\n\",\n+  printf (\"#define GCOV_VERSION ((gcov_unsigned_t)%#08x)  /* %.4s */\\n\",\n \t  version, v);\n \n   return 0;"}, {"sha": "d42cff15b2ca5e08a48837c7c24982d515139687", "filename": "gcc/gcov.c", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "patch": "@@ -417,13 +417,10 @@ print_usage (int error_p)\n static void\n print_version (void)\n {\n-  char v[4];\n   unsigned version = GCOV_VERSION;\n-  unsigned ix;\n \n-  for (ix = 4; ix--; version >>= 8)\n-    v[ix] = version;\n-  fnotice (stdout, \"gcov %.4s (GCC %s)\\n\", v, version_string);\n+  fnotice (stdout, \"gcov %.4s (GCC %s)\\n\",\n+\t   (const char *)&version, version_string);\n   fnotice (stdout, \"Copyright (C) 2002 Free Software Foundation, Inc.\\n\");\n   fnotice (stdout,\n \t   \"This is free software; see the source for copying conditions.  There is NO\\n\\\n@@ -660,10 +657,10 @@ create_file_names (const char *file_name)\n     *cptr = 0;\n \n   length = strlen (name);\n-\n-  bbg_file_name = xmalloc (length + strlen (GCOV_GRAPH_SUFFIX) + 1);\n+  \n+  bbg_file_name = xmalloc (length + strlen (GCOV_NOTE_SUFFIX) + 1);\n   strcpy (bbg_file_name, name);\n-  strcpy (bbg_file_name + length, GCOV_GRAPH_SUFFIX);\n+  strcpy (bbg_file_name + length, GCOV_NOTE_SUFFIX);\n \n   da_file_name = xmalloc (length + strlen (GCOV_DATA_SUFFIX) + 1);\n   strcpy (da_file_name, name);\n@@ -715,7 +712,7 @@ read_graph_file (void)\n       return 1;\n     }\n   bbg_file_time = gcov_time ();\n-  if (gcov_read_unsigned () != GCOV_GRAPH_MAGIC)\n+  if (!gcov_magic (gcov_read_unsigned (), GCOV_NOTE_MAGIC))\n     {\n       fnotice (stderr, \"%s:not a gcov graph file\\n\", bbg_file_name);\n       gcov_close ();\n@@ -984,7 +981,7 @@ read_count_file (void)\n       fnotice (stderr, \"%s:cannot open data file\\n\", da_file_name);\n       return 1;\n     }\n-  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n+  if (!gcov_magic (gcov_read_unsigned (), GCOV_DATA_MAGIC))\n     {\n       fnotice (stderr, \"%s:not a gcov data file\\n\", da_file_name);\n     cleanup:;\n@@ -994,16 +991,10 @@ read_count_file (void)\n   version = gcov_read_unsigned ();\n   if (version != GCOV_VERSION)\n     {\n-      char v[4], e[4];\n       unsigned desired = GCOV_VERSION;\n-\n-      for (ix = 4; ix--; desired >>= 8, version >>= 8)\n-\t{\n-\t  v[ix] = version;\n-\t  e[ix] = desired;\n-\t}\n+      \n       fnotice (stderr, \"%s:version `%.4s', prefer version `%.4s'\\n\",\n-\t       da_file_name, v, e);\n+\t       da_file_name, (const char *)&version, (const char *)&desired);\n     }\n   tag = gcov_read_unsigned ();\n   if (tag != bbg_stamp)"}, {"sha": "826617f14b4260b05da68659cb1cacd82bcd3cd7", "filename": "gcc/libgcov.c", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/160e2e4f2361da06d8cd73afea7b527b29d4c6a7/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=160e2e4f2361da06d8cd73afea7b527b29d4c6a7", "patch": "@@ -91,22 +91,19 @@ static struct gcov_info *gcov_list;\n    object file included in multiple programs.  */\n static gcov_unsigned_t gcov_crc32;\n \n-static void\n-gcov_version_mismatch (struct gcov_info *ptr, gcov_unsigned_t version)\n+static int\n+gcov_version (struct gcov_info *ptr, gcov_unsigned_t version)\n {\n   gcov_unsigned_t expected = GCOV_VERSION;\n-  unsigned ix;\n-  char e[4], v[4];\n \n-  for (ix = 4; ix--; expected >>= 8, version >>= 8)\n+  if (version != GCOV_VERSION)\n     {\n-      e[ix] = expected;\n-      v[ix] = version;\n+      fprintf (stderr,\n+\t       \"profiling:%s:Version mismatch - expected %.4s got %.4s\\n\",\n+\t       ptr->filename, (const char *)&expected, (const char *)&version);\n+      return 0;\n     }\n-  \n-  fprintf (stderr,\n-\t   \"profiling:%s:Version mismatch - expected %.4s got %.4s\\n\",\n-\t   ptr->filename, e, v);\n+  return 1;\n }\n \n /* Dump the coverage counts. We merge with existing counts when\n@@ -163,7 +160,6 @@ gcov_exit (void)\n       struct gcov_ctr_summary *cs_ptr;\n       struct gcov_ctr_summary *cs_obj, *cs_tobj, *cs_prg, *cs_tprg, *cs_all;\n       int error = 0;\n-      int merging;\n       gcov_unsigned_t tag, length;\n       gcov_position_t summary_pos = 0;\n \n@@ -200,18 +196,17 @@ gcov_exit (void)\n \t  fi_stride &= ~(__alignof__ (struct gcov_fn_info) - 1);\n \t}\n       \n-      /* Open for modification, if possible */\n-      merging = gcov_open (gi_ptr->filename, 0);\n-      if (!merging)\n+      if (!gcov_open (gi_ptr->filename))\n \t{\n \t  fprintf (stderr, \"profiling:%s:Cannot open\\n\", gi_ptr->filename);\n \t  continue;\n \t}\n-      \n-      if (merging > 0)\n+\n+      tag = gcov_read_unsigned ();\n+      if (tag)\n \t{\n \t  /* Merge data from file.  */\n-\t  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)\n+\t  if (tag != GCOV_DATA_MAGIC)\n \t    {\n \t      fprintf (stderr, \"profiling:%s:Not a gcov data file\\n\",\n \t\t       gi_ptr->filename);\n@@ -220,11 +215,8 @@ gcov_exit (void)\n \t      continue;\n \t    }\n \t  length = gcov_read_unsigned ();\n-\t  if (length != GCOV_VERSION)\n-\t    {\n-\t      gcov_version_mismatch (gi_ptr, length);\n-\t      goto read_fatal;\n-\t    }\n+\t  if (!gcov_version (gi_ptr, length))\n+\t    goto read_fatal;\n \n \t  length = gcov_read_unsigned ();\n \t  if (length != gi_ptr->stamp)\n@@ -299,16 +291,17 @@ gcov_exit (void)\n \t\t  goto rewrite;\n \t\t}\n \t    }\n-\t  if (!gcov_is_eof ())\n-\t    {\n-\t    read_error:;\n-\t      fprintf (stderr, error < 0 ? \"profiling:%s:Overflow merging\\n\"\n-\t\t       : \"profiling:%s:Error merging\\n\", gi_ptr->filename);\n-\t      goto read_fatal;\n-\t    }\n-\trewrite:;\n-\t  gcov_rewrite ();\n \t}\n+      \n+      if (!gcov_is_eof ())\n+ \t{\n+ \tread_error:;\n+ \t  fprintf (stderr, error < 0 ? \"profiling:%s:Overflow merging\\n\"\n+ \t\t   : \"profiling:%s:Error merging\\n\", gi_ptr->filename);\n+ \t  goto read_fatal;\n+ \t}\n+    rewrite:;\n+      gcov_rewrite ();\n       if (!summary_pos)\n \tmemset (&program, 0, sizeof (program));\n \n@@ -414,9 +407,7 @@ __gcov_init (struct gcov_info *info)\n {\n   if (!info->version)\n     return;\n-  if (info->version != GCOV_VERSION)\n-    gcov_version_mismatch (info, info->version);\n-  else\n+  if (gcov_version (info, info->version))\n     {\n       const char *ptr = info->filename;\n       gcov_unsigned_t crc32 = gcov_crc32;"}]}