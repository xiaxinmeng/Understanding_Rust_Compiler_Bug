{"sha": "eaee4464778034db0c3f27640c98bdfb8584ef17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlZTQ0NjQ3NzgwMzRkYjBjM2YyNzY0MGM5OGJkZmI4NTg0ZWYxNw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2007-01-30T11:20:07Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-01-30T11:20:07Z"}, "message": "builtins.c (expand_builtin_int_interclass_roundingfn): New function to handle optabs that operate on floating point input argument and...\n\n\t* builtins.c (expand_builtin_int_interclass_roundingfn): New function\n\tto handle optabs that operate on floating point input argument and\n\toutput to integer output.\n\t(expand_builtin_mathfn) [BUILT_IN_ILOGB]: Move from here ...\n\t(expand_builtin_interclass_mathfn) [BUILT_IN_ILOGB]: ... to here.\n\t(expand_builtin): Expand BUILT_IN_ILOGB{,F,L} using\n\texpand_builtin_interclass_mathfn ().\n\t* config/i386/i386.md (fxtractxf3_i387): Rename from *fxtractxf3_i387.\n\t(ilogbsi2): Remove.\n\t(ilogbxf2, ilogb<mode>2): New expanders to implement ilogb, ilogbf and\n\tilogbl built-in functions as x87 intrinsics.\n\nFrom-SVN: r121336", "tree": {"sha": "942a2e626dc40e269d296c1c97e6a8efef92aff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/942a2e626dc40e269d296c1c97e6a8efef92aff0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaee4464778034db0c3f27640c98bdfb8584ef17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaee4464778034db0c3f27640c98bdfb8584ef17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaee4464778034db0c3f27640c98bdfb8584ef17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaee4464778034db0c3f27640c98bdfb8584ef17/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b1959ffcaa3fab49a90eb25f32a815ac22c2a85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1959ffcaa3fab49a90eb25f32a815ac22c2a85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b1959ffcaa3fab49a90eb25f32a815ac22c2a85"}], "stats": {"total": 145, "additions": 129, "deletions": 16}, "files": [{"sha": "cc300099d60c81b27eedb05dc3d90471ac0c90dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaee4464778034db0c3f27640c98bdfb8584ef17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaee4464778034db0c3f27640c98bdfb8584ef17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eaee4464778034db0c3f27640c98bdfb8584ef17", "patch": "@@ -1,3 +1,17 @@\n+2007-01-30  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* builtins.c (expand_builtin_int_interclass_roundingfn): New function\n+\tto handle optabs that operate on floating point input argument and\n+\toutput to integer output.\n+\t(expand_builtin_mathfn) [BUILT_IN_ILOGB]: Move from here ...\n+\t(expand_builtin_interclass_mathfn) [BUILT_IN_ILOGB]: ... to here.\n+\t(expand_builtin): Expand BUILT_IN_ILOGB{,F,L} using\n+\texpand_builtin_interclass_mathfn ().\n+\t* config/i386/i386.md (fxtractxf3_i387): Rename from *fxtractxf3_i387.\n+\t(ilogbsi2): Remove.\n+\t(ilogbxf2, ilogb<mode>2): New expanders to implement ilogb, ilogbf and\n+\tilogbl built-in functions as x87 intrinsics.\n+\n 2007-01-30  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/27657"}, {"sha": "5ba1eae5eb6d0790aff4500ac1aa0ce371dae559", "filename": "gcc/builtins.c", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaee4464778034db0c3f27640c98bdfb8584ef17/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaee4464778034db0c3f27640c98bdfb8584ef17/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=eaee4464778034db0c3f27640c98bdfb8584ef17", "patch": "@@ -95,6 +95,7 @@ static void expand_errno_check (tree, rtx);\n static rtx expand_builtin_mathfn (tree, rtx, rtx);\n static rtx expand_builtin_mathfn_2 (tree, rtx, rtx);\n static rtx expand_builtin_mathfn_3 (tree, rtx, rtx);\n+static rtx expand_builtin_interclass_mathfn (tree, rtx, rtx);\n static rtx expand_builtin_sincos (tree);\n static rtx expand_builtin_cexpi (tree, rtx, rtx);\n static rtx expand_builtin_int_roundingfn (tree, rtx, rtx);\n@@ -1814,8 +1815,6 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n       errno_set = true; builtin_optab = expm1_optab; break;\n     CASE_FLT_FN (BUILT_IN_LOGB):\n       errno_set = true; builtin_optab = logb_optab; break;\n-    CASE_FLT_FN (BUILT_IN_ILOGB):\n-      errno_set = true; builtin_optab = ilogb_optab; break;\n     CASE_FLT_FN (BUILT_IN_LOG):\n       errno_set = true; builtin_optab = log_optab; break;\n     CASE_FLT_FN (BUILT_IN_LOG10):\n@@ -2170,6 +2169,86 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n   return target;\n }\n \n+/* Expand a call to one of the builtin math functions that operate on\n+   floating point argument and output an integer result (ilogb, isinf,\n+   isnan, etc).\n+   Return 0 if a normal call should be emitted rather than expanding the\n+   function in-line.  EXP is the expression that is a call to the builtin\n+   function; if convenient, the result should be placed in TARGET.\n+   SUBTARGET may be used as the target for computing one of EXP's operands.  */\n+\n+static rtx\n+expand_builtin_interclass_mathfn (tree exp, rtx target, rtx subtarget)\n+{\n+  optab builtin_optab;\n+  enum insn_code icode;\n+  rtx op0;\n+  tree fndecl = get_callee_fndecl (exp);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum machine_mode mode;\n+  bool errno_set = false;\n+  tree arg, narg;\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg = TREE_VALUE (arglist);\n+\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    CASE_FLT_FN (BUILT_IN_ILOGB):\n+      errno_set = true; builtin_optab = ilogb_optab; break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* There's no easy way to detect the case we need to set EDOM.  */\n+  if (flag_errno_math && errno_set)\n+    return NULL_RTX;\n+\n+  /* Optab mode depends on the mode of the input argument.  */\n+  mode = TYPE_MODE (TREE_TYPE (arg));\n+\n+  icode = builtin_optab->handlers[(int) mode].insn_code;\n+ \n+  /* Before working hard, check whether the instruction is available.  */\n+  if (icode != CODE_FOR_nothing)\n+    {\n+      /* Make a suitable register to place result in.  */\n+      if (!target\n+\t  || GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp)))\n+         target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n+\n+      gcc_assert (insn_data[icode].operand[0].predicate\n+\t\t  (target, GET_MODE (target)));\n+\n+      /* Wrap the computation of the argument in a SAVE_EXPR, as we may\n+\t need to expand the argument again.  This way, we will not perform\n+\t side-effects more the once.  */\n+      narg = builtin_save_expr (arg);\n+      if (narg != arg)\n+\t{\n+\t  arg = narg;\n+\t  arglist = build_tree_list (NULL_TREE, arg);\n+\t  exp = build_function_call_expr (fndecl, arglist);\n+\t}\n+\n+      op0 = expand_expr (arg, subtarget, VOIDmode, 0);\n+\n+      if (mode != GET_MODE (op0))\n+\top0 = convert_to_mode (mode, op0, 0);\n+\n+      /* Compute into TARGET.\n+\t Set TARGET to wherever the result comes back.  */\n+      emit_unop_insn (icode, target, op0, UNKNOWN);\n+      return target;\n+    }\n+\n+  target = expand_call (exp, target, target == const0_rtx);\n+\n+  return target;\n+}\n+\n /* Expand a call to the builtin sincos math function.\n    Return 0 if a normal call should be emitted rather than expanding the\n    function in-line.  EXP is the expression that is a call to the builtin\n@@ -5817,7 +5896,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     CASE_FLT_FN (BUILT_IN_EXP2):\n     CASE_FLT_FN (BUILT_IN_EXPM1):\n     CASE_FLT_FN (BUILT_IN_LOGB):\n-    CASE_FLT_FN (BUILT_IN_ILOGB):\n     CASE_FLT_FN (BUILT_IN_LOG):\n     CASE_FLT_FN (BUILT_IN_LOG10):\n     CASE_FLT_FN (BUILT_IN_LOG2):\n@@ -5842,6 +5920,14 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn target;\n       break;\n \n+    CASE_FLT_FN (BUILT_IN_ILOGB):\n+      if (! flag_unsafe_math_optimizations)\n+\tbreak;\n+      target = expand_builtin_interclass_mathfn (exp, target, subtarget);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     CASE_FLT_FN (BUILT_IN_LCEIL):\n     CASE_FLT_FN (BUILT_IN_LLCEIL):\n     CASE_FLT_FN (BUILT_IN_LFLOOR):"}, {"sha": "a9620e2242be36186f4f3085c325cca70f8429c9", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaee4464778034db0c3f27640c98bdfb8584ef17/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaee4464778034db0c3f27640c98bdfb8584ef17/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=eaee4464778034db0c3f27640c98bdfb8584ef17", "patch": "@@ -16261,7 +16261,7 @@\n   DONE;\n })\n \n-(define_insn \"*fxtractxf3_i387\"\n+(define_insn \"fxtractxf3_i387\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(unspec:XF [(match_operand:XF 2 \"register_operand\" \"0\")]\n \t\t   UNSPEC_XTRACT_FRACT))\n@@ -16316,21 +16316,34 @@\n   DONE;\n })\n \n-(define_expand \"ilogbsi2\"\n-  [(parallel [(set (match_dup 2)\n-\t\t   (unspec:XF [(match_operand:XF 1 \"register_operand\" \"\")]\n-\t\t\t      UNSPEC_XTRACT_FRACT))\n-\t      (set (match_dup 3)\n-\t\t   (unspec:XF [(match_dup 1)] UNSPEC_XTRACT_EXP))])\n-   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t           (fix:SI (match_dup 3)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n+(define_expand \"ilogbxf2\"\n+  [(use (match_operand:SI 0 \"register_operand\" \"\"))\n+   (use (match_operand:XF 1 \"register_operand\" \"\"))]\n   \"TARGET_USE_FANCY_MATH_387\n-   && (!TARGET_SSE_MATH || TARGET_MIX_SSE_I387)\n    && flag_unsafe_math_optimizations && !optimize_size\"\n {\n-  operands[2] = gen_reg_rtx (XFmode);\n-  operands[3] = gen_reg_rtx (XFmode);\n+  rtx op0 = gen_reg_rtx (XFmode);\n+  rtx op1 = gen_reg_rtx (XFmode);\n+\n+  emit_insn (gen_fxtractxf3_i387 (op0, op1, operands[1]));\n+  emit_insn (gen_fix_truncxfsi2 (operands[0], op1));\n+  DONE;\n+})\n+\n+(define_expand \"ilogb<mode>2\"\n+  [(use (match_operand:SI 0 \"register_operand\" \"\"))\n+   (use (match_operand:X87MODEF12 1 \"register_operand\" \"\"))]\n+  \"TARGET_USE_FANCY_MATH_387\n+   && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n+       || TARGET_MIX_SSE_I387)\n+   && flag_unsafe_math_optimizations && !optimize_size\"\n+{\n+  rtx op0 = gen_reg_rtx (XFmode);\n+  rtx op1 = gen_reg_rtx (XFmode);\n+\n+  emit_insn (gen_fxtract_extend<mode>xf3_i387 (op0, op1, operands[1]));\n+  emit_insn (gen_fix_truncxfsi2 (operands[0], op1));\n+  DONE;\n })\n \n (define_insn \"*f2xm1xf2_i387\""}]}