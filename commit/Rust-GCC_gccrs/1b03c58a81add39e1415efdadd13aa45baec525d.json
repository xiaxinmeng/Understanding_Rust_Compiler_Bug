{"sha": "1b03c58a81add39e1415efdadd13aa45baec525d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIwM2M1OGE4MWFkZDM5ZTE0MTVlZmRhZGQxM2FhNDViYWVjNTI1ZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2006-09-14T21:15:12Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-09-14T21:15:12Z"}, "message": "re PR middle-end/28884 (TARGET_FUNCTION_VALUE not documented)\n\n\tPR middle-end/28884.\n\t* doc/tm.texi (TARGET_FUNCTION_VALUE): Document.\n\t(FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE): Deprecate.\n\tReplace mentions of FUNCTION_VALUE and FUNCTION_OUTGOING_VALUE\n\twith TARGET_FUNCTION_VALUE.\n\nCo-Authored-By: Kazu Hirata <kazu@codesourcery.com>\n\nFrom-SVN: r116951", "tree": {"sha": "edbb89fd77cefa7f9655e4bb61b39105d48c3ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edbb89fd77cefa7f9655e4bb61b39105d48c3ad1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b03c58a81add39e1415efdadd13aa45baec525d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b03c58a81add39e1415efdadd13aa45baec525d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b03c58a81add39e1415efdadd13aa45baec525d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b03c58a81add39e1415efdadd13aa45baec525d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e8d0d6d2a84f7d957775ce16bfaa365c52114359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8d0d6d2a84f7d957775ce16bfaa365c52114359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8d0d6d2a84f7d957775ce16bfaa365c52114359"}], "stats": {"total": 102, "additions": 58, "deletions": 44}, "files": [{"sha": "40a8e9f1bd589d93e187c2fd7052f248af7b9b5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b03c58a81add39e1415efdadd13aa45baec525d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b03c58a81add39e1415efdadd13aa45baec525d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b03c58a81add39e1415efdadd13aa45baec525d", "patch": "@@ -1,3 +1,12 @@\n+2006-09-14  Richard Guenther  <rguenther@suse.de>\n+\t    Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tPR middle-end/28884.\n+\t* doc/tm.texi (TARGET_FUNCTION_VALUE): Document.\n+\t(FUNCTION_VALUE, FUNCTION_OUTGOING_VALUE): Deprecate.\n+\tReplace mentions of FUNCTION_VALUE and FUNCTION_OUTGOING_VALUE\n+\twith TARGET_FUNCTION_VALUE.\n+\n 2006-09-14  Anatoly Sokolov <aesok@post.ru>\n \n \tPR target/26504"}, {"sha": "d1217f1b0e24c98fd9683ed141ed13214586e40b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b03c58a81add39e1415efdadd13aa45baec525d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b03c58a81add39e1415efdadd13aa45baec525d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=1b03c58a81add39e1415efdadd13aa45baec525d", "patch": "@@ -1015,8 +1015,8 @@ This target hook should return @code{true} if the promotion described by\n @code{PROMOTE_FUNCTION_MODE} should be done for the return value of\n functions.\n \n-If this target hook returns @code{true}, @code{FUNCTION_VALUE} must\n-perform the same promotions done by @code{PROMOTE_FUNCTION_MODE}.\n+If this target hook returns @code{true}, @code{TARGET_FUNCTION_VALUE}\n+must perform the same promotions done by @code{PROMOTE_FUNCTION_MODE}.\n @end deftypefn\n \n @defmac PARM_BOUNDARY\n@@ -4028,51 +4028,54 @@ must have move patterns for this mode.\n This section discusses the macros that control returning scalars as\n values---values that can fit in registers.\n \n-@defmac FUNCTION_VALUE (@var{valtype}, @var{func})\n-A C expression to create an RTX representing the place where a\n-function returns a value of data type @var{valtype}.  @var{valtype} is\n-a tree node representing a data type.  Write @code{TYPE_MODE\n-(@var{valtype})} to get the machine mode used to represent that type.\n-On many machines, only the mode is relevant.  (Actually, on most\n-machines, scalar values are returned in the same place regardless of\n-mode).\n-\n-The value of the expression is usually a @code{reg} RTX for the hard\n-register where the return value is stored.  The value can also be a\n-@code{parallel} RTX, if the return value is in multiple places.  See\n-@code{FUNCTION_ARG} for an explanation of the @code{parallel} form.\n-\n-If @code{TARGET_PROMOTE_FUNCTION_RETURN} returns true, you must apply the same\n-promotion rules specified in @code{PROMOTE_MODE} if @var{valtype} is a\n-scalar type.\n+@deftypefn {Target Hook} rtx TARGET_FUNCTION_VALUE (tree @var{ret_type},\n+tree @var{fn_decl_or_type}, bool @var{outgoing})\n+\n+Define this to return an RTX representing the place where a function\n+returns or receives a value of data type @var{ret_type}, a tree node\n+node representing a data type.  @var{fn_decl_or_type} is a tree node\n+representing @code{FUNCTION_DECL} or @code{FUNCTION_TYPE} of a\n+function being called.  If @var{outgoing} is false, the hook should\n+compute the register in which the caller will see the return value.\n+Otherwise, the hook should return an RTX representing the place where\n+a function returns a value.\n+\n+On many machines, only @code{TYPE_MODE (@var{ret_type})} is relevant.\n+(Actually, on most machines, scalar values are returned in the same\n+place regardless of mode.)  The value of the expression is usually a\n+@code{reg} RTX for the hard register where the return value is stored.\n+The value can also be a @code{parallel} RTX, if the return value is in\n+multiple places.  See @code{FUNCTION_ARG} for an explanation of the\n+@code{parallel} form.\n+\n+If @code{TARGET_PROMOTE_FUNCTION_RETURN} returns true, you must apply\n+the same promotion rules specified in @code{PROMOTE_MODE} if\n+@var{valtype} is a scalar type.\n \n If the precise function being called is known, @var{func} is a tree\n node (@code{FUNCTION_DECL}) for it; otherwise, @var{func} is a null\n pointer.  This makes it possible to use a different value-returning\n convention for specific functions when all their calls are\n known.\n \n-@code{FUNCTION_VALUE} is not used for return vales with aggregate data\n-types, because these are returned in another way.  See\n+Some target machines have ``register windows'' so that the register in\n+which a function returns its value is not the same as the one in which\n+the caller sees the value.  For such machines, you should return\n+different RTX depending on @var{outgoing}.\n+\n+@code{TARGET_FUNCTION_VALUE} is not used for return values with\n+aggregate data types, because these are returned in another way.  See\n @code{TARGET_STRUCT_VALUE_RTX} and related macros, below.\n+@end deftypefn\n+\n+@defmac FUNCTION_VALUE (@var{valtype}, @var{func})\n+This macro has been deprecated.  Use @code{TARGET_FUNCTION_VALUE} for\n+a new target instead.\n @end defmac\n \n @defmac FUNCTION_OUTGOING_VALUE (@var{valtype}, @var{func})\n-Define this macro if the target machine has ``register windows''\n-so that the register in which a function returns its value is not\n-the same as the one in which the caller sees the value.\n-\n-For such machines, @code{FUNCTION_VALUE} computes the register in which\n-the caller will see the value.  @code{FUNCTION_OUTGOING_VALUE} should be\n-defined in a similar fashion to tell the function where to put the\n-value.\n-\n-If @code{FUNCTION_OUTGOING_VALUE} is not defined,\n-@code{FUNCTION_VALUE} serves both purposes.\n-\n-@code{FUNCTION_OUTGOING_VALUE} is not used for return vales with\n-aggregate data types, because these are returned in another way.  See\n-@code{TARGET_STRUCT_VALUE_RTX} and related macros, below.\n+This macro has been deprecated.  Use @code{TARGET_FUNCTION_VALUE} for\n+a new target instead.\n @end defmac\n \n @defmac LIBCALL_VALUE (@var{mode})\n@@ -4123,10 +4126,11 @@ at the most significant end of a register (in other words, if they are\n padded at the least significant end).  You can assume that @var{type}\n is returned in a register; the caller is required to check this.\n \n-Note that the register provided by @code{FUNCTION_VALUE} must be able\n-to hold the complete return value.  For example, if a 1-, 2- or 3-byte\n-structure is returned at the most significant end of a 4-byte register,\n-@code{FUNCTION_VALUE} should provide an @code{SImode} rtx.\n+Note that the register provided by @code{TARGET_FUNCTION_VALUE} must\n+be able to hold the complete return value.  For example, if a 1-, 2-\n+or 3-byte structure is returned at the most significant end of a\n+4-byte register, @code{TARGET_FUNCTION_VALUE} should provide an\n+@code{SImode} rtx.\n @end deftypefn\n \n @node Aggregate Return\n@@ -4137,10 +4141,11 @@ structure is returned at the most significant end of a 4-byte register,\n @cindex structure value address\n \n When a function value's mode is @code{BLKmode} (and in some other\n-cases), the value is not returned according to @code{FUNCTION_VALUE}\n-(@pxref{Scalar Return}).  Instead, the caller passes the address of a\n-block of memory in which the value should be stored.  This address\n-is called the @dfn{structure value address}.\n+cases), the value is not returned according to\n+@code{TARGET_FUNCTION_VALUE} (@pxref{Scalar Return}).  Instead, the\n+caller passes the address of a block of memory in which the value\n+should be stored.  This address is called the @dfn{structure value\n+address}.\n \n This section describes how to control returning structure values in\n memory."}]}