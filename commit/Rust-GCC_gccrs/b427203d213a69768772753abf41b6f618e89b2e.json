{"sha": "b427203d213a69768772753abf41b6f618e89b2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQyNzIwM2QyMTNhNjk3Njg3NzI3NTNhYmY0MWI2ZjYxOGU4OWIyZQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-15T00:47:16Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-15T00:47:16Z"}, "message": "sendmsg.c: Reindented some code and tidied up comments.\n\n2010-12-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* sendmsg.c: Reindented some code and tidied up comments.  No\n\tactual code changes.\n\nFrom-SVN: r167835", "tree": {"sha": "c993e7ea4b0343a2e1e373c5d054089dcfadc622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c993e7ea4b0343a2e1e373c5d054089dcfadc622"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b427203d213a69768772753abf41b6f618e89b2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b427203d213a69768772753abf41b6f618e89b2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b427203d213a69768772753abf41b6f618e89b2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b427203d213a69768772753abf41b6f618e89b2e/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6da9537811bd00e8f3c4bb2d4ea96232f771f73b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da9537811bd00e8f3c4bb2d4ea96232f771f73b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6da9537811bd00e8f3c4bb2d4ea96232f771f73b"}], "stats": {"total": 272, "additions": 139, "deletions": 133}, "files": [{"sha": "7b3495a73aea0f073830538be656bef34c2ced6e", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427203d213a69768772753abf41b6f618e89b2e/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427203d213a69768772753abf41b6f618e89b2e/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=b427203d213a69768772753abf41b6f618e89b2e", "patch": "@@ -1,3 +1,8 @@\n+2010-12-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* sendmsg.c: Reindented some code and tidied up comments.  No\n+\tactual code changes.\n+\t\n 2010-12-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc/Object.h: Moved all the methods, with the exception of"}, {"sha": "48605fc67f81bdc368935daa3627a96dc623558b", "filename": "libobjc/sendmsg.c", "status": "modified", "additions": 134, "deletions": 133, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b427203d213a69768772753abf41b6f618e89b2e/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b427203d213a69768772753abf41b6f618e89b2e/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=b427203d213a69768772753abf41b6f618e89b2e", "patch": "@@ -60,32 +60,30 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define INVISIBLE_STRUCT_RETURN 0\n #endif\n \n-/* The uninstalled dispatch table */\n+/* The uninstalled dispatch table.  */\n struct sarray *__objc_uninstalled_dtable = 0;   /* !T:MUTEX */\n \n-/* Two hooks for method forwarding. If either is set, it is invoked\n- * to return a function that performs the real forwarding.  If both\n- * are set, the result of __objc_msg_forward2 will be preferred over\n- * that of __objc_msg_forward.  If both return NULL or are unset,\n- * the libgcc based functions (__builtin_apply and friends) are\n- * used.\n- */\n+/* Two hooks for method forwarding. If either is set, it is invoked to\n+ * return a function that performs the real forwarding.  If both are\n+ * set, the result of __objc_msg_forward2 will be preferred over that\n+ * of __objc_msg_forward.  If both return NULL or are unset, the\n+ * libgcc based functions (__builtin_apply and friends) are used.  */\n IMP (*__objc_msg_forward) (SEL) = NULL;\n IMP (*__objc_msg_forward2) (id, SEL) = NULL;\n \n-/* Send +initialize to class */\n+/* Send +initialize to class.  */\n static void __objc_send_initialize (Class);\n \n static void __objc_install_dispatch_table_for_class (Class);\n \n-/* Forward declare some functions */\n+/* Forward declare some functions.  */\n static void __objc_init_install_dtable (id, SEL);\n \n /* Various forwarding functions that are used based upon the\n    return type for the selector.\n    __objc_block_forward for structures.\n    __objc_double_forward for floats/doubles.\n-   __objc_word_forward for pointers or types that fit in registers. */\n+   __objc_word_forward for pointers or types that fit in registers.  */\n static double __objc_double_forward (id, SEL, ...);\n static id __objc_word_forward (id, SEL, ...);\n typedef struct { id many[8]; } __big;\n@@ -99,14 +97,15 @@ static struct objc_method * search_for_method_in_hierarchy (Class class, SEL sel\n struct objc_method * search_for_method_in_list (struct objc_method_list * list, SEL op);\n id nil_method (id, SEL);\n \n-/* Given a selector, return the proper forwarding implementation. */\n+/* Given a selector, return the proper forwarding implementation.  */\n inline\n IMP\n __objc_get_forward_imp (id rcv, SEL sel)\n {\n-  /* If a custom forwarding hook was registered, try getting a forwarding\n-     function from it. There are two forward routine hooks, one that\n-     takes the receiver as an argument and one that does not. */\n+  /* If a custom forwarding hook was registered, try getting a\n+     forwarding function from it. There are two forward routine hooks,\n+     one that takes the receiver as an argument and one that does\n+     not.  */\n   if (__objc_msg_forward2)\n     {\n       IMP result;\n@@ -120,11 +119,11 @@ __objc_get_forward_imp (id rcv, SEL sel)\n         return result;\n     }\n \n-  /* In all other cases, use the default forwarding functions built using\n-     __builtin_apply and friends.  */\n+  /* In all other cases, use the default forwarding functions built\n+     using __builtin_apply and friends.  */\n     {\n       const char *t = sel->sel_types;\n-\n+      \n       if (t && (*t == '[' || *t == '(' || *t == '{')\n #ifdef OBJC_MAX_STRUCT_BY_VALUE\n           && objc_sizeof_type (t) > OBJC_MAX_STRUCT_BY_VALUE\n@@ -234,7 +233,8 @@ __objc_resolve_instance_method (Class class, SEL sel)\n /* Temporary definition until we include objc/runtime.h.  */\n objc_EXPORT Class objc_lookupClass (const char *name);\n \n-/* Given a class and selector, return the selector's implementation.  */\n+/* Given a class and selector, return the selector's\n+   implementation.  */\n inline\n IMP\n get_imp (Class class, SEL sel)\n@@ -250,10 +250,10 @@ get_imp (Class class, SEL sel)\n   void *res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n   if (res == 0)\n     {\n-      /* Not a valid method */\n+      /* Not a valid method.  */\n       if (class->dtable == __objc_uninstalled_dtable)\n \t{\n-\t  /* The dispatch table needs to be installed. */\n+\t  /* The dispatch table needs to be installed.  */\n \t  objc_mutex_lock (__objc_runtime_mutex);\n \n \t   /* Double-checked locking pattern: Check\n@@ -266,8 +266,8 @@ get_imp (Class class, SEL sel)\n            }\n \n \t  objc_mutex_unlock (__objc_runtime_mutex);\n-\t  /* Call ourselves with the installed dispatch table\n-\t     and get the real method */\n+\t  /* Call ourselves with the installed dispatch table and get\n+\t     the real method.  */\n \t  res = get_imp (class, sel);\n \t}\n       else\n@@ -277,8 +277,7 @@ get_imp (Class class, SEL sel)\n          /* Get the method from the dispatch table (we try to get it\n \t    again in case another thread has installed the dtable just\n \t    after we invoked sarray_get_safe, but before we checked\n-\t    class->dtable == __objc_uninstalled_dtable).\n-         */\n+\t    class->dtable == __objc_uninstalled_dtable).  */\n \t  res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n \t  if (res == 0)\n \t    {\n@@ -305,12 +304,12 @@ get_imp (Class class, SEL sel)\n \t      if (res == 0)\n \t\t{\n \t\t  /* If that fails, then return the forwarding\n-\t\t     implementation.  We don't know the receiver (only its\n-\t\t     class), so we have to pass 'nil' as the first\n+\t\t     implementation.  We don't know the receiver (only\n+\t\t     its class), so we have to pass 'nil' as the first\n \t\t     argument.  Passing the class as first argument is\n-\t\t     wrong because the class is not the receiver; it can\n-\t\t     result in us calling a class method when we want an\n-\t\t     instance method of the same name.  */\n+\t\t     wrong because the class is not the receiver; it\n+\t\t     can result in us calling a class method when we\n+\t\t     want an instance method of the same name.  */\n \t\t  res = __objc_get_forward_imp (nil, sel);\n \t\t}\n \t    }\n@@ -338,15 +337,15 @@ method_get_imp (struct objc_method * method)\n }\n \n /* Query if an object can respond to a selector, returns YES if the\n-object implements the selector otherwise NO.  Does not check if the\n-method can be forwarded. */\n+   object implements the selector otherwise NO.  Does not check if the\n+   method can be forwarded.  */\n inline\n BOOL\n __objc_responds_to (id object, SEL sel)\n {\n   void *res;\n \n-  /* Install dispatch table if need be */\n+  /* Install dispatch table if need be.  */\n   if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n     {\n       objc_mutex_lock (__objc_runtime_mutex);\n@@ -357,7 +356,7 @@ __objc_responds_to (id object, SEL sel)\n       objc_mutex_unlock (__objc_runtime_mutex);\n     }\n \n-  /* Get the method from the dispatch table */\n+  /* Get the method from the dispatch table.  */\n   res = sarray_get_safe (object->class_pointer->dtable, (size_t) sel->sel_id);\n   return (res != 0);\n }\n@@ -370,7 +369,7 @@ class_respondsToSelector (Class class_, SEL selector)\n   if (class_ == Nil  ||  selector == NULL)\n     return NO;\n \n-  /* Install dispatch table if need be */\n+  /* Install dispatch table if need be.  */\n   if (class_->dtable == __objc_uninstalled_dtable)\n     {\n       objc_mutex_lock (__objc_runtime_mutex);\n@@ -381,15 +380,15 @@ class_respondsToSelector (Class class_, SEL selector)\n       objc_mutex_unlock (__objc_runtime_mutex);\n     }\n \n-  /* Get the method from the dispatch table */\n+  /* Get the method from the dispatch table.  */\n   res = sarray_get_safe (class_->dtable, (size_t) selector->sel_id);\n   return (res != 0);\n }\n \n-/* This is the lookup function.  All entries in the table are either a \n+/* This is the lookup function.  All entries in the table are either a\n    valid method *or* zero.  If zero then either the dispatch table\n-   needs to be installed or it doesn't exist and forwarding is attempted. */\n-\n+   needs to be installed or it doesn't exist and forwarding is\n+   attempted.  */\n IMP\n objc_msg_lookup (id receiver, SEL op)\n {\n@@ -400,23 +399,24 @@ objc_msg_lookup (id receiver, SEL op)\n \t\t\t\t(sidx)op->sel_id);\n       if (result == 0)\n \t{\n-\t  /* Not a valid method */\n+\t  /* Not a valid method.  */\n \t  if (receiver->class_pointer->dtable == __objc_uninstalled_dtable)\n \t    {\n-\t      /* The dispatch table needs to be installed.\n-\t\t This happens on the very first method call to the class. */\n+\t      /* The dispatch table needs to be installed.  This\n+\t\t happens on the very first method call to the\n+\t\t class.  */\n \t      __objc_init_install_dtable (receiver, op);\n \n-\t      /* Get real method for this in newly installed dtable */\n+\t      /* Get real method for this in newly installed\n+\t\t dtable.  */\n \t      result = get_imp (receiver->class_pointer, op);\n \t    }\n \t  else\n \t    {\n \t      /* The dispatch table has been installed.  Check again\n \t\t if the method exists (just in case the dispatch table\n \t\t has been installed by another thread after we did the\n-\t\t previous check that the method exists).\n-\t      */\n+\t\t previous check that the method exists).  */\n \t      result = sarray_get_safe (receiver->class_pointer->dtable,\n \t\t\t\t\t(sidx)op->sel_id);\n \t      if (result == 0)\n@@ -432,7 +432,7 @@ objc_msg_lookup (id receiver, SEL op)\n \t\t  if (result == 0)\n \t\t    {\n \t\t      /* If the method still just doesn't exist for\n-\t\t\t the class, attempt to forward the method. */\n+\t\t\t the class, attempt to forward the method.  */\n \t\t      result = __objc_get_forward_imp (receiver, op);\n \t\t    }\n \t\t}\n@@ -477,16 +477,16 @@ __objc_init_dispatch_tables ()\n   selector_resolveInstanceMethod  =sel_register_name (\"resolveInstanceMethod:\");\n }\n \n-/* This function is called by objc_msg_lookup when the\n-   dispatch table needs to be installed; thus it is called once\n-   for each class, namely when the very first message is sent to it. */\n+/* This function is called by objc_msg_lookup when the dispatch table\n+   needs to be installed; thus it is called once for each class,\n+   namely when the very first message is sent to it.  */\n static void\n __objc_init_install_dtable (id receiver, SEL op __attribute__ ((__unused__)))\n {\n   objc_mutex_lock (__objc_runtime_mutex);\n   \n-  /* This may happen, if the programmer has taken the address of a \n-     method before the dtable was initialized... too bad for him! */\n+  /* This may happen, if the programmer has taken the address of a\n+     method before the dtable was initialized... too bad for him!  */\n   if (receiver->class_pointer->dtable != __objc_uninstalled_dtable)\n     {\n       objc_mutex_unlock (__objc_runtime_mutex);\n@@ -495,23 +495,23 @@ __objc_init_install_dtable (id receiver, SEL op __attribute__ ((__unused__)))\n   \n   if (CLS_ISCLASS (receiver->class_pointer))\n     {\n-      /* receiver is an ordinary object */\n+      /* receiver is an ordinary object.  */\n       assert (CLS_ISCLASS (receiver->class_pointer));\n \n-      /* install instance methods table */\n+      /* Install instance methods table.  */\n       __objc_install_dispatch_table_for_class (receiver->class_pointer);\n \n-      /* call +initialize -- this will in turn install the factory \n-\t dispatch table if not already done :-) */\n+      /* Call +initialize -- this will in turn install the factory\n+\t dispatch table if not already done. :-)  */\n       __objc_send_initialize (receiver->class_pointer);\n     }\n   else\n     {\n-      /* receiver is a class object */\n+      /* receiver is a class object.  */\n       assert (CLS_ISCLASS ((Class)receiver));\n       assert (CLS_ISMETA (receiver->class_pointer));\n \n-      /* Install real dtable for factory methods */\n+      /* Install real dtable for factory methods.  */\n       __objc_install_dispatch_table_for_class (receiver->class_pointer);\n \n       __objc_send_initialize ((Class)receiver);\n@@ -520,19 +520,19 @@ __objc_init_install_dtable (id receiver, SEL op __attribute__ ((__unused__)))\n }\n \n /* Install dummy table for class which causes the first message to\n-   that class (or instances hereof) to be initialized properly */\n+   that class (or instances hereof) to be initialized properly.  */\n void\n __objc_install_premature_dtable (Class class)\n {\n   assert (__objc_uninstalled_dtable);\n   class->dtable = __objc_uninstalled_dtable;\n }   \n \n-/* Send +initialize to class if not already done */\n+/* Send +initialize to class if not already done.  */\n static void\n __objc_send_initialize (Class class)\n {\n-  /* This *must* be a class object */\n+  /* This *must* be a class object.  */\n   assert (CLS_ISCLASS (class));\n   assert (! CLS_ISMETA (class));\n \n@@ -541,60 +541,62 @@ __objc_send_initialize (Class class)\n       CLS_SETINITIALIZED (class);\n       CLS_SETINITIALIZED (class->class_pointer);\n \n-      /* Create the garbage collector type memory description */\n+      /* Create the garbage collector type memory description.  */\n       __objc_generate_gc_type_description (class);\n \n       if (class->super_class)\n \t__objc_send_initialize (class->super_class);\n \n       {\n-\tSEL \t     op = sel_register_name (\"initialize\");\n-\tIMP\t     imp = 0;\n+\tSEL op = sel_register_name (\"initialize\");\n+\tIMP imp = 0;\n         struct objc_method_list * method_list = class->class_pointer->methods;\n-\n-        while (method_list) {\n-\t  int i;\n-          struct objc_method * method;\n-\n-          for (i = 0; i < method_list->method_count; i++) {\n-\t    method = &(method_list->method_list[i]);\n-            if (method->method_name\n-                && method->method_name->sel_id == op->sel_id) {\n-\t      imp = method->method_imp;\n-              break;\n-            }\n-          }\n-\n-          if (imp)\n-            break;\n-\n-          method_list = method_list->method_next;\n-\n-\t}\n+\t\n+        while (method_list)\n+\t  {\n+\t    int i;\n+\t    struct objc_method * method;\n+\t    \n+\t    for (i = 0; i < method_list->method_count; i++)\n+\t      {\n+\t\tmethod = &(method_list->method_list[i]);\n+\t\tif (method->method_name\n+\t\t    && method->method_name->sel_id == op->sel_id)\n+\t\t  {\n+\t\t    imp = method->method_imp;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    \n+\t    if (imp)\n+\t      break;\n+\t    \n+\t    method_list = method_list->method_next;\n+\t  }\n \tif (imp)\n-\t    (*imp) ((id) class, op);\n-\t\t\n+\t  (*imp) ((id) class, op);\n       }\n     }\n }\n \n-/* Walk on the methods list of class and install the methods in the reverse\n-   order of the lists. Since methods added by categories are before the methods\n-   of class in the methods list, this allows categories to substitute methods\n-   declared in class. However if more than one category replaces the same\n-   method nothing is guaranteed about what method will be used.\n-   Assumes that __objc_runtime_mutex is locked down. */\n+/* Walk on the methods list of class and install the methods in the\n+   reverse order of the lists.  Since methods added by categories are\n+   before the methods of class in the methods list, this allows\n+   categories to substitute methods declared in class.  However if\n+   more than one category replaces the same method nothing is\n+   guaranteed about what method will be used.  Assumes that\n+   __objc_runtime_mutex is locked down.  */\n static void\n __objc_install_methods_in_dtable (Class class, struct objc_method_list * method_list)\n {\n   int i;\n-\n+  \n   if (! method_list)\n     return;\n-\n+  \n   if (method_list->method_next)\n     __objc_install_methods_in_dtable (class, method_list->method_next);\n-\n+  \n   for (i = 0; i < method_list->method_count; i++)\n     {\n       struct objc_method * method = &(method_list->method_list[i]);\n@@ -604,23 +606,23 @@ __objc_install_methods_in_dtable (Class class, struct objc_method_list * method_\n     }\n }\n \n-/* Assumes that __objc_runtime_mutex is locked down. */\n+/* Assumes that __objc_runtime_mutex is locked down.  */\n static void\n __objc_install_dispatch_table_for_class (Class class)\n {\n   Class super;\n \n-  /* If the class has not yet had its class links resolved, we must \n-     re-compute all class links */\n+  /* If the class has not yet had its class links resolved, we must\n+     re-compute all class links.  */\n   if (! CLS_ISRESOLV (class))\n     __objc_resolve_class_links ();\n-\n+  \n   super = class->super_class;\n \n   if (super != 0 && (super->dtable == __objc_uninstalled_dtable))\n     __objc_install_dispatch_table_for_class (super);\n \n-  /* Allocate dtable if necessary */\n+  /* Allocate dtable if necessary.  */\n   if (super == 0)\n     {\n       objc_mutex_lock (__objc_runtime_mutex);\n@@ -639,7 +641,7 @@ __objc_update_dispatch_table_for_class (Class class)\n   Class next;\n   struct sarray *arr;\n \n-  /* not yet installed -- skip it */\n+  /* Not yet installed -- skip it.  */\n   if (class->dtable == __objc_uninstalled_dtable) \n     return;\n \n@@ -648,25 +650,24 @@ __objc_update_dispatch_table_for_class (Class class)\n   arr = class->dtable;\n   __objc_install_premature_dtable (class); /* someone might require it... */\n   sarray_free (arr);\t\t\t   /* release memory */\n-\n-  /* could have been lazy... */\n+  \n+  /* Could have been lazy...  */\n   __objc_install_dispatch_table_for_class (class); \n \n-  if (class->subclass_list)\t/* Traverse subclasses */\n+  if (class->subclass_list)\t/* Traverse subclasses.  */\n     for (next = class->subclass_list; next; next = next->sibling_class)\n       __objc_update_dispatch_table_for_class (next);\n \n   objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n-\n /* This function adds a method list to a class.  This function is\n    typically called by another function specific to the run-time.  As\n    such this function does not worry about thread safe issues.\n \n    This one is only called for categories. Class objects have their\n    methods installed right away, and their selectors are made into\n-   SEL's by the function __objc_register_selectors_from_class. */\n+   SEL's by the function __objc_register_selectors_from_class.  */\n void\n class_add_method_list (Class class, struct objc_method_list * list)\n {\n@@ -679,7 +680,7 @@ class_add_method_list (Class class, struct objc_method_list * list)\n   list->method_next = class->methods;\n   class->methods = list;\n \n-  /* Update the dispatch table of class */\n+  /* Update the dispatch table of class.  */\n   __objc_update_dispatch_table_for_class (class);\n }\n \n@@ -707,8 +708,8 @@ class_getInstanceMethod (Class class_, SEL selector)\n   if (m)\n     return m;\n \n-  /* Try going through +resolveInstanceMethod:, and do\n-     the search again if successful.  */\n+  /* Try going through +resolveInstanceMethod:, and do the search\n+     again if successful.  */\n   if (__objc_resolve_instance_method (class_, selector))\n     return search_for_method_in_hierarchy (class_, selector);\n \n@@ -811,9 +812,9 @@ class_replaceMethod (Class class_, SEL selector, IMP implementation,\n     }\n }\n \n-/* Search for a method starting from the current class up its hierarchy.\n-   Return a pointer to the method's method structure if found.  NULL\n-   otherwise. */   \n+/* Search for a method starting from the current class up its\n+   hierarchy.  Return a pointer to the method's method structure if\n+   found.  NULL otherwise.  */\n static struct objc_method *\n search_for_method_in_hierarchy (Class cls, SEL sel)\n {\n@@ -823,8 +824,8 @@ search_for_method_in_hierarchy (Class cls, SEL sel)\n   if (! sel_is_mapped (sel))\n     return NULL;\n \n-  /* Scan the method list of the class.  If the method isn't found in the\n-     list then step to its super class. */\n+  /* Scan the method list of the class.  If the method isn't found in\n+     the list then step to its super class.  */\n   for (class = cls; ((! method) && class); class = class->super_class)\n     method = search_for_method_in_list (class->methods, sel);\n \n@@ -833,9 +834,9 @@ search_for_method_in_hierarchy (Class cls, SEL sel)\n \n \n \n-/* Given a linked list of method and a method's name.  Search for the named\n-   method's method structure.  Return a pointer to the method's method\n-   structure if found.  NULL otherwise. */  \n+/* Given a linked list of method and a method's name.  Search for the\n+   named method's method structure.  Return a pointer to the method's\n+   method structure if found.  NULL otherwise.  */  \n struct objc_method *\n search_for_method_in_list (struct objc_method_list * list, SEL op)\n {\n@@ -869,7 +870,7 @@ search_for_method_in_list (struct objc_method_list * list, SEL op)\n \n static retval_t __objc_forward (id object, SEL sel, arglist_t args);\n \n-/* Forwarding pointers/integers through the normal registers */\n+/* Forwarding pointers/integers through the normal registers.  */\n static id\n __objc_word_forward (id rcv, SEL op, ...)\n {\n@@ -884,10 +885,10 @@ __objc_word_forward (id rcv, SEL op, ...)\n }\n \n /* Specific routine for forwarding floats/double because of\n-   architectural differences on some processors.  i386s for\n-   example which uses a floating point stack versus general\n-   registers for floating point numbers.  This forward routine \n-   makes sure that GCC restores the proper return values */\n+   architectural differences on some processors.  i386s for example\n+   which uses a floating point stack versus general registers for\n+   floating point numbers.  This forward routine makes sure that GCC\n+   restores the proper return values.  */\n static double\n __objc_double_forward (id rcv, SEL op, ...)\n {\n@@ -920,16 +921,17 @@ __objc_block_forward (id rcv, SEL op, ...)\n }\n \n \n-/* This function is installed in the dispatch table for all methods which are\n-   not implemented.  Thus, it is called when a selector is not recognized. */\n+/* This function is installed in the dispatch table for all methods\n+   which are not implemented.  Thus, it is called when a selector is\n+   not recognized.  */\n static retval_t\n __objc_forward (id object, SEL sel, arglist_t args)\n {\n   IMP imp;\n   static SEL frwd_sel = 0;                      /* !T:SAFE2 */\n   SEL err_sel;\n \n-  /* first try if the object understands forward:: */\n+  /* First try if the object understands forward::.  */\n   if (! frwd_sel)\n     frwd_sel = sel_get_any_uid (\"forward::\");\n \n@@ -939,8 +941,8 @@ __objc_forward (id object, SEL sel, arglist_t args)\n       return (*imp) (object, frwd_sel, sel, args);\n     }\n \n-  /* If the object recognizes the doesNotRecognize: method then we're going\n-     to send it. */\n+  /* If the object recognizes the doesNotRecognize: method then we're\n+     going to send it.  */\n   err_sel = sel_get_any_uid (\"doesNotRecognize:\");\n   if (__objc_responds_to (object, err_sel))\n     {\n@@ -949,7 +951,7 @@ __objc_forward (id object, SEL sel, arglist_t args)\n     }\n   \n   /* The object doesn't recognize the method.  Check for responding to\n-     error:.  If it does then sent it. */\n+     error:.  If it does then sent it.  */\n   {\n     char msg[256 + strlen ((const char *) sel_get_name (sel))\n              + strlen ((const char *) object->class_pointer->name)];\n@@ -968,8 +970,8 @@ __objc_forward (id object, SEL sel, arglist_t args)\n \treturn (*imp) (object, sel_get_any_uid (\"error:\"), msg);\n       }\n \n-    /* The object doesn't respond to doesNotRecognize: or error:;  Therefore,\n-       a default action is taken. */\n+    /* The object doesn't respond to doesNotRecognize: or error:;\n+       Therefore, a default action is taken.  */\n     _objc_abort (\"%s\\n\", msg);\n \n     return 0;\n@@ -1006,10 +1008,9 @@ __objc_print_dtable_stats ()\n   objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n-/* Returns the uninstalled dispatch table indicator.\n- If a class' dispatch table points to __objc_uninstalled_dtable\n- then that means it needs its dispatch table to be installed. */\n-\n+/* Returns the uninstalled dispatch table indicator.  If a class'\n+   dispatch table points to __objc_uninstalled_dtable then that means\n+   it needs its dispatch table to be installed.  */\n struct sarray *\n objc_get_uninstalled_dtable ()\n {"}]}