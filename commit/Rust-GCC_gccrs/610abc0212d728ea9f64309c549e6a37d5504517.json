{"sha": "610abc0212d728ea9f64309c549e6a37d5504517", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEwYWJjMDIxMmQ3MjhlYTlmNjQzMDljNTQ5ZTZhMzdkNTUwNDUxNw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-05-24T18:44:35Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-05-24T18:44:35Z"}, "message": "re PR fortran/66094 (Handle transpose(A) in inline matmul)\n\n2017-05-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/66094\n\t* frontend-passes.c (matrix_case):  Add A2TB2.\n\t(inline_limit_check):  Handle MATMUL(TRANSPOSE(A),B)\n\t(inline_matmul_assign):  Likewise.\n\n2017-05-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/66094\n\t* gfortran.dg/inline_matmul_16.f90:  New test.\n\nFrom-SVN: r248425", "tree": {"sha": "f35dba681ec97df4995a06b263cd9d09f436cad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f35dba681ec97df4995a06b263cd9d09f436cad3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/610abc0212d728ea9f64309c549e6a37d5504517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610abc0212d728ea9f64309c549e6a37d5504517", "html_url": "https://github.com/Rust-GCC/gccrs/commit/610abc0212d728ea9f64309c549e6a37d5504517", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/610abc0212d728ea9f64309c549e6a37d5504517/comments", "author": null, "committer": null, "parents": [{"sha": "1a2fa2f821eec4395ff8869232d0e4e49afbe64b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a2fa2f821eec4395ff8869232d0e4e49afbe64b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a2fa2f821eec4395ff8869232d0e4e49afbe64b"}], "stats": {"total": 192, "additions": 176, "deletions": 16}, "files": [{"sha": "760cbe2f4afe5ed6ff678411c732cf14c4a61fb3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610abc0212d728ea9f64309c549e6a37d5504517/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610abc0212d728ea9f64309c549e6a37d5504517/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=610abc0212d728ea9f64309c549e6a37d5504517", "patch": "@@ -1,3 +1,10 @@\n+2017-05-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/66094\n+\t* frontend-passes.c (matrix_case):  Add A2TB2.\n+\t(inline_limit_check):  Handle MATMUL(TRANSPOSE(A),B)\n+\t(inline_matmul_assign):  Likewise.\n+\n 2017-05-23  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* openmp.c (OACC_KERNELS_CLAUSES): Add \"OMP_CLAUSE_NUM_GANGS\","}, {"sha": "1ea5b5403ce0523b56a85e1dd54a11d826f42efb", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 103, "deletions": 16, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610abc0212d728ea9f64309c549e6a37d5504517/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610abc0212d728ea9f64309c549e6a37d5504517/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=610abc0212d728ea9f64309c549e6a37d5504517", "patch": "@@ -112,7 +112,7 @@ static int var_num = 1;\n \n /* What sort of matrix we are dealing with when inlining MATMUL.  */\n \n-enum matrix_case { none=0, A2B2, A2B1, A1B2, A2B2T };\n+enum matrix_case { none=0, A2B2, A2B1, A1B2, A2B2T, A2TB2 };\n \n /* Keep track of the number of expressions we have inserted so far\n    using create_var.  */\n@@ -2252,7 +2252,7 @@ inline_limit_check (gfc_expr *a, gfc_expr *b, enum matrix_case m_case)\n   gfc_typespec ts;\n   gfc_expr *cond;\n \n-  gcc_assert (m_case == A2B2 || m_case == A2B2T);\n+  gcc_assert (m_case == A2B2 || m_case == A2B2T || m_case == A2TB2);\n \n   /* Calculation is done in real to avoid integer overflow.  */\n \n@@ -2425,6 +2425,20 @@ matmul_lhs_realloc (gfc_expr *c, gfc_expr *a, gfc_expr *b,\n       cond = build_logical_expr (INTRINSIC_OR, ne1, ne2);\n       break;\n \n+    case A2TB2:\n+\n+      ar->start[0] = get_array_inq_function (GFC_ISYM_SIZE, a, 2);\n+      ar->start[1] = get_array_inq_function (GFC_ISYM_SIZE, b, 2);\n+\n+      ne1 = build_logical_expr (INTRINSIC_NE,\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, c, 1),\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, a, 2));\n+      ne2 = build_logical_expr (INTRINSIC_NE,\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, c, 2),\n+\t\t\t\tget_array_inq_function (GFC_ISYM_SIZE, b, 2));\n+      cond = build_logical_expr (INTRINSIC_OR, ne1, ne2);\n+      break;\n+\n     case A2B1:\n       ar->start[0] = get_array_inq_function (GFC_ISYM_SIZE, a, 1);\n       cond = build_logical_expr (INTRINSIC_NE,\n@@ -3009,7 +3023,7 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n \n   a = expr2->value.function.actual;\n   matrix_a = check_conjg_transpose_variable (a->expr, &conjg_a, &transpose_a);\n-  if (transpose_a || matrix_a == NULL)\n+  if (matrix_a == NULL)\n     return 0;\n \n   b = a->next;\n@@ -3026,27 +3040,36 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n       || gfc_check_dependency (expr1, matrix_b, true))\n     return 0;\n \n+  m_case = none;\n   if (matrix_a->rank == 2)\n     {\n-      if (matrix_b->rank == 1)\n-\tm_case = A2B1;\n+      if (transpose_a)\n+\t{\n+\t  if (matrix_b->rank == 2 && !transpose_b)\n+\t    m_case = A2TB2;\n+\t}\n       else\n \t{\n-\t  if (transpose_b)\n-\t    m_case = A2B2T;\n-\t  else\n-\t    m_case = A2B2;\n+\t  if (matrix_b->rank == 1)\n+\t    m_case = A2B1;\n+\t  else /* matrix_b->rank == 2 */\n+\t    {\n+\t      if (transpose_b)\n+\t\tm_case = A2B2T;\n+\t      else\n+\t\tm_case = A2B2;\n+\t    }\n \t}\n     }\n-  else\n+  else /* matrix_a->rank == 1 */\n     {\n-      /* Vector * Transpose(B) not handled yet.  */\n-      if (transpose_b)\n-\tm_case = none;\n-      else\n-\tm_case = A1B2;\n+      if (matrix_b->rank == 2)\n+\t{\n+\t  if (!transpose_b)\n+\t    m_case = A1B2;\n+\t}\n     }\n-\n+    \n   if (m_case == none)\n     return 0;\n \n@@ -3250,6 +3273,37 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n \t  next_code_point = &test->next;\n \n \t}\n+\n+      if (m_case == A2TB2)\n+\t{\n+\t  c1 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 1);\n+\t  a2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 2);\n+\n+\t  test = runtime_error_ne (c1, a2, \"Incorrect extent in return array in \"\n+\t\t\t\t   \"MATMUL intrinsic for dimension 1: \"\n+\t\t\t\t   \"is %ld, should be %ld\");\n+\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t  c2 = get_array_inq_function (GFC_ISYM_SIZE, expr1, 2);\n+\t  b2 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 2);\n+\t  test = runtime_error_ne (c2, b2, \"Incorrect extent in return array in \"\n+\t\t\t\t   \"MATMUL intrinsic for dimension 2: \"\n+\t\t\t\t   \"is %ld, should be %ld\");\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t  a1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_a, 1);\n+\t  b1 = get_array_inq_function (GFC_ISYM_SIZE, matrix_b, 1);\n+\n+\t  test = runtime_error_ne (b1, a1, \"Incorrect extent in argument B in \"\n+\t\t\t\t   \"MATMUL intrnisic for dimension 2: \"\n+\t\t\t\t   \"is %ld, should be %ld\");\n+\t  *next_code_point = test;\n+\t  next_code_point = &test->next;\n+\n+\t}\n     }\n \n   *next_code_point = assign_zero;\n@@ -3331,6 +3385,39 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n \n       break;\n \n+    case A2TB2:\n+      inline_limit_check (matrix_a, matrix_b, m_case);\n+\n+      u1 = get_size_m1 (matrix_a, 2);\n+      u2 = get_size_m1 (matrix_b, 2);\n+      u3 = get_size_m1 (matrix_a, 1);\n+\n+      do_1 = create_do_loop (gfc_copy_expr (zero), u1, NULL, &co->loc, ns);\n+      do_2 = create_do_loop (gfc_copy_expr (zero), u2, NULL, &co->loc, ns);\n+      do_3 = create_do_loop (gfc_copy_expr (zero), u3, NULL, &co->loc, ns);\n+\n+      do_1->block->next = do_2;\n+      do_2->block->next = do_3;\n+      do_3->block->next = assign_matmul;\n+\n+      var_1 = do_1->ext.iterator->var;\n+      var_2 = do_2->ext.iterator->var;\n+      var_3 = do_3->ext.iterator->var;\n+\n+      list[0] = var_1;\n+      list[1] = var_2;\n+      cscalar = scalarized_expr (co->expr1, list, 2);\n+\n+      list[0] = var_3;\n+      list[1] = var_1;\n+      ascalar = scalarized_expr (matrix_a, list, 2);\n+\n+      list[0] = var_3;\n+      list[1] = var_2;\n+      bscalar = scalarized_expr (matrix_b, list, 2);\n+\n+      break;\n+\n     case A2B1:\n       u1 = get_size_m1 (matrix_b, 1);\n       u2 = get_size_m1 (matrix_a, 1);"}, {"sha": "b6f824b21fafb0136514a6341f903d6c5c75e575", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610abc0212d728ea9f64309c549e6a37d5504517/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610abc0212d728ea9f64309c549e6a37d5504517/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=610abc0212d728ea9f64309c549e6a37d5504517", "patch": "@@ -1,3 +1,8 @@\n+2017-05-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/66094\n+\t* gfortran.dg/inline_matmul_16.f90:  New test.\n+\n 2017-05-24  Tom de Vries  <tom@codesourcery.com>\n \n \t* gcc.dg/cpp/19940712-1.c: Reinstate absolute line number."}, {"sha": "37dc5ef0ba3fe8f923434e1aba1eb77deb3d6719", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_16.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/610abc0212d728ea9f64309c549e6a37d5504517/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/610abc0212d728ea9f64309c549e6a37d5504517/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_16.f90?ref=610abc0212d728ea9f64309c549e6a37d5504517", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+! { dg-options \"-ffrontend-optimize -fdump-tree-optimized -Wrealloc-lhs -finline-matmul-limit=1000 -O\" }\n+! PR 66094: Check functionality for MATMUL(TRANSPOSE(A),B)) for two-dimensional arrays\n+program main\n+  implicit none\n+  integer, parameter :: n = 3, m=4, cnt=2\n+  real, dimension(cnt,n) :: a\n+  real, dimension(cnt,m) :: b\n+  real, dimension(n,m) :: c, cres\n+  real, dimension(:,:), allocatable :: calloc\n+  integer :: in, im, icnt\n+\n+  data a / 2., -3., 5., -7., 11., -13./\n+  data b /17., -23., 29., -31., 37., -39., 41., -47./\n+  data cres /103.,  246.,  486.,  151.,  362.,  722., &\n+             191.,  458.,  914.,  223.,  534., 1062./\n+\n+  c = matmul(transpose(a),b)\n+  if (sum(c-cres)>1e-4) call abort\n+  if (sum(c-cres)>1e-4) call abort\n+\n+  ! Unallocated\n+  calloc = matmul(transpose(a),b) ! { dg-warning \"Code for reallocating the allocatable array\" }\n+  if (any(shape(c) /= shape(calloc))) call abort\n+  if (sum(calloc-cres)>1e-4) call abort\n+  deallocate(calloc)\n+\n+  ! Allocated to wrong shape\n+  allocate (calloc(10,10))\n+  calloc = matmul(transpose(a),b) ! { dg-warning \"Code for reallocating the allocatable array\" }\n+  if (any(shape(c) /= shape(calloc))) call abort\n+  if (sum(calloc-cres)>1e-4) call abort\n+  deallocate(calloc)\n+\n+  ! cycle through a few test cases...\n+  do in=2,10 \n+     do im = 2,10\n+        do icnt = 2,10\n+           block\n+             real, dimension(icnt,in) :: a2\n+             real, dimension(icnt,im) :: b2\n+             real, dimension(in,im) :: c2,cr\n+             integer :: i,j,k\n+             call random_number(a2)\n+             call random_number(b2)\n+             c2 = 0\n+             do i=1,size(a2,2)\n+                do j=1, size(b2,2)\n+                   do k=1, size(a2,1)\n+                      c2(i,j) = c2(i,j) + a2(k,i) * b2(k,j)\n+                   end do\n+                end do\n+             end do\n+             cr = matmul(transpose(a2), b2)\n+             if (any(abs(c2-cr) > 1e-4)) call abort\n+           end block\n+        end do\n+     end do\n+  end do\n+end program main\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"optimized\" } }"}]}