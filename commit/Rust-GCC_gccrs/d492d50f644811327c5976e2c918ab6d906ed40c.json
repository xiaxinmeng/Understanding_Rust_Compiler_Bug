{"sha": "d492d50f644811327c5976e2c918ab6d906ed40c", "node_id": "C_kwDOANBUbNoAKGQ0OTJkNTBmNjQ0ODExMzI3YzU5NzZlMmM5MThhYjZkOTA2ZWQ0MGM", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-12-05T09:13:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-12-05T13:55:44Z"}, "message": "tree-optimization/106868 - bogus -Wdangling-pointer diagnostic\n\nThe testcase shows we mishandle the case where there's a pass-through\nof a pointer through a function like memcpy.  The following adjusts\nhandling of this copy case to require a taken address and adjust\nthe PHI case similarly.\n\n\tPR tree-optimization/106868\n\t* gimple-ssa-warn-access.cc (pass_waccess::gimple_call_return_arg_ref):\n\tInline into single user ...\n\t(pass_waccess::check_dangling_uses): ... here and adjust the\n\tcall and the PHI case to require that ref.aref is the address\n\tof the decl.\n\n\t* gcc.dg/Wdangling-pointer-pr106868.c: New testcase.", "tree": {"sha": "75d52df242e70b54750ff859c264132b63ca975e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75d52df242e70b54750ff859c264132b63ca975e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d492d50f644811327c5976e2c918ab6d906ed40c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d492d50f644811327c5976e2c918ab6d906ed40c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d492d50f644811327c5976e2c918ab6d906ed40c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d492d50f644811327c5976e2c918ab6d906ed40c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "109148dd16e4bcd50faee19c49082de69d0ba26e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/109148dd16e4bcd50faee19c49082de69d0ba26e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/109148dd16e4bcd50faee19c49082de69d0ba26e"}], "stats": {"total": 66, "additions": 30, "deletions": 36}, "files": [{"sha": "854e47cf389018ea403173c75d325c78f745b6ee", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 16, "deletions": 36, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d492d50f644811327c5976e2c918ab6d906ed40c/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d492d50f644811327c5976e2c918ab6d906ed40c/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=d492d50f644811327c5976e2c918ab6d906ed40c", "patch": "@@ -2127,7 +2127,6 @@ class pass_waccess : public gimple_opt_pass\n \n   /* Return the argument that a call returns.  */\n   tree gimple_call_return_arg (gcall *);\n-  tree gimple_call_return_arg_ref (gcall *);\n \n   /* Check a call for uses of a dangling pointer arguments.  */\n   void check_call_dangling (gcall *);\n@@ -4460,24 +4459,6 @@ pass_waccess::gimple_call_return_arg (gcall *call)\n   return gimple_call_arg (call, argno);\n }\n \n-/* Return the decl referenced by the argument that the call STMT to\n-   a built-in function returns (including with an offset) or null if\n-   it doesn't.  */\n-\n-tree\n-pass_waccess::gimple_call_return_arg_ref (gcall *call)\n-{\n-  if (tree arg = gimple_call_return_arg (call))\n-    {\n-      access_ref aref;\n-      if (m_ptr_qry.get_ref (arg, call, &aref, 0)\n-\t  && DECL_P (aref.ref))\n-\treturn aref.ref;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Check for and diagnose all uses of the dangling pointer VAR to the auto\n    object DECL whose lifetime has ended.  OBJREF is true when VAR denotes\n    an access to a DECL that may have been clobbered.  */\n@@ -4646,11 +4627,10 @@ pass_waccess::check_dangling_uses ()\n   unsigned i;\n   FOR_EACH_SSA_NAME (i, var, m_func)\n     {\n-      /* For each SSA_NAME pointer VAR find the DECL it points to.\n-\t If the DECL is a clobbered local variable, check to see\n+      /* For each SSA_NAME pointer VAR find the object it points to.\n+\t If the object is a clobbered local variable, check to see\n \t if any of VAR's uses (or those of other pointers derived\n \t from VAR) happens after the clobber.  If so, warn.  */\n-      tree decl = NULL_TREE;\n \n       gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n       if (is_gimple_assign (def_stmt))\n@@ -4660,43 +4640,43 @@ pass_waccess::check_dangling_uses ()\n \t    {\n \t      if (!POINTER_TYPE_P (TREE_TYPE (var)))\n \t\tcontinue;\n-\t      decl = TREE_OPERAND (rhs, 0);\n+\t      check_dangling_uses (var, TREE_OPERAND (rhs, 0));\n \t    }\n \t  else\n \t    {\n \t      /* For other expressions, check the base DECL to see\n \t\t if it's been clobbered, most likely as a result of\n \t\t inlining a reference to it.  */\n-\t      decl = get_base_address (rhs);\n+\t      tree decl = get_base_address (rhs);\n \t      if (DECL_P (decl))\n \t\tcheck_dangling_uses (var, decl, false, true);\n-\t      continue;\n \t    }\n \t}\n       else if (POINTER_TYPE_P (TREE_TYPE (var)))\n \t{\n \t  if (gcall *call = dyn_cast<gcall *>(def_stmt))\n-\t    decl = gimple_call_return_arg_ref (call);\n+\t    {\n+\t      if (tree arg = gimple_call_return_arg (call))\n+\t\t{\n+\t\t  access_ref aref;\n+\t\t  if (m_ptr_qry.get_ref (arg, call, &aref, 0)\n+\t\t      && aref.deref < 0)\n+\t\t    check_dangling_uses (var, aref.ref);\n+\t\t}\n+\t    }\n \t  else if (gphi *phi = dyn_cast <gphi *>(def_stmt))\n \t    {\n \t      unsigned nargs = gimple_phi_num_args (phi);\n \t      for (unsigned i = 0; i != nargs; ++i)\n \t\t{\n \t\t  access_ref aref;\n \t\t  tree arg = gimple_phi_arg_def (phi, i);\n-\t\t  if (!m_ptr_qry.get_ref (arg, phi, &aref, 0)\n-\t\t      || (aref.deref == 0\n-\t\t\t  && POINTER_TYPE_P (TREE_TYPE (aref.ref))))\n-\t\t    continue;\n-\t\t  check_dangling_uses (var, aref.ref, true);\n+\t\t  if (m_ptr_qry.get_ref (arg, phi, &aref, 0)\n+\t\t      && aref.deref < 0)\n+\t\t    check_dangling_uses (var, aref.ref, true);\n \t\t}\n-\t      continue;\n \t    }\n-\t  else\n-\t    continue;\n \t}\n-\n-      check_dangling_uses (var, decl);\n     }\n }\n "}, {"sha": "f782a5e07a12cafbf8fb6e51ccb7764b2bc14d72", "filename": "gcc/testsuite/gcc.dg/Wdangling-pointer-pr106868.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d492d50f644811327c5976e2c918ab6d906ed40c/gcc%2Ftestsuite%2Fgcc.dg%2FWdangling-pointer-pr106868.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d492d50f644811327c5976e2c918ab6d906ed40c/gcc%2Ftestsuite%2Fgcc.dg%2FWdangling-pointer-pr106868.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWdangling-pointer-pr106868.c?ref=d492d50f644811327c5976e2c918ab6d906ed40c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -Wdangling-pointer\" } */\n+\n+void alloc(void **p);\n+void false_dangling(char **p)\n+{\n+  {\n+    void *q;\n+    alloc(&q);\n+    *p = q;\n+  }\n+  char *a = __builtin_memcpy(*p, \"\", 1);\n+  *a = 0; /* { dg-bogus \"dangling\" } */\n+}"}]}