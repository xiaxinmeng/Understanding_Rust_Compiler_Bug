{"sha": "a634928f5c8a281442ac8f5fb1636aed048ed72c", "node_id": "C_kwDOANBUbNoAKGE2MzQ5MjhmNWM4YTI4MTQ0MmFjOGY1ZmIxNjM2YWVkMDQ4ZWQ3MmM", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-04T22:50:02Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-11-04T22:50:02Z"}, "message": "libstdc++: Fix pretty printing of std::unique_ptr [PR103086]\n\nSince std::tuple started using [[no_unique_address]] the tuple<T*, D>\nmember of std::unique_ptr<T, D> has two _M_head_impl subobjects, in\ndifferent base classes. That means this printer code is ambiguous:\n\n    tuple_head_type = tuple_impl_type.fields()[1].type   # _Head_base\n    head_field = tuple_head_type.fields()[0]\n    if head_field.name == '_M_head_impl':\n        self.pointer = tuple_member['_M_head_impl']\n\nIn older versions of GDB it happened to work by chance, because GDB\nreturned the last _M_head_impl member and std::tuple's base classes are\nstored in reverse order, so the last one was the T* element of the\ntuple. Since GDB 11 it returns the first _M_head_impl, which is the\ndeleter element.\n\nThe fix is for the printer to stop using an ambiguous field name and\ncast the tuple to the correct base class before accessing the\n_M_head_impl member.\n\nInstead of fixing this in both UniquePointerPrinter and StdPathPrinter a\nnew unique_ptr_get function is defined to do it correctly. That is\ndefined in terms of new tuple_get and _tuple_impl_get functions.\n\nIt would be possible to reuse _tuple_impl_get to access each element in\nStdTuplePrinter._iterator.__next__, but that already does the correct\ncasting, and wouldn't be much simpler anyway.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/103086\n\t* python/libstdcxx/v6/printers.py (_tuple_impl_get): New helper\n\tfor accessing the tuple element stored in a _Tuple_impl node.\n\t(tuple_get): New function for accessing a tuple element.\n\t(unique_ptr_get): New function for accessing a unique_ptr.\n\t(UniquePointerPrinter, StdPathPrinter): Use unique_ptr_get.\n\t* python/libstdcxx/v6/xmethods.py (UniquePtrGetWorker): Cast\n\ttuple to its base class before accessing _M_head_impl.", "tree": {"sha": "2a423d626c36d9ab6ee6f9eaf9e9dfa771ea54ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a423d626c36d9ab6ee6f9eaf9e9dfa771ea54ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a634928f5c8a281442ac8f5fb1636aed048ed72c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a634928f5c8a281442ac8f5fb1636aed048ed72c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a634928f5c8a281442ac8f5fb1636aed048ed72c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a634928f5c8a281442ac8f5fb1636aed048ed72c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4130a3eb545ab1aaf3ecb44f3d06b43e3751e04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4130a3eb545ab1aaf3ecb44f3d06b43e3751e04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4130a3eb545ab1aaf3ecb44f3d06b43e3751e04"}], "stats": {"total": 73, "additions": 52, "deletions": 21}, "files": [{"sha": "c5072c52281bf585bd9d00173aae9a2451043e7d", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a634928f5c8a281442ac8f5fb1636aed048ed72c/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a634928f5c8a281442ac8f5fb1636aed048ed72c/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=a634928f5c8a281442ac8f5fb1636aed048ed72c", "patch": "@@ -240,32 +240,63 @@ def to_string (self):\n                 state = 'use count %d, weak count %d' % (usecount, weakcount - 1)\n         return '%s<%s> (%s)' % (self.typename, str(self.val.type.template_argument(0)), state)\n \n+def _tuple_impl_get(val):\n+    \"Return the tuple element stored in a _Tuple_impl<N, T> base class.\"\n+    bases = val.type.fields()\n+    if not bases[-1].is_base_class:\n+        raise ValueError(\"Unsupported implementation for std::tuple: %s\" % str(val.type))\n+    # Get the _Head_base<N, T> base class:\n+    head_base = val.cast(bases[-1].type)\n+    fields = head_base.type.fields()\n+    if len(fields) == 0:\n+        raise ValueError(\"Unsupported implementation for std::tuple: %s\" % str(val.type))\n+    if fields[0].name == '_M_head_impl':\n+        # The tuple element is the _Head_base::_M_head_impl data member.\n+        return head_base['_M_head_impl']\n+    elif fields[0].is_base_class:\n+        # The tuple element is an empty base class of _Head_base.\n+        # Cast to that empty base class.\n+        return head_base.cast(fields[0].type)\n+    else:\n+        raise ValueError(\"Unsupported implementation for std::tuple: %s\" % str(val.type))\n+\n+def tuple_get(n, val):\n+    \"Return the result of std::get<n>(val) on a std::tuple\"\n+    tuple_size = len(get_template_arg_list(val.type))\n+    if n > tuple_size:\n+        raise ValueError(\"Out of range index for std::get<N> on std::tuple\")\n+    # Get the first _Tuple_impl<0, T...> base class:\n+    node = val.cast(val.type.fields()[0].type)\n+    while n > 0:\n+        # Descend through the base classes until the Nth one.\n+        node = node.cast(node.type.fields()[0].type)\n+        n -= 1\n+    return _tuple_impl_get(node)\n+\n+def unique_ptr_get(val):\n+    \"Return the result of val.get() on a std::unique_ptr\"\n+    # std::unique_ptr<T, D> contains a std::tuple<D::pointer, D>,\n+    # either as a direct data member _M_t (the old implementation)\n+    # or within a data member of type __uniq_ptr_data.\n+    impl_type = val.type.fields()[0].type.strip_typedefs()\n+    # Check for new implementations first:\n+    if is_specialization_of(impl_type, '__uniq_ptr_data') \\\n+        or is_specialization_of(impl_type, '__uniq_ptr_impl'):\n+        tuple_member = val['_M_t']['_M_t']\n+    elif is_specialization_of(impl_type, 'tuple'):\n+        tuple_member = val['_M_t']\n+    else:\n+        raise ValueError(\"Unsupported implementation for unique_ptr: %s\" % str(impl_type))\n+    return tuple_get(0, tuple_member)\n+\n class UniquePointerPrinter:\n     \"Print a unique_ptr\"\n \n     def __init__ (self, typename, val):\n         self.val = val\n-        impl_type = val.type.fields()[0].type.strip_typedefs()\n-        # Check for new implementations first:\n-        if is_specialization_of(impl_type, '__uniq_ptr_data') \\\n-            or is_specialization_of(impl_type, '__uniq_ptr_impl'):\n-            tuple_member = val['_M_t']['_M_t']\n-        elif is_specialization_of(impl_type, 'tuple'):\n-            tuple_member = val['_M_t']\n-        else:\n-            raise ValueError(\"Unsupported implementation for unique_ptr: %s\" % str(impl_type))\n-        tuple_impl_type = tuple_member.type.fields()[0].type # _Tuple_impl\n-        tuple_head_type = tuple_impl_type.fields()[1].type   # _Head_base\n-        head_field = tuple_head_type.fields()[0]\n-        if head_field.name == '_M_head_impl':\n-            self.pointer = tuple_member['_M_head_impl']\n-        elif head_field.is_base_class:\n-            self.pointer = tuple_member.cast(head_field.type)\n-        else:\n-            raise ValueError(\"Unsupported implementation for tuple in unique_ptr: %s\" % str(impl_type))\n \n     def children (self):\n-        return SmartPtrIterator(self.pointer)\n+        return SmartPtrIterator(unique_ptr_get(self.val))\n \n     def to_string (self):\n         return ('std::unique_ptr<%s>' % (str(self.val.type.template_argument(0))))\n@@ -1370,7 +1401,7 @@ class StdPathPrinter:\n     def __init__ (self, typename, val):\n         self.val = val\n         self.typename = typename\n-        impl = self.val['_M_cmpts']['_M_impl']['_M_t']['_M_t']['_M_head_impl']\n+        impl = unique_ptr_get(self.val['_M_cmpts']['_M_impl'])\n         self.type = impl.cast(gdb.lookup_type('uintptr_t')) & 3\n         if self.type == 0:\n             self.impl = impl"}, {"sha": "991d945321acfbf2a0177ed096addc2f89c4df39", "filename": "libstdc++-v3/python/libstdcxx/v6/xmethods.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a634928f5c8a281442ac8f5fb1636aed048ed72c/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fxmethods.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a634928f5c8a281442ac8f5fb1636aed048ed72c/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fxmethods.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fxmethods.py?ref=a634928f5c8a281442ac8f5fb1636aed048ed72c", "patch": "@@ -597,7 +597,7 @@ def __call__(self, obj):\n         tuple_head_type = tuple_impl_type.fields()[1].type   # _Head_base\n         head_field = tuple_head_type.fields()[0]\n         if head_field.name == '_M_head_impl':\n-            return tuple_member['_M_head_impl']\n+            return tuple_member.cast(tuple_head_type)['_M_head_impl']\n         elif head_field.is_base_class:\n             return tuple_member.cast(head_field.type)\n         else:"}]}