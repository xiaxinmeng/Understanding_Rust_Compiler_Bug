{"sha": "8e97bc2bdb4013cbb62d9910083b240e0eb01941", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU5N2JjMmJkYjQwMTNjYmI2MmQ5OTEwMDgzYjI0MGUwZWIwMTk0MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-11-19T23:48:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-11-19T23:48:57Z"}, "message": "re PR tree-optimization/45830 (Code+rodata increase with -ftree-switch-conversion)\n\n\tPR tree-optimization/45830\n\t* stmt.c (expand_switch_using_bit_tests_p): New function.\n\t(expand_case): Use it.\n\t* tree.h (expand_switch_using_bit_tests_p): New prototype.\n\t* tree-switch-conversion.c (struct switch_conv_info): Add\n\tbit_test_uniq, bit_test_count and bit_test_bb fields.\n\t(check_range): Fix a comment.\n\t(check_process_case): Compute bit_test_uniq and bit_test_count.\n\t(create_temp_arrays): Use XCNEWVEC, merge 3 arrays into one\n\tallocation.\n\t(free_temp_arrays): Use XDELETEVEC, adjust for the 3 arrays merging.\n\t(constructor_contains_same_values_p): Use FOR_EACH_VEC_ELT.\n\t(array_value_type): New function.\n\t(build_one_array): Use it, if it returned different type,\n\tfold_convert all constructor fields and convert back to the\n\twider type in the generated code.\n\t(process_switch): Initialize bit_test_uniq, bit_test_count and\n\tbit_test_bb fields.  Don't optimize if expand_switch_using_bit_tests_p\n\treturned true.\n\n\t* gcc.target/i386/pr45830.c: New test.\n\t* gcc.c-torture/execute/pr45830.c: New test.\n\nFrom-SVN: r166966", "tree": {"sha": "e65b38b3e2f234c14ced25bd4b7e019d0bf01d3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e65b38b3e2f234c14ced25bd4b7e019d0bf01d3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e97bc2bdb4013cbb62d9910083b240e0eb01941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e97bc2bdb4013cbb62d9910083b240e0eb01941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e97bc2bdb4013cbb62d9910083b240e0eb01941", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e97bc2bdb4013cbb62d9910083b240e0eb01941/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb3303597e3e88c6c03f2c699ec89c55fb7b7cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3303597e3e88c6c03f2c699ec89c55fb7b7cfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb3303597e3e88c6c03f2c699ec89c55fb7b7cfc"}], "stats": {"total": 347, "additions": 320, "deletions": 27}, "files": [{"sha": "b5dbd5b19d9431dd20ca51bf14c515650126ece8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e97bc2bdb4013cbb62d9910083b240e0eb01941", "patch": "@@ -1,3 +1,25 @@\n+2010-11-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/45830\n+\t* stmt.c (expand_switch_using_bit_tests_p): New function.\n+\t(expand_case): Use it.\n+\t* tree.h (expand_switch_using_bit_tests_p): New prototype.\n+\t* tree-switch-conversion.c (struct switch_conv_info): Add\n+\tbit_test_uniq, bit_test_count and bit_test_bb fields.\n+\t(check_range): Fix a comment.\n+\t(check_process_case): Compute bit_test_uniq and bit_test_count.\n+\t(create_temp_arrays): Use XCNEWVEC, merge 3 arrays into one\n+\tallocation.\n+\t(free_temp_arrays): Use XDELETEVEC, adjust for the 3 arrays merging.\n+\t(constructor_contains_same_values_p): Use FOR_EACH_VEC_ELT.\n+\t(array_value_type): New function.\n+\t(build_one_array): Use it, if it returned different type,\n+\tfold_convert all constructor fields and convert back to the\n+\twider type in the generated code.\n+\t(process_switch): Initialize bit_test_uniq, bit_test_count and\n+\tbit_test_bb fields.  Don't optimize if expand_switch_using_bit_tests_p\n+\treturned true.\n+\n 2010-11-19  Michael Matz  <matz@suse.de>\n \n \tPR tree-optimization/46077"}, {"sha": "e045330ef31b9d88f79bf1df0dc2678925e8647f", "filename": "gcc/stmt.c", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=8e97bc2bdb4013cbb62d9910083b240e0eb01941", "patch": "@@ -2250,6 +2250,25 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n #define HAVE_tablejump 0\n #endif\n \n+/* Return true if a switch should be expanded as a bit test.\n+   INDEX_EXPR is the index expression, RANGE is the difference between\n+   highest and lowest case, UNIQ is number of unique case node targets\n+   not counting the default case and COUNT is the number of comparisons\n+   needed, not counting the default case.  */\n+bool\n+expand_switch_using_bit_tests_p (tree index_expr, tree range,\n+\t\t\t\t unsigned int uniq, unsigned int count)\n+{\n+  return (CASE_USE_BIT_TESTS\n+\t  && ! TREE_CONSTANT (index_expr)\n+\t  && compare_tree_int (range, GET_MODE_BITSIZE (word_mode)) < 0\n+\t  && compare_tree_int (range, 0) > 0\n+\t  && lshift_cheap_p ()\n+\t  && ((uniq == 1 && count >= 3)\n+\t      || (uniq == 2 && count >= 5)\n+\t      || (uniq == 3 && count >= 6)));\n+}\n+\n /* Terminate a case (Pascal/Ada) or switch (C) statement\n    in which ORIG_INDEX is the expression to be tested.\n    If ORIG_TYPE is not NULL, it is the original ORIG_INDEX\n@@ -2384,14 +2403,7 @@ expand_case (gimple stmt)\n       /* Try implementing this switch statement by a short sequence of\n \t bit-wise comparisons.  However, we let the binary-tree case\n \t below handle constant index expressions.  */\n-      if (CASE_USE_BIT_TESTS\n-\t  && ! TREE_CONSTANT (index_expr)\n-\t  && compare_tree_int (range, GET_MODE_BITSIZE (word_mode)) < 0\n-\t  && compare_tree_int (range, 0) > 0\n-\t  && lshift_cheap_p ()\n-\t  && ((uniq == 1 && count >= 3)\n-\t      || (uniq == 2 && count >= 5)\n-\t      || (uniq == 3 && count >= 6)))\n+      if (expand_switch_using_bit_tests_p (index_expr, range, uniq, count))\n \t{\n \t  /* Optimize the case where all the case values fit in a\n \t     word without having to subtract MINVAL.  In this case,"}, {"sha": "38a694cf3d548db2fc85f10d9c2f2220c9129832", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e97bc2bdb4013cbb62d9910083b240e0eb01941", "patch": "@@ -1,3 +1,9 @@\n+2010-11-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/45830\n+\t* gcc.target/i386/pr45830.c: New test.\n+\t* gcc.c-torture/execute/pr45830.c: New test.\n+\n 2010-11-19  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/attributes/class-attribute-1.m: Rewritten."}, {"sha": "0f83e050e251ed88607c1f0ec65025df8d2ed25b", "filename": "gcc/testsuite/gcc.c-torture/execute/pr45830.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr45830.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr45830.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr45830.c?ref=8e97bc2bdb4013cbb62d9910083b240e0eb01941", "patch": "@@ -0,0 +1,97 @@\n+/* PR tree-optimization/45830 */\n+\n+extern void abort (void);\n+\n+long long va, vb, vc, vd, ve;\n+\n+__attribute__((noinline)) int\n+foo (int x)\n+{\n+  long long a, b, c, d, e;\n+  switch (x)\n+    {\n+    case 0:\n+    case 3:\n+    case 1:\n+    case 2:\n+    case 4:\n+      a = 1;\n+      b = 129;\n+      c = -12;\n+      d = -4;\n+      e = 128;\n+      break;\n+    case 23:\n+    case 26:\n+    case 19:\n+    case 65:\n+    case 5:\n+      a = 2;\n+      b = 138;\n+      c = 115;\n+      d = 128;\n+      e = -16;\n+      break;\n+    case 21:\n+    case 20:\n+    case 22:\n+    case 38:\n+    case 27:\n+    case 66:\n+    case 45:\n+    case 47:\n+      a = 3;\n+      b = 6;\n+      c = 127;\n+      d = 25;\n+      e = 257;\n+      break;\n+    default:\n+      a = 0;\n+      b = 18;\n+      c = 0;\n+      d = 64;\n+      e = 32768L;\n+      break;\n+    }\n+  va = a;\n+  vb = b;\n+  vc = c;\n+  vd = d;\n+  ve = e;\n+}\n+\n+int\n+bar (int x)\n+{\n+  if (x < 0)\n+    return 3;\n+  if (x < 5)\n+    return 0;\n+  if (x == 5 || x == 19 || x == 23 | x == 26 || x == 65)\n+    return 1;\n+  if ((x >= 20 && x <= 22) || x == 27 || x == 38\n+      || x == 45 || x == 47 || x == 66)\n+    return 2;\n+  return 3;\n+}\n+\n+long long expected[] =\n+{ 1, 129, -12, -4, 128, 2, 138, 115, 128, -16,\n+  3, 6, 127, 25, 257, 0, 18, 0, 64, 32768L };\n+\n+int\n+main (void)\n+{\n+  int i, v;\n+  for (i = -4; i < 70; i++)\n+    {\n+      foo (i);\n+      v = bar (i);\n+      if (va != expected[5 * v] || vb != expected[5 * v + 1]\n+\t  || vc != expected[5 * v + 2] || vd != expected[5 * v + 3]\n+\t  || ve != expected[5 * v + 4])\n+\tabort ();\n+    }\n+  return 0;\n+}"}, {"sha": "a74d4345464f49c35d930c40f2e877c4fd8610f7", "filename": "gcc/testsuite/gcc.target/i386/pr45830.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr45830.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr45830.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr45830.c?ref=8e97bc2bdb4013cbb62d9910083b240e0eb01941", "patch": "@@ -0,0 +1,31 @@\n+/* PR target/45830 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-switchconv-all -mtune=generic\" } */\n+\n+int\n+foo (int *a)\n+{\n+  switch (*a)\n+    {\n+    case 0:\n+    case 3:\n+    case 1:\n+    case 2:\n+    case 4:\n+    case 23:\n+    case 26:\n+    case 19:\n+    case 5:\n+    case 21:\n+    case 20:\n+    case 22:\n+    case 27:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Expanding as bit test is preferable\" \"switchconv\" } } */\n+/* { dg-final { scan-assembler-not \"CSWTCH\" } } */\n+/* { dg-final { cleanup-tree-dump \"switchconv\" } } */"}, {"sha": "fc333f7480d6ba191fd47f05e5ecc854da291a99", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 142, "deletions": 19, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=8e97bc2bdb4013cbb62d9910083b240e0eb01941", "patch": "@@ -156,6 +156,12 @@ struct switch_conv_info\n   /* String reason why the case wasn't a good candidate that is written to the\n      dump file, if there is one.  */\n   const char *reason;\n+\n+  /* Parameters for expand_switch_using_bit_tests.  Should be computed\n+     the same way as in expand_case.  */\n+  unsigned int bit_test_uniq;\n+  unsigned int bit_test_count;\n+  basic_block bit_test_bb[2];\n };\n \n /* Global pass info.  */\n@@ -174,7 +180,7 @@ check_range (gimple swtch)\n   tree range_max;\n \n   /* The gimplifier has already sorted the cases by CASE_LOW and ensured there\n-     is a default label which is the last in the vector.  */\n+     is a default label which is the first in the vector.  */\n \n   min_case = gimple_switch_label (swtch, 1);\n   info.range_min = CASE_LOW (min_case);\n@@ -234,7 +240,26 @@ check_process_case (tree cs)\n       info.default_count = e->count;\n     }\n   else\n-    info.other_count += e->count;\n+    {\n+      int i;\n+      info.other_count += e->count;\n+      for (i = 0; i < 2; i++)\n+\tif (info.bit_test_bb[i] == label_bb)\n+\t  break;\n+\telse if (info.bit_test_bb[i] == NULL)\n+\t  {\n+\t    info.bit_test_bb[i] = label_bb;\n+\t    info.bit_test_uniq++;\n+\t    break;\n+\t  }\n+      if (i == 2)\n+\tinfo.bit_test_uniq = 3;\n+      if (CASE_HIGH (cs) != NULL_TREE\n+\t  && ! tree_int_cst_equal (CASE_LOW (cs), CASE_HIGH (cs)))\n+\tinfo.bit_test_count += 2;\n+      else\n+\tinfo.bit_test_count++;\n+    }\n \n   if (!label_bb)\n     {\n@@ -336,13 +361,10 @@ create_temp_arrays (void)\n {\n   int i;\n \n-  info.default_values = (tree *) xcalloc (info.phi_count, sizeof (tree));\n-  info.constructors = (VEC (constructor_elt, gc) **) xcalloc (info.phi_count,\n-\t\t\t\t\t\t\t      sizeof (tree));\n-  info.target_inbound_names = (tree *) xcalloc (info.phi_count, sizeof (tree));\n-  info.target_outbound_names = (tree *) xcalloc (info.phi_count,\n-\t\t\t\t\t\t sizeof (tree));\n-\n+  info.default_values = XCNEWVEC (tree, info.phi_count * 3);\n+  info.constructors = XCNEWVEC (VEC (constructor_elt, gc) *, info.phi_count);\n+  info.target_inbound_names = info.default_values + info.phi_count;\n+  info.target_outbound_names = info.target_inbound_names + info.phi_count;\n   for (i = 0; i < info.phi_count; i++)\n     info.constructors[i]\n       = VEC_alloc (constructor_elt, gc, tree_low_cst (info.range_size, 1) + 1);\n@@ -355,10 +377,8 @@ create_temp_arrays (void)\n static void\n free_temp_arrays (void)\n {\n-  free (info.constructors);\n-  free (info.default_values);\n-  free (info.target_inbound_names);\n-  free (info.target_outbound_names);\n+  XDELETEVEC (info.constructors);\n+  XDELETEVEC (info.default_values);\n }\n \n /* Populate the array of default values in the order of phi nodes.\n@@ -468,13 +488,12 @@ build_constructors (gimple swtch)\n static tree\n constructor_contains_same_values_p (VEC (constructor_elt, gc) *vec)\n {\n-  int i, len = VEC_length (constructor_elt, vec);\n+  unsigned int i;\n   tree prev = NULL_TREE;\n+  constructor_elt *elt;\n \n-  for (i = 0; i < len; i++)\n+  FOR_EACH_VEC_ELT (constructor_elt, vec, i, elt)\n     {\n-      constructor_elt *elt = VEC_index (constructor_elt, vec, i);\n-\n       if (!prev)\n \tprev = elt->value;\n       else if (!operand_equal_p (elt->value, prev, OEP_ONLY_CONST))\n@@ -483,6 +502,79 @@ constructor_contains_same_values_p (VEC (constructor_elt, gc) *vec)\n   return prev;\n }\n \n+/* Return type which should be used for array elements, either TYPE,\n+   or for integral type some smaller integral type that can still hold\n+   all the constants.  */\n+\n+static tree\n+array_value_type (gimple swtch, tree type, int num)\n+{\n+  unsigned int i, len = VEC_length (constructor_elt, info.constructors[num]);\n+  constructor_elt *elt;\n+  enum machine_mode mode;\n+  int sign = 0;\n+  tree smaller_type;\n+\n+  if (!INTEGRAL_TYPE_P (type))\n+    return type;\n+\n+  mode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (TYPE_MODE (type)));\n+  if (GET_MODE_SIZE (TYPE_MODE (type)) <= GET_MODE_SIZE (mode))\n+    return type;\n+\n+  if (len < (optimize_bb_for_size_p (gimple_bb (swtch)) ? 2 : 32))\n+    return type;\n+\n+  FOR_EACH_VEC_ELT (constructor_elt, info.constructors[num], i, elt)\n+    {\n+      double_int cst;\n+\n+      if (TREE_CODE (elt->value) != INTEGER_CST)\n+\treturn type;\n+\n+      cst = TREE_INT_CST (elt->value);\n+      while (1)\n+\t{\n+\t  unsigned int prec = GET_MODE_BITSIZE (mode);\n+\t  if (prec > HOST_BITS_PER_WIDE_INT)\n+\t    return type;\n+\n+\t  if (sign >= 0\n+\t      && double_int_equal_p (cst, double_int_zext (cst, prec)))\n+\t    {\n+\t      if (sign == 0\n+\t\t  && double_int_equal_p (cst, double_int_sext (cst, prec)))\n+\t\tbreak;\n+\t      sign = 1;\n+\t      break;\n+\t    }\n+\t  if (sign <= 0\n+\t      && double_int_equal_p (cst, double_int_sext (cst, prec)))\n+\t    {\n+\t      sign = -1;\n+\t      break;\n+\t    }\n+\n+\t  if (sign == 1)\n+\t    sign = 0;\n+\n+\t  mode = GET_MODE_WIDER_MODE (mode);\n+\t  if (mode == VOIDmode\n+\t      || GET_MODE_SIZE (mode) >= GET_MODE_SIZE (TYPE_MODE (type)))\n+\t    return type;\n+\t}\n+    }\n+\n+  if (sign == 0)\n+    sign = TYPE_UNSIGNED (type) ? 1 : -1;\n+  smaller_type = lang_hooks.types.type_for_mode (mode, sign >= 0);\n+  if (GET_MODE_SIZE (TYPE_MODE (type))\n+      <= GET_MODE_SIZE (TYPE_MODE (smaller_type)))\n+    return type;\n+\n+  return smaller_type;\n+}\n+\n /* Create an appropriate array type and declaration and assemble a static array\n    variable.  Also create a load statement that initializes the variable in\n    question with a value from the static array.  SWTCH is the switch statement\n@@ -512,10 +604,19 @@ build_one_array (gimple swtch, int num, tree arr_index_type, gimple phi,\n     load = gimple_build_assign (name, cst);\n   else\n     {\n-      tree array_type, ctor, decl, value_type, fetch;\n+      tree array_type, ctor, decl, value_type, fetch, default_type;\n \n-      value_type = TREE_TYPE (info.default_values[num]);\n+      default_type = TREE_TYPE (info.default_values[num]);\n+      value_type = array_value_type (swtch, default_type, num);\n       array_type = build_array_type (value_type, arr_index_type);\n+      if (default_type != value_type)\n+\t{\n+\t  unsigned int i;\n+\t  constructor_elt *elt;\n+\n+\t  FOR_EACH_VEC_ELT (constructor_elt, info.constructors[num], i, elt)\n+\t    elt->value = fold_convert (value_type, elt->value);\n+\t}\n       ctor = build_constructor (array_type, info.constructors[num]);\n       TREE_CONSTANT (ctor) = true;\n       TREE_STATIC (ctor) = true;\n@@ -534,6 +635,12 @@ build_one_array (gimple swtch, int num, tree arr_index_type, gimple phi,\n \n       fetch = build4 (ARRAY_REF, value_type, decl, tidx, NULL_TREE,\n \t\t      NULL_TREE);\n+      if (default_type != value_type)\n+\t{\n+\t  fetch = fold_convert (default_type, fetch);\n+\t  fetch = force_gimple_operand_gsi (&gsi, fetch, true, NULL_TREE,\n+\t\t\t\t\t    true, GSI_SAME_STMT);\n+\t}\n       load = gimple_build_assign (name, fetch);\n     }\n \n@@ -818,6 +925,10 @@ process_switch (gimple swtch)\n   info.default_prob = 0;\n   info.default_count = 0;\n   info.other_count = 0;\n+  info.bit_test_uniq = 0;\n+  info.bit_test_count = 0;\n+  info.bit_test_bb[0] = NULL;\n+  info.bit_test_bb[1] = NULL;\n \n   /* An ERROR_MARK occurs for various reasons including invalid data type.\n      (comment from stmt.c) */\n@@ -841,6 +952,18 @@ process_switch (gimple swtch)\n \treturn false;\n       }\n \n+  if (info.bit_test_uniq <= 2)\n+    {\n+      rtl_profile_for_bb (gimple_bb (swtch));\n+      if (expand_switch_using_bit_tests_p (gimple_switch_index (swtch),\n+\t\t\t\t\t   info.range_size, info.bit_test_uniq,\n+\t\t\t\t\t   info.bit_test_count))\n+\t{\n+\t  info.reason = \"  Expanding as bit test is preferable\\n\";\n+\t  return false;\n+\t}\n+    }\n+\n   if (!check_final_bb ())\n     return false;\n "}, {"sha": "90170e78d07e1431be67481651c3172dc4467053", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e97bc2bdb4013cbb62d9910083b240e0eb01941/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8e97bc2bdb4013cbb62d9910083b240e0eb01941", "patch": "@@ -5314,6 +5314,8 @@ extern bool parse_input_constraint (const char **, int, int, int, int,\n \t\t\t\t    const char * const *, bool *, bool *);\n extern void expand_asm_stmt (gimple);\n extern tree resolve_asm_operand_names (tree, tree, tree, tree);\n+extern bool expand_switch_using_bit_tests_p (tree, tree, unsigned int,\n+\t\t\t\t\t     unsigned int);\n extern void expand_case (gimple);\n extern void expand_decl (tree);\n #ifdef HARD_CONST"}]}