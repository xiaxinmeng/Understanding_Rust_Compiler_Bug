{"sha": "a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgwZTQxOTU1YWQxMjYyZWE5ZTkyM2NhNmVhMzA0NGZlMDA1ZThmYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-19T00:48:03Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-19T00:48:03Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r11850", "tree": {"sha": "bdbf773e17cdf6ea25a65257bf8b7dd0bdf59bf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdbf773e17cdf6ea25a65257bf8b7dd0bdf59bf7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/comments", "author": null, "committer": null, "parents": [{"sha": "ec497122f7dc8787f6db51c8ab30dc3532455255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec497122f7dc8787f6db51c8ab30dc3532455255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec497122f7dc8787f6db51c8ab30dc3532455255"}], "stats": {"total": 654, "additions": 314, "deletions": 340}, "files": [{"sha": "44e34696f0672392be039220cabc22e4276afe05", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 73, "deletions": 4, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -1,14 +1,83 @@\n-Wed Apr 17 15:20:10 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+Thu Apr 18 08:56:54 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (make_typename_type): Handle getting a TYPE_DECL for a\n+ \tname.\n+\t* parse.y (base_class.1): Allow 'typename foo::bar'.\n+\n+\t* lex.c (check_newline): Remove #pragma code that plays with the\n+ \tinput stream, since we now deal with tokens.  Clear nextchar when\n+ \twe're done.\n+\t(handle_cp_pragma): Use real_yylex.\n+\t(handle_sysv_pragma): Don't do skipline here.  Only call real_yylex\n+\tin one place.\n+\n+\t* lex.c (check_for_missing_semicolon): Handle SELFNAME.\n+\n+\t* lex.c (handle_cp_pragma): Fix \"#pragma implementation\".\n+\n+Wed Apr 17 16:51:33 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* parse.y: New token SELFNAME for potential constructor.\n+\t* spew.c (yylex): Handle it.\n+\t* lex.c (identifier_type): Produce it.\n+\n+\t* parse.y (complete_type_name): In :: case, don't push class binding.\n+\t(complex_type_name): Ditto.\n+\n+Wed Apr 17 15:02:40 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_reinterpret_cast): Handle pointer to member\n+ \tfunctions.\n+\n+Wed Apr 17 12:28:26 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n \n \t* lex.c (handle_cp_pragma): New function, with decl, doing the cc1plus\n-\tpragmas.\n+ \tpragmas.\n \t(check_newline): Put the vtable/unit/implementation/interface pragma\n-\tcode into handle_cp_pragma, replacing it with a call.\n+ \tcode into handle_cp_pragma, replacing it with a call.\n \t(handle_sysv_pragma): Give int return type, and take FINPUT and TOKEN\n-\targs.  Get the next token after handling the pragma token.\n+ \targs.  Get the next token after handling the pragma token.\n+\n+Wed Apr 17 10:28:34 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (cp_convert_to_pointer): Avoid doing base analysis on pmfs.\n+\t(convert_to_pointer_force): Ditto.\n+\n+\t* init.c (build_new): Fix array new without -fcheck-new.\n+\n+Tue Apr 16 13:44:58 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h, call.c, class.c, decl.c, parse.y, pt.c, rtti.c,\n+\ttree.c: Lose TYPE_NESTED_NAME.\n+\n+\t* parse.y (nested_name_specifier_1): Don't treat non-identifiers\n+\tas identifiers.\n+\n+\t* tree.def: Add VEC_INIT_EXPR.\n+\t* expr.c (cplus_expand_expr): Handle it.\n+\t* init.c (build_new): Use it instead of the RTL_EXPR nastiness and\n+ \tthe extra file-scope symbol nastiness.\n+\n+Mon Apr 15 16:21:29 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (make_thunk): Thunks are static.\n+\t(emit_thunk): Use ASM_OUTPUT_MI_THUNK if it's defined.\n+\n+\t* decl2.c (mark_vtable_entries): Emit thunks as needed.\n+\t(finish_file): Don't emit them here.\n+\n+Sun Apr 14 11:34:39 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* rtti.c (build_dynamic_cast): Handle null pointers.\n+\t(ifnonnull): New function.\n \n Fri Apr 12 09:08:27 1996  Bob Manson  <manson@charmed.cygnus.com>\n \n+\t* call.c (build_method_call): Remember the original basetype we\n+ \twere called with. Give an error message instead of trying\n+ \t(incorrectly) to call a non-static member function through a\n+ \tnon-inherited class.\n+\n \t* search.c (expand_upcast_fixups): Mark the new fixup as\n \tDECL_ARTIFICIAL.\n "}, {"sha": "29d264c37e88d1edc1fa82572c2ca38b9f7d604e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -1296,7 +1296,7 @@ find_scoped_type (type, inner_name, inner_types)\n       if (TREE_PURPOSE (tags) == inner_name)\n \t{\n \t  if (inner_types == NULL_TREE)\n-\t    return DECL_NESTED_TYPENAME (TYPE_NAME (TREE_VALUE (tags)));\n+\t    return TYPE_NAME (TREE_VALUE (tags));\n \t  return resolve_scope_to_name (TREE_VALUE (tags), inner_types);\n \t}\n       tags = TREE_CHAIN (tags);\n@@ -1308,7 +1308,7 @@ find_scoped_type (type, inner_name, inner_types)\n       {\n \t/* Code by raeburn.  */\n \tif (inner_types == NULL_TREE)\n-\t  return DECL_NESTED_TYPENAME (tags);\n+\t  return tags;\n \treturn resolve_scope_to_name (TREE_TYPE (tags), inner_types);\n       }\n \n@@ -1569,6 +1569,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   tree last;\n   int pass;\n   tree access = access_public_node;\n+  tree orig_basetype = basetype_path ? BINFO_TYPE (basetype_path) : NULL_TREE;\n \n   /* Range of cases for vtable optimization.  */\n   enum vtable_needs { not_needed, maybe_needed, unneeded, needed };\n@@ -2416,21 +2417,23 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   if (TREE_CODE (fntype) == METHOD_TYPE && static_call_context\n       && !DECL_CONSTRUCTOR_P (function))\n     {\n-      /* Let's be nice to the user for now, and give reasonable\n-\t default behavior.  */\n+      /* Let's be nasty to the user now, and give reasonable\n+\t error messages.  */\n       instance_ptr = current_class_decl;\n       if (instance_ptr)\n \t{\n \t  if (basetype != current_class_type)\n \t    {\n-\t      tree binfo = get_binfo (basetype, current_class_type, 1);\n-\t      if (binfo == NULL_TREE)\n-\t\t{\n-\t\t  error_not_base_type (function, current_class_type);\n-\t\t  return error_mark_node;\n-\t\t}\n-\t      else if (basetype == error_mark_node)\n+\t      if (basetype == error_mark_node)\n \t\treturn error_mark_node;\n+\t      else \n+                {\n+\t\t  if (orig_basetype != NULL_TREE)\n+\t\t    error_not_base_type (orig_basetype, current_class_type);\n+\t\t  else\n+\t\t    error_not_base_type (function, current_class_type);\n+                  return error_mark_node;\n+                }\n \t    }\n \t}\n       /* Only allow a static member function to call another static member"}, {"sha": "c45810453d0a579450ad81eaeec625f9b561683d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -4388,9 +4388,8 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t\t   || TREE_CODE (TREE_TYPE (d)) == TEMPLATE_TYPE_PARM))\n \t      || TREE_CODE (d) == CONST_DECL)\n \t    break;\n-\t  /* Don't inject TYPE_NESTED_NAMEs.  */\n-\t  else if (TREE_MANGLED (DECL_NAME (d))\n-\t\t   || IDENTIFIER_TEMPLATE (DECL_NAME (d)))\n+\t  /* Don't inject cache decls.  */\n+\t  else if (IDENTIFIER_TEMPLATE (DECL_NAME (d)))\n \t    continue;\n \t  DECL_TEMPLATE_INJECT (CLASSTYPE_TI_TEMPLATE (t))\n \t    = tree_cons (NULL_TREE, d,"}, {"sha": "08433366e6d49fe3df12513a0c03eb924e667154", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -69,6 +69,11 @@ DEFTREECODE (VEC_NEW_EXPR, \"vec_nw_expr\", \"e\", 3)\n    else it is NULL_TREE.  */\n DEFTREECODE (THROW_EXPR, \"throw_expr\", \"e\", 1)\n \n+/* Initialization of a vector, used in build_new.  Operand 0 is the target\n+   of the initialization, operand 1 is the initializer, and operand 2 is\n+   the number of elements.  */\n+DEFTREECODE (VEC_INIT_EXPR, \"vec_init_expr\", \"e\", 3)\n+\n /* Template definition.  The following fields have the specified uses,\n    although there are other macros in cp-tree.h that should be used for\n    accessing this data."}, {"sha": "684c9a1bd7181062ba0f9b3174eed7b5c1385a54", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -1123,10 +1123,12 @@ struct lang_decl\n    or virtual baseclasses.  */\n #define TYPE_USES_COMPLEX_INHERITANCE(NODE) (TREE_LANG_FLAG_1 (NODE))\n \n+#if 0\t\t\t\t/* UNUSED */\n /* Nonzero in IDENTIFIER_NODE means that this name is not the name the user\n    gave; it's a DECL_NESTED_TYPENAME.  Someone may want to set this on\n    mangled function names, too, but it isn't currently.  */\n #define TREE_MANGLED(NODE) (TREE_LANG_FLAG_0 (NODE))\n+#endif\n \n #if 0\t\t\t\t/* UNUSED */\n /* Nonzero in IDENTIFIER_NODE means that this name is overloaded, and\n@@ -1310,12 +1312,6 @@ extern int flag_new_for_scope;\n #define DECL_VPARENT(NODE) ((NODE)->decl.arguments)\n #endif\n \n-/* Make a slot so we can implement nested types.  This slot holds\n-   the IDENTIFIER_NODE that uniquely names the nested type.  This\n-   is for TYPE_DECLs only.  */\n-#define DECL_NESTED_TYPENAME(NODE) ((NODE)->decl.arguments)\n-#define TYPE_NESTED_NAME(NODE) (DECL_NESTED_TYPENAME (TYPE_NAME (NODE)))\n-\n #define TYPE_WAS_ANONYMOUS(NODE) (TYPE_LANG_SPECIFIC (NODE)->type_flags.was_anonymous)\n \n /* C++: all of these are overloaded!  These apply only to TYPE_DECLs.  */"}, {"sha": "80f16e29cc0394147a4ffd24eec18128b837f30e", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -133,6 +133,8 @@ cp_convert_to_pointer (type, expr)\n \n       if (TYPE_MAIN_VARIANT (type) != intype\n \t  && TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n+\t  && IS_AGGR_TYPE (TREE_TYPE (type))\n+\t  && IS_AGGR_TYPE (TREE_TYPE (intype))\n \t  && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE)\n \t{\n \t  enum tree_code code = PLUS_EXPR;\n@@ -281,6 +283,8 @@ convert_to_pointer_force (type, expr)\n \n       if (TYPE_MAIN_VARIANT (type) != intype\n \t  && TREE_CODE (TREE_TYPE (type)) == RECORD_TYPE\n+\t  && IS_AGGR_TYPE (TREE_TYPE (type))\n+\t  && IS_AGGR_TYPE (TREE_TYPE (intype))\n \t  && TREE_CODE (TREE_TYPE (intype)) == RECORD_TYPE)\n \t{\n \t  enum tree_code code = PLUS_EXPR;"}, {"sha": "da41eed4af88d5d8142b59b896a56412f6953358", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 29, "deletions": 96, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -1955,56 +1955,6 @@ set_identifier_type_value (id, type)\n   set_identifier_type_value_with_scope (id, type, inner_binding_level);\n }\n \n-/* Subroutine \"set_nested_typename\" builds the nested-typename of\n-   the type decl in question.  (Argument CLASSNAME can actually be\n-   a function as well, if that's the smallest containing scope.)  */\n-\n-void\n-set_nested_typename (decl, classname, name, type)\n-     tree decl, classname, name, type;\n-{\n-  char *buf;\n-  my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 136);\n-\n-  /* No need to do this for anonymous names, since they're unique.  */\n-  if (ANON_AGGRNAME_P (name))\n-    {\n-      DECL_NESTED_TYPENAME (decl) = name;\n-      return;\n-    }\n-\n-  if (classname == NULL_TREE)\n-    classname = get_identifier (\"\");\n-\n-  my_friendly_assert (TREE_CODE (classname) == IDENTIFIER_NODE, 137);\n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 138);\n-  buf = (char *) alloca (4 + IDENTIFIER_LENGTH (classname)\n-\t\t\t + IDENTIFIER_LENGTH (name));\n-  sprintf (buf, \"%s::%s\", IDENTIFIER_POINTER (classname),\n-\t   IDENTIFIER_POINTER (name));\n-  DECL_NESTED_TYPENAME (decl) = get_identifier (buf);\n-  TREE_MANGLED (DECL_NESTED_TYPENAME (decl)) = 1;\n-\n-  /* Create an extra decl so that the nested name will have a type value\n-     where appropriate.  */\n-  {\n-    tree nested, type_decl;\n-    nested = DECL_NESTED_TYPENAME (decl);\n-    type_decl = build_decl (TYPE_DECL, nested, type);\n-    DECL_NESTED_TYPENAME (type_decl) = nested;\n-    SET_DECL_ARTIFICIAL (type_decl);\n-    /* Mark the TYPE_DECL node created just above as a gratuitous one so that\n-       dwarfout.c will know not to generate a TAG_typedef DIE for it, and\n-       sdbout.c won't try to output a .def for \"::foo\".  */\n-    DECL_IGNORED_P (type_decl) = 1;\n-\n-    /* Remove this when local classes are fixed.  */\n-    SET_IDENTIFIER_TYPE_VALUE (nested, type);\n-\n-    pushdecl_nonclass_level (type_decl);\n-  }\n-}\n-\n /* Pop off extraneous binding levels left over due to syntax errors.\n \n    We don't pop past namespaces, as they might be valid.  */\n@@ -2138,19 +2088,6 @@ pushtag (name, type, globalize)\n \t\t}\n \n \t      TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n-\n-\t      if (context == NULL_TREE)\n-\t\t/* Non-nested class.  */\n-\t\tset_nested_typename (d, NULL_TREE, name, type);\n-\t      else if (context && TREE_CODE (context) == FUNCTION_DECL)\n-\t\t/* Function-nested class.  */\n-\t\tset_nested_typename (d, DECL_ASSEMBLER_NAME (c_decl),\n-\t\t\t\t     name, type);\n-\t      else /* if (context && IS_AGGR_TYPE (context)) */\n-\t\t/* Class-nested class.  */\n-\t\tset_nested_typename (d, DECL_NESTED_TYPENAME (c_decl),\n-\t\t\t\t     name, type);\n-\n \t      DECL_ASSEMBLER_NAME (d)\n \t\t= get_identifier (build_overload_name (type, 1, 1));\n \t    }\n@@ -2681,8 +2618,6 @@ duplicate_decls (newdecl, olddecl)\n       register tree newtype = TREE_TYPE (newdecl);\n       register tree oldtype = TREE_TYPE (olddecl);\n \n-      DECL_NESTED_TYPENAME (newdecl) = DECL_NESTED_TYPENAME (olddecl);\n-\n       if (newtype != error_mark_node && oldtype != error_mark_node\n \t  && TYPE_LANG_SPECIFIC (newtype) && TYPE_LANG_SPECIFIC (oldtype))\n \t{\n@@ -3160,12 +3095,6 @@ pushdecl (x)\n \t    }\n \t  my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 140);\n \n-\t  /* Don't set nested_typename on template type parms, for instance.\n-\t     Any artificial decls that need DECL_NESTED_TYPENAME will have it\n-\t     set in pushtag.  */\n-\t  if (! DECL_NESTED_TYPENAME (x) && ! DECL_ARTIFICIAL (x))\n-\t    set_nested_typename (x, current_class_type != NULL_TREE ? TYPE_NESTED_NAME (current_class_type) : current_class_name, DECL_NAME (x), type);\n-\n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)\n \t      && TYPE_IDENTIFIER (type))\n@@ -3486,12 +3415,6 @@ pushdecl_class_level (x)\n       if (TREE_CODE (x) == TYPE_DECL)\n \t{\n \t  set_identifier_type_value (name, TREE_TYPE (x));\n-\n-\t  /* Don't set nested_typename on template type parms, for instance.\n-\t     Any artificial decls that need DECL_NESTED_TYPENAME will have it\n-\t     set in pushtag.  */\n-\t  if (! DECL_NESTED_TYPENAME (x) && ! DECL_ARTIFICIAL (x))\n-\t    set_nested_typename (x, current_class_type != NULL_TREE ? TYPE_NESTED_NAME (current_class_type) : current_class_name, name, TREE_TYPE (x));\n \t}\n     }\n   return x;\n@@ -4105,8 +4028,7 @@ lookup_tag (form, name, binding_level, thislevel_only)\n       else\n \tfor (tail = level->tags; tail; tail = TREE_CHAIN (tail))\n \t  {\n-\t    if (TREE_PURPOSE (tail) == name\n-\t\t|| TYPE_NESTED_NAME (TREE_VALUE (tail)) == name)\n+\t    if (TREE_PURPOSE (tail) == name)\n \t      {\n \t\tenum tree_code code = TREE_CODE (TREE_VALUE (tail));\n \t\t/* Should tighten this up; it'll probably permit\n@@ -4327,7 +4249,12 @@ tree\n make_typename_type (context, name)\n      tree context, name;\n {\n-  tree t, d, i;\n+  tree t, d;\n+\n+  if (TREE_CODE (name) == TYPE_DECL)\n+    name = DECL_NAME (name);\n+  else if (TREE_CODE (name) != IDENTIFIER_NODE)\n+    my_friendly_abort (2000);\n \n   if (! current_template_parms\n       || ! uses_template_parms (context))\n@@ -4345,16 +4272,12 @@ make_typename_type (context, name)\n     push_obstacks (&permanent_obstack, &permanent_obstack);\n   t = make_lang_type (TYPENAME_TYPE);\n   d = build_decl (TYPE_DECL, name, t);\n-  i = make_anon_name ();\n   if (current_template_parms)\n     pop_obstacks ();\n \n   TYPE_CONTEXT (t) = context;\n   TYPE_MAIN_DECL (TREE_TYPE (d)) = d;\n   DECL_CONTEXT (d) = context;\n-  DECL_NESTED_TYPENAME (d) = i;\n-  IDENTIFIER_LOCAL_VALUE (i) = d;\n-  TREE_TYPE (i) = t;\n \n   return t;\n }\n@@ -4396,6 +4319,8 @@ lookup_name_real (name, prefer_type, nonclass)\n \t{\n \t  if (type == error_mark_node)\n \t    return error_mark_node;\n+\t  if (TREE_CODE (type) == TYPENAME_TYPE && TREE_TYPE (type))\n+\t    type = TREE_TYPE (type);\n \n \t  type = complete_type (type);\n \n@@ -4437,6 +4362,18 @@ lookup_name_real (name, prefer_type, nonclass)\n       else\n \tval = NULL_TREE;\n \n+#if 0\n+      if (got_scope && current_template_parms\n+\t  && uses_template_parms (got_scope)\n+\t  && val && TREE_CODE (val) == TYPE_DECL\n+\t  && ! DECL_ARTIFICIAL (val))\n+\t{\n+\t  tree t = make_typename_type (got_scope, DECL_NAME (val));\n+\t  TREE_TYPE (t) = TREE_TYPE (val);\n+\t  val = TYPE_MAIN_DECL (t);\n+\t}\n+#endif\n+\n       if (got_scope)\n \tgoto done;\n \n@@ -8992,14 +8929,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t  {\n \t    tree d = TYPE_NAME (type), c = DECL_CONTEXT (d);\n \n-\t    if (!c)\n-\t      set_nested_typename (d, NULL_TREE, declarator, type);\n-\t    else if (TREE_CODE (c) == FUNCTION_DECL)\n-\t      set_nested_typename (d, DECL_ASSEMBLER_NAME (c),\n-\t\t\t\t   declarator, type);\n-\t    else\n-\t      set_nested_typename (d, TYPE_NESTED_NAME (c), declarator, type);\n-\n \t    DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n \t    DECL_ASSEMBLER_NAME (d)\n \t      = get_identifier (build_overload_name (type, 1, 1));\n@@ -10251,6 +10180,7 @@ xref_tag (code_type_node, name, binfo, globalize)\n   int temp = 0;\n   register tree ref, t;\n   struct binding_level *b = inner_binding_level;\n+  int got_type = 0;\n \n   tag_code = (enum tag_types) TREE_INT_CST_LOW (code_type_node);\n   switch (tag_code)\n@@ -10275,7 +10205,8 @@ xref_tag (code_type_node, name, binfo, globalize)\n   if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n     {\n       t = name;\n-      name = TYPE_NESTED_NAME (t);\n+      name = TYPE_IDENTIFIER (t);\n+      got_type = 1;\n     }\n   else\n     t = IDENTIFIER_TYPE_VALUE (name);\n@@ -10289,11 +10220,11 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t  cp_pedwarn (\"redeclaration of template type-parameter `%T'\", name);\n \t  cp_pedwarn_at (\"  previously declared here\", t);\n \t}\n-      /* If we know we are defining this tag, only look it up in this scope\n-       * and don't try to find it as a type. */\n-      if (t && TYPE_CONTEXT (t) && TREE_MANGLED (name))\n+      if (t && TYPE_CONTEXT (t) && got_type)\n \tref = t;\n       else\n+\t/* If we know we are defining this tag, only look it up in this scope\n+\t * and don't try to find it as a type. */\n       \tref = lookup_tag (code, name, b, 1);\n     }\n   else\n@@ -10478,6 +10409,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \tbasetype = TREE_TYPE (basetype);\n       if (!basetype\n \t  || (TREE_CODE (basetype) != RECORD_TYPE\n+\t      && TREE_CODE (basetype) != TYPENAME_TYPE\n \t      && TREE_CODE (basetype) != TEMPLATE_TYPE_PARM))\n \t{\n \t  cp_error (\"base type `%T' fails to be a struct or class type\",\n@@ -10487,6 +10419,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n #if 1\n       /* This code replaces similar code in layout_basetypes.  */\n       else if (TREE_CODE (basetype) != TEMPLATE_TYPE_PARM\n+\t       && TREE_CODE (basetype) != TYPENAME_TYPE\n \t       && TYPE_SIZE (complete_type (basetype)) == NULL_TREE)\n \t{\n \t  cp_error (\"base class `%T' has incomplete type\", basetype);"}, {"sha": "fe32649f49a0cc26027736a6316a16ba42c9145b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -150,7 +150,7 @@ int warn_implicit = 1;\n \n int warn_ctor_dtor_privacy = 1;\n \n-/* True if we want to implement vtbvales using \"thunks\".\n+/* True if we want to implement vtables using \"thunks\".\n    The default is off now, but will be on later. */\n \n int flag_vtable_thunks;\n@@ -2448,6 +2448,11 @@ mark_vtable_entries (decl)\n       TREE_ADDRESSABLE (fn) = 1;\n       if (DECL_LANG_SPECIFIC (fn) && DECL_ABSTRACT_VIRTUAL_P (fn))\n \tTREE_OPERAND (fnaddr, 0) = fn = abort_fndecl;\n+      if (TREE_CODE (fn) == THUNK_DECL && DECL_EXTERNAL (fn))\n+\t{\n+\t  DECL_EXTERNAL (fn) = 0;\n+\t  emit_thunk (fn);\n+\t}\n       mark_used (fn);\n     }\n }\n@@ -3187,11 +3192,9 @@ finish_file ()\n \n   for (vars = getdecls (); vars; vars = TREE_CHAIN (vars))\n     {\n-      if (TREE_CODE (vars) == THUNK_DECL)\n-\temit_thunk (vars);\n-      else if (TREE_CODE (vars) == FUNCTION_DECL\n-\t       && ! DECL_INTERFACE_KNOWN (vars)\n-\t       && DECL_C_STATIC (vars))\n+      if (TREE_CODE (vars) == FUNCTION_DECL\n+\t  && ! DECL_INTERFACE_KNOWN (vars)\n+\t  && DECL_C_STATIC (vars))\n \tTREE_PUBLIC (vars) = 0;\n     }\n "}, {"sha": "bda84000141e446d75d756bb2c461afe79a68b82", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -234,6 +234,14 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \treturn temp;\n       }\n \n+    case VEC_INIT_EXPR:\n+      return expand_expr\n+\t(expand_vec_init\n+\t (NULL_TREE, TREE_OPERAND (exp, 0),\n+\t  build_binary_op (MINUS_EXPR, TREE_OPERAND (exp, 2),\n+\t\t\t   integer_one_node, 1),\n+\t  TREE_OPERAND (exp, 1), 0), target, tmode, modifier);\n+\n     default:\n       break;\n     }"}, {"sha": "7486a5430b186ade26f0a5b25d49f2fced78be3f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -2823,17 +2823,7 @@ build_new (placement, decl, init, use_global_new)\n     }\n \n   if (flag_check_new && rval)\n-    {\n-      /* For array new, we need to make sure that the call to new is\n-\t not expanded as part of the RTL_EXPR for the initialization,\n-\t so we can't just use save_expr here.  */\n-\n-      alloc_temp = build (VAR_DECL, TREE_TYPE (rval));\n-      layout_decl (alloc_temp, 0);\n-      alloc_expr = build (TARGET_EXPR, TREE_TYPE (rval), alloc_temp, rval, 0);\n-      TREE_SIDE_EFFECTS (alloc_expr) = 1;\n-      rval = alloc_temp;\n-    }\n+    alloc_expr = rval = save_expr (rval);\n   else\n     alloc_expr = NULL_TREE;\n \n@@ -2930,6 +2920,10 @@ build_new (placement, decl, init, use_global_new)\n \t  else\n \t    rval = error_mark_node;\n \t}\n+      else\n+\trval = build (VEC_INIT_EXPR, TREE_TYPE (rval),\n+\t\t      save_expr (rval), init, nelts);\n+#if 0\t\n       else if (current_function_decl == NULL_TREE)\n \t{\n \t  extern tree static_aggregates;\n@@ -3010,23 +3004,19 @@ build_new (placement, decl, init, use_global_new)\n \t    }\n \t  rval = xval;\n \t}\n+#endif\n     }\n   else if (TYPE_READONLY (true_type))\n     cp_error (\"uninitialized const in `new' of `%#T'\", true_type);\n \n  done:\n \n-  if (alloc_expr)\n+  if (alloc_expr && rval != alloc_expr)\n     {\n       /* Did we modify the storage?  */\n-      if (rval != alloc_temp)\n-\t{\n-\t  tree ifexp = build_binary_op (NE_EXPR, alloc_expr,\n-\t\t\t\t\tinteger_zero_node, 1);\n-\t  rval = build_conditional_expr (ifexp, rval, alloc_temp);\n-\t}\n-      else\n-\trval = alloc_expr;\n+      tree ifexp = build_binary_op (NE_EXPR, alloc_expr,\n+\t\t\t\t    integer_zero_node, 1);\n+      rval = build_conditional_expr (ifexp, rval, alloc_expr);\n     }\n \n   if (rval && TREE_TYPE (rval) != build_pointer_type (type))"}, {"sha": "50b71a740896d96da51ba18b53bf2097b982e6d1", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 53, "deletions": 87, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -1743,7 +1743,8 @@ check_for_missing_semicolon (type)\n   if ((yychar > 255\n        && yychar != SCSPEC\n        && yychar != IDENTIFIER\n-       && yychar != TYPENAME)\n+       && yychar != TYPENAME\n+       && yychar != SELFNAME)\n       || end_of_file)\n     {\n       if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (type)))\n@@ -1911,12 +1912,6 @@ check_newline ()\n \t      && getch () == 'm'\n \t      && getch () == 'a')\n \t    {\n-\t      c = getch ();\n-\t      while (c == ' ' || c == '\\t')\n-\t\tc = getch ();\n-\t      put_back (c);\n-\t      if (c == '\\n' || c == EOF)\n-\t\tgoto skipline;\n \t      token = real_yylex ();\n \t      if (token == IDENTIFIER\n \t\t  && TREE_CODE (yylval.ttype) == IDENTIFIER_NODE)\n@@ -1999,15 +1994,9 @@ check_newline ()\n \t      /* Here we have just seen `#ident '.\n \t\t A string constant should follow.  */\n \n-\t      while (c == ' ' || c == '\\t')\n-\t\tc = getch ();\n-\n-\t      /* If no argument, ignore the line.  */\n-\t      if (c == EOF)\n-\t\tgoto skipline;\n-\n-\t      put_back (c);\n \t      token = real_yylex ();\n+\t      if (token == END_OF_LINE)\n+\t\tgoto skipline;\n \t      if (token != STRING\n \t\t  || TREE_CODE (yylval.ttype) != STRING_CST)\n \t\t{\n@@ -2281,6 +2270,7 @@ check_newline ()\n  skipline:\n   linemode = 0;\n   end_of_file = 0;\n+  nextchar = -1;\n   while ((c = getch ()) != EOF && c != '\\n');\n   return c;\n }\n@@ -2471,6 +2461,10 @@ identifier_type (decl)\n     return NSNAME;\n   if (TREE_CODE (decl) != TYPE_DECL)\n     return IDENTIFIER;\n+  if (((got_scope && TREE_TYPE (decl) == got_scope)\n+       || TREE_TYPE (decl) == current_class_type)\n+      && DECL_ARTIFICIAL (decl))\n+    return SELFNAME;\n   return TYPENAME;\n }\n \n@@ -4389,7 +4383,6 @@ handle_cp_pragma (pname)\n      char *pname;\n {\n   register int token;\n-  register int c;\n \n   if (! strcmp (pname, \"vtable\"))\n     {\n@@ -4412,10 +4405,8 @@ handle_cp_pragma (pname)\n \t= perm_tree_cons (NULL_TREE,\n \t\t\t  get_identifier (TREE_STRING_POINTER (yylval.ttype)),\n \t\t\t  pending_vtables);\n-      if (nextchar < 0)\n-\tnextchar = getch ();\n-      c = nextchar;\n-      if (c != EOF)\n+      token = real_yylex ();\n+      if (token != END_OF_LINE)\n \twarning (\"trailing characters ignored\");\n       return 1;\n     }\n@@ -4428,10 +4419,8 @@ handle_cp_pragma (pname)\n \t  error (\"invalid #pragma unit\");\n \t  return -1;\n \t}\n-      if (nextchar < 0)\n-\tnextchar = getch ();\n-      c = nextchar;\n-      if (c != EOF)\n+      token = real_yylex ();\n+      if (token != END_OF_LINE)\n \twarning (\"trailing characters ignored\");\n       return 1;\n     }\n@@ -4443,60 +4432,49 @@ handle_cp_pragma (pname)\n \n       main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n \n-      do\n-\t{\n-\t  c = getch ();\n-\t} while (c == ' ' || c == '\\t');\n-\n-      if (c != EOF)\n+      token = real_yylex ();\n+      \n+      if (token != END_OF_LINE)\n \t{\n-\t  put_back (c);\n-\t  token = real_yylex ();\n \t  if (token != STRING\n \t      || TREE_CODE (yylval.ttype) != STRING_CST)\n \t    {\n \t      error (\"invalid `#pragma interface'\");\n \t      return -1;\n \t    }\n \t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n-\t  c = getch();\n-\t  put_back (c);\n-\n-\t  while (c == ' ' || c == '\\t')\n-\t    c = getch ();\n-\n-\t  while (c != EOF)\n+\t}\n+      \n+      while (token != END_OF_LINE)\n+\t{\n+\t  if (!warned_already && extra_warnings)\n \t    {\n-\t      if (!warned_already && extra_warnings\n-\t\t  && c != ' ' && c != '\\t')\n-\t\t{\n-\t\t  warning (\"garbage after `#pragma interface' ignored\");\n-\t\t  warned_already = 1;\n-\t\t}\n-\t      c = getch ();\n+\t      warning (\"garbage after `#pragma interface' ignored\");\n+\t      warned_already = 1;\n \t    }\n+\t  token = real_yylex ();\n+\t}\n \n-\t  write_virtuals = 3;\n+      write_virtuals = 3;\n \n-\t  if (impl_file_chain == 0)\n-\t    {\n-\t      /* If this is zero at this point, then we are\n-\t\t auto-implementing.  */\n-\t      if (main_input_filename == 0)\n-\t\tmain_input_filename = input_filename;\n+      if (impl_file_chain == 0)\n+\t{\n+\t  /* If this is zero at this point, then we are\n+\t     auto-implementing.  */\n+\t  if (main_input_filename == 0)\n+\t    main_input_filename = input_filename;\n \n #ifdef AUTO_IMPLEMENT\n-\t      filename = FILE_NAME_NONDIRECTORY (main_input_filename);\n-\t      fi = get_time_identifier (filename);\n-\t      fi = IDENTIFIER_CLASS_VALUE (fi);\n-\t      TREE_INT_CST_LOW (fi) = 0;\n-\t      TREE_INT_CST_HIGH (fi) = 1;\n-\t      /* Get default.  */\n-\t      impl_file_chain = (struct impl_files *)permalloc (sizeof (struct impl_files));\n-\t      impl_file_chain->filename = filename;\n-\t      impl_file_chain->next = 0;\n+\t  filename = FILE_NAME_NONDIRECTORY (main_input_filename);\n+\t  fi = get_time_identifier (filename);\n+\t  fi = IDENTIFIER_CLASS_VALUE (fi);\n+\t  TREE_INT_CST_LOW (fi) = 0;\n+\t  TREE_INT_CST_HIGH (fi) = 1;\n+\t  /* Get default.  */\n+\t  impl_file_chain = (struct impl_files *)permalloc (sizeof (struct impl_files));\n+\t  impl_file_chain->filename = filename;\n+\t  impl_file_chain->next = 0;\n #endif\n-\t    }\n \t}\n \n       interface_only = interface_strcmp (main_filename);\n@@ -4514,28 +4492,25 @@ handle_cp_pragma (pname)\n \n       main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n       token = real_yylex ();\n-      if (token != STRING\n-\t  || TREE_CODE (yylval.ttype) != STRING_CST)\n+      if (token != END_OF_LINE)\n \t{\n-\t  error (\"invalid `#pragma implementation'\");\n-\t  return -1;\n+\t  if (token != STRING\n+\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t    {\n+\t      error (\"invalid `#pragma implementation'\");\n+\t      return -1;\n+\t    }\n+\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n \t}\n-      main_filename = TREE_STRING_POINTER (yylval.ttype);\n-      c = getch();\n-      put_back (c);\n \n-      while (c == ' ' || c == '\\t')\n-\tc = getch ();\n-\n-      while (c != EOF)\n+      while (token != END_OF_LINE)\n \t{\n-\t  if (!warned_already && extra_warnings\n-\t      && c != ' ' && c != '\\t')\n+\t  if (!warned_already && extra_warnings)\n \t    {\n \t      warning (\"garbage after `#pragma implementation' ignored\");\n \t      warned_already = 1;\n \t    }\n-\t  c = getch ();\n+\t  token = real_yylex ();\n \t}\n \n       if (write_virtuals == 3)\n@@ -4610,38 +4585,29 @@ handle_sysv_pragma (finput, token)\n \tcase STRING:\n \tcase CONSTANT:\n \t  handle_pragma_token (\"ignored\", yylval.ttype);\n-\t  token = yylex ();\n \t  break;\n \tcase '(':\n \t  handle_pragma_token (\"(\", NULL_TREE);\n-\t  token = yylex ();\n \t  break;\n \tcase ')':\n \t  handle_pragma_token (\")\", NULL_TREE);\n-\t  token = yylex ();\n \t  break;\n \tcase ',':\n \t  handle_pragma_token (\",\", NULL_TREE);\n-\t  token = yylex ();\n \t  break;\n \tcase '=':\n \t  handle_pragma_token (\"=\", NULL_TREE);\n-\t  token = yylex ();\n \t  break;\n \tcase LEFT_RIGHT:\n \t  handle_pragma_token (\"(\", NULL_TREE);\n \t  handle_pragma_token (\")\", NULL_TREE);\n-\t  token = yylex ();\n \t  break;\n \tcase END_OF_LINE:\n-\t  handle_pragma_token (NULL_PTR, NULL_TREE);\n-\t  return 1;\n \tdefault:\n \t  handle_pragma_token (NULL_PTR, NULL_TREE);\n-\t  while (yylex () != END_OF_LINE)\n-\t    /* continue */;\n \t  return 1;\n \t}\n+      token = real_yylex ();\n     }\n }\n #endif /* HANDLE_SYSV_PRAGMA */"}, {"sha": "cdddeaf19a24b48d620674990d1d9f80c817f113", "filename": "gcc/cp/method.c", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -1819,7 +1819,7 @@ make_thunk (function, delta)\n       DECL_INITIAL (thunk) = function;\n       THUNK_DELTA (thunk) = delta;\n       DECL_EXTERNAL (thunk) = 1;\n-      TREE_PUBLIC (thunk) = 1;\n+      TREE_PUBLIC (thunk) = 0;\n       /* So that finish_file can write out any thunks that need to be: */\n       pushdecl_top_level (thunk);\n     }\n@@ -1831,12 +1831,12 @@ emit_thunk (thunk_fndecl)\n   tree thunk_fndecl;\n {\n   rtx insns;\n-  char *fnname;\n   char buffer[250];\n   tree argp;\n   struct args_size stack_args_size;\n   tree function = TREE_OPERAND (DECL_INITIAL (thunk_fndecl), 0);\n   int delta = THUNK_DELTA (thunk_fndecl);\n+  char *fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n   int tem;\n   int failure = 0;\n \n@@ -1856,16 +1856,14 @@ emit_thunk (thunk_fndecl)\n \n   TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n \n-  if (! TREE_PUBLIC (function))\n-    TREE_PUBLIC (thunk_fndecl) = 0;\n-  if (DECL_EXTERNAL (function))\n-    return;\n-  DECL_EXTERNAL (thunk_fndecl) = 0;\n-\n   decl_printable_name = thunk_printable_name;\n   if (current_function_decl)\n     abort ();\n   current_function_decl = thunk_fndecl;\n+#ifdef ASM_OUTPUT_MI_THUNK\n+  assemble_start_function (thunk_fndecl, fnname);\n+  ASM_OUTPUT_MI_THUNK (asm_out_file, thunk_fndecl, delta, function);\n+#else\n   init_function_start (thunk_fndecl, input_filename, lineno);\n   pushlevel (0);\n   expand_start_bindings (1);\n@@ -2031,12 +2029,9 @@ emit_thunk (thunk_fndecl)\n \n   /* Now turn the rtl into assembler code.  */\n \n-    {\n-      char *fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n-      assemble_start_function (thunk_fndecl, fnname);\n-      final (insns, asm_out_file, optimize, 0);\n-      assemble_end_function (thunk_fndecl, fnname);\n-    };\n+  assemble_start_function (thunk_fndecl, fnname);\n+  final (insns, asm_out_file, optimize, 0);\n+  assemble_end_function (thunk_fndecl, fnname);\n \n  exit_rest_of_compilation:\n \n@@ -2047,6 +2042,7 @@ emit_thunk (thunk_fndecl)\n   resume_temporary_allocation ();\n \n   decl_printable_name = save_decl_printable_name;\n+#endif /* ASM_OUTPUT_MI_THUNK */\n   current_function_decl = 0;\n }\n \f"}, {"sha": "6883572be9ba3646c1d6e8f4331152a56c9df285", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 63, "deletions": 72, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -108,6 +108,7 @@ empty_parms ()\n    In some contexts, they are treated just like IDENTIFIER,\n    but they can also serve as typespecs in declarations.  */\n %token TYPENAME\n+%token SELFNAME\n \n /* Reserved words that specify storage class.\n    yylval contains an IDENTIFIER_NODE which indicates which one.  */\n@@ -160,7 +161,7 @@ empty_parms ()\n %nonassoc IF\n %nonassoc ELSE\n \n-%left IDENTIFIER TYPENAME PTYPENAME SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD\n+%left IDENTIFIER TYPENAME SELFNAME PTYPENAME SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD\n \n %left '{' ',' ';'\n \n@@ -191,7 +192,7 @@ empty_parms ()\n %type <code> unop\n \n %type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist\n-%type <ttype> paren_expr_or_null nontrivial_exprlist\n+%type <ttype> paren_expr_or_null nontrivial_exprlist SELFNAME\n %type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n %type <ttype> typed_declspecs reserved_declspecs boolean.literal\n %type <ttype> typed_typespecs reserved_typespecquals\n@@ -230,7 +231,7 @@ empty_parms ()\n %token <ttype> TYPENAME_ELLIPSIS PTYPENAME\n %token <ttype> PRE_PARSED_FUNCTION_DECL EXTERN_LANG_STRING ALL\n %token <ttype> PRE_PARSED_CLASS_DECL\n-%type <ttype> fn.def1 /* Not really! */\n+%type <ttype> fn.def1 /* Not really! */ component_constructor_declarator\n %type <ttype> fn.def2 return_id fn.defpen constructor_declarator\n %type <itype> ctor_initializer_opt\n %type <ttype> named_class_head named_class_head_sans_basetype\n@@ -552,7 +553,7 @@ fndef:\n \t;\n \n constructor_declarator:\n-\t  nested_name_specifier type_name '(' \n+\t  nested_name_specifier SELFNAME '(' \n \t\t{\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n \t\t  if ($1 != current_class_type)\n@@ -563,7 +564,7 @@ constructor_declarator:\n \t\t}\n \t  parmlist ')' type_quals\n \t\t{ $$ = build_parse_node (CALL_EXPR, $<ttype>4, $5, $7); }\n-\t| nested_name_specifier type_name LEFT_RIGHT type_quals\n+\t| nested_name_specifier SELFNAME LEFT_RIGHT type_quals\n \t\t{\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n \t\t  if ($1 != current_class_type)\n@@ -573,7 +574,7 @@ constructor_declarator:\n \t\t    }\n \t\t  $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $4);\n \t\t}\n-\t| global_scope nested_name_specifier type_name '(' \n+\t| global_scope nested_name_specifier SELFNAME '(' \n \t\t{\n \t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n \t\t  if ($2 != current_class_type)\n@@ -584,7 +585,7 @@ constructor_declarator:\n \t\t}\n \t parmlist ')' type_quals\n \t\t{ $$ = build_parse_node (CALL_EXPR, $<ttype>5, $6, $8); }\n-\t| global_scope nested_name_specifier type_name LEFT_RIGHT type_quals\n+\t| global_scope nested_name_specifier SELFNAME LEFT_RIGHT type_quals\n \t\t{\n \t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n \t\t  if ($2 != current_class_type)\n@@ -630,26 +631,27 @@ fn.def1:\n \t\t  $$ = NULL_TREE; }\n \t;\n \n+component_constructor_declarator:\n+\t  SELFNAME '(' parmlist ')' type_quals\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $1, $3, $5); }\n+\t| SELFNAME LEFT_RIGHT type_quals\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $1, empty_parms (), $3); }\n+\t;\n+\n /* more C++ complexity.  See component_decl for a comment on the\n    reduce/reduce conflict introduced by these rules.  */\n fn.def2:\n-\t  typed_declspecs '(' parmlist ')' type_quals exception_specification_opt\n+\t  declmods component_constructor_declarator exception_specification_opt\n \t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs), $3, $5);\n-\t\t  $$ = start_method (TREE_CHAIN (specs), $$, $6);\n+\t\t  $$ = start_method (specs, $2, $3);\n \t\t rest_of_mdef:\n \t\t  if (! $$)\n \t\t    YYERROR1;\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n \t\t  reinit_parse_for_method (yychar, $$); }\n-\t| typed_declspecs LEFT_RIGHT type_quals exception_specification_opt\n-\t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),\n-\t\t\t\t\t empty_parms (), $3);\n-\t\t  $$ = start_method (TREE_CHAIN (specs), $$, $4);\n-\t\t  goto rest_of_mdef;\n-\t\t}\n+\t| component_constructor_declarator exception_specification_opt\n+\t\t{ $$ = start_method (NULL_TREE, $1, $2); goto rest_of_mdef; }\n \t| typed_declspecs declarator exception_specification_opt\n \t\t{ tree specs = strip_attrs ($1);\n \t\t  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }\n@@ -757,6 +759,7 @@ member_init: '(' nonnull_exprlist ')'\n identifier:\n \t  IDENTIFIER\n \t| TYPENAME\n+\t| SELFNAME\n \t| PTYPENAME\n \t| NSNAME\n \t;\n@@ -823,6 +826,18 @@ template_type:\n \t\t  if ($$ != error_mark_node)\n \t\t    $$ = TYPE_STUB_DECL ($$);\n \t\t}\n+\t| SELFNAME  '<' template_arg_list template_close_bracket\n+\t\t{\n+\t\t  $$ = lookup_template_class ($1, $3, NULL_TREE);\n+\t\t  if ($$ != error_mark_node)\n+\t\t    $$ = TYPE_STUB_DECL ($$);\n+\t\t}\n+\t| SELFNAME '<' template_close_bracket\n+\t\t{\n+\t\t  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);\n+\t\t  if ($$ != error_mark_node)\n+\t\t    $$ = TYPE_STUB_DECL ($$);\n+\t\t}\n \t;\n \n template_close_bracket:\n@@ -1192,6 +1207,7 @@ notype_unqualified_id:\n unqualified_id:\n \t  notype_unqualified_id\n \t| TYPENAME\n+\t| SELFNAME\n \t;\n \n expr_or_declarator:\n@@ -2305,6 +2321,10 @@ base_class:\n \n base_class.1:\n \t  complete_type_name\n+\t| TYPENAME_KEYWORD nested_name_specifier identifier\n+\t\t{ $$ = TYPE_MAIN_DECL (make_typename_type ($2, $3)); }\n+\t| TYPENAME_KEYWORD global_scope nested_name_specifier identifier\n+\t\t{ $$ = TYPE_MAIN_DECL (make_typename_type ($3, $4)); }\n \t| SIGOF '(' expr ')'\n \t\t{\n \t\t  if (current_aggr == signature_type_node)\n@@ -2574,34 +2594,13 @@ component_decl_1:\n \t   should \"A::foo\" be declared as a function or \"A::bar\" as a data\n \t   member? In other words, is \"bar\" an after_type_declarator or a\n \t   parmlist? */\n-\t| typed_declspecs '(' parmlist ')' type_quals exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t| declmods component_constructor_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n \t\t{ tree specs, attrs;\n \t\t  split_specs_attrs ($1, &specs, &attrs);\n-\t\t  if (TREE_VALUE (specs) == current_class_type)\n-\t\t    {\n-\t\t      if (TREE_CHAIN (specs) == NULL_TREE)\n-\t\t        specs = get_decl_list (current_class_name);\n-\t\t      else\n-\t\t        TREE_VALUE (specs) = current_class_name;\n-\t\t    } \n-\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),\n-\t\t\t\t\t $3, $5);\n-\t\t  $$ = grokfield ($$, TREE_CHAIN (specs), $6, $9, $7,\n-\t\t\t\t  build_tree_list ($8, attrs)); }\n-\t| typed_declspecs LEFT_RIGHT type_quals exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n-\t\t  if (TREE_VALUE (specs) == current_class_type)\n-\t\t    {\n-\t\t      if (TREE_CHAIN (specs) == NULL_TREE)\n-\t\t        specs = get_decl_list (current_class_name);\n-\t\t      else\n-\t\t        TREE_VALUE (specs) = current_class_name;\n-\t\t    } \n-\t\t  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),\n-\t\t\t\t\t empty_parms (), $3);\n-\t\t  $$ = grokfield ($$, TREE_CHAIN (specs), $4, $7, $5,\n-\t\t\t\t  build_tree_list ($6, attrs)); }\n+\t\t  $$ = grokfield ($2, specs, $3, $6, $4,\n+\t\t\t\t  build_tree_list ($5, attrs)); }\n+\t| component_constructor_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $2, $5, $3, $4); }\n \t| using_decl\n \t\t{ $$ = do_class_using_decl ($1); }\n \t;\n@@ -2808,7 +2807,6 @@ complete_type_name:\n \t\t    {\n \t\t      if (current_class_type\n \t\t\t  && TYPE_BEING_DEFINED (current_class_type)\n-\t\t\t  && ! TREE_MANGLED ($1)\n \t\t\t  && ! IDENTIFIER_CLASS_VALUE ($1))\n \t\t\t{\n \t\t\t  /* Be sure to get an inherited typedef.  */\n@@ -2826,16 +2824,7 @@ complete_type_name:\n \t| global_scope type_name\n \t\t{\n \t\t  if (TREE_CODE ($2) == IDENTIFIER_NODE)\n-\t\t    {\n-\t\t      if (current_class_type\n-\t\t\t  && TYPE_BEING_DEFINED (current_class_type)\n-\t\t\t  && ! TREE_MANGLED ($2)\n-\t\t\t  && ! IDENTIFIER_CLASS_VALUE ($2))\n-\t\t\t/* Be sure to get an inherited typedef.  */\n-\t\t\t$$ = lookup_name ($2, 1);\n-\t\t      else\n-\t\t        $$ = identifier_typedecl_value ($2);\n-\t\t    }\n+\t\t    $$ = identifier_typedecl_value ($2);\n \t\t  else\n \t\t    $$ = $2;\n \t\t  got_scope = NULL_TREE;\n@@ -2948,6 +2937,7 @@ functional_cast:\n \n type_name:\n \t  TYPENAME\n+\t| SELFNAME\n \t| template_type %prec EMPTY\n \t;\n \n@@ -2962,14 +2952,22 @@ nested_name_specifier:\n nested_name_specifier_1:\n \t  TYPENAME SCOPE\n \t\t{\n-\t\t  $$ = lastiddecl;\n-\t\t  /* Remember that this name has been used in the class\n-\t\t     definition, as per [class.scope0] */\n-\t\t  if (current_class_type\n-\t\t      && TYPE_BEING_DEFINED (current_class_type)\n-\t\t      && ! TREE_MANGLED ($1)\n-\t\t      && ! IDENTIFIER_CLASS_VALUE ($1))\n-\t\t    pushdecl_class_level ($$);\n+\t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n+\t\t    {\n+\t\t      $$ = lastiddecl;\n+\t\t      /* Remember that this name has been used in the class\n+\t\t\t definition, as per [class.scope0] */\n+\t\t      if (current_class_type\n+\t\t\t  && TYPE_BEING_DEFINED (current_class_type)\n+\t\t\t  && ! IDENTIFIER_CLASS_VALUE ($1))\n+\t\t\tpushdecl_class_level ($$);\n+\t\t    }\n+\t\t  got_scope = $$ = TREE_TYPE ($$);\n+\t\t}\n+\t| SELFNAME SCOPE\n+\t\t{\n+\t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n+\t\t    $$ = lastiddecl;\n \t\t  got_scope = $$ = TREE_TYPE ($$);\n \t\t}\n \t| NSNAME SCOPE\n@@ -2992,16 +2990,7 @@ complex_type_name:\n \t  global_scope type_name\n \t\t{\n \t\t  if (TREE_CODE ($2) == IDENTIFIER_NODE)\n-\t\t    {\n-\t\t      if (current_class_type\n-\t\t\t  && TYPE_BEING_DEFINED (current_class_type)\n-\t\t\t  && ! TREE_MANGLED ($2)\n-\t\t\t  && ! IDENTIFIER_CLASS_VALUE ($2))\n-\t\t\t/* Be sure to get an inherited typedef.  */\n-\t\t\t$$ = lookup_name ($2, 1);\n-\t\t      else\n-\t\t        $$ = identifier_typedecl_value ($2);\n-\t\t    }\n+\t\t    $$ = identifier_typedecl_value ($2);\n \t\t  else\n \t\t    $$ = $2;\n \t\t  got_scope = NULL_TREE;\n@@ -3675,6 +3664,8 @@ label_colon:\n \t\t{ goto do_label; }\n \t| TYPENAME ':'\n \t\t{ goto do_label; }\n+\t| SELFNAME ':'\n+\t\t{ goto do_label; }\n \t;\n \n for.init.statement:"}, {"sha": "eaac1f12de1db746843effb46ad4d635eff542b0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -1578,7 +1578,6 @@ tsubst (t, args, nargs, in_decl)\n \ttree r = copy_node (t);\n \tTREE_TYPE (r) = type;\n \tDECL_CONTEXT (r) = current_class_type;\n-\tset_nested_typename (r, current_class_type != NULL_TREE ? TYPE_NESTED_NAME (current_class_type) : current_class_name, DECL_NAME (r), type);\n \tTREE_CHAIN (r) = NULL_TREE;\n \treturn r;\n       }\t  "}, {"sha": "45de00fec2997738bcc37a4801e43fa5f92dc97b", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -320,6 +320,18 @@ throw_bad_cast ()\n   return d;\n }\n \n+/* Check whether TEST is null before returning RESULT.  If TEST is used in\n+   RESULT, it must have previously had a save_expr applied to it.  */\n+\n+tree ifnonnull (test, result)\n+     tree test, result;\n+{\n+  return build (COND_EXPR, TREE_TYPE (result),\n+\t\tbuild (EQ_EXPR, boolean_type_node, test, integer_zero_node),\n+\t\tconvert (TREE_TYPE (result), integer_zero_node),\n+\t\tresult);\n+}\n+\n /* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working\n    paper.  */\n \n@@ -406,6 +418,7 @@ build_dynamic_cast (type, expr)\n   /* Otherwise *exprtype must be a polymorphic class (have a vtbl).  */\n   if (TYPE_VIRTUAL_P (TREE_TYPE (exprtype)))\n     {\n+      tree expr1;\n       /* if TYPE is `void *', return pointer to complete object.  */\n       if (tc == POINTER_TYPE\n \t  && TYPE_MAIN_VARIANT (TREE_TYPE (type)) == void_type_node)\n@@ -416,15 +429,18 @@ build_dynamic_cast (type, expr)\n \t      && TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == RECORD_TYPE)\n \t    return build1 (NOP_EXPR, type, expr);\n \n-\t  expr = build_headof (expr);\n-\t  if (TREE_TYPE (expr) != type)\n-\t    expr = build1 (NOP_EXPR, type, expr);\n-\t  return expr;\n+\t  /* Since expr is used twice below, save it.  */\n+\t  expr = save_expr (expr);\n+\n+\t  expr1 = build_headof (expr);\n+\t  if (TREE_TYPE (expr1) != type)\n+\t    expr1 = build1 (NOP_EXPR, type, expr1);\n+\t  return ifnonnull (expr, expr1);\n \t}\n       else\n \t{\n \t  tree retval;\n-          tree result, td1, td2, td3, elems, expr1, expr2;\n+          tree result, td1, td2, td3, elems, expr2;\n \n  \t  /* If we got here, we can't convert statically.  Therefore,\n \t     dynamic_cast<D&>(b) (b an object) cannot succeed.  */\n@@ -522,7 +538,7 @@ build_dynamic_cast (type, expr)\n \n \t  /* Now back to the type we want from a void*. */\n \t  result = convert (type, result);\n-          return result;\n+          return ifnonnull (expr, result);\n \t}\n     }\n \n@@ -603,7 +619,6 @@ expand_class_desc (tdecl, type)\n      tree tdecl;\n      tree type;\n {\n-  tree tname = TYPE_NESTED_NAME (type);\n   tree name_string;\n   tree fn, tmp;\n   char *name;"}, {"sha": "ff65d3395eb51e9e4552170e72ac35b22f6094d2", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -291,6 +291,7 @@ yylex ()\n \t  switch (tmp_token.yychar)\n \t    {\n \t    case TYPENAME:\n+\t    case SELFNAME:\n \t      lastiddecl = identifier_typedecl_value (tmp_token.yylval.ttype);\n \t      if (lastiddecl != trrr)\n \t\t{"}, {"sha": "6db10690b5036acd4ad4aee400b5d2b79ccceab9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -1073,17 +1073,9 @@ get_identifier_list (value)\n \tlist = tree_cons (NULL_TREE, value, NULL_TREE);\n       else\n \t{\n-\t  register tree id;\n-\t  /* This will return the correct thing for regular types,\n-\t     nested types, and templates.  Yay! */\n-\t  if (TYPE_NESTED_NAME (type))\n-\t    id = TYPE_NESTED_NAME (type);\n-\t  else\n-\t    id = TYPE_IDENTIFIER (type);\n-\n-\t  if (CLASSTYPE_ID_AS_LIST (type) == NULL_TREE)\n+\t  if (! CLASSTYPE_ID_AS_LIST (type))\n \t    CLASSTYPE_ID_AS_LIST (type)\n-\t      = perm_tree_cons (NULL_TREE, id, NULL_TREE);\n+\t      = perm_tree_cons (NULL_TREE, TYPE_IDENTIFIER (type), NULL_TREE);\n \t  list = CLASSTYPE_ID_AS_LIST (type);\n \t}\n     }"}, {"sha": "85accd8a657a1551b6badd190fc3e803547875a2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a80e41955ad1262ea9e923ca6ea3044fe005e8fa/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a80e41955ad1262ea9e923ca6ea3044fe005e8fa", "patch": "@@ -5088,15 +5088,19 @@ build_reinterpret_cast (type, expr)\n {\n   tree intype = TREE_TYPE (expr);\n \n-  if (TYPE_PTRMEMFUNC_P (type))\n-    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-\n   if (current_template_parms)\n     {\n       tree t = build_min (REINTERPRET_CAST_EXPR, type, expr);\n       return t;\n     }\n \n+  if (TYPE_PTRMEMFUNC_P (type))\n+    if (TYPE_PTRMEMFUNC_P (intype))\n+      return build1 (NOP_EXPR, type, expr);\n+\n+  if (TYPE_PTRMEMFUNC_P (type))\n+    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+\n   if (TYPE_PTRMEMFUNC_P (intype))\n     intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n "}]}