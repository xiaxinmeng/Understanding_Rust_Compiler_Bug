{"sha": "848bb6fc0e502345536b25e1a110eb7f01eccbc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ4YmI2ZmMwZTUwMjM0NTUzNmIyNWUxYTExMGViN2YwMWVjY2JjMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-02-13T08:34:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-02-13T08:34:42Z"}, "message": "re PR middle-end/84309 (Wrong-code with -ffast-math)\n\n\tPR middle-end/84309\n\t* match.pd (pow(C,x) -> exp(log(C)*x)): Optimize instead into\n\texp2(log2(C)*x) if C is a power of 2 and c99 runtime is available.\n\t* generic-match-head.c (canonicalize_math_after_vectorization_p): New\n\tinline function.\n\t* gimple-match-head.c (canonicalize_math_after_vectorization_p): New\n\tinline function.\n\t* omp-simd-clone.h: New file.\n\t* omp-simd-clone.c: Include omp-simd-clone.h.\n\t(expand_simd_clones): No longer static.\n\t* tree-vect-patterns.c: Include fold-const-call.h, attribs.h,\n\tcgraph.h and omp-simd-clone.h.\n\t(vect_recog_pow_pattern): Optimize pow(C,x) to exp(log(C)*x).\n\t(vect_recog_widen_shift_pattern): Formatting fix.\n\t(vect_pattern_recog_1): Don't check optab for calls.\n\n\t* gcc.dg/pr84309.c: New test.\n\t* gcc.target/i386/pr84309.c: New test.\n\nFrom-SVN: r257617", "tree": {"sha": "d7abb7ffececb36706b28e05151701a372dc8cc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7abb7ffececb36706b28e05151701a372dc8cc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/848bb6fc0e502345536b25e1a110eb7f01eccbc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848bb6fc0e502345536b25e1a110eb7f01eccbc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/848bb6fc0e502345536b25e1a110eb7f01eccbc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848bb6fc0e502345536b25e1a110eb7f01eccbc1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f4b29321048fa82c754f04814dbd46d92773e72a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b29321048fa82c754f04814dbd46d92773e72a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4b29321048fa82c754f04814dbd46d92773e72a"}], "stats": {"total": 233, "additions": 204, "deletions": 29}, "files": [{"sha": "cd4a1c5327b00401e181b0f24caf74f77ad7ec96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=848bb6fc0e502345536b25e1a110eb7f01eccbc1", "patch": "@@ -1,5 +1,21 @@\n 2018-02-13  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/84309\n+\t* match.pd (pow(C,x) -> exp(log(C)*x)): Optimize instead into\n+\texp2(log2(C)*x) if C is a power of 2 and c99 runtime is available.\n+\t* generic-match-head.c (canonicalize_math_after_vectorization_p): New\n+\tinline function.\n+\t* gimple-match-head.c (canonicalize_math_after_vectorization_p): New\n+\tinline function.\n+\t* omp-simd-clone.h: New file.\n+\t* omp-simd-clone.c: Include omp-simd-clone.h.\n+\t(expand_simd_clones): No longer static.\n+\t* tree-vect-patterns.c: Include fold-const-call.h, attribs.h,\n+\tcgraph.h and omp-simd-clone.h.\n+\t(vect_recog_pow_pattern): Optimize pow(C,x) to exp(log(C)*x).\n+\t(vect_recog_widen_shift_pattern): Formatting fix.\n+\t(vect_pattern_recog_1): Don't check optab for calls.\n+\n \tPR target/84336\n \t* config/i386/sse.md (<avx512>_vpermi2var<mode>3_mask): Force\n \toperands[2] into a REG before using gen_lowpart on it."}, {"sha": "f7b6b1f23c58d92fda6f6b9f36da7b35778e028f", "filename": "gcc/generic-match-head.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=848bb6fc0e502345536b25e1a110eb7f01eccbc1", "patch": "@@ -68,3 +68,12 @@ canonicalize_math_p ()\n {\n   return true;\n }\n+\n+/* Return true if math operations that are beneficial only after\n+   vectorization should be canonicalized.  */\n+\n+static inline bool\n+canonicalize_math_after_vectorization_p ()\n+{\n+  return false;\n+}"}, {"sha": "172ef0a6909eb23c48ef95aacf07867ed68f2a74", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=848bb6fc0e502345536b25e1a110eb7f01eccbc1", "patch": "@@ -831,3 +831,12 @@ canonicalize_math_p ()\n {\n   return !cfun || (cfun->curr_properties & PROP_gimple_opt_math) == 0;\n }\n+\n+/* Return true if math operations that are beneficial only after\n+   vectorization should be canonicalized.  */\n+\n+static inline bool\n+canonicalize_math_after_vectorization_p ()\n+{\n+  return !cfun || (cfun->curr_properties & PROP_gimple_lvec) != 0;\n+}"}, {"sha": "833effa9b67119f7c829a7a7ea452afb356dcc09", "filename": "gcc/match.pd", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=848bb6fc0e502345536b25e1a110eb7f01eccbc1", "patch": "@@ -3992,15 +3992,36 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (logs (pows @0 @1))\n    (mult @1 (logs @0))))\n \n- /* pow(C,x) -> exp(log(C)*x) if C > 0.  */\n+ /* pow(C,x) -> exp(log(C)*x) if C > 0,\n+    or if C is a positive power of 2,\n+    pow(C,x) -> exp2(log2(C)*x).  */\n  (for pows (POW)\n       exps (EXP)\n       logs (LOG)\n+      exp2s (EXP2)\n+      log2s (LOG2)\n   (simplify\n    (pows REAL_CST@0 @1)\n-    (if (real_compare (GT_EXPR, TREE_REAL_CST_PTR (@0), &dconst0)\n-\t && real_isfinite (TREE_REAL_CST_PTR (@0)))\n-     (exps (mult (logs @0) @1)))))\n+   (if (real_compare (GT_EXPR, TREE_REAL_CST_PTR (@0), &dconst0)\n+\t&& real_isfinite (TREE_REAL_CST_PTR (@0)))\n+    (with {\n+       const REAL_VALUE_TYPE *const value = TREE_REAL_CST_PTR (@0);\n+       bool use_exp2 = false;\n+       if (targetm.libc_has_function (function_c99_misc)\n+\t   && value->cl == rvc_normal)\n+\t {\n+\t   REAL_VALUE_TYPE frac_rvt = *value;\n+\t   SET_REAL_EXP (&frac_rvt, 1);\n+\t   if (real_equal (&frac_rvt, &dconst1))\n+\t     use_exp2 = true;\n+\t }\n+     }\n+     (if (!use_exp2)\n+      (exps (mult (logs @0) @1))\n+      /* As libmvec doesn't have a vectorized exp2, defer optimizing\n+\t this until after vectorization.  */\n+      (if (canonicalize_math_after_vectorization_p ())\n+\t(exps (mult (logs @0) @1))))))))\n \n  (for sqrts (SQRT)\n       cbrts (CBRT)"}, {"sha": "56832ebf22d17af73b6c25e61eec7c71b83a86bc", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=848bb6fc0e502345536b25e1a110eb7f01eccbc1", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"varasm.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"omp-simd-clone.h\"\n \n /* Return the number of elements in vector type VECTYPE, which is associated\n    with a SIMD clone.  At present these always have a constant length.  */\n@@ -1568,7 +1569,7 @@ simd_clone_adjust (struct cgraph_node *node)\n /* If the function in NODE is tagged as an elemental SIMD function,\n    create the appropriate SIMD clones.  */\n \n-static void\n+void\n expand_simd_clones (struct cgraph_node *node)\n {\n   tree attr = lookup_attribute (\"omp declare simd\","}, {"sha": "c4833e21cfaad64680ea7cbb4f3354132d69c974", "filename": "gcc/omp-simd-clone.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Fomp-simd-clone.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Fomp-simd-clone.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.h?ref=848bb6fc0e502345536b25e1a110eb7f01eccbc1", "patch": "@@ -0,0 +1,26 @@\n+/* OMP constructs' SIMD clone supporting code.\n+\n+   Copyright (C) 2005-2018 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_OMP_SIMD_CLONE_H\n+#define GCC_OMP_SIMD_CLONE_H\n+\n+extern void expand_simd_clones (struct cgraph_node *);\n+\n+#endif /* GCC_OMP_SIMD_CLONE_H */"}, {"sha": "aafa6d3466f5a22ca6cab2cc551abb783c25a431", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=848bb6fc0e502345536b25e1a110eb7f01eccbc1", "patch": "@@ -1,5 +1,9 @@\n 2018-02-13  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/84309\n+\t* gcc.dg/pr84309.c: New test.\n+\t* gcc.target/i386/pr84309.c: New test.\n+\n \tPR target/84336\n \t* gcc.target/i386/pr84336.c: New test.\n "}, {"sha": "6fe774e57cfcb6e66f0aa66390e1307ad6c3f9d1", "filename": "gcc/testsuite/gcc.dg/pr84309.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84309.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84309.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr84309.c?ref=848bb6fc0e502345536b25e1a110eb7f01eccbc1", "patch": "@@ -0,0 +1,14 @@\n+/* PR middle-end/84309 */\n+/* { dg-do run { target c99_runtime } } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+int\n+main ()\n+{\n+  unsigned long a = 1024;\n+  unsigned long b = 16 * 1024;\n+  unsigned long c = __builtin_pow (2, (__builtin_log2 (a) + __builtin_log2 (b)) / 2);\n+  if (c != 4096)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "d1dd6cef815d9225db49cd3cb03e9d89434ff2e1", "filename": "gcc/testsuite/gcc.target/i386/pr84309.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84309.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84309.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84309.c?ref=848bb6fc0e502345536b25e1a110eb7f01eccbc1", "patch": "@@ -0,0 +1,16 @@\n+/* PR middle-end/84309 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -mavx\" } */\n+\n+double pow (double, double) __attribute__((simd));\n+double exp (double) __attribute__((simd));\n+extern double a[1024], b[1024];\n+\n+void\n+foo (void)\n+{\n+  for (int i = 0; i < 1024; ++i)\n+    a[i] = pow (2.0, b[i]);\n+}\n+\n+/* { dg-final { scan-assembler \"_ZGVcN4v_exp\" } } */"}, {"sha": "25a2efb21f8ca062bb0763fdfa7ffcbbfef0ffed", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 83, "deletions": 24, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848bb6fc0e502345536b25e1a110eb7f01eccbc1/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=848bb6fc0e502345536b25e1a110eb7f01eccbc1", "patch": "@@ -41,6 +41,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"internal-fn.h\"\n #include \"case-cfn-macros.h\"\n+#include \"fold-const-call.h\"\n+#include \"attribs.h\"\n+#include \"cgraph.h\"\n+#include \"omp-simd-clone.h\"\n \n /* Pattern recognition functions  */\n static gimple *vect_recog_widen_sum_pattern (vec<gimple *> *, tree *,\n@@ -1049,7 +1053,7 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_in,\n \t\t\ttree *type_out)\n {\n   gimple *last_stmt = (*stmts)[0];\n-  tree base, exp = NULL;\n+  tree base, exp;\n   gimple *stmt;\n   tree var;\n \n@@ -1060,17 +1064,77 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_in,\n     {\n     CASE_CFN_POW:\n     CASE_CFN_POWI:\n-      base = gimple_call_arg (last_stmt, 0);\n-      exp = gimple_call_arg (last_stmt, 1);\n-      if (TREE_CODE (exp) != REAL_CST\n-\t  && TREE_CODE (exp) != INTEGER_CST)\n-        return NULL;\n       break;\n \n     default:\n       return NULL;\n     }\n \n+  base = gimple_call_arg (last_stmt, 0);\n+  exp = gimple_call_arg (last_stmt, 1);\n+  if (TREE_CODE (exp) != REAL_CST\n+      && TREE_CODE (exp) != INTEGER_CST)\n+    {\n+      if (flag_unsafe_math_optimizations\n+\t  && TREE_CODE (base) == REAL_CST\n+\t  && !gimple_call_internal_p (last_stmt))\n+\t{\n+\t  combined_fn log_cfn;\n+\t  built_in_function exp_bfn;\n+\t  switch (DECL_FUNCTION_CODE (gimple_call_fndecl (last_stmt)))\n+\t    {\n+\t    case BUILT_IN_POW:\n+\t      log_cfn = CFN_BUILT_IN_LOG;\n+\t      exp_bfn = BUILT_IN_EXP;\n+\t      break;\n+\t    case BUILT_IN_POWF:\n+\t      log_cfn = CFN_BUILT_IN_LOGF;\n+\t      exp_bfn = BUILT_IN_EXPF;\n+\t      break;\n+\t    case BUILT_IN_POWL:\n+\t      log_cfn = CFN_BUILT_IN_LOGL;\n+\t      exp_bfn = BUILT_IN_EXPL;\n+\t      break;\n+\t    default:\n+\t      return NULL;\n+\t    }\n+\t  tree logc = fold_const_call (log_cfn, TREE_TYPE (base), base);\n+\t  tree exp_decl = builtin_decl_implicit (exp_bfn);\n+\t  /* Optimize pow (C, x) as exp (log (C) * x).  Normally match.pd\n+\t     does that, but if C is a power of 2, we want to use\n+\t     exp2 (log2 (C) * x) in the non-vectorized version, but for\n+\t     vectorization we don't have vectorized exp2.  */\n+\t  if (logc\n+\t      && TREE_CODE (logc) == REAL_CST\n+\t      && exp_decl\n+\t      && lookup_attribute (\"omp declare simd\",\n+\t\t\t\t   DECL_ATTRIBUTES (exp_decl)))\n+\t    {\n+\t      cgraph_node *node = cgraph_node::get_create (exp_decl);\n+\t      if (node->simd_clones == NULL)\n+\t\t{\n+\t\t  if (node->definition)\n+\t\t    return NULL;\n+\t\t  expand_simd_clones (node);\n+\t\t  if (node->simd_clones == NULL)\n+\t\t    return NULL;\n+\t\t}\n+\t      stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+\t      tree def = vect_recog_temp_ssa_var (TREE_TYPE (base), NULL);\n+\t      gimple *g = gimple_build_assign (def, MULT_EXPR, exp, logc);\n+\t      new_pattern_def_seq (stmt_vinfo, g);\n+\t      *type_in = TREE_TYPE (base);\n+\t      *type_out = NULL_TREE;\n+\t      tree res = vect_recog_temp_ssa_var (TREE_TYPE (base), NULL);\n+\t      g = gimple_build_call (exp_decl, 1, def);\n+\t      gimple_call_set_lhs (g, res);\n+\t      return g;\n+\t    }\n+\t}\n+\n+      return NULL;\n+    }\n+\n   /* We now have a pow or powi builtin function call with a constant\n      exponent.  */\n \n@@ -1744,8 +1808,8 @@ vect_recog_widen_shift_pattern (vec<gimple *> *stmts,\n \n   /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n   var = vect_recog_temp_ssa_var (type, NULL);\n-  pattern_stmt =\n-    gimple_build_assign (var, WIDEN_LSHIFT_EXPR, oprnd0, oprnd1);\n+  pattern_stmt\n+    = gimple_build_assign (var, WIDEN_LSHIFT_EXPR, oprnd0, oprnd1);\n   if (wstmt)\n     {\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n@@ -4439,10 +4503,6 @@ vect_pattern_recog_1 (vect_recog_func *recog_func,\n     }\n   else\n     {\n-      machine_mode vec_mode;\n-      enum insn_code icode;\n-      optab optab;\n-\n       /* Check target support  */\n       type_in = get_vectype_for_scalar_type (type_in);\n       if (!type_in)\n@@ -4456,19 +4516,18 @@ vect_pattern_recog_1 (vect_recog_func *recog_func,\n       pattern_vectype = type_out;\n \n       if (is_gimple_assign (pattern_stmt))\n-\tcode = gimple_assign_rhs_code (pattern_stmt);\n-      else\n-        {\n-\t  gcc_assert (is_gimple_call (pattern_stmt));\n-\t  code = CALL_EXPR;\n+\t{\n+\t  enum insn_code icode;\n+\t  code = gimple_assign_rhs_code (pattern_stmt);\n+\t  optab optab = optab_for_tree_code (code, type_in, optab_default);\n+\t  machine_mode vec_mode = TYPE_MODE (type_in);\n+\t  if (!optab\n+\t      || (icode = optab_handler (optab, vec_mode)) == CODE_FOR_nothing\n+\t      || (insn_data[icode].operand[0].mode != TYPE_MODE (type_out)))\n+\t    return false;\n \t}\n-\n-      optab = optab_for_tree_code (code, type_in, optab_default);\n-      vec_mode = TYPE_MODE (type_in);\n-      if (!optab\n-          || (icode = optab_handler (optab, vec_mode)) == CODE_FOR_nothing\n-          || (insn_data[icode].operand[0].mode != TYPE_MODE (type_out)))\n-\treturn false;\n+      else\n+\tgcc_assert (is_gimple_call (pattern_stmt));\n     }\n \n   /* Found a vectorizable pattern.  */"}]}