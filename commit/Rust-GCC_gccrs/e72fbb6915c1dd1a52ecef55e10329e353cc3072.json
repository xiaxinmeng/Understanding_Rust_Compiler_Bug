{"sha": "e72fbb6915c1dd1a52ecef55e10329e353cc3072", "node_id": "C_kwDOANBUbNoAKGU3MmZiYjY5MTVjMWRkMWE1MmVjZWY1NWUxMDMyOWUzNTNjYzMwNzI", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-04-22T20:52:26Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-04-22T20:52:26Z"}, "message": "fortran: Update index extraction code. [PR102043]\n\nThis avoids a regression on hollerith4.f90 and hollerith6.f90 later in\nthe patch series when code generation for array references is changed\nto use pointer arithmetic.\n\nThe problem comes from the extraction of the array index from an\nARRAY_REF tree, which doesn\u2019t work if the tree is not an ARRAY_REF\nany more.\n\nThis updates the code generated for remaining size evaluation to work\nwith a source tree that uses either array indexing or pointer\narithmetic.\n\n\tPR fortran/102043\n\ngcc/fortran/ChangeLog:\n\n\t* trans-io.cc: Add handling for the case where the array\n\tis referenced using pointer arithmetic.", "tree": {"sha": "15791c0b35c94c7d7a99bd0ed8e19938674ab764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15791c0b35c94c7d7a99bd0ed8e19938674ab764"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e72fbb6915c1dd1a52ecef55e10329e353cc3072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72fbb6915c1dd1a52ecef55e10329e353cc3072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e72fbb6915c1dd1a52ecef55e10329e353cc3072", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e72fbb6915c1dd1a52ecef55e10329e353cc3072/comments", "author": null, "committer": null, "parents": [{"sha": "89ca0fffa48b799b228beee48a16e26e24d8e199", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ca0fffa48b799b228beee48a16e26e24d8e199", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ca0fffa48b799b228beee48a16e26e24d8e199"}], "stats": {"total": 48, "additions": 37, "deletions": 11}, "files": [{"sha": "9f86815388cac69ce1dda57cbb6f40c18557e16f", "filename": "gcc/fortran/trans-io.cc", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e72fbb6915c1dd1a52ecef55e10329e353cc3072/gcc%2Ffortran%2Ftrans-io.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e72fbb6915c1dd1a52ecef55e10329e353cc3072/gcc%2Ffortran%2Ftrans-io.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.cc?ref=e72fbb6915c1dd1a52ecef55e10329e353cc3072", "patch": "@@ -737,7 +737,6 @@ set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n static void\n gfc_convert_array_to_string (gfc_se * se, gfc_expr * e)\n {\n-  tree size;\n \n   if (e->rank == 0)\n     {\n@@ -755,36 +754,63 @@ gfc_convert_array_to_string (gfc_se * se, gfc_expr * e)\n       array = sym->backend_decl;\n       type = TREE_TYPE (array);\n \n+      tree elts_count;\n       if (GFC_ARRAY_TYPE_P (type))\n-\tsize = GFC_TYPE_ARRAY_SIZE (type);\n+\telts_count = GFC_TYPE_ARRAY_SIZE (type);\n       else\n \t{\n \t  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n-\t  size = gfc_conv_array_stride (array, rank);\n+\t  tree stride = gfc_conv_array_stride (array, rank);\n \t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t\t gfc_array_index_type,\n \t\t\t\t gfc_conv_array_ubound (array, rank),\n \t\t\t\t gfc_conv_array_lbound (array, rank));\n \t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t\t gfc_array_index_type, tmp,\n \t\t\t\t gfc_index_one_node);\n+\t  elts_count = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\tgfc_array_index_type, tmp, stride);\n+\t}\n+      gcc_assert (elts_count);\n+\n+      tree elt_size = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+      elt_size = fold_convert (gfc_array_index_type, elt_size);\n+\n+      tree size;\n+      if (TREE_CODE (se->expr) == ARRAY_REF)\n+\t{\n+\t  tree index = TREE_OPERAND (se->expr, 1);\n+\t  index = fold_convert (gfc_array_index_type, index);\n+\n+\t  elts_count = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\tgfc_array_index_type,\n+\t\t\t\t\telts_count, index);\n+\n \t  size = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t  gfc_array_index_type, tmp, size);\n+\t\t\t\t  gfc_array_index_type, elts_count, elt_size);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TREE_CODE (se->expr) == INDIRECT_REF);\n+\t  tree ptr = TREE_OPERAND (se->expr, 0);\n+\n+\t  gcc_assert (TREE_CODE (ptr) == POINTER_PLUS_EXPR);\n+\t  tree offset = fold_convert_loc (input_location, gfc_array_index_type,\n+\t\t\t\t\t  TREE_OPERAND (ptr, 1));\n+\n+\t  size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t  gfc_array_index_type, elts_count, elt_size);\n+\t  size = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t  gfc_array_index_type, size, offset);\n \t}\n       gcc_assert (size);\n \n-      size = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t      gfc_array_index_type, size,\n-\t\t\t      TREE_OPERAND (se->expr, 1));\n       se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n-      tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-      size = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t      gfc_array_index_type, size,\n-\t\t\t      fold_convert (gfc_array_index_type, tmp));\n       se->string_length = fold_convert (gfc_charlen_type_node, size);\n       return;\n     }\n \n+  tree size;\n   gfc_conv_array_parameter (se, e, true, NULL, NULL, &size);\n   se->string_length = fold_convert (gfc_charlen_type_node, size);\n }"}]}