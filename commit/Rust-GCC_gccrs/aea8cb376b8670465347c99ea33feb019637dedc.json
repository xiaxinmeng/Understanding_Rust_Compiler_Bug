{"sha": "aea8cb376b8670465347c99ea33feb019637dedc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVhOGNiMzc2Yjg2NzA0NjUzNDdjOTllYTMzZmViMDE5NjM3ZGVkYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-10-24T08:04:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-10-24T08:04:22Z"}, "message": "mips.c (mips_canonicalize_move_class): New function.\n\ngcc/\n\t* config/mips/mips.c (mips_canonicalize_move_class): New function.\n\t(mips_move_to_gpr_cost): Likewise.\n\t(mips_move_from_gpr_cost): Likewise.\n\t(mips_register_move_cost): Make more fine-grained.\n\nFrom-SVN: r141336", "tree": {"sha": "2eaac85e664b4acec5939c78c61de92f60795f35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2eaac85e664b4acec5939c78c61de92f60795f35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aea8cb376b8670465347c99ea33feb019637dedc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea8cb376b8670465347c99ea33feb019637dedc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea8cb376b8670465347c99ea33feb019637dedc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea8cb376b8670465347c99ea33feb019637dedc/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "887e6178d4322cb537fba67be247a1b678cfe0e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/887e6178d4322cb537fba67be247a1b678cfe0e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/887e6178d4322cb537fba67be247a1b678cfe0e8"}], "stats": {"total": 175, "additions": 131, "deletions": 44}, "files": [{"sha": "76d8c014ab286d6765ee8beaa59004667c8a778b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea8cb376b8670465347c99ea33feb019637dedc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea8cb376b8670465347c99ea33feb019637dedc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aea8cb376b8670465347c99ea33feb019637dedc", "patch": "@@ -1,3 +1,10 @@\n+2008-10-24  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips.c (mips_canonicalize_move_class): New function.\n+\t(mips_move_to_gpr_cost): Likewise.\n+\t(mips_move_from_gpr_cost): Likewise.\n+\t(mips_register_move_cost): Make more fine-grained.\n+\n 2008-10-23  Tobias Grosser  <grosser@fim.uni-passau.de>\n \n \t* graphite.c (graphite_apply_transformations): Check for"}, {"sha": "f566e03155bc3e5d873f3aba54b7bbff67047714", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 124, "deletions": 44, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea8cb376b8670465347c99ea33feb019637dedc/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea8cb376b8670465347c99ea33feb019637dedc/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=aea8cb376b8670465347c99ea33feb019637dedc", "patch": "@@ -9689,62 +9689,142 @@ mips_preferred_reload_class (rtx x, enum reg_class rclass)\n   return rclass;\n }\n \n-/* Implement REGISTER_MOVE_COST.  */\n+/* RCLASS is a class involved in a REGISTER_MOVE_COST calculation.\n+   Return a \"canonical\" class to represent it in later calculations.  */\n \n-int\n-mips_register_move_cost (enum machine_mode mode,\n-\t\t\t enum reg_class to, enum reg_class from)\n+static enum reg_class\n+mips_canonicalize_move_class (enum reg_class rclass)\n {\n-  if (TARGET_MIPS16)\n+  /* All moves involving accumulator registers have the same cost.  */\n+  if (reg_class_subset_p (rclass, ACC_REGS))\n+    rclass = ACC_REGS;\n+\n+  /* Likewise promote subclasses of general registers to the most\n+     interesting containing class.  */\n+  if (TARGET_MIPS16 && reg_class_subset_p (rclass, M16_REGS))\n+    rclass = M16_REGS;\n+  else if (reg_class_subset_p (rclass, GENERAL_REGS))\n+    rclass = GENERAL_REGS;\n+\n+  return rclass;\n+}\n+\n+/* Return the cost of moving a value of mode MODE from a register of\n+   class FROM to a GPR.  Return 0 for classes that are unions of other\n+   classes handled by this function.  */\n+\n+static int\n+mips_move_to_gpr_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       enum reg_class from)\n+{\n+  switch (from)\n     {\n-      if (reg_class_subset_p (from, GENERAL_REGS)\n-\t  && reg_class_subset_p (to, GENERAL_REGS))\n-\t{\n-\t  if (reg_class_subset_p (from, M16_REGS)\n-\t      || reg_class_subset_p (to, M16_REGS))\n-\t    return 2;\n-\t  /* Two MOVEs.  */\n-\t  return 4;\n-\t}\n+    case GENERAL_REGS:\n+      /* A MIPS16 MOVE instruction, or a non-MIPS16 MOVE macro.  */\n+      return 2;\n+\n+    case ACC_REGS:\n+      /* MFLO and MFHI.  */\n+      return 6;\n+\n+    case FP_REGS:\n+      /* MFC1, etc.  */\n+      return 4;\n+\n+    case ST_REGS:\n+      /* LUI followed by MOVF.  */\n+      return 4;\n+\n+    case COP0_REGS:\n+    case COP2_REGS:\n+    case COP3_REGS:\n+      /* This choice of value is historical.  */\n+      return 5;\n+\n+    default:\n+      return 0;\n     }\n-  else if (reg_class_subset_p (from, GENERAL_REGS))\n+}\n+\n+/* Return the cost of moving a value of mode MODE from a GPR to a\n+   register of class TO.  Return 0 for classes that are unions of\n+   other classes handled by this function.  */\n+\n+static int\n+mips_move_from_gpr_cost (enum machine_mode mode, enum reg_class to)\n+{\n+  switch (to)\n     {\n-      if (reg_class_subset_p (to, GENERAL_REGS))\n-\treturn 2;\n-      if (reg_class_subset_p (to, FP_REGS))\n-\treturn 4;\n-      if (reg_class_subset_p (to, COP0_REGS)\n-\t  || reg_class_subset_p (to, COP2_REGS)\n-\t  || reg_class_subset_p (to, COP3_REGS))\n-\treturn 5;\n-      if (reg_class_subset_p (to, ACC_REGS))\n-\treturn 6;\n+    case GENERAL_REGS:\n+      /* A MIPS16 MOVE instruction, or a non-MIPS16 MOVE macro.  */\n+      return 2;\n+\n+    case ACC_REGS:\n+      /* MTLO and MTHI.  */\n+      return 6;\n+\n+    case FP_REGS:\n+      /* MTC1, etc.  */\n+      return 4;\n+\n+    case ST_REGS:\n+      /* A secondary reload through an FPR scratch.  */\n+      return (mips_register_move_cost (mode, GENERAL_REGS, FP_REGS)\n+\t      + mips_register_move_cost (mode, FP_REGS, ST_REGS));\n+\n+    case COP0_REGS:\n+    case COP2_REGS:\n+    case COP3_REGS:\n+      /* This choice of value is historical.  */\n+      return 5;\n+\n+    default:\n+      return 0;\n     }\n-  else if (reg_class_subset_p (to, GENERAL_REGS))\n+}\n+\n+/* Implement REGISTER_MOVE_COST.  Return 0 for classes that are the\n+   maximum of the move costs for subclasses; regclass will work out\n+   the maximum for us.  */\n+\n+int\n+mips_register_move_cost (enum machine_mode mode,\n+\t\t\t enum reg_class from, enum reg_class to)\n+{\n+  enum reg_class dregs;\n+  int cost1, cost2;\n+\n+  from = mips_canonicalize_move_class (from);\n+  to = mips_canonicalize_move_class (to);\n+\n+  /* Handle moves that can be done without using general-purpose registers.  */\n+  if (from == FP_REGS)\n     {\n-      if (reg_class_subset_p (from, FP_REGS))\n+      if (to == FP_REGS && mips_mode_ok_for_mov_fmt_p (mode))\n+\t/* MOV.FMT.  */\n \treturn 4;\n-      if (reg_class_subset_p (from, ST_REGS))\n-\t/* LUI followed by MOVF.  */\n-\treturn 4;\n-      if (reg_class_subset_p (from, COP0_REGS)\n-\t  || reg_class_subset_p (from, COP2_REGS)\n-\t  || reg_class_subset_p (from, COP3_REGS))\n-\treturn 5;\n-      if (reg_class_subset_p (from, ACC_REGS))\n-\treturn 6;\n+      if (to == ST_REGS)\n+\t/* The sequence generated by mips_expand_fcc_reload.  */\n+\treturn 8;\n     }\n-  else if (reg_class_subset_p (from, FP_REGS))\n+\n+  /* Handle cases in which only one class deviates from the ideal.  */\n+  dregs = TARGET_MIPS16 ? M16_REGS : GENERAL_REGS;\n+  if (from == dregs)\n+    return mips_move_from_gpr_cost (mode, to);\n+  if (to == dregs)\n+    return mips_move_to_gpr_cost (mode, from);\n+\n+  /* Handles cases that require a GPR temporary.  */\n+  cost1 = mips_move_to_gpr_cost (mode, from);\n+  if (cost1 != 0)\n     {\n-      if (reg_class_subset_p (to, FP_REGS)\n-\t  && mips_mode_ok_for_mov_fmt_p (mode))\n-\treturn 4;\n-      if (reg_class_subset_p (to, ST_REGS))\n-\t/* An expensive sequence.  */\n-\treturn 8;\n+      cost2 = mips_move_from_gpr_cost (mode, to);\n+      if (cost2 != 0)\n+\treturn cost1 + cost2;\n     }\n \n-  return 12;\n+  return 0;\n }\n \n /* Implement TARGET_IRA_COVER_CLASSES.  */"}]}