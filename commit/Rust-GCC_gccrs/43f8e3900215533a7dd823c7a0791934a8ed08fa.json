{"sha": "43f8e3900215533a7dd823c7a0791934a8ed08fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNmOGUzOTAwMjE1NTMzYTdkZDgyM2M3YTA3OTE5MzRhOGVkMDhmYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-10-07T18:13:11Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-10-07T18:13:11Z"}, "message": "* java/util/Properties.java: Merged with Classpath version.\n\nFrom-SVN: r36775", "tree": {"sha": "938b28fd02a65d5451ffc1ebbfc93580af509b0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/938b28fd02a65d5451ffc1ebbfc93580af509b0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43f8e3900215533a7dd823c7a0791934a8ed08fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43f8e3900215533a7dd823c7a0791934a8ed08fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43f8e3900215533a7dd823c7a0791934a8ed08fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43f8e3900215533a7dd823c7a0791934a8ed08fa/comments", "author": null, "committer": null, "parents": [{"sha": "20d431c9315f6aeadce38eab68cf2afb8a10cdcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20d431c9315f6aeadce38eab68cf2afb8a10cdcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20d431c9315f6aeadce38eab68cf2afb8a10cdcf"}], "stats": {"total": 831, "additions": 465, "deletions": 366}, "files": [{"sha": "9bb268d1374473a13a93d843557b227edba0d71b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f8e3900215533a7dd823c7a0791934a8ed08fa/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f8e3900215533a7dd823c7a0791934a8ed08fa/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=43f8e3900215533a7dd823c7a0791934a8ed08fa", "patch": "@@ -1,3 +1,7 @@\n+2000-10-07  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/util/Properties.java: Merged with Classpath version.\n+\n 2000-10-05  Tom Tromey  <tromey@cygnus.com>\n \n \t* java/lang/reflect/natField.cc (BooleanClass): Don't define."}, {"sha": "3f51d479f5c1c2c0fd98267af53f9b3d540b2488", "filename": "libjava/java/util/Properties.java", "status": "modified", "additions": 461, "deletions": 366, "changes": 827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43f8e3900215533a7dd823c7a0791934a8ed08fa/libjava%2Fjava%2Futil%2FProperties.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43f8e3900215533a7dd823c7a0791934a8ed08fa/libjava%2Fjava%2Futil%2FProperties.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FProperties.java?ref=43f8e3900215533a7dd823c7a0791934a8ed08fa", "patch": "@@ -1,393 +1,488 @@\n-// Properties - Property list representation.\n+/* java.util.Properties\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n \n-package java.util;\n-\n-import java.io.BufferedWriter;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.OutputStream;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n-import java.io.PushbackReader;\n-\n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date October 26, 1998.\n- */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * Status: Complete to JDK 1.2.\n- */\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-public class Properties extends Hashtable\n-{\n-  protected Properties defaults;\n \n-  private static final long serialVersionUID = 4112578634029874840L;\n+package java.util;\n+import java.io.*;\n \n-  public String getProperty (String propName)\n-    {\n-      return getProperty (propName, null);\n+/**\n+ * An example of a properties file for the german language is given\n+ * here.  This extends the example given in ListResourceBundle.\n+ * Create a file MyResource_de.properties with the following contents\n+ * and put it in the CLASSPATH.  (The character\n+ * <code>\\</code><code>u00e4</code> is the german &auml;)\n+ * \n+ * <pre>\n+ * s1=3\n+ * s2=MeineDisk\n+ * s3=3. M\\<code></code>u00e4rz 96\n+ * s4=Die Diskette ''{1}'' enth\\<code></code>u00e4lt {0} in {2}.\n+ * s5=0\n+ * s6=keine Dateien\n+ * s7=1\n+ * s8=eine Datei\n+ * s9=2\n+ * s10={0,number} Dateien\n+ * s11=Das Formatieren schlug fehl mit folgender Exception: {0}\n+ * s12=FEHLER\n+ * s13=Ergebnis\n+ * s14=Dialog\n+ * s15=Auswahlkriterium\n+ * s16=1,3\n+ * </pre>\n+ *\n+ * Although this is a sub class of a hash table, you should never\n+ * insert anything other than strings to this property, or several\n+ * methods, that need string keys and values, will fail.  To ensure\n+ * this, you should use the <code>get/setProperty</code> method instead\n+ * of <code>get/put</code>.\n+ *\n+ * @see PropertyResourceBundle\n+ * @author Jochen Hoenicke */\n+public class Properties extends Hashtable {\n+    /**\n+     * The property list that contains default values for any keys not\n+     * in this property list.  \n+     */\n+    protected Properties defaults;\n+\n+    private static final long serialVersionUID = 4112578634029874840L;\n+\n+    /**\n+     * Creates a new empty property list.\n+     */\n+    public Properties() {\n+        this.defaults = null;\n     }\n-\n-  public String getProperty (String propName, String defVal)\n-    {\n-      String r = (String) get (propName);\n-      if (r == null)\n-\t{\n-\t  if (defaults != null)\n-\t    r = defaults.getProperty(propName, defVal);\n-\t  else\n-\t    r = defVal;\n-\t}\n-      return r;\n+    \n+    /**\n+     * Create a new empty property list with the specified default values.\n+     * @param defaults a Properties object containing the default values.\n+     */\n+    public Properties(Properties defaults) {\n+        this.defaults = defaults;\n     }\n \n-  public Object setProperty (String key, String value)\n-  {\n-    return put (key, value);\n-  }\n-\n-  public void list (PrintStream out)\n-    {\n-      Enumeration e = propertyNames ();\n-      while (e.hasMoreElements())\n-\t{\n-\t  String key = (String) e.nextElement();\n-\t  String value = getProperty(key);\n-\t  if (value != null)\n-\t    {\n-\t      if (value.length() > 40)\n-\t\t{\n-\t\t  // JDK compatibility.\n-\t\t  value = value.substring(0, 37) + \"...\";\n-\t\t}\n-\t      out.print(key);\n-\t      out.print(\"=\");\n-\t      out.println(value);\n-\t    }\n-\t}\n+    /**\n+     * Reads a property list from an input stream.  The stream should\n+     * have the following format: <br>\n+     *\n+     * An empty line or a line starting with <code>#</code> or\n+     * <code>!</code> is ignored.  An backslash (<code>\\</code>) at the\n+     * end of the line makes the line continueing on the next line\n+     * (but make sure there is no whitespace after the backslash).\n+     * Otherwise, each line describes a key/value pair. <br>\n+     *\n+     * The chars up to the first whitespace, = or : are the key.  You\n+     * can include this caracters in the key, if you precede them with\n+     * a backslash (<code>\\</code>). The key is followed by optional\n+     * whitespaces, optionally one <code>=</code> or <code>:</code>,\n+     * and optionally some more whitespaces.  The rest of the line is\n+     * the resource belonging to the key. <br>\n+     *\n+     * Escape sequences <code>\\t, \\n, \\r, \\\\, \\\", \\', \\!, \\#, \\ </code>(a\n+     * space), and unicode characters with the\n+     * <code>\\</code><code>u</code>xxxx notation are detected, and \n+     * converted to the corresponding single character. <br>\n+     *\n+     * <pre>\n+     * # This is a comment\n+     * key     = value\n+     * k\\:5      \\ a string starting with space and ending with newline\\n\n+     * # This is a multiline specification; note that the value contains\n+     * # no white space.\n+     * weekdays: Sunday,Monday,Tuesday,Wednesday,\\\n+     *           Thursday,Friday,Saturday\n+     * # The safest way to include a space at the end of a value:\n+     * label   = Name:\\<code></code>u0020\n+     * </pre>\n+     *\n+     * @param in the input stream\n+     * @exception IOException if an error occured when reading\n+     * from the input.  */\n+    public void load(InputStream inStream) throws IOException {\n+        BufferedReader reader = \n+            new BufferedReader(new InputStreamReader(inStream));\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n+            char c = 0;\n+            int pos = 0;\n+            while (pos < line.length()\n+                   && Character.isWhitespace(c = line.charAt(pos)))\n+                pos++;\n+\n+            // If line is empty or begins with a comment character,\n+            // skip this line.\n+            if (pos == line.length() || c == '#' || c == '!')\n+                continue;\n+\n+            // The characaters up to the next Whitespace, ':', or '='\n+            // describe the key.  But look for escape sequences.\n+            StringBuffer key = new StringBuffer();\n+            while (pos < line.length() \n+                   && !Character.isWhitespace(c = line.charAt(pos++))\n+                   && c != '=' && c != ':') {\n+                if (c == '\\\\') {\n+                    if (pos == line.length()) {\n+                        // The line continues on the next line.\n+                        line = reader.readLine();\n+                        pos = 0;\n+                        while (pos < line.length()\n+                               && Character.isWhitespace(c = line.charAt(pos)))\n+                            pos++;\n+                    } else {\n+                        c = line.charAt(pos++);\n+                        switch (c) {\n+                        case 'n':\n+                            key.append('\\n');\n+                            break;\n+                        case 't':\n+                            key.append('\\t');\n+                            break;\n+                        case 'r':\n+                            key.append('\\r');\n+                            break;\n+                        case 'u':\n+                            if (pos+4 <= line.length()) {\n+                                char uni = (char) Integer.parseInt\n+                                    (line.substring(pos, pos+4), 16);\n+                                key.append(uni);\n+                            } // else throw exception?\n+                            break;\n+\t\t\tdefault:\n+                            key.append(c);\n+                            break;\n+                        }\n+                    }\n+                } else \n+                    key.append(c);\n+            }\n+            \n+            boolean isDelim = (c == ':' || c == '=');\n+            while (pos < line.length()\n+                   && Character.isWhitespace(c = line.charAt(pos)))\n+                pos++;\n+\n+            if (!isDelim && (c == ':' || c == '=')) {\n+                pos++;\n+                while (pos < line.length()\n+                       && Character.isWhitespace(c = line.charAt(pos)))\n+                    pos++;\n+            }\n+\n+            StringBuffer element = new StringBuffer(line.length()-pos);\n+            while (pos < line.length()) {\n+                c = line.charAt(pos++);\n+                if (c == '\\\\') {\n+                    if (pos == line.length()) {\n+                        // The line continues on the next line.\n+                        line = reader.readLine();\n+                        pos = 0;\n+                        while (pos < line.length()\n+                               && Character.isWhitespace(c = line.charAt(pos)))\n+                            pos++;\n+\t\t\telement.ensureCapacity(line.length()-pos+element.length());\n+                    } else {\n+                        c = line.charAt(pos++);\n+                        switch (c) {\n+                        case 'n':\n+                            element.append('\\n');\n+                            break;\n+                        case 't':\n+                            element.append('\\t');\n+                            break;\n+                        case 'r':\n+                            element.append('\\r');\n+                            break;\n+                        case 'u':\n+                            if (pos+4 <= line.length()) {\n+                                char uni = (char) Integer.parseInt\n+                                    (line.substring(pos, pos+4), 16);\n+                                element.append(uni);\n+                            } // else throw exception?\n+                            break;\n+\t\t\tdefault:\n+                            element.append(c);\n+                            break;\n+                        }\n+                    }\n+                } else \n+                    element.append(c);\n+            }\n+            put(key.toString(), element.toString());\n+        }\n     }\n \n-  public void list (PrintWriter writer)\n-    {\n-      Enumeration e = propertyNames ();\n-      while (e.hasMoreElements())\n-\t{\n-\t  String key = (String) e.nextElement();\n-\t  String value = getProperty(key);\n-\t  if (value != null)\n-\t    {\n-\t      if (value.length() > 40)\n-\t\t{\n-\t\t  // JDK compatibility.\n-\t\t  value = value.substring(0, 37) + \"...\";\n-\t\t}\n-\t      writer.print(key);\n-\t      writer.print(\"=\");\n-\t      writer.println(value);\n-\t    }\n-\t}\n+    /**\n+     * Calls <code>store(OutputStream out, String header)</code> and\n+     * ignores the IOException that may be thrown.\n+     * @deprecated use store instead.\n+     * @exception ClassCastException if this property contains any key or\n+     * value that isn't a string.\n+     */\n+    public void save(OutputStream out, String header) {\n+        try {\n+            store(out,header);\n+        } catch (IOException ex) {\n+        }\n     }\n-\n-  private final boolean skip_ws (PushbackReader reader) throws IOException\n-    {\n-      while (true)\n-\t{\n-\t  int c = reader.read();\n-\t  if (c == -1)\n-\t    return false;\n-\t  // FIXME: we use our own definition of whitespace.\n-\t  // Character.isWhitespace includes newlines, which we don't\n-\t  // want.  Character.isSpaceChar doesn't include \\t.\n-\t  if (c != ' ' && c != '\\t')\n-\t    {\n-\t      reader.unread(c);\n-\t      return true;\n-\t    }\n-\t}\n+    \n+    /**\n+     * Writes the key/value pairs to the given output stream. <br>\n+     *\n+     * If header is not null, this method writes a comment containing\n+     * the header as first line to the stream.  The next line (or first\n+     * line if header is null) contains a comment with the current date.\n+     * Afterwards the key/value pairs are written to the stream in the\n+     * following format. <br>\n+     *\n+     * Each line has the form <code>key = value</code>.  Newlines,\n+     * Returns and tabs are written as <code>\\n,\\t,\\r</code> resp.\n+     * The characters <code>\\, !, #, =</code> and <code>:</code> are\n+     * preceeded by a backslash.  Spaces are preceded with a backslash,\n+     * if and only if they are at the beginning of the key.  Characters\n+     * that are not in the ascii range 33 to 127 are written in the\n+     * <code>\\</code><code>u</code>xxxx Form.\n+     *\n+     * @param out the output stream\n+     * @param header the header written in the first line, may be null.\n+     * @exception ClassCastException if this property contains any key or\n+     * value that isn't a string.\n+     */\n+    public void store(OutputStream out, String header) throws IOException {\n+        PrintWriter writer = new PrintWriter(out);\n+        if (header != null)\n+            writer.println(\"#\"+header);\n+        writer.println(\"#\"+new Date().toString());\n+        list(writer);\n+\twriter.flush();\n     }\n-\n-  // Note: this method needs to be rewritten for JDK 1.2.\n-  // We rather arbitrarily decide that an EOF in the middle of a line\n-  // means that the whole line should be ignored.  The spec doesn't\n-  // specifically address this, but this interpretation seems valid.\n-  public synchronized void load (InputStream in) throws IOException\n-    {\n-      PushbackReader reader = new PushbackReader (new InputStreamReader (in));\n-\n-      StringBuffer key = new StringBuffer ();\n-      StringBuffer value = new StringBuffer ();\n-\n-    nextLine:\n-      while (true)\n-\t{\n-\t  key.setLength(0);\n-\t  value.setLength(0);\n-\n-\t  // Skip leading whitespace.\n-\t  if (! skip_ws (reader))\n-\t    return;\n-\n-\t  // Read key until key terminator.\n-\t  boolean first_char = true;\n-\t  int c;\n-\t  while (true)\n-\t    {\n-\t      c = reader.read();\n-\t      if (c == -1)\n-\t\treturn;\n-\t      if (c == '\\\\')\n-\t\t{\n-\t\t  first_char = false;\n-\t\t  c = reader.read();\n-\t\t  if (c == -1)\n-\t\t    return;\n-\t\t}\n-\n-\t      // If we found a comment, just read to end of line and\n-\t      // then keep going.\n-\t      if (first_char == true && (c == '#' || c == '!'))\n-\t\t{\n-\t\t  while (c != -1 && c != '\\r' && c != '\\n')\n-\t\t    c = reader.read();\n-\t\t  if (c == -1)\n-\t\t    return;\n-\t\t  continue nextLine;\n-\t\t}\n-\n-\t      if (c == '\\r' || c == '\\n')\n-\t\t{\n-\t\t  if (first_char)\n-\t\t    continue nextLine;\n-\t\t  reader.unread(c);\n-\t\t  break;\n-\t\t}\n-\t      // FIXME: again, our own definition of whitespace.\n-\t      if (c == ' ' || c == '\\t' || c == ':' || c == '=')\n-\t\tbreak;\n-\n-\t      first_char = false;\n-\t      key.append((char) c);\n-\t    }\n-\n-\t  // Found end of key.  Skip whitespace.  If the terminator\n-\t  // was whitespace, also skip a single instance of a \"real\"\n-\t  // terminator, and then more whitespace.\n-\t  if (! skip_ws (reader))\n-\t    return;\n-\t  if (c != ':' && c != '=')\n-\t    {\n-\t      c = reader.read();\n-\t      if (c == -1)\n-\t\treturn;\n-\t      if (c == ':' || c == '=')\n-\t\t{\n-\t\t  // Skip more whitespace.\n-\t\t  if (! skip_ws (reader))\n-\t\t    return;\n-\t\t}\n-\t      else\n-\t\treader.unread(c);\n-\t    }\n-\n-\t  // Now read the value.\n-\t  while (true)\n-\t    {\n-\t      c = reader.read();\n-\t      if (c == -1)\n-\t\treturn;\n-\t      if (c == '\\r' || c == '\\n')\n-\t\tbreak;\n-\t      if (c == '\\\\')\n-\t\t{\n-\t\t  c = reader.read();\n-\t\t  switch (c)\n-\t\t    {\n-\t\t    case -1:\n-\t\t      return;\n-\t\t    case 't':\n-\t\t      c = '\\t';\n-\t\t      break;\n-\t\t    case 'r':\n-\t\t      c = '\\r';\n-\t\t      break;\n-\t\t    case 'n':\n-\t\t      c = '\\n';\n-\t\t      break;\n-\t\t    case 'u':\n-\t\t      c = 0;\n-\t\t      for (int i = 0; i < 4; ++i)\n-\t\t\t{\n-\t\t\t  int x = reader.read();\n-\t\t\t  if (x == -1)\n-\t\t\t    return;\n-\t\t\t  int d = Character.digit((char) x, 16);\n-\t\t\t  // We follow JDK here: invalid characters\n-\t\t\t  // are treated as terminators.\n-\t\t\t  if (d == -1)\n-\t\t\t    {\n-\t\t\t      value.append((char) c);\n-\t\t\t      c = x;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t  c <<= 4;\n-\t\t\t  c |= d;\n-\t\t\t}\n-\t\t      break;\n-\t\t    default:\n-\t\t      // Nothing.\n-\t\t    }\n-\t\t}\n-\t      value.append((char) c);\n-\t    }\n-\n-\t  put (key.toString(), value.toString());\n-\t}\n+    \n+    /**\n+     * Adds the given key/value pair to this properties.  This calls\n+     * the hashtable method put.\n+     * @param key the key for this property\n+     * @param value the value for this property\n+     * @return The old value for the given key.\n+     * @since JDK1.2 */\n+    public Object setProperty(String key, String value) {\n+        return put(key,value);\n     }\n \n-  public Properties ()\n-    {\n-      defaults = null;\n+    /**\n+     * Gets the property with the specified key in this property list.\n+     * If the key is not found, the default property list is searched.\n+     * If the property is not found in default or the default of\n+     * default, null is returned.\n+     * @param key The key for this property.\n+     * @param defaulValue A default value\n+     * @return The value for the given key, or null if not found. \n+     * @exception ClassCastException if this property contains any key or\n+     * value that isn't a string.\n+     */\n+    public String getProperty(String key) {\n+        return getProperty(key, null);\n     }\n \n-  public Properties (Properties defs)\n-    {\n-      defaults = defs;\n+    /**\n+     * Gets the property with the specified key in this property list.  If\n+     * the key is not found, the default property list is searched.  If the\n+     * property is not found in default or the default of default, the \n+     * specified defaultValue is returned.\n+     * @param key The key for this property.\n+     * @param defaulValue A default value\n+     * @return The value for the given key.\n+     * @exception ClassCastException if this property contains any key or\n+     * value that isn't a string.\n+     */\n+    public String getProperty(String key, String defaultValue) {\n+        Properties prop = this;\n+        // Eliminate tail recursion.\n+        do {\n+            String value = (String) prop.get(key);\n+            if (value != null)\n+                return value;\n+            prop = prop.defaults;\n+        } while (prop != null);\n+        return defaultValue;\n     }\n \n-  private final void addHashEntries (Hashtable base)\n-    {\n-      if (defaults != null)\n-\tdefaults.addHashEntries(base);\n-      Enumeration keys = keys ();\n-      while (keys.hasMoreElements())\n-\tbase.put(keys.nextElement(), base);\n+    private final void addHashEntries (Hashtable base) {\n+        if (defaults != null)\n+\t    defaults.addHashEntries(base);\n+\tEnumeration keys = keys ();\n+\twhile (keys.hasMoreElements())\n+\t    base.put(keys.nextElement(), base);\n     }\n \n-  public Enumeration propertyNames ()\n-    {\n-      // We make a new Hashtable that holds all the keys.  Then we\n-      // return an enumeration for this hash.  We do this because we\n-      // don't want modifications to be reflected in the enumeration\n-      // (per JCL), and because there doesn't seem to be a\n-      // particularly better way to ensure that duplicates are\n-      // ignored.\n-      Hashtable t = new Hashtable ();\n-      addHashEntries (t);\n-      return t.keys();\n+    /**\n+     * Returns an enumeration of all keys in this property list, including\n+     * the keys in the default property list.\n+     */\n+    public Enumeration propertyNames () {\n+        // We make a new Hashtable that holds all the keys.  Then we\n+        // return an enumeration for this hash.  We do this because we\n+        // don't want modifications to be reflected in the enumeration\n+        // (per JCL), and because there doesn't seem to be a\n+        // particularly better way to ensure that duplicates are\n+        // ignored.\n+        Hashtable t = new Hashtable ();\n+\taddHashEntries (t);\n+\treturn t.keys();\n     }\n \n-  public synchronized void save (OutputStream out, String comment)\n-  {\n-    try\n-      {\n-\tstore (out, comment);\n-      }\n-    catch (IOException _)\n-      {\n-      }\n-  }\n-\n-  public synchronized void store (OutputStream out, String comment)\n-    throws IOException\n-  {\n-      // Use a buffer because writing a single string through\n-      // OutputStreamWriter is fairly expensive.\n-      BufferedWriter output\n-\t= new BufferedWriter (new OutputStreamWriter (out));\n-      String newline = System.getProperty(\"line.separator\");\n-\n-      if (comment != null)\n-\t{\n-\t  // We just lose if COMMENT contains a newline.  This is\n-\t  // what JDK 1.1 does.\n-\t  output.write(\"#\");\n-\t  output.write(comment);\n-\t  output.write(newline);\n-\t}\n-      output.write(\"# \");\n-      output.write(new Date().toString());\n-      output.write(newline);\n-\n-      Enumeration keys = keys ();\n-      while (keys.hasMoreElements())\n-\t{\n-\t  String key = (String) keys.nextElement();\n-\t  String value = (String) get (key);\n-\n-\t  // FIXME: JCL says that the key can contain many Unicode\n-\t  // characters.  But it also doesn't say we should encode\n-\t  // it in any way.\n-\t  // FIXME: if key contains ':', '=', or whitespace, must\n-\t  // quote it here.  Note that JDK 1.1 does not do this.\n-\t  output.write(key);\n-\t  output.write(\"=\");\n-\n-\t  boolean leading = true;\n-\t  for (int i = 0; i < value.length(); ++i)\n-\t    {\n-\t      boolean new_lead = false;\n-\t      char c = value.charAt(i);\n-\t      switch (c)\n-\t\t{\n-\t\tcase '\\n':\n-\t\t  output.write(\"\\\\n\");\n-\t\t  break;\n-\t\tcase '\\r':\n-\t\t  output.write(\"\\\\r\");\n-\t\t  break;\n-\t\tcase '\\t':\n-\t\t  output.write(\"\\\\t\");\n-\t\t  break;\n-\t\tcase '\\\\':\n-\t\t  output.write(\"\\\\\\\\\");\n-\t\t  break;\n-\n-\t\tcase '#':\n-\t\tcase '!':\n-\t\tcase '=':\n-\t\tcase ':':\n-\t\t  output.write(\"\\\\\");\n-\t\t  output.write(c);\n-\t\t  break;\n-\n-\t\tcase ' ':\n-\t\t  new_lead = leading;\n-\t\t  if (leading)\n-\t\t    output.write(\"\\\\\");\n-\t\t  output.write(c);\n-\t\t  break;\n+    /**\n+     * Formats a key/value pair for output in a properties file.\n+     * See store for a description of the format.\n+     * @param key the key.\n+     * @param value the value.\n+     * @see #store\n+     */\n+    private String formatForOutput(String key, String value) {\n+\t// This is a simple approximation of the expected line size.\n+        StringBuffer result = new StringBuffer(key.length()+value.length()+16);\n+        boolean head = true;\n+        for (int i=0; i< key.length(); i++) {\n+            char c = key.charAt(i);\n+            switch (c) {\n+            case '\\n':\n+                result.append(\"\\\\n\");\n+                break;\n+            case '\\r':\n+                result.append(\"\\\\r\");\n+                break;\n+            case '\\t':\n+                result.append(\"\\\\t\");\n+                break;\n+            case '\\\\':\n+                result.append(\"\\\\\\\\\");\n+                break;\n+            case '!':\n+                result.append(\"\\\\!\");\n+                break;\n+            case '#':\n+                result.append(\"\\\\#\");\n+                break;\n+            case '=':\n+                result.append(\"\\\\=\");\n+                break;\n+            case ':':\n+                result.append(\"\\\\:\");\n+                break;\n+\t    case ' ':\n+\t        result.append(\"\\\\ \");\n+\t\tbreak;\n+            default:\n+                if (c < 32 || c > '~') {\n+                    String hex = Integer.toHexString(c);\n+                    result.append(\"\\\\u0000\".substring(0, 6-hex.length()));\n+                    result.append(hex);\n+                } else\n+                    result.append(c);\n+            }\n+            if (c != 32)\n+                head = false;\n+        }\n+        result.append('=');\n+        head=true;\n+        for (int i=0; i< value.length(); i++) {\n+            char c = value.charAt(i);\n+            switch (c) {\n+            case '\\n':\n+                result.append(\"\\\\n\");\n+                break;\n+            case '\\r':\n+                result.append(\"\\\\r\");\n+                break;\n+            case '\\t':\n+                result.append(\"\\\\t\");\n+                break;\n+            case '\\\\':\n+                result.append(\"\\\\\\\\\");\n+                break;\n+            case '!':\n+                result.append(\"\\\\!\");\n+                break;\n+            case '#':\n+                result.append(\"\\\\#\");\n+                break;\n+\t    case ' ':\n+\t\tresult.append(head ? \"\\\\ \": \" \");\n+\t\tbreak;\n+            default:\n+                if (c < 32 || c > '~') {\n+                    String hex = Integer.toHexString(c);\n+                    result.append(\"\\\\u0000\".substring(0, 6-hex.length()));\n+                    result.append(hex);\n+                } else\n+                    result.append(c);\n+            }\n+            if (c != 32)\n+                head = false;\n+        }\n+        return result.toString();\n+    }\n \n-\t\tdefault:\n-\t\t  if (c < '\\u0020' || c > '\\u007e')\n-\t\t    {\n-\t\t      output.write(\"\\\\u\");\n-\t\t      output.write(Character.forDigit(c >>> 12, 16));\n-\t\t      output.write(Character.forDigit((c >>> 8) & 0xff,\n-\t\t\t\t\t\t      16));\n-\t\t      output.write(Character.forDigit((c >>> 4) & 0xff,\n-\t\t\t\t\t\t      16));\n-\t\t      output.write(Character.forDigit(c & 0xff, 16));\n-\t\t    }\n-\t\t  else\n-\t\t    output.write(c);\n-\t\t}\n-\t      leading = new_lead;\n-\t    }\n-\t  output.write(newline);\n-\t}\n+    /**\n+     * Writes the key/value pairs to the given print stream.  They are\n+     * written in the way, described in the method store.\n+     * @param out the stream, where the key/value pairs are written to.\n+     * @exception ClassCastException if this property contains any key or\n+     * value that isn't a string.\n+     * @see #store\n+     */\n+    public void list(PrintStream out) {\n+        Enumeration keys = keys();\n+        Enumeration elts = elements();\n+        while (keys.hasMoreElements()) {\n+            String key = (String) keys.nextElement();\n+            String elt = (String) elts.nextElement();\n+            String output = formatForOutput(key,elt);\n+            out.println(output);\n+        }\n+    }\n \n-      output.flush();\n-  }\n+    /**\n+     * Writes the key/value pairs to the given print writer.  They are\n+     * written in the way, described in the method store.\n+     * @param out the writer, where the key/value pairs are written to.\n+     * @exception ClassCastException if this property contains any key or\n+     * value that isn't a string.\n+     * @see #store\n+     * @see #list(java.io.PrintStream)\n+     * @since JDK1.1\n+     */\n+    public void list(PrintWriter out) {\n+        Enumeration keys = keys();\n+        Enumeration elts = elements();\n+        while (keys.hasMoreElements()) {\n+            String key = (String) keys.nextElement();\n+            String elt = (String) elts.nextElement();\n+            String output = formatForOutput(key,elt);\n+            out.println(output);\n+        }\n+    }\n }"}]}