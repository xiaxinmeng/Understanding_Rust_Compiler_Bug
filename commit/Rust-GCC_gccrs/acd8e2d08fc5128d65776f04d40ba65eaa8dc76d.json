{"sha": "acd8e2d08fc5128d65776f04d40ba65eaa8dc76d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNkOGUyZDA4ZmM1MTI4ZDY1Nzc2ZjA0ZDQwYmE2NWVhYThkYzc2ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-06-18T19:17:04Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-06-18T19:17:04Z"}, "message": "cp-tree.h (comp_except_specs, [...]): Return bool.\n\n\t* cp-tree.h (comp_except_specs, compparms, cp_has_mutable_p,\n\tat_least_as_qualified_p, more_qualified_p): Return bool.\n\t* typeck.c: ANSIFY function definitions.\n\t(comp_array_types): Take redeclaration bool parameter.\n\t(comptypes): Rearrange STRICT handling.\n\t(at_least_as_qualified_p, more_qualified_p,\n\tcomp_cv_qualification): Cache cv quals.\n\t(compparms): Rearrange loop.\n\nFrom-SVN: r68164", "tree": {"sha": "f2158d249b3856f19d727f993197e873d424806d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2158d249b3856f19d727f993197e873d424806d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d/comments", "author": null, "committer": null, "parents": [{"sha": "b82a33d2a9dfc943324f34c60e4b231baa236eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b82a33d2a9dfc943324f34c60e4b231baa236eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b82a33d2a9dfc943324f34c60e4b231baa236eca"}], "stats": {"total": 421, "additions": 164, "deletions": 257}, "files": [{"sha": "9bf8f6d54a51d5d30f5c0802f09fced8938380ab", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=acd8e2d08fc5128d65776f04d40ba65eaa8dc76d", "patch": "@@ -1,3 +1,14 @@\n+2003-06-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (comp_except_specs, compparms, cp_has_mutable_p,\n+\tat_least_as_qualified_p, more_qualified_p): Return bool.\n+\t* typeck.c: ANSIFY function definitions.\n+\t(comp_array_types): Take redeclaration bool parameter.\n+\t(comptypes): Rearrange STRICT handling.\n+\t(at_least_as_qualified_p, more_qualified_p,\n+\tcomp_cv_qualification): Cache cv quals.\n+\t(compparms): Rearrange loop.\n+\t\n 2003-06-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (COMPARE_RELAXED): Rename to ..."}, {"sha": "23cdee6e711391c47b26dae3e089961959dc60c8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=acd8e2d08fc5128d65776f04d40ba65eaa8dc76d", "patch": "@@ -3796,11 +3796,11 @@ extern void cp_warning_at\t(const char *msgid, ...);\n extern void cp_pedwarn_at\t(const char *msgid, ...);\n \n /* XXX Not i18n clean.  */\n-#define cp_deprecated(STR)\t\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\t\\\n-    if (warn_deprecated)\t\t\t\t\t\t\t\\\n-      warning (\"%s is deprecated, please see the documentation for details\",\t\\\n-\t       (STR));\t\t\t\t\t\t\t\t\\\n+#define cp_deprecated(STR)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (warn_deprecated)\t\t\t\t\t\t\\\n+      warning (\"%s is deprecated, please see the documentation for details\", \\\n+\t       (STR));\t\t\t\t\t\t\t\\\n   } while (0)\n \n /* in error.c */\n@@ -4239,10 +4239,10 @@ extern tree complete_type_or_diagnostic         (tree, tree, int);\n extern int type_unknown_p\t\t\t(tree);\n extern tree commonparms\t\t\t\t(tree, tree);\n extern tree original_type\t\t\t(tree);\n-extern int comp_except_specs\t\t\t(tree, tree, int);\n+extern bool comp_except_specs\t\t\t(tree, tree, bool);\n extern bool comptypes\t\t\t\t(tree, tree, int);\n extern int comp_target_types\t\t\t(tree, tree, int);\n-extern int compparms\t\t\t\t(tree, tree);\n+extern bool compparms\t\t\t\t(tree, tree);\n extern int comp_cv_qualification                (tree, tree);\n extern int comp_cv_qual_signature               (tree, tree);\n extern tree expr_sizeof\t\t\t\t(tree);\n@@ -4275,9 +4275,9 @@ extern int comp_ptr_ttypes\t\t\t(tree, tree);\n extern int ptr_reasonably_similar\t\t(tree, tree);\n extern tree build_ptrmemfunc\t\t\t(tree, tree, int);\n extern int cp_type_quals                        (tree);\n-extern int cp_has_mutable_p                     (tree);\n-extern int at_least_as_qualified_p              (tree, tree);\n-extern int more_qualified_p                     (tree, tree);\n+extern bool cp_has_mutable_p                     (tree);\n+extern bool at_least_as_qualified_p              (tree, tree);\n+extern bool more_qualified_p                     (tree, tree);\n extern tree build_ptrmemfunc1                   (tree, tree, tree);\n extern void expand_ptrmemfunc_cst               (tree, tree *, tree *);\n extern tree pfn_from_ptrmemfunc                 (tree);"}, {"sha": "c80ca6b44d04e831e572020cf22d0eb1e42ec05a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 143, "deletions": 247, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acd8e2d08fc5128d65776f04d40ba65eaa8dc76d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=acd8e2d08fc5128d65776f04d40ba65eaa8dc76d", "patch": "@@ -45,34 +45,32 @@ Boston, MA 02111-1307, USA.  */\n #include \"diagnostic.h\"\n #include \"target.h\"\n \n-static tree convert_for_assignment PARAMS ((tree, tree, const char *, tree,\n-\t\t\t\t\t  int));\n-static tree cp_pointer_int_sum PARAMS ((enum tree_code, tree, tree));\n-static tree rationalize_conditional_expr PARAMS ((enum tree_code, tree));\n-static int comp_target_parms PARAMS ((tree, tree));\n-static int comp_ptr_ttypes_real PARAMS ((tree, tree, int));\n-static int comp_ptr_ttypes_const PARAMS ((tree, tree));\n-static int comp_ptr_ttypes_reinterpret PARAMS ((tree, tree));\n-static int comp_except_types PARAMS ((tree, tree, int));\n-static bool comp_array_types PARAMS ((tree, tree, int));\n-static tree common_base_type PARAMS ((tree, tree));\n-static tree lookup_anon_field PARAMS ((tree, tree));\n-static tree pointer_diff PARAMS ((tree, tree, tree));\n-static tree qualify_type_recursive PARAMS ((tree, tree));\n-static tree get_delta_difference PARAMS ((tree, tree, int));\n-static int comp_cv_target_types PARAMS ((tree, tree, int));\n-static void casts_away_constness_r PARAMS ((tree *, tree *));\n-static int casts_away_constness PARAMS ((tree, tree));\n-static void maybe_warn_about_returning_address_of_local PARAMS ((tree));\n-static tree strip_all_pointer_quals PARAMS ((tree));\n+static tree convert_for_assignment (tree, tree, const char *, tree, int);\n+static tree cp_pointer_int_sum (enum tree_code, tree, tree);\n+static tree rationalize_conditional_expr (enum tree_code, tree);\n+static int comp_target_parms (tree, tree);\n+static int comp_ptr_ttypes_real (tree, tree, int);\n+static int comp_ptr_ttypes_const (tree, tree);\n+static int comp_ptr_ttypes_reinterpret (tree, tree);\n+static bool comp_except_types (tree, tree, bool);\n+static bool comp_array_types (tree, tree, bool);\n+static tree common_base_type (tree, tree);\n+static tree lookup_anon_field (tree, tree);\n+static tree pointer_diff (tree, tree, tree);\n+static tree qualify_type_recursive (tree, tree);\n+static tree get_delta_difference (tree, tree, int);\n+static int comp_cv_target_types (tree, tree, int);\n+static void casts_away_constness_r (tree *, tree *);\n+static bool casts_away_constness (tree, tree);\n+static void maybe_warn_about_returning_address_of_local (tree);\n+static tree strip_all_pointer_quals (tree);\n static tree lookup_destructor (tree, tree, tree);\n \n /* Return the target type of TYPE, which means return T for:\n    T*, T&, T[], T (...), and otherwise, just T.  */\n \n tree\n-target_type (type)\n-     tree type;\n+target_type (tree type)\n {\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n@@ -91,8 +89,7 @@ target_type (type)\n    complete type when this function returns.  */\n \n tree\n-require_complete_type (value)\n-     tree value;\n+require_complete_type (tree value)\n {\n   tree type;\n \n@@ -131,8 +128,7 @@ require_complete_type (value)\n    horribly wrong, in which case the error_mark_node is returned.  */\n \n tree\n-complete_type (type)\n-     tree type;\n+complete_type (tree type)\n {\n   if (type == NULL_TREE)\n     /* Rather than crash, we return something sure to cause an error\n@@ -163,10 +159,7 @@ complete_type (type)\n    Returns NULL_TREE if the type cannot be made complete.  */\n \n tree\n-complete_type_or_diagnostic (type, value, diag_type)\n-     tree type;\n-     tree value;\n-     int diag_type;\n+complete_type_or_diagnostic (tree type, tree value, int diag_type)\n {\n   type = complete_type (type);\n   if (type == error_mark_node)\n@@ -739,7 +732,8 @@ common_type (t1, t2)\n }\n \f\n /* Compare two exception specifier types for exactness or subsetness, if\n-   allowed. Returns 0 for mismatch, 1 for same, 2 if B is allowed by A.\n+   allowed. Returns false for mismatch, true for match (same, or\n+   derived and !exact).\n  \n    [except.spec] \"If a class X ... objects of class X or any class publicly\n    and unambigously derrived from X. Similarly, if a pointer type Y * ...\n@@ -753,61 +747,57 @@ common_type (t1, t2)\n    \n    We implement the letter of the standard.  */\n \n-static int\n-comp_except_types (a, b, exact)\n-     tree a, b;\n-     int exact;\n+static bool\n+comp_except_types (tree a, tree b, bool exact)\n {\n   if (same_type_p (a, b))\n-    return 1;\n+    return true;\n   else if (!exact)\n     {\n       if (cp_type_quals (a) || cp_type_quals (b))\n-        return 0;\n+        return false;\n       \n       if (TREE_CODE (a) == POINTER_TYPE\n           && TREE_CODE (b) == POINTER_TYPE)\n         {\n           a = TREE_TYPE (a);\n           b = TREE_TYPE (b);\n           if (cp_type_quals (a) || cp_type_quals (b))\n-            return 0;\n+            return false;\n         }\n       \n       if (TREE_CODE (a) != RECORD_TYPE\n           || TREE_CODE (b) != RECORD_TYPE)\n-        return 0;\n+        return false;\n       \n       if (ACCESSIBLY_UNIQUELY_DERIVED_P (a, b))\n-        return 2;\n+        return true;\n     }\n-  return 0;\n+  return false;\n }\n \n-/* Return 1 if TYPE1 and TYPE2 are equivalent exception specifiers.\n-   If EXACT is 0, T2 can be stricter than T1 (according to 15.4/7),\n+/* Return true if TYPE1 and TYPE2 are equivalent exception specifiers.\n+   If EXACT is false, T2 can be stricter than T1 (according to 15.4/7),\n    otherwise it must be exact. Exception lists are unordered, but\n    we've already filtered out duplicates. Most lists will be in order,\n    we should try to make use of that.  */\n \n-int\n-comp_except_specs (t1, t2, exact)\n-     tree t1, t2;\n-     int exact;\n+bool\n+comp_except_specs (tree t1, tree t2, bool exact)\n {\n   tree probe;\n   tree base;\n   int  length = 0;\n \n   if (t1 == t2)\n-    return 1;\n+    return true;\n   \n   if (t1 == NULL_TREE)              /* T1 is ...  */\n     return t2 == NULL_TREE || !exact;\n   if (!TREE_VALUE (t1)) /* t1 is EMPTY */\n     return t2 != NULL_TREE && !TREE_VALUE (t2);\n   if (t2 == NULL_TREE)              /* T2 is ...  */\n-    return 0;\n+    return false;\n   if (TREE_VALUE (t1) && !TREE_VALUE (t2)) /* T2 is EMPTY, T1 is not */\n     return !exact;\n   \n@@ -831,27 +821,25 @@ comp_except_specs (t1, t2, exact)\n             }\n         }\n       if (probe == NULL_TREE)\n-        return 0;\n+        return false;\n     }\n   return !exact || base == NULL_TREE || length == list_length (t1);\n }\n \n-/* Compare the array types T1 and T2.  STRICT is as for comptypes.  */\n+/* Compare the array types T1 and T2.  ALLOW_REDECLARATION is true if\n+   [] can match [size].  */\n \n static bool\n-comp_array_types (t1, t2, strict)\n-     tree t1, t2;\n-     int strict;\n+comp_array_types (tree t1, tree t2, bool allow_redeclaration)\n {\n   tree d1;\n   tree d2;\n \n   if (t1 == t2)\n-    return 1;\n+    return true;\n \n   /* The type of the array elements must be the same.  */\n-  if (!comptypes (TREE_TYPE (t1), TREE_TYPE (t2), \n-\t\t strict & ~COMPARE_REDECLARATION))\n+  if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n     return false;\n \n   d1 = TYPE_DOMAIN (t1);\n@@ -873,7 +861,7 @@ comp_array_types (t1, t2, strict)\n        array types that differ by the presence or absence of a major\n        array bound (_dcl.array_).  */\n   if (!d1 || !d2)\n-    return strict & COMPARE_REDECLARATION;\n+    return allow_redeclaration;\n \n   /* Check that the dimensions are the same.  */\n   return (cp_tree_equal (TYPE_MIN_VALUE (d1), TYPE_MIN_VALUE (d2))\n@@ -884,18 +872,11 @@ comp_array_types (t1, t2, strict)\n    is a bitwise-or of the COMPARE_* flags.  */\n \n bool\n-comptypes (t1, t2, strict)\n-     tree t1;\n-     tree t2;\n-     int strict;\n+comptypes (tree t1, tree t2, int strict)\n {\n-  int orig_strict = strict;\n-\n   if (t1 == t2)\n     return true;\n \n-  strict &= ~(COMPARE_REDECLARATION | COMPARE_BASE | COMPARE_DERIVED);\n-\n   /* This should never happen.  */\n   my_friendly_assert (t1 != error_mark_node, 307);\n \n@@ -970,7 +951,7 @@ comptypes (t1, t2, strict)\n       if (TREE_CODE (t1) == TEMPLATE_TEMPLATE_PARM)\n \treturn true;\n       /* Don't check inheritance.  */\n-      orig_strict = COMPARE_STRICT;\n+      strict = COMPARE_STRICT;\n       /* fall through */\n \n     case RECORD_TYPE:\n@@ -981,34 +962,32 @@ comptypes (t1, t2, strict)\n \t  && comp_template_args (TYPE_TI_ARGS (t1), TYPE_TI_ARGS (t2)))\n \treturn true;\n       \n-      if ((orig_strict & COMPARE_BASE) && DERIVED_FROM_P (t1, t2))\n+      if ((strict & COMPARE_BASE) && DERIVED_FROM_P (t1, t2))\n \treturn true;\n-      else if ((orig_strict & COMPARE_DERIVED) && DERIVED_FROM_P (t2, t1))\n+      else if ((strict & COMPARE_DERIVED) && DERIVED_FROM_P (t2, t1))\n \treturn true;\n       \n       return false;\n \n     case OFFSET_TYPE:\n       if (!comptypes (TYPE_OFFSET_BASETYPE (t1), TYPE_OFFSET_BASETYPE (t2),\n-\t\t      orig_strict))\n+\t\t      strict & ~COMPARE_REDECLARATION))\n \treturn false;\n-      return comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict);\n+      /* FALLTHROUGH*/\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-      return comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict);\n+      return same_type_p (TREE_TYPE (t1), TREE_TYPE (t2));\n \n     case METHOD_TYPE:\n     case FUNCTION_TYPE:\n-      if (!comptypes (TREE_TYPE (t1), TREE_TYPE (t2), strict))\n+      if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n \treturn false;\n       return compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2));\n \n     case ARRAY_TYPE:\n-      /* Target types must match incl. qualifiers.  We use ORIG_STRICT\n-\t here since this is the one place where\n-\t COMPARE_REDECLARATION should be used.  */\n-      return comp_array_types (t1, t2, orig_strict & COMPARE_REDECLARATION);\n+      /* Target types must match incl. qualifiers. */\n+      return comp_array_types (t1, t2, !!(strict & COMPARE_REDECLARATION));\n \n     case TEMPLATE_TYPE_PARM:\n       return (TEMPLATE_TYPE_IDX (t1) == TEMPLATE_TYPE_IDX (t2)\n@@ -1038,9 +1017,7 @@ comptypes (t1, t2, strict)\n    only in the same direction as the target type.  */\n \n static int\n-comp_cv_target_types (ttl, ttr, nptrs)\n-     tree ttl, ttr;\n-     int nptrs;\n+comp_cv_target_types (tree ttl, tree ttr, int nptrs)\n {\n   int t;\n \n@@ -1073,9 +1050,7 @@ comp_cv_target_types (ttl, ttr, nptrs)\n    similar instead.  (jason 17 Apr 1997)  */\n \n int\n-comp_target_types (ttl, ttr, nptrs)\n-     tree ttl, ttr;\n-     int nptrs;\n+comp_target_types (tree ttl, tree ttr, int nptrs)\n {\n   ttl = TYPE_MAIN_VARIANT (ttl);\n   ttr = TYPE_MAIN_VARIANT (ttr);\n@@ -1240,42 +1215,42 @@ comp_target_types (ttl, ttr, nptrs)\n \n /* Returns 1 if TYPE1 is at least as qualified as TYPE2.  */\n \n-int\n-at_least_as_qualified_p (type1, type2)\n-     tree type1;\n-     tree type2;\n+bool\n+at_least_as_qualified_p (tree type1, tree type2)\n {\n+  int q1 = cp_type_quals (type1);\n+  int q2 = cp_type_quals (type2);\n+  \n   /* All qualifiers for TYPE2 must also appear in TYPE1.  */\n-  return ((cp_type_quals (type1) & cp_type_quals (type2))\n-\t  == cp_type_quals (type2));\n+  return (q1 & q2) == q2;\n }\n \n /* Returns 1 if TYPE1 is more qualified than TYPE2.  */\n \n-int\n-more_qualified_p (type1, type2)\n-     tree type1;\n-     tree type2;\n+bool\n+more_qualified_p (tree type1, tree type2)\n {\n-  return (cp_type_quals (type1) != cp_type_quals (type2)\n-\t  && at_least_as_qualified_p (type1, type2));\n+  int q1 = cp_type_quals (type1);\n+  int q2 = cp_type_quals (type2);\n+\n+  return q1 != q2 && (q1 & q2) == q2;\n }\n \n /* Returns 1 if TYPE1 is more cv-qualified than TYPE2, -1 if TYPE2 is\n    more cv-qualified that TYPE1, and 0 otherwise.  */\n \n int\n-comp_cv_qualification (type1, type2)\n-     tree type1;\n-     tree type2;\n+comp_cv_qualification (tree type1, tree type2)\n {\n-  if (cp_type_quals (type1) == cp_type_quals (type2))\n+  int q1 = cp_type_quals (type1);\n+  int q2 = cp_type_quals (type2);\n+\n+  if (q1 == q2)\n     return 0;\n \n-  if (at_least_as_qualified_p (type1, type2))\n+  if ((q1 & q2) == q2)\n     return 1;\n-\n-  else if (at_least_as_qualified_p (type2, type1))\n+  else if ((q1 & q2) == q1)\n     return -1;\n \n   return 0;\n@@ -1286,9 +1261,7 @@ comp_cv_qualification (type1, type2)\n    are similar.  Returns -1 if the other way 'round, and 0 otherwise.  */\n \n int\n-comp_cv_qual_signature (type1, type2)\n-     tree type1;\n-     tree type2;\n+comp_cv_qual_signature (tree type1, tree type2)\n {\n   if (comp_ptr_ttypes_real (type2, type1, -1))\n     return 1;\n@@ -1303,8 +1276,7 @@ comp_cv_qual_signature (type1, type2)\n    returns ERROR_MARK_NODE.  */\n \n static tree\n-common_base_type (tt1, tt2)\n-     tree tt1, tt2;\n+common_base_type (tree tt1, tree tt2)\n {\n   tree best = NULL_TREE;\n   int i;\n@@ -1352,36 +1324,31 @@ common_base_type (tt1, tt2)\n \f\n /* Subroutines of `comptypes'.  */\n \n-/* Return 1 if two parameter type lists PARMS1 and PARMS2 are\n+/* Return true if two parameter type lists PARMS1 and PARMS2 are\n    equivalent in the sense that functions with those parameter types\n    can have equivalent types.  The two lists must be equivalent,\n-   element by element.\n+   element by element.  */\n \n-   C++: See comment above about TYPE1, TYPE2.  */\n-\n-int\n-compparms (parms1, parms2)\n-     tree parms1, parms2;\n+bool\n+compparms (tree parms1, tree parms2)\n {\n-  register tree t1 = parms1, t2 = parms2;\n+  tree t1, t2;\n \n   /* An unspecified parmlist matches any specified parmlist\n      whose argument types don't need default promotions.  */\n \n-  while (1)\n+  for (t1 = parms1, t2 = parms2;\n+       t1 || t2;\n+       t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n     {\n-      if (t1 == 0 && t2 == 0)\n-\treturn 1;\n       /* If one parmlist is shorter than the other,\n \t they fail to match.  */\n-      if (t1 == 0 || t2 == 0)\n-\treturn 0;\n+      if (!t1 || !t2)\n+\treturn false;\n       if (!same_type_p (TREE_VALUE (t2), TREE_VALUE (t1)))\n-\treturn 0;\n-\n-      t1 = TREE_CHAIN (t1);\n-      t2 = TREE_CHAIN (t2);\n+\treturn false;\n     }\n+  return true;\n }\n \n /* This really wants return whether or not parameter type lists\n@@ -1394,8 +1361,7 @@ compparms (parms1, parms2)\n    (jason 17 Apr 1997)  */\n \n static int\n-comp_target_parms (parms1, parms2)\n-     tree parms1, parms2;\n+comp_target_parms (tree parms1, tree parms2)\n {\n   register tree t1 = parms1, t2 = parms2;\n   int warn_contravariance = 0;\n@@ -1461,10 +1427,7 @@ comp_target_parms (parms1, parms2)\n }\n \f\n tree\n-cxx_sizeof_or_alignof_type (type, op, complain)\n-     tree type;\n-     enum tree_code op;\n-     int complain;\n+cxx_sizeof_or_alignof_type (tree type, enum tree_code op, int complain)\n {\n   enum tree_code type_code;\n   tree value;\n@@ -1499,8 +1462,7 @@ cxx_sizeof_or_alignof_type (type, op, complain)\n }\n \n tree\n-expr_sizeof (e)\n-     tree e;\n+expr_sizeof (tree e)\n {\n   if (processing_template_decl)\n     return build_min_nt (SIZEOF_EXPR, e);\n@@ -1538,8 +1500,7 @@ expr_sizeof (e)\n    constants are replaced by their values.  */\n \n tree\n-decay_conversion (exp)\n-     tree exp;\n+decay_conversion (tree exp)\n {\n   register tree type;\n   register enum tree_code code;\n@@ -1656,8 +1617,7 @@ decay_conversion (exp)\n }\n \n tree\n-default_conversion (exp)\n-     tree exp;\n+default_conversion (tree exp)\n {\n   tree type;\n   enum tree_code code;\n@@ -1681,8 +1641,7 @@ default_conversion (exp)\n    or TREE_USED.  */\n \n tree\n-inline_conversion (exp)\n-     tree exp;\n+inline_conversion (tree exp)\n {\n   if (TREE_CODE (exp) == FUNCTION_DECL)\n     exp = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (exp)), exp);\n@@ -1694,9 +1653,7 @@ inline_conversion (exp)\n    decay_conversion to one.  */\n \n int\n-string_conv_p (totype, exp, warn)\n-     tree totype, exp;\n-     int warn;\n+string_conv_p (tree totype, tree exp, int warn)\n {\n   tree t;\n \n@@ -1742,9 +1699,7 @@ string_conv_p (totype, exp, warn)\n    get it there.  */\n \n static tree\n-rationalize_conditional_expr (code, t)\n-     enum tree_code code;\n-     tree t;\n+rationalize_conditional_expr (enum tree_code code, tree t)\n {\n   /* For MIN_EXPR or MAX_EXPR, fold-const.c has arranged things so that\n      the first operand is always the one to be used if both operands\n@@ -1772,8 +1727,7 @@ rationalize_conditional_expr (code, t)\n    that are directly reachable.  */\n \n static tree\n-lookup_anon_field (t, type)\n-     tree t, type;\n+lookup_anon_field (tree t, tree type)\n {\n   tree field;\n \n@@ -4068,10 +4022,7 @@ build_nop (tree type, tree expr)\n    (such as from short to int).  */\n \n tree\n-build_unary_op (code, xarg, noconvert)\n-     enum tree_code code;\n-     tree xarg;\n-     int noconvert;\n+build_unary_op (enum tree_code code, tree xarg, int noconvert)\n {\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n   register tree arg = xarg;\n@@ -4522,9 +4473,7 @@ build_unary_op (code, xarg, noconvert)\n    If ARG is not a kind of expression we can handle, return zero.  */\n    \n tree\n-unary_complex_lvalue (code, arg)\n-     enum tree_code code;\n-     tree arg;\n+unary_complex_lvalue (enum tree_code code, tree arg)\n {\n   /* Handle (a, b) used as an \"lvalue\".  */\n   if (TREE_CODE (arg) == COMPOUND_EXPR)\n@@ -4661,8 +4610,7 @@ unary_complex_lvalue (code, arg)\n    C++: we do not allow `current_class_ptr' to be addressable.  */\n \n bool\n-cxx_mark_addressable (exp)\n-     tree exp;\n+cxx_mark_addressable (tree exp)\n {\n   register tree x = exp;\n \n@@ -4727,8 +4675,7 @@ cxx_mark_addressable (exp)\n /* Build and return a conditional expression IFEXP ? OP1 : OP2.  */\n \n tree\n-build_x_conditional_expr (ifexp, op1, op2)\n-     tree ifexp, op1, op2;\n+build_x_conditional_expr (tree ifexp, tree op1, tree op2)\n {\n   if (processing_template_decl)\n     return build_min_nt (COND_EXPR, ifexp, op1, op2);\n@@ -4740,8 +4687,7 @@ build_x_conditional_expr (ifexp, op1, op2)\n    this function just builds an expression list.  */\n \n tree\n-build_x_compound_expr (list)\n-     tree list;\n+build_x_compound_expr (tree list)\n {\n   tree rest = TREE_CHAIN (list);\n   tree result;\n@@ -4784,8 +4730,7 @@ build_x_compound_expr (list)\n    that performs them all and returns the value of the last of them.  */\n \n tree\n-build_compound_expr (list)\n-     tree list;\n+build_compound_expr (tree list)\n {\n   register tree rest;\n   tree first;\n@@ -4820,8 +4765,7 @@ build_compound_expr (list)\n }\n \n tree\n-build_static_cast (type, expr)\n-   tree type, expr;\n+build_static_cast (tree type, tree expr)\n {\n   tree intype;\n   int ok;\n@@ -4933,8 +4877,7 @@ build_static_cast (type, expr)\n }\n \n tree\n-build_reinterpret_cast (type, expr)\n-   tree type, expr;\n+build_reinterpret_cast (tree type, tree expr)\n {\n   tree intype;\n \n@@ -5024,8 +4967,7 @@ build_reinterpret_cast (type, expr)\n }\n \n tree\n-build_const_cast (type, expr)\n-   tree type, expr;\n+build_const_cast (tree type, tree expr)\n {\n   tree intype;\n \n@@ -5094,8 +5036,7 @@ build_const_cast (type, expr)\n    when doing the cast.  */\n \n tree\n-build_c_cast (type, expr)\n-     tree type, expr;\n+build_c_cast (tree type, tree expr)\n {\n   register tree value = expr;\n   tree otype;\n@@ -5261,10 +5202,7 @@ build_c_cast (type, expr)\n    C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.  */\n \n tree\n-build_modify_expr (lhs, modifycode, rhs)\n-     tree lhs;\n-     enum tree_code modifycode;\n-     tree rhs;\n+build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n {\n   register tree result;\n   tree newrhs = rhs;\n@@ -5627,10 +5565,7 @@ build_modify_expr (lhs, modifycode, rhs)\n }\n \n tree\n-build_x_modify_expr (lhs, modifycode, rhs)\n-     tree lhs;\n-     enum tree_code modifycode;\n-     tree rhs;\n+build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n {\n   if (processing_template_decl)\n     return build_min_nt (MODOP_EXPR, lhs,\n@@ -5657,9 +5592,7 @@ build_x_modify_expr (lhs, modifycode, rhs)\n    a pointer to member of FROM to a pointer to member of TO.  */\n \n static tree\n-get_delta_difference (from, to, force)\n-     tree from, to;\n-     int force;\n+get_delta_difference (tree from, tree to, int force)\n {\n   tree delta = integer_zero_node;\n   tree binfo;\n@@ -5722,8 +5655,7 @@ get_delta_difference (from, to, force)\n    the other components as specified.  */\n \n tree\n-build_ptrmemfunc1 (type, delta, pfn)\n-     tree type, delta, pfn;\n+build_ptrmemfunc1 (tree type, tree delta, tree pfn)\n {\n   tree u = NULL_TREE;\n   tree delta_field;\n@@ -5761,9 +5693,7 @@ build_ptrmemfunc1 (type, delta, pfn)\n    Return error_mark_node, if something goes wrong.  */\n \n tree\n-build_ptrmemfunc (type, pfn, force)\n-     tree type, pfn;\n-     int force;\n+build_ptrmemfunc (tree type, tree pfn, int force)\n {\n   tree fn;\n   tree pfn_type;\n@@ -5848,10 +5778,7 @@ build_ptrmemfunc (type, pfn, force)\n    integer_type_node.  */\n \n void\n-expand_ptrmemfunc_cst (cst, delta, pfn)\n-     tree cst;\n-     tree *delta;\n-     tree *pfn;\n+expand_ptrmemfunc_cst (tree cst, tree *delta, tree *pfn)\n {\n   tree type = TREE_TYPE (cst);\n   tree fn = PTRMEM_CST_MEMBER (cst);\n@@ -5914,8 +5841,7 @@ expand_ptrmemfunc_cst (cst, delta, pfn)\n    given by T.  */\n \n tree\n-pfn_from_ptrmemfunc (t)\n-     tree t;\n+pfn_from_ptrmemfunc (tree t)\n {\n   if (TREE_CODE (t) == PTRMEM_CST)\n     {\n@@ -5935,12 +5861,8 @@ pfn_from_ptrmemfunc (t)\n    marked EXPR.  */\n \n tree\n-dubious_conversion_warnings (type, expr, errtype, fndecl, parmnum)\n-     tree type;\n-     tree expr;\n-     const char *errtype;\n-     tree fndecl;\n-     int parmnum;\n+dubious_conversion_warnings (tree type, tree expr,\n+\t\t\t     const char *errtype, tree fndecl, int parmnum)\n {\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n@@ -5995,11 +5917,8 @@ dubious_conversion_warnings (type, expr, errtype, fndecl, parmnum)\n    FNDECL.  */\n \n static tree\n-convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n-     tree type, rhs;\n-     const char *errtype;\n-     tree fndecl;\n-     int parmnum;\n+convert_for_assignment (tree type, tree rhs,\n+\t\t\tconst char *errtype, tree fndecl, int parmnum)\n {\n   register enum tree_code codel = TREE_CODE (type);\n   register tree rhstype;\n@@ -6099,12 +6018,8 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n    If flags doesn't include LOOKUP_COMPLAIN, don't complain about anything.  */\n \n tree\n-convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n-     tree exp, type, rhs;\n-     int flags;\n-     const char *errtype;\n-     tree fndecl;\n-     int parmnum;\n+convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n+\t\t\t    const char *errtype, tree fndecl, int parmnum)\n {\n   register enum tree_code codel = TREE_CODE (type);\n   register tree rhstype;\n@@ -6194,11 +6109,8 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n    up operands that are expected to be in memory.  */\n \n void\n-c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n-     tree string, outputs, inputs, clobbers;\n-     int vol;\n-     const char *filename;\n-     int line;\n+c_expand_asm_operands (tree string, tree outputs, tree inputs, tree clobbers,\n+\t\t       int vol, const char *filename, int line)\n {\n   int noutputs = list_length (outputs);\n   register int i;\n@@ -6248,8 +6160,7 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n    temporary give an appropraite warning.  */\n \n static void\n-maybe_warn_about_returning_address_of_local (retval)\n-     tree retval;\n+maybe_warn_about_returning_address_of_local (tree retval)\n {\n   tree valtype = TREE_TYPE (DECL_RESULT (current_function_decl));\n   tree whats_returned = retval;\n@@ -6309,8 +6220,7 @@ maybe_warn_about_returning_address_of_local (retval)\n    the DECL_RESULT for the function.  */\n \n tree\n-check_return_expr (retval)\n-     tree retval;\n+check_return_expr (tree retval)\n {\n   tree result;\n   /* The type actually returned by the function, after any\n@@ -6500,9 +6410,7 @@ check_return_expr (retval)\n    const-qualified.  */\n \n static int\n-comp_ptr_ttypes_real (to, from, constp)\n-     tree to, from;\n-     int constp;\n+comp_ptr_ttypes_real (tree to, tree from, int constp)\n {\n   int to_more_cv_qualified = 0;\n \n@@ -6546,8 +6454,7 @@ comp_ptr_ttypes_real (to, from, constp)\n    types to this function.  */\n \n int\n-comp_ptr_ttypes (to, from)\n-     tree to, from;\n+comp_ptr_ttypes (tree to, tree from)\n {\n   return comp_ptr_ttypes_real (to, from, 1);\n }\n@@ -6556,8 +6463,7 @@ comp_ptr_ttypes (to, from)\n    type or inheritance-related types, regardless of cv-quals.  */\n \n int\n-ptr_reasonably_similar (to, from)\n-     tree to, from;\n+ptr_reasonably_similar (tree to, tree from)\n {\n   for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n     {\n@@ -6592,8 +6498,7 @@ ptr_reasonably_similar (to, from)\n /* Like comp_ptr_ttypes, for const_cast.  */\n \n static int\n-comp_ptr_ttypes_const (to, from)\n-     tree to, from;\n+comp_ptr_ttypes_const (tree to, tree from)\n {\n   for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n     {\n@@ -6613,8 +6518,7 @@ comp_ptr_ttypes_const (to, from)\n /* Like comp_ptr_ttypes, for reinterpret_cast.  */\n \n static int\n-comp_ptr_ttypes_reinterpret (to, from)\n-     tree to, from;\n+comp_ptr_ttypes_reinterpret (tree to, tree from)\n {\n   int constp = 1;\n \n@@ -6649,8 +6553,7 @@ comp_ptr_ttypes_reinterpret (to, from)\n    elements for an array type.  */\n \n int\n-cp_type_quals (type)\n-     tree type;\n+cp_type_quals (tree type)\n {\n   type = strip_array_types (type);\n   if (type == error_mark_node)\n@@ -6660,9 +6563,8 @@ cp_type_quals (type)\n \n /* Returns nonzero if the TYPE contains a mutable member */\n \n-int\n-cp_has_mutable_p (type)\n-     tree type;\n+bool\n+cp_has_mutable_p (tree type)\n {\n   type = strip_array_types (type);\n \n@@ -6674,9 +6576,7 @@ cp_has_mutable_p (type)\n    if and only if there is no implicit conversion from T1 to T2.  */\n \n static void\n-casts_away_constness_r (t1, t2)\n-     tree *t1;\n-     tree *t2;\n+casts_away_constness_r (tree *t1, tree *t2)\n {\n   int quals1;\n   int quals2;\n@@ -6734,10 +6634,8 @@ casts_away_constness_r (t1, t2)\n /* Returns nonzero if casting from TYPE1 to TYPE2 casts away\n    constness.  */\n \n-static int\n-casts_away_constness (t1, t2)\n-     tree t1;\n-     tree t2;\n+static bool\n+casts_away_constness (tree t1, tree t2)\n {\n   if (TREE_CODE (t2) == REFERENCE_TYPE)\n     {\n@@ -6747,8 +6645,7 @@ casts_away_constness (t1, t2)\n \t using a reference cast casts away constness if a cast from an\n \t rvalue of type \"pointer to T1\" to the type \"pointer to T2\"\n \t casts away constness.  */\n-      t1 = (TREE_CODE (t1) == REFERENCE_TYPE\n-\t    ? TREE_TYPE (t1) : t1);\n+      t1 = (TREE_CODE (t1) == REFERENCE_TYPE ? TREE_TYPE (t1) : t1);\n       return casts_away_constness (build_pointer_type (t1),\n \t\t\t\t   build_pointer_type (TREE_TYPE (t2)));\n     }\n@@ -6769,16 +6666,16 @@ casts_away_constness (t1, t2)\n      pointer or reference types.  */\n   if (TREE_CODE (t1) != POINTER_TYPE \n       || TREE_CODE (t2) != POINTER_TYPE)\n-    return 0;\n+    return false;\n \n   /* Top-level qualifiers don't matter.  */\n   t1 = TYPE_MAIN_VARIANT (t1);\n   t2 = TYPE_MAIN_VARIANT (t2);\n   casts_away_constness_r (&t1, &t2);\n   if (!can_convert (t2, t1))\n-    return 1;\n+    return true;\n \n-  return 0;\n+  return false;\n }\n \n /* Returns TYPE with its cv qualifiers removed\n@@ -6787,8 +6684,7 @@ casts_away_constness (t1, t2)\n    above are those of the array members.)  */\n \n static tree\n-strip_all_pointer_quals (type)\n-     tree type;\n+strip_all_pointer_quals (tree type)\n {\n   if (TREE_CODE (type) == POINTER_TYPE)\n     return build_pointer_type (strip_all_pointer_quals (TREE_TYPE (type)));"}]}