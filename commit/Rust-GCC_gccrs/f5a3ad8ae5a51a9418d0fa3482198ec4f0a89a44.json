{"sha": "f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVhM2FkOGFlNWE1MWE5NDE4ZDBmYTM0ODIxOThlYzRmMGE4OWE0NA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-03-16T03:19:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-03-16T03:19:46Z"}, "message": "re PR tree-optimization/71437 (Performance regression after r235817)\n\n\tPR tree-optimization/71437\n\t* tree-ssa-dom.c (derive_equivalences_from_bit_ior): New function.\n\t(record_temporary_equivalences): Use it.\n\nFrom-SVN: r246187", "tree": {"sha": "65c6d842e49784b8797c351ac73767ffff8c3ae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65c6d842e49784b8797c351ac73767ffff8c3ae1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44/comments", "author": null, "committer": null, "parents": [{"sha": "a3d514f231af029090ba40ebcdae4226b739433c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3d514f231af029090ba40ebcdae4226b739433c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3d514f231af029090ba40ebcdae4226b739433c"}], "stats": {"total": 56, "additions": 54, "deletions": 2}, "files": [{"sha": "82ab3d749c9fc7e03b2e1b3009ddf755f41fac38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44", "patch": "@@ -1,5 +1,9 @@\n 2017-03-15  Jeff Law  <law@redhat.com>\n-\t\n+\n+\tPR tree-optimization/71437\n+\t* tree-ssa-dom.c (derive_equivalences_from_bit_ior): New function.\n+\t(record_temporary_equivalences): Use it.\n+\n \tPR tree-optimization/71437\n \t* tree-ssa-dom.c (struct cond_equivalence): Moved from here into\n \ttree-ssa-scopedtables."}, {"sha": "0ebe892977d6cc3ab7310a083451e622a1c8f903", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=f5a3ad8ae5a51a9418d0fa3482198ec4f0a89a44", "patch": "@@ -691,6 +691,33 @@ back_propagate_equivalences (tree lhs, edge e,\n     BITMAP_FREE (domby);\n }\n \n+/* Record NAME has the value zero and if NAME was set from a BIT_IOR_EXPR\n+   recurse into both operands recording their values as zero too.  */\n+\n+static void\n+derive_equivalencs_from_bit_ior (tree name, const_and_copies *const_and_copies)\n+{\n+  if (TREE_CODE (name) == SSA_NAME)\n+    {\n+      tree value = fold_convert (TREE_TYPE (name), integer_zero_node);\n+\n+      /* This records the equivalence for the toplevel object.  */\n+      record_equality (name, value, const_and_copies);\n+\n+      /* And we can recurse into each operand to potentially find more\n+\t equivalences.  */\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n+      if (is_gimple_assign (def_stmt)\n+\t  && gimple_assign_rhs_code (def_stmt) == BIT_IOR_EXPR)\n+\t{\n+\t  derive_equivalencs_from_bit_ior (gimple_assign_rhs1 (def_stmt),\n+\t\t\t\t\t   const_and_copies);\n+\t  derive_equivalencs_from_bit_ior (gimple_assign_rhs2 (def_stmt),\n+\t\t\t\t\t   const_and_copies);\n+\t}\n+    }\n+}\n+\n /* Record into CONST_AND_COPIES and AVAIL_EXPRS_STACK any equivalences implied\n    by traversing edge E (which are cached in E->aux).\n \n@@ -711,7 +738,28 @@ record_temporary_equivalences (edge e,\n       /* If we have 0 = COND or 1 = COND equivalences, record them\n \t into our expression hash tables.  */\n       for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n-\tavail_exprs_stack->record_cond (eq);\n+\t{\n+\t  avail_exprs_stack->record_cond (eq);\n+\n+\t  /* If the condition is testing that X == 0 is true or X != 0 is false\n+\t     and X is set from a BIT_IOR_EXPR, then we can record equivalences\n+\t     for the operands of the BIT_IOR_EXPR (and recurse on those).  */\n+\t  tree op0 = eq->cond.ops.binary.opnd0;\n+\t  tree op1 = eq->cond.ops.binary.opnd1;\n+\t  if (TREE_CODE (op0) == SSA_NAME && integer_zerop (op1))\n+\t    {\n+\t      enum tree_code code = eq->cond.ops.binary.op;\n+\t      if ((code == EQ_EXPR && eq->value == boolean_true_node)\n+\t\t  || (code == NE_EXPR && eq->value == boolean_false_node))\n+\t\tderive_equivalencs_from_bit_ior (op0, const_and_copies);\n+\n+\t      /* TODO: We could handle BIT_AND_EXPR in a similar fashion\n+\t\t recording that the operands have a nonzero value.  */\n+\n+\t      /* TODO: We can handle more cases here, particularly when OP0 is\n+\t\t known to have a boolean range.  */\n+\t    }\n+\t}\n \n       tree lhs = edge_info->lhs;\n       if (!lhs || TREE_CODE (lhs) != SSA_NAME)"}]}