{"sha": "7888a6aecc26ae7f7d406e893e0620dfccb1837b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg4OGE2YWVjYzI2YWU3ZjdkNDA2ZTg5M2UwNjIwZGZjY2IxODM3Yg==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2007-06-06T10:25:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:25:50Z"}, "message": "exp_ch6.ads, [...] (Expand_Call): When adding an extra accessibility actual...\n\n2007-04-20  Gary Dismukes  <dismukes@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.ads, exp_ch6.adb (Expand_Call): When adding an extra\n\taccessibility actual, check for the case of an aliased object that has\n\tbeen rewritten as an Access attribute, and assign Prev to Prev_Orig so\n\twe fall into processing for the attribute rather than the name of the\n\tobject.\n\t(Expand_Inline_Call): If an actual is a literal, and the corresponding\n\tformal has its address taken in the body, create a temporary to capture\n\tvalue.  If the return type is a limited interface, do not treat the\n\treturn value as Controlled.\n\t(Is_In_Place_Function):  If the return type is a limited interface,\n\ttreat as returning in place. The actual returned object may not always\n\tbe limited, but the caller has to assume that it is returned in place.\n\t(Add_Final_List_Actual_To_Build_In_Place_Call): If the call is the\n\tcontext of an allocator, use the correct finalization chain (that is,\n\tthe chain belonging to the access type, rather than the chain belonging\n\tto the current scope).\n\t(Add_Alloc_Form_Actual_To_Build_In_Place_Call): Test for a tagged\n\tresult type rather than a controlling result as a precondition for\n\tadding an allocation form actual to a build-in-place call.\n\t(Add_Final_List_Actual_To_Build_In_Place_Call): Ditto.\n\t(Freeze_Subprogram): Code cleanup. Remove all the code that register the\n\tprimitive in the dispatch tables. This work is now done by Make_DT when\n\tthe type is frozen.\n\t(Register_Predefined_DT_Entry): Removed.\n\t(Add_Return): If end label is not present, use sloc of last statement\n\tfor generated return statement in procedure, for better gdb behavior\n\ton expanded code.\n\t(Add_Access_Actual_To_Build_In_Place_Call): Set parent fields of the\n\tobject address nodes to ensure proper processing by routines like\n\tInsert_After*.\n\t(Expand_Call): Fix generation of validity check for parameter\n\t(Add_Alloc_Form_Actual_To_Build_In_Place_Call): Return without passing\n\tthe allocation form parameter if the result subtype is constrained,\n\texcept when the function has a controlling result.\n\t(Add_Final_List_Actual_To_Build_In_Place_Call): Test Controlled_Type\n\trather than Is_Controlled and Has_Controlled_Component, since we want to\n\tinclude class-wide result types in this treatment. Also test for a\n\tcontrolling result, since that also requires passing a finalization\n\tlist.\n\t(Make_Build_In_Place_Call_In_Allocator): Call Add_Alloc_Form_Actual_*\n\teven when the result subtype is constrained, to handle calls involving\n\tcontrolling results.\n\t(Make_Build_In_Place_Call_In_Anonymous_Context): Add_Alloc_Form_Actual_*\n\tis now called even when the result subtype is constrained, to handle\n\tcalls involving controlling results.\n\t(Make_Build_In_Place_Call_In_Assignment): Remove test for Is_Constrained\n\ton call to Add_Alloc_Form_Actual_To_Build_In_Place_Call (that procedure\n\tnow performs the test).\n\t(Make_Build_In_Place_Call_In_Object_Declaration):\n\tAdd_Alloc_Form_Actual_* is now called even when the result subtype is\n\tconstrained, to handle calls involving controlling results.\n\t(Add_Return): Accomodate rewritten pattern from local raise to goto\n\ttransformation, so that we still recognize an transfer statement\n\tand do the right thing here in that case.\n\t(Expand_N_Subprogram_Body): Add dummy Push/Pop_xxx_Label nodes at start\n\tand end of subprogram code.\n\t(Register_Interface_DT_Entry, Register_Predefined_DT_Entry): Add missing\n\tsupport for primitives that are functions (without formals) with a\n\tcontrolling result.\n\t(Inherited_From_Formal): If the actual subtype has not generic parent\n\ttype, it is not an actual for a formal derived type, and there is no\n\toperation to inherit from the formal.\n\nFrom-SVN: r125399", "tree": {"sha": "1432e807f3070b618d4b46fb313c6cae5e25b550", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1432e807f3070b618d4b46fb313c6cae5e25b550"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7888a6aecc26ae7f7d406e893e0620dfccb1837b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7888a6aecc26ae7f7d406e893e0620dfccb1837b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7888a6aecc26ae7f7d406e893e0620dfccb1837b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7888a6aecc26ae7f7d406e893e0620dfccb1837b/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a79ec8c58c6a8b452a3916fe8d74712c1b0ab708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79ec8c58c6a8b452a3916fe8d74712c1b0ab708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a79ec8c58c6a8b452a3916fe8d74712c1b0ab708"}], "stats": {"total": 848, "additions": 417, "deletions": 431}, "files": [{"sha": "d3ee497d77b33e3cfed0c7d4bc2fcda3e3dbbda3", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 412, "deletions": 420, "changes": 832, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7888a6aecc26ae7f7d406e893e0620dfccb1837b/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7888a6aecc26ae7f7d406e893e0620dfccb1837b/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=7888a6aecc26ae7f7d406e893e0620dfccb1837b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,9 +44,9 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n-with Hostparm; use Hostparm;\n with Inline;   use Inline;\n with Lib;      use Lib;\n+with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -67,8 +67,8 @@ with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n-with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n \n@@ -110,10 +110,14 @@ package body Exp_Ch6 is\n \n    procedure Add_Final_List_Actual_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n-      Function_Id   : Entity_Id);\n+      Function_Id   : Entity_Id;\n+      Acc_Type      : Entity_Id);\n    --  Ada 2005 (AI-318-02): For a build-in-place call, if the result type has\n-   --  controlled parts, add an actual parameter that is a pointer to caller's\n-   --  finalization list.\n+   --  controlled parts, add an actual parameter that is a pointer to\n+   --  appropriate finalization list. The finalization list is that of the\n+   --  current scope, except for \"new Acc'(F(...))\" in which case it's the\n+   --  finalization list of the access type returned by the allocator. Acc_Type\n+   --  is that type in the allocator case; Empty otherwise.\n \n    procedure Add_Task_Actuals_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n@@ -230,13 +234,15 @@ package body Exp_Ch6 is\n \n       if not Present (Return_Object) then\n          Obj_Address := Make_Null (Loc);\n+         Set_Parent (Obj_Address, Function_Call);\n \n       --  If Return_Object is already an expression of an access type, then use\n       --  it directly, since it must be an access value denoting the return\n       --  object, and couldn't possibly be the return object itself.\n \n       elsif Is_Access then\n          Obj_Address := Return_Object;\n+         Set_Parent (Obj_Address, Function_Call);\n \n       --  Apply Unrestricted_Access to caller's return object\n \n@@ -245,6 +251,9 @@ package body Exp_Ch6 is\n             Make_Attribute_Reference (Loc,\n               Prefix         => Return_Object,\n               Attribute_Name => Name_Unrestricted_Access);\n+\n+         Set_Parent (Return_Object, Obj_Address);\n+         Set_Parent (Obj_Address, Function_Call);\n       end if;\n \n       Analyze_And_Resolve (Obj_Address, Etype (Obj_Acc_Formal));\n@@ -270,6 +279,19 @@ package body Exp_Ch6 is\n       Alloc_Form_Formal : Node_Id;\n \n    begin\n+      --  The allocation form generally doesn't need to be passed in the case\n+      --  of a constrained result subtype, since normally the caller performs\n+      --  the allocation in that case. However this formal is still needed in\n+      --  the case where the function has a tagged result, because generally\n+      --  such functions can be called in a dispatching context and such calls\n+      --  must be handled like calls to class-wide functions.\n+\n+      if Is_Constrained (Underlying_Type (Etype (Function_Id)))\n+        and then not Is_Tagged_Type (Underlying_Type (Etype (Function_Id)))\n+      then\n+         return;\n+      end if;\n+\n       --  Locate the implicit allocation form parameter in the called function.\n       --  Maybe it would be better for each implicit formal of a build-in-place\n       --  function to have a flag or a Uint attribute to identify it. ???\n@@ -357,28 +379,48 @@ package body Exp_Ch6 is\n \n    procedure Add_Final_List_Actual_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n-      Function_Id   : Entity_Id)\n+      Function_Id   : Entity_Id;\n+      Acc_Type      : Entity_Id)\n    is\n       Loc               : constant Source_Ptr := Sloc (Function_Call);\n       Final_List        : Node_Id;\n       Final_List_Actual : Node_Id;\n       Final_List_Formal : Node_Id;\n \n    begin\n-      --  No such extra parameter is needed if there are no controlled parts\n-\n-      if not (Is_Controlled (Etype (Function_Id))\n-              or else Has_Controlled_Component (Etype (Function_Id))) then\n+      --  No such extra parameter is needed if there are no controlled parts.\n+      --  The test for Controlled_Type accounts for class-wide results (which\n+      --  potentially have controlled parts, even if the root type doesn't),\n+      --  and the test for a tagged result type is needed because calls to\n+      --  such a function can in general occur in dispatching contexts, which\n+      --  must be treated the same as a call to class-wide functions. Both of\n+      --  these situations require that a finalization list be passed.\n+\n+      if not Controlled_Type (Underlying_Type (Etype (Function_Id)))\n+        and then not Is_Tagged_Type (Underlying_Type (Etype (Function_Id)))\n+      then\n          return;\n       end if;\n \n       --  Locate implicit finalization list parameter in the called function\n \n       Final_List_Formal := Build_In_Place_Formal (Function_Id, BIP_Final_List);\n \n-      --  Create the actual which is a pointer to the current finalization list\n+      --  Create the actual which is a pointer to the appropriate finalization\n+      --  list. Acc_Type is present if and only if this call is the\n+      --  initialization of an allocator. Use the Current_Scope or the Acc_Type\n+      --  as appropriate.\n+\n+      if Present (Acc_Type)\n+        and then (Ekind (Acc_Type) = E_Anonymous_Access_Type\n+                   or else\n+                     Present (Associated_Final_Chain (Base_Type (Acc_Type))))\n+      then\n+         Final_List := Find_Final_List (Acc_Type);\n+      else\n+         Final_List := Find_Final_List (Current_Scope);\n+      end if;\n \n-      Final_List := Find_Final_List (Current_Scope);\n       Final_List_Actual :=\n         Make_Attribute_Reference (Loc,\n           Prefix         => Final_List,\n@@ -499,9 +541,9 @@ package body Exp_Ch6 is\n            Chars (Extra_Formal) =\n              New_External_Name (Chars (Func), BIP_Formal_Suffix (Kind));\n          Next_Formal_With_Extras (Extra_Formal);\n+         pragma Assert (Present (Extra_Formal));\n       end loop;\n \n-      pragma Assert (Present (Extra_Formal));\n       return Extra_Formal;\n    end Build_In_Place_Formal;\n \n@@ -735,7 +777,7 @@ package body Exp_Ch6 is\n       --  Push our current scope for analyzing the declarations and code that\n       --  we will insert for the checking.\n \n-      New_Scope (Spec);\n+      Push_Scope (Spec);\n \n       --  This loop builds temporary variables for each of the referenced\n       --  globals, so that at the end of the loop the list Shad_List contains\n@@ -1261,7 +1303,7 @@ package body Exp_Ch6 is\n             return False;\n \n          --  For users of Starlet, we assume that the specification of by-\n-         --  reference mechanism is mandatory. This may lead to unligned\n+         --  reference mechanism is mandatory. This may lead to unaligned\n          --  objects but at least for DEC legacy code it is known to work.\n          --  The warning will alert users of this code that a problem may\n          --  be lurking.\n@@ -1461,7 +1503,7 @@ package body Exp_Ch6 is\n             elsif Is_Possibly_Unaligned_Slice (Actual) then\n                Add_Call_By_Copy_Code;\n \n-            --  Deal with access types where the actual subtpe and the\n+            --  Deal with access types where the actual subtype and the\n             --  formal subtype are not the same, requiring a check.\n \n             --  It is necessary to exclude tagged types because of \"downward\n@@ -1750,6 +1792,13 @@ package body Exp_Ch6 is\n             Gen_Par := Generic_Parent_Type (Parent (Par));\n          end if;\n \n+         --  If the actual has no generic parent type, the formal is not\n+         --  a formal derived type, so nothing to inherit.\n+\n+         if No (Gen_Par) then\n+            return Empty;\n+         end if;\n+\n          --  If the generic parent type is still the generic type, this is a\n          --  private formal, not a derived formal, and there are no operations\n          --  inherited from the formal.\n@@ -1835,8 +1884,12 @@ package body Exp_Ch6 is\n          --  if we can tell that the first parameter cannot possibly be null.\n          --  This helps optimization and also generation of warnings.\n \n-         if not Restriction_Active (No_Exception_Handlers)\n-           and then Is_RTE (Subp, RE_Raise_Exception)\n+         --  We do not do this if Raise_Exception_Always does not exist, which\n+         --  can happen in configurable run time profiles which provide only a\n+         --  Raise_Exception, which is in fact an unconditional raise anyway.\n+\n+         if Is_RTE (Subp, RE_Raise_Exception)\n+           and then RTE_Available (RE_Raise_Exception_Always)\n          then\n             declare\n                FA : constant Node_Id := Original_Node (First_Actual (N));\n@@ -1850,7 +1903,7 @@ package body Exp_Ch6 is\n                  and then Attribute_Name (FA) = Name_Identity\n                then\n                   Subp := RTE (RE_Raise_Exception_Always);\n-                  Set_Entity (Name (N), Subp);\n+                  Set_Name (N, New_Occurrence_Of (Subp, Loc));\n                end if;\n             end;\n          end if;\n@@ -1928,8 +1981,14 @@ package body Exp_Ch6 is\n          Prev := Actual;\n          Prev_Orig := Original_Node (Prev);\n \n+         --  The original actual may have been a call written in prefix\n+         --  form, and rewritten before analysis.\n+\n          if not Analyzed (Prev_Orig)\n-           and then Nkind (Actual) = N_Function_Call\n+           and then\n+             (Nkind (Actual) = N_Function_Call\n+                or else\n+              Nkind (Actual) = N_Identifier)\n          then\n             Prev_Orig := Prev;\n          end if;\n@@ -2026,6 +2085,23 @@ package body Exp_Ch6 is\n          --  Create possible extra actual for accessibility level\n \n          if Present (Extra_Accessibility (Formal)) then\n+\n+            --  Ada 2005 (AI-252): If the actual was rewritten as an Access\n+            --  attribute, then the original actual may be an aliased object\n+            --  occurring as the prefix in a call using \"Object.Operation\"\n+            --  notation. In that case we must pass the level of the object,\n+            --  so Prev_Orig is reset to Prev and the attribute will be\n+            --  processed by the code for Access attributes further below.\n+\n+            if Prev_Orig /= Prev\n+              and then Nkind (Prev) = N_Attribute_Reference\n+              and then\n+                Get_Attribute_Id (Attribute_Name (Prev)) = Attribute_Access\n+              and then Is_Aliased_View (Prev_Orig)\n+            then\n+               Prev_Orig := Prev;\n+            end if;\n+\n             if Is_Entity_Name (Prev_Orig) then\n \n                --  When passing an access parameter as the actual to another\n@@ -2063,8 +2139,8 @@ package body Exp_Ch6 is\n                      end if;\n                   end;\n \n-               --  The actual is a normal access value, so just pass the\n-               --  level of the actual's access type.\n+               --  The actual is a normal access value, so just pass the level\n+               --  of the actual's access type.\n \n                else\n                   Add_Extra_Actual\n@@ -2173,10 +2249,12 @@ package body Exp_Ch6 is\n                null;\n \n             --  Suppress null checks when passing to access parameters of Java\n-            --  subprograms. (Should this be done for other foreign conventions\n-            --  as well ???)\n+            --  and CIL subprograms. (Should this be done for other foreign\n+            --  conventions as well ???)\n \n-            elsif Convention (Subp) = Convention_Java then\n+            elsif Convention (Subp) = Convention_Java\n+              or else Convention (Subp) = Convention_CIL\n+            then\n                null;\n \n             else\n@@ -2194,14 +2272,28 @@ package body Exp_Ch6 is\n                 (Ekind (Formal) = E_In_Out_Parameter\n                    and then Validity_Check_In_Out_Params)\n             then\n-               --  If the actual is an indexed component of a packed\n-               --  type, it has not been expanded yet. It will be\n-               --  copied in the validity code that follows, and has\n-               --  to be expanded appropriately, so reanalyze it.\n+               --  If the actual is an indexed component of a packed type (or\n+               --  is an indexed or selected component whose prefix recursively\n+               --  meets this condition), it has not been expanded yet. It will\n+               --  be copied in the validity code that follows, and has to be\n+               --  expanded appropriately, so reanalyze it.\n \n-               if Nkind (Actual) = N_Indexed_Component then\n-                  Set_Analyzed (Actual, False);\n-               end if;\n+               --  What we do is just to unset analyzed bits on prefixes till\n+               --  we reach something that does not have a prefix.\n+\n+               declare\n+                  Nod : Node_Id;\n+\n+               begin\n+                  Nod := Actual;\n+                  while Nkind (Nod) = N_Indexed_Component\n+                          or else\n+                        Nkind (Nod) = N_Selected_Component\n+                  loop\n+                     Set_Analyzed (Nod, False);\n+                     Nod := Prefix (Nod);\n+                  end loop;\n+               end;\n \n                Ensure_Valid (Actual);\n             end if;\n@@ -2266,21 +2358,10 @@ package body Exp_Ch6 is\n          --  In a remote call, if the formal is of a class-wide type, check\n          --  that the actual meets the requirements described in E.4(18).\n \n-         if Remote\n-           and then Is_Class_Wide_Type (Etype (Formal))\n-         then\n+         if Remote and then Is_Class_Wide_Type (Etype (Formal)) then\n             Insert_Action (Actual,\n-              Make_Implicit_If_Statement (N,\n-                Condition       =>\n-                  Make_Op_Not (Loc,\n-                    Build_Get_Remotely_Callable (Loc,\n-                      Make_Selected_Component (Loc,\n-                        Prefix => Duplicate_Subexpr_Move_Checks (Actual),\n-                        Selector_Name =>\n-                          Make_Identifier (Loc, Name_uTag)))),\n-                Then_Statements => New_List (\n-                  Make_Raise_Program_Error (Loc,\n-                    Reason => PE_Illegal_RACW_E_4_18))));\n+              Make_Transportable_Check (Loc,\n+                Duplicate_Subexpr_Move_Checks (Actual)));\n          end if;\n \n          --  This label is required when skipping extra actual generation for\n@@ -2366,14 +2447,14 @@ package body Exp_Ch6 is\n       --  extra actuals since this will be done on the re-analysis of the\n       --  dispatching call. Note that we do not try to shorten the actual\n       --  list for a dispatching call, it would not make sense to do so.\n-      --  Expansion of dispatching calls is suppressed when Java_VM, because\n-      --  the JVM back end directly handles the generation of dispatching\n+      --  Expansion of dispatching calls is suppressed when VM_Target, because\n+      --  the VM back-ends directly handle the generation of dispatching\n       --  calls and would have to undo any expansion to an indirect call.\n \n       if (Nkind (N) = N_Function_Call\n            or else Nkind (N) =  N_Procedure_Call_Statement)\n         and then Present (Controlling_Argument (N))\n-        and then not Java_VM\n+        and then VM_Target = No_VM\n       then\n          Expand_Dispatching_Call (N);\n \n@@ -2780,9 +2861,12 @@ package body Exp_Ch6 is\n       end if;\n \n       --  Functions returning controlled objects need special attention\n+      --  If the return type is limited the context is an initialization\n+      --  and different processing applies.\n \n       if Controlled_Type (Etype (Subp))\n         and then not Is_Inherently_Limited_Type (Etype (Subp))\n+        and then not Is_Limited_Interface (Etype (Subp))\n       then\n          Expand_Ctrl_Function_Call (N);\n       end if;\n@@ -2871,9 +2955,6 @@ package body Exp_Ch6 is\n                   Temp   : Node_Id;\n                   Passoc : Node_Id;\n \n-                  Discard : Node_Id;\n-                  pragma Warnings (Off, Discard);\n-\n                begin\n                   --  First step, remove all the named parameters from the\n                   --  list (they are still chained using First_Named_Actual\n@@ -2896,7 +2977,7 @@ package body Exp_Ch6 is\n                      end loop;\n \n                      while Present (Next (Temp)) loop\n-                        Discard := Remove_Next (Temp);\n+                        Remove (Next (Temp));\n                      end loop;\n                   end if;\n \n@@ -2936,9 +3017,15 @@ package body Exp_Ch6 is\n       --  parameter to Raise_Exception is a use of Identity, since in these\n       --  cases we know that the parameter is never null.\n \n+      --  Note: We must check that the node has not been inlined. This is\n+      --  required because under zfp the Raise_Exception subprogram has the\n+      --  pragma inline_always (and hence the call has been expanded above\n+      --  into a block containing the code of the subprogram).\n+\n       if Ada_Version >= Ada_05\n         and then not GNAT_Mode\n         and then Is_RTE (Subp, RE_Raise_Exception)\n+        and then Nkind (N) = N_Procedure_Call_Statement\n         and then (Nkind (First_Actual (N)) /= N_Attribute_Reference\n                    or else Attribute_Name (First_Actual (N)) /= Name_Identity)\n       then\n@@ -3036,7 +3123,7 @@ package body Exp_Ch6 is\n          elsif Nkind (Orig_Bod) /= N_Subprogram_Body then\n             return False;\n \n-         --  Check if this is an ada 2005 null procedure\n+         --  Check if this is an Ada 2005 null procedure\n \n          elsif Nkind (Decl) = N_Subprogram_Declaration\n            and then Null_Present (Specification (Decl))\n@@ -3508,6 +3595,10 @@ package body Exp_Ch6 is\n          --  If the actual is a simple name or a literal, no need to\n          --  create a temporary, object can be used directly.\n \n+         --  If the actual is a literal and the formal has its address taken,\n+         --  we cannot pass the literal itself as an argument, so its value\n+         --  must be captured in a temporary.\n+\n          if (Is_Entity_Name (A)\n               and then\n                (not Is_Scalar_Type (Etype (A))\n@@ -3520,9 +3611,11 @@ package body Exp_Ch6 is\n            or else (Nkind (A) = N_Identifier\n              and then Formal_Is_Used_Once (F))\n \n-           or else Nkind (A) = N_Real_Literal\n-           or else Nkind (A) = N_Integer_Literal\n-           or else Nkind (A) = N_Character_Literal\n+           or else\n+             ((Nkind (A) = N_Real_Literal    or else\n+               Nkind (A) = N_Integer_Literal or else\n+               Nkind (A) = N_Character_Literal)\n+              and then not Address_Taken (F))\n          then\n             if Etype (F) /= Etype (A) then\n                Set_Renamed_Object\n@@ -3563,7 +3656,7 @@ package body Exp_Ch6 is\n \n             --  If the actual has a by-reference type, it cannot be copied, so\n             --  its value is captured in a renaming declaration. Otherwise\n-            --  declare a local constant initalized with the actual.\n+            --  declare a local constant initialized with the actual.\n \n             if Ekind (F) = E_In_Parameter\n               and then not Is_Limited_Type (Etype (A))\n@@ -3745,7 +3838,7 @@ package body Exp_Ch6 is\n       --  If the return type is returned through the secondary stack; that is\n       --  by reference, we don't want to create a temp to force stack checking.\n       --  ???\"sec stack\" is not right -- Ada 95 return-by-reference object are\n-      --  returned whereever they are.\n+      --  returned wherever they are.\n       --  Shouldn't this function be moved to exp_util???\n \n       function Rhs_Of_Assign_Or_Decl (N : Node_Id) return Boolean;\n@@ -3828,7 +3921,7 @@ package body Exp_Ch6 is\n       --  because otherwise gigi may generate a large temporary on the fly and\n       --  this can cause trouble with stack checking.\n \n-      --  This is unecessary if the call is the expression in an object\n+      --  This is unnecessary if the call is the expression in an object\n       --  declaration, or if it appears outside of any library unit. This can\n       --  only happen if it appears as an actual in a library-level instance,\n       --  in which case a temporary will be generated for it once the instance\n@@ -3941,6 +4034,9 @@ package body Exp_Ch6 is\n    --  Add poll call if ATC polling is enabled, unless the body will be\n    --  inlined by the back-end.\n \n+   --  Add dummy push/pop label nodes at start and end to clear any local\n+   --  exception indications if local-exception-to-goto optimization active.\n+\n    --  Add return statement if last statement in body is not a return statement\n    --  (this makes things easier on Gigi which does not want to have to handle\n    --  a missing return).\n@@ -3977,189 +4073,49 @@ package body Exp_Ch6 is\n       --  the latter test is not critical, it does not matter if we add a\n       --  few extra returns, since they get eliminated anyway later on.\n \n-      procedure Expand_Thread_Body;\n-      --  Perform required expansion of a thread body\n-\n       ----------------\n       -- Add_Return --\n       ----------------\n \n       procedure Add_Return (S : List_Id) is\n-      begin\n-         if not Is_Transfer (Last (S)) then\n-\n-            --  The source location for the return is the end label\n-            --  of the procedure in all cases. This is a bit odd when\n-            --  there are exception handlers, but not much else we can do.\n-\n-            Append_To (S, Make_Return_Statement (Sloc (End_Label (H))));\n-         end if;\n-      end Add_Return;\n-\n-      ------------------------\n-      -- Expand_Thread_Body --\n-      ------------------------\n-\n-      --  The required expansion of a thread body is as follows\n-\n-      --  procedure <thread body procedure name> is\n-\n-      --    _Secondary_Stack : aliased\n-      --       Storage_Elements.Storage_Array\n-      --         (1 .. Storage_Offset (Sec_Stack_Size));\n-      --    for _Secondary_Stack'Alignment use Standard'Maximum_Alignment;\n-\n-      --    _Process_ATSD : aliased System.Threads.ATSD;\n-\n-      --  begin\n-      --     System.Threads.Thread_Body_Enter;\n-      --       (_Secondary_Stack'Address,\n-      --        _Secondary_Stack'Length,\n-      --        _Process_ATSD'Address);\n-\n-      --     declare\n-      --        <user declarations>\n-      --     begin\n-      --        <user statements>\n-      --     <user exception handlers>\n-      --     end;\n-\n-      --    System.Threads.Thread_Body_Leave;\n-\n-      --  exception\n-      --     when E : others =>\n-      --       System.Threads.Thread_Body_Exceptional_Exit (E);\n-      --  end;\n-\n-      --  Note the exception handler is omitted if pragma Restriction\n-      --  No_Exception_Handlers is currently active.\n-\n-      procedure Expand_Thread_Body is\n-         User_Decls    : constant List_Id := Declarations (N);\n-         Sec_Stack_Len : Node_Id;\n-\n-         TB_Pragma  : constant Node_Id :=\n-                        Get_Rep_Pragma (Spec_Id, Name_Thread_Body);\n-\n-         Ent_SS   : Entity_Id;\n-         Ent_ATSD : Entity_Id;\n-         Ent_EO   : Entity_Id;\n-\n-         Decl_SS   : Node_Id;\n-         Decl_ATSD : Node_Id;\n-\n-         Excep_Handlers : List_Id;\n+         Last_Stm : Node_Id;\n+         Loc      : Source_Ptr;\n \n       begin\n-         New_Scope (Spec_Id);\n-\n-         --  Get proper setting for secondary stack size\n-\n-         if List_Length (Pragma_Argument_Associations (TB_Pragma)) = 2 then\n-            Sec_Stack_Len :=\n-              Expression (Last (Pragma_Argument_Associations (TB_Pragma)));\n-         else\n-            Sec_Stack_Len :=\n-              New_Occurrence_Of (RTE (RE_Default_Secondary_Stack_Size), Loc);\n-         end if;\n+         --  Get last statement, ignoring any Pop_xxx_Label nodes, which are\n+         --  not relevant in this context since they are not executable.\n \n-         Sec_Stack_Len := Convert_To (RTE (RE_Storage_Offset), Sec_Stack_Len);\n-\n-         --  Build and set declarations for the wrapped thread body\n-\n-         Ent_SS   :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => Name_uSecondary_Stack);\n-         Ent_ATSD :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => Name_uProcess_ATSD);\n+         Last_Stm := Last (S);\n+         while Nkind (Last_Stm) in N_Pop_xxx_Label loop\n+            Prev (Last_Stm);\n+         end loop;\n \n-         Decl_SS :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Ent_SS,\n-             Aliased_Present     => True,\n-             Object_Definition   =>\n-               Make_Subtype_Indication (Loc,\n-                 Subtype_Mark =>\n-                   New_Occurrence_Of (RTE (RE_Storage_Array), Loc),\n-                 Constraint   =>\n-                   Make_Index_Or_Discriminant_Constraint (Loc,\n-                     Constraints => New_List (\n-                       Make_Range (Loc,\n-                         Low_Bound  => Make_Integer_Literal (Loc, 1),\n-                         High_Bound => Sec_Stack_Len)))));\n-\n-         Decl_ATSD :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Ent_ATSD,\n-             Aliased_Present     => True,\n-             Object_Definition   => New_Occurrence_Of (RTE (RE_ATSD), Loc));\n+         --  Now insert return unless last statement is a transfer\n \n-         Set_Declarations (N, New_List (Decl_SS, Decl_ATSD));\n-         Analyze (Decl_SS);\n-         Analyze (Decl_ATSD);\n-         Set_Alignment (Ent_SS, UI_From_Int (Maximum_Alignment));\n+         if not Is_Transfer (Last_Stm) then\n \n-         --  Create new exception handler\n+            --  The source location for the return is the end label of the\n+            --  procedure if present. Otherwise use the sloc of the last\n+            --  statement in the list. If the list comes from a generated\n+            --  exception handler and we are not debugging generated code,\n+            --  all the statements within the handler are made invisible\n+            --  to the debugger.\n \n-         if Restriction_Active (No_Exception_Handlers) then\n-            Excep_Handlers := No_List;\n+            if Nkind (Parent (S)) = N_Exception_Handler\n+              and then not Comes_From_Source (Parent (S))\n+            then\n+               Loc := Sloc (Last_Stm);\n \n-         else\n-            Check_Restriction (No_Exception_Handlers, N);\n+            elsif Present (End_Label (H)) then\n+               Loc := Sloc (End_Label (H));\n \n-            Ent_EO :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => Name_uE);\n+            else\n+               Loc := Sloc (Last_Stm);\n+            end if;\n \n-            Excep_Handlers := New_List (\n-              Make_Implicit_Exception_Handler (Loc,\n-                Choice_Parameter => Ent_EO,\n-                Exception_Choices => New_List (\n-                  Make_Others_Choice (Loc)),\n-                Statements => New_List (\n-                  Make_Procedure_Call_Statement (Loc,\n-                    Name =>\n-                      New_Occurrence_Of\n-                        (RTE (RE_Thread_Body_Exceptional_Exit), Loc),\n-                    Parameter_Associations => New_List (\n-                      New_Occurrence_Of (Ent_EO, Loc))))));\n+            Append_To (S, Make_Return_Statement (Loc));\n          end if;\n-\n-         --  Now build new handled statement sequence and analyze it\n-\n-         Set_Handled_Statement_Sequence (N,\n-           Make_Handled_Sequence_Of_Statements (Loc,\n-             Statements => New_List (\n-\n-               Make_Procedure_Call_Statement (Loc,\n-                 Name => New_Occurrence_Of (RTE (RE_Thread_Body_Enter), Loc),\n-                 Parameter_Associations => New_List (\n-\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix => New_Occurrence_Of (Ent_SS, Loc),\n-                     Attribute_Name => Name_Address),\n-\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix => New_Occurrence_Of (Ent_SS, Loc),\n-                     Attribute_Name => Name_Length),\n-\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix => New_Occurrence_Of (Ent_ATSD, Loc),\n-                     Attribute_Name => Name_Address))),\n-\n-               Make_Block_Statement (Loc,\n-                 Declarations => User_Decls,\n-                 Handled_Statement_Sequence => H),\n-\n-               Make_Procedure_Call_Statement (Loc,\n-                 Name => New_Occurrence_Of (RTE (RE_Thread_Body_Leave), Loc))),\n-\n-             Exception_Handlers => Excep_Handlers));\n-\n-         Analyze (Handled_Statement_Sequence (N));\n-         End_Scope;\n-      end Expand_Thread_Body;\n+      end Add_Return;\n \n    --  Start of processing for Expand_N_Subprogram_Body\n \n@@ -4171,7 +4127,45 @@ package body Exp_Ch6 is\n       if Is_Non_Empty_List (Declarations (N)) then\n          L := Declarations (N);\n       else\n-         L := Statements (Handled_Statement_Sequence (N));\n+         L := Statements (H);\n+      end if;\n+\n+      --  If local-exception-to-goto optimization active, insert dummy push\n+      --  statements at start, and dummy pop statements at end.\n+\n+      if (Debug_Flag_Dot_G\n+           or else Restriction_Active (No_Exception_Propagation))\n+        and then Is_Non_Empty_List (L)\n+      then\n+         declare\n+            FS  : constant Node_Id    := First (L);\n+            FL  : constant Source_Ptr := Sloc (FS);\n+            LS  : Node_Id;\n+            LL  : Source_Ptr;\n+\n+         begin\n+            --  LS points to either last statement, if statements are present\n+            --  or to the last declaration if there are no statements present.\n+            --  It is the node after which the pop's are generated.\n+\n+            if Is_Non_Empty_List (Statements (H)) then\n+               LS := Last (Statements (H));\n+            else\n+               LS := Last (L);\n+            end if;\n+\n+            LL := Sloc (LS);\n+\n+            Insert_List_Before_And_Analyze (FS, New_List (\n+              Make_Push_Constraint_Error_Label (FL),\n+              Make_Push_Program_Error_Label    (FL),\n+              Make_Push_Storage_Error_Label    (FL)));\n+\n+            Insert_List_After_And_Analyze (LS, New_List (\n+              Make_Pop_Constraint_Error_Label  (LL),\n+              Make_Pop_Program_Error_Label     (LL),\n+              Make_Pop_Storage_Error_Label     (LL)));\n+         end;\n       end if;\n \n       --  Find entity for subprogram\n@@ -4184,11 +4178,11 @@ package body Exp_Ch6 is\n          Spec_Id := Body_Id;\n       end if;\n \n-      --  Need poll on entry to subprogram if polling enabled. We only\n-      --  do this for non-empty subprograms, since it does not seem\n-      --  necessary to poll for a dummy null subprogram. Do not add polling\n-      --  point if calls to this subprogram will be inlined by the back-end,\n-      --  to avoid repeated polling points in nested inlinings.\n+      --  Need poll on entry to subprogram if polling enabled. We only do this\n+      --  for non-empty subprograms, since it does not seem necessary to poll\n+      --  for a dummy null subprogram. Do not add polling point if calls to\n+      --  this subprogram will be inlined by the back-end, to avoid repeated\n+      --  polling points in nested inlinings.\n \n       if Is_Non_Empty_List (L) then\n          if Is_Inlined (Spec_Id)\n@@ -4393,7 +4387,7 @@ package body Exp_Ch6 is\n               Make_Handled_Sequence_Of_Statements (Hloc,\n                 Statements => New_List (Blok, Rais)));\n \n-            New_Scope (Spec_Id);\n+            Push_Scope (Spec_Id);\n             Analyze (Blok);\n             Analyze (Rais);\n             Pop_Scope;\n@@ -4442,12 +4436,6 @@ package body Exp_Ch6 is\n          end;\n       end if;\n \n-      --  Deal with thread body\n-\n-      if Is_Thread_Body (Spec_Id) then\n-         Expand_Thread_Body;\n-      end if;\n-\n       --  Set to encode entity names in package body before gigi is called\n \n       Qualify_Entity_Names (N);\n@@ -4517,7 +4505,7 @@ package body Exp_Ch6 is\n             Insert_Before (Prot_Bod, Prot_Decl);\n             Prot_Id := Defining_Unit_Name (Specification (Prot_Decl));\n \n-            New_Scope (Scope (Scop));\n+            Push_Scope (Scope (Scop));\n             Analyze (Prot_Decl);\n             Create_Extra_Formals (Prot_Id);\n             Set_Protected_Body_Subprogram (Subp, Prot_Id);\n@@ -4650,7 +4638,7 @@ package body Exp_Ch6 is\n                   New_Occurrence_Of (Param, Loc)));\n \n             --  Analyze new actual. Other actuals in calls are already analyzed\n-            --  and the list of actuals is not renalyzed after rewriting.\n+            --  and the list of actuals is not reanalyzed after rewriting.\n \n             Set_Parent (Rec, N);\n             Analyze (Rec);\n@@ -4747,6 +4735,13 @@ package body Exp_Ch6 is\n          then\n             return False;\n \n+         --  If the return type is a limited interface it has to be treated\n+         --  as a return in place, even if the actual object is some non-\n+         --  limited descendant.\n+\n+         elsif Is_Limited_Interface (Etype (E)) then\n+            return True;\n+\n          else\n             return Is_Inherently_Limited_Type (Etype (E))\n               and then Ada_Version >= Ada_05\n@@ -4808,7 +4803,6 @@ package body Exp_Ch6 is\n \n    procedure Freeze_Subprogram (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n-      E   : constant Entity_Id  := Entity (N);\n \n       procedure Register_Predefined_DT_Entry (Prim : Entity_Id);\n       --  (Ada 2005): Register a predefined primitive in all the secondary\n@@ -4822,6 +4816,7 @@ package body Exp_Ch6 is\n          Iface_DT_Ptr : Elmt_Id;\n          Tagged_Typ   : Entity_Id;\n          Thunk_Id     : Entity_Id;\n+         Thunk_Code   : Node_Id;\n \n       begin\n          Tagged_Typ := Find_Dispatching_Type (Prim);\n@@ -4843,131 +4838,118 @@ package body Exp_Ch6 is\n          Iface_DT_Ptr :=\n            Next_Elmt (First_Elmt (Access_Disp_Table (Tagged_Typ)));\n \n-         while Present (Iface_DT_Ptr) loop\n-            Thunk_Id :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => New_Internal_Name ('T'));\n-\n-            Insert_Actions (N, New_List (\n-              Expand_Interface_Thunk\n-               (N           => Prim,\n-                Thunk_Alias => Prim,\n-                Thunk_Id    => Thunk_Id),\n-\n-              Build_Set_Predefined_Prim_Op_Address (Loc,\n-                Tag_Node =>\n-                  New_Reference_To (Node (Iface_DT_Ptr), Loc),\n-                Position_Node =>\n-                  Make_Integer_Literal (Loc, DT_Position (Prim)),\n-                Address_Node =>\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix         => New_Reference_To (Thunk_Id, Loc),\n-                    Attribute_Name => Name_Address))));\n+         while Present (Iface_DT_Ptr)\n+            and then Ekind (Node (Iface_DT_Ptr)) = E_Constant\n+         loop\n+            Expand_Interface_Thunk\n+              (N           => Prim,\n+               Thunk_Alias => Prim,\n+               Thunk_Id    => Thunk_Id,\n+               Thunk_Code  => Thunk_Code);\n+\n+            if Present (Thunk_Code) then\n+               Insert_Actions (N, New_List (\n+                 Thunk_Code,\n+\n+                 Build_Set_Predefined_Prim_Op_Address (Loc,\n+                   Tag_Node => New_Reference_To (Node (Iface_DT_Ptr), Loc),\n+                   Position => DT_Position (Prim),\n+                   Address_Node =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         => New_Reference_To (Thunk_Id, Loc),\n+                       Attribute_Name => Name_Address))));\n+            end if;\n \n             Next_Elmt (Iface_DT_Ptr);\n          end loop;\n       end Register_Predefined_DT_Entry;\n \n-   --  Start of processing for Freeze_Subprogram\n+      --  Local variables\n \n-   begin\n-      --  We assume that imported CPP primitives correspond with objects\n-      --  whose constructor is in the CPP side (and therefore we don't need\n-      --  to generate code to register them in the dispatch table).\n-\n-      if Is_Imported (E)\n-        and then Convention (E) = Convention_CPP\n-      then\n-         return;\n-      end if;\n-\n-      --  When a primitive is frozen, enter its name in the corresponding\n-      --  dispatch table. If the DTC_Entity field is not set this is an\n-      --  overridden primitive that can be ignored. We suppress the\n-      --  initialization of the dispatch table entry when Java_VM because\n-      --  the dispatching mechanism is handled internally by the JVM.\n-\n-      if Is_Dispatching_Operation (E)\n-        and then not Is_Abstract_Subprogram (E)\n-        and then Present (DTC_Entity (E))\n-        and then not Java_VM\n-        and then not Is_CPP_Class (Scope (DTC_Entity (E)))\n-      then\n-         Check_Overriding_Operation (E);\n+      Subp : constant Entity_Id := Entity (N);\n+      Typ  : constant Entity_Id := Etype (Subp);\n+      Utyp : constant Entity_Id := Underlying_Type (Typ);\n \n-         --  Ada 95 case: Register the subprogram in the primary dispatch table\n+   begin\n+      if not Static_Dispatch_Tables then\n+         declare\n+            E   : constant Entity_Id := Subp;\n+            Typ : Entity_Id;\n \n-         --  Do not register the subprogram in the dispatch table if we are\n-         --  compiling under No_Dispatching_Calls restriction.\n+         begin\n+            --  We assume that imported CPP primitives correspond with objects\n+            --  whose constructor is in the CPP side (and therefore we don't\n+            --  need to generate code to register them in the dispatch table).\n \n-         if not Restriction_Active (No_Dispatching_Calls) then\n+            if Is_Imported (E)\n+              and then Convention (E) = Convention_CPP\n+            then\n+               return;\n+            end if;\n \n-            if Ada_Version < Ada_05 then\n-               Insert_After (N,\n-                 Fill_DT_Entry (Sloc (N), Prim => E));\n+            --  When a primitive is frozen, enter its name in the corresponding\n+            --  dispatch table. If the DTC_Entity field is not set this is\n+            --  an overridden primitive that can be ignored. We suppress the\n+            --  initialization of the dispatch table entry when VM_Target\n+            --  because the dispatching mechanism is handled internally by\n+            --  the VM.\n+\n+            if Is_Dispatching_Operation (E)\n+              and then not Is_Abstract_Subprogram (E)\n+              and then Present (DTC_Entity (E))\n+              and then VM_Target = No_VM\n+              and then not Is_CPP_Class (Scope (DTC_Entity (E)))\n+            then\n+               Check_Overriding_Operation (E);\n \n-            --  Ada 2005 case: Register the subprogram in all the dispatch\n-            --  tables associated with the type\n+               --  Register the primitive in its dispatch table if we are not\n+               --  compiling under No_Dispatching_Calls restriction\n \n-            else\n-               declare\n-                  Typ : constant Entity_Id := Scope (DTC_Entity (E));\n+               if not Restriction_Active (No_Dispatching_Calls)\n+                 and then RTE_Available (RE_Tag)\n+               then\n+                  Typ := Scope (DTC_Entity (E));\n \n-               begin\n                   if not Is_Interface (Typ)\n-                    and then Is_Predefined_Dispatching_Operation (E)\n-                  then\n-                     Register_Predefined_DT_Entry (E);\n-                     Insert_After (N, Fill_DT_Entry (Sloc (N), Prim => E));\n-\n-                  --  There is no dispatch table associated with abstract\n-                  --  interface types. Each type implementing interfaces will\n-                  --  fill the associated secondary DT entries.\n-\n-                  elsif not Is_Interface (Typ)\n-                    or else Present (Alias (E))\n+                    or else Present (Abstract_Interface_Alias (E))\n                   then\n-                     --  Ada 2005 (AI-251): Check if this entry corresponds\n-                     --  with a subprogram that covers an abstract interface\n-                     --  type.\n-\n-                     if Present (Abstract_Interface_Alias (E)) then\n-                        Register_Interface_DT_Entry (N, E);\n+                     if Is_Predefined_Dispatching_Operation (E) then\n+                        Register_Predefined_DT_Entry (E);\n+                     end if;\n \n-                     --  Common case: Primitive subprogram\n+                     Register_Primitive (Loc,\n+                       Prim    => E,\n+                       Ins_Nod => N);\n+                  end if;\n+               end if;\n+            end if;\n+         end;\n \n-                     else\n-                        --  Generate thunks for all the predefined operations\n+      --  GCC 4.1 backend\n \n-                        if Is_Predefined_Dispatching_Operation (E) then\n-                           Register_Predefined_DT_Entry (E);\n-                        end if;\n+      else\n+         --  Handle private overriden primitives\n \n-                        Insert_After (N,\n-                          Fill_DT_Entry (Sloc (N), Prim => E));\n-                     end if;\n-                  end if;\n-               end;\n-            end if;\n+         if Is_Dispatching_Operation (Subp)\n+           and then not Is_Abstract_Subprogram (Subp)\n+           and then Present (DTC_Entity (Subp))\n+           and then VM_Target = No_VM\n+           and then not Is_CPP_Class (Scope (DTC_Entity (Subp)))\n+         then\n+            Check_Overriding_Operation (Subp);\n          end if;\n       end if;\n \n-      --  Mark functions that return by reference. Note that it cannot be\n-      --  part of the normal semantic analysis of the spec since the\n-      --  underlying returned type may not be known yet (for private types).\n+      --  Mark functions that return by reference. Note that it cannot be part\n+      --  of the normal semantic analysis of the spec since the underlying\n+      --  returned type may not be known yet (for private types).\n \n-      declare\n-         Typ  : constant Entity_Id := Etype (E);\n-         Utyp : constant Entity_Id := Underlying_Type (Typ);\n+      if Is_Inherently_Limited_Type (Typ) then\n+         Set_Returns_By_Ref (Subp);\n \n-      begin\n-         if Is_Inherently_Limited_Type (Typ) then\n-            Set_Returns_By_Ref (E);\n-\n-         elsif Present (Utyp) and then CW_Or_Controlled_Type (Utyp) then\n-            Set_Returns_By_Ref (E);\n-         end if;\n-      end;\n+      elsif Present (Utyp) and then CW_Or_Controlled_Type (Utyp) then\n+         Set_Returns_By_Ref (Subp);\n+      end if;\n    end Freeze_Subprogram;\n \n    -------------------------------------------\n@@ -5009,7 +4991,12 @@ package body Exp_Ch6 is\n       --  allocated on the caller side, and access to it is passed to the\n       --  function.\n \n-      if Is_Constrained (Result_Subt) then\n+      --  Here and in related routines, we must examine the full view of the\n+      --  type, because the view at the point of call may differ from that\n+      --  that in the function body, and the expansion mechanism depends on\n+      --  the characteristics of the full view.\n+\n+      if Is_Constrained (Underlying_Type (Result_Subt)) then\n \n          --  Replace the initialized allocator of form \"new T'(Func (...))\"\n          --  with an uninitialized allocator of form \"new T\", where T is the\n@@ -5038,14 +5025,26 @@ package body Exp_Ch6 is\n              Object_Definition   => New_Reference_To (Acc_Type, Loc),\n              Expression          => Relocate_Node (Allocator)));\n \n+         --  When the function has a controlling result, an allocation-form\n+         --  parameter must be passed indicating that the caller is allocating\n+         --  the result object. This is needed because such a function can be\n+         --  called as a dispatching operation and must be treated similarly\n+         --  to functions with unconstrained result subtypes.\n+\n+         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n+\n+         Add_Final_List_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Acc_Type);\n+\n+         Add_Task_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Master_Actual => Master_Id (Acc_Type));\n+\n          --  Add an implicit actual to the function call that provides access\n          --  to the allocated object. An unchecked conversion to the (specific)\n          --  result subtype of the function is inserted to handle cases where\n          --  the access type of the allocator has a class-wide designated type.\n \n-         Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n-         Add_Task_Actuals_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Master_Actual => Master_Id (Acc_Type));\n          Add_Access_Actual_To_Build_In_Place_Call\n            (Func_Call,\n             Function_Id,\n@@ -5063,18 +5062,22 @@ package body Exp_Ch6 is\n       --  operations. ???\n \n       else\n+\n          --  Pass an allocation parameter indicating that the function should\n          --  allocate its result on the heap.\n \n          Add_Alloc_Form_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n \n-         --  The caller does not provide the return object in this case, so we\n-         --  have to pass null for the object access actual.\n+         Add_Final_List_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Acc_Type);\n \n-         Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n          Add_Task_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Master_Actual => Master_Id (Acc_Type));\n+\n+         --  The caller does not provide the return object in this case, so we\n+         --  have to pass null for the object access actual.\n+\n          Add_Access_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Return_Object => Empty);\n       end if;\n@@ -5123,7 +5126,7 @@ package body Exp_Ch6 is\n       --  When the result subtype is constrained, an object of the subtype is\n       --  declared and an access value designating it is passed as an actual.\n \n-      if Is_Constrained (Result_Subt) then\n+      if Is_Constrained (Underlying_Type (Result_Subt)) then\n \n          --  Create a temporary object to hold the function result\n \n@@ -5142,12 +5145,24 @@ package body Exp_Ch6 is\n \n          Insert_Action (Func_Call, Return_Obj_Decl);\n \n-         --  Add an implicit actual to the function call that provides access\n-         --  to the caller's return object.\n+         --  When the function has a controlling result, an allocation-form\n+         --  parameter must be passed indicating that the caller is allocating\n+         --  the result object. This is needed because such a function can be\n+         --  called as a dispatching operation and must be treated similarly\n+         --  to functions with unconstrained result subtypes.\n+\n+         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n+\n+         Add_Final_List_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Acc_Type => Empty);\n \n-         Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n          Add_Task_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n+\n+         --  Add an implicit actual to the function call that provides access\n+         --  to the caller's return object.\n+\n          Add_Access_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, New_Reference_To (Return_Obj_Id, Loc));\n \n@@ -5157,18 +5172,22 @@ package body Exp_Ch6 is\n       --  scope is established to ensure eventual cleanup of the result.\n \n       else\n+\n          --  Pass an allocation parameter indicating that the function should\n          --  allocate its result on the secondary stack.\n \n          Add_Alloc_Form_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n \n-         --  Pass a null value to the function since no return object is\n-         --  available on the caller side.\n+         Add_Final_List_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Acc_Type => Empty);\n \n-         Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n          Add_Task_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n+\n+         --  Pass a null value to the function since no return object is\n+         --  available on the caller side.\n+\n          Add_Access_Actual_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Empty);\n \n@@ -5215,18 +5234,22 @@ package body Exp_Ch6 is\n \n       --  When the result subtype is unconstrained, an additional actual must\n       --  be passed to indicate that the caller is providing the return object.\n+      --  This parameter must also be passed when the called function has a\n+      --  controlling result, because dispatching calls to the function needs\n+      --  to be treated effectively the same as calls to class-wide functions.\n \n-      if not Is_Constrained (Result_Subt) then\n-         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n-           (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n-      end if;\n+      Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+        (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n \n-      --  Add an implicit actual to the function call that provides access to\n-      --  the caller's return object.\n+      Add_Final_List_Actual_To_Build_In_Place_Call\n+        (Func_Call, Function_Id, Acc_Type => Empty);\n \n-      Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n       Add_Task_Actuals_To_Build_In_Place_Call\n         (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n+\n+      --  Add an implicit actual to the function call that provides access to\n+      --  the caller's return object.\n+\n       Add_Access_Actual_To_Build_In_Place_Call\n         (Func_Call,\n          Function_Id,\n@@ -5282,6 +5305,7 @@ package body Exp_Ch6 is\n       Loc             : Source_Ptr;\n       Obj_Def_Id      : constant Entity_Id :=\n                           Defining_Identifier (Object_Decl);\n+\n       Func_Call       : Node_Id := Function_Call;\n       Function_Id     : Entity_Id;\n       Result_Subt     : Entity_Id;\n@@ -5318,12 +5342,21 @@ package body Exp_Ch6 is\n       --  to the (specific) result type of the function is inserted to handle\n       --  the case where the object is declared with a class-wide type.\n \n-      if Is_Constrained (Result_Subt) then\n+      if Is_Constrained (Underlying_Type (Result_Subt)) then\n          Caller_Object :=\n             Make_Unchecked_Type_Conversion (Loc,\n               Subtype_Mark => New_Reference_To (Result_Subt, Loc),\n               Expression   => New_Reference_To (Obj_Def_Id, Loc));\n \n+         --  When the function has a controlling result, an allocation-form\n+         --  parameter must be passed indicating that the caller is allocating\n+         --  the result object. This is needed because such a function can be\n+         --  called as a dispatching operation and must be treated similarly\n+         --  to functions with unconstrained result subtypes.\n+\n+         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n+\n       --  If the function's result subtype is unconstrained and the object is\n       --  a return object of an enclosing build-in-place function, then the\n       --  implicit build-in-place parameters of the enclosing function must be\n@@ -5343,7 +5376,7 @@ package body Exp_Ch6 is\n \n          --  Otherwise, when the enclosing function has an unconstrained result\n          --  type, the BIP_Alloc_Form formal of the enclosing function must be\n-         --  passed long to the callee.\n+         --  passed along to the callee.\n \n          else\n             Add_Alloc_Form_Actual_To_Build_In_Place_Call\n@@ -5385,22 +5418,28 @@ package body Exp_Ch6 is\n          Establish_Transient_Scope (Object_Decl, Sec_Stack => True);\n       end if;\n \n-      Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n+      Add_Final_List_Actual_To_Build_In_Place_Call\n+        (Func_Call, Function_Id, Acc_Type => Empty);\n+\n       if Nkind (Parent (Object_Decl)) = N_Extended_Return_Statement\n         and then Has_Task (Result_Subt)\n       then\n          Enclosing_Func := Enclosing_Subprogram (Obj_Def_Id);\n+\n+         --  Here we're passing along the master that was passed in to this\n+         --  function.\n+\n          Add_Task_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id,\n             Master_Actual =>\n               New_Reference_To\n                 (Build_In_Place_Formal (Enclosing_Func, BIP_Master), Loc));\n-         --  Here we're passing along the master that was passed in to this\n-         --  function.\n+\n       else\n          Add_Task_Actuals_To_Build_In_Place_Call\n            (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n       end if;\n+\n       Add_Access_Actual_To_Build_In_Place_Call\n         (Func_Call, Function_Id, Caller_Object, Is_Access => Pass_Caller_Acc);\n \n@@ -5425,7 +5464,7 @@ package body Exp_Ch6 is\n       --  the object declaration is rewritten to be a renaming of a dereference\n       --  of the access object.\n \n-      if Is_Constrained (Result_Subt) then\n+      if Is_Constrained (Underlying_Type (Result_Subt)) then\n          Insert_After_And_Analyze (Object_Decl, Ptr_Typ_Decl);\n       else\n          Insert_Before_And_Analyze (Object_Decl, Ptr_Typ_Decl);\n@@ -5449,7 +5488,7 @@ package body Exp_Ch6 is\n           Object_Definition   => New_Reference_To (Ref_Type, Loc),\n           Expression          => New_Expr));\n \n-      if Is_Constrained (Result_Subt) then\n+      if Is_Constrained (Underlying_Type (Result_Subt)) then\n          Set_Expression (Object_Decl, Empty);\n          Set_No_Initialization (Object_Decl);\n \n@@ -5501,51 +5540,4 @@ package body Exp_Ch6 is\n       end if;\n    end Make_Build_In_Place_Call_In_Object_Declaration;\n \n-   ---------------------------------\n-   -- Register_Interface_DT_Entry --\n-   ---------------------------------\n-\n-   procedure Register_Interface_DT_Entry\n-     (Related_Nod : Node_Id;\n-      Prim        : Entity_Id)\n-   is\n-      Loc        : constant Source_Ptr := Sloc (Prim);\n-      Iface_Typ  : Entity_Id;\n-      Tagged_Typ : Entity_Id;\n-      Thunk_Id   : Entity_Id;\n-\n-   begin\n-      --  Nothing to do if the run-time does not support abstract interfaces\n-\n-      if not (RTE_Available (RE_Interface_Tag)) then\n-         return;\n-      end if;\n-\n-      Tagged_Typ := Find_Dispatching_Type (Alias (Prim));\n-      Iface_Typ  := Find_Dispatching_Type (Abstract_Interface_Alias (Prim));\n-\n-      --  Generate the code of the thunk only if the abstract interface type is\n-      --  not an immediate ancestor of Tagged_Type; otherwise the dispatch\n-      --  table associated with the interface is the primary dispatch table.\n-\n-      pragma Assert (Is_Interface (Iface_Typ));\n-\n-      if not Is_Parent (Iface_Typ, Tagged_Typ) then\n-         Thunk_Id  :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_Internal_Name ('T'));\n-\n-         Insert_Actions (Related_Nod, New_List (\n-           Expand_Interface_Thunk\n-             (N           => Prim,\n-              Thunk_Alias => Alias (Prim),\n-              Thunk_Id    => Thunk_Id),\n-\n-           Fill_Secondary_DT_Entry (Sloc (Prim),\n-             Prim         => Prim,\n-             Iface_DT_Ptr => Find_Interface_ADT (Tagged_Typ, Iface_Typ),\n-             Thunk_Id     => Thunk_Id)));\n-      end if;\n-   end Register_Interface_DT_Entry;\n-\n end Exp_Ch6;"}, {"sha": "415fad22bb01a6d9e63ede04de4fabce37a77814", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7888a6aecc26ae7f7d406e893e0620dfccb1837b/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7888a6aecc26ae7f7d406e893e0620dfccb1837b/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=7888a6aecc26ae7f7d406e893e0620dfccb1837b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -61,10 +61,10 @@ package Exp_Ch6 is\n    --  enumeration literals matches the order in which the formals are\n    --  declared. See Sem_Ch6.Create_Extra_Formals.\n      (BIP_Alloc_Form,\n-      --  Present if result subtype is unconstrained. Indicates whether the\n-      --  return object is allocated by the caller or callee, and if the\n-      --  callee, whether to use the secondary stack or the heap. See\n-      --  Create_Extra_Formals.\n+      --  Present if result subtype is unconstrained, or if the result type\n+      --  is tagged. Indicates whether the return object is allocated by the\n+      --  caller or callee, and if the callee, whether to use the secondary\n+      --  stack or the heap. See Create_Extra_Formals.\n       BIP_Final_List,\n       --  Present if result type has controlled parts. Pointer to caller's\n       --  finalization list.\n@@ -162,10 +162,4 @@ package Exp_Ch6 is\n    --  for which Is_Build_In_Place_Call is True, or an N_Qualified_Expression\n    --  node applied to such a function call.\n \n-   procedure Register_Interface_DT_Entry\n-     (Related_Nod : Node_Id;\n-      Prim        : Entity_Id);\n-   --  Ada 2005 (AI-251): Register a primitive in a secondary dispatch table.\n-   --  Related_Nod is the node after which the expanded code will be inserted.\n-\n end Exp_Ch6;"}]}