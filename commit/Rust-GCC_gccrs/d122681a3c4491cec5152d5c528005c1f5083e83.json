{"sha": "d122681a3c4491cec5152d5c528005c1f5083e83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEyMjY4MWEzYzQ0OTFjZWM1MTUyZDVjNTI4MDA1YzFmNTA4M2U4Mw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-06-25T16:55:46Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-06-25T16:55:46Z"}, "message": "IPA REF refactoring\n\n\t* Makefile.in: Removed header file (ipa-ref-inline.h).\n\t* cgraph.c (cgraph_turn_edge_to_speculative): New IPA REF function\n\tcalled.\n\t(cgraph_speculative_call_info): Likewise.\n\t(cgraph_for_node_thunks_and_aliases): Likewise.\n\t(cgraph_for_node_and_aliases): Likewise.\n\t(verify_cgraph_node): Likewise.\n\t* cgraph.h: Batch of IPA REF functions become member functions of\n\tsymtab_node: add_reference, maybe_add_reference, clone_references,\n\tclone_referring, clone_reference, find_reference,\n\tremove_stmt_references, remove_all_references,\n\tremove_all_referring, dump_references, dump_referring,\n\thas_alias_p, iterate_reference, iterate_referring.\n\t* cgraphbuild.c (record_reference): New IPA REF function used.\n\t(record_type_list): Likewise.\n\t(record_eh_tables): Likewise.\n\t(mark_address): Likewise.\n\t(mark_load): Likewise.\n\t(mark_store): Likewise.\n\t(pass_build_cgraph_edges): Likewise.\n\t(rebuild_cgraph_edge): Likewise.\n\t(cgraph_rebuild_references): Likewise.\n\t(pass_remove_cgraph_callee_edges): Likewise.\n\t* cgraphclones.c (cgraph_clone_node): Likewise.\n\t(cgraph_create_virtual_clone): Likewise.\n\t(cgraph_materialize_clone): Likewise.\n\t(cgraph_materialize_all_clones): Likewise.\n\t* cgraphunit.c (cgraph_reset_node): Likewise.\n\t(cgraph_reset_node): Likewise.\n\t(analyze_function): Likewise.\n\t(assemble_thunks_and_aliases): Likewise.\n\t(expand_function): Likewise.\n\t* ipa-comdats.c (propagate_comdat_group): Likewise.\n\t(enqueue_references): Likewise.\n\t* ipa-cp.c (ipcp_discover_new_direct_edges): Likewise.\n\t(create_specialized_node): Likewise.\n\t* ipa-devirt.c (referenced_from_vtable_p): Likewise.\n\t* ipa-inline-transform.c (can_remove_node_now_p_1): Likewise.\n\t* ipa-inline.c (reset_edge_caches): Likewise.\n\t(update_caller_keys): Likewise.\n\t(execute): Likewise.\n\t* ipa-prop.c (remove_described_reference): Likewise.\n\t(propagate_controlled_uses): Likewise.\n\t(ipa_edge_duplication_hook): Likewise.\n\t(ipa_modify_call_arguments): Likewise.\n\t* ipa-pure-const.c (propagate_pure_const): Likewise.\n\t* ipa-ref-inline.h: Header file removed, functions moved\n\tto symtab_node class.\n\t* ipa-ref.c (remove_reference): New class member function.\n\t(cannot_lead_to_return): New class member function.\n\t(referring_ref_list): Likewise.\n\t(referred_ref_list): Likewise.\n\tRest of functions moved to symtab_node class.\n\t* ipa-ref.h: New member functions remove_reference,\n\tcannot_lead_to_return, referring_ref_list, referred_ref_list added\n\tto ipa_ref class.\n\tipa_ref_list class has new member functions: first_reference,\n\tfirst_referring, clear, nreferences.\n\t* ipa-reference.c (analyze_function): New IPA REF function used.\n\t(write_node_summary_p): Likewise.\n\t(ipa_reference_write_optimization_summary): Likewise.\n\t* ipa-split.c (split_function): Likewise.\n\t* ipa-utils.c (ipa_reverse_postorder): Likewise.\n\t* ipa-visibility.c (cgraph_non_local_node_p_1): Likewise.\n\t(function_and_variable_visibility): Likewise.\n\t* ipa.c (has_addr_references_p): Likewise.\n\t(process_references): Argument type changed.\n\t(symtab_remove_unreachable_nodes): New IPA REF function used.\n\t(process_references): Likewise.\n\t(set_writeonly_bit): Likewise.\n\t* lto-cgraph.c: Implementation of new symtab_node member functions\n\tthat uses new IPA REF functions.\n\t* lto-streamer-in.c (fixup_call_stmt_edges_1): New IPA REF function used.\n\t* lto-streamer-out.c (output_symbol_p): Likewise.\n\t* lto-streamer.h (referenced_from_this_partition_p): Argument type\n\tchanged.\n\t* lto/lto-partition.c (add_references_to_partition): New IPA REF function\n\tused.\n\t(add_symbol_to_partition_1): Likewise.\n\t(lto_balanced_map): Likewise.\n\t* lto/lto-symtab.c (lto_cgraph_replace_node): Likewise.\n\t* symtab.c: Implementation of new IPA REF API.\n\t* trans-mem.c (ipa_tm_create_version_alias): New IPA REF function used.\n\t(ipa_tm_create_version): Likewise.\n\t(ipa_tm_execute): Likewise.\n\t* tree-emutls.c (gen_emutls_addr): Likewise.\n\t* tree-inline.c (copy_bb): Likewise.\n\t(delete_unreachable_blocks_update_callgraph): Likewise.\n\t* varpool.c (varpool_remove_unreferenced_decls): Likewise.\n\t(varpool_for_node_and_aliases): Likewise.\n\nFrom-SVN: r211987", "tree": {"sha": "b3a5f8f8784d867b1c0b7b15ee92950397c414aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3a5f8f8784d867b1c0b7b15ee92950397c414aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d122681a3c4491cec5152d5c528005c1f5083e83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d122681a3c4491cec5152d5c528005c1f5083e83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d122681a3c4491cec5152d5c528005c1f5083e83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d122681a3c4491cec5152d5c528005c1f5083e83/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "81d0a226820c32b487bbb855e9873684f51400f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81d0a226820c32b487bbb855e9873684f51400f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81d0a226820c32b487bbb855e9873684f51400f8"}], "stats": {"total": 1190, "additions": 684, "deletions": 506}, "files": [{"sha": "e35a8fe4f8951d3543d7ab6e92fb86f57363067d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -1,3 +1,97 @@\n+2014-06-25  Martin Liska  <mliska@suse.cz>\n+\n+\tIPA REF refactoring\n+\t* Makefile.in: Removed header file (ipa-ref-inline.h).\n+\t* cgraph.c (cgraph_turn_edge_to_speculative): New IPA REF function\n+\tcalled.\n+\t(cgraph_speculative_call_info): Likewise.\n+\t(cgraph_for_node_thunks_and_aliases): Likewise.\n+\t(cgraph_for_node_and_aliases): Likewise.\n+\t(verify_cgraph_node): Likewise.\n+\t* cgraph.h: Batch of IPA REF functions become member functions of\n+\tsymtab_node: add_reference, maybe_add_reference, clone_references,\n+\tclone_referring, clone_reference, find_reference,\n+\tremove_stmt_references, remove_all_references,\n+\tremove_all_referring, dump_references, dump_referring,\n+\thas_alias_p, iterate_reference, iterate_referring.\n+\t* cgraphbuild.c (record_reference): New IPA REF function used.\n+\t(record_type_list): Likewise.\n+\t(record_eh_tables): Likewise.\n+\t(mark_address): Likewise.\n+\t(mark_load): Likewise.\n+\t(mark_store): Likewise.\n+\t(pass_build_cgraph_edges): Likewise.\n+\t(rebuild_cgraph_edge): Likewise.\n+\t(cgraph_rebuild_references): Likewise.\n+\t(pass_remove_cgraph_callee_edges): Likewise.\n+\t* cgraphclones.c (cgraph_clone_node): Likewise.\n+\t(cgraph_create_virtual_clone): Likewise.\n+\t(cgraph_materialize_clone): Likewise.\n+\t(cgraph_materialize_all_clones): Likewise.\n+\t* cgraphunit.c (cgraph_reset_node): Likewise.\n+\t(cgraph_reset_node): Likewise.\n+\t(analyze_function): Likewise.\n+\t(assemble_thunks_and_aliases): Likewise.\n+\t(expand_function): Likewise.\n+\t* ipa-comdats.c (propagate_comdat_group): Likewise.\n+\t(enqueue_references): Likewise.\n+\t* ipa-cp.c (ipcp_discover_new_direct_edges): Likewise.\n+\t(create_specialized_node): Likewise.\n+\t* ipa-devirt.c (referenced_from_vtable_p): Likewise.\n+\t* ipa-inline-transform.c (can_remove_node_now_p_1): Likewise.\n+\t* ipa-inline.c (reset_edge_caches): Likewise.\n+\t(update_caller_keys): Likewise.\n+\t(execute): Likewise.\n+\t* ipa-prop.c (remove_described_reference): Likewise.\n+\t(propagate_controlled_uses): Likewise.\n+\t(ipa_edge_duplication_hook): Likewise.\n+\t(ipa_modify_call_arguments): Likewise.\n+\t* ipa-pure-const.c (propagate_pure_const): Likewise.\n+\t* ipa-ref-inline.h: Header file removed, functions moved\n+\tto symtab_node class.\n+\t* ipa-ref.c (remove_reference): New class member function.\n+\t(cannot_lead_to_return): New class member function.\n+\t(referring_ref_list): Likewise.\n+\t(referred_ref_list): Likewise.\n+\tRest of functions moved to symtab_node class.\n+\t* ipa-ref.h: New member functions remove_reference,\n+\tcannot_lead_to_return, referring_ref_list, referred_ref_list added\n+\tto ipa_ref class.\n+\tipa_ref_list class has new member functions: first_reference,\n+\tfirst_referring, clear, nreferences.\n+\t* ipa-reference.c (analyze_function): New IPA REF function used.\n+\t(write_node_summary_p): Likewise.\n+\t(ipa_reference_write_optimization_summary): Likewise.\n+\t* ipa-split.c (split_function): Likewise.\n+\t* ipa-utils.c (ipa_reverse_postorder): Likewise.\n+\t* ipa-visibility.c (cgraph_non_local_node_p_1): Likewise.\n+\t(function_and_variable_visibility): Likewise.\n+\t* ipa.c (has_addr_references_p): Likewise.\n+\t(process_references): Argument type changed.\n+\t(symtab_remove_unreachable_nodes): New IPA REF function used.\n+\t(process_references): Likewise.\n+\t(set_writeonly_bit): Likewise.\n+\t* lto-cgraph.c: Implementation of new symtab_node member functions\n+\tthat uses new IPA REF functions.\n+\t* lto-streamer-in.c (fixup_call_stmt_edges_1): New IPA REF function used.\n+\t* lto-streamer-out.c (output_symbol_p): Likewise.\n+\t* lto-streamer.h (referenced_from_this_partition_p): Argument type\n+\tchanged.\n+\t* lto/lto-partition.c (add_references_to_partition): New IPA REF function\n+\tused.\n+\t(add_symbol_to_partition_1): Likewise.\n+\t(lto_balanced_map): Likewise.\n+\t* lto/lto-symtab.c (lto_cgraph_replace_node): Likewise.\n+\t* symtab.c: Implementation of new IPA REF API.\n+\t* trans-mem.c (ipa_tm_create_version_alias): New IPA REF function used.\n+\t(ipa_tm_create_version): Likewise.\n+\t(ipa_tm_execute): Likewise.\n+\t* tree-emutls.c (gen_emutls_addr): Likewise.\n+\t* tree-inline.c (copy_bb): Likewise.\n+\t(delete_unreachable_blocks_update_callgraph): Likewise.\n+\t* varpool.c (varpool_remove_unreferenced_decls): Likewise.\n+\t(varpool_for_node_and_aliases): Likewise.\n+\n 2014-06-25  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* config/i386/winnt.c (i386_find_on_wrapper_list): Fix typo."}, {"sha": "c9502736a830aaff756dd35c4cc596f46cd37883", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -905,7 +905,7 @@ CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) double-int.h \\\n IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H)\n IPA_REFERENCE_H = ipa-reference.h $(BITMAP_H) $(TREE_H)\n CGRAPH_H = cgraph.h $(VEC_H) $(TREE_H) $(BASIC_BLOCK_H) $(FUNCTION_H) \\\n-\tcif-code.def ipa-ref.h ipa-ref-inline.h $(LINKER_PLUGIN_API_H) is-a.h\n+\tcif-code.def ipa-ref.h $(LINKER_PLUGIN_API_H) is-a.h\n DF_H = df.h $(BITMAP_H) $(REGSET_H) sbitmap.h $(BASIC_BLOCK_H) \\\n \talloc-pool.h $(TIMEVAR_H)\n RESOURCE_H = resource.h hard-reg-set.h $(DF_H)"}, {"sha": "7360f7734216b636b42ac520e51651f4c2668e4c", "filename": "gcc/cgraph.c", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -1101,7 +1101,7 @@ cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n \t\t\t\t int direct_frequency)\n {\n   struct cgraph_node *n = e->caller;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n   struct cgraph_edge *e2;\n \n   if (dump_file)\n@@ -1123,8 +1123,7 @@ cgraph_turn_edge_to_speculative (struct cgraph_edge *e,\n   e->count -= e2->count;\n   e->frequency -= e2->frequency;\n   cgraph_call_edge_duplication_hooks (e, e2);\n-  ref = ipa_record_reference (n, n2,\n-\t\t\t      IPA_REF_ADDR, e->call_stmt);\n+  ref = n->add_reference (n2, IPA_REF_ADDR, e->call_stmt);\n   ref->lto_stmt_uid = e->lto_stmt_uid;\n   ref->speculative = e->speculative;\n   cgraph_mark_address_taken_node (n2);\n@@ -1177,8 +1176,7 @@ cgraph_speculative_call_info (struct cgraph_edge *e,\n   indirect = e2;\n \n   reference = NULL;\n-  for (i = 0; ipa_ref_list_reference_iterate (&e->caller->ref_list,\n-\t\t\t\t\t      i, ref); i++)\n+  for (i = 0; e->caller->iterate_reference (i, ref); i++)\n     if (ref->speculative\n \t&& ((ref->stmt && ref->stmt == e->call_stmt)\n \t    || (!ref->stmt && ref->lto_stmt_uid == e->lto_stmt_uid)))\n@@ -1257,7 +1255,7 @@ cgraph_resolve_speculation (struct cgraph_edge *edge, tree callee_decl)\n     edge->frequency = CGRAPH_FREQ_MAX;\n   edge->speculative = false;\n   e2->speculative = false;\n-  ipa_remove_reference (ref);\n+  ref->remove_reference ();\n   if (e2->indirect_unknown_callee || e2->inline_failed)\n     cgraph_remove_edge (e2);\n   else\n@@ -2197,7 +2195,7 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n {\n   struct cgraph_edge *e;\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n   if (callback (node, data))\n     return true;\n@@ -2208,10 +2206,10 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n       if (cgraph_for_node_thunks_and_aliases (e->caller, callback, data,\n \t\t\t\t\t      include_overwritable))\n \treturn true;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n+\tstruct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n \tif (include_overwritable\n \t    || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n \t  if (cgraph_for_node_thunks_and_aliases (alias, callback, data,\n@@ -2232,14 +2230,14 @@ cgraph_for_node_and_aliases (struct cgraph_node *node,\n \t\t\t     bool include_overwritable)\n {\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n+\tstruct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n \tif (include_overwritable\n \t    || cgraph_function_body_availability (alias) > AVAIL_OVERWRITABLE)\n           if (cgraph_for_node_and_aliases (alias, callback, data,\n@@ -2843,15 +2841,14 @@ verify_cgraph_node (struct cgraph_node *node)\n     {\n       bool ref_found = false;\n       int i;\n-      struct ipa_ref *ref;\n+      struct ipa_ref *ref = NULL;\n \n       if (node->callees)\n \t{\n \t  error (\"Alias has call edges\");\n           error_found = true;\n \t}\n-      for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list,\n-\t\t\t\t\t\t  i, ref); i++)\n+      for (i = 0; node->iterate_reference (i, ref); i++)\n \tif (ref->use != IPA_REF_ALIAS)\n \t  {\n \t    error (\"Alias has non-alias reference\");\n@@ -2897,7 +2894,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t{\n \t  pointer_set_t *stmts = pointer_set_create ();\n \t  int i;\n-\t  struct ipa_ref *ref;\n+\t  struct ipa_ref *ref = NULL;\n \n \t  /* Reach the trees by walking over the CFG, and note the\n \t     enclosing basic-blocks in the call edges.  */\n@@ -2955,8 +2952,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t}\n \t      }\n \t    for (i = 0;\n-\t\t ipa_ref_list_reference_iterate (&node->ref_list, i, ref);\n-\t\t i++)\n+\t\t node->iterate_reference (i, ref); i++)\n \t      if (ref->stmt && !pointer_set_contains (stmts, ref->stmt))\n \t\t{\n \t\t  error (\"reference to dead statement\");"}, {"sha": "0761e266a1462aab64d06b6dae527f72fa96df75", "filename": "gcc/cgraph.h", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -189,6 +189,71 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n       return x_section->name;\n     }\n \n+  /* Return ipa reference from this symtab_node to\n+     REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+     of the use and STMT the statement (if it exists).  */\n+  struct ipa_ref *add_reference (symtab_node *referred_node,\n+\t\t\t\tenum ipa_ref_use use_type);\n+\n+  /* Return ipa reference from this symtab_node to\n+     REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+     of the use and STMT the statement (if it exists).  */\n+  struct ipa_ref *add_reference (symtab_node *referred_node,\n+\t\t\t\t enum ipa_ref_use use_type, gimple stmt);\n+\n+  /* If VAL is a reference to a function or a variable, add a reference from\n+     this symtab_node to the corresponding symbol table node.  USE_TYPE specify\n+     type of the use and STMT the statement (if it exists).  Return the new\n+     reference or NULL if none was created.  */\n+  struct ipa_ref *maybe_add_reference (tree val, enum ipa_ref_use use_type,\n+\t\t\t\t       gimple stmt);\n+\n+  /* Clone all references from symtab NODE to this symtab_node.  */\n+  void clone_references (symtab_node *node);\n+\n+  /* Remove all stmt references in non-speculative references.\n+     Those are not maintained during inlining & clonning.\n+     The exception are speculative references that are updated along\n+     with callgraph edges associated with them.  */\n+  void clone_referring (symtab_node *node);\n+\n+  /* Clone reference REF to this symtab_node and set its stmt to STMT.  */\n+  struct ipa_ref *clone_reference (struct ipa_ref *ref, gimple stmt);\n+\n+  /* Find the structure describing a reference to REFERRED_NODE\n+     and associated with statement STMT.  */\n+  struct ipa_ref *find_reference (symtab_node *, gimple, unsigned int);\n+\n+  /* Remove all references that are associated with statement STMT.  */\n+  void remove_stmt_references (gimple stmt);\n+\n+  /* Remove all stmt references in non-speculative references.\n+     Those are not maintained during inlining & clonning.\n+     The exception are speculative references that are updated along\n+     with callgraph edges associated with them.  */\n+  void clear_stmts_in_references (void);\n+\n+  /* Remove all references in ref list.  */\n+  void remove_all_references (void);\n+\n+  /* Remove all referring items in ref list.  */\n+  void remove_all_referring (void);\n+\n+  /* Dump references in ref list to FILE.  */\n+  void dump_references (FILE *file);\n+\n+  /* Dump referring in list to FILE.  */\n+  void dump_referring (FILE *);\n+\n+  /* Return true if list contains an alias.  */\n+  bool has_aliases_p (void);\n+\n+  /* Iterates I-th reference in the list, REF is also set.  */\n+  struct ipa_ref *iterate_reference (unsigned i, struct ipa_ref *&ref);\n+\n+  /* Iterates I-th referring item in the list, REF is also set.  */\n+  struct ipa_ref *iterate_referring (unsigned i, struct ipa_ref *&ref);\n+\n   /* Vectors of referring and referenced entities.  */\n   struct ipa_ref_list ref_list;\n \n@@ -1537,16 +1602,13 @@ varpool_all_refs_explicit_p (varpool_node *vnode)\n /* Constant pool accessor function.  */\n htab_t constant_pool_htab (void);\n \n-/* FIXME: inappropriate dependency of cgraph on IPA.  */\n-#include \"ipa-ref-inline.h\"\n-\n /* Return node that alias N is aliasing.  */\n \n static inline symtab_node *\n symtab_alias_target (symtab_node *n)\n {\n-  struct ipa_ref *ref;\n-  ipa_ref_list_reference_iterate (&n->ref_list, 0, ref);\n+  struct ipa_ref *ref = NULL;\n+  n->iterate_reference (0, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n   return ref->referred;\n }"}, {"sha": "bfc4495ca19cd968cb19c0603a8e5962b206dce6", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 20, "deletions": 39, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -82,17 +82,13 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \t  struct cgraph_node *node = cgraph_get_create_node (decl);\n \t  if (!ctx->only_vars)\n \t    cgraph_mark_address_taken_node (node);\n-\t  ipa_record_reference (ctx->varpool_node,\n-\t\t\t\tnode,\n-\t\t\t        IPA_REF_ADDR, NULL);\n+\t  ctx->varpool_node->add_reference (node, IPA_REF_ADDR);\n \t}\n \n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n \t  varpool_node *vnode = varpool_node_for_decl (decl);\n-\t  ipa_record_reference (ctx->varpool_node,\n-\t\t\t\tvnode,\n-\t\t\t\tIPA_REF_ADDR, NULL);\n+\t  ctx->varpool_node->add_reference (vnode, IPA_REF_ADDR);\n \t}\n       *walk_subtrees = 0;\n       break;\n@@ -129,9 +125,7 @@ record_type_list (struct cgraph_node *node, tree list)\n \t  if (TREE_CODE (type) == VAR_DECL)\n \t    {\n \t      varpool_node *vnode = varpool_node_for_decl (type);\n-\t      ipa_record_reference (node,\n-\t\t\t\t    vnode,\n-\t\t\t\t    IPA_REF_ADDR, NULL);\n+\t      node->add_reference (vnode, IPA_REF_ADDR);\n \t    }\n \t}\n     }\n@@ -150,7 +144,7 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)\n       tree per_decl = DECL_FUNCTION_PERSONALITY (node->decl);\n       struct cgraph_node *per_node = cgraph_get_create_node (per_decl);\n \n-      ipa_record_reference (node, per_node, IPA_REF_ADDR, NULL);\n+      node->add_reference (per_node, IPA_REF_ADDR);\n       cgraph_mark_address_taken_node (per_node);\n     }\n \n@@ -231,18 +225,14 @@ mark_address (gimple stmt, tree addr, tree, void *data)\n     {\n       struct cgraph_node *node = cgraph_get_create_node (addr);\n       cgraph_mark_address_taken_node (node);\n-      ipa_record_reference ((symtab_node *)data,\n-\t\t\t    node,\n-\t\t\t    IPA_REF_ADDR, stmt);\n+      ((symtab_node *)data)->add_reference (node, IPA_REF_ADDR, stmt);\n     }\n   else if (addr && TREE_CODE (addr) == VAR_DECL\n \t   && (TREE_STATIC (addr) || DECL_EXTERNAL (addr)))\n     {\n       varpool_node *vnode = varpool_node_for_decl (addr);\n \n-      ipa_record_reference ((symtab_node *)data,\n-\t\t\t    vnode,\n-\t\t\t    IPA_REF_ADDR, stmt);\n+      ((symtab_node *)data)->add_reference (vnode, IPA_REF_ADDR, stmt);\n     }\n \n   return false;\n@@ -260,18 +250,14 @@ mark_load (gimple stmt, tree t, tree, void *data)\n \t directly manipulated in the code.  Pretend that it's an address.  */\n       struct cgraph_node *node = cgraph_get_create_node (t);\n       cgraph_mark_address_taken_node (node);\n-      ipa_record_reference ((symtab_node *)data,\n-\t\t\t    node,\n-\t\t\t    IPA_REF_ADDR, stmt);\n+      ((symtab_node *)data)->add_reference (node, IPA_REF_ADDR, stmt);\n     }\n   else if (t && TREE_CODE (t) == VAR_DECL\n \t   && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       varpool_node *vnode = varpool_node_for_decl (t);\n \n-      ipa_record_reference ((symtab_node *)data,\n-\t\t\t    vnode,\n-\t\t\t    IPA_REF_LOAD, stmt);\n+      ((symtab_node *)data)->add_reference (vnode, IPA_REF_LOAD, stmt);\n     }\n   return false;\n }\n@@ -287,9 +273,7 @@ mark_store (gimple stmt, tree t, tree, void *data)\n     {\n       varpool_node *vnode = varpool_node_for_decl (t);\n \n-      ipa_record_reference ((symtab_node *)data,\n-\t\t\t    vnode,\n-\t\t\t    IPA_REF_STORE, stmt);\n+      ((symtab_node *)data)->add_reference (vnode, IPA_REF_STORE, stmt);\n      }\n   return false;\n }\n@@ -375,22 +359,19 @@ pass_build_cgraph_edges::execute (function *fun)\n \t      && gimple_omp_parallel_child_fn (stmt))\n \t    {\n \t      tree fn = gimple_omp_parallel_child_fn (stmt);\n-\t      ipa_record_reference (node,\n-\t\t\t\t    cgraph_get_create_node (fn),\n-\t\t\t\t    IPA_REF_ADDR, stmt);\n+\t      node->add_reference (cgraph_get_create_node (fn),\n+\t\t\t\t      IPA_REF_ADDR, stmt);\n \t    }\n \t  if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n \t    {\n \t      tree fn = gimple_omp_task_child_fn (stmt);\n \t      if (fn)\n-\t\tipa_record_reference (node,\n-\t\t\t\t      cgraph_get_create_node (fn),\n-\t\t\t\t      IPA_REF_ADDR, stmt);\n+\t\tnode->add_reference (cgraph_get_create_node (fn),\n+\t\t\t\t\tIPA_REF_ADDR, stmt);\n \t      fn = gimple_omp_task_copy_fn (stmt);\n \t      if (fn)\n-\t\tipa_record_reference (node,\n-\t\t\t\t      cgraph_get_create_node (fn),\n-\t\t\t\t      IPA_REF_ADDR, stmt);\n+\t\tnode->add_reference (cgraph_get_create_node (fn),\n+\t\t\t\t\tIPA_REF_ADDR, stmt);\n \t    }\n \t}\n       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -446,7 +427,7 @@ rebuild_cgraph_edges (void)\n   gimple_stmt_iterator gsi;\n \n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->ref_list);\n+  node->remove_all_references ();\n \n   node->count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n \n@@ -492,13 +473,13 @@ cgraph_rebuild_references (void)\n   basic_block bb;\n   struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   gimple_stmt_iterator gsi;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n   int i;\n \n   /* Keep speculative references for further cgraph edge expansion.  */\n-  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref);)\n+  for (i = 0; node->iterate_reference (i, ref);)\n     if (!ref->speculative)\n-      ipa_remove_reference (ref);\n+      ref->remove_reference ();\n     else\n       i++;\n \n@@ -588,7 +569,7 @@ pass_remove_cgraph_callee_edges::execute (function *)\n {\n   struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->ref_list);\n+  node->remove_all_references ();\n   return 0;\n }\n "}, {"sha": "d57cd9f3a41b65d2c7ca60797cff48a148fd227a", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -459,7 +459,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   for (e = n->indirect_calls; e; e = e->next_callee)\n     cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n \t\t       count_scale, freq, update_original);\n-  ipa_clone_references (new_node, &n->ref_list);\n+  new_node->clone_references (n);\n \n   new_node->next_sibling_clone = n->clones;\n   if (n->clones)\n@@ -568,8 +568,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n       || in_lto_p)\n     new_node->unique_name = true;\n   FOR_EACH_VEC_SAFE_ELT (tree_map, i, map)\n-    ipa_maybe_record_reference (new_node, map->new_tree,\n-\t\t\t\tIPA_REF_ADDR, NULL);\n+    new_node->maybe_add_reference (map->new_tree, IPA_REF_ADDR, NULL);\n   if (!args_to_skip)\n     new_node->clone.combined_args_to_skip = old_node->clone.combined_args_to_skip;\n   else if (old_node->clone.combined_args_to_skip)\n@@ -1035,7 +1034,7 @@ cgraph_materialize_clone (struct cgraph_node *node)\n     {\n       cgraph_release_function_body (node->clone_of);\n       cgraph_node_remove_callees (node->clone_of);\n-      ipa_remove_all_references (&node->clone_of->ref_list);\n+      node->clone_of->remove_all_references ();\n     }\n   node->clone_of = NULL;\n   bitmap_obstack_release (NULL);\n@@ -1120,10 +1119,10 @@ cgraph_materialize_all_clones (void)\n     if (!node->analyzed && node->callees)\n       {\n         cgraph_node_remove_callees (node);\n-\tipa_remove_all_references (&node->ref_list);\n+\tnode->remove_all_references ();\n       }\n     else\n-      ipa_clear_stmts_in_references (node);\n+      node->clear_stmts_in_references ();\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Materialization Call site updates done.\\n\");\n #ifdef ENABLE_CHECKING"}, {"sha": "76b2fda1d1e40cc4f0767494b3d48702cbce5225", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -393,18 +393,18 @@ cgraph_reset_node (struct cgraph_node *node)\n   node->cpp_implicit_alias = false;\n \n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->ref_list);\n+  node->remove_all_references ();\n }\n \n /* Return true when there are references to NODE.  */\n \n static bool\n referred_to_p (symtab_node *node)\n {\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n   /* See if there are any references at all.  */\n-  if (ipa_ref_list_referring_iterate (&node->ref_list, 0, ref))\n+  if (node->iterate_referring (0, ref))\n     return true;\n   /* For functions check also calls.  */\n   cgraph_node *cn = dyn_cast <cgraph_node *> (node);\n@@ -1069,7 +1069,7 @@ analyze_functions (void)\n \t\t   next = next->same_comdat_group)\n \t\tenqueue_node (next);\n \t    }\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+\t  for (i = 0; node->iterate_reference (i, ref); i++)\n \t    if (ref->referred->definition)\n \t      enqueue_node (ref->referred);\n           cgraph_process_new_functions ();\n@@ -1712,7 +1712,7 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n   for (e = node->callers; e;)\n     if (e->caller->thunk.thunk_p)\n@@ -1725,11 +1725,10 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n       }\n     else\n       e = e->next_caller;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n-\t\t\t\t\t     i, ref); i++)\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n+\tstruct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n         bool saved_written = TREE_ASM_WRITTEN (node->decl);\n \n \t/* Force assemble_alias to really output the alias this time instead\n@@ -1852,7 +1851,7 @@ expand_function (struct cgraph_node *node)\n   /* Eliminate all call edges.  This is important so the GIMPLE_CALL no longer\n      points to the dead function body.  */\n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->ref_list);\n+  node->remove_all_references ();\n }\n \n /* Node comparer that is responsible for the order that corresponds"}, {"sha": "f9e1ad80059681efc2665a7bbf02d9fe59479d91", "filename": "gcc/ipa-comdats.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-comdats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-comdats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-comdats.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -72,7 +72,7 @@ propagate_comdat_group (struct symtab_node *symbol,\n   /* Walk all references to SYMBOL, recursively dive into aliases.  */\n \n   for (i = 0;\n-       ipa_ref_list_referring_iterate (&symbol->ref_list, i, ref)\n+       symbol->iterate_referring (i, ref)\n        && newgroup != error_mark_node; i++)\n     {\n       struct symtab_node *symbol2 = ref->referring;\n@@ -161,9 +161,9 @@ enqueue_references (symtab_node **first,\n \t\t    symtab_node *symbol)\n {\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n-  for (i = 0; ipa_ref_list_reference_iterate (&symbol->ref_list, i, ref); i++)\n+  for (i = 0; symbol->iterate_reference (i, ref); i++)\n     {\n       symtab_node *node = symtab_alias_ultimate_target (ref->referred, NULL);\n       if (!node->aux && node->definition)"}, {"sha": "04e88b576fde2d7b30ea9327cc32921d48c32120", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -2387,14 +2387,12 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \t\t    fprintf (dump_file, \"     controlled uses count of param \"\n \t\t\t     \"%i bumped down to %i\\n\", param_index, c);\n \t\t  if (c == 0\n-\t\t      && (to_del = ipa_find_reference (node,\n-\t\t\t\t\t\t       cs->callee,\n-\t\t\t\t\t\t       NULL, 0)))\n+\t\t      && (to_del = node->find_reference (cs->callee, NULL, 0)))\n \t\t    {\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\tfprintf (dump_file, \"       and even removing its \"\n \t\t\t\t \"cloning-created reference\\n\");\n-\t\t      ipa_remove_reference (to_del);\n+\t\t      to_del->remove_reference ();\n \t\t    }\n \t\t}\n \t    }\n@@ -2803,8 +2801,7 @@ create_specialized_node (struct cgraph_node *node,\n \t\t\t\t\t  args_to_skip, \"constprop\");\n   ipa_set_node_agg_value_chain (new_node, aggvals);\n   for (av = aggvals; av; av = av->next)\n-    ipa_maybe_record_reference (new_node, av->value,\n-\t\t\t\tIPA_REF_ADDR, NULL);\n+    new_node->maybe_add_reference (av->value, IPA_REF_ADDR, NULL);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {"}, {"sha": "21f4f11218f82ad6991a3c8ffb2e59d73f9b64b2", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -686,8 +686,7 @@ referenced_from_vtable_p (struct cgraph_node *node)\n   if (cgraph_state <= CGRAPH_STATE_CONSTRUCTION)\n     return true;\n \n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n-\t\t\t\t\t      i, ref); i++)\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n \t\n     if ((ref->use == IPA_REF_ALIAS\n \t && referenced_from_vtable_p (cgraph (ref->referring)))"}, {"sha": "03442fc07d7387b864beb0f472e2691217472235", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -86,7 +86,7 @@ can_remove_node_now_p_1 (struct cgraph_node *node)\n      can remove its offline copy, but we would need to keep unanalyzed node in\n      the callgraph so references can point to it.  */\n   return (!node->address_taken\n-\t  && !ipa_ref_has_aliases_p (&node->ref_list)\n+\t  && !node->has_aliases_p ()\n \t  && !node->used_as_abstract_origin\n \t  && cgraph_can_remove_if_no_direct_calls_p (node)\n \t  /* Inlining might enable more devirtualizing, so we want to remove\n@@ -451,7 +451,7 @@ inline_transform (struct cgraph_node *node)\n       next = e->next_callee;\n       cgraph_redirect_edge_call_stmt_to_callee (e);\n     }\n-  ipa_remove_all_references (&node->ref_list);\n+  node->remove_all_references ();\n \n   timevar_push (TV_INTEGRATION);\n   if (node->callees && optimize)"}, {"sha": "81030f3a01a39d1e829bb4be991c281415a3d745", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -1120,7 +1120,7 @@ reset_edge_caches (struct cgraph_node *node)\n   struct cgraph_edge *e = node->callees;\n   struct cgraph_node *where = node;\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n   if (where->global.inlined_to)\n     where = where->global.inlined_to;\n@@ -1131,10 +1131,9 @@ reset_edge_caches (struct cgraph_node *node)\n   for (edge = where->callers; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       reset_edge_growth_cache (edge);\n-  for (i = 0; ipa_ref_list_referring_iterate (&where->ref_list,\n-\t\t\t\t\t      i, ref); i++)\n+  for (i = 0; where->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n-      reset_edge_caches (ipa_ref_referring_node (ref));\n+      reset_edge_caches (dyn_cast <cgraph_node *> (ref->referring));\n \n   if (!e)\n     return;\n@@ -1174,19 +1173,18 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n {\n   struct cgraph_edge *edge;\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n   if ((!node->alias && !inline_summary (node)->inlinable)\n       || node->global.inlined_to)\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n     return;\n \n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n-\t\t\t\t\t      i, ref); i++)\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tstruct cgraph_node *alias = ipa_ref_referring_node (ref);\n+\tstruct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n         update_caller_keys (heap, alias, updated_nodes, check_inlinablity_for);\n       }\n \n@@ -2430,7 +2428,7 @@ pass_early_inline::execute (function *fun)\n #ifdef ENABLE_CHECKING\n   verify_cgraph_node (node);\n #endif\n-  ipa_remove_all_references (&node->ref_list);\n+  node->remove_all_references ();\n \n   /* Even when not optimizing or not inlining inline always-inline\n      functions.  */"}, {"sha": "5f5bf891a5dbbf1a05a1304d04dc1661ef483ee9", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -2806,12 +2806,12 @@ remove_described_reference (symtab_node *symbol, struct ipa_cst_ref_desc *rdesc)\n   origin = rdesc->cs;\n   if (!origin)\n     return false;\n-  to_del = ipa_find_reference (origin->caller, symbol,\n-\t\t\t       origin->call_stmt, origin->lto_stmt_uid);\n+  to_del = origin->caller->find_reference (symbol, origin->call_stmt,\n+\t\t\t\t\t   origin->lto_stmt_uid);\n   if (!to_del)\n     return false;\n \n-  ipa_remove_reference (to_del);\n+  to_del->remove_reference ();\n   if (dump_file)\n     fprintf (dump_file, \"ipa-prop: Removed a reference from %s/%i to %s.\\n\",\n \t     xstrdup (origin->caller->name ()),\n@@ -3209,16 +3209,15 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t      if (t && TREE_CODE (t) == ADDR_EXPR\n \t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL\n \t\t  && (n = cgraph_get_node (TREE_OPERAND (t, 0)))\n-\t\t  && (ref = ipa_find_reference (new_root,\n-\t\t\t\t\t\tn, NULL, 0)))\n+\t\t  && (ref = new_root->find_reference (n, NULL, 0)))\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"ipa-prop: Removing cloning-created \"\n \t\t\t     \"reference from %s/%i to %s/%i.\\n\",\n \t\t\t     xstrdup (new_root->name ()),\n \t\t\t     new_root->order,\n \t\t\t     xstrdup (n->name ()), n->order);\n-\t\t  ipa_remove_reference (ref);\n+\t\t  ref->remove_reference ();\n \t\t}\n \t    }\n \t}\n@@ -3249,8 +3248,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t\t && IPA_NODE_REF (clone)->ipcp_orig_node)\n \t\t    {\n \t\t      struct ipa_ref *ref;\n-\t\t      ref = ipa_find_reference (clone,\n-\t\t\t\t\t\tn, NULL, 0);\n+\t\t      ref = clone->find_reference (n, NULL, 0);\n \t\t      if (ref)\n \t\t\t{\n \t\t\t  if (dump_file)\n@@ -3261,7 +3259,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t\t\t     clone->order,\n \t\t\t\t     xstrdup (n->name ()),\n \t\t\t\t     n->order);\n-\t\t\t  ipa_remove_reference (ref);\n+\t\t\t  ref->remove_reference ();\n \t\t\t}\n \t\t      clone = clone->callers->caller;\n \t\t    }\n@@ -3455,10 +3453,10 @@ ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t      struct ipa_ref *ref;\n \t      symtab_node *n = cgraph_node_for_jfunc (src_jf);\n \t      gcc_checking_assert (n);\n-\t      ref = ipa_find_reference (src->caller, n,\n-\t\t\t\t\tsrc->call_stmt, src->lto_stmt_uid);\n+\t      ref = src->caller->find_reference (n, src->call_stmt,\n+\t\t\t\t\t\t src->lto_stmt_uid);\n \t      gcc_checking_assert (ref);\n-\t      ipa_clone_ref (ref, dst->caller, ref->stmt);\n+\t      dst->caller->clone_reference (ref, ref->stmt);\n \n \t      gcc_checking_assert (ipa_refdesc_pool);\n \t      struct ipa_cst_ref_desc *dst_rdesc\n@@ -3899,7 +3897,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n   len = adjustments.length ();\n   vargs.create (len);\n   callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->decl;\n-  ipa_remove_stmt_references (current_node, stmt);\n+  current_node->remove_stmt_references (stmt);\n \n   gsi = gsi_for_stmt (stmt);\n   prev_gsi = gsi;"}, {"sha": "a074a1186c53c417b817ebbfabbea9a7364f44f7", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -1138,7 +1138,7 @@ propagate_pure_const (void)\n \t  struct cgraph_edge *e;\n \t  struct cgraph_edge *ie;\n \t  int i;\n-\t  struct ipa_ref *ref;\n+\t  struct ipa_ref *ref = NULL;\n \n \t  funct_state w_l = get_function_state (w);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1263,22 +1263,22 @@ propagate_pure_const (void)\n \t    break;\n \n \t  /* And finally all loads and stores.  */\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&w->ref_list, i, ref); i++)\n+\t  for (i = 0; w->iterate_reference (i, ref); i++)\n \t    {\n \t      enum pure_const_state_e ref_state = IPA_CONST;\n \t      bool ref_looping = false;\n \t      switch (ref->use)\n \t\t{\n \t\tcase IPA_REF_LOAD:\n \t\t  /* readonly reads are safe.  */\n-\t\t  if (TREE_READONLY (ipa_ref_varpool_node (ref)->decl))\n+\t\t  if (TREE_READONLY (ref->referred->decl))\n \t\t    break;\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    fprintf (dump_file, \"    nonreadonly global var read\\n\");\n \t\t  ref_state = IPA_PURE;\n \t\t  break;\n \t\tcase IPA_REF_STORE:\n-\t\t  if (ipa_ref_cannot_lead_to_return (ref))\n+\t\t  if (ref->cannot_lead_to_return ())\n \t\t    break;\n \t\t  ref_state = IPA_NEITHER;\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "1be173a1b44830f59b9377ae3b6cd1f8c7e74a4e", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 25, "deletions": 259, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -27,294 +27,60 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"ipa-utils.h\"\n \n-static const char *ipa_ref_use_name[] = {\"read\",\"write\",\"addr\",\"alias\"};\n-\n-/* Return ipa reference from REFERING_NODE or REFERING_VARPOOL_NODE\n-   to REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n-   of the use and STMT the statement (if it exists).  */\n-\n-struct ipa_ref *\n-ipa_record_reference (symtab_node *referring_node,\n-\t\t      symtab_node *referred_node,\n-\t\t      enum ipa_ref_use use_type, gimple stmt)\n-{\n-  struct ipa_ref *ref, *ref2;\n-  struct ipa_ref_list *list, *list2;\n-  ipa_ref_t *old_references;\n-\n-  gcc_checking_assert (!stmt || is_a <cgraph_node *> (referring_node));\n-  gcc_checking_assert (use_type != IPA_REF_ALIAS || !stmt);\n-\n-  list = &referring_node->ref_list;\n-  old_references = vec_safe_address (list->references);\n-  vec_safe_grow (list->references, vec_safe_length (list->references) + 1);\n-  ref = &list->references->last ();\n-\n-  list2 = &referred_node->ref_list;\n-  list2->referring.safe_push (ref);\n-  ref->referred_index = list2->referring.length () - 1;\n-  ref->referring = referring_node;\n-  ref->referred = referred_node;\n-  ref->stmt = stmt;\n-  ref->lto_stmt_uid = 0;\n-  ref->use = use_type;\n-  ref->speculative = 0;\n-\n-  /* If vector was moved in memory, update pointers.  */\n-  if (old_references != list->references->address ())\n-    {\n-      int i;\n-      for (i = 0; ipa_ref_list_reference_iterate (list, i, ref2); i++)\n-\tipa_ref_referred_ref_list (ref2)->referring[ref2->referred_index] = ref2;\n-    }\n-  return ref;\n-}\n-\n-/* If VAL is a reference to a function or a variable, add a reference from\n-   REFERRING_NODE to the corresponding symbol table node.  USE_TYPE specify\n-   type of the use and STMT the statement (if it exists).  Return the new\n-   reference or NULL if none was created.  */\n-\n-struct ipa_ref *\n-ipa_maybe_record_reference (symtab_node *referring_node, tree val,\n-\t\t\t    enum ipa_ref_use use_type, gimple stmt)\n-{\n-  STRIP_NOPS (val);\n-  if (TREE_CODE (val) != ADDR_EXPR)\n-    return NULL;\n-  val = get_base_var (val);\n-  if (val && (TREE_CODE (val) == FUNCTION_DECL\n-\t       || TREE_CODE (val) == VAR_DECL))\n-    {\n-      symtab_node *referred = symtab_get_node (val);\n-      gcc_checking_assert (referred);\n-      return ipa_record_reference (referring_node, referred,\n-\t\t\t\t   use_type, stmt);\n-    }\n-  return NULL;\n-}\n-\n-/* Remove reference REF.  */\n+/* Remove reference.  */\n \n void\n-ipa_remove_reference (struct ipa_ref *ref)\n+ipa_ref::remove_reference ()\n {\n-  struct ipa_ref_list *list = ipa_ref_referred_ref_list (ref);\n-  struct ipa_ref_list *list2 = ipa_ref_referring_ref_list (ref);\n+  struct ipa_ref_list *list = referred_ref_list ();\n+  struct ipa_ref_list *list2 = referring_ref_list ();\n   vec<ipa_ref_t, va_gc> *old_references = list2->references;\n   struct ipa_ref *last;\n \n-  gcc_assert (list->referring[ref->referred_index] == ref);\n+  gcc_assert (list->referring[referred_index] == this);\n   last = list->referring.last ();\n-  if (ref != last)\n+  if (this != last)\n     {\n-      list->referring[ref->referred_index] = list->referring.last ();\n-      list->referring[ref->referred_index]->referred_index \n-\t  = ref->referred_index;\n+      list->referring[referred_index] = list->referring.last ();\n+      list->referring[referred_index]->referred_index\n+\t  = referred_index;\n     }\n   list->referring.pop ();\n \n   last = &list2->references->last ();\n+\n+  struct ipa_ref *ref = this;\n+\n   if (ref != last)\n     {\n       *ref = *last;\n-      ipa_ref_referred_ref_list (ref)->referring[ref->referred_index] = ref;\n+      referred_ref_list ()->referring[referred_index] = ref;\n     }\n   list2->references->pop ();\n   gcc_assert (list2->references == old_references);\n }\n \n-/* Remove all references in ref list LIST.  */\n-\n-void\n-ipa_remove_all_references (struct ipa_ref_list *list)\n-{\n-  while (vec_safe_length (list->references))\n-    ipa_remove_reference (&list->references->last ());\n-  vec_free (list->references);\n-}\n-\n-/* Remove all references in ref list LIST.  */\n-\n-void\n-ipa_remove_all_referring (struct ipa_ref_list *list)\n-{\n-  while (list->referring.length ())\n-    ipa_remove_reference (list->referring.last ());\n-  list->referring.release ();\n-}\n-\n-/* Dump references in LIST to FILE.  */\n-\n-void\n-ipa_dump_references (FILE * file, struct ipa_ref_list *list)\n-{\n-  struct ipa_ref *ref;\n-  int i;\n-  for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n-    {\n-      fprintf (file, \"%s/%i (%s)\",\n-               ref->referred->asm_name (),\n-               ref->referred->order,\n-\t       ipa_ref_use_name [ref->use]);\n-      if (ref->speculative)\n-\tfprintf (file, \" (speculative)\");\n-    }\n-  fprintf (file, \"\\n\");\n-}\n-\n-/* Dump referring in LIST to FILE.  */\n-\n-void\n-ipa_dump_referring (FILE * file, struct ipa_ref_list *list)\n-{\n-  struct ipa_ref *ref;\n-  int i;\n-  for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n-    {\n-      fprintf (file, \"%s/%i (%s)\",\n-               ref->referring->asm_name (),\n-               ref->referring->order,\n-\t       ipa_ref_use_name [ref->use]);\n-      if (ref->speculative)\n-\tfprintf (file, \" (speculative)\");\n-    }\n-  fprintf (file, \"\\n\");\n-}\n-\n-/* Clone reference REF to DEST_NODE and set its stmt to STMT.  */\n-\n-struct ipa_ref *\n-ipa_clone_ref (struct ipa_ref *ref,\n-\t       symtab_node *dest_node,\n-\t       gimple stmt)\n-{\n-  bool speculative = ref->speculative;\n-  unsigned int stmt_uid = ref->lto_stmt_uid;\n-  struct ipa_ref *ref2;\n-\n-  ref2 = ipa_record_reference (dest_node,\n-\t\t\t       ref->referred,\n-\t\t\t       ref->use, stmt);\n-  ref2->speculative = speculative;\n-  ref2->lto_stmt_uid = stmt_uid;\n-  return ref2;\n-}\n-\n-/* Clone all references from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n+/* Return true when execution of reference can lead to return from\n+   function.  */\n \n-void\n-ipa_clone_references (symtab_node *dest_node,\n-\t\t      struct ipa_ref_list *src)\n-{\n-  struct ipa_ref *ref, *ref2;\n-  int i;\n-  for (i = 0; ipa_ref_list_reference_iterate (src, i, ref); i++)\n-    {\n-      bool speculative = ref->speculative;\n-      unsigned int stmt_uid = ref->lto_stmt_uid;\n-\n-      ref2 = ipa_record_reference (dest_node,\n-\t\t\t\t   ref->referred,\n-\t\t\t\t   ref->use, ref->stmt);\n-      ref2->speculative = speculative;\n-      ref2->lto_stmt_uid = stmt_uid;\n-    }\n-}\n-\n-/* Clone all referring from SRC to DEST_NODE or DEST_VARPOOL_NODE.  */\n-\n-void\n-ipa_clone_referring (symtab_node *dest_node,\n-\t\t    struct ipa_ref_list *src)\n-{\n-  struct ipa_ref *ref, *ref2;\n-  int i;\n-  for (i = 0; ipa_ref_list_referring_iterate (src, i, ref); i++)\n-    {\n-      bool speculative = ref->speculative;\n-      unsigned int stmt_uid = ref->lto_stmt_uid;\n-\n-      ref2 = ipa_record_reference (ref->referring,\n-\t\t\t\t   dest_node,\n-\t\t\t\t   ref->use, ref->stmt);\n-      ref2->speculative = speculative;\n-      ref2->lto_stmt_uid = stmt_uid;\n-    }\n-}\n-\n-/* Return true when execution of REF can lead to return from\n-   function. */\n bool\n-ipa_ref_cannot_lead_to_return (struct ipa_ref *ref)\n+ipa_ref::cannot_lead_to_return ()\n {\n-  return cgraph_node_cannot_return (ipa_ref_referring_node (ref));\n-}\n-\n-/* Return true if list contains an alias.  */\n-bool\n-ipa_ref_has_aliases_p (struct ipa_ref_list *ref_list)\n-{\n-  struct ipa_ref *ref;\n-  int i;\n-\n-  for (i = 0; ipa_ref_list_referring_iterate (ref_list, i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS)\n-      return true;\n-  return false;\n+  return cgraph_node_cannot_return (dyn_cast <cgraph_node *> (referring));\n }\n \n-/* Find the structure describing a reference in REFERRING_NODE to REFERRED_NODE\n-   and associated with statement STMT.  */\n+/* Return reference list this reference is in.  */\n \n-struct ipa_ref *\n-ipa_find_reference (symtab_node *referring_node, symtab_node *referred_node,\n-\t\t    gimple stmt, unsigned int lto_stmt_uid)\n+struct ipa_ref_list *\n+ipa_ref::referring_ref_list (void)\n {\n-  struct ipa_ref *r = NULL;\n-  int i;\n-\n-  for (i = 0; ipa_ref_list_reference_iterate (&referring_node->ref_list, i, r); i++)\n-    if (r->referred == referred_node\n-\t&& !r->speculative\n-\t&& ((stmt && r->stmt == stmt)\n-\t    || (lto_stmt_uid && r->lto_stmt_uid == lto_stmt_uid)\n-\t    || (!stmt && !lto_stmt_uid && !r->stmt && !r->lto_stmt_uid)))\n-      return r;\n-  return NULL;\n+  return &referring->ref_list;\n }\n \n-/* Remove all references from REFERRING_NODE that are associated with statement\n-   STMT.  */\n+/* Return reference list this reference is in.  */\n \n-void\n-ipa_remove_stmt_references (symtab_node *referring_node, gimple stmt)\n+struct ipa_ref_list *\n+ipa_ref::referred_ref_list (void)\n {\n-  struct ipa_ref *r = NULL;\n-  int i = 0;\n-\n-  while (ipa_ref_list_reference_iterate (&referring_node->ref_list, i, r))\n-    if (r->stmt == stmt)\n-      ipa_remove_reference (r);\n-    else\n-      i++;\n-}\n-\n-/* Remove all stmt references in non-speculative references.\n-   Those are not maintained during inlining & clonning. \n-   The exception are speculative references that are updated along\n-   with callgraph edges associated with them.  */\n-\n-void\n-ipa_clear_stmts_in_references (symtab_node *referring_node)\n-{\n-  struct ipa_ref *r = NULL;\n-  int i;\n-\n-  for (i = 0; ipa_ref_list_reference_iterate (&referring_node->ref_list, i, r); i++)\n-    if (!r->speculative)\n-      {\n-\tr->stmt = NULL;\n-\tr->lto_stmt_uid = 0;\n-      }\n+  return &referred->ref_list;\n }"}, {"sha": "d2de006b3ca5bbafb1369deea0014e8eda4e8ab3", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -35,6 +35,20 @@ enum GTY(()) ipa_ref_use\n /* Record of reference in callgraph or varpool.  */\n struct GTY(()) ipa_ref\n {\n+public:\n+  /* Remove reference.  */\n+  void remove_reference ();\n+\n+  /* Return true when execution of reference can lead to return from\n+     function.  */\n+  bool cannot_lead_to_return ();\n+\n+  /* Return reference list this reference is in.  */\n+  struct ipa_ref_list * referring_ref_list (void);\n+\n+  /* Return reference list this reference is in.  */\n+  struct ipa_ref_list * referred_ref_list (void);\n+\n   symtab_node *referring;\n   symtab_node *referred;\n   gimple stmt;\n@@ -51,29 +65,39 @@ typedef struct ipa_ref *ipa_ref_ptr;\n /* List of references.  This is stored in both callgraph and varpool nodes.  */\n struct GTY(()) ipa_ref_list\n {\n+public:\n+  /* Return first reference in list or NULL if empty.  */\n+  struct ipa_ref *first_reference (void)\n+  {\n+    if (!vec_safe_length (references))\n+      return NULL;\n+    return &(*references)[0];\n+  }\n+\n+  /* Return first referring ref in list or NULL if empty.  */\n+  struct ipa_ref *first_referring (void)\n+  {\n+    if (!referring.length ())\n+      return NULL;\n+    return referring[0];\n+  }\n+\n+  /* Clear reference list.  */\n+  void clear (void)\n+  {\n+    referring.create (0);\n+    references = NULL;\n+  }\n+\n+  /* Return number of references.  */\n+  unsigned int nreferences (void)\n+  {\n+    return vec_safe_length (references);\n+  }\n+\n   /* Store actual references in references vector.  */\n   vec<ipa_ref_t, va_gc> *references;\n   /* Referring is vector of pointers to references.  It must not live in GGC space\n      or GGC will try to mark middle of references vectors.  */\n   vec<ipa_ref_ptr>  GTY((skip)) referring;\n };\n-\n-struct ipa_ref * ipa_record_reference (symtab_node *,\n-\t\t\t\t       symtab_node *,\n-\t\t\t\t       enum ipa_ref_use, gimple);\n-struct ipa_ref * ipa_maybe_record_reference (symtab_node *, tree,\n-\t\t\t\t\t     enum ipa_ref_use, gimple);\n-\n-void ipa_remove_reference (struct ipa_ref *);\n-void ipa_remove_all_references (struct ipa_ref_list *);\n-void ipa_remove_all_referring (struct ipa_ref_list *);\n-void ipa_dump_references (FILE *, struct ipa_ref_list *);\n-void ipa_dump_referring (FILE *, struct ipa_ref_list *);\n-void ipa_clone_references (symtab_node *, struct ipa_ref_list *);\n-void ipa_clone_referring (symtab_node *, struct ipa_ref_list *);\n-struct ipa_ref * ipa_clone_ref (struct ipa_ref *, symtab_node *, gimple);\n-bool ipa_ref_cannot_lead_to_return (struct ipa_ref *);\n-bool ipa_ref_has_aliases_p (struct ipa_ref_list *);\n-struct ipa_ref * ipa_find_reference (symtab_node *, symtab_node *, gimple, unsigned int);\n-void ipa_remove_stmt_references (symtab_node *, gimple);\n-void ipa_clear_stmts_in_references (symtab_node *);"}, {"sha": "064fde22aa9c7d6e22ad3498dfad7538170b3ea5", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -450,16 +450,16 @@ static void\n analyze_function (struct cgraph_node *fn)\n {\n   ipa_reference_local_vars_info_t local;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n   int i;\n   tree var;\n \n   local = init_function_info (fn);\n-  for (i = 0; ipa_ref_list_reference_iterate (&fn->ref_list, i, ref); i++)\n+  for (i = 0; fn->iterate_reference (i, ref); i++)\n     {\n       if (!is_a <varpool_node *> (ref->referred))\n \tcontinue;\n-      var = ipa_ref_varpool_node (ref)->decl;\n+      var = ref->referred->decl;\n       if (!is_proper_for_analysis (var))\n \tcontinue;\n       switch (ref->use)\n@@ -468,7 +468,7 @@ analyze_function (struct cgraph_node *fn)\n           bitmap_set_bit (local->statics_read, DECL_UID (var));\n \t  break;\n \tcase IPA_REF_STORE:\n-\t  if (ipa_ref_cannot_lead_to_return (ref))\n+\t  if (ref->cannot_lead_to_return ())\n \t    break;\n           bitmap_set_bit (local->statics_written, DECL_UID (var));\n \t  break;\n@@ -882,7 +882,7 @@ write_node_summary_p (struct cgraph_node *node,\n      In future we might also want to include summaries of functions references\n      by initializers of constant variables references in current unit.  */\n   if (!reachable_from_this_partition_p (node, encoder)\n-      && !referenced_from_this_partition_p (&node->ref_list, encoder))\n+      && !referenced_from_this_partition_p (node, encoder))\n     return false;\n \n   /* See if the info has non-empty intersections with vars we want to encode.  */\n@@ -949,7 +949,7 @@ ipa_reference_write_optimization_summary (void)\n       varpool_node *vnode = dyn_cast <varpool_node *> (snode);\n       if (vnode\n \t  && bitmap_bit_p (all_module_statics, DECL_UID (vnode->decl))\n-\t  && referenced_from_this_partition_p (&vnode->ref_list, encoder))\n+\t  && referenced_from_this_partition_p (vnode, encoder))\n \t{\n \t  tree decl = vnode->decl;\n \t  bitmap_set_bit (ltrans_statics, DECL_UID (decl));"}, {"sha": "3ca57b6afe7324ff44ab0e38639fdb164a118b91", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -1251,7 +1251,7 @@ split_function (struct split_point *split_point)\n      a warning for the non-inlinable part.  */\n   DECL_NO_INLINE_WARNING_P (node->decl) = 1;\n   cgraph_node_remove_callees (cur_node);\n-  ipa_remove_all_references (&cur_node->ref_list);\n+  cur_node->remove_all_references ();\n   if (!split_part_return_p)\n     TREE_THIS_VOLATILE (node->decl) = 1;\n   if (dump_file)"}, {"sha": "c191210ccb7c1aa5e296728c5c8ac849971e3983", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -289,7 +289,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n   int order_pos = 0;\n   struct cgraph_edge *edge;\n   int pass;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n   struct postorder_stack *stack =\n     XCNEWVEC (struct postorder_stack, cgraph_n_nodes);\n@@ -332,13 +332,13 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t\t\t    (cgraph_function_node (edge->callee, NULL)->decl))\n \t\t\tnode2 = NULL;\n \t\t    }\n-\t\t  for (;ipa_ref_list_referring_iterate (&stack[stack_size].node->ref_list,\n+\t\t  for (; stack[stack_size].node->iterate_referring (\n \t\t\t\t\t\t       stack[stack_size].ref,\n \t\t\t\t\t\t       ref) && !node2;\n \t\t       stack[stack_size].ref++)\n \t\t    {\n \t\t      if (ref->use == IPA_REF_ALIAS)\n-\t\t\tnode2 = ipa_ref_referring_node (ref);\n+\t\t\tnode2 = dyn_cast <cgraph_node *> (ref->referring);\n \t\t    }\n \t\t  if (!node2)\n \t\t    break;"}, {"sha": "a4848c24783e01de35e6fd1825e35610f5706dd2", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -91,7 +91,7 @@ cgraph_non_local_node_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED\n {\n    /* FIXME: Aliases can be local, but i386 gets thunks wrong then.  */\n    return !(cgraph_only_called_directly_or_aliased_p (node)\n-\t    && !ipa_ref_has_aliases_p (&node->ref_list)\n+\t    && !node->has_aliases_p ()\n \t    && node->definition\n \t    && !DECL_EXTERNAL (node->decl)\n \t    && !node->externally_visible\n@@ -120,15 +120,15 @@ bool\n address_taken_from_non_vtable_p (symtab_node *node)\n {\n   int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n-\t\t\t\t\t     i, ref); i++)\n+  struct ipa_ref *ref = NULL;\n+\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ADDR)\n       {\n \tvarpool_node *node;\n \tif (is_a <cgraph_node *> (ref->referring))\n \t  return true;\n-\tnode = ipa_ref_referring_varpool_node (ref);\n+\tnode = dyn_cast <varpool_node *> (ref->referring);\n \tif (!DECL_VIRTUAL_P (node->decl))\n \t  return true;\n       }\n@@ -682,8 +682,7 @@ function_and_variable_visibility (bool whole_program)\n \t  bool found = false;\n \n \t  /* See if there is something to update.  */\n-\t  for (i = 0; ipa_ref_list_referring_iterate (&vnode->ref_list,\n-\t\t\t\t\t\t      i, ref); i++)\n+\t  for (i = 0; vnode->iterate_referring (i, ref); i++)\n \t    if (ref->use == IPA_REF_ADDR\n \t\t&& can_replace_by_local_alias_in_vtable (ref->referred))\n \t      {\n@@ -696,7 +695,7 @@ function_and_variable_visibility (bool whole_program)\n \t      walk_tree (&DECL_INITIAL (vnode->decl),\n \t\t\t update_vtable_references, NULL, visited_nodes);\n \t      pointer_set_destroy (visited_nodes);\n-\t      ipa_remove_all_references (&vnode->ref_list);\n+\t      vnode->remove_all_references ();\n \t      record_references_in_initializer (vnode->decl, false);\n \t    }\n \t}"}, {"sha": "fce2e36174f73230b7882f1ddaeb3ab25caf33ee", "filename": "gcc/ipa.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -51,10 +51,9 @@ has_addr_references_p (struct cgraph_node *node,\n \t\t       void *data ATTRIBUTE_UNUSED)\n {\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n-\t\t\t\t\t      i, ref); i++)\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ADDR)\n       return true;\n   return false;\n@@ -101,14 +100,14 @@ enqueue_node (symtab_node *node, symtab_node **first,\n /* Process references.  */\n \n static void\n-process_references (struct ipa_ref_list *list,\n+process_references (symtab_node *snode,\n \t\t    symtab_node **first,\n \t\t    bool before_inlining_p,\n \t\t    struct pointer_set_t *reachable)\n {\n   int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n+  struct ipa_ref *ref = NULL;\n+  for (i = 0; snode->iterate_reference (i, ref); i++)\n     {\n       symtab_node *node = ref->referred;\n \n@@ -358,8 +357,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t  enqueue_node (next, &first, reachable);\n \t    }\n \t  /* Mark references as reachable.  */\n-\t  process_references (&node->ref_list, &first,\n-\t\t\t      before_inlining_p, reachable);\n+\t  process_references (node, &first, before_inlining_p, reachable);\n \t}\n \n       if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n@@ -446,8 +444,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  && !vnode->alias\n \t  && in_boundary_p)\n \t{\n-\t  struct ipa_ref *ref;\n-\t  for (int i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+\t  struct ipa_ref *ref = NULL;\n+\t  for (int i = 0; node->iterate_reference (i, ref); i++)\n \t    enqueue_node (ref->referred, &first, reachable);\n \t}\n     }\n@@ -493,7 +491,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\tnode->local.local = false;\n \t      cgraph_node_remove_callees (node);\n \t      symtab_remove_from_same_comdat_group (node);\n-\t      ipa_remove_all_references (&node->ref_list);\n+\t      node->remove_all_references ();\n \t      changed = true;\n \t    }\n \t}\n@@ -555,7 +553,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t    varpool_remove_initializer (vnode);\n \t  else\n \t    DECL_INITIAL (vnode->decl) = init;\n-\t  ipa_remove_all_references (&vnode->ref_list);\n+\t  vnode->remove_all_references ();\n \t}\n       else\n \tvnode->aux = NULL;\n@@ -618,8 +616,7 @@ process_references (varpool_node *vnode,\n       || TREE_THIS_VOLATILE (vnode->decl))\n     *explicit_refs = false;\n \n-  for (i = 0; ipa_ref_list_referring_iterate (&vnode->ref_list,\n-\t\t\t\t\t     i, ref)\n+  for (i = 0; vnode->iterate_referring (i, ref)\n \t      && *explicit_refs && (!*written || !*address_taken || !*read); i++)\n     switch (ref->use)\n       {\n@@ -658,7 +655,7 @@ set_writeonly_bit (varpool_node *vnode, void *data ATTRIBUTE_UNUSED)\n     {\n       DECL_INITIAL (vnode->decl) = NULL;\n       if (!vnode->alias)\n-\tipa_remove_all_references (&vnode->ref_list);\n+\tvnode->remove_all_references ();\n     }\n   return false;\n }\n@@ -1153,7 +1150,7 @@ propagate_single_user (varpool_node *vnode, cgraph_node *function,\n \n   /* Check all users and see if they correspond to a single function.  */\n   for (i = 0;\n-       ipa_ref_list_referring_iterate (&vnode->ref_list, i, ref)\n+       vnode->iterate_referring (i, ref)\n        && function != BOTTOM; i++)\n     {\n       struct cgraph_node *cnode = dyn_cast <cgraph_node *> (ref->referring);\n@@ -1221,7 +1218,7 @@ ipa_single_use (void)\n \n \t  /* Enqueue all aliases for re-processing.  */\n \t  for (i = 0;\n-\t       ipa_ref_list_referring_iterate (&var->ref_list, i, ref); i++)\n+\t       var->iterate_referring (i, ref); i++)\n \t    if (ref->use == IPA_REF_ALIAS\n \t\t&& !ref->referring->aux)\n \t      {\n@@ -1230,7 +1227,7 @@ ipa_single_use (void)\n \t      }\n \t  /* Enqueue all users for re-processing.  */\n \t  for (i = 0;\n-\t       ipa_ref_list_reference_iterate (&var->ref_list, i, ref); i++)\n+\t       var->iterate_reference (i, ref); i++)\n \t    if (!ref->referred->aux\n \t        && ref->referred->definition\n \t\t&& is_a <varpool_node *> (ref->referred))"}, {"sha": "af480bcaea2cd790dd290a15c7144548833d7844", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -315,14 +315,15 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n     }\n }\n \n-/* Return if LIST contain references from other partitions.  */\n+/* Return if NODE contain references from other partitions.  */\n \n bool\n-referenced_from_other_partition_p (struct ipa_ref_list *list, lto_symtab_encoder_t encoder)\n+referenced_from_other_partition_p (symtab_node *node, lto_symtab_encoder_t encoder)\n {\n   int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n+  struct ipa_ref *ref = NULL;\n+\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     {\n       if (ref->referring->in_other_partition\n           || !lto_symtab_encoder_in_partition_p (encoder, ref->referring))\n@@ -348,15 +349,16 @@ reachable_from_other_partition_p (struct cgraph_node *node, lto_symtab_encoder_t\n   return false;\n }\n \n-/* Return if LIST contain references from other partitions.  */\n+/* Return if NODE contain references from other partitions.  */\n \n bool\n-referenced_from_this_partition_p (struct ipa_ref_list *list,\n+referenced_from_this_partition_p (symtab_node *node,\n \t\t\t\t  lto_symtab_encoder_t encoder)\n {\n   int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_referring_iterate (list, i, ref); i++)\n+  struct ipa_ref *ref = NULL;\n+\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (lto_symtab_encoder_in_partition_p (encoder, ref->referring))\n       return true;\n   return false;\n@@ -523,8 +525,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, tag == LTO_symtab_analyzed_node\n \t\t && symtab_get_symbol_partitioning_class (node) == SYMBOL_PARTITION\n \t\t && (reachable_from_other_partition_p (node, encoder)\n-\t\t     || referenced_from_other_partition_p (&node->ref_list,\n-\t\t\t\t\t\t\t   encoder)), 1);\n+\t\t     || referenced_from_other_partition_p (node, encoder)), 1);\n   bp_pack_value (&bp, node->lowered, 1);\n   bp_pack_value (&bp, in_other_partition, 1);\n   /* Real aliases in a boundary become non-aliases. However we still stream\n@@ -607,8 +608,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   else\n     {\n       bp_pack_value (&bp, node->definition\n-\t\t     && referenced_from_other_partition_p (&node->ref_list,\n-\t\t\t\t\t\t\t   encoder), 1);\n+\t\t     && referenced_from_other_partition_p (node, encoder), 1);\n       bp_pack_value (&bp, node->analyzed\n \t\t     && boundary_p && !DECL_EXTERNAL (node->decl), 1);\n \t  /* in_other_partition.  */\n@@ -760,14 +760,13 @@ output_refs (lto_symtab_encoder_t encoder)\n     {\n       symtab_node *node = lsei_node (lsei);\n \n-      count = ipa_ref_list_nreferences (&node->ref_list);\n+      count = node->ref_list.nreferences ();\n       if (count)\n \t{\n \t  streamer_write_gcov_count_stream (ob->main_stream, count);\n \t  streamer_write_uhwi_stream (ob->main_stream,\n \t\t\t\t     lto_symtab_encoder_lookup (encoder, node));\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list,\n-\t\t\t\t\t\t      i, ref); i++)\n+\t  for (i = 0; node->iterate_reference (i, ref); i++)\n \t    lto_output_ref (ob, ref, encoder);\n \t}\n     }\n@@ -791,17 +790,16 @@ add_node_to (lto_symtab_encoder_t encoder, struct cgraph_node *node,\n   lto_symtab_encoder_encode (encoder, node);\n }\n \n-/* Add all references in LIST to encoders.  */\n+/* Add all references in NODE to encoders.  */\n \n static void\n-add_references (lto_symtab_encoder_t encoder,\n-\t\tstruct ipa_ref_list *list)\n+add_references (lto_symtab_encoder_t encoder, symtab_node *node)\n {\n   int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n+  struct ipa_ref *ref = NULL;\n+  for (i = 0; node->iterate_reference (i, ref); i++)\n     if (is_a <cgraph_node *> (ref->referred))\n-      add_node_to (encoder, ipa_ref_node (ref), false);\n+      add_node_to (encoder, dyn_cast <cgraph_node *> (ref->referred), false);\n     else\n       lto_symtab_encoder_encode (encoder, ref->referred);\n }\n@@ -834,7 +832,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n       struct cgraph_node *node = lsei_cgraph_node (lsei);\n       add_node_to (encoder, node, true);\n       lto_set_symtab_encoder_in_partition (encoder, node);\n-      add_references (encoder, &node->ref_list);\n+      add_references (encoder, node);\n       /* For proper debug info, we need to ship the origins, too.  */\n       if (DECL_ABSTRACT_ORIGIN (node->decl))\n \t{\n@@ -850,7 +848,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \n       lto_set_symtab_encoder_in_partition (encoder, vnode);\n       lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n-      add_references (encoder, &vnode->ref_list);\n+      add_references (encoder, vnode);\n       /* For proper debug info, we need to ship the origins, too.  */\n       if (DECL_ABSTRACT_ORIGIN (vnode->decl))\n \t{\n@@ -872,7 +870,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n \t      && ctor_for_folding (vnode->decl) != error_mark_node)\n \t    {\n \t      lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n-\t      add_references (encoder, &vnode->ref_list);\n+\t      add_references (encoder, vnode);\n \t    }\n        }\n     }\n@@ -1317,7 +1315,7 @@ input_ref (struct lto_input_block *ib,\n   use = (enum ipa_ref_use) bp_unpack_value (&bp, 2);\n   speculative = (enum ipa_ref_use) bp_unpack_value (&bp, 1);\n   node = nodes[streamer_read_hwi (ib)];\n-  ref = ipa_record_reference (referring_node, node, use, NULL);\n+  ref = referring_node->add_reference (node, use);\n   ref->speculative = speculative;\n   if (is_a <cgraph_node *> (referring_node))\n     ref->lto_stmt_uid = streamer_read_hwi (ib);"}, {"sha": "5d7989353fe225d7b09fa078775d781dacd10ccc", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -785,7 +785,7 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts,\n \t\t\t struct function *fn)\n {\n   struct cgraph_edge *cedge;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n   unsigned int i;\n \n   for (cedge = node->callees; cedge; cedge = cedge->next_callee)\n@@ -804,9 +804,7 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts,\n       if (!cedge->call_stmt)\n         fatal_error (\"Cgraph edge statement index not found\");\n     }\n-  for (i = 0;\n-       ipa_ref_list_reference_iterate (&node->ref_list, i, ref);\n-       i++)\n+  for (i = 0; node->iterate_reference (i, ref); i++)\n     if (ref->lto_stmt_uid)\n       {\n \tif (gimple_stmt_max_uid (fn) < ref->lto_stmt_uid)"}, {"sha": "30645627d02036c274f6328d50dfc9b16b4037d8", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -2362,8 +2362,7 @@ output_symbol_p (symtab_node *node)\n     {\n       int i;\n       struct ipa_ref *ref;\n-      for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list,\n-\t\t\t\t\t          i, ref); i++)\n+      for (i = 0; node->iterate_referring (i, ref); i++)\n \t{\n \t  if (ref->use == IPA_REF_ALIAS)\n \t    continue;"}, {"sha": "cfa965c4d1e97ef9d0e6e450898f174253794d97", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -888,7 +888,7 @@ bool referenced_from_other_partition_p (struct ipa_ref_list *,\n \t\t\t\t        lto_symtab_encoder_t);\n bool reachable_from_other_partition_p (struct cgraph_node *,\n \t\t\t\t       lto_symtab_encoder_t);\n-bool referenced_from_this_partition_p (struct ipa_ref_list *,\n+bool referenced_from_this_partition_p (struct symtab_node *,\n \t\t\t\t\tlto_symtab_encoder_t);\n bool reachable_from_this_partition_p (struct cgraph_node *,\n \t\t\t\t      lto_symtab_encoder_t);"}, {"sha": "4d19ef6de61470d2c2a1f1d64d54b8c6031694d4", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -86,10 +86,10 @@ static void\n add_references_to_partition (ltrans_partition part, symtab_node *node)\n {\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n   /* Add all duplicated references to the partition.  */\n-  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; node->iterate_reference (i, ref); i++)\n     if (symtab_get_symbol_partitioning_class (ref->referred) == SYMBOL_DUPLICATE)\n       add_symbol_to_partition (part, ref->referred);\n     /* References to a readonly variable may be constant foled into its value.\n@@ -114,7 +114,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n {\n   enum symbol_partitioning_class c = symtab_get_symbol_partitioning_class (node);\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n   symtab_node *node1;\n \n   /* If NODE is already there, we have nothing to do.  */\n@@ -168,7 +168,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n   add_references_to_partition (part, node);\n \n   /* Add all aliases associated with the symbol.  */\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS && !node->weakref)\n       add_symbol_to_partition_1 (part, ref->referring);\n \n@@ -516,17 +516,17 @@ lto_balanced_map (int n_lto_partitions)\n \t it and thus we need to subtract it from COST.  */\n       while (last_visited_node < lto_symtab_encoder_size (partition->encoder))\n \t{\n-\t  struct ipa_ref_list *refs;\n+\t  symtab_node *refs_node;\n \t  int j;\n-\t  struct ipa_ref *ref;\n+\t  struct ipa_ref *ref = NULL;\n \t  symtab_node *snode = lto_symtab_encoder_deref (partition->encoder,\n \t\t\t\t\t\t\tlast_visited_node);\n \n \t  if (cgraph_node *node = dyn_cast <cgraph_node *> (snode))\n \t    {\n \t      struct cgraph_edge *edge;\n \n-\t      refs = &node->ref_list;\n+\t      refs_node = node;\n \n \t      last_visited_node++;\n \n@@ -570,18 +570,18 @@ lto_balanced_map (int n_lto_partitions)\n \t    }\n \t  else\n \t    {\n-\t      refs = &snode->ref_list;\n+\t      refs_node = snode;\n \t      last_visited_node++;\n \t    }\n \n \t  /* Compute boundary cost of IPA REF edges and at the same time look into\n \t     variables referenced from current partition and try to add them.  */\n-\t  for (j = 0; ipa_ref_list_reference_iterate (refs, j, ref); j++)\n+\t  for (j = 0; refs_node->iterate_reference (j, ref); j++)\n \t    if (is_a <varpool_node *> (ref->referred))\n \t      {\n \t\tint index;\n \n-\t\tvnode = ipa_ref_varpool_node (ref);\n+\t\tvnode = dyn_cast <varpool_node *> (ref->referred);\n \t\tif (!vnode->definition)\n \t\t  continue;\n \t\tif (!symbol_partitioned_p (vnode) && flag_toplevel_reorder\n@@ -599,7 +599,7 @@ lto_balanced_map (int n_lto_partitions)\n \t      {\n \t\tint index;\n \n-\t\tnode = ipa_ref_node (ref);\n+\t\tnode = dyn_cast <cgraph_node *> (ref->referred);\n \t\tif (!node->definition)\n \t\t  continue;\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n@@ -610,12 +610,12 @@ lto_balanced_map (int n_lto_partitions)\n \t\telse\n \t\t  cost++;\n \t      }\n-\t  for (j = 0; ipa_ref_list_referring_iterate (refs, j, ref); j++)\n+\t  for (j = 0; refs_node->iterate_referring (j, ref); j++)\n \t    if (is_a <varpool_node *> (ref->referring))\n \t      {\n \t\tint index;\n \n-\t\tvnode = ipa_ref_referring_varpool_node (ref);\n+\t\tvnode = dyn_cast <varpool_node *> (ref->referring);\n \t\tgcc_assert (vnode->definition);\n \t\t/* It is better to couple variables with their users, because it allows them\n \t\t   to be removed.  Coupling with objects they refer to only helps to reduce\n@@ -636,7 +636,7 @@ lto_balanced_map (int n_lto_partitions)\n \t      {\n \t\tint index;\n \n-\t\tnode = ipa_ref_referring_node (ref);\n+\t\tnode = dyn_cast <cgraph_node *> (ref->referring);\n \t\tgcc_assert (node->definition);\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   node);"}, {"sha": "82ee827f63c3a4f43d8f53bc894a5abe5f3c0fb9", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -84,7 +84,7 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \te->call_stmt_cannot_inline_p = 1;\n     }\n   /* Redirect incomming references.  */\n-  ipa_clone_referring (prevailing_node, &node->ref_list);\n+  prevailing_node->clone_referring (node);\n \n   ipa_merge_profiles (prevailing_node, node);\n   lto_free_function_in_decl_state_for_node (node);\n@@ -106,7 +106,7 @@ lto_varpool_replace_node (varpool_node *vnode,\n   gcc_assert (!vnode->definition || prevailing_node->definition);\n   gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n \n-  ipa_clone_referring (prevailing_node, &vnode->ref_list);\n+  prevailing_node->clone_referring (vnode);\n   if (vnode->force_output)\n     prevailing_node->force_output = true;\n   if (vnode->forced_by_abi)"}, {"sha": "89591ee3ac71367bcb1fb5eaf87141d93481685c", "filename": "gcc/symtab.c", "status": "modified", "additions": 283, "deletions": 10, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -42,6 +42,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"lto-streamer.h\"\n #include \"output.h\"\n+#include \"ipa-utils.h\"\n+\n+static const char *ipa_ref_use_name[] = {\"read\",\"write\",\"addr\",\"alias\"};\n \n const char * const ld_plugin_symbol_resolution_names[]=\n {\n@@ -284,7 +287,7 @@ symtab_register_node (symtab_node *node)\n   if (!node->decl->decl_with_vis.symtab_node)\n     node->decl->decl_with_vis.symtab_node = node;\n \n-  ipa_empty_ref_list (&node->ref_list);\n+  node->ref_list.clear ();\n \n   node->order = symtab_order++;\n \n@@ -319,8 +322,8 @@ symtab_remove_from_same_comdat_group (symtab_node *node)\n void\n symtab_unregister_node (symtab_node *node)\n {\n-  ipa_remove_all_references (&node->ref_list);\n-  ipa_remove_all_referring (&node->ref_list);\n+  node->remove_all_references ();\n+  node->remove_all_referring ();\n \n   /* Remove reference to section.  */\n   node->set_section_for_node (NULL);\n@@ -522,6 +525,277 @@ symtab_node::name () const\n   return lang_hooks.decl_printable_name (decl, 2);\n }\n \n+/* Return ipa reference from this symtab_node to\n+   REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+   of the use.  */\n+\n+struct ipa_ref *\n+symtab_node::add_reference (symtab_node *referred_node,\n+\t\t\t    enum ipa_ref_use use_type)\n+{\n+  return add_reference (referred_node, use_type, NULL);\n+}\n+\n+\n+/* Return ipa reference from this symtab_node to\n+   REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+   of the use and STMT the statement (if it exists).  */\n+\n+struct ipa_ref *\n+symtab_node::add_reference (symtab_node *referred_node,\n+\t\t\t    enum ipa_ref_use use_type, gimple stmt)\n+{\n+  struct ipa_ref *ref = NULL, *ref2 = NULL;\n+  struct ipa_ref_list *list, *list2;\n+  ipa_ref_t *old_references;\n+\n+  gcc_checking_assert (!stmt || is_a <cgraph_node *> (this));\n+  gcc_checking_assert (use_type != IPA_REF_ALIAS || !stmt);\n+\n+  list = &ref_list;\n+  old_references = vec_safe_address (list->references);\n+  vec_safe_grow (list->references, vec_safe_length (list->references) + 1);\n+  ref = &list->references->last ();\n+\n+  list2 = &referred_node->ref_list;\n+  list2->referring.safe_push (ref);\n+  ref->referred_index = list2->referring.length () - 1;\n+  ref->referring = this;\n+  ref->referred = referred_node;\n+  ref->stmt = stmt;\n+  ref->lto_stmt_uid = 0;\n+  ref->use = use_type;\n+  ref->speculative = 0;\n+\n+  /* If vector was moved in memory, update pointers.  */\n+  if (old_references != list->references->address ())\n+    {\n+      int i;\n+      for (i = 0; iterate_reference(i, ref2); i++)\n+\tref2->referred_ref_list ()->referring[ref2->referred_index] = ref2;\n+    }\n+  return ref;\n+}\n+\n+/* If VAL is a reference to a function or a variable, add a reference from\n+   this symtab_node to the corresponding symbol table node.  USE_TYPE specify\n+   type of the use and STMT the statement (if it exists).  Return the new\n+   reference or NULL if none was created.  */\n+\n+struct ipa_ref *\n+symtab_node::maybe_add_reference (tree val, enum ipa_ref_use use_type,\n+\t\t\t\t  gimple stmt)\n+{\n+  STRIP_NOPS (val);\n+  if (TREE_CODE (val) != ADDR_EXPR)\n+    return NULL;\n+  val = get_base_var (val);\n+  if (val && (TREE_CODE (val) == FUNCTION_DECL\n+\t       || TREE_CODE (val) == VAR_DECL))\n+    {\n+      symtab_node *referred = symtab_get_node (val);\n+      gcc_checking_assert (referred);\n+      return add_reference (referred, use_type, stmt);\n+    }\n+  return NULL;\n+}\n+\n+/* Clone all references from symtab NODE to this symtab_node.  */\n+\n+void\n+symtab_node::clone_references (struct symtab_node *node)\n+{\n+  struct ipa_ref *ref = NULL, *ref2 = NULL;\n+  int i;\n+  for (i = 0; node->iterate_reference (i, ref); i++)\n+    {\n+      bool speculative = ref->speculative;\n+      unsigned int stmt_uid = ref->lto_stmt_uid;\n+\n+      ref2 = add_reference (ref->referred, ref->use, ref->stmt);\n+      ref2->speculative = speculative;\n+      ref2->lto_stmt_uid = stmt_uid;\n+    }\n+}\n+\n+/* Clone all referring from symtab NODE to this symtab_node.  */\n+\n+void\n+symtab_node::clone_referring (struct symtab_node *node)\n+{\n+  struct ipa_ref *ref = NULL, *ref2 = NULL;\n+  int i;\n+  for (i = 0; node->iterate_referring(i, ref); i++)\n+    {\n+      bool speculative = ref->speculative;\n+      unsigned int stmt_uid = ref->lto_stmt_uid;\n+\n+      ref2 = ref->referring->add_reference (this, ref->use, ref->stmt);\n+      ref2->speculative = speculative;\n+      ref2->lto_stmt_uid = stmt_uid;\n+    }\n+}\n+\n+/* Clone reference REF to this symtab_node and set its stmt to STMT.  */\n+\n+struct ipa_ref *\n+symtab_node::clone_reference (struct ipa_ref *ref, gimple stmt)\n+{\n+  bool speculative = ref->speculative;\n+  unsigned int stmt_uid = ref->lto_stmt_uid;\n+  struct ipa_ref *ref2;\n+\n+  ref2 = add_reference (ref->referred, ref->use, stmt);\n+  ref2->speculative = speculative;\n+  ref2->lto_stmt_uid = stmt_uid;\n+  return ref2;\n+}\n+\n+/* Find the structure describing a reference to REFERRED_NODE\n+   and associated with statement STMT.  */\n+\n+struct ipa_ref *\n+symtab_node::find_reference (symtab_node *referred_node,\n+\t\t\t     gimple stmt, unsigned int lto_stmt_uid)\n+{\n+  struct ipa_ref *r = NULL;\n+  int i;\n+\n+  for (i = 0; iterate_reference (i, r); i++)\n+    if (r->referred == referred_node\n+\t&& !r->speculative\n+\t&& ((stmt && r->stmt == stmt)\n+\t    || (lto_stmt_uid && r->lto_stmt_uid == lto_stmt_uid)\n+\t    || (!stmt && !lto_stmt_uid && !r->stmt && !r->lto_stmt_uid)))\n+      return r;\n+  return NULL;\n+}\n+\n+/* Remove all references that are associated with statement STMT.  */\n+\n+void\n+symtab_node::remove_stmt_references (gimple stmt)\n+{\n+  struct ipa_ref *r = NULL;\n+  int i = 0;\n+\n+  while (iterate_reference (i, r))\n+    if (r->stmt == stmt)\n+      r->remove_reference ();\n+    else\n+      i++;\n+}\n+\n+/* Remove all stmt references in non-speculative references.\n+   Those are not maintained during inlining & clonning.\n+   The exception are speculative references that are updated along\n+   with callgraph edges associated with them.  */\n+\n+void\n+symtab_node::clear_stmts_in_references (void)\n+{\n+  struct ipa_ref *r = NULL;\n+  int i;\n+\n+  for (i = 0; iterate_reference (i, r); i++)\n+    if (!r->speculative)\n+      {\n+\tr->stmt = NULL;\n+\tr->lto_stmt_uid = 0;\n+      }\n+}\n+\n+/* Remove all references in ref list.  */\n+\n+void\n+symtab_node::remove_all_references (void)\n+{\n+  while (vec_safe_length (ref_list.references))\n+    ref_list.references->last ().remove_reference ();\n+  vec_free (ref_list.references);\n+}\n+\n+/* Remove all referring items in ref list.  */\n+\n+void\n+symtab_node::remove_all_referring (void)\n+{\n+  while (ref_list.referring.length ())\n+    ref_list.referring.last ()->remove_reference ();\n+  ref_list.referring.release ();\n+}\n+\n+/* Dump references in ref list to FILE.  */\n+\n+void\n+symtab_node::dump_references (FILE *file)\n+{\n+  struct ipa_ref *ref = NULL;\n+  int i;\n+  for (i = 0; iterate_reference (i, ref); i++)\n+    {\n+      fprintf (file, \"%s/%i (%s)\",\n+               ref->referred->asm_name (),\n+               ref->referred->order,\n+\t       ipa_ref_use_name [ref->use]);\n+      if (ref->speculative)\n+\tfprintf (file, \" (speculative)\");\n+    }\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Dump referring in list to FILE.  */\n+\n+void\n+symtab_node::dump_referring (FILE *file)\n+{\n+  struct ipa_ref *ref = NULL;\n+  int i;\n+  for (i = 0; iterate_referring(i, ref); i++)\n+    {\n+      fprintf (file, \"%s/%i (%s)\",\n+               ref->referring->asm_name (),\n+               ref->referring->order,\n+\t       ipa_ref_use_name [ref->use]);\n+      if (ref->speculative)\n+\tfprintf (file, \" (speculative)\");\n+    }\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Return true if list contains an alias.  */\n+bool\n+symtab_node::has_aliases_p (void)\n+{\n+  struct ipa_ref *ref = NULL;\n+  int i;\n+\n+  for (i = 0; iterate_referring (i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      return true;\n+  return false;\n+}\n+\n+/* Iterates I-th reference in the list, REF is also set.  */\n+\n+struct ipa_ref *\n+symtab_node::iterate_reference (unsigned i, struct ipa_ref *&ref)\n+{\n+  vec_safe_iterate (ref_list.references, i, &ref);\n+\n+  return ref;\n+}\n+\n+/* Iterates I-th referring item in the list, REF is also set.  */\n+\n+struct ipa_ref *\n+symtab_node::iterate_referring (unsigned i, struct ipa_ref *&ref)\n+{\n+  ref_list.referring.iterate (i, &ref);\n+\n+  return ref;\n+}\n+\n static const char * const symtab_type_names[] = {\"symbol\", \"function\", \"variable\"};\n \n /* Dump base fields of symtab nodes.  Not to be used directly.  */\n@@ -634,9 +908,9 @@ dump_symtab_base (FILE *f, symtab_node *node)\n     }\n \n   fprintf (f, \"  References: \");\n-  ipa_dump_references (f, &node->ref_list);\n+  node->dump_references (f);\n   fprintf (f, \"  Referring: \");\n-  ipa_dump_referring (f, &node->ref_list);\n+  node->dump_referring (f);\n   if (node->lto_file_data)\n     fprintf (f, \"  Read from file: %s\\n\",\n \t     node->lto_file_data->file_name);\n@@ -819,10 +1093,9 @@ verify_symtab_base (symtab_node *node)\n       while (n != node);\n       if (symtab_comdat_local_p (node))\n \t{\n-\t  struct ipa_ref_list *refs = &node->ref_list;\n-\t  struct ipa_ref *ref;\n+\t  struct ipa_ref *ref = NULL;\n \n-\t  for (int i = 0; ipa_ref_list_referring_iterate (refs, i, ref); ++i)\n+\t  for (int i = 0; node->iterate_referring (i, ref); ++i)\n \t    {\n \t      if (!symtab_in_same_comdat_p (ref->referring, node))\n \t\t{\n@@ -1355,7 +1628,7 @@ symtab_resolve_alias (symtab_node *node, symtab_node *target)\n   node->definition = true;\n   node->alias = true;\n   node->analyzed = true;\n-  ipa_record_reference (node, target, IPA_REF_ALIAS, NULL);\n+  node->add_reference (target, IPA_REF_ALIAS, NULL);\n \n   /* Add alias into the comdat group of its target unless it is already there.  */\n   if (node->same_comdat_group)\n@@ -1406,7 +1679,7 @@ symtab_for_node_and_aliases (symtab_node *node,\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tsymtab_node *alias = ref->referring;"}, {"sha": "af8bc09e187f9050210a979560315f93101150ba", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -4860,7 +4860,7 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n   record_tm_clone_pair (old_decl, new_decl);\n \n   if (info->old_node->force_output\n-      || ipa_ref_list_first_referring (&info->old_node->ref_list))\n+      || info->old_node->ref_list.first_referring ())\n     ipa_tm_mark_force_output_node (new_node);\n   if (info->old_node->forced_by_abi)\n     ipa_tm_mark_forced_by_abi_node (new_node);\n@@ -4919,7 +4919,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n \n   cgraph_call_function_insertion_hooks (new_node);\n   if (old_node->force_output\n-      || ipa_ref_list_first_referring (&old_node->ref_list))\n+      || old_node->ref_list.first_referring ())\n     ipa_tm_mark_force_output_node (new_node);\n   if (old_node->forced_by_abi)\n     ipa_tm_mark_forced_by_abi_node (new_node);\n@@ -5439,7 +5439,7 @@ ipa_tm_execute (void)\n     {\n       struct cgraph_node *caller;\n       struct cgraph_edge *e;\n-      struct ipa_ref *ref;\n+      struct ipa_ref *ref = NULL;\n       unsigned j;\n \n       if (i > 256 && i == irr_worklist.length () / 8)\n@@ -5466,7 +5466,7 @@ ipa_tm_execute (void)\n \t}\n \n       /* Propagate back to referring aliases as well.  */\n-      for (j = 0; ipa_ref_list_referring_iterate (&node->ref_list, j, ref); j++)\n+      for (j = 0; node->iterate_referring (j, ref); j++)\n \t{\n \t  caller = cgraph (ref->referring);\n \t  if (ref->use == IPA_REF_ALIAS"}, {"sha": "3a486305c1b7808f19058b4bd0913306494ac7f0", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -453,7 +453,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n \n       /* We may be adding a new reference to a new variable to the function.\n          This means we have to play with the ipa-reference web.  */\n-      ipa_record_reference (d->cfun_node, cvar, IPA_REF_ADDR, x);\n+      d->cfun_node->add_reference (cvar, IPA_REF_ADDR, x);\n \n       /* Record this ssa_name for possible use later in the basic block.  */\n       access_vars[index] = addr;"}, {"sha": "f07c1a85d743918af3aef2a11032e6069cb16a6d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -1791,7 +1791,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t\t\t\t\t\t       (old_edge->frequency + indirect->frequency)),\n \t\t\t\t\t\t\t CGRAPH_FREQ_MAX);\n \t\t\t    }\n-\t\t\t  ipa_clone_ref (ref, id->dst_node, stmt);\n+\t\t\t  id->dst_node->clone_reference (ref, stmt);\n \t\t\t}\n \t\t      else\n \t\t\t{\n@@ -5169,7 +5169,7 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n \t      struct cgraph_edge *e;\n \t      struct cgraph_node *node;\n \n-\t      ipa_remove_stmt_references (id->dst_node, gsi_stmt (bsi));\n+\t      id->dst_node->remove_stmt_references (gsi_stmt (bsi));\n \n \t      if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n \t\t  &&(e = cgraph_edge (id->dst_node, gsi_stmt (bsi))) != NULL)\n@@ -5183,7 +5183,7 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n \t\t  && id->dst_node->clones)\n \t\tfor (node = id->dst_node->clones; node != id->dst_node;)\n \t\t  {\n-\t\t    ipa_remove_stmt_references (node, gsi_stmt (bsi));\n+\t\t    node->remove_stmt_references (gsi_stmt (bsi));\n \t\t    if (gimple_code (gsi_stmt (bsi)) == GIMPLE_CALL\n \t\t\t&& (e = cgraph_edge (node, gsi_stmt (bsi))) != NULL)\n \t\t      {"}, {"sha": "04ac87041880e9ebcb7db0f97df826cde35093f2", "filename": "gcc/varpool.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d122681a3c4491cec5152d5c528005c1f5083e83/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=d122681a3c4491cec5152d5c528005c1f5083e83", "patch": "@@ -425,11 +425,12 @@ static void\n assemble_aliases (varpool_node *node)\n {\n   int i;\n-  struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n+  struct ipa_ref *ref = NULL;\n+\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tvarpool_node *alias = ipa_ref_referring_varpool_node (ref);\n+\tvarpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n \tdo_assemble_alias (alias->decl,\n \t\t\t   DECL_ASSEMBLER_NAME (node->decl));\n \tassemble_aliases (alias);\n@@ -506,7 +507,7 @@ varpool_remove_unreferenced_decls (void)\n   varpool_node *next, *node;\n   varpool_node *first = (varpool_node *)(void *)1;\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n   struct pointer_set_t *referenced = pointer_set_create ();\n \n   if (seen_error ())\n@@ -544,7 +545,7 @@ varpool_remove_unreferenced_decls (void)\n \t\tenqueue_node (vnext, &first);\n \t    }\n \t}\n-      for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+      for (i = 0; node->iterate_reference (i, ref); i++)\n \t{\n \t  varpool_node *vnode = dyn_cast <varpool_node *> (ref->referred);\n \t  if (vnode\n@@ -694,14 +695,14 @@ varpool_for_node_and_aliases (varpool_node *node,\n \t\t\t      bool include_overwritable)\n {\n   int i;\n-  struct ipa_ref *ref;\n+  struct ipa_ref *ref = NULL;\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; ipa_ref_list_referring_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; node->iterate_referring (i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n-\tvarpool_node *alias = ipa_ref_referring_varpool_node (ref);\n+\tvarpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n \tif (include_overwritable\n \t    || cgraph_variable_initializer_availability (alias) > AVAIL_OVERWRITABLE)\n           if (varpool_for_node_and_aliases (alias, callback, data,"}]}