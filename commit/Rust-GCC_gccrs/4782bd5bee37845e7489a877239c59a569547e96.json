{"sha": "4782bd5bee37845e7489a877239c59a569547e96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4MmJkNWJlZTM3ODQ1ZTc0ODlhODc3MjM5YzU5YTU2OTU0N2U5Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-04-12T10:55:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-04-12T10:55:27Z"}, "message": "decl.c (duplicate_decls): Don't try to unify an implicit typedef with an explicit one.\n\n\t* decl.c (duplicate_decls): Don't try to unify an implicit typedef\n\twith an explicit one.\n\t(follow_tag_typedef): New.\n\t(lookup_tag): Use it to extract the tag of an explicit typedef.\n\t(xref_tag): Likewise.\n\nFrom-SVN: r52213", "tree": {"sha": "24ec3198f536171df0b213bd1e9130ff7f7d04de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24ec3198f536171df0b213bd1e9130ff7f7d04de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4782bd5bee37845e7489a877239c59a569547e96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4782bd5bee37845e7489a877239c59a569547e96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4782bd5bee37845e7489a877239c59a569547e96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4782bd5bee37845e7489a877239c59a569547e96/comments", "author": null, "committer": null, "parents": [{"sha": "e6f648758eb7636fbfce0981eac9dfba44b50a1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6f648758eb7636fbfce0981eac9dfba44b50a1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6f648758eb7636fbfce0981eac9dfba44b50a1c"}], "stats": {"total": 103, "additions": 84, "deletions": 19}, "files": [{"sha": "a9b70e9b1d3623f7f287894de39b213d9d236d7b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4782bd5bee37845e7489a877239c59a569547e96/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4782bd5bee37845e7489a877239c59a569547e96/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4782bd5bee37845e7489a877239c59a569547e96", "patch": "@@ -1,3 +1,11 @@\n+2002-04-12  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* decl.c (duplicate_decls): Don't try to unify an implicit typedef\n+\twith an explicit one.\n+\t(follow_tag_typedef): New.\n+\t(lookup_tag): Use it to extract the tag of an explicit typedef.\n+\t(xref_tag): Likewise.\n+\n 2002-04-11  Andrew Haley  <aph@redhat.com>\n \n \t* typeck.c (type_after_usual_arithmetic_conversions):"}, {"sha": "93e63058b961756b437abfffa1250877a0712ae7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4782bd5bee37845e7489a877239c59a569547e96/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4782bd5bee37845e7489a877239c59a569547e96/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4782bd5bee37845e7489a877239c59a569547e96", "patch": "@@ -82,6 +82,7 @@ static tree grokfndecl PARAMS ((tree, tree, tree, tree, int,\n \t\t\t      enum overload_flags, tree,\n \t\t\t      tree, int, int, int, int, int, int, tree));\n static tree grokvardecl PARAMS ((tree, tree, RID_BIT_TYPE *, int, int, tree));\n+static tree follow_tag_typedef PARAMS ((tree));\n static tree lookup_tag PARAMS ((enum tree_code, tree,\n \t\t\t      struct binding_level *, int));\n static void set_identifier_type_value_with_scope\n@@ -3426,6 +3427,18 @@ duplicate_decls (newdecl, olddecl)\n \t}\n     }\n \n+  /* Do not merge an implicit typedef with an explicit one.  In:\n+\n+       class A;\n+       ...\n+       typedef class A A __attribute__ ((foo));\n+\n+     the attribute should apply only to the typedef.  */\n+  if (TREE_CODE (olddecl) == TYPE_DECL\n+      && (DECL_IMPLICIT_TYPEDEF_P (olddecl)\n+\t  || DECL_IMPLICIT_TYPEDEF_P (newdecl)))\n+    return 0;\n+\n   /* If new decl is `static' and an `extern' was seen previously,\n      warn about it.  */\n   warn_extern_redeclared_static (newdecl, olddecl);\n@@ -5285,6 +5298,45 @@ storetags (tags)\n   current_binding_level->tags = tags;\n }\n \f\n+/* Return the type that should be used when TYPE's name is preceded\n+   by a tag such as 'struct' or 'union', or null if the name cannot\n+   be used in this way.\n+\n+   For example, when processing the third line of:\n+\n+\tstruct A;\n+\ttypedef struct A A;\n+\tstruct A;\n+\n+   lookup of A will find the typedef.  Given A's typedef, this function\n+   will return the type associated with \"struct A\".  For the tag to be\n+   anything other than TYPE, TYPE must be a typedef whose original type\n+   has the same name and context as TYPE itself.\n+\n+   It is not valid for a typedef of an anonymous type to be used with\n+   an explicit tag:\n+\n+       typedef struct { ... } B;\n+       struct B;\n+\n+   Return null for this case.  */\n+\n+static tree\n+follow_tag_typedef (type)\n+     tree type;\n+{\n+  tree original;\n+\n+  original = original_type (type);\n+  if (TYPE_IDENTIFIER (original) == TYPE_IDENTIFIER (type)\n+      && (CP_DECL_CONTEXT (TYPE_NAME (original))\n+\t  == CP_DECL_CONTEXT (TYPE_NAME (type)))\n+      && !(CLASS_TYPE_P (original) && TYPE_WAS_ANONYMOUS (original)))\n+    return original;\n+  else\n+    return NULL_TREE;\n+}\n+\n /* Given NAME, an IDENTIFIER_NODE,\n    return the structure (or union or enum) definition for that name.\n    Searches binding levels from BINDING_LEVEL up to the global level.\n@@ -5336,18 +5388,23 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t    else\n \t      old = BINDING_TYPE (old);\n \n-\t    /* If it has an original type, it is a typedef, and we\n-\t       should not return it.  */\n-\t    if (old && DECL_ORIGINAL_TYPE (TYPE_NAME (old)))\n-\t      old = NULL_TREE;\n-\t    if (old && TREE_CODE (old) != form\n-\t\t&& (form == ENUMERAL_TYPE || TREE_CODE (old) == ENUMERAL_TYPE))\n+\t    if (old)\n \t      {\n-\t\terror (\"`%#D' redeclared as %C\", old, form);\n-\t\treturn NULL_TREE;\n+\t\t/* We've found something at this binding level.  If it is\n+\t\t   a typedef, extract the tag it refers to.  Lookup fails\n+\t\t   if the typedef doesn't refer to a taggable type.  */\n+\t\told = follow_tag_typedef (old);\n+\t\tif (!old)\n+\t\t  return NULL_TREE;\n+\t\tif (TREE_CODE (old) != form\n+\t\t    && (form == ENUMERAL_TYPE\n+\t\t\t|| TREE_CODE (old) == ENUMERAL_TYPE))\n+\t\t  {\n+\t\t    error (\"`%#D' redeclared as %C\", old, form);\n+\t\t    return NULL_TREE;\n+\t\t  }\n+\t\treturn old;\n \t      }\n-\t    if (old)\n-\t      return old;\n \t    if (thislevel_only || tail == global_namespace)\n \t      return NULL_TREE;\n \t  }\n@@ -12685,7 +12742,6 @@ xref_tag (code_type_node, name, globalize)\n   enum tree_code code;\n   register tree ref, t;\n   struct binding_level *b = current_binding_level;\n-  int got_type = 0;\n   tree attributes = NULL_TREE;\n   tree context = NULL_TREE;\n \n@@ -12722,7 +12778,6 @@ xref_tag (code_type_node, name, globalize)\n     {\n       t = name;\n       name = TYPE_IDENTIFIER (t);\n-      got_type = 1;\n     }\n   else\n     t = IDENTIFIER_TYPE_VALUE (name);\n@@ -12767,18 +12822,20 @@ xref_tag (code_type_node, name, globalize)\n     {\n       if (t)\n \t{\n+\t  ref = follow_tag_typedef (t);\n+\n \t  /* [dcl.type.elab] If the identifier resolves to a\n \t     typedef-name or a template type-parameter, the\n \t     elaborated-type-specifier is ill-formed.  */\n-\t  if (t != TYPE_MAIN_VARIANT (t)\n-\t      || (CLASS_TYPE_P (t) && TYPE_WAS_ANONYMOUS (t)))\n-\t    pedwarn (\"using typedef-name `%D' after `%s'\",\n-\t\t\tTYPE_NAME (t), tag_name (tag_code));\n+\t  if (!ref)\n+\t    {\n+\t      pedwarn (\"using typedef-name `%D' after `%s'\",\n+\t\t       TYPE_NAME (t), tag_name (tag_code));\n+\t      ref = t;\n+\t    }\n \t  else if (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n \t    error (\"using template type parameter `%T' after `%s'\",\n-\t\t      t, tag_name (tag_code));\n-\n-\t  ref = t;\n+\t\t   t, tag_name (tag_code));\n \t}\n       else\n \tref = lookup_tag (code, name, b, 0);"}]}