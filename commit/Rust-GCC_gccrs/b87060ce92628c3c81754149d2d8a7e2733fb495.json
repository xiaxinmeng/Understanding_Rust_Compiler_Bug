{"sha": "b87060ce92628c3c81754149d2d8a7e2733fb495", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg3MDYwY2U5MjYyOGMzYzgxNzU0MTQ5ZDJkOGE3ZTI3MzNmYjQ5NQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-08-09T14:05:17Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-08-09T14:05:17Z"}, "message": "compiler: rewrite compiler directive support\n    \n    Rewrite the compiler directive support to recognize all the compiler\n    directives implemented by the current gc compiler.  The directives other\n    than go:linkname are now turned into GOPRAGMA flags attached to a\n    function or function declaration.  The go:linkname directive is turned\n    into a map attached to the Lex object.  No new directives are actually\n    implemented yet, they are just recognized.\n    \n    Reviewed-on: https://go-review.googlesource.com/26610\n\nFrom-SVN: r239282", "tree": {"sha": "481f59d708170e50cb07a5189895a66babc1ddbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/481f59d708170e50cb07a5189895a66babc1ddbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b87060ce92628c3c81754149d2d8a7e2733fb495", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87060ce92628c3c81754149d2d8a7e2733fb495", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b87060ce92628c3c81754149d2d8a7e2733fb495", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87060ce92628c3c81754149d2d8a7e2733fb495/comments", "author": null, "committer": null, "parents": [{"sha": "a00f4c6b4f46ab219946e738586fca49d4e71bfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a00f4c6b4f46ab219946e738586fca49d4e71bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a00f4c6b4f46ab219946e738586fca49d4e71bfd"}], "stats": {"total": 385, "additions": 298, "deletions": 87}, "files": [{"sha": "f14fdec06dc40e2ba949944b4ff071acaa706469", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=b87060ce92628c3c81754149d2d8a7e2733fb495", "patch": "@@ -1,4 +1,4 @@\n-3b9c57a35370f26e6cf5839084e367e75e45ec97\n+58be5c6c7d92182dec50a62c8e319d2d7aab12a4\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b1dbb850200fe4736f3ef0c365bbbb818edb7ea3", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=b87060ce92628c3c81754149d2d8a7e2733fb495", "patch": "@@ -4439,7 +4439,7 @@ Function::Function(Function_type* type, Named_object* enclosing, Block* block,\n   : type_(type), enclosing_(enclosing), results_(NULL),\n     closure_var_(NULL), block_(block), location_(location), labels_(),\n     local_type_count_(0), descriptor_(NULL), fndecl_(NULL), defer_stack_(NULL),\n-    is_sink_(false), results_are_named_(false), nointerface_(false),\n+    pragmas_(0), is_sink_(false), results_are_named_(false),\n     is_unnamed_type_stub_method_(false), calls_recover_(false),\n     is_recover_thunk_(false), has_recover_thunk_(false),\n     calls_defer_retaddr_(false), is_type_specific_function_(false),\n@@ -4511,6 +4511,24 @@ Function::update_result_variables()\n     (*p)->result_var_value()->set_function(this);\n }\n \n+// Whether this method should not be included in the type descriptor.\n+\n+bool\n+Function::nointerface() const\n+{\n+  go_assert(this->is_method());\n+  return (this->pragmas_ & GOPRAGMA_NOINTERFACE) != 0;\n+}\n+\n+// Record that this method should not be included in the type\n+// descriptor.\n+\n+void\n+Function::set_nointerface()\n+{\n+  this->pragmas_ |= GOPRAGMA_NOINTERFACE;\n+}\n+\n // Return the closure variable, creating it if necessary.\n \n Named_object*\n@@ -5042,7 +5060,8 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n       // We want to put a nointerface function into a unique section\n       // because there is a good chance that the linker garbage\n       // collection can discard it.\n-      bool in_unique_section = this->in_unique_section_ || this->nointerface_;\n+      bool in_unique_section = (this->in_unique_section_\n+\t\t\t\t|| (this->is_method() && this->nointerface()));\n \n       Btype* functype = this->type_->get_backend_fntype(gogo);\n       this->fndecl_ ="}, {"sha": "bac9eb0c168afb55db206c78769073883d9f76dd", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=b87060ce92628c3c81754149d2d8a7e2733fb495", "patch": "@@ -975,23 +975,22 @@ class Function\n   results_are_named() const\n   { return this->results_are_named_; }\n \n+  // Set the pragmas for this function.\n+  void\n+  set_pragmas(unsigned int pragmas)\n+  {\n+    this->pragmas_ = pragmas;\n+  }\n+\n   // Whether this method should not be included in the type\n   // descriptor.\n   bool\n-  nointerface() const\n-  {\n-    go_assert(this->is_method());\n-    return this->nointerface_;\n-  }\n+  nointerface() const;\n \n   // Record that this method should not be included in the type\n   // descriptor.\n   void\n-  set_nointerface()\n-  {\n-    go_assert(this->is_method());\n-    this->nointerface_ = true;\n-  }\n+  set_nointerface();\n \n   // Record that this function is a stub method created for an unnamed\n   // type.\n@@ -1238,12 +1237,12 @@ class Function\n   // distinguish the defer stack for one function from another.  This\n   // is NULL unless we actually need a defer stack.\n   Temporary_statement* defer_stack_;\n+  // Pragmas for this function.  This is a set of GOPRAGMA bits.\n+  unsigned int pragmas_;\n   // True if this function is sink-named.  No code is generated.\n   bool is_sink_ : 1;\n   // True if the result variables are named.\n   bool results_are_named_ : 1;\n-  // True if this method should not be included in the type descriptor.\n-  bool nointerface_ : 1;\n   // True if this function is a stub method created for an unnamed\n   // type.\n   bool is_unnamed_type_stub_method_ : 1;\n@@ -1305,7 +1304,7 @@ class Function_declaration\n  public:\n   Function_declaration(Function_type* fntype, Location location)\n     : fntype_(fntype), location_(location), asm_name_(), descriptor_(NULL),\n-      fndecl_(NULL)\n+      fndecl_(NULL), pragmas_(0)\n   { }\n \n   Function_type*\n@@ -1325,6 +1324,13 @@ class Function_declaration\n   set_asm_name(const std::string& asm_name)\n   { this->asm_name_ = asm_name; }\n \n+  // Set the pragmas for this function.\n+  void\n+  set_pragmas(unsigned int pragmas)\n+  {\n+    this->pragmas_ = pragmas;\n+  }\n+\n   // Return an expression for the function descriptor, given the named\n   // object for this function.  This may only be called for functions\n   // without a closure.  This will be an immutable struct with one\n@@ -1367,6 +1373,8 @@ class Function_declaration\n   Expression* descriptor_;\n   // The function decl if needed.\n   Bfunction* fndecl_;\n+  // Pragmas for this function.  This is a set of GOPRAGMA bits.\n+  unsigned int pragmas_;\n };\n \n // A variable."}, {"sha": "94809d52b23d10eb4228293748490fbe7ab0fd6c", "filename": "gcc/go/gofrontend/lex.cc", "status": "modified", "additions": 151, "deletions": 40, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.cc?ref=b87060ce92628c3c81754149d2d8a7e2733fb495", "patch": "@@ -442,7 +442,7 @@ Token::print(FILE* file) const\n Lex::Lex(const char* input_file_name, FILE* input_file, Linemap* linemap)\n   : input_file_name_(input_file_name), input_file_(input_file),\n     linemap_(linemap), linebuf_(NULL), linebufsize_(120), linesize_(0),\n-    lineoff_(0), lineno_(0), add_semi_at_eol_(false), saw_nointerface_(false),\n+    lineoff_(0), lineno_(0), add_semi_at_eol_(false), pragmas_(0),\n     extern_()\n {\n   this->linebuf_ = new char[this->linebufsize_];\n@@ -1676,29 +1676,47 @@ Lex::skip_cpp_comment()\n   // //extern comment.\n   this->extern_.clear();\n \n-  const char* p = this->linebuf_ + this->lineoff_;\n+  size_t lineoff = this->lineoff_;\n+\n+  const char* p = this->linebuf_ + lineoff;\n   const char* pend = this->linebuf_ + this->linesize_;\n \n-  // By convention, a C++ comment at the start of the line of the form\n+  const char* pcheck = p;\n+  bool saw_error = false;\n+  while (pcheck < pend)\n+    {\n+      this->lineoff_ = pcheck - this->linebuf_;\n+      unsigned int c;\n+      bool issued_error;\n+      pcheck = this->advance_one_utf8_char(pcheck, &c, &issued_error);\n+      if (issued_error)\n+\tsaw_error = true;\n+    }\n+\n+  if (saw_error)\n+    return;\n+\n+  // Recognize various magic comments at the start of a line.\n+\n+  if (lineoff != 2)\n+    {\n+      // Not at the start of the line.  (lineoff == 2 because of the\n+      // two characters in \"//\").\n+      return;\n+    }\n+\n+  while (pend > p\n+\t && (pend[-1] == ' ' || pend[-1] == '\\t'\n+\t     || pend[-1] == '\\r' || pend[-1] == '\\n'))\n+    --pend;\n+\n+  // A C++ comment at the start of the line of the form\n   //   //line FILE:LINENO\n   // is interpreted as setting the file name and line number of the\n   // next source line.\n-\n-  if (this->lineoff_ == 2\n-      && pend - p > 5\n-      && memcmp(p, \"line \", 5) == 0)\n+  if (pend - p > 5 && memcmp(p, \"line \", 5) == 0)\n     {\n       p += 5;\n-\n-      // Before finding FILE:LINENO, make sure line has valid characters.\n-      const char* pcheck = p;\n-      while (pcheck < pend)\n-        {\n-          unsigned int c;\n-          bool issued_error;\n-          pcheck = this->advance_one_utf8_char(pcheck, &c, &issued_error);\n-        }\n-\n       while (p < pend && *p == ' ')\n \t++p;\n       const char* pcolon = static_cast<const char*>(memchr(p, ':', pend - p));\n@@ -1726,6 +1744,7 @@ Lex::skip_cpp_comment()\n \t      p = plend;\n \t    }\n \t}\n+      return;\n     }\n \n   // As a special gccgo extension, a C++ comment at the start of the\n@@ -1734,37 +1753,129 @@ Lex::skip_cpp_comment()\n   // which immediately precedes a function declaration means that the\n   // external name of the function declaration is NAME.  This is\n   // normally used to permit Go code to call a C function.\n-  if (this->lineoff_ == 2\n-      && pend - p > 7\n-      && memcmp(p, \"extern \", 7) == 0)\n+  if (pend - p > 7 && memcmp(p, \"extern \", 7) == 0)\n     {\n       p += 7;\n       while (p < pend && (*p == ' ' || *p == '\\t'))\n \t++p;\n-      const char* plend = pend;\n-      while (plend > p\n-\t     && (plend[-1] == ' ' || plend[-1] == '\\t' || plend[-1] == '\\n'))\n-\t--plend;\n-      if (plend > p)\n-\tthis->extern_ = std::string(p, plend - p);\n+      if (pend > p)\n+\tthis->extern_ = std::string(p, pend - p);\n+      return;\n     }\n \n-  // For field tracking analysis: a //go:nointerface comment means\n-  // that the next interface method should not be stored in the type\n-  // descriptor.  This permits it to be discarded if it is not needed.\n-  if (this->lineoff_ == 2\n-      && pend - p > 14\n-      && memcmp(p, \"go:nointerface\", 14) == 0)\n-    this->saw_nointerface_ = true;\n+  // All other special comments start with \"go:\".\n \n-  while (p < pend)\n+  if (pend - p < 4 || memcmp(p, \"go:\", 3) != 0)\n+    return;\n+\n+  const char *ps = p + 3;\n+  while (ps < pend && *ps != ' ' && *ps != '\\t')\n+    ++ps;\n+  std::string verb = std::string(p, ps - p);\n+\n+  if (verb == \"go:linkname\")\n     {\n-      this->lineoff_ = p - this->linebuf_;\n-      unsigned int c;\n-      bool issued_error;\n-      p = this->advance_one_utf8_char(p, &c, &issued_error);\n-      if (issued_error)\n-\tthis->extern_.clear();\n+      // As in the gc compiler, set the external link name for a Go symbol.\n+      std::string go_name;\n+      std::string c_name;\n+      if (ps < pend)\n+\t{\n+\t  while (ps < pend && (*ps == ' ' || *ps == '\\t'))\n+\t    ++ps;\n+\t  if (ps < pend)\n+\t    {\n+\t      const char* pg = ps;\n+\t      while (ps < pend && *ps != ' ' && *ps != '\\t')\n+\t\t++ps;\n+\t      if (ps < pend)\n+\t\tgo_name = std::string(pg, ps - pg);\n+\t      while (ps < pend && (*ps == ' ' || *ps == '\\t'))\n+\t\t++ps;\n+\t    }\n+\t  if (ps < pend)\n+\t    {\n+\t      const char* pc = ps;\n+\t      while (ps < pend && *ps != ' ' && *ps != '\\t')\n+\t\t++ps;\n+\t      if (ps <= pend)\n+\t\tc_name = std::string(pc, ps - pc);\n+\t    }\n+\t  if (ps != pend)\n+\t    {\n+\t      go_name.clear();\n+\t      c_name.clear();\n+\t    }\n+\t}\n+      if (go_name.empty() || c_name.empty())\n+\terror_at(this->location(), \"usage: //go:linkname localname linkname\");\n+      else\n+\tthis->linknames_[go_name] = c_name;\n+    }\n+  else if (verb == \"go:nointerface\")\n+    {\n+      // For field tracking analysis: a //go:nointerface comment means\n+      // that the next interface method should not be stored in the\n+      // type descriptor.  This permits it to be discarded if it is\n+      // not needed.\n+      this->pragmas_ |= GOPRAGMA_NOINTERFACE;\n+    }\n+  else if (verb == \"go:noescape\")\n+    {\n+      // Applies to the next function declaration.  Any arguments do\n+      // not escape.\n+      // FIXME: Not implemented.\n+      this->pragmas_ |= GOPRAGMA_NOESCAPE;\n+    }\n+  else if (verb == \"go:nosplit\")\n+    {\n+      // Applies to the next function.  Do not split the stack when\n+      // entering the function.\n+      // FIXME: Not implemented.\n+      this->pragmas_ |= GOPRAGMA_NOSPLIT;\n+    }\n+  else if (verb == \"go:noinline\")\n+    {\n+      // Applies to the next function.  Do not inline the function.\n+      // FIXME: Not implemented.\n+      this->pragmas_ |= GOPRAGMA_NOINLINE;\n+    }\n+  else if (verb == \"go:systemstack\")\n+    {\n+      // Applies to the next function.  It must run on the system stack.\n+      // FIXME: Should only work when compiling the runtime package.\n+      // FIXME: Not implemented.\n+      this->pragmas_ |= GOPRAGMA_SYSTEMSTACK;\n+    }\n+  else if (verb == \"go:nowritebarrier\")\n+    {\n+      // Applies to the next function.  If the function needs to use\n+      // any write barriers, it should emit an error instead.\n+      // FIXME: Should only work when compiling the runtime package.\n+      // FIXME: Not implemented.\n+      this->pragmas_ |= GOPRAGMA_NOWRITEBARRIER;\n+    }\n+  else if (verb == \"go:nowritebarrierrec\")\n+    {\n+      // Applies to the next function.  If the function, or any\n+      // function that it calls, needs to use any write barriers, it\n+      // should emit an error instead.\n+      // FIXME: Should only work when compiling the runtime package.\n+      // FIXME: Not implemented.\n+      this->pragmas_ |= GOPRAGMA_NOWRITEBARRIERREC;\n+    }\n+  else if (verb == \"go:cgo_unsafe_args\")\n+    {\n+      // Applies to the next function.  Taking the address of any\n+      // argument implies taking the address of all arguments.\n+      // FIXME: Not implemented.\n+      this->pragmas_ |= GOPRAGMA_CGOUNSAFEARGS;\n+    }\n+  else if (verb == \"go:uintptrescapes\")\n+    {\n+      // Applies to the next function.  If an argument is a pointer\n+      // converted to uintptr, then the pointer escapes.\n+      // FIXME: Not implemented.\n+      this->pragmas_ |= GOPRAGMA_UINTPTRESCAPES;\n     }\n }\n "}, {"sha": "2f14136a525f14a0261cfc8021a2d59c3a8e443b", "filename": "gcc/go/gofrontend/lex.h", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.h?ref=b87060ce92628c3c81754149d2d8a7e2733fb495", "patch": "@@ -49,6 +49,24 @@ enum Keyword\n   KEYWORD_VAR\n };\n \n+// Pragmas built from magic comments and recorded for functions.\n+// These are used as bits in a bitmask.\n+// The set of values is intended to be the same as the gc compiler.\n+\n+enum GoPragma\n+{\n+  GOPRAGMA_NOINTERFACE = 1 << 0,\t// Method not in type descriptor.\n+  GOPRAGMA_NOESCAPE = 1 << 1,\t\t// Args do not escape.\n+  GOPRAGMA_NORACE = 1 << 2,\t\t// No race detector.\n+  GOPRAGMA_NOSPLIT = 1 << 3,\t\t// Do not split stack.\n+  GOPRAGMA_NOINLINE = 1 << 4,\t\t// Do not inline.\n+  GOPRAGMA_SYSTEMSTACK = 1 << 5,\t// Must run on system stack.\n+  GOPRAGMA_NOWRITEBARRIER = 1 << 6,\t// No write barriers.\n+  GOPRAGMA_NOWRITEBARRIERREC = 1 << 7,\t// No write barriers here or callees.\n+  GOPRAGMA_CGOUNSAFEARGS = 1 << 8,\t// Pointer to arg is pointer to all.\n+  GOPRAGMA_UINTPTRESCAPES = 1 << 9\t// uintptr(p) escapes.\n+};\n+\n // A token returned from the lexer.\n \n class Token\n@@ -348,13 +366,12 @@ class Lex\n   extern_name() const\n   { return this->extern_; }\n \n-  // Return whether we have seen a //go:nointerface comment, clearing\n-  // the flag.\n-  bool\n-  get_and_clear_nointerface()\n+  // Return the current set of pragmas, and clear them.\n+  unsigned int\n+  get_and_clear_pragmas()\n   {\n-    bool ret = this->saw_nointerface_;\n-    this->saw_nointerface_ = false;\n+    unsigned int ret = this->pragmas_;\n+    this->pragmas_ = 0;\n     return ret;\n   }\n \n@@ -492,11 +509,13 @@ class Lex\n   size_t lineno_;\n   // Whether to add a semicolon if we see a newline now.\n   bool add_semi_at_eol_;\n-  // Whether we just saw a magic go:nointerface comment.\n-  bool saw_nointerface_;\n+  // Pragmas for the next function, from magic comments.\n+  unsigned int pragmas_;\n   // The external name to use for a function declaration, from a magic\n   // //extern comment.\n   std::string extern_;\n+  // The list of //go:linkname comments.\n+  std::map<std::string, std::string> linknames_;\n };\n \n #endif // !defined(GO_LEX_H)"}, {"sha": "cb7f9664aaf547fff59f59d2a07f794448683f79", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 76, "deletions": 22, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=b87060ce92628c3c81754149d2d8a7e2733fb495", "patch": "@@ -1305,10 +1305,10 @@ Parse::declaration()\n {\n   const Token* token = this->peek_token();\n \n-  bool saw_nointerface = this->lex_->get_and_clear_nointerface();\n-  if (saw_nointerface && !token->is_keyword(KEYWORD_FUNC))\n+  unsigned int pragmas = this->lex_->get_and_clear_pragmas();\n+  if (pragmas != 0 && !token->is_keyword(KEYWORD_FUNC))\n     warning_at(token->location(), 0,\n-\t       \"ignoring magic //go:nointerface comment before non-method\");\n+\t       \"ignoring magic comment before non-function\");\n \n   if (token->is_keyword(KEYWORD_CONST))\n     this->const_decl();\n@@ -1317,7 +1317,7 @@ Parse::declaration()\n   else if (token->is_keyword(KEYWORD_VAR))\n     this->var_decl();\n   else if (token->is_keyword(KEYWORD_FUNC))\n-    this->function_decl(saw_nointerface);\n+    this->function_decl(pragmas);\n   else\n     {\n       error_at(this->location(), \"expected declaration\");\n@@ -2236,13 +2236,12 @@ Parse::simple_var_decl_or_assignment(const std::string& name,\n //                    __asm__ \"(\" string_lit \")\" .\n // This extension means a function whose real name is the identifier\n // inside the asm.  This extension will be removed at some future\n-// date.  It has been replaced with //extern comments.\n-\n-// SAW_NOINTERFACE is true if we saw a magic //go:nointerface comment,\n-// which means that we omit the method from the type descriptor.\n+// date.  It has been replaced with //extern or //go:linkname comments.\n+//\n+// PRAGMAS is a bitset of magic comments.\n \n void\n-Parse::function_decl(bool saw_nointerface)\n+Parse::function_decl(unsigned int pragmas)\n {\n   go_assert(this->peek_token()->is_keyword(KEYWORD_FUNC));\n   Location location = this->location();\n@@ -2257,12 +2256,6 @@ Parse::function_decl(bool saw_nointerface)\n       rec = this->receiver();\n       token = this->peek_token();\n     }\n-  else if (saw_nointerface)\n-    {\n-      warning_at(location, 0,\n-\t\t \"ignoring magic //go:nointerface comment before non-method\");\n-      saw_nointerface = false;\n-    }\n \n   if (!token->is_identifier())\n     {\n@@ -2320,7 +2313,69 @@ Parse::function_decl(bool saw_nointerface)\n \t\t\t\t\t\t     semi_loc));\n     }\n \n-  if (!this->peek_token()->is_op(OPERATOR_LCURLY))\n+  static struct {\n+    unsigned int bit;\n+    const char* name;\n+    bool decl_ok;\n+    bool func_ok;\n+    bool method_ok;\n+  } pragma_check[] =\n+      {\n+\t{ GOPRAGMA_NOINTERFACE, \"nointerface\", false, false, true },\n+\t{ GOPRAGMA_NOESCAPE, \"noescape\", true, false, false },\n+\t{ GOPRAGMA_NORACE, \"norace\", false, true, true },\n+\t{ GOPRAGMA_NOSPLIT, \"nosplit\", false, true, true },\n+\t{ GOPRAGMA_NOINLINE, \"noinline\", false, true, true },\n+\t{ GOPRAGMA_SYSTEMSTACK, \"systemstack\", false, true, true },\n+\t{ GOPRAGMA_NOWRITEBARRIER, \"nowritebarrier\", false, true, true },\n+\t{ GOPRAGMA_NOWRITEBARRIERREC, \"nowritebarrierrec\", false, true, true },\n+\t{ GOPRAGMA_CGOUNSAFEARGS, \"cgo_unsafe_args\", false, true, true },\n+\t{ GOPRAGMA_UINTPTRESCAPES, \"uintptrescapes\", true, true, true },\n+      };\n+\n+  bool is_decl = !this->peek_token()->is_op(OPERATOR_LCURLY);\n+  if (pragmas != 0)\n+    {\n+      for (size_t i = 0;\n+\t   i < sizeof(pragma_check) / sizeof(pragma_check[0]);\n+\t   ++i)\n+\t{\n+\t  if ((pragmas & pragma_check[i].bit) == 0)\n+\t    continue;\n+\n+\t  if (is_decl)\n+\t    {\n+\t      if (pragma_check[i].decl_ok)\n+\t\tcontinue;\n+\t      warning_at(location, 0,\n+\t\t\t (\"ignoring magic //go:%s comment \"\n+\t\t\t  \"before declaration\"),\n+\t\t\t pragma_check[i].name);\n+\t    }\n+\t  else if (rec == NULL)\n+\t    {\n+\t      if (pragma_check[i].func_ok)\n+\t\tcontinue;\n+\t      warning_at(location, 0,\n+\t\t\t (\"ignoring magic //go:%s comment \"\n+\t\t\t  \"before function definition\"),\n+\t\t\t pragma_check[i].name);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (pragma_check[i].method_ok)\n+\t\tcontinue;\n+\t      warning_at(location, 0,\n+\t\t\t (\"ignoring magic //go:%s comment \"\n+\t\t\t  \"before method definition\"),\n+\t\t\t pragma_check[i].name);\n+\t    }\n+\n+\t  pragmas &= ~ pragma_check[i].bit;\n+\t}\n+    }\n+\n+  if (is_decl)\n     {\n       if (named_object == NULL)\n \t{\n@@ -2353,10 +2408,8 @@ Parse::function_decl(bool saw_nointerface)\n \t    }\n \t}\n \n-      if (saw_nointerface)\n-\twarning_at(location, 0,\n-\t\t   (\"ignoring magic //go:nointerface comment \"\n-\t\t    \"before declaration\"));\n+      if (pragmas != 0 && named_object->is_function_declaration())\n+\tnamed_object->func_declaration_value()->set_pragmas(pragmas);\n     }\n   else\n     {\n@@ -2372,10 +2425,11 @@ Parse::function_decl(bool saw_nointerface)\n       named_object = this->gogo_->start_function(name, fntype, true, location);\n       Location end_loc = this->block();\n       this->gogo_->finish_function(end_loc);\n-      if (saw_nointerface\n+\n+      if (pragmas != 0\n \t  && !this->is_erroneous_function_\n \t  && named_object->is_function())\n-\tnamed_object->func_value()->set_nointerface();\n+\tnamed_object->func_value()->set_pragmas(pragmas);\n       this->is_erroneous_function_ = hold_is_erroneous_function;\n     }\n }"}, {"sha": "a7118e77c17575b25d2709f27307980d96ab5eda", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87060ce92628c3c81754149d2d8a7e2733fb495/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=b87060ce92628c3c81754149d2d8a7e2733fb495", "patch": "@@ -209,7 +209,7 @@ class Parse\n   void simple_var_decl_or_assignment(const std::string&, Location,\n \t\t\t\t     bool may_be_composite_lit,\n \t\t\t\t     Range_clause*, Type_switch*);\n-  void function_decl(bool saw_nointerface);\n+  void function_decl(unsigned int pragmas);\n   Typed_identifier* receiver();\n   Expression* operand(bool may_be_sink, bool *is_parenthesized);\n   Expression* enclosing_var_reference(Named_object*, Named_object*,"}]}