{"sha": "e0a0c416a0d163a97d35e83e42d4b8a1273acc0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBhMGM0MTZhMGQxNjNhOTdkMzVlODNlNDJkNGI4YTEyNzNhY2MwZQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-10-06T01:45:47Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-10-06T01:45:47Z"}, "message": "jvspec.c (jvgenmain_spec): Added `-fdollars-in-identifiers'.\n\n\t* jvspec.c (jvgenmain_spec): Added `-fdollars-in-identifiers'.\n\t* jvgenmain.c (class_mangling_prefix): Removed.\n\t(class_mangling_suffix): New global.\n\t(main): Use it.\n\t* gjavah.c (cxx_keyword_subst): Mangle C++ keywords by appending\n\t`$'.\n\t(print_method_info): Handle overrides for static and final\n\tmethods.\n\t(process_file): Generate declaration for class object field.\n\t* class.c (cxx_keywords): New array.\n\t(utf8_cmp): New function.\n\t(cxx_keyword_p): New function.\n\t(layout_class_method): Mangle C++ keywords by appending `$'.\n\t(mangle_field): New function.\n\t(mangle_class_field): Use mangle_field.  Mangle class name as\n\t`class$'.\n\t(mangle_static_field): Use mangle_field.\n\nFrom-SVN: r36738", "tree": {"sha": "45363ed5e9154746dc287f74e62b19db6aa11e99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45363ed5e9154746dc287f74e62b19db6aa11e99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/comments", "author": null, "committer": null, "parents": [{"sha": "d1a458c4ed50e8fe72bf99057c51df06d5aa3ef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1a458c4ed50e8fe72bf99057c51df06d5aa3ef4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1a458c4ed50e8fe72bf99057c51df06d5aa3ef4"}], "stats": {"total": 214, "additions": 166, "deletions": 48}, "files": [{"sha": "3bbe55eb80eff25356b5f026139ad31cc2d82642", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=e0a0c416a0d163a97d35e83e42d4b8a1273acc0e", "patch": "@@ -1,3 +1,23 @@\n+2000-10-05  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* jvspec.c (jvgenmain_spec): Added `-fdollars-in-identifiers'.\n+\t* jvgenmain.c (class_mangling_prefix): Removed.\n+\t(class_mangling_suffix): New global.\n+\t(main): Use it.\n+\t* gjavah.c (cxx_keyword_subst): Mangle C++ keywords by appending\n+\t`$'.\n+\t(print_method_info): Handle overrides for static and final\n+\tmethods.\n+\t(process_file): Generate declaration for class object field.\n+\t* class.c (cxx_keywords): New array.\n+\t(utf8_cmp): New function.\n+\t(cxx_keyword_p): New function.\n+\t(layout_class_method): Mangle C++ keywords by appending `$'.\n+\t(mangle_field): New function.\n+\t(mangle_class_field): Use mangle_field.  Mangle class name as\n+\t`class$'.\n+\t(mangle_static_field): Use mangle_field.\n+\n Tue Oct  3 13:44:37 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* decl.c (find_local_variable): Removed uncessary type check and\n@@ -127,6 +147,7 @@ Wed Sep 13 11:50:35 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \t(argument_types_convertible): Likewise.\n \t(patch_cast): Rename wfl_op parameter to avoid macro conflicts.\n \t\n+>>>>>>> 1.531\n 2000-09-14  Tom Tromey  <tromey@cygnus.com>\n \n \t* lex.h: Use HAVE_ICONV_H, not HAVE_ICONV."}, {"sha": "3d4e5839ccbc67786cb5dc8edf46caefa0b8c2da", "filename": "gcc/java/class.c", "status": "modified", "additions": 129, "deletions": 22, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=e0a0c416a0d163a97d35e83e42d4b8a1273acc0e", "patch": "@@ -52,6 +52,9 @@ static int assume_compiled PARAMS ((const char *));\n static struct hash_entry *init_test_hash_newfunc PARAMS ((struct hash_entry *,\n \t\t\t\t\t\t\t  struct hash_table *,\n \t\t\t\t\t\t\t  hash_table_key));\n+static int utf8_cmp PARAMS ((const unsigned char *, int, const char *));\n+static int cxx_keyword_p PARAMS ((const char *, int));\n+static tree mangle_field PARAMS ((tree, tree));\n \n static rtx registerClass_libfunc;\n \n@@ -1626,29 +1629,13 @@ append_gpp_mangled_type (obstack, type)\n     }\n }\n \n-/* Build the mangled name of the `class' field.  */\n-\n-static tree\n-mangle_class_field (class)\n-     tree class;\n-{\n-  tree name;\n-  obstack_grow (&temporary_obstack, \"_CL_\", 4);\n-  append_gpp_mangled_type (&temporary_obstack, class);\n-  obstack_1grow (&temporary_obstack, '\\0');\n-  name = get_identifier (obstack_base (&temporary_obstack));\n-  obstack_free (&temporary_obstack, obstack_base (&temporary_obstack));\n-  return name;\n-}\n-\n-/* Build the mangled (assembly-level) name of the static field FIELD. */\n+/* Build the mangled name of a field, given the class name and the\n+   field name.  */\n \n static tree\n-mangle_static_field (field)\n-     tree field;\n+mangle_field (class, name)\n+     tree class, name;\n {\n-  tree class = DECL_CONTEXT (field);\n-  tree name = DECL_NAME (field);\n   int encoded_len;\n #if ! defined (NO_DOLLAR_IN_LABEL) || ! defined (NO_DOT_IN_LABEL)\n   obstack_1grow (&temporary_obstack, '_');\n@@ -1683,12 +1670,39 @@ mangle_static_field (field)\n \t\t    IDENTIFIER_POINTER (name),\n \t\t    IDENTIFIER_LENGTH (name));\n     }\n+\n+  /* Mangle C++ keywords by appending a `$'.  */\n+  /* FIXME: NO_DOLLAR_IN_LABEL */\n+  if (cxx_keyword_p (IDENTIFIER_POINTER (name), IDENTIFIER_LENGTH (name)))\n+    obstack_grow (&temporary_obstack, \"$\", 1);\n+\n   obstack_1grow (&temporary_obstack, '\\0');\n   name = get_identifier (obstack_base (&temporary_obstack));\n   obstack_free (&temporary_obstack, obstack_base (&temporary_obstack));\n   return name;\n }\n \n+/* Build the mangled name of the `class' field.  */\n+\n+static tree\n+mangle_class_field (class)\n+     tree class;\n+{\n+  /* We know that we can use `class$' to mangle the class object,\n+     because `class' is a reserved word in Java and thus can't appear\n+     as a field or method name.  */\n+  return mangle_field (class, get_identifier (\"class$\"));\n+}\n+\n+/* Build the mangled (assembly-level) name of the static field FIELD. */\n+\n+static tree\n+mangle_static_field (field)\n+     tree field;\n+{\n+  return mangle_field (DECL_CONTEXT (field), DECL_NAME (field));\n+}\n+\n /* Build a VAR_DECL for the dispatch table (vtable) for class TYPE. */\n \n tree\n@@ -1880,7 +1894,7 @@ layout_class_methods (this_class)\n     }\n   else\n     dtable_count = integer_zero_node;\n-  \n+\n   TYPE_METHODS (handle_type) = nreverse (TYPE_METHODS (handle_type));\n \n   for (method_decl = TYPE_METHODS (handle_type);\n@@ -1896,6 +1910,93 @@ layout_class_methods (this_class)\n   pop_obstacks ();\n }\n \n+/* A sorted list of all C++ keywords.  */\n+\n+static const char *cxx_keywords[] =\n+{\n+  \"asm\",\n+  \"auto\",\n+  \"bool\",\n+  \"const_cast\",\n+  \"delete\",\n+  \"dynamic_cast\",\n+  \"enum\",\n+  \"explicit\",\n+  \"extern\",\n+  \"friend\",\n+  \"inline\",\n+  \"mutable\",\n+  \"namespace\",\n+  \"overload\",\n+  \"register\",\n+  \"reinterpret_cast\",\n+  \"signed\",\n+  \"sizeof\",\n+  \"static_cast\",\n+  \"struct\",\n+  \"template\",\n+  \"typedef\",\n+  \"typeid\",\n+  \"typename\",\n+  \"typenameopt\",\n+  \"union\",\n+  \"unsigned\",\n+  \"using\",\n+  \"virtual\",\n+  \"volatile\",\n+  \"wchar_t\"\n+};\n+\n+/* Return 0 if NAME is equal to STR, -1 if STR is \"less\" than NAME,\n+   and 1 if STR is \"greater\" than NAME.  */\n+\n+static int\n+utf8_cmp (str, length, name)\n+     const unsigned char *str;\n+     int length;\n+     const char *name;\n+{\n+  const unsigned char *limit = str + length;\n+  int i;\n+\n+  for (i = 0; name[i]; ++i)\n+    {\n+      int ch = UTF8_GET (str, limit);\n+      if (ch != name[i])\n+\treturn ch - name[i];\n+    }\n+\n+  return str == limit ? 0 : 1;\n+}\n+\n+/* Return true if NAME is a C++ keyword.  */\n+\n+static int\n+cxx_keyword_p (name, length)\n+     const char *name;\n+     int length;\n+{\n+  int last = ARRAY_SIZE (cxx_keywords);\n+  int first = 0;\n+  int mid = (last + first) / 2;\n+  int old = -1;\n+\n+  for (mid = (last + first) / 2;\n+       mid != old;\n+       old = mid, mid = (last + first) / 2)\n+    {\n+      int r = utf8_cmp (name, length, cxx_keywords[mid]);\n+\n+      if (r == 0)\n+\treturn 1;\n+      else if (r < 0)\n+\tlast = mid;\n+      else\n+\tfirst = mid;\n+    }\n+  return 0;\n+}\n+\n /* Lay METHOD_DECL out, returning a possibly new value of\n    DTABLE_COUNT.  */\n \n@@ -1931,8 +2032,14 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n \t\t\tIDENTIFIER_POINTER (method_name),\n \t\t\tIDENTIFIER_LENGTH (method_name));\n \t}\n+\n+      /* Mangle C++ keywords by appending a `$'.  */\n+      /* FIXME: NO_DOLLAR_IN_LABEL */\n+      if (cxx_keyword_p (IDENTIFIER_POINTER (method_name),\n+\t\t\t IDENTIFIER_LENGTH (method_name)))\n+\tobstack_grow (&temporary_obstack, \"$\", 1);\n     }\n-      \n+\n   obstack_grow (&temporary_obstack, \"__\", 2);\n   if (ID_FINIT_P (method_name))\n     obstack_grow (&temporary_obstack, \"finit\", 5);"}, {"sha": "a25788a436116712b1f0a1ada9484fe452965159", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=e0a0c416a0d163a97d35e83e42d4b8a1273acc0e", "patch": "@@ -440,9 +440,9 @@ cxx_keyword_subst (str, length)\n \n       if (r == 0)\n \t{\n-\t  char *str = xmalloc (9 + strlen (cxx_keywords[mid]));\n-\t  strcpy (str, \"__dummy_\");\n-\t  strcat (str, cxx_keywords[mid]);\n+\t  char *str = xmalloc (2 + strlen (cxx_keywords[mid]));\n+\t  strcpy (str, cxx_keywords[mid]);\n+\t  strcat (str, \"$\");\n \t  return str;\n \t}\n       else if (r < 0)\n@@ -759,18 +759,6 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags, synth),\n \t (not only for calls to this function for for other functions\n \t after it in the vtbl).  So we give it a dummy name instead.  */\n       override = cxx_keyword_subst (str, length);\n-      if (override)\n-\t{\n-\t  /* If the method is static or final, we can safely skip it.\n-\t     If we don't skip it then we'll have problems since the\n-\t     mangling will be wrong.  FIXME.  */\n-\t  if (METHOD_IS_FINAL (jcf->access_flags, flags)\n-\t      || (flags & ACC_STATIC))\n-\t    {\n-\t      free (override);\n-\t      return;\n-\t    }\n-\t}\n     }\n \n   if (! stubs && ! flag_jni)\n@@ -1844,9 +1832,9 @@ DEFUN(process_file, (jcf, out),\n     {\n       if (flag_jni)\n \t{\n-\t      fprintf (out, \"\\n#ifdef __cplusplus\\n\");\n-\t      fprintf (out, \"}\\n\");\n-\t      fprintf (out, \"#endif\\n\");\n+\t  fprintf (out, \"\\n#ifdef __cplusplus\\n\");\n+\t  fprintf (out, \"}\\n\");\n+\t  fprintf (out, \"#endif\\n\");\n \t}\n       else\n \t{\n@@ -1860,8 +1848,11 @@ DEFUN(process_file, (jcf, out),\n \t  for (i = 0; i < add_count; ++i)\n \t    fprintf (out, \"  %s\\n\", add_specs[i]);\n \n-\t  if (! stubs)\n-\t    fputs (\"};\\n\", out);\n+\t  /* Generate an entry for the class object.  */\n+\t  generate_access (out, ACC_PUBLIC);\n+\t  fprintf (out, \"\\n  static ::java::lang::Class class$;\\n\");\n+\n+\t  fputs (\"};\\n\", out);\n \n \t  if (append_count > 0)\n \t    fputc ('\\n', out);"}, {"sha": "6c2670d29ae79a277b84204500de3b66352323f9", "filename": "gcc/java/jvgenmain.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/gcc%2Fjava%2Fjvgenmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/gcc%2Fjava%2Fjvgenmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvgenmain.c?ref=e0a0c416a0d163a97d35e83e42d4b8a1273acc0e", "patch": "@@ -34,7 +34,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n const char main_method_prefix[] = \"main__\";\n const char main_method_suffix[] = \"Pt6JArray1ZPQ34java4lang6String\";\n-const char class_mangling_prefix[] = \"_CL_\";\n+const char class_mangling_suffix[] = \".class$\";\n \n struct obstack name_obstack;\n \n@@ -155,13 +155,12 @@ main (int argc, const char **argv)\n     }\n   fprintf (stream, \"  0\\n};\\n\\n\");\n \n-  fprintf (stream, \"extern struct Class %s%s;\\n\",\n-\t   class_mangling_prefix, mangled_classname);\n+  fprintf (stream, \"extern int class __attribute__ ((alias (\\\"_%s%s\\\")));\\n\",\n+\t   mangled_classname, class_mangling_suffix);\n   fprintf (stream, \"int main (int argc, const char **argv)\\n\");\n   fprintf (stream, \"{\\n\");\n   fprintf (stream, \"   _Jv_Compiler_Properties = props;\\n\");\n-  fprintf (stream, \"   JvRunMain (&%s%s, argc, argv);\\n\",\n-\t   class_mangling_prefix, mangled_classname);\n+  fprintf (stream, \"   JvRunMain (&class, argc, argv);\\n\");\n   fprintf (stream, \"}\\n\");\n   if (stream != stdout && fclose (stream) != 0)\n     {"}, {"sha": "ee9fbf067c45ab74b9ad32ea682c7bf78c5359bf", "filename": "gcc/java/jvspec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0a0c416a0d163a97d35e83e42d4b8a1273acc0e/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=e0a0c416a0d163a97d35e83e42d4b8a1273acc0e", "patch": "@@ -61,7 +61,7 @@ const char jvgenmain_spec[] =\n \t\t   %{<fuse-boehm-gc} %{<fhash-synchronization} %{<fjni}\\\n \t\t   %{<fclasspath*} %{<fCLASSPATH*} %{<foutput-class-dir}\\\n \t\t   %{<fuse-divide-subroutine} %{<fno-use-divide-subroutine}\\\n-\t\t   %{f*}\\\n+\t\t   %{f*} -fdollars-in-identifiers\\\n \t\t   %{aux-info*}\\\n \t\t   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t\t   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%Umain.s}} |\\n\\"}]}