{"sha": "8c7926c4c73c20a4097710c4ffd92d30a839c0fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM3OTI2YzRjNzNjMjBhNDA5NzcxMGM0ZmZkOTJkMzBhODM5YzBmYw==", "commit": {"author": {"name": "Adam Nemet", "email": "anemet@caviumnetworks.com", "date": "2009-05-03T17:20:30Z"}, "committer": {"name": "Adam Nemet", "email": "nemet@gcc.gnu.org", "date": "2009-05-03T17:20:30Z"}, "message": "expr.c (get_def_for_expr): New function.\n\n\t* expr.c (get_def_for_expr): New function.\n\t(expand_expr_real_1) <PLUS_EXPR, MINUS_EXPR>: Adjust to work with\n\tSSA rather than trees.\n\t<MULT_EXPR>: Likewise.  Use subexp0 and subexp1 instead of\n\tTREE_OPERAND (exp, 0) and TREE_OPERAND (exp, 1).\n\nCo-Authored-By: Richard Guenther <rguenther@suse.de>\n\nFrom-SVN: r147078", "tree": {"sha": "ffc56de6b1acc6ed83fb02fefd7abf41c0890808", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffc56de6b1acc6ed83fb02fefd7abf41c0890808"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c7926c4c73c20a4097710c4ffd92d30a839c0fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c7926c4c73c20a4097710c4ffd92d30a839c0fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c7926c4c73c20a4097710c4ffd92d30a839c0fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c7926c4c73c20a4097710c4ffd92d30a839c0fc/comments", "author": null, "committer": null, "parents": [{"sha": "b91cc3b9dcc840b259b0d7e6551b047a42695f87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b91cc3b9dcc840b259b0d7e6551b047a42695f87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b91cc3b9dcc840b259b0d7e6551b047a42695f87"}], "stats": {"total": 200, "additions": 115, "deletions": 85}, "files": [{"sha": "8fb45c142ede8144f6fdd2615e5cb7166c70fbeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7926c4c73c20a4097710c4ffd92d30a839c0fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7926c4c73c20a4097710c4ffd92d30a839c0fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c7926c4c73c20a4097710c4ffd92d30a839c0fc", "patch": "@@ -1,3 +1,12 @@\n+2009-05-03  Adam Nemet  <anemet@caviumnetworks.com>\n+\t    Richard Guenther  <rguenther@suse.de>\n+\n+\t* expr.c (get_def_for_expr): New function.\n+\t(expand_expr_real_1) <PLUS_EXPR, MINUS_EXPR>: Adjust to work with\n+\tSSA rather than trees.\n+\t<MULT_EXPR>: Likewise.  Use subexp0 and subexp1 instead of\n+\tTREE_OPERAND (exp, 0) and TREE_OPERAND (exp, 1).\n+\t\n 2009-05-03  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-common.c (reswords): Add _Imaginary."}, {"sha": "c3e4d818cee9d0ee12ee15e656fef3775b0b37b2", "filename": "gcc/expr.c", "status": "modified", "additions": 106, "deletions": 85, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c7926c4c73c20a4097710c4ffd92d30a839c0fc/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c7926c4c73c20a4097710c4ffd92d30a839c0fc/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8c7926c4c73c20a4097710c4ffd92d30a839c0fc", "patch": "@@ -6992,6 +6992,26 @@ expand_constructor (tree exp, rtx target, enum expand_modifier modifier,\n   return target;\n }\n \n+/* Return the defining gimple statement for SSA_NAME NAME if it is an\n+   assigment and the code of the expresion on the RHS is CODE.  Return\n+   NULL otherwise.  */\n+\n+static gimple\n+get_def_for_expr (tree name, enum tree_code code)\n+{\n+  gimple def_stmt;\n+\n+  if (TREE_CODE (name) != SSA_NAME)\n+    return NULL;\n+\n+  def_stmt = get_gimple_for_ssa_name (name);\n+  if (!def_stmt\n+      || gimple_assign_rhs_code (def_stmt) != code)\n+    return NULL;\n+\n+  return def_stmt;\n+}\n+\n \n /* expand_expr: generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n@@ -7130,6 +7150,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n   int ignore;\n   tree context, subexp0, subexp1;\n   bool reduce_bit_field;\n+  gimple subexp0_def, subexp1_def;\n+  tree top0, top1;\n #define REDUCE_BIT_FIELD(expr)\t(reduce_bit_field\t\t\t  \\\n \t\t\t\t ? reduce_to_bit_field_precision ((expr), \\\n \t\t\t\t\t\t\t\t  target, \\\n@@ -8322,27 +8344,30 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* Check if this is a case for multiplication and addition.  */\n       if ((TREE_CODE (type) == INTEGER_TYPE\n \t   || TREE_CODE (type) == FIXED_POINT_TYPE)\n-\t  && TREE_CODE (TREE_OPERAND (exp, 0)) == MULT_EXPR)\n+\t  && (subexp0_def = get_def_for_expr (TREE_OPERAND (exp, 0),\n+\t\t\t\t\t      MULT_EXPR)))\n \t{\n \t  tree subsubexp0, subsubexp1;\n-\t  enum tree_code code0, code1, this_code;\n+\t  gimple subsubexp0_def, subsubexp1_def;\n+\t  enum tree_code this_code;\n \n-\t  subexp0 = TREE_OPERAND (exp, 0);\n-\t  subsubexp0 = TREE_OPERAND (subexp0, 0);\n-\t  subsubexp1 = TREE_OPERAND (subexp0, 1);\n-\t  code0 = TREE_CODE (subsubexp0);\n-\t  code1 = TREE_CODE (subsubexp1);\n \t  this_code = TREE_CODE (type) == INTEGER_TYPE ? NOP_EXPR\n \t\t\t\t\t\t       : FIXED_CONVERT_EXPR;\n-\t  if (code0 == this_code && code1 == this_code\n-\t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subsubexp0, 0)))\n+\t  subsubexp0 = gimple_assign_rhs1 (subexp0_def);\n+\t  subsubexp0_def = get_def_for_expr (subsubexp0, this_code);\n+\t  subsubexp1 = gimple_assign_rhs2 (subexp0_def);\n+\t  subsubexp1_def = get_def_for_expr (subsubexp1, this_code);\n+\t  if (subsubexp0_def && subsubexp1_def\n+\t      && (top0 = gimple_assign_rhs1 (subsubexp0_def))\n+\t      && (top1 = gimple_assign_rhs1 (subsubexp1_def))\n+\t      && (TYPE_PRECISION (TREE_TYPE (top0))\n \t\t  < TYPE_PRECISION (TREE_TYPE (subsubexp0)))\n-\t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subsubexp0, 0)))\n-\t\t  == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subsubexp1, 0))))\n-\t      && (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subsubexp0, 0)))\n-\t\t  == TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subsubexp1, 0)))))\n+\t      && (TYPE_PRECISION (TREE_TYPE (top0))\n+\t\t  == TYPE_PRECISION (TREE_TYPE (top1)))\n+\t      && (TYPE_UNSIGNED (TREE_TYPE (top0))\n+\t\t  == TYPE_UNSIGNED (TREE_TYPE (top1))))\n \t    {\n-\t      tree op0type = TREE_TYPE (TREE_OPERAND (subsubexp0, 0));\n+\t      tree op0type = TREE_TYPE (top0);\n \t      enum machine_mode innermode = TYPE_MODE (op0type);\n \t      bool zextend_p = TYPE_UNSIGNED (op0type);\n \t      bool sat_p = TYPE_SATURATING (TREE_TYPE (subsubexp0));\n@@ -8355,9 +8380,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t  && (optab_handler (this_optab, mode)->insn_code\n \t\t      != CODE_FOR_nothing))\n \t\t{\n-\t\t  expand_operands (TREE_OPERAND (subsubexp0, 0),\n-\t\t\t\t   TREE_OPERAND (subsubexp1, 0),\n-\t\t\t\t   NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\t\t  expand_operands (top0, top1, NULL_RTX, &op0, &op1,\n+\t\t\t\t   EXPAND_NORMAL);\n \t\t  op2 = expand_expr (TREE_OPERAND (exp, 1), subtarget,\n \t\t\t\t     VOIDmode, EXPAND_NORMAL);\n \t\t  temp = expand_ternary_op (mode, this_optab, op0, op1, op2,\n@@ -8485,27 +8509,30 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* Check if this is a case for multiplication and subtraction.  */\n       if ((TREE_CODE (type) == INTEGER_TYPE\n \t   || TREE_CODE (type) == FIXED_POINT_TYPE)\n-\t  && TREE_CODE (TREE_OPERAND (exp, 1)) == MULT_EXPR)\n+\t  && (subexp1_def = get_def_for_expr (TREE_OPERAND (exp, 1),\n+\t\t\t\t\t      MULT_EXPR)))\n \t{\n \t  tree subsubexp0, subsubexp1;\n-\t  enum tree_code code0, code1, this_code;\n+\t  gimple subsubexp0_def, subsubexp1_def;\n+\t  enum tree_code this_code;\n \n-\t  subexp1 = TREE_OPERAND (exp, 1);\n-\t  subsubexp0 = TREE_OPERAND (subexp1, 0);\n-\t  subsubexp1 = TREE_OPERAND (subexp1, 1);\n-\t  code0 = TREE_CODE (subsubexp0);\n-\t  code1 = TREE_CODE (subsubexp1);\n \t  this_code = TREE_CODE (type) == INTEGER_TYPE ? NOP_EXPR\n \t\t\t\t\t\t       : FIXED_CONVERT_EXPR;\n-\t  if (code0 == this_code && code1 == this_code\n-\t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subsubexp0, 0)))\n+\t  subsubexp0 = gimple_assign_rhs1 (subexp1_def);\n+\t  subsubexp0_def = get_def_for_expr (subsubexp0, this_code);\n+\t  subsubexp1 = gimple_assign_rhs2 (subexp1_def);\n+\t  subsubexp1_def = get_def_for_expr (subsubexp1, this_code);\n+\t  if (subsubexp0_def && subsubexp1_def\n+\t      && (top0 = gimple_assign_rhs1 (subsubexp0_def))\n+\t      && (top1 = gimple_assign_rhs1 (subsubexp1_def))\n+\t      && (TYPE_PRECISION (TREE_TYPE (top0))\n \t\t  < TYPE_PRECISION (TREE_TYPE (subsubexp0)))\n-\t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subsubexp0, 0)))\n-\t\t  == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subsubexp1, 0))))\n-\t      && (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subsubexp0, 0)))\n-\t\t  == TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subsubexp1, 0)))))\n+\t      && (TYPE_PRECISION (TREE_TYPE (top0))\n+\t\t  == TYPE_PRECISION (TREE_TYPE (top1)))\n+\t      && (TYPE_UNSIGNED (TREE_TYPE (top0))\n+\t\t  == TYPE_UNSIGNED (TREE_TYPE (top1))))\n \t    {\n-\t      tree op0type = TREE_TYPE (TREE_OPERAND (subsubexp0, 0));\n+\t      tree op0type = TREE_TYPE (top0);\n \t      enum machine_mode innermode = TYPE_MODE (op0type);\n \t      bool zextend_p = TYPE_UNSIGNED (op0type);\n \t      bool sat_p = TYPE_SATURATING (TREE_TYPE (subsubexp0));\n@@ -8518,9 +8545,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t  && (optab_handler (this_optab, mode)->insn_code\n \t\t      != CODE_FOR_nothing))\n \t\t{\n-\t\t  expand_operands (TREE_OPERAND (subsubexp0, 0),\n-\t\t\t\t   TREE_OPERAND (subsubexp1, 0),\n-\t\t\t\t   NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\t\t  expand_operands (top0, top1, NULL_RTX, &op0, &op1,\n+\t\t\t\t   EXPAND_NORMAL);\n \t\t  op2 = expand_expr (TREE_OPERAND (exp, 0), subtarget,\n \t\t\t\t     VOIDmode, EXPAND_NORMAL);\n \t\t  temp = expand_ternary_op (mode, this_optab, op0, op1, op2,\n@@ -8619,66 +8645,65 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       subexp0 = TREE_OPERAND (exp, 0);\n       subexp1 = TREE_OPERAND (exp, 1);\n+      subexp0_def = get_def_for_expr (subexp0, NOP_EXPR);\n+      subexp1_def = get_def_for_expr (subexp1, NOP_EXPR);\n+      top0 = top1 = NULL_TREE;\n+\n       /* First, check if we have a multiplication of one signed and one\n \t unsigned operand.  */\n-      if (TREE_CODE (subexp0) == NOP_EXPR\n-\t  && TREE_CODE (subexp1) == NOP_EXPR\n+      if (subexp0_def\n+\t  && (top0 = gimple_assign_rhs1 (subexp0_def))\n+\t  && subexp1_def\n+\t  && (top1 = gimple_assign_rhs1 (subexp1_def))\n \t  && TREE_CODE (type) == INTEGER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subexp0, 0)))\n-\t      < TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subexp0, 0)))\n-\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subexp1, 0))))\n-\t  && (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subexp0, 0)))\n-\t      != TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subexp1, 0)))))\n+\t  && (TYPE_PRECISION (TREE_TYPE (top0))\n+\t      < TYPE_PRECISION (TREE_TYPE (subexp0)))\n+\t  && (TYPE_PRECISION (TREE_TYPE (top0))\n+\t      == TYPE_PRECISION (TREE_TYPE (top1)))\n+\t  && (TYPE_UNSIGNED (TREE_TYPE (top0))\n+\t      != TYPE_UNSIGNED (TREE_TYPE (top1))))\n \t{\n \t  enum machine_mode innermode\n-\t    = TYPE_MODE (TREE_TYPE (TREE_OPERAND (subexp0, 0)));\n+\t    = TYPE_MODE (TREE_TYPE (top0));\n \t  this_optab = usmul_widen_optab;\n \t  if (mode == GET_MODE_WIDER_MODE (innermode))\n \t    {\n \t      if (optab_handler (this_optab, mode)->insn_code != CODE_FOR_nothing)\n \t\t{\n-\t\t  if (TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (subexp0, 0))))\n-\t\t    expand_operands (TREE_OPERAND (subexp0, 0),\n-\t\t\t\t     TREE_OPERAND (subexp1, 0),\n-\t\t\t\t     NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\t\t  if (TYPE_UNSIGNED (TREE_TYPE (top0)))\n+\t\t    expand_operands (top0, top1, NULL_RTX, &op0, &op1,\n+\t\t\t\t     EXPAND_NORMAL);\n \t\t  else\n-\t\t    expand_operands (TREE_OPERAND (subexp0, 0),\n-\t\t\t\t     TREE_OPERAND (subexp1, 0),\n-\t\t\t\t     NULL_RTX, &op1, &op0, EXPAND_NORMAL);\n+\t\t    expand_operands (top0, top1, NULL_RTX, &op1, &op0,\n+\t\t\t\t     EXPAND_NORMAL);\n \n \t\t  goto binop3;\n \t\t}\n \t    }\n \t}\n-      /* Check for a multiplication with matching signedness.  */\n-      else if (TREE_CODE (TREE_OPERAND (exp, 0)) == NOP_EXPR\n+      /* Check for a multiplication with matching signedness.  If\n+\t valid, TOP0 and TOP1 were set in the previous if\n+\t condition.  */\n+      else if (top0\n \t  && TREE_CODE (type) == INTEGER_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))\n-\t      < TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t  && ((TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n-\t       && int_fits_type_p (TREE_OPERAND (exp, 1),\n-\t\t\t\t   TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))\n+\t  && (TYPE_PRECISION (TREE_TYPE (top0))\n+\t      < TYPE_PRECISION (TREE_TYPE (subexp0)))\n+\t  && ((TREE_CODE (subexp1) == INTEGER_CST\n+\t       && int_fits_type_p (subexp1, TREE_TYPE (top0))\n \t       /* Don't use a widening multiply if a shift will do.  */\n-\t       && ((GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 1))))\n+\t       && ((GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (subexp1)))\n \t\t    > HOST_BITS_PER_WIDE_INT)\n-\t\t   || exact_log2 (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))) < 0))\n+\t\t   || exact_log2 (TREE_INT_CST_LOW (subexp1)) < 0))\n \t      ||\n-\t      (TREE_CODE (TREE_OPERAND (exp, 1)) == NOP_EXPR\n-\t       && (TYPE_PRECISION (TREE_TYPE\n-\t\t\t\t   (TREE_OPERAND (TREE_OPERAND (exp, 1), 0)))\n-\t\t   == TYPE_PRECISION (TREE_TYPE\n-\t\t\t\t      (TREE_OPERAND\n-\t\t\t\t       (TREE_OPERAND (exp, 0), 0))))\n+\t      (top1\n+\t       && (TYPE_PRECISION (TREE_TYPE (top1))\n+\t\t   == TYPE_PRECISION (TREE_TYPE (top0))\n \t       /* If both operands are extended, they must either both\n \t\t  be zero-extended or both be sign-extended.  */\n-\t       && (TYPE_UNSIGNED (TREE_TYPE\n-\t\t\t\t  (TREE_OPERAND (TREE_OPERAND (exp, 1), 0)))\n-\t\t   == TYPE_UNSIGNED (TREE_TYPE\n-\t\t\t\t     (TREE_OPERAND\n-\t\t\t\t      (TREE_OPERAND (exp, 0), 0)))))))\n+\t       && (TYPE_UNSIGNED (TREE_TYPE (top1))\n+\t\t   == TYPE_UNSIGNED (TREE_TYPE (top0)))))))\n \t{\n-\t  tree op0type = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0));\n+\t  tree op0type = TREE_TYPE (top0);\n \t  enum machine_mode innermode = TYPE_MODE (op0type);\n \t  bool zextend_p = TYPE_UNSIGNED (op0type);\n \t  optab other_optab = zextend_p ? smul_widen_optab : umul_widen_optab;\n@@ -8688,27 +8713,24 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    {\n \t      if (optab_handler (this_optab, mode)->insn_code != CODE_FOR_nothing)\n \t\t{\n-\t\t  if (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)\n-\t\t    expand_operands (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n-\t\t\t\t     TREE_OPERAND (exp, 1),\n-\t\t\t\t     NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\t\t  if (TREE_CODE (subexp1) == INTEGER_CST)\n+\t\t    expand_operands (top0, subexp1, NULL_RTX, &op0, &op1,\n+\t\t\t\t     EXPAND_NORMAL);\n \t\t  else\n-\t\t    expand_operands (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n-\t\t\t\t     TREE_OPERAND (TREE_OPERAND (exp, 1), 0),\n-\t\t\t\t     NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n+\t\t    expand_operands (top0, top1, NULL_RTX, &op0, &op1,\n+\t\t\t\t     EXPAND_NORMAL);\n \t\t  goto binop3;\n \t\t}\n \t      else if (optab_handler (other_optab, mode)->insn_code != CODE_FOR_nothing\n \t\t       && innermode == word_mode)\n \t\t{\n \t\t  rtx htem, hipart;\n-\t\t  op0 = expand_normal (TREE_OPERAND (TREE_OPERAND (exp, 0), 0));\n-\t\t  if (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)\n+\t\t  op0 = expand_normal (top0);\n+\t\t  if (TREE_CODE (subexp1) == INTEGER_CST)\n \t\t    op1 = convert_modes (innermode, mode,\n-\t\t\t\t\t expand_normal (TREE_OPERAND (exp, 1)),\n-\t\t\t\t\t unsignedp);\n+\t\t\t\t\t expand_normal (subexp1), unsignedp);\n \t\t  else\n-\t\t    op1 = expand_normal (TREE_OPERAND (TREE_OPERAND (exp, 1), 0));\n+\t\t    op1 = expand_normal (top1);\n \t\t  temp = expand_binop (mode, other_optab, op0, op1, target,\n \t\t\t\t       unsignedp, OPTAB_LIB_WIDEN);\n \t\t  hipart = gen_highpart (innermode, temp);\n@@ -8721,8 +8743,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t}\n \t    }\n \t}\n-      expand_operands (TREE_OPERAND (exp, 0), TREE_OPERAND (exp, 1),\n-\t\t       subtarget, &op0, &op1, EXPAND_NORMAL);\n+      expand_operands (subexp0, subexp1, subtarget, &op0, &op1, EXPAND_NORMAL);\n       return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1, target, unsignedp));\n \n     case TRUNC_DIV_EXPR:"}]}