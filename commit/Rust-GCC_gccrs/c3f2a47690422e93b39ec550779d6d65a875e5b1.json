{"sha": "c3f2a47690422e93b39ec550779d6d65a875e5b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNmMmE0NzY5MDQyMmU5M2IzOWVjNTUwNzc5ZDZkNjVhODc1ZTViMQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1998-12-02T16:47:33Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1998-12-02T16:47:33Z"}, "message": "class.c (layout_class_method): Call build_java_argument_signature on constructors too.\n\nWed Dec  2 15:52:25 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* class.c (layout_class_method): Call build_java_argument_signature\n\ton constructors too.\n\t* parse.y (check_method_redefinition): Use TYPE_ARGUMENT_SIGNATURE.\n\t(patch_method_invocation): Define a primary when resolving an\n \texpression name. Augmented comment on code checking illegal `this'\n \tusage. Loosened it test by accepting NEW_CLASS_EXPR.\n\nFrom-SVN: r24065", "tree": {"sha": "3e321e2c7e839540f047092abbe1068975523ae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e321e2c7e839540f047092abbe1068975523ae7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3f2a47690422e93b39ec550779d6d65a875e5b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f2a47690422e93b39ec550779d6d65a875e5b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3f2a47690422e93b39ec550779d6d65a875e5b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f2a47690422e93b39ec550779d6d65a875e5b1/comments", "author": null, "committer": null, "parents": [{"sha": "226592de983de618cb54a5985a92bdf8e3e77540", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/226592de983de618cb54a5985a92bdf8e3e77540", "html_url": "https://github.com/Rust-GCC/gccrs/commit/226592de983de618cb54a5985a92bdf8e3e77540"}], "stats": {"total": 56, "additions": 40, "deletions": 16}, "files": [{"sha": "c597e10af81d8379d0f263a9aa6958a9b6546d55", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f2a47690422e93b39ec550779d6d65a875e5b1/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f2a47690422e93b39ec550779d6d65a875e5b1/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c3f2a47690422e93b39ec550779d6d65a875e5b1", "patch": "@@ -1,3 +1,12 @@\n+Wed Dec  2 15:52:25 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (layout_class_method): Call build_java_argument_signature\n+\ton constructors too.\n+\t* parse.y (check_method_redefinition): Use TYPE_ARGUMENT_SIGNATURE.\n+\t(patch_method_invocation): Define a primary when resolving an\n+ \texpression name. Augmented comment on code checking illegal `this'\n+ \tusage. Loosened it test by accepting NEW_CLASS_EXPR.\n+\n Tue Dec  1 13:53:24 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* class.c (layout_class_method): Don't report error on non-static"}, {"sha": "8deff6eebb9bb570f98ddb6e680acd6635055c65", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f2a47690422e93b39ec550779d6d65a875e5b1/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f2a47690422e93b39ec550779d6d65a875e5b1/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=c3f2a47690422e93b39ec550779d6d65a875e5b1", "patch": "@@ -1578,6 +1578,7 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n       else\n \tDECL_NAME (method_decl) = get_identifier (p);\n       DECL_CONSTRUCTOR_P (method_decl) = 1;\n+      build_java_argument_signature (TREE_TYPE (method_decl));\n     }\n   else if (! METHOD_STATIC (method_decl) && !DECL_ARTIFICIAL (method_decl))\n     {"}, {"sha": "6d1feb0d5880896de9f125e73b26186d7248754a", "filename": "gcc/java/parse.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f2a47690422e93b39ec550779d6d65a875e5b1/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f2a47690422e93b39ec550779d6d65a875e5b1/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=c3f2a47690422e93b39ec550779d6d65a875e5b1", "patch": "@@ -6969,7 +6969,7 @@ check_method_redefinition (class, method)\n {\n   tree redef, name;\n   tree cl = DECL_NAME (method);\n-  tree sig = TYPE_LANG_SPECIFIC (TREE_TYPE (method))->signature;\n+  tree sig = TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (method));\n   /* decl name of artificial <clinit> and <finit> doesn't need to be fixed and\n      checked */\n \n@@ -6983,11 +6983,10 @@ check_method_redefinition (class, method)\n   \n   for (redef = TYPE_METHODS (class); redef; redef = TREE_CHAIN (redef))\n     {\n-      struct lang_type *t = TYPE_LANG_SPECIFIC (TREE_TYPE (redef));\n-      \n-      if (! t || (redef == method))\n+      if (redef == method)\n \tbreak;\n-      if (DECL_NAME (redef) == name && sig == t->signature)\n+      if (DECL_NAME (redef) == name \n+\t  && sig == TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (redef)))\n \t{\n \t  parse_error_context \n \t    (cl, \"Duplicate %s declaration `%s'\",\n@@ -9234,6 +9233,10 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \t  field = resolve_field_access (wfl, NULL, &type);\n \t  if (field == error_mark_node)\n \t    PATCH_METHOD_RETURN_ERROR ();\n+\t  /* field is used in lieu of a primary. It alows us not to\n+\t   report errors on erroneous use of `this' in\n+\t   constructors. */\n+\t  primary = field;\t\n \t  \n \t  /* 2- Do the layout of the class where the last field\n \t     was found, so we can search it. */\n@@ -9367,10 +9370,14 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \n   is_static_flag = METHOD_STATIC (list);\n \n-  /* In the context of an explicit constructor invocation, we can't invoke\n-     any method relying on `this' */\n+  /* In the context of an explicit constructor invocation, we can't\n+     invoke any method relying on `this'. Exceptions are: we're\n+     invoking a static function, primary exists and is not the current\n+     this, we're creating a new object. */\n   if (ctxp->explicit_constructor_p \n-      && !is_static_flag && (!primary || primary == current_this))\n+      && !is_static_flag \n+      && (!primary || primary == current_this)\n+      && (TREE_CODE (patch) != NEW_CLASS_EXPR))\n     {\n       parse_error_context \n \t(wfl, \"Can't reference `this' before the superclass constructor has \""}, {"sha": "807ed9c9e7458de0bb15d8b86c6423a7ad675834", "filename": "gcc/java/parse.y", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f2a47690422e93b39ec550779d6d65a875e5b1/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f2a47690422e93b39ec550779d6d65a875e5b1/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c3f2a47690422e93b39ec550779d6d65a875e5b1", "patch": "@@ -4364,7 +4364,7 @@ check_method_redefinition (class, method)\n {\n   tree redef, name;\n   tree cl = DECL_NAME (method);\n-  tree sig = TYPE_LANG_SPECIFIC (TREE_TYPE (method))->signature;\n+  tree sig = TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (method));\n   /* decl name of artificial <clinit> and <finit> doesn't need to be fixed and\n      checked */\n \n@@ -4378,11 +4378,10 @@ check_method_redefinition (class, method)\n   \n   for (redef = TYPE_METHODS (class); redef; redef = TREE_CHAIN (redef))\n     {\n-      struct lang_type *t = TYPE_LANG_SPECIFIC (TREE_TYPE (redef));\n-      \n-      if (! t || (redef == method))\n+      if (redef == method)\n \tbreak;\n-      if (DECL_NAME (redef) == name && sig == t->signature)\n+      if (DECL_NAME (redef) == name \n+\t  && sig == TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (redef)))\n \t{\n \t  parse_error_context \n \t    (cl, \"Duplicate %s declaration `%s'\",\n@@ -6629,6 +6628,10 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \t  field = resolve_field_access (wfl, NULL, &type);\n \t  if (field == error_mark_node)\n \t    PATCH_METHOD_RETURN_ERROR ();\n+\t  /* field is used in lieu of a primary. It alows us not to\n+\t   report errors on erroneous use of `this' in\n+\t   constructors. */\n+\t  primary = field;\t\n \t  \n \t  /* 2- Do the layout of the class where the last field\n \t     was found, so we can search it. */\n@@ -6762,10 +6765,14 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \n   is_static_flag = METHOD_STATIC (list);\n \n-  /* In the context of an explicit constructor invocation, we can't invoke\n-     any method relying on `this' */\n+  /* In the context of an explicit constructor invocation, we can't\n+     invoke any method relying on `this'. Exceptions are: we're\n+     invoking a static function, primary exists and is not the current\n+     this, we're creating a new object. */\n   if (ctxp->explicit_constructor_p \n-      && !is_static_flag && (!primary || primary == current_this))\n+      && !is_static_flag \n+      && (!primary || primary == current_this)\n+      && (TREE_CODE (patch) != NEW_CLASS_EXPR))\n     {\n       parse_error_context \n \t(wfl, \"Can't reference `this' before the superclass constructor has \""}]}