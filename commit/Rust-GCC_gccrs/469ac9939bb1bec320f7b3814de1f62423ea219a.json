{"sha": "469ac9939bb1bec320f7b3814de1f62423ea219a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY5YWM5OTM5YmIxYmVjMzIwZjdiMzgxNGRlMWY2MjQyM2VhMjE5YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-12-13T01:31:47Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-12-13T01:31:47Z"}, "message": "x\n\nFrom-SVN: r13305", "tree": {"sha": "16aaf051fd2c4b487fff6c48e868df681f121018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16aaf051fd2c4b487fff6c48e868df681f121018"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/469ac9939bb1bec320f7b3814de1f62423ea219a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/469ac9939bb1bec320f7b3814de1f62423ea219a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/469ac9939bb1bec320f7b3814de1f62423ea219a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/469ac9939bb1bec320f7b3814de1f62423ea219a/comments", "author": null, "committer": null, "parents": [{"sha": "97adc6ed4cac5b3e857ea1d8166972021ceb772f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97adc6ed4cac5b3e857ea1d8166972021ceb772f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97adc6ed4cac5b3e857ea1d8166972021ceb772f"}], "stats": {"total": 609, "additions": 395, "deletions": 214}, "files": [{"sha": "d9edb71aae3d5427fef9e46795b1cdf9bab6f49b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=469ac9939bb1bec320f7b3814de1f62423ea219a", "patch": "@@ -1832,6 +1832,7 @@ ix86_expand_prologue ()\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n   long tsize = get_frame_size ();\n+  rtx insn;\n \n   if (!TARGET_SCHEDULE_PROLOGUE)\n     return;\n@@ -1841,17 +1842,23 @@ ix86_expand_prologue ()\n   xops[2] = GEN_INT (tsize);\n   if (frame_pointer_needed)\n     {\n-      emit_insn (gen_rtx (SET, 0,\n-\t\t\t  gen_rtx (MEM, SImode,\n-\t\t\t\t   gen_rtx (PRE_DEC, SImode, stack_pointer_rtx)),\n-\t\t\t  frame_pointer_rtx));\n-      emit_move_insn (xops[1], xops[0]);\n+      insn = emit_insn\n+\t(gen_rtx (SET, 0,\n+\t\t  gen_rtx (MEM, SImode,\n+\t\t\t   gen_rtx (PRE_DEC, SImode, stack_pointer_rtx)),\n+\t\t  frame_pointer_rtx));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_move_insn (xops[1], xops[0]);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   if (tsize == 0)\n     ;\n   else if (! TARGET_STACK_PROBE || tsize < CHECK_STACK_LIMIT)\n-    emit_insn (gen_subsi3 (xops[0], xops[0], xops[2]));\n+    {\n+      insn = emit_insn (gen_subsi3 (xops[0], xops[0], xops[2]));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n   else \n     {\n       xops[3] = gen_rtx (REG, SImode, 0);\n@@ -1877,10 +1884,13 @@ ix86_expand_prologue ()\n \t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n       {\n \txops[0] = gen_rtx (REG, SImode, regno);\n-\temit_insn (gen_rtx (SET, 0,\n-\t\t\t    gen_rtx (MEM, SImode,\n-\t\t\t\t     gen_rtx (PRE_DEC, SImode, stack_pointer_rtx)),\n-\t\t\t  xops[0]));\n+\tinsn = emit_insn\n+\t  (gen_rtx (SET, 0,\n+\t\t    gen_rtx (MEM, SImode,\n+\t\t\t     gen_rtx (PRE_DEC, SImode, stack_pointer_rtx)),\n+\t\t    xops[0]));\n+\t\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n       }\n \n   if (pic_reg_used && TARGET_DEEP_BRANCH_PREDICTION)"}, {"sha": "ac08c45e773937b57bf268bb9fef5f65db6ad992", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=469ac9939bb1bec320f7b3814de1f62423ea219a", "patch": "@@ -2331,6 +2331,13 @@ number as al, and ax.\n  (n) == 7 ? 5 : \\\n  (n) + 4)\n \n+/* Before the prologue, RA is at 0(%esp).  */\n+#define INCOMING_RETURN_ADDR_RTX \\\n+  gen_rtx (MEM, VOIDmode, gen_rtx (REG, VOIDmode, STACK_POINTER_REGNUM))\n+\n+/* PC is dbx register 8; let's use that column for RA. */\n+#define DWARF_FRAME_RETURN_COLUMN \t8\n+\n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */\n "}, {"sha": "cacbf1f8fd8c8b12d6d4cc033595a92afeb78ae2", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 39, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=469ac9939bb1bec320f7b3814de1f62423ea219a", "patch": "@@ -5068,22 +5068,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t  if (store_p)\n \t\t    {\n \t\t      rtx insn = emit_move_insn (mem_rtx, reg_rtx);\n-\n-\t\t      if (write_symbols == DWARF2_DEBUG)\n-\t\t\t{\n-\t\t\t  int offset = (gp_offset\n-\t\t\t\t\t- current_frame_info.total_size);\n-\t\t\t  if (regno == GP_REG_FIRST + 31)\n-\t\t\t    REG_NOTES (insn)\n-\t\t\t      = gen_rtx (EXPR_LIST, REG_RETURN_SAVE,\n-\t\t\t\t\t GEN_INT (offset), REG_NOTES (insn));\n-\t\t\t  else\n-\t\t\t    REG_NOTES (insn)\n-\t\t\t      = gen_rtx (EXPR_LIST, REG_SAVE,\n-\t\t\t\t\t gen_rtx (EXPR_LIST, VOIDmode, reg_rtx,\n-\t\t\t\t\t\t  GEN_INT (offset)),\n-\t\t\t\t\t REG_NOTES (insn));\n-\t\t\t}\n+\t\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t\t    }\n \t\t  else if (!TARGET_ABICALLS || mips_abi != ABI_32\n \t\t\t   || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n@@ -5199,17 +5184,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t  if (store_p)\n \t\t    {\n \t\t      rtx insn = emit_move_insn (mem_rtx, reg_rtx);\n-\n-\t\t      if (write_symbols == DWARF2_DEBUG)\n-\t\t\t{\n-\t\t\t  int offset = (gp_offset\n-\t\t\t\t\t- current_frame_info.total_size);\n-\t\t\t  REG_NOTES (insn)\n-\t\t\t    = gen_rtx (EXPR_LIST, REG_SAVE,\n-\t\t\t\t       gen_rtx (EXPR_LIST, VOIDmode, reg_rtx,\n-\t\t\t\t\t\tGEN_INT (offset)),\n-\t\t\t\t       REG_NOTES (insn));\n-\t\t\t}\n+\t\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t\t    }\n \t\t  else\n \t\t    emit_move_insn (reg_rtx, mem_rtx);\n@@ -5452,12 +5427,7 @@ mips_expand_prologue ()\n \t    insn = emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t\t  tsize_rtx));\n \n-\t  if (write_symbols == DWARF2_DEBUG)\n-\t    REG_NOTES (insn)\n-\t      = gen_rtx (EXPR_LIST, REG_FRAME,\n-\t\t\t gen_rtx (PLUS, VOIDmode, stack_pointer_rtx,\n-\t\t\t\t  GEN_INT (tsize)),\n-\t\t\t REG_NOTES (insn));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n \n       save_restore_insns (TRUE, tmp_rtx, tsize, (FILE *)0);\n@@ -5471,12 +5441,7 @@ mips_expand_prologue ()\n \t  else\n \t    insn= emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n \n-\t  if (write_symbols == DWARF2_DEBUG)\n-\t    REG_NOTES (insn)\n-\t      = gen_rtx (EXPR_LIST, REG_FRAME,\n-\t\t\t gen_rtx (PLUS, VOIDmode, frame_pointer_rtx,\n-\t\t\t\t  GEN_INT (tsize)),\n-\t\t\t REG_NOTES (insn));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n \n       if (TARGET_ABICALLS && mips_abi != ABI_32)"}, {"sha": "9b430ab5f481fc201b990400f6b2f17723846f15", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=469ac9939bb1bec320f7b3814de1f62423ea219a", "patch": "@@ -927,11 +927,16 @@ while (0)\n    This mapping does not allow for tracking DBX register 0, since column 0\n    is used for the frame address, but since register 0 is fixed this is\n    not really a problem.  */\n-#define DWARF_FRAME_REGNUM(REG) (DBX_REGISTER_NUMBER (REG))\n+#define DWARF_FRAME_REGNUM(REG)\t\t\t\t\\\n+  (REG == GP_REG_FIRST + 31 ? DWARF_FRAME_RETURN_COLUMN\t\\\n+   : DBX_REGISTER_NUMBER (REG))\n \n /* The DWARF 2 CFA column which tracks the return address.  */\n #define DWARF_FRAME_RETURN_COLUMN (FP_REG_LAST + 1)\n \n+/* Before the prologue, RA lives in r31.  */\n+#define INCOMING_RETURN_ADDR_RTX  gen_rtx (REG, VOIDmode, GP_REG_FIRST + 31)\n+\n /* Overrides for the COFF debug format.  */\n #define PUT_SDB_SCL(a)\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\\"}, {"sha": "99007b3f8aed8e70f16c0538f774f3228a7b24af", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 342, "deletions": 158, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=469ac9939bb1bec320f7b3814de1f62423ea219a", "patch": "@@ -2,6 +2,7 @@\n    Copyright (C) 1992, 1993, 1995, 1996 Free Software Foundation, Inc.\n    Contributed by Gary Funck (gary@intrepid.com).  Derived from the\n    DWARF 1 implementation written by Ron Guilmette (rfg@monkeys.com).\n+   Extensively modified by Jason Merrill (jason@cygnus.com).\n \n This file is part of GNU CC.\n \n@@ -23,6 +24,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #ifdef DWARF2_DEBUGGING_INFO\n #include <stdio.h>\n+#include <setjmp.h>\n #include \"dwarf2.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n@@ -67,7 +69,8 @@ typedef enum\n     dw_val_class_loc,\n     dw_val_class_const,\n     dw_val_class_unsigned_const,\n-    dw_val_class_double_const,\n+    dw_val_class_long_long,\n+    dw_val_class_float,\n     dw_val_class_flag,\n     dw_val_class_die_ref,\n     dw_val_class_fde_ref,\n@@ -95,12 +98,20 @@ typedef struct pubname_struct *pubname_ref;\n typedef dw_die_ref *arange_ref;\n \n /* Describe a double word constant value.  */\n-typedef struct dw_double_const_struct\n+typedef struct dw_long_long_struct\n   {\n-    unsigned long dw_dbl_hi;\n-    unsigned long dw_dbl_low;\n+    unsigned long hi;\n+    unsigned long low;\n   }\n-dw_dbl_const;\n+dw_long_long_const;\n+\n+/* Describe a floating point constant value.  */\n+typedef struct dw_fp_struct\n+  {\n+    long *array;\n+    unsigned length;\n+  }\n+dw_float_const;\n \n /* Each entry in the line_info_table maintains the file and\n    line nuber associated with the label generated for that\n@@ -134,7 +145,8 @@ typedef struct dw_val_struct\n \tdw_loc_descr_ref val_loc;\n \tlong int val_int;\n \tlong unsigned val_unsigned;\n-\tdw_dbl_const val_dbl_const;\n+\tdw_long_long_const val_long_long;\n+\tdw_float_const val_float;\n \tdw_die_ref val_die_ref;\n \tunsigned val_fde_index;\n \tchar *val_str;\n@@ -301,7 +313,11 @@ extern char *language_string;\n static unsigned cie_size;\n \n /* Offsets recorded in opcodes are a multiple of this alignment factor.  */\n-#define DWARF_CIE_DATA_ALIGNMENT -4\n+#ifdef STACK_GROWS_DOWNWARD\n+#define DWARF_CIE_DATA_ALIGNMENT (-UNITS_PER_WORD)\n+#else\n+#define DWARF_CIE_DATA_ALIGNMENT UNITS_PER_WORD\n+#endif\n \n /* Fixed size portion of the FDE.  */\n #define DWARF_FDE_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 2 * PTR_SIZE)\n@@ -830,9 +846,9 @@ char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n #endif\n \n /* The mapping from gcc register number to DWARF 2 CFA column number.  By\n-   default, we provide columns for all registers after the CFA column.  */\n+   default, we just provide columns for all registers.  */\n #ifndef DWARF_FRAME_REGNUM\n-#define DWARF_FRAME_REGNUM(REG) (DBX_REGISTER_NUMBER (REG) + 1)\n+#define DWARF_FRAME_REGNUM(REG) DBX_REGISTER_NUMBER (REG)\n #endif\n \f\n /************************ general utility functions **************************/\n@@ -1948,7 +1964,7 @@ add_AT_unsigned (die, attr_kind, unsigned_val)\n \n /* Add an unsigned double integer attribute value to a DIE.  */\n inline void\n-add_AT_double (die, attr_kind, val_hi, val_low)\n+add_AT_long_long (die, attr_kind, val_hi, val_low)\n      register dw_die_ref die;\n      register enum dwarf_attribute attr_kind;\n      register unsigned long val_hi;\n@@ -1959,9 +1975,29 @@ add_AT_double (die, attr_kind, val_hi, val_low)\n     {\n       attr->dw_attr_next = NULL;\n       attr->dw_attr = attr_kind;\n-      attr->dw_attr_val.val_class = dw_val_class_double_const;\n-      attr->dw_attr_val.v.val_dbl_const.dw_dbl_hi = val_hi;\n-      attr->dw_attr_val.v.val_dbl_const.dw_dbl_low = val_low;\n+      attr->dw_attr_val.val_class = dw_val_class_long_long;\n+      attr->dw_attr_val.v.val_long_long.hi = val_hi;\n+      attr->dw_attr_val.v.val_long_long.low = val_low;\n+      add_dwarf_attr (die, attr);\n+    }\n+}\n+\n+/* Add a floating point attribute value to a DIE and return it.  */\n+inline void\n+add_AT_float (die, attr_kind, length, array)\n+     register dw_die_ref die;\n+     register enum dwarf_attribute attr_kind;\n+     register unsigned length;\n+     register long *array;\n+{\n+  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  if (attr != NULL)\n+    {\n+      attr->dw_attr_next = NULL;\n+      attr->dw_attr = attr_kind;\n+      attr->dw_attr_val.val_class = dw_val_class_float;\n+      attr->dw_attr_val.v.val_float.length = length;\n+      attr->dw_attr_val.v.val_float.array = array;\n       add_dwarf_attr (die, attr);\n     }\n }\n@@ -2502,10 +2538,13 @@ print_die (die, outfile)\n \tcase dw_val_class_unsigned_const:\n \t  fprintf (outfile, \"%u\", a->dw_attr_val.v.val_unsigned);\n \t  break;\n-\tcase dw_val_class_double_const:\n+\tcase dw_val_class_long_long:\n \t  fprintf (outfile, \"constant (%u,%u)\",\n-\t\t  a->dw_attr_val.v.val_dbl_const.dw_dbl_hi,\n-\t\t  a->dw_attr_val.v.val_dbl_const.dw_dbl_low);\n+\t\t  a->dw_attr_val.v.val_long_long.hi,\n+\t\t  a->dw_attr_val.v.val_long_long.low);\n+\t  break;\n+\tcase dw_val_class_float:\n+\t  fprintf (outfile, \"floating-point constant\");\n \t  break;\n \tcase dw_val_class_flag:\n \t  fprintf (outfile, \"%u\", a->dw_attr_val.v.val_flag);\n@@ -2909,8 +2948,11 @@ size_of_die (die)\n \tcase dw_val_class_unsigned_const:\n \t  size += constant_size (a->dw_attr_val.v.val_unsigned);\n \t  break;\n-\tcase dw_val_class_double_const:\n-\t  size += 8;\n+\tcase dw_val_class_long_long:\n+\t  size += 1 + 8; /* block */\n+\t  break;\n+\tcase dw_val_class_float:\n+\t  size += 1 + a->dw_attr_val.v.val_float.length * 4; /* block */\n \t  break;\n \tcase dw_val_class_flag:\n \t  size += 1;\n@@ -3237,8 +3279,10 @@ value_format (v)\n \tdefault:\n \t  abort ();\n \t}\n-    case dw_val_class_double_const:\n-      return DW_FORM_data8;\n+    case dw_val_class_long_long:\n+      return DW_FORM_block1;\n+    case dw_val_class_float:\n+      return DW_FORM_block1;\n     case dw_val_class_flag:\n       return DW_FORM_flag;\n     case dw_val_class_die_ref:\n@@ -3342,9 +3386,7 @@ output_loc_operands (loc)\n       break;\n     case DW_OP_const8u:\n     case DW_OP_const8s:\n-      ASM_OUTPUT_DWARF_DATA8 (asm_out_file,\n-\t\t\t      val1->v.val_dbl_const.dw_dbl_hi,\n-\t\t\t      val2->v.val_dbl_const.dw_dbl_low);\n+      abort ();\n       fputc ('\\n', asm_out_file);\n       break;\n     case DW_OP_constu:\n@@ -3459,6 +3501,8 @@ output_die (die)\n   register unsigned long ref_offset;\n   register unsigned long size;\n   register dw_loc_descr_ref loc;\n+  register int i;\n+\n   output_uleb128 (die->die_abbrev);\n   if (flag_verbose_asm)\n     fprintf (asm_out_file, \" (DIE (0x%x) %s)\",\n@@ -3530,10 +3574,36 @@ output_die (die)\n \t      abort ();\n \t    }\n \t  break;\n-\tcase dw_val_class_double_const:\n+\tcase dw_val_class_long_long:\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 8);\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s %s\",\n+\t\t     ASM_COMMENT_START, dwarf_attr_name (a->dw_attr));\n+\t  fputc ('\\n', asm_out_file);\n \t  ASM_OUTPUT_DWARF_DATA8 (asm_out_file,\n-\t\t\t\t  a->dw_attr_val.v.val_dbl_const.dw_dbl_hi,\n-\t\t\t\t  a->dw_attr_val.v.val_dbl_const.dw_dbl_low);\n+\t\t\t\t  a->dw_attr_val.v.val_long_long.hi,\n+\t\t\t\t  a->dw_attr_val.v.val_long_long.low);\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s long long constant\",\n+\t\t     ASM_COMMENT_START);\n+\t  fputc ('\\n', asm_out_file);\n+\t  break;\n+\tcase dw_val_class_float:\n+\t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file,\n+\t\t\t\t  a->dw_attr_val.v.val_float.length * 4);\n+\t  if (flag_verbose_asm)\n+\t    fprintf (asm_out_file, \"\\t%s %s\",\n+\t\t     ASM_COMMENT_START, dwarf_attr_name (a->dw_attr));\n+\t  fputc ('\\n', asm_out_file);\n+\t  for (i = 0; i < a->dw_attr_val.v.val_float.length; ++i)\n+\t    {\n+\t      ASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n+\t\t\t\t      a->dw_attr_val.v.val_float.array[i]);\n+\t      if (flag_verbose_asm)\n+\t\tfprintf (asm_out_file, \"\\t%s fp constant word %d\",\n+\t\t\t ASM_COMMENT_START, i);\n+\t      fputc ('\\n', asm_out_file);\n+\t    }\n \t  break;\n \tcase dw_val_class_flag:\n \t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, a->dw_attr_val.v.val_flag);\n@@ -3571,7 +3641,9 @@ output_die (die)\n \tdefault:\n \t  abort ();\n \t}\n-      if (a->dw_attr_val.val_class != dw_val_class_loc)\n+      if (a->dw_attr_val.val_class != dw_val_class_loc\n+\t  && a->dw_attr_val.val_class != dw_val_class_long_long\n+\t  && a->dw_attr_val.val_class != dw_val_class_float)\n \t{\n \t  if (flag_verbose_asm)\n \t    {\n@@ -3631,35 +3703,23 @@ output_compilation_unit_header ()\n   fputc ('\\n', asm_out_file);\n }\n \n-/* Extract the register and offset values from RTL.  If no register number\n-   is specified, return -1 to indicate frame-relative addressing.  */\n-static void\n-decode_cfi_rtl (rtl, regp, offsetp)\n-     register rtx rtl;\n-     register unsigned long *regp;\n-     register long *offsetp;\n+/* Generate a new label for the CFI info to refer to.  */\n+\n+char *\n+dwarf2out_cfi_label ()\n {\n-  switch (GET_CODE (rtl))\n-    {\n-    case REG:\n-      *regp = reg_number (rtl);\n-      *offsetp = 0;\n-      break;\n-    case PLUS:\n-      *regp = reg_number (XEXP (rtl, 0));\n-      *offsetp = INTVAL (XEXP (rtl, 1));\n-      break;\n-    case CONST_INT:\n-      *regp = (unsigned long) -1;\n-      *offsetp = INTVAL (rtl);\n-      break;\n-    default:\n-      abort ();\n-    }\n+  static char label[20];\n+  static unsigned long label_num = 0;\n+  \n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LCFI\", label_num++);\n+  ASM_OUTPUT_LABEL (asm_out_file, label);\n+\n+  return label;\n }\n \n /* Add CFI to the current fde at the PC value indicated by LABEL if specified,\n    or to the CIE if LABEL is NULL.  */\n+\n static void\n add_fde_cfi (label, cfi)\n      register char * label;\n@@ -3668,6 +3728,8 @@ add_fde_cfi (label, cfi)\n   if (label)\n     {\n       register dw_fde_ref fde = &fde_table[fde_table_in_use - 1];\n+      if (*label == 0)\n+\tlabel = dwarf2out_cfi_label ();\n       if (fde->dw_fde_current_label == NULL\n \t  || strcmp (label, fde->dw_fde_current_label) != 0)\n \t{\n@@ -3730,20 +3792,20 @@ lookup_cfa (regp, offsetp)\n }\n \n /* Entry point to update the canonical frame address (CFA).\n-   LABEL is passed to add_fde_cfi.  RTL is either:\n+   LABEL is passed to add_fde_cfi.  The value of CFA is now to be\n+   calculated from REG+OFFSET.  */\n \n-   a REG:  The frame is at 0(REG).\n-   a PLUS of a REG and a CONST_INT:  The frame is at CONST(REG).  */\n void\n-dwarf2out_def_cfa (label, rtl)\n+dwarf2out_def_cfa (label, reg, offset)\n      register char * label;\n-     register rtx rtl;\n+     register unsigned reg;\n+     register long offset;\n {\n   register dw_cfi_ref cfi;\n-  unsigned long reg, old_reg;\n-  long offset, old_offset;\n+  unsigned old_reg;\n+  long old_offset;\n \n-  decode_cfi_rtl (rtl, &reg, &offset);\n+  reg = DWARF_FRAME_REGNUM (reg);\n   lookup_cfa (&old_reg, &old_offset);\n \n   if (reg == old_reg && offset == old_offset)\n@@ -3775,36 +3837,31 @@ dwarf2out_def_cfa (label, rtl)\n \n /* Add the CFI for saving a register.  REG is the CFA column number.\n    LABEL is passed to add_fde_cfi.\n-   RTL is either:\n+   If SREG is -1, the register is saved at OFFSET from the CFA;\n+   otherwise it is saved in SREG.  */\n \n-   a REG:  The register is saved in REG.\n-   a CONST_INT:  The register is saved at an offset of CONST\n-     from the CFA.  */\n static void\n-reg_save (label, reg, rtl)\n+reg_save (label, reg, sreg, offset)\n      register char * label;\n-     register unsigned long reg;\n-     register rtx rtl;\n+     register unsigned reg;\n+     register unsigned sreg;\n+     register long offset;\n {\n-  register dw_cfi_ref cfi;\n-  unsigned long sreg;\n-  long offset;\n-\n-  cfi = new_cfi ();\n+  register dw_cfi_ref cfi = new_cfi ();\n \n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n \n-  decode_cfi_rtl (rtl, &sreg, &offset);\n-  offset /= DWARF_CIE_DATA_ALIGNMENT;\n-\n-  if (sreg == (unsigned long) -1)\n+  if (sreg == -1)\n     {\n       if (reg & ~0x3f)\n \t/* The register number won't fit in 6 bits, so we have to use\n \t   the long form.  */\n \tcfi->dw_cfi_opc = DW_CFA_offset_extended;\n       else\n \tcfi->dw_cfi_opc = DW_CFA_offset;\n+\n+      offset /= DWARF_CIE_DATA_ALIGNMENT;\n+      assert (offset >= 0);\n       cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n     }\n   else\n@@ -3817,24 +3874,166 @@ reg_save (label, reg, rtl)\n }\n \n /* Entry point for saving a register.  REG is the GCC register number.\n-   LABEL and RTL are passed to reg_save.  */\n+   LABEL and OFFSET are passed to reg_save.  */\n+\n void\n-dwarf2out_reg_save (label, reg, rtl)\n+dwarf2out_reg_save (label, reg, offset)\n      register char * label;\n-     register unsigned long reg;\n+     register unsigned reg;\n+     register long offset;\n+{\n+  reg_save (label, DWARF_FRAME_REGNUM (reg), -1, offset);\n+}\n+\n+/* Record the initial position of the return address.  RTL is\n+   INCOMING_RETURN_ADDR_RTX.  */\n+\n+static void\n+initial_return_save (rtl)\n      register rtx rtl;\n {\n-  reg_save (label, DWARF_FRAME_REGNUM (reg), rtl);\n+  unsigned reg = -1;\n+  long offset = 0;\n+\n+  switch (GET_CODE (rtl))\n+    {\n+    case REG:\n+      /* RA is in a register.  */\n+      reg = reg_number (rtl);\n+      break;\n+    case MEM:\n+      /* RA is on the stack.  */\n+      rtl = XEXP (rtl, 0);\n+      switch (GET_CODE (rtl))\n+\t{\n+\tcase REG:\n+\t  assert (REGNO (rtl) == STACK_POINTER_REGNUM);\n+\t  offset = 0;\n+\t  break;\n+\tcase PLUS:\n+\t  assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n+\t  offset = INTVAL (XEXP (rtl, 1));\n+\t  break;\n+\tcase MINUS:\n+\t  assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n+\t  offset = -INTVAL (XEXP (rtl, 1));\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  reg_save (NULL, DWARF_FRAME_RETURN_COLUMN, reg, offset);\n }\n \n-/* Entry point for saving the return address.\n-   LABEL and RTL are passed to reg_save.  */\n+/* Record call frame debugging information for INSN, which either\n+   sets SP or FP (adjusting how we calculate the frame address) or saves a\n+   register to the stack.  If INSN is NULL_RTX, initialize our state.  */\n+\n void\n-dwarf2out_return_save (label, rtl)\n-     register char * label;\n-     register rtx rtl;\n+dwarf2out_frame_debug (insn)\n+     rtx insn;\n {\n-  reg_save (label, DWARF_FRAME_RETURN_COLUMN, rtl);\n+  char *label;\n+  rtx src, dest;\n+  long offset;\n+  static unsigned cfa_reg;\n+  static long cfa_offset;\n+  static long cfa_sp_offset;\n+\n+  if (insn == NULL_RTX)\n+    {\n+      /* Set up state for generating call frame debug info.  */\n+      cfa_reg = STACK_POINTER_REGNUM;\n+      cfa_offset = 0;\n+      cfa_sp_offset = 0;\n+      return;\n+    }\n+\n+  label = dwarf2out_cfi_label ();\n+    \n+  insn = PATTERN (insn);\n+  assert (GET_CODE (insn) == SET);\n+\n+  src = SET_SRC (insn);\n+  dest = SET_DEST (insn);\n+\n+  switch (GET_CODE (dest))\n+    {\n+    case REG:\n+      /* Update the CFA rule wrt SP or FP.  Make sure src is\n+\t relative to the current CFA register.  */\n+      assert (REGNO (dest) == STACK_POINTER_REGNUM\n+\t      || frame_pointer_needed && REGNO (dest) == FRAME_POINTER_REGNUM);\n+      switch (GET_CODE (src))\n+\t{\n+\t  /* Setting FP from SP.  */\n+\tcase REG:\n+\t  assert (cfa_reg == REGNO (src));\n+\t  cfa_reg = REGNO (dest);\n+\t  break;\n+\n+\t  /* Adjusting SP.  */\n+\tcase PLUS:\n+\t  cfa_sp_offset -= INTVAL (XEXP (src, 1));\n+\t  goto add;\n+\tcase MINUS:\n+\t  cfa_sp_offset += INTVAL (XEXP (src, 1));\n+\tadd:\n+\t  assert (REGNO (XEXP (src, 0)) == STACK_POINTER_REGNUM);\n+\t  if (cfa_reg == STACK_POINTER_REGNUM)\n+\t    cfa_offset = cfa_sp_offset;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      dwarf2out_def_cfa (label, cfa_reg, cfa_offset);\n+      break;\n+\n+    case MEM:\n+      /* Saving a register to the stack.  Make sure dest is relative to the\n+         CFA register.  */\n+      assert (GET_CODE (src) == REG);\n+      switch (GET_CODE (XEXP (dest, 0)))\n+\t{\n+\t  /* With a push.  */\n+\tcase PRE_DEC:\n+\t  cfa_sp_offset += GET_MODE_SIZE (GET_MODE (dest));\n+\t  goto pre;\n+\tcase PRE_INC:\n+\t  cfa_sp_offset -= GET_MODE_SIZE (GET_MODE (dest));\n+\tpre:\n+\t  assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM);\n+\t  if (cfa_reg == STACK_POINTER_REGNUM)\n+\t    cfa_offset = cfa_sp_offset;\n+\t  offset = -cfa_sp_offset;\n+\t  break;\n+\n+\t  /* With an offset.  */\n+\tcase PLUS:\n+\t  offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n+\t  goto off;\n+\tcase MINUS:\n+\t  offset = -INTVAL (XEXP (XEXP (dest, 0), 1));\n+\toff:\n+\t  assert (cfa_reg == REGNO (XEXP (XEXP (dest, 0), 0)));\n+\t  offset -= cfa_offset;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+      dwarf2out_def_cfa (label, cfa_reg, cfa_offset);\n+      dwarf2out_reg_save (label, REGNO (src), offset);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n }\n \n /* Return the size of a Call Frame Instruction.  */\n@@ -3952,9 +4151,8 @@ output_cfi (cfi, fde)\n \t\t\t      cfi->dw_cfi_opc\n \t\t\t      | (cfi->dw_cfi_oprnd1.dw_cfi_offset & 0x3f));\n       if (flag_verbose_asm)\n-\t{\n-\t  fprintf (asm_out_file, \"\\t%s DW_CFA_advance_loc\", ASM_COMMENT_START);\n-\t}\n+\tfprintf (asm_out_file, \"\\t%s DW_CFA_advance_loc 0x%x\",\n+\t\t ASM_COMMENT_START, cfi->dw_cfi_oprnd1.dw_cfi_offset);\n       fputc ('\\n', asm_out_file);\n     }\n   else if (cfi->dw_cfi_opc == DW_CFA_offset)\n@@ -3963,9 +4161,8 @@ output_cfi (cfi, fde)\n \t\t\t      cfi->dw_cfi_opc\n \t\t\t      | (cfi->dw_cfi_oprnd1.dw_cfi_reg_num & 0x3f));\n       if (flag_verbose_asm)\n-\t{\n-\t  fprintf (asm_out_file, \"\\t%s DW_CFA_offset\", ASM_COMMENT_START);\n-\t}\n+\tfprintf (asm_out_file, \"\\t%s DW_CFA_offset, column 0x%x\",\n+\t\t ASM_COMMENT_START, cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n       fputc ('\\n', asm_out_file);\n       output_uleb128(cfi->dw_cfi_oprnd2.dw_cfi_offset);\n       fputc ('\\n', asm_out_file);\n@@ -3976,9 +4173,8 @@ output_cfi (cfi, fde)\n \t\t\t      cfi->dw_cfi_opc\n \t\t\t      | (cfi->dw_cfi_oprnd1.dw_cfi_reg_num & 0x3f));\n       if (flag_verbose_asm)\n-\t{\n-\t  fprintf (asm_out_file, \"\\t%s DW_CFA_restore\", ASM_COMMENT_START);\n-\t}\n+\tfprintf (asm_out_file, \"\\t%s DW_CFA_restore, column 0x%x\",\n+\t\t ASM_COMMENT_START, cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n       fputc ('\\n', asm_out_file);\n     }\n   else\n@@ -5534,12 +5730,54 @@ add_const_value_attribute (die, rtl)\n       /* Note that a CONST_DOUBLE rtx could represent either an integer or a\n          floating-point constant.  A CONST_DOUBLE is used whenever the\n          constant requires more than one word in order to be adequately\n-         represented.  In all such cases, the original mode of the constant\n-         value is preserved as the mode of the CONST_DOUBLE rtx, but for\n-         simplicity we always just output CONST_DOUBLEs using 8 bytes.  */\n-      add_AT_double (die, DW_AT_const_value,\n-\t\t     (unsigned) CONST_DOUBLE_HIGH (rtl),\n-\t\t     (unsigned) CONST_DOUBLE_LOW (rtl));\n+         represented.  We output CONST_DOUBLEs as blocks.  */\n+      {\n+\tregister enum machine_mode mode = GET_MODE (rtl);\n+\n+\tif (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t  {\n+\t    union real_extract u;\n+\t    jmp_buf handler;\n+\t    register unsigned length = GET_MODE_SIZE (mode) / 4;\n+\t    register long *array = (long *) xmalloc (length * sizeof (long));\n+\t    \n+\t    bcopy ((char *) &CONST_DOUBLE_LOW (rtl), (char *) &u, sizeof u);\n+\n+\t    if (setjmp (handler))\n+\t      {\n+\t\terror (\"floating point trap outputting debug info\");\n+\t\tu.d = dconst0;\n+\t      }\n+\n+\t    set_float_handler (handler);\n+\n+\t    switch (mode)\n+\t      {\n+\t      case SFmode:\n+\t\tREAL_VALUE_TO_TARGET_SINGLE (u.d, array[0]);\n+\t\tbreak;\n+\n+\t      case DFmode:\n+\t\tREAL_VALUE_TO_TARGET_DOUBLE (u.d, array);\n+\t\tbreak;\n+\n+\t      case XFmode:\n+\t      case TFmode:\n+\t\tREAL_VALUE_TO_TARGET_LONG_DOUBLE (u.d, array);\n+\t\tbreak;\n+\n+\t      default:\n+\t\tabort ();\n+\t      }\n+\n+\t    set_float_handler (NULL_PTR);\n+\n+\t    add_AT_float (die, DW_AT_const_value, length, array);\n+\t  }\n+\telse\n+\t  add_AT_long_long (die, DW_AT_const_value,\n+\t\t\t    CONST_DOUBLE_HIGH (rtl), CONST_DOUBLE_LOW (rtl));\n+      }\n       break;\n \n     case CONST_STRING:\n@@ -8043,59 +8281,6 @@ dwarf2out_begin_prologue ()\n   fde->dw_fde_cfi = NULL;\n }\n \n-/* Output a marker (i.e. a label) for the point in the generated code where\n-   the real body of the function begins (after parameters have been moved to\n-   their home locations).  */\n-void\n-dwarf2out_begin_function ()\n-{\n-#ifdef MIPS_DEBUGGING_INFO\n-  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  register long int offset;\n-  register dw_fde_ref fde;\n-  register dw_cfi_ref cfi;\n-  register int regno, fp_inc;\n-\n-  function_section (current_function_decl);\n-  ASM_GENERATE_INTERNAL_LABEL (label, BODY_BEGIN_LABEL,\n-\t\t\t       current_funcdef_number);\n-  ASM_OUTPUT_LABEL (asm_out_file, label);\n-\n-  /* Define the CFA as an offset from either the frame pointer\n-     or the stack pointer.  */\n-  dwarf2out_def_cfa\n-    (label, gen_rtx (PLUS, VOIDmode,\n-\t\t     gen_rtx (REG, VOIDmode,\n-\t\t\t      (frame_pointer_needed ? FRAME_POINTER_REGNUM\n-\t\t\t       : STACK_POINTER_REGNUM)),\n-\t\t     GEN_INT (current_frame_info.total_size)));\n-\n-  /* Record the locations of the return address and any callee-saved regs.  */\n-  offset = current_frame_info.gp_save_offset / DWARF_CIE_DATA_ALIGNMENT;\n-  for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; --regno)\n-    if (current_frame_info.mask & (1<<regno))\n-      {\n-\tassert (offset >= 0);\n-\n-\tif (regno == 31)\n-\t  dwarf2out_return_save (label, GEN_INT (offset));\n-\telse\n-\t  dwarf2out_reg_save (label, regno, GEN_INT (offset));\n-\toffset -= UNITS_PER_WORD / DWARF_CIE_DATA_ALIGNMENT;\n-      }\n-\n-  fp_inc = (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT) ? 1 : 2;\n-  offset = current_frame_info.fp_save_offset / DWARF_CIE_DATA_ALIGNMENT;\n-  for (regno = FP_REG_LAST - 1; regno >= FP_REG_FIRST; regno -= fp_inc)\n-    if (current_frame_info.fmask & (1 << (regno - FP_REG_FIRST)))\n-      {\n-\tassert (offset >= 0);\n-\tdwarf2out_reg_save (label, regno, GEN_INT (offset));\n-\toffset -= (fp_inc * UNITS_PER_FPREG) / DWARF_CIE_DATA_ALIGNMENT;\n-      }\n-#endif\n-}\n-\n /* Output a marker (i.e. a label) for the absolute end of the generated code\n    for a function definition.  This gets called *after* the epilogue code has\n    been generated.  */\n@@ -8336,12 +8521,11 @@ dwarf2out_init (asm_out_file, main_input_filename)\n \n   /* Generate the CFA instructions common to all FDE's.  Do it now for the\n      sake of lookup_cfa.  */\n-#ifdef MIPS_DEBUGGING_INFO\n-  /* On entry, the Call Frame Address is in the stack pointer register.  */\n-  dwarf2out_def_cfa (NULL, gen_rtx (REG, VOIDmode, STACK_POINTER_REGNUM));\n \n-  /* Set the RA on entry to be the contents of r31.  */\n-  dwarf2out_return_save (NULL, gen_rtx (REG, VOIDmode, GP_REG_FIRST + 31));\n+#ifdef INCOMING_RETURN_ADDR_RTX\n+  /* On entry, the Canonical Frame Address is at SP+0.  */\n+  dwarf2out_def_cfa (NULL, STACK_POINTER_REGNUM, 0);\n+  initial_return_save (INCOMING_RETURN_ADDR_RTX);\n #endif\n }\n "}, {"sha": "cc5bedf185103c0fb8ef86a4947230fe3484d37d", "filename": "gcc/final.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=469ac9939bb1bec320f7b3814de1f62423ea219a", "patch": "@@ -1208,6 +1208,10 @@ final (first, file, optimize, prescan)\n   last_ignored_compare = 0;\n   new_block = 1;\n \n+#if defined (DWARF2_DEBUGGING_INFO) && defined (HAVE_prologue)\n+  dwarf2out_frame_debug (NULL_RTX);\n+#endif\n+\n   check_exception_handler_labels ();\n \n   /* Make a map indicating which line numbers appear in this function.\n@@ -1369,12 +1373,6 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t     must be after the prologue.  */\n \t  if (write_symbols == DWARF_DEBUG)\n \t    dwarfout_begin_function ();\n-#endif\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t  /* This outputs a marker where the function body starts, so it\n-\t     must be after the prologue.  */\n-\t  if (write_symbols == DWARF2_DEBUG)\n-\t    dwarf2out_begin_function ();\n #endif\n \t  break;\n \t}\n@@ -2104,6 +2102,13 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n \toutput_asm_insn (template, recog_operand);\n \n+#if defined (DWARF2_DEBUGGING_INFO) && defined (HAVE_prologue)\n+\t/* If this insn is part of the prologue, emit DWARF v2\n+\t   call frame info.  */\n+\tif (write_symbols == DWARF2_DEBUG && RTX_FRAME_RELATED_P (insn))\n+\t  dwarf2out_frame_debug (insn);\n+#endif\n+\n #if 0\n \t/* It's not at all clear why we did this and doing so interferes\n \t   with tests we'd like to do to use REG_WAS_0 notes, so let's try"}, {"sha": "83e3cc040d50625feb0f1d5c3cd01c89ddc6d9f4", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/469ac9939bb1bec320f7b3814de1f62423ea219a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=469ac9939bb1bec320f7b3814de1f62423ea219a", "patch": "@@ -140,6 +140,10 @@ typedef struct rtx_def\n      In a REG, nonzero means this reg refers to the return value\n      of the current function.  */\n   unsigned integrated : 1;\n+  /* Nonzero if this rtx is related to the call frame, either changing how\n+     we compute the frame address or saving and restoring registers in\n+     the prologue and epilogue.  */\n+  unsigned frame_related : 1;\n   /* The first element of the operands of this rtx.\n      The number of operands and their types are controlled\n      by the `code' field, according to rtl.def.  */\n@@ -165,6 +169,7 @@ typedef struct rtx_def\n \n #define RTX_INTEGRATED_P(RTX) ((RTX)->integrated)\n #define RTX_UNCHANGING_P(RTX) ((RTX)->unchanging)\n+#define RTX_FRAME_RELATED_P(RTX) ((RTX)->frame_related)\n \n /* RTL vector.  These appear inside RTX's when there is a need\n    for a variable number of things.  The principle use is inside"}]}