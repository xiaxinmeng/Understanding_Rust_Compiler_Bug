{"sha": "399eeef9786cb661aa86981ee9e7a9f3dec373d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk5ZWVlZjk3ODZjYjY2MWFhODY5ODFlZTllN2E5ZjNkZWMzNzNkNg==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-08-03T14:32:54Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-08-03T14:32:54Z"}, "message": "Implement bracket expression.\n\n2013-08-03  Tim Shen  <timshen91@gmail.com>\n\n\tImplement bracket expression.\n\t* include/bits/regex.h: Remove constexpr from \"|=\", etc.\n\t* include/bits/regex_compiler.h: Parse bracket expression.\n\t* include/bits/regex_nfa.h: _Comparator and _BracketMatcher(old\n\t_RangeMatcher).\n\t* include/bits/regex_nfa.tcc: Implement them.\n\t* testsuite/28_regex/algorithms/regex_match/extended/53622.cc:\n\tfrom regex_search to regex_match.\n\t* testsuite/28_regex/algorithms/regex_match/extended/\n\tcstring_bracket_01.cc: New.\n\nFrom-SVN: r201465", "tree": {"sha": "cd6382282eec0df5837cd32d833217284b86cf42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd6382282eec0df5837cd32d833217284b86cf42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/399eeef9786cb661aa86981ee9e7a9f3dec373d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/399eeef9786cb661aa86981ee9e7a9f3dec373d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/399eeef9786cb661aa86981ee9e7a9f3dec373d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/399eeef9786cb661aa86981ee9e7a9f3dec373d6/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cdaa808aedfc4b5363197ac119ef976a5d66e5a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdaa808aedfc4b5363197ac119ef976a5d66e5a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdaa808aedfc4b5363197ac119ef976a5d66e5a4"}], "stats": {"total": 523, "additions": 331, "deletions": 192}, "files": [{"sha": "a1a690dd82fe3d1b8b16eb3c0db73ffd83934f19", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=399eeef9786cb661aa86981ee9e7a9f3dec373d6", "patch": "@@ -1,3 +1,16 @@\n+2013-08-03  Tim Shen  <timshen91@gmail.com>\n+\n+\tImplement bracket expression.\n+\t* include/bits/regex.h: Remove constexpr from \"|=\", etc.\n+\t* include/bits/regex_compiler.h: Parse bracket expression.\n+\t* include/bits/regex_nfa.h: _Comparator and _BracketMatcher(old\n+\t_RangeMatcher).\n+\t* include/bits/regex_nfa.tcc: Implement them.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/53622.cc:\n+\tfrom regex_search to regex_match.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/\n+\tcstring_bracket_01.cc: New.\n+\n 2013-08-02  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/debug/functions.h (__foreign_iterator_aux4):"}, {"sha": "fd8f1344ff20ad10fb970c347ff92164648d69b5", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=399eeef9786cb661aa86981ee9e7a9f3dec373d6", "patch": "@@ -95,15 +95,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           operator~() const\n           { return _RegexMask(~_M_base, ~_M_extended); }\n \n-          constexpr _RegexMask&\n+          _RegexMask&\n           operator&=(_RegexMask __other)\n           { return *this = (*this) & __other; }\n \n-          constexpr _RegexMask&\n+          _RegexMask&\n           operator|=(_RegexMask __other)\n           { return *this = (*this) | __other; }\n \n-          constexpr _RegexMask&\n+          _RegexMask&\n           operator^=(_RegexMask __other)\n           { return *this = (*this) ^ __other; }\n \n@@ -228,7 +228,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n               __fctyp.tolower(&*__v.begin(), &*__v.end());\n               return this->transform(&*__v.begin(), &*__v.end());\n             }\n-          __catch (...)\n+          __catch (std::bad_cast)\n             {\n             }\n           return string_type();\n@@ -519,7 +519,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         };\n \n       std::string __s(__last - __first, '?');\n-      string_type a(__first, __last);\n       __fctyp.narrow(__first, __last, '?', &*__s.begin());\n \n       for (unsigned int __i = 0; *__collatenames[__i]; __i++)"}, {"sha": "2cc9da1a110330fb352c945bce137687114cf231", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 113, "deletions": 160, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=399eeef9786cb661aa86981ee9e7a9f3dec373d6", "patch": "@@ -44,9 +44,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   {\n     typedef unsigned int _StateT;\n \n-    static constexpr _StateT _S_state_at_start    = 1 << 0;\n-    static constexpr _StateT _S_state_in_brace    = 1 << 2;\n-    static constexpr _StateT _S_state_in_bracket  = 1 << 3;\n+    static constexpr _StateT _S_state_in_brace    = 1 << 0;\n+    static constexpr _StateT _S_state_in_bracket  = 1 << 1;\n \n     virtual ~_Scanner_base() { };\n   };\n@@ -77,8 +76,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_token_anychar,\n \t_S_token_backref,\n \t_S_token_bracket_begin,\n+\t_S_token_bracket_inverse_begin,\n \t_S_token_bracket_end,\n-\t_S_token_inverse_class,\n \t_S_token_char_class_name,\n \t_S_token_closure0,\n \t_S_token_closure1,\n@@ -97,7 +96,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_S_token_opt,\n \t_S_token_or,\n \t_S_token_ord_char,\n-\t_S_token_quoted_char,\n \t_S_token_subexpr_begin,\n \t_S_token_subexpr_end,\n \t_S_token_word_begin,\n@@ -108,7 +106,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Scanner(_IteratorT __begin, _IteratorT __end, _FlagT __flags,\n \t       std::locale __loc)\n       : _M_current(__begin) , _M_end(__end) , _M_flags(__flags),\n-        _M_ctype(std::use_facet<_CtypeT>(__loc)), _M_state(_S_state_at_start)\n+        _M_ctype(std::use_facet<_CtypeT>(__loc)), _M_state(0)\n       { _M_advance(); }\n \n       void\n@@ -219,9 +217,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       else if (__c == _M_ctype.widen('['))\n \t{\n-\t  _M_curToken = _S_token_bracket_begin;\n-\t  _M_state |= (_S_state_in_bracket | _S_state_at_start);\n-\t  ++_M_current;\n+          if (*++_M_current == _M_ctype.widen('^'))\n+            {\n+              _M_curToken = _S_token_bracket_inverse_begin;\n+              ++_M_current;\n+            }\n+          else\n+            _M_curToken = _S_token_bracket_begin;\n+\t  _M_state |= _S_state_in_bracket;\n \t  return;\n \t}\n       else if (__c == _M_ctype.widen('\\\\'))\n@@ -304,14 +307,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Scanner<_InputIterator>::\n     _M_scan_in_bracket()\n     {\n-      if (_M_state & _S_state_at_start && *_M_current == _M_ctype.widen('^'))\n-\t{\n-\t  _M_curToken = _S_token_inverse_class;\n-\t  _M_state &= ~_S_state_at_start;\n-\t  ++_M_current;\n-\t  return;\n-\t}\n-      else if (*_M_current == _M_ctype.widen('['))\n+      if (*_M_current == _M_ctype.widen('['))\n \t{\n \t  ++_M_current;\n \t  if (_M_current == _M_end)\n@@ -347,21 +343,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       else if (*_M_current == _M_ctype.widen(']'))\n \t{\n-\t  if (!(_M_flags & regex_constants::ECMAScript)\n-\t      || !(_M_state & _S_state_at_start))\n-\t    {\n-\t      // special case: only if  _not_ chr first after\n-\t      // '[' or '[^' and if not ECMAscript\n-\t      _M_curToken = _S_token_bracket_end;\n-\t      ++_M_current;\n-\t      return;\n-\t    }\n+          _M_curToken = _S_token_bracket_end;\n+          _M_state &= ~_S_state_in_bracket;\n+          ++_M_current;\n+          return;\n \t}\n+      else if (*_M_current == _M_ctype.widen('\\\\'))\n+        {\n+\t  _M_eat_escape();\n+\t  return;\n+        }\n       _M_curToken = _S_token_collelem_single;\n       _M_curValue.assign(1, *_M_current);\n       ++_M_current;\n     }\n \n+  // TODO implement it.\n   template<typename _InputIterator>\n     void\n     _Scanner<_InputIterator>::\n@@ -463,11 +460,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_curToken = _S_token_backref;\n \t  _M_curValue.assign(1, __c);\n \t}\n+      else if (_M_state & _S_state_in_bracket)\n+        {\n+          if (__c == _M_ctype.widen('-')\n+              || __c == _M_ctype.widen('[')\n+              || __c == _M_ctype.widen(']'))\n+            {\n+              _M_curToken = _S_token_ord_char;\n+              _M_curValue.assign(1, __c);\n+            }\n+          else if ((_M_flags & regex_constants::ECMAScript)\n+                   && __c == _M_ctype.widen('b'))\n+            {\n+              _M_curToken = _S_token_ord_char;\n+              _M_curValue.assign(1, _M_ctype.widen(' '));\n+            }\n+          else\n+            __throw_regex_error(regex_constants::error_escape);\n+        }\n       else\n \t__throw_regex_error(regex_constants::error_escape);\n     }\n \n-\n   // Eats a character class or throwns an exception.\n   // current point to ':' delimiter on entry, char after ']' on return\n   template<typename _InputIterator>\n@@ -549,6 +563,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tcase _S_token_bracket_begin:\n \t  ostr << \"bracket-begin\\n\";\n \t  break;\n+\tcase _S_token_bracket_inverse_begin:\n+          ostr << \"bracket-inverse-begin\\n\";\n+          break;\n \tcase _S_token_bracket_end:\n \t  ostr << \"bracket-end\\n\";\n \t  break;\n@@ -606,9 +623,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tcase _S_token_ord_char:\n \t  ostr << \"ordinary character: \\\"\" << _M_value() << \"\\\"\\n\";\n \t  break;\n-\tcase _S_token_quoted_char:\n-\t  ostr << \"quoted char\\n\";\n-\t  break;\n \tcase _S_token_subexpr_begin:\n \t  ostr << \"subexpr begin\\n\";\n \t  break;\n@@ -624,6 +638,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tcase _S_token_unknown:\n \t  ostr << \"-- unknown token --\\n\";\n \t  break;\n+        default:\n+          _GLIBCXX_DEBUG_ASSERT(false);\n       }\n       return ostr;\n     }\n@@ -650,7 +666,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Scanner<_InIter>                              _ScannerT;\n       typedef typename _ScannerT::_TokenT                    _TokenT;\n       typedef std::stack<_StateSeq, std::vector<_StateSeq> > _StackT;\n-      typedef _RangeMatcher<_InIter, _TraitsT>               _RMatcherT;\n+      typedef _BracketMatcher<_InIter, _TraitsT>             _BMatcherT;\n \n       // accepts a specific token or returns false.\n       bool\n@@ -659,7 +675,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_disjunction();\n \n-      bool\n+      void\n       _M_alternative();\n \n       bool\n@@ -668,7 +684,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_assertion();\n \n-      bool\n+      void\n       _M_quantifier();\n \n       bool\n@@ -678,31 +694,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_bracket_expression();\n \n       bool\n-      _M_bracket_list(_RMatcherT& __matcher);\n+      _M_bracket_list(_BMatcherT& __matcher);\n \n       bool\n-      _M_follow_list(_RMatcherT& __matcher);\n+      _M_follow_list(_BMatcherT& __matcher);\n \n-      bool\n-      _M_follow_list2(_RMatcherT& __matcher);\n-\n-      bool\n-      _M_expression_term(_RMatcherT& __matcher);\n+      void\n+      _M_expression_term(_BMatcherT& __matcher);\n \n       bool\n-      _M_range_expression(_RMatcherT& __matcher);\n+      _M_range_expression(_BMatcherT& __matcher);\n \n       bool\n-      _M_start_range(_RMatcherT& __matcher);\n+      _M_start_range(_BMatcherT& __matcher);\n \n       bool\n-      _M_collating_symbol(_RMatcherT& __matcher);\n+      _M_collating_symbol(_BMatcherT& __matcher);\n \n       bool\n-      _M_equivalence_class(_RMatcherT& __matcher);\n+      _M_equivalence_class(_BMatcherT& __matcher);\n \n       bool\n-      _M_character_class(_RMatcherT& __matcher);\n+      _M_character_class(_BMatcherT& __matcher);\n \n       int\n       _M_cur_int_value(int __radix);\n@@ -712,14 +725,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _StringT       _M_cur_value;\n       _Nfa           _M_state_store;\n       _StackT        _M_stack;\n+      _FlagT         _M_flags;\n     };\n \n   template<typename _InIter, typename _TraitsT>\n     _Compiler<_InIter, _TraitsT>::\n     _Compiler(const _InIter& __b, const _InIter& __e, _TraitsT& __traits,\n \t      _Compiler<_InIter, _TraitsT>::_FlagT __flags)\n     : _M_traits(__traits), _M_scanner(__b, __e, __flags, _M_traits.getloc()),\n-      _M_state_store(__flags)\n+      _M_state_store(__flags), _M_flags(__flags)\n     {\n       typedef _StartTagger<_InIter, _TraitsT> _Start;\n       typedef _EndTagger<_InIter, _TraitsT> _End;\n@@ -743,8 +757,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { \n       if (token == _M_scanner._M_token())\n \t{\n-\t  _M_cur_value = _M_scanner._M_value();\n-\t  _M_scanner._M_advance();\n+          _M_cur_value = _M_scanner._M_value();\n+          _M_scanner._M_advance();\n \t  return true;\n \t}\n       return false;\n@@ -766,7 +780,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _InIter, typename _TraitsT>\n-    bool\n+    void\n     _Compiler<_InIter, _TraitsT>::\n     _M_alternative()\n     {\n@@ -780,9 +794,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      _M_stack.pop();\n \t    }\n \t  _M_stack.push(__re);\n-\t  return true;\n \t}\n-      return false;\n     }\n \n   template<typename _InIter, typename _TraitsT>\n@@ -829,7 +841,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _InIter, typename _TraitsT>\n-    bool\n+    void\n     _Compiler<_InIter, _TraitsT>::\n     _M_quantifier()\n     {\n@@ -841,7 +853,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __r._M_append(__r._M_front());\n \t  _M_stack.pop();\n \t  _M_stack.push(__r);\n-\t  return true;\n+\t  return;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_closure1))\n \t{\n@@ -852,7 +864,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t_M_insert_alt(_S_invalid_state_id,\n \t\t\t\t      _M_stack.top()._M_front()));\n \t  _M_stack.top()._M_append(__r);\n-\t  return true;\n+\t  return;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_opt))\n \t{\n@@ -861,7 +873,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _StateSeq __r(_M_stack.top(), -1);\n \t  _M_stack.pop();\n \t  _M_stack.push(__r);\n-\t  return true;\n+\t  return;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_interval_begin))\n \t{\n@@ -897,9 +909,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      }\n \t  if (!_M_match_token(_ScannerT::_S_token_interval_end))\n \t    __throw_regex_error(regex_constants::error_brace);\n-\t  return true;\n+\t  return;\n \t}\n-      return false;\n     }\n \n   template<typename _InIter, typename _TraitsT>\n@@ -922,15 +933,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  _M_stack.push(_StateSeq(_M_state_store,\n                                   _M_state_store._M_insert_matcher\n-                                  (_CMatcher(_M_cur_value[0], _M_traits))));\n-\t  return true;\n-\t}\n-      if (_M_match_token(_ScannerT::_S_token_quoted_char))\n-\t{\n-\t  // note that in the ECMA grammar, this case covers backrefs.\n-\t  _M_stack.push(_StateSeq(_M_state_store,\n-\t\t\t\t  _M_state_store._M_insert_matcher\n-\t\t\t\t  (_CMatcher(_M_cur_value[0], _M_traits))));\n+                                  (_CMatcher(_M_cur_value[0], _M_flags, _M_traits))));\n \t  return true;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_backref))\n@@ -966,124 +969,74 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _Compiler<_InIter, _TraitsT>::\n     _M_bracket_expression()\n     {\n-      if (_M_match_token(_ScannerT::_S_token_bracket_begin))\n-\t{\n-\t  _RMatcherT __matcher(_M_match_token(_ScannerT::_S_token_line_begin),\n-\t\t\t       _M_traits);\n-\t  if (!_M_bracket_list(__matcher)\n-\t      || !_M_match_token(_ScannerT::_S_token_bracket_end))\n-\t    __throw_regex_error(regex_constants::error_brack);\n-\t  _M_stack.push(_StateSeq(_M_state_store,\n-\t\t\t\t  _M_state_store._M_insert_matcher(__matcher)));\n-\t  return true;\n-\t}\n-      return false;\n-    }\n-\n-  // If the dash is the last character in the bracket expression, it is not\n-  // special.\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_bracket_list(_RMatcherT& __matcher)\n-    {\n-      if (_M_follow_list(__matcher))\n-\t{\n-\t  if (_M_match_token(_ScannerT::_S_token_dash))\n-\t    __matcher._M_add_char(_M_cur_value[0]);\n-\t  return true;\n-\t}\n-      return false;\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_follow_list(_RMatcherT& __matcher)\n-    { return _M_expression_term(__matcher) && _M_follow_list2(__matcher); }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_follow_list2(_RMatcherT& __matcher)\n-    {\n-      if (_M_expression_term(__matcher))\n-\treturn _M_follow_list2(__matcher);\n+      bool __inverse =\n+        _M_match_token(_ScannerT::_S_token_bracket_inverse_begin);\n+      if (!(__inverse || _M_match_token(_ScannerT::_S_token_bracket_begin)))\n+        return false;\n+      _BMatcherT __matcher( __inverse, _M_flags, _M_traits);\n+      // special case: only if  _not_ chr first after\n+      // '[' or '[^' or if ECMAscript\n+      if (!_M_bracket_list(__matcher) // list is empty\n+          && !(_M_flags & regex_constants::ECMAScript))\n+        __throw_regex_error(regex_constants::error_brack);\n+      _M_stack.push(_StateSeq(_M_state_store,\n+                              _M_state_store._M_insert_matcher(__matcher)));\n       return true;\n     }\n \n   template<typename _InIter, typename _TraitsT>\n-    bool\n+    bool // list is non-empty\n     _Compiler<_InIter, _TraitsT>::\n-    _M_expression_term(_RMatcherT& __matcher)\n+    _M_bracket_list(_BMatcherT& __matcher)\n     {\n-      return (_M_collating_symbol(__matcher)\n-\t      || _M_character_class(__matcher)\n-\t      || _M_equivalence_class(__matcher)\n-\t      || (_M_start_range(__matcher)\n-\t\t  && _M_range_expression(__matcher)));\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_range_expression(_RMatcherT& __matcher)\n-    {\n-      if (!_M_collating_symbol(__matcher))\n-\tif (!_M_match_token(_ScannerT::_S_token_dash))\n-\t  __throw_regex_error(regex_constants::error_range);\n-      __matcher._M_make_range();\n+      if (_M_match_token(_ScannerT::_S_token_bracket_end))\n+        return false;\n+      _M_expression_term(__matcher);\n+      _M_bracket_list(__matcher);\n       return true;\n     }\n \n   template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_start_range(_RMatcherT& __matcher)\n-    { return _M_match_token(_ScannerT::_S_token_dash); }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n+    void\n     _Compiler<_InIter, _TraitsT>::\n-    _M_collating_symbol(_RMatcherT& __matcher)\n+    _M_expression_term(_BMatcherT& __matcher)\n     {\n-      if (_M_match_token(_ScannerT::_S_token_collelem_single))\n-\t{\n-\t  __matcher._M_add_char(_M_cur_value[0]);\n-\t  return true;\n-\t}\n       if (_M_match_token(_ScannerT::_S_token_collsymbol))\n \t{\n \t  __matcher._M_add_collating_element(_M_cur_value);\n-\t  return true;\n+\t  return;\n \t}\n-      return false;\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_equivalence_class(_RMatcherT& __matcher)\n-    {\n       if (_M_match_token(_ScannerT::_S_token_equiv_class_name))\n \t{\n \t  __matcher._M_add_equivalence_class(_M_cur_value);\n-\t  return true;\n+\t  return;\n \t}\n-      return false;\n-    }\n-\n-  template<typename _InIter, typename _TraitsT>\n-    bool\n-    _Compiler<_InIter, _TraitsT>::\n-    _M_character_class(_RMatcherT& __matcher)\n-    {\n       if (_M_match_token(_ScannerT::_S_token_char_class_name))\n \t{\n \t  __matcher._M_add_character_class(_M_cur_value);\n-\t  return true;\n+\t  return;\n \t}\n-      return false;\n+      if (_M_match_token(_ScannerT::_S_token_collelem_single)) // [a\n+        {\n+          auto __ch = _M_cur_value[0];\n+          if (_M_match_token(_ScannerT::_S_token_dash)) // [a-\n+            {\n+              // If the dash is the last character in the bracket expression,\n+              // it is not special.\n+              if (_M_scanner._M_token() == _ScannerT::_S_token_bracket_end)\n+                __matcher._M_add_char(_M_cur_value[0]); // [a-] <=> [a\\-]\n+              else // [a-z]\n+                {\n+                  if (!_M_match_token(_ScannerT::_S_token_collelem_single))\n+                    __throw_regex_error(regex_constants::error_range);\n+                  __matcher._M_make_range(__ch, _M_cur_value[0]);\n+                }\n+            }\n+          else // [a]\n+            __matcher._M_add_char(__ch);\n+          return;\n+        }\n+      __throw_regex_error(regex_constants::error_brack);\n     }\n \n   template<typename _InIter, typename _TraitsT>"}, {"sha": "b4ac452fbaa3db4f15c77a3815195fb54cbe5f57", "filename": "libstdc++-v3/include/bits/regex_nfa.h", "status": "modified", "additions": 75, "deletions": 25, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h?ref=399eeef9786cb661aa86981ee9e7a9f3dec373d6", "patch": "@@ -129,6 +129,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       int       _M_index;\n     };\n \n+  // TODO For now we use an all-in-one comparator. In the future there may be\n+  // optimizations based on regex_traits::translate and regex_transform.\n+  template<typename _InIterT, typename _TraitsT>\n+    struct _Comparator\n+    {\n+      typedef regex_constants::syntax_option_type _FlagT;\n+      typedef typename _TraitsT::char_type        _CharT;\n+      typedef std::basic_string<_CharT>           _StringT;\n+\n+      _Comparator(_FlagT __flags, const _TraitsT& __traits)\n+      : _M_flags(__flags), _M_traits(__traits)\n+      { }\n+\n+      bool\n+      _M_equ(_CharT __a, _CharT __b) const;\n+\n+      bool\n+      _M_le(_CharT __a, _CharT __b) const;\n+\n+      _FlagT                              _M_flags;\n+      _TraitsT                            _M_traits;\n+    };\n+\n   /// Indicates if current state matches cursor current.\n   typedef std::function<bool (const _PatternCursor&)> _Matcher;\n \n@@ -140,68 +163,95 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// Matches a single character\n   template<typename _InIterT, typename _TraitsT>\n     struct _CharMatcher\n+    : public _Comparator<_InIterT, _TraitsT>\n     {\n-      typedef typename _TraitsT::char_type char_type;\n+      typedef _Comparator<_InIterT, _TraitsT>     _BaseT;\n+      typedef typename _TraitsT::char_type        _CharT;\n+      typedef regex_constants::syntax_option_type _FlagT;\n \n       explicit\n-      _CharMatcher(char_type __c, const _TraitsT& __t = _TraitsT())\n-      : _M_traits(__t), _M_c(_M_traits.translate(__c))\n+      _CharMatcher(_CharT __c, _FlagT __flags, const _TraitsT& __t)\n+      : _BaseT(__flags, __t), _M_c(__c)\n       { }\n \n       bool\n       operator()(const _PatternCursor& __pc) const\n       {\n \ttypedef const _SpecializedCursor<_InIterT>& _CursorT;\n \t_CursorT __c = static_cast<_CursorT>(__pc);\n-\treturn _M_traits.translate(__c._M_current()) == _M_c;\n+        return this->_M_equ(__c._M_current(), _M_c);\n       }\n \n-      const _TraitsT& _M_traits;\n-      char_type       _M_c;\n+      _CharT       _M_c;\n     };\n \n   /// Matches a character range (bracket expression)\n   template<typename _InIterT, typename _TraitsT>\n-    struct _RangeMatcher\n+    struct _BracketMatcher\n+    : public _Comparator<_InIterT, _TraitsT>\n     {\n-      typedef typename _TraitsT::char_type _CharT;\n-      typedef std::basic_string<_CharT>    _StringT;\n+      typedef _Comparator<_InIterT, _TraitsT>     _BaseT;\n+      typedef typename _TraitsT::char_class_type  _CharClassT;\n+      typedef regex_constants::syntax_option_type _FlagT;\n+      typedef typename _TraitsT::char_type        _CharT;\n+      typedef std::basic_string<_CharT>           _StringT;\n \n       explicit\n-      _RangeMatcher(bool __is_non_matching, const _TraitsT& __t = _TraitsT())\n-      : _M_traits(__t), _M_is_non_matching(__is_non_matching)\n+      _BracketMatcher(bool __is_non_matching,\n+                    _FlagT __flags,\n+                    const _TraitsT& __t)\n+      : _BaseT(__flags, __t), _M_flags(__flags), _M_traits(__t),\n+      _M_is_non_matching(__is_non_matching), _M_class_set(0)\n       { }\n \n       bool\n-      operator()(const _PatternCursor& __pc) const\n-      {\n-\ttypedef const _SpecializedCursor<_InIterT>& _CursorT;\n-\t_CursorT __c = static_cast<_CursorT>(__pc);\n-\treturn true;\n-      }\n+      operator()(const _PatternCursor& __pc) const;\n \n       void\n       _M_add_char(_CharT __c)\n-      { }\n+      { _M_char_set.push_back(__c); }\n \n       void\n       _M_add_collating_element(const _StringT& __s)\n-      { }\n+      {\n+        auto __st = _M_traits.lookup_collatename(&*__s.begin(), &*__s.end());\n+        if (__st.empty())\n+          __throw_regex_error(regex_constants::error_collate);\n+        // TODO: digraph\n+        _M_char_set.push_back(__st[0]);\n+      }\n \n       void\n       _M_add_equivalence_class(const _StringT& __s)\n-      { }\n+      {\n+        _M_add_character_class(\n+          _M_traits.transform_primary(&*__s.begin(), &*__s.end()));\n+      }\n \n       void\n       _M_add_character_class(const _StringT& __s)\n-      { }\n+      {\n+        auto __st = _M_traits.lookup_classname(\n+          &*__s.begin(), &*__s.end(), (_M_flags & regex_constants::icase));\n+        if (__st == 0)\n+          __throw_regex_error(regex_constants::error_ctype);\n+        _M_class_set |= __st;\n+      }\n \n       void\n-      _M_make_range()\n-      { }\n+      _M_make_range(_CharT __l, _CharT __r)\n+      {\n+        if (!this->_M_le(__l, __r))\n+          __throw_regex_error(regex_constants::error_range);\n+        _M_range_set.push_back(make_pair(__l, __r));\n+      }\n \n-      const _TraitsT& _M_traits;\n-      bool            _M_is_non_matching;\n+      _FlagT                              _M_flags;\n+      _TraitsT                            _M_traits;\n+      bool                                _M_is_non_matching;\n+      std::vector<_CharT>                 _M_char_set;\n+      std::vector<pair<_CharT, _CharT>>   _M_range_set;\n+      _CharClassT                         _M_class_set;\n     };\n \n   /// Identifies a state in the NFA."}, {"sha": "12f6fe825a541345ffeedc4b38a83870a9e6d2c0", "filename": "libstdc++-v3/include/bits/regex_nfa.tcc", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.tcc?ref=399eeef9786cb661aa86981ee9e7a9f3dec373d6", "patch": "@@ -35,6 +35,64 @@ namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n+  template<typename _InIterT, typename _TraitsT>\n+    bool _BracketMatcher<_InIterT, _TraitsT>::\n+    operator()(const _PatternCursor& __pc) const\n+    {\n+      typedef const _SpecializedCursor<_InIterT>& _CursorT;\n+      _CursorT __c = static_cast<_CursorT>(__pc);\n+      _CharT __ch = __c._M_current();\n+      bool __ret = false;\n+      for (auto __c : _M_char_set)\n+        if (this->_M_equ(__c, __ch))\n+          {\n+            __ret = true;\n+            break;\n+          }\n+      if (!__ret && _M_traits.isctype(__ch, _M_class_set))\n+        __ret = true;\n+      else\n+        {\n+          for (auto& __it : _M_range_set)\n+            if (this->_M_le(__it.first, __ch) && this->_M_le(__ch, __it.second))\n+              {\n+                __ret = true;\n+                break;\n+              }\n+        }\n+      if (_M_is_non_matching)\n+        __ret = !__ret;\n+      return __ret;\n+    }\n+\n+  template<typename _InIterT, typename _TraitsT>\n+    bool _Comparator<_InIterT, _TraitsT>::\n+    _M_equ(_CharT __a, _CharT __b) const\n+    {\n+      if (_M_flags & regex_constants::icase)\n+        return _M_traits.translate_nocase(__a)\n+          == _M_traits.translate_nocase(__b);\n+      if (_M_flags & regex_constants::collate)\n+        return _M_traits.translate(__a) == _M_traits.translate(__b);\n+      return __a == __b;\n+    }\n+\n+  template<typename _InIterT, typename _TraitsT>\n+    bool _Comparator<_InIterT, _TraitsT>::\n+    _M_le(_CharT __a, _CharT __b) const\n+    {\n+      _StringT __str1 = _StringT(1,\n+                                 _M_flags & regex_constants::icase\n+                                 ? _M_traits.translate_nocase(__a)\n+                                 : _M_traits.translate(__a));\n+      _StringT __str2 = _StringT(1,\n+                                 _M_flags & regex_constants::icase\n+                                 ? _M_traits.translate_nocase(__b)\n+                                 : _M_traits.translate(__b));\n+      return _M_traits.transform(__str1.begin(), __str1.end())\n+        <= _M_traits.transform(__str2.begin(), __str2.end());\n+    }\n+\n #ifdef _GLIBCXX_DEBUG\n inline std::ostream& _State::\n _M_print(std::ostream& ostr) const"}, {"sha": "aee1dbe15dcb1f40ca901eabe34e7d348e816c8a", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/53622.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F53622.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F53622.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F53622.cc?ref=399eeef9786cb661aa86981ee9e7a9f3dec373d6", "patch": "@@ -37,7 +37,7 @@ test01()\n     std::string target(\"zxcv/onetwoabc\");\n     std::smatch m;\n \n-    VERIFY( std::regex_search(target, m, re) );\n+    VERIFY( std::regex_match(target, m, re) );\n     VERIFY( m.size() == 2 );\n     VERIFY( m[0].matched == true );\n     VERIFY( std::string(m[0].first, m[0].second) == \"zxcv/onetwoabc\" );\n@@ -50,7 +50,7 @@ test01()\n     std::string target(\"zxcv/onetwoabc\");\n     std::smatch m;\n \n-    VERIFY( std::regex_search(target, m, re) );\n+    VERIFY( std::regex_match(target, m, re) );\n     VERIFY( m.size() == 3 );\n     VERIFY( m[0].matched == true );\n     VERIFY( std::string(m[0].first, m[0].second) == \"zxcv/onetwoabc\" );"}, {"sha": "3a4ff31f104323bc4cc1aab3523aa12aacd70310", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/cstring_bracket_01.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_bracket_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399eeef9786cb661aa86981ee9e7a9f3dec373d6/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_bracket_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fcstring_bracket_01.cc?ref=399eeef9786cb661aa86981ee9e7a9f3dec373d6", "patch": "@@ -0,0 +1,66 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-08-01  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests Extended bracket expression against a C-string.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  {\n+    std::regex  re(\"pre/[za-x]\", std::regex::extended);\n+    VERIFY( std::regex_match(\"pre/z\", re) );\n+    VERIFY( std::regex_match(\"pre/a\", re) );\n+    VERIFY( !std::regex_match(\"pre/y\", re) );\n+  }\n+  {\n+    std::regex  re(\"pre/[[:uPPer:]]\", std::regex::extended);\n+    VERIFY( std::regex_match(\"pre/Z\", re) );\n+    VERIFY( !std::regex_match(\"pre/_\", re) );\n+    VERIFY( !std::regex_match(\"pre/a\", re) );\n+    VERIFY( !std::regex_match(\"pre/0\", re) );\n+  }\n+  {\n+    std::regex  re(\"pre/[[:lOWer:]]\", std::regex::extended | std::regex::icase);\n+    VERIFY( std::regex_match(\"pre/Z\", re) );\n+    VERIFY( std::regex_match(\"pre/a\", re) );\n+  }\n+  {\n+    std::regex  re(\"pre/[[:w:][.tilde.]]\", std::regex::extended);\n+    VERIFY( std::regex_match(\"pre/~\", re) );\n+    VERIFY( std::regex_match(\"pre/_\", re) );\n+    VERIFY( std::regex_match(\"pre/a\", re) );\n+    VERIFY( std::regex_match(\"pre/0\", re) );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}