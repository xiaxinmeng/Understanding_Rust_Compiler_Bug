{"sha": "d7f5de76fdc534c7eb7bb532b212936665ec2080", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdmNWRlNzZmZGM1MzRjN2ViN2JiNTMyYjIxMjkzNjY2NWVjMjA4MA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-05-24T22:55:15Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-05-24T22:55:15Z"}, "message": "re PR tree-optimization/27639 (VRP miscompilation of simple loop)\n\n\tPR tree-optimization/27639\n\tPR tree-optimization/26719\n\t* tree-vrp.c (adjust_range_with_scev): Use scev_direction and adjust\n\tcall to scev_probably_wraps_p.\n\t* tree-ssa-loop-niter.c (compare_trees, convert_step_widening,\n\tused_in_pointer_arithmetic_p, convert_step): Removed.\n\t(nowrap_type_p): New function.\n\t(scev_probably_wraps_p): Rewritten.\n\t* tree-scalar-evolution.c (instantiate_parameters_1): Do not call\n\tchrec_convert if chrec_convert_aggressive might have been used.\n\t* tree-chrec.c (convert_affine_scev, chrec_convert_1,\n\tscev_direction): New functions.\n\t(chrec_convert): Changed to a wrapper over chrec_convert_1.\n\t* tree-ssa-loop-ivopts.c (idx_find_step): Use convert_affine_scev\n\tinstead of convert_step.\n\t* tree-flow.h (scev_probably_wraps_p): Declaration changed.\n\t(convert_step): Declaration removed.\n\t(convert_affine_scev, nowrap_type_p, scev_direction): Declare.\n\n\t* gcc.dg/pr27639.c: New test.\n\t* gcc.dg/pr26719.c: New test.\n\t* gcc.dg/tree-ssa/scev-cast.c: New test.\n\nFrom-SVN: r114057", "tree": {"sha": "1cb568e88ce4a846caaddba12bd18eb12329f4b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cb568e88ce4a846caaddba12bd18eb12329f4b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7f5de76fdc534c7eb7bb532b212936665ec2080", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7f5de76fdc534c7eb7bb532b212936665ec2080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7f5de76fdc534c7eb7bb532b212936665ec2080", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7f5de76fdc534c7eb7bb532b212936665ec2080/comments", "author": null, "committer": null, "parents": [{"sha": "91f8ce668b14d42e1bcbead322f869009fc896f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f8ce668b14d42e1bcbead322f869009fc896f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91f8ce668b14d42e1bcbead322f869009fc896f0"}], "stats": {"total": 692, "additions": 321, "deletions": 371}, "files": [{"sha": "84396394252352acd7e2c436839fe39008f052e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -1,6 +1,27 @@\n+2006-05-24  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/27639\n+\tPR tree-optimization/26719\n+\t* tree-vrp.c (adjust_range_with_scev): Use scev_direction and adjust\n+\tcall to scev_probably_wraps_p.\n+\t* tree-ssa-loop-niter.c (compare_trees, convert_step_widening,\n+\tused_in_pointer_arithmetic_p, convert_step): Removed.\n+\t(nowrap_type_p): New function.\n+\t(scev_probably_wraps_p): Rewritten.\n+\t* tree-scalar-evolution.c (instantiate_parameters_1): Do not call\n+\tchrec_convert if chrec_convert_aggressive might have been used.\n+\t* tree-chrec.c (convert_affine_scev, chrec_convert_1,\n+\tscev_direction): New functions.\n+\t(chrec_convert): Changed to a wrapper over chrec_convert_1.\n+\t* tree-ssa-loop-ivopts.c (idx_find_step): Use convert_affine_scev\n+\tinstead of convert_step.\n+\t* tree-flow.h (scev_probably_wraps_p): Declaration changed.\n+\t(convert_step): Declaration removed.\n+\t(convert_affine_scev, nowrap_type_p, scev_direction): Declare.\n+\n 2006-05-23  Kenneth Zadeck <zadeck@naturalbridge.com>\n \n-        * df-core.c: Added to header comments.\n+\t* df-core.c: Added to header comments.\n \t* df.h (df_ru_bb_info, df_rd_bb_info, df_lr_bb_info,\n \tdf_ur_bb_info, df_urec_bb_info): Added comments.\n \t* df-problems (df_ref_bitmap, ru, rd, lr, ur, \n@@ -107,7 +128,7 @@\n \t* modulo-sched.c (sms_schedule, tree_opt_pass pass_sms): Enhanced\n \tdebug info.       \n \t* ddg.c (add_deps_for_def): Converted use of reaching defs to\n-        reaching uses and fixed space problem.\n+\treaching uses and fixed space problem.\n \n 2006-05-23  Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "89347e0fe901408319c301bcb7e996ba0749b46e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -1,3 +1,11 @@\n+2006-05-24  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/27639\n+\tPR tree-optimization/26719\n+\t* gcc.dg/pr27639.c: New test.\n+\t* gcc.dg/pr26719.c: New test.\n+\t* gcc.dg/tree-ssa/scev-cast.c: New test.\n+\n 2006-05-23  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/20173"}, {"sha": "3c87df17bb87a31f8fc54e176262d66a6944e518", "filename": "gcc/testsuite/gcc.dg/pr26719.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftestsuite%2Fgcc.dg%2Fpr26719.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftestsuite%2Fgcc.dg%2Fpr26719.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr26719.c?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+void abort (void);\n+\n+int table[32][256];\n+\n+int main(void)\n+{\n+  int i, j;\n+\n+  for (i = 0; i < 32; i++)\n+    for (j = 0; j < 256; j++)\n+      table[i][j] = ((signed char)j) * i;\n+\n+  if (table[9][132] != -1116)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "28e4223d81d4be5a35adb32a010482c09e3af570", "filename": "gcc/testsuite/gcc.dg/pr27639.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftestsuite%2Fgcc.dg%2Fpr27639.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftestsuite%2Fgcc.dg%2Fpr27639.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr27639.c?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -std=c99\" } */\n+\n+char heap[50000];\n+\n+int\n+main ()\n+{\n+  for (unsigned ix = sizeof (heap); ix--;)\n+    heap[ix] = ix;\n+  return 0;\n+}"}, {"sha": "fe6dde4bb1982b7cba62242d5cd1a29f8e603772", "filename": "gcc/testsuite/gcc.dg/tree-ssa/scev-cast.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-cast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-cast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fscev-cast.c?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -0,0 +1,26 @@\n+/* A test for various conversions of chrecs.  */\n+\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+void blas (char xxx);\n+void blau (unsigned char xxx);\n+\n+void tst(void)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < 128; i++) /* This cast to char has to be preserved.  */\n+    blas ((char) i);\n+  for (i = 0; i < 127; i++) /* And this one does not.  */\n+    blas ((char) i);\n+  for (i = 0; i < 255; i++) /* This cast is not necessary.  */\n+    blau ((unsigned char) i);\n+  for (i = 0; i < 256; i++)\n+    blau ((unsigned char) i); /* This one is necessary.  */\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\(int\\\\) \\\\(unsigned char\\\\)\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\(int\\\\) \\\\(char\\\\)\" 1 \"optimized\" } } */\n+\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "8038b12279d01cf83cb2ae78b8578209faf4a3c0", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 149, "deletions": 47, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -1096,6 +1096,103 @@ nb_vars_in_chrec (tree chrec)\n     }\n }\n \n+static tree chrec_convert_1 (tree, tree, tree, bool);\n+\n+/* Converts BASE and STEP of affine scev to TYPE.  LOOP is the loop whose iv\n+   the scev corresponds to.  AT_STMT is the statement at that the scev is\n+   evaluated.  USE_OVERFLOW_SEMANTICS is true if this function should assume that\n+   the rules for overflow of the given language apply (e.g., that signed\n+   arithmetics in C does not overflow) -- i.e., to use them to avoid unnecessary\n+   tests, but also to enforce that the result follows them.  Returns true if the\n+   conversion succeeded, false otherwise.  */\n+\n+bool\n+convert_affine_scev (struct loop *loop, tree type,\n+\t\t     tree *base, tree *step, tree at_stmt,\n+\t\t     bool use_overflow_semantics)\n+{\n+  tree ct = TREE_TYPE (*step);\n+  bool enforce_overflow_semantics;\n+  bool must_check_src_overflow, must_check_rslt_overflow;\n+  tree new_base, new_step;\n+\n+  /* In general,\n+     (TYPE) (BASE + STEP * i) = (TYPE) BASE + (TYPE -- sign extend) STEP * i,\n+     but we must check some assumptions.\n+     \n+     1) If [BASE, +, STEP] wraps, the equation is not valid when precision\n+        of CT is smaller than the precision of TYPE.  For example, when we\n+\tcast unsigned char [254, +, 1] to unsigned, the values on left side\n+\tare 254, 255, 0, 1, ..., but those on the right side are\n+\t254, 255, 256, 257, ...\n+     2) In case that we must also preserve the fact that signed ivs do not\n+        overflow, we must additionally check that the new iv does not wrap.\n+\tFor example, unsigned char [125, +, 1] casted to signed char could\n+\tbecome a wrapping variable with values 125, 126, 127, -128, -127, ...,\n+\twhich would confuse optimizers that assume that this does not\n+\thappen.  */\n+  must_check_src_overflow = TYPE_PRECISION (ct) < TYPE_PRECISION (type);\n+\n+  enforce_overflow_semantics = (use_overflow_semantics\n+\t\t\t\t&& nowrap_type_p (type));\n+  if (enforce_overflow_semantics)\n+    {\n+      /* We can avoid checking whether the result overflows in the following\n+\t cases:\n+\n+\t -- must_check_src_overflow is true, and the range of TYPE is superset\n+\t    of the range of CT -- i.e., in all cases except if CT signed and\n+\t    TYPE unsigned.\n+         -- both CT and TYPE have the same precision and signedness.  */\n+      if (must_check_src_overflow)\n+\t{\n+\t  if (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (ct))\n+\t    must_check_rslt_overflow = true;\n+\t  else\n+\t    must_check_rslt_overflow = false;\n+\t}\n+      else if (TYPE_UNSIGNED (ct) == TYPE_UNSIGNED (type)\n+\t       && TYPE_PRECISION (ct) == TYPE_PRECISION (type))\n+\tmust_check_rslt_overflow = false;\n+      else\n+\tmust_check_rslt_overflow = true;\n+    }\n+  else\n+    must_check_rslt_overflow = false;\n+\n+  if (must_check_src_overflow\n+      && scev_probably_wraps_p (*base, *step, at_stmt, loop,\n+\t\t\t\tuse_overflow_semantics))\n+    return false;\n+\n+  new_base = chrec_convert_1 (type, *base, at_stmt,\n+\t\t\t      use_overflow_semantics);\n+  /* The step must be sign extended, regardless of the signedness\n+     of CT and TYPE.  This only needs to be handled specially when\n+     CT is unsigned -- to avoid e.g. unsigned char [100, +, 255]\n+     (with values 100, 99, 98, ...) from becoming signed or unsigned\n+     [100, +, 255] with values 100, 355, ...; the sign-extension is \n+     performed by default when CT is signed.  */\n+  new_step = *step;\n+  if (TYPE_PRECISION (type) > TYPE_PRECISION (ct) && TYPE_UNSIGNED (ct))\n+    new_step = chrec_convert_1 (signed_type_for (ct), new_step, at_stmt,\n+\t\t\t\tuse_overflow_semantics);\n+  new_step = chrec_convert_1 (type, new_step, at_stmt, use_overflow_semantics);\n+\n+  if (automatically_generated_chrec_p (new_base)\n+      || automatically_generated_chrec_p (new_step))\n+    return false;\n+\n+  if (must_check_rslt_overflow\n+      /* Note that in this case we cannot use the fact that signed variables\n+\t do not overflow, as this is what we are verifying for the new iv.  */\n+      && scev_probably_wraps_p (new_base, new_step, at_stmt, loop, false))\n+    return false;\n+\n+  *base = new_base;\n+  *step = new_step;\n+  return true;\n+}\n \f\n \n /* Convert CHREC to TYPE.  When the analyzer knows the context in\n@@ -1124,8 +1221,29 @@ nb_vars_in_chrec (tree chrec)\n \n tree \n chrec_convert (tree type, tree chrec, tree at_stmt)\n+{\n+  return chrec_convert_1 (type, chrec, at_stmt, true);\n+}\n+\n+/* Convert CHREC to TYPE.  When the analyzer knows the context in\n+   which the CHREC is built, it sets AT_STMT to the statement that\n+   contains the definition of the analyzed variable, otherwise the\n+   conversion is less accurate: the information is used for\n+   determining a more accurate estimation of the number of iterations.\n+   By default AT_STMT could be safely set to NULL_TREE.\n+ \n+   USE_OVERFLOW_SEMANTICS is true if this function should assume that\n+   the rules for overflow of the given language apply (e.g., that signed\n+   arithmetics in C does not overflow) -- i.e., to use them to avoid unnecessary\n+   tests, but also to enforce that the result follows them.  */\n+\n+static tree \n+chrec_convert_1 (tree type, tree chrec, tree at_stmt,\n+\t\t bool use_overflow_semantics)\n {\n   tree ct, res;\n+  tree base, step;\n+  struct loop *loop;\n \n   if (automatically_generated_chrec_p (chrec))\n     return chrec;\n@@ -1134,56 +1252,19 @@ chrec_convert (tree type, tree chrec, tree at_stmt)\n   if (ct == type)\n     return chrec;\n \n-  if (evolution_function_is_affine_p (chrec))\n-    {\n-      tree base, step;\n-      bool dummy;\n-      struct loop *loop = current_loops->parray[CHREC_VARIABLE (chrec)];\n-\n-      base = instantiate_parameters (loop, CHREC_LEFT (chrec));\n-      step = instantiate_parameters (loop, CHREC_RIGHT (chrec));\n-\n-      /* Avoid conversion of (signed char) {(uchar)1, +, (uchar)1}_x\n-\t when it is not possible to prove that the scev does not wrap.\n-\t See PR22236, where a sequence 1, 2, ..., 255 has to be\n-\t converted to signed char, but this would wrap: \n-\t 1, 2, ..., 127, -128, ...  The result should not be\n-\t {(schar)1, +, (schar)1}_x, but instead, we should keep the\n-\t conversion: (schar) {(uchar)1, +, (uchar)1}_x.  */\n-      if (scev_probably_wraps_p (type, base, step, at_stmt, loop,\n-\t\t\t\t &dummy, &dummy))\n-\tgoto failed_to_convert;\n-\n-      step = convert_step (loop, type, base, step, at_stmt);\n-      if (!step)\n- \t{\n-\tfailed_to_convert:;\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"(failed conversion:\");\n-\t      fprintf (dump_file, \"\\n  type: \");\n-\t      print_generic_expr (dump_file, type, 0);\n-\t      fprintf (dump_file, \"\\n  base: \");\n-\t      print_generic_expr (dump_file, base, 0);\n-\t      fprintf (dump_file, \"\\n  step: \");\n-\t      print_generic_expr (dump_file, step, 0);\n-\t      fprintf (dump_file, \"\\n  estimated_nb_iterations: \");\n-\t      print_generic_expr (dump_file, loop->estimated_nb_iterations, 0);\n-\t      fprintf (dump_file, \"\\n)\\n\");\n-\t    }\n+  if (!evolution_function_is_affine_p (chrec))\n+    goto keep_cast;\n \n-\t  return fold_convert (type, chrec);\n-\t}\n+  loop = current_loops->parray[CHREC_VARIABLE (chrec)];\n+  base = CHREC_LEFT (chrec);\n+  step = CHREC_RIGHT (chrec);\n \n-      return build_polynomial_chrec (CHREC_VARIABLE (chrec),\n- \t\t\t\t     chrec_convert (type, CHREC_LEFT (chrec),\n- \t\t\t\t\t\t    at_stmt),\n- \t\t\t\t     step);\n-    }\n-\n-  if (TREE_CODE (chrec) == POLYNOMIAL_CHREC)\n-    return chrec_dont_know;\n+  if (convert_affine_scev (loop, type, &base, &step, at_stmt,\n+\t\t\t   use_overflow_semantics))\n+    return build_polynomial_chrec (loop->num, base, step);\n \n+  /* If we cannot propagate the cast inside the chrec, just keep the cast.  */\n+keep_cast:\n   res = fold_convert (type, chrec);\n \n   /* Don't propagate overflows.  */\n@@ -1284,3 +1365,24 @@ eq_evolutions_p (tree chrec0,\n     }  \n }\n \n+/* Returns EV_GROWS if CHREC grows (assuming that it does not overflow),\n+   EV_DECREASES if it decreases, and EV_UNKNOWN if we cannot determine\n+   which of these cases happens.  */\n+\n+enum ev_direction\n+scev_direction (tree chrec)\n+{\n+  tree step;\n+\n+  if (!evolution_function_is_affine_p (chrec))\n+    return EV_DIR_UNKNOWN;\n+\n+  step = CHREC_RIGHT (chrec);\n+  if (TREE_CODE (step) != INTEGER_CST)\n+    return EV_DIR_UNKNOWN;\n+\n+  if (tree_int_cst_sign_bit (step))\n+    return EV_DIR_DECREASES;\n+  else\n+    return EV_DIR_GROWS;\n+}"}, {"sha": "85634025c4424badb950b51b7354b23e3935472b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -810,9 +810,13 @@ tree find_loop_niter (struct loop *, edge *);\n tree loop_niter_by_eval (struct loop *, edge);\n tree find_loop_niter_by_eval (struct loop *, edge *);\n void estimate_numbers_of_iterations (struct loops *);\n-bool scev_probably_wraps_p (tree, tree, tree, tree, struct loop *, bool *,\n-\t\t\t    bool *);\n-tree convert_step (struct loop *, tree, tree, tree, tree);\n+bool scev_probably_wraps_p (tree, tree, tree, struct loop *, bool);\n+bool convert_affine_scev (struct loop *, tree, tree *, tree *, tree, bool);\n+\n+bool nowrap_type_p (tree);\n+enum ev_direction {EV_DIR_GROWS, EV_DIR_DECREASES, EV_DIR_UNKNOWN};\n+enum ev_direction scev_direction (tree);\n+\n void free_numbers_of_iterations_estimates (struct loops *);\n void free_numbers_of_iterations_estimates_loop (struct loop *);\n void rewrite_into_loop_closed_ssa (bitmap, unsigned);"}, {"sha": "52b0ba38b679fa4758b1eb2d0a91bdee2249cb0b", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -2132,6 +2132,12 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n       if (op0 == TREE_OPERAND (chrec, 0))\n \treturn chrec;\n \n+      /* If we used chrec_convert_aggressive, we can no longer assume that\n+\t signed chrecs do not overflow, as chrec_convert does, so avoid\n+         calling it in that case.  */\n+      if (flags & FOLD_CONVERSIONS)\n+\treturn fold_convert (TREE_TYPE (chrec), op0);\n+\n       return chrec_convert (TREE_TYPE (chrec), op0, NULL_TREE);\n \n     case SCEV_NOT_KNOWN:"}, {"sha": "2bb2f0621b7718b119bab5519f1a9477fccb2e88", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -1338,7 +1338,7 @@ idx_find_step (tree base, tree *idx, void *data)\n {\n   struct ifs_ivopts_data *dta = data;\n   struct iv *iv;\n-  tree step, iv_step, lbound, off;\n+  tree step, iv_base, iv_step, lbound, off;\n   struct loop *loop = dta->ivopts_data->current_loop;\n \n   if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF\n@@ -1394,12 +1394,11 @@ idx_find_step (tree base, tree *idx, void *data)\n     /* The step for pointer arithmetics already is 1 byte.  */\n     step = build_int_cst (sizetype, 1);\n \n-  /* FIXME: convert_step should not be used outside chrec_convert: fix\n-     this by calling chrec_convert.  */\n-  iv_step = convert_step (dta->ivopts_data->current_loop,\n-\t\t\t  sizetype, iv->base, iv->step, dta->stmt);\n-\n-  if (!iv_step)\n+  iv_base = iv->base;\n+  iv_step = iv->step;\n+  if (!convert_affine_scev (dta->ivopts_data->current_loop,\n+\t\t\t    sizetype, &iv_base, &iv_step, dta->stmt,\n+\t\t\t    false))\n     {\n       /* The index might wrap.  */\n       return false;"}, {"sha": "6b2789735432f27d4066eec6a5fdd9d217b4be5f", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 52, "deletions": 304, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -1707,33 +1707,6 @@ estimate_numbers_of_iterations (struct loops *loops)\n     }\n }\n \n-/* If A > B, returns -1.  If A == B, returns 0.  If A < B, returns 1.\n-   If neither of these relations can be proved, returns 2.  */\n-\n-static int\n-compare_trees (tree a, tree b)\n-{\n-  tree typea = TREE_TYPE (a), typeb = TREE_TYPE (b);\n-  tree type;\n-\n-  if (TYPE_PRECISION (typea) > TYPE_PRECISION (typeb))\n-    type = typea;\n-  else\n-    type = typeb;\n-\n-  a = fold_convert (type, a);\n-  b = fold_convert (type, b);\n-\n-  if (nonzero_p (fold_binary (EQ_EXPR, boolean_type_node, a, b)))\n-    return 0;\n-  if (nonzero_p (fold_binary (LT_EXPR, boolean_type_node, a, b)))\n-    return 1;\n-  if (nonzero_p (fold_binary (GT_EXPR, boolean_type_node, a, b)))\n-    return -1;\n-\n-  return 2;\n-}\n-\n /* Returns true if statement S1 dominates statement S2.  */\n \n static bool\n@@ -1796,123 +1769,19 @@ n_of_executions_at_most (tree stmt,\n   return nonzero_p (cond);\n }\n \n-/* Checks whether it is correct to count the induction variable BASE +\n-   STEP * I at AT_STMT in a wider type NEW_TYPE, using the bounds on\n-   numbers of iterations of a LOOP.  If it is possible, return the\n-   value of step of the induction variable in the NEW_TYPE, otherwise\n-   return NULL_TREE.  */\n-\n-static tree\n-convert_step_widening (struct loop *loop, tree new_type, tree base, tree step,\n-\t\t       tree at_stmt)\n-{\n-  struct nb_iter_bound *bound;\n-  tree base_in_new_type, base_plus_step_in_new_type, step_in_new_type;\n-  tree delta, step_abs;\n-  tree unsigned_type, valid_niter;\n-\n-  /* Compute the new step.  For example, {(uchar) 100, +, (uchar) 240}\n-     is converted to {(uint) 100, +, (uint) 0xfffffff0} in order to\n-     keep the values of the induction variable unchanged: 100, 84, 68,\n-     ...\n-\n-     Another example is: (uint) {(uchar)100, +, (uchar)3} is converted\n-     to {(uint)100, +, (uint)3}.  \n-\n-     Before returning the new step, verify that the number of\n-     iterations is less than DELTA / STEP_ABS (i.e. in the previous\n-     example (256 - 100) / 3) such that the iv does not wrap (in which\n-     case the operations are too difficult to be represented and\n-     handled: the values of the iv should be taken modulo 256 in the\n-     wider type; this is not implemented).  */\n-  base_in_new_type = fold_convert (new_type, base);\n-  base_plus_step_in_new_type = \n-    fold_convert (new_type,\n-\t\t  fold_build2 (PLUS_EXPR, TREE_TYPE (base), base, step));\n-  step_in_new_type = fold_build2 (MINUS_EXPR, new_type,\n-\t\t\t\t  base_plus_step_in_new_type,\n-\t\t\t\t  base_in_new_type);\n-\n-  if (TREE_CODE (step_in_new_type) != INTEGER_CST)\n-    return NULL_TREE;\n-\n-  switch (compare_trees (base_plus_step_in_new_type, base_in_new_type))\n-    {\n-    case -1:\n-      {\n-\ttree extreme = upper_bound_in_type (new_type, TREE_TYPE (base));\n-\tdelta = fold_build2 (MINUS_EXPR, new_type, extreme,\n-\t\t\t     base_in_new_type);\n-\tstep_abs = step_in_new_type;\n-\tbreak;\n-      }\n-\n-    case 1:\n-      {\n-\ttree extreme = lower_bound_in_type (new_type, TREE_TYPE (base));\n-\tdelta = fold_build2 (MINUS_EXPR, new_type, base_in_new_type,\n-\t\t\t     extreme);\n-\tstep_abs = fold_build1 (NEGATE_EXPR, new_type, step_in_new_type);\n-\tbreak;\n-      }\n-\n-    case 0:\n-      return step_in_new_type;\n-\n-    default:\n-      return NULL_TREE;\n-    }\n-\n-  unsigned_type = unsigned_type_for (new_type);\n-  delta = fold_convert (unsigned_type, delta);\n-  step_abs = fold_convert (unsigned_type, step_abs);\n-  valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type,\n-\t\t\t     delta, step_abs);\n+/* Returns true if the arithmetics in TYPE can be assumed not to wrap.  */\n \n-  estimate_numbers_of_iterations_loop (loop);\n-  for (bound = loop->bounds; bound; bound = bound->next)\n-    if (n_of_executions_at_most (at_stmt, bound, valid_niter))\n-      return step_in_new_type;\n-\n-  /* Fail when the loop has no bound estimations, or when no bound can\n-     be used for verifying the conversion.  */\n-  return NULL_TREE;\n-}\n-\n-/* Returns true when VAR is used in pointer arithmetics.  DEPTH is\n-   used for limiting the search.  */\n-\n-static bool\n-used_in_pointer_arithmetic_p (tree var, int depth)\n+bool\n+nowrap_type_p (tree type)\n {\n-  use_operand_p use_p;\n-  imm_use_iterator iter;\n-\n-  if (depth == 0\n-      || TREE_CODE (var) != SSA_NAME\n-      || !has_single_use (var))\n-    return false;\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, var)\n-    {\n-      tree stmt = USE_STMT (use_p);\n+  if (!flag_wrapv\n+      && INTEGRAL_TYPE_P (type)\n+      && !TYPE_UNSIGNED (type))\n+    return true;\n \n-      if (stmt && TREE_CODE (stmt) == MODIFY_EXPR)\n-\t{\n-\t  tree rhs = TREE_OPERAND (stmt, 1);\n+  if (POINTER_TYPE_P (type))\n+    return true;\n \n-\t  if (TREE_CODE (rhs) == NOP_EXPR\n-\t      || TREE_CODE (rhs) == CONVERT_EXPR)\n-\t    {\n-\t      if (POINTER_TYPE_P (TREE_TYPE (rhs)))\n-\t\treturn true;\n-\t      return false;\n-\t    }\n-\t  else\n-\t    return used_in_pointer_arithmetic_p (TREE_OPERAND (stmt, 0),\n-\t\t\t\t\t\t depth - 1);\n-\t}\n-    }\n   return false;\n }\n \n@@ -1921,156 +1790,72 @@ used_in_pointer_arithmetic_p (tree var, int depth)\n    enough with respect to the step and initial condition in order to\n    keep the evolution confined in TYPEs bounds.  Return true when the\n    iv is known to overflow or when the property is not computable.\n-\n-   Initialize INIT_IS_MAX to true when the evolution goes from\n-   INIT_IS_MAX to LOWER_BOUND_IN_TYPE, false in the contrary case.\n-   When this property cannot be determined, UNKNOWN_MAX is set to\n-   true.  */\n+ \n+   USE_OVERFLOW_SEMANTICS is true if this function should assume that\n+   the rules for overflow of the given language apply (e.g., that signed\n+   arithmetics in C does not overflow).  */\n \n bool\n-scev_probably_wraps_p (tree type, tree base, tree step, \n+scev_probably_wraps_p (tree base, tree step, \n \t\t       tree at_stmt, struct loop *loop,\n-\t\t       bool *init_is_max, bool *unknown_max)\n+\t\t       bool use_oveflow_semantics)\n {\n   struct nb_iter_bound *bound;\n   tree delta, step_abs;\n   tree unsigned_type, valid_niter;\n-  tree base_plus_step, bpsps;\n-  int cps, cpsps;\n-\n-  /* FIXME: The following code will not be used anymore once\n-     http://gcc.gnu.org/ml/gcc-patches/2005-06/msg02025.html is\n-     committed.\n-\n-     If AT_STMT is a cast to unsigned that is later used for\n-     referencing a memory location, it is followed by a pointer\n-     conversion just after.  Because pointers do not wrap, the\n-     sequences that reference the memory do not wrap either.  In the\n-     following example, sequences corresponding to D_13 and to D_14\n-     can be proved to not wrap because they are used for computing a\n-     memory access:\n+  tree type = TREE_TYPE (step);\n+\n+  /* FIXME: We really need something like\n+     http://gcc.gnu.org/ml/gcc-patches/2005-06/msg02025.html.\n+\n+     We used to test for the following situation that frequently appears\n+     during address arithmetics:\n \t \n        D.1621_13 = (long unsigned intD.4) D.1620_12;\n        D.1622_14 = D.1621_13 * 8;\n        D.1623_15 = (doubleD.29 *) D.1622_14;\n-  */\n-  if (at_stmt && TREE_CODE (at_stmt) == MODIFY_EXPR)\n-    {\n-      tree op0 = TREE_OPERAND (at_stmt, 0);\n-      tree op1 = TREE_OPERAND (at_stmt, 1);\n-      tree type_op1 = TREE_TYPE (op1);\n \n-      if ((TYPE_UNSIGNED (type_op1)\n-\t   && used_in_pointer_arithmetic_p (op0, 2))\n-\t  || POINTER_TYPE_P (type_op1))\n-\t{\n-\t  *unknown_max = true;\n-\t  return false;\n-\t}\n-    }\n+     And derived that the sequence corresponding to D_14\n+     can be proved to not wrap because it is used for computing a\n+     memory access; however, this is not really the case -- for example,\n+     if D_12 = (unsigned char) [254,+,1], then D_14 has values\n+     2032, 2040, 0, 8, ..., but the code is still legal.  */\n \n   if (chrec_contains_undetermined (base)\n       || chrec_contains_undetermined (step)\n-      || TREE_CODE (base) == REAL_CST\n-      || TREE_CODE (step) == REAL_CST)\n-    {\n-      *unknown_max = true;\n-      return true;\n-    }\n+      || TREE_CODE (step) != INTEGER_CST)\n+    return true;\n \n-  *unknown_max = false;\n-  base_plus_step = fold_build2 (PLUS_EXPR, type, base, step);\n-  bpsps = fold_build2 (PLUS_EXPR, type, base_plus_step, step);\n-  cps = compare_trees (base_plus_step, base);\n-  cpsps = compare_trees (bpsps, base_plus_step);\n+  if (zero_p (step))\n+    return false;\n \n-  /* Check that the sequence is not wrapping in the first step: it\n-     should have the same monotonicity for the first two steps.  See\n-     PR23410.  */\n-  if (cps != cpsps)\n-    return true;\n+  /* If we can use the fact that signed and pointer arithmetics does not\n+     wrap, we are done.  */\n+  if (use_oveflow_semantics && nowrap_type_p (type))\n+    return false;\n \n-  switch (cps)\n-    {\n-    case -1:\n-      {\n-\ttree extreme = upper_bound_in_type (type, TREE_TYPE (base));\n-\tdelta = fold_build2 (MINUS_EXPR, type, extreme, base);\n-\tstep_abs = step;\n-\t*init_is_max = false;\n-\tbreak;\n-      }\n-\n-    case 1:\n-      {\n-\ttree extreme = lower_bound_in_type (type, TREE_TYPE (base));\n-\tdelta = fold_build2 (MINUS_EXPR, type, base, extreme);\n-\tstep_abs = fold_build1 (NEGATE_EXPR, type, step);\n-\t*init_is_max = true;\n-\tbreak;\n-      }\n-\n-    case 0:\n-      /* This means step is equal to 0.  This should not happen.  It\n-\t could happen in convert step, but not here.  Safely answer\n-\t don't know as in the default case.  */\n+  /* Otherwise, compute the number of iterations before we reach the\n+     bound of the type, and verify that the loop is exited before this\n+     occurs.  */\n+  unsigned_type = unsigned_type_for (type);\n+  base = fold_convert (unsigned_type, base);\n \n-    default:\n-      *unknown_max = true;\n-      return true;\n+  if (tree_int_cst_sign_bit (step))\n+    {\n+      tree extreme = fold_convert (unsigned_type,\n+\t\t\t\t   lower_bound_in_type (type, type));\n+      delta = fold_build2 (MINUS_EXPR, unsigned_type, base, extreme);\n+      step_abs = fold_build1 (NEGATE_EXPR, unsigned_type,\n+\t\t\t      fold_convert (unsigned_type, step));\n     }\n-\n-  /* If AT_STMT represents a cast operation, we may not be able to\n-     take advantage of the undefinedness of signed type evolutions.\n-\n-     implement-c.texi states: \"For conversion to a type of width\n-     N, the value is reduced modulo 2^N to be within range of the\n-     type;\"\n-\n-     See PR 21959 for a test case.  Essentially, given a cast\n-     operation\n-     \t\tunsigned char uc;\n-\t\tsigned char sc;\n-\t\t...\n-     \t\tsc = (signed char) uc;\n-\t\tif (sc < 0)\n-\t\t  ...\n-\n-     where uc and sc have the scev {0, +, 1}, we would consider uc to\n-     wrap around, but not sc, because it is of a signed type.  This\n-     causes VRP to erroneously fold the predicate above because it\n-     thinks that sc cannot be negative.  */\n-  if (at_stmt && TREE_CODE (at_stmt) == MODIFY_EXPR)\n+  else\n     {\n-      tree rhs = TREE_OPERAND (at_stmt, 1);\n-      tree outer_t = TREE_TYPE (rhs);\n-\n-      if (!TYPE_UNSIGNED (outer_t)\n-\t  && (TREE_CODE (rhs) == NOP_EXPR || TREE_CODE (rhs) == CONVERT_EXPR))\n-\t{\n-\t  tree inner_t = TREE_TYPE (TREE_OPERAND (rhs, 0));\n-\n-\t  /* If the inner type is unsigned and its size and/or\n-\t     precision are smaller to that of the outer type, then the\n-\t     expression may wrap around.  */\n-\t  if (TYPE_UNSIGNED (inner_t)\n-\t      && (TYPE_SIZE (inner_t) <= TYPE_SIZE (outer_t)\n-\t\t  || TYPE_PRECISION (inner_t) <= TYPE_PRECISION (outer_t)))\n-\t    {\n-\t      *unknown_max = true;\n-\t      return true;\n-\t    }\n-\t}\n+      tree extreme = fold_convert (unsigned_type,\n+\t\t\t\t   upper_bound_in_type (type, type));\n+      delta = fold_build2 (MINUS_EXPR, unsigned_type, extreme, base);\n+      step_abs = fold_convert (unsigned_type, step);\n     }\n \n-  /* After having set INIT_IS_MAX, we can return false: when not using\n-     wrapping arithmetic, signed types don't wrap.  */\n-  if (!flag_wrapv && !TYPE_UNSIGNED (type))\n-    return false;\n-\n-  unsigned_type = unsigned_type_for (type);\n-  delta = fold_convert (unsigned_type, delta);\n-  step_abs = fold_convert (unsigned_type, step_abs);\n   valid_niter = fold_build2 (FLOOR_DIV_EXPR, unsigned_type, delta, step_abs);\n \n   estimate_numbers_of_iterations_loop (loop);\n@@ -2080,46 +1865,9 @@ scev_probably_wraps_p (tree type, tree base, tree step,\n \n   /* At this point we still don't have a proof that the iv does not\n      overflow: give up.  */\n-  *unknown_max = true;\n   return true;\n }\n \n-/* Return the conversion to NEW_TYPE of the STEP of an induction\n-   variable BASE + STEP * I at AT_STMT.  When it fails, return\n-   NULL_TREE.  */\n-\n-tree\n-convert_step (struct loop *loop, tree new_type, tree base, tree step,\n-\t      tree at_stmt)\n-{\n-  tree res, base_type;\n-\n-  if (chrec_contains_undetermined (base)\n-      || chrec_contains_undetermined (step))\n-    return NULL_TREE;\n-\n-  base_type = TREE_TYPE (base);\n-\n-  /* When not using wrapping arithmetic, signed types don't wrap.  */\n-  if (!flag_wrapv && !TYPE_UNSIGNED (base_type))\n-    goto do_convert_step;\n-\n-  if (TYPE_PRECISION (new_type) > TYPE_PRECISION (base_type))\n-    return convert_step_widening (loop, new_type, base, step, at_stmt);\n-\n- do_convert_step:\n-  \n-  res = fold_convert (new_type, step);\n-\n-  if (TREE_CODE (res) == INTEGER_CST)\n-    {\n-      TREE_OVERFLOW (res) = 0;\n-      TREE_CONSTANT_OVERFLOW (res) = 0;\n-    }\n-\n-  return res;\n-}\n-\n /* Frees the information on upper bounds on numbers of iterations of LOOP.  */\n \n void"}, {"sha": "11c8077b8251aad8dd3b9459a739ad6e4d704993", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7f5de76fdc534c7eb7bb532b212936665ec2080/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=d7f5de76fdc534c7eb7bb532b212936665ec2080", "patch": "@@ -1975,7 +1975,7 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n \t\t\ttree var)\n {\n   tree init, step, chrec;\n-  bool init_is_max, unknown_max;\n+  enum ev_direction dir;\n \n   /* TODO.  Don't adjust anti-ranges.  An anti-range may provide\n      better opportunities than a regular range, but I'm not sure.  */\n@@ -1998,11 +1998,14 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n       || !valid_value_p (init))\n     return;\n \n-  /* Do not adjust ranges when chrec may wrap.  */\n-  if (scev_probably_wraps_p (chrec_type (chrec), init, step, stmt,\n-\t\t\t     current_loops->parray[CHREC_VARIABLE (chrec)],\n-\t\t\t     &init_is_max, &unknown_max)\n-      || unknown_max)\n+  dir = scev_direction (chrec);\n+  if (/* Do not adjust ranges if we do not know whether the iv increases\n+\t or decreases,  ... */\n+      dir == EV_DIR_UNKNOWN\n+      /* ... or if it may wrap.  */\n+      || scev_probably_wraps_p (init, step, stmt,\n+\t\t\t\tcurrent_loops->parray[CHREC_VARIABLE (chrec)],\n+\t\t\t\ttrue))\n     return;\n \n   if (!POINTER_TYPE_P (TREE_TYPE (init))\n@@ -2013,7 +2016,7 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n       tree min = TYPE_MIN_VALUE (TREE_TYPE (init));\n       tree max = TYPE_MAX_VALUE (TREE_TYPE (init));\n \n-      if (init_is_max)\n+      if (dir == EV_DIR_DECREASES)\n \tmax = init;\n       else\n \tmin = init;\n@@ -2031,7 +2034,7 @@ adjust_range_with_scev (value_range_t *vr, struct loop *loop, tree stmt,\n       tree min = vr->min;\n       tree max = vr->max;\n \n-      if (init_is_max)\n+      if (dir == EV_DIR_DECREASES)\n \t{\n \t  /* INIT is the maximum value.  If INIT is lower than VR->MAX\n \t     but no smaller than VR->MIN, set VR->MAX to INIT.  */"}]}