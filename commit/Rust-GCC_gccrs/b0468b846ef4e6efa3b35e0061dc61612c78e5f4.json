{"sha": "b0468b846ef4e6efa3b35e0061dc61612c78e5f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA0NjhiODQ2ZWY0ZTZlZmEzYjM1ZTAwNjFkYzYxNjEyYzc4ZTVmNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-30T21:38:29Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-30T21:38:29Z"}, "message": "(sparc_type_code): Revise so it supports non-C types.\n\nFrom-SVN: r6919", "tree": {"sha": "a8791f442e59eb747c9a09784110ffffcafd24e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8791f442e59eb747c9a09784110ffffcafd24e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0468b846ef4e6efa3b35e0061dc61612c78e5f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0468b846ef4e6efa3b35e0061dc61612c78e5f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0468b846ef4e6efa3b35e0061dc61612c78e5f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0468b846ef4e6efa3b35e0061dc61612c78e5f4/comments", "author": null, "committer": null, "parents": [{"sha": "ffa969a1c486f41f959535d864b051e7edf3a9b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa969a1c486f41f959535d864b051e7edf3a9b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa969a1c486f41f959535d864b051e7edf3a9b0"}], "stats": {"total": 88, "additions": 26, "deletions": 62}, "files": [{"sha": "81723adf9c62a6b54f5772f2f1722d00eb3b2288", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 26, "deletions": 62, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0468b846ef4e6efa3b35e0061dc61612c78e5f4/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0468b846ef4e6efa3b35e0061dc61612c78e5f4/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b0468b846ef4e6efa3b35e0061dc61612c78e5f4", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Sun SPARC.\n-   Copyright (C) 1987, 1988, 1989, 1992, 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92, 93, 1994 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -2843,6 +2843,10 @@ output_double_int (file, value)\n     abort ();\n }\n \f\n+/* Return the value of a code used in the .proc pseudo-op that says\n+   what kind of result this function returns.  For non-C types, we pick\n+   the closest C type.  */\n+\n #ifndef CHAR_TYPE_SIZE\n #define CHAR_TYPE_SIZE BITS_PER_UNIT\n #endif\n@@ -2914,6 +2918,7 @@ sparc_type_code (type)\n \t  return (qualifiers | 8);\n \n \tcase UNION_TYPE:\n+\tcase QUAL_UNION_TYPE:\n \t  return (qualifiers | 9);\n \n \tcase ENUMERAL_TYPE:\n@@ -2932,78 +2937,37 @@ sparc_type_code (type)\n \t    }\n \n \t  /* Carefully distinguish all the standard types of C,\n-\t     without messing up if the language is not C.\n-\t     Note that we check only for the names that contain spaces;\n-\t     other names might occur by coincidence in other languages.  */\n-\t  if (TYPE_NAME (type) != 0\n-\t      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t      && DECL_NAME (TYPE_NAME (type)) != 0\n-\t      && TREE_CODE (DECL_NAME (TYPE_NAME (type))) == IDENTIFIER_NODE)\n-\t    {\n-\t      char *name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-  \n-\t      if (!strcmp (name, \"unsigned char\"))\n-\t\treturn (qualifiers | 12);\n-\t      if (!strcmp (name, \"signed char\"))\n-\t\treturn (qualifiers | 2);\n-\t      if (!strcmp (name, \"unsigned int\"))\n-\t\treturn (qualifiers | 14);\n-\t      if (!strcmp (name, \"short int\"))\n-\t\treturn (qualifiers | 3);\n-\t      if (!strcmp (name, \"short unsigned int\"))\n-\t\treturn (qualifiers | 13);\n-\t      if (!strcmp (name, \"long int\"))\n-\t\treturn (qualifiers | 5);\n-\t      if (!strcmp (name, \"long unsigned int\"))\n-\t\treturn (qualifiers | 15);\n-\t      if (!strcmp (name, \"long long int\"))\n-\t\treturn (qualifiers | 5);\t/* Who knows? */\n-\t      if (!strcmp (name, \"long long unsigned int\"))\n-\t\treturn (qualifiers | 15);\t/* Who knows? */\n-\t    }\n+\t     without messing up if the language is not C.  We do this by\n+\t     testing TYPE_PRECISION and TREE_UNSIGNED.  The old code used to\n+\t     look at both the names and the above fields, but that's redundant.\n+\t     Any type whose size is between two C types will be considered\n+\t     to be the wider of the two types.  Also, we do not have a\n+\t     special code to use for \"long long\", so anything wider than\n+\t     long is treated the same.  Note that we can't distinguish\n+\t     between \"int\" and \"long\" in this code if they are the same\n+\t     size, but that's fine, since neither can the assembler.  */\n+\n+\t  if (TYPE_PRECISION (type) <= CHAR_TYPE_SIZE)\n+\t    return (qualifiers | (TREE_UNSIGNED (type) ? 12 : 2));\n   \n-\t  /* Most integer types will be sorted out above, however, for the\n-\t     sake of special `array index' integer types, the following code\n-\t     is also provided.  */\n+\t  else if (TYPE_PRECISION (type) <= SHORT_TYPE_SIZE)\n+\t    return (qualifiers | (TREE_UNSIGNED (type) ? 13 : 3));\n   \n-\t  if (TYPE_PRECISION (type) == INT_TYPE_SIZE)\n+\t  else if (TYPE_PRECISION (type) <= INT_TYPE_SIZE)\n \t    return (qualifiers | (TREE_UNSIGNED (type) ? 14 : 4));\n   \n-\t  if (TYPE_PRECISION (type) == LONG_TYPE_SIZE)\n-\t    return (qualifiers | (TREE_UNSIGNED (type) ? 15 : 5));\n-  \n-\t  if (TYPE_PRECISION (type) == LONG_LONG_TYPE_SIZE)\n+\t  else\n \t    return (qualifiers | (TREE_UNSIGNED (type) ? 15 : 5));\n   \n-\t  if (TYPE_PRECISION (type) == SHORT_TYPE_SIZE)\n-\t    return (qualifiers | (TREE_UNSIGNED (type) ? 13 : 3));\n-  \n-\t  if (TYPE_PRECISION (type) == CHAR_TYPE_SIZE)\n-\t    return (qualifiers | (TREE_UNSIGNED (type) ? 12 : 2));\n-  \n-\t  abort ();\n-  \n \tcase REAL_TYPE:\n \t  /* Carefully distinguish all the standard types of C,\n \t     without messing up if the language is not C.  */\n-\t  if (TYPE_NAME (type) != 0\n-\t      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t      && DECL_NAME (TYPE_NAME (type)) != 0\n-\t      && TREE_CODE (DECL_NAME (TYPE_NAME (type))) == IDENTIFIER_NODE)\n-\t    {\n-\t      char *name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-  \n-\t      if (!strcmp (name, \"long double\"))\n-\t\treturn (qualifiers | 7);\t/* Who knows? */\n-\t    }\n-  \n-\t  if (TYPE_PRECISION (type) == DOUBLE_TYPE_SIZE)\n-\t    return (qualifiers | 7);\n+\n \t  if (TYPE_PRECISION (type) == FLOAT_TYPE_SIZE)\n \t    return (qualifiers | 6);\n-\t  if (TYPE_PRECISION (type) == LONG_DOUBLE_TYPE_SIZE)\n-\t    return (qualifiers | 7);\t/* Who knows? */\n-\t  abort ();\n+\n+\t  else \n+\t    return (qualifiers | 7);\n   \n \tcase COMPLEX_TYPE:\t/* GNU Fortran COMPLEX type.  */\n \t  /* ??? We need to distinguish between double and float complex types,"}]}