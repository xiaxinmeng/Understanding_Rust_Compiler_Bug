{"sha": "c779924eee2c26684b32b4a0b15e793884d1cafc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc3OTkyNGVlZTJjMjY2ODRiMzJiNGEwYjE1ZTc5Mzg4NGQxY2FmYw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2015-12-13T20:37:26Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2015-12-13T20:37:26Z"}, "message": "[PR67355] drop dummy zero from reverse VTA ops, fix infinite recursion\n\nVTA's cselib expression hashing compares expressions with the same\nhash before adding them to the hash table.  When there is a collision\ninvolving a self-referencing expression, we could get infinite\nrecursion, in spite of the cycle breakers already in place.  The\nproblem is currently latent in the trunk, because by chance we don't\nget a collision.\n\nSuch value cycles are often introduced by reverse_op; most often,\nthey're indirect, and then value canonicalization takes care of the\ncycle, but if the reverse operation simplifies to the original value,\nwe used to issue a (plus V (const_int 0)), because at some point\nadding a plain value V to a location list as a reverse_op equivalence\ncaused other problems.\n\nThis dummy zero, in turn, caused the value canonicalizer to not fully\nrealize the equivalence, leading to more complex graphs and,\noccasionally, to infinite recursion when comparing such\nvalue-plus-zero expressions recursively.\n\nSimply using V solves the infinite recursion from the PR testcase,\nsince the extra equivalence and the preexisting value canonicalization\ntogether prevent recursion while the unrecognized equivalence\nwouldn't, but it exposed another infinite recursion in\nmemrefs_conflict_p: get_addr had a cycle breaker in place, to skip RTL\nreferencing values introduced after the one we're examining, but it\nwouldn't break the cycle if the value itself appeared in the\nexpression being examined.\n\nAfter removing the dummy zero above, this kind of cycle in the\nequivalence graph is no longer introduced by VTA itself, but dummy\nzeros are also present in generated code, such as in the 32-bit x86's\npro_epilogue_adjust_stack_si_add epilogue insn generated as part of\nthe builtin longjmp in _Unwind_RaiseException building libgcc's\nunwind-dw2.o.  So, break the recursion cycle for them too.\n\n\nfor  gcc/ChangeLog\n\n\tPR debug/67355\n\t* var-tracking.c (reverse_op): Don't add dummy zero to reverse\n\tops that simplify back to the original value.\n\t* alias.c (refs_newer_value_p): Cut off recursion for\n\texpressions containing the original value.\n\nFrom-SVN: r231599", "tree": {"sha": "6100f51adbc38b570a0bf6f479816c9e7813abc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6100f51adbc38b570a0bf6f479816c9e7813abc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c779924eee2c26684b32b4a0b15e793884d1cafc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c779924eee2c26684b32b4a0b15e793884d1cafc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c779924eee2c26684b32b4a0b15e793884d1cafc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c779924eee2c26684b32b4a0b15e793884d1cafc/comments", "author": null, "committer": null, "parents": [{"sha": "8454aad340922ae794096dd6045990f087b7906f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8454aad340922ae794096dd6045990f087b7906f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8454aad340922ae794096dd6045990f087b7906f"}], "stats": {"total": 17, "additions": 10, "deletions": 7}, "files": [{"sha": "42955284bc35728b56d7a193fdc90cf2434d603a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779924eee2c26684b32b4a0b15e793884d1cafc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779924eee2c26684b32b4a0b15e793884d1cafc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c779924eee2c26684b32b4a0b15e793884d1cafc", "patch": "@@ -1,3 +1,11 @@\n+2015-12-13  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR debug/67355\n+\t* var-tracking.c (reverse_op): Don't add dummy zero to reverse\n+\tops that simplify back to the original value.\n+\t* alias.c (refs_newer_value_p): Cut off recursion for\n+\texpressions containing the original value.\n+\n 2015-12-13  Kazu Kirata  <kazu@gcc.gnu.org>\n \n \t* config/m68k/m68k.md (load feeding clear byte): New peephole2."}, {"sha": "1ab96008743902f5b05e1ab1ebd483a25fe6adbb", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779924eee2c26684b32b4a0b15e793884d1cafc/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779924eee2c26684b32b4a0b15e793884d1cafc/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=c779924eee2c26684b32b4a0b15e793884d1cafc", "patch": "@@ -2129,15 +2129,15 @@ base_alias_check (rtx x, rtx x_base, rtx y, rtx y_base,\n }\n \n /* Return TRUE if EXPR refers to a VALUE whose uid is greater than\n-   that of V.  */\n+   (or equal to) that of V.  */\n \n static bool\n refs_newer_value_p (const_rtx expr, rtx v)\n {\n   int minuid = CSELIB_VAL_PTR (v)->uid;\n   subrtx_iterator::array_type array;\n   FOR_EACH_SUBRTX (iter, array, expr, NONCONST)\n-    if (GET_CODE (*iter) == VALUE && CSELIB_VAL_PTR (*iter)->uid > minuid)\n+    if (GET_CODE (*iter) == VALUE && CSELIB_VAL_PTR (*iter)->uid >= minuid)\n       return true;\n   return false;\n }"}, {"sha": "07eea841f4443f6c358c466d905679d654cc81ee", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c779924eee2c26684b32b4a0b15e793884d1cafc/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c779924eee2c26684b32b4a0b15e793884d1cafc/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=c779924eee2c26684b32b4a0b15e793884d1cafc", "patch": "@@ -5774,11 +5774,6 @@ reverse_op (rtx val, const_rtx expr, rtx_insn *insn)\n \t    return;\n \t}\n       ret = simplify_gen_binary (code, GET_MODE (val), val, arg);\n-      if (ret == val)\n-\t/* Ensure ret isn't VALUE itself (which can happen e.g. for\n-\t   (plus (reg1) (reg2)) when reg2 is known to be 0), as that\n-\t   breaks a lot of routines during var-tracking.  */\n-\tret = gen_rtx_fmt_ee (PLUS, GET_MODE (val), val, const0_rtx);\n       break;\n     default:\n       gcc_unreachable ();"}]}