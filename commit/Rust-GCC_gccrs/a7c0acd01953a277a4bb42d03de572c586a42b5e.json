{"sha": "a7c0acd01953a277a4bb42d03de572c586a42b5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdjMGFjZDAxOTUzYTI3N2E0YmI0MmQwM2RlNTcyYzU4NmE0MmI1ZQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-09-23T17:06:44Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-09-23T17:06:44Z"}, "message": "re PR target/50447 ([avr] Better support of AND, OR, XOR and PLUS with constant integers for 16- and 32-bit values)\n\n\t* config/avr/avr.md (adjust_len): Add alternatives \"tsthi\",\n\t\"tstsi\", \"compare\".\n\t(*cmpqi_sign_extend): Use s8_operand.\n\t(*cmphi, *cmpsi): Rewrite using avr_out_compare.\n\t* config/avr/avr-protos.h (compare_diff_p, compare_eq_p): Remove\n\tprototypes.\n\t(out_tsthi, out_tstsi): Remove prototypes.\n\t(avr_out_tsthi, avr_out_tstsi): New prototypes.\n\t* config/avr/avr.c (out_tsthi, out_tstsi): Remove functions.\n\t(avr_asm_len): Negative length now sets *plen to -length.\n\t(compare_sign_p): Return bool instead of int.\n\t(compare_diff_p, compare_eq_p): Ditto and make static.\n\t(avr_out_tsthi): New function.\n\t(avr_out_tstsi): New function.\n\t(avr_out_compare): New function.\n\t(adjust_insn_length): Handle ADJUST_LEN_TSTHI, ADJUST_LEN_TSTSI,\n\tADJUST_LEN_COMPARE.\n\tPR target/50447\n\nFrom-SVN: r179124", "tree": {"sha": "f6a6167d5f26e759d125375ed7918c126367394f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6a6167d5f26e759d125375ed7918c126367394f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7c0acd01953a277a4bb42d03de572c586a42b5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c0acd01953a277a4bb42d03de572c586a42b5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7c0acd01953a277a4bb42d03de572c586a42b5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c0acd01953a277a4bb42d03de572c586a42b5e/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "590245153a345410c79f16df7c58660ff91df05e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590245153a345410c79f16df7c58660ff91df05e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/590245153a345410c79f16df7c58660ff91df05e"}], "stats": {"total": 391, "additions": 232, "deletions": 159}, "files": [{"sha": "c0223e46ba468202cde0cceda78fe63ae1713d11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c0acd01953a277a4bb42d03de572c586a42b5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c0acd01953a277a4bb42d03de572c586a42b5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7c0acd01953a277a4bb42d03de572c586a42b5e", "patch": "@@ -1,3 +1,24 @@\n+2011-09-23  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/50447\n+\t* config/avr/avr.md (adjust_len): Add alternatives \"tsthi\",\n+\t\"tstsi\", \"compare\".\n+\t(*cmpqi_sign_extend): Use s8_operand.\n+\t(*cmphi, *cmpsi): Rewrite using avr_out_compare.\n+\t* config/avr/avr-protos.h (compare_diff_p, compare_eq_p): Remove\n+\tprototypes.\n+\t(out_tsthi, out_tstsi): Remove prototypes.\n+\t(avr_out_tsthi, avr_out_tstsi): New prototypes.\n+\t* config/avr/avr.c (out_tsthi, out_tstsi): Remove functions.\n+\t(avr_asm_len): Negative length now sets *plen to -length.\n+\t(compare_sign_p): Return bool instead of int.\n+\t(compare_diff_p, compare_eq_p): Ditto and make static.\n+\t(avr_out_tsthi): New function.\n+\t(avr_out_tstsi): New function.\n+\t(avr_out_compare): New function.\n+\t(adjust_insn_length): Handle ADJUST_LEN_TSTHI, ADJUST_LEN_TSTSI,\n+\tADJUST_LEN_COMPARE.\n+\n 2011-09-23  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/50447"}, {"sha": "2fa8ce1c654d20111f2ddb593f65d02ffcc489fc", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c0acd01953a277a4bb42d03de572c586a42b5e/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c0acd01953a277a4bb42d03de572c586a42b5e/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=a7c0acd01953a277a4bb42d03de572c586a42b5e", "patch": "@@ -47,7 +47,6 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \n #ifdef RTX_CODE\n extern void asm_output_external_libcall (FILE *file, rtx symref);\n-extern int compare_diff_p (rtx insn);\n extern const char *output_movqi (rtx insn, rtx operands[], int *l);\n extern const char *output_movhi (rtx insn, rtx operands[], int *l);\n extern const char *out_movqi_r_mr (rtx insn, rtx op[], int *l);\n@@ -57,8 +56,9 @@ extern const char *out_movhi_mr_r (rtx insn, rtx op[], int *l);\n extern const char *out_movsi_r_mr (rtx insn, rtx op[], int *l);\n extern const char *out_movsi_mr_r (rtx insn, rtx op[], int *l);\n extern const char *output_movsisf (rtx insn, rtx operands[], int *l);\n-extern const char *out_tstsi (rtx insn, rtx src, int *l);\n-extern const char *out_tsthi (rtx insn, rtx src, int *l);\n+extern const char *avr_out_tstsi (rtx, rtx*, int*);\n+extern const char *avr_out_tsthi (rtx, rtx*, int*);\n+extern const char *avr_out_compare (rtx, rtx*, int*);\n extern const char *ret_cond_branch (rtx x, int len, int reverse);\n \n extern const char *ashlqi3_out (rtx insn, rtx operands[], int *len);\n@@ -103,7 +103,6 @@ extern void final_prescan_insn (rtx insn, rtx *operand, int num_operands);\n extern int avr_simplify_comparison_p (enum machine_mode mode,\n \t\t\t\t      RTX_CODE op, rtx x);\n extern RTX_CODE avr_normalize_condition (RTX_CODE condition);\n-extern int compare_eq_p (rtx insn);\n extern void out_shift_with_cnt (const char *templ, rtx insn,\n \t\t\t\trtx operands[], int *len, int t_len);\n extern rtx avr_incoming_return_addr_rtx (void);"}, {"sha": "16d536138382fcc63508d2be06c9ada086b894ed", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 163, "deletions": 47, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c0acd01953a277a4bb42d03de572c586a42b5e/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c0acd01953a277a4bb42d03de572c586a42b5e/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=a7c0acd01953a277a4bb42d03de572c586a42b5e", "patch": "@@ -69,9 +69,7 @@ static const char *ptrreg_to_str (int);\n static const char *cond_string (enum rtx_code);\n static int avr_num_arg_regs (enum machine_mode, const_tree);\n \n-static RTX_CODE compare_condition (rtx insn);\n static rtx avr_legitimize_address (rtx, rtx, enum machine_mode);\n-static int compare_sign_p (rtx insn);\n static tree avr_handle_progmem_attribute (tree *, tree, tree, int, bool *);\n static tree avr_handle_fndecl_attribute (tree *, tree, tree, int, bool *);\n static tree avr_handle_fntype_attribute (tree *, tree, tree, int, bool *);\n@@ -1291,7 +1289,8 @@ avr_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n        by OPERANDS.  This is just forwarding to output_asm_insn.\n    \n    If PLEN != NULL:\n-       Add N_WORDS to *PLEN.\n+       If N_WORDS >= 0  Add N_WORDS to *PLEN.\n+       If N_WORDS < 0   Set *PLEN to -N_WORDS.\n        Don't output anything.\n */\n \n@@ -1304,7 +1303,10 @@ avr_asm_len (const char* tpl, rtx* operands, int* plen, int n_words)\n     }\n   else\n     {\n-      *plen += n_words;\n+      if (n_words < 0)\n+        *plen = -n_words;\n+      else\n+        *plen += n_words;\n     }\n }\n \n@@ -3052,85 +3054,204 @@ compare_condition (rtx insn)\n   return UNKNOWN;\n }\n \n-/* Returns nonzero if INSN is a tst insn that only tests the sign.  */\n \n-static int\n+/* Returns true iff INSN is a tst insn that only tests the sign.  */\n+\n+static bool\n compare_sign_p (rtx insn)\n {\n   RTX_CODE cond = compare_condition (insn);\n   return (cond == GE || cond == LT);\n }\n \n-/* Returns nonzero if the next insn is a JUMP_INSN with a condition\n+\n+/* Returns true iff the next insn is a JUMP_INSN with a condition\n    that needs to be swapped (GT, GTU, LE, LEU).  */\n \n-int\n+static bool\n compare_diff_p (rtx insn)\n {\n   RTX_CODE cond = compare_condition (insn);\n   return (cond == GT || cond == GTU || cond == LE || cond == LEU) ? cond : 0;\n }\n \n-/* Returns nonzero if INSN is a compare insn with the EQ or NE condition.  */\n+/* Returns true iff INSN is a compare insn with the EQ or NE condition.  */\n \n-int\n+static bool\n compare_eq_p (rtx insn)\n {\n   RTX_CODE cond = compare_condition (insn);\n   return (cond == EQ || cond == NE);\n }\n \n \n+/* Output compare instruction\n+\n+      compare (XOP[0], XOP[1])\n+\n+   for an HI/SI register XOP[0] and an integer XOP[1].  Return \"\".\n+   XOP[2] is an 8-bit scratch register as needed.\n+\n+   PLEN == NULL:  Output instructions.\n+   PLEN != NULL:  Set *PLEN to the length (in words) of the sequence.\n+                  Don't output anything.  */\n+\n+const char*\n+avr_out_compare (rtx insn, rtx *xop, int *plen)\n+{\n+  /* Register to compare and value to compare against. */\n+  rtx xreg = xop[0];\n+  rtx xval = xop[1];\n+  \n+  /* MODE of the comparison.  */\n+  enum machine_mode mode = GET_MODE (xreg);\n+\n+  /* Number of bytes to operate on.  */\n+  int i, n_bytes = GET_MODE_SIZE (mode);\n+\n+  /* Value (0..0xff) held in clobber register xop[2] or -1 if unknown.  */\n+  int clobber_val = -1;\n+\n+  gcc_assert (REG_P (xreg)\n+              && CONST_INT_P (xval));\n+  \n+  if (plen)\n+    *plen = 0;\n+\n+  for (i = 0; i < n_bytes; i++)\n+    {\n+      /* We compare byte-wise.  */\n+      rtx reg8 = simplify_gen_subreg (QImode, xreg, mode, i);\n+      rtx xval8 = simplify_gen_subreg (QImode, xval, mode, i);\n+\n+      /* 8-bit value to compare with this byte.  */\n+      unsigned int val8 = UINTVAL (xval8) & GET_MODE_MASK (QImode);\n+\n+      /* Registers R16..R31 can operate with immediate.  */\n+      bool ld_reg_p = test_hard_reg_class (LD_REGS, reg8);\n+\n+      xop[0] = reg8;\n+      xop[1] = gen_int_mode (val8, QImode);\n+\n+      /* Word registers >= R24 can use SBIW/ADIW with 0..63.  */\n+\n+      if (i == 0\n+          && test_hard_reg_class (ADDW_REGS, reg8))\n+        {\n+          int val16 = trunc_int_for_mode (INTVAL (xval), HImode);\n+          \n+          if (IN_RANGE (val16, 0, 63)\n+              && (val8 == 0\n+                  || reg_unused_after (insn, xreg)))\n+            {\n+              avr_asm_len (\"sbiw %0,%1\", xop, plen, 1);\n+              i++;\n+              continue;\n+            }\n+\n+          if (n_bytes == 2\n+              && IN_RANGE (val16, -63, -1)\n+              && compare_eq_p (insn)\n+              && reg_unused_after (insn, xreg))\n+            {\n+              avr_asm_len (\"adiw %0,%n1\", xop, plen, 1);\n+              break;\n+            }\n+        }\n+\n+      /* Comparing against 0 is easy.  */\n+      \n+      if (val8 == 0)\n+        {\n+          avr_asm_len (i == 0\n+                       ? \"cp %0,__zero_reg__\"\n+                       : \"cpc %0,__zero_reg__\", xop, plen, 1);\n+          continue;\n+        }\n+\n+      /* Upper registers can compare and subtract-with-carry immediates.\n+         Notice that compare instructions do the same as respective subtract\n+         instruction; the only difference is that comparisons don't write\n+         the result back to the target register.  */\n+\n+      if (ld_reg_p)\n+        {\n+          if (i == 0)\n+            {\n+              avr_asm_len (\"cpi %0,%1\", xop, plen, 1);\n+              continue;\n+            }\n+          else if (reg_unused_after (insn, xreg))\n+            {\n+              avr_asm_len (\"sbci %0,%1\", xop, plen, 1);\n+              continue;\n+            }\n+        }\n+\n+      /* Must load the value into the scratch register.  */\n+\n+      gcc_assert (REG_P (xop[2]));\n+              \n+      if (clobber_val != (int) val8)\n+        avr_asm_len (\"ldi %2,%1\", xop, plen, 1);\n+      clobber_val = (int) val8;\n+              \n+      avr_asm_len (i == 0\n+                   ? \"cp %0,%2\"\n+                   : \"cpc %0,%2\", xop, plen, 1);\n+    }\n+\n+  return \"\";\n+}\n+\n+\n /* Output test instruction for HImode.  */\n \n-const char *\n-out_tsthi (rtx insn, rtx op, int *l)\n+const char*\n+avr_out_tsthi (rtx insn, rtx *op, int *plen)\n {\n   if (compare_sign_p (insn))\n     {\n-      if (l) *l = 1;\n-      return AS1 (tst,%B0);\n+      avr_asm_len (\"tst %B0\", op, plen, -1);\n     }\n-  if (reg_unused_after (insn, op)\n-      && compare_eq_p (insn))\n+  else if (reg_unused_after (insn, op[0])\n+           && compare_eq_p (insn))\n     {\n       /* Faster than sbiw if we can clobber the operand.  */\n-      if (l) *l = 1;\n-      return \"or %A0,%B0\";\n+      avr_asm_len (\"or %A0,%B0\", op, plen, -1);\n     }\n-  if (test_hard_reg_class (ADDW_REGS, op))\n+  else\n     {\n-      if (l) *l = 1;\n-      return AS2 (sbiw,%0,0);\n+      avr_out_compare (insn, op, plen);\n     }\n-  if (l) *l = 2;\n-  return (AS2 (cp,%A0,__zero_reg__) CR_TAB\n-          AS2 (cpc,%B0,__zero_reg__));\n+\n+  return \"\";\n }\n \n \n /* Output test instruction for SImode.  */\n \n-const char *\n-out_tstsi (rtx insn, rtx op, int *l)\n+const char*\n+avr_out_tstsi (rtx insn, rtx *op, int *plen)\n {\n   if (compare_sign_p (insn))\n     {\n-      if (l) *l = 1;\n-      return AS1 (tst,%D0);\n+      avr_asm_len (\"tst %D0\", op, plen, -1);\n     }\n-  if (test_hard_reg_class (ADDW_REGS, op))\n+  else if (reg_unused_after (insn, op[0])\n+           && compare_eq_p (insn))\n     {\n-      if (l) *l = 3;\n-      return (AS2 (sbiw,%A0,0) CR_TAB\n-              AS2 (cpc,%C0,__zero_reg__) CR_TAB\n-              AS2 (cpc,%D0,__zero_reg__));\n+      /* Faster than sbiw if we can clobber the operand.  */\n+      avr_asm_len (\"or %A0,%B0\" CR_TAB\n+                   \"or %A0,%C0\" CR_TAB\n+                   \"or %A0,%D0\", op, plen, -3);\n+    }\n+  else\n+    {\n+      avr_out_compare (insn, op, plen);\n     }\n-  if (l) *l = 4;\n-  return (AS2 (cp,%A0,__zero_reg__) CR_TAB\n-          AS2 (cpc,%B0,__zero_reg__) CR_TAB\n-          AS2 (cpc,%C0,__zero_reg__) CR_TAB\n-          AS2 (cpc,%D0,__zero_reg__));\n+\n+  return \"\";\n }\n \n \n@@ -5016,6 +5137,10 @@ adjust_insn_length (rtx insn, int len)\n           avr_out_plus (op, &len);\n           break;\n \n+        case ADJUST_LEN_TSTHI: avr_out_tsthi (insn, op, &len); break;\n+        case ADJUST_LEN_TSTSI: avr_out_tstsi (insn, op, &len); break;\n+        case ADJUST_LEN_COMPARE: avr_out_compare (insn, op, &len); break;\n+          \n         default:\n           gcc_unreachable();\n         }\n@@ -5051,15 +5176,6 @@ adjust_insn_length (rtx insn, int len)\n \t      break;\n \t    }\n \t}\n-      else if (op[0] == cc0_rtx && REG_P (op[1]))\n-\t{\n-\t  switch (GET_MODE (op[1]))\n-\t    {\n-\t    case HImode: out_tsthi (insn, op[1], &len); break;\n-\t    case SImode: out_tstsi (insn, op[1], &len); break;\n-\t    default: break;\n-\t    }\n-\t}\n     }\n   set = single_set (insn);\n   if (set)"}, {"sha": "06e00392dbc8836a57aee4436b6fb8ecfdcca498", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 45, "deletions": 108, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c0acd01953a277a4bb42d03de572c586a42b5e/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c0acd01953a277a4bb42d03de572c586a42b5e/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=a7c0acd01953a277a4bb42d03de572c586a42b5e", "patch": "@@ -136,7 +136,7 @@\n ;; Otherwise do special processing depending on the attribute.\n \n (define_attr \"adjust_len\"\n-  \"yes,no,reload_in32,out_bitop,out_plus\"\n+  \"yes,no,reload_in32,out_bitop,out_plus,tsthi,tstsi,compare\"\n   (const_string \"yes\"))\n \n ;; Define mode iterators\n@@ -3344,125 +3344,62 @@\n \n (define_insn \"*cmpqi_sign_extend\"\n   [(set (cc0)\n-        (compare (sign_extend:HI\n-\t\t  (match_operand:QI 0 \"register_operand\"  \"d\"))\n-\t\t (match_operand:HI 1 \"const_int_operand\" \"n\")))]\n-  \"INTVAL (operands[1]) >= -128 && INTVAL (operands[1]) <= 127\"\n+        (compare (sign_extend:HI (match_operand:QI 0 \"register_operand\" \"d\"))\n+                 (match_operand:HI 1 \"s8_operand\"                       \"n\")))]\n+  \"\"\n   \"cpi %0,lo8(%1)\"\n   [(set_attr \"cc\" \"compare\")\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*cmphi\"\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"register_operand\"  \"!w,r,r,d,d,r,r\")\n-\t\t (match_operand:HI 1 \"nonmemory_operand\" \"L,L,r,M,i,M,i\")))\n-   (clobber (match_scratch:QI 2 \"=X,X,X,X,&d,&d,&d\"))]\n+        (compare (match_operand:HI 0 \"register_operand\"  \"!w,r,r,d ,r  ,d,r\")\n+                 (match_operand:HI 1 \"nonmemory_operand\" \"L ,L,r,s ,s  ,M,n\")))\n+   (clobber (match_scratch:QI 2                         \"=X ,X,X,&d,&d ,X,&d\"))]\n   \"\"\n-  \"*{\n-  switch (which_alternative)\n-    {\n-    case 0: case 1:\n-      return out_tsthi (insn, operands[0], NULL);\n-\n-    case 2:\n-      return (AS2 (cp,%A0,%A1) CR_TAB\n-              AS2 (cpc,%B0,%B1));\n-    case 3:\n-      if (reg_unused_after (insn, operands[0])\n-          && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 63\n-          && test_hard_reg_class (ADDW_REGS, operands[0]))\n-        return AS2 (sbiw,%0,%1);\n-       else\n-        return (AS2 (cpi,%0,%1) CR_TAB\n-                AS2 (cpc,%B0,__zero_reg__));\n-    case 4:\n-      if (reg_unused_after (insn, operands[0]))\n-        return (AS2 (subi,%0,lo8(%1))  CR_TAB\n-                AS2 (sbci,%B0,hi8(%1)));\n-      else\n-        return (AS2 (ldi, %2,hi8(%1))  CR_TAB\n-\t        AS2 (cpi, %A0,lo8(%1)) CR_TAB\n-\t        AS2 (cpc, %B0,%2));\n-   case 5:\n-      return (AS2 (ldi, %2,lo8(%1))  CR_TAB\n-\t      AS2 (cp, %A0,%2) CR_TAB\n-\t      AS2 (cpc, %B0,__zero_reg__));\n-\n-   case 6:\n-      return (AS2 (ldi, %2,lo8(%1))  CR_TAB\n-              AS2 (cp, %A0,%2)       CR_TAB\n-              AS2 (ldi, %2,hi8(%1)) CR_TAB\n-\t      AS2 (cpc, %B0,%2));\n-    }\n-  return \\\"bug\\\";\n-}\" \n-  [(set_attr \"cc\" \"compare,compare,compare,compare,compare,compare,compare\")\n-   (set_attr \"length\" \"1,2,2,2,3,3,4\")])\n+  {\n+    switch (which_alternative)\n+      {\n+      case 0:\n+      case 1:\n+        return avr_out_tsthi (insn, operands, NULL);\n+        \n+      case 2:\n+        return \"cp %A0,%A1\\;cpc %B0,%B1\";\n+\n+      case 3:\n+        return reg_unused_after (insn, operands[0])\n+               ? \"subi %A0,lo8(%1)\\;sbci %B0,hi8(%1)\"\n+               : \"ldi %2,hi8(%1)\\;cpi %A0,lo8(%1)\\;cpc %B0,%2\";\n+               \n+      case 4:\n+        return \"ldi %2,lo8(%1)\\;cp %A0,%2\\;ldi %2,hi8(%1)\\;cpc %B0,%2\";\n+      }\n+      \n+    return avr_out_compare (insn, operands, NULL);\n+  } \n+  [(set_attr \"cc\" \"compare\")\n+   (set_attr \"length\" \"1,2,2,3,4,2,4\")\n+   (set_attr \"adjust_len\" \"tsthi,tsthi,no,no,no,compare,compare\")])\n \n \n (define_insn \"*cmpsi\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\"  \"r,r,d,d,r,r\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"L,r,M,i,M,i\")))\n-   (clobber (match_scratch:QI 2 \"=X,X,X,&d,&d,&d\"))]\n+        (compare (match_operand:SI 0 \"register_operand\"  \"r,r ,d,r ,r\")\n+                 (match_operand:SI 1 \"nonmemory_operand\" \"L,r ,M,M ,n\")))\n+   (clobber (match_scratch:QI 2                         \"=X,X ,X,&d,&d\"))]\n   \"\"\n-  \"*{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return out_tstsi (insn, operands[0], NULL);\n-\n-    case 1:\n-      return (AS2 (cp,%A0,%A1) CR_TAB\n-              AS2 (cpc,%B0,%B1) CR_TAB\n-\t      AS2 (cpc,%C0,%C1) CR_TAB\n-\t      AS2 (cpc,%D0,%D1));\n-    case 2:\n-      if (reg_unused_after (insn, operands[0])\n-          && INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 63\n-          && test_hard_reg_class (ADDW_REGS, operands[0]))\n-        return (AS2 (sbiw,%0,%1) CR_TAB\n-                AS2 (cpc,%C0,__zero_reg__) CR_TAB\n-                AS2 (cpc,%D0,__zero_reg__));\n-      else\n-        return (AS2 (cpi,%A0,lo8(%1))  CR_TAB\n-                AS2 (cpc,%B0,__zero_reg__) CR_TAB\n-                AS2 (cpc,%C0,__zero_reg__) CR_TAB\n-                AS2 (cpc,%D0,__zero_reg__));\n-    case 3:\n-      if (reg_unused_after (insn, operands[0]))\n-        return (AS2 (subi,%A0,lo8(%1))  CR_TAB\n-                AS2 (sbci,%B0,hi8(%1))  CR_TAB\n-                AS2 (sbci,%C0,hlo8(%1))  CR_TAB\n-                AS2 (sbci,%D0,hhi8(%1)));\n-      else\n-       return (AS2 (cpi, %A0,lo8(%1))   CR_TAB\n-\t       AS2 (ldi, %2,hi8(%1))  CR_TAB\n-\t       AS2 (cpc, %B0,%2)       CR_TAB\n-\t       AS2 (ldi, %2,hlo8(%1))  CR_TAB\n-\t       AS2 (cpc, %C0,%2)       CR_TAB\n-\t       AS2 (ldi, %2,hhi8(%1)) CR_TAB\n-\t       AS2 (cpc, %D0,%2));\n-    case 4:\n-        return (AS2 (ldi,%2,lo8(%1))        CR_TAB\n-                AS2 (cp,%A0,%2)            CR_TAB\n-                AS2 (cpc,%B0,__zero_reg__) CR_TAB\n-                AS2 (cpc,%C0,__zero_reg__) CR_TAB\n-                AS2 (cpc,%D0,__zero_reg__));\n-    case 5:\n-       return (AS2 (ldi, %2,lo8(%1))   CR_TAB\n-               AS2 (cp, %A0,%2)        CR_TAB\n-\t       AS2 (ldi, %2,hi8(%1))  CR_TAB\n-\t       AS2 (cpc, %B0,%2)       CR_TAB\n-\t       AS2 (ldi, %2,hlo8(%1))  CR_TAB\n-\t       AS2 (cpc, %C0,%2)       CR_TAB\n-\t       AS2 (ldi, %2,hhi8(%1)) CR_TAB\n-\t       AS2 (cpc, %D0,%2));\n-    }\n-  return \\\"bug\\\";\n-}\"\n-  [(set_attr \"cc\" \"compare,compare,compare,compare,compare,compare\")\n-   (set_attr \"length\" \"4,4,4,7,5,8\")])\n+  {\n+    if (0 == which_alternative)\n+      return avr_out_tstsi (insn, operands, NULL);\n+    else if (1 == which_alternative)\n+      return \"cp %A0,%A1\\;cpc %B0,%B1\\;cpc %C0,%C1\\;cpc %D0,%D1\";\n+      \n+    return avr_out_compare (insn, operands, NULL);\n+  }\n+  [(set_attr \"cc\" \"compare\")\n+   (set_attr \"length\" \"4,4,4,5,8\")\n+   (set_attr \"adjust_len\" \"tstsi,no,compare,compare,compare\")])\n \n \n ;; ----------------------------------------------------------------------"}]}