{"sha": "1722e2013f05f1f1f99379dbaa0c0df356da731f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcyMmUyMDEzZjA1ZjFmMWY5OTM3OWRiYWEwYzBkZjM1NmRhNzMxZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-07-21T04:19:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-07-29T18:24:59Z"}, "message": "c++: Implement C++20 implicit move changes. [PR91427]\n\nP1825R0 extends the C++11 implicit move on return by removing the\nconstraints on the called constructor: previously, it needed to take an\nrvalue reference to the type of the returned variable.  The paper also\nallows move on throw of parameters and implicit move of rvalue references.\n\nDiscussion on the CWG reflector about how to avoid breaking the PR91212 test\nin the new model settled on the model of doing only a single overload\nresolution, with the variable treated as an xvalue that can bind to\nnon-const lvalue references.  So this patch implements that approach.  The\nimplementation does not use the existing LOOKUP_PREFER_RVALUE flag, but\ninstead sets a flag on the representation of the static_cast turning the\nvariable into an xvalue.\n\nFor the time being I'm limiting the new semantics to C++20 mode; since it\nwas moved as a DR, we will probably want to apply the change to other\nstandard modes as well once we have a better sense of the impact on existing\ncode, probably in GCC 12.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/91427\n\t* cp-tree.h (IMPLICIT_RVALUE_P): New.\n\t(enum cp_lvalue_kind_flags): Add clk_implicit_rval.\n\t(implicit_rvalue_p, set_implicit_rvalue_p): New.\n\t* call.c (reference_binding): Check clk_implicit_rval.\n\t(build_over_call): Adjust C++20 implicit move.\n\t* coroutines.cc (finish_co_return_stmt): Simplify implicit move.\n\t* except.c (build_throw): Adjust C++20 implicit move.\n\t* pt.c (tsubst_copy_and_build) [STATIC_CAST_EXPR]: Propagate\n\tIMPLICIT_RVALUE_P.\n\t* tree.c (lvalue_kind): Set clk_implicit_rval.\n\t* typeck.c (treat_lvalue_as_rvalue_p): Overhaul.\n\t(maybe_warn_pessimizing_move): Adjust.\n\t(check_return_expr): Adjust C++20 implicit move.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/91427\n\t* g++.dg/coroutines/co-return-syntax-10-movable.C: Extend.\n\t* g++.dg/cpp0x/Wredundant-move1.C: Adjust for C++20.\n\t* g++.dg/cpp0x/Wredundant-move7.C: Adjust for C++20.\n\t* g++.dg/cpp0x/Wredundant-move9.C: Adjust for C++20.\n\t* g++.dg/cpp0x/elision_neg.C: Adjust for C++20.\n\t* g++.dg/cpp0x/move-return2.C: Adjust for C++20.\n\t* g++.dg/cpp0x/ref-qual20.C: Adjust for C++20.\n\t* g++.dg/cpp2a/implicit-move1.C: New test.\n\t* g++.dg/cpp2a/implicit-move2.C: New test.\n\t* g++.dg/cpp2a/implicit-move3.C: New test.", "tree": {"sha": "700c28dfdf865fbe07e5823a5a828fd15e9746dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/700c28dfdf865fbe07e5823a5a828fd15e9746dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1722e2013f05f1f1f99379dbaa0c0df356da731f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1722e2013f05f1f1f99379dbaa0c0df356da731f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1722e2013f05f1f1f99379dbaa0c0df356da731f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1722e2013f05f1f1f99379dbaa0c0df356da731f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81bc0ec3e926d7a2c90502847ddaacf3d56d5b75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81bc0ec3e926d7a2c90502847ddaacf3d56d5b75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81bc0ec3e926d7a2c90502847ddaacf3d56d5b75"}], "stats": {"total": 353, "additions": 279, "deletions": 74}, "files": [{"sha": "f164b211c9f58585f9bc9894f4be74141233b51a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -1822,6 +1822,9 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n \n       /* Nor the reverse.  */\n       if (!is_lvalue && !TYPE_REF_IS_RVALUE (rto)\n+\t  /* Unless it's really an lvalue.  */\n+\t  && !(cxx_dialect >= cxx20\n+\t       && (gl_kind & clk_implicit_rval))\n \t  && (!CP_TYPE_CONST_NON_VOLATILE_P (to)\n \t      || (flags & LOOKUP_NO_RVAL_BIND))\n \t  && TREE_CODE (to) != FUNCTION_TYPE)\n@@ -8678,7 +8681,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t  parm = TREE_CHAIN (parm);\n \t}\n \n-      if (cand->flags & LOOKUP_PREFER_RVALUE)\n+      if (cxx_dialect < cxx20\n+\t  && (cand->flags & LOOKUP_PREFER_RVALUE))\n \t{\n \t  /* The implicit move specified in 15.8.3/3 fails \"...if the type of\n \t     the first parameter of the selected constructor is not an rvalue"}, {"sha": "8bebbe3f9e1aea8dd9d73816af652ec6a593797f", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -1189,29 +1189,15 @@ finish_co_return_stmt (location_t kw, tree expr)\n \t treating the object as an rvalue, if that fails, then we fall back\n \t to regular overload resolution.  */\n \n-      if (treat_lvalue_as_rvalue_p (expr, /*parm_ok*/true)\n-\t  && CLASS_TYPE_P (TREE_TYPE (expr))\n-\t  && !TYPE_VOLATILE (TREE_TYPE (expr)))\n-\t{\n-\t  /* It's OK if this fails... */\n-\t  vec<tree, va_gc> *args = make_tree_vector_single (move (expr));\n-\t  co_ret_call\n-\t    = coro_build_promise_expression (current_function_decl, NULL,\n-\t\t\t\t\t     coro_return_value_identifier, kw,\n-\t\t\t\t\t     &args, /*musthave=*/false);\n-\t  release_tree_vector (args);\n-\t}\n-\n-      if (!co_ret_call || co_ret_call == error_mark_node)\n-\t{\n-\t  /* ... but this must succeed if we didn't get the move variant.  */\n-\t  vec<tree, va_gc> *args = make_tree_vector_single (expr);\n-\t  co_ret_call\n-\t    = coro_build_promise_expression (current_function_decl, NULL,\n-\t\t\t\t\t     coro_return_value_identifier, kw,\n-\t\t\t\t\t     &args, /*musthave=*/true);\n-\t  release_tree_vector (args);\n-\t}\n+      tree arg = expr;\n+      if (tree moved = treat_lvalue_as_rvalue_p (expr, /*return*/true))\n+\targ = moved;\n+\n+      releasing_vec args = make_tree_vector_single (arg);\n+      co_ret_call\n+\t= coro_build_promise_expression (current_function_decl, NULL,\n+\t\t\t\t\t coro_return_value_identifier, kw,\n+\t\t\t\t\t &args, /*musthave=*/true);\n     }\n \n   /* Makes no sense for a co-routine really. */"}, {"sha": "ea4871f836a54a2b1072d2f127c87c51d3038bb7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -466,7 +466,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       IMPLICIT_CONV_EXPR_BRACED_INIT (in IMPLICIT_CONV_EXPR)\n       TINFO_VAR_DECLARED_CONSTINIT (in TEMPLATE_INFO)\n       CALL_FROM_NEW_OR_DELETE_P (in CALL_EXPR)\n-   3: (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n+   3: IMPLICIT_RVALUE_P (in NON_LVALUE_EXPR or STATIC_CAST_EXPR)\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n       BIND_EXPR_BODY_BLOCK (in BIND_EXPR)\n@@ -3803,6 +3803,11 @@ struct GTY(()) lang_decl {\n    && TREE_TYPE (TREE_OPERAND (NODE, 0))\t\t\\\n    && TYPE_REF_P (TREE_TYPE (TREE_OPERAND ((NODE), 0))))\n \n+/* True iff this represents an lvalue being treated as an rvalue during return\n+   or throw as per [class.copy.elision].  */\n+#define IMPLICIT_RVALUE_P(NODE) \\\n+  TREE_LANG_FLAG_3 (TREE_CHECK2 ((NODE), NON_LVALUE_EXPR, STATIC_CAST_EXPR))\n+\n #define NEW_EXPR_USE_GLOBAL(NODE) \\\n   TREE_LANG_FLAG_0 (NEW_EXPR_CHECK (NODE))\n #define DELETE_EXPR_USE_GLOBAL(NODE) \\\n@@ -5184,7 +5189,8 @@ enum cp_lvalue_kind_flags {\n   clk_rvalueref = 2,/* An xvalue (rvalue formed using an rvalue reference) */\n   clk_class = 4,    /* A prvalue of class or array type.  */\n   clk_bitfield = 8, /* An lvalue for a bit-field.  */\n-  clk_packed = 16   /* An lvalue for a packed field.  */\n+  clk_packed = 16,  /* An lvalue for a packed field.  */\n+  clk_implicit_rval = 1<<5 /* An lvalue being treated as an xvalue.  */\n };\n \n /* This type is used for parameters and variables which hold\n@@ -5572,6 +5578,8 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n    not found by lookup.)  */\n #define LOOKUP_HIDDEN (LOOKUP_PREFER_NAMESPACES << 1)\n /* We're trying to treat an lvalue as an rvalue.  */\n+/* FIXME remove when we extend the P1825 semantics to all standard modes, the\n+   C++20 approach uses IMPLICIT_RVALUE_P instead.  */\n #define LOOKUP_PREFER_RVALUE (LOOKUP_HIDDEN << 1)\n /* We're inside an init-list, so narrowing conversions are ill-formed.  */\n #define LOOKUP_NO_NARROWING (LOOKUP_PREFER_RVALUE << 1)\n@@ -7645,7 +7653,7 @@ extern tree cp_perform_integral_promotions      (tree, tsubst_flags_t);\n extern tree finish_left_unary_fold_expr      (tree, int);\n extern tree finish_right_unary_fold_expr     (tree, int);\n extern tree finish_binary_fold_expr          (tree, tree, int);\n-extern bool treat_lvalue_as_rvalue_p\t     (tree, bool);\n+extern tree treat_lvalue_as_rvalue_p\t     (tree, bool);\n extern bool decl_in_std_namespace_p\t     (tree);\n \n /* in typeck2.c */\n@@ -8116,6 +8124,27 @@ concept_check_p (const_tree t)\n   return false;\n }\n \n+/* Helpers for IMPLICIT_RVALUE_P to look through automatic dereference.  */\n+\n+inline bool\n+implicit_rvalue_p (const_tree t)\n+{\n+  if (REFERENCE_REF_P (t))\n+    t = TREE_OPERAND (t, 0);\n+  return ((TREE_CODE (t) == NON_LVALUE_EXPR\n+\t   || TREE_CODE (t) == STATIC_CAST_EXPR)\n+\t  && IMPLICIT_RVALUE_P (t));\n+}\n+inline tree\n+set_implicit_rvalue_p (tree ot)\n+{\n+  tree t = ot;\n+  if (REFERENCE_REF_P (t))\n+    t = TREE_OPERAND (t, 0);\n+  IMPLICIT_RVALUE_P (t) = 1;\n+  return ot;\n+}\n+\n /* True if t is a \"constrained auto\" type-specifier.  */\n \n inline bool"}, {"sha": "cb1a4105dae16c81c0f2cb589b63d556ecabd6e1", "filename": "gcc/cp/except.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -696,21 +696,25 @@ build_throw (location_t loc, tree exp)\n \t  /* Under C++0x [12.8/16 class.copy], a thrown lvalue is sometimes\n \t     treated as an rvalue for the purposes of overload resolution\n \t     to favor move constructors over copy constructors.  */\n-\t  if (treat_lvalue_as_rvalue_p (exp, /*parm_ok*/false)\n-\t      /* The variable must not have the `volatile' qualifier.  */\n-\t      && !CP_TYPE_VOLATILE_P (TREE_TYPE (exp)))\n+\t  if (tree moved = treat_lvalue_as_rvalue_p (exp, /*return*/false))\n \t    {\n-\t      tree moved = move (exp);\n-\t      releasing_vec exp_vec (make_tree_vector_single (moved));\n-\t      moved = (build_special_member_call\n-\t\t       (object, complete_ctor_identifier, &exp_vec,\n-\t\t\tTREE_TYPE (object), flags|LOOKUP_PREFER_RVALUE,\n-\t\t\ttf_none));\n-\t      if (moved != error_mark_node)\n+\t      if (cxx_dialect < cxx20)\n \t\t{\n-\t\t  exp = moved;\n-\t\t  converted = true;\n+\t\t  releasing_vec exp_vec (make_tree_vector_single (moved));\n+\t\t  moved = (build_special_member_call\n+\t\t\t   (object, complete_ctor_identifier, &exp_vec,\n+\t\t\t    TREE_TYPE (object), flags|LOOKUP_PREFER_RVALUE,\n+\t\t\t    tf_none));\n+\t\t  if (moved != error_mark_node)\n+\t\t    {\n+\t\t      exp = moved;\n+\t\t      converted = true;\n+\t\t    }\n \t\t}\n+\t      else\n+\t\t/* In C++20 we just treat the return value as an rvalue that\n+\t\t   can bind to lvalue refs.  */\n+\t\texp = moved;\n \t    }\n \n \t  /* Call the copy constructor.  */"}, {"sha": "6a42cf93dccb4518d50020465d20bfc035505951", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -19411,6 +19411,8 @@ tsubst_copy_and_build (tree t,\n \t    break;\n \t  case STATIC_CAST_EXPR:\n \t    r = build_static_cast (input_location, type, op, complain);\n+\t    if (IMPLICIT_RVALUE_P (t))\n+\t      set_implicit_rvalue_p (r);\n \t    break;\n \t  default:\n \t    gcc_unreachable ();"}, {"sha": "e8606602bd21589bbdaec17a516f836dc43523e9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -73,7 +73,12 @@ lvalue_kind (const_tree ref)\n \t  && TREE_CODE (ref) != COMPONENT_REF\n \t  /* Functions are always lvalues.  */\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (ref))) != FUNCTION_TYPE)\n-\treturn clk_rvalueref;\n+\t{\n+\t  op1_lvalue_kind = clk_rvalueref;\n+\t  if (implicit_rvalue_p (ref))\n+\t    op1_lvalue_kind |= clk_implicit_rval;\n+\t  return op1_lvalue_kind;\n+\t}\n \n       /* lvalue references and named rvalue references are lvalues.  */\n       return clk_ordinary;"}, {"sha": "a557f3439a8f49111ddda5533c3ab24cc1d5c120", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 74, "deletions": 23, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -9719,19 +9719,62 @@ can_do_nrvo_p (tree retval, tree functype)\n \t  && !TYPE_VOLATILE (TREE_TYPE (retval)));\n }\n \n-/* Returns true if we should treat RETVAL, an expression being returned,\n-   as if it were designated by an rvalue.  See [class.copy.elision].\n-   PARM_P is true if a function parameter is OK in this context.  */\n+/* If we should treat RETVAL, an expression being returned, as if it were\n+   designated by an rvalue, returns it adjusted accordingly; otherwise, returns\n+   NULL_TREE.  See [class.copy.elision].  RETURN_P is true if this is a return\n+   context (rather than throw).  */\n \n-bool\n-treat_lvalue_as_rvalue_p (tree retval, bool parm_ok)\n+tree\n+treat_lvalue_as_rvalue_p (tree expr, bool return_p)\n {\n+  if (cxx_dialect == cxx98)\n+    return NULL_TREE;\n+\n+  tree retval = expr;\n   STRIP_ANY_LOCATION_WRAPPER (retval);\n-  return ((cxx_dialect != cxx98)\n-\t  && ((VAR_P (retval) && !DECL_HAS_VALUE_EXPR_P (retval))\n-\t      || (parm_ok && TREE_CODE (retval) == PARM_DECL))\n-\t  && DECL_CONTEXT (retval) == current_function_decl\n-\t  && !TREE_STATIC (retval));\n+  if (REFERENCE_REF_P (retval))\n+    retval = TREE_OPERAND (retval, 0);\n+\n+  /* An implicitly movable entity is a variable of automatic storage duration\n+     that is either a non-volatile object or (C++20) an rvalue reference to a\n+     non-volatile object type.  */\n+  if (!(((VAR_P (retval) && !DECL_HAS_VALUE_EXPR_P (retval))\n+\t || TREE_CODE (retval) == PARM_DECL)\n+\t&& !TREE_STATIC (retval)\n+\t&& !CP_TYPE_VOLATILE_P (non_reference (TREE_TYPE (retval)))\n+\t&& (TREE_CODE (TREE_TYPE (retval)) != REFERENCE_TYPE\n+\t    || (cxx_dialect >= cxx20\n+\t\t&& TYPE_REF_IS_RVALUE (TREE_TYPE (retval))))))\n+    return NULL_TREE;\n+\n+  /* If the expression in a return or co_return statement is a (possibly\n+     parenthesized) id-expression that names an implicitly movable entity\n+     declared in the body or parameter-declaration-clause of the innermost\n+     enclosing function or lambda-expression, */\n+  if (DECL_CONTEXT (retval) != current_function_decl)\n+    return NULL_TREE;\n+  if (return_p)\n+    return set_implicit_rvalue_p (move (expr));\n+\n+  /* if the operand of a throw-expression is a (possibly parenthesized)\n+     id-expression that names an implicitly movable entity whose scope does not\n+     extend beyond the compound-statement of the innermost try-block or\n+     function-try-block (if any) whose compound-statement or ctor-initializer\n+     encloses the throw-expression, */\n+\n+  /* C++20 added move on throw of parms.  */\n+  if (TREE_CODE (retval) == PARM_DECL && cxx_dialect < cxx20)\n+    return NULL_TREE;\n+\n+  for (cp_binding_level *b = current_binding_level;\n+       ; b = b->level_chain)\n+    {\n+      for (tree decl = b->names; decl; decl = TREE_CHAIN (decl))\n+\tif (decl == retval)\n+\t  return set_implicit_rvalue_p (move (expr));\n+      if (b->kind == sk_function_parms || b->kind == sk_try)\n+\treturn NULL_TREE;\n+    }\n }\n \n /* Warn about wrong usage of std::move in a return statement.  RETVAL\n@@ -9767,6 +9810,7 @@ maybe_warn_pessimizing_move (tree retval, tree functype)\n       if (is_std_move_p (fn))\n \t{\n \t  tree arg = CALL_EXPR_ARG (fn, 0);\n+\t  tree moved;\n \t  if (TREE_CODE (arg) != NOP_EXPR)\n \t    return;\n \t  arg = TREE_OPERAND (arg, 0);\n@@ -9786,12 +9830,12 @@ maybe_warn_pessimizing_move (tree retval, tree functype)\n \t  /* Warn if the move is redundant.  It is redundant when we would\n \t     do maybe-rvalue overload resolution even without std::move.  */\n \t  else if (warn_redundant_move\n-\t\t   && treat_lvalue_as_rvalue_p (arg, /*parm_ok*/true))\n+\t\t   && (moved = treat_lvalue_as_rvalue_p (arg, /*return*/true)))\n \t    {\n \t      /* Make sure that the overload resolution would actually succeed\n \t\t if we removed the std::move call.  */\n \t      tree t = convert_for_initialization (NULL_TREE, functype,\n-\t\t\t\t\t\t   move (arg),\n+\t\t\t\t\t\t   moved,\n \t\t\t\t\t\t   (LOOKUP_NORMAL\n \t\t\t\t\t\t    | LOOKUP_ONLYCONVERTING\n \t\t\t\t\t\t    | LOOKUP_PREFER_RVALUE),\n@@ -10089,19 +10133,26 @@ check_return_expr (tree retval, bool *no_warning)\n          Note that these conditions are similar to, but not as strict as,\n \t the conditions for the named return value optimization.  */\n       bool converted = false;\n-      if (treat_lvalue_as_rvalue_p (retval, /*parm_ok*/true)\n-\t  /* This is only interesting for class type.  */\n-\t  && CLASS_TYPE_P (functype))\n-\t{\n-\t  tree moved = move (retval);\n-\t  moved = convert_for_initialization\n-\t    (NULL_TREE, functype, moved, flags|LOOKUP_PREFER_RVALUE,\n-\t     ICR_RETURN, NULL_TREE, 0, tf_none);\n-\t  if (moved != error_mark_node)\n+      tree moved;\n+      /* This is only interesting for class type.  */\n+      if (CLASS_TYPE_P (functype)\n+\t  && (moved = treat_lvalue_as_rvalue_p (retval, /*return*/true)))\n+\t{\n+\t  if (cxx_dialect < cxx20)\n \t    {\n-\t      retval = moved;\n-\t      converted = true;\n+\t      moved = convert_for_initialization\n+\t\t(NULL_TREE, functype, moved, flags|LOOKUP_PREFER_RVALUE,\n+\t\t ICR_RETURN, NULL_TREE, 0, tf_none);\n+\t      if (moved != error_mark_node)\n+\t\t{\n+\t\t  retval = moved;\n+\t\t  converted = true;\n+\t\t}\n \t    }\n+\t  else\n+\t    /* In C++20 we just treat the return value as an rvalue that\n+\t       can bind to lvalue refs.  */\n+\t    retval = moved;\n \t}\n \n       /* The call in a (lambda) thunk needs no conversions.  */"}, {"sha": "c6f36a7143f19e3c07ac96c372aa4cb70b60ea39", "filename": "gcc/testsuite/g++.dg/coroutines/co-return-syntax-10-movable.C", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-10-movable.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-10-movable.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fco-return-syntax-10-movable.C?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -35,6 +35,7 @@ struct coro1 {\n   coro::suspend_always final_suspend () const {  return {}; }\n \n   void return_value(T&& v) noexcept { value = std::move(v); }\n+  void return_value(const T&) noexcept = delete;\n   \n   T get_value (void) { return value; }\n   void unhandled_exception() { }\n@@ -59,9 +60,16 @@ struct MoveOnlyType\n   ~MoveOnlyType() { value_ = -2; }\n };\n \n+bool b1, b2;\n+\n coro1<MoveOnlyType> \n-my_coro ()\n+my_coro (MoveOnlyType p, MoveOnlyType &&r)\n {\n   MoveOnlyType x{10};\n-  co_return x;\n+  if (b1)\n+    co_return p;\n+  else if (b2)\n+    co_return r;\n+  else\n+    co_return x;\n }"}, {"sha": "ce4087b476fe375504dfe71762751da0ff260e49", "filename": "gcc/testsuite/g++.dg/cpp0x/Wredundant-move1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move1.C?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -60,7 +60,7 @@ fn4 (const T t)\n {\n   // t is const: will decay into copy despite std::move, so it's redundant.\n   // We used to warn about this, but no longer since c++/87378.\n-  return std::move (t);\n+  return std::move (t);\t // { dg-warning \"redundant move\" \"\" { target c++20 } }\n }\n \n int"}, {"sha": "3fec525879d8fbf487329f798c330fc5563c6518", "filename": "gcc/testsuite/g++.dg/cpp0x/Wredundant-move7.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move7.C?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -28,7 +28,7 @@ struct S2 : S1 {};\n S1\n f (S2 s)\n {\n-  return std::move(s); // { dg-bogus \"redundant move in return statement\" }\n+  return std::move(s); // { dg-warning \"redundant move in return statement\" \"\" { target c++20 } }\n }\n \n struct R1 {\n@@ -40,7 +40,7 @@ struct R2 : R1 {};\n R1\n f2 (const R2 s)\n {\n-  return std::move(s); // { dg-bogus \"redundant move in return statement\" }\n+  return std::move(s); // { dg-warning \"redundant move in return statement\" \"\" { target c++20 } }\n }\n \n struct T1 {\n@@ -55,5 +55,5 @@ f3 (const T2 s)\n {\n   // Without std::move: const T1 &\n   // With std::move: const T1 &&\n-  return std::move(s); // { dg-bogus \"redundant move in return statement\" }\n+  return std::move(s); // { dg-warning \"redundant move in return statement\" \"\" { target c++20 } }\n }"}, {"sha": "ca1e23b7a4bcae3b9898e8f7e4c2f0f78b6fa840", "filename": "gcc/testsuite/g++.dg/cpp0x/Wredundant-move9.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWredundant-move9.C?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -61,7 +61,7 @@ fn4 (const T<int> t)\n {\n   // t is const: will decay into copy despite std::move, so it's redundant.\n   // We used to warn about this, but no longer since c++/87378.\n-  return std::move (t);\n+  return std::move (t);\t // { dg-warning \"redundant move\" \"\" { target c++20 } }\n }\n \n int"}, {"sha": "6a181b27d3761586d1b65df7b60a2084fee98404", "filename": "gcc/testsuite/g++.dg/cpp0x/elision_neg.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_neg.C?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -30,7 +30,7 @@ test1()\n move_only\n test2(move_only&& x)\n {\n-    return x;  //  { dg-error \"within this context\" }\n+    return x;  //  { dg-error \"within this context\" \"\" { target c++17_down } }\n }\n \n int main()"}, {"sha": "999f2c95c4935bff6c1cd2bef6a9b67be1e2c118", "filename": "gcc/testsuite/g++.dg/cpp0x/move-return2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return2.C?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -7,5 +7,5 @@ struct S2 : S1 {};\n S1\n f (S2 s)\n {\n-  return s; // { dg-error \"use of deleted function\" }\n+  return s; // { dg-error \"use of deleted function\" \"\" { target c++17_down } }\n }"}, {"sha": "cfbef30022604bc5288651ef5dabec5bb898791b", "filename": "gcc/testsuite/g++.dg/cpp0x/ref-qual20.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fref-qual20.C?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -52,14 +52,15 @@ f5 ()\n int\n main ()\n {\n+  int return_lval = __cplusplus > 201703L ? -1 : 2;\n   Y y1 = f (A());\n-  if (y1.y != 2)\n+  if (y1.y != return_lval)\n     __builtin_abort ();\n   Y y2 = f2 (A());\n   if (y2.y != -1)\n     __builtin_abort ();\n   Y y3 = f3 ();\n-  if (y3.y != 2)\n+  if (y3.y != return_lval)\n     __builtin_abort ();\n   Y y4 = f4 ();\n   if (y4.y != -1)"}, {"sha": "4c284a13cae1107383373ebf9995047a98625243", "filename": "gcc/testsuite/g++.dg/cpp2a/implicit-move1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fimplicit-move1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fimplicit-move1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fimplicit-move1.C?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -0,0 +1,17 @@\n+// testcase from P1825R0\n+// { dg-do compile { target c++20 } }\n+\n+struct base {\n+    base();\n+    base(base const &);\n+private:\n+    base(base &&);\n+};\n+\n+struct derived : base {};\n+\n+base f(base b) {\n+    throw b;        // { dg-error \"\" } base(base &&) is private\n+    derived d;\n+    return d;       // { dg-error \"\" } base(base &&) is private\n+}"}, {"sha": "cb1379648c95de05d0b51bbf850c0616a0c2b104", "filename": "gcc/testsuite/g++.dg/cpp2a/implicit-move2.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fimplicit-move2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fimplicit-move2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fimplicit-move2.C?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -0,0 +1,49 @@\n+// Testcase from P1825R0\n+// { dg-do compile { target c++17 } }\n+\n+extern \"C\" void abort();\n+\n+int m;\n+\n+struct T\n+{\n+  int i;\n+  T(): i (42) { }\n+  T(const T& t) = delete;\n+  T(T&& t): i(t.i) { t.i = 0; ++m; }\n+};\n+\n+struct U\n+{\n+  int i;\n+  U(): i (42) { }\n+  U(const U& t): i(t.i) { }\n+  U(U&& t) = delete;\n+};\n+\n+template <class V> void g(const V&);\n+void h();\n+\n+bool b;\n+\n+void f()\n+{\n+  U x;\n+  try {\n+    T y;\n+    try { h(); }\n+    catch(...) {\n+      if (b)\n+        throw x;                // does not move\n+      throw y;                  // moves\n+    }\n+    g(y);\n+  } catch(...) {\n+    g(x);\n+  }\n+}\n+\n+int main()\n+{\n+  f();\n+}"}, {"sha": "a1f0b3d07405ecd44dda1928bc974fa72188af47", "filename": "gcc/testsuite/g++.dg/cpp2a/implicit-move3.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fimplicit-move3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1722e2013f05f1f1f99379dbaa0c0df356da731f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fimplicit-move3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fimplicit-move3.C?ref=1722e2013f05f1f1f99379dbaa0c0df356da731f", "patch": "@@ -0,0 +1,49 @@\n+// Testcase from P1825R0, modified for rvalue refs.\n+// { dg-do compile { target c++20 } }\n+\n+extern \"C\" void abort();\n+\n+int m;\n+\n+struct T\n+{\n+  int i;\n+  T(): i (42) { }\n+  T(const T& t) = delete;\n+  T(T&& t): i(t.i) { t.i = 0; ++m; }\n+};\n+\n+struct U\n+{\n+  int i;\n+  U(): i (42) { }\n+  U(const U& t): i(t.i) { }\n+  U(U&& t) = delete;\n+};\n+\n+template <class V> void g(const V&);\n+void h();\n+\n+bool b;\n+\n+void f()\n+{\n+  U&& x = U();\n+  try {\n+    T&& y = T();\n+    try { h(); }\n+    catch(...) {\n+      if (b)\n+        throw x;                // does not move\n+      throw y;                  // moves\n+    }\n+    g(y);\n+  } catch(...) {\n+    g(x);\n+  }\n+}\n+\n+int main()\n+{\n+  f();\n+}"}]}