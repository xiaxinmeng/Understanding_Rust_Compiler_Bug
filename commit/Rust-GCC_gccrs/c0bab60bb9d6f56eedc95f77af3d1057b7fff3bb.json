{"sha": "c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBiYWI2MGJiOWQ2ZjU2ZWVkYzk1Zjc3YWYzZDEwNTdiN2ZmZjNiYg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2020-07-10T15:13:57Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-19T09:53:41Z"}, "message": "[Ada] Ada_2020: Implement Key_Expression for named container aggregates\n\ngcc/ada/\n\n\t* par-ch4.adb: (P_Aggregate_Or_Paren_Expr): Recognize\n\tIterated_Element_Component.\n\t(P_Iterated_Component_Association): Rebuild node as an Iterated_\n\tElement_Association when Key_Expression is present, and attach\n\teither the Loop_Parameter_Specification or the\n\tIterator_Specification to the new node.\n\t* sem_aggr.adb: (Resolve_Container_Aggregate):\n\tResolve_Iterated_Association handles bota Iterated_Component_\n\tand Iterated_Element_Associations, in which case it analyzes and\n\tresoles the orresponding Key_Expression.\n\t* exp_aggr.adb (Expand_Iterated_Component): If a Key_Expression\n\tis present, use it as the required parameter in the call to the\n\tinsertion routine for the destination container aggregate. Call\n\tthis routine for both kinds of Iterated_Associations.", "tree": {"sha": "dab3252a76f14c20c02575c14109ad6d8e477610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dab3252a76f14c20c02575c14109ad6d8e477610"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86b3d0d55f947d8c5328a25b113bb52ae3ac89fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b3d0d55f947d8c5328a25b113bb52ae3ac89fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b3d0d55f947d8c5328a25b113bb52ae3ac89fa"}], "stats": {"total": 188, "additions": 149, "deletions": 39}, "files": [{"sha": "01e5c83366622eed8d8aba86c848ee08a34a5acc", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 70, "deletions": 12, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb", "patch": "@@ -6899,23 +6899,62 @@ package body Exp_Aggr is\n \n       procedure Expand_Iterated_Component (Comp : Node_Id) is\n          Expr    : constant Node_Id := Expression (Comp);\n-         Loop_Id : constant Entity_Id :=\n-            Make_Defining_Identifier (Loc,\n-              Chars => Chars (Defining_Identifier (Comp)));\n \n+         Key_Expr           : Node_Id := Empty;\n+         Loop_Id            : Entity_Id;\n          L_Range            : Node_Id;\n          L_Iteration_Scheme : Node_Id;\n          Loop_Stat          : Node_Id;\n          Stats              : List_Id;\n \n       begin\n-         if Present (Iterator_Specification (Comp)) then\n+         if Nkind (Comp) = N_Iterated_Element_Association then\n+            Key_Expr := Key_Expression (Comp);\n+\n+            --  We create a new entity as loop identifier in all cases,\n+            --  as is done for generated loops elsewhere, as the loop\n+            --  structure has been previously analyzed.\n+\n+            if Present (Iterator_Specification (Comp)) then\n+\n+               --  Either an Iterator_Specification of a Loop_Parameter_\n+               --  Specification is present.\n+\n+               L_Iteration_Scheme :=\n+                 Make_Iteration_Scheme (Loc,\n+                   Iterator_Specification => Iterator_Specification (Comp));\n+               Loop_Id :=\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Chars (Defining_Identifier\n+                               (Iterator_Specification (Comp))));\n+               Set_Defining_Identifier\n+                  (Iterator_Specification (L_Iteration_Scheme), Loop_Id);\n+\n+            else\n+               L_Iteration_Scheme :=\n+                 Make_Iteration_Scheme (Loc,\n+                   Loop_Parameter_Specification =>\n+                     Loop_Parameter_Specification (Comp));\n+               Loop_Id :=\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Chars (Defining_Identifier\n+                               (Loop_Parameter_Specification (Comp))));\n+               Set_Defining_Identifier\n+                  (Loop_Parameter_Specification\n+                     (L_Iteration_Scheme), Loop_Id);\n+            end if;\n+\n+         elsif Present (Iterator_Specification (Comp)) then\n             L_Iteration_Scheme :=\n               Make_Iteration_Scheme (Loc,\n                 Iterator_Specification => Iterator_Specification (Comp));\n \n          else\n             L_Range := Relocate_Node (First (Discrete_Choices (Comp)));\n+            Loop_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => Chars (Defining_Identifier (Comp)));\n+\n             L_Iteration_Scheme :=\n               Make_Iteration_Scheme (Loc,\n                 Loop_Parameter_Specification =>\n@@ -6928,6 +6967,9 @@ package body Exp_Aggr is\n          --  expression is needed. For a named aggregate, the loop variable,\n          --  whose type is that of the key, is an additional parameter for\n          --  the insertion operation.\n+         --  If a Key_Expression is present, it serves as the additional\n+         --  parameter. Otherwise the key is given by the loop parameter\n+         --  itself.\n \n          if Present (Add_Unnamed_Subp) then\n             Stats := New_List\n@@ -6937,13 +6979,27 @@ package body Exp_Aggr is\n                    New_List (New_Occurrence_Of (Temp, Loc),\n                      New_Copy_Tree (Expr))));\n          else\n-            Stats := New_List\n-              (Make_Procedure_Call_Statement (Loc,\n-                 Name => New_Occurrence_Of (Entity (Add_Named_Subp), Loc),\n-                 Parameter_Associations =>\n-                   New_List (New_Occurrence_Of (Temp, Loc),\n-                     New_Occurrence_Of (Loop_Id, Loc),\n-                     New_Copy_Tree (Expr))));\n+            --  Named or indexed aggregate, for which a key is present,\n+            --  possibly with a specified key_expression.\n+\n+            if Present (Key_Expr) then\n+               Stats := New_List\n+                 (Make_Procedure_Call_Statement (Loc,\n+                    Name => New_Occurrence_Of (Entity (Add_Named_Subp), Loc),\n+                    Parameter_Associations =>\n+                      New_List (New_Occurrence_Of (Temp, Loc),\n+                        New_Copy_Tree (Key_Expr),\n+                        New_Copy_Tree (Expr))));\n+\n+            else\n+               Stats := New_List\n+                 (Make_Procedure_Call_Statement (Loc,\n+                    Name => New_Occurrence_Of (Entity (Add_Named_Subp), Loc),\n+                    Parameter_Associations =>\n+                      New_List (New_Occurrence_Of (Temp, Loc),\n+                        New_Occurrence_Of (Loop_Id, Loc),\n+                        New_Copy_Tree (Expr))));\n+            end if;\n          end if;\n \n          Loop_Stat :=  Make_Implicit_Loop_Statement\n@@ -7029,7 +7085,9 @@ package body Exp_Aggr is\n             --  generate an insertion statement for each.\n \n             while Present (Comp) loop\n-               if Nkind (Comp) = N_Iterated_Component_Association then\n+               if Nkind (Comp) in N_Iterated_Component_Association\n+                                | N_Iterated_Element_Association\n+               then\n                   Expand_Iterated_Component (Comp);\n                else\n                   Key := First (Choices (Comp));"}, {"sha": "501429d9e9183348119a25491adc9c5d8419d8c5", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb", "patch": "@@ -1607,8 +1607,11 @@ package body Ch4 is\n          --  identifier or OTHERS follows (the latter cases are missing\n          --  comma cases). Also assume positional if a semicolon follows,\n          --  which can happen if there are missing parens.\n+         --  In Ada_2012 and Ada_2020 an iterated association can appear.\n \n-         elsif Nkind (Expr_Node) = N_Iterated_Component_Association then\n+         elsif Nkind (Expr_Node) in\n+           N_Iterated_Component_Association | N_Iterated_Element_Association\n+         then\n             if No (Assoc_List) then\n                Assoc_List := New_List (Expr_Node);\n             else\n@@ -3417,6 +3420,7 @@ package body Ch4 is\n \n    function P_Iterated_Component_Association return Node_Id is\n       Assoc_Node : Node_Id;\n+      Choice     : Node_Id;\n       Id         : Node_Id;\n       Iter_Spec  : Node_Id;\n       Loop_Spec  : Node_Id;\n@@ -3451,15 +3455,25 @@ package body Ch4 is\n \n          if Token = Tok_Use then\n \n-            --  Key-expression is present, rewrite node as an\n+            --  Ada_2020 Key-expression is present, rewrite node as an\n             --  iterated_Element_Awwoiation.\n \n             Scan;  --  past USE\n             Loop_Spec :=\n               New_Node (N_Loop_Parameter_Specification, Prev_Token_Ptr);\n             Set_Defining_Identifier (Loop_Spec, Id);\n-            Set_Discrete_Subtype_Definition (Loop_Spec,\n-               First (Discrete_Choices (Assoc_Node)));\n+\n+            Choice :=  First (Discrete_Choices (Assoc_Node));\n+\n+            if Present (Next (Choice)) then\n+               Error_Msg_N (\"expect loop parameter specification\", Choice);\n+            end if;\n+\n+            Remove (Choice);\n+            Set_Discrete_Subtype_Definition (Loop_Spec, Choice);\n+\n+            Assoc_Node :=\n+              New_Node (N_Iterated_Element_Association, Prev_Token_Ptr);\n             Set_Loop_Parameter_Specification (Assoc_Node, Loop_Spec);\n             Set_Key_Expression (Assoc_Node, P_Expression);\n          end if;"}, {"sha": "eb695617566b97bd24edf87d59b9ea5dbba3a394", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=c0bab60bb9d6f56eedc95f77af3d1057b7fff3bb", "patch": "@@ -48,6 +48,7 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Dim;  use Sem_Dim;\n@@ -2646,11 +2647,12 @@ package body Sem_Aggr is\n    ---------------------------------\n \n    procedure Resolve_Container_Aggregate (N : Node_Id; Typ : Entity_Id) is\n-      procedure Resolve_Iterated_Component_Association\n+      procedure Resolve_Iterated_Association\n        (Comp      : Node_Id;\n         Key_Type  : Entity_Id;\n         Elmt_Type : Entity_Id);\n-      --  Resolve choices and expression in an iterated component association.\n+      --  Resolve choices and expression in an iterated component association\n+      --  or an iterated element association, which has a key_expression.\n       --  This is similar but not identical to the handling of this construct\n       --  in an array aggregate.\n       --  For a named container, the type of each choice must be compatible\n@@ -2666,25 +2668,54 @@ package body Sem_Aggr is\n       New_Indexed_Subp    : Node_Id := Empty;\n       Assign_Indexed_Subp : Node_Id := Empty;\n \n-      --------------------------------------------\n-      -- Resolve_Iterated_Component_Association --\n-      --------------------------------------------\n+      ----------------------------------\n+      -- Resolve_Iterated_Association --\n+      ----------------------------------\n \n-      procedure Resolve_Iterated_Component_Association\n+      procedure Resolve_Iterated_Association\n        (Comp      : Node_Id;\n         Key_Type  : Entity_Id;\n         Elmt_Type : Entity_Id)\n       is\n-         Choice : Node_Id;\n-         Ent    : Entity_Id;\n-         Expr   : Node_Id;\n-         Id     : Entity_Id;\n-         Iter   : Node_Id;\n-         Typ    : Entity_Id := Empty;\n+         Choice   : Node_Id;\n+         Ent      : Entity_Id;\n+         Expr     : Node_Id;\n+         Key_Expr : Node_Id;\n+         Id       : Entity_Id;\n+         Id_Name  : Name_Id;\n+         Iter     : Node_Id;\n+         Typ      : Entity_Id := Empty;\n \n       begin\n-         if Present (Iterator_Specification (Comp)) then\n-            Iter := Copy_Separate_Tree (Iterator_Specification (Comp));\n+         --  If this is an Iterated_Element_Association then either a\n+         --  an Iterator_Specification or a Loop_Parameter specification\n+         --  is present. In both cases a Key_Expression is present.\n+\n+         if Nkind (Comp) = N_Iterated_Element_Association then\n+            if Present (Loop_Parameter_Specification (Comp)) then\n+               Analyze_Loop_Parameter_Specification\n+                  (Loop_Parameter_Specification (Comp));\n+               Id_Name := Chars (Defining_Identifier\n+                            (Loop_Parameter_Specification (Comp)));\n+            else\n+               Iter := Copy_Separate_Tree (Iterator_Specification (Comp));\n+               Analyze (Iter);\n+               Typ := Etype (Defining_Identifier (Iter));\n+               Id_Name := Chars (Defining_Identifier\n+                            (Iterator_Specification (Comp)));\n+            end if;\n+\n+            --  Key expression must have the type of the key. We analyze\n+            --  a copy of the original expression, because it will be\n+            --  reanalyzed and copied as needed during expansion of the\n+            --  corresponding loop.\n+\n+            Key_Expr := Key_Expression (Comp);\n+            Analyze_And_Resolve (New_Copy_Tree (Key_Expr), Key_Type);\n+\n+         elsif Present (Iterator_Specification (Comp)) then\n+            Iter    := Copy_Separate_Tree (Iterator_Specification (Comp));\n+            Id_Name := Chars (Defining_Identifier (Comp));\n             Analyze (Iter);\n             Typ := Etype (Defining_Identifier (Iter));\n \n@@ -2711,19 +2742,19 @@ package body Sem_Aggr is\n \n                Next (Choice);\n             end loop;\n+\n+            Id_Name := Chars (Defining_Identifier (Comp));\n          end if;\n \n          --  Create a scope in which to introduce an index, which is usually\n          --  visible in the expression for the component, and needed for its\n          --  analysis.\n \n+         Id := Make_Defining_Identifier (Sloc (Comp), Id_Name);\n          Ent := New_Internal_Entity (E_Loop, Current_Scope, Sloc (Comp), 'L');\n          Set_Etype  (Ent, Standard_Void_Type);\n          Set_Parent (Ent, Parent (Comp));\n          Push_Scope (Ent);\n-         Id :=\n-           Make_Defining_Identifier (Sloc (Comp),\n-             Chars => Chars (Defining_Identifier (Comp)));\n \n          --  Insert and decorate the loop variable in the current scope.\n          --  The expression has to be analyzed once the loop variable is\n@@ -2752,7 +2783,8 @@ package body Sem_Aggr is\n          Expr := New_Copy_Tree (Expression (Comp));\n          Preanalyze_And_Resolve (Expr, Elmt_Type);\n          End_Scope;\n-      end Resolve_Iterated_Component_Association;\n+\n+      end Resolve_Iterated_Association;\n \n    begin\n       pragma Assert (Nkind (Asp) = N_Aggregate);\n@@ -2797,7 +2829,7 @@ package body Sem_Aggr is\n                           & \"for unnamed container aggregate\", Comp);\n                         return;\n                      else\n-                        Resolve_Iterated_Component_Association\n+                        Resolve_Iterated_Association\n                           (Comp, Empty, Elmt_Type);\n                      end if;\n \n@@ -2837,8 +2869,11 @@ package body Sem_Aggr is\n \n                   Analyze_And_Resolve (Expression (Comp), Elmt_Type);\n \n-               elsif Nkind (Comp) = N_Iterated_Component_Association then\n-                  Resolve_Iterated_Component_Association\n+               elsif Nkind (Comp) in\n+                 N_Iterated_Component_Association |\n+                 N_Iterated_Element_Association\n+               then\n+                  Resolve_Iterated_Association\n                     (Comp, Key_Type, Elmt_Type);\n                end if;\n \n@@ -2883,8 +2918,11 @@ package body Sem_Aggr is\n \n                      Analyze_And_Resolve (Expression (Comp), Comp_Type);\n \n-                  elsif Nkind (Comp) = N_Iterated_Component_Association then\n-                     Resolve_Iterated_Component_Association\n+                  elsif Nkind (Comp) in\n+                    N_Iterated_Component_Association |\n+                    N_Iterated_Element_Association\n+                  then\n+                     Resolve_Iterated_Association\n                        (Comp, Index_Type, Comp_Type);\n                   end if;\n "}]}