{"sha": "f824e5c36eea7d0a9a5b9a5147751278de4778c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgyNGU1YzM2ZWVhN2QwYTlhNWI5YTUxNDc3NTEyNzhkZTQ3NzhjMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-06-01T16:18:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-06-01T16:18:18Z"}, "message": "alias.c (get_alias_set): Don't call language-specific routine more than is needed and clean up code a bit.\n\n\t* alias.c (get_alias_set): Don't call language-specific routine more\n\tthan is needed and clean up code a bit.\n\t* c-common.c (c_get_alias_set): All references whose type\n\tis char get alias set 0, but character types need not.\n\t* varasm.c (make_function_rtl): Don't call set_mem_attributes.\n\t(make_decl_rtl): Don't call it for FUNCTION_DECL.\n\nFrom-SVN: r34341", "tree": {"sha": "9c9aade5f3fbb3ff2540e194718e4cecd3846365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c9aade5f3fbb3ff2540e194718e4cecd3846365"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f824e5c36eea7d0a9a5b9a5147751278de4778c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f824e5c36eea7d0a9a5b9a5147751278de4778c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f824e5c36eea7d0a9a5b9a5147751278de4778c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f824e5c36eea7d0a9a5b9a5147751278de4778c0/comments", "author": null, "committer": null, "parents": [{"sha": "611a4b873e1fbd6fc2b4a28c05924660a0b5c2af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/611a4b873e1fbd6fc2b4a28c05924660a0b5c2af"}], "stats": {"total": 118, "additions": 61, "deletions": 57}, "files": [{"sha": "3959db26df3d8333741aa6688e7fcfb8fae08d7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f824e5c36eea7d0a9a5b9a5147751278de4778c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f824e5c36eea7d0a9a5b9a5147751278de4778c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f824e5c36eea7d0a9a5b9a5147751278de4778c0", "patch": "@@ -1,3 +1,12 @@\n+Thu Jun  1 12:24:21 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (get_alias_set): Don't call language-specific routine more\n+\tthan is needed and clean up code a bit.\n+\t* c-common.c (c_get_alias_set): All references whose type\n+\tis char get alias set 0, but character types need not.\n+\t* varasm.c (make_function_rtl): Don't call set_mem_attributes.\n+\t(make_decl_rtl): Don't call it for FUNCTION_DECL.\n+\n 2000-06-01  Bruce Korb  <bkorb@gnu.org>\n \n \t* fixinc/tests/base/...: new base result files"}, {"sha": "4541d519858f6675abbe4cad161e5259afbc30b1", "filename": "gcc/alias.c", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f824e5c36eea7d0a9a5b9a5147751278de4778c0/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f824e5c36eea7d0a9a5b9a5147751278de4778c0/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f824e5c36eea7d0a9a5b9a5147751278de4778c0", "patch": "@@ -338,6 +338,7 @@ HOST_WIDE_INT\n get_alias_set (t)\n      tree t;\n {\n+  tree orig_t;\n   HOST_WIDE_INT set;\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n@@ -357,45 +358,50 @@ get_alias_set (t)\n      language-specific routine may make mutually-recursive calls to\n      each other to figure out what to do.  At each juncture, we see if\n      this is a tree that the language may need to handle specially.\n-     But first remove nops since we care only about the actual object.  */\n-  while (TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR\n-\t || TREE_CODE (t) == NON_LVALUE_EXPR)\n-    t = TREE_OPERAND (t, 0);\n-\n-  /* Now give the language a chance to do something.  */\n-  if (lang_get_alias_set != 0\n-      && (set = (*lang_get_alias_set) (t)) != -1)\n-    return set;\n-\n-  /* If this is a reference, go inside it and use the underlying object.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (t)) == 'r')\n-    t = get_inner_reference (t, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t     &unsignedp, &volatilep, &alignment);\n-\n-  if (TREE_CODE (t) == INDIRECT_REF)\n+     First handle things that aren't types and start by removing nops\n+     since we care only about the actual object.  */\n+  if (! TYPE_P (t))\n     {\n-      /* Check for accesses through restrict-qualified pointers.  */\n-      tree decl = find_base_decl (TREE_OPERAND (t, 0));\n+      while (TREE_CODE (t) == NOP_EXPR || TREE_CODE (t) == CONVERT_EXPR\n+\t     || TREE_CODE (t) == NON_LVALUE_EXPR)\n+\tt = TREE_OPERAND (t, 0);\n+\n+      /* Now give the language a chance to do something but record what we\n+\t gave it this time.  */\n+      orig_t = t;\n+      if (lang_get_alias_set != 0\n+\t  && (set = (*lang_get_alias_set) (t)) != -1)\n+\treturn set;\n+\n+      /* If this is a reference, go inside it and use the underlying\n+         object.  */\n+      if (TREE_CODE_CLASS (TREE_CODE (t)) == 'r')\n+\tt = get_inner_reference (t, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t &unsignedp, &volatilep, &alignment);\n+\n+      if (TREE_CODE (t) == INDIRECT_REF)\n+\t{\n+\t  /* Check for accesses through restrict-qualified pointers.  */\n+\t  tree decl = find_base_decl (TREE_OPERAND (t, 0));\n \n-      if (decl && DECL_POINTER_ALIAS_SET_KNOWN_P (decl))\n-\t/* We use the alias set indicated in the declaration.  */\n-\treturn DECL_POINTER_ALIAS_SET (decl);\n+\t  if (decl && DECL_POINTER_ALIAS_SET_KNOWN_P (decl))\n+\t    /* We use the alias set indicated in the declaration.  */\n+\t    return DECL_POINTER_ALIAS_SET (decl);\n \n-      /* If we have an INDIRECT_REF via a void pointer, we don't know anything\n-\t about what that might alias.  */\n-      if (TREE_CODE (TREE_TYPE (t)) == VOID_TYPE)\n-\treturn 0;\n-    }\n+\t  /* If we have an INDIRECT_REF via a void pointer, we don't\n+\t     know anything about what that might alias.  */\n+\t  if (TREE_CODE (TREE_TYPE (t)) == VOID_TYPE)\n+\t    return 0;\n+\t}\n \n-  /* Give the language another chance to do something special.  */\n-  if (lang_get_alias_set != 0\n-      && (set = (*lang_get_alias_set) (t)) != -1)\n-    return set;\n+      /* Give the language another chance to do something special.  */\n+      if (orig_t != t && lang_get_alias_set != 0\n+\t  && (set = (*lang_get_alias_set) (t)) != -1)\n+\treturn set;\n \n-  /* Now we are done with expressions, so get the type if this isn't\n-     a type.  */\n-  if (! TYPE_P (t))\n-    t = TREE_TYPE (t);\n+      /* Now all we care about is the type.  */\n+      t = TREE_TYPE (t);\n+    }\n \n   /* Variant qualifiers don't affect the alias set, so get the main\n      variant. If this is a type with a known alias set, return it.  */"}, {"sha": "0ba6873311831d66dba6a6867de5d4de0b775b30", "filename": "gcc/c-common.c", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f824e5c36eea7d0a9a5b9a5147751278de4778c0/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f824e5c36eea7d0a9a5b9a5147751278de4778c0/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=f824e5c36eea7d0a9a5b9a5147751278de4778c0", "patch": "@@ -3284,33 +3284,22 @@ c_get_alias_set (t)\n       return 0;\n \n   /* If this is a char *, the ANSI C standard says it can alias\n-     anything.  */\n-  else if (TREE_CODE (t) == INDIRECT_REF\n-\t   && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == INTEGER_TYPE\n-\t   && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t       == TYPE_PRECISION (char_type_node)))\n+     anything.  Note that all references need do this.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (t)) == 'r'\n+      && TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n+      && TYPE_PRECISION (TREE_TYPE (t)) == TYPE_PRECISION (char_type_node))\n     return 0;\n \n   /* That's all the expressions we handle specially.  */\n   if (! TYPE_P (t))\n     return -1;\n \n-  if (TREE_CODE (t) == INTEGER_TYPE)\n-    {\n-      /* The C standard specifically allows aliasing between signed and\n-\t unsigned variants of the same type.  We treat the signed\n-\t variant as canonical.  */\n-      tree signed_variant = signed_type (t);\n-\n-      if (signed_variant == signed_char_type_node)\n-\t/* The C standard guarantess that any object may be accessed\n-\t   via an lvalue that has character type.  We don't have to\n-\t   check for unsigned_char_type_node or char_type_node because\n-\t   we are specifically looking at the signed variant.  */\n-\treturn 0;\n-      else if (signed_variant  != t)\n-\treturn get_alias_set (signed_variant);\n-    }\n+  /* The C standard specifically allows aliasing between signed and\n+     unsigned variants of the same type.  We treat the signed\n+     variant as canonical.  */\n+  if (TREE_CODE (t) == INTEGER_TYPE && TREE_UNSIGNED (t))\n+    return get_alias_set (signed_type (t));\n+\n   else if (POINTER_TYPE_P (t))\n     {\n       tree t1;"}, {"sha": "75af9466530ef2c83e6952105b8101089b53269a", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f824e5c36eea7d0a9a5b9a5147751278de4778c0/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f824e5c36eea7d0a9a5b9a5147751278de4778c0/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f824e5c36eea7d0a9a5b9a5147751278de4778c0", "patch": "@@ -559,7 +559,6 @@ make_function_rtl (decl)\n       DECL_RTL (decl)\n \t= gen_rtx_MEM (DECL_MODE (decl),\n \t\t       gen_rtx_SYMBOL_REF (Pmode, name));\n-      set_mem_attributes (DECL_RTL (decl), decl, 1);\n \n       /* Optionally set flags or add text to the name to record\n \t information such as that it is a function name.  If the name\n@@ -812,7 +811,8 @@ make_decl_rtl (decl, asmspec, top_level)\n \t    = get_identifier (name[0] == '*' ? name + 1 : name);\n \t  DECL_RTL (decl) = gen_rtx_MEM (DECL_MODE (decl),\n \t\t\t\t\t gen_rtx_SYMBOL_REF (Pmode, name));\n-\t  set_mem_attributes (DECL_RTL (decl), decl, 1);\n+\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t    set_mem_attributes (DECL_RTL (decl), decl, 1);\n \n \t  /* Optionally set flags or add text to the name to record information\n \t     such as that it is a function name."}]}