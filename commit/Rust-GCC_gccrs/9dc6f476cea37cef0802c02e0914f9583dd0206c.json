{"sha": "9dc6f476cea37cef0802c02e0914f9583dd0206c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRjNmY0NzZjZWEzN2NlZjA4MDJjMDJlMDkxNGY5NTgzZGQwMjA2Yw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2013-03-22T03:55:51Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2013-03-22T03:55:51Z"}, "message": "cp-tree.h (identifier_p): New.\n\n\t* cp-tree.h (identifier_p): New.\n\t* call.c: Throughout, call identifier_p insstead of direct\n\tcomparaison of TREE_CODE against IDENTIFIER_NODE.\n\t* decl.c: Likewisse.\n\t* decl2.c: Likewise.\n\t* init.c: Likewise.\n\t* mangle.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t* parser.c: Likewise.\n\t* pt.c: Likewise.\n\t* search.c: Likewise.\n\t* semantics.c: Likewise.\n\t* tree.c: Likewise.\n\t* typeck.c: Likewise.\n\t* typeck2.c: Likewise.\n\nFrom-SVN: r196897", "tree": {"sha": "c508723a4bc62e4868f5b9b447ddc497eba95417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c508723a4bc62e4868f5b9b447ddc497eba95417"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dc6f476cea37cef0802c02e0914f9583dd0206c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc6f476cea37cef0802c02e0914f9583dd0206c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dc6f476cea37cef0802c02e0914f9583dd0206c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc6f476cea37cef0802c02e0914f9583dd0206c/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "35054b15e4f9517aa0f63bae3048ab4fa183d4b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35054b15e4f9517aa0f63bae3048ab4fa183d4b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35054b15e4f9517aa0f63bae3048ab4fa183d4b2"}], "stats": {"total": 186, "additions": 101, "deletions": 85}, "files": [{"sha": "e3428ba3037dd45e1a9678e8c2f40c9a1cfdce17", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -1,3 +1,21 @@\n+2013-03-21  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* cp-tree.h (identifier_p): New.\n+\t* call.c: Throughout, call identifier_p insstead of direct\n+\tcomparaison of TREE_CODE against IDENTIFIER_NODE.\n+\t* decl.c: Likewisse.\n+\t* decl2.c: Likewise.\n+\t* init.c: Likewise.\n+\t* mangle.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* parser.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* search.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* typeck.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\n 2013-03-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/48087"}, {"sha": "dd19e48ed18d77a82e7c9c37b26de36fad14a23a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -233,7 +233,7 @@ check_dtor_name (tree basetype, tree name)\n     name = TREE_TYPE (name);\n   else if (TYPE_P (name))\n     /* OK */;\n-  else if (TREE_CODE (name) == IDENTIFIER_NODE)\n+  else if (identifier_p (name))\n     {\n       if ((MAYBE_CLASS_TYPE_P (basetype)\n \t   && name == constructor_name (basetype))\n@@ -3147,7 +3147,7 @@ print_z_candidate (location_t loc, const char *msgstr,\n \t\t     : ACONCAT ((msgstr, \" \", NULL)));\n   location_t cloc = location_of (candidate->fn);\n \n-  if (TREE_CODE (candidate->fn) == IDENTIFIER_NODE)\n+  if (identifier_p (candidate->fn))\n     {\n       cloc = loc;\n       if (candidate->num_convs == 3)\n@@ -8563,8 +8563,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n      - do not have the same parameter type list as any non-template\n        non-member candidate.  */\n \n-  if (TREE_CODE (cand1->fn) == IDENTIFIER_NODE\n-      || TREE_CODE (cand2->fn) == IDENTIFIER_NODE)\n+  if (identifier_p (cand1->fn) || identifier_p (cand2->fn))\n     {\n       for (i = 0; i < len; ++i)\n \tif (!same_type_p (cand1->convs[i]->type,\n@@ -8575,7 +8574,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \t  if (cand1->fn == cand2->fn)\n \t    /* Two built-in candidates; arbitrarily pick one.  */\n \t    return 1;\n-\t  else if (TREE_CODE (cand1->fn) == IDENTIFIER_NODE)\n+\t  else if (identifier_p (cand1->fn))\n \t    /* cand1 is built-in; prefer cand2.  */\n \t    return -1;\n \t  else"}, {"sha": "401868549cdad2026dac1a24818aa676c7266c51", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -241,6 +241,16 @@ struct GTY(()) lang_identifier {\n   tree label_value;\n };\n \n+/* Return a typed pointer version of T if it designates a\n+   C++ front-end identifier.  */\n+inline lang_identifier*\n+identifier_p (tree t)\n+{\n+  if (TREE_CODE (t) == IDENTIFIER_NODE)\n+    return (lang_identifier*) t;\n+  return NULL;\n+}\n+\n /* In an IDENTIFIER_NODE, nonzero if this identifier is actually a\n    keyword.  C_RID_CODE (node) is then the RID_* value of the keyword,\n    and C_RID_YYCODE is the token number wanted by Yacc.  */"}, {"sha": "ea1a08d2674c52cd97118b1d548cd576dc5c64e1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -3296,7 +3296,7 @@ make_typename_type (tree context, tree name, enum tag_types tag_type,\n \terror (\"%qD used without template parameters\", name);\n       return error_mark_node;\n     }\n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (identifier_p (name));\n   gcc_assert (TYPE_P (context));\n \n   if (!MAYBE_CLASS_TYPE_P (context))\n@@ -3402,7 +3402,7 @@ make_unbound_class_template (tree context, tree name, tree parm_list,\n     name = TYPE_IDENTIFIER (name);\n   else if (DECL_P (name))\n     name = DECL_NAME (name);\n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (identifier_p (name));\n \n   if (!dependent_type_p (context)\n       || currently_open_class (context))\n@@ -4781,7 +4781,7 @@ check_array_designated_initializer (const constructor_elt *ce,\n \t}\n       else\n \t{\n-\t  gcc_assert (TREE_CODE (ce->index) == IDENTIFIER_NODE);\n+\t  gcc_assert (identifier_p (ce->index));\n \t  error (\"name %qD used in a GNU-style designated \"\n \t\t \"initializer for an array\", ce->index);\n \t}\n@@ -7413,8 +7413,7 @@ grokfndecl (tree ctype,\n \t\t\t  == current_class_type);\n \t      fns = TREE_OPERAND (fns, 1);\n \t    }\n-\t  gcc_assert (TREE_CODE (fns) == IDENTIFIER_NODE\n-\t\t      || TREE_CODE (fns) == OVERLOAD);\n+\t  gcc_assert (identifier_p (fns) || TREE_CODE (fns) == OVERLOAD);\n \t  DECL_TEMPLATE_INFO (decl) = build_template_info (fns, args);\n \n \t  for (t = TYPE_ARG_TYPES (TREE_TYPE (decl)); t; t = TREE_CHAIN (t))\n@@ -7772,7 +7771,7 @@ grokvardecl (tree type,\n   tree decl;\n   tree explicit_scope;\n \n-  gcc_assert (!name || TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (!name || identifier_p (name));\n \n   /* Compute the scope in which to place the variable, but remember\n      whether or not that scope was explicitly specified by the user.   */\n@@ -8509,7 +8508,7 @@ check_var_type (tree identifier, tree type)\n     {\n       if (!identifier)\n \terror (\"unnamed variable or field declared void\");\n-      else if (TREE_CODE (identifier) == IDENTIFIER_NODE)\n+      else if (identifier_p (identifier))\n \t{\n \t  gcc_assert (!IDENTIFIER_OPNAME_P (identifier));\n \t  error (\"variable or field %qE declared void\", identifier);\n@@ -8778,7 +8777,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  tree fns = TREE_OPERAND (decl, 0);\n \n \t\t  dname = fns;\n-\t\t  if (TREE_CODE (dname) != IDENTIFIER_NODE)\n+\t\t  if (!identifier_p (dname))\n \t\t    {\n \t\t      gcc_assert (is_overloaded_fn (dname));\n \t\t      dname = DECL_NAME (get_first_fn (dname));\n@@ -8787,7 +8786,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t/* Fall through.  */\n \n \t      case IDENTIFIER_NODE:\n-\t\tif (TREE_CODE (decl) == IDENTIFIER_NODE)\n+\t\tif (identifier_p (decl))\n \t\t  dname = decl;\n \n \t\tif (C_IS_RESERVED_WORD (dname))\n@@ -8852,7 +8851,7 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n \n   if (dname\n-      && TREE_CODE (dname) == IDENTIFIER_NODE\n+      && identifier_p (dname)\n       && UDLIT_OPER_P (dname)\n       && innermost_code != cdk_function)\n     {\n@@ -8977,7 +8976,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t common.  With no options, it is allowed.  With -Wreturn-type,\n \t it is a warning.  It is only an error with -pedantic-errors.  */\n       is_main = (funcdef_flag\n-\t\t && dname && TREE_CODE (dname) == IDENTIFIER_NODE\n+\t\t && dname && identifier_p (dname)\n \t\t && MAIN_NAME_P (dname)\n \t\t && ctype == NULL_TREE\n \t\t && in_namespace == NULL_TREE\n@@ -11896,7 +11895,7 @@ xref_tag_1 (enum tag_types tag_code, tree name,\n   tree context = NULL_TREE;\n   tag_scope scope;\n \n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (identifier_p (name));\n \n   switch (tag_code)\n     {\n@@ -12323,7 +12322,7 @@ start_enum (tree name, tree enumtype, tree underlying_type,\n \t    bool scoped_enum_p, bool *is_new)\n {\n   tree prevtype = NULL_TREE;\n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (identifier_p (name));\n \n   if (is_new)\n     *is_new = false;"}, {"sha": "f13efd67da97b006fcf4c55e4ff5363e572b7594", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -1121,7 +1121,7 @@ is_late_template_attribute (tree attr, tree decl)\n \t second and following arguments.  Attributes like mode, format,\n \t cleanup and several target specific attributes aren't late\n \t just because they have an IDENTIFIER_NODE as first argument.  */\n-      if (arg == args && TREE_CODE (t) == IDENTIFIER_NODE)\n+      if (arg == args && identifier_p (t))\n \tcontinue;\n \n       if (value_dependent_expression_p (t)"}, {"sha": "32f242c3275b26eb33dccdb1989240b2f986ff2d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -1416,7 +1416,7 @@ expand_member_init (tree name)\n     }\n   else\n     {\n-      if (TREE_CODE (name) == IDENTIFIER_NODE)\n+      if (identifier_p (name))\n \tfield = lookup_field (current_class_type, name, 1, false);\n       else\n \tfield = name;"}, {"sha": "603f7019a702a9cd0b4552944b4924fd578d0aed", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -1189,7 +1189,7 @@ write_unqualified_name (const tree decl)\n {\n   MANGLE_TRACE_TREE (\"unqualified-name\", decl);\n \n-  if (TREE_CODE (decl) == IDENTIFIER_NODE)\n+  if (identifier_p (decl))\n     {\n       write_unqualified_id (decl);\n       return;\n@@ -2519,7 +2519,7 @@ write_template_args (tree args)\n static void\n write_member_name (tree member)\n {\n-  if (TREE_CODE (member) == IDENTIFIER_NODE)\n+  if (identifier_p (member))\n     write_unqualified_id (member);\n   else if (DECL_P (member))\n     write_unqualified_name (member);\n@@ -2697,7 +2697,7 @@ write_expression (tree expr)\n     {\n       write_expression (TREE_OPERAND (expr, 0));\n     }\n-  else if (TREE_CODE (expr) == IDENTIFIER_NODE)\n+  else if (identifier_p (expr))\n     {\n       /* An operator name appearing as a dependent name needs to be\n \t specially marked to disambiguate between a use of the operator"}, {"sha": "dd6ef223def4b1b09bc1280041572f79dbb84ce7", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -1959,7 +1959,7 @@ constructor_name_p (tree name, tree type)\n   if (!name)\n     return false;\n \n-  if (TREE_CODE (name) != IDENTIFIER_NODE)\n+  if (!identifier_p (name))\n     return false;\n \n   /* These don't have names.  */\n@@ -2073,7 +2073,7 @@ lookup_extern_c_fun_in_all_ns (tree function)\n   gcc_assert (function && TREE_CODE (function) == FUNCTION_DECL);\n \n   name = DECL_NAME (function);\n-  gcc_assert (name && TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (name && identifier_p (name));\n \n   for (iter = IDENTIFIER_NAMESPACE_BINDINGS (name);\n        iter;\n@@ -2136,7 +2136,7 @@ push_using_decl_1 (tree scope, tree name)\n   tree decl;\n \n   gcc_assert (TREE_CODE (scope) == NAMESPACE_DECL);\n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (identifier_p (name));\n   for (decl = current_binding_level->usings; decl; decl = DECL_CHAIN (decl))\n     if (USING_DECL_SCOPE (decl) == scope && DECL_NAME (decl) == name)\n       break;\n@@ -5724,7 +5724,7 @@ pushtag_1 (tree name, tree type, tag_scope scope)\n \t\t || COMPLETE_TYPE_P (b->this_entity))))\n     b = b->level_chain;\n \n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (identifier_p (name));\n \n   /* Do C++ gratuitous typedefing.  */\n   if (identifier_type_value_1 (name) != type)"}, {"sha": "7ac90df167116e10d3fde84021b8f7053bf699ad", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -1110,7 +1110,7 @@ cp_lexer_print_token (FILE * stream, cp_token *token)\n     case CPP_KEYWORD:\n       /* Some keywords have a value that is not an IDENTIFIER_NODE.\n \t For example, `struct' is mapped to an INTEGER_CST.  */\n-      if (TREE_CODE (token->u.value) != IDENTIFIER_NODE)\n+      if (!identifier_p (token->u.value))\n \tbreak;\n       /* else fall through */\n     case CPP_NAME:\n@@ -1259,7 +1259,7 @@ make_id_declarator (tree qualifying_scope, tree unqualified_name,\n   if (qualifying_scope && TYPE_P (qualifying_scope))\n     qualifying_scope = TYPE_MAIN_VARIANT (qualifying_scope);\n \n-  gcc_assert (TREE_CODE (unqualified_name) == IDENTIFIER_NODE\n+  gcc_assert (identifier_p (unqualified_name)\n \t      || TREE_CODE (unqualified_name) == BIT_NOT_EXPR\n \t      || TREE_CODE (unqualified_name) == TEMPLATE_ID_EXPR);\n \n@@ -2587,7 +2587,7 @@ cp_parser_check_for_invalid_template_id (cp_parser* parser,\n     {\n       if (TYPE_P (type))\n \terror_at (location, \"%qT is not a template\", type);\n-      else if (TREE_CODE (type) == IDENTIFIER_NODE)\n+      else if (identifier_p (type))\n \t{\n \t  if (tag_type != none_type)\n \t    error_at (location, \"%qE is not a class template\", type);\n@@ -3193,7 +3193,7 @@ cp_parser_make_typename_type (cp_parser *parser, tree scope,\n \t\t\t      tree id, location_t id_location)\n {\n   tree result;\n-  if (TREE_CODE (id) == IDENTIFIER_NODE)\n+  if (identifier_p (id))\n     {\n       result = make_typename_type (scope, id, typename_type,\n \t\t\t\t   /*complain=*/tf_none);\n@@ -5654,7 +5654,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n   while (true)\n     {\n       if (idk == CP_ID_KIND_UNQUALIFIED\n-\t  && TREE_CODE (postfix_expression) == IDENTIFIER_NODE\n+\t  && identifier_p (postfix_expression)\n \t  && cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_PAREN))\n \t/* It is not a Koenig lookup function call.  */\n \tpostfix_expression\n@@ -5741,7 +5741,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    if (idk == CP_ID_KIND_UNQUALIFIED\n \t\t|| idk == CP_ID_KIND_TEMPLATE_ID)\n \t      {\n-\t\tif (TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n+\t\tif (identifier_p (postfix_expression))\n \t\t  {\n \t\t    if (!args->is_empty ())\n \t\t      {\n@@ -11310,7 +11310,7 @@ cp_parser_decltype (cp_parser *parser)\n       cp_id_kind idk;\n       const char *error_msg;\n \n-      if (TREE_CODE (expr) == IDENTIFIER_NODE)\n+      if (identifier_p (expr))\n \t/* Lookup the name we got back from the id-expression.  */\n \texpr = cp_parser_lookup_name (parser, expr,\n \t\t\t\t      none_type,\n@@ -12759,7 +12759,7 @@ cp_parser_template_id (cp_parser *parser,\n     }\n \n   /* Build a representation of the specialization.  */\n-  if (TREE_CODE (templ) == IDENTIFIER_NODE)\n+  if (identifier_p (templ))\n     template_id = build_min_nt_loc (next_token->location,\n \t\t\t\t    TEMPLATE_ID_EXPR,\n \t\t\t\t    templ, arguments);\n@@ -13980,7 +13980,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t  && !global_p\n \t  && !qualified_p\n \t  && TREE_CODE (type) == TYPE_DECL\n-\t  && TREE_CODE (DECL_NAME (type)) == IDENTIFIER_NODE)\n+\t  && identifier_p (DECL_NAME (type)))\n \tmaybe_note_name_used_in_class (DECL_NAME (type), type);\n       /* If it didn't work out, we don't have a TYPE.  */\n       if ((flags & CP_PARSER_FLAGS_OPTIONAL)\n@@ -15279,7 +15279,7 @@ cp_parser_using_declaration (cp_parser* parser,\n      depending on what scope we are in.  */\n   if (qscope == error_mark_node || identifier == error_mark_node)\n     ;\n-  else if (TREE_CODE (identifier) != IDENTIFIER_NODE\n+  else if (!identifier_p (identifier)\n \t   && TREE_CODE (identifier) != BIT_NOT_EXPR)\n     /* [namespace.udecl]\n \n@@ -16562,8 +16562,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  unqualified_name = error_mark_node;\n \t\telse if (unqualified_name\n \t\t\t && (qualifying_scope\n-\t\t\t     || (TREE_CODE (unqualified_name)\n-\t\t\t\t != IDENTIFIER_NODE)))\n+\t\t\t     || (!identifier_p (unqualified_name))))\n \t\t  {\n \t\t    cp_parser_error (parser, \"expected unqualified-id\");\n \t\t    unqualified_name = error_mark_node;\n@@ -18226,7 +18225,7 @@ cp_parser_class_name (cp_parser *parser,\n \n   /* Check to see that it is really the name of a class.  */\n   if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n-      && TREE_CODE (TREE_OPERAND (decl, 0)) == IDENTIFIER_NODE\n+      && identifier_p (TREE_OPERAND (decl, 0))\n       && cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))\n     /* Situations like this:\n \n@@ -21120,7 +21119,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n   /* By this point, the NAME should be an ordinary identifier.  If\n      the id-expression was a qualified name, the qualifying scope is\n      stored in PARSER->SCOPE at this point.  */\n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (identifier_p (name));\n \n   /* Perform the lookup.  */\n   if (parser->scope)\n@@ -24290,7 +24289,7 @@ cp_parser_objc_protocol_qualifiers (cp_parser* parser)\n \n   node = token->u.value;\n \n-  while (node && TREE_CODE (node) == IDENTIFIER_NODE\n+  while (node && identifier_p (node)\n \t && (node == ridpointers [(int) RID_IN]\n \t     || node == ridpointers [(int) RID_OUT]\n \t     || node == ridpointers [(int) RID_INOUT]"}, {"sha": "b44c6320ac99d7bb76cc194be544046d78be6512", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -2467,7 +2467,7 @@ check_explicit_specialization (tree declarator,\n \t{\n \t  tree fns;\n \n-\t  gcc_assert (TREE_CODE (declarator) == IDENTIFIER_NODE);\n+\t  gcc_assert (identifier_p (declarator));\n \t  if (ctype)\n \t    fns = dname;\n \t  else\n@@ -2528,8 +2528,7 @@ check_explicit_specialization (tree declarator,\n \t  return decl;\n \t}\n       else if (ctype != NULL_TREE\n-\t       && (TREE_CODE (TREE_OPERAND (declarator, 0)) ==\n-\t\t   IDENTIFIER_NODE))\n+\t       && (identifier_p (TREE_OPERAND (declarator, 0))))\n \t{\n \t  /* Find the list of functions in ctype that have the same\n \t     name as the declared function.  */\n@@ -6955,7 +6954,7 @@ lookup_template_function (tree fns, tree arglist)\n \n   gcc_assert (!arglist || TREE_CODE (arglist) == TREE_VEC);\n \n-  if (!is_overloaded_fn (fns) && TREE_CODE (fns) != IDENTIFIER_NODE)\n+  if (!is_overloaded_fn (fns) && !identifier_p (fns))\n     {\n       error (\"%q#D is not a function template\", fns);\n       return error_mark_node;\n@@ -7058,7 +7057,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n   spec_entry elt;\n   hashval_t hash;\n \n-  if (TREE_CODE (d1) == IDENTIFIER_NODE)\n+  if (identifier_p (d1))\n     {\n       tree value = innermost_non_namespace_value (d1);\n       if (value && DECL_TEMPLATE_TEMPLATE_PARM_P (value))\n@@ -7853,7 +7852,7 @@ uses_template_parms (tree t)\n \t   || TREE_CODE (t) == TEMPLATE_PARM_INDEX\n \t   || TREE_CODE (t) == OVERLOAD\n \t   || BASELINK_P (t)\n-\t   || TREE_CODE (t) == IDENTIFIER_NODE\n+\t   || identifier_p (t)\n \t   || TREE_CODE (t) == TRAIT_EXPR\n \t   || TREE_CODE (t) == CONSTRUCTOR\n \t   || CONSTANT_CLASS_P (t))\n@@ -8482,8 +8481,7 @@ apply_late_template_attributes (tree *decl_p, tree attributes, int attr_flags,\n \t      if (TREE_VALUE (t)\n \t\t  && TREE_CODE (TREE_VALUE (t)) == TREE_LIST\n \t\t  && TREE_VALUE (TREE_VALUE (t))\n-\t\t  && (TREE_CODE (TREE_VALUE (TREE_VALUE (t)))\n-\t\t      == IDENTIFIER_NODE))\n+\t\t  && (identifier_p (TREE_VALUE (TREE_VALUE (t)))))\n \t\t{\n \t\t  tree chain\n \t\t    = tsubst_expr (TREE_CHAIN (TREE_VALUE (t)), args, complain,\n@@ -13480,7 +13478,7 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t     input_location);\n \tif (error_msg)\n \t  error (error_msg);\n-\tif (!function_p && TREE_CODE (decl) == IDENTIFIER_NODE)\n+\tif (!function_p && identifier_p (decl))\n \t  {\n \t    if (complain & tf_error)\n \t      unqualified_name_lookup_error (decl);\n@@ -13907,7 +13905,7 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t\t    /*done=*/false,\n \t\t\t\t\t    /*address_p=*/false);\n \t  }\n-\telse if (koenig_p && TREE_CODE (function) == IDENTIFIER_NODE)\n+\telse if (koenig_p && identifier_p (function))\n \t  {\n \t    /* Do nothing; calling tsubst_copy_and_build on an identifier\n \t       would incorrectly perform unqualified lookup again.\n@@ -13991,15 +13989,15 @@ tsubst_copy_and_build (tree t,\n \t\t    not appropriate, even if an unqualified-name was used\n \t\t    to denote the function.  */\n \t\t && !DECL_FUNCTION_MEMBER_P (get_first_fn (function)))\n-\t\t|| TREE_CODE (function) == IDENTIFIER_NODE)\n+\t\t|| identifier_p (function))\n \t    /* Only do this when substitution turns a dependent call\n \t       into a non-dependent call.  */\n \t    && type_dependent_expression_p_push (t)\n \t    && !any_type_dependent_arguments_p (call_args))\n \t  function = perform_koenig_lookup (function, call_args, false,\n \t\t\t\t\t    tf_none);\n \n-\tif (TREE_CODE (function) == IDENTIFIER_NODE\n+\tif (identifier_p (function)\n \t    && !any_type_dependent_arguments_p (call_args))\n \t  {\n \t    if (koenig_p && (complain & tf_warning_or_error))\n@@ -14049,7 +14047,7 @@ tsubst_copy_and_build (tree t,\n \t\t    function = unq;\n \t\t  }\n \t      }\n-\t    if (TREE_CODE (function) == IDENTIFIER_NODE)\n+\t    if (identifier_p (function))\n \t      {\n \t\tif (complain & tf_error)\n \t\t  unqualified_name_lookup_error (function);\n@@ -19781,8 +19779,7 @@ type_dependent_expression_p (tree expression)\n     return false;\n \n   /* An unresolved name is always dependent.  */\n-  if (TREE_CODE (expression) == IDENTIFIER_NODE\n-      || TREE_CODE (expression) == USING_DECL)\n+  if (identifier_p (expression) || TREE_CODE (expression) == USING_DECL)\n     return true;\n \n   /* Some expression forms are never type-dependent.  */\n@@ -19887,7 +19884,7 @@ type_dependent_expression_p (tree expression)\n \t  if (type_dependent_expression_p (TREE_OPERAND (expression, 0)))\n \t    return true;\n \t  expression = TREE_OPERAND (expression, 1);\n-\t  if (TREE_CODE (expression) == IDENTIFIER_NODE)\n+\t  if (identifier_p (expression))\n \t    return false;\n \t}\n       /* SCOPE_REF with non-null TREE_TYPE is always non-dependent.  */\n@@ -19978,7 +19975,7 @@ instantiation_dependent_r (tree *tp, int *walk_subtrees,\n       return NULL_TREE;\n \n     case COMPONENT_REF:\n-      if (TREE_CODE (TREE_OPERAND (*tp, 1)) == IDENTIFIER_NODE)\n+      if (identifier_p (TREE_OPERAND (*tp, 1)))\n \t/* In a template, finish_class_member_access_expr creates a\n \t   COMPONENT_REF with an IDENTIFIER_NODE for op1 even if it isn't\n \t   type-dependent, so that we can check access control at\n@@ -20222,8 +20219,7 @@ dependent_template_p (tree tmpl)\n       || TREE_CODE (tmpl) == TEMPLATE_TEMPLATE_PARM)\n     return true;\n   /* So are names that have not been looked up.  */\n-  if (TREE_CODE (tmpl) == SCOPE_REF\n-      || TREE_CODE (tmpl) == IDENTIFIER_NODE)\n+  if (TREE_CODE (tmpl) == SCOPE_REF || identifier_p (tmpl))\n     return true;\n   /* So are member templates of dependent classes.  */\n   if (TYPE_P (CP_DECL_CONTEXT (tmpl)))\n@@ -20380,7 +20376,7 @@ resolve_typename_type (tree type, bool only_current_p)\n      find a TEMPLATE_DECL.  Otherwise, we want to find a TYPE_DECL.  */\n   if (!decl)\n     /*nop*/;\n-  else if (TREE_CODE (TYPENAME_TYPE_FULLNAME (type)) == IDENTIFIER_NODE\n+  else if (identifier_p (TYPENAME_TYPE_FULLNAME (type))\n \t   && TREE_CODE (decl) == TYPE_DECL)\n     {\n       result = TREE_TYPE (decl);"}, {"sha": "0ac7cdc2767014019c11e8edee2082e3a3b6bdea", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -381,7 +381,7 @@ lookup_field_1 (tree type, tree name, bool want_type)\n {\n   tree field;\n \n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (identifier_p (name));\n \n   if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n       || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM\n@@ -1190,7 +1190,7 @@ lookup_member (tree xbasetype, tree name, int protect, bool want_type,\n       || xbasetype == error_mark_node)\n     return NULL_TREE;\n \n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  gcc_assert (identifier_p (name));\n \n   if (TREE_CODE (xbasetype) == TREE_BINFO)\n     {"}, {"sha": "e3aeb817a5208880cbfe0ee724b6ed6ad2030c0c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -536,7 +536,7 @@ simplify_loop_decl_cond (tree *cond_p, tree body)\n tree\n finish_goto_stmt (tree destination)\n {\n-  if (TREE_CODE (destination) == IDENTIFIER_NODE)\n+  if (identifier_p (destination))\n     destination = lookup_label (destination);\n \n   /* We warn about unused labels with -Wunused.  That means we have to\n@@ -1999,7 +1999,7 @@ perform_koenig_lookup (tree fn, vec<tree, va_gc> *args, bool include_std,\n     }\n \n   /* Find the name of the overloaded function.  */\n-  if (TREE_CODE (fn) == IDENTIFIER_NODE)\n+  if (identifier_p (fn))\n     identifier = fn;\n   else if (is_overloaded_fn (fn))\n     {\n@@ -2966,7 +2966,7 @@ finish_id_expression (tree id_expression,\n \t  if (scope\n \t      && (!TYPE_P (scope)\n \t\t  || (!dependent_type_p (scope)\n-\t\t      && !(TREE_CODE (id_expression) == IDENTIFIER_NODE\n+\t\t      && !(identifier_p (id_expression)\n \t\t\t   && IDENTIFIER_TYPENAME_P (id_expression)\n \t\t\t   && dependent_type_p (TREE_TYPE (id_expression))))))\n \t    {\n@@ -2995,8 +2995,7 @@ finish_id_expression (tree id_expression,\n \t the current class so that we can check later to see if\n \t the meaning would have been different after the class\n \t was entirely defined.  */\n-      if (!scope && decl != error_mark_node\n-\t  && TREE_CODE (id_expression) == IDENTIFIER_NODE)\n+      if (!scope && decl != error_mark_node && identifier_p (id_expression))\n \tmaybe_note_name_used_in_class (id_expression, decl);\n \n       /* Disallow uses of local variables from containing functions, except\n@@ -3169,8 +3168,7 @@ finish_id_expression (tree id_expression,\n       /* A template-id where the name of the template was not resolved\n \t is definitely dependent.  */\n       else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n-\t       && (TREE_CODE (TREE_OPERAND (decl, 0))\n-\t\t   == IDENTIFIER_NODE))\n+\t       && (identifier_p (TREE_OPERAND (decl, 0))))\n \tdependent_p = true;\n       /* For anything except an overloaded function, just check its\n \t type.  */\n@@ -5301,7 +5299,7 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n          [expr.ref]), decltype(e) is defined as the type of the entity\n          named by e. If there is no such entity, or e names a set of\n          overloaded functions, the program is ill-formed.  */\n-      if (TREE_CODE (expr) == IDENTIFIER_NODE)\n+      if (identifier_p (expr))\n         expr = lookup_name (expr);\n \n       if (TREE_CODE (expr) == INDIRECT_REF)"}, {"sha": "3cfc8690d8972a08e71280a2fe8e51d9da16eee0", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -1734,7 +1734,7 @@ is_overloaded_fn (tree x)\n tree\n dependent_name (tree x)\n {\n-  if (TREE_CODE (x) == IDENTIFIER_NODE)\n+  if (identifier_p (x))\n     return x;\n   if (TREE_CODE (x) != COMPONENT_REF\n       && TREE_CODE (x) != OFFSET_REF"}, {"sha": "4e42a9d3d7b6e1e170325a230d60a0d834ddea62", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -2467,7 +2467,7 @@ lookup_destructor (tree object, tree scope, tree dtor_name)\n \t     scope, dtor_type);\n       return error_mark_node;\n     }\n-  if (TREE_CODE (dtor_type) == IDENTIFIER_NODE)\n+  if (identifier_p (dtor_type))\n     {\n       /* In a template, names we can't find a match for are still accepted\n \t destructor names, and we check them here.  */\n@@ -2588,7 +2588,7 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n \t  dependent_type_p (object_type)\n \t  /* If NAME is just an IDENTIFIER_NODE, then the expression\n \t     is dependent.  */\n-\t  || TREE_CODE (object) == IDENTIFIER_NODE\n+\t  || identifier_p (object)\n \t  /* If NAME is \"f<args>\", where either 'f' or 'args' is\n \t     dependent, then the expression is dependent.  */\n \t  || (TREE_CODE (name) == TEMPLATE_ID_EXPR\n@@ -2604,7 +2604,7 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n       object = build_non_dependent_expr (object);\n     }\n   else if (c_dialect_objc ()\n-\t   && TREE_CODE (name) == IDENTIFIER_NODE\n+\t   && identifier_p (name)\n \t   && (expr = objc_maybe_build_component_ref (object, name)))\n     return expr;\n     \n@@ -2671,8 +2671,7 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n \t    }\n \n \t  gcc_assert (CLASS_TYPE_P (scope));\n-\t  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE\n-\t\t      || TREE_CODE (name) == BIT_NOT_EXPR);\n+\t  gcc_assert (identifier_p (name) || TREE_CODE (name) == BIT_NOT_EXPR);\n \n \t  if (constructor_name_p (name, scope))\n \t    {\n@@ -5067,8 +5066,7 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n   arg = mark_lvalue_use (arg);\n   argtype = lvalue_type (arg);\n \n-  gcc_assert (TREE_CODE (arg) != IDENTIFIER_NODE\n-\t      || !IDENTIFIER_OPNAME_P (arg));\n+  gcc_assert (!identifier_p (arg) || !IDENTIFIER_OPNAME_P (arg));\n \n   if (TREE_CODE (arg) == COMPONENT_REF && type_unknown_p (arg)\n       && !really_overloaded_fn (TREE_OPERAND (arg, 1)))"}, {"sha": "ca31610d66b87d55500a9ff4baf5878057493fa2", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc6f476cea37cef0802c02e0914f9583dd0206c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=9dc6f476cea37cef0802c02e0914f9583dd0206c", "patch": "@@ -278,8 +278,7 @@ abstract_virtuals_error_sfinae (tree decl, tree type, abstract_class_use use,\n       void **slot;\n       struct pending_abstract_type *pat;\n \n-      gcc_assert (!decl || DECL_P (decl)\n-\t\t  || TREE_CODE (decl) == IDENTIFIER_NODE);\n+      gcc_assert (!decl || DECL_P (decl) || identifier_p (decl));\n \n       if (!abstract_pending_vars)\n \tabstract_pending_vars = htab_create_ggc (31, &pat_calc_hash,\n@@ -336,7 +335,7 @@ abstract_virtuals_error_sfinae (tree decl, tree type, abstract_class_use use,\n \terror (\"invalid abstract return type for member function %q+#D\", decl);\n       else if (TREE_CODE (decl) == FUNCTION_DECL)\n \terror (\"invalid abstract return type for function %q+#D\", decl);\n-      else if (TREE_CODE (decl) == IDENTIFIER_NODE)\n+      else if (identifier_p (decl))\n \t/* Here we do not have location information.  */\n \terror (\"invalid abstract type %qT for %qE\", type, decl);\n       else\n@@ -1241,7 +1240,7 @@ process_init_constructor_record (tree type, tree init,\n \t\t latter case can happen in templates where lookup has to be\n \t\t deferred.  */\n \t      gcc_assert (TREE_CODE (ce->index) == FIELD_DECL\n-\t\t\t  || TREE_CODE (ce->index) == IDENTIFIER_NODE);\n+\t\t\t  || identifier_p (ce->index));\n \t      if (ce->index != field\n \t\t  && ce->index != DECL_NAME (field))\n \t\t{\n@@ -1367,7 +1366,7 @@ process_init_constructor_union (tree type, tree init,\n     {\n       if (TREE_CODE (ce->index) == FIELD_DECL)\n \t;\n-      else if (TREE_CODE (ce->index) == IDENTIFIER_NODE)\n+      else if (identifier_p (ce->index))\n \t{\n \t  /* This can happen within a cast, see g++.dg/opt/cse2.C.  */\n \t  tree name = ce->index;"}]}