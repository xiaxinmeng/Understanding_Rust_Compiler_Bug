{"sha": "bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNjNzA4ZmNkYzYwYzZiNDQ4NWIxNzk2YWMxYmE2MWM1ZjU2YjBiMw==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2012-05-08T15:54:13Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-05-08T15:54:13Z"}, "message": "basic-block.h (struct rtl_bb_info): Remove visited member and move head_ member to ...\n\n\t* basic-block.h (struct rtl_bb_info): Remove visited member and\n\tmove head_ member to ...\n\t(struct basic_block_def.basic_block_il_dependent): ... the new\n\tmember x, replacing but containing old member rtl.\n\t(enum bb_flags): New BB_VISITED flag.\n\t(BB_HEADER, BB_FOOTER): New macros.\n\n\t* jump.c (mark_all_labels): Adjust.\n\t* cfgcleanup.c (try_optimize_cfg): Adjust.\n\t* cfglayout.c (record_effective_endpoints): Adjust.\n\t(relink_block_chain): Ditto (and don't fiddle with visited).\n\t(fixup_reorder_chain): Adjust.\n\t(fixup_fallthru_exit_predecessor): Ditto.\n\t(cfg_layout_duplicate_bb): Ditto.\n\t* combine.c (update_cfg_for_uncondjump): Adjust.\n\t* bb-reorder.c (struct bbro_basic_block_data_def): Add visited\n\tmember.\n\t(bb_visited_trace): New accessor.\n\t(mark_bb_visited): Move in front.\n\t(rotate_loop): Use bb_visited_trace.\n\t(find_traces_1_round): Ditto.\n\t(emit_barrier_after): Ditto.\n\t(copy_bb): Ditto, and initialize visited on resize.\n\t(reorder_basic_blocks): Initize visited member.\n\t(duplicate_computed_gotos): Clear bb flags at start, use\n\tBB_VISITED flags.\n\n\t* cfgrtl.c (try_redirect_by_replacing_jump): Adjust.\n\t(rtl_verify_flow_info_1): Ditto.\n\t(cfg_layout_split_block): Ditto.\n\t(cfg_layout_delete_block): Ditto.\n\t(cfg_layout_merge_blocks): Ditto.\n\t(init_rtl_bb_info): Adjust and initialize il.x.head_ member.\n\nFrom-SVN: r187288", "tree": {"sha": "6c299e917ec2a3f887c9fedcefdf3a151c51eebb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c299e917ec2a3f887c9fedcefdf3a151c51eebb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "88231ff68197c2c22f33e1a8ba251bc0b02b1f2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88231ff68197c2c22f33e1a8ba251bc0b02b1f2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88231ff68197c2c22f33e1a8ba251bc0b02b1f2d"}], "stats": {"total": 281, "additions": 168, "deletions": 113}, "files": [{"sha": "e933f4e0cd9982e088958a3d34a9ed14028a7839", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "patch": "@@ -1,3 +1,39 @@\n+2012-05-08  Michael Matz  <matz@suse.de>\n+\n+\t* basic-block.h (struct rtl_bb_info): Remove visited member and\n+\tmove head_ member to ...\n+\t(struct basic_block_def.basic_block_il_dependent): ... the new\n+\tmember x, replacing but containing old member rtl.\n+\t(enum bb_flags): New BB_VISITED flag.\n+\t(BB_HEADER, BB_FOOTER): New macros.\n+\n+\t* jump.c (mark_all_labels): Adjust.\n+\t* cfgcleanup.c (try_optimize_cfg): Adjust.\n+\t* cfglayout.c (record_effective_endpoints): Adjust.\n+\t(relink_block_chain): Ditto (and don't fiddle with visited).\n+\t(fixup_reorder_chain): Adjust.\n+\t(fixup_fallthru_exit_predecessor): Ditto.\n+\t(cfg_layout_duplicate_bb): Ditto.\n+\t* combine.c (update_cfg_for_uncondjump): Adjust.\n+\t* bb-reorder.c (struct bbro_basic_block_data_def): Add visited\n+\tmember.\n+\t(bb_visited_trace): New accessor.\n+\t(mark_bb_visited): Move in front.\n+\t(rotate_loop): Use bb_visited_trace.\n+\t(find_traces_1_round): Ditto.\n+\t(emit_barrier_after): Ditto.\n+\t(copy_bb): Ditto, and initialize visited on resize.\n+\t(reorder_basic_blocks): Initize visited member.\n+\t(duplicate_computed_gotos): Clear bb flags at start, use\n+\tBB_VISITED flags.\n+\n+\t* cfgrtl.c (try_redirect_by_replacing_jump): Adjust.\n+\t(rtl_verify_flow_info_1): Ditto.\n+\t(cfg_layout_split_block): Ditto.\n+\t(cfg_layout_delete_block): Ditto.\n+\t(cfg_layout_merge_blocks): Ditto.\n+\t(init_rtl_bb_info): Adjust and initialize il.x.head_ member.\n+\n 2012-05-08  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR target/53272"}, {"sha": "f0eeba7a7d3ef0b04d8d07c6f30a8c91baf6cd43", "filename": "gcc/basic-block.h", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "patch": "@@ -102,17 +102,14 @@ extern const struct gcov_ctr_summary *profile_info;\n struct loop;\n \n struct GTY(()) rtl_bb_info {\n-  /* The first and last insns of the block.  */\n-  rtx head_;\n+  /* The first insn of the block is embedded into bb->il.x.  */\n+  /* The last insn of the block.  */\n   rtx end_;\n \n   /* In CFGlayout mode points to insn notes/jumptables to be placed just before\n      and after the block.   */\n-  rtx header;\n-  rtx footer;\n-\n-  /* This field is used by the bb-reorder pass.  */\n-  int visited;\n+  rtx header_;\n+  rtx footer_;\n };\n \n struct GTY(()) gimple_bb_info {\n@@ -169,7 +166,10 @@ struct GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\"))) basic_block_d\n \n   union basic_block_il_dependent {\n       struct gimple_bb_info GTY ((tag (\"0\"))) gimple;\n-      struct rtl_bb_info * GTY ((tag (\"1\"))) rtl;\n+      struct {\n+        rtx head_;\n+        struct rtl_bb_info * rtl;\n+      } GTY ((tag (\"1\"))) x;\n     } GTY ((desc (\"((%1.flags & BB_RTL) != 0)\"))) il;\n \n   /* Expected number of executions: calculated in profile.c.  */\n@@ -260,7 +260,10 @@ enum bb_flags\n      df_set_bb_dirty, but not cleared by df_analyze, so it can be used\n      to test whether a block has been modified prior to a df_analyze\n      call.  */\n-  BB_MODIFIED = 1 << 12\n+  BB_MODIFIED = 1 << 12,\n+\n+  /* A general visited flag for passes to use.  */\n+  BB_VISITED = 1 << 13\n };\n \n /* Dummy flag for convenience in the hot/cold partitioning code.  */\n@@ -415,8 +418,10 @@ struct GTY(()) control_flow_graph {\n \f\n /* Stuff for recording basic block info.  */\n \n-#define BB_HEAD(B)      (B)->il.rtl->head_\n-#define BB_END(B)       (B)->il.rtl->end_\n+#define BB_HEAD(B)      (B)->il.x.head_\n+#define BB_END(B)       (B)->il.x.rtl->end_\n+#define BB_HEADER(B)    (B)->il.x.rtl->header_\n+#define BB_FOOTER(B)    (B)->il.x.rtl->footer_\n \n /* Special block numbers [markers] for entry and exit.\n    Neither of them is supposed to hold actual statements.  */"}, {"sha": "7f73b947e695eb7e877ff95a2619c4035e957642", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "patch": "@@ -133,6 +133,9 @@ typedef struct bbro_basic_block_data_def\n   /* Which trace is the bb in?  */\n   int in_trace;\n \n+  /* Which trace was this bb visited in?  */\n+  int visited;\n+\n   /* Which heap is BB in (if any)?  */\n   fibheap_t heap;\n \n@@ -183,6 +186,29 @@ static void connect_traces (int, struct trace *);\n static bool copy_bb_p (const_basic_block, int);\n static bool push_to_next_round_p (const_basic_block, int, int, int, gcov_type);\n \f\n+/* Return the trace number in which BB was visited.  */\n+\n+static int\n+bb_visited_trace (const_basic_block bb)\n+{\n+  gcc_assert (bb->index < array_size);\n+  return bbd[bb->index].visited;\n+}\n+\n+/* This function marks BB that it was visited in trace number TRACE.  */\n+\n+static void\n+mark_bb_visited (basic_block bb, int trace)\n+{\n+  bbd[bb->index].visited = trace;\n+  if (bbd[bb->index].heap)\n+    {\n+      fibheap_delete_node (bbd[bb->index].heap, bbd[bb->index].node);\n+      bbd[bb->index].heap = NULL;\n+      bbd[bb->index].node = NULL;\n+    }\n+}\n+\n /* Check to see if bb should be pushed into the next round of trace\n    collections or not.  Reasons for pushing the block forward are 1).\n    If the block is cold, we are doing partitioning, and there will be\n@@ -306,14 +332,14 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->dest != EXIT_BLOCK_PTR\n-\t    && e->dest->il.rtl->visited != trace_n\n+\t    && bb_visited_trace (e->dest) != trace_n\n \t    && (e->flags & EDGE_CAN_FALLTHRU)\n \t    && !(e->flags & EDGE_COMPLEX))\n \t{\n \t  if (is_preferred)\n \t    {\n \t      /* The best edge is preferred.  */\n-\t      if (!e->dest->il.rtl->visited\n+\t      if (!bb_visited_trace (e->dest)\n \t\t  || bbd[e->dest->index].start_of_trace >= 0)\n \t\t{\n \t\t  /* The current edge E is also preferred.  */\n@@ -329,7 +355,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t    }\n \t  else\n \t    {\n-\t      if (!e->dest->il.rtl->visited\n+\t      if (!bb_visited_trace (e->dest)\n \t\t  || bbd[e->dest->index].start_of_trace >= 0)\n \t\t{\n \t\t  /* The current edge E is preferred.  */\n@@ -397,20 +423,6 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n   return best_bb;\n }\n \n-/* This function marks BB that it was visited in trace number TRACE.  */\n-\n-static void\n-mark_bb_visited (basic_block bb, int trace)\n-{\n-  bb->il.rtl->visited = trace;\n-  if (bbd[bb->index].heap)\n-    {\n-      fibheap_delete_node (bbd[bb->index].heap, bbd[bb->index].node);\n-      bbd[bb->index].heap = NULL;\n-      bbd[bb->index].node = NULL;\n-    }\n-}\n-\n /* One round of finding traces. Find traces for BRANCH_TH and EXEC_TH i.e. do\n    not include basic blocks their probability is lower than BRANCH_TH or their\n    frequency is lower than EXEC_TH into traces (or count is lower than\n@@ -496,8 +508,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \n-\t      if (e->dest->il.rtl->visited\n-\t\t  && e->dest->il.rtl->visited != *n_traces)\n+\t      if (bb_visited_trace (e->dest)\n+\t\t  && bb_visited_trace (e->dest) != *n_traces)\n \t\tcontinue;\n \n \t      if (BB_PARTITION (e->dest) != BB_PARTITION (bb))\n@@ -550,7 +562,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t    {\n \t      if (e == best_edge\n \t\t  || e->dest == EXIT_BLOCK_PTR\n-\t\t  || e->dest->il.rtl->visited)\n+\t\t  || bb_visited_trace (e->dest))\n \t\tcontinue;\n \n \t      key = bb_to_key (e->dest);\n@@ -611,7 +623,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n \t  if (best_edge) /* Suitable successor was found.  */\n \t    {\n-\t      if (best_edge->dest->il.rtl->visited == *n_traces)\n+\t      if (bb_visited_trace (best_edge->dest) == *n_traces)\n \t\t{\n \t\t  /* We do nothing with one basic block loops.  */\n \t\t  if (best_edge->dest != bb)\n@@ -682,7 +694,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t    if (e != best_edge\n \t\t\t&& (e->flags & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(e->flags & EDGE_COMPLEX)\n-\t\t\t&& !e->dest->il.rtl->visited\n+\t\t\t&& !bb_visited_trace (e->dest)\n \t\t\t&& single_pred_p (e->dest)\n \t\t\t&& !(e->flags & EDGE_CROSSING)\n \t\t\t&& single_succ_p (e->dest)\n@@ -716,7 +728,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (e->dest == EXIT_BLOCK_PTR\n-\t      || e->dest->il.rtl->visited)\n+\t      || bb_visited_trace (e->dest))\n \t    continue;\n \n \t  if (bbd[e->dest->index].heap)\n@@ -758,15 +770,11 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n   BB_COPY_PARTITION (new_bb, old_bb);\n \n   gcc_assert (e->dest == new_bb);\n-  gcc_assert (!e->dest->il.rtl->visited);\n \n   if (dump_file)\n     fprintf (dump_file,\n \t     \"Duplicated bb %d (created bb %d)\\n\",\n \t     old_bb->index, new_bb->index);\n-  new_bb->il.rtl->visited = trace;\n-  new_bb->aux = bb->aux;\n-  bb->aux = new_bb;\n \n   if (new_bb->index >= array_size || last_basic_block > array_size)\n     {\n@@ -779,8 +787,9 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n       for (i = array_size; i < new_size; i++)\n \t{\n \t  bbd[i].start_of_trace = -1;\n-\t  bbd[i].in_trace = -1;\n \t  bbd[i].end_of_trace = -1;\n+\t  bbd[i].in_trace = -1;\n+\t  bbd[i].visited = 0;\n \t  bbd[i].heap = NULL;\n \t  bbd[i].node = NULL;\n \t}\n@@ -794,6 +803,11 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n \t}\n     }\n \n+  gcc_assert (!bb_visited_trace (e->dest));\n+  mark_bb_visited (new_bb, trace);\n+  new_bb->aux = bb->aux;\n+  bb->aux = new_bb;\n+\n   bbd[new_bb->index].in_trace = trace;\n \n   return new_bb;\n@@ -1214,7 +1228,7 @@ static void\n emit_barrier_after_bb (basic_block bb)\n {\n   rtx barrier = emit_barrier_after (BB_END (bb));\n-  bb->il.rtl->footer = unlink_insn_chain (barrier, barrier);\n+  BB_FOOTER (bb) = unlink_insn_chain (barrier, barrier);\n }\n \n /* The landing pad OLD_LP, in block OLD_BB, has edges from both partitions.\n@@ -1929,8 +1943,9 @@ reorder_basic_blocks (void)\n   for (i = 0; i < array_size; i++)\n     {\n       bbd[i].start_of_trace = -1;\n-      bbd[i].in_trace = -1;\n       bbd[i].end_of_trace = -1;\n+      bbd[i].in_trace = -1;\n+      bbd[i].visited = 0;\n       bbd[i].heap = NULL;\n       bbd[i].node = NULL;\n     }\n@@ -2012,6 +2027,7 @@ duplicate_computed_gotos (void)\n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return 0;\n \n+  clear_bb_flags ();\n   cfg_layout_initialize (0);\n \n   /* We are estimating the length of uncond jump insn only once\n@@ -2075,10 +2091,10 @@ duplicate_computed_gotos (void)\n   /* Duplicate computed gotos.  */\n   FOR_EACH_BB (bb)\n     {\n-      if (bb->il.rtl->visited)\n+      if (bb->flags & BB_VISITED)\n \tcontinue;\n \n-      bb->il.rtl->visited = 1;\n+      bb->flags |= BB_VISITED;\n \n       /* BB must have one outgoing edge.  That edge must not lead to\n \t the exit block or the next block.\n@@ -2096,7 +2112,7 @@ duplicate_computed_gotos (void)\n       new_bb = duplicate_block (single_succ (bb), single_succ_edge (bb), bb);\n       new_bb->aux = bb->aux;\n       bb->aux = new_bb;\n-      new_bb->il.rtl->visited = 1;\n+      new_bb->flags |= BB_VISITED;\n     }\n \n done:"}, {"sha": "e94e7e3fb4161413a6859249e06ae31ae2fa0355", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "patch": "@@ -2586,21 +2586,21 @@ try_optimize_cfg (int mode)\n \n \t\t      if (current_ir_type () == IR_RTL_CFGLAYOUT)\n \t\t\t{\n-\t\t\t  if (b->il.rtl->footer\n-\t\t\t      && BARRIER_P (b->il.rtl->footer))\n+\t\t\t  if (BB_FOOTER (b)\n+\t\t\t      && BARRIER_P (BB_FOOTER (b)))\n \t\t\t    FOR_EACH_EDGE (e, ei, b->preds)\n \t\t\t      if ((e->flags & EDGE_FALLTHRU)\n-\t\t\t\t  && e->src->il.rtl->footer == NULL)\n+\t\t\t\t  && BB_FOOTER (e->src) == NULL)\n \t\t\t\t{\n-\t\t\t\t  if (b->il.rtl->footer)\n+\t\t\t\t  if (BB_FOOTER (b))\n \t\t\t\t    {\n-\t\t\t\t      e->src->il.rtl->footer = b->il.rtl->footer;\n-\t\t\t\t      b->il.rtl->footer = NULL;\n+\t\t\t\t      BB_FOOTER (e->src) = BB_FOOTER (b);\n+\t\t\t\t      BB_FOOTER (b) = NULL;\n \t\t\t\t    }\n \t\t\t\t  else\n \t\t\t\t    {\n \t\t\t\t      start_sequence ();\n-\t\t\t\t      e->src->il.rtl->footer = emit_barrier ();\n+\t\t\t\t      BB_FOOTER (e->src) = emit_barrier ();\n \t\t\t\t      end_sequence ();\n \t\t\t\t    }\n \t\t\t\t}"}, {"sha": "2a5448c7083b9daa262f9233138bc8bb98d7f233", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "patch": "@@ -208,11 +208,11 @@ record_effective_endpoints (void)\n       rtx end;\n \n       if (PREV_INSN (BB_HEAD (bb)) && next_insn != BB_HEAD (bb))\n-\tbb->il.rtl->header = unlink_insn_chain (next_insn,\n+\tBB_HEADER (bb) = unlink_insn_chain (next_insn,\n \t\t\t\t\t      PREV_INSN (BB_HEAD (bb)));\n       end = skip_insns_after_block (bb);\n       if (NEXT_INSN (BB_END (bb)) && BB_END (bb) != end)\n-\tbb->il.rtl->footer = unlink_insn_chain (NEXT_INSN (BB_END (bb)), end);\n+\tBB_FOOTER (bb) = unlink_insn_chain (NEXT_INSN (BB_END (bb)), end);\n       next_insn = NEXT_INSN (BB_END (bb));\n     }\n \n@@ -633,9 +633,8 @@ reemit_insn_block_notes (void)\n \f\n \n /* Link the basic blocks in the correct order, compacting the basic\n-   block queue while at it.  This also clears the visited flag on\n-   all basic blocks.  If STAY_IN_CFGLAYOUT_MODE is false, this function\n-   also clears the basic block header and footer fields.\n+   block queue while at it.  If STAY_IN_CFGLAYOUT_MODE is false, this\n+   function also clears the basic block header and footer fields.\n \n    This function is usually called after a pass (e.g. tracer) finishes\n    some transformations while in cfglayout mode.  The required sequence\n@@ -681,13 +680,12 @@ relink_block_chain (bool stay_in_cfglayout_mode)\n   prev_bb->next_bb = EXIT_BLOCK_PTR;\n   EXIT_BLOCK_PTR->prev_bb = prev_bb;\n \n-  /* Then, clean up the aux and visited fields.  */\n+  /* Then, clean up the aux fields.  */\n   FOR_ALL_BB (bb)\n     {\n       bb->aux = NULL;\n-      bb->il.rtl->visited = 0;\n       if (!stay_in_cfglayout_mode)\n-\tbb->il.rtl->header = bb->il.rtl->footer = NULL;\n+\tBB_HEADER (bb) = BB_FOOTER (bb) = NULL;\n     }\n \n   /* Maybe reset the original copy tables, they are not valid anymore\n@@ -723,14 +721,14 @@ fixup_reorder_chain (void)\n \n   for (bb = ENTRY_BLOCK_PTR->next_bb; bb; bb = (basic_block) bb->aux)\n     {\n-      if (bb->il.rtl->header)\n+      if (BB_HEADER (bb))\n \t{\n \t  if (insn)\n-\t    NEXT_INSN (insn) = bb->il.rtl->header;\n+\t    NEXT_INSN (insn) = BB_HEADER (bb);\n \t  else\n-\t    set_first_insn (bb->il.rtl->header);\n-\t  PREV_INSN (bb->il.rtl->header) = insn;\n-\t  insn = bb->il.rtl->header;\n+\t    set_first_insn (BB_HEADER (bb));\n+\t  PREV_INSN (BB_HEADER (bb)) = insn;\n+\t  insn = BB_HEADER (bb);\n \t  while (NEXT_INSN (insn))\n \t    insn = NEXT_INSN (insn);\n \t}\n@@ -740,10 +738,10 @@ fixup_reorder_chain (void)\n \tset_first_insn (BB_HEAD (bb));\n       PREV_INSN (BB_HEAD (bb)) = insn;\n       insn = BB_END (bb);\n-      if (bb->il.rtl->footer)\n+      if (BB_FOOTER (bb))\n \t{\n-\t  NEXT_INSN (insn) = bb->il.rtl->footer;\n-\t  PREV_INSN (bb->il.rtl->footer) = insn;\n+\t  NEXT_INSN (insn) = BB_FOOTER (bb);\n+\t  PREV_INSN (BB_FOOTER (bb)) = insn;\n \t  while (NEXT_INSN (insn))\n \t    insn = NEXT_INSN (insn);\n \t}\n@@ -799,7 +797,7 @@ fixup_reorder_chain (void)\n \t\t{\n \t\t  gcc_assert (!onlyjump_p (bb_end_insn)\n \t\t\t      || returnjump_p (bb_end_insn));\n-\t\t  bb->il.rtl->footer = emit_barrier_after (bb_end_insn);\n+\t\t  BB_FOOTER (bb) = emit_barrier_after (bb_end_insn);\n \t\t  continue;\n \t\t}\n \n@@ -908,7 +906,6 @@ fixup_reorder_chain (void)\n       nb = force_nonfallthru_and_redirect (e_fall, e_fall->dest, ret_label);\n       if (nb)\n \t{\n-\t  nb->il.rtl->visited = 1;\n \t  nb->aux = bb->aux;\n \t  bb->aux = nb;\n \t  /* Don't process this new block.  */\n@@ -1062,8 +1059,8 @@ fixup_fallthru_exit_predecessor (void)\n \t  bb = split_block (bb, NULL)->dest;\n \t  bb->aux = c->aux;\n \t  c->aux = bb;\n-\t  bb->il.rtl->footer = c->il.rtl->footer;\n-\t  c->il.rtl->footer = NULL;\n+\t  BB_FOOTER (bb) = BB_FOOTER (c);\n+\t  BB_FOOTER (c) = NULL;\n \t}\n \n       while (c->aux != bb)\n@@ -1272,24 +1269,24 @@ cfg_layout_duplicate_bb (basic_block bb)\n \t\t\t       EXIT_BLOCK_PTR->prev_bb);\n \n   BB_COPY_PARTITION (new_bb, bb);\n-  if (bb->il.rtl->header)\n+  if (BB_HEADER (bb))\n     {\n-      insn = bb->il.rtl->header;\n+      insn = BB_HEADER (bb);\n       while (NEXT_INSN (insn))\n \tinsn = NEXT_INSN (insn);\n-      insn = duplicate_insn_chain (bb->il.rtl->header, insn);\n+      insn = duplicate_insn_chain (BB_HEADER (bb), insn);\n       if (insn)\n-\tnew_bb->il.rtl->header = unlink_insn_chain (insn, get_last_insn ());\n+\tBB_HEADER (new_bb) = unlink_insn_chain (insn, get_last_insn ());\n     }\n \n-  if (bb->il.rtl->footer)\n+  if (BB_FOOTER (bb))\n     {\n-      insn = bb->il.rtl->footer;\n+      insn = BB_FOOTER (bb);\n       while (NEXT_INSN (insn))\n \tinsn = NEXT_INSN (insn);\n-      insn = duplicate_insn_chain (bb->il.rtl->footer, insn);\n+      insn = duplicate_insn_chain (BB_FOOTER (bb), insn);\n       if (insn)\n-\tnew_bb->il.rtl->footer = unlink_insn_chain (insn, get_last_insn ());\n+\tBB_FOOTER (new_bb) = unlink_insn_chain (insn, get_last_insn ());\n     }\n \n   return new_bb;"}, {"sha": "4e1ec8644d1acb4d93af333a3a52c4a56593f354", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "patch": "@@ -837,7 +837,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       /* Selectively unlink whole insn chain.  */\n       if (in_cfglayout)\n \t{\n-\t  rtx insn = src->il.rtl->footer;\n+\t  rtx insn = BB_FOOTER (src);\n \n \t  delete_insn_chain (kill_from, BB_END (src), false);\n \n@@ -849,7 +849,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t\t  if (PREV_INSN (insn))\n \t\t    NEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n \t\t  else\n-\t\t    src->il.rtl->footer = NEXT_INSN (insn);\n+\t\t    BB_FOOTER (src) = NEXT_INSN (insn);\n \t\t  if (NEXT_INSN (insn))\n \t\t    PREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n \t\t}\n@@ -1857,15 +1857,15 @@ rtl_verify_flow_info_1 (void)\n \t    err = 1;\n \t  }\n \n-      for (insn = bb->il.rtl->header; insn; insn = NEXT_INSN (insn))\n+      for (insn = BB_HEADER (bb); insn; insn = NEXT_INSN (insn))\n \tif (!BARRIER_P (insn)\n \t    && BLOCK_FOR_INSN (insn) != NULL)\n \t  {\n \t    error (\"insn %d in header of bb %d has non-NULL basic block\",\n \t\t   INSN_UID (insn), bb->index);\n \t    err = 1;\n \t  }\n-      for (insn = bb->il.rtl->footer; insn; insn = NEXT_INSN (insn))\n+      for (insn = BB_FOOTER (bb); insn; insn = NEXT_INSN (insn))\n \tif (!BARRIER_P (insn)\n \t    && BLOCK_FOR_INSN (insn) != NULL)\n \t  {\n@@ -2597,8 +2597,8 @@ cfg_layout_split_block (basic_block bb, void *insnp)\n   rtx insn = (rtx) insnp;\n   basic_block new_bb = rtl_split_block (bb, insn);\n \n-  new_bb->il.rtl->footer = bb->il.rtl->footer;\n-  bb->il.rtl->footer = NULL;\n+  BB_FOOTER (new_bb) = BB_FOOTER (bb);\n+  BB_FOOTER (bb) = NULL;\n \n   return new_bb;\n }\n@@ -2703,44 +2703,44 @@ cfg_layout_delete_block (basic_block bb)\n {\n   rtx insn, next, prev = PREV_INSN (BB_HEAD (bb)), *to, remaints;\n \n-  if (bb->il.rtl->header)\n+  if (BB_HEADER (bb))\n     {\n       next = BB_HEAD (bb);\n       if (prev)\n-\tNEXT_INSN (prev) = bb->il.rtl->header;\n+\tNEXT_INSN (prev) = BB_HEADER (bb);\n       else\n-\tset_first_insn (bb->il.rtl->header);\n-      PREV_INSN (bb->il.rtl->header) = prev;\n-      insn = bb->il.rtl->header;\n+\tset_first_insn (BB_HEADER (bb));\n+      PREV_INSN (BB_HEADER (bb)) = prev;\n+      insn = BB_HEADER (bb);\n       while (NEXT_INSN (insn))\n \tinsn = NEXT_INSN (insn);\n       NEXT_INSN (insn) = next;\n       PREV_INSN (next) = insn;\n     }\n   next = NEXT_INSN (BB_END (bb));\n-  if (bb->il.rtl->footer)\n+  if (BB_FOOTER (bb))\n     {\n-      insn = bb->il.rtl->footer;\n+      insn = BB_FOOTER (bb);\n       while (insn)\n \t{\n \t  if (BARRIER_P (insn))\n \t    {\n \t      if (PREV_INSN (insn))\n \t\tNEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n \t      else\n-\t\tbb->il.rtl->footer = NEXT_INSN (insn);\n+\t\tBB_FOOTER (bb) = NEXT_INSN (insn);\n \t      if (NEXT_INSN (insn))\n \t\tPREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n \t    }\n \t  if (LABEL_P (insn))\n \t    break;\n \t  insn = NEXT_INSN (insn);\n \t}\n-      if (bb->il.rtl->footer)\n+      if (BB_FOOTER (bb))\n \t{\n \t  insn = BB_END (bb);\n-\t  NEXT_INSN (insn) = bb->il.rtl->footer;\n-\t  PREV_INSN (bb->il.rtl->footer) = insn;\n+\t  NEXT_INSN (insn) = BB_FOOTER (bb);\n+\t  PREV_INSN (BB_FOOTER (bb)) = insn;\n \t  while (NEXT_INSN (insn))\n \t    insn = NEXT_INSN (insn);\n \t  NEXT_INSN (insn) = next;\n@@ -2751,7 +2751,7 @@ cfg_layout_delete_block (basic_block bb)\n \t}\n     }\n   if (bb->next_bb != EXIT_BLOCK_PTR)\n-    to = &bb->next_bb->il.rtl->header;\n+    to = &BB_HEADER (bb->next_bb);\n   else\n     to = &cfg_layout_function_footer;\n \n@@ -2882,18 +2882,18 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n     }\n \n   /* Possible line number notes should appear in between.  */\n-  if (b->il.rtl->header)\n+  if (BB_HEADER (b))\n     {\n       rtx first = BB_END (a), last;\n \n-      last = emit_insn_after_noloc (b->il.rtl->header, BB_END (a), a);\n+      last = emit_insn_after_noloc (BB_HEADER (b), BB_END (a), a);\n       /* The above might add a BARRIER as BB_END, but as barriers\n \t aren't valid parts of a bb, remove_insn doesn't update\n \t BB_END if it is a barrier.  So adjust BB_END here.  */\n       while (BB_END (a) != first && BARRIER_P (BB_END (a)))\n \tBB_END (a) = PREV_INSN (BB_END (a));\n       delete_insn_chain (NEXT_INSN (first), last, false);\n-      b->il.rtl->header = NULL;\n+      BB_HEADER (b) = NULL;\n     }\n \n   /* In the case basic blocks are not adjacent, move them around.  */\n@@ -2924,20 +2924,20 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n   df_bb_delete (b->index);\n \n   /* Possible tablejumps and barriers should appear after the block.  */\n-  if (b->il.rtl->footer)\n+  if (BB_FOOTER (b))\n     {\n-      if (!a->il.rtl->footer)\n-\ta->il.rtl->footer = b->il.rtl->footer;\n+      if (!BB_FOOTER (a))\n+\tBB_FOOTER (a) = BB_FOOTER (b);\n       else\n \t{\n-\t  rtx last = a->il.rtl->footer;\n+\t  rtx last = BB_FOOTER (a);\n \n \t  while (NEXT_INSN (last))\n \t    last = NEXT_INSN (last);\n-\t  NEXT_INSN (last) = b->il.rtl->footer;\n-\t  PREV_INSN (b->il.rtl->footer) = last;\n+\t  NEXT_INSN (last) = BB_FOOTER (b);\n+\t  PREV_INSN (BB_FOOTER (b)) = last;\n \t}\n-      b->il.rtl->footer = NULL;\n+      BB_FOOTER (b) = NULL;\n     }\n \n   /* If B was a forwarder block, propagate the locus on the edge.  */\n@@ -3211,8 +3211,9 @@ rtl_extract_cond_bb_edges (basic_block b, edge *branch_edge,\n void\n init_rtl_bb_info (basic_block bb)\n {\n-  gcc_assert (!bb->il.rtl);\n-  bb->il.rtl = ggc_alloc_cleared_rtl_bb_info ();\n+  gcc_assert (!bb->il.x.rtl);\n+  bb->il.x.head_ = NULL;\n+  bb->il.x.rtl = ggc_alloc_cleared_rtl_bb_info ();\n }\n \n /* Returns true if it is possible to remove edge E by redirecting"}, {"sha": "67a35207d4f2f3ea1de825d2602f5d2ebe82f44d", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "patch": "@@ -2536,13 +2536,13 @@ update_cfg_for_uncondjump (rtx insn)\n       single_succ_edge (bb)->flags |= EDGE_FALLTHRU;\n \n       /* Remove barriers from the footer if there are any.  */\n-      for (insn = bb->il.rtl->footer; insn; insn = NEXT_INSN (insn))\n+      for (insn = BB_FOOTER (bb); insn; insn = NEXT_INSN (insn))\n \tif (BARRIER_P (insn))\n \t  {\n \t    if (PREV_INSN (insn))\n \t      NEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n \t    else\n-\t      bb->il.rtl->footer = NEXT_INSN (insn);\n+\t      BB_FOOTER (bb) = NEXT_INSN (insn);\n \t    if (NEXT_INSN (insn))\n \t      PREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n \t  }"}, {"sha": "246fab02ff354e8585fd7743100b06b6d4ed2377", "filename": "gcc/jump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=bcc708fcdc60c6b4485b1796ac1ba61c5f56b0b3", "patch": "@@ -275,13 +275,13 @@ mark_all_labels (rtx f)\n \t  /* In cfglayout mode, there may be non-insns between the\n \t     basic blocks.  If those non-insns represent tablejump data,\n \t     they contain label references that we must record.  */\n-\t  for (insn = bb->il.rtl->header; insn; insn = NEXT_INSN (insn))\n+\t  for (insn = BB_HEADER (bb); insn; insn = NEXT_INSN (insn))\n \t    if (INSN_P (insn))\n \t      {\n \t\tgcc_assert (JUMP_TABLE_DATA_P (insn));\n \t\tmark_jump_label (PATTERN (insn), insn, 0);\n \t      }\n-\t  for (insn = bb->il.rtl->footer; insn; insn = NEXT_INSN (insn))\n+\t  for (insn = BB_FOOTER (bb); insn; insn = NEXT_INSN (insn))\n \t    if (INSN_P (insn))\n \t      {\n \t\tgcc_assert (JUMP_TABLE_DATA_P (insn));"}]}