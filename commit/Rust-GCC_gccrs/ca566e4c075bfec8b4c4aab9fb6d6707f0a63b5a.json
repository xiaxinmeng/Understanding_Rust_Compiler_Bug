{"sha": "ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E1NjZlNGMwNzViZmVjOGI0YzRhYWI5ZmI2ZDY3MDdmMGE2M2I1YQ==", "commit": {"author": {"name": "Nathan C. Myers", "email": "ncm-nospam@cantrip.org", "date": "2003-06-13T20:59:42Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-06-13T20:59:42Z"}, "message": "Avoid multi-processor bus contention on increment/decrement-and- test of the reference count in the empty-string object...\n\n2003-06-13  Nathan C. Myers <ncm-nospam@cantrip.org>\n\n\tAvoid multi-processor bus contention on increment/decrement-and-\n\ttest of the reference count in the empty-string object, by comparing\n        addresses first, and never touching the reference count of the empty-\n        string object.\n\t* include/bits/basic_string.h:\n\t(_S_empty_rep_storage): Move into basic_string<>::_Rep for use by its\n\tmembers.\n\t(_Rep::_S_empty_rep()): New accessor.\n\t(_Rep::_M_length, _Rep::_M_capacity, _Rep::_M_references): Move to\n\ta base class _Rep_base.\n\t(_Rep::_M_dispose, _Rep::_M_refcopy): Check for the empty string.\n\t(basic_string()): Change to use _M_refdata() in place of _M_refcopy(),\n\tsince no longer must increment its refcount.\n\t* include/bits/basic_string.tcc:\n\t(_Rep::_M_destroy, _M_leak_hard): Check for the empty string and\n        return immediately.  The former might be unnecessary.  The latter\n        prevents begin() and end() from cloning it unnecessarily.\n\t(_S_construct(_InIterator, _InIterator, const _Alloc&,\n\tinput_iterator_tag), _S_construct(_InIterator, _InIterator,\n\tconst _Alloc&, forward_iterator_tag), _S_construct(size_type, _CharT,\n\tconst _Alloc&)): Change to use _M_refdata() in place of _M_refcopy().\n\t(_M_mutate): Check for the empty string and treat it as shared.\n        This is necessary here because _M_mutate is sometimes called with\n        all-zero arguments; in all other uses of _M_is_shared, the test comes\n        out right anyhow.\n\nFrom-SVN: r67912", "tree": {"sha": "93548ad6fc3770e67322116c7c4cf63b2aaf9778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93548ad6fc3770e67322116c7c4cf63b2aaf9778"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a/comments", "author": null, "committer": null, "parents": [{"sha": "9f629a219154cf0b501355215fb3b73f0a2b71b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f629a219154cf0b501355215fb3b73f0a2b71b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f629a219154cf0b501355215fb3b73f0a2b71b2"}], "stats": {"total": 132, "additions": 91, "deletions": 41}, "files": [{"sha": "883e9f8942cafa39820d838051212d2255827aa0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a", "patch": "@@ -1,3 +1,31 @@\n+2003-06-13  Nathan C. Myers <ncm-nospam@cantrip.org>\n+\n+\tAvoid multi-processor bus contention on increment/decrement-and-\n+\ttest of the reference count in the empty-string object, by comparing \n+        addresses first, and never touching the reference count of the empty-\n+        string object.  \n+\t* include/bits/basic_string.h:\n+\t(_S_empty_rep_storage): Move into basic_string<>::_Rep for use by its\n+\tmembers.\n+\t(_Rep::_S_empty_rep()): New accessor. \n+\t(_Rep::_M_length, _Rep::_M_capacity, _Rep::_M_references): Move to\n+\ta base class _Rep_base.\n+\t(_Rep::_M_dispose, _Rep::_M_refcopy): Check for the empty string.\n+\t(basic_string()): Change to use _M_refdata() in place of _M_refcopy(),\n+\tsince no longer must increment its refcount.\n+\t* include/bits/basic_string.tcc:\n+\t(_Rep::_M_destroy, _M_leak_hard): Check for the empty string and \n+        return immediately.  The former might be unnecessary.  The latter \n+        prevents begin() and end() from cloning it unnecessarily.\n+\t(_S_construct(_InIterator, _InIterator, const _Alloc&,\n+\tinput_iterator_tag), _S_construct(_InIterator, _InIterator,\n+\tconst _Alloc&, forward_iterator_tag), _S_construct(size_type, _CharT,\n+\tconst _Alloc&)): Change to use _M_refdata() in place of _M_refcopy().\n+\t(_M_mutate): Check for the empty string and treat it as shared.\n+        This is necessary here because _M_mutate is sometimes called with\n+        all-zero arguments; in all other uses of _M_is_shared, the test comes\n+        out right anyhow.\n+\n 2003-06-12  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* src/allocator-inst.cc: Explicitly instantiate."}, {"sha": "c843b75efd5697db1deec4466baff3e5bde63e33", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a", "patch": "@@ -1,6 +1,6 @@\n // Components for manipulating sequences of characters -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -140,7 +140,15 @@ namespace std\n       //   4. All fields==0 is an empty string, given the extra storage\n       //      beyond-the-end for a null terminator; thus, the shared\n       //      empty string representation needs no constructor.\n-      struct _Rep\n+\n+      struct _Rep_base\n+      {\n+\tsize_type \t\t_M_length;\n+\tsize_type \t\t_M_capacity;\n+\t_Atomic_word\t\t_M_references;\n+      };\n+\n+      struct _Rep : _Rep_base\n       {\n \t// Types:\n \ttypedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;\n@@ -157,29 +165,33 @@ namespace std\n \t// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)\n \t// Solving for m:\n \t// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1\n-\t// In addition, this implementation quarters this ammount.\n+\t// In addition, this implementation quarters this amount.\n \tstatic const size_type \t_S_max_size;\n \tstatic const _CharT \t_S_terminal;\n \n-\tsize_type \t\t_M_length;\n-\tsize_type \t\t_M_capacity;\n-\t_Atomic_word\t\t_M_references;\n+\t// The following storage is init'd to 0 by the linker, resulting\n+        // (carefully) in an empty string with one reference.\n+        static size_type _S_empty_rep_storage[];\n \n+        static _Rep& \n+        _S_empty_rep()\n+        { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }\n+ \n         bool\n \t_M_is_leaked() const\n-        { return _M_references < 0; }\n+        { return this->_M_references < 0; }\n \n         bool\n \t_M_is_shared() const\n-        { return _M_references > 0; }\n+        { return this->_M_references > 0; }\n \n         void\n \t_M_set_leaked()\n-        { _M_references = -1; }\n+        { this->_M_references = -1; }\n \n         void\n \t_M_set_sharable()\n-        { _M_references = 0; }\n+        { this->_M_references = 0; }\n \n \t_CharT*\n \t_M_refdata() throw()\n@@ -203,8 +215,9 @@ namespace std\n \tvoid\n \t_M_dispose(const _Alloc& __a)\n \t{\n-\t  if (__exchange_and_add(&_M_references, -1) <= 0)\n-\t    _M_destroy(__a);\n+\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n+\t    if (__exchange_and_add(&this->_M_references, -1) <= 0)\n+\t      _M_destroy(__a);\n \t}  // XXX MT\n \n \tvoid\n@@ -213,7 +226,8 @@ namespace std\n \t_CharT*\n \t_M_refcopy() throw()\n \t{\n-\t  __atomic_add(&_M_references, 1);\n+\t  if (__builtin_expect(this != &_S_empty_rep(), false))\n+            __atomic_add(&this->_M_references, 1);\n \t  return _M_refdata();\n \t}  // XXX MT\n \n@@ -240,10 +254,6 @@ namespace std\n       // Data Members (private):\n       mutable _Alloc_hider \t_M_dataplus;\n \n-      // The following storage is init'd to 0 by the linker, resulting\n-      // (carefully) in an empty string with one reference.\n-      static size_type _S_empty_rep_storage[(sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];\n-\n       _CharT*\n       _M_data() const\n       { return  _M_dataplus._M_p; }\n@@ -322,7 +332,7 @@ namespace std\n \n       static _Rep&\n       _S_empty_rep()\n-      { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }\n+      { return _Rep::_S_empty_rep(); }\n \n     public:\n       // Construct/copy/destroy:\n@@ -859,7 +869,7 @@ namespace std\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     inline basic_string<_CharT, _Traits, _Alloc>::\n     basic_string()\n-    : _M_dataplus(_S_empty_rep()._M_refcopy(), _Alloc()) { }\n+    : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }\n \n   // operator+\n   template<typename _CharT, typename _Traits, typename _Alloc>"}, {"sha": "9b83603521944321cd4bc5d716ab6ef3a43e32a6", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=ca566e4c075bfec8b4c4aab9fb6d6707f0a63b5a", "patch": "@@ -48,7 +48,7 @@ namespace std\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     const typename basic_string<_CharT, _Traits, _Alloc>::size_type \n     basic_string<_CharT, _Traits, _Alloc>::\n-    _Rep::_S_max_size = (((npos - sizeof(_Rep))/sizeof(_CharT)) - 1) / 4;\n+    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     const _CharT \n@@ -63,8 +63,9 @@ namespace std\n   // at static init time (before static ctors are run).\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     typename basic_string<_CharT, _Traits, _Alloc>::size_type\n-    basic_string<_CharT, _Traits, _Alloc>::_S_empty_rep_storage[\n-    (sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];\n+    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[\n+    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /\n+      sizeof(size_type)];\n \n   // NB: This is the special case for Input Iterators, used in\n   // istreambuf_iterators, etc.\n@@ -78,7 +79,7 @@ namespace std\n \t\t   input_iterator_tag)\n       {\n \tif (__beg == __end && __a == _Alloc())\n-\t  return _S_empty_rep()._M_refcopy();\n+\t  return _S_empty_rep()._M_refdata();\n \t// Avoid reallocation for common case.\n \t_CharT __buf[100];\n \tsize_type __i = 0;\n@@ -138,7 +139,7 @@ namespace std\n \t\t   forward_iterator_tag)\n       {\n \tif (__beg == __end && __a == _Alloc())\n-\t  return _S_empty_rep()._M_refcopy();\n+\t  return _S_empty_rep()._M_refdata();\n \n \t// NB: Not required, but considered best practice.\n \tif (__builtin_expect(__beg == _InIterator(), 0))\n@@ -167,7 +168,7 @@ namespace std\n     _S_construct(size_type __n, _CharT __c, const _Alloc& __a)\n     {\n       if (__n == 0 && __a == _Alloc())\n-\treturn _S_empty_rep()._M_refcopy();\n+\treturn _S_empty_rep()._M_refdata();\n \n       // Check for out_of_range and length_error exceptions.\n       _Rep* __r = _Rep::_S_create(__n, __a);\n@@ -242,7 +243,8 @@ namespace std\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT, _Traits, _Alloc>&\n-    basic_string<_CharT, _Traits, _Alloc>::assign(const basic_string& __str)\n+    basic_string<_CharT, _Traits, _Alloc>::\n+    assign(const basic_string& __str)\n     {\n       if (_M_rep() != __str._M_rep())\n \t{\n@@ -371,14 +373,19 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::_Rep::\n     _M_destroy(const _Alloc& __a) throw ()\n     {\n-      const size_type __size = sizeof(_Rep) + (_M_capacity + 1) * sizeof(_CharT);\n+      if (this == &_S_empty_rep())\n+        return;\n+      const size_type __size = sizeof(_Rep_base) +\n+\t                       (this->_M_capacity + 1) * sizeof(_CharT);\n       _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);\n     }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n     basic_string<_CharT, _Traits, _Alloc>::_M_leak_hard()\n     {\n+      if (_M_rep() == &_S_empty_rep())\n+        return;\n       if (_M_rep()->_M_is_shared()) \n \t_M_mutate(0, 0, 0);\n       _M_rep()->_M_set_leaked();\n@@ -400,7 +407,8 @@ namespace std\n       const _CharT*        __src = _M_data()  + __pos + __len1;\n       const size_type __how_much = __old_size - __pos - __len1;\n       \n-      if (_M_rep()->_M_is_shared() || __new_size > capacity())\n+      if (_M_rep() == &_S_empty_rep()\n+\t  || _M_rep()->_M_is_shared() || __new_size > capacity())\n \t{\n \t  // Must reallocate.\n \t  allocator_type __a = get_allocator();\n@@ -434,7 +442,7 @@ namespace std\n \t    }\n \t  _M_rep()->_M_dispose(__a);\n \t  _M_data(__r->_M_refdata());\n-      }\n+\t}\n       else if (__how_much && __len1 != __len2)\n \t{\n \t  // Work in-place\n@@ -443,7 +451,7 @@ namespace std\n       _M_rep()->_M_set_sharable();\n       _M_rep()->_M_length = __new_size;\n       _M_data()[__new_size] = _Rep::_S_terminal; // grrr. (per 21.3.4)\n-    // You cannot leave those LWG people alone for a second.\n+      // You cannot leave those LWG people alone for a second.\n     }\n   \n   template<typename _CharT, typename _Traits, typename _Alloc>\n@@ -505,7 +513,7 @@ namespace std\n       // NB: Need an array of char_type[__capacity], plus a\n       // terminating null char_type() element, plus enough for the\n       // _Rep data structure. Whew. Seemingly so needy, yet so elemental.\n-      size_t __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\n+      size_t __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep_base);\n \n       // The standard places no restriction on allocating more memory\n       // than is strictly needed within this layer at the moment or as\n@@ -538,15 +546,15 @@ namespace std\n \t    (__pagesize - ((__size + __malloc_header_size) % __pagesize))\n \t    % __pagesize;\n \t  __capacity += __extra / sizeof(_CharT);\n-\t  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\n+\t  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep_base);\n \t}\n       else if (__size > __subpagesize)\n \t{\n \t  const size_t __extra =\n \t    (__subpagesize - ((__size + __malloc_header_size) % __subpagesize))\n \t    % __subpagesize;\n \t  __capacity += __extra / sizeof(_CharT);\n-\t  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);\n+\t  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep_base);\n \t}\n \n       // NB: Might throw, but no worries about a leak, mate: _Rep()\n@@ -565,33 +573,37 @@ namespace std\n     _M_clone(const _Alloc& __alloc, size_type __res)\n     {\n       // Requested capacity of the clone.\n-      const size_type __requested_cap = _M_length + __res;\n+      const size_type __requested_cap = this->_M_length + __res;\n       // See above (_S_create) for the meaning and value of these constants.\n       const size_type __pagesize = 4096;\n       const size_type __malloc_header_size = 4 * sizeof (void*);\n       // The biggest string which fits in a memory page.\n       const size_type __page_capacity =\n-        (__pagesize - __malloc_header_size - sizeof(_Rep) - sizeof(_CharT))\n+        (__pagesize - __malloc_header_size - sizeof(_Rep_base) - sizeof(_CharT))\n         / sizeof(_CharT);\n       _Rep* __r;\n-      if (__requested_cap > _M_capacity && __requested_cap > __page_capacity)\n+      if (__requested_cap > this->_M_capacity\n+\t  && __requested_cap > __page_capacity)\n         // Growing exponentially.\n-        __r = _Rep::_S_create(__requested_cap > 2*_M_capacity ?\n-                              __requested_cap : 2*_M_capacity, __alloc);\n+        __r = _Rep::_S_create(__requested_cap > 2*this->_M_capacity ?\n+                              __requested_cap : 2*this->_M_capacity, __alloc);\n       else\n         __r = _Rep::_S_create(__requested_cap, __alloc);\n       \n-      if (_M_length)\n+      if (this->_M_length)\n \t{\n \t  try \n-\t    { traits_type::copy(__r->_M_refdata(), _M_refdata(), _M_length); }\n+\t    {\n+\t      traits_type::copy(__r->_M_refdata(), _M_refdata(),\n+\t\t\t\tthis->_M_length);\n+\t    }\n \t  catch(...)  \n \t    { \n \t      __r->_M_destroy(__alloc); \n \t      __throw_exception_again;\n \t    }\n \t}\n-      __r->_M_length = _M_length;\n+      __r->_M_length = this->_M_length;\n       return __r->_M_refdata();\n     }\n   "}]}