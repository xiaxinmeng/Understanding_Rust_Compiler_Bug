{"sha": "fe96ecb94ac3a81499d804d428d275284e676027", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU5NmVjYjk0YWMzYTgxNDk5ZDgwNGQ0MjhkMjc1Mjg0ZTY3NjAyNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:33:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T12:33:22Z"}, "message": "[multiple changes]\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* a-cdlili.adb: Minor addition of pragma Warnings (Off).\n\n2013-04-11  Robert Dewar  <dewar@adacore.com>\n\n\t* hostparm.ads: Minor reformatting.\n\n2013-04-11  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.ads, aspects.adb: Add Aspect_Depends to all the relevant\n\ttables.\n\t* elists.ads, elists.adb (Contains): New routine.\n\t* par-prag.adb: Pragma Depends does not need any special treatment\n\tby the parser.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n\tTransform aspect Depends into a corresponding pragma.\n\t(Check_Aspect_At_Freeze_Point): Aspect Depends does not need\n\tinspection at its freeze point.\n\t* sem_prag.adb (Analyze_Pragma): Perform analysis and\n\tnormalization of pragma Depends. Remove the use of function\n\tIs_Duplicate_Item. Use End_Scope to uninstalle the formal\n\tparameters of a subprogram. Add a value for pragma Depends in\n\ttable Sig_Flags.\n\t(Is_Duplicate_Item): Removed.\n\t* snames.ads-tmpl: Add predefined name for Depends as well as\n\ta pragma identifier.\n\nFrom-SVN: r197774", "tree": {"sha": "5aa7f395f252e3b9883e6e1455e0a7338497bdc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aa7f395f252e3b9883e6e1455e0a7338497bdc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe96ecb94ac3a81499d804d428d275284e676027", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe96ecb94ac3a81499d804d428d275284e676027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe96ecb94ac3a81499d804d428d275284e676027", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe96ecb94ac3a81499d804d428d275284e676027/comments", "author": null, "committer": null, "parents": [{"sha": "8bfbd380f2c411f1b264fa234b3beb9cde53752b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bfbd380f2c411f1b264fa234b3beb9cde53752b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bfbd380f2c411f1b264fa234b3beb9cde53752b"}], "stats": {"total": 839, "additions": 796, "deletions": 43}, "files": [{"sha": "5899c52661dfa6dc32c3420ae029fd90f402f31a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -1,3 +1,31 @@\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-cdlili.adb: Minor addition of pragma Warnings (Off).\n+\n+2013-04-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* hostparm.ads: Minor reformatting.\n+\n+2013-04-11  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.ads, aspects.adb: Add Aspect_Depends to all the relevant\n+\ttables.\n+\t* elists.ads, elists.adb (Contains): New routine.\n+\t* par-prag.adb: Pragma Depends does not need any special treatment\n+\tby the parser.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n+\tTransform aspect Depends into a corresponding pragma.\n+\t(Check_Aspect_At_Freeze_Point): Aspect Depends does not need\n+\tinspection at its freeze point.\n+\t* sem_prag.adb (Analyze_Pragma): Perform analysis and\n+\tnormalization of pragma Depends. Remove the use of function\n+\tIs_Duplicate_Item. Use End_Scope to uninstalle the formal\n+\tparameters of a subprogram. Add a value for pragma Depends in\n+\ttable Sig_Flags.\n+\t(Is_Duplicate_Item): Removed.\n+\t* snames.ads-tmpl: Add predefined name for Depends as well as\n+\ta pragma identifier.\n+\n 2013-04-11  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnat1drv.adb: Minor code clean up."}, {"sha": "b097ef86ca4a1a77a92caf6aba812e605e3855e5", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -570,6 +570,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          B := B + 1;\n          L := L + 1;\n \n+         pragma Warnings (Off);\n+         --  Deal with junk infinite loop warning from below loop\n+\n          Result := null;\n          while Node /= null loop\n             if Node.Element = Item then\n@@ -580,6 +583,9 @@ package body Ada.Containers.Doubly_Linked_Lists is\n             end if;\n          end loop;\n \n+         pragma Warnings (On);\n+         --  End of section dealing with junk infinite loop warning\n+\n          B := B - 1;\n          L := L - 1;\n "}, {"sha": "8186e0ca7b425c73ff8cbf2b66b74a8999c4eeef", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2010-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -259,6 +259,7 @@ package body Aspects is\n     Aspect_Default_Component_Value      => Aspect_Default_Component_Value,\n     Aspect_Default_Iterator             => Aspect_Default_Iterator,\n     Aspect_Default_Value                => Aspect_Default_Value,\n+    Aspect_Depends                      => Aspect_Depends,\n     Aspect_Dimension                    => Aspect_Dimension,\n     Aspect_Dimension_System             => Aspect_Dimension_System,\n     Aspect_Discard_Names                => Aspect_Discard_Names,"}, {"sha": "25ce022e0c3a7a2129174bfbb4528d5ac05fd841", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2010-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2010-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -88,6 +88,7 @@ package Aspects is\n       Aspect_Default_Component_Value,\n       Aspect_Default_Iterator,\n       Aspect_Default_Value,\n+      Aspect_Depends,                       -- GNAT\n       Aspect_Dimension,                     -- GNAT\n       Aspect_Dimension_System,              -- GNAT\n       Aspect_Dispatching_Domain,\n@@ -229,6 +230,7 @@ package Aspects is\n                              Aspect_Compiler_Unit            => True,\n                              Aspect_Contract_Case            => True,\n                              Aspect_Contract_Cases           => True,\n+                             Aspect_Depends                  => True,\n                              Aspect_Dimension                => True,\n                              Aspect_Dimension_System         => True,\n                              Aspect_Favor_Top_Level          => True,\n@@ -325,6 +327,7 @@ package Aspects is\n                         Aspect_Default_Component_Value => Expression,\n                         Aspect_Default_Iterator        => Name,\n                         Aspect_Default_Value           => Expression,\n+                        Aspect_Depends                 => Expression,\n                         Aspect_Dimension               => Expression,\n                         Aspect_Dimension_System        => Expression,\n                         Aspect_Dispatching_Domain      => Expression,\n@@ -399,6 +402,7 @@ package Aspects is\n      Aspect_Default_Iterator             => Name_Default_Iterator,\n      Aspect_Default_Value                => Name_Default_Value,\n      Aspect_Default_Component_Value      => Name_Default_Component_Value,\n+     Aspect_Depends                      => Name_Depends,\n      Aspect_Dimension                    => Name_Dimension,\n      Aspect_Dimension_System             => Name_Dimension_System,\n      Aspect_Discard_Names                => Name_Discard_Names,"}, {"sha": "6170585272ea923cb14f1b62a8a4709ca2f9b07e", "filename": "gcc/ada/elists.adb", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Felists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Felists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.adb?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -158,6 +158,28 @@ package body Elists is\n       end loop;\n    end Append_Unique_Elmt;\n \n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains (List : Elist_Id; N : Node_Or_Entity_Id) return Boolean is\n+      Elmt : Elmt_Id;\n+\n+   begin\n+      if Present (List) then\n+         Elmt := First_Elmt (List);\n+         while Present (Elmt) loop\n+            if Node (Elmt) = N then\n+               return True;\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Contains;\n+\n    --------------------\n    -- Elists_Address --\n    --------------------"}, {"sha": "8f66e0553bfed6aa5d16d847087df4b6ae78d768", "filename": "gcc/ada/elists.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Felists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Felists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.ads?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -153,6 +153,10 @@ package Elists is\n    --  affected, but the space used by the list element may be (but is not\n    --  required to be) freed for reuse in a subsequent Append_Elmt call.\n \n+   function Contains (List : Elist_Id; N : Node_Or_Entity_Id) return Boolean;\n+   --  Perform a sequential search to determine whether the given list contains\n+   --  a node or an entity.\n+\n    function No (List : Elist_Id) return Boolean;\n    pragma Inline (No);\n    --  Tests given Id for equality with No_Elist. This allows notations like"}, {"sha": "d868f2fa724b794c992ca5997c25479c5a75075b", "filename": "gcc/ada/hostparm.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fhostparm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fhostparm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fhostparm.ads?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,13 +54,14 @@ package Hostparm is\n    Normalized_CWD : constant String := \".\" & Direct_Separator;\n    --  Normalized string to access current directory\n \n-   Max_Line_Length : constant := Types.Column_Number'Pred\n-                       (Types.Column_Number'Last);\n+   Max_Line_Length : constant :=\n+     Types.Column_Number'Pred (Types.Column_Number'Last);\n    --  Maximum source line length. By default we set it to the maximum\n    --  value that can be supported, which is given by the range of the\n    --  Column_Number type. We subtract 1 because need to be able to\n    --  have a valid Column_Number equal to Max_Line_Length to represent\n    --  the location of a \"line too long\" error.\n+   --\n    --  200 is the minimum value required (RM 2.2(15)). The value set here\n    --  can be reduced by the explicit use of the -gnatyM style switch.\n "}, {"sha": "cda47de815244169f05d609ec38122313802c6b4", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -1140,6 +1140,7 @@ begin\n            Pragma_Controlled                     |\n            Pragma_Convention                     |\n            Pragma_Debug_Policy                   |\n+           Pragma_Depends                        |\n            Pragma_Detect_Blocking                |\n            Pragma_Default_Storage_Pool           |\n            Pragma_Disable_Atomic_Synchronization |"}, {"sha": "41a7a2c3c055c946a3b878a4c2d4664d9f792f83", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -1475,6 +1475,17 @@ package body Sem_Ch13 is\n \n                   Delay_Required := False;\n \n+               when Aspect_Depends =>\n+                  Aitem :=\n+                    Make_Pragma (Loc,\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Sloc (Id), Name_Depends),\n+                      Pragma_Argument_Associations => New_List (\n+                        Make_Pragma_Argument_Association (Loc,\n+                          Expression => Relocate_Node (Expr))));\n+\n+                  Delay_Required := False;\n+\n                --  Aspect Global must be delayed because it can mention names\n                --  and benefit from the forward visibility rules applicable to\n                --  aspects of subprograms.\n@@ -7265,6 +7276,7 @@ package body Sem_Ch13 is\n          when Aspect_Abstract_State       |\n               Aspect_Contract_Case        |\n               Aspect_Contract_Cases       |\n+              Aspect_Depends              |\n               Aspect_Dimension            |\n               Aspect_Dimension_System     |\n               Aspect_Implicit_Dereference |"}, {"sha": "806199c9c250cc9038a180c5710323e45210d46c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 708, "deletions": 36, "changes": 744, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -6732,7 +6732,7 @@ package body Sem_Prag is\n \n          --  PROPERTY_LIST              ::= PROPERTY {, PROPERTY}\n          --  PROPERTY                   ::= SIMPLE_PROPERTY\n-         --                                 | NAME_VALUE_PROPERTY\n+         --                               | NAME_VALUE_PROPERTY\n          --  SIMPLE_PROPERTY            ::= IDENTIFIER\n          --  NAME_VALUE_PROPERTY        ::= IDENTIFIER => EXPRESSION\n          --  STATE_NAME                 ::= DEFINING_IDENTIFIER\n@@ -8872,6 +8872,706 @@ package body Sem_Prag is\n             Debug_Pragmas_Disabled :=\n               Chars (Get_Pragma_Arg (Arg1)) = Name_Disable;\n \n+         -------------\n+         -- Depends --\n+         -------------\n+\n+         --  pragma Depends (DEPENDENCY_RELATION);\n+\n+         --  DEPENDENCY_RELATION ::= null\n+         --                        | DEPENDENCY_CLAUSE {, DEPENDENCY_CLAUSE}\n+         --  DEPENDENCY_CLAUSE   ::= OUTPUT_LIST =>[+] INPUT_LIST\n+         --  OUTPUT_LIST         ::= null\n+         --                        | OUTPUT\n+         --                        | (OUTPUT {, OUTPUT})\n+         --  INPUT_LIST          ::= null\n+         --                        | INPUT\n+         --                        | (INPUT {, INPUT})\n+         --  OUTPUT              ::= NAME | FUNCTION_RESULT\n+         --  INPUT               ::= NAME\n+\n+         --  where FUNCTION_RESULT is a function Result attribute_reference\n+\n+         when Pragma_Depends => Depends : declare\n+            Subp_Decl : Node_Id;\n+            Subp_Id   : Entity_Id;\n+\n+            All_Inputs_Seen : Elist_Id := No_Elist;\n+            --  A list containing the entities of all the inputs processed so\n+            --  far. This Elist is populated with unique entities because the\n+            --  same input may appear in multiple input lists.\n+\n+            Outputs_Seen : Elist_Id := No_Elist;\n+            --  A list containing the entities of all the outputs processed so\n+            --  far. The elements of this list may come from different output\n+            --  lists.\n+\n+            Null_Output_Seen : Boolean := False;\n+            --  A flag used to track the legality of a null output\n+\n+            procedure Analyze_Dependency_Clause\n+              (Clause  : Node_Id;\n+               Is_Last : Boolean);\n+            --  Verify the legality of a single dependency clause. Flag Is_Last\n+            --  denotes whether Clause is the last clause in the relation.\n+\n+            function Entity_Of (N : Node_Id) return Entity_Id;\n+            --  Return the entity of N or Empty. If N is a renaming, find the\n+            --  entity of the root renamed object.\n+\n+            procedure Normalize_Clause (Clause : Node_Id);\n+            --  Remove a self-dependency \"+\" from the input list of a clause.\n+            --  Depending on the contents of the relation, either split the\n+            --  the clause into multiple smaller clauses or perform the\n+            --  normalization in place.\n+\n+            -------------------------------\n+            -- Analyze_Dependency_Clause --\n+            -------------------------------\n+\n+            procedure Analyze_Dependency_Clause\n+              (Clause  : Node_Id;\n+               Is_Last : Boolean)\n+            is\n+               procedure Analyze_Input_List (Inputs : Node_Id);\n+               --  Verify the legality of a single input list\n+\n+               procedure Analyze_Input_Output\n+                 (Item      : Node_Id;\n+                  Is_Input  : Boolean;\n+                  Top_Level : Boolean;\n+                  Seen      : in out Elist_Id;\n+                  Null_Seen : in out Boolean);\n+               --  Verify the legality of a single input or output item. Flag\n+               --  Is_Input should be set whenever Item is an input, False when\n+               --  it denotes an output. Flag Top_Level should be set whenever\n+               --  Item appears immediately within an input or output list.\n+               --  Seen is a collection of all abstract states, variables and\n+               --  formals processed so far. Flag Null_Seen denotes whether a\n+               --  null input or output has been encountered.\n+\n+               ------------------------\n+               -- Analyze_Input_List --\n+               ------------------------\n+\n+               procedure Analyze_Input_List (Inputs : Node_Id) is\n+                  Inputs_Seen : Elist_Id := No_Elist;\n+                  --  A list containing the entities of all inputs that appear\n+                  --  in the current input list.\n+\n+                  Null_Input_Seen : Boolean := False;\n+                  --  A flag used to track the legality of a null input\n+\n+                  Input : Node_Id;\n+\n+               begin\n+                  --  Multiple inputs appear as an aggregate\n+\n+                  if Nkind (Inputs) = N_Aggregate then\n+                     if Present (Component_Associations (Inputs)) then\n+                        Error_Msg_N\n+                          (\"nested dependency relations not allowed\", Inputs);\n+\n+                     elsif Present (Expressions (Inputs)) then\n+                        Input := First (Expressions (Inputs));\n+                        while Present (Input) loop\n+                           Analyze_Input_Output\n+                             (Item      => Input,\n+                              Is_Input  => True,\n+                              Top_Level => False,\n+                              Seen      => Inputs_Seen,\n+                              Null_Seen => Null_Input_Seen);\n+\n+                           Next (Input);\n+                        end loop;\n+\n+                     else\n+                        Error_Msg_N\n+                          (\"malformed input dependency list\", Inputs);\n+                     end if;\n+\n+                  --  Process a solitary input\n+\n+                  else\n+                     Analyze_Input_Output\n+                       (Item      => Inputs,\n+                        Is_Input  => True,\n+                        Top_Level => False,\n+                        Seen      => Inputs_Seen,\n+                        Null_Seen => Null_Input_Seen);\n+                  end if;\n+               end Analyze_Input_List;\n+\n+               --------------------------\n+               -- Analyze_Input_Output --\n+               --------------------------\n+\n+               procedure Analyze_Input_Output\n+                 (Item      : Node_Id;\n+                  Is_Input  : Boolean;\n+                  Top_Level : Boolean;\n+                  Seen      : in out Elist_Id;\n+                  Null_Seen : in out Boolean)\n+               is\n+                  Is_Output : constant Boolean := not Is_Input;\n+                  Item_Id   : Entity_Id;\n+                  Grouped   : Node_Id;\n+\n+               begin\n+                  --  Multiple input or output items appear as an aggregate\n+\n+                  if Nkind (Item) = N_Aggregate then\n+                     if not Top_Level then\n+                        Error_Msg_N\n+                          (\"nested grouping of items not allowed\", Item);\n+\n+                     elsif Present (Component_Associations (Item)) then\n+                        Error_Msg_N\n+                          (\"nested dependency relations not allowed\", Item);\n+\n+                     --  Recursively analyze the grouped items\n+\n+                     elsif Present (Expressions (Item)) then\n+                        Grouped := First (Expressions (Item));\n+                        while Present (Grouped) loop\n+                           Analyze_Input_Output\n+                             (Item      => Grouped,\n+                              Is_Input  => Is_Input,\n+                              Top_Level => False,\n+                              Seen      => Seen,\n+                              Null_Seen => Null_Seen);\n+\n+                           Next (Grouped);\n+                        end loop;\n+\n+                     else\n+                        Error_Msg_N (\"malformed dependency list\", Item);\n+                     end if;\n+\n+                  --  Process Function'Result in the context of a dependency\n+                  --  clause.\n+\n+                  elsif Nkind (Item) = N_Attribute_Reference\n+                    and then Attribute_Name (Item) = Name_Result\n+                  then\n+                     --  It is sufficent to analyze the prefix of 'Result in\n+                     --  order to establish legality of the attribute.\n+\n+                     Analyze (Prefix (Item));\n+\n+                     --  The prefix of 'Result must denote the function for\n+                     --  which aspect/pragma Depends applies.\n+\n+                     if not Is_Entity_Name (Prefix (Item))\n+                       or else Ekind (Subp_Id) /= E_Function\n+                       or else Entity (Prefix (Item)) /= Subp_Id\n+                     then\n+                        Error_Msg_Name_1 := Name_Result;\n+                        Error_Msg_N\n+                          (\"prefix of attribute % must denote the enclosing \" &\n+                           \"function\", Item);\n+\n+                     --  Function'Result is allowed to appear on the output\n+                     --  side of a dependency clause.\n+\n+                     elsif Is_Input then\n+                        Error_Msg_N\n+                          (\"function result cannot act as input\", Item);\n+                     end if;\n+\n+                  --  Detect multiple uses of null in a single dependency list\n+                  --  or throughout the whole relation. Verify the placement of\n+                  --  a null output list relative to the other clauses.\n+\n+                  elsif Nkind (Item) = N_Null then\n+                     if Null_Seen then\n+                        Error_Msg_N\n+                          (\"multiple null dependency relations not allowed\",\n+                           Item);\n+                     else\n+                        Null_Seen := True;\n+\n+                        if Is_Output and then not Is_Last then\n+                           Error_Msg_N\n+                             (\"null output list must be the last clause in \" &\n+                              \"a dependency relation\", Item);\n+                        end if;\n+                     end if;\n+\n+                  --  Default case\n+\n+                  else\n+                     Analyze (Item);\n+\n+                     if Is_Entity_Name (Item) then\n+                        Item_Id := Entity_Of (Item);\n+\n+                        if Present (Item_Id)\n+                          and then Ekind_In (Item_Id, E_Abstract_State,\n+                                                      E_In_Parameter,\n+                                                      E_In_Out_Parameter,\n+                                                      E_Out_Parameter,\n+                                                      E_Variable)\n+                        then\n+                           --  Detect multiple uses of the same state, variable\n+                           --  or formal parameter. If this is not the case,\n+                           --  add the item to the list of processed relations.\n+\n+                           if Contains (Seen, Item_Id) then\n+                              Error_Msg_N (\"duplicate use of item\", Item);\n+                           else\n+                              if No (Seen) then\n+                                 Seen := New_Elmt_List;\n+                              end if;\n+\n+                              Append_Elmt (Item_Id, Seen);\n+                           end if;\n+\n+                           --  Detect an illegal use of an input related to a\n+                           --  null output. Such input items cannot appear in\n+                           --  other input lists.\n+\n+                           if Null_Output_Seen\n+                             and then Contains (All_Inputs_Seen, Item_Id)\n+                           then\n+                              Error_Msg_N\n+                                (\"input of a null output list appears in \" &\n+                                 \"multiple input lists\", Item);\n+                           else\n+                              if No (All_Inputs_Seen) then\n+                                 All_Inputs_Seen := New_Elmt_List;\n+                              end if;\n+\n+                              Append_Unique_Elmt (Item_Id, All_Inputs_Seen);\n+                           end if;\n+\n+                        --  All other input/output items are illegal\n+\n+                        else\n+                           Error_Msg_N\n+                             (\"item must denote variable, state or formal \" &\n+                              \"parameter\", Item);\n+                        end if;\n+\n+                     --  All other input/output items are illegal\n+\n+                     else\n+                        Error_Msg_N\n+                          (\"item must denote variable, state or formal \" &\n+                           \"parameter\", Item);\n+                     end if;\n+                  end if;\n+               end Analyze_Input_Output;\n+\n+               --  Local variables\n+\n+               Inputs : Node_Id;\n+               Output : Node_Id;\n+\n+            --  Start of processing for Analyze_Dependency_Clause\n+\n+            begin\n+               --  Process the output_list of a dependency_clause\n+\n+               Output := First (Choices (Clause));\n+               while Present (Output) loop\n+                  Analyze_Input_Output\n+                    (Item      => Output,\n+                     Is_Input  => False,\n+                     Top_Level => True,\n+                     Seen      => Outputs_Seen,\n+                     Null_Seen => Null_Output_Seen);\n+\n+                  Next (Output);\n+               end loop;\n+\n+               --  Process the input_list of a dependency_clause\n+\n+               Inputs := Expression (Clause);\n+\n+               --  An input list with a self-dependency appears as operator \"+\"\n+               --  where the actuals inputs are the right operand.\n+\n+               if Nkind (Inputs) = N_Op_Plus then\n+                  Inputs := Right_Opnd (Inputs);\n+               end if;\n+\n+               Analyze_Input_List (Inputs);\n+            end Analyze_Dependency_Clause;\n+\n+            ---------------\n+            -- Entity_Of --\n+            ---------------\n+\n+            function Entity_Of (N : Node_Id) return Entity_Id is\n+               Id : Entity_Id := Entity (N);\n+\n+            begin\n+               --  Follow a possible chain of renamings to reach the root\n+               --  renamed object.\n+\n+               while Present (Renamed_Object (Id)) loop\n+                  if Is_Entity_Name (Renamed_Object (Id)) then\n+                     Id := Entity (Renamed_Object (Id));\n+\n+                  --  The root of the renaming is not an entire object or\n+                  --  variable, return Empty.\n+\n+                  else\n+                     Id := Empty;\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               return Id;\n+            end Entity_Of;\n+\n+            ----------------------\n+            -- Normalize_Clause --\n+            ----------------------\n+\n+            procedure Normalize_Clause (Clause : Node_Id) is\n+               procedure Create_Or_Modify_Clause\n+                 (Output   : Node_Id;\n+                  Outputs  : Node_Id;\n+                  Inputs   : Node_Id;\n+                  After    : Node_Id;\n+                  In_Place : Boolean;\n+                  Multiple : Boolean);\n+               --  Create a brand new clause to represent the self-reference\n+               --  or modify the input and/or output lists of an existing\n+               --  clause. Output denotes a self-referencial output. Outputs\n+               --  is the output list of a clause. Inputs is the input list\n+               --  of a clause. After denotes the clause after which the new\n+               --  clause is to be inserted. Flag In_Place should be set when\n+               --  normalizing the last output of an output list. Flag Multiple\n+               --  should be set when Output comes from a list with multiple\n+               --  items.\n+\n+               -----------------------------\n+               -- Create_Or_Modify_Clause --\n+               -----------------------------\n+\n+               procedure Create_Or_Modify_Clause\n+                 (Output   : Node_Id;\n+                  Outputs  : Node_Id;\n+                  Inputs   : Node_Id;\n+                  After    : Node_Id;\n+                  In_Place : Boolean;\n+                  Multiple : Boolean)\n+               is\n+                  procedure Propagate_Output\n+                    (Output : Node_Id;\n+                     Inputs : Node_Id);\n+                  --  Handle the various cases of output propagation to the\n+                  --  input list. Output denotes a self-referencial output\n+                  --  item. Inputs is the input list of a clause.\n+\n+                  ----------------------\n+                  -- Propagate_Output --\n+                  ----------------------\n+\n+                  procedure Propagate_Output\n+                    (Output : Node_Id;\n+                     Inputs : Node_Id)\n+                  is\n+                     function Contains\n+                       (List : List_Id;\n+                        Id   : Entity_Id) return Boolean;\n+                     --  Determine whether List contains element Id\n+\n+                     --------------\n+                     -- Contains --\n+                     --------------\n+\n+                     function Contains\n+                       (List : List_Id;\n+                        Id   : Entity_Id) return Boolean\n+                     is\n+                        Elmt : Node_Id;\n+\n+                     begin\n+                        Elmt := First (List);\n+                        while Present (Elmt) loop\n+                           if Entity_Of (Elmt) = Id then\n+                              return True;\n+                           end if;\n+\n+                           Next (Elmt);\n+                        end loop;\n+\n+                        return False;\n+                     end Contains;\n+\n+                     --  Local variables\n+\n+                     Grouped : List_Id;\n+\n+                  --  Start of processing for Propagate_Output\n+\n+                  begin\n+                     --  The clause is of the form:\n+\n+                     --    (Output =>+ null)\n+\n+                     --  Remove the null input and replace it with a copy of\n+                     --  the output:\n+\n+                     --    (Output => Output)\n+\n+                     if Nkind (Inputs) = N_Null then\n+                        Rewrite (Inputs, New_Copy_Tree (Output));\n+\n+                     --  The clause is of the form:\n+\n+                     --    (Output =>+ (Input1, ..., InputN))\n+\n+                     --  Determine whether the output is not already mentioned\n+                     --  in the input list and if not, add it to the list of\n+                     --  inputs:\n+\n+                     --    (Output => (Output, Input1, ..., InputN))\n+\n+                     elsif Nkind (Inputs) = N_Aggregate then\n+                        Grouped := Expressions (Inputs);\n+\n+                        if not Contains (Grouped, Entity_Of (Output)) then\n+                           Prepend_To (Grouped, New_Copy_Tree (Output));\n+                        end if;\n+\n+                     --  The clause is of the form:\n+\n+                     --    (Output =>+ Input)\n+\n+                     --  If the input does not mention the output, group the\n+                     --  two together:\n+\n+                     --    (Output => (Output, Input))\n+\n+                     elsif Entity_Of (Output) /= Entity_Of (Inputs) then\n+                        Rewrite (Inputs,\n+                          Make_Aggregate (Loc,\n+                            Expressions => New_List (\n+                              New_Copy_Tree (Output),\n+                              New_Copy_Tree (Inputs))));\n+                     end if;\n+                  end Propagate_Output;\n+\n+                  --  Local variables\n+\n+                  Loc    : constant Source_Ptr := Sloc (Output);\n+                  Clause : Node_Id;\n+\n+               --  Start of processing for Create_Or_Modify_Clause\n+\n+               begin\n+                  --  A function result cannot depend on itself because it\n+                  --  cannot appear in the input list of a relation.\n+\n+                  if Nkind (Output) = N_Attribute_Reference\n+                    and then Attribute_Name (Output) = Name_Result\n+                  then\n+                     Error_Msg_N\n+                       (\"function result cannot depend on itself\", Output);\n+                     return;\n+\n+                  --  A null output depending on itself does not require any\n+                  --  normalization.\n+\n+                  elsif Nkind (Output) = N_Null then\n+                     return;\n+                  end if;\n+\n+                  --  When performing the transformation in place, simply add\n+                  --  the output to the list of inputs (if not already there).\n+                  --  This case arises when dealing with the last output of an\n+                  --  output list - we perform the normalization in place to\n+                  --  avoid generating a malformed tree.\n+\n+                  if In_Place then\n+                     Propagate_Output (Output, Inputs);\n+\n+                     --  A list with multiple outputs is slowly trimmed until\n+                     --  only one element remains. When this happens, replace\n+                     --  the aggregate with the element itself.\n+\n+                     if Multiple then\n+                        Remove  (Output);\n+                        Rewrite (Outputs, Output);\n+                     end if;\n+\n+                  --  Default case\n+\n+                  else\n+                     --  Unchain the output from its output list as it will\n+                     --  appear in a new clause. Note that we cannot simply\n+                     --  rewrite the output as null because this will violate\n+                     --  the semantics of aspect/pragma Depends.\n+\n+                     Remove (Output);\n+\n+                     --  Create a new clause of the form:\n+\n+                     --    (Output => Inputs)\n+\n+                     Clause :=\n+                       Make_Component_Association (Loc,\n+                         Choices    => New_List (Output),\n+                         Expression => New_Copy_Tree (Inputs));\n+\n+                     --  The new clause contains replicated content that has\n+                     --  already been analyzed. There is not need to reanalyze\n+                     --  it or renormalize it again.\n+\n+                     Set_Analyzed (Clause);\n+\n+                     Propagate_Output\n+                       (Output => First (Choices (Clause)),\n+                        Inputs => Expression (Clause));\n+\n+                     Insert_After (After, Clause);\n+                  end if;\n+               end Create_Or_Modify_Clause;\n+\n+               --  Local variables\n+\n+               Outputs     : constant Node_Id := First (Choices (Clause));\n+               Inputs      : Node_Id;\n+               Last_Output : Node_Id;\n+               Next_Output : Node_Id;\n+               Output      : Node_Id;\n+\n+            --  Start of processing for Normalize_Clause\n+\n+            begin\n+               --  A self-dependency appears as operator \"+\". Remove the \"+\"\n+               --  from the tree by moving the real inputs to their proper\n+               --  place.\n+\n+               if Nkind (Expression (Clause)) = N_Op_Plus then\n+                  Rewrite\n+                    (Expression (Clause), Right_Opnd (Expression (Clause)));\n+                  Inputs := Expression (Clause);\n+\n+                  --  Multiple outputs appear as an aggregate\n+\n+                  if Nkind (Outputs) = N_Aggregate then\n+                     Last_Output := Last (Expressions (Outputs));\n+\n+                     Output := First (Expressions (Outputs));\n+                     while Present (Output) loop\n+\n+                        --  Normalization may remove an output from its list,\n+                        --  preserve the subsequent output now.\n+\n+                        Next_Output := Next (Output);\n+\n+                        Create_Or_Modify_Clause\n+                          (Output   => Output,\n+                           Outputs  => Outputs,\n+                           Inputs   => Inputs,\n+                           After    => Clause,\n+                           In_Place => Output = Last_Output,\n+                           Multiple => True);\n+\n+                        Output := Next_Output;\n+                     end loop;\n+\n+                  --  Solitary output\n+\n+                  else\n+                     Create_Or_Modify_Clause\n+                       (Output   => Outputs,\n+                        Outputs  => Empty,\n+                        Inputs   => Inputs,\n+                        After    => Empty,\n+                        In_Place => True,\n+                        Multiple => False);\n+                  end if;\n+               end if;\n+            end Normalize_Clause;\n+\n+            --  Local variables\n+\n+            Clause      : Node_Id;\n+            Errors      : Nat;\n+            Last_Clause : Node_Id;\n+\n+         --  Start of processing for Depends\n+\n+         begin\n+            GNAT_Pragma;\n+            S14_Pragma;\n+            Check_Arg_Count (1);\n+\n+            --  Ensure the proper placement of the pragma. Depends must be\n+            --  associated with a subprogram declaration.\n+\n+            Subp_Decl := Parent (Corresponding_Aspect (N));\n+\n+            if Nkind (Subp_Decl) /= N_Subprogram_Declaration then\n+               Pragma_Misplaced;\n+               return;\n+            end if;\n+\n+            Subp_Id := Defining_Unit_Name (Specification (Subp_Decl));\n+            Clause  := Expression (Arg1);\n+\n+            --  There is nothing to be done for a null dependency relation\n+\n+            if Nkind (Clause) = N_Null then\n+               null;\n+\n+            --  Dependency clauses appear as component associations of an\n+            --  aggregate.\n+\n+            elsif Nkind (Clause) = N_Aggregate\n+              and then Present (Component_Associations (Clause))\n+            then\n+               Last_Clause := Last (Component_Associations (Clause));\n+\n+               --  Ensure that the formal parameters are visible when analyzing\n+               --  all clauses. This falls out of the general rule of aspects\n+               --  pertaining to subprogram declarations.\n+\n+               Push_Scope (Subp_Id);\n+               Install_Formals (Subp_Id);\n+\n+               Clause := First (Component_Associations (Clause));\n+               while Present (Clause) loop\n+                  Errors := Serious_Errors_Detected;\n+\n+                  --  Normalization may create extra clauses that contain\n+                  --  replicated input and output names. There is no need\n+                  --  to reanalyze or renormalize these extra clauses.\n+\n+                  if not Analyzed (Clause) then\n+                     Set_Analyzed (Clause);\n+\n+                     Analyze_Dependency_Clause\n+                       (Clause  => Clause,\n+                        Is_Last => Clause = Last_Clause);\n+\n+                     --  Do not normalize an erroneous clause because the\n+                     --  inputs or outputs may denote illegal items.\n+\n+                     if Errors = Serious_Errors_Detected then\n+                        Normalize_Clause (Clause);\n+                     end if;\n+                  end if;\n+\n+                  Next (Clause);\n+               end loop;\n+\n+               End_Scope;\n+\n+            --  The top level dependency relation is malformed\n+\n+            else\n+               Error_Msg_N (\"malformed dependency relation\", Clause);\n+            end if;\n+         end Depends;\n+\n          ---------------------\n          -- Detect_Blocking --\n          ---------------------\n@@ -10064,13 +10764,13 @@ package body Sem_Prag is\n \n          --  pragma Global (GLOBAL_SPECIFICATION)\n \n-         --  GLOBAL_SPECIFICATION ::= MODED_GLOBAL_LIST {, MODED_GLOBAL_LIST}\n-         --                           | GLOBAL_LIST\n-         --                           | null\n+         --  GLOBAL_SPECIFICATION ::= null\n+         --                         | GLOBAL_LIST\n+         --                         | MODED_GLOBAL_LIST {, MODED_GLOBAL_LIST}\n          --  MODED_GLOBAL_LIST    ::= MODE_SELECTOR => GLOBAL_LIST\n          --  MODE_SELECTOR        ::= Input | Output | In_Out | Contract_In\n          --  GLOBAL_LIST          ::= GLOBAL_ITEM\n-         --                           | (GLOBAL_ITEM {, GLOBAL_ITEM})\n+         --                         | (GLOBAL_ITEM {, GLOBAL_ITEM})\n          --  GLOBAL_ITEM          ::= NAME\n \n          when Pragma_Global => Global : declare\n@@ -10127,37 +10827,8 @@ package body Sem_Prag is\n                  (Item        : Node_Id;\n                   Global_Mode : Name_Id)\n                is\n-                  function Is_Duplicate_Item (Id : Entity_Id) return Boolean;\n-                  --  Determine whether Id has already been processed\n-\n-                  -----------------------\n-                  -- Is_Duplicate_Item --\n-                  -----------------------\n-\n-                  function Is_Duplicate_Item (Id : Entity_Id) return Boolean is\n-                     Item_Elmt : Elmt_Id;\n-\n-                  begin\n-                     if Present (Seen) then\n-                        Item_Elmt := First_Elmt (Seen);\n-                        while Present (Item_Elmt) loop\n-                           if Node (Item_Elmt) = Id then\n-                              return True;\n-                           end if;\n-\n-                           Next_Elmt (Item_Elmt);\n-                        end loop;\n-                     end if;\n-\n-                     return False;\n-                  end Is_Duplicate_Item;\n-\n-                  --  Local declarations\n-\n                   Id : Entity_Id;\n \n-               --  Start of processing for Analyze_Global_Item\n-\n                begin\n                   --  Detect one of the following cases\n \n@@ -10207,7 +10878,7 @@ package body Sem_Prag is\n                   --  The same entity might be referenced through various way.\n                   --  Check the entity of the item rather than the item itself.\n \n-                  if Is_Duplicate_Item (Id) then\n+                  if Contains (Seen, Id) then\n                      Error_Msg_N (\"duplicate global item\", Item);\n \n                   --  Add the entity of the current item to the list of\n@@ -10421,7 +11092,7 @@ package body Sem_Prag is\n \n                Analyze_Global_List (List);\n \n-               Pop_Scope;\n+               End_Scope;\n             end if;\n          end Global;\n \n@@ -16624,6 +17295,7 @@ package body Sem_Prag is\n       Pragma_Debug_Policy                   =>  0,\n       Pragma_Detect_Blocking                => -1,\n       Pragma_Default_Storage_Pool           => -1,\n+      Pragma_Depends                        => -1,\n       Pragma_Disable_Atomic_Synchronization => -1,\n       Pragma_Discard_Names                  =>  0,\n       Pragma_Dispatching_Domain             => -1,"}, {"sha": "77e2caa5a2d976bfa6dcfb65750d50e33f442301", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe96ecb94ac3a81499d804d428d275284e676027/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=fe96ecb94ac3a81499d804d428d275284e676027", "patch": "@@ -485,6 +485,7 @@ package Snames is\n    --  pragma.\n \n    Name_Debug                          : constant Name_Id := N + $; -- GNAT\n+   Name_Depends                        : constant Name_Id := N + $; -- GNAT\n    Name_Elaborate                      : constant Name_Id := N + $; -- Ada 83\n    Name_Elaborate_All                  : constant Name_Id := N + $;\n    Name_Elaborate_Body                 : constant Name_Id := N + $;\n@@ -1774,6 +1775,7 @@ package Snames is\n       Pragma_CPP_Virtual,\n       Pragma_CPP_Vtable,\n       Pragma_Debug,\n+      Pragma_Depends,\n       Pragma_Elaborate,\n       Pragma_Elaborate_All,\n       Pragma_Elaborate_Body,"}]}