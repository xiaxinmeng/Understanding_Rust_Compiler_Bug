{"sha": "58c8f7700a237538681b287d03625ca85a71e651", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThjOGY3NzAwYTIzNzUzODY4MWIyODdkMDM2MjVjYTg1YTcxZTY1MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-15T21:15:47Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-15T21:15:47Z"}, "message": "cuintp.c (UI_To_gnu): Fix long line.\n\n\t* gcc-interface/cuintp.c (UI_To_gnu): Fix long line.\n\t* gcc-interface/gigi.h (MARK_VISITED): Skip objects of constant class.\n\t(process_attributes): Delete.\n\t(post_error_ne_num): Change parameter name.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Do not force debug info\n\twith -g3.  Remove a couple of obsolete lines.  Minor tweaks.\n\tIf type annotating mode, operate on trees to compute the adjustment to\n\tthe sizes of tagged types.  Fix long line.\n\t(cannot_be_superflat_p): Tweak head comment.\n\t(annotate_value): Fold local constant.\n\t(set_rm_size): Fix long line.\n\t* gcc-interface/trans.c (Identifier_to_gnu): Rework comments.\n\t(Attribute_to_gnu): Fix long line.\n\t<Attr_Size>: Remove useless assertion.\n\tReorder statements.  Use size_binop routine.\n\t(Loop_Statement_to_gnu): Use build5 in lieu of build_nt.\n\tCreate local variables for the label and the test.  Tweak comments.\n\t(Subprogram_Body_to_gnu): Reset cfun to NULL.\n\t(Compilation_Unit_to_gnu): Use the Sloc of the Unit node.\n\t(process_inlined_subprograms): Integrate into...\n\t(Compilation_Unit_to_gnu): ...this.\n\t(gnat_to_gnu): Fix long line.\n\t(post_error_ne_num): Change parameter name.\n\t* gcc-interface/utils.c (process_attributes): Static-ify.\n\t<ATTR_MACHINE_ATTRIBUTE>: Set input_location before proceeding.\n\t(create_type_decl): Add comment.\n\t(create_var_decl_1): Process the attributes after adding the VAR_DECL\n\tto the current binding level.\n\t(create_subprog_decl): Likewise for the FUNCTION_DECL.\n\t(end_subprog_body): Do not reset cfun to NULL.\n\t(build_vms_descriptor32): Fix long line.\n\t(build_vms_descriptor): Likewise.\n\t(handle_nonnull_attribute): Likewise.\n\t(convert_vms_descriptor64): Likewise.\n\t* gcc-interface/utils2.c (fill_vms_descriptor): Fix long line.\n\t(gnat_protect_expr): Fix thinko.\n\nFrom-SVN: r158390", "tree": {"sha": "1b4bd01f3488b586b49c260c1be8487436d8f1ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b4bd01f3488b586b49c260c1be8487436d8f1ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58c8f7700a237538681b287d03625ca85a71e651", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c8f7700a237538681b287d03625ca85a71e651", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c8f7700a237538681b287d03625ca85a71e651", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c8f7700a237538681b287d03625ca85a71e651/comments", "author": null, "committer": null, "parents": [{"sha": "1fc24649bc296400468fdd26eb93f144fdafdfbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc24649bc296400468fdd26eb93f144fdafdfbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fc24649bc296400468fdd26eb93f144fdafdfbf"}], "stats": {"total": 527, "additions": 279, "deletions": 248}, "files": [{"sha": "38a5ae5dee97acee396c2c8328f2df63e4699586", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=58c8f7700a237538681b287d03625ca85a71e651", "patch": "@@ -1,3 +1,42 @@\n+2010-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/cuintp.c (UI_To_gnu): Fix long line.\n+\t* gcc-interface/gigi.h (MARK_VISITED): Skip objects of constant class.\n+\t(process_attributes): Delete.\n+\t(post_error_ne_num): Change parameter name.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Do not force debug info\n+\twith -g3.  Remove a couple of obsolete lines.  Minor tweaks.\n+\tIf type annotating mode, operate on trees to compute the adjustment to\n+\tthe sizes of tagged types.  Fix long line.\n+\t(cannot_be_superflat_p): Tweak head comment.\n+\t(annotate_value): Fold local constant.\n+\t(set_rm_size): Fix long line.\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Rework comments.\n+\t(Attribute_to_gnu): Fix long line.\n+\t<Attr_Size>: Remove useless assertion.\n+\tReorder statements.  Use size_binop routine.\n+\t(Loop_Statement_to_gnu): Use build5 in lieu of build_nt.\n+\tCreate local variables for the label and the test.  Tweak comments.\n+\t(Subprogram_Body_to_gnu): Reset cfun to NULL.\n+\t(Compilation_Unit_to_gnu): Use the Sloc of the Unit node.\n+\t(process_inlined_subprograms): Integrate into...\n+\t(Compilation_Unit_to_gnu): ...this.\n+\t(gnat_to_gnu): Fix long line.\n+\t(post_error_ne_num): Change parameter name.\n+\t* gcc-interface/utils.c (process_attributes): Static-ify.\n+\t<ATTR_MACHINE_ATTRIBUTE>: Set input_location before proceeding.\n+\t(create_type_decl): Add comment.\n+\t(create_var_decl_1): Process the attributes after adding the VAR_DECL\n+\tto the current binding level.\n+\t(create_subprog_decl): Likewise for the FUNCTION_DECL.\n+\t(end_subprog_body): Do not reset cfun to NULL.\n+\t(build_vms_descriptor32): Fix long line.\n+\t(build_vms_descriptor): Likewise.\n+\t(handle_nonnull_attribute): Likewise.\n+\t(convert_vms_descriptor64): Likewise.\n+\t* gcc-interface/utils2.c (fill_vms_descriptor): Fix long line.\n+\t(gnat_protect_expr): Fix thinko.\n+\n 2010-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (gigi): Set DECL_IGNORED_P on EH functions."}, {"sha": "642a71b21c55028a16a6fd6901589ef89646390c", "filename": "gcc/ada/gcc-interface/cuintp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fcuintp.c?ref=58c8f7700a237538681b287d03625ca85a71e651", "patch": "@@ -106,7 +106,8 @@ UI_To_gnu (Uint Input, tree type)\n \t The base integer precision must be superior than 16.  */\n \n       if (TREE_CODE (comp_type) != REAL_TYPE\n-\t  && TYPE_PRECISION (comp_type) < TYPE_PRECISION (long_integer_type_node))\n+\t  && TYPE_PRECISION (comp_type)\n+\t     < TYPE_PRECISION (long_integer_type_node))\n \t{\n \t  comp_type = long_integer_type_node;\n \t  gcc_assert (TYPE_PRECISION (comp_type) > 16);"}, {"sha": "9ca27fd03ab1b4314782b1b958b8b29a62e17bcf", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=58c8f7700a237538681b287d03625ca85a71e651", "patch": "@@ -207,8 +207,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   /* True if we made GNU_DECL and its type here.  */\n   bool this_made_decl = false;\n   /* True if debug info is requested for this entity.  */\n-  bool debug_info_p = (Needs_Debug_Info (gnat_entity)\n-\t\t       || debug_info_level == DINFO_LEVEL_VERBOSE);\n+  bool debug_info_p = Needs_Debug_Info (gnat_entity);\n   /* True if this entity is to be considered as imported.  */\n   bool imported_p = (Is_Imported (gnat_entity)\n \t\t     && No (Address_Clause (gnat_entity)));\n@@ -983,8 +982,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t   as we have a VAR_DECL for the pointer we make.  */\n \t\t      }\n \n-\t\t    gnu_expr\n-\t\t      = build_unary_op (ADDR_EXPR, gnu_type, maybe_stable_expr);\n+\t\t    gnu_expr = build_unary_op (ADDR_EXPR, gnu_type,\n+\t\t\t\t\t       maybe_stable_expr);\n \n \t\t    gnu_size = NULL_TREE;\n \t\t    used_by_ref = true;\n@@ -1291,10 +1290,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t|| Is_Exported (gnat_entity)))))\n \t  gnu_ext_name = create_concat_name (gnat_entity, NULL);\n \n-\t/* If this is constant initialized to a static constant and the\n-\t   object has an aggregate type, force it to be statically\n-\t   allocated.  This will avoid an initialization copy.  */\n-\tif (!static_p && const_flag\n+\t/* If this is an aggregate constant initialized to a constant, force it\n+\t   to be statically allocated.  This saves an initialization copy.  */\n+\tif (!static_p\n+\t    && const_flag\n \t    && gnu_expr && TREE_CONSTANT (gnu_expr)\n \t    && AGGREGATE_TYPE_P (gnu_type)\n \t    && host_integerp (TYPE_SIZE_UNIT (gnu_type), 1)\n@@ -1303,11 +1302,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t    (TREE_TYPE (TYPE_FIELDS (gnu_type))), 1)))\n \t  static_p = true;\n \n-\tgnu_decl = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n-\t\t\t\t    gnu_expr, const_flag,\n-\t\t\t\t    Is_Public (gnat_entity),\n-\t\t\t\t    imported_p || !definition,\n-\t\t\t\t    static_p, attr_list, gnat_entity);\n+\tgnu_decl\n+\t  = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n+\t\t\t     gnu_expr, const_flag, Is_Public (gnat_entity),\n+\t\t\t     imported_p || !definition, static_p, attr_list,\n+\t\t\t     gnat_entity);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n \tif (TREE_CODE (gnu_decl) == VAR_DECL && renamed_obj)\n@@ -3473,7 +3472,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_type, gnu_old);\n \t\tTYPE_POINTER_TO (gnu_old) = gnu_type;\n \n-\t\tSloc_to_locus (Sloc (gnat_entity), &input_location);\n \t\tfields\n \t\t  = chainon (chainon (NULL_TREE,\n \t\t\t\t      create_field_decl\n@@ -4170,8 +4168,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t  | (TYPE_QUAL_CONST * const_flag)\n \t\t\t\t  | (TYPE_QUAL_VOLATILE * volatile_flag));\n \n-\tSloc_to_locus (Sloc (gnat_entity), &input_location);\n-\n \tif (has_stub)\n \t  gnu_stub_type\n \t    = build_qualified_type (gnu_stub_type,\n@@ -4705,38 +4701,40 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       if (Unknown_Esize (gnat_entity) && TYPE_SIZE (gnu_type))\n \t{\n-\t  /* If the size is self-referential, we annotate the maximum\n-\t     value of that size.  */\n \t  tree gnu_size = TYPE_SIZE (gnu_type);\n \n+\t  /* If the size is self-referential, annotate the maximum value.  */\n \t  if (CONTAINS_PLACEHOLDER_P (gnu_size))\n \t    gnu_size = max_size (gnu_size, true);\n \n-\t  Set_Esize (gnat_entity, annotate_value (gnu_size));\n-\n \t  if (type_annotate_only && Is_Tagged_Type (gnat_entity))\n \t    {\n-\t      /* In this mode the tag and the parent components are not\n-\t\t generated by the front-end, so the sizes must be adjusted\n-\t\t explicitly now.  */\n-\t      int size_offset, new_size;\n+\t      /* In this mode, the tag and the parent components are not\n+\t\t generated by the front-end so the sizes must be adjusted.  */\n+\t      tree pointer_size = bitsize_int (POINTER_SIZE), offset;\n+\t      Uint uint_size;\n \n \t      if (Is_Derived_Type (gnat_entity))\n \t\t{\n-\t\t  size_offset\n-\t\t    = UI_To_Int (Esize (Etype (Base_Type (gnat_entity))));\n+\t\t  offset = UI_To_gnu (Esize (Etype (Base_Type (gnat_entity))),\n+\t\t\t\t      bitsizetype);\n \t\t  Set_Alignment (gnat_entity,\n \t\t\t\t Alignment (Etype (Base_Type (gnat_entity))));\n \t\t}\n \t      else\n-\t\tsize_offset = POINTER_SIZE;\n-\n-\t      new_size = UI_To_Int (Esize (gnat_entity)) + size_offset;\n-\t      Set_Esize (gnat_entity,\n-\t\t\t UI_From_Int (((new_size + (POINTER_SIZE - 1))\n-\t\t\t\t       / POINTER_SIZE) * POINTER_SIZE));\n-\t      Set_RM_Size (gnat_entity, Esize (gnat_entity));\n+\t\toffset = pointer_size;\n+\n+\t      gnu_size = size_binop (PLUS_EXPR, gnu_size, offset);\n+\t      gnu_size = size_binop (MULT_EXPR, pointer_size,\n+\t\t\t\t\t\tsize_binop (CEIL_DIV_EXPR,\n+\t\t\t\t\t\t\t    gnu_size,\n+\t\t\t\t\t\t\t    pointer_size));\n+\t      uint_size = annotate_value (gnu_size);\n+\t      Set_Esize (gnat_entity, uint_size);\n+\t      Set_RM_Size (gnat_entity, uint_size);\n \t    }\n+\t  else\n+\t    Set_Esize (gnat_entity, annotate_value (gnu_size));\n \t}\n \n       if (Unknown_RM_Size (gnat_entity) && rm_size (gnu_type))\n@@ -5366,15 +5364,14 @@ compile_time_known_address_p (Node_Id gnat_address)\n   return Compile_Time_Known_Value (gnat_address);\n }\n \n-/* Return true if GNAT_RANGE, a N_Range node, cannot be superflat, i.e.\n-   cannot verify HB < LB-1 when LB and HB are the low and high bounds.  */\n+/* Return true if GNAT_RANGE, a N_Range node, cannot be superflat, i.e. if the\n+   inequality HB >= LB-1 is true.  LB and HB are the low and high bounds.  */\n \n static bool\n cannot_be_superflat_p (Node_Id gnat_range)\n {\n   Node_Id gnat_lb = Low_Bound (gnat_range), gnat_hb = High_Bound (gnat_range);\n   Node_Id scalar_range;\n-\n   tree gnu_lb, gnu_hb;\n \n   /* If the low bound is not constant, try to find an upper bound.  */\n@@ -7087,12 +7084,10 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n static Uint\n annotate_value (tree gnu_size)\n {\n-  int len = TREE_CODE_LENGTH (TREE_CODE (gnu_size));\n   TCode tcode;\n   Node_Ref_Or_Val ops[3], ret;\n-  int i;\n-  int size;\n   struct tree_int_map **h = NULL;\n+  int size, i;\n \n   /* See if we've already saved the value for this node.  */\n   if (EXPR_P (gnu_size))\n@@ -7223,7 +7218,7 @@ annotate_value (tree gnu_size)\n   for (i = 0; i < 3; i++)\n     ops[i] = No_Uint;\n \n-  for (i = 0; i < len; i++)\n+  for (i = 0; i < TREE_CODE_LENGTH (TREE_CODE (gnu_size)); i++)\n     {\n       ops[i] = annotate_value (TREE_OPERAND (gnu_size, i));\n       if (ops[i] == No_Uint)\n@@ -7675,7 +7670,8 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n \t       && TYPE_PACKED_ARRAY_TYPE_P (gnu_type))\n \t  && !(TYPE_IS_PADDING_P (gnu_type)\n \t       && TREE_CODE (TREE_TYPE (TYPE_FIELDS (gnu_type))) == ARRAY_TYPE\n-\t       && TYPE_PACKED_ARRAY_TYPE_P (TREE_TYPE (TYPE_FIELDS (gnu_type))))\n+\t       && TYPE_PACKED_ARRAY_TYPE_P\n+\t\t  (TREE_TYPE (TYPE_FIELDS (gnu_type))))\n \t  && tree_int_cst_lt (size, old_size)))\n     {\n       if (Present (gnat_attr_node))"}, {"sha": "f0c577799e2dfd8c611ff96f5c239f19185cea05", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=58c8f7700a237538681b287d03625ca85a71e651", "patch": "@@ -85,7 +85,7 @@ extern void mark_visited (tree t);\n \n #define MARK_VISITED(EXP)\t\t\\\n do {\t\t\t\t\t\\\n-  if((EXP) && !TREE_CONSTANT (EXP))\t\\\n+  if((EXP) && !CONSTANT_CLASS_P (EXP))\t\\\n     mark_visited (EXP);\t\t\t\\\n } while (0)\n \n@@ -240,9 +240,9 @@ extern void post_error (const char *msg, Node_Id node);\n extern void post_error_ne (const char *msg, Node_Id node, Entity_Id ent);\n \n /* Similar, but NODE is the node at which to post the error, ENT is the node\n-   to use for the \"&\" substitution, and N is the number to use for the ^.  */\n+   to use for the \"&\" substitution, and NUM is the number to use for ^.  */\n extern void post_error_ne_num (const char *msg, Node_Id node, Entity_Id ent,\n-                               int n);\n+                               int num);\n \n /* Similar to post_error_ne_num, but T is a GCC tree representing the number\n    to write.  If the tree represents a constant that fits within a\n@@ -252,8 +252,8 @@ extern void post_error_ne_num (const char *msg, Node_Id node, Entity_Id ent,\n extern void post_error_ne_tree (const char *msg, Node_Id node, Entity_Id ent,\n                                 tree t);\n \n-/* Similar to post_error_ne_tree, except that NUM is a second\n-   integer to write in the message.  */\n+/* Similar to post_error_ne_tree, except that NUM is a second integer to write\n+   in the message.  */\n extern void post_error_ne_tree_2 (const char *msg, Node_Id node, Entity_Id ent,\n                                   tree t, int num);\n \n@@ -622,9 +622,6 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n \t\t     const_flag, public_flag, extern_flag,\t\t\\\n \t\t     static_flag, false, attr_list, gnat_node)\n \n-/* Given a DECL and ATTR_LIST, apply the listed attributes.  */\n-extern void process_attributes (tree decl, struct attrib *attr_list);\n-\n /* Record DECL as a global renaming pointer.  */\n extern void record_global_renaming_pointer (tree decl);\n "}, {"sha": "e701bc08612b743a6ce952b9aad60c168f8da962", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 106, "deletions": 112, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=58c8f7700a237538681b287d03625ca85a71e651", "patch": "@@ -200,7 +200,6 @@ static void pop_stack (tree *);\n static enum gimplify_status gnat_gimplify_stmt (tree *);\n static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n-static void process_inlined_subprograms (Node_Id);\n static void process_decls (List_Id, List_Id, Node_Id, bool, bool);\n static tree emit_range_check (tree, Node_Id, Node_Id);\n static tree emit_index_check (tree, tree, tree, tree, Node_Id);\n@@ -1034,10 +1033,9 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \tgnu_result_type = TREE_TYPE (TYPE_FIELDS (gnu_result_type));\n     }\n \n-  /* If we have a constant declaration and its initializer at hand,\n-     try to return the latter to avoid the need to call fold in lots\n-     of places and the need of elaboration code if this Id is used as\n-     an initializer itself.  */\n+  /* If we have a constant declaration and its initializer, try to return the\n+     latter to avoid the need to call fold in lots of places and the need for\n+     elaboration code if this identifier is used as an initializer itself.  */\n   if (TREE_CONSTANT (gnu_result)\n       && DECL_P (gnu_result)\n       && DECL_INITIAL (gnu_result))\n@@ -1055,11 +1053,15 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t  = lvalue_required_p (gnat_node, gnu_result_type, true,\n \t\t\t       address_of_constant, Is_Aliased (gnat_temp));\n \n+      /* ??? We need to unshare the initializer if the object is external\n+\t as such objects are not marked for unsharing if we are not at the\n+\t global level.  This should be fixed in add_decl_expr.  */\n       if ((constant_only && !address_of_constant) || !require_lvalue)\n \tgnu_result = unshare_expr (DECL_INITIAL (gnu_result));\n     }\n \n   *gnu_result_type_p = gnu_result_type;\n+\n   return gnu_result;\n }\n \f\n@@ -1357,7 +1359,8 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t    tree gnu_byte_offset\n \t      = convert (sizetype,\n \t\t\t size_diffop (size_zero_node, gnu_pos));\n-\t    gnu_byte_offset = fold_build1 (NEGATE_EXPR, sizetype, gnu_byte_offset);\n+\t    gnu_byte_offset\n+\t      = fold_build1 (NEGATE_EXPR, sizetype, gnu_byte_offset);\n \n \t    gnu_ptr = convert (gnu_char_ptr_type, gnu_ptr);\n \t    gnu_ptr = build_binary_op (POINTER_PLUS_EXPR, gnu_char_ptr_type,\n@@ -1456,17 +1459,14 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       else\n \tgnu_result = rm_size (gnu_type);\n \n-      gcc_assert (gnu_result);\n-\n       /* Deal with a self-referential size by returning the maximum size for\n-\t a type and by qualifying the size with the object for 'Size of an\n-\t object.  */\n+\t a type and by qualifying the size with the object otherwise.  */\n       if (CONTAINS_PLACEHOLDER_P (gnu_result))\n \t{\n-\t  if (TREE_CODE (gnu_prefix) != TYPE_DECL)\n-\t    gnu_result = substitute_placeholder_in_expr (gnu_result, gnu_expr);\n-\t  else\n+\t  if (TREE_CODE (gnu_prefix) == TYPE_DECL)\n \t    gnu_result = max_size (gnu_result, true);\n+\t  else\n+\t    gnu_result = substitute_placeholder_in_expr (gnu_result, gnu_expr);\n \t}\n \n       /* If the type contains a template, subtract its size.  */\n@@ -1475,11 +1475,11 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tgnu_result = size_binop (MINUS_EXPR, gnu_result,\n \t\t\t\t DECL_SIZE (TYPE_FIELDS (gnu_type)));\n \n-      gnu_result_type = get_unpadded_type (Etype (gnat_node));\n-\n+      /* For 'Max_Size_In_Storage_Elements, adjust the unit.  */\n       if (attribute == Attr_Max_Size_In_Storage_Elements)\n-\tgnu_result = fold_build2 (CEIL_DIV_EXPR, bitsizetype,\n-\t\t\t\t  gnu_result, bitsize_unit_node);\n+\tgnu_result = size_binop (CEIL_DIV_EXPR, gnu_result, bitsize_unit_node);\n+\n+      gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       break;\n \n     case Attr_Alignment:\n@@ -2052,25 +2052,22 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n static tree\n Loop_Statement_to_gnu (Node_Id gnat_node)\n {\n-  /* ??? It would be nice to use \"build\" here, but there's no build5.  */\n-  tree gnu_loop_stmt = build_nt (LOOP_STMT, NULL_TREE, NULL_TREE,\n-\t\t\t\t NULL_TREE, NULL_TREE, NULL_TREE);\n-  tree gnu_loop_var = NULL_TREE;\n-  Node_Id gnat_iter_scheme = Iteration_Scheme (gnat_node);\n-  tree gnu_cond_expr = NULL_TREE;\n+  const Node_Id gnat_iter_scheme = Iteration_Scheme (gnat_node);\n+  tree gnu_loop_stmt = build5 (LOOP_STMT, void_type_node, NULL_TREE,\n+\t\t\t       NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE);\n+  tree gnu_loop_label = create_artificial_label (input_location);\n+  tree gnu_loop_var = NULL_TREE, gnu_cond_expr = NULL_TREE;\n   tree gnu_result;\n \n-  TREE_TYPE (gnu_loop_stmt) = void_type_node;\n-  TREE_SIDE_EFFECTS (gnu_loop_stmt) = 1;\n-  LOOP_STMT_LABEL (gnu_loop_stmt) = create_artificial_label (input_location);\n+  /* Set location information for statement and end label.  */\n   set_expr_location_from_node (gnu_loop_stmt, gnat_node);\n   Sloc_to_locus (Sloc (End_Label (gnat_node)),\n-\t\t &DECL_SOURCE_LOCATION (LOOP_STMT_LABEL (gnu_loop_stmt)));\n+\t\t &DECL_SOURCE_LOCATION (gnu_loop_label));\n+  LOOP_STMT_LABEL (gnu_loop_stmt) = gnu_loop_label;\n \n-  /* Save the end label of this LOOP_STMT in a stack so that the corresponding\n+  /* Save the end label of this LOOP_STMT in a stack so that a corresponding\n      N_Exit_Statement can find it.  */\n-  push_stack (&gnu_loop_label_stack, NULL_TREE,\n-\t      LOOP_STMT_LABEL (gnu_loop_stmt));\n+  push_stack (&gnu_loop_label_stack, NULL_TREE, gnu_loop_label);\n \n   /* Set the condition under which the loop must keep going.\n      For the case \"LOOP .... END LOOP;\" the condition is always true.  */\n@@ -2082,8 +2079,8 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n     LOOP_STMT_TOP_COND (gnu_loop_stmt)\n       = gnat_to_gnu (Condition (gnat_iter_scheme));\n \n-  /* Otherwise we have an iteration scheme and the condition is given by\n-     the bounds of the subtype of the iteration variable.  */\n+  /* Otherwise we have an iteration scheme and the condition is given by the\n+     bounds of the subtype of the iteration variable.  */\n   else\n     {\n       Node_Id gnat_loop_spec = Loop_Parameter_Specification (gnat_iter_scheme);\n@@ -2092,33 +2089,34 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       tree gnu_type = get_unpadded_type (gnat_type);\n       tree gnu_low = TYPE_MIN_VALUE (gnu_type);\n       tree gnu_high = TYPE_MAX_VALUE (gnu_type);\n-      tree gnu_first, gnu_last, gnu_limit;\n-      enum tree_code update_code, end_code;\n       tree gnu_base_type = get_base_type (gnu_type);\n+      tree gnu_first, gnu_last, gnu_limit, gnu_test;\n+      enum tree_code update_code, test_code;\n \n-      /* We must disable modulo reduction for the loop variable, if any,\n+      /* We must disable modulo reduction for the iteration variable, if any,\n \t in order for the loop comparison to be effective.  */\n       if (Reverse_Present (gnat_loop_spec))\n \t{\n \t  gnu_first = gnu_high;\n \t  gnu_last = gnu_low;\n \t  update_code = MINUS_NOMOD_EXPR;\n-\t  end_code = GE_EXPR;\n+\t  test_code = GE_EXPR;\n \t  gnu_limit = TYPE_MIN_VALUE (gnu_base_type);\n \t}\n       else\n \t{\n \t  gnu_first = gnu_low;\n \t  gnu_last = gnu_high;\n \t  update_code = PLUS_NOMOD_EXPR;\n-\t  end_code = LE_EXPR;\n+\t  test_code = LE_EXPR;\n \t  gnu_limit = TYPE_MAX_VALUE (gnu_base_type);\n \t}\n \n-      /* We know the loop variable will not overflow if GNU_LAST is a constant\n-\t and is not equal to GNU_LIMIT.  If it might overflow, we have to move\n-\t the limit test to the end of the loop.  In that case, we have to test\n-\t for an empty loop outside the loop.  */\n+      /* We know that the iteration variable will not overflow if GNU_LAST is\n+\t a constant and is not equal to GNU_LIMIT.  If it might overflow, we\n+\t have to turn the limit test into an inequality test and move it to\n+\t the end of the loop; as a consequence, we also have to test for an\n+\t empty loop before entering it.  */\n       if (TREE_CODE (gnu_last) != INTEGER_CST\n \t  || TREE_CODE (gnu_limit) != INTEGER_CST\n \t  || tree_int_cst_equal (gnu_last, gnu_limit))\n@@ -2129,32 +2127,30 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t\t\t\t       gnu_low, gnu_high),\n \t\t      NULL_TREE, alloc_stmt_list ());\n \t  set_expr_location_from_node (gnu_cond_expr, gnat_loop_spec);\n+\t  test_code = NE_EXPR;\n \t}\n \n       /* Open a new nesting level that will surround the loop to declare the\n-\t loop index variable.  */\n+\t iteration variable.  */\n       start_stmt_group ();\n       gnat_pushlevel ();\n \n-      /* Declare the loop index and set it to its initial value.  */\n+      /* Declare the iteration variable and set it to its initial value.  */\n       gnu_loop_var = gnat_to_gnu_entity (gnat_loop_var, gnu_first, 1);\n       if (DECL_BY_REF_P (gnu_loop_var))\n \tgnu_loop_var = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_loop_var);\n \n-      /* The loop variable might be a padded type, so use `convert' to get a\n-\t reference to the inner variable if so.  */\n-      gnu_loop_var = convert (get_base_type (gnu_type), gnu_loop_var);\n+      /* Do all the arithmetics in the base type.  */\n+      gnu_loop_var = convert (gnu_base_type, gnu_loop_var);\n \n       /* Set either the top or bottom exit condition as appropriate depending\n \t on whether or not we know an overflow cannot occur.  */\n+      gnu_test = build_binary_op (test_code, integer_type_node, gnu_loop_var,\n+\t\t\t\t  gnu_last);\n       if (gnu_cond_expr)\n-\tLOOP_STMT_BOT_COND (gnu_loop_stmt)\n-\t  = build_binary_op (NE_EXPR, integer_type_node,\n-\t\t\t     gnu_loop_var, gnu_last);\n+\tLOOP_STMT_BOT_COND (gnu_loop_stmt) = gnu_test;\n       else\n-\tLOOP_STMT_TOP_COND (gnu_loop_stmt)\n-\t  = build_binary_op (end_code, integer_type_node,\n-\t\t\t     gnu_loop_var, gnu_last);\n+\tLOOP_STMT_TOP_COND (gnu_loop_stmt) = gnu_test;\n \n       LOOP_STMT_UPDATE (gnu_loop_stmt)\n \t= build_binary_op (MODIFY_EXPR, NULL_TREE,\n@@ -2169,16 +2165,15 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n     }\n \n   /* If the loop was named, have the name point to this loop.  In this case,\n-     the association is not a ..._DECL node, but the end label from this\n-     LOOP_STMT.  */\n+     the association is not a DECL node, but the end label of the loop.  */\n   if (Present (Identifier (gnat_node)))\n-    save_gnu_tree (Entity (Identifier (gnat_node)),\n-\t\t   LOOP_STMT_LABEL (gnu_loop_stmt), true);\n+    save_gnu_tree (Entity (Identifier (gnat_node)), gnu_loop_label, true);\n \n   /* Make the loop body into its own block, so any allocated storage will be\n      released every iteration.  This is needed for stack allocation.  */\n   LOOP_STMT_BODY (gnu_loop_stmt)\n     = build_stmt_group (Statements (gnat_node), true);\n+  TREE_SIDE_EFFECTS (gnu_loop_stmt) = 1;\n \n   /* If we declared a variable, then we are in a statement group for that\n      declaration.  Add the LOOP_STMT to it and make that the \"loop\".  */\n@@ -2325,13 +2320,14 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   allocate_struct_function (gnu_subprog_decl, false);\n   DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language\n     = GGC_CNEW (struct language_function);\n+  set_cfun (NULL);\n \n   begin_subprog_body (gnu_subprog_decl);\n-  gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n \n   /* If there are Out parameters, we need to ensure that the return statement\n      properly copies them out.  We do this by making a new block and converting\n      any inner return into a goto to a label at the end of the block.  */\n+  gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n   push_stack (&gnu_return_label_stack, NULL_TREE,\n \t      gnu_cico_list ? create_artificial_label (input_location)\n \t      : NULL_TREE);\n@@ -3422,26 +3418,26 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n static void\n Compilation_Unit_to_gnu (Node_Id gnat_node)\n {\n+  const Node_Id gnat_unit = Unit (gnat_node);\n+  const bool body_p = (Nkind (gnat_unit) == N_Package_Body\n+\t\t       || Nkind (gnat_unit) == N_Subprogram_Body);\n+  const Entity_Id gnat_unit_entity = Defining_Entity (gnat_unit);\n   /* Make the decl for the elaboration procedure.  */\n-  bool body_p = (Defining_Entity (Unit (gnat_node)),\n-\t    Nkind (Unit (gnat_node)) == N_Package_Body\n-\t    || Nkind (Unit (gnat_node)) == N_Subprogram_Body);\n-  Entity_Id gnat_unit_entity = Defining_Entity (Unit (gnat_node));\n   tree gnu_elab_proc_decl\n     = create_subprog_decl\n-      (create_concat_name (gnat_unit_entity,\n-\t\t\t   body_p ? \"elabb\" : \"elabs\"),\n-       NULL_TREE, void_ftype, NULL_TREE, false, true, false, NULL,\n-       gnat_unit_entity);\n+      (create_concat_name (gnat_unit_entity, body_p ? \"elabb\" : \"elabs\"),\n+       NULL_TREE, void_ftype, NULL_TREE, false, true, false, NULL, gnat_unit);\n   struct elab_info *info;\n \n   push_stack (&gnu_elab_proc_stack, NULL_TREE, gnu_elab_proc_decl);\n-\n   DECL_ELABORATION_PROC_P (gnu_elab_proc_decl) = 1;\n+\n+  /* Initialize the information structure for the function.  */\n   allocate_struct_function (gnu_elab_proc_decl, false);\n-  Sloc_to_locus (Sloc (gnat_unit_entity), &cfun->function_end_locus);\n-  current_function_decl = NULL_TREE;\n   set_cfun (NULL);\n+\n+  current_function_decl = NULL_TREE;\n+\n   start_stmt_group ();\n   gnat_pushlevel ();\n \n@@ -3454,7 +3450,34 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n       finalize_from_with_types ();\n     }\n \n-  process_inlined_subprograms (gnat_node);\n+  /* If we can inline, generate code for all the inlined subprograms.  */\n+  if (optimize)\n+    {\n+      Entity_Id gnat_entity;\n+\n+      for (gnat_entity = First_Inlined_Subprogram (gnat_node);\n+\t   Present (gnat_entity);\n+\t   gnat_entity = Next_Inlined_Subprogram (gnat_entity))\n+\t{\n+\t  Node_Id gnat_body = Parent (Declaration_Node (gnat_entity));\n+\n+\t  if (Nkind (gnat_body) != N_Subprogram_Body)\n+\t    {\n+\t      /* ??? This really should always be present.  */\n+\t      if (No (Corresponding_Body (gnat_body)))\n+\t\tcontinue;\n+\t      gnat_body\n+\t\t= Parent (Declaration_Node (Corresponding_Body (gnat_body)));\n+\t    }\n+\n+\t  if (Present (gnat_body))\n+\t    {\n+\t      /* Define the entity first so we set DECL_EXTERNAL.  */\n+\t      gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n+\t      add_stmt (gnat_to_gnu (gnat_body));\n+\t    }\n+\t}\n+    }\n \n   if (type_annotate_only && gnat_node == Cunit (Main_Unit))\n     {\n@@ -3481,6 +3504,11 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   set_current_block_context (gnu_elab_proc_decl);\n   gnat_poplevel ();\n   DECL_SAVED_TREE (gnu_elab_proc_decl) = end_stmt_group ();\n+\n+  Sloc_to_locus\n+    (Sloc (gnat_unit),\n+     &DECL_STRUCT_FUNCTION (gnu_elab_proc_decl)->function_end_locus);\n+\n   info->next = elab_info_list;\n   info->elab_proc = gnu_elab_proc_decl;\n   info->gnat_node = gnat_node;\n@@ -5220,7 +5248,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\tgnu_actual_obj_type\n \t\t  = build_unc_object_type_from_ptr (gnu_ptr_type,\n \t\t\t\t\t\t    gnu_actual_obj_type,\n-\t\t\t\t\t\t    get_identifier (\"DEALLOC\"));\n+\t\t\t\t\t\t    get_identifier\n+\t\t\t\t\t\t    (\"DEALLOC\"));\n \t    }\n \t  else\n \t    gnu_actual_obj_type = gnu_obj_type;\n@@ -5235,7 +5264,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      tree gnu_byte_offset\n \t\t= convert (sizetype,\n \t\t\t   size_diffop (size_zero_node, gnu_pos));\n-\t      gnu_byte_offset = fold_build1 (NEGATE_EXPR, sizetype, gnu_byte_offset);\n+\t      gnu_byte_offset\n+\t\t= fold_build1 (NEGATE_EXPR, sizetype, gnu_byte_offset);\n \n \t      gnu_ptr = convert (gnu_char_ptr_type, gnu_ptr);\n \t      gnu_ptr = build_binary_op (POINTER_PLUS_EXPR, gnu_char_ptr_type,\n@@ -6219,42 +6249,6 @@ process_freeze_entity (Node_Id gnat_node)\n \t\t       TREE_TYPE (gnu_new));\n }\n \f\n-/* Process the list of inlined subprograms of GNAT_NODE, which is an\n-   N_Compilation_Unit.  */\n-\n-static void\n-process_inlined_subprograms (Node_Id gnat_node)\n-{\n-  Entity_Id gnat_entity;\n-  Node_Id gnat_body;\n-\n-  /* If we can inline, generate Gimple for all the inlined subprograms.\n-     Define the entity first so we set DECL_EXTERNAL.  */\n-  if (optimize > 0)\n-    for (gnat_entity = First_Inlined_Subprogram (gnat_node);\n-\t Present (gnat_entity);\n-\t gnat_entity = Next_Inlined_Subprogram (gnat_entity))\n-      {\n-\tgnat_body = Parent (Declaration_Node (gnat_entity));\n-\n-\tif (Nkind (gnat_body) != N_Subprogram_Body)\n-\t  {\n-\t    /* ??? This really should always be Present.  */\n-\t    if (No (Corresponding_Body (gnat_body)))\n-\t      continue;\n-\n-\t    gnat_body\n-\t      = Parent (Declaration_Node (Corresponding_Body (gnat_body)));\n-\t  }\n-\n-\tif (Present (gnat_body))\n-\t  {\n-\t    gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n-\t    add_stmt (gnat_to_gnu (gnat_body));\n-\t  }\n-      }\n-}\n-\f\n /* Elaborate decls in the lists GNAT_DECLS and GNAT_DECLS2, if present.\n    We make two passes, one to elaborate anything other than bodies (but\n    we declare a function if there was no spec).  The second pass\n@@ -7428,17 +7422,17 @@ post_error_ne (const char *msg, Node_Id node, Entity_Id ent)\n }\n \n /* Similar, but NODE is the node at which to post the error, ENT is the node\n-   to use for the \"&\" substitution, and N is the number to use for the ^.  */\n+   to use for the \"&\" substitution, and NUM is the number to use for ^.  */\n \n void\n-post_error_ne_num (const char *msg, Node_Id node, Entity_Id ent, int n)\n+post_error_ne_num (const char *msg, Node_Id node, Entity_Id ent, int num)\n {\n   String_Template temp;\n   Fat_Pointer fp;\n \n   temp.Low_Bound = 1, temp.High_Bound = strlen (msg);\n   fp.Array = msg, fp.Bounds = &temp;\n-  Error_Msg_Uint_1 = UI_From_Int (n);\n+  Error_Msg_Uint_1 = UI_From_Int (num);\n \n   if (Present (node))\n     Error_Msg_NE (fp, node, ent);\n@@ -7495,8 +7489,8 @@ post_error_ne_tree (const char *msg, Node_Id node, Entity_Id ent, tree t)\n     Error_Msg_NE (fp, node, ent);\n }\n \n-/* Similar to post_error_ne_tree, except that NUM is a second\n-   integer to write in the message.  */\n+/* Similar to post_error_ne_tree, except that NUM is a second integer to write\n+   in the message.  */\n \n void\n post_error_ne_tree_2 (const char *msg, Node_Id node, Entity_Id ent, tree t,"}, {"sha": "27959ea505ca1102310f8ca2b772c43f812c6923", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=58c8f7700a237538681b287d03625ca85a71e651", "patch": "@@ -203,6 +203,7 @@ static tree convert_to_fat_pointer (tree, tree);\n static tree convert_to_thin_pointer (tree, tree);\n static tree make_descriptor_field (const char *,tree, tree, tree);\n static bool potential_alignment_gap (tree, tree, tree);\n+static void process_attributes (tree, struct attrib *);\n \f\n /* Initialize the association of GNAT nodes to GCC trees.  */\n \n@@ -1283,7 +1284,10 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n \t\t\t    TYPE_DECL, type_name, type);\n \n   DECL_ARTIFICIAL (type_decl) = artificial_p;\n+\n+  /* Add this decl to the current binding level.  */\n   gnat_pushdecl (type_decl, gnat_node);\n+\n   process_attributes (type_decl, attr_list);\n \n   /* If we're naming the type, equate the TYPE_STUB_DECL to the name.\n@@ -1413,21 +1417,17 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n \t   != null_pointer_node)\n     DECL_IGNORED_P (var_decl) = 1;\n \n-  if (TREE_CODE (var_decl) == VAR_DECL)\n-    {\n-      if (asm_name)\n-\tSET_DECL_ASSEMBLER_NAME (var_decl, asm_name);\n-      process_attributes (var_decl, attr_list);\n-    }\n-\n   /* Add this decl to the current binding level.  */\n   gnat_pushdecl (var_decl, gnat_node);\n \n   if (TREE_SIDE_EFFECTS (var_decl))\n     TREE_ADDRESSABLE (var_decl) = 1;\n \n-  if (TREE_CODE (var_decl) != CONST_DECL)\n+  if (TREE_CODE (var_decl) == VAR_DECL)\n     {\n+      if (asm_name)\n+\tSET_DECL_ASSEMBLER_NAME (var_decl, asm_name);\n+      process_attributes (var_decl, attr_list);\n       if (global_bindings_p ())\n \trest_of_decl_compilation (var_decl, true, 0);\n     }\n@@ -1647,13 +1647,14 @@ create_param_decl (tree param_name, tree param_type, bool readonly)\n \f\n /* Given a DECL and ATTR_LIST, process the listed attributes.  */\n \n-void\n+static void\n process_attributes (tree decl, struct attrib *attr_list)\n {\n   for (; attr_list; attr_list = attr_list->next)\n     switch (attr_list->type)\n       {\n       case ATTR_MACHINE_ATTRIBUTE:\n+\tinput_location = DECL_SOURCE_LOCATION (decl);\n \tdecl_attributes (&decl, tree_cons (attr_list->name, attr_list->args,\n \t\t\t\t\t   NULL_TREE),\n \t\t\t ATTR_FLAG_TYPE_IN_PLACE);\n@@ -1863,11 +1864,11 @@ create_subprog_decl (tree subprog_name, tree asm_name,\n \tDECL_NAME (subprog_decl) = main_identifier_node;\n     }\n \n-  process_attributes (subprog_decl, attr_list);\n-\n   /* Add this decl to the current binding level.  */\n   gnat_pushdecl (subprog_decl, gnat_node);\n \n+  process_attributes (subprog_decl, attr_list);\n+\n   /* Output the assembler code and/or RTL for the declaration.  */\n   rest_of_decl_compilation (subprog_decl, global_bindings_p (), 0);\n \n@@ -1883,9 +1884,10 @@ begin_subprog_body (tree subprog_decl)\n {\n   tree param_decl;\n \n-  current_function_decl = subprog_decl;\n   announce_function (subprog_decl);\n \n+  current_function_decl = subprog_decl;\n+\n   /* Enter a new binding level and show that all the parameters belong to\n      this function.  */\n   gnat_pushlevel ();\n@@ -1926,7 +1928,6 @@ end_subprog_body (tree body)\n   DECL_SAVED_TREE (fndecl) = body;\n \n   current_function_decl = DECL_CONTEXT (fndecl);\n-  set_cfun (NULL);\n \n   /* We cannot track the location of errors past this point.  */\n   error_gnat_node = Empty;\n@@ -2329,12 +2330,12 @@ build_template (tree template_type, tree array_type, tree expr)\n   return gnat_build_constructor (template_type, nreverse (template_elts));\n }\n \f\n-/* Build a 32bit VMS descriptor from a Mechanism_Type, which must specify\n-   a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n-   in the type contains in its DECL_INITIAL the expression to use when\n-   a constructor is made for the type.  GNAT_ENTITY is an entity used\n-   to print out an error message if the mechanism cannot be applied to\n-   an object of that type and also for the name.  */\n+/* Build a 32-bit VMS descriptor from a Mechanism_Type, which must specify a\n+   descriptor type, and the GCC type of an object.  Each FIELD_DECL in the\n+   type contains in its DECL_INITIAL the expression to use when a constructor\n+   is made for the type.  GNAT_ENTITY is an entity used to print out an error\n+   message if the mechanism cannot be applied to an object of that type and\n+   also for the name.  */\n \n tree\n build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n@@ -2473,37 +2474,36 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n       break;\n     }\n \n-  /* Make the type for a descriptor for VMS.  The first four fields\n-     are the same for all types.  */\n-\n+  /* Make the type for a descriptor for VMS.  The first four fields are the\n+     same for all types.  */\n+  field_list\n+    = chainon (field_list,\n+\t       make_descriptor_field (\"LENGTH\", gnat_type_for_size (16, 1),\n+\t\t\t\t      record_type,\n+\t\t\t\t      size_in_bytes\n+\t\t\t\t      ((mech == By_Descriptor_A\n+\t\t\t\t\t|| mech == By_Short_Descriptor_A)\n+\t\t\t\t       ? inner_type : type)));\n   field_list\n     = chainon (field_list,\n-\t       make_descriptor_field\n-\t       (\"LENGTH\", gnat_type_for_size (16, 1), record_type,\n-\t\tsize_in_bytes ((mech == By_Descriptor_A ||\n-                                mech == By_Short_Descriptor_A)\n-                               ? inner_type : type)));\n-\n-  field_list = chainon (field_list,\n-\t\t\tmake_descriptor_field (\"DTYPE\",\n-\t\t\t\t\t       gnat_type_for_size (8, 1),\n-\t\t\t\t\t       record_type, size_int (dtype)));\n-  field_list = chainon (field_list,\n-\t\t\tmake_descriptor_field (\"CLASS\",\n-\t\t\t\t\t       gnat_type_for_size (8, 1),\n-\t\t\t\t\t       record_type, size_int (klass)));\n+\t       make_descriptor_field (\"DTYPE\", gnat_type_for_size (8, 1),\n+\t\t\t\t      record_type, size_int (dtype)));\n+  field_list\n+    = chainon (field_list,\n+\t       make_descriptor_field (\"CLASS\", gnat_type_for_size (8, 1),\n+\t\t\t\t      record_type, size_int (klass)));\n \n   /* Of course this will crash at run-time if the address space is not\n      within the low 32 bits, but there is nothing else we can do.  */\n   pointer32_type = build_pointer_type_for_mode (type, SImode, false);\n \n   field_list\n     = chainon (field_list,\n-\t       make_descriptor_field\n-\t       (\"POINTER\", pointer32_type, record_type,\n-\t\tbuild_unary_op (ADDR_EXPR,\n-\t\t\t\tpointer32_type,\n-\t\t\t\tbuild0 (PLACEHOLDER_EXPR, type))));\n+\t       make_descriptor_field (\"POINTER\", pointer32_type, record_type,\n+\t\t\t\t      build_unary_op (ADDR_EXPR,\n+\t\t\t\t\t\t      pointer32_type,\n+\t\t\t\t\t\t      build0 (PLACEHOLDER_EXPR,\n+\t\t\t\t\t\t\t      type))));\n \n   switch (mech)\n     {\n@@ -2644,12 +2644,12 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   return record_type;\n }\n \n-/* Build a 64bit VMS descriptor from a Mechanism_Type, which must specify\n-   a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n-   in the type contains in its DECL_INITIAL the expression to use when\n-   a constructor is made for the type.  GNAT_ENTITY is an entity used\n-   to print out an error message if the mechanism cannot be applied to\n-   an object of that type and also for the name.  */\n+/* Build a 64-bit VMS descriptor from a Mechanism_Type, which must specify a\n+   descriptor type, and the GCC type of an object.  Each FIELD_DECL in the\n+   type contains in its DECL_INITIAL the expression to use when a constructor\n+   is made for the type.  GNAT_ENTITY is an entity used to print out an error\n+   message if the mechanism cannot be applied to an object of that type and\n+   also for the name.  */\n \n tree\n build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n@@ -2783,43 +2783,41 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n       break;\n     }\n \n-  /* Make the type for a 64bit descriptor for VMS.  The first six fields\n+  /* Make the type for a 64-bit descriptor for VMS.  The first six fields\n      are the same for all types.  */\n-\n-  field_list64 = chainon (field_list64,\n-\t\t\tmake_descriptor_field (\"MBO\",\n-                                               gnat_type_for_size (16, 1),\n-                                               record64_type, size_int (1)));\n-\n-  field_list64 = chainon (field_list64,\n-\t\t\tmake_descriptor_field (\"DTYPE\",\n-\t\t\t\t\t       gnat_type_for_size (8, 1),\n-\t\t\t\t\t       record64_type, size_int (dtype)));\n-  field_list64 = chainon (field_list64,\n-\t\t\tmake_descriptor_field (\"CLASS\",\n-\t\t\t\t\t       gnat_type_for_size (8, 1),\n-\t\t\t\t\t       record64_type, size_int (klass)));\n-\n-  field_list64 = chainon (field_list64,\n-\t\t\tmake_descriptor_field (\"MBMO\",\n-                                               gnat_type_for_size (32, 1),\n-                                               record64_type, ssize_int (-1)));\n-\n   field_list64\n     = chainon (field_list64,\n-\t       make_descriptor_field\n-\t       (\"LENGTH\", gnat_type_for_size (64, 1), record64_type,\n-\t\tsize_in_bytes (mech == By_Descriptor_A ? inner_type : type)));\n+\t       make_descriptor_field (\"MBO\", gnat_type_for_size (16, 1),\n+\t\t\t\t      record64_type, size_int (1)));\n+  field_list64\n+    = chainon (field_list64,\n+\t       make_descriptor_field (\"DTYPE\", gnat_type_for_size (8, 1),\n+\t\t\t\t      record64_type, size_int (dtype)));\n+  field_list64\n+    = chainon (field_list64,\n+\t       make_descriptor_field (\"CLASS\", gnat_type_for_size (8, 1),\n+\t\t\t\t      record64_type, size_int (klass)));\n+  field_list64\n+    = chainon (field_list64,\n+\t       make_descriptor_field (\"MBMO\", gnat_type_for_size (32, 1),\n+\t\t\t\t      record64_type, ssize_int (-1)));\n+  field_list64\n+    = chainon (field_list64,\n+\t       make_descriptor_field (\"LENGTH\", gnat_type_for_size (64, 1),\n+\t\t\t\t      record64_type,\n+\t\t\t\t      size_in_bytes (mech == By_Descriptor_A\n+\t\t\t\t\t\t     ? inner_type : type)));\n \n   pointer64_type = build_pointer_type_for_mode (type, DImode, false);\n \n   field_list64\n     = chainon (field_list64,\n-\t       make_descriptor_field\n-\t       (\"POINTER\", pointer64_type, record64_type,\n-\t\tbuild_unary_op (ADDR_EXPR,\n-\t\t\t\tpointer64_type,\n-\t\t\t\tbuild0 (PLACEHOLDER_EXPR, type))));\n+\t       make_descriptor_field (\"POINTER\", pointer64_type,\n+\t\t\t\t      record64_type,\n+\t\t\t\t      build_unary_op (ADDR_EXPR,\n+\t\t\t\t\t\t      pointer64_type,\n+\t\t\t\t\t\t      build0 (PLACEHOLDER_EXPR,\n+\t\t\t\t\t\t\t      type))));\n \n   switch (mech)\n     {\n@@ -2983,11 +2981,11 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n   /* The CLASS field is the 3rd field in the descriptor.  */\n   tree klass = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n   /* The POINTER field is the 6th field in the descriptor.  */\n-  tree pointer64 = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (klass)));\n+  tree pointer = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (klass)));\n \n   /* Retrieve the value of the POINTER field.  */\n   tree gnu_expr64\n-    = build3 (COMPONENT_REF, TREE_TYPE (pointer64), desc, pointer64, NULL_TREE);\n+    = build3 (COMPONENT_REF, TREE_TYPE (pointer), desc, pointer, NULL_TREE);\n \n   if (POINTER_TYPE_P (gnu_type))\n     return convert (gnu_type, gnu_expr64);\n@@ -3033,7 +3031,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \t  /* If so, there is already a template in the descriptor and\n \t     it is located right after the POINTER field.  The fields are\n              64bits so they must be repacked. */\n-\t  t = TREE_CHAIN (pointer64);\n+\t  t = TREE_CHAIN (pointer);\n           lfield = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n           lfield = convert (TREE_TYPE (TYPE_FIELDS (template_type)), lfield);\n \n@@ -3058,7 +3056,7 @@ convert_vms_descriptor64 (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n \tcase 4:  /* Class A */\n \t  /* The AFLAGS field is the 3rd field after the pointer in the\n              descriptor.  */\n-\t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (pointer64)));\n+\t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (pointer)));\n \t  aflags = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n \t  /* The DIMCT field is the next field in the descriptor after\n              aflags.  */\n@@ -5084,15 +5082,17 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n \t  if (!argument\n \t      || TREE_CODE (TREE_VALUE (argument)) == VOID_TYPE)\n \t    {\n-\t      error (\"nonnull argument with out-of-range operand number (argument %lu, operand %lu)\",\n+\t      error (\"nonnull argument with out-of-range operand number \"\n+\t\t     \"(argument %lu, operand %lu)\",\n \t\t     (unsigned long) attr_arg_num, (unsigned long) arg_num);\n \t      *no_add_attrs = true;\n \t      return NULL_TREE;\n \t    }\n \n \t  if (TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE)\n \t    {\n-\t      error (\"nonnull argument references non-pointer operand (argument %lu, operand %lu)\",\n+\t      error (\"nonnull argument references non-pointer operand \"\n+\t\t     \"(argument %lu, operand %lu)\",\n \t\t   (unsigned long) attr_arg_num, (unsigned long) arg_num);\n \t      *no_add_attrs = true;\n \t      return NULL_TREE;"}, {"sha": "b6bd268feeeddf1f01c2f919efe37cec9519cf04", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58c8f7700a237538681b287d03625ca85a71e651/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=58c8f7700a237538681b287d03625ca85a71e651", "patch": "@@ -2121,7 +2121,8 @@ fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual)\n \t\t\t\t\t     convert (long_integer_type_node,\n \t\t\t\t\t\t      addr64expr),\n \t\t\t\t\t     malloc64low),\n-\t\t\t    build_call_raise (CE_Range_Check_Failed, gnat_actual,\n+\t\t\t    build_call_raise (CE_Range_Check_Failed,\n+\t\t\t\t\t      gnat_actual,\n \t\t\t\t\t      N_Raise_Constraint_Error),\n \t\t\t    NULL_TREE));\n         }\n@@ -2228,9 +2229,12 @@ gnat_protect_expr (tree exp)\n      unshared for gimplification; in order to avoid a complexity explosion\n      at that point, we protect any expressions more complex than a simple\n      arithmetic expression.  */\n-  if (!TREE_SIDE_EFFECTS (exp)\n-      && !EXPRESSION_CLASS_P (skip_simple_arithmetic (exp)))\n-    return exp;\n+  if (!TREE_SIDE_EFFECTS (exp))\n+    {\n+      tree inner = skip_simple_arithmetic (exp);\n+      if (!EXPR_P (inner) || REFERENCE_CLASS_P (inner))\n+\treturn exp;\n+    }\n \n   /* If this is a conversion, protect what's inside the conversion.  */\n   if (code == NON_LVALUE_EXPR"}]}