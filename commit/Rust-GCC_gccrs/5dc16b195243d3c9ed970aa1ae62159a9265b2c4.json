{"sha": "5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRjMTZiMTk1MjQzZDNjOWVkOTcwYWExYWU2MjE1OWE5MjY1YjJjNA==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2010-04-27T20:22:54Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2010-04-27T20:22:54Z"}, "message": "invoke.texi (-Wsuggest-attribute=const, [...]): Document.\n\n2010-04-27  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\t    Jan Hubicka <hubicka@ucw.cz>\n\n\t* doc/invoke.texi (-Wsuggest-attribute=const,\n\t-Wsuggest-attribute=pure): Document.\n\t* ipa-pure-const.c: Include toplev.h, intl.h and opts.h.\n\t(function_always_visible_to_compiler_p,\n\tsuggest_attribute, warn_function_pure, warn_function_const):\n\tNew functions.\n\t(check_call): Improve debug info.\n\t(analyze_function): Do not check availability.\n\t(add_new_function): Check availability.\n\t(propagate): Output warnings.\n\t(skip_function_for_local_pure_const): New function.\n\t(local_pure_const): Use it; output warnings.\n\t* common.opt (Wsuggest-attribute=const,\n\tWsuggest-attribute=pure): New.\n\ntestsuite/\n\t* gcc.dg/pure-2.c: New testcase.\n\t* gcc.dg/const-1.c: New testcase.\n\nCo-Authored-By: Jan Hubicka <hubicka@ucw.cz>\n\nFrom-SVN: r158803", "tree": {"sha": "778af4c2a789370f37221943c394560c41ac11e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/778af4c2a789370f37221943c394560c41ac11e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/comments", "author": null, "committer": null, "parents": [{"sha": "ea8b8aa005a994ce5d3e5437c780a35a2c27ff4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea8b8aa005a994ce5d3e5437c780a35a2c27ff4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea8b8aa005a994ce5d3e5437c780a35a2c27ff4e"}], "stats": {"total": 362, "additions": 325, "deletions": 37}, "files": [{"sha": "0f376e5dd3f35a829b6dbade0350474c4230a9e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "patch": "@@ -1,3 +1,21 @@\n+2010-04-27  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\t    Jan Hubicka <hubicka@ucw.cz>\n+\n+\t* doc/invoke.texi (-Wsuggest-attribute=const,\n+\t-Wsuggest-attribute=pure): Document.\n+\t* ipa-pure-const.c: Include toplev.h, intl.h and opts.h.\n+\t(function_always_visible_to_compiler_p,\n+\tsuggest_attribute, warn_function_pure, warn_function_const):\n+\tNew functions.\n+\t(check_call): Improve debug info.\n+\t(analyze_function): Do not check availability.\n+\t(add_new_function): Check availability.\n+\t(propagate): Output warnings.\n+\t(skip_function_for_local_pure_const): New function.\n+\t(local_pure_const): Use it; output warnings.\n+\t* common.opt (Wsuggest-attribute=const,\n+\tWsuggest-attribute=pure): New.\n+\n 2010-04-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (def_cfa_1): After DW_CFA_def_cfa_expression"}, {"sha": "e62e3d583a09051b8a1d9d8a0c26c731dc65313f", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "patch": "@@ -180,6 +180,14 @@ Wstrict-overflow=\n Common Joined UInteger Var(warn_strict_overflow) Init(-1) Warning\n Warn about optimizations that assume that signed overflow is undefined\n \n+Wsuggest-attribute=const\n+Common Var(warn_suggest_attribute_const) Warning\n+Warn about functions which might be candidates for __attribute__((const))\n+\n+Wsuggest-attribute=pure\n+Common Var(warn_suggest_attribute_pure) Warning\n+Warn about functions which might be candidates for __attribute__((pure))\n+\n Wswitch\n Common Var(warn_switch) Warning\n Warn about enumerated switches, with no default, missing a case"}, {"sha": "fefb0abd1d55e974c355ce5b261d1572c4528927", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "patch": "@@ -257,6 +257,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wsign-compare  -Wsign-conversion  -Wstack-protector @gol\n -Wstrict-aliasing -Wstrict-aliasing=n @gol\n -Wstrict-overflow -Wstrict-overflow=@var{n} @gol\n+-Wsuggest-attribute=@r{[}const@r{|}pure@r{]} @gol\n -Wswitch  -Wswitch-default  -Wswitch-enum -Wsync-nand @gol\n -Wsystem-headers  -Wtrigraphs  -Wtype-limits  -Wundef  -Wuninitialized @gol\n -Wunknown-pragmas  -Wno-pragmas @gol\n@@ -3621,11 +3622,36 @@ comparisons, so this warning level will give a very large number of\n false positives.\n @end table\n \n+@item -Wsuggest-attribute=@r{[}const@r{|}pure@r{]}\n+@opindex Wsuggest-attribute=\n+@opindex Wno-suggest-attribute=\n+Warn for cases where adding an attribute may be beneficial. The\n+attributes currently supported are listed below.\n+\n+@table @gcctabopt\n+@item -Wsuggest-attribute=pure\n+@itemx -Wsuggest-attribute=const\n+@opindex Wsuggest-attribute=pure\n+@opindex Wno-suggest-attribute=pure\n+@opindex Wsuggest-attribute=const\n+@opindex Wno-suggest-attribute=const\n+\n+Warn about functions which might be candidates for attributes\n+@code{pure} or @code{const}.  The compiler only warns for functions\n+visible in other compilation units or if it cannot prove that the\n+function returns normally. A function returns normally if it doesn't\n+contain an infinite loop nor returns abnormally by throwing, calling\n+@code{abort()} or trapping.  This analysis requires option\n+@option{-fipa-pure-const}, which is enabled by default at @option{-O}\n+and higher.  Higher optimization levels improve the accuracy of the\n+analysis.\n+@end table\n+\n @item -Warray-bounds\n @opindex Wno-array-bounds\n @opindex Warray-bounds\n This option is only active when @option{-ftree-vrp} is active\n-(default for -O2 and above). It warns about subscripts to arrays\n+(default for @option{-O2} and above). It warns about subscripts to arrays\n that are always out of bounds. This warning is enabled by @option{-Wall}.\n \n @item -Wno-div-by-zero"}, {"sha": "46d03e692483403cf272348781d7cb079101a9b9", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 152, "deletions": 36, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "patch": "@@ -49,12 +49,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"flags.h\"\n #include \"timevar.h\"\n+#include \"toplev.h\"\n #include \"diagnostic.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n #include \"lto-streamer.h\"\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"intl.h\"\n+#include \"opts.h\"\n \n static struct pointer_set_t *visited_nodes;\n \n@@ -106,6 +109,71 @@ static struct cgraph_node_hook_list *function_insertion_hook_holder;\n static struct cgraph_2node_hook_list *node_duplication_hook_holder;\n static struct cgraph_node_hook_list *node_removal_hook_holder;\n \n+/* Try to guess if function body will always be visible to compiler\n+   when compiling the call and whether compiler will be able\n+   to propagate the information by itself.  */\n+\n+static bool\n+function_always_visible_to_compiler_p (tree decl)\n+{\n+  return (!TREE_PUBLIC (decl) || DECL_DECLARED_INLINE_P (decl));\n+}\n+\n+/* Emit suggestion about attribute ATTRIB_NAME for DECL.  KNOWN_FINITE\n+   is true if the function is known to be finite.  The diagnostic is\n+   controlled by OPTION.  WARNED_ABOUT is a pointer_set unique for\n+   OPTION, this function may initialize it and it is always returned\n+   by the function.  */\n+\n+static struct pointer_set_t *\n+suggest_attribute (int option, tree decl, bool known_finite,\n+\t\t   struct pointer_set_t *warned_about,\n+\t\t   const char * attrib_name)\n+{\n+  if (!option_enabled (option))\n+    return warned_about;\n+  if (TREE_THIS_VOLATILE (decl)\n+      || (known_finite && function_always_visible_to_compiler_p (decl)))\n+    return warned_about;\n+\n+  if (!warned_about)\n+    warned_about = pointer_set_create (); \n+  if (pointer_set_contains (warned_about, decl))\n+    return warned_about;\n+  pointer_set_insert (warned_about, decl);\n+  warning_at (DECL_SOURCE_LOCATION (decl),\n+\t      option,\n+\t      known_finite\n+\t      ? _(\"function might be candidate for attribute %<%s%>\")\n+\t      : _(\"function might be candidate for attribute %<%s%>\"\n+\t\t  \" if it is known to return normally\"), attrib_name);\n+  return warned_about;\n+}\n+\n+/* Emit suggestion about __attribute_((pure)) for DECL.  KNOWN_FINITE\n+   is true if the function is known to be finite.  */\n+\n+static void\n+warn_function_pure (tree decl, bool known_finite)\n+{\n+  static struct pointer_set_t *warned_about;\n+\n+  warned_about \n+    = suggest_attribute (OPT_Wsuggest_attribute_pure, decl,\n+\t\t\t known_finite, warned_about, \"pure\");\n+}\n+\n+/* Emit suggestion about __attribute_((const)) for DECL.  KNOWN_FINITE\n+   is true if the function is known to be finite.  */\n+\n+static void\n+warn_function_const (tree decl, bool known_finite)\n+{\n+  static struct pointer_set_t *warned_about;\n+  warned_about \n+    = suggest_attribute (OPT_Wsuggest_attribute_const, decl,\n+\t\t\t known_finite, warned_about, \"const\");\n+}\n /* Init the function state.  */\n \n static void\n@@ -325,7 +393,11 @@ check_call (funct_state local, gimple call, bool ipa)\n \n   /* When not in IPA mode, we can still handle self recursion.  */\n   if (!ipa && callee_t == current_function_decl)\n-    local->looping = true;\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"    Recursive call can loop.\\n\");\n+      local->looping = true;\n+    }\n   /* Either calle is unknown or we are doing local analysis.\n      Look to see if there are any bits available for the callee (such as by\n      declaration or because it is builtin) and process solely on the basis of\n@@ -353,12 +425,20 @@ check_call (funct_state local, gimple call, bool ipa)\n       if (flags & ECF_CONST)\n \t{\n           if (callee_t && DECL_LOOPING_CONST_OR_PURE_P (callee_t))\n-            local->looping = true;\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"    calls looping pure.\\n\");\n+              local->looping = true;\n+\t    }\n \t }\n       else if (flags & ECF_PURE)\n \t{\n           if (callee_t && DECL_LOOPING_CONST_OR_PURE_P (callee_t))\n-            local->looping = true;\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"    calls looping const.\\n\");\n+              local->looping = true;\n+\t    }\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    pure function call in not const\\n\");\n \t  if (local->pure_const_state == IPA_CONST)\n@@ -604,7 +684,8 @@ add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n      since all we would be interested in are the addressof\n      operations.  */\n   visited_nodes = pointer_set_create ();\n-  set_function_state (node, analyze_function (node, true));\n+  if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE)\n+    set_function_state (node, analyze_function (node, true));\n   pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n }\n@@ -938,19 +1019,27 @@ propagate (void)\n \t  switch (this_state)\n \t    {\n \t    case IPA_CONST:\n-\t      if (!TREE_READONLY (w->decl) && dump_file)\n-\t\tfprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n-\t\t\t this_looping ? \"looping \" : \"\",\n-\t\t\t cgraph_node_name (w));\n+\t      if (!TREE_READONLY (w->decl))\n+\t\t{\n+\t\t  warn_function_const (w->decl, !this_looping);\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n+\t\t\t     this_looping ? \"looping \" : \"\",\n+\t\t\t     cgraph_node_name (w));\n+\t\t}\n \t      cgraph_set_readonly_flag (w, true);\n \t      cgraph_set_looping_const_or_pure_flag (w, this_looping);\n \t      break;\n \n \t    case IPA_PURE:\n-\t      if (!DECL_PURE_P (w->decl) && dump_file)\n-\t\tfprintf (dump_file, \"Function found to be %spure: %s\\n\",\n-\t\t\t this_looping ? \"looping \" : \"\",\n-\t\t\t cgraph_node_name (w));\n+\t      if (!DECL_PURE_P (w->decl))\n+\t\t{\n+\t\t  warn_function_pure (w->decl, !this_looping);\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Function found to be %spure: %s\\n\",\n+\t\t\t     this_looping ? \"looping \" : \"\",\n+\t\t\t     cgraph_node_name (w));\n+\t\t}\n \t      cgraph_set_pure_flag (w, true);\n \t      cgraph_set_looping_const_or_pure_flag (w, this_looping);\n \t      break;\n@@ -1103,44 +1192,61 @@ struct ipa_opt_pass_d pass_ipa_pure_const =\n  NULL\t\t\t\t\t/* variable_transform */\n };\n \n-/* Simple local pass for pure const discovery reusing the analysis from\n-   ipa_pure_const.   This pass is effective when executed together with\n-   other optimization passes in early optimization pass queue.  */\n+/* Return true if function should be skipped for local pure const analysis.  */\n \n-static unsigned int\n-local_pure_const (void)\n+static bool\n+skip_function_for_local_pure_const (struct cgraph_node *node)\n {\n-  bool changed = false;\n-  funct_state l;\n-  struct cgraph_node *node;\n-\n   /* Because we do not schedule pass_fixup_cfg over whole program after early optimizations\n      we must not promote functions that are called by already processed functions.  */\n \n   if (function_called_by_processed_nodes_p ())\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Function called in recursive cycle; ignoring\\n\");\n-      return 0;\n+      return true;\n     }\n-  node = cgraph_node (current_function_decl);\n   if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n     {\n       if (dump_file)\n-        fprintf (dump_file, \"Function has wrong visibility; ignoring\\n\");\n-      return 0;\n+        fprintf (dump_file, \"Function is not available or overwrittable; not analyzing.\\n\");\n+      return true;\n     }\n+  return false;\n+}\n+\n+/* Simple local pass for pure const discovery reusing the analysis from\n+   ipa_pure_const.   This pass is effective when executed together with\n+   other optimization passes in early optimization pass queue.  */\n \n+static unsigned int\n+local_pure_const (void)\n+{\n+  bool changed = false;\n+  funct_state l;\n+  bool skip;\n+  struct cgraph_node *node;\n+\n+  node = cgraph_node (current_function_decl);\n+  skip = skip_function_for_local_pure_const (node);\n+  if (!warn_suggest_attribute_const\n+      && !warn_suggest_attribute_pure\n+      && skip)\n+    return 0;\n   l = analyze_function (node, false);\n \n   switch (l->pure_const_state)\n     {\n     case IPA_CONST:\n       if (!TREE_READONLY (current_function_decl))\n \t{\n-\t  cgraph_set_readonly_flag (node, true);\n-\t  cgraph_set_looping_const_or_pure_flag (node, l->looping);\n-\t  changed = true;\n+\t  warn_function_const (current_function_decl, !l->looping);\n+\t  if (!skip)\n+\t    {\n+\t      cgraph_set_readonly_flag (node, true);\n+\t      cgraph_set_looping_const_or_pure_flag (node, l->looping);\n+\t      changed = true;\n+\t    }\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n \t\t     l->looping ? \"looping \" : \"\",\n@@ -1150,8 +1256,11 @@ local_pure_const (void)\n       else if (DECL_LOOPING_CONST_OR_PURE_P (current_function_decl)\n \t       && !l->looping)\n \t{\n-\t  cgraph_set_looping_const_or_pure_flag (node, false);\n-\t  changed = true;\n+\t  if (!skip)\n+\t    {\n+\t      cgraph_set_looping_const_or_pure_flag (node, false);\n+\t      changed = true;\n+\t    }\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Function found to be non-looping: %s\\n\",\n \t\t     lang_hooks.decl_printable_name (current_function_decl,\n@@ -1160,11 +1269,15 @@ local_pure_const (void)\n       break;\n \n     case IPA_PURE:\n-      if (!TREE_READONLY (current_function_decl))\n+      if (!DECL_PURE_P (current_function_decl))\n \t{\n-\t  cgraph_set_pure_flag (node, true);\n-\t  cgraph_set_looping_const_or_pure_flag (node, l->looping);\n-\t  changed = true;\n+\t  if (!skip)\n+\t    {\n+\t      cgraph_set_pure_flag (node, true);\n+\t      cgraph_set_looping_const_or_pure_flag (node, l->looping);\n+\t      changed = true;\n+\t    }\n+\t  warn_function_pure (current_function_decl, !l->looping);\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Function found to be %spure: %s\\n\",\n \t\t     l->looping ? \"looping \" : \"\",\n@@ -1174,8 +1287,11 @@ local_pure_const (void)\n       else if (DECL_LOOPING_CONST_OR_PURE_P (current_function_decl)\n \t       && !l->looping)\n \t{\n-\t  cgraph_set_looping_const_or_pure_flag (node, false);\n-\t  changed = true;\n+\t  if (!skip)\n+\t    {\n+\t      cgraph_set_looping_const_or_pure_flag (node, false);\n+\t      changed = true;\n+\t    }\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Function found to be non-looping: %s\\n\",\n \t\t     lang_hooks.decl_printable_name (current_function_decl,"}, {"sha": "4a8fb182f770b65da910eef7f2ef8fd6dc9353b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "patch": "@@ -1,3 +1,9 @@\n+2010-04-27  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\t    Jan Hubicka <hubicka@ucw.cz>\n+\n+\t* gcc.dg/pure-2.c: New testcase.\n+\t* gcc.dg/const-1.c: New testcase.\n+\n 2010-04-27  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/lambda/lambda-ice1.C: New."}, {"sha": "2657c9b5738babe3aa976545ad3f2737e2e99943", "filename": "gcc/testsuite/gcc.dg/const-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fconst-1.c?ref=5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wsuggest-attribute=const\" } */\n+\n+extern int extern_const(int a) __attribute__ ((const));\n+\n+/* Trivial.  */\n+int\n+foo1(int a)  /* { dg-bogus \"normally\" \"detect const candidate\" } */\n+{ /* { dg-warning \"const\" \"detect const candidate\" { target *-*-* } \"8\" } */ \n+  return extern_const (a);\n+}\n+\n+/* Loops known to be normally and extern const calls should be safe.  */\n+\n+int __attribute__ ((noinline))\n+foo2(int n)  /* { dg-bogus \"normally\" \"detect const candidate\" } */\n+{ /* { dg-warning \"const\" \"detect const candidate\" { target *-*-* } \"16\" } */\n+  int ret = 0;\n+  int i;\n+  for (i=0; i<n; i++)\n+    ret+=extern_const (i);\n+  return ret;\n+}\n+\n+/* No warning here; we can work it by ourselves.  */\n+static int __attribute__ ((noinline))\n+foo2b(int n)\n+{\n+  int ret = 0;\n+  int i;\n+  for (i=0; i<n; i++)\n+    ret+=extern_const (i);\n+  return ret;\n+}\n+\n+/* Unbounded loops are not safe.  */\n+static int __attribute__ ((noinline))\n+foo3(int n)  /* { dg-warning \"const\\[^\\n\\]* normally\" \"detect const candidate\" } */\n+{\n+  int ret = 0;\n+  int i;\n+  for (i=0; extern_const (i+n); n++)\n+    ret+=extern_const (i);\n+  return ret;\n+}\n+\n+int\n+foo4(int n) /* { dg-warning \"const\\[^\\n\\]* normally\" \"detect const candidate\" } */\n+{\n+  return foo3(n) + foo2b(n);\n+} \n+\n+int\n+foo5(int n)  /* { dg-bogus \"normally\" \"detect const candidate\" } */\n+{ /* { dg-warning \"const\" \"detect const candidate\" { target *-*-* } \"54\" } */\n+  return foo2(n);\n+} "}, {"sha": "97ba31f0261f1552c412238f30b208cb9cef582a", "filename": "gcc/testsuite/gcc.dg/pure-2.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Ftestsuite%2Fgcc.dg%2Fpure-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc16b195243d3c9ed970aa1ae62159a9265b2c4/gcc%2Ftestsuite%2Fgcc.dg%2Fpure-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpure-2.c?ref=5dc16b195243d3c9ed970aa1ae62159a9265b2c4", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wsuggest-attribute=pure\" } */\n+\n+extern int extern_const(int a) __attribute__ ((pure));\n+extern int v;\n+\n+/* Trivial.  */\n+int\n+foo1(int a)  /* { dg-bogus \"normally\" \"detect pure candidate\" } */\n+{ /* { dg-warning \"pure\" \"detect pure candidate\" { target *-*-* } \"9\" } */\n+  return v;\n+}\n+\n+/* Loops known to be normally and extern const calls should be safe.  */\n+int __attribute__ ((noinline))\n+foo2(int n)  /* { dg-bogus \"normally\" \"detect pure candidate\" } */\n+{ /* { dg-warning \"pure\" \"detect pure candidate\" { target *-*-* } \"16\" } */\n+  int ret = 0;\n+  int i;\n+  for (i=0; i<n; i++)\n+    ret+=extern_const (i);\n+  return ret;\n+}\n+\n+/* No warning here; we can work it by ourselves.  */\n+static int __attribute__ ((noinline))\n+foo2b(int n)\n+{\n+  int ret = 0;\n+  int i;\n+  for (i=0; i<n; i++)\n+    ret+=extern_const (i);\n+  return ret;\n+}\n+\n+/* Unbounded loops are not safe.  */\n+static int __attribute__ ((noinline))\n+foo3(int n) /* { dg-warning \"pure\\[^\\n\\]* normally\" \"detect pure candidate\" } */\n+{\n+  int ret = 0;\n+  int i;\n+  for (i=0; extern_const (i+n); n++)\n+    ret+=extern_const (i);\n+  return ret;\n+}\n+\n+int\n+foo4(int n)  /* { dg-warning \"pure\\[^\\n\\]* normally\" \"detect pure candidate\" } */\n+{\n+  return foo3(n) + foo2b(n);\n+}\n+\n+int\n+foo5(int n)  /* { dg-bogus \"normally\" \"detect pure candidate\" } */\n+{  /* { dg-warning \"pure\" \"detect pure candidate\" { target *-*-* } \"54\" } */\n+  return foo2(n);\n+}"}]}