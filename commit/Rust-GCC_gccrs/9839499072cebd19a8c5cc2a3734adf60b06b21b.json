{"sha": "9839499072cebd19a8c5cc2a3734adf60b06b21b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgzOTQ5OTA3MmNlYmQxOWE4YzVjYzJhMzczNGFkZjYwYjA2YjIxYg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-11-18T02:29:13Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-11-18T02:29:13Z"}, "message": "natString.cc: Include Locale.h.\n\n\t* java/lang/natString.cc: Include Locale.h.\n\t(toUpperCase): Added `locale' argument.  Handle locale\n\tsensitivity.\n\t(toLowerCase): Added `locale' argument.  Handle locale\n\tsensitivity.\n\t(ESSET, CAPITAL_S, SMALL_I, CAPITAL_I_WITH_DOT, SMALL_DOTLESS_I,\n\tCAPITAL_I): New defines.\n\t* java/lang/String.java (CASE_INSENSITIVE_ORDER): Now public and\n\tfinal.\n\tImport Locale.\n\t(toUpperCase, toLowerCase): New methods.  Variants which accept\n\tlocale now native.\n\n\t* java/lang/ExceptionInInitializerError.java (printStackTrace):\n\tNew methods.\n\n\t* java/util/PropertyPermission.java: Re-merged from Classpath.\n\n\t* java/text/RuleBasedCollator.java (getCollationElementIterator):\n\tNew method.\n\t* java/text/StringCharacterIterator.java: Reindented.\n\t(setText): New method.\n\nFrom-SVN: r37539", "tree": {"sha": "172790643762236160d84d128d568d37d0b773ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/172790643762236160d84d128d568d37d0b773ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9839499072cebd19a8c5cc2a3734adf60b06b21b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9839499072cebd19a8c5cc2a3734adf60b06b21b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9839499072cebd19a8c5cc2a3734adf60b06b21b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9839499072cebd19a8c5cc2a3734adf60b06b21b/comments", "author": null, "committer": null, "parents": [{"sha": "c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5f651bf3ff1ec27c25ebdcd14d55bc125c020a4"}], "stats": {"total": 486, "additions": 327, "deletions": 159}, "files": [{"sha": "e711ff44d4dd556ce2c75b489fa63f89f354dfc4", "filename": "libjava/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=9839499072cebd19a8c5cc2a3734adf60b06b21b", "patch": "@@ -1,3 +1,28 @@\n+2000-11-17  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/lang/natString.cc: Include Locale.h.\n+\t(toUpperCase): Added `locale' argument.  Handle locale\n+\tsensitivity.\n+\t(toLowerCase): Added `locale' argument.  Handle locale\n+\tsensitivity.\n+\t(ESSET, CAPITAL_S, SMALL_I, CAPITAL_I_WITH_DOT, SMALL_DOTLESS_I,\n+\tCAPITAL_I): New defines.\n+\t* java/lang/String.java (CASE_INSENSITIVE_ORDER): Now public and\n+\tfinal.\n+\tImport Locale.\n+\t(toUpperCase, toLowerCase): New methods.  Variants which accept\n+\tlocale now native.\n+\n+\t* java/lang/ExceptionInInitializerError.java (printStackTrace):\n+\tNew methods.\n+\n+\t* java/util/PropertyPermission.java: Re-merged from Classpath.\n+\n+\t* java/text/RuleBasedCollator.java (getCollationElementIterator):\n+\tNew method.\n+\t* java/text/StringCharacterIterator.java: Reindented.\n+\t(setText): New method.\n+\n 2000-11-17  Mark Wielaar <mark@klomp.org>\n \n \tMerge with Classpath (changes by Bryce McKinlay)"}, {"sha": "0aad2fc89eaf200c67b9accaf257904db22173c5", "filename": "libjava/java/lang/ExceptionInInitializerError.java", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Flang%2FExceptionInInitializerError.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Flang%2FExceptionInInitializerError.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FExceptionInInitializerError.java?ref=9839499072cebd19a8c5cc2a3734adf60b06b21b", "patch": "@@ -1,15 +1,17 @@\n // ExceptionInInitializerError.java\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n This software is copyrighted work licensed under the terms of the\n Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n- \n+\n package java.lang;\n- \n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n /**\n  * @author Tom Tromey <tromey@cygnus.com>\n  * @date October 1, 1998 \n@@ -45,6 +47,21 @@ public Throwable getException ()\n     return exception;\n   }\n \n+  public void printStackTrace ()\n+  {\n+    exception.printStackTrace ();\n+  }\n+\n+  public void printStackTrace (PrintStream ps)\n+  {\n+    exception.printStackTrace (ps);\n+  }\n+\n+  public void printStackTrace (PrintWriter pw)\n+  {\n+    exception.printStackTrace (pw);\n+  }\n+\n   // The exception that caused this error.\n   private Throwable exception;\n }"}, {"sha": "22e11530f77c24f2d387a1deaaa09b2a2efacdd5", "filename": "libjava/java/lang/String.java", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=9839499072cebd19a8c5cc2a3734adf60b06b21b", "patch": "@@ -11,6 +11,7 @@\n import java.io.Serializable;\n import java.lang.Comparable;\n import java.util.Comparator;\n+import java.util.Locale;\n \n /**\n  * @author Per Bothner <bothner@cygnus.com>\n@@ -31,13 +32,13 @@ public final class String implements Serializable, Comparable\n   // but it will avoid showing up as a discrepancy when comparing SUIDs.\n   private static final long serialVersionUID = -6849794470754667710L;\n \n-  static Comparator CASE_INSENSITIVE_ORDER = new Comparator()\n+  public static final Comparator CASE_INSENSITIVE_ORDER = new Comparator()\n+  {\n+    public int compare (Object o1, Object o2)\n     {\n-      public int compare (Object o1, Object o2)\n-      {\n-        return ((String) o1).compareToIgnoreCase ((String) o2);\n-      }\n-    };\n+      return ((String) o1).compareToIgnoreCase ((String) o2);\n+    }\n+  };\n \n   public String ()\n   {\n@@ -276,9 +277,26 @@ public String substring (int beginIndex)\n \n   public native String replace (char oldChar, char newChar);\n \n-  public native String toLowerCase ();\n+  public native String toLowerCase (Locale locale);\n+  public native String toUpperCase (Locale locale);\n+\n+  public String toLowerCase ()\n+  {\n+    // The JDK is a bit confused about what to do here.  If we pass in\n+    // the default Locale then special Locale handling might be\n+    // invoked.  However, the docs also say that Character.toLowerCase\n+    // rules here.  We go with the latter.\n+    return toLowerCase (null);\n+  }\n \n-  public native String toUpperCase ();\n+  public String toUpperCase ()\n+  {\n+    // The JDK is a bit confused about what to do here.  If we pass in\n+    // the default Locale then special Locale handling might be\n+    // invoked.  However, the docs also say that Character.toLowerCase\n+    // rules here.  We go with the latter.\n+    return toUpperCase (null);\n+  }\n \n   public native String trim ();\n "}, {"sha": "c05aeb95a3971ef49d96ec19dd8cf16c25104652", "filename": "libjava/java/lang/natString.cc", "status": "modified", "additions": 83, "deletions": 12, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=9839499072cebd19a8c5cc2a3734adf60b06b21b", "patch": "@@ -24,6 +24,7 @@ details.  */\n #include <java/io/OutputStreamWriter.h>\n #include <java/io/ByteArrayInputStream.h>\n #include <java/io/InputStreamReader.h>\n+#include <java/util/Locale.h>\n #include <gnu/gcj/convert/UnicodeToBytes.h>\n #include <gnu/gcj/convert/BytesToUnicode.h>\n #include <jvm.h>\n@@ -33,6 +34,14 @@ static int strhash_count = 0;  /* Number of slots used in strhash. */\n static int strhash_size = 0;  /* Number of slots available in strhash.\n                                * Assumed be power of 2! */\n \n+// Some defines used by toUpperCase / toLowerCase.\n+#define ESSET     0x00df\n+#define CAPITAL_S 0x0053\n+#define SMALL_I   0x0069\n+#define CAPITAL_I_WITH_DOT 0x0130\n+#define SMALL_DOTLESS_I    0x0131\n+#define CAPITAL_I 0x0049\n+\n #define DELETED_STRING ((jstring)(~0))\n #define SET_STRING_IS_INTERNED(STR) /* nothing */\n \n@@ -755,16 +764,32 @@ java::lang::String::replace (jchar oldChar, jchar newChar)\n }\n \n jstring\n-java::lang::String::toLowerCase ()\n+java::lang::String::toLowerCase (java::util::Locale *locale)\n {\n   jint i;\n   jchar* chrs = JvGetStringChars(this);\n   jchar ch;\n+\n+  bool handle_tr = false;\n+  if (locale != NULL)\n+    {\n+      String *lang = locale->getLanguage ();\n+      if (lang->length () == 2\n+\t  && lang->charAt (0) == 't'\n+\t  && lang->charAt (1) == 'r')\n+\thandle_tr = true;\n+    }\n+\n   for (i = 0;  ;  i++)\n     {\n       if (i == count)\n \treturn this;\n       jchar origChar = chrs[i];\n+\n+      if (handle_tr && (origChar == CAPITAL_I\n+\t\t\t|| origChar == CAPITAL_I_WITH_DOT))\n+\tbreak;\n+\n       ch = java::lang::Character::toLowerCase(origChar);\n       if (ch != origChar)\n \tbreak;\n@@ -776,34 +801,80 @@ java::lang::String::toLowerCase ()\n   *dPtr++ = ch;  i++;\n   for (; i < count;  i++)\n     {\n-      *dPtr++ = java::lang::Character::toLowerCase(chrs[i]);\n+      if (handle_tr && chrs[i] == CAPITAL_I)\n+\t*dPtr++ = SMALL_DOTLESS_I;\n+      else if (handle_tr && chrs[i] == CAPITAL_I_WITH_DOT)\n+\t*dPtr++ = SMALL_I;\n+      else\n+\t*dPtr++ = java::lang::Character::toLowerCase(chrs[i]);\n     }\n   return result;\n }\n \n jstring\n-java::lang::String::toUpperCase ()\n+java::lang::String::toUpperCase (java::util::Locale *locale)\n {\n   jint i;\n   jchar* chrs = JvGetStringChars(this);\n   jchar ch;\n+\n+  // When handling a specific locale there might be special rules.\n+  // Currently all existing rules are simply handled inline, as there\n+  // are only two and they are documented in the online 1.2 docs.\n+  bool handle_esset = locale != NULL;\n+  bool handle_tr = false;\n+  if (locale != NULL)\n+    {\n+      String *lang = locale->getLanguage ();\n+      if (lang->length () == 2\n+\t  && lang->charAt (0) == 't'\n+\t  && lang->charAt (1) == 'r')\n+\thandle_tr = true;\n+    }\n+\n+  int new_count = count;\n+  bool new_string = false;\n   for (i = 0;  ;  i++)\n     {\n       if (i == count)\n-\treturn this;\n+\tbreak;\n       jchar origChar = chrs[i];\n-      ch = java::lang::Character::toUpperCase(origChar);\n-      if (ch != origChar)\n+\n+      if (handle_esset && origChar == ESSET)\n+\t{\n+\t  ++new_count;\n+\t  new_string = true;\n+\t}\n+      else if (handle_tr && (origChar == SMALL_I\n+\t\t\t     || origChar == SMALL_DOTLESS_I))\n+\tnew_string = true;\n+      else\n+\t{\n+\t  ch = java::lang::Character::toUpperCase(origChar);\n+\t  if (ch != origChar)\n+\t    new_string = true;\n+\t}\n+\n+      if (new_string && ! handle_esset)\n \tbreak;\n     }\n-  jstring result = JvAllocString(count);\n+  if (! new_string)\n+    return this;\n+  jstring result = JvAllocString(new_count);\n   jchar *dPtr = JvGetStringChars (result);\n-  for (int j = 0;  j < i;  j++)\n-    *dPtr++ = chrs[j];\n-  *dPtr++ = ch;  i++;\n-  for (; i < count;  i++)\n+  for (i = 0; i < count;  i++)\n     {\n-      *dPtr++ = java::lang::Character::toUpperCase(chrs[i]);\n+      if (handle_esset && chrs[i] == ESSET)\n+\t{\n+\t  *dPtr++ = CAPITAL_S;\n+\t  *dPtr++ = CAPITAL_S;\n+\t}\n+      else if (handle_tr && chrs[i] == SMALL_I)\n+\t*dPtr++ = CAPITAL_I_WITH_DOT;\n+      else if (handle_tr && chrs[i] == SMALL_DOTLESS_I)\n+\t*dPtr++ = CAPITAL_I;\n+      else\n+\t*dPtr++ = java::lang::Character::toUpperCase(chrs[i]);\n     }\n   return result;\n }"}, {"sha": "dde09572923f7297f2d86379f63c48560505eafe", "filename": "libjava/java/text/RuleBasedCollator.java", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java?ref=9839499072cebd19a8c5cc2a3734adf60b06b21b", "patch": "@@ -176,6 +176,17 @@ public CollationElementIterator getCollationElementIterator (String source)\n     return new CollationElementIterator (expand.toString(), this);\n   }\n \n+  public CollationElementIterator getCollationElementIterator (CharacterIterator source)\n+  {\n+    StringBuffer expand = new StringBuffer ();\n+    for (char c = source.first ();\n+\t c != CharacterIterator.DONE;\n+\t c = source.next ())\n+      decomposeCharacter (c, expand);\n+\n+    return new CollationElementIterator (expand.toString(), this);\n+  }\n+\n   public CollationKey getCollationKey (String source)\n   {\n     return new CollationKey (getCollationElementIterator (source), source,"}, {"sha": "487b09c8220109ad74062dd1057684f956d8e36c", "filename": "libjava/java/text/StringCharacterIterator.java", "status": "modified", "additions": 89, "deletions": 76, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Ftext%2FStringCharacterIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Ftext%2FStringCharacterIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FStringCharacterIterator.java?ref=9839499072cebd19a8c5cc2a3734adf60b06b21b", "patch": "@@ -22,108 +22,121 @@\n public final class StringCharacterIterator implements CharacterIterator\n {\n   public Object clone ()\n-    {\n-      return (Object) new StringCharacterIterator (text, begin, end, pos);\n-    }\n+  {\n+    return (Object) new StringCharacterIterator (text, begin, end, pos);\n+  }\n \n   public char current ()\n-    {\n-      // This follows JDK 1.2 semantics and not 1.1 semantics.\n-      // In 1.1 we would throw an exception if begin==end.\n-      return (pos < end) ? text.charAt(pos) : CharacterIterator.DONE;\n-    }\n+  {\n+    // This follows JDK 1.2 semantics and not 1.1 semantics.\n+    // In 1.1 we would throw an exception if begin==end.\n+    return (pos < end) ? text.charAt(pos) : CharacterIterator.DONE;\n+  }\n \n   public boolean equals (Object obj)\n-    {\n-      if (! (obj instanceof StringCharacterIterator))\n-\treturn false;\n-      StringCharacterIterator sci = (StringCharacterIterator) obj;\n-      // The spec says \"the same text\".  We take this to mean equals,\n-      // not ==.\n-      return (pos == sci.pos\n-\t      && begin == sci.begin\n-\t      && end == sci.end\n-\t      && text.equals(sci.text));\n-    }\n+  {\n+    if (! (obj instanceof StringCharacterIterator))\n+      return false;\n+    StringCharacterIterator sci = (StringCharacterIterator) obj;\n+    // The spec says \"the same text\".  We take this to mean equals,\n+    // not ==.\n+    return (pos == sci.pos\n+\t    && begin == sci.begin\n+\t    && end == sci.end\n+\t    && text.equals(sci.text));\n+  }\n \n   public char first ()\n-    {\n-      pos = begin;\n-      return current ();\n-    }\n+  {\n+    pos = begin;\n+    return current ();\n+  }\n \n   public int getBeginIndex ()\n-    {\n-      return begin;\n-    }\n+  {\n+    return begin;\n+  }\n \n   public int getEndIndex ()\n-    {\n-      return end;\n-    }\n+  {\n+    return end;\n+  }\n \n   public int getIndex ()\n-    {\n-      return pos;\n-    }\n+  {\n+    return pos;\n+  }\n \n   public int hashCode ()\n-    {\n-      // FIXME: this is a terrible hash code.  Find a better one.\n-      return text.hashCode() + pos + begin + end;\n-    }\n+  {\n+    // FIXME: this is a terrible hash code.  Find a better one.\n+    return text.hashCode() + pos + begin + end;\n+  }\n \n   public char last ()\n-    {\n-      pos = end;\n-      return current ();\n-    }\n+  {\n+    pos = end;\n+    return current ();\n+  }\n \n   public char next ()\n-    {\n-      if (pos == end)\n-\treturn CharacterIterator.DONE;\n-      ++pos;\n-      return current ();\n-    }\n+  {\n+    if (pos == end)\n+      return CharacterIterator.DONE;\n+    ++pos;\n+    return current ();\n+  }\n \n   public char previous ()\n-    {\n-      if (pos == begin)\n-\treturn CharacterIterator.DONE;\n-      --pos;\n-      return current ();\n-    }\n+  {\n+    if (pos == begin)\n+      return CharacterIterator.DONE;\n+    --pos;\n+    return current ();\n+  }\n \n   public char setIndex (int idx)\n-    {\n-      // In 1.1 we would throw an error if `idx == end'.\n-      if (idx < begin || idx > end)\n-\tthrow new IllegalArgumentException ();\n-      pos = idx;\n-      return current ();\n-    }\n+  {\n+    // In 1.1 we would throw an error if `idx == end'.\n+    if (idx < begin || idx > end)\n+      throw new IllegalArgumentException ();\n+    pos = idx;\n+    return current ();\n+  }\n \n   public StringCharacterIterator (String text)\n-    {\n-      this (text, 0, text.length(), 0);\n-    }\n+  {\n+    this (text, 0, text.length(), 0);\n+  }\n+\n   public StringCharacterIterator (String text, int pos)\n-    {\n-      this (text, 0, text.length(), pos);\n-    }\n+  {\n+    this (text, 0, text.length(), pos);\n+  }\n+\n   public StringCharacterIterator (String text, int begin, int end, int pos)\n-    {\n-      if (begin < 0 || begin > end || end > text.length()\n-\t  // In 1.1 we would also throw if `pos == end'.\n-\t  || pos < begin || pos > end)\n-\tthrow new IllegalArgumentException ();\n-\n-      this.text = text;\n-      this.begin = begin;\n-      this.end = end;\n-      this.pos = pos;\n-    }\n+  {\n+    if (begin < 0 || begin > end || end > text.length()\n+\t// In 1.1 we would also throw if `pos == end'.\n+\t|| pos < begin || pos > end)\n+      throw new IllegalArgumentException ();\n+\n+    this.text = text;\n+    this.begin = begin;\n+    this.end = end;\n+    this.pos = pos;\n+  }\n+\n+  // The online 1.2 docs say that this is \"package visible\" in the\n+  // method description, but they also say it is public.  We choose\n+  // the latter for compatibility with the actual implementation.\n+  public void setText (String text)\n+  {\n+    this.text = text;\n+    this.begin = 0;\n+    this.end = text.length ();\n+    this.pos = 0;\n+  }\n \n   // String to iterate over.\n   private String text;"}, {"sha": "57f5f08c928634fa6facaa82b4bf7162db25d17c", "filename": "libjava/java/util/PropertyPermission.java", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Futil%2FPropertyPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9839499072cebd19a8c5cc2a3734adf60b06b21b/libjava%2Fjava%2Futil%2FPropertyPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FPropertyPermission.java?ref=9839499072cebd19a8c5cc2a3734adf60b06b21b", "patch": "@@ -1,13 +1,13 @@\n /* java.util.PropertyPermission\n-   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -68,13 +68,13 @@ public final class PropertyPermission extends BasicPermission\n \n   private static final long serialVersionUID = 885438825399942851L;\n \n-  private static final int READ  = 1;\n+  private static final int READ = 1;\n   private static final int WRITE = 2;\n   private transient int actions;\n \n-  private static String actionStrings[] = \n-  { \n-    \"\", \"read\", \"write\", \"read,write\" \n+  private static final String actionStrings[] =\n+  {\n+    \"\", \"read\", \"write\", \"read,write\"\n   };\n \n   /**\n@@ -109,7 +109,7 @@ private void setActions(String actions)\n \telse if (\"write\".equals(anAction))\n \t  this.actions |= WRITE;\n \telse\n-\t  throw new IllegalArgumentException(\"illegal action \"+anAction);\n+\t  throw new IllegalArgumentException(\"illegal action \" + anAction);\n       }\n   }\n \n@@ -127,7 +127,7 @@ public boolean implies(Permission p)\n   {\n     if (!(p instanceof PropertyPermission))\n       return false;\n-    \n+\n     // We have to check the actions.\n     PropertyPermission pp = (PropertyPermission) p;\n     if ((pp.actions & ~actions) != 0)\n@@ -150,11 +150,25 @@ public String getActions()\n     return actionStrings[actions];\n   }\n \n+  /**\n+   * Check to see whether this object is the same as another\n+   * PropertyPermission object.\n+   *\n+   * @param obj The other object\n+   */\n+  public boolean equals (Object obj)\n+  {\n+    if (! (obj instanceof PropertyPermission))\n+      return false;\n+    PropertyPermission p = (PropertyPermission) obj;\n+    return actions == p.actions && super.equals (p);\n+  }\n+\n   /**\n    * Reads an object from the stream. This converts the external to the\n    * internal representation.\n    */\n-  private void readObject(ObjectInputStream s) \n+  private void readObject(ObjectInputStream s)\n     throws IOException, ClassNotFoundException\n   {\n     ObjectInputStream.GetField fields = s.readFields();\n@@ -165,8 +179,7 @@ private void readObject(ObjectInputStream s)\n    * Writes an object to the stream. This converts the internal to the\n    * external representation.\n    */\n-  private void writeObject(ObjectOutputStream s) \n-    throws IOException\n+  private void writeObject(ObjectOutputStream s) throws IOException\n   {\n     ObjectOutputStream.PutField fields = s.putFields();\n     fields.put(\"actions\", getActions());\n@@ -178,61 +191,61 @@ private void writeObject(ObjectOutputStream s)\n    * PropertyPermission objects.\n    * @return a new empty PermissionCollection.  \n    */\n-  public PermissionCollection newPermissionCollection() \n+  public PermissionCollection newPermissionCollection()\n   {\n-    return new PermissionCollection() \n+    return new PermissionCollection()\n+    {\n+      Hashtable permissions = new Hashtable();\n+      int allActions = 0;\n+\n+      public void add(Permission permission)\n       {\n-\tHashtable permissions = new Hashtable();\n-\tint allActions = 0;\n-\t\n-\tpublic void add(Permission permission) \n-\t  {\n-\t    if (isReadOnly())\n-\t      throw new IllegalStateException(\"readonly\");\n-\n-\t    // also check that permission is of correct type.\n-\t    PropertyPermission pp = (PropertyPermission) permission;\n-\t    String name = pp.getName();\n-\t    if (name.equals(\"*\"))\n-\t      allActions |= pp.actions;\n-\t    permissions.put(name, pp);\n-\t  }\n-\t\n-\tpublic boolean implies(Permission permission)\n-\t  {\n-\t    if (!(permission instanceof PropertyPermission))\n-\t      return false;\n+\tif (isReadOnly())\n+\t  throw new IllegalStateException(\"readonly\");\n+\n+\t// also check that permission is of correct type.\n+\tPropertyPermission pp = (PropertyPermission) permission;\n+\tString name = pp.getName();\n+\tif (name.equals(\"*\"))\n+\t  allActions |= pp.actions;\n+\tpermissions.put(name, pp);\n+      }\n \n-\t    PropertyPermission toImply = (PropertyPermission) permission;\n-\t    if ((toImply.actions & ~allActions) == 0)\n-\t      return true;\n+      public boolean implies(Permission permission)\n+      {\n+\tif (!(permission instanceof PropertyPermission))\n+\t  return false;\n \n-\t    String name = toImply.getName();\n-\t    if (name.equals(\"*\"))\n-\t      return false;\n+\tPropertyPermission toImply = (PropertyPermission) permission;\n+\tif ((toImply.actions & ~allActions) == 0)\n+\t  return true;\n \n-\t    int prefixLength = name.length();\n-\t    if (name.endsWith(\"*\"))\n-\t      prefixLength -= 2;\n-\n-\t    while (true) {\n-\t      PropertyPermission forName = \n-\t\t(PropertyPermission) permissions.get(name);\n-\t      if (forName != null\n-\t\t  && (toImply.actions & ~forName.actions) == 0)\n-\t\treturn true;\n-\n-\t      prefixLength = name.lastIndexOf('.', prefixLength);\n-\t      if (prefixLength < 0)\n-\t\treturn false;\n-\t      name = name.substring(0, prefixLength + 1) + '*';\n-\t    }\n-\t  }\n-\t\n-\tpublic Enumeration elements()\n+\tString name = toImply.getName();\n+\tif (name.equals(\"*\"))\n+\t  return false;\n+\n+\tint prefixLength = name.length();\n+\tif (name.endsWith(\"*\"))\n+\t  prefixLength -= 2;\n+\n+\twhile (true)\n \t  {\n-\t    return permissions.elements();\n+\t    PropertyPermission forName =\n+\t      (PropertyPermission) permissions.get(name);\n+\t    if (forName != null && (toImply.actions & ~forName.actions) == 0)\n+\t      return true;\n+\n+\t    prefixLength = name.lastIndexOf('.', prefixLength);\n+\t    if (prefixLength < 0)\n+\t      return false;\n+\t    name = name.substring(0, prefixLength + 1) + '*';\n \t  }\n-      };\n+      }\n+\n+      public Enumeration elements()\n+      {\n+\treturn permissions.elements();\n+      }\n+    };\n   }\n }"}]}