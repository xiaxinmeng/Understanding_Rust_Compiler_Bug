{"sha": "5440c0e74197052ca981f29b74df9f187f88385e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ0MGMwZTc0MTk3MDUyY2E5ODFmMjliNzRkZjlmMTg3Zjg4Mzg1ZQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-02-03T15:00:33Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-02-03T15:00:33Z"}, "message": "re PR debug/42896 (Random debug generation differences, bootstrap fails)\n\n2010-02-03  Alexandre Oliva  <aoliva@redhat.com>\n\n\tPR debug/42896\n\t* cselib.h (struct cselib_val_struct): Add uid.  Rename value to\n\thash.\n\t(cselib_reset_table): Renamed from...\n\t(cselib_reset_table_with_next_value): ... this.\n\t(cselib_get_next_uid): Renamed from...\n\t(cselib_get_next_unknown_value): ... this.\n\t* cselib.c (next_uid): Renamed from...\n\t(next_unknown_value): ... this.\n\t(cselib_clear_table): Adjust.\n\t(cselib_reset_table): Adjust.  Renamed from...\n\t(cselib_reset_table_with_next_value): ... this.\n\t(cselib_get_next_uid): Adjust.  Renamed from...\n\t(cselib_get_next_unknown_value): ... this.\n\t(get_value_hash): Use hash.\n\t(cselib_hash_rtx): Likewise.\n\t(new_cselib_val): Adjust.  Set and dump uid.\n\t(cselib_lookup_mem): Pass next_uid as hash.\n\t(cselib_subst_to_values): Likewise.\n\t(cselib_log_lookup): Dump uid.\n\t(cselib_lookup): Pass next_uid as hash.  Adjust.\n\t(cselib_process_insn): Adjust.\n\t(cselib_init): Initialize next_uid.\n\t(cselib_finish): Adjust.\n\t(dump_cselib_table): Likewise.\n\t* dse.c (canon_address): Dump value uid.\n\t* print-rtl.c (print_rtx): Print value uid.\n\t* var-tracking.c (VARIABLE_HASH_VAL): Dropped.\n\t(dvuid): New type.\n\t(dv_uid): New function, sort of renamed from...\n\t(dv_htab_hash): ... this, reimplemented in terms of it and...\n\t(dv_uid2hash): ... this.  New.\n\t(variable_htab_eq): Drop excess assertions.\n\t(tie_break_pointers): Removed.\n\t(canon_value_cmp): Compare uids.\n\t(variable_post_merge_New_vals): Print uids.\n\t(vt_add_function_parameters): Adjust.\n\t(vt_initialize): Reset table.  Adjust.\n\nFrom-SVN: r156468", "tree": {"sha": "d1d02dd20ec7ed6126855d129131396ddfb171df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1d02dd20ec7ed6126855d129131396ddfb171df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5440c0e74197052ca981f29b74df9f187f88385e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5440c0e74197052ca981f29b74df9f187f88385e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5440c0e74197052ca981f29b74df9f187f88385e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5440c0e74197052ca981f29b74df9f187f88385e/comments", "author": null, "committer": null, "parents": [{"sha": "e3c70387dc0fdf85f15dab9b1499148a039841ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3c70387dc0fdf85f15dab9b1499148a039841ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3c70387dc0fdf85f15dab9b1499148a039841ea"}], "stats": {"total": 210, "additions": 118, "deletions": 92}, "files": [{"sha": "180d60431a1c0db490a2efaaab57cd92c212b738", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5440c0e74197052ca981f29b74df9f187f88385e", "patch": "@@ -1,3 +1,44 @@\n+2010-02-03  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/42896\n+\t* cselib.h (struct cselib_val_struct): Add uid.  Rename value to\n+\thash.\n+\t(cselib_reset_table): Renamed from...\n+\t(cselib_reset_table_with_next_value): ... this.\n+\t(cselib_get_next_uid): Renamed from...\n+\t(cselib_get_next_unknown_value): ... this.\n+\t* cselib.c (next_uid): Renamed from...\n+\t(next_unknown_value): ... this.\n+\t(cselib_clear_table): Adjust.\n+\t(cselib_reset_table): Adjust.  Renamed from...\n+\t(cselib_reset_table_with_next_value): ... this.\n+\t(cselib_get_next_uid): Adjust.  Renamed from...\n+\t(cselib_get_next_unknown_value): ... this.\n+\t(get_value_hash): Use hash.\n+\t(cselib_hash_rtx): Likewise.\n+\t(new_cselib_val): Adjust.  Set and dump uid.\n+\t(cselib_lookup_mem): Pass next_uid as hash.\n+\t(cselib_subst_to_values): Likewise.\n+\t(cselib_log_lookup): Dump uid.\n+\t(cselib_lookup): Pass next_uid as hash.  Adjust.\n+\t(cselib_process_insn): Adjust.\n+\t(cselib_init): Initialize next_uid.\n+\t(cselib_finish): Adjust.\n+\t(dump_cselib_table): Likewise.\n+\t* dse.c (canon_address): Dump value uid.\n+\t* print-rtl.c (print_rtx): Print value uid.\n+\t* var-tracking.c (VARIABLE_HASH_VAL): Dropped.\n+\t(dvuid): New type.\n+\t(dv_uid): New function, sort of renamed from...\n+\t(dv_htab_hash): ... this, reimplemented in terms of it and...\n+\t(dv_uid2hash): ... this.  New.\n+\t(variable_htab_eq): Drop excess assertions.\n+\t(tie_break_pointers): Removed.\n+\t(canon_value_cmp): Compare uids.\n+\t(variable_post_merge_New_vals): Print uids.\n+\t(vt_add_function_parameters): Adjust.\n+\t(vt_initialize): Reset table.  Adjust.\n+\n 2010-02-03  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/42944"}, {"sha": "deac835f9333e541a4fee9b640484895be6f9775", "filename": "gcc/cselib.c", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=5440c0e74197052ca981f29b74df9f187f88385e", "patch": "@@ -89,8 +89,8 @@ static htab_t cselib_hash_table;\n    It is used in new_elt_loc_list to set SETTING_INSN.  */\n static rtx cselib_current_insn;\n \n-/* Every new unknown value gets a unique number.  */\n-static unsigned int next_unknown_value;\n+/* The unique id that the next create value will take.  */\n+static unsigned int next_uid;\n \n /* The number of registers we had when the varrays were last resized.  */\n static unsigned int cselib_nregs;\n@@ -227,14 +227,14 @@ unchain_one_value (cselib_val *v)\n void\n cselib_clear_table (void)\n {\n-  cselib_reset_table_with_next_value (0);\n+  cselib_reset_table (1);\n }\n \n /* Remove all entries from the hash table, arranging for the next\n    value to be numbered NUM.  */\n \n void\n-cselib_reset_table_with_next_value (unsigned int num)\n+cselib_reset_table (unsigned int num)\n {\n   unsigned int i;\n \n@@ -250,17 +250,17 @@ cselib_reset_table_with_next_value (unsigned int num)\n \n   n_useless_values = 0;\n \n-  next_unknown_value = num;\n+  next_uid = num;\n \n   first_containing_mem = &dummy_val;\n }\n \n /* Return the number of the next value that will be generated.  */\n \n unsigned int\n-cselib_get_next_unknown_value (void)\n+cselib_get_next_uid (void)\n {\n-  return next_unknown_value;\n+  return next_uid;\n }\n \n /* The equality test for our hash table.  The first argument ENTRY is a table\n@@ -306,7 +306,7 @@ static hashval_t\n get_value_hash (const void *entry)\n {\n   const cselib_val *const v = (const cselib_val *) entry;\n-  return v->value;\n+  return v->hash;\n }\n \n /* Return true if X contains a VALUE rtx.  If ONLY_USELESS is set, we\n@@ -715,7 +715,7 @@ cselib_hash_rtx (rtx x, int create)\n       if (! e)\n \treturn 0;\n \n-      return e->value;\n+      return e->hash;\n \n     case DEBUG_EXPR:\n       hash += ((unsigned) DEBUG_EXPR << 7)\n@@ -866,13 +866,15 @@ cselib_hash_rtx (rtx x, int create)\n    value is MODE.  */\n \n static inline cselib_val *\n-new_cselib_val (unsigned int value, enum machine_mode mode, rtx x)\n+new_cselib_val (unsigned int hash, enum machine_mode mode, rtx x)\n {\n   cselib_val *e = (cselib_val *) pool_alloc (cselib_val_pool);\n \n-  gcc_assert (value);\n+  gcc_assert (hash);\n+  gcc_assert (next_uid);\n \n-  e->value = value;\n+  e->hash = hash;\n+  e->uid = next_uid++;\n   /* We use an alloc pool to allocate this RTL construct because it\n      accounts for about 8% of the overall memory usage.  We know\n      precisely when we can have VALUE RTXen (when cselib is active)\n@@ -889,7 +891,7 @@ new_cselib_val (unsigned int value, enum machine_mode mode, rtx x)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"cselib value %u \", value);\n+      fprintf (dump_file, \"cselib value %u:%u \", e->uid, hash);\n       if (flag_dump_noaddr || flag_dump_unnumbered)\n \tfputs (\"# \", dump_file);\n       else\n@@ -957,10 +959,10 @@ cselib_lookup_mem (rtx x, int create)\n   if (! create)\n     return 0;\n \n-  mem_elt = new_cselib_val (++next_unknown_value, mode, x);\n+  mem_elt = new_cselib_val (next_uid, mode, x);\n   add_mem_for_addr (addr, mem_elt, x);\n   slot = htab_find_slot_with_hash (cselib_hash_table, wrap_constant (mode, x),\n-\t\t\t\t   mem_elt->value, INSERT);\n+\t\t\t\t   mem_elt->hash, INSERT);\n   *slot = mem_elt;\n   return mem_elt;\n }\n@@ -1393,7 +1395,7 @@ cselib_subst_to_values (rtx x)\n \t{\n \t  /* This happens for autoincrements.  Assign a value that doesn't\n \t     match any other.  */\n-\t  e = new_cselib_val (++next_unknown_value, GET_MODE (x), x);\n+\t  e = new_cselib_val (next_uid, GET_MODE (x), x);\n \t}\n       return e->val_rtx;\n \n@@ -1409,7 +1411,7 @@ cselib_subst_to_values (rtx x)\n     case PRE_DEC:\n     case POST_MODIFY:\n     case PRE_MODIFY:\n-      e = new_cselib_val (++next_unknown_value, GET_MODE (x), x);\n+      e = new_cselib_val (next_uid, GET_MODE (x), x);\n       return e->val_rtx;\n \n     default:\n@@ -1463,7 +1465,9 @@ cselib_log_lookup (rtx x, cselib_val *ret)\n     {\n       fputs (\"cselib lookup \", dump_file);\n       print_inline_rtx (dump_file, x, 2);\n-      fprintf (dump_file, \" => %u\\n\", ret ? ret->value : 0);\n+      fprintf (dump_file, \" => %u:%u\\n\",\n+\t       ret ? ret->uid : 0,\n+\t       ret ? ret->hash : 0);\n     }\n \n   return ret;\n@@ -1510,7 +1514,7 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n \t    max_value_regs = n;\n \t}\n \n-      e = new_cselib_val (++next_unknown_value, GET_MODE (x), x);\n+      e = new_cselib_val (next_uid, GET_MODE (x), x);\n       e->locs = new_elt_loc_list (e->locs, x);\n       if (REG_VALUES (i) == 0)\n \t{\n@@ -1521,7 +1525,7 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n \t  REG_VALUES (i) = new_elt_list (REG_VALUES (i), NULL);\n \t}\n       REG_VALUES (i)->next = new_elt_list (REG_VALUES (i)->next, e);\n-      slot = htab_find_slot_with_hash (cselib_hash_table, x, e->value, INSERT);\n+      slot = htab_find_slot_with_hash (cselib_hash_table, x, e->hash, INSERT);\n       *slot = e;\n       return cselib_log_lookup (x, e);\n     }\n@@ -1961,7 +1965,7 @@ cselib_process_insn (rtx insn)\n \t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n \t  && MEM_VOLATILE_P (PATTERN (insn))))\n     {\n-      cselib_reset_table_with_next_value (next_unknown_value);\n+      cselib_reset_table (next_uid);\n       return;\n     }\n \n@@ -2057,6 +2061,7 @@ cselib_init (bool record_memory)\n   n_used_regs = 0;\n   cselib_hash_table = htab_create (31, get_value_hash,\n \t\t\t\t   entry_and_rtx_equal_p, NULL);\n+  next_uid = 1;\n }\n \n /* Called when the current user is done with cselib.  */\n@@ -2075,7 +2080,7 @@ cselib_finish (void)\n   used_regs = 0;\n   cselib_hash_table = 0;\n   n_useless_values = 0;\n-  next_unknown_value = 0;\n+  next_uid = 0;\n }\n \n /* Dump the cselib_val *X to FILE *info.  */\n@@ -2163,7 +2168,7 @@ dump_cselib_table (FILE *out)\n       print_inline_rtx (out, first_containing_mem->val_rtx, 2);\n       fputc ('\\n', out);\n     }\n-  fprintf (out, \"last unknown value %i\\n\", next_unknown_value);\n+  fprintf (out, \"next uid %i\\n\", next_uid);\n }\n \n #include \"gt-cselib.h\""}, {"sha": "75ff457bf2d5dd126daad05ab9f5645504d0c2bf", "filename": "gcc/cselib.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=5440c0e74197052ca981f29b74df9f187f88385e", "patch": "@@ -1,6 +1,7 @@\n /* Common subexpression elimination for GNU compiler.\n-   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n+   1998, 1999, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -21,7 +22,10 @@ along with GCC; see the file COPYING3.  If not see\n /* Describe a value.  */\n typedef struct GTY(()) cselib_val_struct {\n   /* The hash value.  */\n-  unsigned int value;\n+  unsigned int hash;\n+\n+  /* A unique id assigned to values.  */\n+  int uid;\n \n   /* A VALUE rtx that points back to this structure.  */\n   rtx val_rtx;\n@@ -81,8 +85,8 @@ extern rtx cselib_expand_value_rtx_cb (rtx, bitmap, int,\n extern rtx cselib_subst_to_values (rtx);\n extern void cselib_invalidate_rtx (rtx);\n \n-extern void cselib_reset_table_with_next_value (unsigned int);\n-extern unsigned int cselib_get_next_unknown_value (void);\n+extern void cselib_reset_table (unsigned int);\n+extern unsigned int cselib_get_next_uid (void);\n extern void cselib_preserve_value (cselib_val *);\n extern bool cselib_preserved_value_p (cselib_val *);\n extern void cselib_preserve_only_values (bool);"}, {"sha": "e72b998133e70f1d979e3bbc66f7a640f0eac5cf", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=5440c0e74197052ca981f29b74df9f187f88385e", "patch": "@@ -1199,8 +1199,8 @@ canon_address (rtx mem,\n       return false;\n     }\n   if (dump_file)\n-    fprintf (dump_file, \"  varying cselib base=%d offset = %d\\n\",\n-\t     (*base)->value, (int)*offset);\n+    fprintf (dump_file, \"  varying cselib base=%u:%u offset = %d\\n\",\n+\t     (*base)->uid, (*base)->hash, (int)*offset);\n   return true;\n }\n "}, {"sha": "52709da6ea0bab55b397f81671ae22b3d00cfd7e", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=5440c0e74197052ca981f29b74df9f187f88385e", "patch": "@@ -316,7 +316,7 @@ print_rtx (const_rtx in_rtx)\n #ifndef GENERATOR_FILE\n \t    cselib_val *val = CSELIB_VAL_PTR (in_rtx);\n \n-\t    fprintf (outfile, \" %i\", val->value);\n+\t    fprintf (outfile, \" %u:%u\", val->uid, val->hash);\n \t    dump_addr (outfile, \" @\", in_rtx);\n \t    dump_addr (outfile, \"/\", (void*)val);\n #endif"}, {"sha": "7fa75748a545d01724e71801b81c6068c6b1969d", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 37, "deletions": 61, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5440c0e74197052ca981f29b74df9f187f88385e/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=5440c0e74197052ca981f29b74df9f187f88385e", "patch": "@@ -345,9 +345,6 @@ typedef struct value_chain_def\n } *value_chain;\n typedef const struct value_chain_def *const_value_chain;\n \n-/* Hash function for DECL for VARIABLE_HTAB.  */\n-#define VARIABLE_HASH_VAL(decl) (DECL_UID (decl))\n-\n /* Pointer to the BB's information specific to variable tracking pass.  */\n #define VTI(BB) ((variable_tracking_info) (BB)->aux)\n \n@@ -820,13 +817,33 @@ dv_from_value (rtx value)\n   return dv;\n }\n \n-static inline hashval_t\n-dv_htab_hash (decl_or_value dv)\n+typedef unsigned int dvuid;\n+\n+/* Return the uid of DV.  */\n+\n+static inline dvuid\n+dv_uid (decl_or_value dv)\n {\n   if (dv_is_value_p (dv))\n-    return -(hashval_t)(CSELIB_VAL_PTR (dv_as_value (dv))->value);\n+    return CSELIB_VAL_PTR (dv_as_value (dv))->uid;\n   else\n-    return (VARIABLE_HASH_VAL (dv_as_decl (dv)));\n+    return DECL_UID (dv_as_decl (dv));\n+}\n+\n+/* Compute the hash from the uid.  */\n+\n+static inline hashval_t\n+dv_uid2hash (dvuid uid)\n+{\n+  return uid;\n+}\n+\n+/* The hash function for a mask table in a shared_htab chain.  */\n+\n+static inline hashval_t\n+dv_htab_hash (decl_or_value dv)\n+{\n+  return dv_uid2hash (dv_uid (dv));\n }\n \n /* The hash function for variable_htab, computes the hash value\n@@ -848,29 +865,7 @@ variable_htab_eq (const void *x, const void *y)\n   const_variable const v = (const_variable) x;\n   decl_or_value dv = CONST_CAST2 (decl_or_value, const void *, y);\n \n-  if (dv_as_opaque (v->dv) == dv_as_opaque (dv))\n-    return true;\n-\n-#if ENABLE_CHECKING\n-  {\n-    bool visv, dvisv;\n-\n-    visv = dv_is_value_p (v->dv);\n-    dvisv = dv_is_value_p (dv);\n-\n-    if (visv != dvisv)\n-      return false;\n-\n-    if (visv)\n-      gcc_assert (CSELIB_VAL_PTR (dv_as_value (v->dv))\n-\t\t  != CSELIB_VAL_PTR (dv_as_value (dv)));\n-    else\n-      gcc_assert (VARIABLE_HASH_VAL (dv_as_decl (v->dv))\n-\t\t  != VARIABLE_HASH_VAL (dv_as_decl (dv)));\n-  }\n-#endif\n-\n-  return false;\n+  return (dv_as_opaque (v->dv) == dv_as_opaque (dv));\n }\n \n /* Free the element of VARIABLE_HTAB (its type is struct variable_def).  */\n@@ -1151,23 +1146,6 @@ shared_hash_find (shared_hash vars, decl_or_value dv)\n   return shared_hash_find_1 (vars, dv, dv_htab_hash (dv));\n }\n \n-/* Determine a total order between two distinct pointers.  Compare the\n-   pointers as integral types if size_t is wide enough, otherwise\n-   resort to bitwise memory compare.  The actual order does not\n-   matter, we just need to be consistent, so endianness is\n-   irrelevant.  */\n-\n-static int\n-tie_break_pointers (const void *p1, const void *p2)\n-{\n-  gcc_assert (p1 != p2);\n-\n-  if (sizeof (size_t) >= sizeof (void*))\n-    return (size_t)p1 < (size_t)p2 ? -1 : 1;\n-  else\n-    return memcmp (&p1, &p2, sizeof (p1));\n-}\n-\n /* Return true if TVAL is better than CVAL as a canonival value.  We\n    choose lowest-numbered VALUEs, using the RTX address as a\n    tie-breaker.  The idea is to arrange them into a star topology,\n@@ -1181,9 +1159,7 @@ static inline bool\n canon_value_cmp (rtx tval, rtx cval)\n {\n   return !cval\n-    || CSELIB_VAL_PTR (tval)->value < CSELIB_VAL_PTR (cval)->value\n-    || (CSELIB_VAL_PTR (tval)->value == CSELIB_VAL_PTR (cval)->value\n-\t&& tie_break_pointers (tval, cval) < 0);\n+    || CSELIB_VAL_PTR (tval)->uid < CSELIB_VAL_PTR (cval)->uid;\n }\n \n static bool dst_can_be_shared;\n@@ -3563,8 +3539,8 @@ variable_post_merge_new_vals (void **slot, void *info)\n \t\t      cdv = dv_from_value (cval);\n \t\t      if (dump_file)\n \t\t\tfprintf (dump_file,\n-\t\t\t\t \"Created new value %i for reg %i\\n\",\n-\t\t\t\t v->value, REGNO (node->loc));\n+\t\t\t\t \"Created new value %u:%u for reg %i\\n\",\n+\t\t\t\t v->uid, v->hash, REGNO (node->loc));\n \t\t    }\n \n \t\t  var_reg_decl_set (*dfpm->permp, node->loc,\n@@ -7336,7 +7312,7 @@ vt_add_function_parameters (void)\n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n       cselib_preserve_only_values (true);\n-      cselib_reset_table_with_next_value (cselib_get_next_unknown_value ());\n+      cselib_reset_table (cselib_get_next_uid ());\n     }\n \n }\n@@ -7369,15 +7345,15 @@ vt_initialize (void)\n       rtx insn;\n       HOST_WIDE_INT pre, post = 0;\n       int count;\n-      unsigned int next_value_before = cselib_get_next_unknown_value ();\n-      unsigned int next_value_after = next_value_before;\n+      unsigned int next_uid_before = cselib_get_next_uid ();\n+      unsigned int next_uid_after = next_uid_before;\n \n       if (MAY_HAVE_DEBUG_INSNS)\n \t{\n \t  cselib_record_sets_hook = count_with_sets;\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"first value: %i\\n\",\n-\t\t     cselib_get_next_unknown_value ());\n+\t\t     cselib_get_next_uid ());\n \t}\n \n       /* Count the number of micro operations.  */\n@@ -7432,12 +7408,12 @@ vt_initialize (void)\n       if (MAY_HAVE_DEBUG_INSNS)\n \t{\n \t  cselib_preserve_only_values (false);\n-\t  next_value_after = cselib_get_next_unknown_value ();\n-\t  cselib_reset_table_with_next_value (next_value_before);\n+\t  next_uid_after = cselib_get_next_uid ();\n+\t  cselib_reset_table (next_uid_before);\n \t  cselib_record_sets_hook = add_with_sets;\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"first value: %i\\n\",\n-\t\t     cselib_get_next_unknown_value ());\n+\t\t     cselib_get_next_uid ());\n \t}\n \n       /* Add the micro-operations to the array.  */\n@@ -7496,8 +7472,8 @@ vt_initialize (void)\n       if (MAY_HAVE_DEBUG_INSNS)\n \t{\n \t  cselib_preserve_only_values (true);\n-\t  gcc_assert (next_value_after == cselib_get_next_unknown_value ());\n-\t  cselib_reset_table_with_next_value (next_value_after);\n+\t  gcc_assert (next_uid_after == cselib_get_next_uid ());\n+\t  cselib_reset_table (next_uid_after);\n \t  cselib_record_sets_hook = NULL;\n \t}\n     }"}]}