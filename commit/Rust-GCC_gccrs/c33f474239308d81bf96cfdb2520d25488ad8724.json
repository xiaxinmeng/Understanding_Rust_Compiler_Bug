{"sha": "c33f474239308d81bf96cfdb2520d25488ad8724", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMzZjQ3NDIzOTMwOGQ4MWJmOTZjZmRiMjUyMGQyNTQ4OGFkODcyNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-24T13:09:17Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-09-24T13:09:17Z"}, "message": "Add access through parameter derference tracking to modref\n\nre-add tracking of accesses which was unfinished in David's patch.\nAt the moment I only implemented tracking of the fact that access is based on\nderefernece of the parameter (so we track THIS pointers).\nPatch does not implement IPA propagation since it needs bit more work which\nI will post shortly: ipa-fnsummary needs to track when parameter points to\nlocal memory, summaries needs to be merged when function is inlined (because\njump functions are) and propagation needs to be turned into iterative dataflow\non SCC components.\n\nPatch also adds documentation of -fipa-modref and params that was left uncommited\nin my branch :(.\n\nEven without this change it does lead to nice increase of disambiguations\nfor cc1plus build.\n\nAlias oracle query stats:\n  refs_may_alias_p: 62758323 disambiguations, 72935683 queries\n  ref_maybe_used_by_call_p: 139511 disambiguations, 63654045 queries\n  call_may_clobber_ref_p: 23502 disambiguations, 29242 queries\n  nonoverlapping_component_refs_p: 0 disambiguations, 37654 queries\n  nonoverlapping_refs_since_match_p: 19417 disambiguations, 55555 must overlaps, 75721 queries\n  aliasing_component_refs_p: 54665 disambiguations, 752449 queries\n  TBAA oracle: 21917926 disambiguations 53054678 queries\n               15763411 are in alias set 0\n               10162238 queries asked about the same object\n               124 queries asked about the same alias set\n               0 access volatile\n               3681593 are dependent in the DAG\n               1529386 are aritificially in conflict with void *\n\nModref stats:\n  modref use: 8311 disambiguations, 32527 queries\n  modref clobber: 742126 disambiguations, 1036986 queries\n  1987054 tbaa queries (1.916182 per modref query)\n  125479 base compares (0.121004 per modref query)\n\nPTA query stats:\n  pt_solution_includes: 968314 disambiguations, 13609584 queries\n  pt_solutions_intersect: 1019136 disambiguations, 13147139 queries\n\nSo compared to\nhttps://gcc.gnu.org/pipermail/gcc-patches/2020-September/554605.html\nwe get 41% more use disambiguations (with similar number of queries) and 8% more\nclobber disambiguations.\n\nFor tramp3d:\nAlias oracle query stats:\n  refs_may_alias_p: 2052256 disambiguations, 2312703 queries\n  ref_maybe_used_by_call_p: 7122 disambiguations, 2089118 queries\n  call_may_clobber_ref_p: 234 disambiguations, 234 queries\n  nonoverlapping_component_refs_p: 0 disambiguations, 4299 queries\n  nonoverlapping_refs_since_match_p: 329 disambiguations, 10200 must overlaps, 10616 queries\n  aliasing_component_refs_p: 857 disambiguations, 34555 queries\n  TBAA oracle: 885546 disambiguations 1677080 queries\n               132105 are in alias set 0\n               469030 queries asked about the same object\n               0 queries asked about the same alias set\n               0 access volatile\n               190084 are dependent in the DAG\n               315 are aritificially in conflict with void *\n\nModref stats:\n  modref use: 426 disambiguations, 1881 queries\n  modref clobber: 10042 disambiguations, 16202 queries\n  19405 tbaa queries (1.197692 per modref query)\n  2775 base compares (0.171275 per modref query)\n\nPTA query stats:\n  pt_solution_includes: 313908 disambiguations, 526183 queries\n  pt_solutions_intersect: 130510 disambiguations, 416084 queries\n\nHere uses decrease by 4 disambiguations and clobber improve by 3.5%.  I think\nthe difference is caused by fact that gcc has much more alias set 0 accesses\noriginating from gimple and tree unions as I mentioned in original mail.\n\nAfter pushing out the IPA propagation I will re-add code to track offsets and\nsizes that further improve disambiguation. On tramp3d it enables a lot of DSE\nfor structure fields not acessed by uninlined function.\n\ngcc/\n\n\t* doc/invoke.texi: Document -fipa-modref, ipa-modref-max-bases,\n\tipa-modref-max-refs, ipa-modref-max-accesses, ipa-modref-max-tests.\n\t* ipa-modref-tree.c (test_insert_search_collapse): Update.\n\t(test_merge): Update.\n\t(gt_ggc_mx): New function.\n\t* ipa-modref-tree.h (struct modref_access_node): New structure.\n\t(struct modref_ref_node): Add every_access and accesses array.\n\t(modref_ref_node::modref_ref_node): Update ctor.\n\t(modref_ref_node::search): New member function.\n\t(modref_ref_node::collapse): New member function.\n\t(modref_ref_node::insert_access): New member function.\n\t(modref_base_node::insert_ref): Do not collapse base if ref is 0.\n\t(modref_base_node::collapse): Copllapse also refs.\n\t(modref_tree): Add accesses.\n\t(modref_tree::modref_tree): Initialize max_accesses.\n\t(modref_tree::insert): Add access parameter.\n\t(modref_tree::cleanup): New member function.\n\t(modref_tree::merge): Add parm_map; merge accesses.\n\t(modref_tree::copy_from): New member function.\n\t(modref_tree::create_ggc): Add max_accesses.\n\t* ipa-modref.c (dump_access): New function.\n\t(dump_records): Dump accesses.\n\t(dump_lto_records): Dump accesses.\n\t(get_access): New function.\n\t(record_access): Record access.\n\t(record_access_lto): Record access.\n\t(analyze_call): Compute parm_map.\n\t(analyze_function): Update construction of modref records.\n\t(modref_summaries::duplicate): Likewise; use copy_from.\n\t(write_modref_records): Stream accesses.\n\t(read_modref_records): Sream accesses.\n\t(pass_ipa_modref::execute): Update call of merge.\n\t* params.opt (-param=modref-max-accesses): New.\n\t* tree-ssa-alias.c (alias_stats): Add modref_baseptr_tests.\n\t(dump_alias_stats): Update.\n\t(base_may_alias_with_dereference_p): New function.\n\t(modref_may_conflict): Check accesses.\n\t(ref_maybe_used_by_call_p_1): Update call to modref_may_conflict.\n\t(call_may_clobber_ref_p_1): Update call to modref_may_conflict.", "tree": {"sha": "1d1ee6bae9e840ecb7043c72dbd9cd97aa4017e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d1ee6bae9e840ecb7043c72dbd9cd97aa4017e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c33f474239308d81bf96cfdb2520d25488ad8724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c33f474239308d81bf96cfdb2520d25488ad8724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c33f474239308d81bf96cfdb2520d25488ad8724", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c33f474239308d81bf96cfdb2520d25488ad8724/comments", "author": null, "committer": null, "parents": [{"sha": "329851416e698f4455b3021e297a13c248273618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/329851416e698f4455b3021e297a13c248273618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/329851416e698f4455b3021e297a13c248273618"}], "stats": {"total": 623, "additions": 501, "deletions": 122}, "files": [{"sha": "623dfb8ac28f0c69341928ba4d1c37e8930477d7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c33f474239308d81bf96cfdb2520d25488ad8724", "patch": "@@ -486,7 +486,7 @@ Objective-C and Objective-C++ Dialects}.\n -fgcse-sm  -fhoist-adjacent-loads  -fif-conversion @gol\n -fif-conversion2  -findirect-inlining @gol\n -finline-functions  -finline-functions-called-once  -finline-limit=@var{n} @gol\n--finline-small-functions  -fipa-cp  -fipa-cp-clone @gol\n+-finline-small-functions -fipa-modref -fipa-cp  -fipa-cp-clone @gol\n -fipa-bit-cp  -fipa-vrp  -fipa-pta  -fipa-profile  -fipa-pure-const @gol\n -fipa-reference  -fipa-reference-addressable @gol\n -fipa-stack-alignment  -fipa-icf  -fira-algorithm=@var{algorithm} @gol\n@@ -9688,6 +9688,7 @@ compilation time.\n -fif-conversion @gol\n -fif-conversion2 @gol\n -finline-functions-called-once @gol\n+-fipa-modref @gol\n -fipa-profile @gol\n -fipa-pure-const @gol\n -fipa-reference @gol\n@@ -10783,11 +10784,18 @@ default at any optimization level.\n @opindex fipa-profile\n Perform interprocedural profile propagation.  The functions called only from\n cold functions are marked as cold. Also functions executed once (such as\n-@code{cold}, @code{noreturn}, static constructors or destructors) are identified. Cold\n-functions and loop less parts of functions executed once are then optimized for\n-size.\n+@code{cold}, @code{noreturn}, static constructors or destructors) are\n+identified. Cold functions and loop less parts of functions executed once are\n+then optimized for size.\n Enabled by default at @option{-O} and higher.\n \n+@item -fipa-modref\n+@opindex fipa-modref\n+Perform interprocedural mod/ref analysis.  This optimization analyzes the side\n+effects of functions (memory locations that are modified or referenced) and\n+enables better optimization across the function call boundary.  This flag is\n+enabled by default at @option{-O} and higher.\n+\n @item -fipa-cp\n @opindex fipa-cp\n Perform interprocedural constant propagation.\n@@ -12764,6 +12772,18 @@ Deeper chains are still handled by late inlining.\n Probability (in percent) that C++ inline function with comdat visibility\n are shared across multiple compilation units.\n \n+@item ipa-modref-max-bases\n+@item ipa-modref-max-refs\n+@item ipa-modref-max-accesses\n+Specifies the maximal number of base pointers, referneces and accesses stored\n+for a single function by mod/ref analysis.\n+\n+@item ipa-modref-max-tests\n+Specifies the maxmal number of tests alias oracle can perform to disambiguate\n+memory locations using the mod/ref information.  This parameter ought to be\n+bigger than @option{--param ipa-modref-max-bases} and @option{--param\n+ipa-modref-max-refs}.\n+\n @item profile-func-internal-id\n A parameter to control whether to use function internal id in profile\n database lookup. If the value is 0, the compiler uses an id that"}, {"sha": "499dc60b75ef7705579892c69c6c894f14e5399e", "filename": "gcc/ipa-modref-tree.c", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Fipa-modref-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Fipa-modref-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.c?ref=c33f474239308d81bf96cfdb2520d25488ad8724", "patch": "@@ -35,12 +35,13 @@ test_insert_search_collapse ()\n {\n   modref_base_node<alias_set_type> *base_node;\n   modref_ref_node<alias_set_type> *ref_node;\n+  modref_access_node a = { -1 };\n \n-  modref_tree<alias_set_type> *t = new modref_tree<alias_set_type>(1, 2);\n+  modref_tree<alias_set_type> *t = new modref_tree<alias_set_type>(1, 2, 2);\n   ASSERT_FALSE (t->every_base);\n \n   /* Insert into an empty tree.  */\n-  t->insert (1, 2);\n+  t->insert (1, 2, a);\n   ASSERT_NE (t->bases, NULL);\n   ASSERT_EQ (t->bases->length (), 1);\n   ASSERT_FALSE (t->every_base);\n@@ -58,7 +59,7 @@ test_insert_search_collapse ()\n   ASSERT_EQ (ref_node->ref, 2);\n \n   /* Insert when base exists but ref does not.  */\n-  t->insert (1, 3);\n+  t->insert (1, 3, a);\n   ASSERT_NE (t->bases, NULL);\n   ASSERT_EQ (t->bases->length (), 1);\n   ASSERT_EQ (t->search (1), base_node);\n@@ -71,42 +72,42 @@ test_insert_search_collapse ()\n \n   /* Insert when base and ref exist, but access is not dominated by nor\n      dominates other accesses.  */\n-  t->insert (1, 2);\n+  t->insert (1, 2, a);\n   ASSERT_EQ (t->bases->length (), 1);\n   ASSERT_EQ (t->search (1), base_node);\n \n   ref_node = base_node->search (2);\n   ASSERT_NE (ref_node, NULL);\n \n   /* Insert when base and ref exist and access is dominated.  */\n-  t->insert (1, 2);\n+  t->insert (1, 2, a);\n   ASSERT_EQ (t->search (1), base_node);\n   ASSERT_EQ (base_node->search (2), ref_node);\n \n   /* Insert ref to trigger ref list collapse for base 1.  */\n-  t->insert (1, 4);\n+  t->insert (1, 4, a);\n   ASSERT_EQ (t->search (1), base_node);\n   ASSERT_EQ (base_node->refs, NULL);\n   ASSERT_EQ (base_node->search (2), NULL);\n   ASSERT_EQ (base_node->search (3), NULL);\n   ASSERT_TRUE (base_node->every_ref);\n \n   /* Further inserts to collapsed ref list are ignored.  */\n-  t->insert (1, 5);\n+  t->insert (1, 5, a);\n   ASSERT_EQ (t->search (1), base_node);\n   ASSERT_EQ (base_node->refs, NULL);\n   ASSERT_EQ (base_node->search (2), NULL);\n   ASSERT_EQ (base_node->search (3), NULL);\n   ASSERT_TRUE (base_node->every_ref);\n \n   /* Insert base to trigger base list collapse.  */\n-  t->insert (5, 6);\n+  t->insert (5, 6, a);\n   ASSERT_TRUE (t->every_base);\n   ASSERT_EQ (t->bases, NULL);\n   ASSERT_EQ (t->search (1), NULL);\n \n   /* Further inserts to collapsed base list are ignored.  */\n-  t->insert (7, 8);\n+  t->insert (7, 8, a);\n   ASSERT_TRUE (t->every_base);\n   ASSERT_EQ (t->bases, NULL);\n   ASSERT_EQ (t->search (1), NULL);\n@@ -117,24 +118,25 @@ test_merge ()\n {\n   modref_tree<alias_set_type> *t1, *t2;\n   modref_base_node<alias_set_type> *base_node;\n-\n-  t1 = new modref_tree<alias_set_type>(3, 4);\n-  t1->insert (1, 1);\n-  t1->insert (1, 2);\n-  t1->insert (1, 3);\n-  t1->insert (2, 1);\n-  t1->insert (3, 1);\n-\n-  t2 = new modref_tree<alias_set_type>(10, 10);\n-  t2->insert (1, 2);\n-  t2->insert (1, 3);\n-  t2->insert (1, 4);\n-  t2->insert (3, 2);\n-  t2->insert (3, 3);\n-  t2->insert (3, 4);\n-  t2->insert (3, 5);\n-\n-  t1->merge (t2);\n+  modref_access_node a = { -1 };\n+\n+  t1 = new modref_tree<alias_set_type>(3, 4, 1);\n+  t1->insert (1, 1, a);\n+  t1->insert (1, 2, a);\n+  t1->insert (1, 3, a);\n+  t1->insert (2, 1, a);\n+  t1->insert (3, 1, a);\n+\n+  t2 = new modref_tree<alias_set_type>(10, 10, 10);\n+  t2->insert (1, 2, a);\n+  t2->insert (1, 3, a);\n+  t2->insert (1, 4, a);\n+  t2->insert (3, 2, a);\n+  t2->insert (3, 3, a);\n+  t2->insert (3, 4, a);\n+  t2->insert (3, 5, a);\n+\n+  t1->merge (t2, NULL);\n \n   ASSERT_FALSE (t1->every_base);\n   ASSERT_NE (t1->bases, NULL);\n@@ -222,11 +224,21 @@ void gt_pch_nx (modref_base_node<tree_node*>*, gt_pointer_operator, void *) {}\n void gt_ggc_mx (modref_ref_node<int>* &r)\n {\n   ggc_test_and_set_mark (r);\n+  if (r->accesses)\n+    {\n+      ggc_test_and_set_mark (r->accesses);\n+      gt_ggc_mx (r->accesses);\n+    }\n }\n \n void gt_ggc_mx (modref_ref_node<tree_node*>* &r)\n {\n   ggc_test_and_set_mark (r);\n+  if (r->accesses)\n+    {\n+      ggc_test_and_set_mark (r->accesses);\n+      gt_ggc_mx (r->accesses);\n+    }\n   if (r->ref)\n     gt_ggc_mx (r->ref);\n }\n@@ -236,4 +248,6 @@ void gt_pch_nx (modref_ref_node<tree_node*>*) {}\n void gt_pch_nx (modref_ref_node<int>*, gt_pointer_operator, void *) {}\n void gt_pch_nx (modref_ref_node<tree_node*>*, gt_pointer_operator, void *) {}\n \n-\n+void gt_ggc_mx (modref_access_node &)\n+{\n+}"}, {"sha": "caf5d348dd8256b0a9cb87d14666852966fa4f5f", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 195, "deletions": 21, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=c33f474239308d81bf96cfdb2520d25488ad8724", "patch": "@@ -18,20 +18,101 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/* modref_tree represent a decision tree that can be used by alias analysis\n+   oracle to determine whether given memory access can be affected by a function\n+   call.  For every function we collect two trees, one for loads and other\n+   for stores.  Tree consist of following levels:\n+\n+   1) Base: this level represent base alias set of the acecess and refers\n+      to sons (ref nodes). Flag all_refs means that all possible references\n+      are aliasing.\n+\n+      Because for LTO streaming we need to stream types rahter than alias sets\n+      modref_base_node is implemented as a template.\n+   2) Ref: this level represent ref alias set and links to acesses unless\n+      all_refs flag is et.\n+      Again ref is an template to allow LTO streaming.\n+   3) Access: this level represent info about individual accesses.  Presently\n+      we record whether access is trhough a dereference of a function parameter\n+*/\n+\n #ifndef GCC_MODREF_TREE_H\n #define GCC_MODREF_TREE_H\n \n struct ipa_modref_summary;\n \n+/* Memory access.  */\n+struct GTY(()) modref_access_node\n+{\n+  /* Index of parameter which specifies the base of access. -1 if base is not\n+     a function parameter.  */\n+  int parm_index;\n+\n+  /* Return true if access node holds no useful info.  */\n+  bool useful_p ()\n+    {\n+      return parm_index != -1;\n+    }\n+};\n \n template <typename T>\n struct GTY((user)) modref_ref_node\n {\n   T ref;\n+  bool every_access;\n+  vec <modref_access_node, va_gc> *accesses;\n \n   modref_ref_node (T ref):\n-    ref (ref)\n+    ref (ref),\n+    every_access (false),\n+    accesses (NULL)\n   {}\n+\n+  /* Search REF; return NULL if failed.  */\n+  modref_access_node *search (modref_access_node access)\n+  {\n+    size_t i;\n+    modref_access_node *a;\n+    FOR_EACH_VEC_SAFE_ELT (accesses, i, a)\n+      if (a->parm_index == access.parm_index)\n+\treturn a;\n+    return NULL;\n+  }\n+\n+  /* Collapse the tree.  */\n+  void collapse ()\n+  {\n+    vec_free (accesses);\n+    accesses = NULL;\n+    every_access = true;\n+  }\n+\n+  /* Insert access with OFFSET and SIZE.\n+     Collapse tree if it has more than MAX_ACCESSES entries.  */\n+  void insert_access (modref_access_node a, size_t max_accesses)\n+  {\n+    /* If this base->ref pair has no access information, bail out.  */\n+    if (every_access)\n+      return;\n+\n+    /* Otherwise, insert a node for the ref of the access under the base.  */\n+    modref_access_node *access_node = search (a);\n+    if (access_node)\n+      return;\n+\n+    /* If this base->ref pair has too many accesses stored, we will clear\n+       all accesses and bail out.  */\n+    if ((accesses && accesses->length () >= max_accesses)\n+\t|| !a.useful_p ())\n+      {\n+\tif (dump_file && a.useful_p ())\n+\t  fprintf (dump_file,\n+\t\t   \"--param param=modref-max-accesses limit reached\\n\");\n+\tcollapse ();\n+\treturn;\n+      }\n+    vec_safe_push (accesses, a);\n+  }\n };\n \n /* Base of an access.  */\n@@ -67,12 +148,6 @@ struct GTY((user)) modref_base_node\n     if (every_ref)\n       return NULL;\n \n-    if (!ref)\n-      {\n-\tcollapse ();\n-\treturn NULL;\n-      }\n-\n     /* Otherwise, insert a node for the ref of the access under the base.  */\n     ref_node = search (ref);\n     if (ref_node)\n@@ -101,7 +176,10 @@ struct GTY((user)) modref_base_node\n     if (refs)\n       {\n \tFOR_EACH_VEC_SAFE_ELT (refs, i, r)\n-\t  ggc_free (r);\n+\t  {\n+\t    r->collapse ();\n+\t    ggc_free (r);\n+\t  }\n \tvec_free (refs);\n       }\n     refs = NULL;\n@@ -116,12 +194,14 @@ struct GTY((user)) modref_tree\n   vec <modref_base_node <T> *, va_gc> *bases;\n   size_t max_bases;\n   size_t max_refs;\n+  size_t max_accesses;\n   bool every_base;\n \n-  modref_tree (size_t max_bases, size_t max_refs):\n+  modref_tree (size_t max_bases, size_t max_refs, size_t max_accesses):\n     bases (NULL),\n     max_bases (max_bases),\n     max_refs (max_refs),\n+    max_accesses (max_accesses),\n     every_base (false) {}\n \n   modref_base_node <T> *insert_base (T base)\n@@ -153,31 +233,92 @@ struct GTY((user)) modref_tree\n   }\n \n   /* Insert memory access to the tree.\t*/\n-  void insert (T base, T ref)\n+  void insert (T base, T ref, modref_access_node a)\n   {\n-    modref_base_node <T> *base_node;\n-\n-    base_node = insert_base (base);\n-\n-    if (!base && !ref)\n+    /* No useful information tracked; collapse everything.  */\n+    if (!base && !ref && !a.useful_p ())\n       {\n \tcollapse ();\n \treturn;\n       }\n+\n+    modref_base_node <T> *base_node = insert_base (base);\n     if (!base_node)\n       return;\n     gcc_assert (search (base) != NULL);\n \n-    base_node->insert_ref (ref, max_refs);\n+    modref_ref_node <T> *ref_node = base_node->insert_ref (ref, max_refs);\n+\n+    /* No useful ref information and no useful base; collapse everyting.  */\n     if (!base && base_node->every_ref)\n       {\n \tcollapse ();\n \treturn;\n       }\n+    if (ref_node)\n+      {\n+\t/* No useful ref and access; collapse ref.  */\n+\tif (!ref && !a.useful_p ())\n+\t  ref_node->collapse ();\n+\telse\n+\t  {\n+\t    ref_node->insert_access (a, max_accesses);\n+\t    /* If ref has collapses and there is no useful base; collapse\n+\t       everything.  */\n+\t    if (!base && !ref && ref_node->every_access)\n+\t      collapse ();\n+\t  }\n+      }\n   }\n \n-  /* Merge OTHER into the tree.  */\n-  void merge (modref_tree <T> *other)\n+ /* Remove tree branches that are not useful (i.e. they will allways pass).  */\n+\n+ void cleanup ()\n+ {\n+   size_t i, j;\n+   modref_base_node <T> *base_node;\n+   modref_ref_node <T> *ref_node;\n+\n+   if (!bases)\n+     return;\n+\n+   for (i = 0; vec_safe_iterate (bases, i, &base_node);)\n+     {\n+       if (base_node->refs)\n+\t for (j = 0; vec_safe_iterate (base_node->refs, j, &ref_node);)\n+\t   {\n+\t     if (!ref_node->every_access\n+\t\t && (!ref_node->accesses\n+\t\t     || !ref_node->accesses->length ()))\n+\t       {\n+\t\t base_node->refs->unordered_remove (j);\n+\t\t vec_free (ref_node->accesses);\n+\t\t ggc_delete (ref_node);\n+\t       }\n+\t     else\n+\t       j++;\n+\t   }\n+       if (!base_node->every_ref\n+\t   && (!base_node->refs || !base_node->refs->length ()))\n+\t {\n+\t   bases->unordered_remove (i);\n+\t   vec_free (base_node->refs);\n+\t   ggc_delete (base_node);\n+\t }\n+       else\n+\t i++;\n+     }\n+   if (bases && !bases->length ())\n+     {\n+       vec_free (bases);\n+       bases = NULL;\n+     }\n+ }\n+\n+  /* Merge OTHER into the tree.\n+     PARM_MAP, if non-NULL, maps parm indexes of callee to caller.  -2 is used\n+     to signalize that parameter is local and does not need to be tracked.  */\n+  void merge (modref_tree <T> *other, vec <int> *parm_map)\n   {\n     if (!other)\n       return;\n@@ -187,9 +328,10 @@ struct GTY((user)) modref_tree\n \treturn;\n       }\n \n-    size_t i, j;\n+    size_t i, j, k;\n     modref_base_node <T> *base_node, *my_base_node;\n     modref_ref_node <T> *ref_node, *my_ref_node;\n+    modref_access_node *access_node;\n     FOR_EACH_VEC_SAFE_ELT (other->bases, i, base_node)\n       {\n \tmy_base_node = insert_base (base_node->base);\n@@ -207,8 +349,36 @@ struct GTY((user)) modref_tree\n \t    my_ref_node = my_base_node->insert_ref (ref_node->ref, max_refs);\n \t    if (!my_ref_node)\n \t      continue;\n+\n+\t    if (ref_node->every_access)\n+\t      {\n+\t\tmy_ref_node->collapse ();\n+\t\tcontinue;\n+\t      }\n+\t    FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n+\t      {\n+\t\tmodref_access_node a = *access_node;\n+\t\tif (a.parm_index != -1 && parm_map)\n+\t\t  {\n+\t\t    if (a.parm_index >= (int)parm_map->length ())\n+\t\t      a.parm_index = -1;\n+\t\t    else if ((*parm_map) [a.parm_index] == -2)\n+\t\t      continue;\n+\t\t    else\n+\t\t      a.parm_index = (*parm_map) [a.parm_index];\n+\t\t  }\n+\t\tmy_ref_node->insert_access (a, max_accesses);\n+\t      }\n \t  }\n       }\n+    if (parm_map)\n+      cleanup ();\n+  }\n+\n+  /* Copy OTHER to THIS.  */\n+  void copy_from (modref_tree <T> *other)\n+  {\n+    merge (other, NULL);\n   }\n \n   /* Search BASE in tree; return NULL if failed.  */\n@@ -225,12 +395,14 @@ struct GTY((user)) modref_tree\n   /* Return ggc allocated instance.  We explicitly call destructors via\n      ggc_delete and do not want finalizers to be registered and\n      called at the garbage collection time.  */\n-  static modref_tree<T> *create_ggc (size_t max_bases, size_t max_refs)\n+  static modref_tree<T> *create_ggc (size_t max_bases, size_t max_refs,\n+\t\t\t\t     size_t max_accesses)\n   {\n     return new (ggc_alloc_no_dtor<modref_tree<T>> ())\n-\t modref_tree<T> (max_bases, max_refs);\n+\t modref_tree<T> (max_bases, max_refs, max_accesses);\n   }\n \n+  /* Remove all records and mark tree to alias with everything.  */\n   void collapse ()\n   {\n     size_t i;\n@@ -248,6 +420,8 @@ struct GTY((user)) modref_tree\n     bases = NULL;\n     every_base = true;\n   }\n+\n+  /* Release memory.  */\n   ~modref_tree ()\n   {\n     collapse ();"}, {"sha": "aa6929ff0105ac64687d514f9cfa07075e46afe1", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 184, "deletions": 44, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=c33f474239308d81bf96cfdb2520d25488ad8724", "patch": "@@ -20,14 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Mod/ref pass records summary about loads and stores performed by the\n    function.  This is later used by alias analysis to disambiguate memory\n-   accesses across function calls.  The summary has a form of decision tree and\n-   contains:\n-\n-    - base alias set\n-      and for each:\n-      - ref alias set\n-\n-   In future more information will be tracked.\n+   accesses across function calls.  The summary has a form of decision tree\n+   described in ipa-modref-tree.h.\n \n    This file contains a tree pass and an IPA pass.  Both performs the same\n    analys however tree pass is executed during early and late optimization\n@@ -144,6 +138,14 @@ modref_summary::useful_p (int ecf_flags)\n   return stores && !loads->every_base;\n }\n \n+/* Dump A to OUT.  */\n+\n+static void\n+dump_access (modref_access_node *a, FILE *out)\n+{\n+   fprintf (out, \"          Parm %i\\n\", a->parm_index);\n+}\n+\n /* Dump records TT to OUT.  */\n \n static void\n@@ -171,6 +173,15 @@ dump_records (modref_records *tt, FILE *out)\n       FOR_EACH_VEC_SAFE_ELT (n->refs, j, r)\n \t{\n \t  fprintf (out, \"        Ref %i: alias set %i\\n\", (int)j, r->ref);\n+\t  if (r->every_access)\n+\t    {\n+\t      fprintf (out, \"        Every access\\n\");\n+\t      continue;\n+\t    }\n+\t  size_t k;\n+\t  modref_access_node *a;\n+\t  FOR_EACH_VEC_SAFE_ELT (r->accesses, k, a)\n+\t    dump_access (a, out);\n \t}\n     }\n }\n@@ -208,6 +219,15 @@ dump_lto_records (modref_records_lto *tt, FILE *out)\n \t  print_generic_expr (dump_file, r->ref);\n \t  fprintf (out, \" (alias set %i)\\n\",\n \t\t   r->ref ? get_alias_set (r->ref) : 0);\n+\t  if (r->every_access)\n+\t    {\n+\t      fprintf (out, \"      Every access\\n\");\n+\t      continue;\n+\t    }\n+\t  size_t k;\n+\t  modref_access_node *a;\n+\t  FOR_EACH_VEC_SAFE_ELT (r->accesses, k, a)\n+\t    dump_access (a, out);\n \t}\n     }\n }\n@@ -268,6 +288,43 @@ get_modref_function_summary (cgraph_node *func)\n   return NULL;\n }\n \n+/* Construct modref_access_node from REF.  */\n+static modref_access_node\n+get_access (ao_ref *ref)\n+{\n+  modref_access_node a;\n+  tree base;\n+\n+  base = ref->ref;\n+  while (handled_component_p (base))\n+    base = TREE_OPERAND (base, 0);\n+  if (TREE_CODE (base) == MEM_REF || TREE_CODE (base) == TARGET_MEM_REF)\n+    {\n+      base = TREE_OPERAND (base, 0);\n+      if (TREE_CODE (base) == SSA_NAME\n+\t  && SSA_NAME_IS_DEFAULT_DEF (base)\n+\t  && TREE_CODE (SSA_NAME_VAR (base)) == PARM_DECL)\n+\t{\n+\t  a.parm_index = 0;\n+\t  for (tree t = DECL_ARGUMENTS (current_function_decl);\n+\t       t != SSA_NAME_VAR (base); t = DECL_CHAIN (t))\n+\t    {\n+\t      if (!t)\n+\t\t{\n+\t\t  a.parm_index = -1;\n+\t\t  break;\n+\t\t}\n+\t      a.parm_index++;\n+\t    }\n+\t}\n+      else\n+\ta.parm_index = -1;\n+    }\n+  else\n+    a.parm_index = -1;\n+  return a;\n+}\n+\n /* Record access into the modref_records data structure.  */\n \n static void\n@@ -277,12 +334,13 @@ record_access (modref_records *tt, ao_ref *ref)\n \t\t\t    : ao_ref_base_alias_set (ref);\n   alias_set_type ref_set = !flag_strict_aliasing ? 0\n \t\t\t    : (ao_ref_alias_set (ref));\n+  modref_access_node a = get_access (ref);\n   if (dump_file)\n     {\n-       fprintf (dump_file, \"   - Recording base_set=%i ref_set=%i\\n\",\n-\t        base_set, ref_set);\n+       fprintf (dump_file, \"   - Recording base_set=%i ref_set=%i parm=%i\\n\",\n+\t\tbase_set, ref_set, a.parm_index);\n     }\n-  tt->insert (base_set, ref_set);\n+  tt->insert (base_set, ref_set, a);\n }\n \n /* IPA version of record_access_tree.  */\n@@ -335,18 +393,20 @@ record_access_lto (modref_records_lto *tt, ao_ref *ref)\n \t\t       || variably_modified_type_p (ref_type, NULL_TREE)))\n \tref_type = NULL_TREE;\n     }\n+  modref_access_node a = get_access (ref);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"   - Recording base type:\");\n       print_generic_expr (dump_file, base_type);\n       fprintf (dump_file, \" (alias set %i) ref type:\",\n \t       base_type ? get_alias_set (base_type) : 0);\n       print_generic_expr (dump_file, ref_type);\n-      fprintf (dump_file, \" (alias set %i)\\n\",\n-\t       ref_type ? get_alias_set (ref_type) : 0);\n+      fprintf (dump_file, \" (alias set %i) parm:%i\\n\",\n+\t       ref_type ? get_alias_set (ref_type) : 0,\n+\t       a.parm_index);\n     }\n \n-  tt->insert (base_type, ref_type);\n+  tt->insert (base_type, ref_type, a);\n }\n \n /* Returns true if and only if we should store the access to EXPR.\n@@ -490,17 +550,47 @@ analyze_call (modref_summary *cur_summary,\n       return false;\n     }\n \n+  auto_vec <int, 32> parm_map;\n+\n+  parm_map.safe_grow (gimple_call_num_args (stmt));\n+  for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n+    {\n+      tree op = gimple_call_arg (stmt, i);\n+      STRIP_NOPS (op);\n+      if (TREE_CODE (op) == SSA_NAME\n+\t  && SSA_NAME_IS_DEFAULT_DEF (op)\n+\t  && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n+\t{\n+\t  int index = 0;\n+\t  for (tree t = DECL_ARGUMENTS (current_function_decl);\n+\t       t != SSA_NAME_VAR (op); t = DECL_CHAIN (t))\n+\t    {\n+\t      if (!t)\n+\t\t{\n+\t\t  index = -1;\n+\t\t  break;\n+\t\t}\n+\t      index++;\n+\t    }\n+\t  parm_map[i] = index;\n+\t}\n+      else if (points_to_local_or_readonly_memory_p (op))\n+\tparm_map[i] = -2;\n+      else\n+\tparm_map[i] = -1;\n+    }\n+\n   /* Merge with callee's summary.  */\n   if (cur_summary->loads)\n-    cur_summary->loads->merge (callee_summary->loads);\n+    cur_summary->loads->merge (callee_summary->loads, &parm_map);\n   if (cur_summary->loads_lto)\n-    cur_summary->loads_lto->merge (callee_summary->loads_lto);\n+    cur_summary->loads_lto->merge (callee_summary->loads_lto, &parm_map);\n   if (!ignore_stores)\n     {\n       if (cur_summary->stores)\n-\tcur_summary->stores->merge (callee_summary->stores);\n+\tcur_summary->stores->merge (callee_summary->stores, &parm_map);\n       if (cur_summary->stores_lto)\n-\tcur_summary->stores_lto->merge (callee_summary->stores_lto);\n+\tcur_summary->stores_lto->merge (callee_summary->stores_lto, &parm_map);\n     }\n \n   return true;\n@@ -638,21 +728,25 @@ analyze_function (function *f, bool ipa)\n     {\n       gcc_assert (!summary->loads);\n       summary->loads = modref_records::create_ggc (param_modref_max_bases,\n-\t\t\t\t\t\t   param_modref_max_refs);\n+\t\t\t\t\t\t   param_modref_max_refs,\n+\t\t\t\t\t\t   param_modref_max_accesses);\n       gcc_assert (!summary->stores);\n       summary->stores = modref_records::create_ggc (param_modref_max_bases,\n-\t\t\t\t\t\t    param_modref_max_refs);\n+\t\t\t\t\t\t    param_modref_max_refs,\n+\t\t\t\t\t\t    param_modref_max_accesses);\n     }\n   if (lto)\n     {\n       gcc_assert (!summary->loads_lto);\n       summary->loads_lto = modref_records_lto::create_ggc\n \t\t\t\t (param_modref_max_bases,\n-\t\t\t\t  param_modref_max_refs);\n+\t\t\t\t  param_modref_max_refs,\n+\t\t\t\t  param_modref_max_accesses);\n       gcc_assert (!summary->stores_lto);\n       summary->stores_lto = modref_records_lto::create_ggc\n \t\t\t\t (param_modref_max_bases,\n-\t\t\t\t  param_modref_max_refs);\n+\t\t\t\t  param_modref_max_refs,\n+\t\t\t\t  param_modref_max_accesses);\n     }\n   summary->finished = false;\n   int ecf_flags = flags_from_decl_or_type (current_function_decl);\n@@ -730,29 +824,33 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *,\n     {\n       dst_data->stores = modref_records::create_ggc\n \t\t\t    (src_data->stores->max_bases,\n-\t\t\t     src_data->stores->max_refs);\n-      dst_data->stores->merge (src_data->stores);\n+\t\t\t     src_data->stores->max_refs,\n+\t\t\t     src_data->stores->max_accesses);\n+      dst_data->stores->copy_from (src_data->stores);\n     }\n   if (src_data->loads)\n     {\n       dst_data->loads = modref_records::create_ggc\n \t\t\t    (src_data->loads->max_bases,\n-\t\t\t     src_data->loads->max_refs);\n-      dst_data->loads->merge (src_data->loads);\n+\t\t\t     src_data->loads->max_refs,\n+\t\t\t     src_data->loads->max_accesses);\n+      dst_data->loads->copy_from (src_data->loads);\n     }\n   if (src_data->stores_lto)\n     {\n       dst_data->stores_lto = modref_records_lto::create_ggc\n \t\t\t    (src_data->stores_lto->max_bases,\n-\t\t\t     src_data->stores_lto->max_refs);\n-      dst_data->stores_lto->merge (src_data->stores_lto);\n+\t\t\t     src_data->stores_lto->max_refs,\n+\t\t\t     src_data->stores_lto->max_accesses);\n+      dst_data->stores_lto->copy_from (src_data->stores_lto);\n     }\n   if (src_data->loads_lto)\n     {\n       dst_data->loads_lto = modref_records_lto::create_ggc\n \t\t\t    (src_data->loads_lto->max_bases,\n-\t\t\t     src_data->loads_lto->max_refs);\n-      dst_data->loads_lto->merge (src_data->loads_lto);\n+\t\t\t     src_data->loads_lto->max_refs,\n+\t\t\t     src_data->stores_lto->max_accesses);\n+      dst_data->loads_lto->copy_from (src_data->loads_lto);\n     }\n }\n \n@@ -796,6 +894,7 @@ write_modref_records (modref_records_lto *tt, struct output_block *ob)\n {\n   streamer_write_uhwi (ob, tt->max_bases);\n   streamer_write_uhwi (ob, tt->max_refs);\n+  streamer_write_uhwi (ob, tt->max_accesses);\n \n   streamer_write_uhwi (ob, tt->every_base);\n   streamer_write_uhwi (ob, vec_safe_length (tt->bases));\n@@ -807,11 +906,19 @@ write_modref_records (modref_records_lto *tt, struct output_block *ob)\n \n       streamer_write_uhwi (ob, base_node->every_ref);\n       streamer_write_uhwi (ob, vec_safe_length (base_node->refs));\n+\n       size_t j;\n       modref_ref_node <tree> *ref_node;\n       FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n \t{\n \t  stream_write_tree (ob, ref_node->ref, true);\n+\t  streamer_write_uhwi (ob, ref_node->every_access);\n+\t  streamer_write_uhwi (ob, vec_safe_length (ref_node->accesses));\n+\n+\t  size_t k;\n+\t  modref_access_node *access_node;\n+\t  FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n+\t    streamer_write_uhwi (ob, access_node->parm_index);\n \t}\n     }\n }\n@@ -828,13 +935,16 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n {\n   size_t max_bases = streamer_read_uhwi (ib);\n   size_t max_refs = streamer_read_uhwi (ib);\n+  size_t max_accesses = streamer_read_uhwi (ib);\n \n   /* Decide whether we want to turn LTO data types to non-LTO (i.e. when\n      LTO re-streaming is not going to happen).  */\n   if (flag_wpa || flag_incremental_link == INCREMENTAL_LINK_LTO)\n-    *lto_ret = modref_records_lto::create_ggc (max_bases, max_refs);\n+    *lto_ret = modref_records_lto::create_ggc (max_bases, max_refs,\n+\t\t\t\t\t       max_accesses);\n   else\n-    *nolto_ret = modref_records::create_ggc (max_bases, max_refs);\n+    *nolto_ret = modref_records::create_ggc (max_bases, max_refs,\n+\t\t\t\t\t     max_accesses);\n \n   size_t every_base = streamer_read_uhwi (ib);\n   size_t nbase = streamer_read_uhwi (ib);\n@@ -897,16 +1007,43 @@ read_modref_records (lto_input_block *ib, struct data_in *data_in,\n \t\t  print_generic_expr (dump_file, ref_tree);\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n-\t      base_tree = NULL;\n+\t      ref_tree = NULL;\n \t    }\n \n+\t  modref_ref_node <alias_set_type> *nolto_ref_node = NULL;\n+\t  modref_ref_node <tree> *lto_ref_node = NULL;\n+\n \t  if (nolto_base_node)\n-\t    nolto_base_node->insert_ref (ref_tree ? get_alias_set (ref_tree)\n-\t\t\t\t\t : 0, max_refs);\n+\t    nolto_ref_node\n+\t      = nolto_base_node->insert_ref (ref_tree\n+\t\t\t\t\t     ? get_alias_set (ref_tree) : 0,\n+\t\t\t\t\t     max_refs);\n \t  if (lto_base_node)\n-\t    lto_base_node->insert_ref (ref_tree, max_refs);\n+\t    lto_ref_node = lto_base_node->insert_ref (ref_tree, max_refs);\n+\n+\t  size_t every_access = streamer_read_uhwi (ib);\n+\t  size_t naccesses = streamer_read_uhwi (ib);\n+\n+\t  if (nolto_ref_node)\n+\t    nolto_ref_node->every_access = every_access;\n+\t  if (lto_ref_node)\n+\t    lto_ref_node->every_access = every_access;\n+\n+\t  for (size_t k = 0; k < naccesses; k++)\n+\t    {\n+\t      int parm_index = streamer_read_uhwi (ib);\n+\t      modref_access_node a = {parm_index};\n+\t      if (nolto_ref_node)\n+\t\tnolto_ref_node->insert_access (a, max_accesses);\n+\t      if (lto_ref_node)\n+\t\tlto_ref_node->insert_access (a, max_accesses);\n+\t    }\n \t}\n     }\n+  if (*lto_ret)\n+    (*lto_ret)->cleanup ();\n+  if (*nolto_ret)\n+    (*nolto_ret)->cleanup ();\n }\n \n /* Callback for write_summary.  */\n@@ -1305,19 +1442,22 @@ unsigned int pass_ipa_modref::execute (function *)\n \t\t    }\n \t\t}\n \n+\t      auto_vec <int, 32> parm_map;\n+\t      /* TODO: compute parm_map.  */\n+\n \t      /* Merge in callee's information.  */\n \t      if (callee_summary->loads\n \t\t  && callee_summary->loads != loads)\n-\t\tloads->merge (callee_summary->loads);\n+\t\tloads->merge (callee_summary->loads, &parm_map);\n \t      if (callee_summary->stores\n \t\t  && callee_summary->stores != stores)\n-\t\tstores->merge (callee_summary->stores);\n+\t\tstores->merge (callee_summary->stores, &parm_map);\n \t      if (callee_summary->loads_lto\n \t\t  && callee_summary->loads_lto != loads_lto)\n-\t\tloads_lto->merge (callee_summary->loads_lto);\n+\t\tloads_lto->merge (callee_summary->loads_lto, &parm_map);\n \t      if (callee_summary->stores_lto\n \t\t  && callee_summary->stores_lto != stores_lto)\n-\t\tstores_lto->merge (callee_summary->stores_lto);\n+\t\tstores_lto->merge (callee_summary->stores_lto, &parm_map);\n \t    }\n \t}\n \n@@ -1351,13 +1491,13 @@ unsigned int pass_ipa_modref::execute (function *)\n \t      else\n \t\t{\n \t\t  if (loads)\n-\t\t    cur_summary->loads->merge (loads);\n+\t\t    cur_summary->loads->merge (loads, NULL);\n \t\t  if (stores)\n-\t\t    cur_summary->stores->merge (stores);\n+\t\t    cur_summary->stores->merge (stores, NULL);\n \t\t  if (loads_lto)\n-\t\t    cur_summary->loads_lto->merge (loads_lto);\n+\t\t    cur_summary->loads_lto->merge (loads_lto, NULL);\n \t\t  if (stores_lto)\n-\t\t    cur_summary->stores_lto->merge (stores_lto);\n+\t\t    cur_summary->stores_lto->merge (stores_lto, NULL);\n \t\t}\n \t      cur_summary->finished = true;\n \t      if (dump_file)"}, {"sha": "5bc7e1619c5f0656191f07ef4514ce0958372ffd", "filename": "gcc/params.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=c33f474239308d81bf96cfdb2520d25488ad8724", "patch": "@@ -882,7 +882,11 @@ Maximum number of bases stored in each modref tree.\n \n -param=modref-max-refs=\n Common Joined UInteger Var(param_modref_max_refs) Init(16)\n-Maximum number of refs stored in each modref tree.\n+Maximum number of references stored in each modref base.\n+\n+-param=modref-max-accesses=\n+Common Joined UInteger Var(param_modref_max_accesses) Init(16)\n+Maximum number of accesse stored in each modref reference.\n \n -param=modref-max-tests=\n Common Joined UInteger Var(param_modref_max_tests) Init(64)"}, {"sha": "fe390d4ffbea9a7033e8c81e9cc828d942018c41", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c33f474239308d81bf96cfdb2520d25488ad8724/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=c33f474239308d81bf96cfdb2520d25488ad8724", "patch": "@@ -114,6 +114,7 @@ static struct {\n   unsigned HOST_WIDE_INT modref_clobber_may_alias;\n   unsigned HOST_WIDE_INT modref_clobber_no_alias;\n   unsigned HOST_WIDE_INT modref_tests;\n+  unsigned HOST_WIDE_INT modref_baseptr_tests;\n } alias_stats;\n \n void\n@@ -169,13 +170,18 @@ dump_alias_stats (FILE *s)\n \t   + alias_stats.modref_use_may_alias);\n   fprintf (s, \"  modref clobber: \"\n \t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n-\t   HOST_WIDE_INT_PRINT_DEC\" queries\\n  \"\n-\t   HOST_WIDE_INT_PRINT_DEC\" tbaa queries (%f per modref query)\\n\",\n+\t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\"\n+\t   \"  \" HOST_WIDE_INT_PRINT_DEC\" tbaa queries (%f per modref query)\\n\"\n+\t   \"  \" HOST_WIDE_INT_PRINT_DEC\" base compares (%f per modref query)\\n\",\n \t   alias_stats.modref_clobber_no_alias,\n \t   alias_stats.modref_clobber_no_alias\n \t   + alias_stats.modref_clobber_may_alias,\n \t   alias_stats.modref_tests,\n \t   ((double)alias_stats.modref_tests)\n+\t   / (alias_stats.modref_clobber_no_alias\n+\t      + alias_stats.modref_clobber_may_alias),\n+\t   alias_stats.modref_baseptr_tests,\n+\t   ((double)alias_stats.modref_baseptr_tests)\n \t   / (alias_stats.modref_clobber_no_alias\n \t      + alias_stats.modref_clobber_may_alias));\n }\n@@ -2423,12 +2429,13 @@ refs_output_dependent_p (tree store1, tree store2)\n    IF TBAA_P is true, use TBAA oracle.  */\n \n static bool\n-modref_may_conflict (modref_tree <alias_set_type> *tt, ao_ref *ref, bool tbaa_p)\n+modref_may_conflict (const gimple *stmt,\n+\t\t     modref_tree <alias_set_type> *tt, ao_ref *ref, bool tbaa_p)\n {\n   alias_set_type base_set, ref_set;\n   modref_base_node <alias_set_type> *base_node;\n   modref_ref_node <alias_set_type> *ref_node;\n-  size_t i, j;\n+  size_t i, j, k;\n \n   if (tt->every_base)\n     return true;\n@@ -2440,37 +2447,57 @@ modref_may_conflict (modref_tree <alias_set_type> *tt, ao_ref *ref, bool tbaa_p)\n   int num_tests = 0, max_tests = param_modref_max_tests;\n   FOR_EACH_VEC_SAFE_ELT (tt->bases, i, base_node)\n     {\n-      if (base_node->every_ref)\n-\treturn true;\n-\n-      if (!base_node->base)\n-\treturn true;\n-\n       if (tbaa_p && flag_strict_aliasing)\n \t{\n+\t  if (num_tests >= max_tests)\n+\t    return true;\n \t  alias_stats.modref_tests++;\n \t  if (!alias_sets_conflict_p (base_set, base_node->base))\n \t    continue;\n \t  num_tests++;\n \t}\n-      else\n-\treturn true;\n-      if (num_tests >= max_tests)\n+\n+      if (base_node->every_ref)\n \treturn true;\n \n       FOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n \t{\n \t  /* Do not repeat same test as before.  */\n-\t  if (ref_set == base_set && base_node->base == ref_node->ref)\n-\t    return true;\n-\t  if (!flag_strict_aliasing)\n-\t    return true;\n-\t  alias_stats.modref_tests++;\n-\t  if (alias_sets_conflict_p (ref_set, ref_node->ref))\n-\t    return true;\n-\t  num_tests++;\n-\t  if (num_tests >= max_tests)\n+\t  if ((ref_set != base_set || base_node->base != ref_node->ref)\n+\t      && tbaa_p && flag_strict_aliasing)\n+\t    {\n+\t      if (num_tests >= max_tests)\n+\t\treturn true;\n+\t      alias_stats.modref_tests++;\n+\t      if (!alias_sets_conflict_p (ref_set, ref_node->ref))\n+\t\tcontinue;\n+\t      num_tests++;\n+\t    }\n+\n+\t  /* TBAA checks did not disambiguate,  try to use base pointer, for\n+\t     that we however need to have ref->ref.  */\n+\t  if (ref_node->every_access || !ref->ref)\n \t    return true;\n+\n+\t  modref_access_node *access_node;\n+\t  FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n+\t    {\n+\t      if (num_tests >= max_tests)\n+\t\treturn true;\n+\n+\t      if (access_node->parm_index == -1\n+\t\t  || (unsigned)access_node->parm_index\n+\t\t     >= gimple_call_num_args (stmt))\n+\t\treturn true;\n+\n+\n+\t      alias_stats.modref_baseptr_tests++;\n+\n+\t      if (ptr_deref_may_alias_ref_p_1\n+\t\t   (gimple_call_arg (stmt, access_node->parm_index), ref))\n+\t\treturn true;\n+\t      num_tests++;\n+\t    }\n \t}\n     }\n   return false;\n@@ -2510,7 +2537,7 @@ ref_maybe_used_by_call_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n \t  modref_summary *summary = get_modref_function_summary (node);\n \t  if (summary)\n \t    {\n-\t      if (!modref_may_conflict (summary->loads, ref, tbaa_p))\n+\t      if (!modref_may_conflict (call, summary->loads, ref, tbaa_p))\n \t\t{\n \t\t  alias_stats.modref_use_no_alias++;\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2934,7 +2961,7 @@ call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n \t  modref_summary *summary = get_modref_function_summary (node);\n \t  if (summary)\n \t    {\n-\t      if (!modref_may_conflict (summary->stores, ref, tbaa_p))\n+\t      if (!modref_may_conflict (call, summary->stores, ref, tbaa_p))\n \t\t{\n \t\t  alias_stats.modref_clobber_no_alias++;\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))"}]}