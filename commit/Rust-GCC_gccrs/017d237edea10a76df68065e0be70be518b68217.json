{"sha": "017d237edea10a76df68065e0be70be518b68217", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE3ZDIzN2VkZWExMGE3NmRmNjgwNjVlMGJlNzBiZTUxOGI2ODIxNw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2016-06-22T10:49:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-22T10:49:48Z"}, "message": "sem_prag.ads (Build_Classwide_Expression): new procedure to build the expression for an inherited classwide condition...\n\n2016-06-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.ads (Build_Classwide_Expression): new procedure to\n\tbuild the expression for an inherited classwide condition, and\n\tto validate such expressions when they apply to an inherited\n\toperation that is not overridden.\n\t* sem_prag.adb (Primitives_Mapping): new data structure to\n\thandle the mapping between operations of a root type and the\n\tcorresponding overriding operations of a type extension. Used\n\tto construct the expression for an inherited classwide condition.\n\t(Update_Primitives_Mapping): add to Primitives_Mapping the links\n\tbetween primitive operations of a root type and those of a given\n\ttype extension.\n\t(Build_Pragma_Check_Equivalent): use Primitives_Mapping.\n\t* sem_ch6.adb (New_Overloaded_Entity): Remove call to\n\tCollect_Iherited_Class_Wide_Conditions in GNATprove_Mode. This\n\tneeds to be done at freeze point of the type.\n\t* freeze.adb (Check_Inherited_Conditions): new procedure to\n\tverify the legality of inherited classwide conditions. In normal\n\tcompilation mode the procedure determines whether an inherited\n\toperation needs a wrapper to handle an inherited condition that\n\tdiffers from the condition of the root type.  In SPARK mode\n\tthe routine invokes Collect_Inherited_Class_Wide_Conditions to\n\tproduce the SPARK version of these inherited conditions.\n\t(Freeze_Record_Type): For a type extension, call\n\tCheck_Inherited_Conditions.\n\nFrom-SVN: r237698", "tree": {"sha": "b1e810a677d3291cfd2381f73860a652a9d9650f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1e810a677d3291cfd2381f73860a652a9d9650f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/017d237edea10a76df68065e0be70be518b68217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/017d237edea10a76df68065e0be70be518b68217", "html_url": "https://github.com/Rust-GCC/gccrs/commit/017d237edea10a76df68065e0be70be518b68217", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/017d237edea10a76df68065e0be70be518b68217/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "497a660d21f75362b8b6c7e4f4463a2ffbdeb38e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497a660d21f75362b8b6c7e4f4463a2ffbdeb38e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497a660d21f75362b8b6c7e4f4463a2ffbdeb38e"}], "stats": {"total": 718, "additions": 434, "deletions": 284}, "files": [{"sha": "0a252c6ba28f06ceacfb8e07d3663abceac9f8a3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017d237edea10a76df68065e0be70be518b68217/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017d237edea10a76df68065e0be70be518b68217/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=017d237edea10a76df68065e0be70be518b68217", "patch": "@@ -1,3 +1,30 @@\n+2016-06-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.ads (Build_Classwide_Expression): new procedure to\n+\tbuild the expression for an inherited classwide condition, and\n+\tto validate such expressions when they apply to an inherited\n+\toperation that is not overridden.\n+\t* sem_prag.adb (Primitives_Mapping): new data structure to\n+\thandle the mapping between operations of a root type and the\n+\tcorresponding overriding operations of a type extension. Used\n+\tto construct the expression for an inherited classwide condition.\n+\t(Update_Primitives_Mapping): add to Primitives_Mapping the links\n+\tbetween primitive operations of a root type and those of a given\n+\ttype extension.\n+\t(Build_Pragma_Check_Equivalent): use Primitives_Mapping.\n+\t* sem_ch6.adb (New_Overloaded_Entity): Remove call to\n+\tCollect_Iherited_Class_Wide_Conditions in GNATprove_Mode. This\n+\tneeds to be done at freeze point of the type.\n+\t* freeze.adb (Check_Inherited_Conditions): new procedure to\n+\tverify the legality of inherited classwide conditions. In normal\n+\tcompilation mode the procedure determines whether an inherited\n+\toperation needs a wrapper to handle an inherited condition that\n+\tdiffers from the condition of the root type.  In SPARK mode\n+\tthe routine invokes Collect_Inherited_Class_Wide_Conditions to\n+\tproduce the SPARK version of these inherited conditions.\n+\t(Freeze_Record_Type): For a type extension, call\n+\tCheck_Inherited_Conditions.\n+\n 2016-06-22  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch3.adb, sem_type.adb, sem.adb, freeze.adb, sem_util.adb,"}, {"sha": "271dc90abf2828d75c2b81e0705ffb1aa9dbe152", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017d237edea10a76df68065e0be70be518b68217/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017d237edea10a76df68065e0be70be518b68217/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=017d237edea10a76df68065e0be70be518b68217", "patch": "@@ -127,6 +127,11 @@ package body Freeze is\n    --  Attribute references to outer types are freeze points for those types;\n    --  this routine generates the required freeze nodes for them.\n \n+   procedure Check_Inherited_Conditions (R : Entity_Id);\n+   --  For a tagged derived type, create wrappers for inherited operations\n+   --  that have a classwide condition, so it can be properly rewritten if\n+   --  it involves calls to other overriding primitives.\n+\n    procedure Check_Strict_Alignment (E : Entity_Id);\n    --  E is a base type. If E is tagged or has a component that is aliased\n    --  or tagged or contains something this is aliased or tagged, set\n@@ -1381,6 +1386,59 @@ package body Freeze is\n       end if;\n    end Check_Expression_Function;\n \n+   --------------------------------\n+   -- Check_Inherited_Conditions --\n+   --------------------------------\n+\n+   procedure Check_Inherited_Conditions (R : Entity_Id) is\n+      Prim_Ops : constant Elist_Id := Primitive_Operations (R);\n+      Op_Node  : Elmt_Id;\n+      Prim     : Entity_Id;\n+      Par_Prim : Entity_Id;\n+      A_Pre    : Node_Id;\n+      A_Post   : Node_Id;\n+\n+   begin\n+      Op_Node := First_Elmt (Prim_Ops);\n+      while Present (Op_Node) loop\n+         Prim := Node (Op_Node);\n+\n+         --  In SPARK mode this is where we can collect the inherited\n+         --  conditions, because we do not create the Check pragmas that\n+         --  normally convey the the modified classwide conditions on\n+         --  overriding operations.\n+\n+         if SPARK_Mode = On\n+            and then Comes_From_Source (Prim)\n+            and then Present (Overridden_Operation (Prim))\n+         then\n+            Collect_Inherited_Class_Wide_Conditions (Prim);\n+         end if;\n+\n+         --  In normal mode, we examine inherited operations to check\n+         --  whether they require a wrapper to handle inherited conditions\n+         --  that call other primitives.\n+         --  Wrapper construction TBD.\n+\n+         if not Comes_From_Source (Prim)\n+           and then Present (Alias (Prim))\n+         then\n+            Par_Prim := Alias (Prim);\n+            A_Pre  := Find_Aspect (Par_Prim, Aspect_Pre);\n+            if Present (A_Pre) and then Class_Present (A_Pre) then\n+               Build_Classwide_Expression (Expression (A_Pre), Prim);\n+            end if;\n+\n+            A_Post := Find_Aspect (Par_Prim, Aspect_Post);\n+            if Present (A_Post) and then Class_Present (A_Post) then\n+               Build_Classwide_Expression (Expression (A_Post), Prim);\n+            end if;\n+         end if;\n+\n+         Next_Elmt (Op_Node);\n+      end loop;\n+   end Check_Inherited_Conditions;\n+\n    ----------------------------\n    -- Check_Strict_Alignment --\n    ----------------------------\n@@ -1657,6 +1715,9 @@ package body Freeze is\n \n                Freeze_All (First_Entity (E), After);\n \n+               --  Analyze_Pending_Bodies (Visible_Declarations (E));\n+               --  Analyze_Pending_Bodies (Private_Declarations (E));\n+\n                End_Package_Scope (E);\n \n                if Is_Generic_Instance (E)\n@@ -4573,6 +4634,13 @@ package body Freeze is\n                end loop;\n             end;\n          end if;\n+\n+         --  For a derived tagged type, check whether inherited primitives\n+         --  might require a wrapper to handle classwide conditions.\n+\n+         if Is_Tagged_Type (Rec) and then Is_Derived_Type (Rec) then\n+            Check_Inherited_Conditions (Rec);\n+         end if;\n       end Freeze_Record_Type;\n \n       -------------------------------"}, {"sha": "5865b874f38d1c66e2e2654d49f6433a29f25310", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017d237edea10a76df68065e0be70be518b68217/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017d237edea10a76df68065e0be70be518b68217/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=017d237edea10a76df68065e0be70be518b68217", "patch": "@@ -10535,13 +10535,6 @@ package body Sem_Ch6 is\n                         Set_Convention (S, Convention (E));\n                         Check_Dispatching_Operation (S, E);\n \n-                        --  In GNATprove_Mode, create the pragmas corresponding\n-                        --  to inherited class-wide conditions.\n-\n-                        if GNATprove_Mode then\n-                           Collect_Inherited_Class_Wide_Conditions (S);\n-                        end if;\n-\n                      else\n                         Check_Dispatching_Operation (S, Empty);\n                      end if;"}, {"sha": "7f9d74ee6769b4a377256ffcca6c6f7a4bddf497", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 328, "deletions": 277, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017d237edea10a76df68065e0be70be518b68217/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017d237edea10a76df68065e0be70be518b68217/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=017d237edea10a76df68065e0be70be518b68217", "patch": "@@ -44,6 +44,7 @@ with Exp_Dist;  use Exp_Dist;\n with Exp_Util;  use Exp_Util;\n with Freeze;    use Freeze;\n with Ghost;     use Ghost;\n+with Gnatvsn;   use Gnatvsn;\n with Lib;       use Lib;\n with Lib.Writ;  use Lib.Writ;\n with Lib.Xref;  use Lib.Xref;\n@@ -88,6 +89,8 @@ with Urealp;    use Urealp;\n with Validsw;   use Validsw;\n with Warnsw;    use Warnsw;\n \n+with GNAT.HTable; use GNAT.HTable;\n+\n package body Sem_Prag is\n \n    ----------------------------------------------\n@@ -163,6 +166,40 @@ package body Sem_Prag is\n      Table_Increment      => 100,\n      Table_Name           => \"Name_Externals\");\n \n+     --------------------------------------------------------\n+     -- Handling of inherited classwide pre/postconditions --\n+     --------------------------------------------------------\n+\n+     --  Following AI12-0113, the expression for a classwide condition is\n+     --  transformed for a subprogram that inherits it, by replacing calls\n+     --  to primitive operations of the original controlling type into the\n+     --  corresponding overriding operations of the derived type. The following\n+     --  hash table manages this mapping, and is expanded on demand whenever\n+     --  such inherited expression needs to be constructed.\n+\n+     --  The mapping is also used to check whether an inherited operation has\n+     --  a condition that depends on overridden operations. For such an\n+     --  operation we must create a wrapper that is then treated as a normal\n+     --  overriding. In SPARK mode such operations are illegal.\n+\n+     --  For a given root type there may be several type extensions with their\n+     --  own overriding operations, so at various times a given operation of\n+     --  the root will be mapped into different overridings. The root type is\n+     --  also mapped into the current type extension to indicate that its\n+     --  operations are mapped into the overriding operations of that current\n+     --  type extension.\n+\n+      subtype Num_Primitives is Integer range 0 .. 510;\n+      function Entity_Hash (E : Entity_Id) return Num_Primitives;\n+\n+      package Primitives_Mapping is new Gnat.HTable.Simple_Htable\n+        (Header_Num => Num_Primitives,\n+         Key        => Entity_Id,\n+         Element    => Entity_Id,\n+         No_element => Empty,\n+         Hash       => Entity_Hash,\n+         Equal      => \"=\");\n+\n    -------------------------------------\n    -- Local Subprograms and Variables --\n    -------------------------------------\n@@ -193,6 +230,11 @@ package body Sem_Prag is\n    --  Query whether a particular item appears in a mixed list of nodes and\n    --  entities. It is assumed that all nodes in the list have entities.\n \n+   --  procedure Build_Classwide_Expression (Prag : Node_Id; Subp : Entity_Id);\n+   --  Build the expression for an inherited classwide condition. Prag is\n+   --  the pragma constructed from the corresponding aspect of the parent\n+   --  subprogram, and Subp is the overridding operation.\n+\n    procedure Check_Postcondition_Use_In_Inlined_Subprogram\n      (Prag    : Node_Id;\n       Spec_Id : Entity_Id);\n@@ -289,6 +331,14 @@ package body Sem_Prag is\n    pragma Volatile (Dummy);\n    --  Dummy volatile integer used in bodies of ip/rv to prevent optimization\n \n+   procedure Update_Primitives_Mapping\n+     (Inher_Id : Entity_Id;\n+      Subp_Id  : Entity_Id);\n+\n+   --  map primitive operations of the parent type to the corresponding\n+   --  operations of the descendant. note that the descendant type may\n+   --  not be frozen yet, so we cannot use the dispatch table directly.\n+\n    procedure ip;\n    pragma No_Inline (ip);\n    --  A dummy procedure called when pragma Inspection_Point is analyzed. This\n@@ -17580,28 +17630,39 @@ package body Sem_Prag is\n             Check_Valid_Configuration_Pragma;\n             Check_Arg_Count (0);\n \n-            No_Run_Time_Mode           := True;\n-            Configurable_Run_Time_Mode := True;\n+            --  Remove backward compatibility if Build_Type is FSF or GPL\n+            --  and generate a warning.\n \n-            --  Set Duration to 32 bits if word size is 32\n+            declare\n+               Ignore : constant Boolean := Build_Type in FSF .. GPL;\n+            begin\n+               if Ignore then\n+                  Error_Pragma (\"pragma% is ignored, has no effect??\");\n+               else\n+                  No_Run_Time_Mode           := True;\n+                  Configurable_Run_Time_Mode := True;\n \n-            if Ttypes.System_Word_Size = 32 then\n-               Duration_32_Bits_On_Target := True;\n-            end if;\n+                  --  Set Duration to 32 bits if word size is 32\n \n-            --  Set appropriate restrictions\n+                  if Ttypes.System_Word_Size = 32 then\n+                     Duration_32_Bits_On_Target := True;\n+                  end if;\n \n-            Set_Restriction (No_Finalization, N);\n-            Set_Restriction (No_Exception_Handlers, N);\n-            Set_Restriction (Max_Tasks, N, 0);\n-            Set_Restriction (No_Tasking, N);\n+                  --  Set appropriate restrictions\n \n-            -----------------------\n-            -- No_Tagged_Streams --\n-            -----------------------\n+                  Set_Restriction (No_Finalization, N);\n+                  Set_Restriction (No_Exception_Handlers, N);\n+                  Set_Restriction (Max_Tasks, N, 0);\n+                  Set_Restriction (No_Tasking, N);\n+               end if;\n+            end;\n \n-            --  pragma No_Tagged_Streams;\n-            --  pragma No_Tagged_Streams ([Entity => ]tagged_type_local_NAME);\n+         -----------------------\n+         -- No_Tagged_Streams --\n+         -----------------------\n+\n+         --  pragma No_Tagged_Streams;\n+         --  pragma No_Tagged_Streams ([Entity => ]tagged_type_local_NAME);\n \n          when Pragma_No_Tagged_Streams => No_Tagged_Strms : declare\n             E    : Entity_Id;\n@@ -22295,22 +22356,7 @@ package body Sem_Prag is\n \n          when Pragma_Universal_Data =>\n             GNAT_Pragma;\n-\n-            --  If this is a configuration pragma, then set the universal\n-            --  addressing option, otherwise confirm that the pragma satisfies\n-            --  the requirements of library unit pragma placement and leave it\n-            --  to the GNAAMP back end to detect the pragma (avoids transitive\n-            --  setting of the option due to withed units).\n-\n-            if Is_Configuration_Pragma then\n-               Universal_Addressing_On_AAMP := True;\n-            else\n-               Check_Valid_Library_Unit_Pragma;\n-            end if;\n-\n-            if not AAMP_On_Target then\n-               Error_Pragma (\"??pragma% ignored (applies only to AAMP)\");\n-            end if;\n+            Error_Pragma (\"??pragma% ignored (applies only to AAMP)\");\n \n          ----------------\n          -- Unmodified --\n@@ -26291,104 +26337,13 @@ package body Sem_Prag is\n       Inher_Id       : Entity_Id := Empty;\n       Keep_Pragma_Id : Boolean := False) return Node_Id\n    is\n-      Map : Elist_Id;\n-      --  List containing the following mappings\n-      --    * Formal parameters of inherited subprogram Inher_Id and subprogram\n-      --    Subp_Id.\n-      --\n-      --    * The dispatching type of Inher_Id and the dispatching type of\n-      --    Subp_Id.\n-      --\n-      --    * Primitives of the dispatching type of Inher_Id and primitives of\n-      --    the dispatching type of Subp_Id.\n-\n-      function Replace_Entity (N : Node_Id) return Traverse_Result;\n-      --  Replace reference to formal of inherited operation or to primitive\n-      --  operation of root type, with corresponding entity for derived type.\n \n       function Suppress_Reference (N : Node_Id) return Traverse_Result;\n       --  Detect whether node N references a formal parameter subject to\n       --  pragma Unreferenced. If this is the case, set Comes_From_Source\n       --  to False to suppress the generation of a reference when analyzing\n       --  N later on.\n \n-      --------------------\n-      -- Replace_Entity --\n-      --------------------\n-\n-      function Replace_Entity (N : Node_Id) return Traverse_Result is\n-         Elmt  : Elmt_Id;\n-         New_E : Entity_Id;\n-\n-      begin\n-         if Nkind (N) = N_Identifier\n-           and then Present (Entity (N))\n-           and then\n-             (Is_Formal (Entity (N)) or else Is_Subprogram (Entity (N)))\n-           and then\n-             (Nkind (Parent (N)) /= N_Attribute_Reference\n-               or else Attribute_Name (Parent (N)) /= Name_Class)\n-         then\n-            --  The replacement does not apply to dispatching calls within the\n-            --  condition, but only to calls whose static tag is that of the\n-            --  parent type.\n-\n-            if Is_Subprogram (Entity (N))\n-              and then Nkind (Parent (N)) = N_Function_Call\n-              and then Present (Controlling_Argument (Parent (N)))\n-            then\n-               return OK;\n-            end if;\n-\n-            --  Loop to find out if entity has a renaming\n-\n-            New_E := Empty;\n-            Elmt  := First_Elmt (Map);\n-            while Present (Elmt) loop\n-               if Node (Elmt) = Entity (N) then\n-                  New_E := Node (Next_Elmt (Elmt));\n-                  exit;\n-               end if;\n-\n-               Next_Elmt (Elmt);\n-            end loop;\n-\n-            if Present (New_E) then\n-               Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n-            end if;\n-\n-            --  Check that there are no calls left to abstract operations if\n-            --  the current subprogram is not abstract.\n-\n-            if Nkind (Parent (N)) = N_Function_Call\n-              and then N = Name (Parent (N))\n-              and then not Is_Abstract_Subprogram (Subp_Id)\n-              and then Is_Abstract_Subprogram (Entity (N))\n-            then\n-               Error_Msg_Sloc := Sloc (Current_Scope);\n-               Error_Msg_NE\n-                 (\"cannot call abstract subprogram in inherited condition \"\n-                   & \"for&#\", N, Current_Scope);\n-            end if;\n-\n-            --  Update type of function call node, which should be the same as\n-            --  the function's return type.\n-\n-            if Is_Subprogram (Entity (N))\n-              and then Nkind (Parent (N)) = N_Function_Call\n-            then\n-               Set_Etype (Parent (N), Etype (Entity (N)));\n-            end if;\n-\n-         --  The whole expression will be reanalyzed\n-\n-         elsif Nkind (N) in N_Has_Etype then\n-            Set_Analyzed (N, False);\n-         end if;\n-\n-         return OK;\n-      end Replace_Entity;\n-\n       ------------------------\n       -- Suppress_Reference --\n       ------------------------\n@@ -26414,9 +26369,6 @@ package body Sem_Prag is\n          return OK;\n       end Suppress_Reference;\n \n-      procedure Replace_Condition_Entities is\n-        new Traverse_Proc (Replace_Entity);\n-\n       procedure Suppress_References is\n         new Traverse_Proc (Suppress_Reference);\n \n@@ -26433,8 +26385,6 @@ package body Sem_Prag is\n    --  Start of processing for Build_Pragma_Check_Equivalent\n \n    begin\n-      Map := No_Elist;\n-\n       --  When the pre- or postcondition is inherited, map the formals of the\n       --  inherited subprogram to those of the current subprogram. In addition,\n       --  map primitive operations of the parent type into the corresponding\n@@ -26443,170 +26393,26 @@ package body Sem_Prag is\n       if Present (Inher_Id) then\n          pragma Assert (Present (Subp_Id));\n \n-         Map := New_Elmt_List;\n+         Update_Primitives_Mapping (Inher_Id, Subp_Id);\n \n-         --  Create a mapping  <inherited formal> => <subprogram formal>\n+         --  Add mapping from old formals to new formals.\n \n          Inher_Formal := First_Formal (Inher_Id);\n          Subp_Formal  := First_Formal (Subp_Id);\n          while Present (Inher_Formal) and then Present (Subp_Formal) loop\n-            Append_Elmt (Inher_Formal, Map);\n-            Append_Elmt (Subp_Formal,  Map);\n-\n+            Primitives_Mapping.Set (Inher_Formal, Subp_Formal);\n             Next_Formal (Inher_Formal);\n             Next_Formal (Subp_Formal);\n          end loop;\n-\n-         --  Map primitive operations of the parent type to the corresponding\n-         --  operations of the descendant. Note that the descendant type may\n-         --  not be frozen yet, so we cannot use the dispatch table directly.\n-\n-         --  Note : the construction of the map involves a full traversal of\n-         --  the list of primitive operations, as well as a scan of the\n-         --  declarations in the scope of the operation. Given that class-wide\n-         --  conditions are typically short expressions, it might be much more\n-         --  efficient to collect the identifiers in the expression first, and\n-         --  then determine the ones that have to be mapped. Optimization ???\n-\n-         Primitive_Mapping : declare\n-            function Overridden_Ancestor (S : Entity_Id) return Entity_Id;\n-            --  Given the controlling type of the overridden operation and a\n-            --  primitive of the current type, find the corresponding operation\n-            --  of the parent type.\n-\n-            -------------------------\n-            -- Overridden_Ancestor --\n-            -------------------------\n-\n-            function Overridden_Ancestor (S : Entity_Id) return Entity_Id is\n-               Par : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n-               Anc : Entity_Id;\n-\n-            begin\n-               Anc := S;\n-\n-               --  Locate the ancestor subprogram with the proper controlling\n-               --  type.\n-\n-               while Present (Overridden_Operation (Anc)) loop\n-                  Anc := Overridden_Operation (Anc);\n-                  exit when Find_Dispatching_Type (Anc) = Par;\n-               end loop;\n-\n-               return Anc;\n-            end Overridden_Ancestor;\n-\n-            --  Local variables\n-\n-            Old_Typ  : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n-            Typ      : constant Entity_Id := Find_Dispatching_Type (Subp_Id);\n-            Decl     : Node_Id;\n-            Old_Elmt : Elmt_Id;\n-            Old_Prim : Entity_Id;\n-            Prim     : Entity_Id;\n-\n-         --  Start of processing for Primitive_Mapping\n-\n-         begin\n-            Decl := First (List_Containing (Unit_Declaration_Node (Subp_Id)));\n-\n-            --  Look for primitive operations of the current type that have\n-            --  overridden an operation of the type related to the original\n-            --  class-wide precondition. There may be several intermediate\n-            --  overridings between them.\n-\n-            while Present (Decl) loop\n-               if Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n-                                  N_Subprogram_Declaration)\n-               then\n-                  Prim := Defining_Entity (Decl);\n-\n-                  if Is_Subprogram (Prim)\n-                    and then Present (Overridden_Operation (Prim))\n-                    and then Find_Dispatching_Type (Prim) = Typ\n-                  then\n-                     Old_Prim := Overridden_Ancestor (Prim);\n-\n-                     Append_Elmt (Old_Prim, Map);\n-                     Append_Elmt (Prim,     Map);\n-                  end if;\n-               end if;\n-\n-               Next (Decl);\n-            end loop;\n-\n-            --  Now examine inherited operations. These do not override, but\n-            --  have an alias, which is the entity used in a call. In turn\n-            --  that alias may be inherited or comes from source, in which\n-            --  case it may override an earlier operation. We only need to\n-            --  examine inherited functions, that may appear within the\n-            --  inherited expression.\n-\n-            Prim := First_Entity (Scope (Subp_Id));\n-            while Present (Prim) loop\n-               if not Comes_From_Source (Prim)\n-                 and then Ekind (Prim) = E_Function\n-                 and then Present (Alias (Prim))\n-               then\n-                  Old_Prim := Alias (Prim);\n-\n-                  if Comes_From_Source (Old_Prim) then\n-                     Old_Prim := Overridden_Ancestor (Old_Prim);\n-\n-                  else\n-                     while Present (Alias (Old_Prim))\n-                       and then Scope (Old_Prim) /= Scope (Inher_Id)\n-                     loop\n-                        Old_Prim := Alias (Old_Prim);\n-\n-                        if Comes_From_Source (Old_Prim) then\n-                           Old_Prim := Overridden_Ancestor (Old_Prim);\n-                           exit;\n-                        end if;\n-                     end loop;\n-                  end if;\n-\n-                  Append_Elmt (Old_Prim, Map);\n-                  Append_Elmt (Prim,     Map);\n-               end if;\n-\n-               Next_Entity (Prim);\n-            end loop;\n-\n-            --  If the parent operation is an interface operation, the\n-            --  overriding indicator is not present. Instead, we get from\n-            --  the interface operation the primitive of the current type\n-            --  that implements it.\n-\n-            if Is_Interface (Old_Typ) then\n-               Old_Elmt := First_Elmt (Collect_Primitive_Operations (Old_Typ));\n-               while Present (Old_Elmt) loop\n-                  Old_Prim := Node (Old_Elmt);\n-                  Prim := Find_Primitive_Covering_Interface (Typ, Old_Prim);\n-\n-                  if Present (Prim) then\n-                     Append_Elmt (Old_Prim, Map);\n-                     Append_Elmt (Prim,     Map);\n-                  end if;\n-\n-                  Next_Elmt (Old_Elmt);\n-               end loop;\n-            end if;\n-\n-            if Map /= No_Elist then\n-               Append_Elmt (Old_Typ, Map);\n-               Append_Elmt (Typ,     Map);\n-            end if;\n-         end Primitive_Mapping;\n       end if;\n \n       --  Copy the original pragma while performing substitutions (if\n       --  applicable).\n \n       Check_Prag := New_Copy_Tree (Source => Prag);\n \n-      if Map /= No_Elist then\n-         Replace_Condition_Entities (Check_Prag);\n+      if Present (Inher_Id) then\n+         Build_Classwide_Expression (Check_Prag, Subp_Id);\n       end if;\n \n       --  Mark the pragma as being internally generated and reset the Analyzed\n@@ -27029,6 +26835,100 @@ package body Sem_Prag is\n       end if;\n    end Check_Missing_Part_Of;\n \n+   --------------------------------\n+   -- Build_Classwide_Expression --\n+   --------------------------------\n+\n+   procedure Build_Classwide_Expression (Prag : Node_Id; Subp : Entity_Id) is\n+      function Replace_Entity (N : Node_Id) return Traverse_Result;\n+      --  Replace reference to formal of inherited operation or to primitive\n+      --  operation of root type, with corresponding entity for derived type,\n+      --  when constructing the classwide condition of an overridding\n+      --  subprogram.\n+\n+      --------------------\n+      -- Replace_Entity --\n+      --------------------\n+\n+      function Replace_Entity (N : Node_Id) return Traverse_Result is\n+         New_E : Entity_Id;\n+\n+      begin\n+         if Nkind (N) = N_Identifier\n+           and then Present (Entity (N))\n+           and then\n+             (Is_Formal (Entity (N)) or else Is_Subprogram (Entity (N)))\n+           and then\n+             (Nkind (Parent (N)) /= N_Attribute_Reference\n+               or else Attribute_Name (Parent (N)) /= Name_Class)\n+         then\n+            --  The replacement does not apply to dispatching calls within the\n+            --  condition, but only to calls whose static tag is that of the\n+            --  parent type.\n+\n+            if Is_Subprogram (Entity (N))\n+              and then Nkind (Parent (N)) = N_Function_Call\n+              and then Present (Controlling_Argument (Parent (N)))\n+            then\n+               return OK;\n+            end if;\n+\n+            --  Determine whether entity has a renaming\n+\n+            New_E := Primitives_Mapping.Get (Entity (N));\n+\n+            if Present (New_E) then\n+               Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n+            end if;\n+\n+            --  Check that there are no calls left to abstract operations if\n+            --  the current subprogram is not abstract.\n+\n+            if Nkind (Parent (N)) = N_Function_Call\n+              and then N = Name (Parent (N))\n+            then\n+               if not Is_Abstract_Subprogram (Subp)\n+                 and then Is_Abstract_Subprogram (Entity (N))\n+               then\n+                  Error_Msg_Sloc := Sloc (Current_Scope);\n+                  Error_Msg_NE\n+                    (\"cannot call abstract subprogram in inherited condition \"\n+                      & \"for&#\", N, Current_Scope);\n+\n+               elsif Present (Alias (Subp))\n+                 and then Warn_On_Suspicious_Contract\n+                 and then SPARK_Mode = On\n+               then\n+                  Error_Msg_NE (\"?inherited condition is modified, \"\n+                  & \"build a wrapper for&\", Parent (Subp), Subp);\n+               end if;\n+            end if;\n+\n+            --  Update type of function call node, which should be the same as\n+            --  the function's return type.\n+\n+            if Is_Subprogram (Entity (N))\n+              and then Nkind (Parent (N)) = N_Function_Call\n+            then\n+               Set_Etype (Parent (N), Etype (Entity (N)));\n+            end if;\n+\n+         --  The whole expression will be reanalyzed\n+\n+         elsif Nkind (N) in N_Has_Etype then\n+            Set_Analyzed (N, False);\n+         end if;\n+\n+         return OK;\n+      end Replace_Entity;\n+\n+      procedure Replace_Condition_Entities is\n+        new Traverse_Proc (Replace_Entity);\n+\n+   begin\n+      Replace_Condition_Entities (Prag);\n+   end Build_Classwide_Expression;\n+\n    ---------------------------------------------------\n    -- Check_Postcondition_Use_In_Inlined_Subprogram --\n    ---------------------------------------------------\n@@ -27948,6 +27848,15 @@ package body Sem_Prag is\n       return Result;\n    end Get_Base_Subprogram;\n \n+   -----------------\n+   -- Entity_Hash --\n+   -----------------\n+\n+   function Entity_Hash (E : Entity_Id) return Num_Primitives is\n+   begin\n+      return Num_Primitives (E mod 511);\n+   end Entity_Hash;\n+\n    -----------------------\n    -- Get_SPARK_Mode_Type --\n    -----------------------\n@@ -29195,6 +29104,148 @@ package body Sem_Prag is\n       Generate_Reference (Entity (With_Item), N, Set_Ref => False);\n    end Set_Elab_Unit_Name;\n \n+   -------------------------------\n+   -- Update_Primitives_Mapping --\n+   -------------------------------\n+\n+   procedure Update_Primitives_Mapping\n+     (Inher_Id : Entity_Id;\n+      Subp_Id  : Entity_Id)\n+   is\n+      function Overridden_Ancestor (S : Entity_Id) return Entity_Id;\n+\n+      -------------------------\n+      -- Overridden_Ancestor --\n+      -------------------------\n+\n+      function Overridden_Ancestor (S : Entity_Id) return Entity_Id is\n+         Par : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n+         Anc : Entity_Id;\n+\n+      begin\n+         Anc := S;\n+\n+         --  Locate the ancestor subprogram with the proper controlling\n+         --  type.\n+\n+         while Present (Overridden_Operation (Anc)) loop\n+            Anc := Overridden_Operation (Anc);\n+            exit when Find_Dispatching_Type (Anc) = Par;\n+         end loop;\n+\n+         return Anc;\n+      end Overridden_Ancestor;\n+\n+      --  Local variables\n+\n+      Old_Typ  : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n+      Typ      : constant Entity_Id := Find_Dispatching_Type (Subp_Id);\n+      Decl     : Node_Id;\n+      Old_Elmt : Elmt_Id;\n+      Old_Prim : Entity_Id;\n+      Prim     : Entity_Id;\n+\n+   --  Start of processing for Primitive_Mapping\n+\n+   begin\n+      --  if the types are already in the map, it has been previously built\n+      --  for some other overriding primitive.\n+\n+      if Primitives_Mapping.Get (Old_Typ)  = Typ then\n+         return;\n+\n+      else\n+\n+         --  initialize new mapping with the primitive operations.\n+\n+         Decl := First (List_Containing (Unit_Declaration_Node (Subp_Id)));\n+\n+         --  look for primitive operations of the current type that have\n+         --  overridden an operation of the type related to the original\n+         --  class-wide precondition. there may be several intermediate\n+         --  overridings between them.\n+\n+         while Present (Decl) loop\n+            if Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n+                               N_Subprogram_Declaration)\n+            then\n+               Prim := Defining_Entity (Decl);\n+\n+               if Is_Subprogram (Prim)\n+                 and then Present (Overridden_Operation (Prim))\n+                 and then Find_Dispatching_Type (Prim) = Typ\n+               then\n+                  Old_Prim := Overridden_Ancestor (Prim);\n+\n+                  Primitives_Mapping.Set (Old_Prim, Prim);\n+               end if;\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+\n+         --  now examine inherited operations. these do not override, but have\n+         --  an alias, which is the entity used in a call. that alias may be\n+         --  inherited or come from source, in which case it may override an\n+         --  earlier operation. we only need to examine inherited functions,\n+         --  that can appear within the inherited expression.\n+\n+         Prim := First_Entity (Scope (Subp_Id));\n+         while Present (Prim) loop\n+            if not Comes_From_Source (Prim)\n+              and then Ekind (Prim) = E_Function\n+              and then Present (Alias (Prim))\n+            then\n+               Old_Prim := Alias (Prim);\n+\n+               if Comes_From_Source (Old_Prim) then\n+                  Old_Prim := Overridden_Ancestor (Old_Prim);\n+\n+               else\n+                  while Present (Alias (Old_Prim))\n+                    and then Scope (Old_Prim) /= Scope (Inher_Id)\n+                  loop\n+                     Old_Prim := Alias (Old_Prim);\n+\n+                     if Comes_From_Source (Old_Prim) then\n+                        Old_Prim := Overridden_Ancestor (Old_Prim);\n+                        exit;\n+                     end if;\n+                  end loop;\n+               end if;\n+\n+               Primitives_Mapping.Set (Old_Prim, Prim);\n+            end if;\n+\n+            Next_Entity (Prim);\n+         end loop;\n+\n+         --  if the parent operation is an interface operation, the\n+         --  overriding indicator is not present. instead, we get from\n+         --  the interface operation the primitive of the current type\n+         --  that implements it.\n+\n+         if Is_Interface (Old_Typ) then\n+            Old_Elmt := First_Elmt (Collect_Primitive_Operations (Old_Typ));\n+            while Present (Old_Elmt) loop\n+               Old_Prim := Node (Old_Elmt);\n+               Prim := Find_Primitive_Covering_Interface (Typ, Old_Prim);\n+\n+               if Present (Prim) then\n+                  Primitives_Mapping.Set (Old_Prim, Prim);\n+               end if;\n+\n+               Next_Elmt (Old_Elmt);\n+            end loop;\n+         end if;\n+      end if;\n+\n+      --  map the types themselves, so that the process is not repeated for\n+      --  other overriding primitives.\n+\n+      Primitives_Mapping.Set (Old_Typ, Typ);\n+   end Update_Primitives_Mapping;\n+\n    -------------------\n    -- Test_Case_Arg --\n    -------------------"}, {"sha": "064534f6ee34a1abd4db6373c03b8deb3c4e1b07", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017d237edea10a76df68065e0be70be518b68217/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017d237edea10a76df68065e0be70be518b68217/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=017d237edea10a76df68065e0be70be518b68217", "patch": "@@ -244,6 +244,17 @@ package Sem_Prag is\n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id);\n    --  Perform preanalysis of pragma Test_Case\n \n+   procedure Build_Classwide_Expression (Prag : Node_Id; Subp : Entity_Id);\n+   --  Build the expression for an inherited classwide condition. Prag is\n+   --  the pragma constructed from the corresponding aspect of the parent\n+   --  subprogram, and Subp is the overridding operation.\n+   --  The routine is also called to check whether an inherited operation\n+   --  that is not overridden but has inherited conditions need a wrapper,\n+   --  because the inherited condition includes calls to other primitives that\n+   --  have been overridden. In that case the first argument is the expression\n+   --  of the original classwide aspect. In SPARK_Mode, such operation which\n+   --  are just inherited but have modified pre/postconditions are illegal.\n+\n    function Build_Pragma_Check_Equivalent\n      (Prag           : Node_Id;\n       Subp_Id        : Entity_Id := Empty;"}]}