{"sha": "b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVlNjI0YzZkYzJjZmJjMWJjNDFmYzRmNGI3MGEzMjBmMGYwY2FkYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-01T14:17:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-01T14:17:36Z"}, "message": "local-alloc.c (update_equiv_regs): Use gcc_assert, gcc_unreachable.\n\n\t* local-alloc.c (update_equiv_regs): Use gcc_assert, gcc_unreachable.\n\t(block_alloc, find_free_reg): Likewise.\n\t* loop-doloop.c (doloop_modify): Likewise.\n\t* loop-invariant.c (record_use): Likewise.\n\t* loop-iv.c (get_biv_step_1, get_biv_step, iv_analyze,\n\tget_iv_value, canon_condition, eliminate_implied_condition,\n\teliminate_implied_condition, simplify_using_initial_values,\n\tshorten_into_mode, canonicalize_iv_subregs,\n\tiv_number_of_iterations): Likewise.\n\t* loop-unroll.c (expand_var_during_unrolling): Likewise.\n\t* loop-unswitch.c (compare_and_jump_seq, unswitch_single_loop,\n\tunswitch_loop): Likewise.\n\t* loop.c (INSN_LUID, loop_optimize, rtx_equal_for_loop_p,\n\tmove_movables, replace_call_address, find_and_verify_loops,\n\trtx_equal_for_prefetch_p, fold_rtx_mult_add, loop_iterations,\n\trecord_giv, final_giv_value, general_induction_var,\n\tsimplify_giv_expr, extension_within_bounds_p, try_copy_prop,\n\tloop_giv_dump): Likewise.\n\nFrom-SVN: r97394", "tree": {"sha": "2faae66acc9a81f1dddcb31724e669a2eb325a04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2faae66acc9a81f1dddcb31724e669a2eb325a04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/comments", "author": null, "committer": null, "parents": [{"sha": "71df4441367b6ed747ccc97431f1a63fc68ee00b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71df4441367b6ed747ccc97431f1a63fc68ee00b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71df4441367b6ed747ccc97431f1a63fc68ee00b"}], "stats": {"total": 289, "additions": 134, "deletions": 155}, "files": [{"sha": "cbd884f7fd3b509333db4caa3e321758b55b4964", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "patch": "@@ -1,5 +1,24 @@\n 2005-04-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* local-alloc.c (update_equiv_regs): Use gcc_assert, gcc_unreachable.\n+\t(block_alloc, find_free_reg): Likewise.\n+\t* loop-doloop.c (doloop_modify): Likewise.\n+\t* loop-invariant.c (record_use): Likewise.\n+\t* loop-iv.c (get_biv_step_1, get_biv_step, iv_analyze,\n+\tget_iv_value, canon_condition, eliminate_implied_condition,\n+\teliminate_implied_condition, simplify_using_initial_values,\n+\tshorten_into_mode, canonicalize_iv_subregs,\n+\tiv_number_of_iterations): Likewise.\n+\t* loop-unroll.c (expand_var_during_unrolling): Likewise.\n+\t* loop-unswitch.c (compare_and_jump_seq, unswitch_single_loop,\n+\tunswitch_loop): Likewise.\n+\t* loop.c (INSN_LUID, loop_optimize, rtx_equal_for_loop_p,\n+\tmove_movables, replace_call_address, find_and_verify_loops,\n+\trtx_equal_for_prefetch_p, fold_rtx_mult_add, loop_iterations,\n+\trecord_giv, final_giv_value, general_induction_var,\n+\tsimplify_giv_expr, extension_within_bounds_p, try_copy_prop,\n+\tloop_giv_dump): Likewise.\n+\n \t* gcov-io.h (GCOV_CHECK, GCOV_CHECK_READING,\n \tGCOV_CHECK_WRITING): Remove.\n \t(gcov_position, gcov_rewrite): Use gcc_assert."}, {"sha": "3969a86c2ece9dcd370133f5723eb790769cc36f", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "patch": "@@ -1032,9 +1032,8 @@ update_equiv_regs (void)\n \t\t     once and used once.  (If it were only set, but not used,\n \t\t     flow would have deleted the setting insns.)  Hence\n \t\t     there can only be one insn in reg_equiv[REGNO].init_insns.  */\n-\t\t  if (reg_equiv[regno].init_insns == NULL_RTX\n-\t\t      || XEXP (reg_equiv[regno].init_insns, 1) != NULL_RTX)\n-\t\t    abort ();\n+\t\t  gcc_assert (reg_equiv[regno].init_insns\n+\t\t\t      && !XEXP (reg_equiv[regno].init_insns, 1));\n \t\t  equiv_insn = XEXP (reg_equiv[regno].init_insns, 0);\n \n \t\t  /* We may not move instructions that can throw, since\n@@ -1196,8 +1195,10 @@ block_alloc (int b)\n   while (1)\n     {\n       if (!NOTE_P (insn))\n-\tif (++insn_count > max_uid)\n-\t  abort ();\n+\t{\n+\t  ++insn_count;\n+\t  gcc_assert (insn_count <= max_uid);\n+\t}\n       if (insn == BB_HEAD (BASIC_BLOCK (b)))\n \tbreak;\n       insn = PREV_INSN (insn);\n@@ -2117,8 +2118,7 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n #endif\n \n   /* Validate our parameters.  */\n-  if (born_index < 0 || born_index > dead_index)\n-    abort ();\n+  gcc_assert (born_index >= 0 && born_index <= dead_index);\n \n   /* Don't let a pseudo live in a reg across a function call\n      if we might get a nonlocal goto.  */"}, {"sha": "c6ef37e84d6f5cd3e14fa796a2118c399b267c98", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "patch": "@@ -299,21 +299,17 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n     {\n     case NE:\n       /* Currently only NE tests against zero and one are supported.  */\n-      if (XEXP (condition, 1) == const1_rtx)\n+      noloop = XEXP (condition, 1);\n+      if (noloop != const0_rtx)\n \t{\n+\t  gcc_assert (noloop == const1_rtx);\n \t  increment_count = true;\n-\t  noloop = const1_rtx;\n \t}\n-      else if (XEXP (condition, 1) == const0_rtx)\n-       \tnoloop = const0_rtx;\n-      else\n-\tabort ();\n       break;\n \n     case GE:\n       /* Currently only GE tests against zero are supported.  */\n-      if (XEXP (condition, 1) != const0_rtx)\n-\tabort ();\n+      gcc_assert (XEXP (condition, 1) == const0_rtx);\n \n       noloop = constm1_rtx;\n \n@@ -330,7 +326,7 @@ doloop_modify (struct loop *loop, struct niter_desc *desc,\n \n       /* Abort if an invalid doloop pattern has been generated.  */\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   if (increment_count)"}, {"sha": "7639373ee71e01f8bb9a2b9cda6ac339321659f2", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "patch": "@@ -355,8 +355,7 @@ record_use (struct def *def, rtx *use, rtx insn)\n \n   if (GET_CODE (*use) == SUBREG)\n     use = &SUBREG_REG (*use);\n-  if (!REG_P (*use))\n-    abort ();\n+  gcc_assert (REG_P (*use));\n \n   u->pos = use;\n   u->insn = insn;"}, {"sha": "09ed73c6324287ac566e1fe403d066fb37f4ef0f", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 35, "deletions": 46, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "patch": "@@ -793,16 +793,15 @@ get_biv_step_1 (rtx insn, rtx reg,\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n-      if (GET_MODE (op0) != *inner_mode\n-\t  || *extend != UNKNOWN\n-\t  || *outer_step != const0_rtx)\n-\tabort ();\n+      gcc_assert (GET_MODE (op0) == *inner_mode\n+\t\t  && *extend == UNKNOWN\n+\t\t  && *outer_step == const0_rtx);\n \n       *extend = code;\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return true;\n@@ -826,17 +825,8 @@ get_biv_step (rtx reg, rtx *inner_step, enum machine_mode *inner_mode,\n \t\t       outer_step))\n     return false;\n \n-  if (*inner_mode != *outer_mode\n-      && *extend == UNKNOWN)\n-    abort ();\n-\n-  if (*inner_mode == *outer_mode\n-      && *extend != UNKNOWN)\n-    abort ();\n-\n-  if (*inner_mode == *outer_mode\n-      && *outer_step != const0_rtx)\n-    abort ();\n+  gcc_assert ((*inner_mode == *outer_mode) != (*extend != UNKNOWN));\n+  gcc_assert (*inner_mode != *outer_mode || *outer_step == const0_rtx);\n \n   return true;\n }\n@@ -1085,23 +1075,21 @@ iv_analyze (rtx insn, rtx def, struct rtx_iv *iv)\n \t  mby = XEXP (rhs, 1);\n \t  if (!CONSTANT_P (mby))\n \t    {\n-\t      if (!CONSTANT_P (op0))\n-\t\tabort ();\n+\t      gcc_assert (CONSTANT_P (op0));\n \t      tmp = op0;\n \t      op0 = mby;\n \t      mby = tmp;\n \t    }\n \t  break;\n \n \tcase ASHIFT:\n-\t  if (CONSTANT_P (XEXP (rhs, 0)))\n-\t    abort ();\n+\t  gcc_assert (!CONSTANT_P (XEXP (rhs, 0)));\n \t  op0 = XEXP (rhs, 0);\n \t  mby = XEXP (rhs, 1);\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       amode = GET_MODE (rhs);\n@@ -1210,8 +1198,7 @@ get_iv_value (struct rtx_iv *iv, rtx iteration)\n \n   /* We would need to generate some if_then_else patterns, and so far\n      it is not needed anywhere.  */\n-  if (iv->first_special)\n-    abort ();\n+  gcc_assert (!iv->first_special);\n \n   if (iv->step != const0_rtx && iteration != const0_rtx)\n     val = simplify_gen_binary (PLUS, iv->extend_mode, iv->base,\n@@ -1547,8 +1534,7 @@ canon_condition (rtx cond)\n   mode = GET_MODE (op0);\n   if (mode == VOIDmode)\n     mode = GET_MODE (op1);\n-  if (mode == VOIDmode)\n-    abort ();\n+  gcc_assert (mode != VOIDmode);\n \n   if (GET_CODE (op1) == CONST_INT\n       && GET_MODE_CLASS (mode) != MODE_CC\n@@ -1677,20 +1663,23 @@ simplify_using_condition (rtx cond, rtx *expr, regset altered)\n static void\n eliminate_implied_condition (enum rtx_code op, rtx a, rtx *b)\n {\n-  if (op == AND)\n+  switch (op)\n     {\n+    case AND:\n       /* If A implies *B, we may replace *B by true.  */\n       if (implies_p (a, *b))\n \t*b = const_true_rtx;\n-    }\n-  else if (op == IOR)\n-    {\n+      break;\n+\n+    case IOR:\n       /* If *B implies A, we may replace *B by false.  */\n       if (implies_p (*b, a))\n \t*b = const0_rtx;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n }\n \n /* Eliminates the conditions in TAIL that are implied by HEAD.  OP is the\n@@ -1731,19 +1720,22 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n \n       eliminate_implied_conditions (op, &head, tail);\n \n-      if (op == AND)\n+      switch (op)\n \t{\n+\tcase AND:\n \t  neutral = const_true_rtx;\n \t  aggr = const0_rtx;\n-\t}\n-      else if (op == IOR)\n-\t{\n+\t  break;\n+\n+\tcase IOR:\n \t  neutral = const0_rtx;\n \t  aggr = const_true_rtx;\n-\t}\n-      else\n-\tabort ();\n+\t  break;\n \n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      \n       simplify_using_initial_values (loop, UNKNOWN, &head);\n       if (head == aggr)\n \t{\n@@ -1770,8 +1762,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n       return;\n     }\n \n-  if (op != UNKNOWN)\n-    abort ();\n+  gcc_assert (op == UNKNOWN);\n \n   e = loop_preheader_edge (loop);\n   if (e->src == ENTRY_BLOCK_PTR)\n@@ -1873,7 +1864,7 @@ shorten_into_mode (struct rtx_iv *iv, enum machine_mode mode,\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   iv->mode = mode;\n@@ -1931,7 +1922,7 @@ canonicalize_iv_subregs (struct rtx_iv *iv0, struct rtx_iv *iv1,\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n \n   /* Values of both variables should be computed in the same mode.  These\n@@ -2031,15 +2022,13 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   desc->niter_max = 0;\n \n   cond = GET_CODE (condition);\n-  if (!COMPARISON_P (condition))\n-    abort ();\n+  gcc_assert (COMPARISON_P (condition));\n \n   mode = GET_MODE (XEXP (condition, 0));\n   if (mode == VOIDmode)\n     mode = GET_MODE (XEXP (condition, 1));\n   /* The constant comparisons should be folded.  */\n-  if (mode == VOIDmode)\n-    abort ();\n+  gcc_assert (mode != VOIDmode);\n \n   /* We only handle integers or pointers.  */\n   if (GET_MODE_CLASS (mode) != MODE_INT"}, {"sha": "e44dae69383323a16b2350e597c5f108a4a87dc1", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "patch": "@@ -1891,8 +1891,7 @@ expand_var_during_unrolling (struct var_to_expand *ve, rtx insn)\n   bool really_new_expansion = false;\n   \n   set = single_set (insn);\n-  if (!set)\n-    abort ();\n+  gcc_assert (set);\n   \n   /* Generate a new register only if the expansion limit has not been\n      reached.  Else reuse an already existing expansion.  */"}, {"sha": "96d80c3947781d2c1a0f5f7f8afaf8eb0e68aa43", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "patch": "@@ -104,13 +104,11 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n     {\n       /* A hack -- there seems to be no easy generic way how to make a\n \t conditional jump from a ccmode comparison.  */\n-      if (!cinsn)\n-\tabort ();\n+      gcc_assert (cinsn);\n       cond = XEXP (SET_SRC (pc_set (cinsn)), 0);\n-      if (GET_CODE (cond) != comp\n-\t  || !rtx_equal_p (op0, XEXP (cond, 0))\n-\t  || !rtx_equal_p (op1, XEXP (cond, 1)))\n-\tabort ();\n+      gcc_assert (GET_CODE (cond) == comp);\n+      gcc_assert (rtx_equal_p (op0, XEXP (cond, 0)));\n+      gcc_assert (rtx_equal_p (op1, XEXP (cond, 1)));\n       emit_jump_insn (copy_insn (PATTERN (cinsn)));\n       jump = get_last_insn ();\n       JUMP_LABEL (jump) = JUMP_LABEL (cinsn);\n@@ -119,8 +117,7 @@ compare_and_jump_seq (rtx op0, rtx op1, enum rtx_code comp, rtx label, int prob,\n     }\n   else\n     {\n-      if (cinsn)\n-\tabort ();\n+      gcc_assert (!cinsn);\n \n       op0 = force_operand (op0, NULL_RTX);\n       op1 = force_operand (op1, NULL_RTX);\n@@ -380,8 +377,7 @@ unswitch_single_loop (struct loops *loops, struct loop *loop,\n \n   /* Unswitch the loop on this condition.  */\n   nloop = unswitch_loop (loops, loop, bbs[i], cond, cinsn);\n-  if (!nloop)\n-  abort ();\n+  gcc_assert (nloop);\n \n   /* Invoke itself on modified loops.  */\n   unswitch_single_loop (loops, nloop, rconds, num + 1);\n@@ -413,18 +409,12 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n   rtx seq;\n \n   /* Some sanity checking.  */\n-  if (!flow_bb_inside_loop_p (loop, unswitch_on))\n-    abort ();\n-  if (EDGE_COUNT (unswitch_on->succs) != 2)\n-    abort ();\n-  if (!just_once_each_iteration_p (loop, unswitch_on))\n-    abort ();\n-  if (loop->inner)\n-    abort ();\n-  if (!flow_bb_inside_loop_p (loop, EDGE_SUCC (unswitch_on, 0)->dest))\n-    abort ();\n-  if (!flow_bb_inside_loop_p (loop, EDGE_SUCC (unswitch_on, 1)->dest))\n-    abort ();\n+  gcc_assert (flow_bb_inside_loop_p (loop, unswitch_on));\n+  gcc_assert (EDGE_COUNT (unswitch_on->succs) == 2);\n+  gcc_assert (just_once_each_iteration_p (loop, unswitch_on));\n+  gcc_assert (!loop->inner);\n+  gcc_assert (flow_bb_inside_loop_p (loop, EDGE_SUCC (unswitch_on, 0)->dest));\n+  gcc_assert (flow_bb_inside_loop_p (loop, EDGE_SUCC (unswitch_on, 1)->dest));\n \n   entry = loop_preheader_edge (loop);\n "}, {"sha": "6a99e97d38f948b33fa03ff6f3a28d4deaed8c58", "filename": "gcc/loop.c", "status": "modified", "additions": 54, "deletions": 67, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=b5e624c6dc2cfbc1bc41fc4f4b70a320f0f0cadb", "patch": "@@ -83,8 +83,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    of an insn added during loop, since these don't have LUIDs.  */\n \n #define INSN_LUID(INSN)\t\t\t\\\n-  (INSN_UID (INSN) < max_uid_for_loop ? uid_luid[INSN_UID (INSN)] \\\n-   : (abort (), -1))\n+  (gcc_assert (INSN_UID (INSN) < max_uid_for_loop), uid_luid[INSN_UID (INSN)])\n \n #define REGNO_FIRST_LUID(REGNO)\t\t\t\\\n   (REGNO_FIRST_UID (REGNO) < max_uid_for_loop\t\\\n@@ -869,8 +868,7 @@ loop_optimize (rtx f, FILE *dumpfile, int flags)\n \n   /* See if we went too far.  Note that get_max_uid already returns\n      one more that the maximum uid of all insn.  */\n-  if (get_max_uid () > max_uid_for_loop)\n-    abort ();\n+  gcc_assert (get_max_uid () <= max_uid_for_loop);\n   /* Now reset it to the actual size we need.  See above.  */\n   max_uid_for_loop = get_max_uid ();\n \n@@ -2117,7 +2115,7 @@ rtx_equal_for_loop_p (rtx x, rtx y, struct loop_movables *movables,\n \t     contain anything but integers and other rtx's,\n \t     except for within LABEL_REFs and SYMBOL_REFs.  */\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return 1;\n@@ -2310,21 +2308,26 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \n \t\t  for (count = m->consec; count >= 0; count--)\n \t\t    {\n-\t\t      /* If this is the first insn of a library call sequence,\n-\t\t\t something is very wrong.  */\n-\t\t      if (!NOTE_P (p)\n-\t\t\t  && (temp = find_reg_note (p, REG_LIBCALL, NULL_RTX)))\n-\t\t\tabort ();\n-\n-\t\t      /* If this is the last insn of a libcall sequence, then\n-\t\t\t delete every insn in the sequence except the last.\n-\t\t\t The last insn is handled in the normal manner.  */\n-\t\t      if (!NOTE_P (p)\n-\t\t\t  && (temp = find_reg_note (p, REG_RETVAL, NULL_RTX)))\n+\t\t      if (!NOTE_P (p))\n \t\t\t{\n-\t\t\t  temp = XEXP (temp, 0);\n-\t\t\t  while (temp != p)\n-\t\t\t    temp = delete_insn (temp);\n+\t\t\t  /* If this is the first insn of a library\n+\t\t\t     call sequence, something is very\n+\t\t\t     wrong.  */\n+\t\t\t  gcc_assert (!find_reg_note\n+\t\t\t\t      (p, REG_LIBCALL, NULL_RTX));\n+\n+\t\t\t  /* If this is the last insn of a libcall\n+\t\t\t     sequence, then delete every insn in the\n+\t\t\t     sequence except the last.  The last insn\n+\t\t\t     is handled in the normal manner.  */\n+\t\t\t  temp = find_reg_note (p, REG_RETVAL, NULL_RTX);\n+\t\t\t  \n+\t\t\t  if (temp)\n+\t\t\t    {\n+\t\t\t      temp = XEXP (temp, 0);\n+\t\t\t      while (temp != p)\n+\t\t\t\ttemp = delete_insn (temp);\n+\t\t\t    }\n \t\t\t}\n \n \t\t      temp = p;\n@@ -2488,8 +2491,7 @@ move_movables (struct loop *loop, struct loop_movables *movables,\n \t\t\t\t\t<< GET_MODE_BITSIZE (m->savemode)))\n \t\t\t\t      - 1),\n \t\t\t     reg, 1, OPTAB_LIB_WIDEN);\n-\t\t\t  if (tem == 0)\n-\t\t\t    abort ();\n+\t\t\t  gcc_assert (tem);\n \t\t\t  if (tem != reg)\n \t\t\t    emit_move_insn (reg, tem);\n \t\t\t  sequence = get_insns ();\n@@ -2777,8 +2779,7 @@ replace_call_address (rtx x, rtx reg, rtx addr)\n     case MEM:\n       /* If this MEM uses a reg other than the one we expected,\n \t something is wrong.  */\n-      if (XEXP (x, 0) != reg)\n-\tabort ();\n+      gcc_assert (XEXP (x, 0) == reg);\n       XEXP (x, 0) = addr;\n       return;\n \n@@ -3091,8 +3092,7 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \t    break;\n \n \t  case NOTE_INSN_LOOP_END:\n-\t    if (! current_loop)\n-\t      abort ();\n+\t    gcc_assert (current_loop);\n \n \t    current_loop->end = insn;\n \t    current_loop = current_loop->outer;\n@@ -3340,8 +3340,7 @@ find_and_verify_loops (rtx f, struct loops *loops)\n \n \t\t\t    /* If we didn't find it, then something is\n \t\t\t       wrong.  */\n-\t\t\t    if (! r)\n-\t\t\t      abort ();\n+\t\t\t    gcc_assert (r);\n \t\t\t  }\n \n \t\t\t/* P is now a jump outside the loop, so it must be put\n@@ -4038,7 +4037,7 @@ rtx_equal_for_prefetch_p (rtx x, rtx y)\n \t     contain anything but integers and other rtx's,\n \t     except for within LABEL_REFs and SYMBOL_REFs.  */\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n   return 1;\n@@ -4964,10 +4963,9 @@ fold_rtx_mult_add (rtx mult1, rtx mult2, rtx add1, enum machine_mode mode)\n \n   /* The modes must all be the same.  This should always be true.  For now,\n      check to make sure.  */\n-  if ((GET_MODE (mult1) != mode && GET_MODE (mult1) != VOIDmode)\n-      || (GET_MODE (mult2) != mode && GET_MODE (mult2) != VOIDmode)\n-      || (GET_MODE (add1) != mode && GET_MODE (add1) != VOIDmode))\n-    abort ();\n+  gcc_assert (GET_MODE (mult1) == mode || GET_MODE (mult1) == VOIDmode);\n+  gcc_assert (GET_MODE (mult2) == mode || GET_MODE (mult2) == VOIDmode);\n+  gcc_assert (GET_MODE (add1) == mode || GET_MODE (add1) == VOIDmode);\n \n   /* Ensure that if at least one of mult1/mult2 are constant, then mult2\n      will be a constant.  */\n@@ -5802,9 +5800,8 @@ loop_iterations (struct loop *loop)\n      will propagate a new pseudo into the old iteration register but\n      this will be marked by having the REG_USERVAR_P bit set.  */\n \n-  if ((unsigned) REGNO (iteration_var) >= ivs->n_regs\n-      && ! REG_USERVAR_P (iteration_var))\n-    abort ();\n+  gcc_assert ((unsigned) REGNO (iteration_var) < ivs->n_regs\n+\t      || REG_USERVAR_P (iteration_var));\n \n   /* Determine the initial value of the iteration variable, and the amount\n      that it is incremented each loop.  Use the tables constructed by\n@@ -5861,8 +5858,7 @@ loop_iterations (struct loop *loop)\n \n   if (REG_IV_TYPE (ivs, REGNO (iteration_var)) == BASIC_INDUCT)\n     {\n-      if (REGNO (iteration_var) >= ivs->n_regs)\n-\tabort ();\n+      gcc_assert (REGNO (iteration_var) < ivs->n_regs);\n \n       /* Grab initial value, only useful if it is a constant.  */\n       bl = REG_IV_CLASS (ivs, REGNO (iteration_var));\n@@ -5883,8 +5879,7 @@ loop_iterations (struct loop *loop)\n       struct induction *v = REG_IV_INFO (ivs, REGNO (iteration_var));\n       rtx biv_initial_value;\n \n-      if (REGNO (v->src_reg) >= ivs->n_regs)\n-\tabort ();\n+      gcc_assert (REGNO (v->src_reg) < ivs->n_regs);\n \n       if (!v->always_executed || v->maybe_multiple)\n \t{\n@@ -5991,7 +5986,7 @@ loop_iterations (struct loop *loop)\n       compare_dir = 0;\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* If the comparison value is an invariant register, then try to find\n@@ -6243,18 +6238,17 @@ loop_iterations (struct loop *loop)\n      unsigned, because they can be as large as 2^n - 1.  */\n \n   inc = INTVAL (increment);\n+  gcc_assert (inc);\n   if (inc > 0)\n     {\n       abs_diff = INTVAL (final_value) - INTVAL (initial_value);\n       abs_inc = inc;\n     }\n-  else if (inc < 0)\n+  else\n     {\n       abs_diff = INTVAL (initial_value) - INTVAL (final_value);\n       abs_inc = -inc;\n     }\n-  else\n-    abort ();\n \n   /* Given that iteration_var is going to iterate over its own mode,\n      not HOST_WIDE_INT, disregard higher bits that might have come\n@@ -6964,19 +6958,15 @@ record_giv (const struct loop *loop, struct induction *v, rtx insn,\n   /* Add the giv to the class of givs computed from one biv.  */\n \n   bl = REG_IV_CLASS (ivs, REGNO (src_reg));\n-  if (bl)\n-    {\n-      v->next_iv = bl->giv;\n-      bl->giv = v;\n-      /* Don't count DEST_ADDR.  This is supposed to count the number of\n-\t insns that calculate givs.  */\n-      if (type == DEST_REG)\n-\tbl->giv_count++;\n-      bl->total_benefit += benefit;\n-    }\n-  else\n-    /* Fatal error, biv missing for this giv?  */\n-    abort ();\n+  gcc_assert (bl);\n+  v->next_iv = bl->giv;\n+  bl->giv = v;\n+  \n+  /* Don't count DEST_ADDR.  This is supposed to count the number of\n+     insns that calculate givs.  */\n+  if (type == DEST_REG)\n+    bl->giv_count++;\n+  bl->total_benefit += benefit;\n \n   if (type == DEST_ADDR)\n     {\n@@ -7191,8 +7181,7 @@ final_giv_value (const struct loop *loop, struct induction *v)\n     }\n \n   /* Replaceable giv's should never reach here.  */\n-  if (v->replaceable)\n-    abort ();\n+  gcc_assert (!v->replaceable);\n \n   /* Check to see if the biv is dead at all loop exits.  */\n   if (reg_dead_after_loop (loop, v->dest_reg))\n@@ -7756,7 +7745,7 @@ general_induction_var (const struct loop *loop, rtx x, rtx *src_reg,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   /* Remove any enclosing USE from ADD_VAL and MULT_VAL (there will be\n@@ -7875,7 +7864,7 @@ simplify_giv_expr (const struct loop *loop, rtx x, rtx *ext_val, int *benefit)\n \t\t\t\t ext_val, benefit);\n \n \t  default:\n-\t    abort ();\n+\t    gcc_unreachable ();\n \t  }\n \n       /* Each argument must be either REG, PLUS, or MULT.  Convert REG to\n@@ -8016,7 +8005,7 @@ simplify_giv_expr (const struct loop *loop, rtx x, rtx *ext_val, int *benefit)\n \t\t\t\t    ext_val, benefit);\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n     case ASHIFT:\n@@ -8775,7 +8764,7 @@ extension_within_bounds_p (const struct loop *loop, struct iv_class *bl,\n       break;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n \n   return ((!signedp || biv_fits_mode_p (loop, bl, incr, mode, false))\n@@ -11112,8 +11101,7 @@ try_copy_prop (const struct loop *loop, rtx replacement, unsigned int regno)\n \t  && REG_P (SET_DEST (set))\n \t  && REGNO (SET_DEST (set)) == regno)\n \t{\n-\t  if (init_insn)\n-\t    abort ();\n+\t  gcc_assert (!init_insn);\n \n \t  init_insn = insn;\n \t  if (REGNO_FIRST_UID (regno) == INSN_UID (insn))\n@@ -11146,8 +11134,7 @@ try_copy_prop (const struct loop *loop, rtx replacement, unsigned int regno)\n \t    }\n \t}\n     }\n-  if (! init_insn)\n-    abort ();\n+  gcc_assert (init_insn);\n   if (apply_change_group ())\n     {\n       if (loop_dump_stream)\n@@ -11648,7 +11635,7 @@ loop_giv_dump (const struct induction *v, FILE *file, int verbose)\n \t  fprintf (file, \" ext tr\");\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n "}]}