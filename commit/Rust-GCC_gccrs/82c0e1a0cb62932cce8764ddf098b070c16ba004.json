{"sha": "82c0e1a0cb62932cce8764ddf098b070c16ba004", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJjMGUxYTBjYjYyOTMyY2NlODc2NGRkZjA5OGIwNzBjMTZiYTAwNA==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2013-04-02T18:34:32Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2013-04-02T18:34:32Z"}, "message": "re PR target/52790 (Problems using x86_64-w64-mingw-w32-gfortran with mcmodel=large and medium)\n\n\tPR target/52790\n\t* config/i386/cygming.h (SUB_TARGET_RECORD_STUB): New sub-target macro.\n\t* config/i386/i386-protos.h (i386_pe_record_stub): Add new prototype.\n\t* config/i386/i386.c (legitimize_pe_coff_extern_decl): New static\n\tfunction.\n\t(legitimize_pe_coff_symbol): Likewise.\n\t(is_imported_p): New helper-function.\n\t(ix86_option_override_internal): Make MEDIUM_PIC the default code-model\n\tfor Windows x64 targets.\n\t(ix86_expand_prologue): Optimize for pe-coff targets.\n\t(ix86_expand_split_stack_prologue): Adjust for pe-coff targets.\n\t(legitimate_pic_address_disp_p): Adjust for x64 pe-coff to support\n\tmedium/large code-model.\n\t(legitimize_pic_address): Likewise.\n\t(legitimize_tls_address): Likewise.\n\t(ix86_expand_call): Likewise.\n\t(x86_output_mi_thunk): Likewise.\n\t(get_dllimport_decl): Add new beimport argument.\n\t(construct_plt_address): Don't assert for x64 pe-coff targets.\n\t* config/i386/i386.h (PIC_OFFSET_TABLE_REGNUM): Adjust for x64 pe-coff\n\ttargets.\n\t(SYMBOL_FLAG_STUBVAR): New macro.\n\t(SYMBOL_REF_STUBVAR_P): Likewise.\n\t* config/i386/winnt.c (stub_list): New structure.\n\t(stub_head): New local variable.\n\t(i386_pe_record_stub): New function.\n\t(i386_pe_file_end): Emit refptr-stubs.\n\nFrom-SVN: r197373", "tree": {"sha": "cb13617ed673270e2d6f46bff9bee1bd4a42cb30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb13617ed673270e2d6f46bff9bee1bd4a42cb30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82c0e1a0cb62932cce8764ddf098b070c16ba004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c0e1a0cb62932cce8764ddf098b070c16ba004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82c0e1a0cb62932cce8764ddf098b070c16ba004", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c0e1a0cb62932cce8764ddf098b070c16ba004/comments", "author": null, "committer": null, "parents": [{"sha": "09bb4c99b03944e4910975593a80dcf1545886ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09bb4c99b03944e4910975593a80dcf1545886ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09bb4c99b03944e4910975593a80dcf1545886ff"}], "stats": {"total": 322, "additions": 264, "deletions": 58}, "files": [{"sha": "10611fef6bab068f274c8e2b9d53845f3027774d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82c0e1a0cb62932cce8764ddf098b070c16ba004", "patch": "@@ -1,3 +1,32 @@\n+2013-04-02  Kai Tietz  <ktietz@redhat.com>\n+\n+\tPR target/52790\n+\t* config/i386/cygming.h (SUB_TARGET_RECORD_STUB): New sub-target macro.\n+\t* config/i386/i386-protos.h (i386_pe_record_stub): Add new prototype.\n+\t* config/i386/i386.c (legitimize_pe_coff_extern_decl): New static function.\n+\t(legitimize_pe_coff_symbol): Likewise.\n+\t(is_imported_p): New helper-function.\n+\t(ix86_option_override_internal): Make MEDIUM_PIC the default code-model\n+\tfor Windows x64 targets.\n+\t(ix86_expand_prologue): Optimize for pe-coff targets.\n+\t(ix86_expand_split_stack_prologue): Adjust for pe-coff targets.\n+\t(legitimate_pic_address_disp_p): Adjust for x64 pe-coff to support\n+\tmedium/large code-model.\n+\t(legitimize_pic_address): Likewise.\n+\t(legitimize_tls_address): Likewise.\n+\t(ix86_expand_call): Likewise.\n+\t(x86_output_mi_thunk): Likewise.\n+\t(get_dllimport_decl): Add new beimport argument.\n+\t(construct_plt_address): Don't assert for x64 pe-coff targets.\n+\t* config/i386/i386.h (PIC_OFFSET_TABLE_REGNUM): Adjust for x64 pe-coff\n+\ttargets.\n+\t(SYMBOL_FLAG_STUBVAR): New macro.\n+\t(SYMBOL_REF_STUBVAR_P): Likewise.\n+\t* config/i386/winnt.c (stub_list): New structure.\n+\t(stub_head): New local variable.\n+\t(i386_pe_record_stub): New function.\n+\t(i386_pe_file_end): Emit refptr-stubs.\n+\n 2013-04-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/56745"}, {"sha": "4be15c486b863d63bc67441fd628d4d90a7d7211", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=82c0e1a0cb62932cce8764ddf098b070c16ba004", "patch": "@@ -474,5 +474,8 @@ do {\t\t\t\t\t\t\\\n #undef TARGET_ASM_ASSEMBLE_VISIBILITY\n #define TARGET_ASM_ASSEMBLE_VISIBILITY i386_pe_assemble_visibility\n \n+#undef SUB_TARGET_RECORD_STUB\n+#define SUB_TARGET_RECORD_STUB i386_pe_record_stub\n+\n /* Static stack checking is supported by means of probes.  */\n #define STACK_CHECK_STATIC_BUILTIN 1"}, {"sha": "ef4dc761d5a5570d256727c10097ac6120dd58b0", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=82c0e1a0cb62932cce8764ddf098b070c16ba004", "patch": "@@ -260,6 +260,7 @@ extern void i386_pe_end_function (FILE *, const char *, tree);\n extern void i386_pe_assemble_visibility (tree, int);\n extern tree i386_pe_mangle_decl_assembler_name (tree, tree);\n extern tree i386_pe_mangle_assembler_name (const char *);\n+extern void i386_pe_record_stub (const char *);\n \n extern void i386_pe_seh_init (FILE *);\n extern void i386_pe_seh_end_prologue (FILE *);"}, {"sha": "9f5a24f6c006901f8fbafa082164994ad0349967", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 167, "deletions": 57, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=82c0e1a0cb62932cce8764ddf098b070c16ba004", "patch": "@@ -64,6 +64,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n \n static rtx legitimize_dllimport_symbol (rtx, bool);\n+static rtx legitimize_pe_coff_extern_decl (rtx, bool);\n+static rtx legitimize_pe_coff_symbol (rtx, bool);\n \n #ifndef CHECK_STACK_LIMIT\n #define CHECK_STACK_LIMIT (-1)\n@@ -3233,9 +3235,7 @@ ix86_option_override_internal (bool main_args_p)\n \t use of rip-relative addressing.  This eliminates fixups that\n \t would otherwise be needed if this object is to be placed in a\n \t DLL, and is essentially just as efficient as direct addressing.  */\n-      if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)\n-\tix86_cmodel = CM_SMALL_PIC, flag_pic = 1;\n-      else if (TARGET_64BIT && TARGET_RDOS)\n+      if (TARGET_64BIT && (TARGET_RDOS || DEFAULT_ABI == MS_ABI))\n \tix86_cmodel = CM_MEDIUM_PIC, flag_pic = 1;\n       else if (TARGET_64BIT)\n \tix86_cmodel = flag_pic ? CM_SMALL_PIC : CM_SMALL;\n@@ -10575,7 +10575,9 @@ ix86_expand_prologue (void)\n     ix86_emit_save_sse_regs_using_mov (frame.sse_reg_save_offset);\n \n   pic_reg_used = false;\n+  /* We don't use pic-register for pe-coff target.  */\n   if (pic_offset_table_rtx\n+      && DEFAULT_ABI != MS_ABI\n       && (df_regs_ever_live_p (REAL_PIC_OFFSET_TABLE_REGNUM)\n \t  || crtl->profile))\n     {\n@@ -11380,7 +11382,8 @@ ix86_expand_split_stack_prologue (void)\n \t  use_reg (&call_fusage, rax);\n \t}\n \n-      if (ix86_cmodel == CM_LARGE || ix86_cmodel == CM_LARGE_PIC)\n+      if ((ix86_cmodel == CM_LARGE || ix86_cmodel == CM_LARGE_PIC)\n+          && DEFAULT_ABI != MS_ABI)\n \t{\n \t  HOST_WIDE_INT argval;\n \n@@ -11998,6 +12001,19 @@ ix86_cannot_force_const_mem (enum machine_mode mode, rtx x)\n   return !ix86_legitimate_constant_p (mode, x);\n }\n \n+/*  Nonzero if the symbol is marked as dllimport, or as stub-variable,\n+    otherwise zero.  */\n+\n+static bool\n+is_imported_p (rtx x)\n+{\n+  if (!TARGET_DLLIMPORT_DECL_ATTRIBUTES\n+      || GET_CODE (x) != SYMBOL_REF)\n+    return false;\n+\n+  return SYMBOL_REF_DLLIMPORT_P (x) || SYMBOL_REF_STUBVAR_P (x);\n+}\n+\n \n /* Nonzero if the constant value X is a legitimate general operand\n    when generating PIC code.  It is given that flag_pic is on and\n@@ -12086,11 +12102,39 @@ legitimate_pic_address_disp_p (rtx disp)\n \t  /* FALLTHRU */\n \n \tcase SYMBOL_REF:\n-\t  /* TLS references should always be enclosed in UNSPEC.  */\n-\t  if (SYMBOL_REF_TLS_MODEL (op0))\n+\t  /* TLS references should always be enclosed in UNSPEC.\n+\t     The dllimported symbol needs always to be resolved.  */\n+\t  if (SYMBOL_REF_TLS_MODEL (op0)\n+\t      || (TARGET_DLLIMPORT_DECL_ATTRIBUTES && SYMBOL_REF_DLLIMPORT_P (op0)))\n \t    return false;\n-\t  if (!SYMBOL_REF_FAR_ADDR_P (op0) && SYMBOL_REF_LOCAL_P (op0)\n-\t      && ix86_cmodel != CM_LARGE_PIC)\n+\n+\t  if (DEFAULT_ABI == MS_ABI)\n+\t    {\n+\t      if (is_imported_p (op0))\n+\t\treturn true;\n+\n+\t      if (SYMBOL_REF_FAR_ADDR_P (op0)\n+\t\t  || !SYMBOL_REF_LOCAL_P (op0))\n+\t\tbreak;\n+\n+\t      /* Function-symbols need to be resolved only for\n+\t         large-model.\n+\t         For the small-model we don't need to resolve anything\n+\t         here.  */\n+\t      if ((ix86_cmodel != CM_LARGE_PIC\n+\t           && SYMBOL_REF_FUNCTION_P (op0))\n+\t\t  || ix86_cmodel == CM_SMALL_PIC)\n+\t\treturn true;\n+\t      /* Non-external symbols don't need to be resolved for\n+\t         large, and medium-model.  */\n+\t      if ((ix86_cmodel == CM_LARGE_PIC\n+\t\t   || ix86_cmodel == CM_MEDIUM_PIC)\n+\t\t  && !SYMBOL_REF_EXTERNAL_P (op0))\n+\t\treturn true;\n+\t    }\n+\t  else if (!SYMBOL_REF_FAR_ADDR_P (op0)\n+\t\t   && SYMBOL_REF_LOCAL_P (op0)\n+\t\t   && ix86_cmodel != CM_LARGE_PIC)\n \t    return true;\n \t  break;\n \n@@ -12151,7 +12195,7 @@ legitimate_pic_address_disp_p (rtx disp)\n       if ((GET_CODE (XVECEXP (disp, 0, 0)) == SYMBOL_REF\n \t   || GET_CODE (XVECEXP (disp, 0, 0)) == LABEL_REF)\n \t  && !TARGET_64BIT)\n-        return gotoff_operand (XVECEXP (disp, 0, 0), Pmode);\n+        return DEFAULT_ABI != MS_ABI && gotoff_operand (XVECEXP (disp, 0, 0), Pmode);\n       return false;\n     case UNSPEC_GOTTPOFF:\n     case UNSPEC_GOTNTPOFF:\n@@ -12486,11 +12530,17 @@ legitimize_pic_address (rtx orig, rtx reg)\n     }\n #endif\n \n+  if (TARGET_64BIT && TARGET_DLLIMPORT_DECL_ATTRIBUTES)\n+    {\n+      rtx tmp = legitimize_pe_coff_symbol (addr, true);\n+      if (tmp)\n+        return tmp;\n+    }\n+\n   if (TARGET_64BIT && legitimate_pic_address_disp_p (addr))\n     new_rtx = addr;\n-  else if (TARGET_64BIT\n-\t   && ix86_cmodel != CM_SMALL_PIC\n-\t   && gotoff_operand (addr, Pmode))\n+  else if (TARGET_64BIT && DEFAULT_ABI != MS_ABI\n+\t   && ix86_cmodel != CM_SMALL_PIC && gotoff_operand (addr, Pmode))\n     {\n       rtx tmpreg;\n       /* This symbol may be referenced via a displacement from the PIC\n@@ -12521,9 +12571,10 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t\t\t\t\t tmpreg, 1, OPTAB_DIRECT);\n \t  new_rtx = reg;\n \t}\n-      else new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmpreg);\n+      else\n+        new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, tmpreg);\n     }\n-  else if (!TARGET_64BIT && gotoff_operand (addr, Pmode))\n+  else if (!TARGET_64BIT && DEFAULT_ABI != MS_ABI && gotoff_operand (addr, Pmode))\n     {\n       /* This symbol may be referenced via a displacement from the PIC\n \t base address (@GOTOFF).  */\n@@ -12554,31 +12605,22 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t      see gotoff_operand.  */\n \t   || (TARGET_VXWORKS_RTP && GET_CODE (addr) == LABEL_REF))\n     {\n-      if (TARGET_DLLIMPORT_DECL_ATTRIBUTES)\n-        {\n-          if (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_DLLIMPORT_P (addr))\n-            return legitimize_dllimport_symbol (addr, true);\n-          if (GET_CODE (addr) == CONST && GET_CODE (XEXP (addr, 0)) == PLUS\n-              && GET_CODE (XEXP (XEXP (addr, 0), 0)) == SYMBOL_REF\n-              && SYMBOL_REF_DLLIMPORT_P (XEXP (XEXP (addr, 0), 0)))\n-            {\n-              rtx t = legitimize_dllimport_symbol (XEXP (XEXP (addr, 0), 0), true);\n-              return gen_rtx_PLUS (Pmode, t, XEXP (XEXP (addr, 0), 1));\n-            }\n-        }\n+      rtx tmp = legitimize_pe_coff_symbol (addr, true);\n+      if (tmp)\n+        return tmp;\n \n       /* For x64 PE-COFF there is no GOT table.  So we use address\n          directly.  */\n       if (TARGET_64BIT && DEFAULT_ABI == MS_ABI)\n-      {\n+\t{\n \t  new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_PCREL);\n \t  new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n \n \t  if (reg == 0)\n \t    reg = gen_reg_rtx (Pmode);\n-  \t  emit_move_insn (reg, new_rtx);\n+\t  emit_move_insn (reg, new_rtx);\n \t  new_rtx = reg;\n-      }\n+\t}\n       else if (TARGET_64BIT && ix86_cmodel != CM_LARGE_PIC)\n \t{\n \t  new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTPCREL);\n@@ -12647,7 +12689,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \n \t  /* Check first to see if this is a constant offset from a @GOTOFF\n \t     symbol reference.  */\n-\t  if (gotoff_operand (op0, Pmode)\n+\t  if (DEFAULT_ABI != MS_ABI && gotoff_operand (op0, Pmode)\n \t      && CONST_INT_P (op1))\n \t    {\n \t      if (!TARGET_64BIT)\n@@ -12791,7 +12833,7 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n \n       if (!TARGET_64BIT)\n \t{\n-\t  if (flag_pic)\n+\t  if (flag_pic && DEFAULT_ABI != MS_ABI)\n \t    pic = pic_offset_table_rtx;\n \t  else\n \t    {\n@@ -13000,13 +13042,14 @@ legitimize_tls_address (rtx x, enum tls_model model, bool for_mov)\n }\n \n /* Create or return the unique __imp_DECL dllimport symbol corresponding\n-   to symbol DECL.  */\n+   to symbol DECL if BEIMPORT is true.  Otherwise create or return the\n+   unique refptr-DECL symbol corresponding to symbol DECL.  */\n \n static GTY((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n   htab_t dllimport_map;\n \n static tree\n-get_dllimport_decl (tree decl)\n+get_dllimport_decl (tree decl, bool beimport)\n {\n   struct tree_map *h, in;\n   void **loc;\n@@ -13039,8 +13082,11 @@ get_dllimport_decl (tree decl)\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n   name = targetm.strip_name_encoding (name);\n-  prefix = name[0] == FASTCALL_PREFIX || user_label_prefix[0] == 0\n-    ? \"*__imp_\" : \"*__imp__\";\n+  if (beimport)\n+    prefix = name[0] == FASTCALL_PREFIX || user_label_prefix[0] == 0\n+      ? \"*__imp_\" : \"*__imp__\";\n+  else\n+    prefix = user_label_prefix[0] == 0 ? \"*.refptr.\" : \"*refptr.\";\n   namelen = strlen (name);\n   prefixlen = strlen (prefix);\n   imp_name = (char *) alloca (namelen + prefixlen + 1);\n@@ -13050,7 +13096,14 @@ get_dllimport_decl (tree decl)\n   name = ggc_alloc_string (imp_name, namelen + prefixlen);\n   rtl = gen_rtx_SYMBOL_REF (Pmode, name);\n   SET_SYMBOL_REF_DECL (rtl, to);\n-  SYMBOL_REF_FLAGS (rtl) = SYMBOL_FLAG_LOCAL;\n+  SYMBOL_REF_FLAGS (rtl) = SYMBOL_FLAG_LOCAL | SYMBOL_FLAG_STUBVAR;\n+  if (!beimport)\n+    {\n+      SYMBOL_REF_FLAGS (rtl) |= SYMBOL_FLAG_EXTERNAL;\n+#ifdef SUB_TARGET_RECORD_STUB\n+      SUB_TARGET_RECORD_STUB (name);\n+#endif\n+    }      \n \n   rtl = gen_const_mem (Pmode, rtl);\n   set_mem_alias_set (rtl, ix86_GOT_alias_set ());\n@@ -13061,6 +13114,24 @@ get_dllimport_decl (tree decl)\n   return to;\n }\n \n+/* Expand SYMBOL into its corresponding far-addresse symbol.\n+   WANT_REG is true if we require the result be a register.  */\n+\n+static rtx\n+legitimize_pe_coff_extern_decl (rtx symbol, bool want_reg)\n+{\n+  tree imp_decl;\n+  rtx x;\n+\n+  gcc_assert (SYMBOL_REF_DECL (symbol));\n+  imp_decl = get_dllimport_decl (SYMBOL_REF_DECL (symbol), false);\n+\n+  x = DECL_RTL (imp_decl);\n+  if (want_reg)\n+    x = force_reg (Pmode, x);\n+  return x;\n+}\n+\n /* Expand SYMBOL into its corresponding dllimport symbol.  WANT_REG is\n    true if we require the result be a register.  */\n \n@@ -13071,14 +13142,58 @@ legitimize_dllimport_symbol (rtx symbol, bool want_reg)\n   rtx x;\n \n   gcc_assert (SYMBOL_REF_DECL (symbol));\n-  imp_decl = get_dllimport_decl (SYMBOL_REF_DECL (symbol));\n+  imp_decl = get_dllimport_decl (SYMBOL_REF_DECL (symbol), true);\n \n   x = DECL_RTL (imp_decl);\n   if (want_reg)\n     x = force_reg (Pmode, x);\n   return x;\n }\n \n+/* Expand SYMBOL into its corresponding dllimport or refptr symbol.  WANT_REG \n+   is true if we require the result be a register.  */\n+\n+static rtx\n+legitimize_pe_coff_symbol (rtx addr, bool inreg)\n+{\n+  if (DEFAULT_ABI != MS_ABI)\n+    return NULL_RTX;\n+\n+  if (TARGET_DLLIMPORT_DECL_ATTRIBUTES)\n+    {\n+      if (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_DLLIMPORT_P (addr))\n+\treturn legitimize_dllimport_symbol (addr, inreg);\n+      if (GET_CODE (addr) == CONST\n+\t  && GET_CODE (XEXP (addr, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (addr, 0), 0)) == SYMBOL_REF\n+\t  && SYMBOL_REF_DLLIMPORT_P (XEXP (XEXP (addr, 0), 0)))\n+\t{\n+\t  rtx t = legitimize_dllimport_symbol (XEXP (XEXP (addr, 0), 0), inreg);\n+\t  return gen_rtx_PLUS (Pmode, t, XEXP (XEXP (addr, 0), 1));\n+\t}\n+    }\n+\n+  if (ix86_cmodel != CM_LARGE_PIC && ix86_cmodel != CM_MEDIUM_PIC)\n+    return NULL_RTX;\n+  if (GET_CODE (addr) == SYMBOL_REF\n+      && !is_imported_p (addr)\n+      && SYMBOL_REF_EXTERNAL_P (addr)\n+      && SYMBOL_REF_DECL (addr))\n+    return legitimize_pe_coff_extern_decl (addr, inreg);\n+\n+  if (GET_CODE (addr) == CONST\n+      && GET_CODE (XEXP (addr, 0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (addr, 0), 0)) == SYMBOL_REF\n+      && !is_imported_p (XEXP (XEXP (addr, 0), 0))\n+      && SYMBOL_REF_EXTERNAL_P (XEXP (XEXP (addr, 0), 0))\n+      && SYMBOL_REF_DECL (XEXP (XEXP (addr, 0), 0)))\n+    {\n+      rtx t = legitimize_pe_coff_extern_decl (XEXP (XEXP (addr, 0), 0), inreg);\n+      return gen_rtx_PLUS (Pmode, t, XEXP (XEXP (addr, 0), 1));\n+    }\n+  return NULL_RTX;\n+}\n+\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.\n@@ -13119,16 +13234,9 @@ ix86_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \n   if (TARGET_DLLIMPORT_DECL_ATTRIBUTES)\n     {\n-      if (GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_DLLIMPORT_P (x))\n-\treturn legitimize_dllimport_symbol (x, true);\n-      if (GET_CODE (x) == CONST\n-\t  && GET_CODE (XEXP (x, 0)) == PLUS\n-\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n-\t  && SYMBOL_REF_DLLIMPORT_P (XEXP (XEXP (x, 0), 0)))\n-\t{\n-\t  rtx t = legitimize_dllimport_symbol (XEXP (XEXP (x, 0), 0), true);\n-\t  return gen_rtx_PLUS (Pmode, t, XEXP (XEXP (x, 0), 1));\n-\t}\n+      rtx tmp = legitimize_pe_coff_symbol (x, true);\n+      if (tmp)\n+        return tmp;\n     }\n \n   if (flag_pic && SYMBOLIC_CONST (x))\n@@ -15944,6 +16052,8 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n \n   if (GET_CODE (op1) == SYMBOL_REF)\n     {\n+      rtx tmp;\n+\n       model = SYMBOL_REF_TLS_MODEL (op1);\n       if (model)\n \t{\n@@ -15953,24 +16063,22 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n \t    return;\n \t  op1 = convert_to_mode (mode, op1, 1);\n \t}\n-      else if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-\t       && SYMBOL_REF_DLLIMPORT_P (op1))\n-\top1 = legitimize_dllimport_symbol (op1, false);\n+      else if ((tmp = legitimize_pe_coff_symbol (op1, false)) != NULL_RTX)\n+\top1 = tmp;\n     }\n   else if (GET_CODE (op1) == CONST\n \t   && GET_CODE (XEXP (op1, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (op1, 0), 0)) == SYMBOL_REF)\n     {\n       rtx addend = XEXP (XEXP (op1, 0), 1);\n       rtx symbol = XEXP (XEXP (op1, 0), 0);\n-      rtx tmp = NULL;\n+      rtx tmp;\n \n       model = SYMBOL_REF_TLS_MODEL (symbol);\n       if (model)\n \ttmp = legitimize_tls_address (symbol, model, true);\n-      else if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-\t       && SYMBOL_REF_DLLIMPORT_P (symbol))\n-\ttmp = legitimize_dllimport_symbol (symbol, true);\n+      else\n+        tmp = legitimize_pe_coff_symbol (symbol, true);\n \n       if (tmp)\n \t{\n@@ -23576,7 +23684,7 @@ construct_plt_address (rtx symbol)\n   rtx tmp, unspec;\n \n   gcc_assert (GET_CODE (symbol) == SYMBOL_REF);\n-  gcc_assert (ix86_cmodel == CM_LARGE_PIC);\n+  gcc_assert (ix86_cmodel == CM_LARGE_PIC && DEFAULT_ABI != MS_ABI);\n   gcc_assert (Pmode == DImode);\n \n   tmp = gen_reg_rtx (Pmode);\n@@ -23618,7 +23726,8 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n   else\n     {\n       /* Static functions and indirect calls don't need the pic register.  */\n-      if (flag_pic && (!TARGET_64BIT || ix86_cmodel == CM_LARGE_PIC)\n+      if (flag_pic && (!TARGET_64BIT\n+                       || (ix86_cmodel == CM_LARGE_PIC && DEFAULT_ABI != MS_ABI))\n \t  && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n \t  && ! SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0)))\n \tuse_reg (&use, pic_offset_table_rtx);\n@@ -23632,6 +23741,7 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n     }\n \n   if (ix86_cmodel == CM_LARGE_PIC\n+      && DEFAULT_ABI != MS_ABI\n       && MEM_P (fnaddr)\n       && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n       && !local_symbolic_operand (XEXP (fnaddr, 0), VOIDmode))\n@@ -34970,7 +35080,7 @@ x86_output_mi_thunk (FILE *file,\n   if (TARGET_64BIT)\n     {\n       if (!flag_pic || targetm.binds_local_p (function)\n-\t  || cfun->machine->call_abi == MS_ABI)\n+\t  || DEFAULT_ABI == MS_ABI)\n \t;\n       else\n \t{"}, {"sha": "5d31f80feb56652d0e9917b47f461f70265735ba", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=82c0e1a0cb62932cce8764ddf098b070c16ba004", "patch": "@@ -1179,7 +1179,8 @@ enum target_cpu_default\n #define REAL_PIC_OFFSET_TABLE_REGNUM  BX_REG\n \n #define PIC_OFFSET_TABLE_REGNUM\t\t\t\t\\\n-  ((TARGET_64BIT && ix86_cmodel == CM_SMALL_PIC)\t\\\n+  ((TARGET_64BIT && (ix86_cmodel == CM_SMALL_PIC\t\\\n+                     || DEFAULT_ABI == MS_ABI))\t\t\\\n    || !flag_pic ? INVALID_REGNUM\t\t\t\\\n    : reload_completed ? REGNO (pic_offset_table_rtx)\t\\\n    : REAL_PIC_OFFSET_TABLE_REGNUM)\n@@ -2379,6 +2380,10 @@ struct GTY(()) machine_function {\n #define SYMBOL_REF_DLLEXPORT_P(X) \\\n \t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_DLLEXPORT) != 0)\n \n+#define SYMBOL_FLAG_STUBVAR\t(SYMBOL_FLAG_MACH_DEP << 4)\n+#define SYMBOL_REF_STUBVAR_P(X) \\\n+\t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_STUBVAR) != 0)\n+\n extern void debug_ready_dispatch (void);\n extern void debug_dispatch_window (int);\n "}, {"sha": "c8002f6723f416f9e0968d6d8d25cbd8f35bac45", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c0e1a0cb62932cce8764ddf098b070c16ba004/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=82c0e1a0cb62932cce8764ddf098b070c16ba004", "patch": "@@ -646,8 +646,18 @@ struct GTY(()) export_list\n   int is_data;\t\t/* used to type tag exported symbols.  */\n };\n \n+/* Keep a list of stub symbols.  */\n+\n+struct GTY(()) stub_list\n+{\n+  struct stub_list *next;\n+  const char *name;\n+};\n+\n static GTY(()) struct export_list *export_head;\n \n+static GTY(()) struct stub_list *stub_head;\n+\n /* Assemble an export symbol entry.  We need to keep a list of\n    these, so that we can output the export list at the end of the\n    assembly.  We used to output these export symbols in each function,\n@@ -678,6 +688,30 @@ i386_pe_maybe_record_exported_symbol (tree decl, const char *name, int is_data)\n   export_head = p;\n }\n \n+void\n+i386_pe_record_stub (const char *name)\n+{\n+  struct stub_list *p;\n+\n+  if (!name || *name == 0)\n+    return;\n+\n+  p = stub_head;\n+  while (p != NULL)\n+    {\n+      if (p->name[0] == *name\n+          && !strcmp (p->name, name))\n+\treturn;\n+      p = p->next;\n+    }\n+\n+  p = ggc_alloc_stub_list ();\n+  p->next = stub_head;\n+  p->name = name;\n+  stub_head = p;\n+}\n+\n+\n #ifdef CXX_WRAP_SPEC_LIST\n \n /*  Hash table equality helper function.  */\n@@ -781,6 +815,30 @@ i386_pe_file_end (void)\n \t\t   (q->is_data ? \",data\" : \"\"));\n \t}\n     }\n+\n+  if (stub_head)\n+    {\n+      struct stub_list *q;\n+\n+      for (q = stub_head; q != NULL; q = q->next)\n+\t{\n+\t  const char *name = q->name;\n+\t  const char *oname;\n+\n+\t  if (name[0] == '*')\n+\t    ++name;\n+\t  oname = name;\n+\t  if (name[0] == '.')\n+\t    ++name;\n+\t  if (strncmp (name, \"refptr.\", 7) != 0)\n+\t    continue;\n+\t  name += 7;\n+\t  fprintf (asm_out_file, \"\\t.section\\t.rdata$%s, \\\"dr\\\"\\n\"\n+\t  \t\t   \"\\t.globl\\t%s\\n\"\n+\t\t\t   \"\\t.linkonce\\tdiscard\\n\", oname, oname);\n+\t  fprintf (asm_out_file, \"%s:\\n\\t.quad\\t%s\\n\", oname, name);\n+\t}\n+    }\n }\n \n \f"}]}