{"sha": "3e3f722c44c09d267a8e311ddda6896ede6bbffa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UzZjcyMmM0NGMwOWQyNjdhOGUzMTFkZGRhNjg5NmVkZTZiYmZmYQ==", "commit": {"author": {"name": "Martin v. L\u00f6wis", "email": "loewis@informatik.hu-berlin.de", "date": "1998-06-05T02:26:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-06-05T02:26:55Z"}, "message": "cp-tree.h (DECL_NAMESPACE_ALIAS, [...]): Declare.\n\n\t* cp-tree.h (DECL_NAMESPACE_ALIAS, ORIGINAL_NAMESPACE): Declare.\n\t* decl.c (lookup_name_real): Add namespaces_only parameter.\n\tIf set, return only NAMESPACE_DECLs.\n\t(select_decl): Likewise.\n\t(identifier_type_value): Give additional parameter.\n\t(lookup_name_nonclass): Likewise.\n\t(lookup_name): Likewise.\n\t(find_binding): Skip namespace aliases.\n\t(binding_for_name): Likewise.\n\t(push_namespace): Check for namespace aliases.\n\t(lookup_name_namespace_only): New function.\n\t(begin_only_namespace_names, end_only_namespace_names): New functions.\n\t* decl2.c (set_decl_namespace): Skip namespace aliases.\n\t(do_using_directive): Likewise.\n\t(do_namespace_alias): Produce namespace aliases, fix alias\n\tredeclaration.\n\t* error.c (dump_decl): Support SCOPE_REF.\n\t* parse.y (extdef): Wrap lookup with namespace_only for namespace\n\taliases and using declarations.\n\nFrom-SVN: r20236", "tree": {"sha": "3dca5dd31050fe5db2a4134ea9b3b519e94692ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dca5dd31050fe5db2a4134ea9b3b519e94692ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e3f722c44c09d267a8e311ddda6896ede6bbffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e3f722c44c09d267a8e311ddda6896ede6bbffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e3f722c44c09d267a8e311ddda6896ede6bbffa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e3f722c44c09d267a8e311ddda6896ede6bbffa/comments", "author": null, "committer": null, "parents": [{"sha": "122d34f62660c230a978966d1c233e0bd53ded36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/122d34f62660c230a978966d1c233e0bd53ded36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/122d34f62660c230a978966d1c233e0bd53ded36"}], "stats": {"total": 8242, "additions": 4184, "deletions": 4058}, "files": [{"sha": "c340bdba5b61d62922765c6feb72cb6595e10d1c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3e3f722c44c09d267a8e311ddda6896ede6bbffa", "patch": "@@ -1,3 +1,25 @@\n+1998-06-05  Martin v. Loewis  <loewis@informatik.hu-berlin.de>\n+\n+\t* cp-tree.h (DECL_NAMESPACE_ALIAS, ORIGINAL_NAMESPACE): Declare.\n+\t* decl.c (lookup_name_real): Add namespaces_only parameter.\n+\tIf set, return only NAMESPACE_DECLs.\n+\t(select_decl): Likewise.\n+\t(identifier_type_value): Give additional parameter.\n+\t(lookup_name_nonclass): Likewise.\n+\t(lookup_name): Likewise.\n+\t(find_binding): Skip namespace aliases.\n+\t(binding_for_name): Likewise.\n+\t(push_namespace): Check for namespace aliases.\n+\t(lookup_name_namespace_only): New function.\n+\t(begin_only_namespace_names, end_only_namespace_names): New functions.\n+\t* decl2.c (set_decl_namespace): Skip namespace aliases.\n+\t(do_using_directive): Likewise.\n+\t(do_namespace_alias): Produce namespace aliases, fix alias \n+\tredeclaration.\n+\t* error.c (dump_decl): Support SCOPE_REF.\n+\t* parse.y (extdef): Wrap lookup with namespace_only for namespace\n+\taliases and using declarations.\n+\n 1998-06-04  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* tree.c (really_overloaded_fn): Only see through one TREE_LIST."}, {"sha": "9632d81aa80e704135fec3eba93b615ce6ee4d5b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3e3f722c44c09d267a8e311ddda6896ede6bbffa", "patch": "@@ -1205,6 +1205,12 @@ struct lang_decl\n    of a namespace, to record the transitive closure of using namespace. */\n #define DECL_NAMESPACE_USERS(NODE) DECL_INITIAL (NODE)\n \n+/* In a NAMESPACE_DECL, points to the original namespace if this is\n+   a namespace alias.  */\n+#define DECL_NAMESPACE_ALIAS(NODE) DECL_ABSTRACT_ORIGIN (NODE)\n+#define ORIGINAL_NAMESPACE(NODE)  \\\n+  (DECL_NAMESPACE_ALIAS (NODE) ? DECL_NAMESPACE_ALIAS (NODE) : (NODE))\n+\n /* In a TREE_LIST concatenating using directives, indicate indirekt\n    directives  */\n #define TREE_INDIRECT_USING(NODE) ((NODE)->common.lang_flag_0)\n@@ -2354,6 +2360,9 @@ extern tree lookup_name_nonclass\t\tPROTO((tree));\n extern tree lookup_function_nonclass            PROTO((tree, tree));\n extern tree lookup_name\t\t\t\tPROTO((tree, int));\n extern tree lookup_name_current_level\t\tPROTO((tree));\n+extern tree lookup_name_namespace_only          PROTO((tree));\n+extern void begin_only_namespace_names          PROTO((void));\n+extern void end_only_namespace_names            PROTO((void));\n extern int  lookup_using_namespace              PROTO((tree,tree,tree,tree));\n extern int  qualified_lookup_using_namespace    PROTO((tree,tree,tree));\n extern tree auto_function\t\t\tPROTO((tree, tree, enum built_in_function));"}, {"sha": "67720731f59dc0cdd42474ec0f94a06e4d6ac365", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 61, "deletions": 12, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3e3f722c44c09d267a8e311ddda6896ede6bbffa", "patch": "@@ -157,7 +157,7 @@ static tree store_bindings PROTO((tree, tree));\n static tree lookup_tag_reverse PROTO((tree, tree));\n static tree obscure_complex_init PROTO((tree, tree));\n static tree maybe_build_cleanup_1 PROTO((tree, tree));\n-static tree lookup_name_real PROTO((tree, int, int));\n+static tree lookup_name_real PROTO((tree, int, int, int));\n static void warn_extern_redeclared_static PROTO((tree, tree));\n static void grok_reference_init PROTO((tree, tree, tree));\n static tree grokfndecl PROTO((tree, tree, tree, tree, int,\n@@ -331,6 +331,9 @@ tree vtbl_type_node;\n tree std_node;\n int in_std = 0;\n \n+/* Expect only namespace names now. */\n+static int only_namespace_names;\n+\n /* In a destructor, the point at which all derived class destroying\n    has been done, just before any base class destroying will be done.  */\n \n@@ -1646,6 +1649,9 @@ find_binding (name, scope)\n      tree scope;\n {\n   tree iter, prev = NULL_TREE;\n+\n+  scope = ORIGINAL_NAMESPACE (scope);\n+  \n   for (iter = IDENTIFIER_NAMESPACE_BINDINGS (name); iter;\n        iter = TREE_CHAIN (iter))\n     {\n@@ -1678,6 +1684,9 @@ binding_for_name (name, scope)\n {\n   tree b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n   tree result;\n+\n+  scope = ORIGINAL_NAMESPACE (scope);\n+  \n   if (b && TREE_CODE (b) != CPLUS_BINDING)\n     {\n       /* Get rid of optimization for global scope. */\n@@ -1783,7 +1792,15 @@ push_namespace (name)\n       /* Check whether this is an extended namespace definition. */\n       d = IDENTIFIER_NAMESPACE_VALUE (name);\n       if (d != NULL_TREE && TREE_CODE (d) == NAMESPACE_DECL)\n-\tneed_new = 0;\n+        {\n+          need_new = 0;\n+          if (DECL_NAMESPACE_ALIAS (d))\n+            {\n+              cp_error (\"namespace alias `%D' not allowed here, assuming `%D'\",\n+                        d, DECL_NAMESPACE_ALIAS (d));\n+              d = DECL_NAMESPACE_ALIAS (d);\n+            }\n+        }\n     }\n   \n   if (need_new)\n@@ -2145,7 +2162,7 @@ identifier_type_value (id)\n     return REAL_IDENTIFIER_TYPE_VALUE (id);\n   /* Have to search for it. It must be on the global level, now.\n      Ask lookup_name not to return non-types. */\n-  id = lookup_name_real (id, 2, 1);\n+  id = lookup_name_real (id, 2, 1, 0);\n   if (id)\n     return TREE_TYPE (id);\n   return NULL_TREE;\n@@ -4680,12 +4697,20 @@ make_typename_type (context, name)\n /* Select the right _DECL from multiple choices. */\n \n static tree\n-select_decl (binding, prefer_type)\n+select_decl (binding, prefer_type, namespaces_only)\n      tree binding;\n-     int prefer_type;\n+     int prefer_type, namespaces_only;\n {\n   tree val;\n   val = BINDING_VALUE (binding);\n+  if (namespaces_only)\n+    {\n+      /* We are not interested in types. */\n+      if (val && TREE_CODE (val) == NAMESPACE_DECL)\n+        return val;\n+      return NULL_TREE;\n+    }\n+  \n   /* If we could have a type and\n      we have nothing or we need a type and have none.  */\n   if (BINDING_TYPE (binding)\n@@ -4713,15 +4738,19 @@ select_decl (binding, prefer_type)\n    using IDENTIFIER_CLASS_VALUE.  */\n \n static tree\n-lookup_name_real (name, prefer_type, nonclass)\n+lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n      tree name;\n-     int prefer_type, nonclass;\n+     int prefer_type, nonclass, namespaces_only;\n {\n   register tree val;\n   int yylex = 0;\n   tree from_obj = NULL_TREE;\n   tree locval, classval;\n \n+  /* Hack: copy flag set by parser, if set. */\n+  if (only_namespace_names)\n+    namespaces_only = 1;\n+  \n   if (prefer_type == -2)\n     {\n       extern int looking_for_typename;\n@@ -4756,7 +4785,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \t      val = binding_init (&b);\n \t      if (!qualified_lookup_using_namespace (name, type, val))\n \t\treturn NULL_TREE;\n-\t      val = select_decl (val, prefer_type);\n+\t      val = select_decl (val, prefer_type, namespaces_only);\n \t    }\n \t  else if (! IS_AGGR_TYPE (type)\n \t\t   || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n@@ -4800,7 +4829,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \n   locval = classval = NULL_TREE;\n \n-  if (!current_binding_level->namespace_p\n+  if (!namespaces_only && !current_binding_level->namespace_p\n       && IDENTIFIER_LOCAL_VALUE (name)\n       /* Kludge to avoid infinite recursion with identifier_type_value.  */\n       && (prefer_type <= 0\n@@ -4885,7 +4914,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \t      val = NULL_TREE;\n \t      break;\n \t    }\n-\t  val = select_decl (b, prefer_type);\n+\t  val = select_decl (b, prefer_type, namespaces_only);\n \t  if (scope == global_namespace)\n \t    break;\n \t  scope = DECL_CONTEXT (scope);\n@@ -4932,7 +4961,7 @@ tree\n lookup_name_nonclass (name)\n      tree name;\n {\n-  return lookup_name_real (name, 0, 1);\n+  return lookup_name_real (name, 0, 1, 0);\n }\n \n tree\n@@ -4943,12 +4972,20 @@ lookup_function_nonclass (name, args)\n   return lookup_arg_dependent (name, lookup_name_nonclass (name), args);\n }\n \n+tree\n+lookup_name_namespace_only (name)\n+     tree name;\n+{\n+  /* type-or-namespace, nonclass, namespace_only */\n+  return lookup_name_real (name, 1, 1, 1);\n+}\n+\n tree\n lookup_name (name, prefer_type)\n      tree name;\n      int prefer_type;\n {\n-  return lookup_name_real (name, prefer_type, 0);\n+  return lookup_name_real (name, prefer_type, 0, 0);\n }\n \n /* Similar to `lookup_name' but look only at current binding level.  */\n@@ -4986,6 +5023,18 @@ lookup_name_current_level (name)\n \n   return t;\n }\n+\n+void\n+begin_only_namespace_names ()\n+{\n+  only_namespace_names = 1;\n+}\n+\n+void\n+end_only_namespace_names ()\n+{\n+  only_namespace_names = 0;\n+}\n \f\n /* Arrange for the user to get a source line number, even when the\n    compiler is going down in flames, so that she at least has a"}, {"sha": "373093a0719d1fbe5ced7ad09a36ed407962dce3", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3e3f722c44c09d267a8e311ddda6896ede6bbffa", "patch": "@@ -4003,6 +4003,9 @@ set_decl_namespace (decl, scope)\n   tree old;\n   if (scope == std_node)\n     scope = global_namespace;\n+  /* Get rid of namespace aliases. */\n+  scope = ORIGINAL_NAMESPACE (scope);\n+  \n   if (!is_namespace_ancestor (current_namespace, scope))\n     cp_error (\"declaration of `%D' not in a namespace surrounding `%D'\",\n \t      decl, scope);\n@@ -4354,27 +4357,35 @@ do_namespace_alias (alias, namespace)\n      tree alias, namespace;\n {\n   tree binding;\n-  tree ns;\n-  if (TREE_CODE (namespace) == IDENTIFIER_NODE)\n-    ns = lookup_name (namespace, 1);\n-  else\n-    ns = namespace;\n-  if (TREE_CODE (ns) != NAMESPACE_DECL)\n+  tree old;\n+\n+  if (TREE_CODE (namespace) != NAMESPACE_DECL)\n     {\n-      cp_error (\"`%D' is not a namespace\", namespace);\n+      /* The parser did not find it, so it's not there. */\n+      cp_error (\"unknown namespace `%D'\", namespace);\n       return;\n     }\n+\n+  namespace = ORIGINAL_NAMESPACE (namespace);\n+\n   binding = binding_for_name (alias, current_namespace);\n-  if (BINDING_VALUE (binding) && BINDING_VALUE (binding) != namespace)\n+  old = BINDING_VALUE (binding);\n+  if (old)\n     {\n+      if (TREE_CODE (old) == NAMESPACE_DECL\n+          && DECL_NAMESPACE_ALIAS (old) == namespace)\n+        /* Ok: redeclaration. */\n+        return;\n       cp_error (\"invalid namespace alias `%D'\", alias);\n-      cp_error_at (\"`%D' previously declared here\", alias);\n+      cp_error_at (\"`%D' previously declared here\", old);\n     }\n   else\n     {\n-      /* XXX the alias is not exactly identical to the name space,\n-\t it must not be used in a using directive or namespace alias */\n-      BINDING_VALUE (binding) = ns;\n+      /* Build the alias. */\n+      alias = build_lang_decl (NAMESPACE_DECL, alias, void_type_node);     \n+      DECL_NAMESPACE_ALIAS (alias) = namespace;\n+      DECL_CONTEXT (alias) = current_namespace;\n+      BINDING_VALUE (binding) = alias;\n     }\n }\n \n@@ -4512,7 +4523,7 @@ do_using_directive (namespace)\n       sorry (\"using directives inside functions\");\n       return;\n     }\n-  /* using A::B::C; */\n+  /* using namespace A::B::C; */\n   if (TREE_CODE (namespace) == SCOPE_REF)\n       namespace = TREE_OPERAND (namespace, 1);\n   if (TREE_CODE (namespace) == IDENTIFIER_NODE)\n@@ -4526,6 +4537,7 @@ do_using_directive (namespace)\n       cp_error (\"`%T' is not a namespace\", namespace);\n       return;\n     }\n+  namespace = ORIGINAL_NAMESPACE (namespace);\n   /* direct usage */\n   add_using_namespace (current_namespace, namespace, 0);\n }"}, {"sha": "2c77eff44e799d46196785446e052fed4ef2d7e1", "filename": "gcc/cp/error.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=3e3f722c44c09d267a8e311ddda6896ede6bbffa", "patch": "@@ -39,18 +39,18 @@ typedef char* cp_printer ();\n #define T type_as_string\n #define V cv_as_string\n \n-#define _ (cp_printer *) 0\n+#define o (cp_printer *) 0\n cp_printer * cp_printers[256] =\n-{ \n+{\n /*0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */\n-  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x00 */\n-  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x10 */\n-  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x20 */\n-  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x30 */\n-  _, A, _, C, D, E, _, _, _, _, _, _, L, _, _, O, /* 0x40 */\n-  P, Q, _, _, T, _, V, _, _, _, _, _, _, _, _, _, /* 0x50 */\n-  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x60 */\n-  _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, /* 0x70 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x00 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x10 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x20 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x30 */\n+  o, A, o, C, D, E, o, o, o, o, o, o, L, o, o, O, /* 0x40 */\n+  P, Q, o, o, T, o, V, o, o, o, o, o, o, o, o, o, /* 0x50 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x60 */\n+  o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, o, /* 0x70 */\n };\n #undef C\n #undef D\n@@ -61,7 +61,7 @@ cp_printer * cp_printers[256] =\n #undef Q\n #undef T\n #undef V\n-#undef _\n+#undef o\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -726,6 +726,12 @@ dump_decl (t, v)\n       OB_PUTID (DECL_NAME (t));\n       break;\n \n+    case SCOPE_REF:\n+      dump_decl (TREE_OPERAND (t, 0), 0);\n+      OB_PUTS (\"::\");\n+      dump_decl (TREE_OPERAND (t, 1), 0);\n+      break;      \n+\n     case ARRAY_REF:\n       dump_decl (TREE_OPERAND (t, 0), v);\n       OB_PUTC ('[');"}, {"sha": "481a1ff0d03037f0b57efa9c01d1bdaf6561624e", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 4034, "deletions": 4016, "changes": 8050, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=3e3f722c44c09d267a8e311ddda6896ede6bbffa"}, {"sha": "5feb62d65f07cccffa6ef6be212d501b6a0cfe7b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e3f722c44c09d267a8e311ddda6896ede6bbffa/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=3e3f722c44c09d267a8e311ddda6896ede6bbffa", "patch": "@@ -401,18 +401,28 @@ extdef:\n \t\t{ push_namespace (NULL_TREE); }\n \t  extdefs_opt '}'\n \t\t{ pop_namespace (); }\n-\t| NAMESPACE identifier '=' any_id ';'\n-\t\t{ do_namespace_alias ($2, $4); }\n+\t| NAMESPACE identifier '=' \n+                { begin_only_namespace_names (); }\n+                any_id ';'\n+\t\t{\n+\t\t  end_only_namespace_names ();\n+\t\t  if (lastiddecl)\n+\t\t    $5 = lastiddecl;\n+\t\t  do_namespace_alias ($2, $5);\n+\t\t}\n \t| using_decl ';'\n \t\t{ do_toplevel_using_decl ($1); }\n-\t| USING NAMESPACE any_id ';'\n+\t| USING NAMESPACE\n+\t\t{ begin_only_namespace_names (); }\n+\t\tany_id ';'\n \t\t{\n+\t\t  end_only_namespace_names ();\n \t\t  /* If no declaration was found, the using-directive is\n \t\t     invalid. Since that was not reported, we need the\n \t\t     identifier for the error message. */\n-\t\t  if (TREE_CODE ($3) == IDENTIFIER_NODE && lastiddecl)\n-\t\t    $3 = lastiddecl;\n-\t\t  do_using_directive ($3);\n+\t\t  if (TREE_CODE ($4) == IDENTIFIER_NODE && lastiddecl)\n+\t\t    $4 = lastiddecl;\n+\t\t  do_using_directive ($4);\n \t\t}\n \t| extension extdef\n \t\t{ pedantic = $<itype>1; }"}]}