{"sha": "fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVlOGI2ZGFkZDM4NDdkNmNkYzVlNDhhNDY3YmU0OGNlMTZmZDcxZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-19T22:28:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-19T22:28:54Z"}, "message": "cgraph.h (save_inline_function_body): Remove.\n\n\t* cgraph.h (save_inline_function_body): Remove.\n\t* ipa-inline-transform.c: New file, broke out of...\n\t* ipa-inline.c: ... this one; Update toplevel comment.\n\t(ncalls_inlined, nfunctions_inlined): Move to ipa-inline-transform.c;\n\tmake global.\n\t(update_noncloned_frequencies): Move to ipa-inline-transform.c\n\t(cgraph_mark_inline_edge): Rename to inline_call; move to\n\tipa-inline-transform.c.\n\t(cgraph_clone_inlined_nodes): Rename to clone_inlined_nodes;\n\tmove to ipa-inline-transform.c\n\t(recursive_inlining, inline_small_functions, flatten_function,\n\tipa_inline, inline_always_inline_functions,\n\tearly_inline_small_functions): Update.\n\t(inline_transform): Move to ipa-inline-transform.c.\n\t* ipa-inline.h (inline_call, inline_transform, clone_inlined_nodes):\n\tDeclare.\n\t* Makefile.in (ipa-inline-transform.o): New file.\n\t* cgraphunit.c (save_inline_function_body): Move to\n\tipa-inline-transform.c\n\nFrom-SVN: r172739", "tree": {"sha": "518ceb62ac7521423992dc5befe95e7c201bee2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/518ceb62ac7521423992dc5befe95e7c201bee2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/comments", "author": null, "committer": null, "parents": [{"sha": "61eca8d71b276c84155b88d7fca656c49ff73b98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61eca8d71b276c84155b88d7fca656c49ff73b98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61eca8d71b276c84155b88d7fca656c49ff73b98"}], "stats": {"total": 651, "additions": 372, "deletions": 279}, "files": [{"sha": "7ba9b21c4c1701eda4883cfcaabf93a2283c4ff8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "patch": "@@ -1,3 +1,25 @@\n+2011-04-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (save_inline_function_body): Remove.\n+\t* ipa-inline-transform.c: New file, broke out of...\n+\t* ipa-inline.c: ... this one; Update toplevel comment.\n+\t(ncalls_inlined, nfunctions_inlined): Move to ipa-inline-transform.c;\n+\tmake global.\n+\t(update_noncloned_frequencies): Move to ipa-inline-transform.c\n+\t(cgraph_mark_inline_edge): Rename to inline_call; move to\n+\tipa-inline-transform.c.\n+\t(cgraph_clone_inlined_nodes): Rename to clone_inlined_nodes;\n+\tmove to ipa-inline-transform.c\n+\t(recursive_inlining, inline_small_functions, flatten_function,\n+\tipa_inline, inline_always_inline_functions,\n+\tearly_inline_small_functions): Update.\n+\t(inline_transform): Move to ipa-inline-transform.c.\n+\t* ipa-inline.h (inline_call, inline_transform, clone_inlined_nodes):\n+\tDeclare.\n+\t* Makefile.in (ipa-inline-transform.o): New file.\n+\t* cgraphunit.c (save_inline_function_body): Move to\n+\tipa-inline-transform.c\n+\n 2011-04-19  DJ Delorie  <dj@redhat.com>\n \n \t* config/m32c/m32c.c (m32c_emit_epilogue): Don't try to push"}, {"sha": "e300a6c8ca6c9377cf22fcc7f808774bf9bc1b07", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "patch": "@@ -1469,6 +1469,7 @@ OBJS-archive = \\\n         ipa-split.o \\\n \tipa-inline.o \\\n \tipa-inline-analysis.o \\\n+\tipa-inline-transform.o \\\n \tipa-prop.o \\\n \tipa-pure-const.o \\\n \tipa-reference.o \\\n@@ -3035,6 +3036,11 @@ ipa-inline-analysis.o : ipa-inline-analysis.c $(CONFIG_H) $(SYSTEM_H) coretypes.\n    $(DIAGNOSTIC_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n    $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(IPA_PROP_H) \\\n    gimple-pretty-print.h ipa-inline.h $(LTO_STREAMER_H)\n+ipa-inline-transform.o : ipa-inline-transform.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \\\n+   $(DIAGNOSTIC_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) \\\n+   $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(IPA_PROP_H) \\\n+   gimple-pretty-print.h ipa-inline.h $(LTO_STREAMER_H)\n ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \\\n    pointer-set.h $(GGC_H) $(GIMPLE_H) $(SPLAY_TREE_H) \\"}, {"sha": "032c837a228634216278cca7a1c32cd0ed353c50", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "patch": "@@ -595,7 +595,6 @@ struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n \t\t\t\t\t\tconst char *);\n void tree_function_versioning (tree, tree, VEC (ipa_replace_map_p,gc)*, bool, bitmap,\n \t\t\t       bitmap, basic_block);\n-struct cgraph_node *save_inline_function_body (struct cgraph_node *);\n void record_references_in_initializer (tree, bool);\n bool cgraph_process_new_functions (void);\n \n@@ -927,7 +926,6 @@ cgraph_edge_recursive_p (struct cgraph_edge *e)\n     return e->caller->decl == e->callee->decl;\n }\n \n-\n /* FIXME: inappropriate dependency of cgraph on IPA.  */\n #include \"ipa-ref-inline.h\"\n "}, {"sha": "1a687fbbc7a938cf6abb7755407b06a45e02a731", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "patch": "@@ -2094,74 +2094,6 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n   return new_version_node;\n }\n \n-/* Produce separate function body for inline clones so the offline copy can be\n-   modified without affecting them.  */\n-struct cgraph_node *\n-save_inline_function_body (struct cgraph_node *node)\n-{\n-  struct cgraph_node *first_clone, *n;\n-\n-  gcc_assert (node == cgraph_get_node (node->decl));\n-\n-  cgraph_lower_function (node);\n-\n-  first_clone = node->clones;\n-\n-  first_clone->decl = copy_node (node->decl);\n-  cgraph_insert_node_to_hashtable (first_clone);\n-  gcc_assert (first_clone == cgraph_get_node (first_clone->decl));\n-  if (first_clone->next_sibling_clone)\n-    {\n-      for (n = first_clone->next_sibling_clone; n->next_sibling_clone; n = n->next_sibling_clone)\n-        n->clone_of = first_clone;\n-      n->clone_of = first_clone;\n-      n->next_sibling_clone = first_clone->clones;\n-      if (first_clone->clones)\n-        first_clone->clones->prev_sibling_clone = n;\n-      first_clone->clones = first_clone->next_sibling_clone;\n-      first_clone->next_sibling_clone->prev_sibling_clone = NULL;\n-      first_clone->next_sibling_clone = NULL;\n-      gcc_assert (!first_clone->prev_sibling_clone);\n-    }\n-  first_clone->clone_of = NULL;\n-  node->clones = NULL;\n-\n-  if (first_clone->clones)\n-    for (n = first_clone->clones; n != first_clone;)\n-      {\n-        gcc_assert (n->decl == node->decl);\n-\tn->decl = first_clone->decl;\n-\tif (n->clones)\n-\t  n = n->clones;\n-\telse if (n->next_sibling_clone)\n-\t  n = n->next_sibling_clone;\n-\telse\n-\t  {\n-\t    while (n != first_clone && !n->next_sibling_clone)\n-\t      n = n->clone_of;\n-\t    if (n != first_clone)\n-\t      n = n->next_sibling_clone;\n-\t  }\n-      }\n-\n-  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (node->decl, first_clone->decl, NULL, true, NULL,\n-\t\t\t    NULL, NULL);\n-\n-  DECL_EXTERNAL (first_clone->decl) = 0;\n-  DECL_COMDAT_GROUP (first_clone->decl) = NULL_TREE;\n-  TREE_PUBLIC (first_clone->decl) = 0;\n-  DECL_COMDAT (first_clone->decl) = 0;\n-  VEC_free (ipa_opt_pass, heap,\n-            first_clone->ipa_transforms_to_apply);\n-  first_clone->ipa_transforms_to_apply = NULL;\n-\n-#ifdef ENABLE_CHECKING\n-  verify_cgraph_node (first_clone);\n-#endif\n-  return first_clone;\n-}\n-\n /* Given virtual clone, turn it into actual clone.  */\n static void\n cgraph_materialize_clone (struct cgraph_node *node)"}, {"sha": "0fb2448889340403ce81bae61b6dffd52f8f1c47", "filename": "gcc/ipa-inline-transform.c", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "patch": "@@ -0,0 +1,328 @@\n+/* Callgraph transformations to handle inlining\n+   Copyright (C) 2003, 2004, 2007, 2008, 2009, 2010, 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* The inline decisions are stored in callgraph in \"inline plan\" and\n+   applied later.\n+\n+   To mark given call inline, use inline_call function.\n+   The function marks the edge inlinable and, if necessary, produces\n+   virtual clone in the callgraph representing the new copy of callee's\n+   function body.\n+\n+   The inline plan is applied on given function body by inline_transform.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"langhooks.h\"\n+#include \"cgraph.h\"\n+#include \"timevar.h\"\n+#include \"output.h\"\n+#include \"intl.h\"\n+#include \"coverage.h\"\n+#include \"ggc.h\"\n+#include \"tree-flow.h\"\n+#include \"ipa-prop.h\"\n+#include \"ipa-inline.h\"\n+#include \"tree-inline.h\"\n+\n+int ncalls_inlined;\n+int nfunctions_inlined;\n+\n+/* Scale frequency of NODE edges by FREQ_SCALE and increase loop nest\n+   by NEST.  */\n+\n+static void\n+update_noncloned_frequencies (struct cgraph_node *node,\n+\t\t\t      int freq_scale, int nest)\n+{\n+  struct cgraph_edge *e;\n+\n+  /* We do not want to ignore high loop nest after freq drops to 0.  */\n+  if (!freq_scale)\n+    freq_scale = 1;\n+  for (e = node->callees; e; e = e->next_callee)\n+    {\n+      e->loop_nest += nest;\n+      e->frequency = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n+      if (e->frequency > CGRAPH_FREQ_MAX)\n+        e->frequency = CGRAPH_FREQ_MAX;\n+      if (!e->inline_failed)\n+        update_noncloned_frequencies (e->callee, freq_scale, nest);\n+    }\n+}\n+\n+\n+/* E is expected to be an edge being inlined.  Clone destination node of\n+   the edge and redirect it to the new clone.\n+   DUPLICATE is used for bookkeeping on whether we are actually creating new\n+   clones or re-using node originally representing out-of-line function call.\n+   */\n+\n+void\n+clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n+\t\t     bool update_original, int *overall_size)\n+{\n+  HOST_WIDE_INT peak;\n+  struct inline_summary *caller_info, *callee_info;\n+\n+  if (duplicate)\n+    {\n+      /* We may eliminate the need for out-of-line copy to be output.\n+\t In that case just go ahead and re-use it.  This is not just an\n+\t memory optimization.  Making offline copy of fuction disappear\n+\t from the program will improve future decisions on inlining.  */\n+      if (!e->callee->callers->next_caller\n+\t  /* Recursive inlining never wants the master clone to\n+\t     be overwritten.  */\n+\t  && update_original\n+\t  /* FIXME: When address is taken of DECL_EXTERNAL function we still\n+\t     can remove its offline copy, but we would need to keep unanalyzed\n+\t     node in the callgraph so references can point to it.  */\n+\t  && !e->callee->address_taken\n+\t  && cgraph_can_remove_if_no_direct_calls_p (e->callee)\n+\t  /* Inlining might enable more devirtualizing, so we want to remove\n+\t     those only after all devirtualizable virtual calls are processed.\n+\t     Lacking may edges in callgraph we just preserve them post\n+\t     inlining.  */\n+\t  && (!DECL_VIRTUAL_P (e->callee->decl)\n+\t      || (!DECL_COMDAT (e->callee->decl)\n+\t\t  && !DECL_EXTERNAL (e->callee->decl)))\n+\t  /* Don't reuse if more than one function shares a comdat group.\n+\t     If the other function(s) are needed, we need to emit even\n+\t     this function out of line.  */\n+\t  && !e->callee->same_comdat_group\n+\t  /* During early inlining some unanalyzed cgraph nodes might be in the\n+\t     callgraph and they might reffer the function in question.  */\n+\t  && !cgraph_new_nodes)\n+\t{\n+\t  gcc_assert (!e->callee->global.inlined_to);\n+\t  if (e->callee->analyzed && !DECL_EXTERNAL (e->callee->decl))\n+\t    {\n+\t      if (overall_size)\n+\t        *overall_size -= inline_summary (e->callee)->size;\n+\t      nfunctions_inlined++;\n+\t    }\n+\t  duplicate = false;\n+\t  e->callee->local.externally_visible = false;\n+          update_noncloned_frequencies (e->callee, e->frequency, e->loop_nest);\n+\t}\n+      else\n+\t{\n+\t  struct cgraph_node *n;\n+\t  n = cgraph_clone_node (e->callee, e->callee->decl,\n+\t\t\t\t e->count, e->frequency, e->loop_nest,\n+\t\t\t\t update_original, NULL);\n+\t  cgraph_redirect_edge_callee (e, n);\n+\t}\n+    }\n+\n+  callee_info = inline_summary (e->callee);\n+  caller_info = inline_summary (e->caller);\n+\n+  if (e->caller->global.inlined_to)\n+    e->callee->global.inlined_to = e->caller->global.inlined_to;\n+  else\n+    e->callee->global.inlined_to = e->caller;\n+  callee_info->stack_frame_offset\n+    = caller_info->stack_frame_offset\n+      + caller_info->estimated_self_stack_size;\n+  peak = callee_info->stack_frame_offset\n+      + callee_info->estimated_self_stack_size;\n+  if (inline_summary (e->callee->global.inlined_to)->estimated_stack_size\n+      < peak)\n+    inline_summary (e->callee->global.inlined_to)->estimated_stack_size = peak;\n+  cgraph_propagate_frequency (e->callee);\n+\n+  /* Recursively clone all bodies.  */\n+  for (e = e->callee->callees; e; e = e->next_callee)\n+    if (!e->inline_failed)\n+      clone_inlined_nodes (e, duplicate, update_original, overall_size);\n+}\n+\n+\n+/* Mark edge E as inlined and update callgraph accordingly.  UPDATE_ORIGINAL\n+   specify whether profile of original function should be updated.  If any new\n+   indirect edges are discovered in the process, add them to NEW_EDGES, unless\n+   it is NULL.  Return true iff any new callgraph edges were discovered as a\n+   result of inlining.  */\n+\n+bool\n+inline_call (struct cgraph_edge *e, bool update_original,\n+\t     VEC (cgraph_edge_p, heap) **new_edges,\n+\t     int *overall_size)\n+{\n+  int old_size = 0, new_size = 0;\n+  struct cgraph_node *to = NULL;\n+  struct cgraph_edge *curr = e;\n+  struct inline_summary *info;\n+\n+  /* Don't inline inlined edges.  */\n+  gcc_assert (e->inline_failed);\n+  /* Don't even think of inlining inline clone.  */\n+  gcc_assert (!e->callee->global.inlined_to);\n+\n+  e->inline_failed = CIF_OK;\n+  DECL_POSSIBLY_INLINED (e->callee->decl) = true;\n+\n+  clone_inlined_nodes (e, true, update_original, overall_size);\n+\n+  /* Now update size of caller and all functions caller is inlined into.  */\n+  for (;e && !e->inline_failed; e = e->caller->callers)\n+    {\n+      to = e->caller;\n+      info = inline_summary (to);\n+      old_size = info->size;\n+      new_size = estimate_size_after_inlining (to, curr);\n+      info->size = new_size;\n+      info->time = estimate_time_after_inlining (to, curr);\n+    }\n+  gcc_assert (curr->callee->global.inlined_to == to);\n+  if (overall_size && new_size > old_size)\n+    *overall_size += new_size - old_size;\n+  ncalls_inlined++;\n+\n+  if (flag_indirect_inlining && optimize)\n+    return ipa_propagate_indirect_call_infos (curr, new_edges);\n+  else\n+    return false;\n+}\n+\n+\n+/* Copy function body of NODE and redirect all inline clones to it.\n+   This is done before inline plan is applied to NODE when there are\n+   still some inline clones if it.\n+\n+   This is neccesary because inline decisions are not really transitive\n+   and the other inline clones may have different bodies.  */\n+\n+static struct cgraph_node *\n+save_inline_function_body (struct cgraph_node *node)\n+{\n+  struct cgraph_node *first_clone, *n;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nSaving body of %s for later reuse\\n\",\n+\t     cgraph_node_name (node));\n+ \n+  gcc_assert (node == cgraph_get_node (node->decl));\n+\n+  /* first_clone will be turned into real function.  */\n+  first_clone = node->clones;\n+  first_clone->decl = copy_node (node->decl);\n+  cgraph_insert_node_to_hashtable (first_clone);\n+  gcc_assert (first_clone == cgraph_get_node (first_clone->decl));\n+\n+  /* Now reshape the clone tree, so all other clones descends from\n+     first_clone.  */\n+  if (first_clone->next_sibling_clone)\n+    {\n+      for (n = first_clone->next_sibling_clone; n->next_sibling_clone; n = n->next_sibling_clone)\n+        n->clone_of = first_clone;\n+      n->clone_of = first_clone;\n+      n->next_sibling_clone = first_clone->clones;\n+      if (first_clone->clones)\n+        first_clone->clones->prev_sibling_clone = n;\n+      first_clone->clones = first_clone->next_sibling_clone;\n+      first_clone->next_sibling_clone->prev_sibling_clone = NULL;\n+      first_clone->next_sibling_clone = NULL;\n+      gcc_assert (!first_clone->prev_sibling_clone);\n+    }\n+  first_clone->clone_of = NULL;\n+\n+  /* Now node in question has no clones.  */\n+  node->clones = NULL;\n+\n+  if (first_clone->clones)\n+    for (n = first_clone->clones; n != first_clone;)\n+      {\n+        gcc_assert (n->decl == node->decl);\n+\tn->decl = first_clone->decl;\n+\tif (n->clones)\n+\t  n = n->clones;\n+\telse if (n->next_sibling_clone)\n+\t  n = n->next_sibling_clone;\n+\telse\n+\t  {\n+\t    while (n != first_clone && !n->next_sibling_clone)\n+\t      n = n->clone_of;\n+\t    if (n != first_clone)\n+\t      n = n->next_sibling_clone;\n+\t  }\n+      }\n+\n+  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n+  tree_function_versioning (node->decl, first_clone->decl, NULL, true, NULL,\n+\t\t\t    NULL, NULL);\n+\n+  DECL_EXTERNAL (first_clone->decl) = 0;\n+  DECL_COMDAT_GROUP (first_clone->decl) = NULL_TREE;\n+  TREE_PUBLIC (first_clone->decl) = 0;\n+  DECL_COMDAT (first_clone->decl) = 0;\n+  VEC_free (ipa_opt_pass, heap,\n+            first_clone->ipa_transforms_to_apply);\n+  first_clone->ipa_transforms_to_apply = NULL;\n+\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph_node (first_clone);\n+#endif\n+  return first_clone;\n+}\n+\n+\n+/* Apply inline plan to function.  */\n+\n+unsigned int\n+inline_transform (struct cgraph_node *node)\n+{\n+  unsigned int todo = 0;\n+  struct cgraph_edge *e;\n+  bool inline_p = false;\n+\n+  /* FIXME: Currently the pass manager is adding inline transform more than\n+     once to some clones.  This needs revisiting after WPA cleanups.  */\n+  if (cfun->after_inlining)\n+    return 0;\n+\n+  /* We might need the body of this function so that we can expand\n+     it inline somewhere else.  */\n+  if (cgraph_preserve_function_body_p (node->decl))\n+    save_inline_function_body (node);\n+\n+  for (e = node->callees; e; e = e->next_callee)\n+    {\n+      cgraph_redirect_edge_call_stmt_to_callee (e);\n+      if (!e->inline_failed || warn_inline)\n+        inline_p = true;\n+    }\n+\n+  if (inline_p)\n+    {\n+      timevar_push (TV_INTEGRATION);\n+      todo = optimize_inline_calls (current_function_decl);\n+      timevar_pop (TV_INTEGRATION);\n+    }\n+  cfun->always_inline_functions_inlined = true;\n+  cfun->after_inlining = true;\n+  return todo | execute_fixup_cfg ();\n+}"}, {"sha": "5140cfa744cdb114bb9b2941e96e043e41395ada", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 7, "deletions": 209, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "patch": "@@ -23,18 +23,6 @@ along with GCC; see the file COPYING3.  If not see\n \n     The implementation of inliner is organized as follows:\n \n-    Transformation of callgraph to represent inlining decisions.\n-\n-      The inline decisions are stored in callgraph in \"inline plan\" and\n-      all applied later.\n-\n-      To mark given call inline, use cgraph_mark_inline function.\n-      The function marks the edge inlinable and, if necessary, produces\n-      virtual clone in the callgraph representing the new copy of callee's\n-      function body.\n-\n-      The inline plan is applied on given function body by inline_transform. \n-\n     inlining heuristics limits\n \n       can_inline_edge_p allow to check that particular inlining is allowed\n@@ -128,163 +116,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-inline.h\"\n \n /* Statistics we collect about inlining algorithm.  */\n-static int ncalls_inlined;\n-static int nfunctions_inlined;\n static int overall_size;\n static gcov_type max_count, max_benefit;\n \n-/* Scale frequency of NODE edges by FREQ_SCALE and increase loop nest\n-   by NEST.  */\n-\n-static void\n-update_noncloned_frequencies (struct cgraph_node *node,\n-\t\t\t      int freq_scale, int nest)\n-{\n-  struct cgraph_edge *e;\n-\n-  /* We do not want to ignore high loop nest after freq drops to 0.  */\n-  if (!freq_scale)\n-    freq_scale = 1;\n-  for (e = node->callees; e; e = e->next_callee)\n-    {\n-      e->loop_nest += nest;\n-      e->frequency = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n-      if (e->frequency > CGRAPH_FREQ_MAX)\n-        e->frequency = CGRAPH_FREQ_MAX;\n-      if (!e->inline_failed)\n-        update_noncloned_frequencies (e->callee, freq_scale, nest);\n-    }\n-}\n-\n-/* E is expected to be an edge being inlined.  Clone destination node of\n-   the edge and redirect it to the new clone.\n-   DUPLICATE is used for bookkeeping on whether we are actually creating new\n-   clones or re-using node originally representing out-of-line function call.\n-   */\n-void\n-cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n-\t\t\t    bool update_original)\n-{\n-  HOST_WIDE_INT peak;\n-  struct inline_summary *caller_info, *callee_info;\n-\n-  if (duplicate)\n-    {\n-      /* We may eliminate the need for out-of-line copy to be output.\n-\t In that case just go ahead and re-use it.  */\n-      if (!e->callee->callers->next_caller\n-\t  /* Recursive inlining never wants the master clone to\n-\t     be overwritten.  */\n-\t  && update_original\n-\t  /* FIXME: When address is taken of DECL_EXTERNAL function we still\n-\t     can remove its offline copy, but we would need to keep unanalyzed\n-\t     node in the callgraph so references can point to it.  */\n-\t  && !e->callee->address_taken\n-\t  && cgraph_can_remove_if_no_direct_calls_p (e->callee)\n-\t  /* Inlining might enable more devirtualizing, so we want to remove\n-\t     those only after all devirtualizable virtual calls are processed.\n-\t     Lacking may edges in callgraph we just preserve them post\n-\t     inlining.  */\n-\t  && (!DECL_VIRTUAL_P (e->callee->decl)\n-\t      || (!DECL_COMDAT (e->callee->decl)\n-\t\t  && !DECL_EXTERNAL (e->callee->decl)))\n-\t  /* Don't reuse if more than one function shares a comdat group.\n-\t     If the other function(s) are needed, we need to emit even\n-\t     this function out of line.  */\n-\t  && !e->callee->same_comdat_group\n-\t  && !cgraph_new_nodes)\n-\t{\n-\t  gcc_assert (!e->callee->global.inlined_to);\n-\t  if (e->callee->analyzed && !DECL_EXTERNAL (e->callee->decl))\n-\t    {\n-\t      overall_size -= inline_summary (e->callee)->size;\n-\t      nfunctions_inlined++;\n-\t    }\n-\t  duplicate = false;\n-\t  e->callee->local.externally_visible = false;\n-          update_noncloned_frequencies (e->callee, e->frequency, e->loop_nest);\n-\t}\n-      else\n-\t{\n-\t  struct cgraph_node *n;\n-\t  n = cgraph_clone_node (e->callee, e->callee->decl,\n-\t\t\t\t e->count, e->frequency, e->loop_nest,\n-\t\t\t\t update_original, NULL);\n-\t  cgraph_redirect_edge_callee (e, n);\n-\t}\n-    }\n-\n-  callee_info = inline_summary (e->callee);\n-  caller_info = inline_summary (e->caller);\n-\n-  if (e->caller->global.inlined_to)\n-    e->callee->global.inlined_to = e->caller->global.inlined_to;\n-  else\n-    e->callee->global.inlined_to = e->caller;\n-  callee_info->stack_frame_offset\n-    = caller_info->stack_frame_offset\n-      + caller_info->estimated_self_stack_size;\n-  peak = callee_info->stack_frame_offset\n-      + callee_info->estimated_self_stack_size;\n-  if (inline_summary (e->callee->global.inlined_to)->estimated_stack_size\n-      < peak)\n-    inline_summary (e->callee->global.inlined_to)->estimated_stack_size = peak;\n-  cgraph_propagate_frequency (e->callee);\n-\n-  /* Recursively clone all bodies.  */\n-  for (e = e->callee->callees; e; e = e->next_callee)\n-    if (!e->inline_failed)\n-      cgraph_clone_inlined_nodes (e, duplicate, update_original);\n-}\n-\n-/* Mark edge E as inlined and update callgraph accordingly.  UPDATE_ORIGINAL\n-   specify whether profile of original function should be updated.  If any new\n-   indirect edges are discovered in the process, add them to NEW_EDGES, unless\n-   it is NULL.  Return true iff any new callgraph edges were discovered as a\n-   result of inlining.  */\n-\n-static bool\n-cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n-\t\t\t VEC (cgraph_edge_p, heap) **new_edges)\n-{\n-  int old_size = 0, new_size = 0;\n-  struct cgraph_node *to = NULL;\n-  struct cgraph_edge *curr = e;\n-  struct inline_summary *info;\n-\n-  /* Don't inline inlined edges.  */\n-  gcc_assert (e->inline_failed);\n-  /* Don't even think of inlining inline clone.  */\n-  gcc_assert (!e->callee->global.inlined_to);\n-\n-  e->inline_failed = CIF_OK;\n-  DECL_POSSIBLY_INLINED (e->callee->decl) = true;\n-\n-  cgraph_clone_inlined_nodes (e, true, update_original);\n-\n-  /* Now update size of caller and all functions caller is inlined into.  */\n-  for (;e && !e->inline_failed; e = e->caller->callers)\n-    {\n-      to = e->caller;\n-      info = inline_summary (to);\n-      old_size = info->size;\n-      new_size = estimate_size_after_inlining (to, curr);\n-      info->size = new_size;\n-      info->time = estimate_time_after_inlining (to, curr);\n-    }\n-  gcc_assert (curr->callee->global.inlined_to == to);\n-  if (new_size > old_size)\n-    overall_size += new_size - old_size;\n-  ncalls_inlined++;\n-\n-  /* FIXME: We should remove the optimize check after we ensure we never run\n-     IPA passes when not optimizing.  */\n-  if (flag_indirect_inlining && optimize)\n-    return ipa_propagate_indirect_call_infos (curr, new_edges);\n-  else\n-    return false;\n-}\n-\n /* Return false when inlining edge E would lead to violating\n    limits on function unit growth or stack usage growth.  \n \n@@ -1196,11 +1030,11 @@ recursive_inlining (struct cgraph_edge *edge,\n \t\t\t\t\t    false, NULL);\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n \t    if (!e->inline_failed)\n-\t      cgraph_clone_inlined_nodes (e, true, false);\n+\t      clone_inlined_nodes (e, true, false, NULL);\n \t}\n \n       cgraph_redirect_edge_callee (curr, master_clone);\n-      cgraph_mark_inline_edge (curr, false, new_edges);\n+      inline_call (curr, false, new_edges, &overall_size);\n       lookup_recursive_calls (node, curr->callee, heap);\n       n++;\n     }\n@@ -1460,7 +1294,7 @@ inline_small_functions (void)\n \n \t  callee = edge->callee;\n \t  gcc_checking_assert (!callee->global.inlined_to);\n-\t  cgraph_mark_inline_edge (edge, true, &new_indirect_edges);\n+\t  inline_call (edge, true, &new_indirect_edges, &overall_size);\n \t  if (flag_indirect_inlining)\n \t    add_new_edges_to_heap (heap, new_indirect_edges);\n \n@@ -1588,7 +1422,7 @@ flatten_function (struct cgraph_node *node)\n \t\t cgraph_node_name (e->callee),\n \t\t cgraph_node_name (e->caller));\n       orig_callee = e->callee;\n-      cgraph_mark_inline_edge (e, true, NULL);\n+      inline_call (e, true, NULL, NULL);\n       if (e->callee != orig_callee)\n \torig_callee->aux = (void *) node;\n       flatten_function (e->callee);\n@@ -1697,7 +1531,7 @@ ipa_inline (void)\n \t\t\t       inline_summary (node->callers->caller)->size);\n \t\t    }\n \n-\t\t  cgraph_mark_inline_edge (node->callers, true, NULL);\n+\t\t  inline_call (node->callers, true, NULL, NULL);\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \" Inlined into %s which now has %i size\\n\",\n@@ -1752,7 +1586,7 @@ inline_always_inline_functions (struct cgraph_node *node)\n \tfprintf (dump_file, \"  Inlining %s into %s (always_inline).\\n\",\n \t\t cgraph_node_name (e->callee),\n \t\t cgraph_node_name (e->caller));\n-      cgraph_mark_inline_edge (e, true, NULL);\n+      inline_call (e, true, NULL, NULL);\n       inlined = true;\n     }\n \n@@ -1801,7 +1635,7 @@ early_inline_small_functions (struct cgraph_node *node)\n \tfprintf (dump_file, \" Inlining %s into %s.\\n\",\n \t\t cgraph_node_name (e->callee),\n \t\t cgraph_node_name (e->caller));\n-      cgraph_mark_inline_edge (e, true, NULL);\n+      inline_call (e, true, NULL, NULL);\n       inlined = true;\n     }\n \n@@ -1916,42 +1750,6 @@ struct gimple_opt_pass pass_early_inline =\n };\n \n \n-/* Apply inline plan to function.  */\n-static unsigned int\n-inline_transform (struct cgraph_node *node)\n-{\n-  unsigned int todo = 0;\n-  struct cgraph_edge *e;\n-  bool inline_p = false;\n-\n-  /* FIXME: Currently the pass manager is adding inline transform more than\n-     once to some clones.  This needs revisiting after WPA cleanups.  */\n-  if (cfun->after_inlining)\n-    return 0;\n-\n-  /* We might need the body of this function so that we can expand\n-     it inline somewhere else.  */\n-  if (cgraph_preserve_function_body_p (node->decl))\n-    save_inline_function_body (node);\n-\n-  for (e = node->callees; e; e = e->next_callee)\n-    {\n-      cgraph_redirect_edge_call_stmt_to_callee (e);\n-      if (!e->inline_failed || warn_inline)\n-        inline_p = true;\n-    }\n-\n-  if (inline_p)\n-    {\n-      timevar_push (TV_INTEGRATION);\n-      todo = optimize_inline_calls (current_function_decl);\n-      timevar_pop (TV_INTEGRATION);\n-    }\n-  cfun->always_inline_functions_inlined = true;\n-  cfun->after_inlining = true;\n-  return todo | execute_fixup_cfg ();\n-}\n-\n /* When to run IPA inlining.  Inlining of always-inline functions\n    happens during early inlining.  */\n "}, {"sha": "48415e6eea2e2953dc3770b6c25332fb8dbf1df0", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fee8b6dadd3847d6cdc5e48a467be48ce16fd71e/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=fee8b6dadd3847d6cdc5e48a467be48ce16fd71e", "patch": "@@ -63,6 +63,7 @@ DEF_VEC_O(inline_summary_t);\n DEF_VEC_ALLOC_O(inline_summary_t,heap);\n extern VEC(inline_summary_t,heap) *inline_summary_vec;\n \n+/* In ipa-inline-analysis.c  */\n void debug_inline_summary (struct cgraph_node *);\n void dump_inline_summaries (FILE *f);\n void inline_generate_summary (void);\n@@ -74,6 +75,14 @@ int estimate_time_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_growth (struct cgraph_node *);\n \n+/* In ipa-inline-transform.c  */\n+bool inline_call (struct cgraph_edge *, bool, VEC (cgraph_edge_p, heap) **, int *);\n+unsigned int inline_transform (struct cgraph_node *);\n+void clone_inlined_nodes (struct cgraph_edge *e, bool, bool, int *);\n+\n+extern int ncalls_inlined;\n+extern int nfunctions_inlined;\n+\n static inline struct inline_summary *\n inline_summary (struct cgraph_node *node)\n {"}]}