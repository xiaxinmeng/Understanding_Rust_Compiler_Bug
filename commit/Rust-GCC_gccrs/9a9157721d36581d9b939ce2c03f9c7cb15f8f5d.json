{"sha": "9a9157721d36581d9b939ce2c03f9c7cb15f8f5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE5MTU3NzIxZDM2NTgxZDliOTM5Y2UyYzAzZjljN2NiMTVmOGY1ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-11T23:10:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-11T23:10:30Z"}, "message": "i386.c (ix86_comparison_operator, [...]): Convert fp comparison codes to integer before handling.\n\n\n\t* i386.c (ix86_comparison_operator, fcmov_comparison_operator,\n\tput_condition_code): Convert fp comparison codes to integer\n\tbefore handling.\n\t(ix86_expand_fp_compare): Postnote the fp comparison code converison\n\tto final.\n\n\t* i386.c (unsigned_comparison, no_comparison_operator): Kill.\n\t* i386-protos.h (no_comparison_operator): Kill.\n\n\t* i386.c (ix86_expand_fp_compare): Fix ordered/unordered confussion.\n\n\t* combine.c (REVERSIBLE_CC_MODE): Remove.\n\t(reversible_comparison_p): Remove.\n\t(combine_reversed_comparison_code): New.\n\t(reversed_comparison): New.\n\t(combine_simplify_rtx): Use\n\tcombine_reversed_comparison_code/reversed_comparison instead\n\tof reversible_comparison_p.\n\t(simplify_if_then_else): Likewise.\n\t(simplify_set): Likewise.\n\t(simplify_logical): Likewise.\n\t(if_then_else_cond): Likewise.\n\t(known_cond): Likewise.\n\t(simplify_comparison): Likewise.\n\nFrom-SVN: r38930", "tree": {"sha": "11507db92bb37bf428cc6b58a4f2ba61d9c406d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11507db92bb37bf428cc6b58a4f2ba61d9c406d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d/comments", "author": null, "committer": null, "parents": [{"sha": "bbc7fda9b0e4596d55e7ae9bc73d918004f6e4f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbc7fda9b0e4596d55e7ae9bc73d918004f6e4f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbc7fda9b0e4596d55e7ae9bc73d918004f6e4f1"}], "stats": {"total": 520, "additions": 239, "deletions": 281}, "files": [{"sha": "a04f1355eb81d99d6c96608de71b0b68610c949f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a9157721d36581d9b939ce2c03f9c7cb15f8f5d", "patch": "@@ -1,3 +1,30 @@\n+Fri Jan 12 00:04:00 MET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_comparison_operator, fcmov_comparison_operator,\n+\tput_condition_code): Convert fp comparison codes to integer\n+\tbefore handling.\n+\t(ix86_expand_fp_compare): Postnote the fp comparison code converison\n+\tto final.\n+\n+\t* i386.c (unsigned_comparison, no_comparison_operator): Kill.\n+\t* i386-protos.h (no_comparison_operator): Kill.\n+\n+\t* i386.c (ix86_expand_fp_compare): Fix ordered/unordered confussion.\n+\n+\t* combine.c (REVERSIBLE_CC_MODE): Remove.\n+\t(reversible_comparison_p): Remove.\n+\t(combine_reversed_comparison_code): New.\n+\t(reversed_comparison): New.\n+\t(combine_simplify_rtx): Use\n+\tcombine_reversed_comparison_code/reversed_comparison instead\n+\tof reversible_comparison_p.\n+\t(simplify_if_then_else): Likewise.\n+\t(simplify_set): Likewise.\n+\t(simplify_logical): Likewise.\n+\t(if_then_else_cond): Likewise.\n+\t(known_cond): Likewise.\n+\t(simplify_comparison): Likewise.\n+\n 2001-01-11  Alan Lehotsky  <lehotsky@tiac.net>\n \n \t* builtins.c (std_expand_builtin_va_start): Handle varargs when"}, {"sha": "53857edbf70a0143b0940075d9ae74ea8d415982", "filename": "gcc/combine.c", "status": "modified", "additions": 86, "deletions": 90, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9a9157721d36581d9b939ce2c03f9c7cb15f8f5d", "patch": "@@ -131,12 +131,6 @@ static int combine_successes;\n \n static int total_attempts, total_merges, total_extras, total_successes;\n \n-/* Define a default value for REVERSIBLE_CC_MODE.\n-   We can never assume that a condition code mode is safe to reverse unless\n-   the md tells us so.  */\n-#ifndef REVERSIBLE_CC_MODE\n-#define REVERSIBLE_CC_MODE(MODE) 0\n-#endif\n \f\n /* Vector mapping INSN_UIDs to cuids.\n    The cuids are like uids but increase monotonically always.\n@@ -414,7 +408,6 @@ static rtx gen_binary\t\tPARAMS ((enum rtx_code, enum machine_mode,\n static rtx gen_unary\t\tPARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t\t enum machine_mode, rtx));\n static enum rtx_code simplify_comparison  PARAMS ((enum rtx_code, rtx *, rtx *));\n-static int reversible_comparison_p  PARAMS ((rtx));\n static void update_table_tick\tPARAMS ((rtx));\n static void record_value_for_reg  PARAMS ((rtx, rtx, rtx));\n static void check_promoted_subreg PARAMS ((rtx, rtx));\n@@ -432,6 +425,8 @@ static void distribute_links\tPARAMS ((rtx));\n static void mark_used_regs_combine PARAMS ((rtx));\n static int insn_cuid\t\tPARAMS ((rtx));\n static void record_promoted_value PARAMS ((rtx, rtx));\n+static rtx reversed_comparison  PARAMS ((rtx, enum machine_mode, rtx, rtx));\n+static enum rtx_code combine_reversed_comparison_code PARAMS ((rtx));\n \f\n /* Substitute NEWVAL, an rtx expression, into INTO, a place in some\n    insn.  The substitution can be undone by undo_all.  If INTO is already\n@@ -3501,6 +3496,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n   rtx temp;\n+  rtx reversed;\n   int i;\n \n   /* If this is a commutative operation, put a constant last and a complex\n@@ -3922,10 +3918,9 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t reversing the comparison code if valid.  */\n       if (STORE_FLAG_VALUE == -1\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && reversible_comparison_p (XEXP (x, 0)))\n-\treturn gen_rtx_combine (reverse_condition (GET_CODE (XEXP (x, 0))),\n-\t\t\t\tmode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\tXEXP (XEXP (x, 0), 1));\n+\t  && (reversed = reversed_comparison (x, mode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t      XEXP (XEXP (x, 0), 1))))\n+\treturn reversed;\n \n       /* (ashiftrt foo C) where C is the number of bits in FOO minus 1\n \t is (lt foo (const_int 0)) if STORE_FLAG_VALUE is -1, so we can\n@@ -4218,14 +4213,13 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t is 1.  This produces better code than the alternative immediately\n \t below.  */\n       if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && reversible_comparison_p (XEXP (x, 0))\n \t  && ((STORE_FLAG_VALUE == -1 && XEXP (x, 1) == const1_rtx)\n-\t      || (STORE_FLAG_VALUE == 1 && XEXP (x, 1) == constm1_rtx)))\n+\t      || (STORE_FLAG_VALUE == 1 && XEXP (x, 1) == constm1_rtx))\n+\t  && (reversed = reversed_comparison (XEXP (x, 0), mode,\n+\t\t\t\t\t      XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t      XEXP (XEXP (x, 0), 1))))\n \treturn\n-\t  gen_unary (NEG, mode, mode,\n-\t\t     gen_binary (reverse_condition (GET_CODE (XEXP (x, 0))),\n-\t\t\t\t mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t XEXP (XEXP (x, 0), 1)));\n+\t  gen_unary (NEG, mode, mode, reversed);\n \n       /* If only the low-order bit of X is possibly nonzero, (plus x -1)\n \t can become (ashiftrt (ashift (xor x 1) C) C) where C is\n@@ -4270,10 +4264,10 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       if (STORE_FLAG_VALUE == 1\n \t  && XEXP (x, 0) == const1_rtx\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<'\n-\t  && reversible_comparison_p (XEXP (x, 1)))\n-\treturn gen_binary (reverse_condition (GET_CODE (XEXP (x, 1))), mode,\n-\t\t\t   XEXP (XEXP (x, 1), 0),\n-\t\t\t   XEXP (XEXP (x, 1), 1));\n+\t  && (reversed = reversed_comparison (XEXP (x, 1), mode,\n+\t\t\t\t\t      XEXP (XEXP (x, 1), 0),\n+\t\t\t\t\t      XEXP (XEXP (x, 1), 1))))\n+\treturn reversed;\n \n       /* (minus <foo> (and <foo> (const_int -pow2))) becomes\n \t (and <foo> (const_int pow2-1))  */\n@@ -4626,27 +4620,31 @@ simplify_if_then_else (x)\n   int comparison_p = GET_RTX_CLASS (true_code) == '<';\n   rtx temp;\n   int i;\n+  enum rtx_code false_code;\n+  rtx reversed;\n \n   /* Simplify storing of the truth value.  */\n   if (comparison_p && true == const_true_rtx && false == const0_rtx)\n     return gen_binary (true_code, mode, XEXP (cond, 0), XEXP (cond, 1));\n \n   /* Also when the truth value has to be reversed.  */\n-  if (comparison_p && reversible_comparison_p (cond)\n-      && true == const0_rtx && false == const_true_rtx)\n-    return gen_binary (reverse_condition (true_code),\n-\t\t       mode, XEXP (cond, 0), XEXP (cond, 1));\n+  if (comparison_p\n+      && true == const0_rtx && false == const_true_rtx\n+      && (reversed = reversed_comparison (cond, mode, XEXP (cond, 0),\n+\t\t\t\t\t  XEXP (cond, 1))))\n+    return reversed;\n \n   /* Sometimes we can simplify the arm of an IF_THEN_ELSE if a register used\n      in it is being compared against certain values.  Get the true and false\n      comparisons and see if that says anything about the value of each arm.  */\n \n-  if (comparison_p && reversible_comparison_p (cond)\n+  if (comparison_p\n+      && ((false_code = combine_reversed_comparison_code (cond))\n+\t  != UNKNOWN)\n       && GET_CODE (XEXP (cond, 0)) == REG)\n     {\n       HOST_WIDE_INT nzb;\n       rtx from = XEXP (cond, 0);\n-      enum rtx_code false_code = reverse_condition (true_code);\n       rtx true_val = XEXP (cond, 1);\n       rtx false_val = true_val;\n       int swapped = 0;\n@@ -4695,7 +4693,8 @@ simplify_if_then_else (x)\n      arm, the false arm is the same as the first operand of the comparison, or\n      the false arm is more complicated than the true arm.  */\n \n-  if (comparison_p && reversible_comparison_p (cond)\n+  if (comparison_p\n+      && combine_reversed_comparison_code (cond) != UNKNOWN\n       && (true == pc_rtx\n \t  || (CONSTANT_P (true)\n \t      && GET_CODE (false) != CONST_INT && false != pc_rtx)\n@@ -4708,10 +4707,10 @@ simplify_if_then_else (x)\n \t  || reg_mentioned_p (true, false)\n \t  || rtx_equal_p (false, XEXP (cond, 0))))\n     {\n-      true_code = reverse_condition (true_code);\n+      true_code = reversed_comparison_code (cond, NULL);\n       SUBST (XEXP (x, 0),\n-\t     gen_binary (true_code, GET_MODE (cond), XEXP (cond, 0),\n-\t\t\t XEXP (cond, 1)));\n+\t     reversed_comparison (cond, GET_MODE (cond), XEXP (cond, 0),\n+\t\t\t\t  XEXP (cond, 1)));\n \n       SUBST (XEXP (x, 1), false);\n       SUBST (XEXP (x, 2), true);\n@@ -5211,6 +5210,7 @@ simplify_set (x)\n       rtx cond = XEXP (src, 0);\n       rtx true_val = const1_rtx;\n       rtx false_arm, true_arm;\n+      rtx reversed;\n \n       if (GET_CODE (cond) == MULT)\n \t{\n@@ -5236,16 +5236,16 @@ simplify_set (x)\n       /* Canonicalize if true_arm is the simpler one.  */\n       if (GET_RTX_CLASS (GET_CODE (true_arm)) == 'o'\n \t  && GET_RTX_CLASS (GET_CODE (false_arm)) != 'o'\n-\t  && reversible_comparison_p (cond))\n+\t  && (reversed = reversed_comparison_code (cond, GET_MODE (cond),\n+\t\t\t\t\t\t   XEXP (cond, 0),\n+\t\t\t\t\t\t   XEXP (cond, 1))))\n \t{\n \t  rtx temp = true_arm;\n \n \t  true_arm = false_arm;\n \t  false_arm = temp;\n \n-\t  cond = gen_rtx_combine (reverse_condition (GET_CODE (cond)),\n-\t\t\t\t  GET_MODE (cond), XEXP (cond, 0),\n-\t\t\t\t  XEXP (cond, 1));\n+\t  cond = reversed;\n \t}\n \n       src = gen_rtx_combine (IF_THEN_ELSE, GET_MODE (src),\n@@ -5279,6 +5279,7 @@ simplify_logical (x, last)\n   enum machine_mode mode = GET_MODE (x);\n   rtx op0 = XEXP (x, 0);\n   rtx op1 = XEXP (x, 1);\n+  rtx reversed;\n \n   switch (GET_CODE (x))\n     {\n@@ -5530,9 +5531,9 @@ simplify_logical (x, last)\n       if (STORE_FLAG_VALUE == 1\n \t  && op1 == const1_rtx\n \t  && GET_RTX_CLASS (GET_CODE (op0)) == '<'\n-\t  && reversible_comparison_p (op0))\n-\treturn gen_rtx_combine (reverse_condition (GET_CODE (op0)),\n-\t\t\t\tmode, XEXP (op0, 0), XEXP (op0, 1));\n+\t  && (reversed = reversed_comparison (op0, mode, XEXP (op0, 0),\n+\t\t\t\t\t      XEXP (op0, 1))))\n+\treturn reversed;\n \n       /* (lshiftrt foo C) where C is the number of bits in FOO minus 1\n \t is (lt foo (const_int 0)), so we can perform the above\n@@ -5552,9 +5553,9 @@ simplify_logical (x, last)\n \t      == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n \t  && op1 == const_true_rtx\n \t  && GET_RTX_CLASS (GET_CODE (op0)) == '<'\n-\t  && reversible_comparison_p (op0))\n-\treturn gen_rtx_combine (reverse_condition (GET_CODE (op0)),\n-\t\t\t\tmode, XEXP (op0, 0), XEXP (op0, 1));\n+\t  && (reversed = reversed_comparison (op0, mode, XEXP (op0, 0),\n+\t\t\t\t\t      XEXP (op0, 1))))\n+\treturn reversed;\n \n       break;\n \n@@ -7344,12 +7345,11 @@ if_then_else_cond (x, ptrue, pfalse)\n \n \t  if (GET_RTX_CLASS (GET_CODE (cond0)) == '<'\n \t      && GET_RTX_CLASS (GET_CODE (cond1)) == '<'\n-\t      && reversible_comparison_p (cond1)\n-\t      && ((GET_CODE (cond0) == reverse_condition (GET_CODE (cond1))\n+\t      && ((GET_CODE (cond0) == combine_reversed_comparison_code (cond1)\n \t\t   && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 0))\n \t\t   && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 1)))\n \t\t  || ((swap_condition (GET_CODE (cond0))\n-\t\t       == reverse_condition (GET_CODE (cond1)))\n+\t\t       == combine_reversed_comparison_code (cond1))\n \t\t      && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 1))\n \t\t      && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 0))))\n \t      && ! side_effects_p (x))\n@@ -7374,12 +7374,11 @@ if_then_else_cond (x, ptrue, pfalse)\n \n \t  if (GET_RTX_CLASS (GET_CODE (cond0)) == '<'\n \t      && GET_RTX_CLASS (GET_CODE (cond1)) == '<'\n-\t      && reversible_comparison_p (cond1)\n-\t      && ((GET_CODE (cond0) == reverse_condition (GET_CODE (cond1))\n+\t      && ((GET_CODE (cond0) == combine_reversed_comparison_code (cond1)\n \t\t   && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 0))\n \t\t   && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 1)))\n \t\t  || ((swap_condition (GET_CODE (cond0))\n-\t\t       == reverse_condition (GET_CODE (cond1)))\n+\t\t       == combine_reversed_comparison_code (cond1))\n \t\t      && rtx_equal_p (XEXP (cond0, 0), XEXP (cond1, 1))\n \t\t      && rtx_equal_p (XEXP (cond0, 1), XEXP (cond1, 0))))\n \t      && ! side_effects_p (x))\n@@ -7527,7 +7526,7 @@ known_cond (x, cond, reg, val)\n \t      if (comparison_dominates_p (cond, code))\n \t\treturn const_true_rtx;\n \n-\t      code = reverse_condition (code);\n+\t      code = combine_reversed_comparison_code (x);\n \t      if (code != UNKNOWN\n \t\t  && comparison_dominates_p (cond, code))\n \t\treturn const0_rtx;\n@@ -10705,20 +10704,21 @@ simplify_comparison (code, pop0, pop1)\n \n \t  /* Check for the cases where we simply want the result of the\n \t     earlier test or the opposite of that result.  */\n-\t  if (code == NE\n-\t      || (code == EQ && reversible_comparison_p (op0))\n+\t  if (code == NE || code == EQ\n \t      || (GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n \t\t  && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n \t\t  && (STORE_FLAG_VALUE\n \t\t      & (((HOST_WIDE_INT) 1\n \t\t\t  << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1))))\n-\t\t  && (code == LT\n-\t\t      || (code == GE && reversible_comparison_p (op0)))))\n+\t\t  && (code == LT || (code == GE))))\n \t    {\n \t      code = (code == LT || code == NE\n-\t\t      ? GET_CODE (op0) : reverse_condition (GET_CODE (op0)));\n-\t      op0 = tem, op1 = tem1;\n-\t      continue;\n+\t\t      ? GET_CODE (op0) : combine_reversed_comparison_code (op0));\n+\t      if (code != UNKNOWN)\n+\t\t{\n+\t\t  op0 = tem, op1 = tem1;\n+\t\t  continue;\n+\t\t}\n \t    }\n \t  break;\n \n@@ -11121,42 +11121,38 @@ simplify_comparison (code, pop0, pop1)\n   return code;\n }\n \f\n-/* Return 1 if we know that X, a comparison operation, is not operating\n-   on a floating-point value or is EQ or NE, meaning that we can safely\n-   reverse it.  */\n-\n-static int\n-reversible_comparison_p (x)\n-     rtx x;\n+/* Like jump.c' reversed_comparison_code, but use combine infrastructure for\n+   searching backward.  */\n+enum rtx_code\n+combine_reversed_comparison_code (exp)\n+     rtx exp;\n {\n-  if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-      || flag_fast_math\n-      || GET_CODE (x) == NE || GET_CODE (x) == EQ\n-      || GET_CODE (x) == UNORDERED || GET_CODE (x) == ORDERED)\n-    return 1;\n-\n-  switch (GET_MODE_CLASS (GET_MODE (XEXP (x, 0))))\n-    {\n-    case MODE_INT:\n-    case MODE_PARTIAL_INT:\n-    case MODE_COMPLEX_INT:\n-      return 1;\n-\n-    case MODE_CC:\n-      /* If the mode of the condition codes tells us that this is safe,\n-\t we need look no further.  */\n-      if (REVERSIBLE_CC_MODE (GET_MODE (XEXP (x, 0))))\n-\treturn 1;\n-\n-      /* Otherwise try and find where the condition codes were last set and\n-\t use that.  */\n-      x = get_last_value (XEXP (x, 0));\n-      return (x && GET_CODE (x) == COMPARE\n-\t      && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0))));\n-\n-    default:\n-      return 0;\n-    }\n+   enum rtx_code code1 = reversed_comparison_code (exp, NULL);\n+   rtx x;\n+\n+   if (code1 != UNKNOWN\n+       || GET_MODE_CLASS (GET_MODE (XEXP (exp, 0))) != MODE_CC)\n+     return code1;\n+   /* Otherwise try and find where the condition codes were last set and\n+      use that.  */\n+   x = get_last_value (XEXP (x, 0));\n+   if (GET_CODE (x) != COMPARE)\n+     return UNKNOWN;\n+   return reversed_comparison_code_parts (GET_CODE (exp),\n+\t\t\t\t\t  XEXP (x, 0), XEXP (x, 1), NULL);\n+}\n+/* Return comparison with reversed code of EXP and operands OP0 and OP1.\n+   Return NULL_RTX in case we fail to do the reversal.  */\n+static rtx\n+reversed_comparison (exp, mode, op0, op1)\n+     rtx exp, op0, op1;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code reversed_code = combine_reversed_comparison_code (exp);\n+  if (reversed_code == UNKNOWN)\n+    return NULL_RTX;\n+  else\n+    return gen_binary (reversed_code, mode, op0, op1);\n }\n \f\n /* Utility function for following routine.  Called when X is part of a value"}, {"sha": "42481fba1f30a696ce53cf81cc156b4cad25e307", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=9a9157721d36581d9b939ce2c03f9c7cb15f8f5d", "patch": "@@ -56,7 +56,6 @@ extern int general_no_elim_operand PARAMS ((rtx, enum machine_mode));\n extern int nonmemory_no_elim_operand PARAMS ((rtx, enum machine_mode));\n extern int q_regs_operand PARAMS ((rtx, enum machine_mode));\n extern int non_q_regs_operand PARAMS ((rtx, enum machine_mode));\n-extern int no_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int sse_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int fcmov_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int cmp_fp_expander_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "50ac27b3f1ecd757a7d56fc4b4e64e256b0ca4be", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 126, "deletions": 190, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a9157721d36581d9b939ce2c03f9c7cb15f8f5d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=9a9157721d36581d9b939ce2c03f9c7cb15f8f5d", "patch": "@@ -386,7 +386,6 @@ int ix86_align_jumps;\n static void output_pic_addr_const PARAMS ((FILE *, rtx, int));\n static void put_condition_code PARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t       int, int, FILE *));\n-static enum rtx_code unsigned_comparison PARAMS ((enum rtx_code code));\n static rtx ix86_expand_int_compare PARAMS ((enum rtx_code, rtx, rtx));\n static enum rtx_code ix86_prepare_fp_compare_args PARAMS ((enum rtx_code,\n \t\t\t\t\t\t\t   rtx *, rtx *));\n@@ -1267,30 +1266,6 @@ non_q_regs_operand (op, mode)\n   return NON_QI_REG_P (op);\n }\n \n-/* Return 1 if OP is a comparison operator that can use the condition code\n-   generated by a logical operation, which characteristicly does not set\n-   overflow or carry.  To be used with CCNOmode.  */\n-\n-int\n-no_comparison_operator (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return 0;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case EQ: case NE:\n-    case LT: case GE:\n-    case LEU: case LTU: case GEU: case GTU:\n-      return 1;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n /* Return 1 if OP is a comparison that can be used in the CMPSS/CMPPS\n    insns.  */\n int\n@@ -1308,25 +1283,33 @@ ix86_comparison_operator (op, mode)\n      enum machine_mode mode;\n {\n   enum machine_mode inmode;\n+  enum rtx_code code = GET_CODE (op);\n   if (mode != VOIDmode && GET_MODE (op) != mode)\n     return 0;\n-  switch (GET_CODE (op))\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+  inmode = GET_MODE (XEXP (op, 0));\n+\n+  if (inmode == CCFPmode || inmode == CCFPUmode)\n+    {\n+      enum rtx_code second_code, bypass_code;\n+      ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n+      return (bypass_code == NIL && second_code == NIL);\n+    }\n+  switch (code)\n     {\n     case EQ: case NE:\n       return 1;\n     case LT: case GE:\n-      inmode = GET_MODE (XEXP (op, 0));\n       if (inmode == CCmode || inmode == CCGCmode\n \t  || inmode == CCGOCmode || inmode == CCNOmode)\n \treturn 1;\n       return 0;\n     case LTU: case GTU: case LEU: case ORDERED: case UNORDERED: case GEU:\n-      inmode = GET_MODE (XEXP (op, 0));\n       if (inmode == CCmode)\n \treturn 1;\n       return 0;\n     case GT: case LE:\n-      inmode = GET_MODE (XEXP (op, 0));\n       if (inmode == CCmode || inmode == CCGCmode || inmode == CCNOmode)\n \treturn 1;\n       return 0;\n@@ -1343,16 +1326,30 @@ fcmov_comparison_operator (op, mode)\n     enum machine_mode mode;\n {\n   enum machine_mode inmode = GET_MODE (XEXP (op, 0));\n+  enum rtx_code code = GET_CODE (op);\n   if (mode != VOIDmode && GET_MODE (op) != mode)\n     return 0;\n-  switch (GET_CODE (op))\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+  inmode = GET_MODE (XEXP (op, 0));\n+  if (inmode == CCFPmode || inmode == CCFPUmode)\n     {\n-    case EQ: case NE:\n-      return 1;\n-    case LTU: case GTU: case LEU: case ORDERED: case UNORDERED: case GEU:\n-      if (inmode == CCFPmode || inmode == CCFPUmode)\n+      enum rtx_code second_code, bypass_code;\n+      ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n+      if (bypass_code != NIL || second_code != NIL)\n+\treturn 0;\n+      code = ix86_fp_compare_code_to_integer (code);\n+    }\n+  /* i387 supports just limited amount of conditional codes.  */\n+  switch (code)\n+    {\n+    case LTU: case GTU: case LEU: case GEU:\n+      if (inmode == CCmode || inmode == CCFPmode || inmode == CCFPUmode)\n \treturn 1;\n       return 0;\n+    case ORDERED: case UNORDERED:\n+    case EQ: case NE:\n+      return 1;\n     default:\n       return 0;\n     }\n@@ -3102,6 +3099,15 @@ put_condition_code (code, mode, reverse, fp, file)\n {\n   const char *suffix;\n \n+  if (mode == CCFPmode || mode == CCFPUmode)\n+    {\n+      enum rtx_code second_code, bypass_code;\n+      ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n+      if (bypass_code != NIL || second_code != NIL)\n+\tabort();\n+      code = ix86_fp_compare_code_to_integer (code);\n+      mode = CCmode;\n+    }\n   if (reverse)\n     code = reverse_condition (code);\n \n@@ -4611,41 +4617,6 @@ ix86_match_ccmode (insn, req_mode)\n   return (GET_MODE (SET_SRC (set)) == set_mode);\n }\n \n-/* Produce an unsigned comparison for a given signed comparison.  */\n-\n-static enum rtx_code\n-unsigned_comparison (code)\n-     enum rtx_code code;\n-{\n-  switch (code)\n-    {\n-    case GT:\n-      code = GTU;\n-      break;\n-    case LT:\n-      code = LTU;\n-      break;\n-    case GE:\n-      code = GEU;\n-      break;\n-    case LE:\n-      code = LEU;\n-      break;\n-    case EQ:\n-    case NE:\n-    case LEU:\n-    case LTU:\n-    case GEU:\n-    case GTU:\n-    case UNORDERED:\n-    case ORDERED:\n-      break;\n-    default:\n-      abort ();\n-    }\n-  return code;\n-}\n-\n /* Generate insn patterns to do an integer compare of OPERANDS.  */\n \n static rtx\n@@ -4960,8 +4931,7 @@ ix86_expand_fp_compare (code, op0, op1, scratch)\n \t}\n \n       /* The FP codes work out to act like unsigned.  */\n-      code = ix86_fp_compare_code_to_integer (first_code);\n-      intcmp_mode = CCmode;\n+      intcmp_mode = fpcmp_mode;\n     }\n   else\n     {\n@@ -4970,153 +4940,119 @@ ix86_expand_fp_compare (code, op0, op1, scratch)\n       tmp2 = gen_rtx_UNSPEC (HImode, gen_rtvec (1, tmp), 9);\n       emit_insn (gen_rtx_SET (VOIDmode, scratch, tmp2));\n \n-      if (fpcmp_mode == CCFPmode\n-\t  || code == ORDERED\n-\t  || code == UNORDERED)\n-\t{\n-\t  /* We have two options here -- use sahf, or testing bits of ah\n-\t     directly.  On PPRO, they are equivalent, sahf being one byte\n-\t     smaller.  On Pentium, sahf is non-pairable while test is UV\n-\t     pairable.  */\n-\n-\t  /*\n-\t   * The numbers below correspond to the bits of the FPSW in AH.\n-\t   * C3, C2, and C0 are in bits 0x40, 0x4, and 0x01 respectively.\n-\t   *\n-\t   *    cmp    C3 C2 C0\n-\t   *    >      0  0  0\n-\t   *    <      0  0  1\n-\t   *    =      1  0  0\n-\t   *    un     1  1  1\n-\t   */\n-\n-\t  int mask;\n+      /* In the unordered case, we have to check C2 for NaN's, which\n+\t doesn't happen to work out to anything nice combination-wise.\n+\t So do some bit twiddling on the value we've got in AH to come\n+\t up with an appropriate set of condition codes.  */\n \n-\t  switch (code)\n-\t    {\n-\t    case GT:\n-\t      mask = 0x41;\n-\t      code = EQ;\n-\t      break;\n-\t    case LT:\n-\t      mask = 0x01;\n-\t      code = NE;\n-\t      break;\n-\t    case GE:\n-\t      /* We'd have to use `xorb 1,ah; andb 0x41,ah', so it's\n-\t\t faster in all cases to just fall back on sahf.  */\n-\t      goto do_sahf;\n-\t    case LE:\n-\t      mask = 0x41;\n-\t      code = NE;\n-\t      break;\n-\t    case EQ:\n-\t      mask = 0x40;\n-\t      code = NE;\n-\t      break;\n-\t    case NE:\n-\t      mask = 0x40;\n-\t      code = EQ;\n-\t      break;\n-\t    case UNORDERED:\n-\t      mask = 0x04;\n-\t      code = NE;\n-\t      break;\n-\t    case ORDERED:\n-\t      mask = 0x04;\n-\t      code = EQ;\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n-\t    }\n-\n-\t  emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (mask)));\n-\t  intcmp_mode = CCNOmode;\n-\t}\n-      else\n+      intcmp_mode = CCNOmode;\n+      switch (code)\n \t{\n-\t  /* In the unordered case, we have to check C2 for NaN's, which\n-\t     doesn't happen to work out to anything nice combination-wise.\n-\t     So do some bit twiddling on the value we've got in AH to come\n-\t     up with an appropriate set of condition codes.  */\n-\n-\t  intcmp_mode = CCNOmode;\n-\t  switch (code)\n+\tcase GT:\n+\tcase UNGT:\n+\t  if (code == GT || !TARGET_IEEE_FP)\n \t    {\n-\t    case GT:\n \t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x45)));\n \t      code = EQ;\n-\t      break;\n-\t    case LT:\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_addqi_ext_1 (scratch, scratch, constm1_rtx));\n+\t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x44)));\n+\t      intcmp_mode = CCmode;\n+\t      code = GEU;\n+\t    }\n+\t  break;\n+\tcase LT:\n+\tcase UNLT:\n+\t  if (code == LT && TARGET_IEEE_FP)\n+\t    {\n \t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n \t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x01)));\n \t      intcmp_mode = CCmode;\n \t      code = EQ;\n-\t      break;\n-\t    case GE:\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x01)));\n+\t      code = NE;\n+\t    }\n+\t  break;\n+\tcase GE:\n+\tcase UNGE:\n+\t  if (code == GE || !TARGET_IEEE_FP)\n+\t    {\n \t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x05)));\n \t      code = EQ;\n-\t      break;\n-\t    case LE:\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n+\t      emit_insn (gen_xorqi_cc_ext_1 (scratch, scratch,\n+\t\t\t\t\t     GEN_INT (0x01)));\n+\t      code = NE;\n+\t    }\n+\t  break;\n+\tcase LE:\n+\tcase UNLE:\n+\t  if (code == LE && TARGET_IEEE_FP)\n+\t    {\n \t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n \t      emit_insn (gen_addqi_ext_1 (scratch, scratch, constm1_rtx));\n \t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x40)));\n \t      intcmp_mode = CCmode;\n \t      code = LTU;\n-\t      break;\n-\t    case EQ:\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x45)));\n+\t      code = NE;\n+\t    }\n+\t  break;\n+\tcase EQ:\n+\tcase UNEQ:\n+\t  if (code == EQ && TARGET_IEEE_FP)\n+\t    {\n \t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n \t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x40)));\n \t      intcmp_mode = CCmode;\n \t      code = EQ;\n-\t      break;\n-\t    case NE:\n-\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n-\t      emit_insn (gen_xorqi_cc_ext_1 (scratch, scratch, GEN_INT (0x40)));\n-\t      code = NE;\n-\t      break;\n-\n-\t    case UNORDERED:\n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x04)));\n-\t      code = NE;\n-\t      break;\n-\t    case ORDERED:\n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x04)));\n-\t      code = EQ;\n-\t      break;\n-\t    case UNEQ:\n+\t    }\n+\t  else\n+\t    {\n \t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x40)));\n \t      code = NE;\n \t      break;\n-\t    case UNGE:\n+\t    }\n+\t  break;\n+\tcase NE:\n+\tcase LTGT:\n+\t  if (code == NE && TARGET_IEEE_FP)\n+\t    {\n \t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n-\t      emit_insn (gen_xorqi_cc_ext_1 (scratch, scratch, GEN_INT (0x01)));\n+\t      emit_insn (gen_xorqi_cc_ext_1 (scratch, scratch,\n+\t\t\t\t\t     GEN_INT (0x40)));\n \t      code = NE;\n-\t      break;\n-\t    case UNGT:\n-\t      emit_insn (gen_andqi_ext_0 (scratch, scratch, GEN_INT (0x45)));\n-\t      emit_insn (gen_addqi_ext_1 (scratch, scratch, constm1_rtx));\n-\t      emit_insn (gen_cmpqi_ext_3 (scratch, GEN_INT (0x44)));\n-\t      intcmp_mode = CCmode;\n-\t      code = GEU;\n-\t      break;\n-\t    case UNLE:\n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x45)));\n-\t      code = NE;\n-\t      break;\n-\t    case UNLT:\n-\t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x01)));\n-\t      code = NE;\n-\t      break;\n-\t    case LTGT:\n+\t    }\n+\t  else\n+\t    {\n \t      emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x40)));\n \t      code = EQ;\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n \t    }\n+\t  break;\n+\n+\tcase UNORDERED:\n+\t  emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x04)));\n+\t  code = NE;\n+\t  break;\n+\tcase ORDERED:\n+\t  emit_insn (gen_testqi_ext_ccno_0 (scratch, GEN_INT (0x04)));\n+\t  code = EQ;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n \t}\n     }\n "}]}