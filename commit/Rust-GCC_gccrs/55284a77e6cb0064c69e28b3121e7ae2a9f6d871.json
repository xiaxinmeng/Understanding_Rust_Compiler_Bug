{"sha": "55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUyODRhNzdlNmNiMDA2NGM2OWUyOGIzMTIxZTdhZTJhOWY2ZDg3MQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2016-04-24T20:58:02Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-04-24T20:58:02Z"}, "message": "i386-protos.h (standard_sse_constant_p): Add machine_mode argument.\n\n\t* config/i386/i386-protos.h (standard_sse_constant_p): Add\n\tmachine_mode argument.\n\t* config/i386/i386.c (standard_sse_constant_p): Return 2 for\n\tconstm1_rtx operands.  For VOIDmode constants, get mode from\n\tpred_mode.  Check mode size if the mode is supported by ABI.\n\t(standard_sse_constant_opcode): Do not use standard_constant_p.\n\tStrictly check ABI support for all-ones operands.\n\t(ix86_legitimate_constant_p): Handle TImode, OImode and XImode\n\timmediates. Update calls to standard_sse_constant_p.\n\t(ix86_expand_vector_move): Update calls to standard_sse_constant_p.\n\t(ix86_rtx_costs): Ditto.\n\t* config/i386/i386.md (*movxi_internal_avx512f): Use\n\tnonimmediate_or_sse_const_operand instead of vector_move_operand.\n\tUse (v,BC) alternative instead of (v,C). Use register_operand\n\tchecks instead of MEM_P.\n\t(*movoi_internal_avx): Use nonimmediate_or_sse_const_operand instead\n\tof vector_move_operand.  Add (v,BC) alternative and corresponding avx2\n\tisa attribute.  Use register_operand checks instead of MEM_P.\n\t(*movti_internal): Use nonimmediate_or_sse_const_operand for\n\tTARGET_SSE.  Improve TARGET_SSE insn constraint.  Add (v,BC)\n\talternative and corresponding sse2 isa attribute.\n\t(*movtf_internal, *movdf_internal, *movsf_interal): Update calls\n\tto standard_sse_constant_p.\n\t(FP constant splitters): Ditto.\n\t* config/i386/constraints.md (BC): Do not use standard_sse_constant_p.\n\t(C): Ditto.\n\t* config/i386/predicates.md (constm1_operand): Remove.\n\t(nonimmediate_or_sse_const_operand): Rewrite using RTX.\n\t* config/i386/sse.md (*<avx512>_cvtmask2<ssemodesuffix><mode>): Use\n\tvector_all_ones_operand instead of constm1_operand.\n\n\nCo-Authored-By: H.J. Lu <hongjiu.lu@intel.com>\n\nFrom-SVN: r235396", "tree": {"sha": "f2b87899a19898a4774cab674e5417030b44ffc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2b87899a19898a4774cab674e5417030b44ffc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a635cdb2cc8079c72ffece4f5614244cf78b10a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a635cdb2cc8079c72ffece4f5614244cf78b10a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a635cdb2cc8079c72ffece4f5614244cf78b10a2"}], "stats": {"total": 287, "additions": 185, "deletions": 102}, "files": [{"sha": "2ef411c6d08c4bf2d8da2c1c66c208af4937a2bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "patch": "@@ -1,3 +1,37 @@\n+2016-04-24  Uros Bizjak  <ubizjak@gmail.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/i386-protos.h (standard_sse_constant_p): Add\n+\tmachine_mode argument.\n+\t* config/i386/i386.c (standard_sse_constant_p): Return 2 for\n+\tconstm1_rtx operands.  For VOIDmode constants, get mode from\n+\tpred_mode.  Check mode size if the mode is supported by ABI.\n+\t(standard_sse_constant_opcode): Do not use standard_constant_p.\n+\tStrictly check ABI support for all-ones operands.\n+\t(ix86_legitimate_constant_p): Handle TImode, OImode and XImode\n+\timmediates. Update calls to standard_sse_constant_p.\n+\t(ix86_expand_vector_move): Update calls to standard_sse_constant_p.\n+\t(ix86_rtx_costs): Ditto.\n+\t* config/i386/i386.md (*movxi_internal_avx512f): Use\n+\tnonimmediate_or_sse_const_operand instead of vector_move_operand.\n+\tUse (v,BC) alternative instead of (v,C). Use register_operand\n+\tchecks instead of MEM_P.\n+\t(*movoi_internal_avx): Use nonimmediate_or_sse_const_operand instead\n+\tof vector_move_operand.  Add (v,BC) alternative and corresponding avx2\n+\tisa attribute.  Use register_operand checks instead of MEM_P.\n+\t(*movti_internal): Use nonimmediate_or_sse_const_operand for\n+\tTARGET_SSE.  Improve TARGET_SSE insn constraint.  Add (v,BC)\n+\talternative and corresponding sse2 isa attribute.\n+\t(*movtf_internal, *movdf_internal, *movsf_interal): Update calls\n+\tto standard_sse_constant_p.\n+\t(FP constant splitters): Ditto.\n+\t* config/i386/constraints.md (BC): Do not use standard_sse_constant_p.\n+\t(C): Ditto.\n+\t* config/i386/predicates.md (constm1_operand): Remove.\n+\t(nonimmediate_or_sse_const_operand): Rewrite using RTX.\n+\t* config/i386/sse.md (*<avx512>_cvtmask2<ssemodesuffix><mode>): Use\n+\tvector_all_ones_operand instead of constm1_operand.\n+\n 2016-04-24  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* print-rtl.c (print_rtx_insn_vec): New function."}, {"sha": "fb9ead45cf5ef4469e9a66acffa697941aecbabb", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "patch": "@@ -186,7 +186,10 @@\n \n (define_constraint \"BC\"\n   \"@internal SSE constant operand.\"\n-  (match_test \"standard_sse_constant_p (op)\"))\n+  (and (match_test \"TARGET_SSE\")\n+       (ior (match_test \"op == const0_rtx || op == constm1_rtx\")\n+\t    (match_operand 0 \"const0_operand\")\n+\t    (match_operand 0 \"vector_all_ones_operand\"))))\n \n ;; Integer constant constraints.\n (define_constraint \"I\"\n@@ -239,7 +242,9 @@\n ;; This can theoretically be any mode's CONST0_RTX.\n (define_constraint \"C\"\n   \"SSE constant zero operand.\"\n-  (match_test \"standard_sse_constant_p (op) == 1\"))\n+  (and (match_test \"TARGET_SSE\")\n+       (ior (match_test \"op == const0_rtx\")\n+\t    (match_operand 0 \"const0_operand\"))))\n \n ;; Constant-or-symbol-reference constraints.\n "}, {"sha": "93b5e1ed613cedca33cc012a553b87a232a2d182", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "patch": "@@ -50,7 +50,7 @@ extern bool ix86_using_red_zone (void);\n extern int standard_80387_constant_p (rtx);\n extern const char *standard_80387_constant_opcode (rtx);\n extern rtx standard_80387_constant_rtx (int);\n-extern int standard_sse_constant_p (rtx);\n+extern int standard_sse_constant_p (rtx, machine_mode);\n extern const char *standard_sse_constant_opcode (rtx_insn *, rtx);\n extern bool symbolic_reference_mentioned_p (rtx);\n extern bool extended_reg_mentioned_p (rtx);"}, {"sha": "a061b2f1a6efa297698b8ae85050e7692795ba39", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 107, "deletions": 59, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "patch": "@@ -10762,45 +10762,49 @@ standard_80387_constant_rtx (int idx)\n \t\t\t\t       XFmode);\n }\n \n-/* Return 1 if X is all 0s and 2 if x is all 1s\n+/* Return 1 if X is all bits 0 and 2 if X is all bits 1\n    in supported SSE/AVX vector mode.  */\n \n int\n-standard_sse_constant_p (rtx x)\n+standard_sse_constant_p (rtx x, machine_mode pred_mode)\n {\n   machine_mode mode;\n \n   if (!TARGET_SSE)\n     return 0;\n \n   mode = GET_MODE (x);\n-  \n-  if (x == const0_rtx || x == CONST0_RTX (mode))\n+\n+  if (x == const0_rtx || const0_operand (x, mode))\n     return 1;\n-  if (vector_all_ones_operand (x, mode))\n-    switch (mode)\n-      {\n-      case V16QImode:\n-      case V8HImode:\n-      case V4SImode:\n-      case V2DImode:\n-\tif (TARGET_SSE2)\n-\t  return 2;\n-      case V32QImode:\n-      case V16HImode:\n-      case V8SImode:\n-      case V4DImode:\n-\tif (TARGET_AVX2)\n-\t  return 2;\n-      case V64QImode:\n-      case V32HImode:\n-      case V16SImode:\n-      case V8DImode:\n-\tif (TARGET_AVX512F)\n-\t  return 2;\n-      default:\n-\tbreak;\n-      }\n+\n+  if (x == constm1_rtx || vector_all_ones_operand (x, mode))\n+    {\n+      /* VOIDmode integer constant, get mode from the predicate.  */\n+      if (mode == VOIDmode)\n+\tmode = pred_mode;\n+\n+      switch (GET_MODE_SIZE (mode))\n+\t{\n+\tcase 64:\n+\t  if (TARGET_AVX512F)\n+\t    return 2;\n+\t  break;\n+\tcase 32:\n+\t  if (TARGET_AVX2)\n+\t    return 2;\n+\t  break;\n+\tcase 16:\n+\t  if (TARGET_SSE2)\n+\t    return 2;\n+\t  break;\n+\tcase 0:\n+\t  /* VOIDmode */\n+\t  gcc_unreachable ();\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n \n   return 0;\n }\n@@ -10811,53 +10815,85 @@ standard_sse_constant_p (rtx x)\n const char *\n standard_sse_constant_opcode (rtx_insn *insn, rtx x)\n {\n-  switch (standard_sse_constant_p (x))\n+  machine_mode mode;\n+\n+  gcc_assert (TARGET_SSE);\n+\n+  mode = GET_MODE (x);\n+\n+  if (x == const0_rtx || const0_operand (x, mode))\n     {\n-    case 1:\n       switch (get_attr_mode (insn))\n \t{\n \tcase MODE_XI:\n \t  return \"vpxord\\t%g0, %g0, %g0\";\n-\tcase MODE_V16SF:\n-\t  return TARGET_AVX512DQ ? \"vxorps\\t%g0, %g0, %g0\"\n-\t\t\t\t : \"vpxord\\t%g0, %g0, %g0\";\n-\tcase MODE_V8DF:\n-\t  return TARGET_AVX512DQ ? \"vxorpd\\t%g0, %g0, %g0\"\n-\t\t\t\t : \"vpxorq\\t%g0, %g0, %g0\";\n+\tcase MODE_OI:\n+\t  return (TARGET_AVX512VL\n+\t\t  ? \"vpxord\\t%x0, %x0, %x0\"\n+\t\t  : \"vpxor\\t%x0, %x0, %x0\");\n \tcase MODE_TI:\n-\t  return TARGET_AVX512VL ? \"vpxord\\t%t0, %t0, %t0\"\n-\t\t\t\t : \"%vpxor\\t%0, %d0\";\n+\t  return (TARGET_AVX512VL\n+\t\t  ? \"vpxord\\t%t0, %t0, %t0\"\n+\t\t  : \"%vpxor\\t%0, %d0\");\n+\n+\tcase MODE_V8DF:\n+\t  return (TARGET_AVX512DQ\n+\t\t  ? \"vxorpd\\t%g0, %g0, %g0\"\n+\t\t  : \"vpxorq\\t%g0, %g0, %g0\");\n+\tcase MODE_V4DF:\n+\t  return \"vxorpd\\t%x0, %x0, %x0\";\n \tcase MODE_V2DF:\n \t  return \"%vxorpd\\t%0, %d0\";\n+\n+\tcase MODE_V16SF:\n+\t  return (TARGET_AVX512DQ\n+\t\t  ? \"vxorps\\t%g0, %g0, %g0\"\n+\t\t  : \"vpxord\\t%g0, %g0, %g0\");\n+\tcase MODE_V8SF:\n+\t  return \"vxorps\\t%x0, %x0, %x0\";\n \tcase MODE_V4SF:\n \t  return \"%vxorps\\t%0, %d0\";\n \n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else if (x == constm1_rtx || vector_all_ones_operand (x, mode))\n+    {\n+      enum attr_mode insn_mode = get_attr_mode (insn);\n+      \n+      switch (insn_mode)\n+\t{\n+\tcase MODE_XI:\n+\tcase MODE_V8DF:\n+\tcase MODE_V16SF:\n+\t  gcc_assert (TARGET_AVX512F);\n+\t  break;\n \tcase MODE_OI:\n-\t  return TARGET_AVX512VL ? \"vpxord\\t%x0, %x0, %x0\"\n-\t\t\t\t : \"vpxor\\t%x0, %x0, %x0\";\n \tcase MODE_V4DF:\n-\t  return \"vxorpd\\t%x0, %x0, %x0\";\n \tcase MODE_V8SF:\n-\t  return \"vxorps\\t%x0, %x0, %x0\";\n-\n-\tdefault:\n+\t  gcc_assert (TARGET_AVX2);\n+\t  break;\n+\tcase MODE_TI:\n+\tcase MODE_V2DF:\n+\tcase MODE_V4SF:\n+\t  gcc_assert (TARGET_SSE2);\n \t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n \n-    case 2:\n       if (TARGET_AVX512VL\n-\t  || get_attr_mode (insn) == MODE_XI\n-\t  || get_attr_mode (insn) == MODE_V8DF\n-\t  || get_attr_mode (insn) == MODE_V16SF)\n+\t  || insn_mode == MODE_XI\n+\t  || insn_mode == MODE_V8DF\n+\t  || insn_mode == MODE_V16SF)\n \treturn \"vpternlogd\\t{$0xFF, %g0, %g0, %g0|%g0, %g0, %g0, 0xFF}\";\n-      if (TARGET_AVX)\n+      else if (TARGET_AVX)\n \treturn \"vpcmpeqd\\t%0, %0, %0\";\n       else\n \treturn \"pcmpeqd\\t%0, %0\";\n+   }\n \n-    default:\n-      break;\n-    }\n   gcc_unreachable ();\n }\n \n@@ -14360,7 +14396,7 @@ darwin_local_data_pic (rtx disp)\n    satisfies CONSTANT_P.  */\n \n static bool\n-ix86_legitimate_constant_p (machine_mode, rtx x)\n+ix86_legitimate_constant_p (machine_mode mode, rtx x)\n {\n   /* Pointer bounds constants are not valid.  */\n   if (POINTER_BOUNDS_MODE_P (GET_MODE (x)))\n@@ -14426,13 +14462,25 @@ ix86_legitimate_constant_p (machine_mode, rtx x)\n #endif\n       break;\n \n+    case CONST_INT:\n     case CONST_WIDE_INT:\n-      if (!TARGET_64BIT && !standard_sse_constant_p (x))\n-\treturn false;\n+      switch (mode)\n+\t{\n+\tcase TImode:\n+\t  if (TARGET_64BIT)\n+\t    return true;\n+\t  /* FALLTHRU */\n+\tcase OImode:\n+\tcase XImode:\n+\t  if (!standard_sse_constant_p (x, mode))\n+\t    return false;\n+\tdefault:\n+\t  break;\n+\t}\n       break;\n \n     case CONST_VECTOR:\n-      if (!standard_sse_constant_p (x))\n+      if (!standard_sse_constant_p (x, mode))\n \treturn false;\n \n     default:\n@@ -18758,7 +18806,7 @@ ix86_expand_vector_move (machine_mode mode, rtx operands[])\n       && (CONSTANT_P (op1)\n \t  || (SUBREG_P (op1)\n \t      && CONSTANT_P (SUBREG_REG (op1))))\n-      && !standard_sse_constant_p (op1))\n+      && !standard_sse_constant_p (op1, mode))\n     op1 = validize_mem (force_const_mem (mode, op1));\n \n   /* We need to check memory alignment for SSE mode since attribute\n@@ -43679,8 +43727,8 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t}\n       if (SSE_FLOAT_MODE_P (mode))\n \t{\n-    case CONST_VECTOR:\n-\t  switch (standard_sse_constant_p (x))\n+\tcase CONST_VECTOR:\n+\t  switch (standard_sse_constant_p (x, mode))\n \t    {\n \t    case 0:\n \t      break;"}, {"sha": "25be5ca26fd935de92fd471360691420ba7507fc", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "patch": "@@ -1970,9 +1970,11 @@\n    (set_attr \"length_immediate\" \"1\")])\n \n (define_insn \"*movxi_internal_avx512f\"\n-  [(set (match_operand:XI 0 \"nonimmediate_operand\" \"=v,v ,m\")\n-\t(match_operand:XI 1 \"vector_move_operand\"  \"C ,vm,v\"))]\n-  \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  [(set (match_operand:XI 0 \"nonimmediate_operand\"\t\t\"=v,v ,m\")\n+\t(match_operand:XI 1 \"nonimmediate_or_sse_const_operand\" \"BC,vm,v\"))]\n+  \"TARGET_AVX512F\n+   && (register_operand (operands[0], XImode)\n+       || register_operand (operands[1], XImode))\"\n {\n   switch (which_alternative)\n     {\n@@ -1994,9 +1996,11 @@\n    (set_attr \"mode\" \"XI\")])\n \n (define_insn \"*movoi_internal_avx\"\n-  [(set (match_operand:OI 0 \"nonimmediate_operand\" \"=v,v ,m\")\n-\t(match_operand:OI 1 \"vector_move_operand\"  \"C ,vm,v\"))]\n-  \"TARGET_AVX && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  [(set (match_operand:OI 0 \"nonimmediate_operand\"\t\t\"=v,v,v ,m\")\n+\t(match_operand:OI 1 \"nonimmediate_or_sse_const_operand\" \"BC,C,vm,v\"))]\n+  \"TARGET_AVX\n+   && (register_operand (operands[0], OImode)\n+       || register_operand (operands[1], OImode))\"\n {\n   switch (get_attr_type (insn))\n     {\n@@ -2028,25 +2032,30 @@\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"sselog1,ssemov,ssemov\")\n+  [(set_attr \"isa\" \"avx2,*,*,*\")\n+   (set_attr \"type\" \"sselog1,sselog1,ssemov,ssemov\")\n    (set_attr \"prefix\" \"vex\")\n    (set (attr \"mode\")\n \t(cond [(ior (match_operand 0 \"ext_sse_reg_operand\")\n \t\t    (match_operand 1 \"ext_sse_reg_operand\"))\n \t\t (const_string \"XI\")\n \t       (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\")\n \t\t (const_string \"V8SF\")\n-\t       (and (eq_attr \"alternative\" \"2\")\n+\t       (and (eq_attr \"alternative\" \"3\")\n \t\t    (match_test \"TARGET_SSE_TYPELESS_STORES\"))\n \t\t (const_string \"V8SF\")\n \t      ]\n \t      (const_string \"OI\")))])\n \n (define_insn \"*movti_internal\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=!r ,o ,v,v ,m\")\n-\t(match_operand:TI 1 \"general_operand\"      \"riFo,re,C,vm,v\"))]\n-  \"(TARGET_64BIT || TARGET_SSE)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=!r ,o ,v ,v,v ,m\")\n+\t(match_operand:TI 1 \"general_operand\"\t   \"riFo,re,BC,C,vm,v\"))]\n+  \"(TARGET_64BIT\n+    && !(MEM_P (operands[0]) && MEM_P (operands[1])))\n+   || (TARGET_SSE\n+       && nonimmediate_or_sse_const_operand (operands[1], TImode)\n+       && (register_operand (operands[0], TImode)\n+\t   || register_operand (operands[1], TImode)))\"\n {\n   switch (get_attr_type (insn))\n     {\n@@ -2083,8 +2092,8 @@\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"isa\" \"x64,x64,*,*,*\")\n-   (set_attr \"type\" \"multi,multi,sselog1,ssemov,ssemov\")\n+  [(set_attr \"isa\" \"x64,x64,sse2,*,*,*\")\n+   (set_attr \"type\" \"multi,multi,sselog1,sselog1,ssemov,ssemov\")\n    (set (attr \"prefix\")\n      (if_then_else (eq_attr \"type\" \"sselog1,ssemov\")\n        (const_string \"maybe_vex\")\n@@ -2098,7 +2107,7 @@\n \t       (ior (not (match_test \"TARGET_SSE2\"))\n \t\t    (match_test \"TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL\"))\n \t\t (const_string \"V4SF\")\n-\t       (and (eq_attr \"alternative\" \"4\")\n+\t       (and (eq_attr \"alternative\" \"5\")\n \t\t    (match_test \"TARGET_SSE_TYPELESS_STORES\"))\n \t\t (const_string \"V4SF\")\n \t       (match_test \"TARGET_AVX\")\n@@ -3086,7 +3095,7 @@\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || !CONST_DOUBLE_P (operands[1])\n        || (optimize_function_for_size_p (cfun)\n-\t   && standard_sse_constant_p (operands[1])\n+\t   && standard_sse_constant_p (operands[1], TFmode) == 1\n \t   && !memory_operand (operands[0], TFmode))\n        || (!TARGET_MEMORY_MISMATCH_STALL\n \t   && memory_operand (operands[0], TFmode)))\"\n@@ -3240,7 +3249,7 @@\n \t   && ((!(TARGET_SSE2 && TARGET_SSE_MATH)\n \t\t&& standard_80387_constant_p (operands[1]) > 0)\n \t       || (TARGET_SSE2 && TARGET_SSE_MATH\n-\t\t   && standard_sse_constant_p (operands[1])))\n+\t\t   && standard_sse_constant_p (operands[1], DFmode) == 1))\n \t   && !memory_operand (operands[0], DFmode))\n        || ((TARGET_64BIT || !TARGET_MEMORY_MISMATCH_STALL)\n \t   && memory_operand (operands[0], DFmode))\n@@ -3442,7 +3451,7 @@\n \t   && ((!TARGET_SSE_MATH\n \t\t&& standard_80387_constant_p (operands[1]) > 0)\n \t       || (TARGET_SSE_MATH\n-\t\t   && standard_sse_constant_p (operands[1]))))\n+\t\t   && standard_sse_constant_p (operands[1], SFmode) == 1)))\n        || memory_operand (operands[0], SFmode)\n        || !TARGET_HARD_SF_REGS)\"\n {\n@@ -3579,7 +3588,8 @@\n \n   if (operands[2] == NULL_RTX\n       || (SSE_REGNO_P (REGNO (operands[0]))\n-\t  && !standard_sse_constant_p (operands[2]))\n+\t  && standard_sse_constant_p (operands[2],\n+\t\t\t\t      GET_MODE (operands[0])) != 1)\n       || (STACK_REGNO_P (REGNO (operands[0]))\n \t   && standard_80387_constant_p (operands[2]) < 1))\n     FAIL;\n@@ -3598,7 +3608,8 @@\n \n   if (operands[2] == NULL_RTX\n       || (SSE_REGNO_P (REGNO (operands[0]))\n-\t  && !standard_sse_constant_p (operands[2]))\n+\t  && standard_sse_constant_p (operands[2],\n+\t\t\t\t      GET_MODE (operands[0])) != 1)\n       || (STACK_REGNO_P (REGNO (operands[0]))\n \t   && standard_80387_constant_p (operands[2]) < 1))\n     FAIL;"}, {"sha": "079cf4ef91b385df824437f3690c1a82d6bda2a0", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "patch": "@@ -666,16 +666,7 @@\n   return op == CONST0_RTX (mode);\n })\n \n-;; Match -1.\n-(define_predicate \"constm1_operand\"\n-  (match_code \"const_int,const_wide_int,const_double,const_vector\")\n-{\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-  return op == CONSTM1_RTX (mode);\n-})\n-\n-;; Match one or vector filled with ones.\n+;; Match one or a vector with all elements equal to one.\n (define_predicate \"const1_operand\"\n   (match_code \"const_int,const_wide_int,const_double,const_vector\")\n {\n@@ -976,14 +967,8 @@\n \n ;; Return true when OP is nonimmediate or standard SSE constant.\n (define_predicate \"nonimmediate_or_sse_const_operand\"\n-  (match_operand 0 \"general_operand\")\n-{\n-  if (nonimmediate_operand (op, mode))\n-    return true;\n-  if (standard_sse_constant_p (op) > 0)\n-    return true;\n-  return false;\n-})\n+  (ior (match_operand 0 \"nonimmediate_operand\")\n+       (match_test \"standard_sse_constant_p (op, mode)\")))\n \n ;; Return true if OP is a register or a zero.\n (define_predicate \"reg_or_0_operand\""}, {"sha": "608552362693e788c462a4ef29e80a074f821ed6", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55284a77e6cb0064c69e28b3121e7ae2a9f6d871/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=55284a77e6cb0064c69e28b3121e7ae2a9f6d871", "patch": "@@ -5097,7 +5097,7 @@\n (define_insn \"*<avx512>_cvtmask2<ssemodesuffix><mode>\"\n   [(set (match_operand:VI12_AVX512VL 0 \"register_operand\" \"=v\")\n \t(vec_merge:VI12_AVX512VL\n-\t  (match_operand:VI12_AVX512VL 2 \"constm1_operand\")\n+\t  (match_operand:VI12_AVX512VL 2 \"vector_all_ones_operand\")\n \t  (match_operand:VI12_AVX512VL 3 \"const0_operand\")\n \t  (match_operand:<avx512fmaskmode> 1 \"register_operand\" \"Yk\")))]\n   \"TARGET_AVX512BW\"\n@@ -5120,7 +5120,7 @@\n (define_insn \"*<avx512>_cvtmask2<ssemodesuffix><mode>\"\n   [(set (match_operand:VI48_AVX512VL 0 \"register_operand\" \"=v\")\n \t(vec_merge:VI48_AVX512VL\n-\t  (match_operand:VI48_AVX512VL 2 \"constm1_operand\")\n+\t  (match_operand:VI48_AVX512VL 2 \"vector_all_ones_operand\")\n \t  (match_operand:VI48_AVX512VL 3 \"const0_operand\")\n \t  (match_operand:<avx512fmaskmode> 1 \"register_operand\" \"Yk\")))]\n   \"TARGET_AVX512DQ\""}]}