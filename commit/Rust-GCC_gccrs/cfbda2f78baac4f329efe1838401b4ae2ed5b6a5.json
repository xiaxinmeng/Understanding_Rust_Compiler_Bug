{"sha": "cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "node_id": "C_kwDOANBUbNoAKGNmYmRhMmY3OGJhYWM0ZjMyOWVmZTE4Mzg0MDFiNGFlMmVkNWI2YTU", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-21T12:29:50Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:07Z"}, "message": "gccrs: Add HIR to GCC GENERIC lowering entry point\n\nThis patch contains the entry point and utilities used for the lowering\nof HIR nodes to `tree`s. It also contains a constant evaluator, ported\nover from the C++ frontend.\n\n\tgcc/rust/\n\t* backend/rust-compile-context.cc: New.\n\t* backend/rust-compile-context.h: New.\n\t* backend/rust-compile.cc: New.\n\t* backend/rust-compile.h: New.\n\t* backend/rust-constexpr.cc: New.\n\t* backend/rust-constexpr.h: New.\n\nCo-authored-by: David Faust <david.faust@oracle.com>\nCo-authored-by: Faisal Abbas <90.abbasfaisal@gmail.com>\nSigned-off-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "63d04c0e9b01fe40f25380329f5801707583db1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63d04c0e9b01fe40f25380329f5801707583db1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "019b2f15581948806ee14a6d05b09ec94f04c966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/019b2f15581948806ee14a6d05b09ec94f04c966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/019b2f15581948806ee14a6d05b09ec94f04c966"}], "stats": {"total": 1414, "additions": 1414, "deletions": 0}, "files": [{"sha": "cb2addf6c21734b267733a2fd86e5d31a8e1f83b", "filename": "gcc/rust/backend/rust-compile-context.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-compile-context.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-compile-context.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.cc?ref=cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "patch": "@@ -0,0 +1,146 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-context.h\"\n+#include \"rust-compile-type.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+Context::Context (::Backend *backend)\n+  : backend (backend), resolver (Resolver::Resolver::get ()),\n+    tyctx (Resolver::TypeCheckContext::get ()),\n+    mappings (Analysis::Mappings::get ()), mangler (Mangler ())\n+{\n+  setup_builtins ();\n+}\n+\n+void\n+Context::setup_builtins ()\n+{\n+  auto builtins = resolver->get_builtin_types ();\n+  for (auto it = builtins.begin (); it != builtins.end (); it++)\n+    {\n+      HirId ref;\n+      bool ok = tyctx->lookup_type_by_node_id ((*it)->get_node_id (), &ref);\n+      rust_assert (ok);\n+\n+      TyTy::BaseType *lookup;\n+      ok = tyctx->lookup_type (ref, &lookup);\n+      rust_assert (ok);\n+\n+      TyTyResolveCompile::compile (this, lookup);\n+    }\n+}\n+\n+hashval_t\n+Context::type_hasher (tree type)\n+{\n+  inchash::hash hstate;\n+\n+  hstate.add_int (TREE_CODE (type));\n+\n+  if (TYPE_NAME (type))\n+    {\n+      hashval_t record_name_hash\n+\t= IDENTIFIER_HASH_VALUE (DECL_NAME (TYPE_NAME (type)));\n+      hstate.add_object (record_name_hash);\n+    }\n+\n+  for (tree t = TYPE_ATTRIBUTES (type); t; t = TREE_CHAIN (t))\n+    /* Just the identifier is adequate to distinguish.  */\n+    hstate.add_object (IDENTIFIER_HASH_VALUE (TREE_PURPOSE (t)));\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case METHOD_TYPE:\n+      hstate.add_object (TYPE_HASH (TYPE_METHOD_BASETYPE (type)));\n+      /* FALLTHROUGH. */\n+    case FUNCTION_TYPE:\n+      for (tree t = TYPE_ARG_TYPES (type); t; t = TREE_CHAIN (t))\n+\tif (TREE_VALUE (t) != error_mark_node)\n+\t  hstate.add_object (TYPE_HASH (TREE_VALUE (t)));\n+      break;\n+\n+    case OFFSET_TYPE:\n+      hstate.add_object (TYPE_HASH (TYPE_OFFSET_BASETYPE (type)));\n+      break;\n+\n+      case ARRAY_TYPE: {\n+\tif (TYPE_DOMAIN (type))\n+\t  hstate.add_object (TYPE_HASH (TYPE_DOMAIN (type)));\n+\tif (!AGGREGATE_TYPE_P (TREE_TYPE (type)))\n+\t  {\n+\t    unsigned typeless = TYPE_TYPELESS_STORAGE (type);\n+\t    hstate.add_object (typeless);\n+\t  }\n+      }\n+      break;\n+\n+      case INTEGER_TYPE: {\n+\ttree t = TYPE_MAX_VALUE (type);\n+\tif (!t)\n+\t  t = TYPE_MIN_VALUE (type);\n+\tfor (int i = 0; i < TREE_INT_CST_NUNITS (t); i++)\n+\t  hstate.add_object (TREE_INT_CST_ELT (t, i));\n+\tbreak;\n+      }\n+\n+    case REAL_TYPE:\n+      case FIXED_POINT_TYPE: {\n+\tunsigned prec = TYPE_PRECISION (type);\n+\thstate.add_object (prec);\n+\tbreak;\n+      }\n+\n+    case VECTOR_TYPE:\n+      hstate.add_poly_int (TYPE_VECTOR_SUBPARTS (type));\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      case QUAL_UNION_TYPE: {\n+\tfor (tree t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n+\t  {\n+\t    hashval_t name_hash = IDENTIFIER_HASH_VALUE (DECL_NAME (t));\n+\t    hashval_t type_hash = type_hasher (TREE_TYPE (t));\n+\t    hstate.add_object (name_hash);\n+\t    hstate.add_object (type_hash);\n+\t  }\n+      }\n+      break;\n+\n+    case BOOLEAN_TYPE:\n+      break;\n+\n+    case REFERENCE_TYPE:\n+      case POINTER_TYPE: {\n+\thashval_t type_hash = type_hasher (TREE_TYPE (type));\n+\thstate.add_object (type_hash);\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return hstate.end ();\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "096b65f8b3945178e862e98dcfbb9392105005fa", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "patch": "@@ -0,0 +1,343 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_CONTEXT\n+#define RUST_COMPILE_CONTEXT\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-backend.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-mangle.h\"\n+#include \"rust-tree.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+struct fncontext\n+{\n+  tree fndecl;\n+  ::Bvariable *ret_addr;\n+};\n+\n+class Context\n+{\n+public:\n+  Context (::Backend *backend);\n+\n+  void setup_builtins ();\n+\n+  bool lookup_compiled_types (tree t, tree *type)\n+  {\n+    hashval_t h = type_hasher (t);\n+    auto it = compiled_type_map.find (h);\n+    if (it == compiled_type_map.end ())\n+      return false;\n+\n+    *type = it->second;\n+    return true;\n+  }\n+\n+  tree insert_compiled_type (tree type)\n+  {\n+    hashval_t h = type_hasher (type);\n+    auto it = compiled_type_map.find (h);\n+    if (it != compiled_type_map.end ())\n+      return it->second;\n+\n+    compiled_type_map.insert ({h, type});\n+    push_type (type);\n+    return type;\n+  }\n+\n+  tree insert_main_variant (tree type)\n+  {\n+    hashval_t h = type_hasher (type);\n+    auto it = main_variants.find (h);\n+    if (it != main_variants.end ())\n+      return it->second;\n+\n+    main_variants.insert ({h, type});\n+    return type;\n+  }\n+\n+  ::Backend *get_backend () { return backend; }\n+  Resolver::Resolver *get_resolver () { return resolver; }\n+  Resolver::TypeCheckContext *get_tyctx () { return tyctx; }\n+  Analysis::Mappings *get_mappings () { return mappings; }\n+\n+  void push_block (tree scope)\n+  {\n+    scope_stack.push_back (scope);\n+    statements.push_back ({});\n+  }\n+\n+  tree pop_block ()\n+  {\n+    auto block = scope_stack.back ();\n+    scope_stack.pop_back ();\n+\n+    auto stmts = statements.back ();\n+    statements.pop_back ();\n+\n+    backend->block_add_statements (block, stmts);\n+\n+    return block;\n+  }\n+\n+  tree peek_enclosing_scope ()\n+  {\n+    if (scope_stack.size () == 0)\n+      return nullptr;\n+\n+    return scope_stack.back ();\n+  }\n+\n+  void add_statement_to_enclosing_scope (tree stmt)\n+  {\n+    statements.at (statements.size () - 2).push_back (stmt);\n+  }\n+\n+  void add_statement (tree stmt) { statements.back ().push_back (stmt); }\n+\n+  void insert_var_decl (HirId id, ::Bvariable *decl)\n+  {\n+    compiled_var_decls[id] = decl;\n+  }\n+\n+  bool lookup_var_decl (HirId id, ::Bvariable **decl)\n+  {\n+    auto it = compiled_var_decls.find (id);\n+    if (it == compiled_var_decls.end ())\n+      return false;\n+\n+    *decl = it->second;\n+    return true;\n+  }\n+\n+  void insert_function_decl (const TyTy::FnType *ref, tree fn)\n+  {\n+    auto id = ref->get_ty_ref ();\n+    auto dId = ref->get_id ();\n+\n+    rust_assert (compiled_fn_map.find (id) == compiled_fn_map.end ());\n+    compiled_fn_map[id] = fn;\n+\n+    auto it = mono_fns.find (dId);\n+    if (it == mono_fns.end ())\n+      mono_fns[dId] = {};\n+\n+    mono_fns[dId].push_back ({ref, fn});\n+  }\n+\n+  bool lookup_function_decl (HirId id, tree *fn, DefId dId = UNKNOWN_DEFID,\n+\t\t\t     const TyTy::BaseType *ref = nullptr)\n+  {\n+    // for for any monomorphized fns\n+    if (ref != nullptr)\n+      {\n+\trust_assert (dId != UNKNOWN_DEFID);\n+\n+\tauto it = mono_fns.find (dId);\n+\tif (it == mono_fns.end ())\n+\t  return false;\n+\n+\tfor (auto &e : mono_fns[dId])\n+\t  {\n+\t    const TyTy::BaseType *r = e.first;\n+\t    tree f = e.second;\n+\t    if (ref->is_equal (*r))\n+\t      {\n+\t\t*fn = f;\n+\t\treturn true;\n+\t      }\n+\t  }\n+\treturn false;\n+      }\n+\n+    auto it = compiled_fn_map.find (id);\n+    if (it == compiled_fn_map.end ())\n+      return false;\n+\n+    *fn = it->second;\n+    return true;\n+  }\n+\n+  void insert_const_decl (HirId id, tree expr) { compiled_consts[id] = expr; }\n+\n+  bool lookup_const_decl (HirId id, tree *expr)\n+  {\n+    auto it = compiled_consts.find (id);\n+    if (it == compiled_consts.end ())\n+      return false;\n+\n+    *expr = it->second;\n+    return true;\n+  }\n+\n+  void insert_label_decl (HirId id, tree label) { compiled_labels[id] = label; }\n+\n+  bool lookup_label_decl (HirId id, tree *label)\n+  {\n+    auto it = compiled_labels.find (id);\n+    if (it == compiled_labels.end ())\n+      return false;\n+\n+    *label = it->second;\n+    return true;\n+  }\n+\n+  void insert_pattern_binding (HirId id, tree binding)\n+  {\n+    implicit_pattern_bindings[id] = binding;\n+  }\n+\n+  bool lookup_pattern_binding (HirId id, tree *binding)\n+  {\n+    auto it = implicit_pattern_bindings.find (id);\n+    if (it == implicit_pattern_bindings.end ())\n+      return false;\n+\n+    *binding = it->second;\n+    return true;\n+  }\n+\n+  void push_fn (tree fn, ::Bvariable *ret_addr)\n+  {\n+    fn_stack.push_back (fncontext{fn, ret_addr});\n+  }\n+  void pop_fn () { fn_stack.pop_back (); }\n+\n+  bool in_fn () { return fn_stack.size () != 0; }\n+\n+  // Note: it is undefined behavior to call peek_fn () if fn_stack is empty.\n+  fncontext peek_fn ()\n+  {\n+    rust_assert (!fn_stack.empty ());\n+    return fn_stack.back ();\n+  }\n+\n+  void push_type (tree t) { type_decls.push_back (t); }\n+  void push_var (::Bvariable *v) { var_decls.push_back (v); }\n+  void push_const (tree c) { const_decls.push_back (c); }\n+  void push_function (tree f) { func_decls.push_back (f); }\n+\n+  void write_to_backend ()\n+  {\n+    backend->write_global_definitions (type_decls, const_decls, func_decls,\n+\t\t\t\t       var_decls);\n+  }\n+\n+  bool function_completed (tree fn)\n+  {\n+    for (auto it = func_decls.begin (); it != func_decls.end (); it++)\n+      {\n+\ttree i = (*it);\n+\tif (i == fn)\n+\t  {\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  void push_loop_context (Bvariable *var) { loop_value_stack.push_back (var); }\n+\n+  Bvariable *peek_loop_context () { return loop_value_stack.back (); }\n+\n+  Bvariable *pop_loop_context ()\n+  {\n+    auto back = loop_value_stack.back ();\n+    loop_value_stack.pop_back ();\n+    return back;\n+  }\n+\n+  void push_loop_begin_label (tree label)\n+  {\n+    loop_begin_labels.push_back (label);\n+  }\n+\n+  tree peek_loop_begin_label () { return loop_begin_labels.back (); }\n+\n+  tree pop_loop_begin_label ()\n+  {\n+    tree pop = loop_begin_labels.back ();\n+    loop_begin_labels.pop_back ();\n+    return pop;\n+  }\n+\n+  void push_const_context (void) { const_context++; }\n+  void pop_const_context (void)\n+  {\n+    if (const_context > 0)\n+      const_context--;\n+  }\n+  bool const_context_p (void) { return (const_context > 0); }\n+\n+  std::string mangle_item (const TyTy::BaseType *ty,\n+\t\t\t   const Resolver::CanonicalPath &path) const\n+  {\n+    return mangler.mangle_item (ty, path);\n+  }\n+\n+  std::vector<tree> &get_type_decls () { return type_decls; }\n+  std::vector<::Bvariable *> &get_var_decls () { return var_decls; }\n+  std::vector<tree> &get_const_decls () { return const_decls; }\n+  std::vector<tree> &get_func_decls () { return func_decls; }\n+\n+  static hashval_t type_hasher (tree type);\n+\n+private:\n+  ::Backend *backend;\n+  Resolver::Resolver *resolver;\n+  Resolver::TypeCheckContext *tyctx;\n+  Analysis::Mappings *mappings;\n+  Mangler mangler;\n+\n+  // state\n+  std::vector<fncontext> fn_stack;\n+  std::map<HirId, ::Bvariable *> compiled_var_decls;\n+  std::map<hashval_t, tree> compiled_type_map;\n+  std::map<HirId, tree> compiled_fn_map;\n+  std::map<HirId, tree> compiled_consts;\n+  std::map<HirId, tree> compiled_labels;\n+  std::vector<::std::vector<tree>> statements;\n+  std::vector<tree> scope_stack;\n+  std::vector<::Bvariable *> loop_value_stack;\n+  std::vector<tree> loop_begin_labels;\n+  std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, tree>>>\n+    mono_fns;\n+  std::map<HirId, tree> implicit_pattern_bindings;\n+  std::map<hashval_t, tree> main_variants;\n+\n+  // To GCC middle-end\n+  std::vector<tree> type_decls;\n+  std::vector<::Bvariable *> var_decls;\n+  std::vector<tree> const_decls;\n+  std::vector<tree> func_decls;\n+\n+  // Nonzero iff we are currently compiling something inside a constant context.\n+  unsigned int const_context = 0;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_CONTEXT"}, {"sha": "0ccb98d9e12893ac9348d7b8ed990a6d018f194c", "filename": "gcc/rust/backend/rust-compile.cc", "status": "added", "additions": 414, "deletions": 0, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "patch": "@@ -0,0 +1,414 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile.h\"\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-compile-stmt.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-dot-operator.h\"\n+#include \"rust-compile-block.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+CompileCrate::CompileCrate (HIR::Crate &crate, Context *ctx)\n+  : crate (crate), ctx (ctx)\n+{}\n+\n+CompileCrate::~CompileCrate () {}\n+\n+void\n+CompileCrate::Compile (HIR::Crate &crate, Context *ctx)\n+{\n+  CompileCrate c (crate, ctx);\n+  c.go ();\n+}\n+\n+void\n+CompileCrate::go ()\n+{\n+  for (auto &item : crate.items)\n+    CompileItem::compile (item.get (), ctx);\n+}\n+\n+// Shared methods in compilation\n+\n+tree\n+HIRCompileBase::coercion_site (HirId id, tree rvalue,\n+\t\t\t       const TyTy::BaseType *rval,\n+\t\t\t       const TyTy::BaseType *lval,\n+\t\t\t       Location lvalue_locus, Location rvalue_locus)\n+{\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_autoderef_mappings (id, &adjustments);\n+  if (ok)\n+    {\n+      rvalue = resolve_adjustements (*adjustments, rvalue, rvalue_locus);\n+    }\n+\n+  return coercion_site1 (rvalue, rval, lval, lvalue_locus, rvalue_locus);\n+}\n+\n+tree\n+HIRCompileBase::coercion_site1 (tree rvalue, const TyTy::BaseType *rval,\n+\t\t\t\tconst TyTy::BaseType *lval,\n+\t\t\t\tLocation lvalue_locus, Location rvalue_locus)\n+{\n+  if (rvalue == error_mark_node)\n+    return error_mark_node;\n+\n+  const TyTy::BaseType *actual = rval->destructure ();\n+  const TyTy::BaseType *expected = lval->destructure ();\n+\n+  if (expected->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      // this is a dyn object\n+      if (SLICE_TYPE_P (TREE_TYPE (rvalue)))\n+\t{\n+\t  return rvalue;\n+\t}\n+\n+      // bad coercion... of something to a reference\n+      if (actual->get_kind () != TyTy::TypeKind::REF)\n+\treturn error_mark_node;\n+\n+      const TyTy::ReferenceType *exp\n+\t= static_cast<const TyTy::ReferenceType *> (expected);\n+      const TyTy::ReferenceType *act\n+\t= static_cast<const TyTy::ReferenceType *> (actual);\n+\n+      tree deref_rvalue = indirect_expression (rvalue, rvalue_locus);\n+      tree coerced\n+\t= coercion_site1 (deref_rvalue, act->get_base (), exp->get_base (),\n+\t\t\t  lvalue_locus, rvalue_locus);\n+      if (exp->is_dyn_object () && SLICE_TYPE_P (TREE_TYPE (coerced)))\n+\treturn coerced;\n+\n+      return address_expression (coerced, rvalue_locus);\n+    }\n+  else if (expected->get_kind () == TyTy::TypeKind::POINTER)\n+    {\n+      // this is a dyn object\n+      if (SLICE_TYPE_P (TREE_TYPE (rvalue)))\n+\t{\n+\t  return rvalue;\n+\t}\n+\n+      // bad coercion... of something to a reference\n+      bool valid_coercion = actual->get_kind () == TyTy::TypeKind::REF\n+\t\t\t    || actual->get_kind () == TyTy::TypeKind::POINTER;\n+      if (!valid_coercion)\n+\treturn error_mark_node;\n+\n+      const TyTy::ReferenceType *exp\n+\t= static_cast<const TyTy::ReferenceType *> (expected);\n+\n+      TyTy::BaseType *actual_base = nullptr;\n+      if (actual->get_kind () == TyTy::TypeKind::REF)\n+\t{\n+\t  const TyTy::ReferenceType *act\n+\t    = static_cast<const TyTy::ReferenceType *> (actual);\n+\n+\t  actual_base = act->get_base ();\n+\t}\n+      else if (actual->get_kind () == TyTy::TypeKind::POINTER)\n+\t{\n+\t  const TyTy::PointerType *act\n+\t    = static_cast<const TyTy::PointerType *> (actual);\n+\n+\t  actual_base = act->get_base ();\n+\t}\n+      rust_assert (actual_base != nullptr);\n+\n+      tree deref_rvalue = indirect_expression (rvalue, rvalue_locus);\n+      tree coerced\n+\t= coercion_site1 (deref_rvalue, actual_base, exp->get_base (),\n+\t\t\t  lvalue_locus, rvalue_locus);\n+\n+      if (exp->is_dyn_object () && SLICE_TYPE_P (TREE_TYPE (coerced)))\n+\treturn coerced;\n+\n+      return address_expression (coerced, rvalue_locus);\n+    }\n+  else if (expected->get_kind () == TyTy::TypeKind::ARRAY)\n+    {\n+      if (actual->get_kind () != TyTy::TypeKind::ARRAY)\n+\treturn error_mark_node;\n+\n+      tree tree_rval_type = TyTyResolveCompile::compile (ctx, actual);\n+      tree tree_lval_type = TyTyResolveCompile::compile (ctx, expected);\n+      if (!verify_array_capacities (tree_lval_type, tree_rval_type,\n+\t\t\t\t    lvalue_locus, rvalue_locus))\n+\treturn error_mark_node;\n+    }\n+  else if (expected->get_kind () == TyTy::TypeKind::SLICE)\n+    {\n+      // bad coercion\n+      bool valid_coercion = actual->get_kind () == TyTy::TypeKind::SLICE\n+\t\t\t    || actual->get_kind () == TyTy::TypeKind::ARRAY;\n+      if (!valid_coercion)\n+\treturn error_mark_node;\n+\n+      // nothing to do here\n+      if (actual->get_kind () == TyTy::TypeKind::SLICE)\n+\treturn rvalue;\n+\n+      // return an unsized coercion\n+      Resolver::Adjustment unsize_adj (\n+\tResolver::Adjustment::AdjustmentType::UNSIZE, actual, expected);\n+      return resolve_unsized_adjustment (unsize_adj, rvalue, rvalue_locus);\n+    }\n+\n+  return rvalue;\n+}\n+\n+tree\n+HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n+\t\t\t\t      const TyTy::BaseType *actual,\n+\t\t\t\t      const TyTy::DynamicObjectType *ty,\n+\t\t\t\t      Location locus)\n+{\n+  tree dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n+  tree dynamic_object_fields = TYPE_FIELDS (dynamic_object);\n+  tree vtable_field = DECL_CHAIN (dynamic_object_fields);\n+  rust_assert (TREE_CODE (TREE_TYPE (vtable_field)) == ARRAY_TYPE);\n+\n+  //' this assumes ordering and current the structure is\n+  // __trait_object_ptr\n+  // [list of function ptrs]\n+\n+  std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n+    probed_bounds_for_receiver = Resolver::TypeBoundsProbe::Probe (actual);\n+\n+  tree address_of_compiled_ref = null_pointer_node;\n+  if (!actual->is_unit ())\n+    address_of_compiled_ref = address_expression (compiled_ref, locus);\n+\n+  std::vector<tree> vtable_ctor_elems;\n+  std::vector<unsigned long> vtable_ctor_idx;\n+  unsigned long i = 0;\n+  for (auto &bound : ty->get_object_items ())\n+    {\n+      const Resolver::TraitItemReference *item = bound.first;\n+      const TyTy::TypeBoundPredicate *predicate = bound.second;\n+\n+      auto address = compute_address_for_trait_item (item, predicate,\n+\t\t\t\t\t\t     probed_bounds_for_receiver,\n+\t\t\t\t\t\t     actual, actual, locus);\n+      vtable_ctor_elems.push_back (address);\n+      vtable_ctor_idx.push_back (i++);\n+    }\n+\n+  tree vtable_ctor = ctx->get_backend ()->array_constructor_expression (\n+    TREE_TYPE (vtable_field), vtable_ctor_idx, vtable_ctor_elems, locus);\n+\n+  std::vector<tree> dyn_ctor = {address_of_compiled_ref, vtable_ctor};\n+  return ctx->get_backend ()->constructor_expression (dynamic_object, false,\n+\t\t\t\t\t\t      dyn_ctor, -1, locus);\n+}\n+\n+tree\n+HIRCompileBase::compute_address_for_trait_item (\n+  const Resolver::TraitItemReference *ref,\n+  const TyTy::TypeBoundPredicate *predicate,\n+  std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n+    &receiver_bounds,\n+  const TyTy::BaseType *receiver, const TyTy::BaseType *root, Location locus)\n+{\n+  // There are two cases here one where its an item which has an implementation\n+  // within a trait-impl-block. Then there is the case where there is a default\n+  // implementation for this within the trait.\n+  //\n+  // The awkward part here is that this might be a generic trait and we need to\n+  // figure out the correct monomorphized type for this so we can resolve the\n+  // address of the function , this is stored as part of the\n+  // type-bound-predicate\n+  //\n+  // Algo:\n+  // check if there is an impl-item for this trait-item-ref first\n+  // else assert that the trait-item-ref has an implementation\n+\n+  TyTy::TypeBoundPredicateItem predicate_item\n+    = predicate->lookup_associated_item (ref->get_identifier ());\n+  rust_assert (!predicate_item.is_error ());\n+\n+  // this is the expected end type\n+  TyTy::BaseType *trait_item_type = predicate_item.get_tyty_for_receiver (root);\n+  rust_assert (trait_item_type->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *trait_item_fntype\n+    = static_cast<TyTy::FnType *> (trait_item_type);\n+\n+  // find impl-block for this trait-item-ref\n+  HIR::ImplBlock *associated_impl_block = nullptr;\n+  const Resolver::TraitReference *predicate_trait_ref = predicate->get ();\n+  for (auto &item : receiver_bounds)\n+    {\n+      Resolver::TraitReference *trait_ref = item.first;\n+      HIR::ImplBlock *impl_block = item.second;\n+      if (predicate_trait_ref->is_equal (*trait_ref))\n+\t{\n+\t  associated_impl_block = impl_block;\n+\t  break;\n+\t}\n+    }\n+\n+  // FIXME this probably should just return error_mark_node but this helps\n+  // debug for now since we are wrongly returning early on type-resolution\n+  // failures, until we take advantage of more error types and error_mark_node\n+  rust_assert (associated_impl_block != nullptr);\n+\n+  // lookup self for the associated impl\n+  std::unique_ptr<HIR::Type> &self_type_path\n+    = associated_impl_block->get_type ();\n+  TyTy::BaseType *self = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    self_type_path->get_mappings ().get_hirid (), &self);\n+  rust_assert (ok);\n+\n+  // lookup the predicate item from the self\n+  TyTy::TypeBoundPredicate *self_bound = nullptr;\n+  for (auto &bound : self->get_specified_bounds ())\n+    {\n+      const Resolver::TraitReference *bound_ref = bound.get ();\n+      const Resolver::TraitReference *specified_ref = predicate->get ();\n+      if (bound_ref->is_equal (*specified_ref))\n+\t{\n+\t  self_bound = &bound;\n+\t  break;\n+\t}\n+    }\n+  rust_assert (self_bound != nullptr);\n+\n+  // lookup the associated item from the associated impl block\n+  TyTy::TypeBoundPredicateItem associated_self_item\n+    = self_bound->lookup_associated_item (ref->get_identifier ());\n+  rust_assert (!associated_self_item.is_error ());\n+\n+  TyTy::BaseType *mono1 = associated_self_item.get_tyty_for_receiver (self);\n+  rust_assert (mono1 != nullptr);\n+  rust_assert (mono1->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *assocated_item_ty1 = static_cast<TyTy::FnType *> (mono1);\n+\n+  // Lookup the impl-block for the associated impl_item if it exists\n+  HIR::Function *associated_function = nullptr;\n+  for (auto &impl_item : associated_impl_block->get_impl_items ())\n+    {\n+      bool is_function = impl_item->get_impl_item_type ()\n+\t\t\t == HIR::ImplItem::ImplItemType::FUNCTION;\n+      if (!is_function)\n+\tcontinue;\n+\n+      HIR::Function *fn = static_cast<HIR::Function *> (impl_item.get ());\n+      bool found_associated_item\n+\t= fn->get_function_name ().compare (ref->get_identifier ()) == 0;\n+      if (found_associated_item)\n+\tassociated_function = fn;\n+    }\n+\n+  // we found an impl_item for this\n+  if (associated_function != nullptr)\n+    {\n+      // lookup the associated type for this item\n+      TyTy::BaseType *lookup = nullptr;\n+      bool ok = ctx->get_tyctx ()->lookup_type (\n+\tassociated_function->get_mappings ().get_hirid (), &lookup);\n+      rust_assert (ok);\n+      rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+      TyTy::FnType *lookup_fntype = static_cast<TyTy::FnType *> (lookup);\n+\n+      if (lookup_fntype->needs_substitution ())\n+\t{\n+\t  TyTy::SubstitutionArgumentMappings mappings\n+\t    = assocated_item_ty1->solve_missing_mappings_from_this (\n+\t      *trait_item_fntype, *lookup_fntype);\n+\t  lookup_fntype = lookup_fntype->handle_substitions (mappings);\n+\t}\n+\n+      return CompileInherentImplItem::Compile (associated_function, ctx,\n+\t\t\t\t\t       lookup_fntype, true, locus);\n+    }\n+\n+  // we can only compile trait-items with a body\n+  bool trait_item_has_definition = ref->is_optional ();\n+  rust_assert (trait_item_has_definition);\n+\n+  HIR::TraitItem *trait_item = ref->get_hir_trait_item ();\n+  return CompileTraitItem::Compile (trait_item, ctx, trait_item_fntype, true,\n+\t\t\t\t    locus);\n+}\n+\n+bool\n+HIRCompileBase::verify_array_capacities (tree ltype, tree rtype,\n+\t\t\t\t\t Location lvalue_locus,\n+\t\t\t\t\t Location rvalue_locus)\n+{\n+  rust_assert (ltype != NULL_TREE);\n+  rust_assert (rtype != NULL_TREE);\n+\n+  // lets just return ok as other errors have already occurred\n+  if (ltype == error_mark_node || rtype == error_mark_node)\n+    return true;\n+\n+  tree ltype_domain = TYPE_DOMAIN (ltype);\n+  if (!ltype_domain)\n+    return false;\n+\n+  if (!TREE_CONSTANT (TYPE_MAX_VALUE (ltype_domain)))\n+    return false;\n+\n+  unsigned HOST_WIDE_INT ltype_length\n+    = wi::ext (wi::to_offset (TYPE_MAX_VALUE (ltype_domain))\n+\t\t - wi::to_offset (TYPE_MIN_VALUE (ltype_domain)) + 1,\n+\t       TYPE_PRECISION (TREE_TYPE (ltype_domain)),\n+\t       TYPE_SIGN (TREE_TYPE (ltype_domain)))\n+\t.to_uhwi ();\n+\n+  tree rtype_domain = TYPE_DOMAIN (rtype);\n+  if (!rtype_domain)\n+    return false;\n+\n+  if (!TREE_CONSTANT (TYPE_MAX_VALUE (rtype_domain)))\n+    return false;\n+\n+  unsigned HOST_WIDE_INT rtype_length\n+    = wi::ext (wi::to_offset (TYPE_MAX_VALUE (rtype_domain))\n+\t\t - wi::to_offset (TYPE_MIN_VALUE (rtype_domain)) + 1,\n+\t       TYPE_PRECISION (TREE_TYPE (rtype_domain)),\n+\t       TYPE_SIGN (TREE_TYPE (rtype_domain)))\n+\t.to_uhwi ();\n+\n+  if (ltype_length != rtype_length)\n+    {\n+      rust_error_at (\n+\trvalue_locus,\n+\t\"expected an array with a fixed size of \" HOST_WIDE_INT_PRINT_UNSIGNED\n+\t\" elements, found one with \" HOST_WIDE_INT_PRINT_UNSIGNED \" elements\",\n+\tltype_length, rtype_length);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "62ebac69cc13311b45cd491c74fa652a64139f03", "filename": "gcc/rust/backend/rust-compile.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-compile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-compile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.h?ref=cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "patch": "@@ -0,0 +1,47 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_H\n+#define RUST_COMPILE_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-compile-context.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileCrate\n+{\n+public:\n+  static void Compile (HIR::Crate &crate, Context *ctx);\n+\n+  ~CompileCrate ();\n+\n+private:\n+  CompileCrate (HIR::Crate &crate, Context *ctx);\n+  void go ();\n+\n+  HIR::Crate &crate;\n+  Context *ctx;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_H"}, {"sha": "5aa10d92e15bc2324051144815a67af94cdc54ec", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "added", "additions": 433, "deletions": 0, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "patch": "@@ -0,0 +1,433 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-constexpr.h\"\n+#include \"rust-location.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-tree.h\"\n+\n+#include \"fold-const.h\"\n+#include \"realmpfr.h\"\n+#include \"convert.h\"\n+#include \"print-tree.h\"\n+#include \"gimplify.h\"\n+#include \"tree-iterator.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+struct constexpr_global_ctx\n+{\n+  HOST_WIDE_INT constexpr_ops_count;\n+\n+  constexpr_global_ctx () : constexpr_ops_count (0) {}\n+};\n+\n+struct constexpr_ctx\n+{\n+  constexpr_global_ctx *global;\n+};\n+\n+static tree\n+constant_value_1 (tree decl, bool strict_p, bool return_aggregate_cst_ok_p,\n+\t\t  bool unshare_p);\n+tree\n+decl_constant_value (tree decl, bool unshare_p);\n+\n+static void\n+non_const_var_error (location_t loc, tree r);\n+\n+static tree\n+constexpr_expression (const constexpr_ctx *ctx, tree);\n+\n+static tree\n+constexpr_fn_retval (const constexpr_ctx *ctx, tree r);\n+\n+static tree\n+eval_store_expression (const constexpr_ctx *ctx, tree r);\n+\n+static tree\n+eval_call_expression (const constexpr_ctx *ctx, tree r);\n+\n+static tree\n+eval_binary_expression (const constexpr_ctx *ctx, tree r);\n+\n+static tree\n+get_function_named_in_call (tree t);\n+\n+tree\n+fold_expr (tree expr)\n+{\n+  constexpr_global_ctx global_ctx;\n+  constexpr_ctx ctx = {&global_ctx};\n+\n+  tree folded = constexpr_expression (&ctx, expr);\n+  rust_assert (folded != NULL_TREE);\n+  return folded;\n+}\n+\n+static tree\n+constexpr_expression (const constexpr_ctx *ctx, tree t)\n+{\n+  location_t loc = EXPR_LOCATION (t);\n+\n+  if (CONSTANT_CLASS_P (t))\n+    {\n+      if (TREE_OVERFLOW (t))\n+\t{\n+\t  error_at (loc, \"overflow in constant expression\");\n+\t  return t;\n+\t}\n+\n+      return t;\n+    }\n+\n+  // Avoid excessively long constexpr evaluations\n+  if (++ctx->global->constexpr_ops_count >= constexpr_ops_limit)\n+    {\n+      rust_error_at (\n+\tLocation (loc),\n+\t\"%<constexpr%> evaluation operation count exceeds limit of \"\n+\t\"%wd (use %<-fconstexpr-ops-limit=%> to increase the limit)\",\n+\tconstexpr_ops_limit);\n+\n+      return t;\n+    }\n+\n+  tree r = t;\n+  tree_code tcode = TREE_CODE (t);\n+  switch (tcode)\n+    {\n+      case CONST_DECL: {\n+\tr = decl_constant_value (t, /*unshare_p=*/false);\n+\tif (TREE_CODE (r) == TARGET_EXPR\n+\t    && TREE_CODE (TARGET_EXPR_INITIAL (r)) == CONSTRUCTOR)\n+\t  r = TARGET_EXPR_INITIAL (r);\n+\tif (DECL_P (r))\n+\t  {\n+\t    non_const_var_error (loc, r);\n+\t    return r;\n+\t  }\n+      }\n+      break;\n+\n+    case POINTER_PLUS_EXPR:\n+    case POINTER_DIFF_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case TRUTH_XOR_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case SPACESHIP_EXPR:\n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case LTGT_EXPR:\n+    case RANGE_EXPR:\n+    case COMPLEX_EXPR:\n+      r = eval_binary_expression (ctx, t);\n+      break;\n+\n+    case CALL_EXPR:\n+      r = eval_call_expression (ctx, t);\n+      break;\n+\n+    case RETURN_EXPR:\n+      rust_assert (TREE_OPERAND (t, 0) != NULL_TREE);\n+      r = constexpr_expression (ctx, TREE_OPERAND (t, 0));\n+      break;\n+\n+    case MODIFY_EXPR:\n+      r = eval_store_expression (ctx, t);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return r;\n+}\n+\n+static tree\n+eval_store_expression (const constexpr_ctx *ctx, tree t)\n+{\n+  tree init = TREE_OPERAND (t, 1);\n+  if (TREE_CLOBBER_P (init))\n+    /* Just ignore clobbers.  */\n+    return void_node;\n+\n+  /* First we figure out where we're storing to.  */\n+  tree target = TREE_OPERAND (t, 0);\n+\n+  tree type = TREE_TYPE (target);\n+  bool preeval = SCALAR_TYPE_P (type) || TREE_CODE (t) == MODIFY_EXPR;\n+  if (preeval)\n+    {\n+      /* Evaluate the value to be stored without knowing what object it will be\n+\t stored in, so that any side-effects happen first.  */\n+      init = fold_expr (init);\n+    }\n+\n+  bool evaluated = false;\n+  tree object = NULL_TREE;\n+  for (tree probe = target; object == NULL_TREE;)\n+    {\n+      switch (TREE_CODE (probe))\n+\t{\n+\tdefault:\n+\t  if (evaluated)\n+\t    object = probe;\n+\t  else\n+\t    {\n+\t      probe = constexpr_expression (ctx, probe);\n+\t      evaluated = true;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+\n+  return init;\n+}\n+\n+/* Subroutine of cxx_eval_constant_expression.\n+ Like cxx_eval_unary_expression, except for binary expressions.  */\n+static tree\n+eval_binary_expression (const constexpr_ctx *ctx, tree t)\n+{\n+  tree orig_lhs = TREE_OPERAND (t, 0);\n+  tree orig_rhs = TREE_OPERAND (t, 1);\n+  tree lhs, rhs;\n+\n+  lhs = constexpr_expression (ctx, orig_lhs);\n+  rhs = constexpr_expression (ctx, orig_rhs);\n+\n+  location_t loc = EXPR_LOCATION (t);\n+  enum tree_code code = TREE_CODE (t);\n+  tree type = TREE_TYPE (t);\n+\n+  return fold_binary_loc (loc, code, type, lhs, rhs);\n+}\n+\n+// Subroutine of cxx_eval_constant_expression.\n+// Evaluate the call expression tree T in the context of OLD_CALL expression\n+// evaluation.\n+static tree\n+eval_call_expression (const constexpr_ctx *ctx, tree t)\n+{\n+  tree fun = get_function_named_in_call (t);\n+  return constexpr_fn_retval (ctx, DECL_SAVED_TREE (fun));\n+}\n+\n+// Subroutine of check_constexpr_fundef.  BODY is the body of a function\n+// declared to be constexpr, or a sub-statement thereof.  Returns the\n+// return value if suitable, error_mark_node for a statement not allowed in\n+// a constexpr function, or NULL_TREE if no return value was found.\n+static tree\n+constexpr_fn_retval (const constexpr_ctx *ctx, tree body)\n+{\n+  switch (TREE_CODE (body))\n+    {\n+      case STATEMENT_LIST: {\n+\ttree expr = NULL_TREE;\n+\tfor (tree stmt : tsi_range (body))\n+\t  {\n+\t    tree s = constexpr_fn_retval (ctx, stmt);\n+\t    if (s == error_mark_node)\n+\t      return error_mark_node;\n+\t    else if (s == NULL_TREE)\n+\t      /* Keep iterating.  */;\n+\t    else if (expr)\n+\t      /* Multiple return statements.  */\n+\t      return error_mark_node;\n+\t    else\n+\t      expr = s;\n+\t  }\n+\treturn expr;\n+      }\n+\n+    case RETURN_EXPR:\n+      return constexpr_expression (ctx, body);\n+\n+      case DECL_EXPR: {\n+\ttree decl = DECL_EXPR_DECL (body);\n+\tif (TREE_CODE (decl) == USING_DECL\n+\t    /* Accept __func__, __FUNCTION__, and __PRETTY_FUNCTION__.  */\n+\t    || DECL_ARTIFICIAL (decl))\n+\t  return NULL_TREE;\n+\treturn error_mark_node;\n+      }\n+\n+    case CLEANUP_POINT_EXPR:\n+      return constexpr_fn_retval (ctx, TREE_OPERAND (body, 0));\n+\n+      case BIND_EXPR: {\n+\ttree b = BIND_EXPR_BODY (body);\n+\treturn constexpr_fn_retval (ctx, b);\n+      }\n+      break;\n+\n+    default:\n+      return error_mark_node;\n+    }\n+  return error_mark_node;\n+}\n+\n+// Taken from cp/constexpr.cc\n+//\n+// If DECL is a scalar enumeration constant or variable with a\n+// constant initializer, return the initializer (or, its initializers,\n+// recursively); otherwise, return DECL.  If STRICT_P, the\n+// initializer is only returned if DECL is a\n+// constant-expression.  If RETURN_AGGREGATE_CST_OK_P, it is ok to\n+// return an aggregate constant.  If UNSHARE_P, return an unshared\n+// copy of the initializer.\n+static tree\n+constant_value_1 (tree decl, bool strict_p, bool return_aggregate_cst_ok_p,\n+\t\t  bool unshare_p)\n+{\n+  while (TREE_CODE (decl) == CONST_DECL)\n+    {\n+      tree init;\n+      /* If DECL is a static data member in a template\n+\t specialization, we must instantiate it here.  The\n+\t initializer for the static data member is not processed\n+\t until needed; we need it now.  */\n+\n+      init = DECL_INITIAL (decl);\n+      if (init == error_mark_node)\n+\t{\n+\t  if (TREE_CODE (decl) == CONST_DECL)\n+\t    /* Treat the error as a constant to avoid cascading errors on\n+\t       excessively recursive template instantiation (c++/9335).  */\n+\t    return init;\n+\t  else\n+\t    return decl;\n+\t}\n+\n+      decl = init;\n+    }\n+  return unshare_p ? unshare_expr (decl) : decl;\n+}\n+\n+// A more relaxed version of decl_really_constant_value, used by the\n+// common C/C++ code.\n+tree\n+decl_constant_value (tree decl, bool unshare_p)\n+{\n+  return constant_value_1 (decl, /*strict_p=*/false,\n+\t\t\t   /*return_aggregate_cst_ok_p=*/true,\n+\t\t\t   /*unshare_p=*/unshare_p);\n+}\n+\n+static void\n+non_const_var_error (location_t loc, tree r)\n+{\n+  error_at (loc,\n+\t    \"the value of %qD is not usable in a constant \"\n+\t    \"expression\",\n+\t    r);\n+  /* Avoid error cascade.  */\n+  if (DECL_INITIAL (r) == error_mark_node)\n+    return;\n+\n+  // more in cp/constexpr.cc\n+}\n+\n+static tree\n+get_callee (tree call)\n+{\n+  if (call == NULL_TREE)\n+    return call;\n+  else if (TREE_CODE (call) == CALL_EXPR)\n+    return CALL_EXPR_FN (call);\n+\n+  return NULL_TREE;\n+}\n+\n+// We have an expression tree T that represents a call, either CALL_EXPR\n+// or AGGR_INIT_EXPR. If the call is lexically to a named function,\n+// return the _DECL for that function.\n+static tree\n+get_function_named_in_call (tree t)\n+{\n+  tree fun = get_callee (t);\n+  if (fun && TREE_CODE (fun) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (fun, 0)) == FUNCTION_DECL)\n+    fun = TREE_OPERAND (fun, 0);\n+  return fun;\n+}\n+\n+// forked from gcc/cp/constexpr.cc maybe_constexpr_fn\n+\n+/* True if a function might be declared constexpr  */\n+\n+bool\n+maybe_constexpr_fn (tree t)\n+{\n+  return (DECL_DECLARED_CONSTEXPR_P (t));\n+}\n+\n+// forked from gcc/cp/constexpr.cc get_nth_callarg\n+\n+/* We have an expression tree T that represents a call, either CALL_EXPR.\n+  Return the Nth argument.  */\n+\n+inline tree\n+get_nth_callarg (tree t, int n)\n+{\n+  return CALL_EXPR_ARG (t, n);\n+}\n+\n+// forked from gcc/cp/constexpr.cc var_in_maybe_constexpr_fn\n+\n+/* True if T was declared in a function that might be constexpr: either a\n+   function that was declared constexpr.  */\n+\n+bool\n+var_in_maybe_constexpr_fn (tree t)\n+{\n+  return (DECL_FUNCTION_SCOPE_P (t) && maybe_constexpr_fn (DECL_CONTEXT (t)));\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "3cfcec817a9ff59baa72a1114c1c36c65a249cb7", "filename": "gcc/rust/backend/rust-constexpr.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-constexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfbda2f78baac4f329efe1838401b4ae2ed5b6a5/gcc%2Frust%2Fbackend%2Frust-constexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.h?ref=cfbda2f78baac4f329efe1838401b4ae2ed5b6a5", "patch": "@@ -0,0 +1,31 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_CONSTEXPR\n+#define RUST_CONSTEXPR\n+\n+#include \"rust-system.h\"\n+#include \"tree.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+extern tree fold_expr (tree);\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_CONSTEXPR"}]}