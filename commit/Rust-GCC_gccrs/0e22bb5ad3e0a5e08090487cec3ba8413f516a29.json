{"sha": "0e22bb5ad3e0a5e08090487cec3ba8413f516a29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUyMmJiNWFkM2UwYTVlMDgwOTA0ODdjZWMzYmE4NDEzZjUxNmEyOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-10-15T11:39:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-10-15T11:39:09Z"}, "message": "tree-vectorizer.h (vect_get_new_ssa_name): Declare.\n\n2015-10-15  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (vect_get_new_ssa_name): Declare.\n\t* tree-vect-data-refs.c (vect_get_new_ssa_name): New helper.\n\t* tree-vect-loop.c (get_initial_def_for_induction): Drop\n\tuse of force_gimple_operand in favor of gimple_build.\n\tUse vect_get_new_ssa_name.\n\t* tree-vect-stmts.c (vect_init_vector): Use vect_get_new_ssa_name.\n\t(vectorizable_mask_load_store): Likewise.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vect_get_vec_def_for_stmt_copy): Remove redundant stmt.\n\nFrom-SVN: r228841", "tree": {"sha": "69415cd77cbef8ae87d676560e71106520729a9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69415cd77cbef8ae87d676560e71106520729a9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e22bb5ad3e0a5e08090487cec3ba8413f516a29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e22bb5ad3e0a5e08090487cec3ba8413f516a29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e22bb5ad3e0a5e08090487cec3ba8413f516a29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53f3cd25de6706b1850650111a31c0ea0bb63406", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53f3cd25de6706b1850650111a31c0ea0bb63406", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53f3cd25de6706b1850650111a31c0ea0bb63406"}], "stats": {"total": 144, "additions": 81, "deletions": 63}, "files": [{"sha": "9e153a84e879c8a0eb6f6f8a694aba8b2eeb3493", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e22bb5ad3e0a5e08090487cec3ba8413f516a29", "patch": "@@ -1,3 +1,17 @@\n+2015-10-15  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (vect_get_new_ssa_name): Declare.\n+\t* tree-vect-data-refs.c (vect_get_new_ssa_name): New helper.\n+\t* tree-vect-loop.c (get_initial_def_for_induction): Drop\n+\tuse of force_gimple_operand in favor of gimple_build.\n+\tUse vect_get_new_ssa_name.\n+\t* tree-vect-stmts.c (vect_init_vector): Use vect_get_new_ssa_name.\n+\t(vectorizable_mask_load_store): Likewise.\n+\t(vectorizable_call): Likewise.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(vect_get_vec_def_for_stmt_copy): Remove redundant stmt.\n+\n 2015-10-15  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/67945"}, {"sha": "755b5a17e50d79c47980dbb7387e1261606048d8", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=0e22bb5ad3e0a5e08090487cec3ba8413f516a29", "patch": "@@ -3897,6 +3897,41 @@ vect_get_new_vect_var (tree type, enum vect_var_kind var_kind, const char *name)\n   return new_vect_var;\n }\n \n+/* Like vect_get_new_vect_var but return an SSA name.  */\n+\n+tree\n+vect_get_new_ssa_name (tree type, enum vect_var_kind var_kind, const char *name)\n+{\n+  const char *prefix;\n+  tree new_vect_var;\n+\n+  switch (var_kind)\n+  {\n+  case vect_simple_var:\n+    prefix = \"vect\";\n+    break;\n+  case vect_scalar_var:\n+    prefix = \"stmp\";\n+    break;\n+  case vect_pointer_var:\n+    prefix = \"vectp\";\n+    break;\n+  default:\n+    gcc_unreachable ();\n+  }\n+\n+  if (name)\n+    {\n+      char* tmp = concat (prefix, \"_\", name, NULL);\n+      new_vect_var = make_temp_ssa_name (type, NULL, tmp);\n+      free (tmp);\n+    }\n+  else\n+    new_vect_var = make_temp_ssa_name (type, NULL, prefix);\n+\n+  return new_vect_var;\n+}\n+\n /* Duplicate ptr info and set alignment/misaligment on NAME from DR.  */\n \n static void"}, {"sha": "32c54a78d88e88a04985725e9114b38e5b04902b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 18, "deletions": 36, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=0e22bb5ad3e0a5e08090487cec3ba8413f516a29", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\"\n #include \"target.h\"\n+#include \"gimple-fold.h\"\n \n /* Loop Vectorization Pass.\n \n@@ -3341,9 +3342,8 @@ get_initial_def_for_induction (gimple *iv_phi)\n   struct loop *iv_loop;\n   basic_block new_bb;\n   tree new_vec, vec_init, vec_step, t;\n-  tree new_var;\n   tree new_name;\n-  gimple *init_stmt, *new_stmt;\n+  gimple *new_stmt;\n   gphi *induction_phi;\n   tree induc_def, vec_def, vec_dest;\n   tree init_expr, step_expr;\n@@ -3353,7 +3353,7 @@ get_initial_def_for_induction (gimple *iv_phi)\n   tree expr;\n   stmt_vec_info phi_info = vinfo_for_stmt (iv_phi);\n   bool nested_in_vect_loop = false;\n-  gimple_seq stmts = NULL;\n+  gimple_seq stmts;\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n   gimple *exit_phi;\n@@ -3394,9 +3394,8 @@ get_initial_def_for_induction (gimple *iv_phi)\n   gcc_assert (ncopies >= 1);\n \n   /* Convert the step to the desired type.  */\n-  step_expr = force_gimple_operand (fold_convert (TREE_TYPE (vectype),\n-\t\t\t\t\t\t  step_expr),\n-\t\t\t\t    &stmts, true, NULL_TREE);\n+  stmts = NULL;\n+  step_expr = gimple_convert (&stmts, TREE_TYPE (vectype), step_expr);\n   if (stmts)\n     {\n       new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n@@ -3417,14 +3416,13 @@ get_initial_def_for_induction (gimple *iv_phi)\n       if (!useless_type_conversion_p (vectype, TREE_TYPE (vec_init)))\n \t{\n \t  new_stmt\n-\t    = gimple_build_assign (vect_get_new_vect_var (vectype,\n+\t    = gimple_build_assign (vect_get_new_ssa_name (vectype,\n \t\t\t\t\t\t\t  vect_simple_var,\n \t\t\t\t\t\t\t  \"vec_iv_\"),\n \t\t\t\t   VIEW_CONVERT_EXPR,\n \t\t\t\t   build1 (VIEW_CONVERT_EXPR, vectype,\n \t\t\t\t\t   vec_init));\n-\t  vec_init = make_ssa_name (gimple_assign_lhs (new_stmt), new_stmt);\n-\t  gimple_assign_set_lhs (new_stmt, vec_init);\n+\t  vec_init = gimple_assign_lhs (new_stmt);\n \t  new_bb = gsi_insert_on_edge_immediate (loop_preheader_edge (iv_loop),\n \t\t\t\t\t\t new_stmt);\n \t  gcc_assert (!new_bb);\n@@ -3438,43 +3436,27 @@ get_initial_def_for_induction (gimple *iv_phi)\n \n       /* iv_loop is the loop to be vectorized. Create:\n \t vec_init = [X, X+S, X+2*S, X+3*S] (S = step_expr, X = init_expr)  */\n-      new_var = vect_get_new_vect_var (TREE_TYPE (vectype),\n-\t\t\t\t       vect_scalar_var, \"var_\");\n-      new_name = force_gimple_operand (fold_convert (TREE_TYPE (vectype),\n-\t\t\t\t\t\t     init_expr),\n-\t\t\t\t       &stmts, false, new_var);\n-      if (stmts)\n-\t{\n-\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t  gcc_assert (!new_bb);\n-\t}\n+      stmts = NULL;\n+      new_name = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n \n       vec_alloc (v, nunits);\n       bool constant_p = is_gimple_min_invariant (new_name);\n       CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, new_name);\n       for (i = 1; i < nunits; i++)\n \t{\n \t  /* Create: new_name_i = new_name + step_expr  */\n-\t  new_name = fold_build2 (PLUS_EXPR, TREE_TYPE (new_name),\n-\t\t\t\t  new_name, step_expr);\n+\t  new_name = gimple_build (&stmts, PLUS_EXPR, TREE_TYPE (new_name),\n+\t\t\t\t   new_name, step_expr);\n \t  if (!is_gimple_min_invariant (new_name))\n-\t    {\n-\t      init_stmt = gimple_build_assign (new_var, new_name);\n-\t      new_name = make_ssa_name (new_var, init_stmt);\n-\t      gimple_assign_set_lhs (init_stmt, new_name);\n-\t      new_bb = gsi_insert_on_edge_immediate (pe, init_stmt);\n-\t      gcc_assert (!new_bb);\n-\t      if (dump_enabled_p ())\n-\t\t{\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t   \"created new init_stmt: \");\n-\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, init_stmt, 0);\n-                  dump_printf (MSG_NOTE, \"\\n\");\n-\t\t}\n-\t      constant_p = false;\n-\t    }\n+\t    constant_p = false;\n \t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, new_name);\n \t}\n+      if (stmts)\n+\t{\n+\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t  gcc_assert (!new_bb);\n+\t}\n+\n       /* Create a vector from [new_name_0, new_name_1, ..., new_name_nunits-1]  */\n       if (constant_p)\n \tnew_vec = build_vector_from_ctor (vectype, v);"}, {"sha": "1386dc05549bfa39acf0f1c2c11d6f89895e8dd1", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=0e22bb5ad3e0a5e08090487cec3ba8413f516a29", "patch": "@@ -1319,13 +1319,10 @@ vect_init_vector (gimple *stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n       val = build_vector_from_val (type, val);\n     }\n \n-  new_var = vect_get_new_vect_var (type, vect_simple_var, \"cst_\");\n-  init_stmt = gimple_build_assign  (new_var, val);\n-  new_temp = make_ssa_name (new_var, init_stmt);\n-  gimple_assign_set_lhs (init_stmt, new_temp);\n+  new_temp = vect_get_new_ssa_name (type, vect_simple_var, \"cst_\");\n+  init_stmt = gimple_build_assign  (new_temp, val);\n   vect_init_vector_1 (stmt, init_stmt, gsi);\n-  vec_oprnd = gimple_assign_lhs (init_stmt);\n-  return vec_oprnd;\n+  return new_temp;\n }\n \n \n@@ -1509,7 +1506,6 @@ vect_get_vec_def_for_stmt_copy (enum vect_def_type dt, tree vec_oprnd)\n   gcc_assert (def_stmt_info);\n   vec_stmt_for_operand = STMT_VINFO_RELATED_STMT (def_stmt_info);\n   gcc_assert (vec_stmt_for_operand);\n-  vec_oprnd = gimple_get_lhs (vec_stmt_for_operand);\n   if (gimple_code (vec_stmt_for_operand) == GIMPLE_PHI)\n     vec_oprnd = PHI_RESULT (vec_stmt_for_operand);\n   else\n@@ -1888,8 +1884,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    {\n \t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op))\n \t\t\t  == TYPE_VECTOR_SUBPARTS (idxtype));\n-\t      var = vect_get_new_vect_var (idxtype, vect_simple_var, NULL);\n-\t      var = make_ssa_name (var);\n+\t      var = vect_get_new_ssa_name (idxtype, vect_simple_var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n \t      new_stmt\n \t\t= gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n@@ -1915,9 +1910,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t{\n \t\t  gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (mask_op))\n \t\t\t      == TYPE_VECTOR_SUBPARTS (masktype));\n-\t\t  var = vect_get_new_vect_var (masktype, vect_simple_var,\n-\t\t\t\t\t       NULL);\n-\t\t  var = make_ssa_name (var);\n+\t\t  var = vect_get_new_ssa_name (masktype, vect_simple_var);\n \t\t  mask_op = build1 (VIEW_CONVERT_EXPR, masktype, mask_op);\n \t\t  new_stmt\n \t\t    = gimple_build_assign (var, VIEW_CONVERT_EXPR, mask_op);\n@@ -1934,8 +1927,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    {\n \t      gcc_assert (TYPE_VECTOR_SUBPARTS (vectype)\n \t\t\t  == TYPE_VECTOR_SUBPARTS (rettype));\n-\t      var = vect_get_new_vect_var (rettype, vect_simple_var, NULL);\n-\t      op = make_ssa_name (var, new_stmt);\n+\t      op = vect_get_new_ssa_name (rettype, vect_simple_var);\n \t      gimple_call_set_lhs (new_stmt, op);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      var = make_ssa_name (vec_dest);\n@@ -2379,14 +2371,11 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\tv[k] = build_int_cst (unsigned_type_node, j * nunits_out + k);\n \t      tree cst = build_vector (vectype_out, v);\n \t      tree new_var\n-\t\t= vect_get_new_vect_var (vectype_out, vect_simple_var, \"cst_\");\n+\t\t= vect_get_new_ssa_name (vectype_out, vect_simple_var, \"cst_\");\n \t      gimple *init_stmt = gimple_build_assign (new_var, cst);\n-\t      new_temp = make_ssa_name (new_var, init_stmt);\n-\t      gimple_assign_set_lhs (init_stmt, new_temp);\n \t      vect_init_vector_1 (stmt, init_stmt, NULL);\n \t      new_temp = make_ssa_name (vec_dest);\n-\t      new_stmt = gimple_build_assign (new_temp,\n-\t\t\t\t\t      gimple_assign_lhs (init_stmt));\n+\t      new_stmt = gimple_build_assign (new_temp, new_var);\n \t    }\n \t  else\n \t    {\n@@ -5350,8 +5339,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    {\n \t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (src))\n \t\t\t  == TYPE_VECTOR_SUBPARTS (srctype));\n-\t      var = vect_get_new_vect_var (srctype, vect_simple_var, NULL);\n-\t      var = make_ssa_name (var);\n+\t      var = vect_get_new_ssa_name (srctype, vect_simple_var);\n \t      src = build1 (VIEW_CONVERT_EXPR, srctype, src);\n \t      new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, src);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -5362,8 +5350,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    {\n \t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op))\n \t\t\t  == TYPE_VECTOR_SUBPARTS (idxtype));\n-\t      var = vect_get_new_vect_var (idxtype, vect_simple_var, NULL);\n-\t      var = make_ssa_name (var);\n+\t      var = vect_get_new_ssa_name (idxtype, vect_simple_var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n \t      new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -6408,8 +6395,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    {\n \t      gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (op))\n \t\t\t  == TYPE_VECTOR_SUBPARTS (idxtype));\n-\t      var = vect_get_new_vect_var (idxtype, vect_simple_var, NULL);\n-\t      var = make_ssa_name (var);\n+\t      var = vect_get_new_ssa_name (idxtype, vect_simple_var);\n \t      op = build1 (VIEW_CONVERT_EXPR, idxtype, op);\n \t      new_stmt\n \t\t= gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n@@ -6424,8 +6410,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    {\n \t      gcc_assert (TYPE_VECTOR_SUBPARTS (vectype)\n \t\t\t  == TYPE_VECTOR_SUBPARTS (rettype));\n-\t      var = vect_get_new_vect_var (rettype, vect_simple_var, NULL);\n-\t      op = make_ssa_name (var, new_stmt);\n+\t      op = vect_get_new_ssa_name (rettype, vect_simple_var);\n \t      gimple_call_set_lhs (new_stmt, op);\n \t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t      var = make_ssa_name (vec_dest);"}, {"sha": "bdd8e6aec328a228ed94e2b9d72ef8dd82ab7988", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e22bb5ad3e0a5e08090487cec3ba8413f516a29/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=0e22bb5ad3e0a5e08090487cec3ba8413f516a29", "patch": "@@ -1020,6 +1020,8 @@ extern void vect_transform_grouped_load (gimple *, vec<tree> , int,\n                                          gimple_stmt_iterator *);\n extern void vect_record_grouped_load_vectors (gimple *, vec<tree> );\n extern tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n+extern tree vect_get_new_ssa_name (tree, enum vect_var_kind,\n+\t\t\t\t   const char * = NULL);\n extern tree vect_create_addr_base_for_vector_ref (gimple *, gimple_seq *,\n \t\t\t\t\t\t  tree, struct loop *,\n \t\t\t\t\t\t  tree = NULL_TREE);"}]}