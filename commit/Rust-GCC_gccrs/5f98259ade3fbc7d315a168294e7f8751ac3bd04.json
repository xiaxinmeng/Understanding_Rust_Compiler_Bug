{"sha": "5f98259ade3fbc7d315a168294e7f8751ac3bd04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY5ODI1OWFkZTNmYmM3ZDMxNWExNjgyOTRlN2Y4NzUxYWMzYmQwNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-12-05T12:36:48Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-12-05T12:36:48Z"}, "message": "vmsdbg.h, [...]: Add documentation and minor cleanups.\n\n\t* vmsdbg.h, vmsdbgout.c: Add documentation and minor cleanups.\n\t* doc/invoke.texi: Add -gvms.\n\t* doc/passes.texi: Add mention of vmsdbgout.c.\n\t* doc/tm.texi: Document VMS debugging output.\n\nCo-Authored-By: Douglas B Rupp <rupp@gnat.com>\n\nFrom-SVN: r47668", "tree": {"sha": "196ac20d7a6c33f8318e4f2a28b07583cecf907c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/196ac20d7a6c33f8318e4f2a28b07583cecf907c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f98259ade3fbc7d315a168294e7f8751ac3bd04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f98259ade3fbc7d315a168294e7f8751ac3bd04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f98259ade3fbc7d315a168294e7f8751ac3bd04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f98259ade3fbc7d315a168294e7f8751ac3bd04/comments", "author": null, "committer": null, "parents": [{"sha": "33afb1b72b8399bd65973453965690275d7ac0a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33afb1b72b8399bd65973453965690275d7ac0a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33afb1b72b8399bd65973453965690275d7ac0a9"}], "stats": {"total": 507, "additions": 344, "deletions": 163}, "files": [{"sha": "dc6a8bedd9b5157ab6583bd576a5ccc1d7a351d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f98259ade3fbc7d315a168294e7f8751ac3bd04", "patch": "@@ -1,3 +1,11 @@\n+Wed Dec  5 07:27:42 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\t\t\t  Douglas B. Rupp  <rupp@gnat.com>\n+\t\n+\t* vmsdbg.h, vmsdbgout.c: Add documentation and minor cleanups.\n+\t* doc/invoke.texi: Add -gvms.\n+\t* doc/passes.texi: Add mention of vmsdbgout.c.\n+\t* doc/tm.texi: Document VMS debugging output.\n+\n Wed Dec  5 06:26:27 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* function.h (tree, rtx): Remove no-longer-needed definitions."}, {"sha": "0bb76df305c2b4415736b1c9454c919e8b0a3c34", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5f98259ade3fbc7d315a168294e7f8751ac3bd04", "patch": "@@ -248,7 +248,7 @@ in the following sections.\n -fmem-report  -fpretend-float @gol\n -fprofile-arcs  -ftest-coverage  -ftime-report @gol\n -g  -g@var{level}  -gcoff  -gdwarf  -gdwarf-1  -gdwarf-1+  -gdwarf-2 @gol\n--ggdb  -gstabs  -gstabs+  -gxcoff  -gxcoff+ @gol\n+-ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol\n -p  -pg  -print-file-name=@var{library}  -print-libgcc-file-name @gol\n -print-multi-directory  -print-multi-lib @gol\n -print-prog-name=@var{program}  -print-search-dirs  -Q @gol\n@@ -2608,8 +2608,8 @@ makes debugging work better in GDB but will probably make other debuggers\n crash or\n refuse to read the program.  If you want to control for certain whether\n to generate the extra information, use @option{-gstabs+}, @option{-gstabs},\n-@option{-gxcoff+}, @option{-gxcoff}, @option{-gdwarf-1+}, or @option{-gdwarf-1}\n-(see below).\n+@option{-gxcoff+}, @option{-gxcoff}, @option{-gdwarf-1+}, @option{-gdwarf-1},\n+or @option{-gvms} (see below).\n \n Unlike most other C compilers, GCC allows you to use @option{-g} with\n @option{-O}.  The shortcuts taken by optimized code may occasionally\n@@ -2684,13 +2684,19 @@ crash or refuse to read the program.\n Produce debugging information in DWARF version 2 format (if that is\n supported).  This is the format used by DBX on IRIX 6.\n \n+@item -gvms\n+@opindex gvms\n+Produce debugging information in VMS debug format (if that is\n+supported).  This is the format used by DEBUG on VMS systems.\n+\n @item -g@var{level}\n @itemx -ggdb@var{level}\n @itemx -gstabs@var{level}\n @itemx -gcoff@var{level}\n @itemx -gxcoff@var{level}\n @itemx -gdwarf@var{level}\n @itemx -gdwarf-2@var{level}\n+@itemx -gvms@var{level}\n Request debugging information and also use @var{level} to specify how\n much information.  The default level is 2.\n "}, {"sha": "771734139acc7eeb7e10f8b9f0484d95d74d56ca", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=5f98259ade3fbc7d315a168294e7f8751ac3bd04", "patch": "@@ -600,8 +600,9 @@ Debugging information output.  This is run after final because it must\n output the stack slot offsets for pseudo registers that did not get\n hard registers.  Source files are @file{dbxout.c} for DBX symbol table\n format, @file{sdbout.c} for SDB symbol table format,  @file{dwarfout.c}\n-for DWARF symbol table format, and the files @file{dwarf2out.c} and\n-@file{dwarf2asm.c} for DWARF2 symbol table format.\n+for DWARF symbol table format, files @file{dwarf2out.c} and\n+@file{dwarf2asm.c} for DWARF2 symbol table format, and @file{vmsdbgout.c}\n+for VMS debug symbol table format.\n @end itemize\n \n Some additional files are used by all or many passes:"}, {"sha": "4c3da22b1b6e1f6c9fafae71797d32d1923b7ab6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=5f98259ade3fbc7d315a168294e7f8751ac3bd04", "patch": "@@ -7367,6 +7367,7 @@ This describes how to specify debugging information.\n * DBX Hooks::          Hook macros for varying DBX format.\n * File Names and DBX:: Macros controlling output of file names in DBX format.\n * SDB and DWARF::      Macros for SDB (COFF) and DWARF formats.\n+* VMS Debug::          Macros for VMS debug format.\n @end menu\n \n @node All Debuggers\n@@ -7417,8 +7418,8 @@ A C expression that returns the type of debugging output GCC should\n produce when the user specifies just @option{-g}.  Define\n this if you have arranged for GCC to support more than one format of\n debugging output.  Currently, the allowable values are @code{DBX_DEBUG},\n-@code{SDB_DEBUG}, @code{DWARF_DEBUG}, @code{DWARF2_DEBUG}, and\n-@code{XCOFF_DEBUG}.\n+@code{SDB_DEBUG}, @code{DWARF_DEBUG}, @code{DWARF2_DEBUG},\n+@code{XCOFF_DEBUG}, @code{VMS_DEBUG}, and @code{VMS_AND_DWARF2_DEBUG}.\n \n When the user specifies @option{-ggdb}, GCC normally also uses the\n value of this macro to select the debugging output format, but with two\n@@ -7429,7 +7430,8 @@ defined, GCC uses @code{DBX_DEBUG}.\n \n The value of this macro only affects the default debugging output; the\n user can always get a specific type of output by using @option{-gstabs},\n-@option{-gcoff}, @option{-gdwarf-1}, @option{-gdwarf-2}, or @option{-gxcoff}.\n+@option{-gcoff}, @option{-gdwarf-1}, @option{-gdwarf-2}, @option{-gxcoff},\n+or @option{-gvms}.\n @end table\n \n @node DBX Options\n@@ -7819,6 +7821,24 @@ enumeration tags that have not yet been seen to be handled.  Some\n assemblers choke if forward tags are used, while some require it.\n @end table\n \n+@need 2000\n+@node VMS Debug\n+@subsection Macros for VMS Debug Format\n+\n+@c prevent bad page break with this line\n+Here are macros for VMS debug format.\n+\n+@table @code\n+@findex VMS_DEBUGGING_INFO\n+@item VMS_DEBUGGING_INFO\n+Define this macro if GCC should produce debugging output for VMS\n+in response to the @option{-g} option.  The default behavior for VMS\n+is to generate minimal debug info for a traceback in the absence of\n+@option{-g} unless explicitly overridden with @option{-g0}.  This\n+behavior is controlled by @code{OPTIMIZATION_OPTIONS} and\n+@code{OVERRIDE_OPTIONS}.\n+@end table\n+\n @node Cross-compilation\n @section Cross Compilation and Floating Point\n @cindex cross compilation and floating point"}, {"sha": "4d48d7989cab2fc4f895133ac008e156d8a8216b", "filename": "gcc/vmsdbg.h", "status": "modified", "additions": 164, "deletions": 84, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2Fvmsdbg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2Fvmsdbg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbg.h?ref=5f98259ade3fbc7d315a168294e7f8751ac3bd04", "patch": "@@ -1,109 +1,171 @@\n-/* This file contains definitions for the data structures and codes used in\n-   VMS debugging information.  */\n+/* Definitions for the data structures and codes used in VMS debugging.  */\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n \n-#ifndef VMSDBG_H\n-#define VMSDBG_H 1\n-\t\n-typedef unsigned short int DST_DTYPE;\n-#define DST_K_SOURCE 155\n-#define DST_K_PROLOG 162\n-#define DST_K_BLKBEG 176\n-#define DST_K_BLKEND 177\n-#define DST_K_LINE_NUM 185\n-#define DST_K_MODBEG 188\n-#define DST_K_MODEND 189\n-#define DST_K_RTNBEG 190\n-#define DST_K_RTNEND 191\n-\n-typedef struct _DST_HEADER {\n-  union  {\n-    unsigned short int dst_w_length;\n-    unsigned short int dst_x_length;\n-  } dst__header_length;\n-  union  {\n-    DST_DTYPE dst_w_type;\n-    DST_DTYPE dst_x_type;\n-  } dst__header_type;\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef GCC_VMSDBG_H\n+#define GCC_VMSDBG_H 1\n+\n+/*  We define types and constants used in VMS Debug output.  Note that the\n+    structs only approximate the output that is written.  We write the output\n+    explicitly, field by field.  This output would only agree with the\n+    structs in this file if no padding were done.  The sizes after each\n+    struct are the size actually written, which is usually smaller than the\n+    size of the struct.  */\n+\n+/* Header type codes.  */\n+typedef enum _DST_TYPE {DST_K_SOURCE = 155, DST_K_PROLOG = 162,\n+\t\t\tDST_K_BLKBEG = 176, DST_K_BLKEND = 177,\n+\t\t\tDST_K_LINE_NUM = 185, DST_K_MODBEG = 188,\n+\t\t\tDST_K_MODEND = 189, DST_K_RTNBEG = 190,\n+\t\t\tDST_K_RTNEND = 191} DST_DTYPE;\n+\n+/* Header.  */\n+\n+typedef struct _DST_HEADER\n+{\n+  union\n+    {\n+      unsigned short int dst_w_length;\n+      unsigned short int dst_x_length;\n+    } dst__header_length;\n+  union\n+    {\n+      ENUM_BITFIELD (_DST_DTYPE) dst_w_type : 16;\n+      ENUM_BITFIELD (_DST_DTYPE) dst_x_type : 16;\n+    } dst__header_type;\n } DST_HEADER;\n-#define DST_K_DST_HEADER_SIZE 4\n-\t\n-typedef unsigned int DST_LANGUAGE;\n-#define DST_K_FORTRAN 1\n-#define DST_K_C 7\n-#define DST_K_ADA 9\n-#define DST_K_UNKNOWN 10\n-#define DST_K_CXX 15\n-typedef struct _DST_MODULE_BEGIN {\n+#define DST_K_DST_HEADER_SIZE sizeof 4\n+\n+/* Language type codes. */\n+typedef enum _DST_LANGUAGE {DST_K_FORTRAN = 1, DST_K_C = 7, DST_K_ADA = 9,\n+\t\t\t    DST_K_UNKNOWN = 10, DST_K_CXX = 15} DST_LANGUAGE;\n+\n+/* Module header (a module is the result of a single compilation). */\n+\n+typedef struct _DST_MODULE_BEGIN\n+{\n   DST_HEADER dst_a_modbeg_header;\n-  struct  {\n-    unsigned dst_v_modbeg_hide : 1;\n-    unsigned dst_v_modbeg_version : 1;\n-    unsigned dst_v_modbeg_unused : 6;\n-  } dst_b_modbeg_flags;\n+  struct\n+    {\n+      unsigned dst_v_modbeg_hide : 1;\n+      unsigned dst_v_modbeg_version : 1;\n+      unsigned dst_v_modbeg_unused : 6;\n+    } dst_b_modbeg_flags;\n   unsigned char dst_b_modbeg_unused;\n   DST_LANGUAGE dst_l_modbeg_language;\n   unsigned short int dst_w_version_major;\n   unsigned short int dst_w_version_minor;\n   unsigned char dst_b_modbeg_name;\n } DST_MODULE_BEGIN;\n #define DST_K_MODBEG_SIZE 15\n-\t\n-typedef struct _DST_MB_TRLR {\n+\n+/* Module trailer.  */\n+\n+typedef struct _DST_MB_TRLR\n+{\n   unsigned char dst_b_compiler;\n } DST_MB_TRLR;\n+\n #define DST_K_MB_TRLR_SIZE 1\n+\n #define DST_K_VERSION_MAJOR 1\n #define DST_K_VERSION_MINOR 13\n-typedef struct _DST_MODULE_END {\n+\n+typedef struct _DST_MODULE_END\n+{\n   DST_HEADER dst_a_modend_header;\n } DST_MODULE_END;\n-#define DST_K_MODEND_SIZE 4\n-typedef struct _DST_ROUTINE_BEGIN {\n+#define DST_K_MODEND_SIZE sizeof 4\n+\n+/* Routine header. */\n+\n+typedef struct _DST_ROUTINE_BEGIN\n+{\n   DST_HEADER dst_a_rtnbeg_header;\n-  struct  {\n-    unsigned dst_v_rtnbeg_unused : 4;\n-    unsigned dst_v_rtnbeg_unalloc : 1;\n-    unsigned dst_v_rtnbeg_prototype : 1;\n-    unsigned dst_v_rtnbeg_inlined : 1;\n-    unsigned dst_v_rtnbeg_no_call : 1;\n-  } dst_b_rtnbeg_flags;\n+  struct\n+    {\n+      unsigned dst_v_rtnbeg_unused : 4;\n+      unsigned dst_v_rtnbeg_unalloc : 1;\n+      unsigned dst_v_rtnbeg_prototype : 1;\n+      unsigned dst_v_rtnbeg_inlined : 1;\n+      unsigned dst_v_rtnbeg_no_call : 1;\n+    } dst_b_rtnbeg_flags;\n   int *dst_l_rtnbeg_address;\n   int *dst_l_rtnbeg_pd_address;\n   unsigned char dst_b_rtnbeg_name;\n } DST_ROUTINE_BEGIN;\n #define DST_K_RTNBEG_SIZE 14\n-typedef struct _DST_ROUTINE_END {\n+\n+/* Routine trailer */\n+\n+typedef struct _DST_ROUTINE_END\n+{\n   DST_HEADER dst_a_rtnend_header;\n   char dst_b_rtnend_unused;\n   unsigned int dst_l_rtnend_size;\n } DST_ROUTINE_END;\n #define DST_K_RTNEND_SIZE 9\n-typedef struct _DST_BLOCK_BEGIN {\n+\n+/* Block header. */\n+\n+typedef struct _DST_BLOCK_BEGIN\n+{\n   DST_HEADER dst_a_blkbeg_header;\n   unsigned char dst_b_blkbeg_unused;\n   int *dst_l_blkbeg_address;\n   unsigned char dst_b_blkbeg_name;\n } DST_BLOCK_BEGIN;\n #define DST_K_BLKBEG_SIZE 10\n-typedef struct _DST_BLOCK_END {\n+\n+/* Block trailer. */\n+\n+typedef struct _DST_BLOCK_END\n+{\n   DST_HEADER dst_a_blkend_header;\n   unsigned char dst_b_blkend_unused;\n   unsigned int dst_l_blkend_size;\n } DST_BLOCK_END;\n #define DST_K_BLKEND_SIZE 9\n-typedef struct _DST_LINE_NUM_HEADER {\n+\n+/* Line number header.  */\n+\n+typedef struct _DST_LINE_NUM_HEADER\n+{\n   DST_HEADER dst_a_line_num_header;\n } DST_LINE_NUM_HEADER;\n #define DST_K_LINE_NUM_HEADER_SIZE 4\n \n-typedef struct _DST_PCLINE_COMMANDS {\n+/* PC to Line number correlation.  */\n+\n+typedef struct _DST_PCLINE_COMMANDS\n+{\n   char dst_b_pcline_command;\n-  union  {\n-    unsigned int dst_l_pcline_unslong;\n-    unsigned short int dst_w_pcline_unsword;\n-    unsigned char dst_b_pcline_unsbyte;\n-  } dst_a_pcline_access_fields;\n+  union\n+    {\n+      unsigned int dst_l_pcline_unslong;\n+      unsigned short int dst_w_pcline_unsword;\n+      unsigned char dst_b_pcline_unsbyte;\n+    } dst_a_pcline_access_fields;\n } DST_PCLINE_COMMANDS;\n+\n+/* PC and Line number correlation codes.  */\n+\n #define DST_K_PCLINE_COMMANDS_SIZE 5\n #define DST_K_PCLINE_COMMANDS_SIZE_MIN 2\n #define DST_K_PCLINE_COMMANDS_SIZE_MAX 5\n@@ -118,10 +180,16 @@ typedef struct _DST_PCLINE_COMMANDS {\n #define DST_K_INCR_LINUM_L 18\n #define DST_K_SET_LINUM_B 19\n #define DST_K_SET_LINUM_L 20\n-typedef struct _DST_SOURCE_CORR {\n+\n+/* Source file correlation header.  */\n+\n+typedef struct _DST_SOURCE_CORR\n+{\n   DST_HEADER dst_a_source_corr_header;\n } DST_SOURCE_CORR;\n #define DST_K_SOURCE_CORR_HEADER_SIZE 4\n+\n+/* Source file correlation codes.  */\n \t\n #define DST_K_SRC_DECLFILE 1\n #define DST_K_SRC_SETFILE 2\n@@ -135,39 +203,51 @@ typedef struct _DST_SOURCE_CORR {\n #define DST_K_SRC_FORMFEED 16\n #define DST_K_SRC_MIN_CMD 1\n #define DST_K_SRC_MAX_CMD 16\n-typedef struct _DST_SRC_COMMAND {\n+\n+/* Source file header.  */\n+\n+typedef struct _DST_SRC_COMMAND\n+{\n   unsigned char dst_b_src_command;\n-  union  {\n-    struct  {\n-      unsigned char dst_b_src_df_length;\n-      unsigned char dst_b_src_df_flags;\n-      unsigned short int dst_w_src_df_fileid;\n+  union\n+    {\n+      struct\n+\t{\n+\t  unsigned char dst_b_src_df_length;\n+\t  unsigned char dst_b_src_df_flags;\n+\t  unsigned short int dst_w_src_df_fileid;\n #ifdef __GNUC__\n-      long long dst_q_src_df_rms_cdt;\n+\t  long long dst_q_src_df_rms_cdt;\n #else\n-      __int64 dst_q_src_df_rms_cdt;\n+\t  __int64 dst_q_src_df_rms_cdt;\n #endif\n-      unsigned int dst_l_src_df_rms_ebk;\n-      unsigned short int dst_w_src_df_rms_ffb;\n-      unsigned char dst_b_src_df_rms_rfo;\n-      unsigned char dst_b_src_df_filename;\n-    } dst_a_src_decl_src;\n-    unsigned int dst_l_src_unslong;\n-    unsigned short int dst_w_src_unsword;\n-    unsigned char dst_b_src_unsbyte;\n-  } dst_a_src_cmd_fields;\n+\t  unsigned int dst_l_src_df_rms_ebk;\n+\t  unsigned short int dst_w_src_df_rms_ffb;\n+\t  unsigned char dst_b_src_df_rms_rfo;\n+\t  unsigned char dst_b_src_df_filename;\n+\t} dst_a_src_decl_src;\n+      unsigned int dst_l_src_unslong;\n+      unsigned short int dst_w_src_unsword;\n+      unsigned char dst_b_src_unsbyte;\n+    } dst_a_src_cmd_fields;\n } DST_SRC_COMMAND;\n #define DST_K_SRC_COMMAND_SIZE 21\n-\t\n-typedef struct _DST_SRC_CMDTRLR {\n+\n+/* Source file trailer.  */\n+\n+typedef struct _DST_SRC_CMDTRLR\n+{\n   unsigned char dst_b_src_df_libmodname;\n } DST_SRC_CMDTRLR;\n #define DST_K_SRC_CMDTRLR_SIZE 1\n-\t\n-typedef struct _DST_PROLOG {\n+\n+/* Prolog header.  */\n+\n+typedef struct _DST_PROLOG\n+{\n   DST_HEADER dst_a_prolog_header;\n   unsigned int dst_l_prolog_bkpt_addr;\n } DST_PROLOG;\n #define DST_K_PROLOG_SIZE 8\n \t\n-#endif /* VMSDBG_H */\n+#endif /* GCC_VMSDBG_H */"}, {"sha": "257d5066f04f2f4be4504ed2956e40e6a8d55ae3", "filename": "gcc/vmsdbgout.c", "status": "modified", "additions": 137, "deletions": 71, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2Fvmsdbgout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f98259ade3fbc7d315a168294e7f8751ac3bd04/gcc%2Fvmsdbgout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvmsdbgout.c?ref=5f98259ade3fbc7d315a168294e7f8751ac3bd04", "patch": "@@ -171,7 +171,6 @@ static void vmsdbgout_decl\t\tPARAMS ((tree));\n static void vmsdbgout_global_decl\tPARAMS ((tree));\n static void vmsdbgout_abstract_function PARAMS ((tree));\n \n-\n /* The debug hooks structure.  */\n \n struct gcc_debug_hooks vmsdbg_debug_hooks\n@@ -523,157 +522,190 @@ addr_const_to_string (str, x)\n     }\n }\n \n+/* Output the debug header HEADER.  Also output COMMENT if flag_verbose_asm is\n+   set.  Return the header size.  Just return the size if DOSIZEONLY is\n+   non-zero. */\n+\n static int\n write_debug_header (header, comment, dosizeonly)\n      DST_HEADER *header;\n      const char *comment;\n      int dosizeonly;\n {\n-  if (dosizeonly)\n-    return 4;\n+  if (!dosizeonly)\n+    {\n+      ASM_OUTPUT_DEBUG_DATA2 (asm_out_file,\n+\t\t\t      header->dst__header_length.dst_w_length);\n+\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s record length\", ASM_COMMENT_START);\n+      fputc ('\\n', asm_out_file);\n \n-  ASM_OUTPUT_DEBUG_DATA2 (asm_out_file,\n-\t\t\t  header->dst__header_length.dst_w_length);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s record length\", ASM_COMMENT_START);\n-  fputc ('\\n', asm_out_file);\n+      ASM_OUTPUT_DEBUG_DATA2 (asm_out_file,\n+\t\t\t      header->dst__header_type.dst_w_type);\n \n-  ASM_OUTPUT_DEBUG_DATA2 (asm_out_file,\n-\t\t\t  header->dst__header_type.dst_w_type);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s record type (%s)\", ASM_COMMENT_START,\n-\t     comment);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s record type (%s)\", ASM_COMMENT_START,\n+\t\t comment);\n \n-  fputc ('\\n', asm_out_file);\n+      fputc ('\\n', asm_out_file);\n+    }\n \n   return 4;\n }\n \n+/* Output the address of SYMBOL.  Also output COMMENT if flag_verbose_asm is\n+   set.  Return the address size.  Just return the size if DOSIZEONLY is\n+   non-zero. */\n+\n static int\n write_debug_addr (symbol, comment, dosizeonly)\n      char *symbol;\n      const char *comment;\n      int dosizeonly;\n {\n-  if (dosizeonly)\n-    return PTR_SIZE;\n+  if (!dosizeonly)\n+    {\n+      ASM_OUTPUT_DEBUG_ADDR (asm_out_file, symbol);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+      fputc ('\\n', asm_out_file);\n+    }\n \n-  ASM_OUTPUT_DEBUG_ADDR (asm_out_file, symbol);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n-  fputc ('\\n', asm_out_file);\n-  \n   return PTR_SIZE;\n }\n \n+/* Output the single byte DATA1.  Also output COMMENT if flag_verbose_asm is\n+   set.  Return the data size.  Just return the size if DOSIZEONLY is\n+   non-zero. */\n+\n static int\n write_debug_data1 (data1, comment, dosizeonly)\n      unsigned int data1;\n      const char *comment;\n      int dosizeonly;\n {\n-  if (dosizeonly)\n-    return 1;\n+  if (!dosizeonly)\n+    {\n+      ASM_OUTPUT_DEBUG_DATA1 (asm_out_file, data1);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+      fputc ('\\n', asm_out_file);\n+    }\n \n-  ASM_OUTPUT_DEBUG_DATA1 (asm_out_file, data1);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n-  fputc ('\\n', asm_out_file);\n-  \n   return 1;\n }\n \n+/* Output the single word DATA2.  Also output COMMENT if flag_verbose_asm is\n+   set.  Return the data size.  Just return the size if DOSIZEONLY is\n+   non-zero. */\n+\n static int\n write_debug_data2 (data2, comment, dosizeonly)\n      unsigned int data2;\n      const char *comment;\n      int dosizeonly;\n {\n-  if (dosizeonly)\n-    return 2;\n+  if (!dosizeonly)\n+    {\n+      ASM_OUTPUT_DEBUG_DATA2 (asm_out_file, data2);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+      fputc ('\\n', asm_out_file);\n+    }\n \n-  ASM_OUTPUT_DEBUG_DATA2 (asm_out_file, data2);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n-  fputc ('\\n', asm_out_file);\n-  \n   return 2;\n }\n \n+/* Output double word DATA4.  Also output COMMENT if flag_verbose_asm is set.\n+   Return the data size.  Just return the size if DOSIZEONLY is non-zero. */\n+\n static int\n write_debug_data4 (data4, comment, dosizeonly)\n      unsigned long data4;\n      const char *comment;\n      int dosizeonly;\n {\n-  if (dosizeonly)\n-    return 4;\n-\n-  ASM_OUTPUT_DEBUG_DATA4 (asm_out_file, data4);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n-  fputc ('\\n', asm_out_file);\n+  if (!dosizeonly)\n+    {\n+      ASM_OUTPUT_DEBUG_DATA4 (asm_out_file, data4);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+      fputc ('\\n', asm_out_file);\n+    }\n   \n   return 4;\n }\n \n+/* Output quad word DATA8.  Also output COMMENT if flag_verbose_asm is set.\n+   Return the data size.  Just return the size if DOSIZEONLY is non-zero.  */\n+\n static int\n write_debug_data8 (data8, comment, dosizeonly)\n      unsigned long long data8;\n      const char *comment;\n      int dosizeonly;\n {\n-  if (dosizeonly)\n-    return 8;\n+  if (!dosizeonly)\n+    {\n+      ASM_OUTPUT_DEBUG_DATA8 (asm_out_file, data8);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+      fputc ('\\n', asm_out_file);\n+    }\n \n-  ASM_OUTPUT_DEBUG_DATA8 (asm_out_file, data8);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n-  fputc ('\\n', asm_out_file);\n-  \n   return 8;\n }\n \n+/* Output the difference between LABEL1 and LABEL2.  Also output COMMENT if\n+   flag_verbose_asm is set.  Return the data size.  Just return the size if\n+   DOSIZEONLY is non-zero. */\n+\n static int\n write_debug_delta4 (label1, label2, comment, dosizeonly)\n      char *label1;\n      char *label2;\n      const char *comment;\n      int dosizeonly;\n {\n-  if (dosizeonly)\n-    return 4;\n+  if (!dosizeonly)\n+    {\n+      ASM_OUTPUT_DEBUG_DELTA4 (asm_out_file, label1, label2);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+      fputc ('\\n', asm_out_file);\n+    }\n \n-  ASM_OUTPUT_DEBUG_DELTA4(asm_out_file, label1, label2);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n-  fputc ('\\n', asm_out_file);\n-  \n   return 4;\n }\n \n+/* Output a character string STRING.  Also write COMMENT if flag_verbose_asm is\n+   set.  Return the string length.  Just return the length if DOSIZEONLY is\n+   non-zero. */\n+\n static int\n write_debug_string (string, comment, dosizeonly)\n      char *string;\n      const char *comment;\n      int dosizeonly;\n {\n-  if (dosizeonly)\n-    return strlen (string);\n-\n-  ASM_OUTPUT_DEBUG_STRING (asm_out_file, string);\n-  if (flag_verbose_asm)\n-    fprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n-  fputc ('\\n', asm_out_file);\n+  if (!dosizeonly)\n+    {\n+      ASM_OUTPUT_DEBUG_STRING (asm_out_file, string);\n+      if (flag_verbose_asm)\n+\tfprintf (asm_out_file, \"\\t%s %s\", ASM_COMMENT_START, comment);\n+      fputc ('\\n', asm_out_file);\n+    }\n   \n   return strlen (string);\n }\n \n-static int\n+/* Output a module begin header and return the header size.  Just return the\n+   size if DOSIZEONLY is non-zero. */\n+\n write_modbeg (dosizeonly)\n      int dosizeonly;\n {\n-\n   DST_MODULE_BEGIN modbeg;\n   DST_MB_TRLR mb_trlr;\n   int i;\n@@ -731,6 +763,9 @@ write_modbeg (dosizeonly)\n   return totsize;\n }\n \n+/* Output a module end trailer and return the trailer size.   Just return\n+   the size if DOSIZEONLY is non-zero. */\n+\n static int\n write_modend (dosizeonly)\n      int dosizeonly;\n@@ -748,6 +783,9 @@ write_modend (dosizeonly)\n   return totsize;\n }\n \n+/* Output a routine begin header routine RTNNUM and return the header size.\n+   Just return the size if DOSIZEONLY is non-zero. */\n+\n static int\n write_rtnbeg (rtnnum, dosizeonly)\n      int rtnnum;\n@@ -843,6 +881,9 @@ write_rtnbeg (rtnnum, dosizeonly)\n   return totsize;\n }\n \n+/* Output a routine end trailer for routine RTNNUM and return the header size.\n+   Just return the size if DOSIZEONLY is non-zero. */\n+\n static int\n write_rtnend (rtnnum, dosizeonly)\n      int rtnnum;\n@@ -884,6 +925,9 @@ write_rtnend (rtnnum, dosizeonly)\n  ((I) < 256 ? DST_K_INCR_LINUM \\\n   : (I) < 65536 ? DST_K_INCR_LINUM_W : DST_K_INCR_LINUM_L)\n \n+/* Output the PC to line number correlations and return the size.  Just return\n+   the size if DOSIZEONLY is non-zero */\n+\n static int\n write_pclines (dosizeonly)\n      int dosizeonly;\n@@ -1011,6 +1055,10 @@ write_pclines (dosizeonly)\n   return totsize;\n }\n \n+/* Output a source correlation for file FILEID using information saved in\n+   FILE_INFO_ENTRY and return the size.  Just return the size if DOSIZEONLY is\n+   non-zero. */\n+\n static int\n write_srccorr (fileid, file_info_entry, dosizeonly)\n      int fileid;\n@@ -1199,6 +1247,9 @@ write_srccorr (fileid, file_info_entry, dosizeonly)\n   return totsize;\n }\n \n+/* Output all the source correlation entries and return the size.  Just return\n+   the size if DOSIZEONLY is non-zero. */\n+\n static int\n write_srccorrs (dosizeonly)\n      int dosizeonly;\n@@ -1211,7 +1262,6 @@ write_srccorrs (dosizeonly)\n \n   return totsize;\n }     \n-\n \f\n /* Output a marker (i.e. a label) for the beginning of a function, before\n    the prologue.  */\n@@ -1303,6 +1353,8 @@ vmsdbgout_end_block (line, blocknum)\n     ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BLOCK_END_LABEL, blocknum);\n }\n \n+/* Not implemented in VMS Debug.  */\n+\n static bool\n vmsdbgout_ignore_block (block)\n      tree block;\n@@ -1315,6 +1367,8 @@ vmsdbgout_ignore_block (block)\n   return retval;\n }\n \n+/* Add an entry for function DECL into the func_table.  */\n+\n static void\n vmsdbgout_begin_function (decl)\n      tree decl;\n@@ -1337,6 +1391,9 @@ vmsdbgout_begin_function (decl)\n \n static char fullname_buff [4096];\n \n+/* Return the full file specification for FILENAME.  The specification must be\n+   in VMS syntax in order to be processed by VMS Debug. */\n+\n static char *\n full_name (filename)\n      const char *filename;\n@@ -1362,9 +1419,8 @@ full_name (filename)\n /* Lookup a filename (in the list of filenames that we know about here in\n    vmsdbgout.c) and return its \"index\".  The index of each (known) filename is\n    just a unique number which is associated with only that one filename.  We\n-   need such numbers for the sake of generating labels (in the .debug_sfnames\n-   section) and references to those files numbers (in the .debug_srcinfo\n-   and.debug_macinfo sections).  If the filename given as an argument is not\n+   need such numbers for the sake of generating labels  and references\n+   to those files numbers.  If the filename given as an argument is not\n    found in our current list, add it to the list and assign it the next\n    available unique index number.  In order to speed up searches, we remember\n    the index of the filename was looked up last.  This handles the majority of\n@@ -1575,6 +1631,8 @@ vmsdbgout_init (main_input_filename)\n \n }\n \n+/* Not implemented in VMS Debug.  */\n+\n static void\n vmsdbgout_define (lineno, buffer)\n      unsigned int lineno;\n@@ -1584,6 +1642,8 @@ vmsdbgout_define (lineno, buffer)\n     (*dwarf2_debug_hooks.define) (lineno, buffer);\n }\n \n+/* Not implemented in VMS Debug.  */\n+\n static void\n vmsdbgout_undef (lineno, buffer)\n      unsigned int lineno;\n@@ -1593,6 +1653,8 @@ vmsdbgout_undef (lineno, buffer)\n     (*dwarf2_debug_hooks.undef) (lineno, buffer);\n }\n \n+/* Not implemented in VMS Debug.  */\n+\n static void\n vmsdbgout_decl (decl)\n      tree decl;\n@@ -1601,6 +1663,8 @@ vmsdbgout_decl (decl)\n     (*dwarf2_debug_hooks.function_decl) (decl);\n }\n \n+/* Not implemented in VMS Debug.  */\n+\n static void\n vmsdbgout_global_decl (decl)\n      tree decl;\n@@ -1609,6 +1673,8 @@ vmsdbgout_global_decl (decl)\n     (*dwarf2_debug_hooks.global_decl) (decl);\n }\n \n+/* Not implemented in VMS Debug.  */\n+\n static void\n vmsdbgout_abstract_function (decl)\n      tree decl;\n@@ -1617,8 +1683,8 @@ vmsdbgout_abstract_function (decl)\n     (*dwarf2_debug_hooks.outlining_inline_function) (decl);\n }\n \n-/* Output stuff that Debug requires at the end of every file,\n-   and generate the VMS Debug debugging info.  */\n+/* Output stuff that Debug requires at the end of every file and generate the\n+   VMS Debug debugging info.  */\n \n static void\n vmsdbgout_finish (input_filename)"}]}