{"sha": "4746cf844723522037d0f0688f2189edd706e7b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc0NmNmODQ0NzIzNTIyMDM3ZDBmMDY4OGYyMTg5ZWRkNzA2ZTdiNw==", "commit": {"author": {"name": "Matt Austern", "email": "austern@apple.com", "date": "2004-03-12T17:09:03Z"}, "committer": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2004-03-12T17:09:03Z"}, "message": "Enabled linkonce support for Darwin.\n\n\t* target.h (struct gcc_target): New target hook, unwind_label.\n\t* target-def.h (TARGET_ASM_EMIT_UNWIND_LABEL): New hook.\n\t* output.h (default_emit_unwind_label): New function.\n\t* default.h (TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY): New macro.\n\t(TARGET_USES_WEAK_UNWIND_INFO): New target macro.\n\t(TARGET_SUPPORTS_HIDDEN): New target macro.\n\t* dwarf2out.c (struct dw_fde_struct): Add field for function decl\n\tthat corresponds to this FDE.\n\t(FRAME_BEGIN_LABEL): Allow target to override default label.\n\t(output_call_frame_info): If FDEs are linknonce, then use extra\n\tindirection for FDE encoding, output a label for each FDE, and\n\toutput an empty label for each function without an FDE.\n\t(dwarf2out_begin_prologue): Set up decl field when creating an FDE.\n\t* varasm.c (globalize_decl): Call ASM_MAKE_LABEL_LINKONCE for\n\tdecls with DECL_ONE_ONLY set, if that macro is defined.\n\t(make_decl_one_only): Don't use DECL_COMMON if we're compiling\n\tfor a SUPPORTS_ONE_ONLY target.\n\t* config/darwin-protos.h (darwin_unique_section): Declare.\n\t(darwin_asm_named_section): Likewise.\n\t(darwin_section_type_flags): Likewise.\n\t(darwin_non_lazy_pcrel): Likewise.\n\t(darwin_emit_unwind_label): Likewise.\n\t(darwin_make_decl_one_only): Likewise.\n\t* config/darwin.c (machopic_finish): Get rid of tweak that\n\teliminate stubs for symbols that are defined.\n\t(darwin_encode_section_info): Don't treat weak functions as defined.\n\t(darwin_make_decl_one_only): Define.\n\t(darwin_asm_named_section): Likewise.\n\t(darwin_section_type_flags): Likewise.\n\t(darwin_unique_section): Likewise.\n\t(darwin_emit_unwind_label): Likewise.\n\t(darwin_non_lazy_pcrel): Likewise.\n\t(darwin_asm_output_dwarf_delta): Difference between two labels is\n\tlocal only if both labels are local.\n\t* config/darwin.h (MAKE_DECL_ONE_ONLY): Define.\n\t(ASM_MAKE_LABEL_LINKONCE): Likewise.\n\t(TARGET_SUPPORTS_HIDDEN): Likewise.\n\t(TARGET_USES_WEAK_UNWIND_INFO): Likewise.\n\t(TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY): Likewise.\n\t(FRAME_BEGIN_LABEL): Likewise.\n\t(ASM_DECLARE_OBJECT_NAME): Make references to weak symbols indirect.\n\t(ASM_DECLARE_FUNCTION_NAME): Likewise.\n\t(darwin_eh_frame_section): Give __eh_frame section the coalesced flag.\n\t(TARGET_ASM_UNIQUE_SECTION): Define.\n\t(EH_FRAME_SECTION_NAME): Define.\n\t(EH_FRAME_SECTION_ATTR): Likewise.\n\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Likewise.\n\t(TARGET_ASM_NAMED_SECTION): Likewise.\n\t(TARGET_SECTION_TYPE_FLAGS): Likewise.\n\t* doc/tm.texi: Document TARGET_USES_WEAK_UNWIND_INFO,\n\tTARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY, TARGET_SUPPORTS_HIDDEN,\n\tTARGET_ASM_EMIT_UNWIND_LABEL.\n\n\t* cp/decl2.c (maybe_make_one_only): Look at\n\tTARGET_EXPLICIT_INSTANTIATION_ONE_ONLY when deciding whether\n\tto make an explicit instantiation weak.\n\t* cp/method.c (use_thunk): Make sure we call comdat_linkage\n\twhen appropriate.\n\t* cp/pt.c (do_type_instantiation): On systems where weak symbols\n\tdon't go in a static archive's TOC, explicit instantiation of a\n\tclass must imply *explicit* instantiation of its memeber.\n\nFrom-SVN: r79394", "tree": {"sha": "caa8a2f6e25f2a2ca455a215f64f01003c8ba7c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caa8a2f6e25f2a2ca455a215f64f01003c8ba7c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4746cf844723522037d0f0688f2189edd706e7b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4746cf844723522037d0f0688f2189edd706e7b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4746cf844723522037d0f0688f2189edd706e7b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4746cf844723522037d0f0688f2189edd706e7b7/comments", "author": null, "committer": null, "parents": [{"sha": "cd33cf6e2f13de407e2e308f10f77b52dad6c3de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd33cf6e2f13de407e2e308f10f77b52dad6c3de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd33cf6e2f13de407e2e308f10f77b52dad6c3de"}], "stats": {"total": 514, "additions": 463, "deletions": 51}, "files": [{"sha": "e2821e3dedaf0e5b61b0fa0697b9a77157ee0861", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -1,3 +1,58 @@\n+2004-03-12  Matt Austern  <austern@apple.com>\n+\n+\t* target.h (struct gcc_target): New target hook, unwind_label.\n+\t* target-def.h (TARGET_ASM_EMIT_UNWIND_LABEL): New hook.\n+\t* output.h (default_emit_unwind_label): New function.\n+\t* default.h (TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY): New macro.\n+\t(TARGET_USES_WEAK_UNWIND_INFO): New target macro.\n+\t(TARGET_SUPPORTS_HIDDEN): New target macro.\n+\t* dwarf2out.c (struct dw_fde_struct): Add field for function decl\n+\tthat corresponds to this FDE.\n+\t(FRAME_BEGIN_LABEL): Allow target to override default label.\n+\t(output_call_frame_info): If FDEs are linknonce, then use extra\n+\tindirection for FDE encoding, output a label for each FDE, and \n+\toutput an empty label for each function without an FDE.\n+\t(dwarf2out_begin_prologue): Set up decl field when creating an FDE.\n+\t* varasm.c (globalize_decl): Call ASM_MAKE_LABEL_LINKONCE for\n+\tdecls with DECL_ONE_ONLY set, if that macro is defined.\n+\t(make_decl_one_only): Don't use DECL_COMMON if we're compiling\n+\tfor a SUPPORTS_ONE_ONLY target.\n+\t* config/darwin-protos.h (darwin_unique_section): Declare.\n+\t(darwin_asm_named_section): Likewise.\n+\t(darwin_section_type_flags): Likewise.\n+\t(darwin_non_lazy_pcrel): Likewise.\n+\t(darwin_emit_unwind_label): Likewise.\n+\t(darwin_make_decl_one_only): Likewise.\n+\t* config/darwin.c (machopic_finish): Get rid of tweak that\n+\teliminate stubs for symbols that are defined.\n+\t(darwin_encode_section_info): Don't treat weak functions as defined.\n+\t(darwin_make_decl_one_only): Define.\n+\t(darwin_asm_named_section): Likewise.\n+\t(darwin_section_type_flags): Likewise.\n+\t(darwin_unique_section): Likewise.\n+\t(darwin_emit_unwind_label): Likewise.\n+\t(darwin_non_lazy_pcrel): Likewise.\n+\t(darwin_asm_output_dwarf_delta): Difference between two labels is\n+\tlocal only if both labels are local.\n+\t* config/darwin.h (MAKE_DECL_ONE_ONLY): Define.\n+\t(ASM_MAKE_LABEL_LINKONCE): Likewise.\n+\t(TARGET_SUPPORTS_HIDDEN): Likewise.\n+\t(TARGET_USES_WEAK_UNWIND_INFO): Likewise.\n+\t(TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY): Likewise.\n+\t(FRAME_BEGIN_LABEL): Likewise.\n+\t(ASM_DECLARE_OBJECT_NAME): Make references to weak symbols indirect.\n+\t(ASM_DECLARE_FUNCTION_NAME): Likewise.\n+\t(darwin_eh_frame_section): Give __eh_frame section the coalesced flag.\n+\t(TARGET_ASM_UNIQUE_SECTION): Define.\n+\t(EH_FRAME_SECTION_NAME): Define.\n+\t(EH_FRAME_SECTION_ATTR): Likewise.\n+\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Likewise.\n+\t(TARGET_ASM_NAMED_SECTION): Likewise.\n+\t(TARGET_SECTION_TYPE_FLAGS): Likewise.\n+\t* doc/tm.texi: Document TARGET_USES_WEAK_UNWIND_INFO,\n+\tTARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY, TARGET_SUPPORTS_HIDDEN,\n+\tTARGET_ASM_EMIT_UNWIND_LABEL.\n+\t\n 2004-03-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* builtins.c (expand_builtin_mathfn): Add pow10* to the"}, {"sha": "845a8283c73028a67bc46d3bdb3a4e3157e7c07d", "filename": "gcc/config/darwin-protos.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -71,12 +71,21 @@ extern void machopic_select_section (tree, int, unsigned HOST_WIDE_INT);\n extern void machopic_select_rtx_section (enum machine_mode, rtx,\n \t\t\t\t\t unsigned HOST_WIDE_INT);\n \n+extern void darwin_unique_section (tree decl, int reloc);\n+extern void darwin_asm_named_section (const char *, unsigned int);\n+extern unsigned int darwin_section_type_flags (tree, const char *, int);\n+extern void darwin_non_lazy_pcrel (FILE *, rtx);\n+\n+extern void darwin_emit_unwind_label(FILE *, tree, int);\n+\n extern void darwin_pragma_ignore (struct cpp_reader *);\n extern void darwin_pragma_options (struct cpp_reader *);\n extern void darwin_pragma_unused (struct cpp_reader *);\n \n extern void darwin_file_end (void);\n \n+extern void darwin_make_decl_one_only (tree decl);\n+\n /* Expanded by EXTRA_SECTION_FUNCTIONS into varasm.o.  */\n extern void const_section (void);\n extern void const_data_section (void);"}, {"sha": "dec2eb72a358aa12c93c515509c361c646acb6c7", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -1004,6 +1004,7 @@ darwin_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n   if ((TREE_CODE (decl) == FUNCTION_DECL\n        || TREE_CODE (decl) == VAR_DECL)\n       && !DECL_EXTERNAL (decl)\n+      && (!TREE_PUBLIC (decl) || (!DECL_ONE_ONLY (decl) && !DECL_WEAK (decl)))\n       && ((TREE_STATIC (decl)\n \t   && (!DECL_COMMON (decl) || !TREE_PUBLIC (decl)))\n \t  || (DECL_INITIAL (decl)\n@@ -1123,6 +1124,20 @@ update_stubs (const char *name)\n     }\n }\n \n+void\n+darwin_make_decl_one_only (tree decl)\n+{\n+  static const char *text_section = \"__TEXT,__textcoal_nt,coalesced,no_toc\";\n+  static const char *data_section = \"__DATA,__datacoal_nt,coalesced,no_toc\";\n+\n+  const char *sec = TREE_CODE (decl) == FUNCTION_DECL\n+    ? text_section\n+    : data_section;\n+  TREE_PUBLIC (decl) = 1;\n+  DECL_ONE_ONLY (decl) = 1;\n+  DECL_SECTION_NAME (decl) = build_string (strlen (sec), sec);\n+}\n+\n void\n machopic_select_section (tree exp, int reloc,\n \t\t\t unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n@@ -1289,6 +1304,103 @@ darwin_globalize_label (FILE *stream, const char *name)\n     default_globalize_label (stream, name);\n }\n \n+void\n+darwin_asm_named_section (const char *name, unsigned int flags ATTRIBUTE_UNUSED)\n+{\n+  fprintf (asm_out_file, \".section %s\\n\", name);\n+}\n+\n+unsigned int\n+darwin_section_type_flags (tree decl, const char *name, int reloc)\n+{\n+  unsigned int flags = default_section_type_flags (decl, name, reloc);\n+ \n+  /* Weak or linkonce variables live in a writable section.  */\n+  if (decl != 0 && TREE_CODE (decl) != FUNCTION_DECL\n+      && (DECL_WEAK (decl) || DECL_ONE_ONLY (decl)))\n+    flags |= SECTION_WRITE;\n+  \n+  return flags;\n+}              \n+\n+void \n+darwin_unique_section (tree decl, int reloc ATTRIBUTE_UNUSED)\n+{\n+  /* Darwin does not use unique sections.  However, the target's\n+     unique_section hook is called for linkonce symbols.  We need\n+     to set an appropriate section for such symbols. */\n+  if (DECL_ONE_ONLY (decl) && !DECL_SECTION_NAME (decl))\n+    darwin_make_decl_one_only (decl);\n+}\n+\n+/* Emit a label for an FDE, making it global and/or weak if appropriate. \n+   The third parameter is nonzero if this is just a placeholder for an\n+   FDE that we are omitting. */\n+void \n+darwin_emit_unwind_label(FILE *file, tree decl, int empty)\n+{\n+  tree id = DECL_ASSEMBLER_NAME (decl)\n+    ? DECL_ASSEMBLER_NAME (decl)\n+    : DECL_NAME (decl);\n+\n+  const char *prefix = \"_\";\n+  const int prefix_len = 1;\n+\n+  const char *base = IDENTIFIER_POINTER (id);\n+  unsigned int base_len = IDENTIFIER_LENGTH (id);\n+\n+  const char *suffix = \".eh\";\n+  unsigned int suffix_len = 3;\n+\n+  int need_quotes = name_needs_quotes (base);\n+  int quotes_len = need_quotes ? 2 : 0;\n+\n+  char *lab = xmalloc (prefix_len + base_len + suffix_len + quotes_len + 1);\n+  lab[0] = '\\0';\n+\n+  if (need_quotes)\n+    strcat(lab, \"\\\"\");\n+  strcat(lab, prefix);\n+  strcat(lab, base);\n+  strcat(lab, suffix);\n+  if (need_quotes)\n+    strcat(lab, \"\\\"\");\n+\n+  if (TREE_PUBLIC (decl))\n+    fprintf (file, \"%s %s\\n\",\n+\t     (DECL_VISIBILITY (decl) != VISIBILITY_HIDDEN\n+\t      ? \".globl\"\n+\t      : \".private_extern\"),\n+\t     lab);\n+\n+  if (DECL_ONE_ONLY (decl) && TREE_PUBLIC (decl))\n+    fprintf (file, \".weak_definition %s\\n\", lab);\n+\n+  if (empty)\n+    fprintf (file, \"%s = 0\\n\", lab);\n+  else\n+    fprintf (file, \"%s:\\n\", lab);\n+\n+  free (lab);\n+}\n+\n+/* Generate a PC-relative reference to a Mach-O non-lazy-symbol.  */ \n+void\n+darwin_non_lazy_pcrel (FILE *file, rtx addr)\n+{\n+  const char *str;\n+  const char *nlp_name;\n+\n+  if (GET_CODE (addr) != SYMBOL_REF)\n+    abort ();\n+\n+  str = darwin_strip_name_encoding (XSTR (addr, 0));\n+  nlp_name = machopic_non_lazy_ptr_name (str);\n+  fputs (\"\\t.long\\t\", file);\n+  ASM_OUTPUT_LABELREF (file, nlp_name);\n+  fputs (\"-.\", file);\n+}\n+\n /* Emit an assembler directive to set visibility for a symbol.  The\n    only supported visibilities are VISIBILITY_DEFAULT and\n    VISIBILITY_HIDDEN; the latter corresponds to Darwin's \"private\n@@ -1325,8 +1437,8 @@ void\n darwin_asm_output_dwarf_delta (FILE *file, int size ATTRIBUTE_UNUSED,\n \t\t\t       const char *lab1, const char *lab2)\n {\n-  const char *p = lab1 + (lab1[0] == '*');\n-  int islocaldiff = (p[0] == 'L');\n+  int islocaldiff = (lab1[0] == '*' && lab1[1] == 'L'\n+\t\t     && lab2[0] == '*' && lab2[1] == 'L');\n \n   if (islocaldiff)\n     fprintf (file, \"\\t.set L$set$%d,\", darwin_dwarf_label_counter);"}, {"sha": "8a659d9ed8f873dfea25cf3059873d9abfcc461c", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 71, "deletions": 9, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -319,6 +319,47 @@ do { text_section ();\t\t\t\t\t\t\t\\\n \t      \"\\t.stabs \\\"%s\\\",%d,0,0,Letext\\nLetext:\\n\", \"\" , N_SO);\t\\\n    } while (0)\n \n+/* Making a symbols weak on Darwin requires more than just setting DECL_WEAK. */\n+#define MAKE_DECL_ONE_ONLY(DECL) darwin_make_decl_one_only (DECL)\n+\n+/* Representation of linkonce symbols for the MACH-O assembler. Linkonce\n+   symbols must be given a special section *and* must be preceded by a \n+   special assembler directive. */\n+#define ASM_MAKE_LABEL_LINKONCE(FILE,  NAME)                            \\\n+ do { const char* _x = (NAME); if (!!strncmp (_x, \"_OBJC_\", 6)) {\t\\\n+  fputs (\".weak_definition \", FILE); assemble_name (FILE, _x);\t\t\\\n+  fputs (\"\\n\", FILE); }} while (0)\n+\n+/* We support hidden visibility */\n+#undef TARGET_SUPPORTS_HIDDEN\n+#define TARGET_SUPPORTS_HIDDEN 1\n+\n+/* The Darwin linker imposes two limitations on common symbols: they \n+   can't have hidden visibility, and they can't appear in dylibs.  As\n+   a consequence, we should never use common symbols to represent \n+   vague linkage. */\n+#undef USE_COMMON_FOR_ONE_ONLY\n+#define USE_COMMON_FOR_ONE_ONLY 0\n+\n+/* The Darwin linker doesn't like explicit template instantions to be\n+   coalesced, because it doesn't want coalesced symbols to appear in\n+   a static archive's table of contents. */\n+#undef TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY\n+#define TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY 0\n+\n+/* We make exception information linkonce. */\n+#undef TARGET_USES_WEAK_UNWIND_INFO\n+#define TARGET_USES_WEAK_UNWIND_INFO 1\n+\n+/* We need to use a nonlocal label for the start of an EH frame: the\n+   Darwin linker requires that a coalesced section start with a label. */\n+#undef FRAME_BEGIN_LABEL\n+#define FRAME_BEGIN_LABEL \"EH_frame\"\n+\n+/* Emit a label for the FDE corresponding to DECL.  EMPTY means \n+   emit a label for an empty FDE. */\n+#define TARGET_ASM_EMIT_UNWIND_LABEL darwin_emit_unwind_label\n+\n /* Our profiling scheme doesn't LP labels and counter words.  */\n \n #define NO_PROFILE_COUNTERS\t1\n@@ -370,10 +411,11 @@ do { text_section ();\t\t\t\t\t\t\t\\\n     const char *xname = NAME;\t\t\t\t\t\t\\\n     if (GET_CODE (XEXP (DECL_RTL (DECL), 0)) != SYMBOL_REF)\t\t\\\n       xname = IDENTIFIER_POINTER (DECL_NAME (DECL));\t\t\t\\\n-    if ((TREE_STATIC (DECL)\t\t\t\t\t\t\\\n-\t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n-        || DECL_INITIAL (DECL))\t\t\t\t\t\t\\\n-      machopic_define_name (xname);\t\t\t\t\t\\\n+    if (! DECL_ONE_ONLY (DECL) && ! DECL_WEAK (DECL))                   \\\n+      if ((TREE_STATIC (DECL)\t\t\t\t\t\t\\\n+\t   && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n+          || DECL_INITIAL (DECL))\t\t\t\t\t\\\n+        machopic_define_name (xname);\t\t\t\t\t\\\n     if ((TREE_STATIC (DECL)\t\t\t\t\t\t\\\n \t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n         || DECL_INITIAL (DECL))\t\t\t\t\t\t\\\n@@ -390,10 +432,11 @@ do { text_section ();\t\t\t\t\t\t\t\\\n     const char *xname = NAME;                                           \\\n     if (GET_CODE (XEXP (DECL_RTL (DECL), 0)) != SYMBOL_REF)             \\\n       xname = IDENTIFIER_POINTER (DECL_NAME (DECL));                    \\\n-    if ((TREE_STATIC (DECL)                                             \\\n-\t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))               \\\n-        || DECL_INITIAL (DECL))                                         \\\n-      machopic_define_name (xname);                                     \\\n+    if (! DECL_ONE_ONLY (DECL) && ! DECL_WEAK (DECL))\t\t\t\\\n+      if ((TREE_STATIC (DECL)                                           \\\n+\t   && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))             \\\n+          || DECL_INITIAL (DECL))                                       \\\n+        machopic_define_name (xname);                                   \\\n     if ((TREE_STATIC (DECL)                                             \\\n \t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))               \\\n         || DECL_INITIAL (DECL))                                         \\\n@@ -646,7 +689,7 @@ SECTION_FUNCTION (darwin_exception_section,\t\t\\\n \t\t\".section __DATA,__gcc_except_tab\", 0)\t\\\n SECTION_FUNCTION (darwin_eh_frame_section,\t\t\\\n \t\tin_darwin_eh_frame,\t\t\t\\\n-\t\t\".section __TEXT,__eh_frame\", 0)\t\\\n+\t\t\".section \" EH_FRAME_SECTION_NAME \",__eh_frame\" EH_FRAME_SECTION_ATTR, 0)  \\\n \t\t\t\t\t\t\t\\\n static void\t\t\t\t\t\\\n objc_section_init (void)\t\t\t\\\n@@ -687,6 +730,10 @@ objc_section_init (void)\t\t\t\\\n #define TARGET_ASM_SELECT_SECTION machopic_select_section\n #undef\tTARGET_ASM_SELECT_RTX_SECTION\n #define TARGET_ASM_SELECT_RTX_SECTION machopic_select_rtx_section\n+#undef  TARGET_ASM_UNIQUE_SECTION\n+#define TARGET_ASM_UNIQUE_SECTION darwin_unique_section\n+\n+\n \n #define ASM_DECLARE_UNRESOLVED_REFERENCE(FILE,NAME)\t\t\t\\\n     do {\t\t\t\t\t\t\t\t\\\n@@ -814,6 +861,9 @@ enum machopic_addr_class {\n \n #define TARGET_ASM_EH_FRAME_SECTION darwin_eh_frame_section\n \n+#define EH_FRAME_SECTION_NAME   \"__TEXT\"\n+#define EH_FRAME_SECTION_ATTR \",coalesced,no_toc+strip_static_syms\"\n+\n #undef ASM_PREFERRED_EH_DATA_FORMAT\n #define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)  \\\n   (((CODE) == 2 && (GLOBAL) == 1) \\\n@@ -823,8 +873,20 @@ enum machopic_addr_class {\n #define ASM_OUTPUT_DWARF_DELTA(FILE,SIZE,LABEL1,LABEL2)  \\\n   darwin_asm_output_dwarf_delta (FILE, SIZE, LABEL1, LABEL2)\n \n+#define ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(ASM_OUT_FILE, ENCODING, SIZE, ADDR, DONE)\t\\\n+      if (ENCODING == ASM_PREFERRED_EH_DATA_FORMAT (2, 1)) {\t\t\t\t\\\n+\tdarwin_non_lazy_pcrel (ASM_OUT_FILE, ADDR);\t\t\t\t\t\\\n+\tgoto DONE;\t\t\t\t\t\t\t\t\t\\\n+      }\n+\n+\n #define TARGET_TERMINATE_DW2_EH_FRAME_INFO false\n \n+#undef TARGET_ASM_NAMED_SECTION\n+#define TARGET_ASM_NAMED_SECTION darwin_asm_named_section\n+#undef TARGET_SECTION_TYPE_FLAGS\n+#define TARGET_SECTION_TYPE_FLAGS darwin_section_type_flags\n+\n #define DARWIN_REGISTER_TARGET_PRAGMAS()\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n     c_register_pragma (0, \"mark\", darwin_pragma_ignore);\t\\"}, {"sha": "fc34864146c8ea9874521f9950edd7a26a4ee6b8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -1,3 +1,14 @@\n+2004-03-12  Matt Austern  <austern@apple.com>\n+\n+\t* decl2.c (maybe_make_one_only): Look at\n+\tTARGET_EXPLICIT_INSTANTIATION_ONE_ONLY when deciding whether\n+\tto make an explicit instantiation weak.\n+\t* method.c (use_thunk): Make sure we call comdat_linkage\n+\twhen appropriate.\n+\t* pt.c (do_type_instantiation): On systems where weak symbols\n+\tdon't go in a static archive's TOC, explicit instantiation of a\n+\tclass must imply *explicit* instantiation of its memeber.\n+\t\n 2004-03-11  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* call.c, cp-tree.h, pt.c: Fix comment typos."}, {"sha": "7310d091e12578fa01d77616760e524152e5599e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -1399,7 +1399,9 @@ comdat_linkage (tree decl)\n \n /* For win32 we also want to put explicit instantiations in\n    linkonce sections, so that they will be merged with implicit\n-   instantiations; otherwise we get duplicate symbol errors.  */\n+   instantiations; otherwise we get duplicate symbol errors.  \n+   For Darwin we do not want explicit instantiations to be \n+   linkonce. */\n \n void\n maybe_make_one_only (tree decl)\n@@ -1418,13 +1420,18 @@ maybe_make_one_only (tree decl)\n      to for variables so that cp_finish_decl will update their linkage,\n      because their DECL_INITIAL may not have been set properly yet.  */\n \n-  make_decl_one_only (decl);\n-\n-  if (TREE_CODE (decl) == VAR_DECL)\n+  if (TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY\n+      || (! DECL_EXPLICIT_INSTANTIATION (decl)\n+\t  && ! DECL_TEMPLATE_SPECIALIZATION (decl)))\n     {\n-      DECL_COMDAT (decl) = 1;\n-      /* Mark it needed so we don't forget to emit it.  */\n-      mark_referenced (DECL_ASSEMBLER_NAME (decl));\n+      make_decl_one_only (decl);\n+\n+      if (TREE_CODE (decl) == VAR_DECL)\n+\t{\n+\t  DECL_COMDAT (decl) = 1;\n+\t  /* Mark it needed so we don't forget to emit it.  */\n+\t  mark_referenced (DECL_ASSEMBLER_NAME (decl));\n+\t}\n     }\n }\n "}, {"sha": "10dfaca60867c9e3bbcbda6af155f34b1c81a7ad", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -390,6 +390,8 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n      rewrite.  */\n   TREE_PUBLIC (thunk_fndecl) = TREE_PUBLIC (function);\n   DECL_VISIBILITY (thunk_fndecl) = DECL_VISIBILITY (function);\n+  if (flag_weak && TREE_PUBLIC (thunk_fndecl))\n+    comdat_linkage (thunk_fndecl);\n \n   if (flag_syntax_only)\n     {"}, {"sha": "45fa0123b36b55641c2c2100ebb37117ecc3f80d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -10661,6 +10661,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n   int extern_p = 0;\n   int nomem_p = 0;\n   int static_p = 0;\n+  int previous_instantiation_extern_p = 0;\n \n   if (TREE_CODE (t) == TYPE_DECL)\n     t = TREE_TYPE (t);\n@@ -10722,11 +10723,16 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \t No program shall explicitly instantiate any template more\n \t than once.  \n \n-         If CLASSTYPE_INTERFACE_ONLY, then the first explicit instantiation\n-\t was `extern'.  If EXTERN_P then the second is.  If -frepo, chances\n-\t are we already got marked as an explicit instantiation because of the\n-\t repo file.  All these cases are OK.  */\n-      if (!CLASSTYPE_INTERFACE_ONLY (t) && !extern_p && !flag_use_repository\n+         If PREVIOUS_INSTANTIATION_EXTERN_P, then the first explicit\n+\t instantiation was `extern'.  If EXTERN_P then the second is.\n+\t If -frepo, chances are we already got marked as an explicit\n+\t instantiation because of the repo file.  All these cases are\n+\t OK.  */\n+\n+      previous_instantiation_extern_p = CLASSTYPE_INTERFACE_ONLY (t);\n+\n+      if (!previous_instantiation_extern_p && !extern_p\n+\t  && !flag_use_repository\n \t  && (complain & tf_error))\n \tpedwarn (\"duplicate explicit instantiation of `%#T'\", t);\n       \n@@ -10743,6 +10749,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n   {\n     tree tmp;\n+    int explicitly_instantiate_members = 0;\n \n     /* In contrast to implicit instantiation, where only the\n        declarations, and not the definitions, of members are\n@@ -10761,26 +10768,46 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n        *explicit* instantiations or not.  We choose to be generous,\n        and not set DECL_EXPLICIT_INSTANTIATION.  Therefore, we allow\n        the explicit instantiation of a class where some of the members\n-       have no definition in the current translation unit.  */\n+       have no definition in the current translation unit.  Exception:\n+       on some targets (e.g. Darwin), weak symbols do not get put in \n+       a static archive's TOC.  The problematic case is if we're doing\n+       a non-extern explicit instantiation of an extern template: we\n+       have to put member functions in the TOC in that case, or we'll\n+       get unresolved symbols at link time. */\n+\n+    explicitly_instantiate_members =\n+      TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY\n+      && previous_instantiation_extern_p && ! extern_p\n+      && ! TYPE_FOR_JAVA (t);\n \n     if (! static_p)\n       for (tmp = TYPE_METHODS (t); tmp; tmp = TREE_CHAIN (tmp))\n \tif (TREE_CODE (tmp) == FUNCTION_DECL\n \t    && DECL_TEMPLATE_INSTANTIATION (tmp))\n \t  {\n-\t    mark_decl_instantiated (tmp, extern_p);\n-\t    repo_template_instantiated (tmp, extern_p);\n-\t    if (! extern_p)\n-\t      instantiate_decl (tmp, /*defer_ok=*/1);\n+\t    if (explicitly_instantiate_members)\n+\t      do_decl_instantiation (tmp, NULL_TREE);\n+\t    else\n+\t      {\n+\t\tmark_decl_instantiated (tmp, extern_p);\n+\t\trepo_template_instantiated (tmp, extern_p);\n+\t\tif (! extern_p)\n+\t\t  instantiate_decl (tmp, /*defer_ok=*/1);\n+\t      }\n \t  }\n \n     for (tmp = TYPE_FIELDS (t); tmp; tmp = TREE_CHAIN (tmp))\n       if (TREE_CODE (tmp) == VAR_DECL && DECL_TEMPLATE_INSTANTIATION (tmp))\n \t{\n-\t  mark_decl_instantiated (tmp, extern_p);\n-\t  repo_template_instantiated (tmp, extern_p);\n-\t  if (! extern_p)\n-\t    instantiate_decl (tmp, /*defer_ok=*/1);\n+\t  if (explicitly_instantiate_members)\n+\t    do_decl_instantiation (tmp, NULL_TREE);\n+\t  else\n+\t    {\n+\t      mark_decl_instantiated (tmp, extern_p);\n+\t      repo_template_instantiated (tmp, extern_p);\n+\t      if (! extern_p)\n+\t\tinstantiate_decl (tmp, /*defer_ok=*/1);\n+\t    }\n \t}\n \n     if (CLASSTYPE_NESTED_UTDS (t))"}, {"sha": "602cbdd72a1d5efacdf14a9f62e7b88c89dd1fb6", "filename": "gcc/defaults.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -237,6 +237,18 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n #endif\n #endif\n \n+/* Determines whether explicit template instantiations should\n+   be given link-once semantics. The C++ ABI requires this \n+   macro to be nonzero; see the documentation. */\n+#ifndef TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY\n+# define TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY 1\n+#endif\n+\n+/* This determines whether or not we need linkonce unwind information */\n+#ifndef TARGET_USES_WEAK_UNWIND_INFO\n+#define TARGET_USES_WEAK_UNWIND_INFO 0\n+#endif\n+\n /* By default, there is no prefix on user-defined symbols.  */\n #ifndef USER_LABEL_PREFIX\n #define USER_LABEL_PREFIX \"\"\n@@ -258,6 +270,24 @@ do { fputs (integer_asm_op (POINTER_SIZE / BITS_PER_UNIT, TRUE), FILE); \\\n # endif\n #endif\n \n+/* This determines whether this target supports hidden visibility.\n+   This is a weaker condition than HAVE_GAS_HIDDEN, which probes for\n+   specific assembler syntax. */\n+#ifndef TARGET_SUPPORTS_HIDDEN\n+# ifdef HAVE_GAS_HIDDEN\n+#  define TARGET_SUPPORTS_HIDDEN 1\n+# else\n+#  define TARGET_SUPPORTS_HIDDEN 0\n+# endif\n+#endif\n+\n+/* Determines whether we may use common symbols to represent one-only\n+   semantics (a.k.a. \"vague linkage\"). */\n+#ifndef USE_COMMON_FOR_ONE_ONLY\n+# define USE_COMMON_FOR_ONE_ONLY 1\n+#endif\n+\n+\n /* If the target supports init_priority C++ attribute, give\n    SUPPORTS_INIT_PRIORITY a nonzero value.  */\n #ifndef SUPPORTS_INIT_PRIORITY"}, {"sha": "1988c14ef2023b0bd9b389c7ddd7f9e4821ad082", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -3072,6 +3072,12 @@ for the abi and context in the @code{.unwabi} directive.  If the\n be updated in @var{fs}.\n @end defmac\n \n+@defmac TARGET_USES_WEAK_UNWIND_INFO\n+A C expression that evaluates to true if the target requires unwind\n+info to be given comdat linkage.  Define it to be @code{1} if comdat\n+linkage is necessary.  The default is @code{0}.\n+@end defmac\n+\n @node Stack Checking\n @subsection Specifying How Stack Checking is Done\n \n@@ -6705,6 +6711,24 @@ commands that will make the symbol(s) associated with @var{decl} have\n hidden, protected or internal visibility as specified by @var{visibility}.\n @end deftypefn\n \n+@defmac TARGET_EXPLICIT_INSTANTIATIONS_ONE_ONLY\n+A C expression that evaluates to true if the target's linker expects\n+explicit template specializations, as well as implicit, to be given\n+linkonce semantics.  The default is @code{1}.  The C++ ABI requires\n+this macro to be nonzero.  Define this macro for targets where full\n+C++ ABI compliance is impossible and where explicit and implicit \n+template specialization must be treated differently.\n+@end defmac\n+\n+@defmac TARGET_SUPPORTS_HIDDEN\n+A C expression that evaluates to true if the target supports hidden\n+visibility.  By default this expression is true if and only if\n+@code{HAS_GAS_HIDDEN} is defined.  Set this macro if the\n+@code{HAS_GAS_HIDDEN} macro gives the wrong answer for this\n+target.  (For example, if the target's mechanism for supporting\n+hidden visibility is not the same as GAS's.)\n+@end defmac\n+\n @defmac ASM_OUTPUT_EXTERNAL (@var{stream}, @var{decl}, @var{name})\n A C statement (sans semicolon) to output to the stdio stream\n @var{stream} any text necessary for declaring the name of an external\n@@ -7427,6 +7451,17 @@ If this macro is not defined, nothing special is output at the end of\n the jump-table.\n @end defmac\n \n+@deftypefn {Target Hook} void TARGET_ASM_EMIT_UNWIND_LABEL (@var{stream}, @var{decl}, @var{empty})\n+This target hook emits a label at the beginning of each FDE.  It\n+should be defined on targets where FDEs need special labels, and it\n+should write the appropriate label, for the FDE associated with the\n+function declaration @var{decl}, to the stdio stream @var{stream}.\n+The third argument, @var{empty}, is a boolean: true if this is a\n+placeholder label for an omitted FDE.\n+\n+The default is that FDEs are not given nonlocal labels.\n+@end deftypefn\n+\n @node Exception Region Output\n @subsection Assembler Commands for Exception Regions\n "}, {"sha": "90a9caa7ebf95462b91a48babb3dc2fc7a9f4461", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -243,6 +243,7 @@ typedef struct cfa_loc GTY(())\n \n typedef struct dw_fde_struct GTY(())\n {\n+  tree decl;\n   const char *dw_fde_begin;\n   const char *dw_fde_current_label;\n   const char *dw_fde_end;\n@@ -391,7 +392,9 @@ static void def_cfa_1 (const char *, dw_cfa_location *);\n #define FUNC_END_LABEL\t\t\"LFE\"\n #endif\n \n+#ifndef FRAME_BEGIN_LABEL\n #define FRAME_BEGIN_LABEL\t\"Lframe\"\n+#endif\n #define CIE_AFTER_SIZE_LABEL\t\"LSCIE\"\n #define CIE_END_LABEL\t\t\"LECIE\"\n #define FDE_LABEL\t\t\"LSFDE\"\n@@ -1942,6 +1945,22 @@ output_call_frame_info (int for_eh)\n   if (fde_table_in_use == 0)\n     return;\n \n+  /* If we make FDEs linkonce, we may have to emit an empty label for\n+     an FDE that wouldn't otherwise be emitted.  We want to avoid\n+     having an FDE kept around when the function it refers to is\n+     discarded. (Example where this matters: a primary function\n+     template in C++ requires EH information, but an explicit\n+     specialization doesn't. */\n+  if (TARGET_USES_WEAK_UNWIND_INFO\n+      && ! flag_asynchronous_unwind_tables\n+      && for_eh)\n+    for (i = 0; i < fde_table_in_use; i++)\n+      if ((fde_table[i].nothrow || fde_table[i].all_throwers_are_sibcalls)\n+          && !fde_table[i].uses_eh_lsda\n+\t  && ! DECL_ONE_ONLY (fde_table[i].decl))\n+\t(*targetm.asm_out.unwind_label) (asm_out_file, fde_table[i].decl,\n+\t\t\t\t\t /* empty */ 1);\n+\n   /* If we don't have any functions we'll want to unwind out of, don't\n      emit any EH unwind information.  Note that if exceptions aren't\n      enabled, we won't have collected nothrow information, and if we\n@@ -1953,6 +1972,9 @@ output_call_frame_info (int for_eh)\n       for (i = 0; i < fde_table_in_use; i++)\n \tif (fde_table[i].uses_eh_lsda)\n \t  any_eh_needed = any_lsda_needed = true;\n+        else if (TARGET_USES_WEAK_UNWIND_INFO\n+\t\t && DECL_ONE_ONLY (fde_table[i].decl))\n+\t  any_eh_needed = 1;\n \telse if (! fde_table[i].nothrow\n \t\t && ! fde_table[i].all_throwers_are_sibcalls)\n \t  any_eh_needed = true;\n@@ -2004,7 +2026,9 @@ output_call_frame_info (int for_eh)\n \t P\tIndicates the presence of an encoding + language\n \t\tpersonality routine in the CIE augmentation.  */\n \n-      fde_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/1, /*global=*/0);\n+      fde_encoding = TARGET_USES_WEAK_UNWIND_INFO\n+\t? ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2, /*global=*/1)\n+\t: ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/1, /*global=*/0);\n       per_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/2, /*global=*/1);\n       lsda_encoding = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/0);\n \n@@ -2095,9 +2119,11 @@ output_call_frame_info (int for_eh)\n       /* Don't emit EH unwind info for leaf functions that don't need it.  */\n       if (for_eh && !flag_asynchronous_unwind_tables && flag_exceptions\n \t  && (fde->nothrow || fde->all_throwers_are_sibcalls)\n+\t  && (! TARGET_USES_WEAK_UNWIND_INFO || ! DECL_ONE_ONLY (fde->decl))\n \t  && !fde->uses_eh_lsda)\n \tcontinue;\n \n+      (*targetm.asm_out.unwind_label) (asm_out_file, fde->decl, /* empty */ 0);\n       (*targetm.asm_out.internal_label) (asm_out_file, FDE_LABEL, for_eh + i * 2);\n       ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + i * 2);\n       ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + i * 2);\n@@ -2113,9 +2139,16 @@ output_call_frame_info (int for_eh)\n \n       if (for_eh)\n \t{\n-\t  dw2_asm_output_encoded_addr_rtx (fde_encoding,\n-\t\t   gen_rtx_SYMBOL_REF (Pmode, fde->dw_fde_begin),\n-\t\t   \"FDE initial location\");\n+\t  if (TARGET_USES_WEAK_UNWIND_INFO\n+\t      && DECL_ONE_ONLY (fde->decl))\n+\t    dw2_asm_output_encoded_addr_rtx (fde_encoding,\n+\t\t     gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER\n+\t\t\t\t\t          (DECL_ASSEMBLER_NAME (fde->decl))),\n+\t\t     \"FDE initial location\");\n+\t  else\n+\t    dw2_asm_output_encoded_addr_rtx (fde_encoding,\n+\t\t     gen_rtx_SYMBOL_REF (Pmode, fde->dw_fde_begin),\n+\t\t     \"FDE initial location\");\n \t  dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n \t\t\t\tfde->dw_fde_end, fde->dw_fde_begin,\n \t\t\t\t\"FDE address range\");\n@@ -2248,6 +2281,7 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n \n   /* Add the new FDE at the end of the fde_table.  */\n   fde = &fde_table[fde_table_in_use++];\n+  fde->decl = current_function_decl;\n   fde->dw_fde_begin = xstrdup (label);\n   fde->dw_fde_current_label = NULL;\n   fde->dw_fde_end = NULL;"}, {"sha": "36dab8cca826f8fd86e4d75f7ebb505901563303", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -514,6 +514,7 @@ extern const char *default_strip_name_encoding (const char *);\n extern bool default_binds_local_p (tree);\n extern bool default_binds_local_p_1 (tree, int);\n extern void default_globalize_label (FILE *, const char *);\n+extern void default_emit_unwind_label (FILE *, tree, int);\n extern void default_internal_label (FILE *, const char *, unsigned long);\n extern void default_file_start (void);\n extern void file_end_indicate_exec_stack (void);"}, {"sha": "930fba64b1099a99349f176eec6cda7968859857", "filename": "gcc/target-def.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -57,6 +57,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #ifndef TARGET_ASM_GLOBALIZE_LABEL\n #define TARGET_ASM_GLOBALIZE_LABEL default_globalize_label\n #endif\n+\n+#ifndef TARGET_ASM_EMIT_UNWIND_LABEL\n+#define TARGET_ASM_EMIT_UNWIND_LABEL default_emit_unwind_label\n+#endif\n+\n #ifndef TARGET_ASM_INTERNAL_LABEL\n #define TARGET_ASM_INTERNAL_LABEL default_internal_label\n #endif\n@@ -189,6 +194,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \t\t\tTARGET_ASM_UNALIGNED_INT_OP,\t\t\\\n \t\t\tTARGET_ASM_INTEGER,\t\t\t\\\n \t\t\tTARGET_ASM_GLOBALIZE_LABEL,\t\t\\\n+                        TARGET_ASM_EMIT_UNWIND_LABEL,           \\\n \t\t\tTARGET_ASM_INTERNAL_LABEL,\t\t\\\n \t\t\tTARGET_ASM_ASSEMBLE_VISIBILITY,\t\t\\\n \t\t\tTARGET_ASM_FUNCTION_PROLOGUE,\t\t\\"}, {"sha": "5dea29a8204b017b3127d840beeb1ea3867ab4f7", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -74,6 +74,12 @@ struct gcc_target\n     /* Output code that will globalize a label.  */\n     void (* globalize_label) (FILE *, const char *);\n \n+    /* Output code that will emit a label for unwind info, if this\n+       target requires such labels.  Second argument is the decl the\n+       unwind info is associated with, third is is a boolean: true if\n+       this is only a placeholder for an omitted FDE. */\n+    void (* unwind_label ) (FILE *, tree, int);\n+\n     /* Output an internal label.  */\n     void (* internal_label) (FILE *, const char *, unsigned long);\n "}, {"sha": "6a32ccc76d97f71d3a51df63fdc96e1ef86207d7", "filename": "gcc/varasm.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -4104,6 +4104,9 @@ globalize_decl (tree decl)\n \t}\n       return;\n     }\n+#elif defined(ASM_MAKE_LABEL_LINKONCE)\n+  if (DECL_ONE_ONLY (decl))\n+    ASM_MAKE_LABEL_LINKONCE (asm_out_file, name);\n #endif\n \n   (*targetm.asm_out.globalize_label) (asm_out_file, name);\n@@ -4228,16 +4231,16 @@ make_decl_one_only (tree decl)\n \n   TREE_PUBLIC (decl) = 1;\n \n-  if (TREE_CODE (decl) == VAR_DECL\n-      && (DECL_INITIAL (decl) == 0 || DECL_INITIAL (decl) == error_mark_node))\n-    DECL_COMMON (decl) = 1;\n-  else if (SUPPORTS_ONE_ONLY)\n+  if (SUPPORTS_ONE_ONLY)\n     {\n #ifdef MAKE_DECL_ONE_ONLY\n       MAKE_DECL_ONE_ONLY (decl);\n #endif\n       DECL_ONE_ONLY (decl) = 1;\n     }\n+  else if (TREE_CODE (decl) == VAR_DECL\n+      && (DECL_INITIAL (decl) == 0 || DECL_INITIAL (decl) == error_mark_node))\n+    DECL_COMMON (decl) = 1;\n   else if (SUPPORTS_WEAK)\n     DECL_WEAK (decl) = 1;\n   else\n@@ -4917,6 +4920,16 @@ default_globalize_label (FILE * stream, const char *name)\n }\n #endif /* GLOBAL_ASM_OP */\n \n+/* Default function to output a label for unwind information.  The\n+   default is to do nothing.  A target that needs nonlocal labels for\n+   unwind information must provide its own function to do this. */\n+void\n+default_emit_unwind_label (FILE * stream ATTRIBUTE_UNUSED,\n+\t\t\t   tree decl ATTRIBUTE_UNUSED,\n+\t\t\t   int empty ATTRIBUTE_UNUSED)\n+{ \n+}\n+\n /* This is how to output an internal numbered label where PREFIX is\n    the class of label and LABELNO is the number within the class.  */\n "}, {"sha": "ad4824e2762b1c8cfea65e5271266ca4f2bd644c", "filename": "libffi/src/powerpc/darwin.S", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -162,8 +162,8 @@ _ffi_call_AIX:\n /* END(_ffi_call_AIX)  */\n \n .data\n-.section __TEXT,__eh_frame\n-Lframe1:\n+.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms\n+EH_frame1:\n \t.set\tL$set$0,LECIE1-LSCIE1\n \t.long\tL$set$0\t; Length of Common Information Entry\n LSCIE1:\n@@ -173,19 +173,20 @@ LSCIE1:\n \t.byte\t0x1\t; uleb128 0x1; CIE Code Alignment Factor\n \t.byte\t0x7c\t; sleb128 -4; CIE Data Alignment Factor\n \t.byte\t0x41\t; CIE RA Column\n-\t.byte   0x1     ; uleb128 0x1; Augmentation size\n-\t.byte   0x10    ; FDE Encoding (pcrel)\n+\t.byte\t0x1\t; uleb128 0x1; Augmentation size\n+\t.byte\t0x90\t; FDE Encoding (indirect pcrel)\n \t.byte\t0xc\t; DW_CFA_def_cfa\n \t.byte\t0x1\t; uleb128 0x1\n \t.byte\t0x0\t; uleb128 0x0\n \t.align\t2\n LECIE1:\n+.globl _ffi_call_DARWIN.eh\n+_ffi_call_DARWIN.eh:\n LSFDE1:\n \t.set\tL$set$1,LEFDE1-LASFDE1\n \t.long\tL$set$1\t; FDE Length\n LASFDE1:\n-\t.set\tL$set$2,LASFDE1-Lframe1\n-\t.long\tL$set$2\t; FDE CIE offset\n+\t.long\tLASFDE1-EH_frame1 ; FDE CIE offset\n \t.long\tLFB0-.\t; FDE initial location\n \t.set\tL$set$3,LFE1-LFB0\n \t.long\tL$set$3\t; FDE address range"}, {"sha": "13ee81d6049cd6b8da8d8519a6785b2f321e085e", "filename": "libffi/src/powerpc/darwin_closure.S", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4746cf844723522037d0f0688f2189edd706e7b7/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4746cf844723522037d0f0688f2189edd706e7b7/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S?ref=4746cf844723522037d0f0688f2189edd706e7b7", "patch": "@@ -234,8 +234,8 @@ Lfinish:\n /* END(ffi_closure_ASM)  */\n \n .data\n-.section __TEXT,__eh_frame\n-Lframe1:\n+.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms\n+EH_frame1:\n \t.set\tL$set$0,LECIE1-LSCIE1\n \t.long\tL$set$0\t; Length of Common Information Entry\n LSCIE1:\n@@ -246,19 +246,20 @@ LSCIE1:\n \t.byte\t0x7c\t; sleb128 -4; CIE Data Alignment Factor\n \t.byte\t0x41\t; CIE RA Column\n \t.byte\t0x1\t; uleb128 0x1; Augmentation size\n-\t.byte\t0x10\t; FDE Encoding (pcrel)\n+\t.byte\t0x90\t; FDE Encoding (indirect pcrel)\n \t.byte\t0xc\t; DW_CFA_def_cfa\n \t.byte\t0x1\t; uleb128 0x1\n \t.byte\t0x0\t; uleb128 0x0\n \t.align\t2\n LECIE1:\n+.globl _ffi_closure_ASM.eh\n+_ffi_closure_ASM.eh:\n LSFDE1:\n \t.set\tL$set$1,LEFDE1-LASFDE1\n \t.long\tL$set$1\t; FDE Length\n \n LASFDE1:\n-\t.set\tL$set$2,LASFDE1-Lframe1\n-\t.long\tL$set$2\t; FDE CIE offset\n+\t.long\tLASFDE1-EH_frame1\t; FDE CIE offset\n \t.long\tLFB1-.\t; FDE initial location\n \t.set\tL$set$3,LFE1-LFB1\n \t.long\tL$set$3\t; FDE address range"}]}