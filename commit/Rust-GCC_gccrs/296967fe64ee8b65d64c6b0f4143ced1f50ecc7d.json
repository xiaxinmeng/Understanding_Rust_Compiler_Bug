{"sha": "296967fe64ee8b65d64c6b0f4143ced1f50ecc7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk2OTY3ZmU2NGVlOGI2NWQ2NGM2YjBmNDE0M2NlZDFmNTBlY2M3ZA==", "commit": {"author": {"name": "John Wehle", "email": "john@feith.com", "date": "1999-04-20T10:18:33Z"}, "committer": {"name": "John Wehle", "email": "wehle@gcc.gnu.org", "date": "1999-04-20T10:18:33Z"}, "message": "i386.c (output_move_double): Abort if a non-offsettable memory operand is encountered.\n\n\t* i386.c (output_move_double): Abort if a non-offsettable\n\tmemory operand is encountered.  Delete unused code.\n\t(find_addr_reg): Remove.\n\nFrom-SVN: r26561", "tree": {"sha": "c66beb31756c33f451cb72266ed8b08d93587964", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c66beb31756c33f451cb72266ed8b08d93587964"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/296967fe64ee8b65d64c6b0f4143ced1f50ecc7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/296967fe64ee8b65d64c6b0f4143ced1f50ecc7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/296967fe64ee8b65d64c6b0f4143ced1f50ecc7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/296967fe64ee8b65d64c6b0f4143ced1f50ecc7d/comments", "author": {"login": "jlwehle", "id": 46985578, "node_id": "MDQ6VXNlcjQ2OTg1NTc4", "avatar_url": "https://avatars.githubusercontent.com/u/46985578?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlwehle", "html_url": "https://github.com/jlwehle", "followers_url": "https://api.github.com/users/jlwehle/followers", "following_url": "https://api.github.com/users/jlwehle/following{/other_user}", "gists_url": "https://api.github.com/users/jlwehle/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlwehle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlwehle/subscriptions", "organizations_url": "https://api.github.com/users/jlwehle/orgs", "repos_url": "https://api.github.com/users/jlwehle/repos", "events_url": "https://api.github.com/users/jlwehle/events{/privacy}", "received_events_url": "https://api.github.com/users/jlwehle/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "01f78a025e7e000b836ab9ff76ffc3b9958ba43e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01f78a025e7e000b836ab9ff76ffc3b9958ba43e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01f78a025e7e000b836ab9ff76ffc3b9958ba43e"}], "stats": {"total": 105, "additions": 18, "deletions": 87}, "files": [{"sha": "c31352a2b49a94ff667968d77a1b09b0e724d855", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296967fe64ee8b65d64c6b0f4143ced1f50ecc7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296967fe64ee8b65d64c6b0f4143ced1f50ecc7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=296967fe64ee8b65d64c6b0f4143ced1f50ecc7d", "patch": "@@ -1,3 +1,9 @@\n+Tue Apr 20 13:14:58 EDT 1999  John Wehle  (john@feith.com)\n+\n+\t* i386.c (output_move_double): Abort if a non-offsettable\n+\tmemory operand is encountered.  Delete unused code.\n+\t(find_addr_reg): Remove.\n+\n Mon Apr 19 21:13:02 1999  Craig Burley  <craig@jcb-sc.com>\n \n \t* tree.def (BLOCK): Fix typo in comment."}, {"sha": "854be258e25155ead25337c11c91f085aa0a6842", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 87, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/296967fe64ee8b65d64c6b0f4143ced1f50ecc7d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/296967fe64ee8b65d64c6b0f4143ced1f50ecc7d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=296967fe64ee8b65d64c6b0f4143ced1f50ecc7d", "patch": "@@ -992,32 +992,6 @@ singlemove_string (operands)\n     }\n }\n \f\n-/* Return a REG that occurs in ADDR with coefficient 1.\n-   ADDR can be effectively incremented by incrementing REG.  */\n-\n-static rtx\n-find_addr_reg (addr)\n-     rtx addr;\n-{\n-  while (GET_CODE (addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (addr, 0)) == REG)\n-\taddr = XEXP (addr, 0);\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\taddr = XEXP (addr, 1);\n-      else if (CONSTANT_P (XEXP (addr, 0)))\n-\taddr = XEXP (addr, 1);\n-      else if (CONSTANT_P (XEXP (addr, 1)))\n-\taddr = XEXP (addr, 0);\n-      else\n-\tabort ();\n-    }\n-\n-  if (GET_CODE (addr) == REG)\n-    return addr;\n-  abort ();\n-}\n-\f\n /* Output an insn to add the constant N to the register X.  */\n \n static void\n@@ -1055,7 +1029,6 @@ output_move_double (operands)\n   rtx latehalf[2];\n   rtx middlehalf[2];\n   rtx xops[2];\n-  rtx addreg0 = 0, addreg1 = 0;\n   int dest_overlapped_low = 0;\n   int size = GET_MODE_SIZE (GET_MODE (operands[0]));\n \n@@ -1092,11 +1065,14 @@ output_move_double (operands)\n   else\n     optype1 = RNDOP;\n \n-  /* Check for the cases that the operand constraints are not\n-     supposed to allow to happen.  Abort if we get one,\n-     because generating code for these cases is painful.  */\n+  /* Check for the cases that are not supposed to happen\n+     either due to the operand constraints or the fact\n+     that all memory operands on the x86 are offsettable.\n+     Abort if we get one, because generating code for these\n+     cases is painful.  */\n \n-  if (optype0 == RNDOP || optype1 == RNDOP)\n+  if (optype0 == RNDOP || optype1 == RNDOP\n+      || optype0 == MEMOP || optype1 == MEMOP)\n     abort ();\n \n   /* If one operand is decrementing and one is incrementing\n@@ -1131,15 +1107,6 @@ output_move_double (operands)\n       optype1 = OFFSOP;\n     }\n \n-  /* If an operand is an unoffsettable memory ref, find a register\n-     we can increment temporarily to make it refer to the second word.  */\n-\n-  if (optype0 == MEMOP)\n-    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n-\n-  if (optype1 == MEMOP)\n-    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n-\n   /* Ok, we can do one word at a time.\n      Normally we do the low-numbered word first,\n      but if either operand is autodecrementing then we\n@@ -1236,8 +1203,7 @@ output_move_double (operands)\n      emit the move late-half first.  Otherwise, compute the MEM address\n      into the upper part of N and use that as a pointer to the memory\n      operand.  */\n-  if (optype0 == REGOP\n-      && (optype1 == OFFSOP || optype1 == MEMOP))\n+  if (optype0 == REGOP && optype1 == OFFSOP)\n     {\n       if (reg_mentioned_p (operands[0], XEXP (operands[1], 0))\n \t  && reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n@@ -1269,10 +1235,6 @@ output_move_double (operands)\n \t\t|| reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n \t    goto compadr;\n \n-\t  /* JRV says this can't happen: */\n-\t  if (addreg0 || addreg1)\n-\t      abort ();\n-\n \t  /* Only the middle reg conflicts; simply put it last. */\n \t  output_asm_insn (singlemove_string (operands), operands);\n \t  output_asm_insn (singlemove_string (latehalf), latehalf);\n@@ -1307,29 +1269,11 @@ output_move_double (operands)\n \t      || REGNO (operands[0]) == REGNO (latehalf[1])))\n       || dest_overlapped_low)\n     {\n-      /* Make any unoffsettable addresses point at high-numbered word.  */\n-      if (addreg0)\n-\tasm_add (size-4, addreg0);\n-      if (addreg1)\n-\tasm_add (size-4, addreg1);\n-\n-      /* Do that word.  */\n+      /* Do the high-numbered word.  */\n       output_asm_insn (singlemove_string (latehalf), latehalf);\n \n-      /* Undo the adds we just did.  */\n-      if (addreg0)\n-\tasm_add (-4, addreg0);\n-      if (addreg1)\n-\tasm_add (-4, addreg1);\n-\n       if (size == 12)\n-        {\n-\t  output_asm_insn (singlemove_string (middlehalf), middlehalf);\n-\t  if (addreg0)\n-\t    asm_add (-4, addreg0);\n-\t  if (addreg1)\n-\t    asm_add (-4, addreg1);\n-\t}\n+\toutput_asm_insn (singlemove_string (middlehalf), middlehalf);\n \n       /* Do low-numbered word.  */\n       return singlemove_string (operands);\n@@ -1341,30 +1285,11 @@ output_move_double (operands)\n \n   /* Do the middle one of the three words for long double */\n   if (size == 12)\n-    {\n-      if (addreg0)\n-        asm_add (4, addreg0);\n-      if (addreg1)\n-        asm_add (4, addreg1);\n-\n-      output_asm_insn (singlemove_string (middlehalf), middlehalf);\n-    }\n-\n-  /* Make any unoffsettable addresses point at high-numbered word.  */\n-  if (addreg0)\n-    asm_add (4, addreg0);\n-  if (addreg1)\n-    asm_add (4, addreg1);\n+    output_asm_insn (singlemove_string (middlehalf), middlehalf);\n \n-  /* Do that word.  */\n+  /* Do the high-numbered word.  */\n   output_asm_insn (singlemove_string (latehalf), latehalf);\n \n-  /* Undo the adds we just did.  */\n-  if (addreg0)\n-    asm_add (4-size, addreg0);\n-  if (addreg1)\n-    asm_add (4-size, addreg1);\n-\n   return \"\";\n }\n \f"}]}