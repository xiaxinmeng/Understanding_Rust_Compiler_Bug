{"sha": "f324806d744dcc7874140dff1d11b738812ce2d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMyNDgwNmQ3NDRkY2M3ODc0MTQwZGZmMWQxMWI3Mzg4MTJjZTJkNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2015-09-09T17:18:15Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-09-09T17:18:15Z"}, "message": "nvptx.md (call_operation): Move bound out of loop.\n\n\t* config/nvptx/nvptx.md (call_operation): Move bound out of loop.\n\t(*cmp<mode>): Add assembler spacing.\n\t(setcc_int<mode>, set_cc_float<mode>): Likewise.\n\t* config/nvptx/nvptx.c (nvptx_option_override): Override debug\n\tlevel.\n\t(write_func_decl_from_insn): Refactor argument loops & comma emission.\n\t(nvptx_expand_call): Likewise.\n\t(nvptx_output_call_insn): Likewise.\n\t(nvptx_reorg_subreg): Add spacing.\n\nFrom-SVN: r227597", "tree": {"sha": "3a0aa0e1c8633367c8135d47e5e9e4ff01590a49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a0aa0e1c8633367c8135d47e5e9e4ff01590a49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f324806d744dcc7874140dff1d11b738812ce2d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f324806d744dcc7874140dff1d11b738812ce2d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f324806d744dcc7874140dff1d11b738812ce2d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f324806d744dcc7874140dff1d11b738812ce2d6/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2f1e8e7c4730bbc4bf15e85ecf4f954d1711db10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f1e8e7c4730bbc4bf15e85ecf4f954d1711db10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f1e8e7c4730bbc4bf15e85ecf4f954d1711db10"}], "stats": {"total": 150, "additions": 80, "deletions": 70}, "files": [{"sha": "4bb4e016849aab0d81868dd3fe2fc341c48eef33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f324806d744dcc7874140dff1d11b738812ce2d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f324806d744dcc7874140dff1d11b738812ce2d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f324806d744dcc7874140dff1d11b738812ce2d6", "patch": "@@ -1,3 +1,15 @@\n+2015-09-09  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx.md (call_operation): Move bound out of loop.\n+\t(*cmp<mode>): Add assembler spacing.\n+\t(setcc_int<mode>, set_cc_float<mode>): Likewise.\n+\t* config/nvptx/nvptx.c (nvptx_option_override): Override debug\n+\tlevel.\n+\t(write_func_decl_from_insn): Refactor argument loops & comma emission.\n+\t(nvptx_expand_call): Likewise.\n+\t(nvptx_output_call_insn): Likewise.\n+\t(nvptx_reorg_subreg): Add spacing.\n+\n 2015-09-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR middle-end/67512"}, {"sha": "32c34e5ff0cc7710d32a4086dc319974a318edcf", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 60, "deletions": 62, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f324806d744dcc7874140dff1d11b738812ce2d6/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f324806d744dcc7874140dff1d11b738812ce2d6/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=f324806d744dcc7874140dff1d11b738812ce2d6", "patch": "@@ -102,6 +102,8 @@ nvptx_option_override (void)\n   flag_toplevel_reorder = 1;\n   /* Assumes that it will see only hard registers.  */\n   flag_var_tracking = 0;\n+  write_symbols = NO_DEBUG;\n+  debug_info_level = DINFO_LEVEL_NONE;\n \n   declared_fndecls_htab = hash_table<tree_hasher>::create_ggc (17);\n   needed_fndecls_htab = hash_table<tree_hasher>::create_ggc (17);\n@@ -681,29 +683,30 @@ write_func_decl_from_insn (std::stringstream &s, rtx result, rtx pat,\n \n   s << name;\n \n-  int nargs = XVECLEN (pat, 0) - 1;\n-  if (nargs > 0)\n+  int arg_end = XVECLEN (pat, 0);\n+      \n+  if (1 < arg_end)\n     {\n+      const char *comma = \"\";\n       s << \" (\";\n-      for (int i = 0; i < nargs; i++)\n+      for (int i = 1; i < arg_end; i++)\n \t{\n-\t  rtx t = XEXP (XVECEXP (pat, 0, i + 1), 0);\n+\t  rtx t = XEXP (XVECEXP (pat, 0, i), 0);\n \t  machine_mode mode = GET_MODE (t);\n \t  int count = maybe_split_mode (&mode);\n \n-\t  while (count-- > 0)\n+\t  while (count--)\n \t    {\n-\t      s << \".param\";\n+\t      s << comma << \".param\";\n \t      s << nvptx_ptx_type_from_mode (mode, false);\n \t      s << \" \";\n \t      if (callprototype)\n \t\ts << \"_\";\n \t      else\n-\t\ts << \"%arg\" << i;\n+\t\ts << \"%arg\" << i - 1;\n \t      if (mode == QImode || mode == HImode)\n \t\ts << \"[1]\";\n-\t      if (i + 1 < nargs || count > 0)\n-\t\ts << \", \";\n+\t      comma = \", \";\n \t    }\n \t}\n       s << \")\";\n@@ -775,19 +778,17 @@ nvptx_end_call_args (void)\n void\n nvptx_expand_call (rtx retval, rtx address)\n {\n-  int nargs;\n+  int nargs = 0;\n   rtx callee = XEXP (address, 0);\n   rtx pat, t;\n   rtvec vec;\n   bool external_decl = false;\n+  rtx varargs = NULL_RTX;\n+  tree decl_type = NULL_TREE;\n \n-  nargs = 0;\n   for (t = cfun->machine->call_args; t; t = XEXP (t, 1))\n     nargs++;\n \n-  bool has_varargs = false;\n-  tree decl_type = NULL_TREE;\n-\n   if (!call_insn_operand (callee, Pmode))\n     {\n       callee = force_reg (Pmode, callee);\n@@ -814,31 +815,18 @@ nvptx_expand_call (rtx retval, rtx address)\n \t  || TREE_CODE (cfun->machine->funtype) == METHOD_TYPE)\n       && stdarg_p (cfun->machine->funtype))\n     {\n-      has_varargs = true;\n-      cfun->machine->has_call_with_varargs = true;\n-    }\n-  vec = rtvec_alloc (nargs + 1 + (has_varargs ? 1 : 0));\n-  pat = gen_rtx_PARALLEL (VOIDmode, vec);\n-  if (has_varargs)\n-    {\n-      rtx this_arg = gen_reg_rtx (Pmode);\n+      varargs = gen_reg_rtx (Pmode);\n       if (Pmode == DImode)\n-\temit_move_insn (this_arg, stack_pointer_rtx);\n+\temit_move_insn (varargs, stack_pointer_rtx);\n       else\n-\temit_move_insn (this_arg, stack_pointer_rtx);\n-      XVECEXP (pat, 0, nargs + 1) = gen_rtx_USE (VOIDmode, this_arg);\n-    }\n-\n-  /* Construct the call insn, including a USE for each argument pseudo\n-     register.  These will be used when printing the insn.  */\n-  int i;\n-  rtx arg;\n-  for (i = 1, arg = cfun->machine->call_args; arg; arg = XEXP (arg, 1), i++)\n-    {\n-      rtx this_arg = XEXP (arg, 0);\n-      XVECEXP (pat, 0, i) = gen_rtx_USE (VOIDmode, this_arg);\n+\temit_move_insn (varargs, stack_pointer_rtx);\n+      cfun->machine->has_call_with_varargs = true;\n     }\n+  vec = rtvec_alloc (nargs + 1 + (varargs ? 1 : 0));\n+  pat = gen_rtx_PARALLEL (VOIDmode, vec);\n \n+  int vec_pos = 0;\n+  \n   rtx tmp_retval = retval;\n   t = gen_rtx_CALL (VOIDmode, address, const0_rtx);\n   if (retval != NULL_RTX)\n@@ -847,7 +835,20 @@ nvptx_expand_call (rtx retval, rtx address)\n \ttmp_retval = gen_reg_rtx (GET_MODE (retval));\n       t = gen_rtx_SET (tmp_retval, t);\n     }\n-  XVECEXP (pat, 0, 0) = t;\n+  XVECEXP (pat, 0, vec_pos++) = t;\n+\n+  /* Construct the call insn, including a USE for each argument pseudo\n+     register.  These will be used when printing the insn.  */\n+  for (rtx arg = cfun->machine->call_args; arg; arg = XEXP (arg, 1))\n+    {\n+      rtx this_arg = XEXP (arg, 0);\n+      XVECEXP (pat, 0, vec_pos++) = gen_rtx_USE (VOIDmode, this_arg);\n+    }\n+\n+  if (varargs)\n+      XVECEXP (pat, 0, vec_pos++) = gen_rtx_USE (VOIDmode, varargs);\n+\n+  gcc_assert (vec_pos = XVECLEN (pat, 0));\n \n   /* If this is a libcall, decl_type is NULL. For a call to a non-libcall\n      undeclared function, we'll have an external decl without arg types.\n@@ -1498,16 +1499,14 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n   static int labelno;\n   bool needs_tgt = register_operand (callee, Pmode);\n   rtx pat = PATTERN (insn);\n-  int nargs = XVECLEN (pat, 0) - 1;\n+  int arg_end = XVECLEN (pat, 0);\n   tree decl = NULL_TREE;\n \n   fprintf (asm_out_file, \"\\t{\\n\");\n   if (result != NULL)\n-    {\n-      fprintf (asm_out_file, \"\\t\\t.param%s %%retval_in;\\n\",\n-\t       nvptx_ptx_type_from_mode (arg_promotion (GET_MODE (result)),\n-\t\t\t\t\t false));\n-    }\n+    fprintf (asm_out_file, \"\\t\\t.param%s %%retval_in;\\n\",\n+\t     nvptx_ptx_type_from_mode (arg_promotion (GET_MODE (result)),\n+\t\t\t\t       false));\n \n   /* Ensure we have a ptx declaration in the output if necessary.  */\n   if (GET_CODE (callee) == SYMBOL_REF)\n@@ -1527,20 +1526,20 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n       fputs (s.str().c_str(), asm_out_file);\n     }\n \n-  for (int i = 0, argno = 0; i < nargs; i++)\n+  for (int i = 1, argno = 0; i < arg_end; i++)\n     {\n-      rtx t = XEXP (XVECEXP (pat, 0, i + 1), 0);\n+      rtx t = XEXP (XVECEXP (pat, 0, i), 0);\n       machine_mode mode = GET_MODE (t);\n       int count = maybe_split_mode (&mode);\n \n-      while (count-- > 0)\n+      while (count--)\n \tfprintf (asm_out_file, \"\\t\\t.param%s %%out_arg%d%s;\\n\",\n \t\t nvptx_ptx_type_from_mode (mode, false), argno++,\n \t\t mode == QImode || mode == HImode ? \"[1]\" : \"\");\n     }\n-  for (int i = 0, argno = 0; i < nargs; i++)\n+  for (int i = 1, argno = 0; i < arg_end; i++)\n     {\n-      rtx t = XEXP (XVECEXP (pat, 0, i + 1), 0);\n+      rtx t = XEXP (XVECEXP (pat, 0, i), 0);\n       gcc_assert (REG_P (t));\n       machine_mode mode = GET_MODE (t);\n       int count = maybe_split_mode (&mode);\n@@ -1552,7 +1551,7 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n       else\n \t{\n \t  int n = 0;\n-\t  while (count-- > 0)\n+\t  while (count--)\n \t    fprintf (asm_out_file, \"\\t\\tst.param%s [%%out_arg%d], %%r%d$%d;\\n\",\n \t\t     nvptx_ptx_type_from_mode (mode, false), argno++,\n \t\t     REGNO (t), n++);\n@@ -1572,33 +1571,30 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n   else\n     output_address (callee);\n \n-  if (nargs > 0 || (decl && DECL_STATIC_CHAIN (decl)))\n+  if (arg_end > 1 || (decl && DECL_STATIC_CHAIN (decl)))\n     {\n+      const char *comma = \"\";\n+      \n       fprintf (asm_out_file, \", (\");\n-      int i, argno;\n-      for (i = 0, argno = 0; i < nargs; i++)\n+      for (int i = 1, argno = 0; i < arg_end; i++)\n \t{\n-\t  rtx t = XEXP (XVECEXP (pat, 0, i + 1), 0);\n+\t  rtx t = XEXP (XVECEXP (pat, 0, i), 0);\n \t  machine_mode mode = GET_MODE (t);\n \t  int count = maybe_split_mode (&mode);\n \n-\t  while (count-- > 0)\n+\t  while (count--)\n \t    {\n-\t      fprintf (asm_out_file, \"%%out_arg%d\", argno++);\n-\t      if (i + 1 < nargs || count > 0)\n-\t\tfprintf (asm_out_file, \", \");\n+\t      fprintf (asm_out_file, \"%s%%out_arg%d\", comma, argno++);\n+\t      comma = \", \";\n \t    }\n \t}\n       if (decl && DECL_STATIC_CHAIN (decl))\n-\t{\n-\t  if (i > 0)\n-\t    fprintf (asm_out_file, \", \");\n-\t  fprintf (asm_out_file, \"%s\",\n-\t\t   reg_names [OUTGOING_STATIC_CHAIN_REGNUM]);\n-\t}\n+\tfprintf (asm_out_file, \"%s%s\", comma,\n+\t\t reg_names [OUTGOING_STATIC_CHAIN_REGNUM]);\n \n       fprintf (asm_out_file, \")\");\n     }\n+\n   if (needs_tgt)\n     {\n       fprintf (asm_out_file, \", \");\n@@ -1922,12 +1918,14 @@ nvptx_reorg_subreg (void)\n \t  || GET_CODE (PATTERN (insn)) == USE\n \t  || GET_CODE (PATTERN (insn)) == CLOBBER)\n \tcontinue;\n+\n       qiregs.n_in_use = 0;\n       hiregs.n_in_use = 0;\n       siregs.n_in_use = 0;\n       diregs.n_in_use = 0;\n       extract_insn (insn);\n       enum attr_subregs_ok s_ok = get_attr_subregs_ok (insn);\n+\n       for (int i = 0; i < recog_data.n_operands; i++)\n \t{\n \t  rtx op = recog_data.operand[i];"}, {"sha": "049f34c6fbf1a91162d480dd547431c458fbecbe", "filename": "gcc/config/nvptx/nvptx.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f324806d744dcc7874140dff1d11b738812ce2d6/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f324806d744dcc7874140dff1d11b738812ce2d6/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=f324806d744dcc7874140dff1d11b738812ce2d6", "patch": "@@ -197,9 +197,9 @@\n (define_predicate \"call_operation\"\n   (match_code \"parallel\")\n {\n-  int i;\n+  int arg_end = XVECLEN (op, 0);\n \n-  for (i = 1; i < XVECLEN (op, 0); i++)\n+  for (int i = 1; i < arg_end; i++)\n     {\n       rtx elt = XVECEXP (op, 0, i);\n \n@@ -783,15 +783,15 @@\n \t   [(match_operand:HSDIM 2 \"nvptx_register_operand\" \"R\")\n \t    (match_operand:HSDIM 3 \"nvptx_nonmemory_operand\" \"Ri\")]))]\n   \"\"\n-  \"%.\\\\tsetp%c1 %0,%2,%3;\")\n+  \"%.\\\\tsetp%c1\\\\t%0, %2, %3;\")\n \n (define_insn \"*cmp<mode>\"\n   [(set (match_operand:BI 0 \"nvptx_register_operand\" \"=R\")\n \t(match_operator:BI 1 \"nvptx_float_comparison_operator\"\n \t   [(match_operand:SDFM 2 \"nvptx_register_operand\" \"R\")\n \t    (match_operand:SDFM 3 \"nvptx_nonmemory_operand\" \"RF\")]))]\n   \"\"\n-  \"%.\\\\tsetp%c1 %0,%2,%3;\")\n+  \"%.\\\\tsetp%c1\\\\t%0, %2, %3;\")\n \n (define_insn \"jump\"\n   [(set (pc)\n@@ -908,31 +908,31 @@\n \t  [(match_operand:HSDIM 2 \"nvptx_register_operand\" \"R\")\n \t   (match_operand:HSDIM 3 \"nvptx_nonmemory_operand\" \"Ri\")]))]\n   \"\"\n-  \"%.\\\\tset%t0%c1 %0,%2,%3;\")\n+  \"%.\\\\tset%t0%c1\\\\t%0, %2, %3;\")\n \n (define_insn \"setcc_int<mode>\"\n   [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n \t(match_operator:SI 1 \"nvptx_float_comparison_operator\"\n \t   [(match_operand:SDFM 2 \"nvptx_register_operand\" \"R\")\n \t    (match_operand:SDFM 3 \"nvptx_nonmemory_operand\" \"RF\")]))]\n   \"\"\n-  \"%.\\\\tset%t0%c1 %0,%2,%3;\")\n+  \"%.\\\\tset%t0%c1\\\\t%0, %2, %3;\")\n \n (define_insn \"setcc_float<mode>\"\n   [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n \t(match_operator:SF 1 \"nvptx_comparison_operator\"\n \t   [(match_operand:HSDIM 2 \"nvptx_register_operand\" \"R\")\n \t    (match_operand:HSDIM 3 \"nvptx_nonmemory_operand\" \"Ri\")]))]\n   \"\"\n-  \"%.\\\\tset%t0%c1 %0,%2,%3;\")\n+  \"%.\\\\tset%t0%c1\\\\t%0, %2, %3;\")\n \n (define_insn \"setcc_float<mode>\"\n   [(set (match_operand:SF 0 \"nvptx_register_operand\" \"=R\")\n \t(match_operator:SF 1 \"nvptx_float_comparison_operator\"\n \t   [(match_operand:SDFM 2 \"nvptx_register_operand\" \"R\")\n \t    (match_operand:SDFM 3 \"nvptx_nonmemory_operand\" \"RF\")]))]\n   \"\"\n-  \"%.\\\\tset%t0%c1 %0,%2,%3;\")\n+  \"%.\\\\tset%t0%c1\\\\t%0, %2, %3;\")\n \n (define_expand \"cstorebi4\"\n   [(set (match_operand:SI 0 \"nvptx_register_operand\")"}]}