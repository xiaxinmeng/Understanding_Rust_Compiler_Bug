{"sha": "ca2b325127fdbacb4c2073e26a5191af17f126e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EyYjMyNTEyN2ZkYmFjYjRjMjA3M2UyNmE1MTkxYWYxN2YxMjZlNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-07-23T18:08:04Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-07-23T18:08:04Z"}, "message": "update\n\nFrom-SVN: r21352", "tree": {"sha": "f8b4535e4e88e3ddc9d7cfcac57f4317a96e7794", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8b4535e4e88e3ddc9d7cfcac57f4317a96e7794"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca2b325127fdbacb4c2073e26a5191af17f126e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca2b325127fdbacb4c2073e26a5191af17f126e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca2b325127fdbacb4c2073e26a5191af17f126e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca2b325127fdbacb4c2073e26a5191af17f126e4/comments", "author": null, "committer": null, "parents": [{"sha": "a38fe5356df7d7b1a551a01e934139b5f14a07e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38fe5356df7d7b1a551a01e934139b5f14a07e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a38fe5356df7d7b1a551a01e934139b5f14a07e4"}], "stats": {"total": 209, "additions": 120, "deletions": 89}, "files": [{"sha": "138a8a046b56cc2098936df75664d91c3e54b86e", "filename": "gcc/cexp.c", "status": "modified", "additions": 120, "deletions": 89, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca2b325127fdbacb4c2073e26a5191af17f126e4/gcc%2Fcexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca2b325127fdbacb4c2073e26a5191af17f126e4/gcc%2Fcexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcexp.c?ref=ca2b325127fdbacb4c2073e26a5191af17f126e4", "patch": "@@ -35,12 +35,12 @@\n #include \"system.h\"\n #include <setjmp.h>\n /* #define YYDEBUG 1 */\n+#include \"gansidecl.h\"\n \n #ifdef MULTIBYTE_CHARS\n+#include \"mbchar.h\"\n #include <locale.h>\n-#endif\n-\n-#include \"gansidecl.h\"\n+#endif /* MULTIBYTE_CHARS */\n \n typedef unsigned char U_CHAR;\n \n@@ -187,7 +187,7 @@ static void integer_overflow PROTO((void));\n #define SIGNED (~0)\n #define UNSIGNED 0\n \n-#line 251 \"cexp.y\"\n+#line 195 \"cexp.y\"\n typedef union {\n   struct constant {HOST_WIDE_INT value; int signedp;} integer;\n   struct name {U_CHAR *address; int length;} name;\n@@ -268,10 +268,10 @@ static const short yyrhs[] = {    35,\n \n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n-   281,   291,   292,   299,   304,   307,   309,   312,   316,   318,\n-   323,   328,   341,   358,   371,   377,   383,   389,   395,   398,\n-   401,   408,   415,   422,   429,   432,   435,   438,   441,   444,\n-   447,   450,   452,   455,   458,   460,   462,   470,   472,   485\n+   225,   235,   236,   243,   248,   251,   253,   256,   260,   262,\n+   267,   272,   285,   302,   315,   321,   327,   333,   339,   342,\n+   345,   352,   359,   366,   373,   376,   379,   382,   385,   388,\n+   391,   394,   396,   399,   402,   404,   406,   414,   416,   429\n };\n #endif\n \n@@ -377,7 +377,7 @@ static const short yycheck[] = {     4,\n     26,    27,    23,    24,    25,    26,    27,     0,     9\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/cygnus/latest-940103/share/bison.simple\"\n+#line 3 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -570,7 +570,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/cygnus/latest-940103/share/bison.simple\"\n+#line 196 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -875,7 +875,7 @@ yyparse(YYPARSE_PARAM_ARG)\n   switch (yyn) {\n \n case 1:\n-#line 282 \"cexp.y\"\n+#line 226 \"cexp.y\"\n {\n \t\t  expression_value = yyvsp[0].integer.value;\n #ifdef TEST_EXP_READER\n@@ -884,55 +884,55 @@ case 1:\n \t\t;\n     break;}\n case 3:\n-#line 293 \"cexp.y\"\n+#line 237 \"cexp.y\"\n { if (pedantic)\n \t\t\t    pedwarn (\"comma operator in operand of `#if'\");\n \t\t\t  yyval.integer = yyvsp[0].integer; ;\n     break;}\n case 4:\n-#line 300 \"cexp.y\"\n+#line 244 \"cexp.y\"\n { yyval.integer.value = - yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[0].integer.signedp;\n \t\t\t  if ((yyval.integer.value & yyvsp[0].integer.value & yyval.integer.signedp) < 0)\n \t\t\t    integer_overflow (); ;\n     break;}\n case 5:\n-#line 305 \"cexp.y\"\n+#line 249 \"cexp.y\"\n { yyval.integer.value = ! yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 6:\n-#line 308 \"cexp.y\"\n+#line 252 \"cexp.y\"\n { yyval.integer = yyvsp[0].integer; ;\n     break;}\n case 7:\n-#line 310 \"cexp.y\"\n+#line 254 \"cexp.y\"\n { yyval.integer.value = ~ yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[0].integer.signedp; ;\n     break;}\n case 8:\n-#line 313 \"cexp.y\"\n+#line 257 \"cexp.y\"\n { yyval.integer.value = check_assertion (yyvsp[0].name.address, yyvsp[0].name.length,\n \t\t\t\t\t\t      0, NULL_PTR);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 9:\n-#line 317 \"cexp.y\"\n+#line 261 \"cexp.y\"\n { keyword_parsing = 1; ;\n     break;}\n case 10:\n-#line 319 \"cexp.y\"\n+#line 263 \"cexp.y\"\n { yyval.integer.value = check_assertion (yyvsp[-4].name.address, yyvsp[-4].name.length,\n \t\t\t\t\t\t      1, yyvsp[-1].keywords);\n \t\t\t  keyword_parsing = 0;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 11:\n-#line 324 \"cexp.y\"\n+#line 268 \"cexp.y\"\n { yyval.integer = yyvsp[-1].integer; ;\n     break;}\n case 12:\n-#line 329 \"cexp.y\"\n+#line 273 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (yyval.integer.signedp)\n \t\t\t    {\n@@ -947,7 +947,7 @@ case 12:\n \t\t\t\t\t* yyvsp[0].integer.value); ;\n     break;}\n case 13:\n-#line 342 \"cexp.y\"\n+#line 286 \"cexp.y\"\n { if (yyvsp[0].integer.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n@@ -966,7 +966,7 @@ case 13:\n \t\t\t\t\t/ yyvsp[0].integer.value); ;\n     break;}\n case 14:\n-#line 359 \"cexp.y\"\n+#line 303 \"cexp.y\"\n { if (yyvsp[0].integer.value == 0)\n \t\t\t    {\n \t\t\t      if (!skip_evaluation)\n@@ -981,49 +981,49 @@ case 14:\n \t\t\t\t\t% yyvsp[0].integer.value); ;\n     break;}\n case 15:\n-#line 372 \"cexp.y\"\n+#line 316 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value + yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (overflow_sum_sign (yyvsp[-2].integer.value, yyvsp[0].integer.value,\n \t\t\t\t\t\t yyval.integer.value, yyval.integer.signedp))\n \t\t\t    integer_overflow (); ;\n     break;}\n case 16:\n-#line 378 \"cexp.y\"\n+#line 322 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value - yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp;\n \t\t\t  if (overflow_sum_sign (yyval.integer.value, yyvsp[0].integer.value,\n \t\t\t\t\t\t yyvsp[-2].integer.value, yyval.integer.signedp))\n \t\t\t    integer_overflow (); ;\n     break;}\n case 17:\n-#line 384 \"cexp.y\"\n+#line 328 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp;\n \t\t\t  if ((yyvsp[0].integer.value & yyvsp[0].integer.signedp) < 0)\n \t\t\t    yyval.integer.value = right_shift (&yyvsp[-2].integer, -yyvsp[0].integer.value);\n \t\t\t  else\n \t\t\t    yyval.integer.value = left_shift (&yyvsp[-2].integer, yyvsp[0].integer.value); ;\n     break;}\n case 18:\n-#line 390 \"cexp.y\"\n+#line 334 \"cexp.y\"\n { yyval.integer.signedp = yyvsp[-2].integer.signedp;\n \t\t\t  if ((yyvsp[0].integer.value & yyvsp[0].integer.signedp) < 0)\n \t\t\t    yyval.integer.value = left_shift (&yyvsp[-2].integer, -yyvsp[0].integer.value);\n \t\t\t  else\n \t\t\t    yyval.integer.value = right_shift (&yyvsp[-2].integer, yyvsp[0].integer.value); ;\n     break;}\n case 19:\n-#line 396 \"cexp.y\"\n+#line 340 \"cexp.y\"\n { yyval.integer.value = (yyvsp[-2].integer.value == yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 20:\n-#line 399 \"cexp.y\"\n+#line 343 \"cexp.y\"\n { yyval.integer.value = (yyvsp[-2].integer.value != yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 21:\n-#line 402 \"cexp.y\"\n+#line 346 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value <= yyvsp[0].integer.value;\n@@ -1032,7 +1032,7 @@ case 21:\n \t\t\t\t\t<= yyvsp[0].integer.value); ;\n     break;}\n case 22:\n-#line 409 \"cexp.y\"\n+#line 353 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value >= yyvsp[0].integer.value;\n@@ -1041,7 +1041,7 @@ case 22:\n \t\t\t\t\t>= yyvsp[0].integer.value); ;\n     break;}\n case 23:\n-#line 416 \"cexp.y\"\n+#line 360 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value < yyvsp[0].integer.value;\n@@ -1050,7 +1050,7 @@ case 23:\n \t\t\t\t\t< yyvsp[0].integer.value); ;\n     break;}\n case 24:\n-#line 423 \"cexp.y\"\n+#line 367 \"cexp.y\"\n { yyval.integer.signedp = SIGNED;\n \t\t\t  if (yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp)\n \t\t\t    yyval.integer.value = yyvsp[-2].integer.value > yyvsp[0].integer.value;\n@@ -1059,76 +1059,76 @@ case 24:\n \t\t\t\t\t> yyvsp[0].integer.value); ;\n     break;}\n case 25:\n-#line 430 \"cexp.y\"\n+#line 374 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value & yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 26:\n-#line 433 \"cexp.y\"\n+#line 377 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value ^ yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 27:\n-#line 436 \"cexp.y\"\n+#line 380 \"cexp.y\"\n { yyval.integer.value = yyvsp[-2].integer.value | yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-2].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 28:\n-#line 439 \"cexp.y\"\n+#line 383 \"cexp.y\"\n { skip_evaluation += !yyvsp[-1].integer.value; ;\n     break;}\n case 29:\n-#line 441 \"cexp.y\"\n+#line 385 \"cexp.y\"\n { skip_evaluation -= !yyvsp[-3].integer.value;\n \t\t\t  yyval.integer.value = (yyvsp[-3].integer.value && yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 30:\n-#line 445 \"cexp.y\"\n+#line 389 \"cexp.y\"\n { skip_evaluation += !!yyvsp[-1].integer.value; ;\n     break;}\n case 31:\n-#line 447 \"cexp.y\"\n+#line 391 \"cexp.y\"\n { skip_evaluation -= !!yyvsp[-3].integer.value;\n \t\t\t  yyval.integer.value = (yyvsp[-3].integer.value || yyvsp[0].integer.value);\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 32:\n-#line 451 \"cexp.y\"\n+#line 395 \"cexp.y\"\n { skip_evaluation += !yyvsp[-1].integer.value; ;\n     break;}\n case 33:\n-#line 453 \"cexp.y\"\n+#line 397 \"cexp.y\"\n { skip_evaluation += !!yyvsp[-4].integer.value - !yyvsp[-4].integer.value; ;\n     break;}\n case 34:\n-#line 455 \"cexp.y\"\n+#line 399 \"cexp.y\"\n { skip_evaluation -= !!yyvsp[-6].integer.value;\n \t\t\t  yyval.integer.value = yyvsp[-6].integer.value ? yyvsp[-3].integer.value : yyvsp[0].integer.value;\n \t\t\t  yyval.integer.signedp = yyvsp[-3].integer.signedp & yyvsp[0].integer.signedp; ;\n     break;}\n case 35:\n-#line 459 \"cexp.y\"\n+#line 403 \"cexp.y\"\n { yyval.integer = yylval.integer; ;\n     break;}\n case 36:\n-#line 461 \"cexp.y\"\n+#line 405 \"cexp.y\"\n { yyval.integer = yylval.integer; ;\n     break;}\n case 37:\n-#line 463 \"cexp.y\"\n+#line 407 \"cexp.y\"\n { if (warn_undef && !skip_evaluation)\n \t\t\t    warning (\"`%.*s' is not defined\",\n \t\t\t\t     yyvsp[0].name.length, yyvsp[0].name.address);\n \t\t\t  yyval.integer.value = 0;\n \t\t\t  yyval.integer.signedp = SIGNED; ;\n     break;}\n case 38:\n-#line 471 \"cexp.y\"\n+#line 415 \"cexp.y\"\n { yyval.keywords = 0; ;\n     break;}\n case 39:\n-#line 473 \"cexp.y\"\n+#line 417 \"cexp.y\"\n { struct arglist *temp;\n \t\t\t  yyval.keywords = (struct arglist *) xmalloc (sizeof (struct arglist));\n \t\t\t  yyval.keywords->next = yyvsp[-2].keywords;\n@@ -1143,15 +1143,15 @@ case 39:\n \t\t\t  temp->next->length = 1; ;\n     break;}\n case 40:\n-#line 486 \"cexp.y\"\n+#line 430 \"cexp.y\"\n { yyval.keywords = (struct arglist *) xmalloc (sizeof (struct arglist));\n \t\t\t  yyval.keywords->name = yyvsp[-1].name.address;\n \t\t\t  yyval.keywords->length = yyvsp[-1].name.length;\n \t\t\t  yyval.keywords->next = yyvsp[0].keywords; ;\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/cygnus/latest-940103/share/bison.simple\"\n+#line 498 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -1347,7 +1347,7 @@ case 40:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 491 \"cexp.y\"\n+#line 435 \"cexp.y\"\n \n \f\n /* During parsing of a C expression, the pointer to the next character\n@@ -1557,23 +1557,18 @@ yylex ()\n     {\n       register HOST_WIDE_INT result = 0;\n       register int num_chars = 0;\n+      int chars_seen = 0;\n       unsigned width = MAX_CHAR_TYPE_SIZE;\n       int max_chars;\n-      char *token_buffer;\n-\n-      if (wide_flag)\n-\t{\n-\t  width = MAX_WCHAR_TYPE_SIZE;\n #ifdef MULTIBYTE_CHARS\n-\t  max_chars = MB_CUR_MAX;\n-#else\n-\t  max_chars = 1;\n+      int longest_char = local_mb_cur_max ();\n+      char *token_buffer = (char *) alloca (longest_char);\n+      (void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n #endif\n-\t}\n-      else\n-\tmax_chars = MAX_LONG_TYPE_SIZE / width;\n \n-      token_buffer = (char *) alloca (max_chars + 1);\n+      max_chars = MAX_LONG_TYPE_SIZE / width;\n+      if (wide_flag)\n+\twidth = MAX_WCHAR_TYPE_SIZE;\n \n       while (1)\n \t{\n@@ -1582,44 +1577,96 @@ yylex ()\n \t  if (c == '\\'' || c == EOF)\n \t    break;\n \n+\t  ++chars_seen;\n \t  if (c == '\\\\')\n \t    {\n \t      c = parse_escape (&lexptr, mask);\n \t    }\n+\t  else\n+\t    {\n+#ifdef MULTIBYTE_CHARS\n+\t      wchar_t wc;\n+\t      int i;\n+\t      int char_len = -1;\n+\t      for (i = 1; i <= longest_char; ++i)\n+\t\t{\n+\t\t  token_buffer[i - 1] = c;\n+\t\t  char_len = local_mbtowc (& wc, token_buffer, i);\n+\t\t  if (char_len != -1)\n+\t\t    break;\n+\t\t  c = *lexptr++;\n+\t\t}\n+\t      if (char_len > 1)\n+\t\t{\n+\t\t  /* mbtowc sometimes needs an extra char before accepting */\n+\t\t  if (char_len < i)\n+\t\t    lexptr--;\n+\t\t  if (! wide_flag)\n+\t\t    {\n+\t\t      /* Merge character into result; ignore excess chars.  */\n+\t\t      for (i = 1; i <= char_len; ++i)\n+\t\t\t{\n+\t\t\t  if (i > max_chars)\n+\t\t\t    break;\n+\t\t\t  if (width < HOST_BITS_PER_INT)\n+\t\t\t    result = (result << width)\n+\t\t\t      | (token_buffer[i - 1]\n+\t\t\t\t & ((1 << width) - 1));\n+\t\t\t  else\n+\t\t\t    result = token_buffer[i - 1];\n+\t\t\t}\n+\t\t      num_chars += char_len;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (char_len == -1)\n+\t\t    warning (\"Ignoring invalid multibyte character\");\n+\t\t}\n+\t      if (wide_flag)\n+\t\tc = wc;\n+#endif /* ! MULTIBYTE_CHARS */\n+\t    }\n \n-\t  num_chars++;\n+\t  if (wide_flag)\n+\t    {\n+\t      if (chars_seen == 1) /* only keep the first one */\n+\t\tresult = c;\n+\t      continue;\n+\t    }\n \n \t  /* Merge character into result; ignore excess chars.  */\n+\t  num_chars++;\n \t  if (num_chars <= max_chars)\n \t    {\n-\t      if (width < HOST_BITS_PER_WIDE_INT)\n-\t\tresult = (result << width) | c;\n+\t      if (width < HOST_BITS_PER_INT)\n+\t\tresult = (result << width) | (c & ((1 << width) - 1));\n \t      else\n \t\tresult = c;\n-\t      token_buffer[num_chars - 1] = c;\n \t    }\n \t}\n \n-      token_buffer[num_chars] = 0;\n-\n       if (c != '\\'')\n \terror (\"malformatted character constant\");\n-      else if (num_chars == 0)\n+      else if (chars_seen == 0)\n \terror (\"empty character constant\");\n       else if (num_chars > max_chars)\n \t{\n \t  num_chars = max_chars;\n \t  error (\"character constant too long\");\n \t}\n-      else if (num_chars != 1 && ! traditional)\n+      else if (chars_seen != 1 && ! traditional)\n \twarning (\"multi-character character constant\");\n \n       /* If char type is signed, sign-extend the constant.  */\n       if (! wide_flag)\n \t{\n \t  int num_bits = num_chars * width;\n-\n-\t  if (lookup ((U_CHAR *) \"__CHAR_UNSIGNED__\",\n+\t  if (num_bits == 0)\n+\t    /* We already got an error; avoid invalid shift.  */\n+\t    yylval.integer.value = 0;\n+\t  else if (lookup ((U_CHAR *) \"__CHAR_UNSIGNED__\",\n \t\t      sizeof (\"__CHAR_UNSIGNED__\") - 1, -1)\n \t      || ((result >> (num_bits - 1)) & 1) == 0)\n \t    yylval.integer.value\n@@ -1632,22 +1679,6 @@ yylex ()\n \t}\n       else\n \t{\n-#ifdef MULTIBYTE_CHARS\n-\t  /* Set the initial shift state and convert the next sequence.  */\n-\t  result = 0;\n-\t  /* In all locales L'\\0' is zero and mbtowc will return zero,\n-\t     so don't use it.  */\n-\t  if (num_chars > 1\n-\t      || (num_chars == 1 && token_buffer[0] != '\\0'))\n-\t    {\n-\t      wchar_t wc;\n-\t      (void) mbtowc (NULL_PTR, NULL_PTR, 0);\n-\t      if (mbtowc (& wc, token_buffer, num_chars) == num_chars)\n-\t\tresult = wc;\n-\t      else\n-\t\tpedwarn (\"Ignoring invalid multibyte character\");\n-\t    }\n-#endif\n \t  yylval.integer.value = result;\n \t}\n     }"}]}