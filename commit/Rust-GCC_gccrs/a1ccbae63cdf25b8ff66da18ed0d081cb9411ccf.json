{"sha": "a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFjY2JhZTYzY2RmMjViOGZmNjZkYTE4ZWQwZDA4MWNiOTQxMWNjZg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-04-13T09:25:26Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-04-13T09:35:28Z"}, "message": "d: Merge update dmd 799066f49\n\nRemoves the implementation of __traits(argTypes), which only supported\nx86_64 targets.  The only use of this trait is an unused va_arg()\nfunction, this has been removed as well.\n\nReviewed-on: https://github.com/dlang/dmd/pull/11022\n\ngcc/d/ChangeLog:\n\n2020-04-13  Iain Buclaw  <ibuclaw@gdcproject.org>\n\n\t* Make-lang.in (D_FRONTEND_OBJS): Remove d/argtypes.o.\n\t* d-target.cc (Target::toArgTypes): New function.\n\nlibphobos/ChangeLog:\n\n2020-04-13  Iain Buclaw  <ibuclaw@gdcproject.org>\n\n\t* libdruntime/core/stdc/stdarg.d: Remove run-time va_list template.", "tree": {"sha": "5c0266feb2fee3b909db9586eebd8bc8a9afc560", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c0266feb2fee3b909db9586eebd8bc8a9afc560"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af4c92573dc462a17a6c345756889d28054ed591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af4c92573dc462a17a6c345756889d28054ed591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af4c92573dc462a17a6c345756889d28054ed591"}], "stats": {"total": 792, "additions": 28, "deletions": 764}, "files": [{"sha": "6544b3d324e2b38139503475ff760f1306baeede", "filename": "gcc/d/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FChangeLog?ref=a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "patch": "@@ -1,3 +1,8 @@\n+2020-04-13  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* Make-lang.in (D_FRONTEND_OBJS): Remove d/argtypes.o.\n+\t* d-target.cc (Target::toArgTypes): New function.\n+\n 2020-04-10  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* d-spec.cc (LIBDRUNTIME): Remove."}, {"sha": "ac04d074aa5543d9954f74e3ff4214daf4a6b7ad", "filename": "gcc/d/Make-lang.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FMake-lang.in?ref=a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "patch": "@@ -59,7 +59,6 @@ D_FRONTEND_OBJS = \\\n \td/access.o \\\n \td/aliasthis.o \\\n \td/apply.o \\\n-\td/argtypes.o \\\n \td/arrayop.o \\\n \td/attrib.o \\\n \td/blockexit.o \\"}, {"sha": "b2df26605797e5281824c8f2e6697bc10d25ff5c", "filename": "gcc/d/d-target.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2Fd-target.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2Fd-target.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.cc?ref=a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "patch": "@@ -410,3 +410,15 @@ Target::systemLinkage (void)\n {\n   return LINKc;\n }\n+\n+/* Generate a TypeTuple of the equivalent types used to determine if a\n+   function argument of the given type can be passed in registers.\n+   The results of this are highly platform dependent, and intended\n+   primarly for use in implementing va_arg() with RTTI.  */\n+\n+TypeTuple *\n+Target::toArgTypes (Type *)\n+{\n+  /* Not implemented, however this is not currently used anywhere.  */\n+  return NULL;\n+}"}, {"sha": "dc9fb1b8d97100d2ccafaa65184d2426e2a39d71", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "patch": "@@ -1,4 +1,4 @@\n-3e10e2dd29e583f1d94d84de5e4bd858e0303669\n+799066f498aebcfa420df284cac1f204b1f953a8\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "bed1d4020abdff77f207406247eadc7d0ac7fee3", "filename": "gcc/d/dmd/argtypes.c", "status": "removed", "additions": 0, "deletions": 484, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4c92573dc462a17a6c345756889d28054ed591/gcc%2Fd%2Fdmd%2Fargtypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4c92573dc462a17a6c345756889d28054ed591/gcc%2Fd%2Fdmd%2Fargtypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fargtypes.c?ref=af4c92573dc462a17a6c345756889d28054ed591", "patch": "@@ -1,484 +0,0 @@\n-\n-/* Compiler implementation of the D programming language\n- * Copyright (C) 2010-2019 by The D Language Foundation, All Rights Reserved\n- * written by Walter Bright\n- * http://www.digitalmars.com\n- * Distributed under the Boost Software License, Version 1.0.\n- * http://www.boost.org/LICENSE_1_0.txt\n- * https://github.com/D-Programming-Language/dmd/blob/master/src/argtypes.c\n- */\n-\n-#include \"root/dsystem.h\"\n-#include \"root/checkedint.h\"\n-\n-#include \"mars.h\"\n-#include \"dsymbol.h\"\n-#include \"mtype.h\"\n-#include \"scope.h\"\n-#include \"init.h\"\n-#include \"expression.h\"\n-#include \"attrib.h\"\n-#include \"declaration.h\"\n-#include \"template.h\"\n-#include \"id.h\"\n-#include \"enum.h\"\n-#include \"import.h\"\n-#include \"aggregate.h\"\n-#include \"hdrgen.h\"\n-\n-/****************************************************\n- * This breaks a type down into 'simpler' types that can be passed to a function\n- * in registers, and returned in registers.\n- * It's highly platform dependent.\n- * Params:\n- *      t = type to break down\n- * Returns:\n- *      tuple of types, each element can be passed in a register.\n- *      A tuple of zero length means the type cannot be passed/returned in registers.\n- */\n-\n-TypeTuple *toArgTypes(Type *t)\n-{\n-    class ToArgTypes : public Visitor\n-    {\n-    public:\n-        TypeTuple *result;\n-\n-        ToArgTypes()\n-        {\n-            result = NULL;\n-        }\n-\n-        void visit(Type *)\n-        {\n-            // not valid for a parameter\n-        }\n-\n-        void visit(TypeError *)\n-        {\n-            result = new TypeTuple(Type::terror);\n-        }\n-\n-        void visit(TypeBasic *t)\n-        {\n-            Type *t1 = NULL;\n-            Type *t2 = NULL;\n-            switch (t->ty)\n-            {\n-                case Tvoid:\n-                     return;\n-\n-                case Tbool:\n-                case Tint8:\n-                case Tuns8:\n-                case Tint16:\n-                case Tuns16:\n-                case Tint32:\n-                case Tuns32:\n-                case Tfloat32:\n-                case Tint64:\n-                case Tuns64:\n-                case Tint128:\n-                case Tuns128:\n-                case Tfloat64:\n-                case Tfloat80:\n-                    t1 = t;\n-                    break;\n-\n-                case Timaginary32:\n-                    t1 = Type::tfloat32;\n-                    break;\n-\n-                case Timaginary64:\n-                    t1 = Type::tfloat64;\n-                    break;\n-\n-                case Timaginary80:\n-                    t1 = Type::tfloat80;\n-                    break;\n-\n-                case Tcomplex32:\n-                    if (global.params.is64bit)\n-                        t1 = Type::tfloat64;\n-                    else\n-                    {\n-                        t1 = Type::tfloat64;\n-                        t2 = Type::tfloat64;\n-                    }\n-                    break;\n-\n-                case Tcomplex64:\n-                    t1 = Type::tfloat64;\n-                    t2 = Type::tfloat64;\n-                    break;\n-\n-                case Tcomplex80:\n-                    t1 = Type::tfloat80;\n-                    t2 = Type::tfloat80;\n-                    break;\n-\n-                case Tchar:\n-                    t1 = Type::tuns8;\n-                    break;\n-\n-                case Twchar:\n-                    t1 = Type::tuns16;\n-                    break;\n-\n-                case Tdchar:\n-                    t1 = Type::tuns32;\n-                    break;\n-\n-                default:\n-                    assert(0);\n-            }\n-\n-            if (t1)\n-            {\n-                if (t2)\n-                    result = new TypeTuple(t1, t2);\n-                else\n-                    result = new TypeTuple(t1);\n-            }\n-            else\n-                result = new TypeTuple();\n-        }\n-\n-        void visit(TypeVector *t)\n-        {\n-            result = new TypeTuple(t);\n-        }\n-\n-        void visit(TypeSArray *t)\n-        {\n-            if (t->dim)\n-            {\n-                /* Should really be done as if it were a struct with dim members\n-                 * of the array's elements.\n-                 * I.e. int[2] should be done like struct S { int a; int b; }\n-                 */\n-                dinteger_t sz = t->dim->toInteger();\n-                // T[1] should be passed like T\n-                if (sz == 1)\n-                {\n-                    t->next->accept(this);\n-                    return;\n-                }\n-            }\n-            result = new TypeTuple();     // pass on the stack for efficiency\n-        }\n-\n-        void visit(TypeAArray *)\n-        {\n-            result = new TypeTuple(Type::tvoidptr);\n-        }\n-\n-        void visit(TypePointer *)\n-        {\n-            result = new TypeTuple(Type::tvoidptr);\n-        }\n-\n-        /*************************************\n-         * Convert a floating point type into the equivalent integral type.\n-         */\n-\n-        static Type *mergeFloatToInt(Type *t)\n-        {\n-            switch (t->ty)\n-            {\n-                case Tfloat32:\n-                case Timaginary32:\n-                    t = Type::tint32;\n-                    break;\n-                case Tfloat64:\n-                case Timaginary64:\n-                case Tcomplex32:\n-                    t = Type::tint64;\n-                    break;\n-                default:\n-                    assert(0);\n-            }\n-            return t;\n-        }\n-\n-        /*************************************\n-         * This merges two types into an 8byte type.\n-         * Params:\n-         *      t1 = first type (can be null)\n-         *      t2 = second type (can be null)\n-         *      offset2 = offset of t2 from start of t1\n-         * Returns:\n-         *      type that encompasses both t1 and t2, null if cannot be done\n-         */\n-\n-        static Type *argtypemerge(Type *t1, Type *t2, unsigned offset2)\n-        {\n-            //printf(\"argtypemerge(%s, %s, %d)\\n\", t1 ? t1->toChars() : \"\", t2 ? t2->toChars() : \"\", offset2);\n-            if (!t1)\n-            {   assert(!t2 || offset2 == 0);\n-                return t2;\n-            }\n-            if (!t2)\n-                return t1;\n-\n-            const d_uns64 sz1 = t1->size(Loc());\n-            const d_uns64 sz2 = t2->size(Loc());\n-            assert(sz1 != SIZE_INVALID && sz2 != SIZE_INVALID);\n-\n-            if (t1->ty != t2->ty &&\n-                (t1->ty == Tfloat80 || t2->ty == Tfloat80))\n-                return NULL;\n-\n-            // [float,float] => [cfloat]\n-            if (t1->ty == Tfloat32 && t2->ty == Tfloat32 && offset2 == 4)\n-                return Type::tfloat64;\n-\n-            // Merging floating and non-floating types produces the non-floating type\n-            if (t1->isfloating())\n-            {\n-                if (!t2->isfloating())\n-                    t1 = mergeFloatToInt(t1);\n-            }\n-            else if (t2->isfloating())\n-                t2 = mergeFloatToInt(t2);\n-\n-            Type *t;\n-\n-            // Pick type with larger size\n-            if (sz1 < sz2)\n-                t = t2;\n-            else\n-                t = t1;\n-\n-            // If t2 does not lie within t1, need to increase the size of t to enclose both\n-            assert(sz2 < UINT64_MAX - UINT32_MAX);\n-            if (offset2 && sz1 < offset2 + sz2)\n-            {\n-                switch (offset2 + sz2)\n-                {\n-                    case 2:\n-                        t = Type::tint16;\n-                        break;\n-                    case 3:\n-                    case 4:\n-                        t = Type::tint32;\n-                        break;\n-                    default:\n-                        t = Type::tint64;\n-                        break;\n-                }\n-            }\n-            return t;\n-        }\n-\n-        void visit(TypeDArray *)\n-        {\n-            /* Should be done as if it were:\n-             * struct S { size_t length; void* ptr; }\n-             */\n-            if (global.params.is64bit && !global.params.isLP64)\n-            {\n-                // For AMD64 ILP32 ABI, D arrays fit into a single integer register.\n-                unsigned offset = (unsigned)Type::tsize_t->size(Loc());\n-                Type *t = argtypemerge(Type::tsize_t, Type::tvoidptr, offset);\n-                if (t)\n-                {\n-                    result = new TypeTuple(t);\n-                    return;\n-                }\n-            }\n-            result = new TypeTuple(Type::tsize_t, Type::tvoidptr);\n-        }\n-\n-        void visit(TypeDelegate *)\n-        {\n-            /* Should be done as if it were:\n-             * struct S { size_t length; void* ptr; }\n-             */\n-            if (global.params.is64bit && !global.params.isLP64)\n-            {\n-                // For AMD64 ILP32 ABI, delegates fit into a single integer register.\n-                unsigned offset = (unsigned)Type::tsize_t->size(Loc());\n-                Type *t = argtypemerge(Type::tsize_t, Type::tvoidptr, offset);\n-                if (t)\n-                {\n-                    result = new TypeTuple(t);\n-                    return;\n-                }\n-            }\n-            result = new TypeTuple(Type::tvoidptr, Type::tvoidptr);\n-        }\n-\n-        void visit(TypeStruct *t)\n-        {\n-            //printf(\"TypeStruct::toArgTypes() %s\\n\", t->toChars());\n-            if (!t->sym->isPOD() || t->sym->fields.dim == 0)\n-            {\n-            Lmemory:\n-                //printf(\"\\ttoArgTypes() %s => [ ]\\n\", t->toChars());\n-                result = new TypeTuple();         // pass on the stack\n-                return;\n-            }\n-            Type *t1 = NULL;\n-            Type *t2 = NULL;\n-            const d_uns64 sz = t->size(Loc());\n-            assert(sz < 0xFFFFFFFF);\n-            switch ((unsigned)sz)\n-            {\n-                case 1:\n-                    t1 = Type::tint8;\n-                    break;\n-                case 2:\n-                    t1 = Type::tint16;\n-                    break;\n-                case 3:\n-                    if (!global.params.is64bit)\n-                        goto Lmemory;\n-                    /* fall through */\n-                case 4:\n-                    t1 = Type::tint32;\n-                    break;\n-                case 5:\n-                case 6:\n-                case 7:\n-                    if (!global.params.is64bit)\n-                        goto Lmemory;\n-                    /* fall through */\n-                case 8:\n-                    t1 = Type::tint64;\n-                    break;\n-                case 16:\n-                    t1 = NULL;                   // could be a TypeVector\n-                    break;\n-                case 9:\n-                case 10:\n-                case 11:\n-                case 12:\n-                case 13:\n-                case 14:\n-                case 15:\n-                    if (!global.params.is64bit)\n-                        goto Lmemory;\n-                    t1 = NULL;\n-                    break;\n-                default:\n-                    goto Lmemory;\n-            }\n-            if (global.params.is64bit && t->sym->fields.dim)\n-            {\n-                t1 = NULL;\n-                for (size_t i = 0; i < t->sym->fields.dim; i++)\n-                {\n-                    VarDeclaration *f = t->sym->fields[i];\n-                    //printf(\"  [%d] %s f->type = %s\\n\", (int)i, f->toChars(), f->type->toChars());\n-\n-                    TypeTuple *tup = toArgTypes(f->type);\n-                    if (!tup)\n-                        goto Lmemory;\n-                    size_t dim = tup->arguments->dim;\n-                    Type *ft1 = NULL;\n-                    Type *ft2 = NULL;\n-                    switch (dim)\n-                    {\n-                        case 2:\n-                            ft1 = (*tup->arguments)[0]->type;\n-                            ft2 = (*tup->arguments)[1]->type;\n-                            break;\n-                        case 1:\n-                            if (f->offset < 8)\n-                                ft1 = (*tup->arguments)[0]->type;\n-                            else\n-                                ft2 = (*tup->arguments)[0]->type;\n-                            break;\n-                        default:\n-                            goto Lmemory;\n-                    }\n-\n-                    if (f->offset & 7)\n-                    {\n-                        // Misaligned fields goto Lmemory\n-                        unsigned alignsz = f->type->alignsize();\n-                        if (f->offset & (alignsz - 1))\n-                            goto Lmemory;\n-\n-                        // Fields that overlap the 8byte boundary goto Lmemory\n-                        const d_uns64 fieldsz = f->type->size(Loc());\n-                        assert(fieldsz != SIZE_INVALID && fieldsz < UINT64_MAX - UINT32_MAX);\n-                        if (f->offset < 8 && (f->offset + fieldsz) > 8)\n-                            goto Lmemory;\n-                    }\n-\n-                    // First field in 8byte must be at start of 8byte\n-                    assert(t1 || f->offset == 0);\n-                    //printf(\"ft1 = %s\\n\", ft1 ? ft1->toChars() : \"null\");\n-                    //printf(\"ft2 = %s\\n\", ft2 ? ft2->toChars() : \"null\");\n-                    if (ft1)\n-                    {\n-                        t1 = argtypemerge(t1, ft1, f->offset);\n-                        if (!t1)\n-                            goto Lmemory;\n-                    }\n-\n-                    if (ft2)\n-                    {\n-                        unsigned off2 = f->offset;\n-                        if (ft1)\n-                            off2 = 8;\n-                        if (!t2 && off2 != 8)\n-                            goto Lmemory;\n-                        assert(t2 || off2 == 8);\n-                        t2 = argtypemerge(t2, ft2, off2 - 8);\n-                        if (!t2)\n-                            goto Lmemory;\n-                    }\n-                }\n-\n-                if (t2)\n-                {\n-                    if (t1->isfloating() && t2->isfloating())\n-                    {\n-                        if ((t1->ty == Tfloat32 || t1->ty == Tfloat64) &&\n-                            (t2->ty == Tfloat32 || t2->ty == Tfloat64))\n-                            ;\n-                        else\n-                            goto Lmemory;\n-                    }\n-                    else if (t1->isfloating())\n-                        goto Lmemory;\n-                    else if (t2->isfloating())\n-                        goto Lmemory;\n-                    else\n-                    {\n-                    }\n-                }\n-            }\n-\n-            //printf(\"\\ttoArgTypes() %s => [%s,%s]\\n\", t->toChars(), t1 ? t1->toChars() : \"\", t2 ? t2->toChars() : \"\");\n-\n-            if (t1)\n-            {\n-                //if (t1) printf(\"test1: %s => %s\\n\", toChars(), t1->toChars());\n-                if (t2)\n-                    result = new TypeTuple(t1, t2);\n-                else\n-                    result = new TypeTuple(t1);\n-            }\n-            else\n-                goto Lmemory;\n-        }\n-\n-        void visit(TypeEnum *t)\n-        {\n-            t->toBasetype()->accept(this);\n-        }\n-\n-        void visit(TypeClass *)\n-        {\n-            result = new TypeTuple(Type::tvoidptr);\n-        }\n-    };\n-\n-    ToArgTypes v;\n-    t->accept(&v);\n-    return v.result;\n-}"}, {"sha": "10771c95a07ff69f0c0ce9b206ff9443d038b5b3", "filename": "gcc/d/dmd/dstruct.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2Fdmd%2Fdstruct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2Fdmd%2Fdstruct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdstruct.c?ref=a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "patch": "@@ -22,9 +22,9 @@\n #include \"statement.h\"\n #include \"template.h\"\n #include \"tokens.h\"\n+#include \"target.h\"\n \n Type *getTypeInfoType(Loc loc, Type *t, Scope *sc);\n-TypeTuple *toArgTypes(Type *t);\n void unSpeculative(Scope *sc, RootObject *o);\n bool MODimplicitConv(MOD modfrom, MOD modto);\n Expression *resolve(Loc loc, Scope *sc, Dsymbol *s, bool hasOverloads);\n@@ -1303,8 +1303,8 @@ void StructDeclaration::finalizeSize()\n         }\n     }\n \n-    TypeTuple *tt = toArgTypes(type);\n-    size_t dim = tt->arguments->dim;\n+    TypeTuple *tt = Target::toArgTypes(type);\n+    size_t dim = tt ? tt->arguments->dim : 0;\n     if (dim >= 1)\n     {\n         assert(dim <= 2);"}, {"sha": "629768aaf067b8ef9d9cb27048ab1fe83a9f215f", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "patch": "@@ -37,7 +37,6 @@\n bool typeMerge(Scope *sc, TOK op, Type **pt, Expression **pe1, Expression **pe2);\n bool isArrayOpValid(Expression *e);\n Expression *expandVar(int result, VarDeclaration *v);\n-TypeTuple *toArgTypes(Type *t);\n bool checkAssignEscape(Scope *sc, Expression *e, bool gag);\n bool checkParamArgumentEscape(Scope *sc, FuncDeclaration *fdc, Identifier *par, Expression *arg, bool gag);\n bool checkAccess(AggregateDeclaration *ad, Loc loc, Scope *sc, Dsymbol *smember);\n@@ -2074,7 +2073,7 @@ class ExpressionSemanticVisitor : public Visitor\n                      * The results of this are highly platform dependent, and intended\n                      * primarly for use in implementing va_arg().\n                      */\n-                    tded = toArgTypes(e->targ);\n+                    tded = Target::toArgTypes(e->targ);\n                     if (!tded)\n                         goto Lno;           // not valid for a parameter\n                     break;"}, {"sha": "51e85ff7ca954c195ca320789d4dd57baa359400", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "patch": "@@ -21,6 +21,7 @@ class Dsymbol;\n class Expression;\n class Parameter;\n class Type;\n+class TypeTuple;\n struct OutBuffer;\n \n struct Target\n@@ -73,4 +74,5 @@ struct Target\n     static Type *cppParameterType(Parameter *p);\n     static bool cppFundamentalType(const Type *t, bool& isFundamental);\n     static LINK systemLinkage();\n+    static TypeTuple *toArgTypes(Type *t);\n };"}, {"sha": "343a1c80e146ff49ed46fdf5a494411574b4d7e8", "filename": "gcc/testsuite/gdc.test/runnable/testargtypes.d", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af4c92573dc462a17a6c345756889d28054ed591/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestargtypes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af4c92573dc462a17a6c345756889d28054ed591/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestargtypes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestargtypes.d?ref=af4c92573dc462a17a6c345756889d28054ed591", "patch": "@@ -1,113 +0,0 @@\n-\n-void chkArgTypes(S, V...)()\n-{\n-    pragma(msg, S);\n-    static if (is(S U == __argTypes))\n-    {\n-        foreach (T; U) { pragma(msg, T); }\n-        static assert(U.length == V.length);\n-        foreach (i, T; U)\n-            static assert(is(V[i] == T));\n-    }\n-    else\n-        static assert(0);\n-}\n-\n-void chkSingle(T,U)()\n-{\n-    struct S { T a; }\n-    chkArgTypes!(S, U)();\n-}\n-\n-void chkIdentity(T)()\n-{\n-    chkSingle!(T,T)();\n-}\n-\n-void chkPair(T,U,V)()\n-{\n-    struct S { T a; U b; }\n-    chkArgTypes!(S, V)();\n-}\n-\n-version (X86_64)\n-{\n-    int main()\n-    {\n-        chkIdentity!byte();\n-        chkIdentity!ubyte();\n-        chkIdentity!short();\n-        chkIdentity!ushort();\n-        chkIdentity!int();\n-        chkIdentity!uint();\n-        chkIdentity!long();\n-        chkIdentity!ulong();\n-        chkSingle!(char,ubyte)();\n-        chkSingle!(wchar,ushort)();\n-        chkSingle!(dchar,uint)();\n-\n-        chkIdentity!float();\n-        chkIdentity!double();\n-        chkIdentity!real();\n-\n-        chkIdentity!(void*)();\n-\n-        chkIdentity!(__vector(byte[16]))();\n-        chkIdentity!(__vector(ubyte[16]))();\n-        chkIdentity!(__vector(short[8]))();\n-        chkIdentity!(__vector(ushort[8]))();\n-        chkIdentity!(__vector(int[4]))();\n-        chkIdentity!(__vector(uint[4]))();\n-        chkIdentity!(__vector(long[2]))();\n-        chkIdentity!(__vector(ulong[2]))();\n-\n-        chkIdentity!(__vector(float[4]))();\n-        chkIdentity!(__vector(double[2]))();\n-\n-        chkPair!(byte,byte,short);\n-        chkPair!(ubyte,ubyte,short);\n-        chkPair!(short,short,int);\n-        chkPair!(int,int,long);\n-\n-        chkPair!(byte,short,int);\n-        chkPair!(short,byte,int);\n-\n-        chkPair!(int,float,long);\n-        chkPair!(float,int,long);\n-        chkPair!(byte,float,long);\n-        chkPair!(float,short,long);\n-\n-        //struct S1 { long a; long b; }\n-        //chkArgTypes!(S1, long, long)();\n-\n-        struct S2 { union { long a; double d; }}\n-        chkArgTypes!(S2, long)();\n-\n-        struct S3 { union { double d; long a; }}\n-        chkArgTypes!(S3, long)();\n-\n-        struct S4 { int a,b,c,d,e; }\n-        chkArgTypes!(S4)();\n-\n-        struct S5 { align(1): char a; int b; }\n-        chkArgTypes!(S5)();\n-\n-        struct S6 { align(1): int a; void* b; }\n-        chkArgTypes!(S5)();\n-\n-        struct S7 { union { void* p; real r; }}\n-        chkArgTypes!(S7)();\n-\n-        struct S8 { union { real r; void* p; }}\n-        chkArgTypes!(S8)();\n-\n-        return 0;\n-    }\n-}\n-else\n-{\n-    int main()\n-    {\n-        return 0;\n-    }\n-}"}, {"sha": "e6eec480b1f50dc4618673ccdeb65a357b581411", "filename": "libphobos/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/libphobos%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/libphobos%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2FChangeLog?ref=a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "patch": "@@ -1,3 +1,7 @@\n+2020-04-13  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* libdruntime/core/stdc/stdarg.d: Remove run-time va_list template.\n+\n 2020-04-10  Iain Buclaw  <ibuclaw@gdcproject.org>\n \n \t* d_rules.am (libdgruntime_la_LINK): Move to libdruntime/Makefile.am."}, {"sha": "586fe20d9913dda749b92a9eadd5d0de0787678e", "filename": "libphobos/libdruntime/core/stdc/stdarg.d", "status": "modified", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdarg.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdarg.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdarg.d?ref=a1ccbae63cdf25b8ff66da18ed0d081cb9411ccf", "patch": "@@ -50,166 +50,6 @@ version (GNU)\n     void va_arg(T)(ref va_list ap, ref T parmn);\n \n \n-    /*************\n-     * Retrieve and store through parmn the next value that is of TypeInfo ti.\n-     * Used when the static type is not known.\n-     */\n-    version (X86)\n-    {\n-        ///\n-        void va_arg()(ref va_list ap, TypeInfo ti, void* parmn)\n-        {\n-            auto p = ap;\n-            auto tsize = ti.tsize;\n-            ap = cast(va_list)(cast(size_t)p + ((tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));\n-            parmn[0..tsize] = p[0..tsize];\n-        }\n-    }\n-    else version (X86_64)\n-    {\n-        /// Layout of this struct must match __builtin_va_list for C ABI compatibility\n-        struct __va_list\n-        {\n-            uint offset_regs = 6 * 8;            // no regs\n-            uint offset_fpregs = 6 * 8 + 8 * 16; // no fp regs\n-            void* stack_args;\n-            void* reg_args;\n-        }\n-\n-        ///\n-        void va_arg()(ref va_list apx, TypeInfo ti, void* parmn)\n-        {\n-            __va_list* ap = cast(__va_list*)apx;\n-            TypeInfo arg1, arg2;\n-            if (!ti.argTypes(arg1, arg2))\n-            {\n-                bool inXMMregister(TypeInfo arg) pure nothrow @safe\n-                {\n-                    return (arg.flags & 2) != 0;\n-                }\n-\n-                TypeInfo_Vector v1 = arg1 ? cast(TypeInfo_Vector)arg1 : null;\n-                if (arg1 && (arg1.tsize() <= 8 || v1))\n-                {   // Arg is passed in one register\n-                    auto tsize = arg1.tsize();\n-                    void* p;\n-                    bool stack = false;\n-                    auto offset_fpregs_save = ap.offset_fpregs;\n-                    auto offset_regs_save = ap.offset_regs;\n-                L1:\n-                    if (inXMMregister(arg1) || v1)\n-                    {   // Passed in XMM register\n-                        if (ap.offset_fpregs < (6 * 8 + 16 * 8) && !stack)\n-                        {\n-                            p = ap.reg_args + ap.offset_fpregs;\n-                            ap.offset_fpregs += 16;\n-                        }\n-                        else\n-                        {\n-                            p = ap.stack_args;\n-                            ap.stack_args += (tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1);\n-                            stack = true;\n-                        }\n-                    }\n-                    else\n-                    {   // Passed in regular register\n-                        if (ap.offset_regs < 6 * 8 && !stack)\n-                        {\n-                            p = ap.reg_args + ap.offset_regs;\n-                            ap.offset_regs += 8;\n-                        }\n-                        else\n-                        {\n-                            p = ap.stack_args;\n-                            ap.stack_args += 8;\n-                            stack = true;\n-                        }\n-                    }\n-                    parmn[0..tsize] = p[0..tsize];\n-\n-                    if (arg2)\n-                    {\n-                        if (inXMMregister(arg2))\n-                        {   // Passed in XMM register\n-                            if (ap.offset_fpregs < (6 * 8 + 16 * 8) && !stack)\n-                            {\n-                                p = ap.reg_args + ap.offset_fpregs;\n-                                ap.offset_fpregs += 16;\n-                            }\n-                            else\n-                            {\n-                                if (!stack)\n-                                {   // arg1 is really on the stack, so rewind and redo\n-                                    ap.offset_fpregs = offset_fpregs_save;\n-                                    ap.offset_regs = offset_regs_save;\n-                                    stack = true;\n-                                    goto L1;\n-                                }\n-                                p = ap.stack_args;\n-                                ap.stack_args += (arg2.tsize() + size_t.sizeof - 1) & ~(size_t.sizeof - 1);\n-                            }\n-                        }\n-                        else\n-                        {   // Passed in regular register\n-                            if (ap.offset_regs < 6 * 8 && !stack)\n-                            {\n-                                p = ap.reg_args + ap.offset_regs;\n-                                ap.offset_regs += 8;\n-                            }\n-                            else\n-                            {\n-                                if (!stack)\n-                                {   // arg1 is really on the stack, so rewind and redo\n-                                    ap.offset_fpregs = offset_fpregs_save;\n-                                    ap.offset_regs = offset_regs_save;\n-                                    stack = true;\n-                                    goto L1;\n-                                }\n-                                p = ap.stack_args;\n-                                ap.stack_args += 8;\n-                            }\n-                        }\n-                        auto sz = ti.tsize() - 8;\n-                        (parmn + 8)[0..sz] = p[0..sz];\n-                    }\n-                }\n-                else\n-                {   // Always passed in memory\n-                    // The arg may have more strict alignment than the stack\n-                    auto talign = ti.talign();\n-                    auto tsize = ti.tsize();\n-                    auto p = cast(void*)((cast(size_t)ap.stack_args + talign - 1) & ~(talign - 1));\n-                    ap.stack_args = cast(void*)(cast(size_t)p + ((tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));\n-                    parmn[0..tsize] = p[0..tsize];\n-                }\n-            }\n-            else\n-            {\n-                assert(false, \"not a valid argument type for va_arg\");\n-            }\n-        }\n-    }\n-    else version (ARM)\n-    {\n-        ///\n-        void va_arg()(ref va_list ap, TypeInfo ti, void* parmn)\n-        {\n-            auto p = *cast(void**) &ap;\n-            auto tsize = ti.tsize();\n-            *cast(void**) &ap += ( tsize + size_t.sizeof - 1 ) & ~( size_t.sizeof - 1 );\n-            parmn[0..tsize] = p[0..tsize];\n-        }\n-    }\n-    else\n-    {\n-        ///\n-        void va_arg()(ref va_list ap, TypeInfo ti, void* parmn)\n-        {\n-            static assert(false, \"Unsupported platform\");\n-        }\n-    }\n-\n-\n     /***********************\n      * End use of ap.\n      */"}]}