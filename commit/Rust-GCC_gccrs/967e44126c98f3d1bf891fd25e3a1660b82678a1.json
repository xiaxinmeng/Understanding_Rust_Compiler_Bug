{"sha": "967e44126c98f3d1bf891fd25e3a1660b82678a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY3ZTQ0MTI2Yzk4ZjNkMWJmODkxZmQyNWUzYTE2NjBiODI2NzhhMQ==", "commit": {"author": {"name": "Roland McGrath", "email": "roland@gcc.gnu.org", "date": "1992-10-20T21:12:16Z"}, "committer": {"name": "Roland McGrath", "email": "roland@gcc.gnu.org", "date": "1992-10-20T21:12:16Z"}, "message": "entered into RCS\n\nFrom-SVN: r2535", "tree": {"sha": "e1a974b9aee325e1f8e73307230e2b56a4d3fc9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1a974b9aee325e1f8e73307230e2b56a4d3fc9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/967e44126c98f3d1bf891fd25e3a1660b82678a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967e44126c98f3d1bf891fd25e3a1660b82678a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/967e44126c98f3d1bf891fd25e3a1660b82678a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967e44126c98f3d1bf891fd25e3a1660b82678a1/comments", "author": null, "committer": null, "parents": [{"sha": "d9bb485941d72d1278061542332055c936f126a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9bb485941d72d1278061542332055c936f126a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9bb485941d72d1278061542332055c936f126a9"}], "stats": {"total": 448, "additions": 448, "deletions": 0}, "files": [{"sha": "ee9be0241ed730a9b8e7de5a19338d06d4b523de", "filename": "gcc/PROJECTS", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967e44126c98f3d1bf891fd25e3a1660b82678a1/gcc%2FPROJECTS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967e44126c98f3d1bf891fd25e3a1660b82678a1/gcc%2FPROJECTS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FPROJECTS?ref=967e44126c98f3d1bf891fd25e3a1660b82678a1", "patch": "@@ -0,0 +1,448 @@\n+0. Improved efficiency.\n+\n+* Parse and output array initializers an element at a time, freeing\n+storage after each, instead of parsing the whole initializer first and\n+then outputting.  This would reduce memory usage for large\n+initializers.\n+\n+* See if the techniques describe in Oct 1991 SIGPLAN Notices\n+(Frazer and Hanson) are applicable to GCC.\n+\n+1. Better optimization.\n+\n+* Constants in unused inline functions\n+\n+It would be nice to delay output of string constants so that string\n+constants mentioned in unused inline functions are never generated.\n+Perhaps this would also take care of string constants in dead code.\n+\n+The difficulty is in finding a clean way for the RTL which refers\n+to the constant (currently, only by an assembler symbol name)\n+to point to the constant and cause it to be output.\n+\n+* More cse\n+\n+The techniques for doing full global cse are described in the red\n+dragon book, or (a different version) in Frederick Chow's thesis from\n+Stanford.  It is likely to be slow and use a lot of memory, but it\n+might be worth offering as an additional option.\n+\n+It is probably possible to extend cse to a few very frequent cases\n+without so much expense.\n+\n+For example, it is not very hard to handle cse through if-then\n+statements with no else clauses.  Here's how to do it.  On reaching a\n+label, notice that the label's use-count is 1 and that the last\n+preceding jump jumps conditionally to this label.  Now you know it\n+is a simple if-then statement.  Remove from the hash table\n+all the expressions that were entered since that jump insn\n+and you can continue with cse.\n+\n+It is probably not hard to handle cse from the end of a loop\n+around to the beginning, and a few loops would be greatly sped\n+up by this.\n+\n+* Optimize a sequence of if statements whose conditions are exclusive.\n+\n+It is possible to optimize \n+\n+    if (x == 1) ...;\n+    if (x == 2) ...;\n+    if (x == 3) ...;\n+\n+into\n+\n+    if (x == 1) ...;\n+    else if (x == 2) ...;\n+    else if (x == 3) ...;\n+\n+provided that x is not altered by the contents of the if statements.\n+\n+It's not certain whether this is worth doing.  Perhaps programmers\n+nearly always write the else's themselves, leaving few opportunities\n+to improve anything.\n+\n+* Un-cse.\n+\n+Perhaps we should have an un-cse step right after cse, which tries to\n+replace a reg with its value if the value can be substituted for the\n+reg everywhere, if that looks like an improvement.  Which is if the\n+reg is used only a few times.  Use rtx_cost to determine if the\n+change is really an improvement.\n+\n+* Clean up how cse works.\n+\n+The scheme is that each value has just one hash entry.  The\n+first_same_value and next_same_value chains are no longer needed.\n+\n+For arithmetic, each hash table elt has the following slots:\n+\n+* Operation.  This is an rtx code.\n+* Mode.\n+* Operands 0, 1 and 2.  These point to other hash table elements.\n+\n+So, if we want to enter (PLUS:SI (REG:SI 30) (CONST_INT 104)), we\n+first enter (CONST_INT 104) and find the entry that (REG:SI 30) now\n+points to.  Then we put these elts into operands 0 and 1 of a new elt.\n+We put PLUS and SI into the new elt.\n+\n+Registers and mem refs would never be entered into the table as such.\n+However, the values they contain would be entered.  There would be a\n+table indexed by regno which points at the hash entry for the value in\n+that reg.\n+\n+The hash entry index now plays the role of a qty number.\n+We still need qty_first_reg, reg_next_eqv, etc. to record which regs\n+share a particular qty.\n+\n+When a reg is used whose contents are unknown, we need to create a\n+hash table entry whose contents say \"unknown\", as a place holder for\n+whatever the reg contains.  If that reg is added to something, then\n+the hash entry for the sum will refer to the \"unknown\" entry.  Use\n+UNKNOWN for the rtx code in this entry.  This replaces make_new_qty.\n+\n+For a constant, a unique hash entry would be made based on the\n+value of the constant.\n+\n+What about MEM?  Each time a memory address is referenced, we need a\n+qty (a hash table elt) to represent what is in it.  (Just as for a\n+register.)  If this isn't known, create one, just as for a reg whose\n+contents are unknown.\n+\n+We need a way to find all mem refs that still contain a certain value.\n+Do this with a chain of hash elts (for memory addresses) that point to\n+locations that hold the value.  The hash elt for the value itself should\n+point to the start of the chain.  It would be good for the hash elt\n+for an address to point to the hash elt for the contents of that address\n+(but this ptr can be null if the contents have never been entered).\n+\n+With this data structure, nothing need ever be invalidated except\n+the lists of which regs or mems hold a particular value.  It is easy\n+to see if there is a reg or mem that is equiv to a particular value.\n+If the value is constant, it is always explicitly constant.\n+\n+* Support more general tail-recursion among different functions.\n+\n+This might be possible under certain circumstances, such as when\n+the argument lists of the functions have the same lengths.\n+Perhaps it could be done with a special declaration.\n+\n+You would need to verify in the calling function that it does not\n+use the addresses of any local variables and does not use setjmp.\n+\n+* Put short statics vars at low addresses and use short addressing mode?\n+\n+Useful on the 68000/68020 and perhaps on the 32000 series,\n+provided one has a linker that works with the feature.\n+This is said to make a 15% speedup on the 68000.\n+\n+* Keep global variables in registers.\n+\n+Here is a scheme for doing this.  A global variable, or a local variable\n+whose address is taken, can be kept in a register for an entire function\n+if it does not use non-constant memory addresses and (for globals only)\n+does not call other functions.  If the entire function does not meet\n+this criterion, a loop may.\n+\n+The VAR_DECL for such a variable would have to have two RTL expressions:\n+the true home in memory, and the pseudo-register used temporarily. \n+It is necessary to emit insns to copy the memory location into the\n+pseudo-register at the beginning of the function or loop, and perhaps\n+back out at the end.  These insns should have REG_EQUIV notes so that,\n+if the pseudo-register does not get a hard register, it is spilled into\n+the memory location which exists in any case.\n+\n+The easiest way to set up these insns is to modify the routine\n+put_var_into_stack so that it does not apply to the entire function\n+(sparing any loops which contain nothing dangerous) and to call it at\n+the end of the function regardless of where in the function the\n+address of a local variable is taken.  It would be called\n+unconditionally at the end of the function for all relevant global\n+variables.\n+\n+For debugger output, the thing to do is to invent a new binding level\n+around the appropriate loop and define the variable name as a register\n+variable with that scope.\n+\n+* Live-range splitting.\n+\n+Currently a variable is allocated a hard register either for the full\n+extent of its use or not at all.  Sometimes it would be good to\n+allocate a variable a hard register for just part of a function; for\n+example, through a particular loop where the variable is mostly used,\n+or outside of a particular loop where the variable is not used.  (The\n+latter is nice because it might let the variable be in a register most\n+of the time even though the loop needs all the registers.)\n+\n+It might not be very hard to do this in global.c when a variable\n+fails to get a hard register for its entire life span.\n+\n+The first step is to find a loop in which the variable is live, but\n+which is not the whole life span or nearly so.  It's probably best to\n+use a loop in which the variable is heavily used.\n+\n+Then create a new pseudo-register to represent the variable in that loop.\n+Substitute this for the old pseudo-register there, and insert move insns\n+to copy between the two at the loop entry and all exits.  (When several\n+such moves are inserted at the same place, some new feature should be\n+added to say that none of those registers conflict merely because of\n+overlap between the new moves.  And the reload pass should reorder them\n+so that a store precedes a load, for any given hard register.)\n+\n+After doing this for all the reasonable candidates, run global-alloc\n+over again.  With luck, one of the two pseudo-registers will be fit\n+somewhere.  It may even have a much higher priority due to its reduced\n+life span.\n+\n+There will be no room in general for the new pseudo-registers in\n+basic_block_live_at_start, so there will need to be a second such\n+matrix exclusively for the new ones.  Various other vectors indexed by\n+register number will have to be made bigger, or there will have to be\n+secondary extender vectors just for global-alloc.\n+\n+A simple new feature could arrange that both pseudo-registers get the\n+same stack slot if they both fail to get hard registers.\n+\n+Other compilers split live ranges when they are not connected, or\n+try to split off pieces `at the edge'.  I think splitting around loops\n+will provide more speedup.\n+\n+Creating a fake binding block and a new like-named variable with\n+shorter life span and different address might succeed in describing\n+this technique for the debugger.\n+\n+* Detect dead stores into memory?\n+\n+A store into memory is dead if it is followed by another store into\n+the same location; and, in between, there is no reference to anything\n+that might be that location (including no reference to a variable\n+address).\n+\n+* Loop optimization.\n+\n+Strength reduction and iteration variable elimination could be\n+smarter.  They should know how to decide which iteration variables are\n+not worth making explicit because they can be computed as part of an\n+address calculation.  Based on this information, they should decide\n+when it is desirable to eliminate one iteration variable and create\n+another in its place.\n+\n+It should be possible to compute what the value of an iteration\n+variable will be at the end of the loop, and eliminate the variable\n+within the loop by computing that value at the loop end.\n+\n+When a loop has a simple increment that adds 1,\n+instead of jumping in after the increment,\n+decrement the loop count and jump to the increment.\n+This allows aob insns to be used.\n+\n+* Using constraints on values.\n+\n+Many operations could be simplified based on knowledge of the\n+minimum and maximum possible values of a register at any particular time.\n+These limits could come from the data types in the tree, via rtl generation,\n+or they can be deduced from operations that are performed.  For example,\n+the result of an `and' operation one of whose operands is 7 must be in\n+the range 0 to 7.  Compare instructions also tell something about the\n+possible values of the operand, in the code beyond the test.\n+\n+Value constraints can be used to determine the results of a further\n+comparison.  They can also indicate that certain `and' operations are\n+redundant.  Constraints might permit a decrement and branch\n+instruction that checks zeroness to be used when the user has\n+specified to exit if negative.\n+\n+* Smarter reload pass.\n+\n+The reload pass as currently written can reload values only into registers\n+that are reserved for reloading.  This means that in order to use a\n+register for reloading it must spill everything out of that register.\n+\n+It would be straightforward, though complicated, for reload1.c to keep\n+track, during its scan, of which hard registers were available at each\n+point in the function, and use for reloading even registers that were\n+free only at the point they were needed.  This would avoid much spilling\n+and make better code.\n+\n+* Change the type of a variable.\n+\n+Sometimes a variable is declared as `int', it is assigned only once\n+from a value of type `char', and then it is used only by comparison\n+against constants.  On many machines, better code would result if\n+the variable had type `char'.  If the compiler could detect this\n+case, it could change the declaration of the variable and change\n+all the places that use it.\n+\n+* Better handling for very sparse switches.\n+\n+There may be cases where it would be better to compile a switch\n+statement to use a fixed hash table rather than the current\n+combination of jump tables and binary search.\n+\n+* Order of subexpressions.\n+\n+It might be possible to make better code by paying attention\n+to the order in which to generate code for subexpressions of an expression.\n+\n+* More code motion.\n+\n+Consider hoisting common code up past conditional branches or\n+tablejumps.\n+\n+* Trace scheduling.\n+\n+This technique is said to be able to figure out which way a jump\n+will usually go, and rearrange the code to make that path the\n+faster one.\n+\n+* Distributive law.\n+\n+The C expression *(X + 4 * (Y + C)) compiles better on certain\n+machines if rewritten as *(X + 4*C + 4*Y) because of known addressing\n+modes.  It may be tricky to determine when, and for which machines, to\n+use each alternative.\n+\n+Some work has been done on this, in combine.c.\n+\n+* Can optimize by changing if (x) y; else z; into z; if (x) y;\n+if z and x do not interfere and z has no effects not undone by y.\n+This is desirable if z is faster than jumping.\n+\n+* For a two-insn loop on the 68020, such as\n+  foo:\tmovb\ta2@+,a3@+\n+\tjne\tfoo\n+it is better to insert dbeq d0,foo before the jne.\n+d0 can be a junk register.  The challenge is to fit this into\n+a portable framework: when can you detect this situation and\n+still be able to allocate a junk register?\n+\n+2. Simpler porting.\n+\n+Right now, describing the target machine's instructions is done\n+cleanly, but describing its addressing mode is done with several\n+ad-hoc macro definitions.  Porting would be much easier if there were\n+an RTL description for addressing modes like that for instructions.\n+Tools analogous to genflags and genrecog would generate macros from\n+this description.\n+\n+There would be one pattern in the address-description file for each\n+kind of addressing, and this pattern would have:\n+\n+  * the RTL expression for the address\n+  * C code to verify its validity (since that may depend on\n+    the exact data).\n+  * C code to print the address in assembler language.\n+  * C code to convert the address into a valid one, if it is not valid.\n+    (This would replace LEGITIMIZE_ADDRESS).\n+  * Register constraints for all indeterminates that appear\n+    in the RTL expression.\n+\n+3. Other languages.\n+\n+Front ends for Pascal, Fortran, Algol, Cobol, Modula-2 and Ada are\n+desirable.\n+\n+Pascal, Modula-2 and Ada require the implementation of functions\n+within functions.  Some of the mechanisms for this already exist.\n+\n+4. More extensions.\n+\n+* Generated unique labels.  Have some way of generating distinct labels\n+for use in extended asm statements.  I don't know what a good syntax would\n+be.\n+\n+* A way of defining a structure containing a union, in which the choice of\n+union alternative is controlled by a previous structure component.\n+\n+Here is a possible syntax for this.\n+\n+struct foo {\n+  enum { INT, DOUBLE } code;\n+  auto union { case INT: int i; case DOUBLE: double d;} value : code;\n+};\n+\n+* Allow constructor expressions as lvalues, like this:\n+\n+\t(struct foo) {a, b, c} = foo();\n+\n+This would call foo, which returns a structure, and then store the\n+several components of the structure into the variables a, b, and c.\n+\n+5. Generalize the machine model.\n+\n+* Some new compiler features may be needed to do a good job on machines\n+where static data needs to be addressed using base registers.\n+\n+* Some machines have two stacks in different areas of memory, one used\n+for scalars and another for large objects.  The compiler does not\n+now have a way to understand this.\n+\n+6. Useful warnings.\n+\n+* Warn about statements that are undefined because the order of\n+evaluation of increment operators makes a big difference.  Here is an\n+example:\n+\n+    *foo++ = hack (*foo);\n+\n+7. Better documentation of how GCC works and how to port it.\n+\n+Here is an outline proposed by Allan Adler.\n+\n+I.    Overview of this document\n+II.   The machines on which GCC is implemented\n+    A. Prose description of those characteristics of target machines and\n+       their operating systems which are pertinent to the implementation\n+       of GCC.\n+\ti. target machine characteristics\n+\tii. comparison of this system of machine characteristics with\n+\t    other systems of machine specification currently in use\n+    B. Tables of the characteristics of the target machines on which\n+       GCC is implemented.\n+    C. A priori restrictions on the values of characteristics of target \n+       machines, with special reference to those parts of the source code\n+       which entail those restrictions\n+\ti. restrictions on individual characteristics \n+        ii. restrictions involving relations between various characteristics\n+    D. The use of GCC as a cross-compiler \n+\ti. cross-compilation to existing machines\n+\tii. cross-compilation to non-existent machines\n+    E. Assumptions which are made regarding the target machine\n+\ti.  assumptions regarding the architecture of the target machine\n+\tii. assumptions regarding the operating system of the target machine\n+\tiii. assumptions regarding software resident on the target machine\n+\tiv. where in the source code these assumptions are in effect made\n+III.   A systematic approach to writing the files tm.h and xm.h\n+    A. Macros which require special care or skill\n+    B. Examples, with special reference to the underlying reasoning\n+IV.    A systematic approach to writing the machine description file md\n+    A. Minimal viable sets of insn descriptions\n+    B. Examples, with special reference to the underlying reasoning\n+V.     Uses of the file aux-output.c\n+VI.    Specification of what constitutes correct performance of an \n+       implementation of GCC\n+    A. The components of GCC\n+    B. The itinerary of a C program through GCC\n+    C. A system of benchmark programs\n+    D. What your RTL and assembler should look like with these benchmarks\n+    E. Fine tuning for speed and size of compiled code\n+VII.   A systematic procedure for debugging an implementation of GCC\n+    A. Use of GDB\n+\ti. the macros in the file .gdbinit for GCC\n+\tii. obstacles to the use of GDB\n+\t    a. functions implemented as macros can't be called in GDB\n+    B. Debugging without GDB\n+\ti. How to turn off the normal operation of GCC and access specific\n+\t   parts of GCC\n+    C. Debugging tools\n+    D. Debugging the parser\n+\ti. how machine macros and insn definitions affect the parser\n+    E. Debugging the recognizer\n+\ti. how machine macros and insn definitions affect the recognizer\n+\n+ditto for other components\n+\n+VIII. Data types used by GCC, with special reference to restrictions not \n+      specified in the formal definition of the data type\n+IX.   References to the literature for the algorithms used in GCC\n+"}]}