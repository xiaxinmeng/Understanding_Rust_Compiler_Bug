{"sha": "743c8beb16b662bd3db79e190554d9f9674e4e2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQzYzhiZWIxNmI2NjJiZDNkYjc5ZTE5MDU1NGQ5Zjk2NzRlNGUyZQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2006-10-31T18:02:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:02:40Z"}, "message": "sem_ch10.ads, [...] (Check_Redundant_Withs, [...]): If the context of a body includes a use clause for P.Q then a with_clause for P...\n\n2006-10-31  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch10.ads, sem_ch10.adb (Check_Redundant_Withs,\n\tProcess_Body_Clauses): If the context of a body includes a use clause\n\tfor P.Q then a with_clause for P in the same body is not redundant,\n\teven if the spec also has a with_clause on P.\n\tAdd missing continuation mark to error msg\n\t(Build_Limited_Views): A limited view of a type is tagged if its\n\tdeclaration includes a record extension.\n\t(Analyze_Proper_Body): Set Corresponding_Stub field in N_Subunit\n\tnode, even if the subunit has errors. This avoids malfunction by\n\tLib.Check_Same_Extended_Unit in the presence of syntax errors.\n\t(Analyze_Compilation_Unit): Add circuit to make sure we get proper\n\tgeneration of obsolescent messages for with statements (cannot do\n\tthis too early, or we cannot implement avoiding the messages in the\n\tcase of obsolescent units withing obsolescent units).\n\t(Install_Siblings): If the with_clause is on a remote descendant of\n\tan ancestor of the current compilation unit, find whether there is\n\ta sibling child unit that is immediately visible.\n\t(Remove_Private_With_Clauses): New procedure, invoked after completing\n\tthe analysis of the private part of a nested package, to remove from\n\tvisibility the private with_clauses of the enclosing package\n\tdeclaration.\n\t(Analyze_With_Clause): Remove Check_Obsolescent call, this checking is\n\tnow centralized in Generate_Reference.\n\t(Install_Limited_Context_Clauses): Remove superfluous error\n\tmessage associated with unlimited view visible through use\n\tand renamings. In addition, at the point in which the error\n\tis reported, we add the backslash to the text of the error\n\tto ensure that it is reported as a single error message.\n\tUse new // insertion for some continuation messages\n\t(Expand_Limited_With_Clause): Use copy of name rather than name itself,\n\tto create implicit with_clause for parent unit mentioned in original\n\tlimited_with_clause.\n\t(Install_Limited_With_Unit): Set entity of parent identifiers if the\n\tunit is a child unit. For ASIS queries.\n\t(Analyze_Subunit): If the subunit appears within a child unit, make all\n\tancestor child units directly visible again.\n\nFrom-SVN: r118287", "tree": {"sha": "a3cc72e2674895159ea276b8b1b3e563ab81bbd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3cc72e2674895159ea276b8b1b3e563ab81bbd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/743c8beb16b662bd3db79e190554d9f9674e4e2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/743c8beb16b662bd3db79e190554d9f9674e4e2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/743c8beb16b662bd3db79e190554d9f9674e4e2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/743c8beb16b662bd3db79e190554d9f9674e4e2e/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f6cf2af4c766a8dbb0e52b94867e10cdd2a20cf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cf2af4c766a8dbb0e52b94867e10cdd2a20cf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6cf2af4c766a8dbb0e52b94867e10cdd2a20cf1"}], "stats": {"total": 429, "additions": 339, "deletions": 90}, "files": [{"sha": "49b7ceacc1735f6d7f9a50120afee915f99e31a4", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 331, "deletions": 89, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/743c8beb16b662bd3db79e190554d9f9674e4e2e/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/743c8beb16b662bd3db79e190554d9f9674e4e2e/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=743c8beb16b662bd3db79e190554d9f9674e4e2e", "patch": "@@ -45,6 +45,7 @@ with Output;   use Output;\n with Restrict; use Restrict;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n+with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n@@ -316,10 +317,35 @@ package body Sem_Ch10 is\n                if Nkind (Cont_Item) = N_Use_Package_Clause\n                  and then not Used\n                then\n+                  --  Search through use clauses\n+\n                   Use_Item := First (Names (Cont_Item));\n                   while Present (Use_Item) and then not Used loop\n+\n+                     --  Case of a direct use of the one we are looking for\n+\n                      if Entity (Use_Item) = Nam_Ent then\n                         Used := True;\n+\n+                     --  Handle nested case, as in \"with P; use P.Q.R\"\n+\n+                     else\n+                        declare\n+                           UE : Node_Id;\n+\n+                        begin\n+                           --  Loop through prefixes looking for match\n+\n+                           UE := Use_Item;\n+                           while Nkind (UE) = N_Expanded_Name loop\n+                              if Entity (Prefix (UE)) = Nam_Ent then\n+                                 Used := True;\n+                                 exit;\n+                              end if;\n+\n+                              UE := Prefix (UE);\n+                           end loop;\n+                        end;\n                      end if;\n \n                      Next (Use_Item);\n@@ -812,7 +838,6 @@ package body Sem_Ch10 is\n       if Present (Pragmas_After (Aux_Decls_Node (N))) then\n          declare\n             Prag_Node : Node_Id := First (Pragmas_After (Aux_Decls_Node (N)));\n-\n          begin\n             while Present (Prag_Node) loop\n                Analyze (Prag_Node);\n@@ -930,11 +955,14 @@ package body Sem_Ch10 is\n             Item := First (Context_Items (N));\n             while Present (Item) loop\n \n-               --  Ada 2005 (AI-50217): Do not consider limited-withed units\n+               --  Check for explicit with clause\n \n                if Nkind (Item) = N_With_Clause\n-                  and then not Implicit_With (Item)\n-                  and then not Limited_Present (Item)\n+                 and then not Implicit_With (Item)\n+\n+                  --  Ada 2005 (AI-50217): Ignore limited-withed units\n+\n+                 and then not Limited_Present (Item)\n                then\n                   Nam := Entity (Name (Item));\n \n@@ -1057,16 +1085,15 @@ package body Sem_Ch10 is\n          end;\n       end if;\n \n-      --  Finally, freeze the compilation unit entity. This for sure is needed\n-      --  because of some warnings that can be output (see Freeze_Subprogram),\n-      --  but may in general be required. If freezing actions result, place\n-      --  them in the compilation unit actions list, and analyze them.\n+      --  Freeze the compilation unit entity. This for sure is needed because\n+      --  of some warnings that can be output (see Freeze_Subprogram), but may\n+      --  in general be required. If freezing actions result, place them in the\n+      --  compilation unit actions list, and analyze them.\n \n       declare\n          Loc : constant Source_Ptr := Sloc (N);\n          L   : constant List_Id :=\n                  Freeze_Entity (Cunit_Entity (Current_Sem_Unit), Loc);\n-\n       begin\n          while Is_Non_Empty_List (L) loop\n             Insert_Library_Level_Action (Remove_Head (L));\n@@ -1096,6 +1123,49 @@ package body Sem_Ch10 is\n             Warning_Mode := Save_Warning;\n          end;\n       end if;\n+\n+      --  If we are generating obsolescent warnings, then here is where we\n+      --  generate them for the with'ed items. The reason for this special\n+      --  processing is that the normal mechanism of generating the warnings\n+      --  for referenced entities does not work for context clause references.\n+      --  That's because when we first analyze the context, it is too early to\n+      --  know if the with'ing unit is itself obsolescent (which suppresses\n+      --  the warnings).\n+\n+      if not GNAT_Mode and then Warn_On_Obsolescent_Feature then\n+\n+         --  Push current compilation unit as scope, so that the test for\n+         --  being within an obsolescent unit will work correctly.\n+\n+         New_Scope (Defining_Entity (Unit (N)));\n+\n+         --  Loop through context items to deal with with clauses\n+\n+         declare\n+            Item : Node_Id;\n+            Nam  : Node_Id;\n+            Ent  : Entity_Id;\n+\n+         begin\n+            Item := First (Context_Items (N));\n+            while Present (Item) loop\n+               if Nkind (Item) = N_With_Clause then\n+                  Nam := Name (Item);\n+                  Ent := Entity (Nam);\n+\n+                  if Is_Obsolescent (Ent) then\n+                     Output_Obsolescent_Entity_Warnings (Nam, Ent);\n+                  end if;\n+               end if;\n+\n+               Next (Item);\n+            end loop;\n+         end;\n+\n+         --  Remove temporary install of current unit as scope\n+\n+         Pop_Scope;\n+      end if;\n    end Analyze_Compilation_Unit;\n \n    ---------------------\n@@ -1272,7 +1342,7 @@ package body Sem_Ch10 is\n                                     & \" context clause found #\",\n                                     Item, It);\n                                  Error_Msg_N\n-                                   (\"simultaneous visibility of the limited\"\n+                                   (\"\\simultaneous visibility of the limited\"\n                                     & \" and unlimited views not allowed\"\n                                     , Item);\n                                  exit;\n@@ -1560,9 +1630,7 @@ package body Sem_Ch10 is\n \n             Compiler_State := Analyzing;\n \n-            if Unum /= No_Unit\n-              and then (not Fatal_Error (Unum) or else Try_Semantics)\n-            then\n+            if Unum /= No_Unit then\n                if Debug_Flag_L then\n                   Write_Str (\"*** Loaded subunit from stub. Analyze\");\n                   Write_Eol;\n@@ -1579,12 +1647,21 @@ package body Sem_Ch10 is\n                        (\"expected SEPARATE subunit, found child unit\",\n                         Cunit_Entity (Unum));\n \n-                  --  OK, we have a subunit, so go ahead and analyze it,\n-                  --  and set Scope of entity in stub, for ASIS use.\n+                  --  OK, we have a subunit\n \n                   else\n+                     --  Set corresponding stub (even if errors)\n+\n                      Set_Corresponding_Stub (Unit (Comp_Unit), N);\n-                     Analyze_Subunit (Comp_Unit);\n+\n+                     --  Analyze the unit if semantics active\n+\n+                     if not Fatal_Error (Unum) or else Try_Semantics then\n+                        Analyze_Subunit (Comp_Unit);\n+                     end if;\n+\n+                     --  Set the library unit pointer in any case\n+\n                      Set_Library_Unit (N, Comp_Unit);\n \n                      --  We update the version. Although we are not technically\n@@ -1985,6 +2062,26 @@ package body Sem_Ch10 is\n \n       Analyze (Proper_Body (Unit (N)));\n       Remove_Context (N);\n+\n+      --  The subunit may contain a with_clause on a sibling of some\n+      --  ancestor. Removing the context will remove from visibility those\n+      --  ancestor child units, which must be restored to the visibility\n+      --  they have in the enclosing body.\n+\n+      if Present (Enclosing_Child) then\n+         declare\n+            C : Entity_Id;\n+         begin\n+            C := Current_Scope;\n+            while Present (C)\n+              and then Is_Child_Unit (C)\n+            loop\n+               Set_Is_Immediately_Visible (C);\n+               Set_Is_Visible_Child_Unit (C);\n+               C := Scope (C);\n+            end loop;\n+         end;\n+      end if;\n    end Analyze_Subunit;\n \n    ----------------------------\n@@ -2282,13 +2379,6 @@ package body Sem_Ch10 is\n       if Private_Present (N) then\n          Set_Is_Immediately_Visible (E_Name, False);\n       end if;\n-\n-      --  Check for with'ing obsolescent package. Exclude subprograms here\n-      --  since we will catch those on the call rather than the WITH.\n-\n-      if Is_Package_Or_Generic_Package (E_Name) then\n-         Check_Obsolescent (E_Name, N);\n-      end if;\n    end Analyze_With_Clause;\n \n    ------------------------------\n@@ -2760,7 +2850,7 @@ package body Sem_Ch10 is\n                      Error_Msg_N\n                        (\"unit in with clause is private child unit!\", Item);\n                      Error_Msg_NE\n-                       (\"current unit must also have parent&!\",\n+                       (\"\\current unit must also have parent&!\",\n                         Item, Child_Parent);\n                   end if;\n \n@@ -3384,6 +3474,8 @@ package body Sem_Ch10 is\n          Item := First (Visible_Declarations (Spec));\n          while Present (Item) loop\n \n+            --  Look only at use package clauses\n+\n             if Nkind (Item) = N_Use_Package_Clause then\n \n                --  Traverse the list of packages\n@@ -3397,8 +3489,11 @@ package body Sem_Ch10 is\n                   if Nkind (Parent (E)) = N_Package_Renaming_Declaration\n                     and then Renamed_Entity (E) = WEnt\n                   then\n-                     Error_Msg_N (\"unlimited view visible through \" &\n-                                  \"use clause and renamings\", W);\n+                     --  The unlimited view is visible through use clause and\n+                     --  renamings. There is not need to generate the error\n+                     --  message here because Is_Visible_Through_Renamings\n+                     --  takes care of generating the precise error message.\n+\n                      return;\n \n                   elsif Nkind (Parent (E)) = N_Package_Specification then\n@@ -3421,7 +3516,6 @@ package body Sem_Ch10 is\n                   end if;\n                   Next (Nam);\n                end loop;\n-\n             end if;\n \n             Next (Item);\n@@ -3480,7 +3574,7 @@ package body Sem_Ch10 is\n             Error_Msg_N\n               (\"unit in with clause is private child unit!\", Item);\n             Error_Msg_NE\n-              (\"current unit must also have parent&!\",\n+              (\"\\current unit must also have parent&!\",\n                Item, Defining_Unit_Name (Specification (Unit (Child_Parent))));\n \n          elsif not Private_Present (Parent (Item))\n@@ -3546,9 +3640,12 @@ package body Sem_Ch10 is\n          New_Nodes_OK := New_Nodes_OK + 1;\n \n          if Nkind (Nam) = N_Identifier then\n+\n+            --  Create node for name of withed unit\n+\n             Withn :=\n               Make_With_Clause (Loc,\n-                Name => Nam);\n+                Name => New_Copy (Nam));\n \n          else pragma Assert (Nkind (Nam) = N_Selected_Component);\n             Withn :=\n@@ -3644,6 +3741,53 @@ package body Sem_Ch10 is\n \n          Next (Item);\n       end loop;\n+\n+      --  Ada 2005 (AI-412): Examine the visible declarations of a package\n+      --  spec, looking for incomplete subtype declarations of incomplete\n+      --  types visible through a limited with clause.\n+\n+      if Ada_Version >= Ada_05\n+        and then Analyzed (N)\n+        and then Nkind (Unit (N)) = N_Package_Declaration\n+      then\n+         declare\n+            Decl         : Node_Id;\n+            Def_Id       : Entity_Id;\n+            Non_Lim_View : Entity_Id;\n+\n+         begin\n+            Decl := First (Visible_Declarations (Specification (Unit (N))));\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Subtype_Declaration\n+                 and then\n+                   Ekind (Defining_Identifier (Decl)) = E_Incomplete_Subtype\n+                 and then\n+                   From_With_Type (Defining_Identifier (Decl))\n+               then\n+                  Def_Id := Defining_Identifier (Decl);\n+                  Non_Lim_View := Non_Limited_View (Def_Id);\n+\n+                  --  Convert an incomplete subtype declaration into a\n+                  --  corresponding non-limited view subtype declaration.\n+\n+                  Set_Subtype_Indication (Decl,\n+                    New_Reference_To (Non_Lim_View, Sloc (Def_Id)));\n+                  Set_Etype (Def_Id, Non_Lim_View);\n+                  Set_Ekind (Def_Id, Subtype_Kind (Ekind (Non_Lim_View)));\n+                  Set_Analyzed (Decl, False);\n+\n+                  --  Reanalyze the declaration, suppressing the call to\n+                  --  Enter_Name to avoid duplicate names.\n+\n+                  Analyze_Subtype_Declaration\n+                   (N    => Decl,\n+                    Skip => True);\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end;\n+      end if;\n    end Install_Limited_Context_Clauses;\n \n    ---------------------\n@@ -3808,7 +3952,8 @@ package body Sem_Ch10 is\n       Prev : Entity_Id;\n    begin\n       --  Iterate over explicit with clauses, and check whether the\n-      --  scope of each entity is an ancestor of the current unit.\n+      --  scope of each entity is an ancestor of the current unit, in\n+      --  which case it is immediately visible.\n \n       Item := First (Context_Items (N));\n       while Present (Item) loop\n@@ -3861,13 +4006,27 @@ package body Sem_Ch10 is\n                   end;\n                end if;\n \n-            --  the With_Clause may be on a grand-child, which makes\n-            --  the child immediately visible.\n+            --  The With_Clause may be on a grand-child or one of its\n+            --  further descendants, which makes a child immediately visible.\n+            --  Examine ancestry to determine whether such a child exists.\n+            --  For example, if current unit is A.C, and with_clause is on\n+            --  A.X.Y.Z, then X is immediately visible.\n \n-            elsif Is_Child_Unit (Scope (Id))\n-              and then Is_Ancestor_Package (Scope (Scope (Id)), U_Name)\n-            then\n-               Set_Is_Immediately_Visible (Scope (Id));\n+            elsif Is_Child_Unit (Id) then\n+               declare\n+                  Par : Entity_Id;\n+\n+               begin\n+                  Par := Scope (Id);\n+                  while Is_Child_Unit (Par) loop\n+                     if Is_Ancestor_Package (Scope (Par), U_Name) then\n+                        Set_Is_Immediately_Visible (Par);\n+                        exit;\n+                     end if;\n+\n+                     Par := Scope (Par);\n+                  end loop;\n+               end;\n             end if;\n          end if;\n \n@@ -3881,6 +4040,7 @@ package body Sem_Ch10 is\n \n    procedure Install_Limited_Withed_Unit (N : Node_Id) is\n       P_Unit           : constant Entity_Id := Unit (Library_Unit (N));\n+      E                : Entity_Id;\n       P                : Entity_Id;\n       Is_Child_Package : Boolean := False;\n \n@@ -3944,19 +4104,15 @@ package body Sem_Ch10 is\n                         --  installed.\n \n                         if Kind = N_Package_Declaration then\n+                           Error_Msg_N\n+                             (\"simultaneous visibility of the limited and\" &\n+                              \" unlimited views not allowed\", N);\n                            Error_Msg_Sloc := Sloc (Item);\n                            Error_Msg_NE\n-                             (\"unlimited view of & visible through the context\"\n-                              & \" clause found #\", N, P);\n-\n+                             (\"\\unlimited view of & visible through the\" &\n+                              \" context clause found #\", N, P);\n                            Error_Msg_Sloc := Sloc (Decl);\n-                           Error_Msg_NE\n-                             (\"unlimited view of & visible through the\"\n-                              & \" renaming found #\", N, P);\n-\n-                           Error_Msg_N\n-                             (\"simultaneous visibility of the limited and\"\n-                              & \" unlimited views not allowed\", N);\n+                           Error_Msg_NE (\"\\and the renaming found #\", N, P);\n                         end if;\n \n                         return True;\n@@ -4145,20 +4301,15 @@ package body Sem_Ch10 is\n          --  avoid its usage. This is needed to cover all the subtype decla-\n          --  rations because we do not remove them from the homonym chain.\n \n-         declare\n-            E : Entity_Id;\n-\n-         begin\n-            E := First_Entity (P);\n-            while Present (E) and then E /= First_Private_Entity (P) loop\n-               if Is_Type (E) then\n-                  Set_Was_Hidden (E, Is_Hidden (E));\n-                  Set_Is_Hidden (E);\n-               end if;\n+         E := First_Entity (P);\n+         while Present (E) and then E /= First_Private_Entity (P) loop\n+            if Is_Type (E) then\n+               Set_Was_Hidden (E, Is_Hidden (E));\n+               Set_Is_Hidden (E);\n+            end if;\n \n-               Next_Entity (E);\n-            end loop;\n-         end;\n+            Next_Entity (E);\n+         end loop;\n \n          --  Replace the real entities by the shadow entities of the limited\n          --  view. The first element of the limited view is a header that is\n@@ -4173,25 +4324,48 @@ package body Sem_Ch10 is\n          loop\n             pragma Assert (not In_Chain (Lim_Typ));\n \n-            --  Do not unchain child units\n+            --  Do not unchain nested packages and child units\n \n-            if not Is_Child_Unit (Lim_Typ) then\n+            if Ekind (Lim_Typ) /= E_Package\n+              and then not Is_Child_Unit (Lim_Typ)\n+            then\n                declare\n                   Prev : Entity_Id;\n \n                begin\n-                  Set_Homonym (Lim_Typ, Homonym (Non_Limited_View (Lim_Typ)));\n                   Prev := Current_Entity (Lim_Typ);\n \n-                  if Prev = Non_Limited_View (Lim_Typ) then\n+                  --  Handle incomplete types\n+\n+                  if Ekind (Prev) = E_Incomplete_Type then\n+                     E := Full_View (Prev);\n+                  else\n+                     E := Prev;\n+                  end if;\n+\n+                  --  Replace E in the homonyms list\n+\n+                  if E = Non_Limited_View (Lim_Typ) then\n+                     Set_Homonym (Lim_Typ, Homonym (Prev));\n                      Set_Current_Entity (Lim_Typ);\n+\n                   else\n-                     while Present (Prev)\n-                       and then Homonym (Prev) /= Non_Limited_View (Lim_Typ)\n                      loop\n+                        E := Homonym (Prev);\n+                        pragma Assert (Present (E));\n+\n+                        --  Handle incomplete types\n+\n+                        if Ekind (E) = E_Incomplete_Type then\n+                           E := Full_View (E);\n+                        end if;\n+\n+                        exit when E = Non_Limited_View (Lim_Typ);\n+\n                         Prev := Homonym (Prev);\n                      end loop;\n \n+                     Set_Homonym (Lim_Typ, Homonym (Homonym (Prev)));\n                      Set_Homonym (Prev, Lim_Typ);\n                   end if;\n                end;\n@@ -4224,15 +4398,29 @@ package body Sem_Ch10 is\n          declare\n             Nam : Node_Id;\n             Ent : Entity_Id;\n+\n          begin\n             Nam := Name (N);\n             Ent := P;\n             while Nkind (Nam) = N_Selected_Component\n               and then Present (Ent)\n             loop\n                Change_Selected_Component_To_Expanded_Name (Nam);\n+\n+               --  Set entity of parent identifiers if the unit is a child\n+               --  unit. This ensures that the tree is properly formed from\n+               --  semantic point of view (e.g. for ASIS queries).\n+\n+               Set_Entity (Nam, Ent);\n+\n                Nam := Prefix (Nam);\n                Ent := Scope (Ent);\n+\n+               --  Set entity of last ancestor\n+\n+               if Nkind (Nam) = N_Identifier then\n+                  Set_Entity (Nam, Ent);\n+               end if;\n             end loop;\n          end;\n       end if;\n@@ -4610,9 +4798,9 @@ package body Sem_Ch10 is\n          Set_Etype (P, Standard_Void_Type);\n       end Decorate_Package_Specification;\n \n-      -------------------------\n-      -- New_Internal_Entity --\n-      -------------------------\n+      --------------------------------\n+      -- New_Internal_Shadow_Entity --\n+      --------------------------------\n \n       function New_Internal_Shadow_Entity\n         (Kind       : Entity_Kind;\n@@ -4665,11 +4853,19 @@ package body Sem_Ch10 is\n             --     completion is the type_declaration. If the type_declaration\n             --     is tagged, then the incomplete_type_declaration is tagged\n             --     incomplete.\n+            --     The partial view is tagged if the declaration has the\n+            --     explicit keyword, or else if it is a type extension, both\n+            --     of which can be ascertained syntactically.\n \n             if Nkind (Decl) = N_Full_Type_Declaration then\n                Is_Tagged :=\n-                  Nkind (Type_Definition (Decl)) = N_Record_Definition\n-                    and then Tagged_Present (Type_Definition (Decl));\n+                  (Nkind (Type_Definition (Decl)) = N_Record_Definition\n+                    and then Tagged_Present (Type_Definition (Decl)))\n+                 or else\n+                   (Nkind (Type_Definition (Decl)) = N_Derived_Type_Definition\n+                     and then\n+                       Present\n+                         (Record_Extension_Part (Type_Definition (Decl))));\n \n                Comp_Typ := Defining_Identifier (Decl);\n \n@@ -5076,6 +5272,7 @@ package body Sem_Ch10 is\n \n    procedure Remove_Limited_With_Clause (N : Node_Id) is\n       P_Unit     : constant Entity_Id := Unit (Library_Unit (N));\n+      E          : Entity_Id;\n       P          : Entity_Id;\n       Lim_Header : Entity_Id;\n       Lim_Typ    : Entity_Id;\n@@ -5137,48 +5334,66 @@ package body Sem_Ch10 is\n          --  from visibility at the point of installation of the limited-view.\n          --  Now we recover the previous value of the hidden attribute.\n \n-         declare\n-            E : Entity_Id;\n-\n-         begin\n-            E := First_Entity (P);\n-            while Present (E) and then E /= First_Private_Entity (P) loop\n-               if Is_Type (E) then\n-                  Set_Is_Hidden (E, Was_Hidden (E));\n-               end if;\n+         E := First_Entity (P);\n+         while Present (E) and then E /= First_Private_Entity (P) loop\n+            if Is_Type (E) then\n+               Set_Is_Hidden (E, Was_Hidden (E));\n+            end if;\n \n-               Next_Entity (E);\n-            end loop;\n-         end;\n+            Next_Entity (E);\n+         end loop;\n \n          while Present (Lim_Typ)\n            and then Lim_Typ /= First_Private_Entity (Lim_Header)\n          loop\n-            pragma Assert (not In_Chain (Non_Limited_View (Lim_Typ)));\n+            --  Nested packages and child units were not unchained\n+\n+            if Ekind (Lim_Typ) /= E_Package\n+              and then not Is_Child_Unit (Non_Limited_View (Lim_Typ))\n+            then\n+               --  Handle incomplete types of the real view. For this purpose\n+               --  we traverse the list of visible entities to look for an\n+               --  incomplete type in the real-view associated with Lim_Typ.\n+\n+               E := First_Entity (P);\n+               while Present (E) and then E /= First_Private_Entity (P) loop\n+                  exit when Ekind (E) = E_Incomplete_Type\n+                    and then Present (Full_View (E))\n+                    and then Full_View (E) = Lim_Typ;\n+\n+                  Next_Entity (E);\n+               end loop;\n+\n+               --  If the previous search was not sucessful then the entity\n+               --  to be restored in the homonym list is the non-limited view\n \n-            --  Child units have not been unchained\n+               if E = First_Private_Entity (P) then\n+                  E := Non_Limited_View (Lim_Typ);\n+               end if;\n+\n+               pragma Assert (not In_Chain (E));\n \n-            if not Is_Child_Unit (Non_Limited_View (Lim_Typ)) then\n                Prev := Current_Entity (Lim_Typ);\n \n                if Prev = Lim_Typ then\n-                  Set_Current_Entity (Non_Limited_View (Lim_Typ));\n+                  Set_Current_Entity (E);\n+\n                else\n                   while Present (Prev)\n                     and then Homonym (Prev) /= Lim_Typ\n                   loop\n                      Prev := Homonym (Prev);\n                   end loop;\n-\n                   pragma Assert (Present (Prev));\n-                  Set_Homonym (Prev, Non_Limited_View (Lim_Typ));\n+\n+                  Set_Homonym (Prev, E);\n                end if;\n \n                --  We must also set the next homonym entity of the real entity\n                --  to handle the case in which the next homonym was a shadow\n                --  entity.\n \n-               Set_Homonym (Non_Limited_View (Lim_Typ), Homonym (Lim_Typ));\n+               Set_Homonym (E, Homonym (Lim_Typ));\n             end if;\n \n             Next_Entity (Lim_Typ);\n@@ -5243,6 +5458,33 @@ package body Sem_Ch10 is\n       end if;\n    end Remove_Parents;\n \n+   ---------------------------------\n+   -- Remove_Private_With_Clauses --\n+   ---------------------------------\n+\n+   procedure Remove_Private_With_Clauses (Comp_Unit : Node_Id) is\n+      Item : Node_Id;\n+\n+   begin\n+      Item := First (Context_Items (Comp_Unit));\n+      while Present (Item) loop\n+         if Nkind (Item) = N_With_Clause\n+           and then Private_Present (Item)\n+         then\n+            if Limited_Present (Item) then\n+               if not Limited_View_Installed (Item) then\n+                  Remove_Limited_With_Clause (Item);\n+               end if;\n+            else\n+               Remove_Unit_From_Visibility (Entity (Name (Item)));\n+               Set_Context_Installed (Item, False);\n+            end if;\n+         end if;\n+\n+         Next (Item);\n+      end loop;\n+   end Remove_Private_With_Clauses;\n+\n    -----------------------------\n    -- Remove_With_Type_Clause --\n    -----------------------------"}, {"sha": "c7018b451185f13e0a82d4820f8bb2b772efef3f", "filename": "gcc/ada/sem_ch10.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/743c8beb16b662bd3db79e190554d9f9674e4e2e/gcc%2Fada%2Fsem_ch10.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/743c8beb16b662bd3db79e190554d9f9674e4e2e/gcc%2Fada%2Fsem_ch10.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.ads?ref=743c8beb16b662bd3db79e190554d9f9674e4e2e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,6 +53,13 @@ package Sem_Ch10 is\n    --  end of the main unit the visibility table won't be needed in any case.\n    --  For a child unit, remove parents and their context as well.\n \n+   procedure Remove_Private_With_Clauses (Comp_Unit : Node_Id);\n+   --  The private_with_clauses of a compilation unit are visible in the\n+   --  private part of a nested package, even if this package appears in\n+   --  the visible part of the enclosing compilation unit. This Ada 2005\n+   --  rule imposes extra steps in order to install/remove the private_with\n+   --  clauses of the an enclosing unit.\n+\n    procedure Load_Needed_Body (N : Node_Id; OK : out Boolean);\n    --  Load and analyze the body of a context unit that is generic, or\n    --  that contains generic units or inlined units. The body becomes"}]}