{"sha": "e22862689667e739d308140d72e8cc85ed116a2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIyODYyNjg5NjY3ZTczOWQzMDgxNDBkNzJlOGNjODVlZDExNmEyZg==", "commit": {"author": {"name": "Monk Chiang", "email": "sh.chiang04@gmail.com", "date": "2018-04-06T05:51:33Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-04-06T05:51:33Z"}, "message": "[NDS32] Add hard float support.\n\ngcc/\n\t* config.gcc (nds32*-*-*): Add v2j v3f v3s checking.\n\t(nds32*-*-*): Add float and fpu_config into supported_defaults.\n\t* common/config/nds32/nds32-common.c (TARGET_DEFAULT_TARGET_FLAGS):\n\tInclude TARGET_DEFAULT_FPU_ISA and TARGET_DEFAULT_FPU_FMA.\n\t* config/nds32/constants.md (unspec_element): Add UNSPEC_COPYSIGN,\n\tUNSPEC_FCPYNSD, UNSPEC_FCPYNSS, UNSPEC_FCPYSD and UNSPEC_FCPYSS.\n\t* config/nds32/constraints.md: New constraints and checking for hard\n\tfloat configuration.\n\t* config/nds32/iterators.md: New mode iterator and attribute for hard\n\tfloat configuration.\n\t* config/nds32/nds32-doubleword.md: Use hard float alternatives and\n\tpatterns.\n\t* config/nds32/nds32-fpu.md: New file.\n\t* config/nds32/nds32-md-auxiliary.c: New functions and checkings to\n\tdeal with hard float code generation.\n\t* config/nds32/nds32-opts.h (nds32_arch_type): Add ARCH_V3F and\n\tARCH_V3S.\n\t(abi_type, float_reg_number): New enum type.\n\t* config/nds32/nds32-predicates.c: New predicates for hard float.\n\t* config/nds32/nds32-protos.h: Declare functions for hard float.\n\t* config/nds32/nds32.c: Implementation for hard float configuration.\n\t* config/nds32/nds32.h: Definitions for hard float configuration.\n\t* config/nds32/nds32.md: Include hard float machine description and\n\tmodify patterns for hard float configuration.\n\t* config/nds32/nds32.opt: New options for hard float configuration.\n\t* config/nds32/predicates.md: New predicates for hard float\n\tconfiguration.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\n\nFrom-SVN: r259161", "tree": {"sha": "d2c7d8e25a700eade32158174a160be46dcc37c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2c7d8e25a700eade32158174a160be46dcc37c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e22862689667e739d308140d72e8cc85ed116a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e22862689667e739d308140d72e8cc85ed116a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e22862689667e739d308140d72e8cc85ed116a2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e22862689667e739d308140d72e8cc85ed116a2f/comments", "author": {"login": "monkchiang", "id": 62004175, "node_id": "MDQ6VXNlcjYyMDA0MTc1", "avatar_url": "https://avatars.githubusercontent.com/u/62004175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/monkchiang", "html_url": "https://github.com/monkchiang", "followers_url": "https://api.github.com/users/monkchiang/followers", "following_url": "https://api.github.com/users/monkchiang/following{/other_user}", "gists_url": "https://api.github.com/users/monkchiang/gists{/gist_id}", "starred_url": "https://api.github.com/users/monkchiang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/monkchiang/subscriptions", "organizations_url": "https://api.github.com/users/monkchiang/orgs", "repos_url": "https://api.github.com/users/monkchiang/repos", "events_url": "https://api.github.com/users/monkchiang/events{/privacy}", "received_events_url": "https://api.github.com/users/monkchiang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58e297628fe95a905d73878915df4e004612369d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58e297628fe95a905d73878915df4e004612369d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58e297628fe95a905d73878915df4e004612369d"}], "stats": {"total": 3142, "additions": 2826, "deletions": 316}, "files": [{"sha": "979450f612cb7974d9c7e1bf38da50a6880524b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -1,3 +1,34 @@\n+2018-04-06  Monk Chiang  <sh.chiang04@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config.gcc (nds32*-*-*): Add v2j v3f v3s checking.\n+\t(nds32*-*-*): Add float and fpu_config into supported_defaults.\n+\t* common/config/nds32/nds32-common.c (TARGET_DEFAULT_TARGET_FLAGS):\n+\tInclude TARGET_DEFAULT_FPU_ISA and TARGET_DEFAULT_FPU_FMA.\n+\t* config/nds32/constants.md (unspec_element): Add UNSPEC_COPYSIGN,\n+\tUNSPEC_FCPYNSD, UNSPEC_FCPYNSS, UNSPEC_FCPYSD and UNSPEC_FCPYSS.\n+\t* config/nds32/constraints.md: New constraints and checking for hard\n+\tfloat configuration.\n+\t* config/nds32/iterators.md: New mode iterator and attribute for hard\n+\tfloat configuration.\n+\t* config/nds32/nds32-doubleword.md: Use hard float alternatives and\n+\tpatterns.\n+\t* config/nds32/nds32-fpu.md: New file.\n+\t* config/nds32/nds32-md-auxiliary.c: New functions and checkings to\n+\tdeal with hard float code generation.\n+\t* config/nds32/nds32-opts.h (nds32_arch_type): Add ARCH_V3F and\n+\tARCH_V3S.\n+\t(abi_type, float_reg_number): New enum type.\n+\t* config/nds32/nds32-predicates.c: New predicates for hard float.\n+\t* config/nds32/nds32-protos.h: Declare functions for hard float.\n+\t* config/nds32/nds32.c: Implementation for hard float configuration.\n+\t* config/nds32/nds32.h: Definitions for hard float configuration.\n+\t* config/nds32/nds32.md: Include hard float machine description and\n+\tmodify patterns for hard float configuration.\n+\t* config/nds32/nds32.opt: New options for hard float configuration.\n+\t* config/nds32/predicates.md: New predicates for hard float\n+\tconfiguration.\n+\n 2018-04-06  Kuan-Lin Chen  <kuanlinchentw@gmail.com>\n \n \t* common/config/nds32/nds32-common.c"}, {"sha": "dbcc390728e0bd748a53a0a0c44369f1fa3d211d", "filename": "gcc/common/config/nds32/nds32-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fcommon%2Fconfig%2Fnds32%2Fnds32-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fcommon%2Fconfig%2Fnds32%2Fnds32-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fnds32%2Fnds32-common.c?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -107,6 +107,8 @@ static const struct default_options nds32_option_optimization_table[] =\n #undef TARGET_DEFAULT_TARGET_FLAGS\n #define TARGET_DEFAULT_TARGET_FLAGS\t\t\\\n   (TARGET_CPU_DEFAULT\t\t\t\t\\\n+   | TARGET_DEFAULT_FPU_ISA\t\t\t\\\n+   | TARGET_DEFAULT_FPU_FMA\t\t\t\\\n    | MASK_16_BIT\t\t\t\t\\\n    | MASK_EXT_PERF\t\t\t\t\\\n    | MASK_EXT_PERF2\t\t\t\t\\"}, {"sha": "75d0ae815fff90862707f2bf4f8808c47c0d70fd", "filename": "gcc/config.gcc", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -4278,15 +4278,26 @@ case \"${target}\" in\n \t\t;;\n \n \tnds32*-*-*)\n-\t\tsupported_defaults=\"arch cpu nds32_lib\"\n+\t\tsupported_defaults=\"arch cpu nds32_lib float fpu_config\"\n \n \t\t# process --with-arch\n \t\tcase \"${with_arch}\" in\n-\t\t\"\" | v2 | v3 | v3m)\n+\t\t\"\" | v3 )\n+\t\t\ttm_defines=\"${tm_defines} TARGET_ARCH_DEFAULT=0\"\n+\t\t\t;;\n+\t\tv2 | v2j | v3m)\n \t\t\t# OK\n+\t\t\ttm_defines=\"${tm_defines} TARGET_ARCH_DEFAULT=0\"\n+\t\t\t;;\n+\t\tv3f)\n+\t\t\ttm_defines=\"${tm_defines} TARGET_ARCH_DEFAULT=1\"\n+\t\t\t;;\n+\t\tv3s)\n+\t\t\ttm_defines=\"${tm_defines} TARGET_ARCH_DEFAULT=2\"\n+\n \t\t\t;;\n \t\t*)\n-\t\t\techo \"Cannot accept --with-arch=$with_arch, available values are: v2 v3 v3m\" 1>&2\n+\t\t\techo \"Cannot accept --with-arch=$with_arch, available values are: v2 v2j v3 v3m v3f v3s\" 1>&2\n \t\t\texit 1\n \t\t\t;;\n \t\tesac\n@@ -4321,8 +4332,31 @@ case \"${target}\" in\n \t\t\texit 1\n \t\t\t;;\n \t\tesac\n-\t\t;;\n \n+\t\t# process --with-float\n+\t\tcase \"${with_float}\" in\n+\t\t\"\" | soft | hard)\n+\t\t\t# OK\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"Cannot accept --with-float=$with_float, available values are: soft hard\" 1>&2\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n+\n+\t\t# process --with-config-fpu\n+\t\tcase \"${with_config_fpu}\" in\n+\t\t\"\" | 0 | 1 | 2 | 3)\n+\t\t\t# OK\n+\t\t\t;;\n+\t\t*)\n+\t\t\techo \"Cannot accept --with-config-fpu=$with_config_fpu, available values from 0 to 7\" 1>&2\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n+\n+\n+\t\t;;\n \tnios2*-*-*)\n \t\tsupported_defaults=\"arch\"\n \t\t\tcase \"$with_arch\" in"}, {"sha": "7c706eb7da033fbfce778ffdf537d8a99768e683", "filename": "gcc/config/nds32/constants.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fconstants.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fconstants.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fconstants.md?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -32,6 +32,11 @@\n \n ;; The unpec operation index.\n (define_c_enum \"unspec_element\" [\n+  UNSPEC_COPYSIGN\n+  UNSPEC_FCPYNSD\n+  UNSPEC_FCPYNSS\n+  UNSPEC_FCPYSD\n+  UNSPEC_FCPYSS\n   UNSPEC_FFB\n   UNSPEC_FFMISM\n   UNSPEC_FLMISM"}, {"sha": "7af7769fcbf68771ea95b78fb1b47314b8b40ca2", "filename": "gcc/config/nds32/constraints.md", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fconstraints.md?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -53,6 +53,10 @@\n (define_register_constraint \"x\" \"FRAME_POINTER_REG\"\n   \"Frame pointer register $fp\")\n \n+(define_register_constraint \"f\"\n+  \"(TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE) ? FP_REGS : NO_REGS\"\n+ \"The Floating point registers $fs0 ~ $fs31\")\n+\n (define_constraint \"Iv00\"\n   \"Constant value 0\"\n   (and (match_code \"const_int\")\n@@ -108,6 +112,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival < (1 << 4) && ival >= -(1 << 4)\")))\n \n+(define_constraint \"Cs05\"\n+  \"Signed immediate 5-bit value\"\n+  (and (match_code \"const_double\")\n+       (match_test \"nds32_const_double_range_ok_p (op, SFmode, -(1 << 4), (1 << 4))\")))\n+\n (define_constraint \"Iu05\"\n   \"Unsigned immediate 5-bit value\"\n   (and (match_code \"const_int\")\n@@ -246,12 +255,21 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival < (1 << 19) && ival >= -(1 << 19)\")))\n \n+(define_constraint \"Cs20\"\n+  \"Signed immediate 20-bit value\"\n+  (and (match_code \"const_double\")\n+       (match_test \"nds32_const_double_range_ok_p (op, SFmode, -(1 << 19), (1 << 19))\")))\n \n (define_constraint \"Ihig\"\n   \"The immediate value that can be simply set high 20-bit\"\n   (and (match_code \"const_int\")\n        (match_test \"(ival != 0) && ((ival & 0xfff) == 0)\")))\n \n+(define_constraint \"Chig\"\n+  \"The immediate value that can be simply set high 20-bit\"\n+  (and (match_code \"high\")\n+       (match_test \"GET_CODE (XEXP (op, 0)) == CONST_DOUBLE\")))\n+\n (define_constraint \"Izeb\"\n   \"The immediate value 0xff\"\n   (and (match_code \"const_int\")\n@@ -296,25 +314,39 @@\n   \"Memory constraint for 45 format\"\n   (and (match_code \"mem\")\n        (match_test \"(nds32_mem_format (op) == ADDRESS_REG)\n-\t\t    && (GET_MODE (op) == SImode)\")))\n+\t\t    && ((GET_MODE (op) == SImode)\n+\t\t       || (GET_MODE (op) == SFmode))\")))\n \n (define_memory_constraint \"Ufe\"\n   \"Memory constraint for fe format\"\n   (and (match_code \"mem\")\n        (match_test \"nds32_mem_format (op) == ADDRESS_R8_IMM7U\n-\t\t    && (GET_MODE (op) == SImode)\")))\n+\t\t    && (GET_MODE (op) == SImode\n+\t\t\t|| GET_MODE (op) == SFmode)\")))\n \n (define_memory_constraint \"U37\"\n   \"Memory constraint for 37 format\"\n   (and (match_code \"mem\")\n        (match_test \"(nds32_mem_format (op) == ADDRESS_SP_IMM7U\n \t\t    || nds32_mem_format (op) == ADDRESS_FP_IMM7U)\n-\t\t    && (GET_MODE (op) == SImode)\")))\n-\n+\t\t    && (GET_MODE (op) == SImode\n+\t\t\t|| GET_MODE (op) == SFmode)\")))\n \n (define_memory_constraint \"Umw\"\n   \"Memory constraint for lwm/smw\"\n   (and (match_code \"mem\")\n        (match_test \"nds32_valid_smw_lwm_base_p (op)\")))\n \n+(define_memory_constraint \"Da\"\n+  \"Memory constraint for non-offset loads/stores\"\n+  (and (match_code \"mem\")\n+       (match_test \"REG_P (XEXP (op, 0))\n+\t\t    || (GET_CODE (XEXP (op, 0)) == POST_INC)\")))\n+\n+(define_memory_constraint \"Q\"\n+  \"Memory constraint for no symbol_ref and const\"\n+  (and (match_code \"mem\")\n+       (match_test \"(TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE)\n+\t\t     && nds32_float_mem_operand_p (op)\")))\n+\n ;; ------------------------------------------------------------------------"}, {"sha": "c2062de2e977104dfd1b358060ab20e56bd6a9e3", "filename": "gcc/config/nds32/iterators.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fiterators.md?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -45,11 +45,15 @@\n (define_mode_iterator VSQIHIDI [V4QI V2HI QI HI DI])\n (define_mode_iterator VQIHIDI [V4QI V2HI DI])\n \n+;; A list of the modes that are up to double-word long.\n+(define_mode_iterator ANYF [(SF \"TARGET_FPU_SINGLE\")\n+\t\t\t    (DF \"TARGET_FPU_DOUBLE\")])\n+\n ;;----------------------------------------------------------------------------\n ;; Mode attributes.\n ;;----------------------------------------------------------------------------\n \n-(define_mode_attr size [(QI \"b\") (HI \"h\") (SI \"w\")])\n+(define_mode_attr size [(QI \"b\") (HI \"h\") (SI \"w\") (SF \"s\") (DF \"d\")])\n \n (define_mode_attr byte [(QI \"1\") (HI \"2\") (SI \"4\") (V4QI \"4\") (V2HI \"4\")])\n "}, {"sha": "7df715a771fea828487e7d578f3340e5afcf3a3f", "filename": "gcc/config/nds32/nds32-doubleword.md", "status": "modified", "additions": 86, "deletions": 125, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-doubleword.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-doubleword.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-doubleword.md?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -46,145 +46,77 @@\n \n \n (define_insn \"move_<mode>\"\n-  [(set (match_operand:DIDF 0 \"nonimmediate_operand\" \"=r, r, r, m\")\n-\t(match_operand:DIDF 1 \"general_operand\"      \" r, i, m, r\"))]\n+  [(set (match_operand:DIDF 0 \"nonimmediate_operand\" \"=r, r,  r, r, Da, m, f, Q, f, *r, *f\")\n+\t(match_operand:DIDF 1 \"general_operand\"      \" r, i, Da, m,  r, r, Q, f, f, *f, *r\"))]\n   \"register_operand(operands[0], <MODE>mode)\n    || register_operand(operands[1], <MODE>mode)\"\n {\n-  rtx addr;\n-  rtx otherops[5];\n-\n   switch (which_alternative)\n     {\n     case 0:\n       return \"movd44\\t%0, %1\";\n-\n     case 1:\n       /* reg <- const_int, we ask gcc to split instruction.  */\n       return \"#\";\n-\n     case 2:\n-      /* Refer to nds32_legitimate_address_p() in nds32.c,\n-         we only allow \"reg\", \"symbol_ref\", \"const\", and \"reg + const_int\"\n-         as address rtx for DImode/DFmode memory access.  */\n-      addr = XEXP (operands[1], 0);\n-\n-      otherops[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n-      otherops[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      otherops[2] = addr;\n-\n-      if (REG_P (addr))\n-\t{\n-\t  /* (reg) <- (mem (reg)) */\n-\t  output_asm_insn (\"lmw.bi\\t%0, [%2], %1, 0\", otherops);\n-\t}\n-      else if (GET_CODE (addr) == PLUS)\n-\t{\n-\t  /* (reg) <- (mem (plus (reg) (const_int))) */\n-\t  rtx op0 = XEXP (addr, 0);\n-\t  rtx op1 = XEXP (addr, 1);\n-\n-\t  if (REG_P (op0))\n-\t    {\n-\t      otherops[2] = op0;\n-\t      otherops[3] = op1;\n-\t      otherops[4] = gen_int_mode (INTVAL (op1) + 4, SImode);\n-\t    }\n-\t  else\n-\t    {\n-\t      otherops[2] = op1;\n-\t      otherops[3] = op0;\n-\t      otherops[4] = gen_int_mode (INTVAL (op0) + 4, SImode);\n-\t    }\n-\n-\t  /* To avoid base overwrite when REGNO(%0) == REGNO(%2).  */\n-\t  if (REGNO (otherops[0]) != REGNO (otherops[2]))\n-\t    {\n-\t      output_asm_insn (\"lwi\\t%0, [%2 + (%3)]\", otherops);\n-\t      output_asm_insn (\"lwi\\t%1, [%2 + (%4)]\", otherops);\n-\t    }\n-\t  else\n-\t    {\n-\t      output_asm_insn (\"lwi\\t%1, [%2 + (%4)]\", otherops);\n-\t      output_asm_insn (\"lwi\\t%0,[ %2 + (%3)]\", otherops);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* (reg) <- (mem (symbol_ref ...))\n-\t     (reg) <- (mem (const ...)) */\n-\t  output_asm_insn (\"lwi.gp\\t%0, [ + %2]\", otherops);\n-\t  output_asm_insn (\"lwi.gp\\t%1, [ + %2 + 4]\", otherops);\n-\t}\n-\n-      /* We have already used output_asm_insn() by ourself,\n-         so return an empty string.  */\n-      return \"\";\n-\n+      /* The memory format is (mem (reg)),\n+\t we can generate 'lmw.bi' instruction.  */\n+      return nds32_output_double (operands, true);\n     case 3:\n-      /* Refer to nds32_legitimate_address_p() in nds32.c,\n-         we only allow \"reg\", \"symbol_ref\", \"const\", and \"reg + const_int\"\n-         as address rtx for DImode/DFmode memory access.  */\n-      addr = XEXP (operands[0], 0);\n-\n-      otherops[0] = gen_rtx_REG (SImode, REGNO (operands[1]));\n-      otherops[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-      otherops[2] = addr;\n-\n-      if (REG_P (addr))\n-\t{\n-\t  /* (mem (reg)) <- (reg) */\n-\t  output_asm_insn (\"smw.bi\\t%0, [%2], %1, 0\", otherops);\n-\t}\n-      else if (GET_CODE (addr) == PLUS)\n-\t{\n-\t  /* (mem (plus (reg) (const_int))) <- (reg) */\n-\t  rtx op0 = XEXP (addr, 0);\n-\t  rtx op1 = XEXP (addr, 1);\n-\n-\t  if (REG_P (op0))\n-\t    {\n-\t      otherops[2] = op0;\n-\t      otherops[3] = op1;\n-\t      otherops[4] = gen_int_mode (INTVAL (op1) + 4, SImode);\n-\t    }\n-\t  else\n-\t    {\n-\t      otherops[2] = op1;\n-\t      otherops[3] = op0;\n-\t      otherops[4] = gen_int_mode (INTVAL (op0) + 4, SImode);\n-\t    }\n-\n-\t  /* To avoid base overwrite when REGNO(%0) == REGNO(%2).  */\n-\t  if (REGNO (otherops[0]) != REGNO (otherops[2]))\n-\t    {\n-\t      output_asm_insn (\"swi\\t%0, [%2 + (%3)]\", otherops);\n-\t      output_asm_insn (\"swi\\t%1, [%2 + (%4)]\", otherops);\n-\t    }\n-\t  else\n-\t    {\n-\t      output_asm_insn (\"swi\\t%1, [%2 + (%4)]\", otherops);\n-\t      output_asm_insn (\"swi\\t%0, [%2 + (%3)]\", otherops);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* (mem (symbol_ref ...)) <- (reg)\n-\t     (mem (const ...))      <- (reg) */\n-\t  output_asm_insn (\"swi.gp\\t%0, [ + %2]\", otherops);\n-\t  output_asm_insn (\"swi.gp\\t%1, [ + %2 + 4]\", otherops);\n-\t}\n-\n-      /* We have already used output_asm_insn() by ourself,\n-         so return an empty string.  */\n-      return \"\";\n-\n+      /* We haven't 64-bit load instruction,\n+\t we split this pattern to two SImode pattern.  */\n+      return \"#\";\n+    case 4:\n+      /* The memory format is (mem (reg)),\n+\t we can generate 'smw.bi' instruction.  */\n+      return nds32_output_double (operands, false);\n+    case 5:\n+      /* We haven't 64-bit store instruction,\n+\t we split this pattern to two SImode pattern.  */\n+      return \"#\";\n+    case 6:\n+      return nds32_output_float_load (operands);\n+    case 7:\n+      return nds32_output_float_store (operands);\n+    case 8:\n+      return \"fcpysd\\t%0, %1, %1\";\n+    case 9:\n+      return \"fmfdr\\t%0, %1\";\n+    case 10:\n+      return \"fmtdr\\t%1, %0\";\n     default:\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\"   \"alu,alu,alu,alu\")\n-   (set_attr \"length\" \"  4, 16,  8,  8\")])\n+  [(set_attr \"type\"    \"alu,alu,load,load,store,store,fload,fstore,fcpy,fmfdr,fmtdr\")\n+   (set_attr_alternative \"length\"\n+     [\n+       ;; Alternative 0\n+       (if_then_else (match_test \"!TARGET_16_BIT\")\n+\t\t     (const_int 4)\n+\t\t     (const_int 2))\n+       ;; Alternative 1\n+       (const_int 16)\n+       ;; Alternative 2\n+       (const_int 4)\n+       ;; Alternative 3\n+       (const_int 8)\n+       ;; Alternative 4\n+       (const_int 4)\n+       ;; Alternative 5\n+       (const_int 8)\n+       ;; Alternative 6\n+       (const_int 4)\n+       ;; Alternative 7\n+       (const_int 4)\n+       ;; Alternative 8\n+       (const_int 4)\n+       ;; Alternative 9\n+       (const_int 4)\n+       ;; Alternative 10\n+       (const_int 4)\n+     ])\n+   (set_attr \"feature\" \" v1, v1,  v1,  v1,   v1,   v1,    fpu,    fpu,    fpu,    fpu,    fpu\")])\n \n (define_split\n   [(set (match_operand:DIDF 0 \"register_operand\"     \"\")\n@@ -208,7 +140,12 @@\n   /* Actually we would like to create move behavior by ourself.\n      So that movsi expander could have chance to split large constant.  */\n   emit_move_insn (operands[2], operands[3]);\n-  emit_move_insn (operands[4], operands[5]);\n+\n+  unsigned HOST_WIDE_INT mask = GET_MODE_MASK (SImode);\n+  if ((UINTVAL (operands[3]) & mask) == (UINTVAL (operands[5]) & mask))\n+    emit_move_insn (operands[4], operands[2]);\n+  else\n+    emit_move_insn (operands[4], operands[5]);\n   DONE;\n })\n \n@@ -218,7 +155,9 @@\n   [(set (match_operand:DIDF 0 \"register_operand\" \"\")\n \t(match_operand:DIDF 1 \"register_operand\" \"\"))]\n   \"reload_completed\n-   && (TARGET_ISA_V2 || !TARGET_16_BIT)\"\n+   && (TARGET_ISA_V2 || !TARGET_16_BIT)\n+   && NDS32_IS_GPR_REGNUM (REGNO (operands[0]))\n+   && NDS32_IS_GPR_REGNUM (REGNO (operands[1]))\"\n   [(set (match_dup 0) (match_dup 1))\n    (set (match_dup 2) (match_dup 3))]\n {\n@@ -240,6 +179,28 @@\n     }\n })\n \n+(define_split\n+  [(set (match_operand:DIDF 0 \"nds32_general_register_operand\" \"\")\n+\t(match_operand:DIDF 1 \"memory_operand\" \"\"))]\n+  \"reload_completed\n+   && nds32_split_double_word_load_store_p (operands, true)\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+{\n+  nds32_spilt_doubleword (operands, true);\n+})\n+\n+(define_split\n+  [(set (match_operand:DIDF 0  \"memory_operand\" \"\")\n+\t(match_operand:DIDF 1  \"nds32_general_register_operand\" \"\"))]\n+  \"reload_completed\n+   && nds32_split_double_word_load_store_p (operands, false)\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+{\n+  nds32_spilt_doubleword (operands, false);\n+})\n+\n ;; -------------------------------------------------------------\n ;; Boolean DImode instructions.\n ;; -------------------------------------------------------------"}, {"sha": "719b0428cedab06943d628fcf3fc09e854271c4b", "filename": "gcc/config/nds32/nds32-fpu.md", "status": "added", "additions": 503, "deletions": 0, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-fpu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-fpu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-fpu.md?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -0,0 +1,503 @@\n+;; Machine description of Andes NDS32 cpu for GNU compiler\n+;; Copyright (C) 2012-2015 Free Software Foundation, Inc.\n+;; Contributed by Andes Technology Corporation.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;;SFmode moves\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  /* Need to force register if mem <- !reg.  */\n+  if (MEM_P (operands[0]) && !REG_P (operands[1]))\n+    operands[1] = force_reg (SFmode, operands[1]);\n+  if (CONST_DOUBLE_P (operands[1])\n+      && !satisfies_constraint_Cs20 (operands[1]))\n+    {\n+      const REAL_VALUE_TYPE *r;\n+      unsigned long l;\n+\n+      r = CONST_DOUBLE_REAL_VALUE (operands[1]);\n+      REAL_VALUE_TO_TARGET_SINGLE (*r, l);\n+\n+      emit_move_insn (operands[0], gen_rtx_HIGH (SFmode, operands[1]));\n+\n+      if ((l & 0xFFF) != 0)\n+\temit_insn (gen_movsf_lo (operands[0], operands[0], operands[1]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"movsf_lo\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SF 2 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"ori\\t%0, %1, lo12(%2)\"\n+  [(set_attr \"type\"   \"alu\")\n+   (set_attr \"length\"   \"4\")]\n+)\n+\n+(define_insn \"*movsf\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r, r, U45, U33, U37, U45, m,   l,   l,   l,   d, r, f, *f, *r, f, Q,   r,   r,    r\")\n+\t(match_operand:SF 1 \"general_operand\"      \" r, r,   l,   l,   l,   d, r, U45, U33, U37, U45, m, f, *r, *f, Q, f,Cs05,Cs20, Chig\"))]\n+  \"(register_operand(operands[0], SFmode)\n+    || register_operand(operands[1], SFmode))\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"mov55\\t%0, %1\";\n+    case 1:\n+      return \"ori\\t%0, %1, 0\";\n+    case 2:\n+    case 3:\n+    case 4:\n+    case 5:\n+      return nds32_output_16bit_store (operands, 4);\n+    case 6:\n+      return nds32_output_32bit_store (operands, 4);\n+    case 7:\n+    case 8:\n+    case 9:\n+    case 10:\n+      return nds32_output_16bit_load (operands, 4);\n+    case 11:\n+      return nds32_output_32bit_load (operands, 4);\n+    case 12:\n+      if (TARGET_FPU_SINGLE)\n+\treturn \"fcpyss\\t%0, %1, %1\";\n+      else\n+\treturn \"#\";\n+    case 13:\n+      return \"fmtsr\\t%1, %0\";\n+    case 14:\n+      return \"fmfsr\\t%0, %1\";\n+    case 15:\n+      return nds32_output_float_load (operands);\n+    case 16:\n+      return nds32_output_float_store (operands);\n+    case 17:\n+      return \"movi55\\t%0, %1\";\n+    case 18:\n+      return \"movi\\t%0, %1\";\n+    case 19:\n+      return \"sethi\\t%0, %1\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set_attr \"type\"    \"alu,alu,store,store,store,store,store,load,load,load,load,load,fcpy,fmtsr,fmfsr,fload,fstore,alu,alu,alu\")\n+   (set_attr \"length\"  \"  2,  4,    2,    2,    2,    2,    4,   2,   2,   2,   2,   4,   4,    4,    4,    4,     4,  2,  4,  4\")\n+   (set_attr \"feature\" \" v1, v1,   v1,   v1,   v1,   v1,   v1,  v1,  v1,  v1,  v1,  v1, fpu,  fpu,  fpu,  fpu,   fpu, v1, v1, v1\")])\n+\n+;; Conditional Move Instructions\n+\n+(define_expand \"mov<mode>cc\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"\")\n+\t(if_then_else:ANYF (match_operand 1 \"nds32_float_comparison_operator\" \"\")\n+\t\t\t   (match_operand:ANYF 2 \"register_operand\" \"\")\n+\t\t\t   (match_operand:ANYF 3 \"register_operand\" \"\")))]\n+  \"\"\n+{\n+  if (nds32_cond_move_p (operands[1]))\n+    {\n+      /* Operands[1] condition code is UNORDERED or ORDERED, and\n+\t sub-operands[1] MODE isn't SFmode or SFmode, return FAIL\n+\t for gcc, because we don't using slt compare instruction\n+\t to generate UNORDERED and ORDERED condition.  */\n+      FAIL;\n+    }\n+  else\n+    nds32_expand_float_movcc (operands);\n+})\n+\n+(define_insn \"fcmov<mode>_eq\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f, f\")\n+\t(if_then_else:ANYF (eq (match_operand:SI 1 \"register_operand\" \"f, f\")\n+\t\t\t       (const_int 0))\n+\t\t\t   (match_operand:ANYF 2 \"register_operand\" \"f, 0\")\n+\t\t\t   (match_operand:ANYF 3 \"register_operand\" \"0, f\")))]\n+  \"\"\n+  \"@\n+   fcmovz<size>\\t%0,%2,%1\n+   fcmovn<size>\\t%0,%3,%1\"\n+  [(set_attr \"type\"  \"fcmov\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"fcmov<mode>_ne\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f, f\")\n+\t(if_then_else:ANYF (ne (match_operand:SI 1 \"register_operand\" \"f, f\")\n+\t\t\t       (const_int 0))\n+\t\t\t   (match_operand:ANYF 2 \"register_operand\" \"f, 0\")\n+\t\t\t   (match_operand:ANYF 3 \"register_operand\" \"0, f\")))]\n+  \"\"\n+  \"@\n+   fcmovn<size>\\t%0,%2,%1\n+   fcmovz<size>\\t%0,%3,%1\"\n+  [(set_attr \"type\"  \"fcmov\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+;; Arithmetic instructions.\n+\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(plus:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fadd<size>\\t %0, %1, %2\"\n+  [(set_attr \"type\"   \"falu\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(minus:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsub<size>\\t %0, %1, %2\"\n+  [(set_attr \"type\"   \"falu\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+;; Multiplication insns.\n+\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(mult:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fmul<size>\\t %0, %1, %2\"\n+  [(set_attr \"type\"   \"fmul<size>\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"fma<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(fma:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:ANYF 2 \"register_operand\" \"f\")\n+\t\t  (match_operand:ANYF 3 \"register_operand\" \"0\")))]\n+  \"TARGET_EXT_FPU_FMA\"\n+  \"fmadd<size>\\t%0, %1, %2\"\n+  [(set_attr \"type\"   \"fmac<size>\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"fnma<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(fma:ANYF (neg:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\"))\n+\t\t  (match_operand:ANYF 2 \"register_operand\" \"f\")\n+\t\t  (match_operand:ANYF 3 \"register_operand\" \"0\")))]\n+  \"TARGET_EXT_FPU_FMA\"\n+  \"fmsub<size>\\t%0, %1, %2\"\n+  [(set_attr \"type\"   \"fmac<size>\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"fms<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(fma:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:ANYF 2 \"register_operand\" \"f\")\n+\t\t  (neg:ANYF (match_operand:ANYF 3 \"register_operand\" \"0\"))))]\n+  \"TARGET_EXT_FPU_FMA\"\n+  \"fnmsub<size>\\t%0, %1, %2\"\n+  [(set_attr \"type\"   \"fmac<size>\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"fnms<mode>4\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(fma:ANYF (neg:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\"))\n+\t\t  (match_operand:ANYF 2 \"register_operand\" \"f\")\n+\t\t  (neg:ANYF (match_operand:ANYF 3 \"register_operand\" \"0\"))))]\n+  \"TARGET_EXT_FPU_FMA\"\n+  \"fnmadd<size>\\t%0, %1, %2\"\n+  [(set_attr \"type\"   \"fmac<size>\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+;; Div Instructions.\n+\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(div:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fdiv<size>\\t %0, %1, %2\"\n+  [(set_attr \"type\"   \"fdiv<size>\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"sqrt<mode>2\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(sqrt:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsqrt<size>\\t %0, %1\"\n+  [(set_attr \"type\"   \"fsqrt<size>\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+;; Conditional Branch patterns\n+\n+(define_expand \"cstore<mode>4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operator:SI 1 \"nds32_float_comparison_operator\"\n+\t [(match_operand:ANYF 2 \"register_operand\" \"\")\n+\t  (match_operand:ANYF 3 \"register_operand\" \"\")]))]\n+  \"\"\n+{\n+  nds32_expand_float_cstore (operands);\n+  DONE;\n+})\n+\n+(define_expand \"cbranch<mode>4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"nds32_float_comparison_operator\"\n+\t\t       [(match_operand:ANYF 1 \"register_operand\" \"\")\n+\t\t\t(match_operand:ANYF 2 \"register_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+{\n+  nds32_expand_float_cbranch (operands);\n+  DONE;\n+})\n+\n+;; Copysign Instructions.\n+\n+(define_insn \"copysignsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:SF 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_COPYSIGN))]\n+  \"TARGET_FPU_SINGLE\"\n+  \"fcpyss\\t%0,%1,%2\"\n+  [(set_attr \"type\"   \"fcpy\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"copysigndf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:DF 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_COPYSIGN))]\n+  \"TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE\"\n+  \"fcpysd\\t%0,%1,%2\"\n+  [(set_attr \"type\"   \"fcpy\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"*ncopysign<mode>3\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(neg:ANYF (unspec:ANYF [(match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t\t\t(match_operand:ANYF 2 \"register_operand\" \"f\")]\n+\t\t\t\tUNSPEC_COPYSIGN)))]\n+  \"\"\n+  \"fcpyns<size>\\t%0,%1,%2\"\n+  [(set_attr \"type\"   \"fcpy\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+;; Absolute Instructions\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f, r\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"f, r\")))]\n+  \"TARGET_FPU_SINGLE || TARGET_EXT_PERF\"\n+  \"@\n+   fabss\\t%0, %1\n+   bclr\\t%0, %1, 31\"\n+  [(set_attr \"type\"    \"fabs,alu\")\n+   (set_attr \"length\"  \"4\")\n+   (set_attr \"feature\" \"fpu,pe1\")]\n+)\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(abs:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU_DOUBLE\"\n+  \"fabsd\\t%0, %1\"\n+  [(set_attr \"type\"   \"fabs\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+;; Negation Instructions\n+\n+(define_insn \"*negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f, r\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"f, r\")))]\n+  \"TARGET_FPU_SINGLE || TARGET_EXT_PERF\"\n+  \"@\n+   fcpynss\\t%0, %1, %1\n+   btgl\\t%0, %1, 31\"\n+  [(set_attr \"type\"    \"fcpy,alu\")\n+   (set_attr \"length\"  \"4\")\n+   (set_attr \"feature\" \"fpu,pe1\")]\n+)\n+\n+(define_insn \"*negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU_DOUBLE\"\n+  \"fcpynsd\\t%0, %1, %1\"\n+  [(set_attr \"type\"   \"fcpy\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+;; Data Format Conversion Instructions\n+\n+(define_insn \"floatunssi<mode>2\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(unsigned_float:ANYF (match_operand:SI 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fui2<size>\\t %0, %1\"\n+  [(set_attr \"type\"   \"falu\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"floatsi<mode>2\"\n+  [(set (match_operand:ANYF 0 \"register_operand\" \"=f\")\n+\t(float:ANYF (match_operand:SI 1 \"register_operand\" \"f\")))]\n+  \"\"\n+  \"fsi2<size>\\t %0, %1\"\n+  [(set_attr \"type\"   \"falu\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"fixuns_trunc<mode>si2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(unsigned_fix:SI (fix:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\"))))]\n+  \"\"\n+  \"f<size>2ui.z\\t %0, %1\"\n+  [(set_attr \"type\"   \"falu\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"fix_trunc<mode>si2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(fix:SI (fix:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\"))))]\n+  \"\"\n+  \"f<size>2si.z\\t %0, %1\"\n+  [(set_attr \"type\"   \"falu\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU_SINGLE && TARGET_FPU_DOUBLE\"\n+  \"fs2d\\t%0, %1\"\n+  [(set_attr \"type\"   \"falu\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_FPU_SINGLE && TARGET_FPU_DOUBLE\"\n+  \"fd2s\\t%0, %1\"\n+  [(set_attr \"type\"   \"falu\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+;; Compare Instructions\n+\n+(define_insn \"cmp<mode>_eq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(eq:SI (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t       (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+  {\n+    if (NDS32_EXT_FPU_DOT_E)\n+      return \"fcmpeq<size>.e %0, %1, %2\";\n+    else\n+      return \"fcmpeq<size>\\t%0, %1, %2\";\n+  }\n+  [(set_attr \"type\"   \"fcmp\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"cmp<mode>_lt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(lt:SI (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t       (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+{\n+  if (NDS32_EXT_FPU_DOT_E)\n+    return \"fcmplt<size>.e %0, %1, %2\";\n+  else\n+    return \"fcmplt<size>\\t%0, %1, %2\";\n+}\n+  [(set_attr \"type\"   \"fcmp\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"cmp<mode>_le\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(le:SI (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t       (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+{\n+  if (NDS32_EXT_FPU_DOT_E)\n+    return \"fcmple<size>.e %0, %1, %2\";\n+  else\n+    return \"fcmple<size>\\t%0, %1, %2\";\n+}\n+  [(set_attr \"type\"   \"fcmp\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"cmp<mode>_un\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=f\")\n+\t(unordered:SI (match_operand:ANYF 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:ANYF 2 \"register_operand\" \"f\")))]\n+  \"\"\n+{\n+  if (NDS32_EXT_FPU_DOT_E)\n+    return \"fcmpun<size>.e %0, %1, %2\";\n+  else\n+    return \"fcmpun<size>\\t%0, %1, %2\";\n+}\n+  [(set_attr \"type\"   \"fcmp\")\n+   (set_attr \"length\" \"4\")]\n+)\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(match_operand:SF 1 \"register_operand\" \"\"))]\n+  \"!TARGET_FPU_SINGLE\n+   && NDS32_IS_FPR_REGNUM (REGNO (operands[0]))\n+   && NDS32_IS_FPR_REGNUM (REGNO (operands[1]))\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (match_dup 2))]\n+{\n+  operands[2] = gen_rtx_REG (SFmode, TA_REGNUM);\n+})\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n+  \"!satisfies_constraint_Cs20 (operands[1])\n+   && !satisfies_constraint_Chig (operands[1])\"\n+  [(set (match_dup 0) (high:SF (match_dup 1)))\n+   (set (match_dup 0) (lo_sum:SF (match_dup 0) (match_dup 1)))])\n+;; ----------------------------------------------------------------------------"}, {"sha": "dca1c9f959bbbddc821e858081981cc3bb0adc61", "filename": "gcc/config/nds32/nds32-md-auxiliary.c", "status": "modified", "additions": 677, "deletions": 7, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-md-auxiliary.c?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -742,6 +742,146 @@ nds32_expand_cstore (rtx *operands)\n     }\n }\n \n+void\n+nds32_expand_float_cbranch (rtx *operands)\n+{\n+  enum rtx_code code = GET_CODE (operands[0]);\n+  enum rtx_code new_code = code;\n+  rtx cmp_op0 = operands[1];\n+  rtx cmp_op1 = operands[2];\n+  rtx tmp_reg;\n+  rtx tmp;\n+\n+  int reverse = 0;\n+\n+  /* Main Goal: Use compare instruction + branch instruction.\n+\n+     For example:\n+     GT, GE: swap condition and swap operands and generate\n+     compare instruction(LT, LE) + branch not equal instruction.\n+\n+     UNORDERED, LT, LE, EQ: no need to change and generate\n+     compare instruction(UNORDERED, LT, LE, EQ) + branch not equal instruction.\n+\n+     ORDERED, NE: reverse condition and generate\n+     compare instruction(EQ) + branch equal instruction. */\n+\n+  switch (code)\n+    {\n+    case GT:\n+    case GE:\n+      tmp = cmp_op0;\n+      cmp_op0 = cmp_op1;\n+      cmp_op1 = tmp;\n+      new_code = swap_condition (new_code);\n+      break;\n+    case UNORDERED:\n+    case LT:\n+    case LE:\n+    case EQ:\n+      break;\n+    case ORDERED:\n+    case NE:\n+      new_code = reverse_condition (new_code);\n+      reverse = 1;\n+      break;\n+    case UNGT:\n+    case UNGE:\n+      new_code = reverse_condition_maybe_unordered (new_code);\n+      reverse = 1;\n+      break;\n+    case UNLT:\n+    case UNLE:\n+      new_code = reverse_condition_maybe_unordered (new_code);\n+      tmp = cmp_op0;\n+      cmp_op0 = cmp_op1;\n+      cmp_op1 = tmp;\n+      new_code = swap_condition (new_code);\n+      reverse = 1;\n+      break;\n+    default:\n+      return;\n+    }\n+\n+  tmp_reg = gen_reg_rtx (SImode);\n+  emit_insn (gen_rtx_SET (tmp_reg,\n+\t\t\t  gen_rtx_fmt_ee (new_code, SImode,\n+\t\t\t\t\t  cmp_op0, cmp_op1)));\n+\n+  PUT_CODE (operands[0], reverse ? EQ : NE);\n+  emit_insn (gen_cbranchsi4 (operands[0], tmp_reg,\n+\t\t\t     const0_rtx, operands[3]));\n+}\n+\n+void\n+nds32_expand_float_cstore (rtx *operands)\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  enum rtx_code new_code = code;\n+  machine_mode mode = GET_MODE (operands[2]);\n+\n+  rtx cmp_op0 = operands[2];\n+  rtx cmp_op1 = operands[3];\n+  rtx tmp;\n+\n+  /* Main Goal: Use compare instruction to store value.\n+\n+     For example:\n+     GT, GE: swap condition and swap operands.\n+       reg_R = (reg_A >  reg_B) --> fcmplt reg_R, reg_B, reg_A\n+       reg_R = (reg_A >= reg_B) --> fcmple reg_R, reg_B, reg_A\n+\n+     LT, LE, EQ: no need to change, it is already LT, LE, EQ.\n+       reg_R = (reg_A <  reg_B) --> fcmplt reg_R, reg_A, reg_B\n+       reg_R = (reg_A <= reg_B) --> fcmple reg_R, reg_A, reg_B\n+       reg_R = (reg_A == reg_B) --> fcmpeq reg_R, reg_A, reg_B\n+\n+     ORDERED: reverse condition and using xor insturction to achieve 'ORDERED'.\n+       reg_R = (reg_A != reg_B) --> fcmpun reg_R, reg_A, reg_B\n+\t\t\t\t       xor reg_R, reg_R, const1_rtx\n+\n+     NE: reverse condition and using xor insturction to achieve 'NE'.\n+       reg_R = (reg_A != reg_B) --> fcmpeq reg_R, reg_A, reg_B\n+\t\t\t\t       xor reg_R, reg_R, const1_rtx */\n+  switch (code)\n+    {\n+    case GT:\n+    case GE:\n+      tmp = cmp_op0;\n+      cmp_op0 = cmp_op1;\n+      cmp_op1 =tmp;\n+      new_code = swap_condition (new_code);\n+      break;\n+    case UNORDERED:\n+    case LT:\n+    case LE:\n+    case EQ:\n+      break;\n+    case ORDERED:\n+      if (mode == SFmode)\n+\temit_insn (gen_cmpsf_un (operands[0], cmp_op0, cmp_op1));\n+      else\n+\temit_insn (gen_cmpdf_un (operands[0], cmp_op0, cmp_op1));\n+\n+      emit_insn (gen_xorsi3 (operands[0], operands[0], const1_rtx));\n+      return;\n+    case NE:\n+      if (mode == SFmode)\n+\temit_insn (gen_cmpsf_eq (operands[0], cmp_op0, cmp_op1));\n+      else\n+\temit_insn (gen_cmpdf_eq (operands[0], cmp_op0, cmp_op1));\n+\n+      emit_insn (gen_xorsi3 (operands[0], operands[0], const1_rtx));\n+      return;\n+    default:\n+      return;\n+    }\n+\n+  emit_insn (gen_rtx_SET (operands[0],\n+\t\t\t  gen_rtx_fmt_ee (new_code, SImode,\n+\t\t\t\t\t  cmp_op0, cmp_op1)));\n+}\n+\n enum nds32_expand_result_type\n nds32_expand_movcc (rtx *operands)\n {\n@@ -759,6 +899,11 @@ nds32_expand_movcc (rtx *operands)\n \t we have gcc generate original template rtx.  */\n       return EXPAND_CREATE_TEMPLATE;\n     }\n+  else if ((TARGET_FPU_SINGLE && cmp0_mode == SFmode)\n+\t   || (TARGET_FPU_DOUBLE && cmp0_mode == DFmode))\n+    {\n+      nds32_expand_float_movcc (operands);\n+    }\n   else\n     {\n       /* Since there is only 'slt'(Set when Less Than) instruction for\n@@ -849,6 +994,203 @@ nds32_expand_movcc (rtx *operands)\n   return EXPAND_CREATE_TEMPLATE;\n }\n \n+void\n+nds32_expand_float_movcc (rtx *operands)\n+{\n+  if ((GET_CODE (operands[1]) == EQ || GET_CODE (operands[1]) == NE)\n+      && GET_MODE (XEXP (operands[1], 0)) == SImode\n+      && XEXP (operands[1], 1) == const0_rtx)\n+    {\n+      /* If the operands[1] rtx is already (eq X 0) or (ne X 0),\n+\t we have gcc generate original template rtx.  */\n+      return;\n+    }\n+  else\n+    {\n+      enum rtx_code code = GET_CODE (operands[1]);\n+      enum rtx_code new_code = code;\n+      machine_mode cmp0_mode = GET_MODE (XEXP (operands[1], 0));\n+      machine_mode cmp1_mode = GET_MODE (XEXP (operands[1], 1));\n+      rtx cmp_op0 = XEXP (operands[1], 0);\n+      rtx cmp_op1 = XEXP (operands[1], 1);\n+      rtx tmp;\n+\n+      /* Compare instruction Operations: (cmp_op0 condition cmp_op1) ? 1 : 0,\n+\t when result is 1, and 'reverse' be set 1 for fcmovzs instructuin. */\n+      int reverse = 0;\n+\n+      /* Main Goal: Use cmpare instruction + conditional move instruction.\n+\t Strategy : swap condition and swap comparison operands.\n+\n+\t For example:\n+\t     a > b ? P : Q   (GT)\n+\t --> a < b ? Q : P   (swap condition)\n+\t --> b < a ? Q : P   (swap comparison operands to achieve 'GT')\n+\n+\t     a >= b ? P : Q  (GE)\n+\t --> a <= b ? Q : P  (swap condition)\n+\t --> b <= a ? Q : P  (swap comparison operands to achieve 'GE')\n+\n+\t     a <  b ? P : Q  (LT)\n+\t --> (NO NEED TO CHANGE, it is already 'LT')\n+\n+\t     a >= b ? P : Q  (LE)\n+\t --> (NO NEED TO CHANGE, it is already 'LE')\n+\n+\t     a == b ? P : Q  (EQ)\n+\t --> (NO NEED TO CHANGE, it is already 'EQ') */\n+\n+      switch (code)\n+\t{\n+\tcase GT:\n+\tcase GE:\n+\t  tmp = cmp_op0;\n+\t  cmp_op0 = cmp_op1;\n+\t  cmp_op1 =tmp;\n+\t  new_code = swap_condition (new_code);\n+\t  break;\n+\tcase UNORDERED:\n+\tcase LT:\n+\tcase LE:\n+\tcase EQ:\n+\t  break;\n+\tcase ORDERED:\n+\tcase NE:\n+\t  reverse = 1;\n+\t  new_code = reverse_condition (new_code);\n+\t  break;\n+\tcase UNGT:\n+\tcase UNGE:\n+\t  new_code = reverse_condition_maybe_unordered (new_code);\n+\t  reverse = 1;\n+\t  break;\n+\tcase UNLT:\n+\tcase UNLE:\n+\t  new_code = reverse_condition_maybe_unordered (new_code);\n+\t  tmp = cmp_op0;\n+\t  cmp_op0 = cmp_op1;\n+\t  cmp_op1 = tmp;\n+\t  new_code = swap_condition (new_code);\n+\t  reverse = 1;\n+\t  break;\n+\tdefault:\n+\t  return;\n+\t}\n+\n+      /* Use a temporary register to store fcmpxxs result.  */\n+      tmp = gen_reg_rtx (SImode);\n+\n+      /* Create float compare instruction for SFmode and DFmode,\n+\t other MODE using cstoresi create compare instruction. */\n+      if ((cmp0_mode == DFmode || cmp0_mode == SFmode)\n+\t  && (cmp1_mode == DFmode || cmp1_mode == SFmode))\n+\t{\n+\t  /* This emit_insn create corresponding float compare instruction */\n+\t  emit_insn (gen_rtx_SET (tmp,\n+\t\t\t\t  gen_rtx_fmt_ee (new_code, SImode,\n+\t\t\t\t\t\t  cmp_op0, cmp_op1)));\n+\t}\n+      else\n+\t{\n+\t  /* This emit_insn using cstoresi create corresponding\n+\t     compare instruction */\n+\t  PUT_CODE (operands[1], new_code);\n+\t  emit_insn (gen_cstoresi4 (tmp, operands[1],\n+\t\t\t\t    cmp_op0, cmp_op1));\n+\t}\n+      /* operands[1] crete corresponding condition move instruction\n+\t for fcmovzs and fcmovns.  */\n+      operands[1] = gen_rtx_fmt_ee (reverse ? EQ : NE,\n+\t\t\t\t    VOIDmode, tmp, const0_rtx);\n+    }\n+}\n+\n+void\n+nds32_emit_push_fpr_callee_saved (int base_offset)\n+{\n+  rtx fpu_insn;\n+  rtx reg, mem;\n+  unsigned int regno = cfun->machine->callee_saved_first_fpr_regno;\n+  unsigned int last_fpr = cfun->machine->callee_saved_last_fpr_regno;\n+\n+  while (regno <= last_fpr)\n+    {\n+      /* Handling two registers, using fsdi instruction.  */\n+      reg = gen_rtx_REG (DFmode, regno);\n+      mem = gen_frame_mem (DFmode, plus_constant (Pmode,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  base_offset));\n+      base_offset += 8;\n+      regno += 2;\n+      fpu_insn = emit_move_insn (mem, reg);\n+      RTX_FRAME_RELATED_P (fpu_insn) = 1;\n+    }\n+}\n+\n+void\n+nds32_emit_pop_fpr_callee_saved (int gpr_padding_size)\n+{\n+  rtx fpu_insn;\n+  rtx reg, mem, addr;\n+  rtx dwarf, adjust_sp_rtx;\n+  unsigned int regno = cfun->machine->callee_saved_first_fpr_regno;\n+  unsigned int last_fpr = cfun->machine->callee_saved_last_fpr_regno;\n+  int padding = 0;\n+\n+  while (regno <= last_fpr)\n+    {\n+      /* Handling two registers, using fldi.bi instruction.  */\n+      if ((regno + 1) >= last_fpr)\n+\tpadding = gpr_padding_size;\n+\n+      reg = gen_rtx_REG (DFmode, (regno));\n+      addr = gen_rtx_POST_MODIFY (Pmode, stack_pointer_rtx,\n+\t\t\t\t  gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\tGEN_INT (8 + padding)));\n+      mem = gen_frame_mem (DFmode, addr);\n+      regno += 2;\n+      fpu_insn = emit_move_insn (reg, mem);\n+\n+      adjust_sp_rtx =\n+\tgen_rtx_SET (stack_pointer_rtx,\n+\t\t     plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t    8 + padding));\n+\n+      dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, NULL_RTX);\n+      /* Tell gcc we adjust SP in this insn.  */\n+      dwarf = alloc_reg_note (REG_CFA_ADJUST_CFA, copy_rtx (adjust_sp_rtx),\n+\t\t\t      dwarf);\n+      RTX_FRAME_RELATED_P (fpu_insn) = 1;\n+      REG_NOTES (fpu_insn) = dwarf;\n+    }\n+}\n+\n+void\n+nds32_emit_v3pop_fpr_callee_saved (int base)\n+{\n+  int fpu_base_addr = base;\n+  int regno;\n+  rtx fpu_insn;\n+  rtx reg, mem;\n+  rtx dwarf;\n+\n+  regno = cfun->machine->callee_saved_first_fpr_regno;\n+  while (regno <= cfun->machine->callee_saved_last_fpr_regno)\n+    {\n+      /* Handling two registers, using fldi instruction.  */\n+      reg = gen_rtx_REG (DFmode, regno);\n+      mem = gen_frame_mem (DFmode, plus_constant (Pmode,\n+\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t  fpu_base_addr));\n+      fpu_base_addr += 8;\n+      regno += 2;\n+      fpu_insn = emit_move_insn (reg, mem);\n+      dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, NULL_RTX);\n+      RTX_FRAME_RELATED_P (fpu_insn) = 1;\n+      REG_NOTES (fpu_insn) = dwarf;\n+    }\n+}\n+\n /* ------------------------------------------------------------------------ */\n \n /* Function to return memory format.  */\n@@ -867,15 +1209,17 @@ nds32_mem_format (rtx op)\n   op = XEXP (op, 0);\n \n   /* 45 format.  */\n-  if (GET_CODE (op) == REG && (mode_test == SImode))\n+  if (GET_CODE (op) == REG\n+      && ((mode_test == SImode) || (mode_test == SFmode)))\n     return ADDRESS_REG;\n \n   /* 333 format for QI/HImode.  */\n   if (GET_CODE (op) == REG && (REGNO (op) < R8_REGNUM))\n     return ADDRESS_LO_REG_IMM3U;\n \n   /* post_inc 333 format.  */\n-  if ((GET_CODE (op) == POST_INC) && (mode_test == SImode))\n+  if ((GET_CODE (op) == POST_INC)\n+      && ((mode_test == SImode) || (mode_test == SFmode)))\n     {\n       regno = REGNO(XEXP (op, 0));\n \n@@ -885,7 +1229,7 @@ nds32_mem_format (rtx op)\n \n   /* post_inc 333 format.  */\n   if ((GET_CODE (op) == POST_MODIFY)\n-      && (mode_test == SImode)\n+      && ((mode_test == SImode) || (mode_test == SFmode))\n       && (REG_P (XEXP (XEXP (op, 1), 0)))\n       && (CONST_INT_P (XEXP (XEXP (op, 1), 1))))\n     {\n@@ -1409,12 +1753,25 @@ nds32_output_stack_push (rtx par_rtx)\n \t otherwise, generate 'push25 Re,0'.  */\n       sp_adjust = cfun->machine->local_size\n \t\t  + cfun->machine->out_args_size\n-\t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes;\n+\t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t  + cfun->machine->callee_saved_fpr_regs_size;\n       if (satisfies_constraint_Iu08 (GEN_INT (sp_adjust))\n \t  && NDS32_DOUBLE_WORD_ALIGN_P (sp_adjust))\n \toperands[1] = GEN_INT (sp_adjust);\n       else\n-\toperands[1] = GEN_INT (0);\n+\t{\n+\t  /* Allocate callee saved fpr space.  */\n+\t  if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t    {\n+\t      sp_adjust = cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t\t  + cfun->machine->callee_saved_fpr_regs_size;\n+\t      operands[1] = GEN_INT (sp_adjust);\n+\t    }\n+\t  else\n+\t    {\n+\t      operands[1] = GEN_INT (0);\n+\t    }\n+\t}\n \n       /* Create assembly code pattern.  */\n       snprintf (pattern, sizeof (pattern), \"push25\\t%%0, %%1\");\n@@ -1507,13 +1864,28 @@ nds32_output_stack_pop (rtx par_rtx ATTRIBUTE_UNUSED)\n \t and then use 'pop25 Re,0'.  */\n       sp_adjust = cfun->machine->local_size\n \t\t  + cfun->machine->out_args_size\n-\t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes;\n+\t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t  + cfun->machine->callee_saved_fpr_regs_size;\n       if (satisfies_constraint_Iu08 (GEN_INT (sp_adjust))\n \t  && NDS32_DOUBLE_WORD_ALIGN_P (sp_adjust)\n \t  && !cfun->calls_alloca)\n \toperands[1] = GEN_INT (sp_adjust);\n       else\n-\toperands[1] = GEN_INT (0);\n+\t{\n+\t  if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t    {\n+\t      /* If has fpr need to restore, the $sp on callee saved fpr\n+\t\t position, so we need to consider gpr pading bytes and\n+\t\t callee saved fpr size.  */\n+\t      sp_adjust = cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t\t  + cfun->machine->callee_saved_fpr_regs_size;\n+\t      operands[1] = GEN_INT (sp_adjust);\n+\t    }\n+\t  else\n+\t    {\n+\t      operands[1] = GEN_INT (0);\n+\t    }\n+\t}\n \n       /* Create assembly code pattern.  */\n       snprintf (pattern, sizeof (pattern), \"pop25\\t%%0, %%1\");\n@@ -1638,6 +2010,162 @@ nds32_output_casesi_pc_relative (rtx *operands)\n     return \"jr\\t$ta\";\n }\n \n+/* output a float load instruction */\n+const char *\n+nds32_output_float_load (rtx *operands)\n+{\n+  char buff[100];\n+  const char *pattern;\n+  rtx addr, addr_op0, addr_op1;\n+  int dp = GET_MODE_SIZE (GET_MODE (operands[0])) == 8;\n+  addr = XEXP (operands[1], 0);\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      pattern = \"fl%ci\\t%%0, %%1\";\n+      break;\n+\n+    case PLUS:\n+      addr_op0 = XEXP (addr, 0);\n+      addr_op1 = XEXP (addr, 1);\n+\n+      if (REG_P (addr_op0) && REG_P (addr_op1))\n+\tpattern = \"fl%c\\t%%0, %%1\";\n+      else if (REG_P (addr_op0) && CONST_INT_P (addr_op1))\n+\tpattern = \"fl%ci\\t%%0, %%1\";\n+      else if (GET_CODE (addr_op0) == MULT && REG_P (addr_op1)\n+\t       && REG_P (XEXP (addr_op0, 0))\n+\t       && CONST_INT_P (XEXP (addr_op0, 1)))\n+\tpattern = \"fl%c\\t%%0, %%1\";\n+      else\n+\tgcc_unreachable ();\n+      break;\n+\n+    case POST_MODIFY:\n+      addr_op0 = XEXP (addr, 0);\n+      addr_op1 = XEXP (addr, 1);\n+\n+      if (REG_P (addr_op0) && GET_CODE (addr_op1) == PLUS\n+\t  && REG_P (XEXP (addr_op1, 1)))\n+\tpattern = \"fl%c.bi\\t%%0, %%1\";\n+      else if (REG_P (addr_op0) && GET_CODE (addr_op1) == PLUS\n+\t       && CONST_INT_P (XEXP (addr_op1, 1)))\n+\tpattern = \"fl%ci.bi\\t%%0, %%1\";\n+      else\n+\tgcc_unreachable ();\n+      break;\n+\n+    case POST_INC:\n+      if (REG_P (XEXP (addr, 0)))\n+\t{\n+\t  if (dp)\n+\t    pattern = \"fl%ci.bi\\t%%0, %%1, 8\";\n+\t  else\n+\t    pattern = \"fl%ci.bi\\t%%0, %%1, 4\";\n+\t}\n+      else\n+\tgcc_unreachable ();\n+      break;\n+\n+    case POST_DEC:\n+      if (REG_P (XEXP (addr, 0)))\n+\t{\n+\t  if (dp)\n+\t    pattern = \"fl%ci.bi\\t%%0, %%1, -8\";\n+\t  else\n+\t    pattern = \"fl%ci.bi\\t%%0, %%1, -4\";\n+\t}\n+      else\n+\tgcc_unreachable ();\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  sprintf (buff, pattern, dp ? 'd' : 's');\n+  output_asm_insn (buff, operands);\n+  return \"\";\n+}\n+\n+/* output a float store instruction */\n+const char *\n+nds32_output_float_store (rtx *operands)\n+{\n+  char buff[100];\n+  const char *pattern;\n+  rtx addr, addr_op0, addr_op1;\n+  int dp = GET_MODE_SIZE (GET_MODE (operands[0])) == 8;\n+  addr = XEXP (operands[0], 0);\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      pattern = \"fs%ci\\t%%1, %%0\";\n+      break;\n+\n+    case PLUS:\n+      addr_op0 = XEXP (addr, 0);\n+      addr_op1 = XEXP (addr, 1);\n+\n+      if (REG_P (addr_op0) && REG_P (addr_op1))\n+\tpattern = \"fs%c\\t%%1, %%0\";\n+      else if (REG_P (addr_op0) && CONST_INT_P (addr_op1))\n+\tpattern = \"fs%ci\\t%%1, %%0\";\n+      else if (GET_CODE (addr_op0) == MULT && REG_P (addr_op1)\n+\t       && REG_P (XEXP (addr_op0, 0))\n+\t       && CONST_INT_P (XEXP (addr_op0, 1)))\n+\tpattern = \"fs%c\\t%%1, %%0\";\n+      else\n+\tgcc_unreachable ();\n+      break;\n+\n+    case POST_MODIFY:\n+      addr_op0 = XEXP (addr, 0);\n+      addr_op1 = XEXP (addr, 1);\n+\n+      if (REG_P (addr_op0) && GET_CODE (addr_op1) == PLUS\n+\t  && REG_P (XEXP (addr_op1, 1)))\n+\tpattern = \"fs%c.bi\\t%%1, %%0\";\n+      else if (REG_P (addr_op0) && GET_CODE (addr_op1) == PLUS\n+\t       && CONST_INT_P (XEXP (addr_op1, 1)))\n+\tpattern = \"fs%ci.bi\\t%%1, %%0\";\n+      else\n+\tgcc_unreachable ();\n+      break;\n+\n+    case POST_INC:\n+      if (REG_P (XEXP (addr, 0)))\n+\t{\n+\t  if (dp)\n+\t    pattern = \"fs%ci.bi\\t%%1, %%0, 8\";\n+\t  else\n+\t    pattern = \"fs%ci.bi\\t%%1, %%0, 4\";\n+\t}\n+      else\n+\tgcc_unreachable ();\n+      break;\n+\n+    case POST_DEC:\n+      if (REG_P (XEXP (addr, 0)))\n+\t{\n+\t  if (dp)\n+\t    pattern = \"fs%ci.bi\\t%%1, %%0, -8\";\n+\t  else\n+\t    pattern = \"fs%ci.bi\\t%%1, %%0, -4\";\n+\t}\n+      else\n+\tgcc_unreachable ();\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  sprintf (buff, pattern, dp ? 'd' : 's');\n+  output_asm_insn (buff, operands);\n+  return \"\";\n+}\n+\n /* Function to generate normal jump table.  */\n const char *\n nds32_output_casesi (rtx *operands)\n@@ -1936,6 +2464,39 @@ nds32_expand_unaligned_store (rtx *operands, enum machine_mode mode)\n     }\n }\n \n+/* Using multiple load/store instruction to output doubleword instruction.  */\n+const char *\n+nds32_output_double (rtx *operands, bool load_p)\n+{\n+  char pattern[100];\n+  int reg = load_p ? 0 : 1;\n+  int mem = load_p ? 1 : 0;\n+  rtx otherops[3];\n+  rtx addr = XEXP (operands[mem], 0);\n+\n+  otherops[0] = gen_rtx_REG (SImode, REGNO (operands[reg]));\n+  otherops[1] = gen_rtx_REG (SImode, REGNO (operands[reg]) + 1);\n+\n+  if (GET_CODE (addr)  == POST_INC)\n+    {\n+      /* (mem (post_inc (reg))) */\n+      otherops[2] = XEXP (addr, 0);\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"%cmw.bim\\t%%0, [%%2], %%1, 0\", load_p ? 'l' : 's');\n+    }\n+  else\n+    {\n+      /* (mem (reg)) */\n+      otherops[2] = addr;\n+      snprintf (pattern, sizeof (pattern),\n+\t\t\"%cmw.bi\\t%%0, [%%2], %%1, 0\", load_p ? 'l' : 's');\n+\n+    }\n+\n+  output_asm_insn (pattern, otherops);\n+  return \"\";\n+}\n+\n const char *\n nds32_output_cbranchsi4_equality_zero (rtx_insn *insn, rtx *operands)\n {\n@@ -2120,6 +2681,115 @@ nds32_output_cbranchsi4_greater_less_zero (rtx_insn *insn, rtx *operands)\n   return \"\";\n }\n \n+/* Spilt a doubleword instrucion to two single word instructions.  */\n+void\n+nds32_spilt_doubleword (rtx *operands, bool load_p)\n+{\n+  int reg = load_p ? 0 : 1;\n+  int mem = load_p ? 1 : 0;\n+  rtx reg_rtx = load_p ? operands[0] : operands[1];\n+  rtx mem_rtx = load_p ? operands[1] : operands[0];\n+  rtx low_part[2], high_part[2];\n+  rtx sub_mem = XEXP (mem_rtx, 0);\n+\n+  /* Generate low_part and high_part register pattern.\n+     i.e. register pattern like:\n+     (reg:DI) -> (subreg:SI (reg:DI))\n+\t\t (subreg:SI (reg:DI)) */\n+  low_part[reg] = simplify_gen_subreg (SImode, reg_rtx, GET_MODE (reg_rtx), 0);\n+  high_part[reg] = simplify_gen_subreg (SImode, reg_rtx, GET_MODE (reg_rtx), 4);\n+\n+  /* Generate low_part and high_part memory pattern.\n+     Memory format is (post_dec) will generate:\n+       low_part:  lwi.bi reg, [mem], 4\n+       high_part: lwi.bi reg, [mem], -12 */\n+  if (GET_CODE (sub_mem) == POST_DEC)\n+    {\n+      /* memory format is (post_dec (reg)),\n+\t so that extract (reg) from the (post_dec (reg)) pattern.  */\n+      sub_mem = XEXP (sub_mem, 0);\n+\n+      /* generate low_part and high_part memory format:\n+\t   low_part:  (post_modify ((reg) (plus (reg) (const 4)))\n+\t   high_part: (post_modify ((reg) (plus (reg) (const -12))) */\n+      low_part[mem] = gen_frame_mem (SImode,\n+\t\t\t\t     gen_rtx_POST_MODIFY (Pmode, sub_mem,\n+\t\t\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t  sub_mem,\n+\t\t\t\t\t\t\t  GEN_INT (4))));\n+      high_part[mem] = gen_frame_mem (SImode,\n+\t\t\t\t      gen_rtx_POST_MODIFY (Pmode, sub_mem,\n+\t\t\t\t\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t   sub_mem,\n+\t\t\t\t\t\t\t   GEN_INT (-12))));\n+    }\n+  else if (GET_CODE (sub_mem) == POST_MODIFY)\n+    {\n+      /* Memory format is (post_modify (reg) (plus (reg) (const))),\n+\t so that extract (reg) from the post_modify pattern.  */\n+      rtx post_mem = XEXP (sub_mem, 0);\n+\n+      /* Extract (const) from the (post_modify (reg) (plus (reg) (const)))\n+\t pattern.  */\n+\n+      rtx plus_op = XEXP (sub_mem, 1);\n+      rtx post_val = XEXP (plus_op, 1);\n+\n+      /* Generate low_part and high_part memory format:\n+\t   low_part:  (post_modify ((reg) (plus (reg) (const)))\n+\t   high_part: ((plus (reg) (const 4))) */\n+      low_part[mem] = gen_frame_mem (SImode,\n+\t\t\t\t     gen_rtx_POST_MODIFY (Pmode, post_mem,\n+\t\t\t\t\t\t\t  gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t  post_mem,\n+\t\t\t\t\t\t\t  post_val)));\n+      high_part[mem] = gen_frame_mem (SImode, plus_constant (Pmode,\n+\t\t\t\t\t\t\t     post_mem,\n+\t\t\t\t\t\t\t     4));\n+    }\n+  else\n+    {\n+      /* memory format: (symbol_ref), (const), (reg + const_int).  */\n+      low_part[mem] = adjust_address (mem_rtx, SImode, 0);\n+      high_part[mem] = adjust_address (mem_rtx, SImode, 4);\n+    }\n+\n+  /* After reload completed, we have dependent issue by low part register and\n+     higt part memory. i.e. we cannot split a sequence\n+     like:\n+\tload $r0, [%r1]\n+     spilt to\n+\tlw  $r0, [%r0]\n+\tlwi $r1, [%r0 + 4]\n+     swap position\n+\tlwi $r1, [%r0 + 4]\n+\tlw  $r0, [%r0]\n+     For store instruction we don't have a problem.\n+\n+     When memory format is [post_modify], we need to emit high part instruction,\n+     before low part instruction.\n+     expamle:\n+       load $r0, [%r2], post_val\n+     spilt to\n+       load $r1, [%r2 + 4]\n+       load $r0, [$r2], post_val.  */\n+  if ((load_p && reg_overlap_mentioned_p (low_part[0], high_part[1]))\n+      || GET_CODE (sub_mem) == POST_MODIFY)\n+    {\n+      operands[2] = high_part[0];\n+      operands[3] = high_part[1];\n+      operands[4] = low_part[0];\n+      operands[5] = low_part[1];\n+    }\n+  else\n+    {\n+      operands[2] = low_part[0];\n+      operands[3] = low_part[1];\n+      operands[4] = high_part[0];\n+      operands[5] = high_part[1];\n+    }\n+}\n+\n /* Return true X is need use long call.  */\n bool\n nds32_long_call_p (rtx symbol)"}, {"sha": "642ec2867c532114c9b4d9539109715e2dc7cb5a", "filename": "gcc/config/nds32/nds32-opts.h", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -29,7 +29,9 @@ enum nds32_arch_type\n {\n   ARCH_V2,\n   ARCH_V3,\n-  ARCH_V3M\n+  ARCH_V3M,\n+  ARCH_V3F,\n+  ARCH_V3S\n };\n \n /* The code model defines the address generation strategy.  */\n@@ -46,4 +48,24 @@ enum nds32_cpu_type\n   CPU_N9\n };\n \n+/* Which ABI to use.  */\n+enum abi_type\n+{\n+  NDS32_ABI_V2,\n+  NDS32_ABI_V2_FP_PLUS\n+};\n+\n+/* The various FPU number of registers.  */\n+enum float_reg_number\n+{\n+  NDS32_CONFIG_FPU_0,\n+  NDS32_CONFIG_FPU_1,\n+  NDS32_CONFIG_FPU_2,\n+  NDS32_CONFIG_FPU_3,\n+  NDS32_CONFIG_FPU_4,\n+  NDS32_CONFIG_FPU_5,\n+  NDS32_CONFIG_FPU_6,\n+  NDS32_CONFIG_FPU_7\n+};\n+\n #endif"}, {"sha": "5e01430c8e31d4775f8ee20e39ddc962e62bc29f", "filename": "gcc/config/nds32/nds32-predicates.c", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -448,4 +448,71 @@ nds32_symbol_load_store_p (rtx_insn *insn)\n \n   return false;\n }\n+\n+/* Vaild memory operand for floating-point loads and stores */\n+bool\n+nds32_float_mem_operand_p (rtx op)\n+{\n+  machine_mode mode = GET_MODE (op);\n+  rtx addr = XEXP (op, 0);\n+\n+  /* Not support [symbol] [const] memory */\n+  if (GET_CODE (addr) == SYMBOL_REF\n+      || GET_CODE (addr) == CONST\n+      || GET_CODE (addr) == LO_SUM)\n+    return false;\n+\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == SYMBOL_REF)\n+\treturn false;\n+\n+      /* Restrict const range: (imm12s << 2) */\n+      if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t{\n+\t  if ((mode == SImode || mode == SFmode)\n+\t      && NDS32_SINGLE_WORD_ALIGN_P (INTVAL (XEXP (addr, 1)))\n+\t      && !satisfies_constraint_Is14 ( XEXP(addr, 1)))\n+\t    return false;\n+\n+\t  if ((mode == DImode || mode == DFmode)\n+\t      && NDS32_DOUBLE_WORD_ALIGN_P (INTVAL (XEXP (addr, 1)))\n+\t      && !satisfies_constraint_Is14 (XEXP (addr, 1)))\n+\t    return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+int\n+nds32_cond_move_p (rtx cmp_rtx)\n+{\n+  machine_mode cmp0_mode = GET_MODE (XEXP (cmp_rtx, 0));\n+  machine_mode cmp1_mode = GET_MODE (XEXP (cmp_rtx, 1));\n+  enum rtx_code cond = GET_CODE (cmp_rtx);\n+\n+  if ((cmp0_mode == DFmode || cmp0_mode == SFmode)\n+      && (cmp1_mode == DFmode || cmp1_mode == SFmode)\n+      && (cond == ORDERED || cond == UNORDERED))\n+    return true;\n+  return false;\n+}\n+\n+bool\n+nds32_const_double_range_ok_p (rtx op, machine_mode mode,\n+\t\t\t       HOST_WIDE_INT lower, HOST_WIDE_INT upper)\n+{\n+  if (GET_CODE (op) != CONST_DOUBLE\n+      || GET_MODE (op) != mode)\n+    return false;\n+\n+  const REAL_VALUE_TYPE *rv;\n+  long val;\n+\n+  rv = CONST_DOUBLE_REAL_VALUE (op);\n+  REAL_VALUE_TO_TARGET_SINGLE (*rv, val);\n+\n+  return val >= lower && val < upper;\n+}\n /* ------------------------------------------------------------------------ */"}, {"sha": "aebec3b0b3472067d5099c87eda0186872466390", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -58,6 +58,13 @@ extern void nds32_expand_prologue (void);\n extern void nds32_expand_epilogue (bool);\n extern void nds32_expand_prologue_v3push (void);\n extern void nds32_expand_epilogue_v3pop (bool);\n+extern void nds32_emit_push_fpr_callee_saved (int);\n+extern void nds32_emit_pop_fpr_callee_saved (int);\n+extern void nds32_emit_v3pop_fpr_callee_saved (int);\n+\n+/* Controlling Debugging Information Format.  */\n+\n+extern unsigned int nds32_dbx_register_number (unsigned int);\n \n /* ------------------------------------------------------------------------ */\n \n@@ -101,6 +108,9 @@ extern int nds32_can_use_btgl_p (int);\n \n extern int nds32_can_use_bitci_p (int);\n \n+extern bool nds32_const_double_range_ok_p (rtx, machine_mode,\n+\t\t\t\t\t   HOST_WIDE_INT, HOST_WIDE_INT);\n+\n /* Auxiliary function for 'Computing the Length of an Insn'.  */\n \n extern int nds32_adjust_insn_length (rtx_insn *, int);\n@@ -120,28 +130,42 @@ extern const char *nds32_output_casesi (rtx *);\n \n extern enum nds32_expand_result_type nds32_expand_cbranch (rtx *);\n extern enum nds32_expand_result_type nds32_expand_cstore (rtx *);\n+extern void nds32_expand_float_cbranch (rtx *);\n+extern void nds32_expand_float_cstore (rtx *);\n \n /* Auxiliary functions for conditional move generation.  */\n \n extern enum nds32_expand_result_type nds32_expand_movcc (rtx *);\n+extern void nds32_expand_float_movcc (rtx *);\n \n \n /* Auxiliary functions to identify long-call symbol.  */\n extern bool nds32_long_call_p (rtx);\n \n+/* Auxiliary functions to identify conditional move comparison operand.  */\n+\n+extern int nds32_cond_move_p (rtx);\n+\n /* Auxiliary functions to identify 16 bit addresing mode.  */\n \n extern enum nds32_16bit_address_type nds32_mem_format (rtx);\n \n+/* Auxiliary functions to identify floating-point addresing mode.  */\n+\n+extern bool nds32_float_mem_operand_p (rtx);\n+\n /* Auxiliary functions to output assembly code.  */\n \n extern const char *nds32_output_16bit_store (rtx *, int);\n extern const char *nds32_output_16bit_load (rtx *, int);\n extern const char *nds32_output_32bit_store (rtx *, int);\n extern const char *nds32_output_32bit_load (rtx *, int);\n extern const char *nds32_output_32bit_load_s (rtx *, int);\n+extern const char *nds32_output_float_load(rtx *);\n+extern const char *nds32_output_float_store(rtx *);\n extern const char *nds32_output_smw_single_word (rtx *);\n extern const char *nds32_output_lmw_single_word (rtx *);\n+extern const char *nds32_output_double (rtx *, bool);\n extern const char *nds32_output_cbranchsi4_equality_zero (rtx_insn *, rtx *);\n extern const char *nds32_output_cbranchsi4_equality_reg (rtx_insn *, rtx *);\n extern const char *nds32_output_cbranchsi4_equality_reg_or_const_int (rtx_insn *,\n@@ -154,6 +178,10 @@ extern const char *nds32_output_cbranchsi4_greater_less_zero (rtx_insn *, rtx *)\n extern const char *nds32_output_stack_push (rtx);\n extern const char *nds32_output_stack_pop (rtx);\n \n+/* Auxiliary functions to split double word RTX pattern.  */\n+\n+extern void nds32_spilt_doubleword (rtx *, bool);\n+\n /* Auxiliary functions to split large constant RTX pattern.  */\n \n extern void nds32_expand_constant (machine_mode,\n@@ -190,6 +218,8 @@ extern int nds32_address_cost_impl (rtx, machine_mode, addr_space_t, bool);\n /* Auxiliary functions for pre-define marco.  */\n extern void nds32_cpu_cpp_builtins(struct cpp_reader *);\n \n+extern bool nds32_split_double_word_load_store_p (rtx *,bool);\n+\n /* Functions for create nds32 specific optimization pass.  */\n extern rtl_opt_pass *make_pass_nds32_relax_opt (gcc::context *);\n "}, {"sha": "1070b474d8f9a83175b05c88d6fdbc40d1513615", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 895, "deletions": 124, "changes": 1019, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -218,6 +218,10 @@ nds32_compute_stack_frame (void)\n   cfun->machine->callee_saved_gpr_regs_size = 0;\n   cfun->machine->callee_saved_first_gpr_regno = SP_REGNUM;\n   cfun->machine->callee_saved_last_gpr_regno  = SP_REGNUM;\n+  cfun->machine->callee_saved_fpr_regs_size = 0;\n+  cfun->machine->callee_saved_first_fpr_regno = SP_REGNUM;\n+  cfun->machine->callee_saved_last_fpr_regno  = SP_REGNUM;\n+\n   /* Currently, there is no need to check $r28~$r31\n      because we will save them in another way.  */\n   for (r = 0; r < 28; r++)\n@@ -235,6 +239,35 @@ nds32_compute_stack_frame (void)\n \t}\n     }\n \n+  /* Recording fpu callee-saved register.  */\n+  if (TARGET_HARD_FLOAT)\n+    {\n+      for (r = NDS32_FIRST_FPR_REGNUM; r < NDS32_LAST_FPR_REGNUM; r++)\n+\t{\n+\t  if (NDS32_REQUIRED_CALLEE_SAVED_P (r))\n+\t    {\n+\t      /* Mark the first required callee-saved register.  */\n+\t      if (cfun->machine->callee_saved_first_fpr_regno == SP_REGNUM)\n+\t\t{\n+\t\t  /* Make first callee-saved number is even,\n+\t\t     bacause we use doubleword access, and this way\n+\t\t     promise 8-byte alignemt.  */\n+\t\t  if (!NDS32_FPR_REGNO_OK_FOR_DOUBLE (r))\n+\t\t    cfun->machine->callee_saved_first_fpr_regno = r - 1;\n+\t\t  else\n+\t\t    cfun->machine->callee_saved_first_fpr_regno = r;\n+\t\t}\n+\t      cfun->machine->callee_saved_last_fpr_regno = r;\n+\t    }\n+\t}\n+\n+      /* Make last callee-saved register number is odd,\n+\t we hope callee-saved register is even.  */\n+      int last_fpr = cfun->machine->callee_saved_last_fpr_regno;\n+      if (NDS32_FPR_REGNO_OK_FOR_DOUBLE (last_fpr))\n+\tcfun->machine->callee_saved_last_fpr_regno++;\n+    }\n+\n   /* Check if this function can omit prologue/epilogue code fragment.\n      If there is 'naked' attribute in this function,\n      we can set 'naked_p' flag to indicate that\n@@ -252,6 +285,8 @@ nds32_compute_stack_frame (void)\n   if (lookup_attribute (\"naked\", DECL_ATTRIBUTES (current_function_decl))\n       || (cfun->machine->callee_saved_first_gpr_regno == SP_REGNUM\n \t  && cfun->machine->callee_saved_last_gpr_regno == SP_REGNUM\n+\t  && cfun->machine->callee_saved_first_fpr_regno == SP_REGNUM\n+\t  && cfun->machine->callee_saved_last_fpr_regno == SP_REGNUM\n \t  && !df_regs_ever_live_p (FP_REGNUM)\n \t  && !df_regs_ever_live_p (LP_REGNUM)\n \t  && cfun->machine->local_size == 0))\n@@ -340,7 +375,8 @@ nds32_compute_stack_frame (void)\n \n   int sp_adjust = cfun->machine->local_size\n \t\t  + cfun->machine->out_args_size\n-\t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes;\n+\t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t  + cfun->machine->callee_saved_fpr_regs_size;\n \n   if (!v3pushpop_p\n       && sp_adjust == 0\n@@ -385,6 +421,18 @@ nds32_compute_stack_frame (void)\n \t       + 1);\n     }\n \n+  if (TARGET_HARD_FLOAT)\n+    {\n+      /* Compute size of callee svaed floating-point registers.  */\n+      if (cfun->machine->callee_saved_last_fpr_regno != SP_REGNUM)\n+\t{\n+\t  cfun->machine->callee_saved_fpr_regs_size\n+\t   = 4 * (cfun->machine->callee_saved_last_fpr_regno\n+\t\t  - cfun->machine->callee_saved_first_fpr_regno\n+\t\t  + 1);\n+\t}\n+    }\n+\n   /* Important: We need to make sure that\n \t\t(fp_size + gp_size + lp_size + callee_saved_gpr_regs_size)\n \t\tis 8-byte alignment.\n@@ -1130,45 +1178,61 @@ nds32_legitimate_index_p (machine_mode outer_mode,\n \n     case CONST_INT:\n       /* The alignment of the integer value is determined by 'outer_mode'.  */\n-      if (GET_MODE_SIZE (outer_mode) == 1)\n+      switch (GET_MODE_SIZE (outer_mode))\n \t{\n+\tcase 1:\n \t  /* Further check if the value is legal for the 'outer_mode'.  */\n-\t  if (!satisfies_constraint_Is15 (index))\n-\t    return false;\n+\t  if (satisfies_constraint_Is15 (index))\n+\t    return true;\n+\t  break;\n \n-\t  /* Pass all test, the value is valid, return true.  */\n-\t  return true;\n-\t}\n-      if (GET_MODE_SIZE (outer_mode) == 2\n-\t  && NDS32_HALF_WORD_ALIGN_P (INTVAL (index)))\n-\t{\n+\tcase 2:\n \t  /* Further check if the value is legal for the 'outer_mode'.  */\n-\t  if (!satisfies_constraint_Is16 (index))\n-\t    return false;\n+\t  if (satisfies_constraint_Is16 (index))\n+\t    {\n+\t      /* Make sure address is half word alignment.  */\n+\t      if (NDS32_HALF_WORD_ALIGN_P (INTVAL (index)))\n+\t\treturn true;\n+\t    }\n+\t  break;\n \n-\t  /* Pass all test, the value is valid, return true.  */\n-\t  return true;\n-\t}\n-      if (GET_MODE_SIZE (outer_mode) == 4\n-\t  && NDS32_SINGLE_WORD_ALIGN_P (INTVAL (index)))\n-\t{\n+\tcase 4:\n \t  /* Further check if the value is legal for the 'outer_mode'.  */\n-\t  if (!satisfies_constraint_Is17 (index))\n-\t    return false;\n+\t  if (satisfies_constraint_Is17 (index))\n+\t    {\n+\t      if ((TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE))\n+\t\t{\n+\t\t  if (!satisfies_constraint_Is14 (index))\n+\t\t    return false;\n+\t\t}\n+\n+\t      /* Make sure address is word alignment.  */\n+\t      if (NDS32_SINGLE_WORD_ALIGN_P (INTVAL (index)))\n+\t\treturn true;\n+\t    }\n+\t  break;\n \n-\t  /* Pass all test, the value is valid, return true.  */\n-\t  return true;\n-\t}\n-      if (GET_MODE_SIZE (outer_mode) == 8\n-\t  && NDS32_SINGLE_WORD_ALIGN_P (INTVAL (index)))\n-\t{\n-\t  /* Further check if the value is legal for the 'outer_mode'.  */\n-\t  if (!satisfies_constraint_Is17 (gen_int_mode (INTVAL (index) + 4,\n-\t\t\t\t\t\t\tSImode)))\n-\t    return false;\n+\tcase 8:\n+\t  if (satisfies_constraint_Is17 (gen_int_mode (INTVAL (index) + 4,\n+\t\t\t\t\t\t       SImode)))\n+\t    {\n+\t      if ((TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE))\n+\t\t{\n+\t\t  if (!satisfies_constraint_Is14 (index))\n+\t\t    return false;\n+\t\t}\n+\n+\t      /* Make sure address is word alignment.\n+\t\tCurrently we do not have 64-bit load/store yet,\n+\t\tso we will use two 32-bit load/store instructions to do\n+\t\tmemory access and they are single word alignment.  */\n+\t      if (NDS32_SINGLE_WORD_ALIGN_P (INTVAL (index)))\n+\t\treturn true;\n+\t    }\n+\t  break;\n \n-\t  /* Pass all test, the value is valid, return true.  */\n-\t  return true;\n+\tdefault:\n+\t  return false;\n \t}\n \n       return false;\n@@ -1262,6 +1326,39 @@ nds32_register_passes (void)\n /* ------------------------------------------------------------------------ */\n \n /* PART 3: Implement target hook stuff definitions.  */\n+\f\n+\n+/* Register Usage.  */\n+\n+static void\n+nds32_conditional_register_usage (void)\n+{\n+  int regno;\n+\n+  if (TARGET_HARD_FLOAT)\n+    {\n+      for (regno = NDS32_FIRST_FPR_REGNUM;\n+\t   regno <= NDS32_LAST_FPR_REGNUM; regno++)\n+\t{\n+\t  fixed_regs[regno] = 0;\n+\t  if (regno < NDS32_FIRST_FPR_REGNUM + NDS32_MAX_FPR_REGS_FOR_ARGS)\n+\t    call_used_regs[regno] = 1;\n+\t  else if (regno >= NDS32_FIRST_FPR_REGNUM + 22\n+\t\t   && regno < NDS32_FIRST_FPR_REGNUM + 48)\n+\t    call_used_regs[regno] = 1;\n+\t  else\n+\t    call_used_regs[regno] = 0;\n+\t}\n+    }\n+  else if (TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE)\n+    {\n+      for (regno = NDS32_FIRST_FPR_REGNUM;\n+\t   regno <= NDS32_LAST_FPR_REGNUM;\n+\t   regno++)\n+\tfixed_regs[regno] = 0;\n+    }\n+}\n+\n \f\n /* Register Classes.  */\n \n@@ -1298,6 +1395,22 @@ nds32_register_priority (int hard_regno)\n     }\n }\n \n+static bool\n+nds32_can_change_mode_class (machine_mode from,\n+\t\t\t     machine_mode to,\n+\t\t\t     reg_class_t rclass)\n+{\n+  /* Don't spill double-precision register to two singal-precision\n+     registers  */\n+  if ((TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE)\n+       && GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n+    {\n+      return !reg_classes_intersect_p (rclass, FP_REGS);\n+    }\n+\n+  return true;\n+}\n+\n \f\n /* Stack Layout and Calling Conventions.  */\n \n@@ -1422,8 +1535,28 @@ nds32_function_arg (cumulative_args_t ca, machine_mode mode,\n      are different.  */\n   if (TARGET_HARD_FLOAT)\n     {\n-      /* Currently we have not implemented hard float yet.  */\n-      gcc_unreachable ();\n+      /* For TARGET_HARD_FLOAT calling convention, we use GPR and FPR\n+\t to pass argument.  We have to further check TYPE and MODE so\n+\t that we can determine which kind of register we shall use.  */\n+\n+      /* Note that we need to pass argument entirely in registers under\n+\t hard float abi.  */\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  && NDS32_ARG_ENTIRE_IN_FPR_REG_P (cum->fpr_offset, mode, type))\n+\t{\n+\t  /* Pick up the next available FPR register number.  */\n+\t  regno\n+\t    = NDS32_AVAILABLE_REGNUM_FOR_FPR_ARG (cum->fpr_offset, mode, type);\n+\t  return gen_rtx_REG (mode, regno);\n+\t}\n+      else if (GET_MODE_CLASS (mode) != MODE_FLOAT\n+\t       && NDS32_ARG_ENTIRE_IN_GPR_REG_P (cum->gpr_offset, mode, type))\n+\t{\n+\t  /* Pick up the next available GPR register number.  */\n+\t  regno\n+\t    = NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type);\n+\t  return gen_rtx_REG (mode, regno);\n+\t}\n     }\n   else\n     {\n@@ -1506,23 +1639,20 @@ static void\n nds32_function_arg_advance (cumulative_args_t ca, machine_mode mode,\n \t\t\t    const_tree type, bool named)\n {\n-  machine_mode sub_mode;\n   CUMULATIVE_ARGS *cum = get_cumulative_args (ca);\n \n   if (named)\n     {\n       /* We need to further check TYPE and MODE so that we can determine\n-         which kind of register we shall advance.  */\n-      if (type && TREE_CODE (type) == COMPLEX_TYPE)\n-\tsub_mode = TYPE_MODE (TREE_TYPE (type));\n-      else\n-\tsub_mode = mode;\n+\t which kind of register we shall advance.  */\n \n       /* Under hard float abi, we may advance FPR registers.  */\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (sub_mode) == MODE_FLOAT)\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n-\t  /* Currently we have not implemented hard float yet.  */\n-\t  gcc_unreachable ();\n+\t  cum->fpr_offset\n+\t    = NDS32_AVAILABLE_REGNUM_FOR_FPR_ARG (cum->fpr_offset, mode, type)\n+\t      - NDS32_FPR_ARG_FIRST_REGNUM\n+\t      + NDS32_NEED_N_REGS_FOR_ARG (mode, type);\n \t}\n       else\n \t{\n@@ -1569,22 +1699,62 @@ nds32_function_value (const_tree ret_type,\n   mode = TYPE_MODE (ret_type);\n   unsignedp = TYPE_UNSIGNED (ret_type);\n \n-  mode = promote_mode (ret_type, mode, &unsignedp);\n+  if (INTEGRAL_TYPE_P (ret_type))\n+    mode = promote_mode (ret_type, mode, &unsignedp);\n \n-  return gen_rtx_REG (mode, NDS32_GPR_RET_FIRST_REGNUM);\n+  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))\n+    return gen_rtx_REG (mode, NDS32_FPR_RET_FIRST_REGNUM);\n+  else\n+    return gen_rtx_REG (mode, NDS32_GPR_RET_FIRST_REGNUM);\n }\n \n static rtx\n nds32_libcall_value (machine_mode mode,\n \t\t     const_rtx fun ATTRIBUTE_UNUSED)\n {\n+  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))\n+    return gen_rtx_REG (mode, NDS32_FPR_RET_FIRST_REGNUM);\n+\n   return gen_rtx_REG (mode, NDS32_GPR_RET_FIRST_REGNUM);\n }\n \n static bool\n nds32_function_value_regno_p (const unsigned int regno)\n {\n-  return (regno == NDS32_GPR_RET_FIRST_REGNUM);\n+  if (regno == NDS32_GPR_RET_FIRST_REGNUM\n+      || (TARGET_HARD_FLOAT\n+\t  && regno == NDS32_FPR_RET_FIRST_REGNUM))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* -- How Large Values Are Returned.  */\n+\n+static bool\n+nds32_return_in_memory (const_tree type,\n+\t\t\tconst_tree fntype ATTRIBUTE_UNUSED)\n+{\n+  /* Note that int_size_in_bytes can return -1 if the size can vary\n+     or is larger than an integer.  */\n+  HOST_WIDE_INT size = int_size_in_bytes (type);\n+\n+  /* For COMPLEX_TYPE, if the total size cannot be hold within two registers,\n+     the return value is supposed to be in memory.  We need to be aware of\n+     that the size may be -1.  */\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    if (size < 0 || size > 2 * UNITS_PER_WORD)\n+      return true;\n+\n+  /* If it is BLKmode and the total size cannot be hold within two registers,\n+     the return value is supposed to be in memory.  We need to be aware of\n+     that the size may be -1.  */\n+  if (TYPE_MODE (type) == BLKmode)\n+    if (size < 0 || size > 2 * UNITS_PER_WORD)\n+      return true;\n+\n+  /* For other cases, having result in memory is unnecessary.  */\n+  return false;\n }\n \n /* -- Function Entry and Exit.  */\n@@ -1614,7 +1784,7 @@ nds32_asm_function_prologue (FILE *file)\n   /* Use df_regs_ever_live_p() to detect if the register\n      is ever used in the current function.  */\n   fprintf (file, \"\\t! registers ever_live: \");\n-  for (r = 0; r < 32; r++)\n+  for (r = 0; r < 65; r++)\n     {\n       if (df_regs_ever_live_p (r))\n \tfprintf (file, \"%s, \", reg_names[r]);\n@@ -2013,6 +2183,43 @@ nds32_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n static bool\n nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n {\n+  if (TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE)\n+    {\n+     /* When using floating-point instructions,\n+\twe don't allow 'addr' to be [symbol_ref], [CONST] pattern.  */\n+      if ((mode == DFmode || mode == SFmode)\n+\t  && (GET_CODE (x) == SYMBOL_REF\n+\t  || GET_CODE(x) == CONST))\n+\treturn false;\n+\n+      /* Allow [post_modify] addressing mode, when using FPU instructions.  */\n+      if (GET_CODE (x) == POST_MODIFY\n+\t  && mode == DFmode)\n+\t{\n+\t  if (GET_CODE (XEXP (x, 0)) == REG\n+\t      && GET_CODE (XEXP (x, 1)) == PLUS)\n+\t    {\n+\t      rtx plus_op = XEXP (x, 1);\n+\t      rtx op0 = XEXP (plus_op, 0);\n+\t      rtx op1 = XEXP (plus_op, 1);\n+\n+\t      if (nds32_address_register_rtx_p (op0, strict)\n+\t\t  && CONST_INT_P (op1))\n+\t\t{\n+\t\t  if (satisfies_constraint_Is14 (op1))\n+\t\t    {\n+\t\t      /* Make sure address is word alignment.\n+\t\t\tCurrently we do not have 64-bit load/store yet,\n+\t\t\tso we will use two 32-bit load/store instructions to do\n+\t\t\tmemory access and they are single word alignment.  */\n+\t\t      if (NDS32_SINGLE_WORD_ALIGN_P (INTVAL (op1)))\n+\t\t\treturn true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   /* For (mem:DI addr) or (mem:DF addr) case,\n      we only allow 'addr' to be [reg], [symbol_ref],\n \t\t\t\t[const], or [reg + const_int] pattern.  */\n@@ -2031,6 +2238,13 @@ nds32_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n \t    return true;\n \t}\n \n+      /* Allow [post_inc] and [post_dec] addressing mode.  */\n+      if (GET_CODE (x) == POST_INC || GET_CODE (x) == POST_DEC)\n+\t{\n+\t  if (nds32_address_register_rtx_p (XEXP (x, 0), strict))\n+\t    return true;\n+\t}\n+\n       /* Now check [reg], [symbol_ref], and [const].  */\n       if (GET_CODE (x) != REG\n \t  && GET_CODE (x) != SYMBOL_REF\n@@ -2216,10 +2430,13 @@ nds32_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  reg_class_t from,\n \t\t\t  reg_class_t to)\n {\n-  if (from == HIGH_REGS || to == HIGH_REGS)\n-    return 6;\n-\n-  return 2;\n+  if ((from == FP_REGS && to != FP_REGS)\n+      || (from != FP_REGS && to == FP_REGS))\n+    return 9;\n+  else if (from == HIGH_REGS || to == HIGH_REGS)\n+    return optimize_size ? 6 : 2;\n+  else\n+    return 2;\n }\n \n static int\n@@ -2305,7 +2522,10 @@ nds32_asm_file_start (void)\n \n   /* Tell assembler which ABI we are using.  */\n   fprintf (asm_out_file, \"\\t! ABI version\\n\");\n-  fprintf (asm_out_file, \"\\t.abi_2\\n\");\n+  if (TARGET_HARD_FLOAT)\n+    fprintf (asm_out_file, \"\\t.abi_2fp_plus\\n\");\n+  else\n+    fprintf (asm_out_file, \"\\t.abi_2\\n\");\n \n   /* Tell assembler that this asm code is generated by compiler.  */\n   fprintf (asm_out_file, \"\\t! This asm file is generated by compiler\\n\");\n@@ -2334,6 +2554,15 @@ nds32_asm_file_start (void)\n   fprintf (asm_out_file, \"\\t! Endian setting\\t: %s\\n\",\n \t\t\t ((TARGET_BIG_ENDIAN) ? \"big-endian\"\n \t\t\t\t\t      : \"little-endian\"));\n+  fprintf (asm_out_file, \"\\t! Use SP floating-point instruction\\t: %s\\n\",\n+\t\t\t ((TARGET_FPU_SINGLE) ? \"Yes\"\n+\t\t\t\t\t      : \"No\"));\n+  fprintf (asm_out_file, \"\\t! Use DP floating-point instruction\\t: %s\\n\",\n+\t\t\t ((TARGET_FPU_DOUBLE) ? \"Yes\"\n+\t\t\t\t\t      : \"No\"));\n+  fprintf (asm_out_file, \"\\t! ABI version\\t\\t: %s\\n\",\n+\t\t\t ((TARGET_HARD_FLOAT) ? \"ABI2FP+\"\n+\t\t\t\t\t      : \"ABI2\"));\n \n   fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n \n@@ -2404,6 +2633,10 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n {\n   HOST_WIDE_INT one_position;\n   HOST_WIDE_INT zero_position;\n+  bool pick_lsb_p = false;\n+  bool pick_msb_p = false;\n+  int regno;\n+\n   int op_value;\n \n   switch (code)\n@@ -2440,6 +2673,20 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n       /* No need to handle following process, so return immediately.  */\n       return;\n \n+    case 'L':\n+      /* X is supposed to be REG rtx.  */\n+      gcc_assert (REG_P (x));\n+      /* Claim that we are going to pick LSB part of X.  */\n+      pick_lsb_p = true;\n+      break;\n+\n+    case 'H':\n+      /* X is supposed to be REG rtx.  */\n+      gcc_assert (REG_P (x));\n+      /* Claim that we are going to pick MSB part of X.  */\n+      pick_msb_p = true;\n+      break;\n+\n     case 'V':\n       /* 'x' is supposed to be CONST_INT, get the value.  */\n       gcc_assert (CONST_INT_P (x));\n@@ -2489,6 +2736,38 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n       break;\n \n     case REG:\n+      /* Print a Double-precision register name.  */\n+      if ((GET_MODE (x) == DImode || GET_MODE (x) == DFmode)\n+\t  && NDS32_IS_FPR_REGNUM (REGNO (x)))\n+\t{\n+\t  regno = REGNO (x);\n+\t  if (!NDS32_FPR_REGNO_OK_FOR_DOUBLE (regno))\n+\t    {\n+\t      output_operand_lossage (\"invalid operand for code '%c'\", code);\n+\t      break;\n+\t    }\n+\t  fprintf (stream, \"$fd%d\", (regno - NDS32_FIRST_FPR_REGNUM) >> 1);\n+\t  break;\n+\t}\n+\n+      /* Print LSB or MSB part of register pair if the\n+\t constraint modifier 'L' or 'H' is specified.  */\n+      if ((GET_MODE (x) == DImode || GET_MODE (x) == DFmode)\n+\t  && NDS32_IS_GPR_REGNUM (REGNO (x)))\n+\t{\n+\t  if ((pick_lsb_p && WORDS_BIG_ENDIAN)\n+\t      || (pick_msb_p && !WORDS_BIG_ENDIAN))\n+\t    {\n+\t      /* If we would like to print out LSB register under big-endian,\n+\t\t or print out MSB register under little-endian, we need to\n+\t\t increase register number.  */\n+\t      regno = REGNO (x);\n+\t      regno++;\n+\t      fputs (reg_names[regno], stream);\n+\t      break;\n+\t    }\n+\t}\n+\n       /* Forbid using static chain register ($r16)\n \t on reduced-set registers configuration.  */\n       if (TARGET_REDUCED_REGS\n@@ -2503,6 +2782,33 @@ nds32_print_operand (FILE *stream, rtx x, int code)\n       output_address (GET_MODE (x), XEXP (x, 0));\n       break;\n \n+    case HIGH:\n+      if (GET_CODE (XEXP (x, 0)) == CONST_DOUBLE)\n+\t{\n+\t  const REAL_VALUE_TYPE *rv;\n+\t  long val;\n+\t  gcc_assert (GET_MODE (x) == SFmode);\n+\n+\t  rv = CONST_DOUBLE_REAL_VALUE (XEXP (x, 0));\n+\t  REAL_VALUE_TO_TARGET_SINGLE (*rv, val);\n+\n+\t  fprintf (stream, \"hi20(0x%lx)\", val);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+      break;\n+\n+    case CONST_DOUBLE:\n+      const REAL_VALUE_TYPE *rv;\n+      long val;\n+      gcc_assert (GET_MODE (x) == SFmode);\n+\n+      rv = CONST_DOUBLE_REAL_VALUE (x);\n+      REAL_VALUE_TO_TARGET_SINGLE (*rv, val);\n+\n+      fprintf (stream, \"0x%lx\", val);\n+      break;\n+\n     case CODE_LABEL:\n     case CONST_INT:\n     case CONST:\n@@ -2687,6 +2993,84 @@ nds32_print_operand_address (FILE *stream, machine_mode /*mode*/, rtx x)\n     }\n }\n \n+/* -- Assembler Commands for Exception Regions.  */\n+\n+static rtx\n+nds32_dwarf_register_span (rtx reg)\n+{\n+  rtx dwarf_high, dwarf_low;\n+  rtx dwarf_single;\n+  machine_mode mode;\n+  int regno;\n+\n+  mode = GET_MODE (reg);\n+  regno = REGNO (reg);\n+\n+  /* We need to adjust dwarf register information for floating-point registers\n+     rather than using default register number mapping.  */\n+  if (regno >= NDS32_FIRST_FPR_REGNUM\n+      && regno <= NDS32_LAST_FPR_REGNUM)\n+    {\n+      if (mode == DFmode || mode == SCmode)\n+\t{\n+\t  /* By default, GCC maps increasing register numbers to increasing\n+\t     memory locations, but paired FPRs in NDS32 target are always\n+\t     big-endian, i.e.:\n+\n+\t       fd0 :  fs0   fs1\n+\t\t     (MSB) (LSB)\n+\n+\t     We must return parallel rtx to represent such layout.  */\n+\t  dwarf_high = gen_rtx_REG (word_mode, regno);\n+\t  dwarf_low = gen_rtx_REG (word_mode, regno + 1);\n+\t  return gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t   gen_rtvec (2, dwarf_low, dwarf_high));\n+\t}\n+      else if (mode == DCmode)\n+\t{\n+\t  rtx dwarf_high_re = gen_rtx_REG (word_mode, regno);\n+\t  rtx dwarf_low_re = gen_rtx_REG (word_mode, regno + 1);\n+\t  rtx dwarf_high_im = gen_rtx_REG (word_mode, regno);\n+\t  rtx dwarf_low_im = gen_rtx_REG (word_mode, regno + 1);\n+\t  return gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t   gen_rtvec (4, dwarf_low_re, dwarf_high_re,\n+\t\t\t\t\t\t dwarf_high_im, dwarf_low_im));\n+\t}\n+      else if (mode == SFmode || mode == SImode)\n+\t{\n+\t  /* Create new dwarf information with adjusted register number.  */\n+\t  dwarf_single = gen_rtx_REG (word_mode, regno);\n+\t  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, dwarf_single));\n+\t}\n+      else\n+\t{\n+\t  /* We should not be here.  */\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+/* Map internal gcc register numbers to DWARF2 register numbers.  */\n+\n+unsigned int\n+nds32_dbx_register_number (unsigned int regno)\n+{\n+  /* The nds32 port in GDB maintains a mapping between dwarf register\n+     number and displayed register name.  For backward compatibility to\n+     previous toolchain, currently our gdb still has four registers\n+     (d0.l, d0.h, d1.l, and d1.h) between GPR and FPR while compiler\n+     does not count those four registers in its register number table.\n+     So we have to add 4 on its register number and then create new\n+     dwarf information.  Hopefully we can discard such workaround\n+     in the future.  */\n+  if (NDS32_IS_FPR_REGNUM (regno))\n+    return regno + 4;\n+\n+  return regno;\n+}\n+\n \f\n /* Defining target-specific uses of __attribute__.  */\n \n@@ -2894,6 +3278,16 @@ nds32_option_override (void)\n       target_flags &= ~MASK_V3PUSH;\n     }\n \n+  if (TARGET_HARD_FLOAT && !(TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE))\n+    {\n+      if (nds32_arch_option == ARCH_V3S || nds32_arch_option == ARCH_V3F)\n+\terror (\"Disable FPU ISA, \"\n+\t       \"the ABI option must be enable '-mfloat-abi=soft'\");\n+      else\n+\terror (\"'-mabi=2fp+' option only support when FPU available, \"\n+\t       \"must be enable '-mext-fpu-sp' or '-mext-fpu-dp'\");\n+    }\n+\n   /* Currently, we don't support PIC code generation yet.  */\n   if (flag_pic)\n     sorry (\"position-independent code not supported\");\n@@ -2954,13 +3348,52 @@ nds32_cpu_cpp_builtins(struct cpp_reader *pfile)\n   builtin_define (\"__nds32__\");\n   builtin_define (\"__NDS32__\");\n \n+  if (TARGET_HARD_FLOAT)\n+    builtin_define (\"__NDS32_ABI_2FP_PLUS__\");\n+  else\n+    builtin_define (\"__NDS32_ABI_2__\");\n+\n   if (TARGET_ISA_V2)\n     builtin_define (\"__NDS32_ISA_V2__\");\n   if (TARGET_ISA_V3)\n     builtin_define (\"__NDS32_ISA_V3__\");\n   if (TARGET_ISA_V3M)\n     builtin_define (\"__NDS32_ISA_V3M__\");\n \n+  if (TARGET_FPU_SINGLE)\n+    builtin_define (\"__NDS32_EXT_FPU_SP__\");\n+  if (TARGET_FPU_DOUBLE)\n+    builtin_define (\"__NDS32_EXT_FPU_DP__\");\n+\n+  if (TARGET_EXT_FPU_FMA)\n+    builtin_define (\"__NDS32_EXT_FPU_FMA__\");\n+  if (NDS32_EXT_FPU_DOT_E)\n+    builtin_define (\"__NDS32_EXT_FPU_DOT_E__\");\n+  if (TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE)\n+    {\n+      switch (nds32_fp_regnum)\n+\t{\n+\tcase 0:\n+\tcase 4:\n+\t  builtin_define (\"__NDS32_EXT_FPU_CONFIG_0__\");\n+\t  break;\n+\tcase 1:\n+\tcase 5:\n+\t  builtin_define (\"__NDS32_EXT_FPU_CONFIG_1__\");\n+\t  break;\n+\tcase 2:\n+\tcase 6:\n+\t  builtin_define (\"__NDS32_EXT_FPU_CONFIG_2__\");\n+\t  break;\n+\tcase 3:\n+\tcase 7:\n+\t  builtin_define (\"__NDS32_EXT_FPU_CONFIG_3__\");\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+\n   if (TARGET_BIG_ENDIAN)\n     builtin_define (\"__NDS32_EB__\");\n   else\n@@ -2988,6 +3421,12 @@ nds32_cpu_cpp_builtins(struct cpp_reader *pfile)\n \n   builtin_assert (\"cpu=nds32\");\n   builtin_assert (\"machine=nds32\");\n+\n+  if (TARGET_HARD_FLOAT)\n+    builtin_define (\"__NDS32_ABI_2FP_PLUS\");\n+  else\n+    builtin_define (\"__NDS32_ABI_2\");\n+\n #undef builtin_define\n #undef builtin_assert\n }\n@@ -3026,16 +3465,38 @@ nds32_adjust_reg_alloc_order (void)\n \n /* -- How Values Fit in Registers.  */\n \n+static unsigned\n+nds32_hard_regno_nregs (unsigned regno ATTRIBUTE_UNUSED,\n+\t\t\tmachine_mode mode)\n+{\n+  return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n+}\n+\n /* Implement TARGET_HARD_REGNO_MODE_OK.  */\n \n static bool\n nds32_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n-  /* Restrict double-word quantities to even register pairs.  */\n-  if (targetm.hard_regno_nregs (regno, mode) == 1\n-      || !((regno) & 1))\n+  if (regno > FIRST_PSEUDO_REGISTER)\n     return true;\n \n+  if ((TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE) && NDS32_IS_FPR_REGNUM (regno))\n+    {\n+      if (NDS32_IS_EXT_FPR_REGNUM(regno))\n+\treturn (NDS32_FPR_REGNO_OK_FOR_DOUBLE(regno) && (mode == DFmode));\n+      else if (mode == SFmode || mode == SImode)\n+\treturn NDS32_FPR_REGNO_OK_FOR_SINGLE (regno);\n+      else if (mode == DFmode)\n+\treturn NDS32_FPR_REGNO_OK_FOR_DOUBLE (regno);\n+\n+      return false;\n+    }\n+\n+  /* Restrict double-word quantities to even register pairs.  */\n+  if (regno <= NDS32_LAST_GPR_REGNUM)\n+    return (targetm.hard_regno_nregs (regno, mode) == 1\n+\t    || !((regno) & 1));\n+\n   return false;\n }\n \n@@ -3048,10 +3509,22 @@ nds32_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n static bool\n nds32_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n-  return (GET_MODE_CLASS (mode1) == MODE_INT\n-\t  && GET_MODE_CLASS (mode2) == MODE_INT\n-\t  && GET_MODE_SIZE (mode1) <= UNITS_PER_WORD\n-\t  && GET_MODE_SIZE (mode2) <= UNITS_PER_WORD);\n+  if ((GET_MODE_CLASS (mode1) == MODE_INT\n+       && GET_MODE_CLASS (mode2) == MODE_INT)\n+      && GET_MODE_SIZE (mode1) <= UNITS_PER_WORD\n+      && GET_MODE_SIZE (mode2) <= UNITS_PER_WORD)\n+    return true;\n+\n+  if (GET_MODE_SIZE (mode1) == GET_MODE_SIZE (mode2))\n+    {\n+      if ((TARGET_FPU_SINGLE && !TARGET_FPU_DOUBLE)\n+\t  && (mode1 == DFmode || mode2 == DFmode))\n+\treturn false;\n+      else\n+\treturn true;\n+    }\n+\n+  return false;\n }\n \n #undef TARGET_MODES_TIEABLE_P\n@@ -3077,7 +3550,14 @@ nds32_regno_reg_class (int regno)\n   else if (regno >= 20 && regno <= 31)\n     return HIGH_REGS;\n   else if (regno == 32 || regno == 33)\n-    return FRAME_REGS;\n+    {\n+      /* $SFP and $AP is FRAME_REGS in fact, However prevent IRA don't\n+\t know how to allocate register for $SFP and $AP, just tell IRA they\n+\t are GENERAL_REGS, and ARM do this hack too.  */\n+      return GENERAL_REGS;\n+    }\n+  else if (regno >= 34 && regno <= 97)\n+    return FP_REGS;\n   else\n     return NO_REGS;\n }\n@@ -3123,6 +3603,7 @@ nds32_initial_elimination_offset (unsigned int from_reg, unsigned int to_reg)\n \t\t+ cfun->machine->lp_size\n \t\t+ cfun->machine->callee_saved_gpr_regs_size\n \t\t+ cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t+ cfun->machine->callee_saved_fpr_regs_size\n \t\t+ cfun->machine->local_size\n \t\t+ cfun->machine->out_args_size);\n     }\n@@ -3143,7 +3624,8 @@ nds32_initial_elimination_offset (unsigned int from_reg, unsigned int to_reg)\n \t\t       + cfun->machine->gp_size\n \t\t       + cfun->machine->lp_size\n \t\t       + cfun->machine->callee_saved_gpr_regs_size\n-\t\t       + cfun->machine->callee_saved_area_gpr_padding_bytes);\n+\t\t       + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t       + cfun->machine->callee_saved_fpr_regs_size);\n     }\n   else\n     {\n@@ -3162,10 +3644,11 @@ nds32_init_cumulative_args (CUMULATIVE_ARGS *cum,\n \t\t\t    tree fndecl ATTRIBUTE_UNUSED,\n \t\t\t    int n_named_args ATTRIBUTE_UNUSED)\n {\n-  /* Initial available registers\n-     (in offset, corresponding to NDS32_GPR_ARG_FIRST_REGNUM)\n+  /* Initial available registers.  The values are offset against\n+     NDS32_GPR_ARG_FIRST_REGNUM and NDS32_FPR_ARG_FIRST_REGNUM\n      for passing arguments.  */\n   cum->gpr_offset = 0;\n+  cum->fpr_offset = 0;\n }\n \n /* -- Function Entry and Exit.  */\n@@ -3248,17 +3731,79 @@ nds32_expand_prologue (void)\n \t\t\t       fp_adjust);\n     }\n \n-  /* Adjust $sp = $sp - local_size - out_args_size\n-                      - callee_saved_area_gpr_padding_bytes.  */\n-  sp_adjust = cfun->machine->local_size\n-\t      + cfun->machine->out_args_size\n-\t      + cfun->machine->callee_saved_area_gpr_padding_bytes;\n-  /* sp_adjust value may be out of range of the addi instruction,\n-     create alternative add behavior with TA_REGNUM if necessary,\n-     using NEGATIVE value to tell that we are decreasing address.  */\n-  nds32_emit_adjust_frame (stack_pointer_rtx,\n-\t\t\t   stack_pointer_rtx,\n-\t\t\t   -1 * sp_adjust);\n+  /* Save fpu registers.  */\n+  if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+    {\n+      /* When $sp moved to bottom of stack, we need to check whether\n+\t the range of offset in the FPU instruction.  */\n+      int fpr_offset = cfun->machine->local_size\n+\t\t       + cfun->machine->out_args_size\n+\t\t       + cfun->machine->callee_saved_fpr_regs_size;\n+\n+      /* Check FPU instruction offset imm14s.  */\n+      if (!satisfies_constraint_Is14 (GEN_INT (fpr_offset)))\n+\t{\n+\t  int fpr_space = cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t\t  + cfun->machine->callee_saved_fpr_regs_size;\n+\n+\t  /* Save fpu registers, need to allocate stack space\n+\t     for fpu callee registers.  And now $sp position\n+\t     on callee saved fpr registers.  */\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   -1 * fpr_space);\n+\n+\t  /* Emit fpu store instruction, using [$sp + offset] store\n+\t     fpu registers.  */\n+\t  nds32_emit_push_fpr_callee_saved (0);\n+\n+          /* Adjust $sp = $sp - local_size - out_args_size.  */\n+\t  sp_adjust = cfun->machine->local_size\n+\t\t      + cfun->machine->out_args_size;\n+\n+\t  /* Allocate stack space for local size and out args size.  */\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   -1 * sp_adjust);\n+\t}\n+      else\n+\t{\n+\t  /* Offset range in Is14, so $sp moved to bottom of stack.  */\n+\n+          /* Adjust $sp = $sp - local_size - out_args_size\n+\t\t\t      - callee_saved_area_gpr_padding_bytes\n+\t\t\t      - callee_saved_fpr_regs_size.  */\n+\t  sp_adjust = cfun->machine->local_size\n+\t\t      + cfun->machine->out_args_size\n+\t\t      + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t      + cfun->machine->callee_saved_fpr_regs_size;\n+\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   -1 * sp_adjust);\n+\n+\t  /* Emit fpu store instruction, using [$sp + offset] store\n+\t     fpu registers.  */\n+\t  int fpr_position = cfun->machine->out_args_size\n+\t\t\t     + cfun->machine->local_size;\n+\t  nds32_emit_push_fpr_callee_saved (fpr_position);\n+\t}\n+    }\n+  else\n+    {\n+      /* Adjust $sp = $sp - local_size - out_args_size\n+\t\t\t  - callee_saved_area_gpr_padding_bytes.  */\n+      sp_adjust = cfun->machine->local_size\n+\t\t  + cfun->machine->out_args_size\n+\t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes;\n+\n+      /* sp_adjust value may be out of range of the addi instruction,\n+\t create alternative add behavior with TA_REGNUM if necessary,\n+\t using NEGATIVE value to tell that we are decreasing address.  */\n+      nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       -1 * sp_adjust);\n+    }\n \n   /* Prevent the instruction scheduler from\n      moving instructions across the boundary.  */\n@@ -3310,39 +3855,93 @@ nds32_expand_epilogue (bool sibcall_p)\n \n   if (frame_pointer_needed)\n     {\n-      /* adjust $sp = $fp - ($fp size) - ($gp size) - ($lp size)\n-\t\t\t  - (4 * callee-saved-registers)\n-\t Note: No need to adjust\n-\t       cfun->machine->callee_saved_area_gpr_padding_bytes,\n-\t       because we want to adjust stack pointer\n-\t       to the position for pop instruction.  */\n-      sp_adjust = cfun->machine->fp_size\n-\t\t  + cfun->machine->gp_size\n-\t\t  + cfun->machine->lp_size\n-\t\t  + cfun->machine->callee_saved_gpr_regs_size;\n+      /* Restore fpu registers.  */\n+      if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t{\n+\t  int gpr_padding = cfun->machine->callee_saved_area_gpr_padding_bytes;\n+\n+\t  /* adjust $sp = $fp - ($fp size) - ($gp size) - ($lp size)\n+\t\t\t      - (4 * callee-saved-registers)\n+\t\t\t      - (4 * exception-handling-data-registers)\n+\t\t\t      - (4 * callee-saved-gpr-registers padding byte)\n+\t\t\t      - (4 * callee-saved-fpr-registers)\n+\t     Note:  we want to adjust stack pointer\n+\t\t    to the position for callee-saved fpr register,\n+\t\t    And restore fpu register use .bi instruction to adjust $sp\n+\t\t    from callee-saved fpr register to pop instruction.  */\n+\t  sp_adjust = cfun->machine->fp_size\n+\t\t      + cfun->machine->gp_size\n+\t\t      + cfun->machine->lp_size\n+\t\t      + cfun->machine->callee_saved_gpr_regs_size\n+\t\t      + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t      + cfun->machine->callee_saved_fpr_regs_size;\n \n-      nds32_emit_adjust_frame (stack_pointer_rtx,\n-\t\t\t       hard_frame_pointer_rtx,\n-\t\t\t       -1 * sp_adjust);\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   hard_frame_pointer_rtx,\n+\t\t\t\t   -1 * sp_adjust);\n+\n+\t  /* Emit fpu load instruction, using .bi instruction\n+\t     load fpu registers.  */\n+\t  nds32_emit_pop_fpr_callee_saved (gpr_padding);\n+\t}\n+      else\n+\t{\n+\t  /* adjust $sp = $fp - ($fp size) - ($gp size) - ($lp size)\n+\t\t\t      - (4 * callee-saved-registers)\n+\t\t\t      - (4 * exception-handling-data-registers)\n+\t     Note: No need to adjust\n+\t\t   cfun->machine->callee_saved_area_gpr_padding_bytes,\n+\t\t   because we want to adjust stack pointer\n+\t\t   to the position for pop instruction.  */\n+\t  sp_adjust = cfun->machine->fp_size\n+\t\t      + cfun->machine->gp_size\n+\t\t      + cfun->machine->lp_size\n+\t\t      + cfun->machine->callee_saved_gpr_regs_size;\n+\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   hard_frame_pointer_rtx,\n+\t\t\t\t   -1 * sp_adjust);\n+\t}\n     }\n   else\n     {\n-      /* If frame pointer is NOT needed,\n-\t we cannot calculate the sp adjustment from frame pointer.\n-\t Instead, we calculate the adjustment by local_size,\n-\t out_args_size, and callee_saved_area_gpr_padding_bytes.\n-\t Notice that such sp adjustment value may be out of range,\n-\t so we have to deal with it as well.  */\n+      /* Restore fpu registers.  */\n+      if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t{\n+\t  int gpr_padding = cfun->machine->callee_saved_area_gpr_padding_bytes;\n \n-      /* Adjust $sp = $sp + local_size + out_args_size\n-\t                  + callee_saved_area_gpr_padding_bytes.  */\n-      sp_adjust = cfun->machine->local_size\n-\t\t  + cfun->machine->out_args_size\n-\t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes;\n+\t  /* Adjust $sp = $sp + local_size + out_args_size.  */\n+\t  sp_adjust = cfun->machine->local_size\n+\t\t      + cfun->machine->out_args_size;\n \n-      nds32_emit_adjust_frame (stack_pointer_rtx,\n-\t\t\t       stack_pointer_rtx,\n-\t\t\t       sp_adjust);\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   sp_adjust);\n+\n+\t  /* Emit fpu load instruction, using .bi instruction\n+\t     load fpu registers, and adjust $sp from callee-saved fpr register\n+\t     to callee-saved gpr register.  */\n+\t  nds32_emit_pop_fpr_callee_saved (gpr_padding);\n+\t}\n+      else\n+\t{\n+\t  /* If frame pointer is NOT needed,\n+\t     we cannot calculate the sp adjustment from frame pointer.\n+\t     Instead, we calculate the adjustment by local_size,\n+\t     out_args_size, and callee_saved_area_gpr_padding_bytes.\n+\t     Notice that such sp adjustment value may be out of range,\n+\t     so we have to deal with it as well.  */\n+\n+\t  /* Adjust $sp = $sp + local_size + out_args_size\n+\t\t\t      + callee_saved_area_gpr_padding_bytes.  */\n+\t  sp_adjust = cfun->machine->local_size\n+\t\t      + cfun->machine->out_args_size\n+\t\t      + cfun->machine->callee_saved_area_gpr_padding_bytes;\n+\n+\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   sp_adjust);\n+\t}\n     }\n \n   /* Get callee_first_regno and callee_last_regno.  */\n@@ -3389,6 +3988,7 @@ nds32_expand_prologue_v3push (void)\n {\n   int fp_adjust;\n   int sp_adjust;\n+  int fpr_space = 0;\n   unsigned Rb, Re;\n \n   /* Compute and setup stack frame size.\n@@ -3411,7 +4011,8 @@ nds32_expand_prologue_v3push (void)\n      where imm8u has to be 8-byte alignment.  */\n   sp_adjust = cfun->machine->local_size\n \t      + cfun->machine->out_args_size\n-\t      + cfun->machine->callee_saved_area_gpr_padding_bytes;\n+\t      + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t      + cfun->machine->callee_saved_fpr_regs_size;\n \n   if (satisfies_constraint_Iu08 (GEN_INT (sp_adjust))\n       && NDS32_DOUBLE_WORD_ALIGN_P (sp_adjust))\n@@ -3421,6 +4022,18 @@ nds32_expand_prologue_v3push (void)\n       /* nds32_emit_stack_v3push(last_regno, sp_adjust),\n \t the pattern 'stack_v3push' is implemented in nds32.md.  */\n       nds32_emit_stack_v3push (Rb, Re, sp_adjust);\n+\n+      /* Save fpu registers.  */\n+      if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t{\n+\t  /* Calculate fpr position.  */\n+\t  int fpr_position = cfun->machine->local_size\n+\t\t\t     + cfun->machine->out_args_size;\n+\t  /* Emit fpu store instruction, using [$sp + offset] store\n+\t     fpu registers.  */\n+\t  nds32_emit_push_fpr_callee_saved (fpr_position);\n+\t}\n+\n       /* Check frame_pointer_needed to see\n \t if we shall emit fp adjustment instruction.  */\n       if (frame_pointer_needed)\n@@ -3448,12 +4061,26 @@ nds32_expand_prologue_v3push (void)\n     }\n   else\n     {\n-      /* We have to use 'push25 Re,0' and\n-\t expand one more instruction to adjust $sp later.  */\n+      if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t{\n+\t  /* Calculate fpr space.  */\n+\t  fpr_space = cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t      + cfun->machine->callee_saved_fpr_regs_size;\n+\n+\t  /* We have to use 'push25 Re, fpr_space', to pre-allocate\n+\t     callee saved fpr registers space.  */\n+\t  nds32_emit_stack_v3push (Rb, Re, fpr_space);\n+\t  nds32_emit_push_fpr_callee_saved (0);\n+\t}\n+      else\n+\t{\n+\t  /* We have to use 'push25 Re,0' and\n+\t     expand one more instruction to adjust $sp later.  */\n \n-      /* nds32_emit_stack_v3push(last_regno, sp_adjust),\n-\t the pattern 'stack_v3push' is implemented in nds32.md.  */\n-      nds32_emit_stack_v3push (Rb, Re, 0);\n+\t  /* nds32_emit_stack_v3push(last_regno, sp_adjust),\n+\t     the pattern 'stack_v3push' is implemented in nds32.md.  */\n+\t  nds32_emit_stack_v3push (Rb, Re, 0);\n+\t}\n \n       /* Check frame_pointer_needed to see\n \t if we shall emit fp adjustment instruction.  */\n@@ -3472,11 +4099,27 @@ nds32_expand_prologue_v3push (void)\n \t\t      + cfun->machine->lp_size\n \t\t      + cfun->machine->callee_saved_gpr_regs_size;\n \n+\t  if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t    {\n+\t      /* We use 'push25 Re, fpr_space', the $sp is\n+\t\t on callee saved fpr position, so need to consider\n+\t\t fpr space.  */\n+\t      fp_adjust = fp_adjust + fpr_space;\n+\t    }\n+\n \t  nds32_emit_adjust_frame (hard_frame_pointer_rtx,\n \t\t\t\t   stack_pointer_rtx,\n \t\t\t\t   fp_adjust);\n \t}\n \n+      if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t{\n+\t  /* We use 'push25 Re, fpr_space',\n+\t     the $sp is on callee saved fpr position,\n+\t     no need to consider fpr space.  */\n+\t  sp_adjust = sp_adjust - fpr_space;\n+\t}\n+\n       /* Because we use 'push25 Re,0',\n \t we need to expand one more instruction to adjust $sp.\n \t using NEGATIVE value to tell that we are decreasing address.  */\n@@ -3524,7 +4167,8 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n      where imm8u has to be 8-byte alignment.  */\n   sp_adjust = cfun->machine->local_size\n \t      + cfun->machine->out_args_size\n-\t      + cfun->machine->callee_saved_area_gpr_padding_bytes;\n+\t      + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t      + cfun->machine->callee_saved_fpr_regs_size;\n \n   /* We have to consider alloca issue as well.\n      If the function does call alloca(), the stack pointer is not fixed.\n@@ -3537,6 +4181,16 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n       && NDS32_DOUBLE_WORD_ALIGN_P (sp_adjust)\n       && !cfun->calls_alloca)\n     {\n+      /* Restore fpu registers.  */\n+      if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t{\n+\t  int fpr_position = cfun->machine->local_size\n+\t\t\t     + cfun->machine->out_args_size;\n+\t  /* Emit fpu load instruction, using [$sp + offset] restore\n+\t     fpu registers.  */\n+\t  nds32_emit_v3pop_fpr_callee_saved (fpr_position);\n+\t}\n+\n       /* We can use 'pop25 Re,imm8u'.  */\n \n       /* nds32_emit_stack_v3pop(last_regno, sp_adjust),\n@@ -3563,9 +4217,29 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n \t\t      + cfun->machine->lp_size\n \t\t      + cfun->machine->callee_saved_gpr_regs_size;\n \n-\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n-\t\t\t\t   hard_frame_pointer_rtx,\n-\t\t\t\t   -1 * sp_adjust);\n+\t  /* Restore fpu registers.  */\n+\t  if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t    {\n+\t      /* Set $sp to callee saved fpr position, we need to restore\n+\t\t fpr registers.  */\n+\t      sp_adjust = sp_adjust\n+\t\t\t  + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t\t  + cfun->machine->callee_saved_fpr_regs_size;\n+\n+\t      nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t       hard_frame_pointer_rtx,\n+\t\t\t\t       -1 * sp_adjust);\n+\n+\t      /* Emit fpu load instruction, using [$sp + offset] restore\n+\t\t fpu registers.  */\n+\t      nds32_emit_v3pop_fpr_callee_saved (0);\n+\t    }\n+\t  else\n+\t    {\n+\t      nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t       hard_frame_pointer_rtx,\n+\t\t\t\t       -1 * sp_adjust);\n+\t    }\n \t}\n       else\n \t{\n@@ -3577,24 +4251,57 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n \t     so we have to deal with it as well.  */\n \n \t  /* Adjust $sp = $sp + local_size + out_args_size\n-                              + callee_saved_area_gpr_padding_bytes.  */\n+\t\t\t      + callee_saved_area_gpr_padding_bytes\n+\t\t\t      + callee_saved_fpr_regs_size.  */\n \t  sp_adjust = cfun->machine->local_size\n \t\t      + cfun->machine->out_args_size\n-\t\t      + cfun->machine->callee_saved_area_gpr_padding_bytes;\n-\t   /* sp_adjust value may be out of range of the addi instruction,\n-\t      create alternative add behavior with TA_REGNUM if necessary,\n-\t      using POSITIVE value to tell that we are increasing\n-\t      address.  */\n-\t  nds32_emit_adjust_frame (stack_pointer_rtx,\n-\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t   sp_adjust);\n+\t\t      + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t      + cfun->machine->callee_saved_fpr_regs_size;\n+\n+\t  /* Restore fpu registers.  */\n+\t  if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t    {\n+\t      /* Set $sp to callee saved fpr position, we need to restore\n+\t\t fpr registers.  */\n+\t      sp_adjust = sp_adjust\n+\t\t\t  - cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t\t  - cfun->machine->callee_saved_fpr_regs_size;\n+\n+\t      nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t       sp_adjust);\n+\n+\t      /* Emit fpu load instruction, using [$sp + offset] restore\n+\t\t fpu registers.  */\n+\t      nds32_emit_v3pop_fpr_callee_saved (0);\n+\t    }\n+\t  else\n+\t    {\n+\t       /* sp_adjust value may be out of range of the addi instruction,\n+\t\t  create alternative add behavior with TA_REGNUM if necessary,\n+\t\t  using POSITIVE value to tell that we are increasing\n+\t\t  address.  */\n+\t      nds32_emit_adjust_frame (stack_pointer_rtx,\n+\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t       sp_adjust);\n+\t    }\n \t}\n \n-      /* nds32_emit_stack_v3pop(last_regno, sp_adjust),\n-\t the pattern 'stack_v3pop' is implementad in nds32.md.  */\n-      nds32_emit_stack_v3pop (Rb, Re, 0);\n+      if (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)\n+\t{\n+\t  /* We have fpr need to restore, so $sp is set on callee saved fpr\n+\t     position.  And we use 'pop25 Re, fpr_space' to adjust $sp.  */\n+\t  int fpr_space = cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t\t\t  + cfun->machine->callee_saved_fpr_regs_size;\n+\t  nds32_emit_stack_v3pop (Rb, Re, fpr_space);\n+\t}\n+      else\n+\t{\n+\t  /* nds32_emit_stack_v3pop(last_regno, sp_adjust),\n+\t     the pattern 'stack_v3pop' is implementad in nds32.md.  */\n+\t  nds32_emit_stack_v3pop (Rb, Re, 0);\n+\t}\n     }\n-\n   /* Generate return instruction.  */\n   emit_jump_insn (gen_pop25return ());\n }\n@@ -3605,11 +4312,26 @@ nds32_expand_epilogue_v3pop (bool sibcall_p)\n int\n nds32_can_use_return_insn (void)\n {\n+  int sp_adjust;\n+\n   /* Prior to reloading, we can't tell how many registers must be saved.\n      Thus we can not determine whether this function has null epilogue.  */\n   if (!reload_completed)\n     return 0;\n \n+  sp_adjust = cfun->machine->local_size\n+\t      + cfun->machine->out_args_size\n+\t      + cfun->machine->callee_saved_area_gpr_padding_bytes\n+\t      + cfun->machine->callee_saved_fpr_regs_size;\n+  if (!cfun->machine->fp_as_gp_p\n+      && satisfies_constraint_Iu08 (GEN_INT (sp_adjust))\n+      && NDS32_DOUBLE_WORD_ALIGN_P (sp_adjust)\n+      && !cfun->calls_alloca\n+      && NDS32_V3PUSH_AVAILABLE_P\n+      && !(TARGET_HARD_FLOAT\n+\t   && (cfun->machine->callee_saved_first_fpr_regno != SP_REGNUM)))\n+    return 1;\n+\n   /* If no stack was created, two conditions must be satisfied:\n      1. This is a naked function.\n \tSo there is no callee-saved, local size, or outgoing size.\n@@ -3673,6 +4395,36 @@ nds32_adjust_insn_length (rtx_insn *insn, int length)\n   return length;\n }\n \n+bool\n+nds32_split_double_word_load_store_p(rtx *operands, bool load_p)\n+{\n+  rtx mem = load_p ? operands[1] : operands[0];\n+  /* Do split at split2 if -O0 or schedule 2 not enable.  */\n+  if (optimize == 0 || !flag_schedule_insns_after_reload)\n+    return !satisfies_constraint_Da (mem) || MEM_VOLATILE_P (mem);\n+\n+  /* Split double word load store after copy propgation.  */\n+  if (current_pass == NULL)\n+    return false;\n+\n+  const char *pass_name = current_pass->name;\n+  if (pass_name && ((strcmp (pass_name, \"split4\") == 0)\n+\t\t     || (strcmp (pass_name, \"split5\") == 0)))\n+    return !satisfies_constraint_Da (mem) || MEM_VOLATILE_P (mem);\n+\n+  return false;\n+}\n+\n+static bool\n+nds32_use_blocks_for_constant_p (machine_mode mode,\n+\t\t\t\t const_rtx x ATTRIBUTE_UNUSED)\n+{\n+  if ((TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE)\n+      && (mode == DFmode || mode == SFmode))\n+    return true;\n+  else\n+    return false;\n+}\n \n /* Return align 2 (log base 2) if the next instruction of LABEL is 4 byte.  */\n int\n@@ -3720,10 +4472,16 @@ nds32_target_alignment (rtx_insn *label)\n \n /* -- Basic Characteristics of Registers.  */\n \n+#undef TARGET_CONDITIONAL_REGISTER_USAGE\n+#define TARGET_CONDITIONAL_REGISTER_USAGE nds32_conditional_register_usage\n+\n /* -- Order of Allocation of Registers.  */\n \n /* -- How Values Fit in Registers.  */\n \n+#undef TARGET_HARD_REGNO_NREGS\n+#define TARGET_HARD_REGNO_NREGS nds32_hard_regno_nregs\n+\n /* -- Handling Leaf Functions.  */\n \n /* -- Registers That Form a Stack.  */\n@@ -3737,6 +4495,9 @@ nds32_target_alignment (rtx_insn *label)\n #undef TARGET_REGISTER_PRIORITY\n #define TARGET_REGISTER_PRIORITY nds32_register_priority\n \n+#undef TARGET_CAN_CHANGE_MODE_CLASS\n+#define TARGET_CAN_CHANGE_MODE_CLASS nds32_can_change_mode_class\n+\n \f\n /* Obsolete Macros for Defining Constraints.  */\n \n@@ -3788,6 +4549,9 @@ nds32_target_alignment (rtx_insn *label)\n \n /* -- How Large Values Are Returned.  */\n \n+#undef TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY nds32_return_in_memory\n+\n /* -- Caller-Saves Register Allocation.  */\n \n /* -- Function Entry and Exit.  */\n@@ -3931,6 +4695,9 @@ nds32_target_alignment (rtx_insn *label)\n \n /* -- Assembler Commands for Exception Regions.  */\n \n+#undef TARGET_DWARF_REGISTER_SPAN\n+#define TARGET_DWARF_REGISTER_SPAN nds32_dwarf_register_span\n+\n /* -- Assembler Commands for Alignment.  */\n \n \f\n@@ -4002,6 +4769,10 @@ nds32_target_alignment (rtx_insn *label)\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN nds32_expand_builtin\n \n+\n+#undef TARGET_USE_BLOCKS_FOR_CONSTANT_P\n+#define TARGET_USE_BLOCKS_FOR_CONSTANT_P nds32_use_blocks_for_constant_p\n+\n \f\n /* ------------------------------------------------------------------------ */\n "}, {"sha": "c1d389c7d61138a95a66c1497ed7b4ab87afae86", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 224, "deletions": 44, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -130,12 +130,15 @@ enum nds32_16bit_address_type\n \n /* Define maximum numbers of registers for passing arguments.  */\n #define NDS32_MAX_GPR_REGS_FOR_ARGS 6\n+#define NDS32_MAX_FPR_REGS_FOR_ARGS 6\n \n /* Define the register number for first argument.  */\n #define NDS32_GPR_ARG_FIRST_REGNUM 0\n+#define NDS32_FPR_ARG_FIRST_REGNUM 34\n \n /* Define the register number for return value.  */\n #define NDS32_GPR_RET_FIRST_REGNUM 0\n+#define NDS32_FPR_RET_FIRST_REGNUM 34\n \n /* Define the first integer register number.  */\n #define NDS32_FIRST_GPR_REGNUM 0\n@@ -146,6 +149,44 @@ enum nds32_16bit_address_type\n #define NDS32_LAST_CALLEE_SAVE_GPR_REGNUM \\\n   (TARGET_REDUCED_REGS ? 10 : 14)\n \n+/* Define the floating-point number of registers.  */\n+#define NDS32_FLOAT_REGISTER_NUMBER                           \\\n+ (((nds32_fp_regnum == NDS32_CONFIG_FPU_0)              \\\n+   || (nds32_fp_regnum == NDS32_CONFIG_FPU_4)) ? 8      \\\n+  : ((nds32_fp_regnum == NDS32_CONFIG_FPU_1)            \\\n+    || (nds32_fp_regnum == NDS32_CONFIG_FPU_5)) ? 16    \\\n+  : ((nds32_fp_regnum == NDS32_CONFIG_FPU_2)            \\\n+    || (nds32_fp_regnum == NDS32_CONFIG_FPU_6)) ? 32    \\\n+  : ((nds32_fp_regnum == NDS32_CONFIG_FPU_3)            \\\n+    || (nds32_fp_regnum == NDS32_CONFIG_FPU_7)) ? 64    \\\n+  : 32)\n+\n+#define NDS32_EXT_FPU_DOT_E (nds32_fp_regnum >= 4)\n+\n+/* Define the first floating-point register number.  */\n+#define NDS32_FIRST_FPR_REGNUM 34\n+/* Define the last floating-point register number.  */\n+#define NDS32_LAST_FPR_REGNUM \\\n+  (NDS32_FIRST_FPR_REGNUM + NDS32_FLOAT_REGISTER_NUMBER - 1)\n+\n+\n+#define NDS32_IS_EXT_FPR_REGNUM(regno) \\\n+  (((regno) >= NDS32_FIRST_FPR_REGNUM + 32) \\\n+   && ((regno) < NDS32_FIRST_FPR_REGNUM + 64))\n+\n+#define NDS32_IS_FPR_REGNUM(regno) \\\n+  (((regno) >= NDS32_FIRST_FPR_REGNUM) \\\n+   && ((regno) <= NDS32_LAST_FPR_REGNUM))\n+\n+#define NDS32_FPR_REGNO_OK_FOR_SINGLE(regno) \\\n+  ((regno) <= NDS32_LAST_FPR_REGNUM)\n+\n+#define NDS32_FPR_REGNO_OK_FOR_DOUBLE(regno) \\\n+  ((((regno) - NDS32_FIRST_FPR_REGNUM) & 1) == 0)\n+\n+#define NDS32_IS_GPR_REGNUM(regno) \\\n+  (((regno) <= NDS32_LAST_GPR_REGNUM))\n+\n /* Define double word alignment bits.  */\n #define NDS32_DOUBLE_WORD_ALIGNMENT 64\n \n@@ -189,21 +230,38 @@ enum nds32_16bit_address_type\n       : ((reg_offset) + NDS32_GPR_ARG_FIRST_REGNUM))               \\\n    : ((reg_offset) + NDS32_GPR_ARG_FIRST_REGNUM))\n \n-/* This macro is to check if there are still available registers\n+#define NDS32_AVAILABLE_REGNUM_FOR_FPR_ARG(reg_offset, mode, type) \\\n+  ((NDS32_NEED_N_REGS_FOR_ARG (mode, type) > 1)                    \\\n+   ? ((NDS32_MODE_TYPE_ALIGN (mode, type) > PARM_BOUNDARY)         \\\n+      ? (((reg_offset) + NDS32_FPR_ARG_FIRST_REGNUM + 1) & ~1)     \\\n+      : ((reg_offset) + NDS32_FPR_ARG_FIRST_REGNUM))               \\\n+   : ((reg_offset) + NDS32_FPR_ARG_FIRST_REGNUM))\n+\n+/* These two macros are to check if there are still available registers\n    for passing argument, which must be entirely in registers.  */\n #define NDS32_ARG_ENTIRE_IN_GPR_REG_P(reg_offset, mode, type)   \\\n   ((NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (reg_offset, mode, type) \\\n     + NDS32_NEED_N_REGS_FOR_ARG (mode, type))                   \\\n    <= (NDS32_GPR_ARG_FIRST_REGNUM                               \\\n        + NDS32_MAX_GPR_REGS_FOR_ARGS))\n \n-/* This macro is to check if there are still available registers\n+#define NDS32_ARG_ENTIRE_IN_FPR_REG_P(reg_offset, mode, type)   \\\n+  ((NDS32_AVAILABLE_REGNUM_FOR_FPR_ARG (reg_offset, mode, type) \\\n+    + NDS32_NEED_N_REGS_FOR_ARG (mode, type))                   \\\n+   <= (NDS32_FPR_ARG_FIRST_REGNUM                               \\\n+       + NDS32_MAX_FPR_REGS_FOR_ARGS))\n+\n+/* These two macros are to check if there are still available registers\n    for passing argument, either entirely in registers or partially\n    in registers.  */\n #define NDS32_ARG_PARTIAL_IN_GPR_REG_P(reg_offset, mode, type) \\\n   (NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (reg_offset, mode, type) \\\n    < NDS32_GPR_ARG_FIRST_REGNUM + NDS32_MAX_GPR_REGS_FOR_ARGS)\n \n+#define NDS32_ARG_PARTIAL_IN_FPR_REG_P(reg_offset, mode, type) \\\n+  (NDS32_AVAILABLE_REGNUM_FOR_FPR_ARG (reg_offset, mode, type) \\\n+   < NDS32_FPR_ARG_FIRST_REGNUM + NDS32_MAX_FPR_REGS_FOR_ARGS)\n+\n /* This macro is to check if the register is required to be saved on stack.\n    If call_used_regs[regno] == 0, regno is the callee-saved register.\n    If df_regs_ever_live_p(regno) == true, it is used in the current function.\n@@ -251,6 +309,10 @@ struct GTY(()) machine_function\n      callee-saved registers.  */\n   int callee_saved_gpr_regs_size;\n \n+  /* Number of bytes on the stack for saving floating-point\n+     callee-saved registers.  */\n+  int callee_saved_fpr_regs_size;\n+\n   /* The padding bytes in callee-saved area may be required.  */\n   int callee_saved_area_gpr_padding_bytes;\n \n@@ -259,6 +321,11 @@ struct GTY(()) machine_function\n   /* The last required general purpose callee-saved register.  */\n   int callee_saved_last_gpr_regno;\n \n+  /* The first required floating-point callee-saved register.  */\n+  int callee_saved_first_fpr_regno;\n+  /* The last required floating-point callee-saved register.  */\n+  int callee_saved_last_fpr_regno;\n+\n   /* The padding bytes in varargs area may be required.  */\n   int va_args_area_padding_bytes;\n \n@@ -279,6 +346,7 @@ struct GTY(()) machine_function\n typedef struct\n {\n   unsigned int gpr_offset;\n+  unsigned int fpr_offset;\n } nds32_cumulative_args;\n \n /* ------------------------------------------------------------------------ */\n@@ -390,7 +458,11 @@ enum nds32_builtins\n /* ------------------------------------------------------------------------ */\n \n #define TARGET_ISA_V2   (nds32_arch_option == ARCH_V2)\n-#define TARGET_ISA_V3   (nds32_arch_option == ARCH_V3)\n+\n+#define TARGET_ISA_V3 \\\n+  (nds32_arch_option == ARCH_V3 \\\n+   || nds32_arch_option == ARCH_V3F \\\n+   || nds32_arch_option == ARCH_V3S)\n #define TARGET_ISA_V3M  (nds32_arch_option == ARCH_V3M)\n \n #define TARGET_CMODEL_SMALL \\\n@@ -406,21 +478,60 @@ enum nds32_builtins\n    (nds32_cmodel_option == CMODEL_SMALL\\\n     || nds32_cmodel_option == CMODEL_MEDIUM)\n \n-#define TARGET_SOFT_FLOAT 1\n-#define TARGET_HARD_FLOAT 0\n \n+/* Run-time Target Specification.  */\n+#define TARGET_SOFT_FLOAT (nds32_abi == NDS32_ABI_V2)\n+/* Use hardware floating point calling convention.  */\n+#define TARGET_HARD_FLOAT (nds32_abi == NDS32_ABI_V2_FP_PLUS)\n+\n+/* Record arch version in TARGET_ARCH_DEFAULT. 0 means soft ABI,\n+   1 means  hard ABI and using full floating-point instruction,\n+   2 means hard ABI and only using single-precision floating-point\n+   instruction  */\n+#if TARGET_ARCH_DEFAULT == 1\n+#  define TARGET_DEFAULT_ABI NDS32_ABI_V2_FP_PLUS\n+#  define TARGET_DEFAULT_FPU_ISA MASK_FPU_DOUBLE | MASK_FPU_SINGLE\n+#  define TARGET_DEFAULT_FPU_FMA 0\n+#else\n+#  if TARGET_ARCH_DEFAULT == 2\n+#    define TARGET_DEFAULT_ABI NDS32_ABI_V2_FP_PLUS\n+#    define TARGET_DEFAULT_FPU_ISA MASK_FPU_SINGLE\n+#    define TARGET_DEFAULT_FPU_FMA 0\n+#  else\n+#    define TARGET_DEFAULT_ABI NDS32_ABI_V2\n+#    define TARGET_DEFAULT_FPU_ISA 0\n+#    define TARGET_DEFAULT_FPU_FMA 0\n+#  endif\n+#endif\n+\n+#define TARGET_CONFIG_FPU_DEFAULT NDS32_CONFIG_FPU_2\n /* ------------------------------------------------------------------------ */\n \f\n /* Controlling the Compilation Driver.  */\n \n #define OPTION_DEFAULT_SPECS \\\n-  {\"arch\", \"%{!march=*:-march=%(VALUE)}\" }\n+  {\"arch\", \" %{!march=*:-march=%(VALUE)}\" \\\n+\t   \" %{march=v3f:%{!mfloat-abi=*:-mfloat-abi=hard}\" \\\n+\t   \" %{!mno-ext-fpu-sp:%{!mext-fpu-sp:-mext-fpu-sp}}\" \\\n+\t   \" %{!mno-ext-fpu-dp:%{!mext-fpu-dp:-mext-fpu-dp}}}\" \\\n+\t   \" %{march=v3s:%{!mfloat-abi=*:-mfloat-abi=hard}\" \\\n+\t   \" %{!mno-ext-fpu-sp:%{!mext-fpu-sp:-mext-fpu-sp}}}\" }, \\\n+  {\"float\", \"%{!mfloat-abi=*:-mfloat-abi=%(VALUE)}\" }\n \n #define CC1_SPEC \\\n   \"\"\n \n #define ASM_SPEC \\\n-  \" %{mbig-endian:-EB} %{mlittle-endian:-EL}\"\n+  \" %{mbig-endian:-EB} %{mlittle-endian:-EL}\" \\\n+  \" %{march=*:-march=%*}\" \\\n+  \" %{mabi=*:-mabi=v%*}\" \\\n+  \" %{mconfig-fpu=*:-mfpu-freg=%*}\" \\\n+  \" %{mext-fpu-mac:-mmac}\" \\\n+  \" %{mno-ext-fpu-mac:-mno-mac}\" \\\n+  \" %{mext-fpu-sp:-mfpu-sp-ext}\" \\\n+  \" %{mno-ext-fpu-sp:-mno-fpu-sp-ext}\" \\\n+  \" %{mext-fpu-dp:-mfpu-dp-ext}\" \\\n+  \" %{mno-ext-fpu-sp:-mno-fpu-dp-ext}\"\n \n /* If user issues -mrelax, we need to pass '--relax' to linker.  */\n #define LINK_SPEC \\\n@@ -550,8 +661,8 @@ enum nds32_builtins\n    $r30 : $lp\n    $r31 : $sp\n \n-   caller-save registers: $r0 ~ $r5, $r16 ~ $r23\n-   callee-save registers: $r6 ~ $r10, $r11 ~ $r14\n+   caller-save registers: $r0 ~ $r5, $r16 ~ $r23, $fs0 ~ $fs5, $fs22 ~ $fs47\n+   callee-save registers: $r6 ~ $r10, $r11 ~ $r14, $fs6 ~ $fs21, $fs48 ~ $fs63\n \n    reserved for assembler : $r15\n    reserved for other use : $r24, $r25, $r26, $r27 */\n@@ -564,23 +675,23 @@ enum nds32_builtins\n       0,   0,   0,   0,   0,   0,   0,   0,     \\\n   /* r24  r25  r26  r27  r28  r29  r30  r31  */ \\\n       1,   1,   1,   1,   0,   1,   0,   1,     \\\n-  /* AP   FP    Reserved.................... */ \\\n+  /* AP   FP   fs0  fs1  fs2  fs3  fs4  fs5  */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fs6  fs7  fs8  fs9  fs10 fs11 fs12 fs13 */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fs14 fs15 fs16 fs17 fs18 fs19 fs20 fs21 */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fs22 fs23 fs24 fs25 fs26 fs27 fs28 fs29 */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fs30 fs31 fd16      fd17      fd18      */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fd19      fd20      fd21      fd22      */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fd23      fd24      fd25      fd26      */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fd27      fd28      fd29      fd30      */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fd31      Reserved..................... */ \\\n       1,   1,   1,   1,   1                     \\\n }\n \n@@ -599,23 +710,23 @@ enum nds32_builtins\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n   /* r24  r25  r26  r27  r28  r29  r30  r31  */ \\\n       1,   1,   1,   1,   0,   1,   0,   1,     \\\n-  /* AP   FP    Reserved.................... */ \\\n+  /* AP   FP   fs0  fs1  fs2  fs3  fs4  fs5  */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fs6  fs7  fs8  fs9  fs10 fs11 fs12 fs13 */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fs14 fs15 fs16 fs17 fs18 fs19 fs20 fs21 */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fs22 fs23 fs24 fs25 fs26 fs27 fs28 fs29 */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fs30 fs31 fd16      fd17      fd18      */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fd19      fd20      fd21      fd22      */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fd23      fd24      fd25      fd26      */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fd27      fd28      fd29      fd30      */ \\\n       1,   1,   1,   1,   1,   1,   1,   1,     \\\n-  /* Reserved............................... */ \\\n+  /* fd31      Reserved..................... */ \\\n       1,   1,   1,   1,   1                     \\\n }\n \n@@ -670,6 +781,7 @@ enum reg_class\n   HIGH_REGS,\n   GENERAL_REGS,\n   FRAME_REGS,\n+  FP_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n };\n@@ -689,6 +801,7 @@ enum reg_class\n   \"HIGH_REGS\",          \\\n   \"GENERAL_REGS\",       \\\n   \"FRAME_REGS\",         \\\n+  \"FP_REGS\",            \\\n   \"ALL_REGS\"            \\\n }\n \n@@ -715,6 +828,8 @@ enum reg_class\n   {0xffffffff, 0x00000000, 0x00000000, 0x00000000}, \\\n   /* FRAME_REGS          : 32, 33               */  \\\n   {0x00000000, 0x00000003, 0x00000000, 0x00000000}, \\\n+  /* FP_REGS             : 34-98                */  \\\n+  {0x00000000, 0xfffffffc, 0xffffffff, 0x00000003}, \\\n   /* ALL_REGS            : 0-100                */  \\\n   {0xffffffff, 0xffffffff, 0xffffffff, 0x0000001f}  \\\n }\n@@ -724,13 +839,18 @@ enum reg_class\n #define BASE_REG_CLASS GENERAL_REGS\n #define INDEX_REG_CLASS GENERAL_REGS\n \n+#define TEST_REGNO(R, TEST, VALUE) \\\n+  ((R TEST VALUE) || ((unsigned) reg_renumber[R] TEST VALUE))\n+\n /* Return nonzero if it is suitable for use as a\n    base register in operand addresses.\n    So far, we return nonzero only if \"num\" is a hard reg\n    of the suitable class or a pseudo register which is\n    allocated to a suitable hard reg.  */\n #define REGNO_OK_FOR_BASE_P(num) \\\n-  ((num) < 32 || (unsigned) reg_renumber[num] < 32)\n+  (TEST_REGNO (num, <, 32) \\\n+   || TEST_REGNO (num, ==, FRAME_POINTER_REGNUM) \\\n+   || TEST_REGNO (num, ==, ARG_POINTER_REGNUM))\n \n /* Return nonzero if it is suitable for use as a\n    index register in operand addresses.\n@@ -740,7 +860,9 @@ enum reg_class\n    The difference between an index register and a base register is that\n    the index register may be scaled.  */\n #define REGNO_OK_FOR_INDEX_P(num) \\\n-  ((num) < 32 || (unsigned) reg_renumber[num] < 32)\n+  (TEST_REGNO (num, <, 32) \\\n+   || TEST_REGNO (num, ==, FRAME_POINTER_REGNUM) \\\n+   || TEST_REGNO (num, ==, ARG_POINTER_REGNUM))\n \n \f\n /* Obsolete Macros for Defining Constraints.  */\n@@ -768,6 +890,8 @@ enum reg_class\n #define INCOMING_RETURN_ADDR_RTX    gen_rtx_REG (Pmode, LP_REGNUM)\n #define DWARF_FRAME_RETURN_COLUMN   DWARF_FRAME_REGNUM (LP_REGNUM)\n \n+#define DBX_REGISTER_NUMBER(REGNO) nds32_dbx_register_number (REGNO)\n+\n #define STACK_POINTER_REGNUM SP_REGNUM\n \n #define FRAME_POINTER_REGNUM 33\n@@ -796,12 +920,11 @@ enum reg_class\n #define INIT_CUMULATIVE_ARGS(cum, fntype, libname, fndecl, n_named_args) \\\n   nds32_init_cumulative_args (&cum, fntype, libname, fndecl, n_named_args)\n \n-/* The REGNO is an unsigned integer but NDS32_GPR_ARG_FIRST_REGNUM may be 0.\n-   We better cast REGNO into signed integer so that we can avoid\n-   'comparison of unsigned expression >= 0 is always true' warning.  */\n-#define FUNCTION_ARG_REGNO_P(regno)                                        \\\n-  (((int) regno - NDS32_GPR_ARG_FIRST_REGNUM >= 0)                         \\\n-   && ((int) regno - NDS32_GPR_ARG_FIRST_REGNUM < NDS32_MAX_GPR_REGS_FOR_ARGS))\n+#define FUNCTION_ARG_REGNO_P(regno)                                           \\\n+ (IN_RANGE ((regno), NDS32_FIRST_GPR_REGNUM, NDS32_MAX_GPR_REGS_FOR_ARGS - 1) \\\n+  || ((TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE)                                \\\n+      && IN_RANGE ((regno), NDS32_FPR_ARG_FIRST_REGNUM,                       \\\n+\t\t   NDS32_FIRST_FPR_REGNUM + NDS32_MAX_FPR_REGS_FOR_ARGS - 1)))\n \n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n@@ -944,15 +1067,72 @@ enum reg_class\n   \"$r8\",  \"$r9\",  \"$r10\", \"$r11\", \"$r12\", \"$r13\", \"$r14\", \"$ta\",  \\\n   \"$r16\", \"$r17\", \"$r18\", \"$r19\", \"$r20\", \"$r21\", \"$r22\", \"$r23\", \\\n   \"$r24\", \"$r25\", \"$r26\", \"$r27\", \"$fp\",  \"$gp\",  \"$lp\",  \"$sp\",  \\\n-  \"$AP\",  \"$SFP\", \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \\\n-  \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \\\n-  \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \\\n-  \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \\\n-  \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \\\n-  \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \\\n-  \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \\\n-  \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\",   \\\n-  \"NA\",   \"NA\",   \"NA\",   \"NA\",   \"NA\"                            \\\n+  \"$AP\",  \"$SFP\", \"$fs0\", \"$fs1\", \"$fs2\", \"$fs3\", \"$fs4\", \"$fs5\", \\\n+  \"$fs6\", \"$fs7\", \"$fs8\", \"$fs9\", \"$fs10\",\"$fs11\",\"$fs12\",\"$fs13\",\\\n+  \"$fs14\",\"$fs15\",\"$fs16\",\"$fs17\",\"$fs18\",\"$fs19\",\"$fs20\",\"$fs21\",\\\n+  \"$fs22\",\"$fs23\",\"$fs24\",\"$fs25\",\"$fs26\",\"$fs27\",\"$fs28\",\"$fs29\",\\\n+  \"$fs30\",\"$fs31\",\"$fs32\",\"$fs33\",\"$fs34\",\"$fs35\",\"$fs36\",\"$fs37\",\\\n+  \"$fs38\",\"$fs39\",\"$fs40\",\"$fs41\",\"$fs42\",\"$fs43\",\"$fs44\",\"$fs45\",\\\n+  \"$fs46\",\"$fs47\",\"$fs48\",\"$fs49\",\"$fs50\",\"$fs51\",\"$fs52\",\"$fs53\",\\\n+  \"$fs54\",\"$fs55\",\"$fs56\",\"$fs57\",\"$fs58\",\"$fs59\",\"$fs60\",\"$fs61\",\\\n+  \"$fs62\",\"$fs63\",   \"LB\",   \"LE\",   \"LC\"                         \\\n+}\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  {\"$r15\", 15},\t\t\t\t\t\t\t\\\n+  {\"$r28\", 28},\t{\"$r29\", 29},\t{\"$r30\", 30},\t{\"$r31\", 31},\t\\\n+  {\"$a0\", 0},\t{\"$a1\", 1},\t{\"$a2\", 2},\t\t\t\\\n+  {\"$a3\", 3},\t{\"$a4\", 4},\t{\"$a5\", 5},\t\t\t\\\n+  {\"$s0\", 6},\t{\"$s1\", 7},\t{\"$s2\", 8},\t{\"$s3\", 9},\t\\\n+  {\"$s4\", 10},\t{\"$s5\", 11},\t{\"$s6\", 12},\t{\"$s7\", 13},\t\\\n+  {\"$s8\", 14},\t\t\t\t\t\t\t\\\n+  {\"$t0\", 16},\t{\"$t1\", 17},\t{\"$t2\", 18},\t{\"$t3\", 19},\t\\\n+  {\"$t4\", 20},\t{\"$t5\", 21},\t{\"$t6\", 22},\t{\"$t7\", 23},\t\\\n+  {\"$t8\", 24},\t{\"$t9\", 25},\t\t\t\t\t\\\n+  {\"$p0\", 26},\t{\"$p1\", 27},\t\t\t\t\t\\\n+  {\"$h0\", 0},\t{\"$h1\", 1},\t{\"$h2\", 2},\t{\"$h3\", 3},\t\\\n+  {\"$h4\", 4},\t{\"$h5\", 5},\t{\"$h6\", 6},\t{\"$h7\", 7},\t\\\n+  {\"$h8\", 8},\t{\"$h9\", 9},\t{\"$h10\", 10},\t{\"$h11\", 11},\t\\\n+  {\"$h12\", 16},\t{\"$h13\", 17},\t{\"$h14\", 18},\t{\"$h15\", 19},\t\\\n+  {\"$o0\", 0},\t{\"$o1\", 1},\t{\"$o2\", 2},\t{\"$o3\", 3},\t\\\n+  {\"$o4\", 4},\t{\"$o5\", 5},\t{\"$o6\", 6},\t{\"$o7\", 7},\t\\\n+}\n+\n+#define OVERLAPPING_REGISTER_NAMES\t\t\\\n+{\t\t\t\t\t\t\\\n+  {\"$fd0\",  NDS32_FIRST_FPR_REGNUM + 0,  2},\t\\\n+  {\"$fd1\",  NDS32_FIRST_FPR_REGNUM + 2,  2},\t\\\n+  {\"$fd2\",  NDS32_FIRST_FPR_REGNUM + 4,  2},\t\\\n+  {\"$fd3\",  NDS32_FIRST_FPR_REGNUM + 6,  2},\t\\\n+  {\"$fd4\",  NDS32_FIRST_FPR_REGNUM + 8,  2},\t\\\n+  {\"$fd5\",  NDS32_FIRST_FPR_REGNUM + 10, 2},\t\\\n+  {\"$fd6\",  NDS32_FIRST_FPR_REGNUM + 12, 2},\t\\\n+  {\"$fd7\",  NDS32_FIRST_FPR_REGNUM + 14, 2},\t\\\n+  {\"$fd8\",  NDS32_FIRST_FPR_REGNUM + 16, 2},\t\\\n+  {\"$fd9\",  NDS32_FIRST_FPR_REGNUM + 18, 2},\t\\\n+  {\"$fd10\", NDS32_FIRST_FPR_REGNUM + 20, 2},\t\\\n+  {\"$fd11\", NDS32_FIRST_FPR_REGNUM + 22, 2},\t\\\n+  {\"$fd12\", NDS32_FIRST_FPR_REGNUM + 24, 2},\t\\\n+  {\"$fd13\", NDS32_FIRST_FPR_REGNUM + 26, 2},\t\\\n+  {\"$fd14\", NDS32_FIRST_FPR_REGNUM + 28, 2},\t\\\n+  {\"$fd15\", NDS32_FIRST_FPR_REGNUM + 30, 2},\t\\\n+  {\"$fd16\", NDS32_FIRST_FPR_REGNUM + 32, 2},\t\\\n+  {\"$fd17\", NDS32_FIRST_FPR_REGNUM + 34, 2},\t\\\n+  {\"$fd18\", NDS32_FIRST_FPR_REGNUM + 36, 2},\t\\\n+  {\"$fd19\", NDS32_FIRST_FPR_REGNUM + 38, 2},\t\\\n+  {\"$fd20\", NDS32_FIRST_FPR_REGNUM + 40, 2},\t\\\n+  {\"$fd21\", NDS32_FIRST_FPR_REGNUM + 42, 2},\t\\\n+  {\"$fd22\", NDS32_FIRST_FPR_REGNUM + 44, 2},\t\\\n+  {\"$fd23\", NDS32_FIRST_FPR_REGNUM + 46, 2},\t\\\n+  {\"$fd24\", NDS32_FIRST_FPR_REGNUM + 48, 2},\t\\\n+  {\"$fd25\", NDS32_FIRST_FPR_REGNUM + 50, 2},\t\\\n+  {\"$fd26\", NDS32_FIRST_FPR_REGNUM + 52, 2},\t\\\n+  {\"$fd27\", NDS32_FIRST_FPR_REGNUM + 54, 2},\t\\\n+  {\"$fd28\", NDS32_FIRST_FPR_REGNUM + 56, 2},\t\\\n+  {\"$fd29\", NDS32_FIRST_FPR_REGNUM + 58, 2},\t\\\n+  {\"$fd30\", NDS32_FIRST_FPR_REGNUM + 60, 2},\t\\\n+  {\"$fd31\", NDS32_FIRST_FPR_REGNUM + 62, 2},\t\\\n }\n \n /* Output normal jump table entry.  */"}, {"sha": "25ae3144a1fbe8d5b2f55fe2d6e253fcf50d39cf", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 108, "deletions": 6, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -46,13 +46,17 @@\n ;; Include DImode/DFmode operations.\n (include \"nds32-doubleword.md\")\n \n+;; Include floating-point patterns.\n+(include \"nds32-fpu.md\")\n+\n ;; Include peephole patterns.\n (include \"nds32-peephole2.md\")\n \n \n ;; Insn type, it is used to default other attribute values.\n (define_attr \"type\"\n-  \"unknown,load,store,load_multiple,store_multiple,alu,alu_shift,mul,mac,div,branch,call,misc\"\n+  \"unknown,load,store,load_multiple,store_multiple,alu,alu_shift,mul,mac,div,branch,call,misc,\\\n+   falu,fmuls,fmuld,fmacs,fmacd,fdivs,fdivd,fsqrts,fsqrtd,fcmp,fabs,fcpy,fcmov,fmfsr,fmfdr,fmtsr,fmtdr,fload,fstore\"\n   (const_string \"unknown\"))\n \n ;; Insn sub-type\n@@ -77,7 +81,7 @@\n ;; pe2 : Performance Extension Version 2 Instructions\n ;; se  : String Extension instructions\n (define_attr \"feature\"\n-  \"v1,v2,v3m,v3,pe1,pe2,se\"\n+  \"v1,v2,v3m,v3,pe1,pe2,se,fpu\"\n   (const_string \"v1\"))\n \n ;; Enabled, which is used to enable/disable insn alternatives.\n@@ -107,6 +111,9 @@\n \t\t\t\t\t\t    (const_string \"yes\")\n \t\t\t\t\t\t    (const_string \"no\"))\n \t   (eq_attr \"feature\" \"se\")   (if_then_else (match_test \"TARGET_EXT_STRING\")\n+\t\t\t\t\t\t    (const_string \"yes\")\n+\t\t\t\t\t\t    (const_string \"no\"))\n+\t   (eq_attr \"feature\" \"fpu\")  (if_then_else (match_test \"TARGET_FPU_SINGLE || TARGET_FPU_DOUBLE\")\n \t\t\t\t\t\t    (const_string \"yes\")\n \t\t\t\t\t\t    (const_string \"no\"))]\n \t   (const_string \"yes\"))))\n@@ -193,8 +200,8 @@\n })\n \n (define_insn \"*mov<mode>\"\n-  [(set (match_operand:QIHISI 0 \"nonimmediate_operand\" \"=r, r, U45, U33, U37, U45, m,   l,   l,   l,   d,   d, r,    d,    r,    r,    r\")\n-\t(match_operand:QIHISI 1 \"nds32_move_operand\"   \" r, r,   l,   l,   l,   d, r, U45, U33, U37, U45, Ufe, m, Ip05, Is05, Is20, Ihig\"))]\n+  [(set (match_operand:QIHISI 0 \"nonimmediate_operand\" \"=r, r,U45,U33,U37,U45, m,  l,  l,  l,  d,  d, r,   d,    r,    r,    r, *f, *f,  r, *f,  Q\")\n+\t(match_operand:QIHISI 1 \"nds32_move_operand\"   \" r, r,  l,  l,  l,  d, r,U45,U33,U37,U45,Ufe, m,Ip05, Is05, Is20, Ihig, *f,  r, *f,  Q, *f\"))]\n   \"register_operand(operands[0], <MODE>mode)\n    || register_operand(operands[1], <MODE>mode)\"\n {\n@@ -227,12 +234,26 @@\n       return \"movi\\t%0, %1\";\n     case 16:\n       return \"sethi\\t%0, hi20(%1)\";\n+    case 17:\n+      if (TARGET_FPU_SINGLE)\n+\treturn \"fcpyss\\t%0, %1, %1\";\n+      else\n+\treturn \"#\";\n+    case 18:\n+      return \"fmtsr\\t%1, %0\";\n+    case 19:\n+      return \"fmfsr\\t%0, %1\";\n+    case 20:\n+      return nds32_output_float_load (operands);\n+    case 21:\n+      return nds32_output_float_store (operands);\n     default:\n       gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\"   \"alu,alu,store,store,store,store,store,load,load,load,load,load,load,alu,alu,alu,alu\")\n-   (set_attr \"length\" \"  2,  4,    2,    2,    2,    2,    4,   2,   2,   2,   2,   2,   4,  2,  2,  4,  4\")])\n+  [(set_attr \"type\"    \"alu,alu,store,store,store,store,store,load,load,load,load,load,load,alu,alu,alu,alu,fcpy,fmtsr,fmfsr,fload,fstore\")\n+   (set_attr \"length\"  \"  2,  4,    2,    2,    2,    2,    4,   2,   2,   2,   2,   2,   4,  2,  2,  4,  4,   4,    4,    4,    4,     4\")\n+   (set_attr \"feature\" \" v1, v1,   v1,   v1,   v1,   v1,   v1,  v1,  v1,  v1,  v1, v3m,  v1, v1, v1, v1, v1, fpu,  fpu,  fpu,  fpu,   fpu\")])\n \n \n ;; We use nds32_symbolic_operand to limit that only CONST/SYMBOL_REF/LABEL_REF\n@@ -804,6 +825,87 @@\n    (set_attr \"length\"  \"  2,  4\")\n    (set_attr \"feature\" \"v3m, v1\")])\n \n+(define_expand \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!TARGET_FPU_SINGLE && !TARGET_EXT_PERF)\n+    {\n+      rtx new_dst = simplify_gen_subreg (SImode, operands[0], SFmode, 0);\n+      rtx new_src = simplify_gen_subreg (SImode, operands[1], SFmode, 0);\n+\n+      emit_insn (gen_xorsi3 (new_dst,\n+\t\t\t     new_src,\n+\t\t\t     gen_int_mode (0x80000000, SImode)));\n+\n+      DONE;\n+    }\n+})\n+\n+(define_expand \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"\"\n+{\n+})\n+\n+(define_insn_and_split \"soft_negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(neg:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  \"!TARGET_FPU_DOUBLE\"\n+  \"#\"\n+  \"!TARGET_FPU_DOUBLE\"\n+  [(const_int 1)]\n+{\n+    rtx src = operands[1];\n+    rtx dst = operands[0];\n+    rtx ori_dst = operands[0];\n+\n+    bool need_extra_move_for_dst_p;\n+    /* FPU register can't change mode to SI directly, so we need create a\n+       tmp register to handle it, and FPU register can't do `xor` or btgl.  */\n+    if (HARD_REGISTER_P (src)\n+\t&& TEST_HARD_REG_BIT (reg_class_contents[FP_REGS], REGNO (src)))\n+      {\n+\trtx tmp = gen_reg_rtx (DFmode);\n+\temit_move_insn (tmp, src);\n+\tsrc = tmp;\n+      }\n+\n+    if (HARD_REGISTER_P (dst)\n+\t&& TEST_HARD_REG_BIT (reg_class_contents[FP_REGS], REGNO (dst)))\n+      {\n+\tneed_extra_move_for_dst_p = true;\n+\trtx tmp = gen_reg_rtx (DFmode);\n+\tdst = tmp;\n+      }\n+\n+    rtx dst_high_part = simplify_gen_subreg (\n+\t\t\t  SImode, dst,\n+\t\t\t  DFmode, subreg_highpart_offset (SImode, DFmode));\n+    rtx dst_low_part = simplify_gen_subreg (\n+\t\t\t  SImode, dst,\n+\t\t\t  DFmode, subreg_lowpart_offset (SImode, DFmode));\n+    rtx src_high_part = simplify_gen_subreg (\n+\t\t\t  SImode, src,\n+\t\t\t  DFmode, subreg_highpart_offset (SImode, DFmode));\n+    rtx src_low_part = simplify_gen_subreg (\n+\t\t\t  SImode, src,\n+\t\t\t  DFmode, subreg_lowpart_offset (SImode, DFmode));\n+\n+    emit_insn (gen_xorsi3 (dst_high_part,\n+\t\t\t   src_high_part,\n+\t\t\t   gen_int_mode (0x80000000, SImode)));\n+    emit_move_insn (dst_low_part, src_low_part);\n+\n+    if (need_extra_move_for_dst_p)\n+      emit_move_insn (ori_dst, dst);\n+\n+    DONE;\n+})\n+\n+\n ;; ----------------------------------------------------------------------------\n ;; 'ONE_COMPLIMENT' operation\n ;; ----------------------------------------------------------------------------"}, {"sha": "bb2bbce18eb62b6c4d4bae12fb78b2276e4fa2fa", "filename": "gcc/config/nds32/nds32.opt", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.opt?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -32,6 +32,31 @@ EL\n Target RejectNegative Alias(mlittle-endian)\n Generate code in little-endian mode.\n \n+\n+; ---------------------------------------------------------------\n+\n+mabi=\n+Target RejectNegative Joined Enum(abi_type) Var(nds32_abi) Init(TARGET_DEFAULT_ABI)\n+Specify which ABI type to generate code for: 2, 2fp+.\n+\n+Enum\n+Name(abi_type) Type(enum abi_type)\n+Known ABIs (for use with the -mabi= option):\n+\n+EnumValue\n+Enum(abi_type) String(2) Value(NDS32_ABI_V2)\n+\n+EnumValue\n+Enum(abi_type) String(2fp+) Value(NDS32_ABI_V2_FP_PLUS)\n+\n+mfloat-abi=soft\n+Target RejectNegative Alias(mabi=, 2)\n+Specify use soft floating point ABI which mean alias to -mabi=2.\n+\n+mfloat-abi=hard\n+Target RejectNegative Alias(mabi=, 2fp+)\n+Specify use soft floating point ABI which mean alias to -mabi=2fp+.\n+\n ; ---------------------------------------------------------------\n \n mreduced-regs\n@@ -110,6 +135,12 @@ Enum(nds32_arch_type) String(v3) Value(ARCH_V3)\n EnumValue\n Enum(nds32_arch_type) String(v3m) Value(ARCH_V3M)\n \n+EnumValue\n+Enum(nds32_arch_type) String(v3f) Value(ARCH_V3F)\n+\n+EnumValue\n+Enum(nds32_arch_type) String(v3s) Value(ARCH_V3S)\n+\n mcmodel=\n Target RejectNegative Joined Enum(nds32_cmodel_type) Var(nds32_cmodel_option) Init(CMODEL_LARGE)\n Specify the address generation strategy for code model.\n@@ -138,10 +169,54 @@ Known cpu types (for use with the -mcpu= option):\n EnumValue\n Enum(nds32_cpu_type) String(n9) Value(CPU_N9)\n \n+mconfig-fpu=\n+Target RejectNegative Joined Enum(float_reg_number) Var(nds32_fp_regnum) Init(TARGET_CONFIG_FPU_DEFAULT)\n+Specify a fpu configuration value from 0 to 7; 0-3 is as FPU spec says, and 4-7 is corresponding to 0-3.\n+\n+Enum\n+Name(float_reg_number) Type(enum float_reg_number)\n+Known floating-point number of registers (for use with the -mconfig-fpu= option):\n+\n+EnumValue\n+Enum(float_reg_number) String(0) Value(NDS32_CONFIG_FPU_0)\n+\n+EnumValue\n+Enum(float_reg_number) String(1) Value(NDS32_CONFIG_FPU_1)\n+\n+EnumValue\n+Enum(float_reg_number) String(2) Value(NDS32_CONFIG_FPU_2)\n+\n+EnumValue\n+Enum(float_reg_number) String(3) Value(NDS32_CONFIG_FPU_3)\n+\n+EnumValue\n+Enum(float_reg_number) String(4) Value(NDS32_CONFIG_FPU_4)\n+\n+EnumValue\n+Enum(float_reg_number) String(5) Value(NDS32_CONFIG_FPU_5)\n+\n+EnumValue\n+Enum(float_reg_number) String(6) Value(NDS32_CONFIG_FPU_6)\n+\n+EnumValue\n+Enum(float_reg_number) String(7) Value(NDS32_CONFIG_FPU_7)\n+\n mctor-dtor\n Target Report\n Enable constructor/destructor feature.\n \n mrelax\n Target Report\n Guide linker to relax instructions.\n+\n+mext-fpu-fma\n+Target Report Mask(EXT_FPU_FMA)\n+Generate floating-point multiply-accumulation instructions.\n+\n+mext-fpu-sp\n+Target Report Mask(FPU_SINGLE)\n+Generate single-precision floating-point instructions.\n+\n+mext-fpu-dp\n+Target Report Mask(FPU_DOUBLE)\n+Generate double-precision floating-point instructions."}, {"sha": "9eb84685514569dc893cf274d97a9947e294e4d3", "filename": "gcc/config/nds32/predicates.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e22862689667e739d308140d72e8cc85ed116a2f/gcc%2Fconfig%2Fnds32%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fpredicates.md?ref=e22862689667e739d308140d72e8cc85ed116a2f", "patch": "@@ -24,12 +24,21 @@\n (define_predicate \"nds32_greater_less_comparison_operator\"\n   (match_code \"gt,ge,lt,le\"))\n \n+(define_predicate \"nds32_float_comparison_operator\"\n+  (match_code \"eq,ne,le,lt,ge,gt,ordered,unordered,ungt,unge,unlt,unle\"))\n+\n (define_predicate \"nds32_movecc_comparison_operator\"\n   (match_code \"eq,ne,le,leu,ge,geu\"))\n \n (define_special_predicate \"nds32_logical_binary_operator\"\n   (match_code \"and,ior,xor\"))\n \n+(define_special_predicate \"nds32_conditional_call_comparison_operator\"\n+  (match_code \"lt,ge\"))\n+\n+(define_special_predicate \"nds32_have_33_inst_operator\"\n+  (match_code \"mult,and,ior,xor\"))\n+\n (define_predicate \"nds32_symbolic_operand\"\n   (match_code \"const,symbol_ref,label_ref\"))\n \n@@ -122,6 +131,18 @@\n   (and (match_code \"mem\")\n        (match_test \"nds32_valid_smw_lwm_base_p (op)\")))\n \n+(define_predicate \"float_even_register_operand\"\n+  (and (match_code \"reg\")\n+       (and (match_test \"REGNO (op) >= NDS32_FIRST_FPR_REGNUM\")\n+\t    (match_test \"REGNO (op) <= NDS32_LAST_FPR_REGNUM\")\n+\t    (match_test \"(REGNO (op) & 1) == 0\"))))\n+\n+(define_predicate \"float_odd_register_operand\"\n+  (and (match_code \"reg\")\n+       (and (match_test \"REGNO (op) >= NDS32_FIRST_FPR_REGNUM\")\n+\t    (match_test \"REGNO (op) <= NDS32_LAST_FPR_REGNUM\")\n+\t    (match_test \"(REGNO (op) & 1) != 0\"))))\n+\n (define_special_predicate \"nds32_load_multiple_operation\"\n   (match_code \"parallel\")\n {"}]}