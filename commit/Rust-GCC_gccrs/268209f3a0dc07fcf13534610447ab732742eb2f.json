{"sha": "268209f3a0dc07fcf13534610447ab732742eb2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY4MjA5ZjNhMGRjMDdmY2YxMzUzNDYxMDQ0N2FiNzMyNzQyZWIyZg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-12-05T01:28:11Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-12-05T01:28:11Z"}, "message": "PR middle-end/91582 - missing heap overflow detection for strcpy\n\ngcc/ChangeLog:\n\n\tPR middle-end/91582\n\t* builtins.c (gimple_call_alloc_size): New function.\n\t(compute_objsize): Add argument.  Call gimple_call_alloc_size.\n\tHandle variable offsets and indices.\n\t* builtins.h (gimple_call_alloc_size): Declare.\n\t(compute_objsize): Add argument.\n\t* gcc/gimple-ssa-warn-restrict.c: Remove assertions.\n\t* tree-ssa-strlen.c (handle_store): Handle calls to allocated objects.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/91582\n\t* c-c++-common/Wstringop-truncation.c: Remove xfails.\n\t* g++.dg/warn/Wstringop-overflow-4.C: New test.\n\t* g++.dg/ext/attr-alloc_size.C: Suppress -Warray-bounds.\n\t* gcc.dg/Warray-bounds-56.c: New test.\n\t* gcc.dg/Wstringop-overflow-22.c: New test.\n\t* gcc.dg/attr-alloc_size.c: Suppress -Warray-bounds.\n\t* gcc.dg/attr-copy-2.c: Same.\n\t* gcc.dg/builtin-stringop-chk-5.c: Remove xfails.\n\t* gcc.dg/builtin-stringop-chk-8.c: Same.  Correct the text of expected\n\twarnings.\n\t* gcc.target/i386/pr82002-2a.c: Prune expected warning.\n\t* gcc.target/i386/pr82002-2b.c: Same.\n\nFrom-SVN: r278983", "tree": {"sha": "19c70c9ade74615720a40b206b35dcfc02c63f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19c70c9ade74615720a40b206b35dcfc02c63f53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/268209f3a0dc07fcf13534610447ab732742eb2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268209f3a0dc07fcf13534610447ab732742eb2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/268209f3a0dc07fcf13534610447ab732742eb2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/268209f3a0dc07fcf13534610447ab732742eb2f/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a59c50bd14f5bcb467a21ceb55f6b082510efc2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a59c50bd14f5bcb467a21ceb55f6b082510efc2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a59c50bd14f5bcb467a21ceb55f6b082510efc2f"}], "stats": {"total": 935, "additions": 895, "deletions": 40}, "files": [{"sha": "7f44667ab218b2f509b80aad3d14515bb65b94e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -1,3 +1,14 @@\n+2019-12-03  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91582\n+\t* builtins.c (gimple_call_alloc_size): New function.\n+\t(compute_objsize): Add argument.  Call gimple_call_alloc_size.\n+\tHandle variable offsets and indices.\n+\t* builtins.h (gimple_call_alloc_size): Declare.\n+\t(compute_objsize): Add argument.\n+\t* gcc/gimple-ssa-warn-restrict.c: Remove assertions.\n+\t* tree-ssa-strlen.c (handle_store): Handle calls to allocated objects.\n+\n 2019-12-04  Julian Brown  <julian@codesourcery.com>\n \n \t* config/gcn/gcn.h (FIXED_REGISTERS): Make s6/s7 fixed registers."}, {"sha": "53de17c105f996926add6fb4da549a87fdcd6145", "filename": "gcc/builtins.c", "status": "modified", "additions": 210, "deletions": 20, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -3696,6 +3696,97 @@ check_access (tree exp, tree, tree, tree dstwrite,\n   return true;\n }\n \n+/* If STMT is a call to an allocation function, returns the size\n+   of the object allocated by the call.  */\n+\n+tree\n+gimple_call_alloc_size (gimple *stmt)\n+{\n+  if (!stmt)\n+    return NULL_TREE;\n+\n+  tree allocfntype;\n+  if (tree fndecl = gimple_call_fndecl (stmt))\n+    allocfntype = TREE_TYPE (fndecl);\n+  else\n+    allocfntype = gimple_call_fntype (stmt);\n+\n+  if (!allocfntype)\n+    return NULL_TREE;\n+\n+  unsigned argidx1 = UINT_MAX, argidx2 = UINT_MAX;\n+  tree at = lookup_attribute (\"alloc_size\", TYPE_ATTRIBUTES (allocfntype));\n+  if (!at)\n+    {\n+      if (!gimple_call_builtin_p (stmt, BUILT_IN_ALLOCA_WITH_ALIGN))\n+\treturn NULL_TREE;\n+\n+      argidx1 = 0;\n+    }\n+\n+  unsigned nargs = gimple_call_num_args (stmt);\n+\n+  if (argidx1 == UINT_MAX)\n+    {\n+      tree atval = TREE_VALUE (at);\n+      if (!atval)\n+\treturn NULL_TREE;\n+\n+      argidx1 = TREE_INT_CST_LOW (TREE_VALUE (atval)) - 1;\n+      if (nargs <= argidx1)\n+\treturn NULL_TREE;\n+\n+      atval = TREE_CHAIN (atval);\n+      if (atval)\n+\t{\n+\t  argidx2 = TREE_INT_CST_LOW (TREE_VALUE (atval)) - 1;\n+\t  if (nargs <= argidx2)\n+\t    return NULL_TREE;\n+\t}\n+    }\n+\n+  tree size = gimple_call_arg (stmt, argidx1);\n+\n+  wide_int rng1[2];\n+  if (TREE_CODE (size) == INTEGER_CST)\n+    rng1[0] = rng1[1] = wi::to_wide (size);\n+  else if (TREE_CODE (size) != SSA_NAME\n+\t   || get_range_info (size, rng1, rng1 + 1) != VR_RANGE)\n+    return NULL_TREE;\n+\n+  if (argidx2 > nargs && TREE_CODE (size) == INTEGER_CST)\n+    return size;\n+\n+  /* To handle ranges do the math in wide_int and return the product\n+     of the upper bounds as a constant.  Ignore anti-ranges.  */\n+  tree n = argidx2 < nargs ? gimple_call_arg (stmt, argidx2) : integer_one_node;\n+  wide_int rng2[2];\n+  if (TREE_CODE (n) == INTEGER_CST)\n+    rng2[0] = rng2[1] = wi::to_wide (n);\n+  else if (TREE_CODE (n) != SSA_NAME\n+\t   || get_range_info (n, rng2, rng2 + 1) != VR_RANGE)\n+    return NULL_TREE;\n+\n+  /* Extend to the maximum precsion to avoid overflow.  */\n+  const int prec = ADDR_MAX_PRECISION;\n+  rng1[0] = wide_int::from (rng1[0], prec, UNSIGNED);\n+  rng1[1] = wide_int::from (rng1[1], prec, UNSIGNED);\n+  rng2[0] = wide_int::from (rng2[0], prec, UNSIGNED);\n+  rng2[1] = wide_int::from (rng2[1], prec, UNSIGNED);\n+\n+  /* Return the lesser of SIZE_MAX and the product of the upper bounds.  */\n+  rng1[0] = rng1[0] * rng2[0];\n+  rng1[1] = rng1[1] * rng2[1];\n+  tree size_max = TYPE_MAX_VALUE (sizetype);\n+  if (wi::gtu_p (rng1[1], wi::to_wide (size_max, prec)))\n+    {\n+      rng1[1] = wi::to_wide (size_max);\n+      return size_max;\n+    }\n+\n+  return wide_int_to_tree (sizetype, rng1[1]);\n+}\n+\n /* Helper to compute the size of the object referenced by the DEST\n    expression which must have pointer type, using Object Size type\n    OSTYPE (only the least significant 2 bits are used).  Return\n@@ -3704,16 +3795,22 @@ check_access (tree exp, tree, tree, tree dstwrite,\n    a non-constant offset in some range the returned value represents\n    the largest size given the smallest non-negative offset in the\n    range.  If nonnull, set *PDECL to the decl of the referenced\n-   subobject if it can be determined, or to null otherwise.\n+   subobject if it can be determined, or to null otherwise.  Likewise,\n+   when POFF is nonnull *POFF is set to the offset into *PDECL.\n    The function is intended for diagnostics and should not be used\n    to influence code generation or optimization.  */\n \n tree\n-compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */)\n+compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n+\t\t tree *poff /* = NULL */)\n {\n-  tree dummy = NULL_TREE;\n+  tree dummy_decl = NULL_TREE;\n   if (!pdecl)\n-    pdecl = &dummy;\n+    pdecl = &dummy_decl;\n+\n+  tree dummy_off = size_zero_node;\n+  if (!poff)\n+    poff = &dummy_off;\n \n   unsigned HOST_WIDE_INT size;\n \n@@ -3726,6 +3823,13 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */)\n   if (TREE_CODE (dest) == SSA_NAME)\n     {\n       gimple *stmt = SSA_NAME_DEF_STMT (dest);\n+      if (is_gimple_call (stmt))\n+\t{\n+\t  /* If STMT is a call to an allocation function get the size\n+\t     from its argument(s).  */\n+\t  return gimple_call_alloc_size (stmt);\n+\t}\n+\n       if (!is_gimple_assign (stmt))\n \treturn NULL_TREE;\n \n@@ -3741,7 +3845,7 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */)\n \t  tree off = gimple_assign_rhs2 (stmt);\n \t  if (TREE_CODE (off) == INTEGER_CST)\n \t    {\n-\t      if (tree size = compute_objsize (dest, ostype, pdecl))\n+\t      if (tree size = compute_objsize (dest, ostype, pdecl, poff))\n \t\t{\n \t\t  wide_int wioff = wi::to_wide (off);\n \t\t  wide_int wisiz = wi::to_wide (size);\n@@ -3752,10 +3856,16 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */)\n \t\t  if (wi::sign_mask (wioff))\n \t\t    ;\n \t\t  else if (wi::ltu_p (wioff, wisiz))\n-\t\t    return wide_int_to_tree (TREE_TYPE (size),\n-\t\t\t\t\t     wi::sub (wisiz, wioff));\n+\t\t    {\n+\t\t      *poff = size_binop (PLUS_EXPR, *poff, off);\n+\t\t      return wide_int_to_tree (TREE_TYPE (size),\n+\t\t\t\t\t       wi::sub (wisiz, wioff));\n+\t\t    }\n \t\t  else\n-\t\t    return size_zero_node;\n+\t\t    {\n+\t\t      *poff = size_binop (PLUS_EXPR, *poff, off);\n+\t\t      return size_zero_node;\n+\t\t    }\n \t\t}\n \t    }\n \t  else if (TREE_CODE (off) == SSA_NAME\n@@ -3777,10 +3887,18 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */)\n \t\t\t  || wi::sign_mask (max))\n \t\t\t;\n \t\t      else if (wi::ltu_p (min, wisiz))\n-\t\t\treturn wide_int_to_tree (TREE_TYPE (size),\n-\t\t\t\t\t\t wi::sub (wisiz, min));\n+\t\t\t{\n+\t\t\t  *poff = size_binop (PLUS_EXPR, *poff,\n+\t\t\t\t\t      wide_int_to_tree (sizetype, min));\n+\t\t\t  return wide_int_to_tree (TREE_TYPE (size),\n+\t\t\t\t\t\t   wi::sub (wisiz, min));\n+\t\t\t}\n \t\t      else\n-\t\t\treturn size_zero_node;\n+\t\t\t{\n+\t\t\t  *poff = size_binop (PLUS_EXPR, *poff,\n+\t\t\t\t\t      wide_int_to_tree (sizetype, min));\n+\t\t\t  return size_zero_node;\n+\t\t\t}\n \t\t    }\n \t\t}\n \t    }\n@@ -3799,19 +3917,24 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */)\n     {\n       tree ref = TREE_OPERAND (dest, 0);\n       tree off = TREE_OPERAND (dest, 1);\n-      if (tree size = compute_objsize (ref, ostype, pdecl))\n+      if (tree size = compute_objsize (ref, ostype, pdecl, poff))\n \t{\n \t  /* If the declaration of the destination object is known\n \t     to have zero size, return zero.  */\n-\t  if (integer_zerop (size))\n+\t  if (integer_zerop (size)\n+\t      && *pdecl && DECL_P (*pdecl)\n+\t      && *poff && integer_zerop (*poff))\n \t    return integer_zero_node;\n \n-\t  if (TREE_CODE (off) != INTEGER_CST\n-\t      || TREE_CODE (size) != INTEGER_CST)\n-\t    return NULL_TREE;\n+\t  /* A valid offset into a declared object cannot be negative.  */\n+\t  if (tree_int_cst_sgn (*poff) < 0)\n+\t    return size_zero_node;\n \n+\t  /* Adjust SIZE either up or down by the sum of *POFF and OFF\n+\t     above.  */\n \t  if (TREE_CODE (dest) == ARRAY_REF)\n \t    {\n+\t      /* Convert the array index into a byte offset.  */\n \t      tree eltype = TREE_TYPE (dest);\n \t      tree tpsize = TYPE_SIZE_UNIT (eltype);\n \t      if (tpsize && TREE_CODE (tpsize) == INTEGER_CST)\n@@ -3820,9 +3943,74 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */)\n \t\treturn NULL_TREE;\n \t    }\n \n-\t  if (tree_int_cst_lt (off, size))\n-\t    return fold_build2 (MINUS_EXPR, size_type_node, size, off);\n-\t  return integer_zero_node;\n+\t  wide_int offrng[2];\n+\t  if (TREE_CODE (off) == INTEGER_CST)\n+\t    offrng[0] = offrng[1] = wi::to_wide (off);\n+\t  else if (TREE_CODE (off) == SSA_NAME)\n+\t    {\n+\t      wide_int min, max;\n+\t      enum value_range_kind rng\n+\t\t= get_range_info (off, offrng, offrng + 1);\n+\t      if (rng != VR_RANGE)\n+\t\treturn NULL_TREE;\n+\t    }\n+\t  else\n+\t    return NULL_TREE;\n+\n+\t  /* Convert to the same precision to keep wide_int from \"helpfuly\"\n+\t     crashing whenever it sees other argumments.  */\n+\t  offrng[0] = wide_int::from (offrng[0], ADDR_MAX_BITSIZE, SIGNED);\n+\t  offrng[1] = wide_int::from (offrng[1], ADDR_MAX_BITSIZE, SIGNED);\n+\n+\t  tree dstoff = *poff;\n+\t  if (integer_zerop (*poff))\n+\t    *poff = off;\n+\t  else if (!integer_zerop (off))\n+\t    {\n+\t      *poff = fold_convert (ptrdiff_type_node, *poff);\n+\t      off = fold_convert (ptrdiff_type_node, off);\n+\t      *poff = size_binop (PLUS_EXPR, *poff, off);\n+\t    }\n+\n+\t  if (wi::sign_mask (offrng[0]) >= 0)\n+\t    {\n+\t      if (TREE_CODE (size) != INTEGER_CST)\n+\t\treturn NULL_TREE;\n+\n+\t      /* Return the difference between the size and the offset\n+\t\t or zero if the offset is greater.  */\n+\t      wide_int wisize = wi::to_wide (size, ADDR_MAX_BITSIZE);\n+\t      if (wi::ltu_p (wisize, offrng[0]))\n+\t\treturn size_zero_node;\n+\n+\t      return wide_int_to_tree (sizetype, wisize - offrng[0]);\n+\t    }\n+\n+\t  wide_int dstoffrng[2];\n+\t  if (TREE_CODE (dstoff) == INTEGER_CST)\n+\t    dstoffrng[0] = dstoffrng[1] = wi::to_wide (dstoff);\n+\t  else if (TREE_CODE (dstoff) == SSA_NAME)\n+\t    {\n+\t      enum value_range_kind rng\n+\t\t= get_range_info (dstoff, dstoffrng, dstoffrng + 1);\n+\t      if (rng != VR_RANGE)\n+\t\treturn NULL_TREE;\n+\t    }\n+\t  else\n+\t    return NULL_TREE;\n+\n+\t  dstoffrng[0] = wide_int::from (dstoffrng[0], ADDR_MAX_BITSIZE, SIGNED);\n+\t  dstoffrng[1] = wide_int::from (dstoffrng[1], ADDR_MAX_BITSIZE, SIGNED);\n+\n+\t  wide_int declsize = wi::to_wide (size);\n+\t  if (wi::sign_mask (dstoffrng[0]) > 0)\n+\t    declsize += dstoffrng[0];\n+\n+\t  offrng[1] += dstoffrng[1];\n+\t  if (wi::sign_mask (offrng[1]) < 0)\n+\t    return size_zero_node;\n+\n+\t  return wide_int_to_tree (sizetype, declsize);\n \t}\n \n       return NULL_TREE;\n@@ -3850,9 +4038,11 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */)\n     type = TREE_TYPE (type);\n \n   type = TYPE_MAIN_VARIANT (type);\n+  if (TREE_CODE (dest) == ADDR_EXPR)\n+    dest = TREE_OPERAND (dest, 0);\n \n   if (TREE_CODE (type) == ARRAY_TYPE\n-      && !array_at_struct_end_p (ref))\n+      && !array_at_struct_end_p (dest))\n     {\n       if (tree size = TYPE_SIZE_UNIT (type))\n \treturn TREE_CODE (size) == INTEGER_CST ? size : NULL_TREE;"}, {"sha": "0fcccc12a3947a1aaf05e7e01fd040092f2bd354", "filename": "gcc/builtins.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -133,7 +133,8 @@ extern tree fold_call_stmt (gcall *, bool);\n extern void set_builtin_user_assembler_name (tree decl, const char *asmspec);\n extern bool is_simple_builtin (tree);\n extern bool is_inexpensive_builtin (tree);\n-extern tree compute_objsize (tree, int, tree * = NULL);\n+extern tree gimple_call_alloc_size (gimple *);\n+extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL);\n \n extern bool readonly_data_expr (tree exp);\n extern bool init_target_chars (void);"}, {"sha": "9b5d1d795991651ea4080454f4a49b38d17b99d6", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -966,7 +966,6 @@ builtin_access::generic_overlap ()\n   const offset_int maxobjsize = acs.dstref->maxobjsize;\n \n   offset_int maxsize = dstref->basesize < 0 ? maxobjsize : dstref->basesize;\n-  gcc_assert (maxsize <= maxobjsize);\n \n   /* Adjust the larger bounds of the offsets (which may be the first\n      element if the lower bound is larger than the upper bound) to\n@@ -1193,7 +1192,6 @@ builtin_access::strcat_overlap ()\n   acs.dstsiz[1] = 1;\n \n   offset_int maxsize = dstref->basesize < 0 ? maxobjsize : dstref->basesize;\n-  gcc_assert (maxsize <= maxobjsize);\n \n   /* For references to the same base object, determine if there's a pair\n      of valid offsets into the two references such that access between"}, {"sha": "477a3b23a8f9e91b4f956ea78b4d482b504000dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -1,3 +1,18 @@\n+2019-12-03  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91582\n+\t* c-c++-common/Wstringop-truncation.c: Remove xfails.\n+\t* g++.dg/warn/Wstringop-overflow-4.C: New test.\n+\t* gcc/testsuite/g++.dg/ext/attr-alloc_size.C: Suppress -Warray-bounds.\n+\t* gcc.dg/Wstringop-overflow-25.c: New test.\n+\t* gcc/testsuite/gcc.dg/attr-alloc_size.c: Suppress -Warray-bounds.\n+\t* gcc/testsuite/gcc.dg/attr-copy-2.c: Same.\n+\t* gcc.dg/builtin-stringop-chk-5.c: Remove xfails.\n+\t* gcc.dg/builtin-stringop-chk-8.c: Same.  Correct the text of expected\n+\twarnings.\n+\t* gcc.target/i386/pr82002-2a.c: Prune expected warning.\n+\t* gcc.target/i386/pr82002-2b.c: Same.\n+\n 2019-12-04  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/36941"}, {"sha": "592a9494ca4c392b1ca9729100b1aca2fc73b3c5", "filename": "gcc/testsuite/c-c++-common/Wstringop-truncation.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -425,7 +425,7 @@ void test_strncpy_alloc (const char* s)\n   size_t n = 7;\n   char *d = (char *)__builtin_malloc (n);\n \n-  CPY (d, s, n);                    /* { dg-warning \"specified bound 7 equals destination size\" \"bug 79016\" { xfail *-*-* } } */\n+  CPY (d, s, n);                    /* { dg-warning \"specified bound 7 equals destination size\" } */\n \n   Dest *pd = (Dest *)__builtin_malloc (sizeof *pd * n);\n   CPY (pd->a5, s, 5);               /* { dg-warning \"specified bound 5 equals destination size\" } */"}, {"sha": "9194417aee6b73d580229c7e1f0f47f58f4c19b3", "filename": "gcc/testsuite/g++.dg/ext/attr-alloc_size.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-alloc_size.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-alloc_size.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-alloc_size.C?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -1,6 +1,6 @@\n /* PR c++/87541 - ICE using a constant decl as an attribute alloc_size argument\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall\" } */\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n \n #define ALLOC_SIZE(N)   __attribute__ ((alloc_size (N)))\n "}, {"sha": "b6fe0289674b327bd4763af108a6c550c8ed3b80", "filename": "gcc/testsuite/g++.dg/warn/Wstringop-overflow-4.C", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-4.C?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -0,0 +1,157 @@\n+/* PR middle-end/91582 - missing heap overflow detection for strcpy\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+#include \"../../gcc.dg/range.h\"\n+\n+#define INT_MAX     __INT_MAX__\n+#define INT_MIN     (-INT_MAX - 1)\n+\n+extern \"C\" char* strcpy (char*, const char*);\n+\n+void sink (void*);\n+\n+#define S36 \"0123456789abcdefghijklmnopqrstuvwxyz\"\n+#define S(N) (S36 + sizeof S36 - N - 1)\n+\n+#define T(src, alloc) do {\t\t\t\\\n+    const char *s = src;\t\t\t\\\n+    char *d = (char*)alloc;\t\t\t\\\n+    strcpy (d, s);\t\t\t\t\\\n+    sink (d);\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+void test_strcpy_new_char (size_t n)\n+{\n+  size_t r_0_1 = UR (0, 1);\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+  T (S (0), new char[r_0_1]);\n+  T (S (1), new char[r_0_1]);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), new char[r_1_2]);\n+  T (S (1), new char[r_1_2]);\n+  T (S (2), new char[r_1_2]);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), new char[r_2_3]);\n+  T (S (2), new char[r_2_3]);\n+  T (S (3), new char[r_2_3]);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (9), new char[r_2_3]);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  size_t r_2_smax = UR (2, SIZE_MAX);\n+  T (S (0), new char[r_2_smax]);\n+  T (S (1), new char[r_2_smax]);\n+  T (S (2), new char[r_2_smax]);\n+  T (S (3), new char[r_2_smax * 2]);\n+  T (S (4), new char[r_2_smax * 2 + 1]);\n+\n+  T (S (1), new char[n]);\n+  T (S (2), new char[n + 1]);\n+  T (S (9), new char[n * 2 + 1]);\n+\n+  int r_imin_imax = SR (INT_MIN, INT_MAX);\n+  T (S (1), new char[r_imin_imax]);\n+  T (S (2), new char[r_imin_imax + 1]);\n+  T (S (9), new char[r_imin_imax * 2 + 1]);\n+\n+  int r_0_imax = SR (0, INT_MAX);\n+  T (S (1), new char[r_0_imax]);\n+  T (S (2), new char[r_0_imax + 1]);\n+  T (S (9), new char[r_0_imax * 2 + 1]);\n+\n+  int r_1_imax = SR (1, INT_MAX);\n+  T (S (1), new char[r_1_imax]);\n+  T (S (2), new char[r_1_imax + 1]);\n+  T (S (9), new char[r_1_imax * 2 + 1]);\n+\n+  ptrdiff_t r_dmin_dmax = SR (DIFF_MIN, DIFF_MAX);\n+  T (S (1), new char[r_dmin_dmax]);\n+  T (S (2), new char[r_dmin_dmax + 1]);\n+  T (S (9), new char[r_dmin_dmax * 2 + 1]);\n+}\n+\n+\n+void test_strcpy_new_char_array (size_t n)\n+{\n+  size_t r_0_1 = UR (0, 1);\n+\n+  T (S (0), new char[r_0_1][1]);\n+  T (S (1), new char[r_0_1][1]);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (1), new char[r_0_1][2]);\n+  T (S (2), new char[r_0_1][2]);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  size_t r_1_2 = UR (1, 2);\n+  T (S (0), new char[r_1_2][0]);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (0), new char[r_1_2][1]);\n+  T (S (1), new char[r_1_2][1]);\n+  T (S (2), new char[r_1_2][1]);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), new char[r_1_2][0]);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (0), new char[r_1_2][1]);\n+  T (S (1), new char[r_1_2][2]);\n+  T (S (3), new char[r_1_2][2]);\n+  T (S (4), new char[r_1_2][2]);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+#ifdef __INT16_TYPE__\n+\n+typedef __INT16_TYPE__ int16_t;\n+\n+void test_strcpy_new_int16_t (size_t n)\n+{\n+  size_t r_0_1 = UR (0, 1);\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+  T (S (0), new int16_t[r_0_1]);\n+  T (S (1), new int16_t[r_0_1]);\n+  T (S (2), new int16_t[r_0_1]);      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), new int16_t[r_1_2]);\n+  T (S (1), new int16_t[r_1_2]);\n+  T (S (2), new int16_t[r_1_2]);\n+  T (S (3), new int16_t[r_1_2]);\n+  T (S (4), new int16_t[r_1_2]);      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), new int16_t[r_2_3]);\n+  T (S (1), new int16_t[r_2_3]);\n+  T (S (5), new int16_t[r_2_3]);\n+  T (S (6), new int16_t[r_2_3]);      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (9), new int16_t[r_2_3]);      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  size_t r_2_smax = UR (2, SIZE_MAX);\n+  T (S (0), new int16_t[r_2_smax]);\n+  T (S (1), new int16_t[r_2_smax]);\n+  T (S (2), new int16_t[r_2_smax]);\n+  T (S (3), new int16_t[r_2_smax * 2]);\n+  T (S (4), new int16_t[r_2_smax * 2 + 1]);\n+\n+  T (S (1), new int16_t[n]);\n+  T (S (2), new int16_t[n + 1]);\n+  T (S (9), new int16_t[n * 2 + 1]);\n+\n+  int r_imin_imax = SR (INT_MIN, INT_MAX);\n+  T (S (1), new int16_t[r_imin_imax]);\n+  T (S (2), new int16_t[r_imin_imax + 1]);\n+  T (S (9), new int16_t[r_imin_imax * 2 + 1]);\n+\n+  int r_0_imax = SR (0, INT_MAX);\n+  T (S (1), new int16_t[r_0_imax]);\n+  T (S (2), new int16_t[r_0_imax + 1]);\n+  T (S (9), new int16_t[r_0_imax * 2 + 1]);\n+\n+  int r_1_imax = SR (1, INT_MAX);\n+  T (S (1), new int16_t[r_1_imax]);\n+  T (S (2), new int16_t[r_1_imax + 1]);\n+  T (S (9), new int16_t[r_1_imax * 2 + 1]);\n+\n+  ptrdiff_t r_dmin_dmax = SR (DIFF_MIN, DIFF_MAX);\n+  T (S (1), new int16_t[r_dmin_dmax]);\n+  T (S (2), new int16_t[r_dmin_dmax + 1]);\n+  T (S (9), new int16_t[r_dmin_dmax * 2 + 1]);\n+}\n+\n+#endif   // int16_t"}, {"sha": "3d85660fbbe36de306c69cf2c66166698320e6da", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-56.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-56.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-56.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-56.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -0,0 +1,88 @@\n+/* PR middle-end/91582 - missing heap overflow detection for strcpy\n+\n+   The -Warray-bounds instances here probably should be replaced by\n+   -Wstringop-overflow when it detects these overflows (see also\n+   the xfails in Wstringop-overflow-25.c).\n+\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-stringop-overflow -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define INT_MAX     __INT_MAX__\n+#define INT_MIN     (-INT_MAX - 1)\n+\n+#define ATTR(...)   __attribute__ ((__VA_ARGS__))\n+#define NOIPA       ATTR (noipa)\n+\n+extern void* malloc (size_t);\n+extern char* strcpy (char*, const char*);\n+\n+void sink (void*);\n+\n+#define S36 \"0123456789abcdefghijklmnopqrstuvwxyz\"\n+#define S(N) (S36 + sizeof S36 - N - 1)\n+\n+struct Flex\n+{\n+  char n, ax[];\n+};\n+\n+extern struct Flex fx;\n+struct Flex f1 = { 1, { 1 } };\n+struct Flex f2 = { 2, { 1, 2 } };\n+struct Flex f3 = { 3, { 1, 2, 3 } };\n+\n+#define T(src, f) do {\t\t\t\t\\\n+    char *s = src;\t\t\t\t\\\n+    char *d = f.ax;\t\t\t\t\\\n+    strcpy (d, s);\t\t\t\t\\\n+    sink (&f);\t\t\t\t\t\\\n+  } while (0)\n+\n+NOIPA void test_strcpy_flexarray (void)\n+{\n+  T (S (0), fx);                // { dg-bogus \"\\\\\\[-Warray-bounds\" \"pr92815\" { xfail *-*-*} }\n+  T (S (9), fx);                // { dg-bogus \"\\\\\\[-Warray-bounds\" \"pr92815\" { xfail *-*-*} }\n+\n+  T (S (0), f1);\n+  T (S (1), f1);                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T (S (0), f2);\n+  T (S (1), f2);\n+  T (S (2), f2);                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T (S (0), f3);\n+  T (S (2), f3);\n+  T (S (3), f3);                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (S (9), f3);                // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+#undef T\n+#define T(T, src, n) do {\t\t\t\\\n+    char *s = src;\t\t\t\t\\\n+    typedef struct { T n, ax[]; } Flex;\t\t\\\n+    Flex *p = (Flex*)malloc (sizeof *p + n);\t\\\n+    char *d = (char*)p->ax;\t\t\t\\\n+    strcpy (d, s);\t\t\t\t\\\n+    sink (p);\t\t\t\t\t\\\n+  } while (0)\n+\n+NOIPA void test_strcpy_malloc_flexarray (void)\n+{\n+  size_t r_0_1 = UR (0, 1);\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+  T (char, S (0), r_0_1);\n+  T (char, S (1), r_0_1);       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T (char, S (0), r_1_2);\n+  T (char, S (1), r_1_2);\n+  T (char, S (2), r_1_2);       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T (char, S (0), r_2_3);\n+  T (char, S (2), r_2_3);\n+  T (char, S (3), r_2_3);       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (char, S (9), r_2_3);       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}"}, {"sha": "1b38dfe9ae4abb3253f01ecc007ab1f94f06f6d8", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-25.c", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-25.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -0,0 +1,377 @@\n+/* PR middle-end/91582 - missing heap overflow detection for strcpy\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n+\n+#include \"range.h\"\n+\n+#define INT_MAX     __INT_MAX__\n+#define INT_MIN     (-INT_MAX - 1)\n+\n+#define ATTR(...)   __attribute__ ((__VA_ARGS__))\n+#define NOIPA       ATTR (noipa)\n+\n+extern void* alloca (size_t);\n+extern void* calloc (size_t, size_t);\n+extern void* malloc (size_t);\n+\n+extern ATTR (alloc_size (1), malloc) void*\n+  alloc1 (size_t, int);\n+extern ATTR (alloc_size (2), malloc) void*\n+  alloc2 (int, size_t);\n+extern ATTR (alloc_size (2, 4), malloc) void*\n+  alloc2_4 (int, size_t, int, size_t);\n+\n+extern char* strcpy (char*, const char*);\n+\n+void sink (void*);\n+\n+#define S36 \"0123456789abcdefghijklmnopqrstuvwxyz\"\n+#define S(N) (S36 + sizeof S36 - N - 1)\n+\n+#define T(src, alloc) do {\t\t\t\\\n+    char *s = src;\t\t\t\t\\\n+    char *d = alloc;\t\t\t\t\\\n+    strcpy (d, s);\t\t\t\t\\\n+    sink (d);\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+NOIPA void test_strcpy_alloca (size_t n)\n+{\n+  size_t r_0_1 = UR (0, 1);\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+  T (S (0), alloca (r_0_1));\n+  T (S (1), alloca (r_0_1));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloca (r_1_2));\n+  T (S (1), alloca (r_1_2));\n+  T (S (2), alloca (r_1_2));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloca (r_2_3));\n+  T (S (2), alloca (r_2_3));\n+  T (S (3), alloca (r_2_3));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (9), alloca (r_2_3));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  size_t r_2_smax = UR (2, SIZE_MAX);\n+  T (S (0), alloca (r_2_smax));\n+  T (S (1), alloca (r_2_smax));\n+  T (S (2), alloca (r_2_smax));\n+  T (S (3), alloca (r_2_smax * 2));\n+  T (S (4), alloca (r_2_smax * 2 + 1));\n+\n+  T (S (1), alloca (n));\n+  T (S (2), alloca (n + 1));\n+  T (S (9), alloca (n * 2 + 1));\n+\n+  int r_imin_imax = SR (INT_MIN, INT_MAX);\n+  T (S (1), alloca (r_imin_imax));\n+  T (S (2), alloca (r_imin_imax + 1));\n+  T (S (9), alloca (r_imin_imax * 2 + 1));\n+\n+  int r_0_imax = SR (0, INT_MAX);\n+  T (S (1), alloca (r_0_imax));\n+  T (S (2), alloca (r_0_imax + 1));\n+  T (S (9), alloca (r_0_imax * 2 + 1));\n+\n+  int r_1_imax = SR (1, INT_MAX);\n+  T (S (1), alloca (r_1_imax));\n+  T (S (2), alloca (r_1_imax + 1));\n+  T (S (9), alloca (r_1_imax * 2 + 1));\n+\n+  ptrdiff_t r_dmin_dmax = SR (DIFF_MIN, DIFF_MAX);\n+  T (S (1), alloca (r_dmin_dmax));\n+  T (S (2), alloca (r_dmin_dmax + 1));\n+  T (S (9), alloca (r_dmin_dmax * 2 + 1));\n+}\n+\n+NOIPA void test_strcpy_calloc (void)\n+{\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+  T (S (0), calloc (r_1_2, 1));\n+  T (S (1), calloc (r_1_2, 1));\n+  T (S (2), calloc (r_1_2, 1));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (2), calloc (r_2_3, 1));\n+  T (S (3), calloc (r_2_3, 1));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), calloc (1, r_1_2));\n+  T (S (1), calloc (1, r_1_2));\n+  T (S (2), calloc (1, r_1_2));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (2), calloc (1, r_2_3));\n+  T (S (3), calloc (1, r_2_3));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), calloc (r_1_2, 2));\n+  T (S (1), calloc (r_1_2, 2));\n+  T (S (2), calloc (r_1_2, 2));\n+  T (S (3), calloc (r_1_2, 2));\n+  T (S (4), calloc (r_1_2, 2));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), calloc (r_2_3, 2));\n+  T (S (1), calloc (r_2_3, 2));\n+  T (S (2), calloc (r_2_3, 2));\n+  T (S (5), calloc (r_2_3, 2));\n+  T (S (6), calloc (r_2_3, 2));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), calloc (r_1_2, 2));\n+  T (S (1), calloc (r_1_2, 2));\n+  T (S (2), calloc (r_1_2, 2));\n+  T (S (3), calloc (r_1_2, 2));\n+  T (S (4), calloc (r_1_2, 2));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), calloc (r_2_3, 2));\n+  T (S (1), calloc (r_2_3, 2));\n+  T (S (2), calloc (r_2_3, 2));\n+  T (S (5), calloc (r_2_3, 2));\n+  T (S (6), calloc (r_2_3, 2));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), calloc (r_1_2, r_2_3));\n+  T (S (1), calloc (r_1_2, r_2_3));\n+  T (S (2), calloc (r_1_2, r_2_3));\n+  T (S (3), calloc (r_1_2, r_2_3));\n+  T (S (4), calloc (r_1_2, r_2_3));\n+  T (S (5), calloc (r_1_2, r_2_3));\n+  T (S (6), calloc (r_1_2, r_2_3));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (9), calloc (r_1_2, r_2_3));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  size_t r_2_dmax = UR (2, DIFF_MAX);\n+  T (S (0), calloc (0, r_2_dmax));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (0), calloc (1, r_2_dmax));\n+  T (S (9), calloc (2, r_2_dmax));\n+\n+  T (S (0), calloc (r_2_dmax, r_2_dmax));\n+  T (S (9), calloc (r_2_dmax, r_2_dmax));\n+\n+  size_t r_2_smax = UR (2, SIZE_MAX);\n+  T (S (0), calloc (r_2_smax, 1));\n+  T (S (9), calloc (r_2_smax, 2));\n+\n+  T (S (0), calloc (r_2_smax, r_2_smax));\n+  T (S (9), calloc (r_2_smax, r_2_smax));\n+}\n+\n+\n+NOIPA void test_strcpy_malloc (void)\n+{\n+  size_t r_0_1 = UR (0, 1);\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+  T (S (0), malloc (r_0_1));\n+  T (S (1), malloc (r_0_1));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), malloc (r_1_2));\n+  T (S (1), malloc (r_1_2));\n+  T (S (2), malloc (r_1_2));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), malloc (r_2_3));\n+  T (S (2), malloc (r_2_3));\n+  T (S (3), malloc (r_2_3));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (9), malloc (r_2_3));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+NOIPA void test_strcpy_alloc1 (void)\n+{\n+  size_t r_0_1 = UR (0, 1);\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+#define alloc1(n) alloc1 (n, 1)\n+\n+  T (S (0), alloc1 (r_0_1));\n+  T (S (1), alloc1 (r_0_1));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloc1 (r_1_2));\n+  T (S (1), alloc1 (r_1_2));\n+  T (S (2), alloc1 (r_1_2));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloc1 (r_2_3));\n+  T (S (2), alloc1 (r_2_3));\n+  T (S (3), alloc1 (r_2_3));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (9), alloc1 (r_2_3));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+NOIPA void test_strcpy_alloc2 (void)\n+{\n+  size_t r_0_1 = UR (0, 1);\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+#define alloc2(n) alloc2 (1, n)\n+\n+  T (S (0), alloc1 (r_0_1));\n+  T (S (1), alloc1 (r_0_1));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloc1 (r_1_2));\n+  T (S (1), alloc1 (r_1_2));\n+  T (S (2), alloc1 (r_1_2));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloc1 (r_2_3));\n+  T (S (2), alloc1 (r_2_3));\n+  T (S (3), alloc1 (r_2_3));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (9), alloc1 (r_2_3));      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+NOIPA void test_strcpy_alloc2_4 (void)\n+{\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+#define alloc2_4(n1, n2) alloc2_4 (1, n1, 2, n2)\n+\n+  T (S (0), alloc2_4 (r_1_2, 1));\n+  T (S (1), alloc2_4 (r_1_2, 1));\n+  T (S (2), alloc2_4 (r_1_2, 1));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (2), alloc2_4 (r_2_3, 1));\n+  T (S (3), alloc2_4 (r_2_3, 1));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloc2_4 (1, r_1_2));\n+  T (S (1), alloc2_4 (1, r_1_2));\n+  T (S (2), alloc2_4 (1, r_1_2));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (2), alloc2_4 (1, r_2_3));\n+  T (S (3), alloc2_4 (1, r_2_3));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloc2_4 (r_1_2, 2));\n+  T (S (1), alloc2_4 (r_1_2, 2));\n+  T (S (2), alloc2_4 (r_1_2, 2));\n+  T (S (3), alloc2_4 (r_1_2, 2));\n+  T (S (4), alloc2_4 (r_1_2, 2));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloc2_4 (r_2_3, 2));\n+  T (S (1), alloc2_4 (r_2_3, 2));\n+  T (S (2), alloc2_4 (r_2_3, 2));\n+  T (S (5), alloc2_4 (r_2_3, 2));\n+  T (S (6), alloc2_4 (r_2_3, 2));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloc2_4 (r_1_2, 2));\n+  T (S (1), alloc2_4 (r_1_2, 2));\n+  T (S (2), alloc2_4 (r_1_2, 2));\n+  T (S (3), alloc2_4 (r_1_2, 2));\n+  T (S (4), alloc2_4 (r_1_2, 2));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloc2_4 (r_2_3, 2));\n+  T (S (1), alloc2_4 (r_2_3, 2));\n+  T (S (2), alloc2_4 (r_2_3, 2));\n+  T (S (5), alloc2_4 (r_2_3, 2));\n+  T (S (6), alloc2_4 (r_2_3, 2));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (S (0), alloc2_4 (r_1_2, r_2_3));\n+  T (S (1), alloc2_4 (r_1_2, r_2_3));\n+  T (S (2), alloc2_4 (r_1_2, r_2_3));\n+  T (S (3), alloc2_4 (r_1_2, r_2_3));\n+  T (S (4), alloc2_4 (r_1_2, r_2_3));\n+  T (S (5), alloc2_4 (r_1_2, r_2_3));\n+  T (S (6), alloc2_4 (r_1_2, r_2_3));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (S (9), alloc2_4 (r_1_2, r_2_3));   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  size_t r_2_dmax = UR (2, DIFF_MAX);\n+  T (S (0), alloc2_4 (r_2_dmax, r_2_dmax));\n+  T (S (9), alloc2_4 (r_2_dmax, r_2_dmax));\n+\n+  size_t r_2_smax = UR (2, SIZE_MAX);\n+  T (S (0), alloc2_4 (r_2_smax, r_2_smax));\n+  T (S (9), alloc2_4 (r_2_smax, r_2_smax));\n+}\n+\n+#undef T\n+#define T(T, src, n) do {\t\t\t\\\n+    char *s = src;\t\t\t\t\\\n+    T vla[n];\t\t\t\t\t\\\n+    char *d = (char*)vla;\t\t\t\\\n+    strcpy (d, s);\t\t\t\t\\\n+    sink (vla);\t\t\t\t\t\\\n+  } while (0)\n+\n+NOIPA void test_strcpy_vla (void)\n+{\n+  size_t r_0_1 = UR (0, 1);\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+  T (char, S (0), r_0_1);\n+  T (char, S (1), r_0_1);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (char, S (0), r_1_2);\n+  T (char, S (1), r_1_2);\n+  T (char, S (2), r_1_2);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (char, S (0), r_2_3);\n+  T (char, S (2), r_2_3);\n+  T (char, S (3), r_2_3);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (char, S (9), r_2_3);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+#ifdef __INT16_TYPE__\n+  typedef __INT16_TYPE__ int16_t;\n+\n+  T (int16_t, S (0), r_1_2);\n+  T (int16_t, S (2), r_1_2);\n+  T (int16_t, S (3), r_1_2);\n+  T (int16_t, S (4), r_1_2);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (int16_t, S (5), r_1_2);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (int16_t, S (9), r_1_2);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  T (int16_t, S (0), r_2_3);\n+  T (int16_t, S (2), r_2_3);\n+  T (int16_t, S (3), r_2_3);\n+  T (int16_t, S (4), r_2_3);\n+  T (int16_t, S (5), r_2_3);\n+  T (int16_t, S (6), r_2_3);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+#endif\n+\n+#ifdef __INT32_TYPE__\n+  typedef __INT32_TYPE__ int32_t;\n+\n+  T (int32_t, S ( 0), r_2_3);\n+  T (int32_t, S ( 2), r_2_3);\n+  T (int32_t, S ( 3), r_2_3);\n+  T (int32_t, S ( 4), r_2_3);\n+  T (int32_t, S ( 5), r_2_3);\n+  T (int32_t, S ( 6), r_2_3);\n+  T (int32_t, S (11), r_2_3);\n+  T (int32_t, S (12), r_2_3);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  T (int32_t, S (36), r_2_3);    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+#endif\n+}\n+\n+\n+struct Flex\n+{\n+  char n, ax[];\n+};\n+\n+#undef T\n+#define T(T, src, n) do {\t\t\t\\\n+    char *s = src;\t\t\t\t\\\n+    typedef struct { T n, ax[]; } Flex;\t\t\\\n+    Flex *p = (Flex*)malloc (sizeof *p + n);\t\\\n+    char *d = (char*)p->ax;\t\t\t\\\n+    strcpy (d, s);\t\t\t\t\\\n+    sink (p);\t\t\t\t\t\\\n+  } while (0)\n+\n+NOIPA void test_strcpy_malloc_flexarray (void)\n+{\n+  size_t r_0_1 = UR (0, 1);\n+  size_t r_1_2 = UR (1, 2);\n+  size_t r_2_3 = UR (2, 3);\n+\n+  T (char, S (0), r_0_1);\n+  T (char, S (1), r_0_1);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" { xfail *-*-* } }\n+\n+  T (char, S (0), r_1_2);\n+  T (char, S (1), r_1_2);\n+  T (char, S (2), r_1_2);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" { xfail *-*-* } }\n+\n+  T (char, S (0), r_2_3);\n+  T (char, S (2), r_2_3);\n+  T (char, S (3), r_2_3);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" { xfail *-*-* } }\n+  T (char, S (9), r_2_3);       // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92814\" { xfail *-*-* } }\n+}"}, {"sha": "7b0dc6e4535efdb750626e641fe43237cce27882", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+/* { dg-options \"-O2 -Wall -Wno-array-bounds -ftrack-macro-expansion=0\" } */\n \n extern void abort (void);\n "}, {"sha": "f311ca32aa602a249384fcb22432157af8aebbb5", "filename": "gcc/testsuite/gcc.dg/attr-copy-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-copy-2.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -2,7 +2,7 @@\n    Exercise attribute copy for functions.\n    { dg-do compile }\n    { dg-require-alias \"\" }\n-   { dg-options \"-O2 -Wall\" } */\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n \n #define Assert(expr)   typedef char AssertExpr[2 * !!(expr) - 1]\n "}, {"sha": "320cd51fcf2d9fd1eb3a174eb4e3011f01add4a6", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-5.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -1,4 +1,4 @@\n-/* Test exercising -Wrawmem-overflow and -Wstringop-overflow warnings.  */\n+/* Test exercising -Wstringop-overflow warnings.  */\n /* { dg-do compile } */\n /* { dg-options \"-O2 -Wstringop-overflow=1\" } */\n \n@@ -49,7 +49,7 @@ void test_memop_warn_local (const void *src)\n   memcpy (a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" } */\n   escape (a, src);\n \n-  /* At -Wrawmem-overflow=1 the destination is considered to be\n+  /* At -Wstringop-overflow=1 the destination is considered to be\n      the whole array and its size is therefore sizeof a.  */\n   memcpy (&a[0], src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" } */\n   escape (a, src);\n@@ -110,12 +110,12 @@ void test_memop_warn_alloc (const void *src)\n \n   struct A *a = __builtin_malloc (sizeof *a * 2);\n \n-  memcpy (a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memcpy (a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" \"memcpy into allocated\" } */\n   escape (a, src);\n \n-  /* At -Wrawmem-overflow=1 the destination is considered to be\n+  /* At -Wstringop-overflow=1 the destination is considered to be\n      the whole array and its size is therefore sizeof a.  */\n-  memcpy (&a[0], src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memcpy (&a[0], src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" \"memcpy into allocated\" } */\n   escape (a, src);\n \n   /* Verify the same as above but by writing into the first mmeber\n@@ -127,7 +127,7 @@ void test_memop_warn_alloc (const void *src)\n \n   struct B *b = __builtin_malloc (sizeof *b * 2);\n \n-  memcpy (&b[0], src, n);   /* { dg-warning \"writing between 12 and 32 bytes into a region of size 8 overflows the destination\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memcpy (&b[0], src, n);   /* { dg-warning \"writing between 12 and 32 bytes into a region of size 8 overflows the destination\" \"memcpy into allocated\" } */\n   escape (b);\n \n   /* The following idiom of clearing multiple members of a struct is"}, {"sha": "741c1f88eaa54763926a119b396ecec99df12f83", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-8.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -102,23 +102,23 @@ void test_memop_warn_alloc (void *p)\n \n   struct A *a = __builtin_malloc (sizeof *a * 2);\n \n-  memcpy (p, a, n);   /* { dg-warning \"reading between 8 and 32 bytes from region of size 4\" \"memcpy from allocated\" { xfail *-*-*} } */\n+  memcpy (p, a, n);   /* { dg-warning \"reading between 8 and 32 bytes from a region of size 4\" \"memcpy from allocated\" } */\n \n-  memcpy (p, &a[0], n);   /* { dg-warning \"reading between 8 and 32 bytes from a region of size 4\" \"memcpy from allocated\" { xfail *-*-*} } */\n+  memcpy (p, &a[0], n);   /* { dg-warning \"reading between 8 and 32 bytes from a region of size 4\" \"memcpy from allocated\" } */\n \n   memcpy (p, &a[0].a, n);   /* { dg-warning \"reading between 8 and 32 bytes from a region of size 4\" \"memcpy from allocated\" { xfail *-*-*} } */\n \n   n = range (12, 32);\n \n   struct B *b = __builtin_malloc (sizeof *b * 2);\n \n-  memcpy (p, &b[0], n);   /* { dg-warning \"reading between 12 and 32 bytes from a region of size 8\" \"memcpy from allocated\" { xfail *-*-*} } */\n+  memcpy (p, &b[0], n);   /* { dg-warning \"reading between 12 and 32 bytes from a region of size 8\" \"memcpy from allocated\" } */\n \n   /* Verify memchr/memcmp.  */\n   n = sizeof *b * 2 + 1;\n \n-  memchr (b, 1, n);   /* { dg-warning \"reading 5 bytes from a region of size 4\" \"memcmp from allocated\" { xfail *-*-* } } */\n-  memcmp (p, b, n);   /* { dg-warning \"reading 5 bytes from a region of size 4\" \"memcmp from allocated\" { xfail *-*-* } } */\n+  memchr (b, 1, n);   /* { dg-warning \"reading 9 bytes from a region of size 8\" \"memcmp from allocated\" } */\n+  memcmp (p, b, n);   /* { dg-warning \"reading 9 bytes from a region of size 8\" \"memcmp from allocated\" } */\n }\n \n "}, {"sha": "dbcc105fcd2d6103187836b2594e4afd9b0c2679", "filename": "gcc/testsuite/gcc.target/i386/pr82002-2a.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2a.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -10,3 +10,5 @@ b ()\n   a (c);\n   a (c);\n }\n+\n+/* { dg-prune-output \"\\\\\\[-Wstringop-overflow\" }  */"}, {"sha": "e1ad737263c48ee360c63c3a95f94a345184fb4e", "filename": "gcc/testsuite/gcc.target/i386/pr82002-2b.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr82002-2b.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -10,3 +10,5 @@ b ()\n   a (c);\n   a (c);\n }\n+\n+/* { dg-prune-output \"\\\\\\[-Wstringop-overflow\" }  */"}, {"sha": "beff17b37f1a046aed1bf00bde2e360befb2319e", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/268209f3a0dc07fcf13534610447ab732742eb2f/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=268209f3a0dc07fcf13534610447ab732742eb2f", "patch": "@@ -4394,8 +4394,22 @@ handle_store (gimple_stmt_iterator *gsi, bool *zero_write, const vr_values *rval\n \t\t\t       stmt, lenrange[2], dstsize))\n \t\t  {\n \t\t    if (decl)\n-\t\t      inform (DECL_SOURCE_LOCATION (decl),\n-\t\t\t      \"destination object declared here\");\n+\t\t      {\n+\t\t\tif (TREE_CODE (decl) == SSA_NAME)\n+\t\t\t  {\n+\t\t\t    gimple *stmt = SSA_NAME_DEF_STMT (decl);\n+\t\t\t    if (is_gimple_call (stmt))\n+\t\t\t      {\n+\t\t\t\ttree allocfn = gimple_call_fndecl (stmt);\n+\t\t\t\tinform (gimple_location (stmt),\n+\t\t\t\t\t\"destination region allocated by %qD \"\n+\t\t\t\t\t\"here\", allocfn);\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  inform (DECL_SOURCE_LOCATION (decl),\n+\t\t\t\t  \"destination object declared here\");\n+\t\t      }\n \t\t    gimple_set_no_warning (stmt, true);\n \t\t  }\n \t      }"}]}