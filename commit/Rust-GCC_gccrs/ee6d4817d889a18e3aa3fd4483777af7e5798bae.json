{"sha": "ee6d4817d889a18e3aa3fd4483777af7e5798bae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU2ZDQ4MTdkODg5YTE4ZTNhYTNmZDQ0ODM3NzdhZjdlNTc5OGJhZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-27T21:11:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-27T21:11:12Z"}, "message": "Initial revision\n\nFrom-SVN: r19444", "tree": {"sha": "d1288809931d05aa628f5865e459e5172146c19b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1288809931d05aa628f5865e459e5172146c19b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee6d4817d889a18e3aa3fd4483777af7e5798bae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee6d4817d889a18e3aa3fd4483777af7e5798bae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee6d4817d889a18e3aa3fd4483777af7e5798bae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee6d4817d889a18e3aa3fd4483777af7e5798bae/comments", "author": null, "committer": null, "parents": [{"sha": "67bb1a5270273fea70fa8656a4cda4c0c2694449", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67bb1a5270273fea70fa8656a4cda4c0c2694449", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67bb1a5270273fea70fa8656a4cda4c0c2694449"}], "stats": {"total": 216, "additions": 216, "deletions": 0}, "files": [{"sha": "81ea29bf4e425fbb3e4ffaec8168134b424b6453", "filename": "gcc/intl/finddomain.c", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee6d4817d889a18e3aa3fd4483777af7e5798bae/gcc%2Fintl%2Ffinddomain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee6d4817d889a18e3aa3fd4483777af7e5798bae/gcc%2Fintl%2Ffinddomain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl%2Ffinddomain.c?ref=ee6d4817d889a18e3aa3fd4483777af7e5798bae", "patch": "@@ -0,0 +1,216 @@\n+/* Handle list of needed message catalogs\n+   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software Foundation,\n+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#ifdef HAVE_CONFIG_H\n+# include <config.h>\n+#endif\n+\n+#include <ctype.h>\n+#include <errno.h>\n+#include <stdio.h>\n+#include <sys/types.h>\n+\n+#if defined STDC_HEADERS || defined _LIBC\n+# include <stdlib.h>\n+#else\n+# ifdef HAVE_MALLOC_H\n+#  include <malloc.h>\n+# else\n+void free ();\n+# endif\n+#endif\n+\n+#if defined HAVE_STRING_H || defined _LIBC\n+# include <string.h>\n+#else\n+# include <strings.h>\n+# ifndef memcpy\n+#  define memcpy(Dst, Src, Num) bcopy (Src, Dst, Num)\n+# endif\n+#endif\n+#if !HAVE_STRCHR && !defined _LIBC\n+# ifndef strchr\n+#  define strchr index\n+# endif\n+#endif\n+\n+#if defined HAVE_UNISTD_H || defined _LIBC\n+# include <unistd.h>\n+#endif\n+\n+#include \"gettext.h\"\n+#include \"gettextP.h\"\n+#ifdef _LIBC\n+# include <libintl.h>\n+#else\n+# include \"libgettext.h\"\n+#endif\n+\n+/* @@ end of prolog @@ */\n+/* List of already loaded domains.  */\n+static struct loaded_l10nfile *_nl_loaded_domains;\n+\n+\n+/* Return a data structure describing the message catalog described by\n+   the DOMAINNAME and CATEGORY parameters with respect to the currently\n+   established bindings.  */\n+struct loaded_l10nfile *\n+internal_function\n+_nl_find_domain (dirname, locale, domainname)\n+     const char *dirname;\n+     char *locale;\n+     const char *domainname;\n+{\n+  struct loaded_l10nfile *retval;\n+  const char *language;\n+  const char *modifier;\n+  const char *territory;\n+  const char *codeset;\n+  const char *normalized_codeset;\n+  const char *special;\n+  const char *sponsor;\n+  const char *revision;\n+  const char *alias_value;\n+  int mask;\n+\n+  /* LOCALE can consist of up to four recognized parts for the XPG syntax:\n+\n+\t\tlanguage[_territory[.codeset]][@modifier]\n+\n+     and six parts for the CEN syntax:\n+\n+\tlanguage[_territory][+audience][+special][,[sponsor][_revision]]\n+\n+     Beside the first part all of them are allowed to be missing.  If\n+     the full specified locale is not found, the less specific one are\n+     looked for.  The various parts will be stripped off according to\n+     the following order:\n+\t\t(1) revision\n+\t\t(2) sponsor\n+\t\t(3) special\n+\t\t(4) codeset\n+\t\t(5) normalized codeset\n+\t\t(6) territory\n+\t\t(7) audience/modifier\n+   */\n+\n+  /* If we have already tested for this locale entry there has to\n+     be one data set in the list of loaded domains.  */\n+  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,\n+\t\t\t       strlen (dirname) + 1, 0, locale, NULL, NULL,\n+\t\t\t       NULL, NULL, NULL, NULL, NULL, domainname, 0);\n+  if (retval != NULL)\n+    {\n+      /* We know something about this locale.  */\n+      int cnt;\n+\n+      if (retval->decided == 0)\n+\t_nl_load_domain (retval);\n+\n+      if (retval->data != NULL)\n+\treturn retval;\n+\n+      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)\n+\t{\n+\t  if (retval->successor[cnt]->decided == 0)\n+\t    _nl_load_domain (retval->successor[cnt]);\n+\n+\t  if (retval->successor[cnt]->data != NULL)\n+\t    break;\n+\t}\n+      return cnt >= 0 ? retval : NULL;\n+      /* NOTREACHED */\n+    }\n+\n+  /* See whether the locale value is an alias.  If yes its value\n+     *overwrites* the alias name.  No test for the original value is\n+     done.  */\n+  alias_value = _nl_expand_alias (locale);\n+  if (alias_value != NULL)\n+    {\n+#if defined _LIBC || defined HAVE_STRDUP\n+      locale = strdup (alias_value);\n+      if (locale == NULL)\n+\treturn NULL;\n+#else\n+      size_t len = strlen (alias_value) + 1;\n+      locale = (char *) malloc (len);\n+      if (locale == NULL)\n+\treturn NULL;\n+\n+      memcpy (locale, alias_value, len);\n+#endif\n+    }\n+\n+  /* Now we determine the single parts of the locale name.  First\n+     look for the language.  Termination symbols are `_' and `@' if\n+     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */\n+  mask = _nl_explode_name (locale, &language, &modifier, &territory,\n+\t\t\t   &codeset, &normalized_codeset, &special,\n+\t\t\t   &sponsor, &revision);\n+\n+  /* Create all possible locale entries which might be interested in\n+     generalization.  */\n+  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,\n+\t\t\t       strlen (dirname) + 1, mask, language, territory,\n+\t\t\t       codeset, normalized_codeset, modifier, special,\n+\t\t\t       sponsor, revision, domainname, 1);\n+  if (retval == NULL)\n+    /* This means we are out of core.  */\n+    return NULL;\n+\n+  if (retval->decided == 0)\n+    _nl_load_domain (retval);\n+  if (retval->data == NULL)\n+    {\n+      int cnt;\n+      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)\n+\t{\n+\t  if (retval->successor[cnt]->decided == 0)\n+\t    _nl_load_domain (retval->successor[cnt]);\n+\t  if (retval->successor[cnt]->data != NULL)\n+\t    break;\n+\t}\n+    }\n+\n+  /* The room for an alias was dynamically allocated.  Free it now.  */\n+  if (alias_value != NULL)\n+    free (locale);\n+\n+  return retval;\n+}\n+\n+\n+#ifdef _LIBC\n+static void __attribute__ ((unused))\n+free_mem (void)\n+{\n+  struct loaded_l10nfile *runp = _nl_loaded_domains;\n+\n+  while (runp != NULL)\n+    {\n+      struct loaded_l10nfile *here = runp;\n+      if (runp->data != NULL)\n+\t_nl_unload_domain ((struct loaded_domain *) runp->data);\n+      runp = runp->next;\n+      free (here);\n+    }\n+}\n+\n+text_set_element (__libc_subfreeres, free_mem);\n+#endif"}]}