{"sha": "b7442fb5553f2ea9d738e5f2a1177c655baa442d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc0NDJmYjU1NTNmMmVhOWQ3MzhlNWYyYTExNzdjNjU1YmFhNDQyZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-06-05T08:03:45Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-06-05T08:03:45Z"}, "message": "c-common.h (flag_dump_translation_unit): Remove.\n\n\t* c-common.h (flag_dump_translation_unit): Remove.\n\t(enum tree_dump_index): Define.\n\t(TDF_ADDRESS, TDF_SLIM): New #defines.\n\t(dump_node_to_file): Remove.\n\t(dump_node): Make extern. Add flags.\n\t(dump_flag, dump_enabled_p, dump_begin, dump_end,\n\tdump_switch_p): Prototype.\n\t* c-common.c (flag_dump_translation_unit): Remove.\n\t* c-decl.c (c_decode_option): Remove -fdump-translation-unit\n\tlogic. Use dump_switch_p.\n\t* c-dump.h (struct dump_info): Add node and user fields.\n\t(dump_pointer): Declare.\n\t* c-dump.c (dump_node): Make extern. Add flags.\n\t(SOL_COLUMN, EOL_COLUMN, COLUMN_ALIGNMENT): New #defines.\n\t(dump_new_line, dump_maybe_newline): Use them.\n\t(dump_pointer): New function.\n\t(dequeue_and_dump): Check TDF_SLIM before dumping a _DECL's\n\tchain or function's body. Dump address, if TDF_ADDRESS set.\n\t(dump_flag): Define.\n\t(dump_node_to_file): Remove.\n\t(struct dump_file_info): New struct.\n\t(dump_files): New array.\n\t(dump_begin, dump_end, dump_enabled_p, dump_switch_p): Define.\n\t* c-lang.c (finish_file): Adjust dumping.\n\t* toplev.h (dump_base_name): Make extern.\n\t* invoke.texi: Document new flags.\ncp:\n\t* class.c (maybe_indent_hierarchy): New function.\n\t(dump_class_hierarchy_r): Add flags. Dump extra binfo\n\tinformation, if enabled. Use maybe_indent_hierarchy. Adjust\n\toutput format.\n\t(dump_class_hierarchy): Adjust prototype. Adjust output format.\n\t(dump_array, dump_vtable, dump_vtt): New functions.\n\t(finish_struct_1): Adjust hierarchy dumping.\n\t(initialize_vtable): Call dump_vtable.\n\t(build_vtt): Call dump_vtt.\n\t(build_ctor_vtbl_group): Call dump_vtable.\n\t* decl2.c (flag_dump_class_layout): Remove.\n\t(cxx_decode_option): Remove dump translation unit\n\tand dump class hierarchy check. Call dump_switch_p.\n\t(finish_file): Adjust dumping.\n\t(dump.c): Only dump base classes if not TDF_SLIM.\n\tOnly dump namespace members if not TDF_SLIM.\n\t* optimize.c (dump_function): New function.\n\t(optimize_function): Call dump_function.\n\t* semantics.c (expand_body): Use dump_enabled_p.\n\nFrom-SVN: r42896", "tree": {"sha": "b6681bcaabfa37891f4e13f70111f31f94d5e53e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6681bcaabfa37891f4e13f70111f31f94d5e53e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7442fb5553f2ea9d738e5f2a1177c655baa442d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7442fb5553f2ea9d738e5f2a1177c655baa442d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7442fb5553f2ea9d738e5f2a1177c655baa442d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7442fb5553f2ea9d738e5f2a1177c655baa442d/comments", "author": null, "committer": null, "parents": [{"sha": "eb537d4fbb0987ec557b14aa6864b231efdb6e7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb537d4fbb0987ec557b14aa6864b231efdb6e7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb537d4fbb0987ec557b14aa6864b231efdb6e7f"}], "stats": {"total": 9349, "additions": 9220, "deletions": 129}, "files": [{"sha": "45cd94640d8e30968448ef63531f54e67ef1b025", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -1,3 +1,32 @@\n+2001-06-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* c-common.h (flag_dump_translation_unit): Remove.\n+\t(enum tree_dump_index): Define.\n+\t(TDF_ADDRESS, TDF_SLIM): New #defines.\n+\t(dump_node_to_file): Remove.\n+\t(dump_node): Make extern. Add flags.\n+\t(dump_flag, dump_enabled_p, dump_begin, dump_end,\n+\tdump_switch_p): Prototype.\n+\t* c-common.c (flag_dump_translation_unit): Remove.\n+\t* c-decl.c (c_decode_option): Remove -fdump-translation-unit\n+\tlogic. Use dump_switch_p.\n+\t* c-dump.h (struct dump_info): Add node and user fields.\n+\t(dump_pointer): Declare.\n+\t* c-dump.c (dump_node): Make extern. Add flags.\n+\t(SOL_COLUMN, EOL_COLUMN, COLUMN_ALIGNMENT): New #defines.\n+\t(dump_new_line, dump_maybe_newline): Use them.\n+\t(dump_pointer): New function.\n+\t(dequeue_and_dump): Check TDF_SLIM before dumping a _DECL's\n+\tchain or function's body. Dump address, if TDF_ADDRESS set.\n+\t(dump_flag): Define.\n+\t(dump_node_to_file): Remove.\n+\t(struct dump_file_info): New struct.\n+\t(dump_files): New array.\n+\t(dump_begin, dump_end, dump_enabled_p, dump_switch_p): Define.\n+\t* c-lang.c (finish_file): Adjust dumping.\n+\t* toplev.h (dump_base_name): Make extern.\n+\t* invoke.texi: Document new flags.\n+\n 2001-06-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c-tree.h (lang_decl): Add pending_sizes fields."}, {"sha": "2c079e0304ca521f67ac3e6c3326d97f6c22451b", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -189,11 +189,6 @@ int flag_short_double;\n \n int flag_short_wchar;\n \n-/* If non-NULL, dump the tree structure for the entire translation\n-   unit to this file.  */\n-\n-const char *flag_dump_translation_unit;\n-\n /* Nonzero means warn about possible violations of sequence point rules.  */\n \n int warn_sequence_point;"}, {"sha": "3f766a7a179992be746d0176ba1dd33a22023a2f", "filename": "gcc/c-common.h", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -427,11 +427,6 @@ extern int flag_no_builtin;\n \n extern int flag_no_nonansi_builtin;\n \n-/* If non-NULL, dump the tree structure for the entire translation\n-   unit to this file.  */\n-\n-extern const char *flag_dump_translation_unit;\n-\n /* Nonzero means warn about suggesting putting in ()'s.  */\n \n extern int warn_parentheses;\n@@ -811,6 +806,20 @@ extern int c_unsafe_for_reeval\t\t\tPARAMS ((tree));\n \n /* In dump.c */\n \n+/* Different tree dump places. */\n+enum tree_dump_index\n+{\n+  TDI_all,\t\t\t/* dump the whole translation unit */\n+  TDI_original,\t\t\t/* dump each function before optimizing it */\n+  TDI_optimized,\t\t\t/* dump each function after optimizing it */\n+  TDI_class,\t\t\t/* dump class heirarchy */\n+  TDI_end\n+};\n+\n+/* Bit masks to control tree dumping. */\n+#define TDF_ADDRESS\t(1 << 0)\t/* dump node addresses */\n+#define TDF_SLIM\t(1 << 1)\t/* don't go wild following links */\n+\n typedef struct dump_info *dump_info_p;\n \n /* A callback function used dump language-specific parts of tree\n@@ -821,7 +830,12 @@ typedef int (*dump_tree_fn) PARAMS ((dump_info_p, tree));\n \n extern dump_tree_fn lang_dump_tree;\n \n-extern void dump_node_to_file                   PARAMS ((tree, const char *));\n+extern int dump_flag\t\t\tPARAMS ((dump_info_p, int, tree));\n+extern int dump_enabled_p\t\tPARAMS ((enum tree_dump_index));\n+extern FILE *dump_begin\t\t\tPARAMS ((enum tree_dump_index, int *));\n+extern void dump_end\t\t\tPARAMS ((enum tree_dump_index, FILE *));\n+extern void dump_node\t\t\tPARAMS ((tree, int, FILE *));\n+extern int dump_switch_p                PARAMS ((const char *));\n \n /* Information recorded about each file examined during compilation.  */\n "}, {"sha": "e60ab9de785fcdcb5e71df085f8231296d60fc97", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -447,7 +447,6 @@ c_decode_option (argc, argv)\n      char **argv;\n {\n   int strings_processed;\n-  const char *option_value = NULL;\n   char *p = argv[0];\n \n   strings_processed = cpp_handle_option (parse_in, argc, argv);\n@@ -593,14 +592,8 @@ c_decode_option (argc, argv)\n     flag_no_builtin = 0;\n   else if (!strcmp (p, \"-fno-builtin\"))\n     flag_no_builtin = 1;\n-  else if ((option_value\n-\t    = skip_leading_substring (p, \"-fdump-translation-unit-\")))\n-    {\n-      if (p[22] == '\\0')\n-\terror (\"no file specified with -fdump-translation-unit\");\n-      else\n-\tflag_dump_translation_unit = option_value;\n-    }\n+  else if (dump_switch_p (p))\n+    ;\n   else if (!strcmp (p, \"-ansi\"))\n     goto iso_1990;\n   else if (!strcmp (p, \"-Werror-implicit-function-declaration\"))"}, {"sha": "72de67c7479ae9ba88d9fa5603b9e9a9c468a47a", "filename": "gcc/c-dump.c", "status": "modified", "additions": 133, "deletions": 26, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -40,7 +40,6 @@ static void dequeue_and_dump PARAMS ((dump_info_p));\n static void dump_new_line PARAMS ((dump_info_p));\n static void dump_maybe_newline PARAMS ((dump_info_p));\n static void dump_string_field PARAMS ((dump_info_p, const char *, const char *));\n-static void dump_node PARAMS ((tree, FILE *));\n \n /* Add T to the end of the queue of nodes to dump.  Returns the index\n    assigned to T.  */\n@@ -139,15 +138,20 @@ queue_and_dump_type (di, t)\n   queue_and_dump_index (di, \"type\", TREE_TYPE (t), DUMP_NONE);\n }\n \n+/* Dump column control */\n+#define SOL_COLUMN 25\t\t/* Start of line column. */\n+#define EOL_COLUMN 55\t\t/* End of line column. */\n+#define COLUMN_ALIGNMENT 15\t/* Alignment. */\n+\n /* Insert a new line in the dump output, and indent to an appropriate\n    place to start printing more fields.  */\n \n static void\n dump_new_line (di)\n      dump_info_p di;\n {\n-  fprintf (di->stream, \"\\n%25s\", \"\");\n-  di->column = 25;\n+  fprintf (di->stream, \"\\n%*s\", SOL_COLUMN, \"\");\n+  di->column = SOL_COLUMN;\n }\n \n /* If necessary, insert a new line.  */\n@@ -156,18 +160,33 @@ static void\n dump_maybe_newline (di)\n      dump_info_p di;\n {\n+  int extra;\n+  \n   /* See if we need a new line.  */\n-  if (di->column > 53)\n+  if (di->column > EOL_COLUMN)\n     dump_new_line (di);\n   /* See if we need any padding.  */\n-  else if ((di->column - 25) % 14 != 0)\n+  else if ((extra = (di->column - SOL_COLUMN) % COLUMN_ALIGNMENT) != 0)\n     {\n-      fprintf (di->stream, \"%*s\", 14 - ((di->column - 25) % 14), \"\");\n-      di->column += 14 - (di->column - 25) % 14;\n+      fprintf (di->stream, \"%*s\", COLUMN_ALIGNMENT - extra, \"\");\n+      di->column += COLUMN_ALIGNMENT - extra;\n     }\n }\n \n-/* Dump I using FIELD to identity it.  */\n+/* Dump pointer PTR using FIELD to identify it.  */\n+\n+void\n+dump_pointer (di, field, ptr)\n+     dump_info_p di;\n+     const char *field;\n+     void *ptr;\n+{\n+  dump_maybe_newline (di);\n+  fprintf (di->stream, \"%-4s: %-8lx \", field, (long) ptr);\n+  di->column += 15;\n+}\n+\n+/* Dump integer I using FIELD to identify it.  */\n \n void\n dump_int (di, field, i)\n@@ -349,7 +368,7 @@ dequeue_and_dump (di)\n       /* And any declaration can be compiler-generated.  */\n       if (DECL_ARTIFICIAL (t))\n \tdump_string (di, \"artificial\");\n-      if (TREE_CHAIN (t))\n+      if (TREE_CHAIN (t) && !dump_flag (di, TDF_SLIM, NULL))\n \tdump_child (\"chan\", TREE_CHAIN (t));\n     }\n   else if (code_class == 't')\n@@ -504,7 +523,7 @@ dequeue_and_dump (di)\n \tdump_string (di, \"extern\");\n       else\n \tdump_string (di, \"static\");\n-      if (DECL_LANG_SPECIFIC (t))\n+      if (DECL_LANG_SPECIFIC (t) && !dump_flag (di, TDF_SLIM, t))\n \tdump_child (\"body\", DECL_SAVED_TREE (t));\n       break;\n \n@@ -709,15 +728,30 @@ dequeue_and_dump (di)\n     }\n \n  done:\n+  if (dump_flag (di, TDF_ADDRESS, NULL))\n+    dump_pointer (di, \"addr\", (void *)t);\n+  \n   /* Terminate the line.  */\n   fprintf (di->stream, \"\\n\");\n }\n \n+/* Return non-zero if FLAG has been specified for the dump, and NODE\n+   is not the root node of the dump. */\n+\n+int dump_flag (di, flag, node)\n+     dump_info_p di;\n+     int flag;\n+     tree node;\n+{\n+  return (di->flags & flag) && (node != di->node);\n+}\n+\n /* Dump T, and all its children, on STREAM.  */\n \n-static void\n-dump_node (t, stream)\n+void\n+dump_node (t, flags, stream)\n      tree t;\n+     int flags;\n      FILE *stream;\n {\n   struct dump_info di;\n@@ -731,6 +765,8 @@ dump_node (t, stream)\n   di.queue = 0;\n   di.queue_end = 0;\n   di.free_list = 0;\n+  di.flags = flags;\n+  di.node = t;\n   di.nodes = splay_tree_new (splay_tree_compare_pointers, 0, \n \t\t\t     (splay_tree_delete_value_fn) &free);\n \n@@ -750,21 +786,92 @@ dump_node (t, stream)\n   splay_tree_delete (di.nodes);\n }\n \n-/* Dump T, and all its children, to FILE.  */\n+/* Define a tree dump switch. */\n+struct dump_file_info\n+{\n+  const char *suffix;\t\t/* suffix to give output file. */\n+  const char *swtch;\t\t/* command line switch */\n+  int flags;\t\t\t/* user flags */\n+  int state;\t\t\t/* state of play */\n+};\n+\n+/* Table of tree dump switches. */\n+static struct dump_file_info dump_files[TDI_end] =\n+{\n+  {\".tu\", \"dump-translation-unit\", 0, 0},\n+  {\".original\", \"dump-ast-original\", 0, 0},\n+  {\".optimized\", \"dump-ast-optimized\", 0, 0},\n+  {\".class\", \"dump-class-hierarchy\", 0, 0},\n+};\n+\n+/* Begin a tree dump for PHASE. Stores any user supplied flag in\n+   *FLAG_PTR and returns a stream to write to. If the dump is not\n+   enabled, returns NULL.\n+   Multiple calls will reopen and append to the dump file. */\n+\n+FILE *\n+dump_begin (phase, flag_ptr)\n+     enum tree_dump_index phase;\n+     int *flag_ptr;\n+{\n+  FILE *stream;\n+  char *name;\n+  \n+  if (!dump_files[phase].state)\n+    return NULL;\n+  \n+  name = concat (dump_base_name, dump_files[phase].suffix, NULL);\n+  stream = fopen (name, dump_files[phase].state < 0 ? \"w\" : \"a\");\n+  if (!stream)\n+    error (\"could not open dump file `%s'\", name);\n+  else\n+    dump_files[phase].state = 1;\n+  free (name);\n+  if (flag_ptr)\n+    *flag_ptr = dump_files[phase].flags;\n+  \n+  return stream;\n+}\n \n-void\n-dump_node_to_file (t, file)\n-     tree t;\n-     const char *file;\n+/* Returns non-zero if tree dump PHASE is enabled. */\n+\n+int dump_enabled_p (phase)\n+     enum tree_dump_index phase;\n {\n-  FILE *f;\n+  return dump_files[phase].state;\n+}\n \n-  f = fopen (file, \"w\");\n-  if (!f)\n-    error (\"could not open dump file `%s'\", file);\n-  else\n-    {\n-      dump_node (t, f);\n-      fclose (f);\n-    }\n+/* Finish a tree dump for PHASE. STREAM is the stream created by\n+   dump_begin. */\n+\n+void dump_end (phase, stream)\n+     enum tree_dump_index phase ATTRIBUTE_UNUSED;\n+     FILE *stream;\n+{\n+  fclose (stream);\n+}\n+\n+/* Parse ARG as a dump switch. Return non-zero if it is, and store the\n+   relevant details in the dump_files array. */\n+\n+int dump_switch_p (arg)\n+     const char *arg;\n+{\n+  unsigned ix;\n+  const char *option_value;\n+  \n+  for (ix = 0; ix != TDI_end; ix++)\n+    if ((option_value = skip_leading_substring (arg, dump_files[ix].swtch)))\n+      {\n+\tdump_files[ix].state = -1;\n+\tif (*option_value == '-')\n+\t  dump_files[ix].flags\n+\t    = read_integral_parameter (option_value + 1, arg, 0);\n+\telse if (*option_value)\n+\t  warning (\"ignoring `%s' at end of `-f%s'\",\n+\t\t   option_value, dump_files[ix].swtch);\n+\t\n+\treturn 1;\n+      }\n+  return 0;\n }"}, {"sha": "5daaa37d72088a520af2836c3e54822aa536ffba", "filename": "gcc/c-dump.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.h?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -53,6 +53,10 @@ struct dump_info\n {\n   /* The stream on which to dump the information.  */\n   FILE *stream;\n+  /* The original node. */\n+  tree node;\n+  /* User flags. */\n+  int flags;\n   /* The next unused node index.  */\n   unsigned int index;\n   /* The next column.  */\n@@ -73,6 +77,8 @@ struct dump_info\n #define dump_child(field, child) \\\n   queue_and_dump_index (di, field, child, DUMP_NONE)\n \n+extern void dump_pointer\n+  PARAMS ((dump_info_p, const char *, void *));\n extern void dump_int \n   PARAMS ((dump_info_p, const char *, int));\n extern void dump_string "}, {"sha": "e2c906303f856bb7b9c24e9de1b354d2d744b770", "filename": "gcc/c-lang.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -252,9 +252,17 @@ finish_file ()\n \n   if (back_end_hook)\n     (*back_end_hook) (getdecls ());\n+  \n+  {\n+    int flags;\n+    FILE *stream = dump_begin (TDI_all, &flags);\n \n-  if (flag_dump_translation_unit)\n-    dump_node_to_file (getdecls (), flag_dump_translation_unit);\n+    if (stream)\n+      {\n+\tdump_node (getdecls (), flags & ~TDF_SLIM, stream);\n+\tdump_end (TDI_all, stream);\n+      }\n+  }\n }\n \n /* Called during diagnostic message formatting process to print a"}, {"sha": "8f5ebaa69ea8f24c89784ad85d00afbe7312a336", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -1,3 +1,25 @@\n+2001-06-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* class.c (maybe_indent_hierarchy): New function.\n+\t(dump_class_hierarchy_r): Add flags. Dump extra binfo\n+\tinformation, if enabled. Use maybe_indent_hierarchy. Adjust\n+\toutput format.\n+\t(dump_class_hierarchy): Adjust prototype. Adjust output format.\n+\t(dump_array, dump_vtable, dump_vtt): New functions.\n+\t(finish_struct_1): Adjust hierarchy dumping.\n+\t(initialize_vtable): Call dump_vtable.\n+\t(build_vtt): Call dump_vtt.\n+\t(build_ctor_vtbl_group): Call dump_vtable.\n+\t* decl2.c (flag_dump_class_layout): Remove.\n+\t(cxx_decode_option): Remove dump translation unit\n+\tand dump class hierarchy check. Call dump_switch_p.\n+\t(finish_file): Adjust dumping.\n+\t(dump.c): Only dump base classes if not TDF_SLIM.\n+\tOnly dump namespace members if not TDF_SLIM.\n+\t* optimize.c (dump_function): New function.\n+\t(optimize_function): Call dump_function.\n+\t* semantics.c (expand_body): Use dump_enabled_p.\n+\n 2001-06-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR g++/2936"}, {"sha": "7a7f69b0b7d301eaf1258797e2fd532aea1abe79", "filename": "gcc/cp/class.c", "status": "modified", "additions": 185, "deletions": 41, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -171,8 +171,12 @@ static void layout_vtable_decl PARAMS ((tree, int));\n static tree dfs_find_final_overrider PARAMS ((tree, void *));\n static tree find_final_overrider PARAMS ((tree, tree, tree));\n static int make_new_vtable PARAMS ((tree, tree));\n-static void dump_class_hierarchy_r PARAMS ((FILE *, tree, tree, int));\n-extern void dump_class_hierarchy PARAMS ((const char *, tree));\n+static int maybe_indent_hierarchy PARAMS ((FILE *, int, int));\n+static void dump_class_hierarchy_r PARAMS ((FILE *, int, tree, tree, int));\n+static void dump_class_hierarchy PARAMS ((tree));\n+static void dump_array PARAMS ((FILE *, tree));\n+static void dump_vtable PARAMS ((tree, tree, tree));\n+static void dump_vtt PARAMS ((tree, tree));\n static tree build_vtable PARAMS ((tree, tree, tree));\n static void initialize_vtable PARAMS ((tree, tree));\n static void initialize_array PARAMS ((tree, tree));\n@@ -5308,11 +5312,6 @@ finish_struct_1 (t)\n   layout_class_type (t, &empty, &vfuns,\n \t\t     &new_virtuals, &overridden_virtuals);\n \n-  if (flag_dump_class_layout)\n-    dump_class_hierarchy (*flag_dump_class_layout\n-                          ? flag_dump_class_layout : NULL,\n-                          t);\n-  \n   /* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we\n      might need to know it for setting up the offsets in the vtable\n      (or in thunks) below.  */\n@@ -5468,6 +5467,8 @@ finish_struct_1 (t)\n \n   maybe_suppress_debug_info (t);\n \n+  dump_class_hierarchy (t);\n+  \n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (t, ! LOCAL_CLASS_P (t));\n }\n@@ -6805,22 +6806,38 @@ get_primary_binfo (binfo)\n   return result;\n }\n \n+/* If INDENTED_P is zero, indent to INDENT. Return non-zero. */\n+\n+static int\n+maybe_indent_hierarchy (stream, indent, indented_p)\n+     FILE *stream;\n+     int indent;\n+     int indented_p;\n+{\n+  if (!indented_p)\n+    fprintf (stream, \"%*s\", indent, \"\");\n+  return 1;\n+}\n+\n /* Dump the offsets of all the bases rooted at BINFO (in the hierarchy\n    dominated by T) to stderr.  INDENT should be zero when called from\n    the top level; it is incremented recursively.  */\n \n static void\n-dump_class_hierarchy_r (stream, t, binfo, indent)\n+dump_class_hierarchy_r (stream, flags, t, binfo, indent)\n      FILE *stream;\n+     int flags;\n      tree t;\n      tree binfo;\n      int indent;\n {\n   int i;\n-\n-  fprintf (stream, \"%*s0x%lx (%s) \", indent, \"\",\n-\t   (unsigned long) binfo,\n-\t   type_as_string (binfo, TFF_PLAIN_IDENTIFIER));\n+  int indented = 0;\n+  \n+  indented = maybe_indent_hierarchy (stream, indent, 0);\n+  fprintf (stream, \"%s (0x%lx) \",\n+\t   type_as_string (binfo, TFF_PLAIN_IDENTIFIER),\n+\t   (unsigned long) binfo);\n   fprintf (stream, HOST_WIDE_INT_PRINT_DEC,\n \t   tree_low_cst (BINFO_OFFSET (binfo), 0));\n   if (is_empty_class (BINFO_TYPE (binfo)))\n@@ -6830,51 +6847,174 @@ dump_class_hierarchy_r (stream, t, binfo, indent)\n   if (TREE_VIA_VIRTUAL (binfo))\n     {\n       tree canonical = binfo_for_vbase (BINFO_TYPE (binfo), t);\n-      \n+\n+      fprintf (stream, \" virtual\");\n       if (canonical == binfo)\n-        fprintf (stream, \" virtual-canonical\");\n+        fprintf (stream, \" canonical\");\n       else\n-        fprintf (stream, \" virtual-non-canonical\");\n+        fprintf (stream, \" non-canonical\");\n     }\n-  if (BINFO_PRIMARY_P (binfo))\n-    fprintf (stream, \" primary-for 0x%lx (%s)\",\n-             (unsigned long)BINFO_PRIMARY_BASE_OF (binfo),\n-             type_as_string (BINFO_PRIMARY_BASE_OF (binfo), TFF_PLAIN_IDENTIFIER));\n-  if (BINFO_LOST_PRIMARY_P (binfo))\n-    fprintf (stream, \" lost-primary\");\n   fprintf (stream, \"\\n\");\n \n+  indented = 0;\n+  if (BINFO_PRIMARY_BASE_OF (binfo))\n+    {\n+      indented = maybe_indent_hierarchy (stream, indent + 3, indented);\n+      fprintf (stream, \" primary-for %s (0x%lx)\",\n+\t       type_as_string (BINFO_PRIMARY_BASE_OF (binfo),\n+\t\t\t       TFF_PLAIN_IDENTIFIER),\n+\t       (unsigned long)BINFO_PRIMARY_BASE_OF (binfo));\n+    }\n+  if (BINFO_LOST_PRIMARY_P (binfo))\n+    {\n+      indented = maybe_indent_hierarchy (stream, indent + 3, indented);\n+      fprintf (stream, \" lost-primary\");\n+    }\n+  if (indented)\n+    fprintf (stream, \"\\n\");\n+\n+  if (!(flags & TDF_SLIM))\n+    {\n+      int indented = 0;\n+      \n+      if (BINFO_SUBVTT_INDEX (binfo))\n+\t{\n+\t  indented = maybe_indent_hierarchy (stream, indent + 3, indented);\n+\t  fprintf (stream, \" subvttidx=%s\",\n+\t\t   expr_as_string (BINFO_SUBVTT_INDEX (binfo),\n+\t\t\t\t   TFF_PLAIN_IDENTIFIER));\n+\t}\n+      if (BINFO_VPTR_INDEX (binfo))\n+\t{\n+\t  indented = maybe_indent_hierarchy (stream, indent + 3, indented);\n+\t  fprintf (stream, \" vptridx=%s\",\n+\t\t   expr_as_string (BINFO_VPTR_INDEX (binfo),\n+\t\t\t\t   TFF_PLAIN_IDENTIFIER));\n+\t}\n+      if (BINFO_VPTR_FIELD (binfo))\n+\t{\n+\t  indented = maybe_indent_hierarchy (stream, indent + 3, indented);\n+\t  fprintf (stream, \" vbaseoffset=%s\",\n+\t\t   expr_as_string (BINFO_VPTR_FIELD (binfo),\n+\t\t\t\t   TFF_PLAIN_IDENTIFIER));\n+\t}\n+      if (BINFO_VTABLE (binfo))\n+\t{\n+\t  indented = maybe_indent_hierarchy (stream, indent + 3, indented);\n+\t  fprintf (stream, \" vptr=%s\",\n+\t\t   expr_as_string (BINFO_VTABLE (binfo),\n+\t\t\t\t   TFF_PLAIN_IDENTIFIER));\n+\t}\n+      \n+      if (indented)\n+\tfprintf (stream, \"\\n\");\n+    }\n+  \n+\n   for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n-    dump_class_hierarchy_r (stream, t, BINFO_BASETYPE (binfo, i), indent + 2);\n+    dump_class_hierarchy_r (stream, flags,\n+\t\t\t    t, BINFO_BASETYPE (binfo, i),\n+\t\t\t    indent + 2);\n }\n \n /* Dump the BINFO hierarchy for T.  */\n \n-void\n-dump_class_hierarchy (name, t)\n-     const char *name;\n+static void\n+dump_class_hierarchy (t)\n      tree t;\n {\n-  FILE *stream = stderr;\n+  int flags;\n+  FILE *stream = dump_begin (TDI_class, &flags);\n+\n+  if (!stream)\n+    return;\n   \n-  if (name)\n+  fprintf (stream, \"Class %s\\n\", type_as_string (t, TFF_PLAIN_IDENTIFIER));\n+  fprintf (stream, \"   size=%lu align=%lu\\n\",\n+\t   (unsigned long)(tree_low_cst (TYPE_SIZE (t), 0) / BITS_PER_UNIT),\n+\t   (unsigned long)(TYPE_ALIGN (t) / BITS_PER_UNIT));\n+  dump_class_hierarchy_r (stream, flags, t, TYPE_BINFO (t), 0);\n+  fprintf (stream, \"\\n\");\n+  dump_end (TDI_class, stream);\n+}\n+\n+static void\n+dump_array (stream, decl)\n+     FILE *stream;\n+     tree decl;\n+{\n+  tree inits;\n+  int ix;\n+  HOST_WIDE_INT elt;\n+  tree size = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (decl)));\n+\n+  elt = (tree_low_cst (TYPE_SIZE (TREE_TYPE (TREE_TYPE (decl))), 0)\n+\t / BITS_PER_UNIT);\n+  fprintf (stream, \"%s:\", decl_as_string (decl, TFF_PLAIN_IDENTIFIER));\n+  fprintf (stream, \" %s entries\",\n+\t   expr_as_string (size_binop (PLUS_EXPR, size, size_one_node),\n+\t\t\t   TFF_PLAIN_IDENTIFIER));\n+  fprintf (stream, \"\\n\");\n+\n+  for (ix = 0, inits = TREE_OPERAND (DECL_INITIAL (decl), 1);\n+       inits; ix++, inits = TREE_CHAIN (inits))\n+    fprintf (stream, \"%-4d  %s\\n\", ix * elt,\n+\t     expr_as_string (TREE_VALUE (inits), TFF_PLAIN_IDENTIFIER));\n+}\n+\n+static void\n+dump_vtable (t, binfo, vtable)\n+     tree t;\n+     tree binfo;\n+     tree vtable;\n+{\n+  int flags;\n+  FILE *stream = dump_begin (TDI_class, &flags);\n+\n+  if (!stream)\n+    return;\n+\n+  if (!(flags & TDF_SLIM))\n     {\n-      static int append = 0;\n+      int ctor_vtbl_p = TYPE_BINFO (t) != binfo;\n       \n-      stream = fopen (name, append++ ? \"a\" : \"w\");\n-      if (!stream)\n-        error (\"could not open dump file `%s'\", name);\n-      return;\n+      fprintf (stream, \"%s for %s\",\n+\t       ctor_vtbl_p ? \"Construction vtable\" : \"Vtable\",\n+\t       type_as_string (binfo, TFF_PLAIN_IDENTIFIER));\n+      if (ctor_vtbl_p)\n+\t{\n+\t  if (!TREE_VIA_VIRTUAL (binfo))\n+\t    fprintf (stream, \" (0x%lx instance)\", (unsigned long)binfo);\n+\t  fprintf (stream, \" in %s\", type_as_string (t, TFF_PLAIN_IDENTIFIER));\n+\t}\n+      fprintf (stream, \"\\n\");\n+      dump_array (stream, vtable);\n+      fprintf (stream, \"\\n\");\n     }\n-  fprintf (stream, \"%s size=\", type_as_string (t, TFF_PLAIN_IDENTIFIER));\n-  fprintf (stream, HOST_WIDE_INT_PRINT_DEC,\n-\t   tree_low_cst (TYPE_SIZE (t), 0) / BITS_PER_UNIT);\n-  fprintf (stream, \" align=%lu\\n\",\n-\t   (unsigned long)(TYPE_ALIGN (t) / BITS_PER_UNIT));\n-  dump_class_hierarchy_r (stream, t, TYPE_BINFO (t), 0);\n-  fprintf (stream, \"\\n\");\n-  if (name)\n-    fclose (stream);\n+  \n+  dump_end (TDI_class, stream);\n+}\n+\n+static void\n+dump_vtt (t, vtt)\n+     tree t;\n+     tree vtt;\n+{\n+  int flags;\n+  FILE *stream = dump_begin (TDI_class, &flags);\n+\n+  if (!stream)\n+    return;\n+\n+  if (!(flags & TDF_SLIM))\n+    {\n+      fprintf (stream, \"VTT for %s\\n\",\n+\t       type_as_string (t, TFF_PLAIN_IDENTIFIER));\n+      dump_array (stream, vtt);\n+      fprintf (stream, \"\\n\");\n+    }\n+  \n+  dump_end (TDI_class, stream);\n }\n \n /* Virtual function table initialization.  */\n@@ -6957,6 +7097,7 @@ initialize_vtable (binfo, inits)\n   layout_vtable_decl (binfo, list_length (inits));\n   decl = get_vtbl_decl_for_binfo (binfo);\n   initialize_array (decl, inits);\n+  dump_vtable (BINFO_TYPE (binfo), binfo, decl);\n }\n \n /* Initialize DECL (a declaration for a namespace-scope array) with\n@@ -7015,6 +7156,8 @@ build_vtt (t)\n   vtt = build_vtable (t, get_vtt_name (t), type);\n   pushdecl_top_level (vtt);\n   initialize_array (vtt, inits);\n+\n+  dump_vtt (t, vtt);\n }\n \n /* The type corresponding to BASE_BINFO is a base of the type of BINFO, but\n@@ -7332,6 +7475,7 @@ build_ctor_vtbl_group (binfo, t)\n   /* Initialize the construction vtable.  */\n   pushdecl_top_level (vtbl);\n   initialize_array (vtbl, inits);\n+  dump_vtable (t, binfo, vtbl);\n }\n \n /* Add the vtbl initializers for BINFO (and its bases other than"}, {"sha": "c1aa3281c2751b845f8dddf2d63a9714df7c38ff", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -368,10 +368,6 @@ int flag_operator_names = 1;\n \n int flag_check_new;\n \n-/* Nonnull if we want to dump class heirarchies.  */\n-\n-const char *flag_dump_class_layout;\n-\n /* Nonzero if we want the new ISO rules for pushing a new scope for `for'\n    initialization variables.\n    0: Old rules, set by -fno-for-scope.\n@@ -590,24 +586,8 @@ cxx_decode_option (argc, argv)\n \t  warning (\"-fname-mangling-version is no longer supported\");\n \t  return 1;\n \t}\n-      else if ((option_value\n-                = skip_leading_substring (p, \"dump-translation-unit=\")))\n-\t{\n-\t  if (!*option_value)\n-\t    error (\"no file specified with -fdump-translation-unit\");\n-\t  else\n-\t    flag_dump_translation_unit = option_value;\n-\t}\n-      else if ((option_value\n-                = skip_leading_substring (p, \"dump-class-layout=\")))\n-\t{\n-\t  if (!*option_value)\n-\t    error (\"no file specified with -fdump-class-layout\");\n-\t  else\n-\t    flag_dump_class_layout = option_value;\n-\t}\n-      else if (!strcmp (p, \"dump-class-layout\"))\n-\tflag_dump_class_layout = \"\"; /* empty string for stderr */\n+      else if (dump_switch_p (p))\n+\t;\n       else \n \t{\n \t  int found = 0;\n@@ -3715,9 +3695,17 @@ finish_file ()\n \n   /* The entire file is now complete.  If requested, dump everything\n      to a file.   */\n-  if (flag_dump_translation_unit)\n-    dump_node_to_file (global_namespace, flag_dump_translation_unit);\n+  {\n+    int flags;\n+    FILE *stream = dump_begin (TDI_all, &flags);\n \n+    if (stream)\n+      {\n+\tdump_node (global_namespace, flags & ~TDF_SLIM, stream);\n+\tdump_end (TDI_all, stream);\n+      }\n+  }\n+  \n   /* If there's some tool that wants to examine the entire translation\n      unit, let it do so now.  */\n   if (back_end_hook)"}, {"sha": "4826585c11d4596297d8cd14a1e7534fe0f46771", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -101,19 +101,20 @@ cp_dump_tree (di, t)\n \t}\n \n       dump_child (\"vfld\", TYPE_VFIELD (t));\n-\t\n-      {\n-\tint i;\n-\n-\tfor (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n-\t  {\n-\t    tree base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n-\t    dump_child (\"base\", BINFO_TYPE (base_binfo));\n-\t    if (TREE_VIA_VIRTUAL (base_binfo)) \n-\t      dump_string (di, \"virtual\");\n-\t    dump_access (di, base_binfo);\n-\t  }\n-      }\n+\n+      if (!dump_flag (di, TDF_SLIM, t))\n+\t{\n+\t  int i;\n+\t  \n+\t  for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); ++i)\n+\t    {\n+\t      tree base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n+\t      dump_child (\"base\", BINFO_TYPE (base_binfo));\n+\t      if (TREE_VIA_VIRTUAL (base_binfo)) \n+\t\tdump_string (di, \"virtual\");\n+\t      dump_access (di, base_binfo);\n+\t    }\n+\t}\n       break;\n \n     case FIELD_DECL:\n@@ -163,7 +164,7 @@ cp_dump_tree (di, t)\n \tbreak;\n       if (DECL_NAMESPACE_ALIAS (t))\n \tdump_child (\"alis\", DECL_NAMESPACE_ALIAS (t));\n-      else\n+      else if (!dump_flag (di, TDF_SLIM, t))\n \tdump_child (\"dcls\", cp_namespace_decls (t));\n       break;\n "}, {"sha": "aee64f521a31482b99ca9bef288dbd163e1ddbf6", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -100,6 +100,7 @@ static void remap_block PARAMS ((tree, tree, inline_data *));\n static void copy_scope_stmt PARAMS ((tree *, int *, inline_data *));\n static tree calls_setjmp_r PARAMS ((tree *, int *, void *));\n static void update_cloned_parm PARAMS ((tree, tree));\n+static void dump_function PARAMS ((enum tree_dump_index, tree));\n \n /* The approximate number of instructions per statement.  This number\n    need not be particularly accurate; it is used only to make\n@@ -933,12 +934,14 @@ expand_calls_inline (tp, id)\n   walk_tree (tp, expand_call_inline, id, id->tree_pruner);\n }\n \n-/* Optimize the body of FN.  */\n+/* Optimize the body of FN. */\n \n void\n optimize_function (fn)\n      tree fn;\n {\n+  dump_function (TDI_original, fn);\n+\n   /* While in this function, we may choose to go off and compile\n      another function.  For example, we might instantiate a function\n      in the hopes of inlining it.  Normally, that wouldn't trigger any\n@@ -1010,6 +1013,8 @@ optimize_function (fn)\n \n   /* Undo the call to ggc_push_context above.  */\n   --function_depth;\n+  \n+  dump_function (TDI_optimized, fn);\n }\n \n /* Called from calls_setjmp_p via walk_tree.  */\n@@ -1225,3 +1230,26 @@ maybe_clone_body (fn)\n   /* We don't need to process the original function any further.  */\n   return 1;\n }\n+\n+/* Dump FUNCTION_DECL FN as tree dump PHASE. */\n+\n+static void\n+dump_function (phase, fn)\n+     enum tree_dump_index phase;\n+     tree fn;\n+{\n+  FILE *stream;\n+  int flags;\n+\n+  stream = dump_begin (phase, &flags);\n+  if (stream)\n+    {\n+      fprintf (stream, \"\\n;; Function %s\",\n+\t       decl_as_string (fn, TFF_DECL_SPECIFIERS));\n+      fprintf (stream, \" (%s)\", decl_as_string (DECL_ASSEMBLER_NAME (fn), 0));\n+      fprintf (stream, \"\\n\\n\");\n+      \n+      dump_node (fn, TDF_SLIM | flags, stream);\n+      dump_end (phase, stream);\n+    }\n+}"}, {"sha": "b30c80e8c3d687a92b60ab16b7b42213f6c0c73a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -2435,7 +2435,7 @@ expand_body (fn)\n \n   /* If possible, obliterate the body of the function so that it can\n      be garbage collected.  */\n-  if (flag_dump_translation_unit)\n+  if (dump_enabled_p (TDI_all))\n     /* Keep the body; we're going to dump it.  */\n     ;\n   else if (DECL_INLINE (fn) && flag_inline_trees)"}, {"sha": "b035149e416906e0bc147ba725c4ff3d86d9b728", "filename": "gcc/invoke.texi", "status": "added", "additions": 8755, "deletions": 0, "changes": 8755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d"}, {"sha": "8d0d2a6de023deb34a55aa46f43606c0e5cd425a", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7442fb5553f2ea9d738e5f2a1177c655baa442d/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=b7442fb5553f2ea9d738e5f2a1177c655baa442d", "patch": "@@ -137,6 +137,7 @@ extern int warningcount;\n extern int sorrycount;\n \n extern const char *progname;\n+extern const char *dump_base_name;\n \n /* Language-specific hooks.  Can be NULL unless otherwise specified.  */\n struct lang_hooks"}]}