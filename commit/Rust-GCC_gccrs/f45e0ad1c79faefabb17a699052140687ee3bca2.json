{"sha": "f45e0ad1c79faefabb17a699052140687ee3bca2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ1ZTBhZDFjNzlmYWVmYWJiMTdhNjk5MDUyMTQwNjg3ZWUzYmNhMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-12-30T11:58:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-12-30T11:58:01Z"}, "message": "cgraph.c (cgraph_exapnd_queue): Rename to...\n\n\n\t* cgraph.c (cgraph_exapnd_queue): Rename to...\n\t(cgraph_new_nodes): ... this one.\n\t(cgraph_state): New global variable.\n\t(cgraph_add_new_function): Work in more cases.\n\t* cgraph.h (cgraph_expand_queue): Rename to ...\n\t(cgraph_new_nodes): ... this one.\n\t(cgraph_state): New enum and static variable.\n\t(cgraph_add_new_function): Update prototype.\n\t(cgraph_process_new_functions): New.\n\t* omp-low.c (expand_omp_parallel): Update.\n\t* cgraphunit.c (initialize_inline_failed): Declare early.\n\t(cgraph_process_new_functions): New function.\n\t(cgraph_assemble_pending_functions): Use it.\n\t(cgraph_expand_all_functions): Use it.\n\t(cgraph_optimize): Use it; set cgraph_state.\n\t* passes.c (execute_one_pass, execute_ipa_pass_list): Process new\n\tfunctions\n\nFrom-SVN: r120282", "tree": {"sha": "4ee7560469c1e50ca7f51f6e50bca995ec5871a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ee7560469c1e50ca7f51f6e50bca995ec5871a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f45e0ad1c79faefabb17a699052140687ee3bca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f45e0ad1c79faefabb17a699052140687ee3bca2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f45e0ad1c79faefabb17a699052140687ee3bca2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f45e0ad1c79faefabb17a699052140687ee3bca2/comments", "author": null, "committer": null, "parents": [{"sha": "e288c21aea32c7a9424cc4b89fc4a7c75b9e5fb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e288c21aea32c7a9424cc4b89fc4a7c75b9e5fb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e288c21aea32c7a9424cc4b89fc4a7c75b9e5fb2"}], "stats": {"total": 227, "additions": 178, "deletions": 49}, "files": [{"sha": "b728b00e54cdf3f3c3741337d5afae45a53b3762", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f45e0ad1c79faefabb17a699052140687ee3bca2", "patch": "@@ -1,3 +1,23 @@\n+2006-12-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_exapnd_queue): Rename to...\n+\t(cgraph_new_nodes): ... this one.\n+\t(cgraph_state): New global variable.\n+\t(cgraph_add_new_function): Work in more cases.\n+\t* cgraph.h (cgraph_expand_queue): Rename to ...\n+\t(cgraph_new_nodes): ... this one.\n+\t(cgraph_state): New enum and static variable.\n+\t(cgraph_add_new_function): Update prototype.\n+\t(cgraph_process_new_functions): New.\n+\t* omp-low.c (expand_omp_parallel): Update.\n+\t* cgraphunit.c (initialize_inline_failed): Declare early.\n+\t(cgraph_process_new_functions): New function.\n+\t(cgraph_assemble_pending_functions): Use it.\n+\t(cgraph_expand_all_functions): Use it.\n+\t(cgraph_optimize): Use it; set cgraph_state.\n+\t* passes.c (execute_one_pass, execute_ipa_pass_list): Process new\n+\tfunctions\n+\n 2006-12-29  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* tree-cfg.c (last_stmt_ptr): Remove."}, {"sha": "21e821c2b4df030cf2594455e69e551e9650eee4", "filename": "gcc/cgraph.c", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=f45e0ad1c79faefabb17a699052140687ee3bca2", "patch": "@@ -97,10 +97,10 @@ struct cgraph_node *cgraph_nodes;\n /* Queue of cgraph nodes scheduled to be lowered.  */\n struct cgraph_node *cgraph_nodes_queue;\n \n-/* Queue of cgraph nodes scheduled to be expanded.  This is a\n+/* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n    secondary queue used during optimization to accommodate passes that\n    may generate new functions that need to be optimized and expanded.  */\n-struct cgraph_node *cgraph_expand_queue;\n+struct cgraph_node *cgraph_new_nodes;\n \n /* Number of nodes in existence.  */\n int cgraph_n_nodes;\n@@ -111,6 +111,9 @@ int cgraph_max_uid;\n /* Set when whole unit has been analyzed so we can access global info.  */\n bool cgraph_global_info_ready = false;\n \n+/* What state callgraph is in right now.  */\n+enum cgraph_state cgraph_state = CGRAPH_STATE_CONSTRUCTION;\n+\n /* Set when the cgraph is fully build and the basic flags are computed.  */\n bool cgraph_function_flags_ready = false;\n \n@@ -911,23 +914,60 @@ cgraph_function_body_availability (struct cgraph_node *node)\n   return avail;\n }\n \n-/* Add the function FNDECL to the call graph.  FNDECL is assumed to be\n-   in low GIMPLE form and ready to be processed by cgraph_finalize_function.\n+/* Add the function FNDECL to the call graph.\n+   Unlike cgraph_finalize_function, this function is intended to be used\n+   by middle end and allows insertion of new function at arbitrary point\n+   of compilation.  The function can be either in high, low or SSA form\n+   GIMPLE.\n \n-   When operating in unit-at-a-time, a new callgraph node is added to\n-   CGRAPH_EXPAND_QUEUE, which is processed after all the original\n-   functions in the call graph .\n+   The function is assumed to be reachable and have address taken (so no\n+   API breaking optimizations are performed on it).  \n \n-   When not in unit-at-a-time, the new callgraph node is added to\n-   CGRAPH_NODES_QUEUE for cgraph_assemble_pending_functions to\n-   process.  */\n+   Main work done by this function is to enqueue the function for later\n+   processing to avoid need the passes to be re-entrant.  */\n \n void\n-cgraph_add_new_function (tree fndecl)\n+cgraph_add_new_function (tree fndecl, bool lowered)\n {\n-  struct cgraph_node *n = cgraph_node (fndecl);\n-  n->next_needed = cgraph_expand_queue;\n-  cgraph_expand_queue = n;\n+  struct cgraph_node *node;\n+  switch (cgraph_state)\n+    {\n+      case CGRAPH_STATE_CONSTRUCTION:\n+\t/* Just enqueue function to be processed at nearest occurence.  */\n+\tnode = cgraph_node (fndecl);\n+\tnode->next_needed = cgraph_new_nodes;\n+\tif (lowered)\n+\t  node->lowered = true;\n+\tcgraph_new_nodes = node;\n+        break;\n+\n+      case CGRAPH_STATE_IPA:\n+      case CGRAPH_STATE_EXPANSION:\n+\t/* Bring the function into finalized state and enqueue for later\n+\t   analyzing and compilation.  */\n+\tnode = cgraph_node (fndecl);\n+\tnode->local.local = false;\n+\tnode->local.finalized = true;\n+\tnode->reachable = node->needed = true;\n+\tif (lowered)\n+\t  node->lowered = true;\n+\tnode->next_needed = cgraph_new_nodes;\n+\tcgraph_new_nodes = node;\n+        break;\n+\n+      case CGRAPH_STATE_FINISHED:\n+\t/* At the very end of compilation we have to do all the work up\n+\t   to expansion.  */\n+\tpush_cfun (DECL_STRUCT_FUNCTION (fndecl));\n+\tcurrent_function_decl = fndecl;\n+\ttree_register_cfg_hooks ();\n+\tif (!lowered)\n+          tree_lowering_passes (fndecl);\n+\ttree_rest_of_compilation (fndecl);\n+\tpop_cfun ();\n+\tcurrent_function_decl = NULL;\n+\tbreak;\n+    }\n }\n \n #include \"gt-cgraph.h\""}, {"sha": "e363819f166bd648e40139526621bee14b015295", "filename": "gcc/cgraph.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=f45e0ad1c79faefabb17a699052140687ee3bca2", "patch": "@@ -254,9 +254,21 @@ extern GTY(()) struct cgraph_node *cgraph_nodes;\n extern GTY(()) int cgraph_n_nodes;\n extern GTY(()) int cgraph_max_uid;\n extern bool cgraph_global_info_ready;\n+enum cgraph_state\n+{\n+  /* Callgraph is being constructed.  It is safe to add new functions.  */\n+  CGRAPH_STATE_CONSTRUCTION,\n+  /* Callgraph is built and IPA passes are being run.  */\n+  CGRAPH_STATE_IPA,\n+  /* Functions are now ordered and being passed to RTL expanders.  */\n+  CGRAPH_STATE_EXPANSION,\n+  /* All cgraph expansion is done.  */\n+  CGRAPH_STATE_FINISHED\n+};\n+extern enum cgraph_state cgraph_state;\n extern bool cgraph_function_flags_ready;\n extern GTY(()) struct cgraph_node *cgraph_nodes_queue;\n-extern GTY(()) struct cgraph_node *cgraph_expand_queue;\n+extern GTY(()) struct cgraph_node *cgraph_new_nodes;\n \n extern GTY(()) struct cgraph_asm_node *cgraph_asm_nodes;\n extern GTY(()) int cgraph_order;\n@@ -295,7 +307,7 @@ void cgraph_unnest_node (struct cgraph_node *);\n enum availability cgraph_function_body_availability (struct cgraph_node *);\n bool cgraph_is_master_clone (struct cgraph_node *);\n struct cgraph_node *cgraph_master_clone (struct cgraph_node *);\n-void cgraph_add_new_function (tree);\n+void cgraph_add_new_function (tree, bool);\n \n /* In cgraphunit.c  */\n void cgraph_finalize_function (tree, bool);\n@@ -316,6 +328,7 @@ struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n void cgraph_analyze_function (struct cgraph_node *);\n struct cgraph_node *save_inline_function_body (struct cgraph_node *);\n void record_references_in_initializer (tree);\n+bool cgraph_process_new_functions (void);\n \n /* In ipa.c  */\n bool cgraph_remove_unreachable_nodes (bool, FILE *);"}, {"sha": "0aa9f7de124c92ac97d25759bbc4b2fb266da31d", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 83, "deletions": 32, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=f45e0ad1c79faefabb17a699052140687ee3bca2", "patch": "@@ -167,6 +167,7 @@ static void cgraph_expand_function (struct cgraph_node *);\n static tree record_reference (tree *, int *, void *);\n static void cgraph_output_pending_asms (void);\n static void cgraph_increase_alignment (void);\n+static void initialize_inline_failed (struct cgraph_node *);\n \n /* Records tree nodes seen in record_reference.  Simply using\n    walk_tree_without_duplicates doesn't guarantee each node is visited\n@@ -262,6 +263,77 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   return false;\n }\n \n+/* Process CGRAPH_NEW_FUNCTIONS and perform actions neccesary to add these\n+   functions into callgraph in a way so they look like ordinary reachable\n+   functions inserted into callgraph already at construction time.  */\n+\n+bool\n+cgraph_process_new_functions (void)\n+{\n+  bool output = false;\n+  tree fndecl;\n+  struct cgraph_node *node;\n+\n+  /*  Note that this queue may grow as its being processed, as the new\n+      functions may generate new ones.  */\n+  while (cgraph_new_nodes)\n+    {\n+      node = cgraph_new_nodes;\n+      fndecl = node->decl;\n+      cgraph_new_nodes = cgraph_new_nodes->next_needed;\n+      switch (cgraph_state)\n+\t{\n+\tcase CGRAPH_STATE_CONSTRUCTION:\n+\t  /* At construction time we just need to finalize function and move\n+\t     it into reachable functions list.  */\n+\n+\t  node->next_needed = NULL;\n+\t  cgraph_finalize_function (fndecl, false);\n+\t  cgraph_mark_reachable_node (node);\n+\t  output = true;\n+\t  break;\n+\n+\tcase CGRAPH_STATE_IPA:\n+\t  /* When IPA optimization already started, do all essential\n+\t     transformations that has been already performed on the whole\n+\t     cgraph but not on this function.  */\n+\n+\t  tree_register_cfg_hooks ();\n+\t  if (!node->analyzed)\n+\t    cgraph_analyze_function (node);\n+\t  push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n+\t  current_function_decl = fndecl;\n+\t  node->local.inlinable = tree_inlinable_function_p (fndecl);\n+\t  node->local.self_insns = estimate_num_insns (fndecl);\n+\t  node->local.disregard_inline_limits\n+\t    = lang_hooks.tree_inlining.disregard_inline_limits (fndecl);\n+\t  /* Inlining characteristics are maintained by the\n+\t     cgraph_mark_inline.  */\n+\t  node->global.insns = node->local.self_insns;\n+\t  initialize_inline_failed (node);\n+\t  if (flag_really_no_inline && !node->local.disregard_inline_limits)\n+\t     node->local.inlinable = 0;\n+\t  free_dominance_info (CDI_POST_DOMINATORS);\n+\t  free_dominance_info (CDI_DOMINATORS);\n+\t  pop_cfun ();\n+\t  current_function_decl = NULL;\n+\t  break;\n+\n+\tcase CGRAPH_STATE_EXPANSION:\n+\t  /* Functions created during expansion shall be compiled\n+\t     directly.  */\n+\t  node->output = 0;\n+\t  cgraph_expand_function (node);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\t}\n+    }\n+  return output;\n+}\n+\n /* When not doing unit-at-a-time, output all functions enqueued.\n    Return true when such a functions were found.  */\n \n@@ -288,18 +360,7 @@ cgraph_assemble_pending_functions (void)\n \t  cgraph_expand_function (n);\n \t  output = true;\n \t}\n-    }\n-\n-  /* Process CGRAPH_EXPAND_QUEUE, these are functions created during\n-     the expansion process.  Note that this queue may grow as its\n-     being processed, as the new functions may generate new ones.  */\n-  while (cgraph_expand_queue)\n-    {\n-      struct cgraph_node *n = cgraph_expand_queue;\n-      cgraph_expand_queue = cgraph_expand_queue->next_needed;\n-      n->next_needed = NULL;\n-      cgraph_finalize_function (n->decl, false);\n-      output = true;\n+      output |= cgraph_process_new_functions ();\n     }\n \n   return output;\n@@ -1161,21 +1222,10 @@ cgraph_expand_all_functions (void)\n \t  cgraph_expand_function (node);\n \t}\n     }\n+  cgraph_process_new_functions ();\n \n   free (order);\n \n-  /* Process CGRAPH_EXPAND_QUEUE, these are functions created during\n-     the expansion process.  Note that this queue may grow as its\n-     being processed, as the new functions may generate new ones.  */\n-  while (cgraph_expand_queue)\n-    {\n-      node = cgraph_expand_queue;\n-      cgraph_expand_queue = cgraph_expand_queue->next_needed;\n-      node->next_needed = NULL;\n-      node->output = 0;\n-      node->lowered = DECL_STRUCT_FUNCTION (node->decl)->cfg != NULL;\n-      cgraph_expand_function (node);\n-    }\n }\n \n /* This is used to sort the node types by the cgraph order number.  */\n@@ -1383,6 +1433,9 @@ cgraph_optimize (void)\n #endif\n   if (!flag_unit_at_a_time)\n     {\n+      cgraph_assemble_pending_functions ();\n+      cgraph_process_new_functions ();\n+      cgraph_state = CGRAPH_STATE_FINISHED;\n       cgraph_output_pending_asms ();\n       varpool_assemble_pending_decls ();\n       varpool_output_debug_info ();\n@@ -1408,6 +1461,7 @@ cgraph_optimize (void)\n       fprintf (cgraph_dump_file, \"Marked \");\n       dump_cgraph (cgraph_dump_file);\n     }\n+  cgraph_state = CGRAPH_STATE_IPA;\n     \n   /* Don't run the IPA passes if there was any error or sorry messages.  */\n   if (errorcount == 0 && sorrycount == 0)\n@@ -1440,6 +1494,7 @@ cgraph_optimize (void)\n \n   cgraph_mark_functions_to_output ();\n \n+  cgraph_state = CGRAPH_STATE_EXPANSION;\n   if (!flag_toplevel_reorder)\n     cgraph_output_in_order ();\n   else\n@@ -1452,6 +1507,8 @@ cgraph_optimize (void)\n       varpool_assemble_pending_decls ();\n       varpool_output_debug_info ();\n     }\n+  cgraph_process_new_functions ();\n+  cgraph_state = CGRAPH_STATE_FINISHED;\n \n   if (cgraph_dump_file)\n     {\n@@ -1581,14 +1638,8 @@ cgraph_build_static_cdtor (char which, tree body, int priority)\n \n   gimplify_function_tree (decl);\n \n-  /* ??? We will get called LATE in the compilation process.  */\n-  if (cgraph_global_info_ready)\n-    {\n-      tree_lowering_passes (decl);\n-      tree_rest_of_compilation (decl);\n-    }\n-  else\n-    cgraph_finalize_function (decl, 0);\n+  cgraph_add_new_function (decl, false);\n+  cgraph_mark_needed_node (cgraph_node (decl));\n \n   if (targetm.have_ctors_dtors)\n     {"}, {"sha": "e863568d5c4df7a0c0c01bf5722a75bb47f15424", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=f45e0ad1c79faefabb17a699052140687ee3bca2", "patch": "@@ -2533,7 +2533,7 @@ expand_omp_parallel (struct omp_region *region)\n \tsingle_succ_edge (new_bb)->flags = EDGE_FALLTHRU;\n       DECL_STRUCT_FUNCTION (child_fn)->curr_properties\n \t= cfun->curr_properties;\n-      cgraph_add_new_function (child_fn);\n+      cgraph_add_new_function (child_fn, true);\n \n       /* Convert OMP_RETURN into a RETURN_EXPR.  */\n       if (exit_bb)"}, {"sha": "458842163bcd95be0df861bccc58e76c65ac4306", "filename": "gcc/passes.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f45e0ad1c79faefabb17a699052140687ee3bca2/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f45e0ad1c79faefabb17a699052140687ee3bca2", "patch": "@@ -947,6 +947,9 @@ execute_one_pass (struct tree_opt_pass *pass)\n   /* Run post-pass cleanup and verification.  */\n   execute_todo (todo_after | pass->todo_flags_finish);\n \n+  if (!current_function_decl)\n+    cgraph_process_new_functions ();\n+\n   /* Flush and close dump file.  */\n   if (dump_file_name)\n     {\n@@ -986,6 +989,8 @@ execute_ipa_pass_list (struct tree_opt_pass *pass)\n       gcc_assert (!cfun);\n       if (execute_one_pass (pass) && pass->sub)\n \tdo_per_function ((void (*)(void *))execute_pass_list, pass->sub);\n+      if (!current_function_decl)\n+\tcgraph_process_new_functions ();\n       pass = pass->next;\n     }\n   while (pass);"}]}