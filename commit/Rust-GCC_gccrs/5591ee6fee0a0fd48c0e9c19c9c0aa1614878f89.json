{"sha": "5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU5MWVlNmZlZTBhMGZkNDhjMGU5YzE5YzljMGFhMTYxNDg3OGY4OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-12T15:23:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-12T15:23:02Z"}, "message": "(expand_call): Do not reverse args in \"equal from\" field.\n\n\t(emit_library_call_value_1): Emit_libcall_block for const and pure\n\tfunction.\n\nFrom-SVN: r33109", "tree": {"sha": "fcad7608cf7716f13cdcd5fc72f0e1f0d22b5c0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcad7608cf7716f13cdcd5fc72f0e1f0d22b5c0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89/comments", "author": null, "committer": null, "parents": [{"sha": "894a51411ad5e134d30812f26b0923f0398fd1af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/894a51411ad5e134d30812f26b0923f0398fd1af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/894a51411ad5e134d30812f26b0923f0398fd1af"}], "stats": {"total": 63, "additions": 50, "deletions": 13}, "files": [{"sha": "2a1a135bb253f0e9a5d219b95adfcd31c07803a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89", "patch": "@@ -1,3 +1,9 @@\n+Wed Apr 12 17:20:41 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t(expand_call): Do not reverse args in \"equal from\" field.\n+\t(emit_library_call_value_1): Emit_libcall_block for const and pure\n+\tfunction.\n+\n Wed Apr 12 16:00:25 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* reload1.c (reload_combine): Don't enable optimization for fixed"}, {"sha": "642495569a2225fad6dce0337cd2bf26e327b96d", "filename": "gcc/calls.c", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5591ee6fee0a0fd48c0e9c19c9c0aa1614878f89", "patch": "@@ -2833,12 +2833,8 @@ expand_call (exp, target, ignore)\n \n \t  /* Construct an \"equal form\" for the value which mentions all the\n \t     arguments in order as well as the function name.  */\n-\t  if (PUSH_ARGS_REVERSED)\n-\t    for (i = 0; i < num_actuals; i++)\n-\t      note = gen_rtx_EXPR_LIST (VOIDmode, args[i].initial_value, note);\n-\t  else\n-\t    for (i = num_actuals - 1; i >= 0; i--)\n-\t      note = gen_rtx_EXPR_LIST (VOIDmode, args[i].initial_value, note);\n+\t  for (i = 0; i < num_actuals; i++)\n+\t    note = gen_rtx_EXPR_LIST (VOIDmode, args[i].initial_value, note);\n \t  note = gen_rtx_EXPR_LIST (VOIDmode, funexp, note);\n \n \t  insns = get_insns ();\n@@ -3201,6 +3197,7 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n   rtx call_fusage = 0;\n   rtx mem_value = 0;\n+  rtx valreg;\n   int pcc_struct_value = 0;\n   int struct_value_size = 0;\n   int flags = 0;\n@@ -3283,6 +3280,11 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n \n   count = 0;\n \n+  /* Now we are about to start emitting insns that can be deleted\n+     if a libcall is deleted.  */\n+  if (flags & ECF_CONST)\n+    start_sequence ();\n+\n   push_temp_slots ();\n \n   /* If there's a structure value address to be passed,\n@@ -3667,12 +3669,6 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n       NO_DEFER_POP;\n     }\n \n-#if 0\n-  /* For version 1.37, try deleting this entirely.  */\n-  if (! no_queue)\n-    emit_queue ();\n-#endif\n-\n   /* Any regs containing parms remain in use through the call.  */\n   for (count = 0; count < nargs; count++)\n     {\n@@ -3697,6 +3693,8 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n   /* Don't allow popping to be deferred, since then\n      cse'ing of library calls could delete a call and leave the pop.  */\n   NO_DEFER_POP;\n+  valreg = (mem_value == 0 && outmode != VOIDmode\n+\t    ? hard_libcall_value (outmode) : NULL_RTX);\n \n #ifdef PREFERRED_STACK_BOUNDARY\n   /* Stack must to be properly aligned now.  */\n@@ -3718,12 +3716,45 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n                original_args_size.constant, args_size.constant,\n \t       struct_value_size,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n-\t       mem_value == 0 && outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n+\t       valreg,\n \t       old_inhibit_defer_pop + 1, call_fusage, flags);\n \n   /* Now restore inhibit_defer_pop to its actual original value.  */\n   OK_DEFER_POP;\n \n+  /* If call is cse'able, make appropriate pair of reg-notes around it.\n+     Test valreg so we don't crash; may safely ignore `const'\n+     if return type is void.  Disable for PARALLEL return values, because\n+     we have no way to move such values into a pseudo register.  */\n+  if ((flags & ECF_CONST)\n+      && valreg != 0 && GET_CODE (valreg) != PARALLEL)\n+    {\n+      rtx note = 0;\n+      rtx temp = gen_reg_rtx (GET_MODE (valreg));\n+      rtx insns;\n+      int i;\n+\n+      /* Construct an \"equal form\" for the value which mentions all the\n+\t arguments in order as well as the function name.  */\n+      for (i = 0; i < nargs; i++)\n+\tnote = gen_rtx_EXPR_LIST (VOIDmode, argvec[i].value, note);\n+      note = gen_rtx_EXPR_LIST (VOIDmode, fun, note);\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_libcall_block (insns, temp, valreg, note);\n+\n+      valreg = temp;\n+    }\n+  else if (flags & ECF_CONST)\n+    {\n+      /* Otherwise, just write out the sequence without a note.  */\n+      rtx insns = get_insns ();\n+\n+      end_sequence ();\n+      emit_insns (insns);\n+    }\n   pop_temp_slots ();\n \n   /* Copy the value to the right place.  */"}]}