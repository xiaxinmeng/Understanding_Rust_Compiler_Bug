{"sha": "2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI4YjlmNzQ5MTUzNGE5ZjZlMDAwNGYyZWNkYmY4OThkMjRkODQzNA==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2009-10-26T22:00:52Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2009-10-26T22:00:52Z"}, "message": "ea.exp: New file.\n\n2009-10-26  Ben Elliston  <bje@au.ibm.com>\n\t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n\t    Ulrich Weigand  <uweigand@de.ibm.com>\n\n\t* gcc.target/spu/ea/ea.exp: New file.\n\t* gcc.target/spu/ea/cache1.c: Likewise.\n\t* gcc.target/spu/ea/cast1.c: Likewise.\n\t* gcc.target/spu/ea/cast2.c: Likewise.\n\t* gcc.target/spu/ea/compile1.c: Likewise.\n\t* gcc.target/spu/ea/compile2.c: Likewise.\n\t* gcc.target/spu/ea/cppdefine.c: Likewise.\n\t* gcc.target/spu/ea/errors1.c: Likewise.\n\t* gcc.target/spu/ea/errors2.c: Likewise.\n\t* gcc.target/spu/ea/execute1.c: Likewise.\n\t* gcc.target/spu/ea/execute2.c: Likewise.\n\t* gcc.target/spu/ea/execute3.c: Likewise.\n\t* gcc.target/spu/ea/ops1.c: Likewise.\n\t* gcc.target/spu/ea/ops2.c: Likewise.\n\t* gcc.target/spu/ea/options1.c: Likewise.\n\t* gcc.target/spu/ea/test-sizes.c: Likewise.\n\nCo-Authored-By: Michael Meissner <meissner@linux.vnet.ibm.com>\nCo-Authored-By: Ulrich Weigand <uweigand@de.ibm.com>\n\nFrom-SVN: r153576", "tree": {"sha": "d3fe87fbd51d43342fddddff019ffa06755a3bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3fe87fbd51d43342fddddff019ffa06755a3bd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/comments", "author": null, "committer": null, "parents": [{"sha": "299456f3c2978c03a18fc419dc7e29b65e5844f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/299456f3c2978c03a18fc419dc7e29b65e5844f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/299456f3c2978c03a18fc419dc7e29b65e5844f0"}], "stats": {"total": 1688, "additions": 1688, "deletions": 0}, "files": [{"sha": "9673d28c22778e5b6f2e20a983ca86a84134f1ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -1,3 +1,24 @@\n+2009-10-26  Ben Elliston  <bje@au.ibm.com>\n+\t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* gcc.target/spu/ea/ea.exp: New file.\n+\t* gcc.target/spu/ea/cache1.c: Likewise.\n+\t* gcc.target/spu/ea/cast1.c: Likewise.\n+\t* gcc.target/spu/ea/cast2.c: Likewise.\n+\t* gcc.target/spu/ea/compile1.c: Likewise.\n+\t* gcc.target/spu/ea/compile2.c: Likewise.\n+\t* gcc.target/spu/ea/cppdefine.c: Likewise.\n+\t* gcc.target/spu/ea/errors1.c: Likewise.\n+\t* gcc.target/spu/ea/errors2.c: Likewise.\n+\t* gcc.target/spu/ea/execute1.c: Likewise.\n+\t* gcc.target/spu/ea/execute2.c: Likewise.\n+\t* gcc.target/spu/ea/execute3.c: Likewise.\n+\t* gcc.target/spu/ea/ops1.c: Likewise.\n+\t* gcc.target/spu/ea/ops2.c: Likewise.\n+\t* gcc.target/spu/ea/options1.c: Likewise.\n+\t* gcc.target/spu/ea/test-sizes.c: Likewise.\n+\n 2009-10-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/41345"}, {"sha": "3487ce9806bf5de03ab46ddb1c0d19f5de4a30c1", "filename": "gcc/testsuite/gcc.target/spu/ea/cache1.c", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcache1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcache1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcache1.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,195 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* { dg-do run } */\n+/* { dg-require-effective-target \"ealib\" } */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <ea.h>\n+#include <spu_cache.h>\n+\n+#ifdef __EA64__\n+#define addr unsigned long long\n+#else\n+#define addr unsigned long\n+#endif\n+\n+static __ea void *bigblock;\n+static __ea void *block;\n+static int *ls_block;\n+\n+extern char __cache_tag_array_size[];\n+#define CACHE_SIZE (4 * (int) &__cache_tag_array_size[0])\n+#define LINE_SIZE ((addr)128)\n+\n+void\n+init_mem (void)\n+{\n+  bigblock = malloc_ea (CACHE_SIZE + 2 * LINE_SIZE);\n+  block = malloc_ea (2 * LINE_SIZE);\n+  ls_block = malloc (LINE_SIZE);\n+\n+  memset_ea (bigblock, 0, CACHE_SIZE + 2 * LINE_SIZE);\n+  memset_ea (block, -1, 2 * LINE_SIZE);\n+  memset (ls_block, -1, LINE_SIZE);\n+  cache_flush ();\n+}\n+\n+/* Test 1: Simple cache fetching.  */\n+void\n+test1 (void)\n+{\n+  addr aligned = ((((addr) block) + LINE_SIZE - 1) & -LINE_SIZE);\n+  int *p1 = NULL;\n+  int *p2 = NULL;\n+  int i = 0;\n+\n+  /* First, check if the same addr give the same cache ptr.  */\n+  p1 = cache_fetch ((__ea void *) aligned);\n+  p2 = cache_fetch ((__ea void *) aligned);\n+\n+  if (p1 != p2)\n+    abort ();\n+\n+  /* Check that the data actually is in the cache. */\n+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n+    {\n+      if (p1[i] != -1)\n+\tabort ();\n+    }\n+\n+  /* Check returning within the cache line. */\n+  p2 = cache_fetch ((__ea void *) (aligned + sizeof (int)));\n+\n+  if (p2 - p1 != 1)\n+    abort ();\n+\n+  /* Finally, check that fetching an LS pointer returns that pointer.  */\n+  p1 = cache_fetch ((__ea char *) ls_block);\n+  if (p1 != ls_block)\n+    abort ();\n+}\n+\n+/* Test 2: Eviction testing. */\n+void\n+test2 (void)\n+{\n+  addr aligned = ((((addr) block) + LINE_SIZE - 1) & -LINE_SIZE);\n+  int *p = NULL;\n+  int i = 0;\n+\n+  /* First check that clean evictions don't write back.  */\n+  p = cache_fetch ((__ea void *) aligned);\n+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n+    p[i] = 0;\n+\n+  cache_evict ((__ea void *) aligned);\n+  memcpy_ea ((__ea char *) ls_block, (__ea void *) aligned, LINE_SIZE);\n+\n+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n+    {\n+      if (ls_block[i] == 0)\n+\tabort ();\n+    }\n+\n+  /* Now check that dirty evictions do write back.  */\n+  p = cache_fetch_dirty ((__ea void *) aligned, LINE_SIZE);\n+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n+    p[i] = 0;\n+\n+  cache_evict ((__ea void *) aligned);\n+  memcpy_ea ((__ea char *) ls_block, (__ea void *) aligned, LINE_SIZE);\n+\n+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n+    {\n+      if (ls_block[i] != 0)\n+\tabort ();\n+    }\n+\n+  /* Finally, check that non-atomic writeback only writes dirty bytes.  */\n+\n+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n+    {\n+      p = cache_fetch_dirty ((__ea void *) (aligned + i * sizeof (int)),\n+\t\t\t     (i % 2) * sizeof (int));\n+      p[0] = -1;\n+    }\n+\n+  cache_evict ((__ea void *) aligned);\n+  memcpy_ea ((__ea char *) ls_block, (__ea void *) aligned, LINE_SIZE);\n+\n+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)\n+    {\n+      if ((ls_block[i] == -1) && (i % 2 == 0))\n+\tabort ();\n+      if ((ls_block[i] == 0) && (i % 2 == 1))\n+\tabort ();\n+    }\n+}\n+\n+/* Test LS forced-eviction. */\n+void\n+test3 (void)\n+{\n+  addr aligned = ((((addr) bigblock) + LINE_SIZE - 1) & -LINE_SIZE);\n+  char *test = NULL;\n+  char *ls = NULL;\n+  int i = 0;\n+\n+  /* Init memory, fill the cache to capacity.  */\n+  ls = cache_fetch_dirty ((__ea void *) aligned, LINE_SIZE);\n+  for (i = 1; i < (CACHE_SIZE / LINE_SIZE); i++)\n+    cache_fetch_dirty ((__ea void *) (aligned + i * LINE_SIZE), LINE_SIZE);\n+\n+  memset (ls, -1, LINE_SIZE);\n+  test = cache_fetch ((__ea void *) (aligned + CACHE_SIZE));\n+\n+  /* test == ls indicates cache collision.  */\n+  if (test != ls)\n+    abort ();\n+\n+  /* Make sure it actually wrote the cache line.  */\n+  for (i = 0; i < LINE_SIZE; i++)\n+    {\n+      if (ls[i] != 0)\n+\tabort ();\n+    }\n+\n+  ls = cache_fetch ((__ea void *) aligned);\n+\n+  /* test != ls indicates another entry was evicted.  */\n+  if (test == ls)\n+    abort ();\n+\n+  /* Make sure that the previous eviction actually wrote back.  */\n+  for (i = 0; i < LINE_SIZE; i++)\n+    {\n+      if (ls[i] != 0xFF)\n+\tabort ();\n+    }\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  init_mem ();\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+\n+  return 0;\n+}"}, {"sha": "9ec4e15463058aea536799fe89ea9e2dcef2b1d9", "filename": "gcc/testsuite/gcc.target/spu/ea/cast1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast1.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+extern unsigned long long __ea_local_store;\n+\n+__ea int *ppu;\n+int x, *spu = &x, *spu2;\n+\n+int\n+main (int argc, char **argv)\n+{\n+  ppu = (__ea int *) spu;\n+  spu2 = (int *) ppu;\n+\n+#ifdef __EA32__\n+  if ((int) ppu != (int) __ea_local_store + (int) spu)\n+#else\n+  if ((unsigned long long) ppu != __ea_local_store + (unsigned long long)(int) spu)\n+#endif\n+\n+    abort ();\n+\n+  if (spu != spu2)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "6ce57dc4da740aa626bd85daf5393532f19c9644", "filename": "gcc/testsuite/gcc.target/spu/ea/cast2.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcast2.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,74 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+int array[128];\n+\n+__ea int *ea;\n+int *lm;\n+\n+void verify_ea (void) __attribute__ ((noinline));\n+void\n+verify_ea (void)\n+{\n+  if (ea != (__ea int *)lm)\n+    abort ();\n+}\n+\n+void verify_lm (void) __attribute__ ((noinline));\n+void\n+verify_lm (void)\n+{\n+  if ((int *)ea != lm)\n+    abort ();\n+}\n+\n+void verify_diff (int x) __attribute__ ((noinline));\n+void\n+verify_diff (int x)\n+{\n+  if (ea - lm != x)\n+    abort ();\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  ea = 0;\n+  lm = 0;\n+  verify_ea ();\n+  verify_lm ();\n+  verify_diff (0);\n+\n+  ea = &array[64];\n+  lm = &array[64];\n+  verify_ea ();\n+  verify_lm ();\n+  verify_diff (0);\n+\n+  ea = &array[0];\n+  lm = &array[64];\n+  verify_diff (-64);\n+\n+  ea = &array[64];\n+  lm = &array[0];\n+  verify_diff (64);\n+\n+  return 0;\n+}"}, {"sha": "ee7a32ad29b585166a891be09f193e7ae37c11b4", "filename": "gcc/testsuite/gcc.target/spu/ea/compile1.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile1.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,109 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Valid __ea declarations.  */\n+\n+/* { dg-do compile } */\n+\n+/* Typedefs.  */\n+typedef __ea int ea_int_t;\n+typedef __ea int *ea_int_star_t;\n+typedef int outer_t;\n+\n+/* Externs.  */\n+\n+__ea extern int i1;\n+extern __ea int i2;\n+extern int __ea i3;\n+extern __ea ea_int_t i4;\t\t/* __ea qualifier permitted via typedef.  */\n+extern int __ea __ea __ea dupe;\t\t/* __ea duplicate permitted directly.  */\n+extern int __ea *ppu;\n+\n+/* Pointers.  */\n+__ea int *i4p;\n+\n+/* Structs.  */\n+struct st {\n+  __ea int *p;\n+};\n+\n+/* Variable definitions.  */\n+__ea int ii0;\n+int *__ea ii1;\n+static int __ea ii2;\n+\n+void\n+f1 ()\n+{\n+  int *spu;\n+  ppu = (ea_int_t *) spu;\n+  ppu = (ea_int_star_t) spu;\n+}\n+\n+void\n+f2 ()\n+{\n+  int *spu;\n+  spu = (int *) ppu;\n+  ppu = (__ea int *) spu;\n+}\n+\n+void\n+f3 ()\n+{\n+  int i = sizeof (__ea int);\n+}\n+\n+__ea int *f4 (void)\n+{\n+  return 0;\n+}\n+\n+int f5 (__ea int *parm)\n+{\n+  static __ea int local4;\n+  int tmp = local4;\n+  local4 = *parm;\n+  return tmp;\n+}\n+\n+static inline __ea void *f6 (__ea void *start)\n+{\n+  return 0;\n+}\n+\n+void f7 (void)\n+{\n+  __ea void *s1;\n+  auto __ea void *s2;\n+}\n+\n+__ea int *f8 (__ea int *x)\n+{\n+  register __ea int *y = x;\n+  __ea int *z = y;\n+  return z;\n+}\n+\n+long long f9 (__ea long long x[2])\n+{\n+  return x[0] + x[1];\n+}\n+\n+void f10 ()\n+{\n+  static __ea outer_t o;\n+}"}, {"sha": "58e64890e672cd158b047e9d1c425665dce28d1a", "filename": "gcc/testsuite/gcc.target/spu/ea/compile2.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcompile2.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,43 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Make sure __ea structure references work.  */\n+\n+/* { dg-do compile } */\n+\n+typedef unsigned long int uintptr_t;\n+\n+struct tostruct\n+{\n+  uintptr_t selfpc;\n+  long count;\n+  unsigned short link;\n+};\n+\n+/* froms are indexing tos */\n+static __ea unsigned short *froms;\n+static __ea struct tostruct *tos = 0;\n+\n+void\n+foo (uintptr_t frompc, uintptr_t selfpc)\n+{\n+  __ea unsigned short *frompcindex;\n+\n+  frompcindex = &froms[(frompc) / (4 * sizeof (*froms))];\n+  *frompcindex = tos[0].link;\n+\n+  return;\n+}"}, {"sha": "583635734b5ce7f7fd166a289cbabda655073616", "filename": "gcc/testsuite/gcc.target/spu/ea/cppdefine.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcppdefine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcppdefine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fcppdefine.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,36 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Test default __EA32__/__EA64__ define.  */\n+\n+/* { dg-do compile } */\n+\n+#if !defined (__EA32__) && !defined (__EA64__)\n+#error both __EA32__ and __EA64__ undefined\n+#endif\n+\n+#if defined (__EA32__) && defined (__EA64__)\n+#error both __EA32__ and __EA64__ defined\n+#endif\n+\n+#ifdef __EA32__\n+int x [ sizeof (__ea char *) == 4 ? 1 : -1 ];\n+#endif\n+\n+#ifdef __EA64__\n+int x [ sizeof (__ea char *) == 8 ? 1 : -1 ];\n+#endif\n+"}, {"sha": "8485d0fc72087ed273b6bd7e38bfe5dfa543110e", "filename": "gcc/testsuite/gcc.target/spu/ea/ea.exp", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fea.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fea.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fea.exp?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,54 @@\n+#   Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't a SPU target.\n+if { ![istarget spu-*-*] } then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Return 1 if target __ea library functions are available\n+proc check_effective_target_ealib { } {\n+    return [check_no_compiler_messages ealib executable {\n+\t#include <ea.h>\n+\tint main (void)\n+\t{\n+\t    __ea void *ptr = malloc_ea (1024);\n+\t    return 0;\n+\t}\n+    }]\n+}\n+\n+# If a testcase doesn't have special options, use these.\n+# We do not use the global DEFAULT_CFLAGS as all test cases\n+# in this directory use the __ea address space qualifier\n+# extension and thus will not compile with -ansi.\n+set DEFAULT_EA_CFLAGS \"-std=gnu99 -pedantic-errors -O2\"\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Run all tests in both -mea32 and -mea64 mode.\n+set tests [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]]\n+dg-runtest $tests \"-mea32\" $DEFAULT_EA_CFLAGS\n+dg-runtest $tests \"-mea64\" $DEFAULT_EA_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "7d0b5a11ca9477b64baffbdc216ffd8d67ee58d7", "filename": "gcc/testsuite/gcc.target/spu/ea/errors1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors1.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,67 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Invalid __ea declarations.  */\n+\n+/* { dg-do compile } */\n+\n+typedef __ea int eaint;\n+\n+void func ()\n+{\n+  register __ea int local1; /* { dg-error \"'__ea' combined with 'register' qualifier for 'local1'\" } */\n+  auto __ea int local2;     /* { dg-error \"'__ea' combined with 'auto' qualifier for 'local2'\" } */\n+  __ea int local3;\t    /* { dg-error \"'__ea' specified for auto variable 'local3'\" } */\n+  register int *__ea p1;    /* { dg-error \"'__ea' combined with 'register' qualifier for 'p1'\" } */\n+  auto char *__ea p2;       /* { dg-error \"'__ea' combined with 'auto' qualifier for 'p2'\" } */\n+  void *__ea p3;            /* { dg-error \"'__ea' specified for auto variable 'p3'\" } */\n+  register __ea int a1[2];  /* { dg-error \"'__ea' combined with 'register' qualifier for 'a1'\" } */\n+  auto __ea char a2[1];     /* { dg-error \"'__ea' combined with 'auto' qualifier for 'a2'\" } */\n+  __ea char a3[5];          /* { dg-error \"'__ea' specified for auto variable 'a3'\" } */\n+  register eaint td1;       /* { dg-error \"'__ea' combined with 'register' qualifier for 'td1'\" } */\n+  auto eaint td2;           /* { dg-error \"'__ea' combined with 'auto' qualifier for 'td2'\" } */\n+  eaint td3;\t            /* { dg-error \"'__ea' specified for auto variable 'td3'\" } */\n+}\n+\n+void func2 (__ea int x)\t    /* { dg-error \"'__ea' specified for parameter 'x'\" } */\n+{ }\n+\n+void func2td (eaint x)\t    /* { dg-error \"'__ea' specified for parameter 'x'\" } */\n+{ }\n+\n+struct st {\n+  __ea int x;\t\t    /* { dg-error \"'__ea' specified for structure field 'x'\" } */\n+  eaint td;\t\t    /* { dg-error \"'__ea' specified for structure field 'td'\" } */\n+  int *__ea q;\t\t    /* { dg-error \"'__ea' specified for structure field 'q'\" } */\n+  int __ea b : 7;\t    /* { dg-error \"'__ea' specified for structure field 'b'\" } */\n+  int __ea : 1;\t\t    /* { dg-error \"'__ea' specified for structure field\" } */\n+} s;\n+\n+struct A { int a; };\n+\n+int func3 (int *__ea);\t    /* { dg-error \"'__ea' specified for unnamed parameter\" } */\n+int func3 (int *__ea x)\t    /* { dg-error \"'__ea' specified for parameter 'x'\" } */\n+{\n+  struct A i = (__ea struct A) { 1 };\t/* { dg-error \"compound literal qualified by address-space qualifier\" } */\n+  return i.a;\n+}\n+\n+extern __ea int ea_var;\t\t/* { dg-message \"note: previous declaration of 'ea_var' was here\" } */\n+int ea_var;\t\t\t/* { dg-error \"conflicting named address spaces \\\\(generic vs __ea\\\\) for 'ea_var'\" } */\n+\n+extern eaint ea_var_td;\t\t/* { dg-message \"note: previous declaration of 'ea_var_td' was here\" } */\n+int ea_var_td;\t\t\t/* { dg-error \"conflicting named address spaces \\\\(generic vs __ea\\\\) for 'ea_var_td'\" } */\n+"}, {"sha": "74a32ff5e7e1d3c1278313557b53b8f021f308c8", "filename": "gcc/testsuite/gcc.target/spu/ea/errors2.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ferrors2.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,107 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Invalid __ea declarations.  */\n+\n+/* { dg-do compile } */\n+\n+__ea char ea_str[] = \"abc\";\n+char lm_str[] = \"abc\";\n+\n+__ea char *lm_ea_ptr1 = \"abc\";\t\t\t\t/* { dg-error \"initializer element is not computable at load time\" } */\n+__ea char *lm_ea_ptr2 = (__ea char *)\"abc\";\t\t/* { dg-error \"initializer element is not constant\" } */\n+__ea char *lm_ea_ptr3 = ea_str;\n+__ea char *lm_ea_ptr4 = (__ea char *)ea_str;\n+__ea char *lm_ea_ptr5 = lm_str;\t\t\t\t/* { dg-error \"initializer element is not computable at load time\" } */\n+__ea char *lm_ea_ptr6 = (__ea char *)lm_str;\t\t/* { dg-error \"initializer element is not constant\" } */\n+\n+__ea char * __ea ea_ea_ptr1 = ea_str;\n+__ea char * __ea ea_ea_ptr2 = (__ea char *)ea_str;\n+\n+char * __ea ea_lm_ptr1 = lm_str;\n+char * __ea ea_lm_ptr2 = (char *)lm_str;\n+\n+struct foo {\n+  int first;\n+  __ea char *ptr;\n+  int last;\n+};\n+\n+__ea struct foo ea_struct1 = {\n+  10,\n+  (__ea char *)0,\n+  11,\n+};\n+\n+__ea struct foo ea_struct2 = {\n+  20,\n+  0,\n+  21,\n+};\n+\n+struct foo ea_struct3 = {\n+  30,\n+  ea_str,\n+  31,\n+};\n+\n+struct foo ea_struct4 = {\n+  40,\n+  (__ea char *)lm_str,\t/* { dg-error \"(initializer element is not constant)|(near initialization)\" \"\" } */\n+  41,\n+};\n+\n+struct bar {\n+  int first;\n+  char *ptr;\n+  int last;\n+};\n+\n+__ea struct bar ea_struct5 = {\n+  50,\n+  0,\n+  51,\n+};\n+\n+__ea struct bar ea_struct6 = {\n+  60,\n+  (char *)0,\n+  61,\n+};\n+\n+__ea struct bar ea_struct7 = {\n+  70,\n+  lm_str,\n+  71,\n+};\n+\n+struct bar lm_struct8 = {\n+  80,\n+  0,\n+  81,\n+};\n+\n+struct bar lm_struct9 = {\n+  90,\n+  (char *)0,\n+  91,\n+};\n+\n+struct bar lm_struct10 = {\n+  100,\n+  lm_str,\n+  101,\n+};"}, {"sha": "99d6d691810a0d9e063e96e996490bf65e05011a", "filename": "gcc/testsuite/gcc.target/spu/ea/execute1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute1.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* { dg-do compile } */\n+\n+#include <stdlib.h>\n+\n+__ea char str[] = \"abc\";\n+\n+int\n+main (void)\n+{\n+  __ea char *p = str;\n+\n+  if (*p++ != 'a')\n+    abort ();\n+\n+  if (*p++ != 'b')\n+    abort ();\n+\n+  if (*p++ != 'c')\n+    abort ();\n+\n+  if (*p++ != '\\0')\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "5fce4e673ff9e60700553985b97d05b57131ff9d", "filename": "gcc/testsuite/gcc.target/spu/ea/execute2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute2.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+char str[] = \"abc\";\n+\n+int\n+main (void)\n+{\n+  __ea char *p = (__ea char *)str;\n+\n+  if (*p++ != 'a')\n+    abort ();\n+\n+  if (*p++ != 'b')\n+    abort ();\n+\n+  if (*p++ != 'c')\n+    abort ();\n+\n+  if (*p++ != '\\0')\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "1b8c139d7af7131d9a9a1aef61544d5235cbf887", "filename": "gcc/testsuite/gcc.target/spu/ea/execute3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fexecute3.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,39 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  __ea char *p = (__ea char *)\"abc\";\n+\n+  if (*p++ != 'a')\n+    abort ();\n+\n+  if (*p++ != 'b')\n+    abort ();\n+\n+  if (*p++ != 'c')\n+    abort ();\n+\n+  if (*p++ != '\\0')\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "0d162f218205e04dc900d830fde3fc0ab98c8e58", "filename": "gcc/testsuite/gcc.target/spu/ea/ops1.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops1.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,94 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is the same as ops2.c except for the compile option.\n+   If you modify this code, please modify ops2.c as well.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -std=gnu99 -pedantic-errors -maddress-space-conversion\" } */\n+\n+#define __lm\n+\n+__ea int ea_var = 1;\n+__lm int lm_var = 2;\n+\n+typedef __ea int *ea_ptr_t;\n+typedef __lm int *lm_ptr_t;\n+\n+typedef __ea void *ea_vptr_t;\n+typedef __lm void *lm_vptr_t;\n+\n+ea_ptr_t ea, ea2;\n+lm_ptr_t lm, lm2;\n+\n+ea_vptr_t eav;\n+lm_vptr_t lmv;\n+\n+extern void call_ea (ea_ptr_t);\n+extern void call_lm (lm_ptr_t);\n+\n+/* Assignment, initialization, argument passing, and return.  */\n+void to_ea (void) { ea = lm; }\n+void to_lm (void) { lm = ea; }\t\t\t/* { dg-error \"assignment from pointer to non-enclosed address space\" } */\n+void init_ea (void) { ea_ptr_t l_ea = lm; }\n+void init_lm (void) { lm_ptr_t l_lm = ea; }\t/* { dg-error \"initialization from pointer to non-enclosed address space\" } */\n+ea_ptr_t ret_ea (void) { return lm; }\n+lm_ptr_t ret_lm (void) { return ea; }\t\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n+void call_ea2 (void) { call_ea (lm); }\n+void call_lm2 (void) { call_lm (ea); }\t\t/* { dg-error \"passing argument 1 of 'call_lm' from pointer to non-enclosed address space\" } */\n+\n+/* Explicit casts.  */\n+void to_ea_with_cast (void) { ea = (ea_ptr_t)lm; }\n+void to_lm_with_cast (void) { lm = (lm_ptr_t)ea; }\n+void init_ea_with_cast (void) { ea_ptr_t l_ea = (ea_ptr_t)lm; }\n+void init_lm_with_cast (void) { lm_ptr_t l_lm = (lm_ptr_t)ea; }\n+ea_ptr_t ret_ea_with_cast (void) { return (ea_ptr_t)lm; }\n+lm_ptr_t ret_lm_with_cast (void) { return (lm_ptr_t)ea; }\n+void call_ea2_with_cast (void) { call_ea ((ea_ptr_t)lm); }\n+void call_lm2_with_cast (void) { call_lm ((lm_ptr_t)ea); }\n+\n+/* Arithmetic operators.  */\n+int sub_eaea (void) { return ea - ea2; }\n+int sub_ealm (void) { return ea - lm2; }\n+int sub_lmea (void) { return lm - ea2; }\n+int sub_lmlm (void) { return lm - lm2; }\n+ea_ptr_t if_eaea1 (int test) { return test? ea : ea2; }\n+lm_ptr_t if_eaea2 (int test) { return test? ea : ea2; }\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n+ea_ptr_t if_ealm1 (int test) { return test? ea : lm2; }\n+lm_ptr_t if_ealm2 (int test) { return test? ea : lm2; }\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n+ea_ptr_t if_lmea1 (int test) { return test? lm : ea2; }\n+lm_ptr_t if_lmea2 (int test) { return test? lm : ea2; }\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n+ea_ptr_t if_lmlm1 (int test) { return test? lm : lm2; }\n+lm_ptr_t if_lmlm2 (int test) { return test? lm : lm2; }\n+\n+/* Relational operators.  */\n+int eq_eaea (void) { return ea == ea2; }\n+int eq_ealm (void) { return ea == lm2; }\n+int eq_lmea (void) { return lm == ea2; }\n+int eq_lmlm (void) { return lm == lm2; }\n+int lt_eaea (void) { return ea < ea2; }\n+int lt_ealm (void) { return ea < lm2; }\n+int lt_lmea (void) { return lm < ea2; }\n+int lt_lmlm (void) { return lm < lm2; }\n+\n+/* Null pointer.  */\n+void null_ea1 (void) { ea = 0; }\n+void null_ea2 (void) { ea = (void *)0; }\n+void null_ea3 (void) { ea = (__ea void *)0; }\n+void null_lm1 (void) { lm = 0; }\n+void null_lm2 (void) { lm = (void *)0; }\n+void null_lm3 (void) { lm = (__ea void *)0; }\t/* { dg-error \"assignment from pointer to non-enclosed address space\" } */\n+"}, {"sha": "2514e6b2095732089690cf4dbd0049519b894309", "filename": "gcc/testsuite/gcc.target/spu/ea/ops2.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Fops2.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,94 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This is the same as ops1.c except for the compile option.\n+   If you modify this code, please modify ops1.c as well.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -std=gnu99 -pedantic-errors -mno-address-space-conversion\" } */\n+\n+#define __lm\n+\n+__ea int ea_var = 1;\n+__lm int lm_var = 2;\n+\n+typedef __ea int *ea_ptr_t;\n+typedef __lm int *lm_ptr_t;\n+\n+typedef __ea void *ea_vptr_t;\n+typedef __lm void *lm_vptr_t;\n+\n+ea_ptr_t ea, ea2;\n+lm_ptr_t lm, lm2;\n+\n+ea_vptr_t eav;\n+lm_vptr_t lmv;\n+\n+extern void call_ea (ea_ptr_t);\n+extern void call_lm (lm_ptr_t);\n+\n+/* Assignment, initialization, argument passing, and return.  */\n+void to_ea (void) { ea = lm; }\t\t\t/* { dg-error \"assignment from pointer to non-enclosed address space\" } */\n+void to_lm (void) { lm = ea; }\t\t\t/* { dg-error \"assignment from pointer to non-enclosed address space\" } */\n+void init_ea (void) { ea_ptr_t l_ea = lm; }\t/* { dg-error \"initialization from pointer to non-enclosed address space\" } */\n+void init_lm (void) { lm_ptr_t l_lm = ea; }\t/* { dg-error \"initialization from pointer to non-enclosed address space\" } */\n+ea_ptr_t ret_ea (void) { return lm; }\t\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n+lm_ptr_t ret_lm (void) { return ea; }\t\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n+void call_ea2 (void) { call_ea (lm); }\t\t/* { dg-error \"passing argument 1 of 'call_ea' from pointer to non-enclosed address space\" } */\n+void call_lm2 (void) { call_lm (ea); }\t\t/* { dg-error \"passing argument 1 of 'call_lm' from pointer to non-enclosed address space\" } */\n+\n+/* Explicit casts.  */\n+void to_ea_with_cast (void) { ea = (ea_ptr_t)lm; }\t\t/* { dg-warning \"cast to __ea address space pointer\" } */\n+void to_lm_with_cast (void) { lm = (lm_ptr_t)ea; }\t\t/* { dg-warning \"cast to generic address space pointer\" } */\n+void init_ea_with_cast (void) { ea_ptr_t l_ea = (ea_ptr_t)lm; }\t/* { dg-warning \"cast to __ea address space pointer\" } */\n+void init_lm_with_cast (void) { lm_ptr_t l_lm = (lm_ptr_t)ea; }\t/* { dg-warning \"cast to generic address space pointer\" } */\n+ea_ptr_t ret_ea_with_cast (void) { return (ea_ptr_t)lm; }\t/* { dg-warning \"cast to __ea address space pointer\" } */\n+lm_ptr_t ret_lm_with_cast (void) { return (lm_ptr_t)ea; }\t/* { dg-warning \"cast to generic address space pointer\" } */\n+void call_ea2_with_cast (void) { call_ea ((ea_ptr_t)lm); }\t/* { dg-warning \"cast to __ea address space pointer\" } */\n+void call_lm2_with_cast (void) { call_lm ((lm_ptr_t)ea); }\t/* { dg-warning \"cast to generic address space pointer\" } */\n+\n+/* Arithmetic operators.  */\n+int sub_eaea (void) { return ea - ea2; }\n+int sub_ealm (void) { return ea - lm2; }\t\t/* { dg-error \"invalid operands to binary -\" } */\n+int sub_lmea (void) { return lm - ea2; }\t\t/* { dg-error \"invalid operands to binary -\" } */\n+int sub_lmlm (void) { return lm - lm2; }\n+ea_ptr_t if_eaea1 (int test) { return test? ea : ea2; }\n+lm_ptr_t if_eaea2 (int test) { return test? ea : ea2; }\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n+ea_ptr_t if_ealm1 (int test) { return test? ea : lm2; } /* { dg-error \"pointers to disjoint address spaces used in conditional expression\" } */\n+lm_ptr_t if_ealm2 (int test) { return test? ea : lm2; } /* { dg-error \"pointers to disjoint address spaces used in conditional expression\" } */\n+ea_ptr_t if_lmea1 (int test) { return test? lm : ea2; } /* { dg-error \"pointers to disjoint address spaces used in conditional expression\" } */\n+lm_ptr_t if_lmea2 (int test) { return test? lm : ea2; } /* { dg-error \"pointers to disjoint address spaces used in conditional expression\" } */\n+ea_ptr_t if_lmlm1 (int test) { return test? lm : lm2; }\t/* { dg-error \"return from pointer to non-enclosed address space\" } */\n+lm_ptr_t if_lmlm2 (int test) { return test? lm : lm2; }\n+\n+/* Relational operators.  */\n+int eq_eaea (void) { return ea == ea2; }\n+int eq_ealm (void) { return ea == lm2; }\t/* { dg-error \"comparison of pointers to disjoint address spaces\" } */\n+int eq_lmea (void) { return lm == ea2; }\t/* { dg-error \"comparison of pointers to disjoint address spaces\" } */\n+int eq_lmlm (void) { return lm == lm2; }\n+int lt_eaea (void) { return ea < ea2; }\n+int lt_ealm (void) { return ea < lm2; }\t\t/* { dg-error \"comparison of pointers to disjoint address spaces\" } */\n+int lt_lmea (void) { return lm < ea2; }\t\t/* { dg-error \"comparison of pointers to disjoint address spaces\" } */\n+int lt_lmlm (void) { return lm < lm2; }\n+\n+/* Null pointer.  */\n+void null_ea1 (void) { ea = 0; }\n+void null_ea2 (void) { ea = (void *)0; }\n+void null_ea3 (void) { ea = (__ea void *)0; }\n+void null_lm1 (void) { lm = 0; }\n+void null_lm2 (void) { lm = (void *)0; }\n+void null_lm3 (void) { lm = (__ea void *)0; }\t/* { dg-error \"assignment from pointer to non-enclosed address space\" } */\n+"}, {"sha": "19040090206db85c426e6fbd236da9bf3c35a3b4", "filename": "gcc/testsuite/gcc.target/spu/ea/options1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Foptions1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Foptions1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Foptions1.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,22 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Test -mcache-size.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-mcache-size=128\" } */\n+\n+int x;"}, {"sha": "e467616b6280f5379848043339dab7a04e234e80", "filename": "gcc/testsuite/gcc.target/spu/ea/test-sizes.c", "status": "added", "additions": 608, "deletions": 0, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ftest-sizes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b8b9f7491534a9f6e0004f2ecdbf898d24d8434/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ftest-sizes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fea%2Ftest-sizes.c?ref=2b8b9f7491534a9f6e0004f2ecdbf898d24d8434", "patch": "@@ -0,0 +1,608 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* { dg-do run } */\n+\n+#ifdef __EA32__\n+#define EA_PTRSIZE 4\n+#endif\n+#ifdef __EA64__\n+#define EA_PTRSIZE 8\n+#endif\n+\n+#if !defined(LEVEL1) && !defined(LEVEL2) && !defined(LEVEL3)\n+#define LEVEL1 1\t\t/* single pointer indirection */\n+#define LEVEL2 1\t\t/* 2 levels of pointer indirection */\n+#define LEVEL3 1\t\t/* 3 levels of pointer indirection */\n+\n+#else\n+#ifndef LEVEL1\n+#define LEVEL1 0\n+#endif\n+\n+#ifndef LEVEL2\n+#define LEVEL2 0\n+#endif\n+\n+#ifndef LEVEL3\n+#define LEVEL3 0\n+#endif\n+#endif\n+\n+#if !defined(USE_SIMPLE) && !defined(USE_COMPLEX)\n+#define USE_SIMPLE  1\t\t/* build up pointers via multiple typedefs */\n+#define USE_COMPLEX 1\t\t/* single typedef for pointer indirections */\n+\n+#else\n+#ifndef USE_SIMPLE\n+#define USE_SIMPLE 0\n+#endif\n+\n+#ifndef USE_COMPLEX\n+#define USE_COMPLEX 0\n+#endif\n+#endif\n+\n+#if !defined(USE_LOCAL_VAR) && !defined(USE_EA_VAR)\n+#define USE_LOCAL_VAR 1\t\t/* use variables declared locally */\n+#define USE_EA_VAR    1\t\t/* use variables on the host */\n+\n+#else\n+#ifndef USE_LOCAL_VAR\n+#define USE_LOCAL_VAR 0\n+#endif\n+\n+#ifndef USE_EA_VAR\n+#define USE_EA_VAR    0\n+#endif\n+#endif\n+\n+static int errors;\n+\n+#ifdef USE_PRINTF\t\t/* print results via printf */\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+static int num_tests;\n+\n+#define TEST_SIZE(EXPR, EXPECTED)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  char *msg;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (sizeof (EXPR) != EXPECTED)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      msg = \", FAIL\";\t\t\t\t\t\t\t\\\n+      errors++;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    msg = \"\";\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  num_tests++;\t\t\t\t\t\t\t\t\\\n+  printf (\"sizeof %-20s = %2u, expected = %2u%s\\n\",\t\t\t\\\n+\t  #EXPR,\t\t\t\t\t\t\t\\\n+\t  (unsigned) sizeof (EXPR),\t\t\t\t\t\\\n+\t  (unsigned) EXPECTED,\t\t\t\t\t\t\\\n+\t  msg);\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#define PRINT1(FMT)\t  printf (FMT)\n+#define PRINT2(FMT,A1)\t  printf (FMT,A1)\n+#define PRINT3(FMT,A1,A2) printf (FMT,A1,A2)\n+\n+#else\t/* standalone */\n+extern void abort (void);\n+\n+#define TEST_SIZE(EXPR, EXPECTED)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (sizeof (EXPR) != EXPECTED)\t\t\t\t\t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#define PRINT1(FMT)\n+#define PRINT2(FMT,ARG)\n+#define PRINT3(FMT,A1,A2)\n+#endif\n+\n+/* 'local memory' hack to keep the same spacing.  */\n+#define __lm\n+\n+#if USE_SIMPLE\n+#if (LEVEL1 || LEVEL2 || LEVEL3)\n+typedef __lm char *lm_ptr_t;\n+typedef __ea char *ea_ptr_t;\n+#endif\n+\n+#if LEVEL1\n+#if USE_LOCAL_VAR\n+__lm lm_ptr_t lm_ptr;\n+__lm ea_ptr_t ea_ptr;\n+#endif\n+\n+#if USE_EA_VAR\n+__ea lm_ptr_t lm_ptr_ea;\n+__ea ea_ptr_t ea_ptr_ea;\n+#endif\n+#endif\n+\n+#if (LEVEL2 || LEVEL3)\n+typedef __lm lm_ptr_t *lm_lm_ptr_t;\n+typedef __ea lm_ptr_t *ea_lm_ptr_t;\n+typedef __lm ea_ptr_t *lm_ea_ptr_t;\n+typedef __ea ea_ptr_t *ea_ea_ptr_t;\n+#endif\n+\n+#if LEVEL2\n+#if USE_LOCAL_VAR\n+__lm lm_lm_ptr_t lm_lm_ptr;\n+__lm ea_lm_ptr_t ea_lm_ptr;\n+__lm lm_ea_ptr_t lm_ea_ptr;\n+__lm ea_ea_ptr_t ea_ea_ptr;\n+#endif\n+\n+#if USE_EA_VAR\n+__ea lm_lm_ptr_t lm_lm_ptr_ea;\n+__ea ea_lm_ptr_t ea_lm_ptr_ea;\n+__ea lm_ea_ptr_t lm_ea_ptr_ea;\n+__ea ea_ea_ptr_t ea_ea_ptr_ea;\n+#endif\n+#endif\n+\n+#if LEVEL3\n+typedef __lm lm_lm_ptr_t *lm_lm_lm_ptr_t;\n+typedef __ea lm_lm_ptr_t *ea_lm_lm_ptr_t;\n+typedef __lm ea_lm_ptr_t *lm_ea_lm_ptr_t;\n+typedef __ea ea_lm_ptr_t *ea_ea_lm_ptr_t;\n+typedef __lm lm_ea_ptr_t *lm_lm_ea_ptr_t;\n+typedef __ea lm_ea_ptr_t *ea_lm_ea_ptr_t;\n+typedef __lm ea_ea_ptr_t *lm_ea_ea_ptr_t;\n+typedef __ea ea_ea_ptr_t *ea_ea_ea_ptr_t;\n+\n+#if USE_LOCAL_VAR\n+__lm lm_lm_lm_ptr_t lm_lm_lm_ptr;\n+__lm ea_lm_lm_ptr_t ea_lm_lm_ptr;\n+__lm lm_ea_lm_ptr_t lm_ea_lm_ptr;\n+__lm ea_ea_lm_ptr_t ea_ea_lm_ptr;\n+__lm lm_lm_ea_ptr_t lm_lm_ea_ptr;\n+__lm ea_lm_ea_ptr_t ea_lm_ea_ptr;\n+__lm lm_ea_ea_ptr_t lm_ea_ea_ptr;\n+__lm ea_ea_ea_ptr_t ea_ea_ea_ptr;\n+#endif\n+\n+#if USE_EA_VAR\n+__ea lm_lm_lm_ptr_t lm_lm_lm_ptr_ea;\n+__ea ea_lm_lm_ptr_t ea_lm_lm_ptr_ea;\n+__ea lm_ea_lm_ptr_t lm_ea_lm_ptr_ea;\n+__ea ea_ea_lm_ptr_t ea_ea_lm_ptr_ea;\n+__ea lm_lm_ea_ptr_t lm_lm_ea_ptr_ea;\n+__ea ea_lm_ea_ptr_t ea_lm_ea_ptr_ea;\n+__ea lm_ea_ea_ptr_t lm_ea_ea_ptr_ea;\n+__ea ea_ea_ea_ptr_t ea_ea_ea_ptr_ea;\n+#endif\n+#endif\n+#endif\n+\n+#if USE_COMPLEX\n+#if LEVEL1\n+#if USE_LOCAL_VAR\n+__lm char *__lm lm_cptr;\n+__ea char *__lm ea_cptr;\n+#endif\n+\n+#if USE_EA_VAR\n+__lm char *__ea lm_cptr_ea;\n+__ea char *__ea ea_cptr_ea;\n+#endif\n+#endif\n+\n+#if LEVEL2\n+#if USE_LOCAL_VAR\n+__lm char *__lm *__lm lm_lm_cptr;\n+__lm char *__ea *__lm ea_lm_cptr;\n+__ea char *__lm *__lm lm_ea_cptr;\n+__ea char *__ea *__lm ea_ea_cptr;\n+#endif\n+\n+#if USE_EA_VAR\n+__lm char *__lm *__ea lm_lm_cptr_ea;\n+__lm char *__ea *__ea ea_lm_cptr_ea;\n+__ea char *__lm *__ea lm_ea_cptr_ea;\n+__ea char *__ea *__ea ea_ea_cptr_ea;\n+#endif\n+#endif\n+\n+#if LEVEL3\n+#if USE_LOCAL_VAR\n+__lm char *__lm *__lm *__lm lm_lm_lm_cptr;\n+__lm char *__ea *__lm *__lm lm_ea_lm_cptr;\n+__ea char *__lm *__lm *__lm lm_lm_ea_cptr;\n+__ea char *__ea *__lm *__lm lm_ea_ea_cptr;\n+__lm char *__lm *__ea *__lm ea_lm_lm_cptr;\n+__lm char *__ea *__ea *__lm ea_ea_lm_cptr;\n+__ea char *__lm *__ea *__lm ea_lm_ea_cptr;\n+__ea char *__ea *__ea *__lm ea_ea_ea_cptr;\n+#endif\n+\n+#if USE_EA_VAR\n+__lm char *__lm *__lm *__ea lm_lm_lm_cptr_ea;\n+__lm char *__ea *__lm *__ea lm_ea_lm_cptr_ea;\n+__ea char *__lm *__lm *__ea lm_lm_ea_cptr_ea;\n+__ea char *__ea *__lm *__ea lm_ea_ea_cptr_ea;\n+__lm char *__lm *__ea *__ea ea_lm_lm_cptr_ea;\n+__lm char *__ea *__ea *__ea ea_ea_lm_cptr_ea;\n+__ea char *__lm *__ea *__ea ea_lm_ea_cptr_ea;\n+__ea char *__ea *__ea *__ea ea_ea_ea_cptr_ea;\n+#endif\n+#endif\n+#endif\n+\n+int\n+main ()\n+{\n+  PRINT2 (\"LEVEL1        = %d\\n\", LEVEL1);\n+  PRINT2 (\"LEVEL2        = %d\\n\", LEVEL2);\n+  PRINT2 (\"LEVEL3        = %d\\n\", LEVEL3);\n+  PRINT2 (\"USE_SIMPLE    = %d\\n\", USE_SIMPLE);\n+  PRINT2 (\"USE_COMPLEX   = %d\\n\", USE_COMPLEX);\n+  PRINT2 (\"USE_LOCAL_VAR = %d\\n\", USE_LOCAL_VAR);\n+  PRINT2 (\"USE_EA_VAR    = %d\\n\", USE_EA_VAR);\n+  PRINT1 (\"\\n\");\n+\n+#if USE_SIMPLE\n+#if LEVEL1\n+#if USE_LOCAL_VAR\n+  TEST_SIZE ( lm_ptr, 4);\n+  TEST_SIZE (*lm_ptr, 1);\n+  TEST_SIZE ( ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE (*ea_ptr, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+\n+#if USE_EA_VAR\n+  TEST_SIZE ( lm_ptr_ea, 4);\n+  TEST_SIZE (*lm_ptr_ea, 1);\n+  TEST_SIZE ( ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (*ea_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+#endif\n+\n+#if LEVEL2\n+#if USE_LOCAL_VAR\n+  TEST_SIZE (  lm_lm_ptr, 4);\n+  TEST_SIZE ( *lm_lm_ptr, 4);\n+  TEST_SIZE (**lm_lm_ptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  lm_ea_ptr, 4);\n+  TEST_SIZE ( *lm_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE (**lm_ea_ptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  ea_lm_ptr, EA_PTRSIZE);\n+  TEST_SIZE ( *ea_lm_ptr, 4);\n+  TEST_SIZE (**ea_lm_ptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  ea_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE ( *ea_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE (**ea_ea_ptr, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+\n+#if USE_EA_VAR\n+  TEST_SIZE (  lm_lm_ptr_ea, 4);\n+  TEST_SIZE ( *lm_lm_ptr_ea, 4);\n+  TEST_SIZE (**lm_lm_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  lm_ea_ptr_ea, 4);\n+  TEST_SIZE ( *lm_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (**lm_ea_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  ea_lm_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( *ea_lm_ptr_ea, 4);\n+  TEST_SIZE (**ea_lm_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  ea_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( *ea_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (**ea_ea_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+#endif\n+\n+#if LEVEL3\n+#if USE_LOCAL_VAR\n+  TEST_SIZE (   lm_lm_lm_ptr, 4);\n+  TEST_SIZE (  *lm_lm_lm_ptr, 4);\n+  TEST_SIZE ( **lm_lm_lm_ptr, 4);\n+  TEST_SIZE (***lm_lm_lm_ptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_lm_ea_ptr, 4);\n+  TEST_SIZE (  *lm_lm_ea_ptr, 4);\n+  TEST_SIZE ( **lm_lm_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE (***lm_lm_ea_ptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_ea_lm_ptr, 4);\n+  TEST_SIZE (  *lm_ea_lm_ptr, EA_PTRSIZE);\n+  TEST_SIZE ( **lm_ea_lm_ptr, 4);\n+  TEST_SIZE (***lm_ea_lm_ptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_ea_ea_ptr, 4);\n+  TEST_SIZE (  *lm_ea_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE ( **lm_ea_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE (***lm_ea_ea_ptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_lm_lm_ptr, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_lm_lm_ptr, 4);\n+  TEST_SIZE ( **ea_lm_lm_ptr, 4);\n+  TEST_SIZE (***ea_lm_lm_ptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_lm_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_lm_ea_ptr, 4);\n+  TEST_SIZE ( **ea_lm_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE (***ea_lm_ea_ptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_ea_lm_ptr, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_ea_lm_ptr, EA_PTRSIZE);\n+  TEST_SIZE ( **ea_ea_lm_ptr, 4);\n+  TEST_SIZE (***ea_ea_lm_ptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_ea_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_ea_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE ( **ea_ea_ea_ptr, EA_PTRSIZE);\n+  TEST_SIZE (***ea_ea_ea_ptr, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+\n+#if USE_EA_VAR\n+  TEST_SIZE (   lm_lm_lm_ptr_ea, 4);\n+  TEST_SIZE (  *lm_lm_lm_ptr_ea, 4);\n+  TEST_SIZE ( **lm_lm_lm_ptr_ea, 4);\n+  TEST_SIZE (***lm_lm_lm_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_lm_ea_ptr_ea, 4);\n+  TEST_SIZE (  *lm_lm_ea_ptr_ea, 4);\n+  TEST_SIZE ( **lm_lm_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (***lm_lm_ea_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_ea_lm_ptr_ea, 4);\n+  TEST_SIZE (  *lm_ea_lm_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( **lm_ea_lm_ptr_ea, 4);\n+  TEST_SIZE (***lm_ea_lm_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_ea_ea_ptr_ea, 4);\n+  TEST_SIZE (  *lm_ea_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( **lm_ea_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (***lm_ea_ea_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_lm_lm_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_lm_lm_ptr_ea, 4);\n+  TEST_SIZE ( **ea_lm_lm_ptr_ea, 4);\n+  TEST_SIZE (***ea_lm_lm_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_lm_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_lm_ea_ptr_ea, 4);\n+  TEST_SIZE ( **ea_lm_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (***ea_lm_ea_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_ea_lm_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_ea_lm_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( **ea_ea_lm_ptr_ea, 4);\n+  TEST_SIZE (***ea_ea_lm_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_ea_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_ea_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( **ea_ea_ea_ptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (***ea_ea_ea_ptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+#endif\n+#endif\n+\n+#if USE_COMPLEX\n+#if LEVEL1\n+#if USE_LOCAL_VAR\n+  TEST_SIZE ( lm_cptr, 4);\n+  TEST_SIZE (*lm_cptr, 1);\n+  TEST_SIZE ( ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE (*ea_cptr, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+\n+#if USE_EA_VAR\n+  TEST_SIZE ( lm_cptr_ea, 4);\n+  TEST_SIZE (*lm_cptr_ea, 1);\n+  TEST_SIZE ( ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (*ea_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+#endif\n+\n+#if LEVEL2\n+#if USE_LOCAL_VAR\n+  TEST_SIZE (  lm_lm_cptr, 4);\n+  TEST_SIZE ( *lm_lm_cptr, 4);\n+  TEST_SIZE (**lm_lm_cptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  lm_ea_cptr, 4);\n+  TEST_SIZE ( *lm_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE (**lm_ea_cptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  ea_lm_cptr, EA_PTRSIZE);\n+  TEST_SIZE ( *ea_lm_cptr, 4);\n+  TEST_SIZE (**ea_lm_cptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  ea_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE ( *ea_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE (**ea_ea_cptr, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+\n+#if USE_EA_VAR\n+  TEST_SIZE (  lm_lm_cptr_ea, 4);\n+  TEST_SIZE ( *lm_lm_cptr_ea, 4);\n+  TEST_SIZE (**lm_lm_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  lm_ea_cptr_ea, 4);\n+  TEST_SIZE ( *lm_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (**lm_ea_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  ea_lm_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( *ea_lm_cptr_ea, 4);\n+  TEST_SIZE (**ea_lm_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (  ea_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( *ea_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (**ea_ea_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+#endif\n+\n+#if LEVEL3\n+#if USE_LOCAL_VAR\n+  TEST_SIZE (   lm_lm_lm_cptr, 4);\n+  TEST_SIZE (  *lm_lm_lm_cptr, 4);\n+  TEST_SIZE ( **lm_lm_lm_cptr, 4);\n+  TEST_SIZE (***lm_lm_lm_cptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_lm_ea_cptr, 4);\n+  TEST_SIZE (  *lm_lm_ea_cptr, 4);\n+  TEST_SIZE ( **lm_lm_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE (***lm_lm_ea_cptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_ea_lm_cptr, 4);\n+  TEST_SIZE (  *lm_ea_lm_cptr, EA_PTRSIZE);\n+  TEST_SIZE ( **lm_ea_lm_cptr, 4);\n+  TEST_SIZE (***lm_ea_lm_cptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_ea_ea_cptr, 4);\n+  TEST_SIZE (  *lm_ea_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE ( **lm_ea_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE (***lm_ea_ea_cptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_lm_lm_cptr, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_lm_lm_cptr, 4);\n+  TEST_SIZE ( **ea_lm_lm_cptr, 4);\n+  TEST_SIZE (***ea_lm_lm_cptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_lm_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_lm_ea_cptr, 4);\n+  TEST_SIZE ( **ea_lm_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE (***ea_lm_ea_cptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_ea_lm_cptr, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_ea_lm_cptr, EA_PTRSIZE);\n+  TEST_SIZE ( **ea_ea_lm_cptr, 4);\n+  TEST_SIZE (***ea_ea_lm_cptr, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_ea_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_ea_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE ( **ea_ea_ea_cptr, EA_PTRSIZE);\n+  TEST_SIZE (***ea_ea_ea_cptr, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+\n+#if USE_EA_VAR\n+  TEST_SIZE (   lm_lm_lm_cptr_ea, 4);\n+  TEST_SIZE (  *lm_lm_lm_cptr_ea, 4);\n+  TEST_SIZE ( **lm_lm_lm_cptr_ea, 4);\n+  TEST_SIZE (***lm_lm_lm_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_lm_ea_cptr_ea, 4);\n+  TEST_SIZE (  *lm_lm_ea_cptr_ea, 4);\n+  TEST_SIZE ( **lm_lm_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (***lm_lm_ea_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_ea_lm_cptr_ea, 4);\n+  TEST_SIZE (  *lm_ea_lm_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( **lm_ea_lm_cptr_ea, 4);\n+  TEST_SIZE (***lm_ea_lm_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   lm_ea_ea_cptr_ea, 4);\n+  TEST_SIZE (  *lm_ea_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( **lm_ea_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (***lm_ea_ea_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_lm_lm_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_lm_lm_cptr_ea, 4);\n+  TEST_SIZE ( **ea_lm_lm_cptr_ea, 4);\n+  TEST_SIZE (***ea_lm_lm_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_lm_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_lm_ea_cptr_ea, 4);\n+  TEST_SIZE ( **ea_lm_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (***ea_lm_ea_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_ea_lm_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_ea_lm_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( **ea_ea_lm_cptr_ea, 4);\n+  TEST_SIZE (***ea_ea_lm_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+\n+  TEST_SIZE (   ea_ea_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (  *ea_ea_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE ( **ea_ea_ea_cptr_ea, EA_PTRSIZE);\n+  TEST_SIZE (***ea_ea_ea_cptr_ea, 1);\n+  PRINT1 (\"\\n\");\n+#endif\n+#endif\n+#endif\n+\n+  if (errors)\n+    {\n+      PRINT3 (\"%d error(s), %d test(s)\\n\", errors, num_tests);\n+      abort ();\n+    }\n+  else\n+    PRINT2 (\"No errors, %d test(s)\\n\", num_tests);\n+\n+  return 0;\n+}"}]}