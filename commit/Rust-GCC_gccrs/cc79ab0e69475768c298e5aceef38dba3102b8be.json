{"sha": "cc79ab0e69475768c298e5aceef38dba3102b8be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M3OWFiMGU2OTQ3NTc2OGMyOThlNWFjZWVmMzhkYmEzMTAyYjhiZQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2007-12-14T01:01:58Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2007-12-14T01:01:58Z"}, "message": "re PR target/34091 (ICE in reload_cse_simplify_operands, at postreload.c:392)\n\n\tPR target/34091\n\t* gcc.c-torture/compile/pr34091.c: New test.\n\nFrom-SVN: r130927", "tree": {"sha": "638acd5a713ca1f7d135739ffbab6966eabf0dec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/638acd5a713ca1f7d135739ffbab6966eabf0dec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc79ab0e69475768c298e5aceef38dba3102b8be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc79ab0e69475768c298e5aceef38dba3102b8be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc79ab0e69475768c298e5aceef38dba3102b8be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc79ab0e69475768c298e5aceef38dba3102b8be/comments", "author": null, "committer": null, "parents": [{"sha": "d749a87d806239125e6aeadef81ffe0a09221d31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d749a87d806239125e6aeadef81ffe0a09221d31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d749a87d806239125e6aeadef81ffe0a09221d31"}], "stats": {"total": 180, "additions": 180, "deletions": 0}, "files": [{"sha": "f3aea33a7f8bdd6c94ab543531075eb6177d8f30", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc79ab0e69475768c298e5aceef38dba3102b8be/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc79ab0e69475768c298e5aceef38dba3102b8be/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cc79ab0e69475768c298e5aceef38dba3102b8be", "patch": "@@ -1,3 +1,8 @@\n+2007-12-13  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/34091\n+\t* gcc.c-torture/compile/pr34091.c: New test.\n+\n 2007-12-13  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.dg/uninit-13.c: UnXFAIL."}, {"sha": "0b8549132e6dbaa76fa468a2d3c136fe34f11116", "filename": "gcc/testsuite/gcc.c-torture/compile/pr34091.c", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc79ab0e69475768c298e5aceef38dba3102b8be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr34091.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc79ab0e69475768c298e5aceef38dba3102b8be/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr34091.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr34091.c?ref=cc79ab0e69475768c298e5aceef38dba3102b8be", "patch": "@@ -0,0 +1,175 @@\n+typedef unsigned int GLenum;\n+typedef unsigned char GLboolean;\n+typedef int GLint;\n+typedef unsigned short GLushort;\n+typedef unsigned int GLuint;\n+typedef float GLfloat;\n+typedef GLushort GLchan;\n+struct gl_texture_image;\n+typedef struct __GLcontextRec GLcontext;\n+typedef void (*FetchTexelFuncC) (const struct gl_texture_image * texImage,\n+\t\t\t\t GLint col, GLint row, GLint img,\n+\t\t\t\t GLchan * texelOut);\n+struct gl_texture_format\n+{\n+};\n+struct gl_texture_image\n+{\n+  GLenum _BaseFormat;\n+  GLboolean _IsPowerOfTwo;\n+  FetchTexelFuncC FetchTexelc;\n+};\n+struct gl_texture_object\n+{\n+  GLenum Target;\n+  GLenum WrapS;\n+  GLenum MinFilter;\n+  GLenum MagFilter;\n+  GLint BaseLevel;\n+  GLint _MaxLevel;\n+  struct gl_texture_image *Image[6][12];\n+};\n+enum _format\n+{\n+    MESA_FORMAT_RGBA_DXT3, MESA_FORMAT_RGBA_DXT5, MESA_FORMAT_RGBA,\n+    MESA_FORMAT_RGB, MESA_FORMAT_ALPHA, MESA_FORMAT_LUMINANCE,\n+};\n+typedef void (*texture_sample_func) (GLcontext * ctx,\n+\t\t\t\t     const struct gl_texture_object * tObj,\n+\t\t\t\t     GLuint n, const GLfloat texcoords[][4],\n+\t\t\t\t     const GLfloat lambda[],\n+\t\t\t\t     GLchan rgba[][4]);\n+lerp_2d (GLfloat a, GLfloat b, GLfloat v00, GLfloat v10, GLfloat v01,\n+\t GLfloat v11)\n+{\n+  const GLfloat temp0 = ((v00) + (a) * ((v10) - (v00)));\n+  const GLfloat temp1 = ((v01) + (a) * ((v11) - (v01)));\n+  return ((temp0) + (b) * ((temp1) - (temp0)));\n+}\n+static __inline__ void\n+lerp_rgba (GLchan result[4], GLfloat t, const GLchan a[4], const GLchan b[4])\n+{\n+  result[0] = (GLchan) (((a[0]) + (t) * ((b[0]) - (a[0]))) + 0.5);\n+  result[1] = (GLchan) (((a[1]) + (t) * ((b[1]) - (a[1]))) + 0.5);\n+  result[2] = (GLchan) (((a[2]) + (t) * ((b[2]) - (a[2]))) + 0.5);\n+}\n+static __inline__ void\n+lerp_rgba_2d (GLchan result[4], GLfloat a, GLfloat b, const GLchan t00[4],\n+\t      const GLchan t10[4], const GLchan t01[4], const GLchan t11[4])\n+{\n+  result[0] = (GLchan) (lerp_2d (a, b, t00[0], t10[0], t01[0], t11[0]) + 0.5);\n+  result[1] = (GLchan) (lerp_2d (a, b, t00[1], t10[1], t01[1], t11[1]) + 0.5);\n+  result[2] = (GLchan) (lerp_2d (a, b, t00[2], t10[2], t01[2], t11[2]) + 0.5);\n+}\n+static __inline__ void\n+sample_2d_linear_repeat (GLcontext * ctx,\n+\t\t\t const struct gl_texture_object *tObj,\n+\t\t\t const struct gl_texture_image *img,\n+\t\t\t const GLfloat texcoord[4], GLchan rgba[])\n+{\n+  GLint i0, j0, i1, j1;\n+  GLfloat a, b;\n+  GLchan t00[4], t10[4], t01[4], t11[4];\n+  {\n+  };\n+  img->FetchTexelc (img, i1, j1, 0, t11);\n+  lerp_rgba_2d (rgba, a, b, t00, t10, t01, t11);\n+}\n+sample_2d_nearest_mipmap_linear (GLcontext * ctx,\n+\t\t\t\t const struct gl_texture_object *tObj,\n+\t\t\t\t GLuint n, const GLfloat texcoord[][4],\n+\t\t\t\t const GLfloat lambda[], GLchan rgba[][4])\n+{\n+  GLuint i;\n+  GLint level = linear_mipmap_level (tObj, lambda[i]);\n+  sample_2d_nearest (ctx, tObj, tObj->Image[0][tObj->_MaxLevel], texcoord[i], rgba[i]);\n+  GLchan t0[4], t1[4];\n+  sample_2d_nearest (ctx, tObj, tObj->Image[0][level], texcoord[i], t0);\n+  sample_2d_nearest (ctx, tObj, tObj->Image[0][level + 1], texcoord[i], t1);\n+}\n+static void\n+sample_2d_linear_mipmap_linear_repeat (GLcontext * ctx,\n+\t\t\t\t       const struct gl_texture_object *tObj,\n+\t\t\t\t       GLuint n, const GLfloat texcoord[][4],\n+\t\t\t\t       const GLfloat lambda[],\n+\t\t\t\t       GLchan rgba[][4])\n+{\n+  GLuint i;\n+  for (i = 0; i < n; i++)\n+    {\n+      GLint level = linear_mipmap_level (tObj, lambda[i]);\n+      if (level >= tObj->_MaxLevel)\n+\t{\n+\t  GLchan t0[4], t1[4];\n+\t  const GLfloat f = ((lambda[i]) - ifloor (lambda[i]));\n+\t  sample_2d_linear_repeat (ctx, tObj, tObj->Image[0][level],\n+\t\t\t\t   texcoord[i], t0);\n+\t  sample_2d_linear_repeat (ctx, tObj, tObj->Image[0][level + 1],\n+\t\t\t\t   texcoord[i], t1);\n+\t  lerp_rgba (rgba[i], f, t0, t1);\n+\t}\n+    }\n+}\n+static void\n+sample_lambda_2d (GLcontext * ctx, const struct gl_texture_object *tObj,\n+\t\t  GLuint n, const GLfloat texcoords[][4],\n+\t\t  const GLfloat lambda[], GLchan rgba[][4])\n+{\n+  const struct gl_texture_image *tImg = tObj->Image[0][tObj->BaseLevel];\n+  GLuint minStart, minEnd;\n+  GLuint magStart, magEnd;\n+  const GLboolean repeatNoBorderPOT = (tObj->WrapS == 0x2901)\n+    && (tImg->_BaseFormat != 0x1900) && tImg->_IsPowerOfTwo;\n+  compute_min_mag_ranges (tObj, n, lambda, &minStart, &minEnd, &magStart,\n+\t\t\t  &magEnd);\n+  if (minStart < minEnd)\n+    {\n+      const GLuint m = minEnd - minStart;\n+      switch (tObj->MinFilter)\n+\t{\n+\tcase 0x2600:\n+\t  if (repeatNoBorderPOT)\n+\t    {\n+\t\tcase MESA_FORMAT_RGB:\n+\t\t  opt_sample_rgb_2d (ctx, tObj, m, texcoords + minStart,\n+\t\t\t\t     ((void *) 0), rgba + minStart);\n+\t\tcase MESA_FORMAT_RGBA:\n+\t\t  opt_sample_rgba_2d (ctx, tObj, m, texcoords + minStart,\n+\t\t\t\t      ((void *) 0), rgba + minStart);\n+\t    }\n+\t    {\n+\t      sample_nearest_2d (ctx, tObj, m, texcoords + minStart,\n+\t\t\t\t ((void *) 0), rgba + minStart);\n+\t    }\n+\t  break;\n+\t  sample_2d_nearest_mipmap_linear (ctx, tObj, m, texcoords + minStart,\n+\t\t\t\t\t   lambda + minStart,\n+\t\t\t\t\t   rgba + minStart);\n+\tcase 0x2703:\n+\t  if (repeatNoBorderPOT)\n+\t    sample_2d_linear_mipmap_linear_repeat (ctx, tObj, m,\n+\t\t\t\t\t\t   texcoords + minStart,\n+\t\t\t\t\t\t   lambda + minStart,\n+\t\t\t\t\t\t   rgba + minStart);\n+\t}\n+      switch (tObj->MagFilter)\n+\t{\n+\t\tcase MESA_FORMAT_RGB:\n+\t\t  opt_sample_rgb_2d (ctx, tObj, m, texcoords + magStart,\n+\t\t\t\t     ((void *) 0), rgba + magStart);\n+\t\t  opt_sample_rgba_2d (ctx, tObj, m, texcoords + magStart,\n+\t\t\t\t      ((void *) 0), rgba + magStart);\n+                  sample_nearest_2d (ctx, tObj, m, texcoords + magStart,\n+                                     ((void *) 0), rgba + magStart);\n+\t}\n+    }\n+}\n+texture_sample_func\n+_swrast_choose_texture_sample_func (const struct gl_texture_object *t)\n+{\n+      switch (t->Target)\n+\t{\n+\tcase 0x0DE0:\n+\t      return &sample_lambda_2d;\n+\t}\n+}"}]}