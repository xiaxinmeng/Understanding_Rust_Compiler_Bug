{"sha": "89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlmZmE4ZmM0N2EyYzJhOTIyMGYwOTA2YTIzMWRmYjNlYzZlNGJiMA==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2007-07-30T13:48:43Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2007-07-30T13:48:43Z"}, "message": "neon.md (V_ext): New mode attribute.\n\n    gcc/\n    * config/arm/neon.md (V_ext): New mode attribute.\n    (neon_vget_lane<mode>): Replace with define_expand.\n    (neon_vget_lane<mode>_sext_internal)\n    (neon_vget_lane<mode>_zext_internal): New define_insns for double\n    and quad precision vectors.\n    (neon_vget_lanedi): Add bounds check. Remove dead comment.\n    * config/arm/neon.ml (get_lane): Make 32-bit get-lane intrinsics\n    have typeless 32-bit result.\n\n    gcc/testsuite/\n    * gcc.target/arm/neon/*.c: Regenerate.\n\nFrom-SVN: r127061", "tree": {"sha": "c8819622d1848dc3712e103c9c91945b13243dd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8819622d1848dc3712e103c9c91945b13243dd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7f7639220afa04831990f83cd7542bc371cc1eef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f7639220afa04831990f83cd7542bc371cc1eef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f7639220afa04831990f83cd7542bc371cc1eef"}], "stats": {"total": 160, "additions": 118, "deletions": 42}, "files": [{"sha": "e8aff1eeef4b00eeb9c99c6a2a5383f33a0a0237", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "patch": "@@ -1,3 +1,14 @@\n+2007-07-30  Julian Brown  <julian@codesourcery.com>\n+\n+\t* config/arm/neon.md (V_ext): New mode attribute.\n+\t(neon_vget_lane<mode>): Replace with define_expand.\n+\t(neon_vget_lane<mode>_sext_internal)\n+\t(neon_vget_lane<mode>_zext_internal): New define_insns for double\n+\tand quad precision vectors.\n+\t(neon_vget_lanedi): Add bounds check. Remove dead comment.\n+\t* config/arm/neon.ml (get_lane): Make 32-bit get-lane intrinsics\n+\thave typeless 32-bit result.\n+\n 2007-07-30  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR tree-opt/32527"}, {"sha": "1b09ead3af45c362858306e96762e626b1d3fcb8", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 96, "deletions": 35, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "patch": "@@ -266,6 +266,14 @@\n                           (V2SF \"SF\") (V4SF \"SF\")\n                           (DI \"DI\")   (V2DI \"DI\")])\n \n+;; Element modes for vector extraction, padded up to register size.\n+\n+(define_mode_attr V_ext [(V8QI \"SI\") (V16QI \"SI\")\n+\t\t\t (V4HI \"SI\") (V8HI \"SI\")\n+\t\t\t (V2SI \"SI\") (V4SI \"SI\")\n+\t\t\t (V2SF \"SF\") (V4SF \"SF\")\n+\t\t\t (DI \"DI\") (V2DI \"DI\")])\n+\n ;; Mode of pair of elements for each vector mode, to define transfer\n ;; size for structure lane/dup loads and stores.\n (define_mode_attr V_two_elem [(V8QI \"HI\") (V16QI \"HI\")\n@@ -2385,70 +2393,123 @@\n   DONE;\n })\n \n-;; FIXME: 32-bit element sizes are a bit funky (should be output as .32 not\n-;; .u32), but the assembler should cope with that.\n-\n-(define_insn \"neon_vget_lane<mode>\"\n-  [(set (match_operand:<V_elem> 0 \"s_register_operand\" \"=r\")\n-\t(unspec:<V_elem> [(match_operand:VD 1 \"s_register_operand\" \"w\")\n-\t\t\t  (match_operand:SI 2 \"immediate_operand\" \"i\")\n-                          (match_operand:SI 3 \"immediate_operand\" \"i\")]\n-                         UNSPEC_VGET_LANE))]\n+(define_insn \"neon_vget_lane<mode>_sext_internal\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t  (vec_select:<V_elem>\n+\t    (match_operand:VD 1 \"s_register_operand\" \"w\")\n+\t    (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n   \"TARGET_NEON\"\n-{\n-  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<MODE>mode));\n-  return \"vmov%?.%t3%#<V_sz_elem>\\t%0, %P1[%c2]\";\n-}\n+  \"vmov%?.s<V_sz_elem>\\t%0, %P1[%c2]\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n \n-; Operand 2 (lane number) is ignored because we can only extract the zeroth lane\n-; with this insn. Operand 3 (info word) is ignored because it does nothing\n-; useful with 64-bit elements.\n+(define_insn \"neon_vget_lane<mode>_zext_internal\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t  (vec_select:<V_elem>\n+\t    (match_operand:VD 1 \"s_register_operand\" \"w\")\n+\t    (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n+  \"TARGET_NEON\"\n+  \"vmov%?.u<V_sz_elem>\\t%0, %P1[%c2]\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"neon_type\" \"neon_bp_simple\")]\n+)\n \n-(define_insn \"neon_vget_lanedi\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=r\")\n-       (unspec:DI [(match_operand:DI 1 \"s_register_operand\" \"w\")\n-                   (match_operand:SI 2 \"immediate_operand\" \"i\")\n-                   (match_operand:SI 3 \"immediate_operand\" \"i\")]\n-                  UNSPEC_VGET_LANE))]\n+(define_insn \"neon_vget_lane<mode>_sext_internal\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t  (vec_select:<V_elem>\n+\t    (match_operand:VQ 1 \"s_register_operand\" \"w\")\n+\t    (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n   \"TARGET_NEON\"\n {\n-  neon_lane_bounds (operands[2], 0, 1);\n-  return \"vmov%?\\t%Q0, %R0, %P1  @ di\";\n+  rtx ops[3];\n+  int regno = REGNO (operands[1]);\n+  unsigned int halfelts = GET_MODE_NUNITS (<MODE>mode) / 2;\n+  unsigned int elt = INTVAL (operands[2]);\n+\n+  ops[0] = operands[0];\n+  ops[1] = gen_rtx_REG (<V_HALF>mode, regno + 2 * (elt / halfelts));\n+  ops[2] = GEN_INT (elt % halfelts);\n+  output_asm_insn (\"vmov%?.s<V_sz_elem>\\t%0, %P1[%c2]\", ops);\n+\n+  return \"\";\n }\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n \n-(define_insn \"neon_vget_lane<mode>\"\n-  [(set (match_operand:<V_elem> 0 \"s_register_operand\" \"=r\")\n-       (unspec:<V_elem> [(match_operand:VQ 1 \"s_register_operand\" \"w\")\n-                         (match_operand:SI 2 \"immediate_operand\" \"i\")\n-                         (match_operand:SI 3 \"immediate_operand\" \"i\")]\n-                        UNSPEC_VGET_LANE))]\n+(define_insn \"neon_vget_lane<mode>_zext_internal\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t  (vec_select:<V_elem>\n+\t    (match_operand:VQ 1 \"s_register_operand\" \"w\")\n+\t    (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n   \"TARGET_NEON\"\n {\n-  rtx ops[4];\n+  rtx ops[3];\n   int regno = REGNO (operands[1]);\n   unsigned int halfelts = GET_MODE_NUNITS (<MODE>mode) / 2;\n   unsigned int elt = INTVAL (operands[2]);\n \n-  neon_lane_bounds (operands[2], 0, halfelts * 2);\n-\n   ops[0] = operands[0];\n   ops[1] = gen_rtx_REG (<V_HALF>mode, regno + 2 * (elt / halfelts));\n   ops[2] = GEN_INT (elt % halfelts);\n-  ops[3] = operands[3];\n-  output_asm_insn (\"vmov%?.%t3%#<V_sz_elem>\\t%0, %P1[%c2]\", ops);\n+  output_asm_insn (\"vmov%?.u<V_sz_elem>\\t%0, %P1[%c2]\", ops);\n \n   return \"\";\n }\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"neon_type\" \"neon_bp_simple\")]\n )\n \n+(define_expand \"neon_vget_lane<mode>\"\n+  [(match_operand:<V_ext> 0 \"s_register_operand\" \"\")\n+   (match_operand:VDQW 1 \"s_register_operand\" \"\")\n+   (match_operand:SI 2 \"immediate_operand\" \"\")\n+   (match_operand:SI 3 \"immediate_operand\" \"\")]\n+  \"TARGET_NEON\"\n+{\n+  HOST_WIDE_INT magic = INTVAL (operands[3]);\n+  rtx insn;\n+\n+  neon_lane_bounds (operands[2], 0, GET_MODE_NUNITS (<MODE>mode));\n+\n+  if ((magic & 3) == 3 || GET_MODE_BITSIZE (GET_MODE_INNER (<MODE>mode)) == 32)\n+    insn = gen_vec_extract<mode> (operands[0], operands[1], operands[2]);\n+  else\n+    {\n+      if ((magic & 1) != 0)\n+\tinsn = gen_neon_vget_lane<mode>_sext_internal (operands[0], operands[1],\n+\t\t\t\t\t\t       operands[2]);\n+      else\n+\tinsn = gen_neon_vget_lane<mode>_zext_internal (operands[0], operands[1],\n+\t\t\t\t\t\t       operands[2]);\n+    }\n+  emit_insn (insn);\n+  DONE;\n+})\n+\n+; Operand 3 (info word) is ignored because it does nothing useful with 64-bit\n+; elements.\n+\n+(define_insn \"neon_vget_lanedi\"\n+  [(set (match_operand:DI 0 \"s_register_operand\" \"=r\")\n+       (unspec:DI [(match_operand:DI 1 \"s_register_operand\" \"w\")\n+                   (match_operand:SI 2 \"immediate_operand\" \"i\")\n+                   (match_operand:SI 3 \"immediate_operand\" \"i\")]\n+                  UNSPEC_VGET_LANE))]\n+  \"TARGET_NEON\"\n+{\n+  neon_lane_bounds (operands[2], 0, 1);\n+  return \"vmov%?\\t%Q0, %R0, %P1  @ di\";\n+}\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"neon_type\" \"neon_bp_simple\")]\n+)\n+\n (define_insn \"neon_vget_lanev2di\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=r\")\n        (unspec:DI [(match_operand:V2DI 1 \"s_register_operand\" \"w\")"}, {"sha": "a68c64539da822e8ad7f89ba8a8a7596b2763abd", "filename": "gcc/config/arm/neon.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Fconfig%2Farm%2Fneon.ml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Fconfig%2Farm%2Fneon.ml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.ml?ref=89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "patch": "@@ -611,7 +611,7 @@ let shift_insert shape elt =\n let get_lane shape elt =\n   let vtype = type_for_elt shape elt in\n   Arity2 (vtype 0, vtype 1, vtype 2),\n-    (match elt with P8 -> U8 | P16 -> U16 | x -> x)\n+    (match elt with P8 -> U8 | P16 -> U16 | S32 | U32 | F32 -> B32 | x -> x)\n \n let set_lane shape elt =\n   let vtype = type_for_elt shape elt in"}, {"sha": "b7681c3619414f17ebf9b9b485759116bbf7ee8b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "patch": "@@ -1,3 +1,7 @@\n+2007-07-30  Julian Brown  <julian@codesourcery.com>\n+\n+\t* gcc.target/arm/neon/v*.c: Regenerate.\n+\n 2007-07-30  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR c++/32108"}, {"sha": "4d0561b1ed05ac1466bd068494db6bed50f9bed4", "filename": "gcc/testsuite/gcc.target/arm/neon/vgetQ_lanef32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvgetQ_lanef32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvgetQ_lanef32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvgetQ_lanef32.c?ref=89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "patch": "@@ -15,5 +15,5 @@ void test_vgetQ_lanef32 (void)\n   out_float32_t = vgetq_lane_f32 (arg0_float32x4_t, 1);\n }\n \n-/* { dg-final { scan-assembler \"vmov\\.f32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n /* { dg-final { cleanup-saved-temps } } */"}, {"sha": "0f87fdb3b16e6cfe8c001ac5eff4a1f452368b61", "filename": "gcc/testsuite/gcc.target/arm/neon/vgetQ_lanes32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvgetQ_lanes32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvgetQ_lanes32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvgetQ_lanes32.c?ref=89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "patch": "@@ -15,5 +15,5 @@ void test_vgetQ_lanes32 (void)\n   out_int32_t = vgetq_lane_s32 (arg0_int32x4_t, 1);\n }\n \n-/* { dg-final { scan-assembler \"vmov\\.s32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n /* { dg-final { cleanup-saved-temps } } */"}, {"sha": "5a9344a808ad02541346a771c31fcddbef653674", "filename": "gcc/testsuite/gcc.target/arm/neon/vgetQ_laneu32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvgetQ_laneu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvgetQ_laneu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2FvgetQ_laneu32.c?ref=89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "patch": "@@ -15,5 +15,5 @@ void test_vgetQ_laneu32 (void)\n   out_uint32_t = vgetq_lane_u32 (arg0_uint32x4_t, 1);\n }\n \n-/* { dg-final { scan-assembler \"vmov\\.u32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n /* { dg-final { cleanup-saved-temps } } */"}, {"sha": "e469c6ec40b47c981381c4895ae9b53c67b854dd", "filename": "gcc/testsuite/gcc.target/arm/neon/vget_lanef32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvget_lanef32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvget_lanef32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvget_lanef32.c?ref=89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "patch": "@@ -15,5 +15,5 @@ void test_vget_lanef32 (void)\n   out_float32_t = vget_lane_f32 (arg0_float32x2_t, 1);\n }\n \n-/* { dg-final { scan-assembler \"vmov\\.f32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n /* { dg-final { cleanup-saved-temps } } */"}, {"sha": "50b8f40cb5a8c92045bb2788a6cb5c79275a7605", "filename": "gcc/testsuite/gcc.target/arm/neon/vget_lanes32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvget_lanes32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvget_lanes32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvget_lanes32.c?ref=89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "patch": "@@ -15,5 +15,5 @@ void test_vget_lanes32 (void)\n   out_int32_t = vget_lane_s32 (arg0_int32x2_t, 1);\n }\n \n-/* { dg-final { scan-assembler \"vmov\\.s32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n /* { dg-final { cleanup-saved-temps } } */"}, {"sha": "fd09ad4d0d2e065aa9d7fcad92bd557f75c48c68", "filename": "gcc/testsuite/gcc.target/arm/neon/vget_laneu32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvget_laneu32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvget_laneu32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon%2Fvget_laneu32.c?ref=89ffa8fc47a2c2a9220f0906a231dfb3ec6e4bb0", "patch": "@@ -15,5 +15,5 @@ void test_vget_laneu32 (void)\n   out_uint32_t = vget_lane_u32 (arg0_uint32x2_t, 1);\n }\n \n-/* { dg-final { scan-assembler \"vmov\\.u32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.32\\[ \t\\]+\\[rR\\]\\[0-9\\]+, \\[dD\\]\\[0-9\\]+\\\\\\[\\[0-9\\]+\\\\\\]!?\\(\\[ \t\\]+@\\[a-zA-Z0-9 \\]+\\)?\\n\" } } */\n /* { dg-final { cleanup-saved-temps } } */"}]}