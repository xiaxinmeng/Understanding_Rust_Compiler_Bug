{"sha": "45d18331f6fef4363e14fd19871ef765d1203472", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkMTgzMzFmNmZlZjQzNjNlMTRmZDE5ODcxZWY3NjVkMTIwMzQ3Mg==", "commit": {"author": {"name": "Adrian Straetling", "email": "straetling@de.ibm.com", "date": "2005-12-07T20:01:30Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-12-07T20:01:30Z"}, "message": "s390.c (s390_expand_atomic): New function.\n\n2005-12-07  Adrian Straetling  <straetling@de.ibm.com>\n\n\t* config/s390/s390.c (s390_expand_atomic): New function.\n\tAdjust comment of helper functions.\n\t* config/s390/s390-protos.h (s390_expand_atomic): Declare.\n\t* config/s390/s390.md (\"ATOMIC\"): New code macro.\n\t(\"atomic\"): Corresponding new code attribute.\n\t(\"sync_lock_test_and_set[hq]i\", \n\t\"sync_{new_,old_,}{and,ior,xor,add,sub,nand}[hq]i\"): New pattern.\n\nFrom-SVN: r108180", "tree": {"sha": "37f5267f112834ab802c16d730d210dd4de74128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37f5267f112834ab802c16d730d210dd4de74128"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45d18331f6fef4363e14fd19871ef765d1203472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d18331f6fef4363e14fd19871ef765d1203472", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d18331f6fef4363e14fd19871ef765d1203472", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d18331f6fef4363e14fd19871ef765d1203472/comments", "author": null, "committer": null, "parents": [{"sha": "3093f076e124d0d02ef4460e7c47289fdd567c31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3093f076e124d0d02ef4460e7c47289fdd567c31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3093f076e124d0d02ef4460e7c47289fdd567c31"}], "stats": {"total": 159, "additions": 153, "deletions": 6}, "files": [{"sha": "37f83ad477395732feeaea638961a185c4a91b81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d18331f6fef4363e14fd19871ef765d1203472/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d18331f6fef4363e14fd19871ef765d1203472/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45d18331f6fef4363e14fd19871ef765d1203472", "patch": "@@ -1,3 +1,13 @@\n+2005-12-07  Adrian Straetling  <straetling@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_expand_atomic): New function.\n+\tAdjust comment of helper functions.\n+\t* config/s390/s390-protos.h (s390_expand_atomic): Declare.\n+\t* config/s390/s390.md (\"ATOMIC\"): New code macro.\n+\t(\"atomic\"): Corresponding new code attribute.\n+\t(\"sync_lock_test_and_set[hq]i\", \n+\t\"sync_{new_,old_,}{and,ior,xor,add,sub,nand}[hq]i\"): New pattern.\n+\n 2005-12-07  Adrian Straetling  <straetling@de.ibm.com>\n \n \t* config/s390/s390.c (s390_expand_mask_and_shift, "}, {"sha": "e62493d1bb0dc25b17f1ce4c8c0f2e629a56b943", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d18331f6fef4363e14fd19871ef765d1203472/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d18331f6fef4363e14fd19871ef765d1203472/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=45d18331f6fef4363e14fd19871ef765d1203472", "patch": "@@ -76,6 +76,8 @@ extern void s390_expand_cmpmem (rtx, rtx, rtx, rtx);\n extern bool s390_expand_addcc (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern bool s390_expand_insv (rtx, rtx, rtx, rtx);\n extern void s390_expand_cs_hqi (enum machine_mode, rtx, rtx, rtx, rtx);\n+extern void s390_expand_atomic (enum machine_mode, enum rtx_code, \n+\t\t\t\trtx, rtx, rtx, bool);\n extern rtx s390_return_addr_rtx (int, rtx);\n extern rtx s390_back_chain_rtx (void);\n extern rtx s390_emit_call (rtx, rtx, rtx, rtx);"}, {"sha": "901b9b5f8607715532c310132c8638596bfb0de5", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 97, "deletions": 6, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d18331f6fef4363e14fd19871ef765d1203472/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d18331f6fef4363e14fd19871ef765d1203472/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=45d18331f6fef4363e14fd19871ef765d1203472", "patch": "@@ -3972,8 +3972,8 @@ s390_expand_insv (rtx dest, rtx op1, rtx op2, rtx src)\n   return false;\n }\n \n-/* A subroutine of s390_expand_cs_hqi which returns a register which holds VAL\n-   of mode MODE shifted by COUNT bits.  */\n+/* A subroutine of s390_expand_cs_hqi and s390_expand_atomic which returns a\n+   register that holds VAL of mode MODE shifted by COUNT bits.  */\n \n static inline rtx\n s390_expand_mask_and_shift (rtx val, enum machine_mode mode, rtx count)\n@@ -3996,10 +3996,10 @@ struct alignment_context\n   bool aligned;\t  /* True if memory is aliged, false else.  */\n };\n \n-/* A subroutine of s390_expand_cs_hqi to initialize the structure AC for\n-   transparent simplifying, if the memory alignment is known to be at least\n-   32bit.  MEM is the memory location for the actual operation and MODE its\n-   mode.  */\n+/* A subroutine of s390_expand_cs_hqi and s390_expand_atomic to initialize\n+   structure AC for transparent simplifying, if the memory alignment is known\n+   to be at least 32bit.  MEM is the memory location for the actual operation\n+   and MODE its mode.  */\n \n static void\n init_alignment_context (struct alignment_context *ac, rtx mem,\n@@ -4122,6 +4122,97 @@ s390_expand_cs_hqi (enum machine_mode mode, rtx target, rtx mem, rtx cmp, rtx ne\n \t\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT), 1);\n }\n \n+/* Expand an atomic operation CODE of mode MODE.  MEM is the memory location\n+   and VAL the value to play with.  If AFTER is true then store the the value\n+   MEM holds after the operation, if AFTER is false then store the value MEM\n+   holds before the operation.  If TARGET is zero then discard that value, else\n+   store it to TARGET.  */\n+\n+void\n+s390_expand_atomic (enum machine_mode mode, enum rtx_code code,\n+\t\t    rtx target, rtx mem, rtx val, bool after)\n+{\n+  struct alignment_context ac;\n+  rtx cmp;\n+  rtx new = gen_reg_rtx (SImode);\n+  rtx orig = gen_reg_rtx (SImode);\n+  rtx csloop = gen_label_rtx ();\n+\n+  gcc_assert (!target || register_operand (target, VOIDmode));\n+  gcc_assert (MEM_P (mem));\n+\n+  init_alignment_context (&ac, mem, mode);\n+\n+  /* Shift val to the correct bit positions.\n+     Preserve \"icm\", but prevent \"ex icm\".  */\n+  if (!(ac.aligned && code == SET && MEM_P (val)))\n+    val = s390_expand_mask_and_shift (val, mode, ac.shift);\n+\n+  /* Further preparation insns.  */\n+  if (code == PLUS || code == MINUS)\n+    emit_move_insn (orig, val);\n+  else if (code == MULT || code == AND) /* val = \"11..1<val>11..1\" */\n+    val = expand_simple_binop (SImode, XOR, val, ac.modemaski,\n+\t\t\t       NULL_RTX, 1, OPTAB_DIRECT);\n+\n+  /* Load full word.  Subsequent loads are performed by CS.  */\n+  cmp = force_reg (SImode, ac.memsi);\n+\n+  /* Start CS loop.  */\n+  emit_label (csloop);\n+  emit_move_insn (new, cmp);\n+\n+  /* Patch new with val at correct position.  */\n+  switch (code)\n+    {\n+    case PLUS:\n+    case MINUS:\n+      val = expand_simple_binop (SImode, code, new, orig,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      val = expand_simple_binop (SImode, AND, val, ac.modemask,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      /* FALLTHRU */\n+    case SET: \n+      if (ac.aligned && MEM_P (val))\n+\tstore_bit_field (new, GET_MODE_BITSIZE (mode), 0, SImode, val);\n+      else\n+\t{\n+\t  new = expand_simple_binop (SImode, AND, new, ac.modemaski,\n+\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n+\t  new = expand_simple_binop (SImode, IOR, new, val,\n+\t\t\t\t     NULL_RTX, 1, OPTAB_DIRECT);\n+\t}\n+      break;\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      new = expand_simple_binop (SImode, code, new, val,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      break;\n+    case MULT: /* NAND */\n+      new = expand_simple_binop (SImode, XOR, new, ac.modemask,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      new = expand_simple_binop (SImode, AND, new, val,\n+\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  /* Emit compare_and_swap pattern.  */\n+  emit_insn (gen_sync_compare_and_swap_ccsi (cmp, ac.memsi, cmp, new));\n+\n+  /* Loop until swapped (unlikely?).  */\n+  s390_emit_jump (csloop, gen_rtx_fmt_ee (NE, CCZ1mode,\n+\t\t\t\t\t  gen_rtx_REG (CCZ1mode, CC_REGNUM),\n+\t\t\t\t\t  const0_rtx));\n+\n+  /* Return the correct part of the bitfield.  */\n+  if (target)\n+    convert_move (target, expand_simple_binop (SImode, LSHIFTRT,\n+\t\t\t\t\t       after ? new : cmp, ac.shift,\n+\t\t\t\t\t       NULL_RTX, 1, OPTAB_DIRECT), 1);\n+}\n+\n /* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.\n    We need to emit DTP-relative relocations.  */\n "}, {"sha": "cf484c3bc202d07292dc428cce564175532238ad", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d18331f6fef4363e14fd19871ef765d1203472/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d18331f6fef4363e14fd19871ef765d1203472/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=45d18331f6fef4363e14fd19871ef765d1203472", "patch": "@@ -315,6 +315,11 @@\n ;; the same template.\n (define_code_macro SHIFT [ashift lshiftrt])\n \n+;; These macros allow to combine most atomic operations.\n+(define_code_macro ATOMIC [and ior xor plus minus mult])\n+(define_code_attr atomic [(and \"and\") (ior \"ior\") (xor \"xor\") \n+\t\t\t  (plus \"add\") (minus \"sub\") (mult \"nand\")])\n+\n \n ;; In FPR templates, a string like \"lt<de>br\" will expand to \"ltdbr\" in DFmode\n ;; and \"ltebr\" in SFmode.\n@@ -7340,6 +7345,45 @@\n    (set_attr \"type\"   \"sem\")])\n \n \n+;\n+; Other atomic instruction patterns.\n+;\n+\n+(define_expand \"sync_lock_test_and_set<mode>\"\n+  [(match_operand:HQI 0 \"register_operand\")\n+   (match_operand:HQI 1 \"memory_operand\")\n+   (match_operand:HQI 2 \"general_operand\")]\n+  \"\"\n+  \"s390_expand_atomic (<MODE>mode, SET, operands[0], operands[1], \n+\t\t       operands[2], false); DONE;\")\n+\n+(define_expand \"sync_<atomic><mode>\"\n+  [(set (match_operand:HQI 0 \"memory_operand\")\n+\t(ATOMIC:HQI (match_dup 0)\n+\t\t    (match_operand:HQI 1 \"general_operand\")))]\n+  \"\"\n+  \"s390_expand_atomic (<MODE>mode, <CODE>, NULL_RTX, operands[0], \n+\t\t       operands[1], false); DONE;\")\n+\n+(define_expand \"sync_old_<atomic><mode>\"\n+  [(set (match_operand:HQI 0 \"register_operand\")\n+\t(match_operand:HQI 1 \"memory_operand\"))\n+   (set (match_dup 1)\n+\t(ATOMIC:HQI (match_dup 1)\n+\t\t    (match_operand:HQI 2 \"general_operand\")))]\n+  \"\"\n+  \"s390_expand_atomic (<MODE>mode, <CODE>, operands[0], operands[1], \n+\t\t       operands[2], false); DONE;\")\n+\n+(define_expand \"sync_new_<atomic><mode>\"\n+  [(set (match_operand:HQI 0 \"register_operand\")\n+\t(ATOMIC:HQI (match_operand:HQI 1 \"memory_operand\")\n+\t\t    (match_operand:HQI 2 \"general_operand\"))) \n+   (set (match_dup 1) (ATOMIC:HQI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"s390_expand_atomic (<MODE>mode, <CODE>, operands[0], operands[1], \n+\t\t       operands[2], true); DONE;\")\n+\n ;;\n ;;- Miscellaneous instructions.\n ;;"}]}