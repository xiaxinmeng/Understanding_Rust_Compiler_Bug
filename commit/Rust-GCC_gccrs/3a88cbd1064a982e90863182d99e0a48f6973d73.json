{"sha": "3a88cbd1064a982e90863182d99e0a48f6973d73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E4OGNiZDEwNjRhOTgyZTkwODYzMTgyZDk5ZTBhNDhmNjk3M2Q3Mw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-11-12T17:07:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-11-12T17:07:46Z"}, "message": "except.c: Do not include \"assert.h\".\n\n        * except.c: Do not include \"assert.h\".\n        (save_eh_status): Turn asserts into conditional aborts.\n        (restore_eh_status, scan_region): Likewise.\n        * dwarfout.c: Do not include \"assert.h\".\n        (bit_offset_attribute): Turn asserts into conditional aborts.\n        (bit_size_attribute, output_inlined_enumeration_type_die): Likewise.\n        (output_inlined_structure_type_die): Likewise.\n        (output_inlined_union_type_die): Likewise\n        (output_tagged_type_instantiation): Likewise.\n        (dwarfout_file_scope_decl): Likewise.\n        * dwarf2out.c: Do not include \"assert.h\"\n        (expand_builtin_dwarf_reg_size): Turn asserts into conditional aborts.\n        (reg_save, initial_return_save, dwarf2out_frame_debug): Likewise.\n        (add_child_die, modified_type_die, add_bit_offset_attribute): Likewise.\n        (add_bit_size_attribute, scope_die_for): Likewise.\n        (output_pending_types_for_scope): Likewise.\n        (get_inlined_enumeration_type_die): Likewise.\n        (get_inlined_structure_type_die): Likewise.\n        (get_inlined_union_type_die, gen_subprogram_die): Likewise.\n        (gen_tagged_type_instantiation_die): Likewise.\n\nFrom-SVN: r16442", "tree": {"sha": "8981c8afce67fc7c21c2b1606afc5f2108031f4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8981c8afce67fc7c21c2b1606afc5f2108031f4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a88cbd1064a982e90863182d99e0a48f6973d73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a88cbd1064a982e90863182d99e0a48f6973d73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a88cbd1064a982e90863182d99e0a48f6973d73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a88cbd1064a982e90863182d99e0a48f6973d73/comments", "author": null, "committer": null, "parents": [{"sha": "2ec1535d973bcaa1a1f7d86352bc9d8cee60da09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec1535d973bcaa1a1f7d86352bc9d8cee60da09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ec1535d973bcaa1a1f7d86352bc9d8cee60da09"}], "stats": {"total": 218, "additions": 140, "deletions": 78}, "files": [{"sha": "0893da34b14aa8e29c0660e244969b834c0ac273", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a88cbd1064a982e90863182d99e0a48f6973d73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a88cbd1064a982e90863182d99e0a48f6973d73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a88cbd1064a982e90863182d99e0a48f6973d73", "patch": "@@ -1,5 +1,26 @@\n Wed Nov 12 09:37:01 1997  Jeffrey A Law  (law@cygnus.com)\n \n+\t* except.c: Do not include \"assert.h\".\n+\t(save_eh_status): Turn asserts into conditional aborts.\n+\t(restore_eh_status, scan_region): Likewise.\n+\t* dwarfout.c: Do not include \"assert.h\".\n+\t(bit_offset_attribute): Turn asserts into conditional aborts.\n+\t(bit_size_attribute, output_inlined_enumeration_type_die): Likewise.\n+\t(output_inlined_structure_type_die): Likewise.\n+\t(output_inlined_union_type_die): Likewise\n+\t(output_tagged_type_instantiation): Likewise.\n+\t(dwarfout_file_scope_decl): Likewise.\n+\t* dwarf2out.c: Do not include \"assert.h\"\n+\t(expand_builtin_dwarf_reg_size): Turn asserts into conditional aborts.\n+\t(reg_save, initial_return_save, dwarf2out_frame_debug): Likewise.\n+\t(add_child_die, modified_type_die, add_bit_offset_attribute): Likewise.\n+\t(add_bit_size_attribute, scope_die_for): Likewise.\n+\t(output_pending_types_for_scope): Likewise.\n+\t(get_inlined_enumeration_type_die): Likewise.\n+\t(get_inlined_structure_type_die): Likewise.\n+\t(get_inlined_union_type_die, gen_subprogram_die): Likewise.\n+\t(gen_tagged_type_instantiation_die): Likewise.\n+\n \t* flow.c (find_basic_blocks): Refine further to get a more correct\n \tcfg, especially in the presense of exception handling, computed\n \tgotos, and other non-trivial cases.  Call abort if an inaccuracy"}, {"sha": "5e941ad24a38bacf703cb5e2b5c387da6b78b3fc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 89, "deletions": 57, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a88cbd1064a982e90863182d99e0a48f6973d73/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a88cbd1064a982e90863182d99e0a48f6973d73/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=3a88cbd1064a982e90863182d99e0a48f6973d73", "patch": "@@ -41,9 +41,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"except.h\"\n #include \"dwarf2.h\"\n \n-/* #define NDEBUG 1 */\n-#include \"assert.h\"\n-\n /* Decide whether we want to emit frame unwind information for the current\n    translation unit.  */\n \n@@ -550,17 +547,19 @@ expand_builtin_dwarf_reg_size (reg_tree, target)\n \t  ranges[n_ranges].beg = i;\n \t  ranges[n_ranges].size = last_size = GET_MODE_SIZE (reg_raw_mode[i]);\n \t  ++n_ranges;\n-\t  assert (n_ranges < 5);\n+\t  if (n_ranges >= 5)\n+\t    abort ();\n \t}\n       ranges[n_ranges-1].end = i;\n     }\n \n   /* The usual case: fp regs surrounded by general regs.  */\n   if (n_ranges == 3 && ranges[0].size == ranges[2].size)\n     {\n-      assert ((DWARF_FRAME_REGNUM (ranges[1].end)\n-\t       - DWARF_FRAME_REGNUM (ranges[1].beg))\n-\t      == ranges[1].end - ranges[1].beg);\n+      if ((DWARF_FRAME_REGNUM (ranges[1].end)\n+\t   - DWARF_FRAME_REGNUM (ranges[1].beg))\n+\t  != ranges[1].end - ranges[1].beg)\n+\tabort ();\n       t  = fold (build (GE_EXPR, integer_type_node, reg_tree,\n \t\t\tbuild_int_2 (DWARF_FRAME_REGNUM (ranges[1].beg), 0)));\n       t2 = fold (build (LE_EXPR, integer_type_node, reg_tree,\n@@ -577,10 +576,12 @@ expand_builtin_dwarf_reg_size (reg_tree, target)\n       size = DWARF_FRAME_REGNUM (ranges[n_ranges].beg);\n       for (; n_ranges--; )\n \t{\n-\t  assert ((DWARF_FRAME_REGNUM (ranges[n_ranges].end)\n-\t\t   - DWARF_FRAME_REGNUM (ranges[n_ranges].beg))\n-\t\t  == ranges[n_ranges].end - ranges[n_ranges].beg);\n-\t  assert (DWARF_FRAME_REGNUM (ranges[n_ranges].beg) < size);\n+\t  if ((DWARF_FRAME_REGNUM (ranges[n_ranges].end)\n+\t       - DWARF_FRAME_REGNUM (ranges[n_ranges].beg))\n+\t      != ranges[n_ranges].end - ranges[n_ranges].beg)\n+\t    abort ();\n+\t  if (DWARF_FRAME_REGNUM (ranges[n_ranges].beg) >= size)\n+\t    abort ();\n \t  size = DWARF_FRAME_REGNUM (ranges[n_ranges].beg);\n \t  t2 = fold (build (LE_EXPR, integer_type_node, reg_tree,\n \t\t\t    build_int_2 (DWARF_FRAME_REGNUM\n@@ -869,7 +870,8 @@ reg_save (label, reg, sreg, offset)\n \tcfi->dw_cfi_opc = DW_CFA_offset;\n \n       offset /= DWARF_CIE_DATA_ALIGNMENT;\n-      assert (offset >= 0);\n+      if (offset < 0)\n+\tabort ();\n       cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n     }\n   else\n@@ -967,15 +969,18 @@ initial_return_save (rtl)\n       switch (GET_CODE (rtl))\n \t{\n \tcase REG:\n-\t  assert (REGNO (rtl) == STACK_POINTER_REGNUM);\n+\t  if (REGNO (rtl) != STACK_POINTER_REGNUM)\n+\t    abort ();\n \t  offset = 0;\n \t  break;\n \tcase PLUS:\n-\t  assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n+\t  if (REGNO (XEXP (rtl, 0)) != STACK_POINTER_REGNUM)\n+\t    abort ();\n \t  offset = INTVAL (XEXP (rtl, 1));\n \t  break;\n \tcase MINUS:\n-\t  assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n+\t  if (REGNO (XEXP (rtl, 0)) != STACK_POINTER_REGNUM)\n+\t    abort ();\n \t  offset = -INTVAL (XEXP (rtl, 1));\n \t  break;\n \tdefault:\n@@ -986,7 +991,8 @@ initial_return_save (rtl)\n       /* The return address is at some offset from any value we can\n \t actually load.  For instance, on the SPARC it is in %i7+8. Just\n \t ignore the offset for now; it doesn't matter for unwinding frames.  */\n-      assert (GET_CODE (XEXP (rtl, 1)) == CONST_INT);\n+      if (GET_CODE (XEXP (rtl, 1)) != CONST_INT)\n+\tabort ();\n       initial_return_save (XEXP (rtl, 0));\n       return;\n     default:\n@@ -1097,7 +1103,8 @@ dwarf2out_frame_debug (insn)\n     {\n       /* Set up state for generating call frame debug info.  */\n       lookup_cfa (&cfa_reg, &cfa_offset);\n-      assert (cfa_reg == DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM));\n+      if (cfa_reg != DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM))\n+\tabort ();\n       cfa_reg = STACK_POINTER_REGNUM;\n       cfa_store_reg = cfa_reg;\n       cfa_store_offset = cfa_offset;\n@@ -1119,7 +1126,8 @@ dwarf2out_frame_debug (insn)\n      significant.  Currently this is true.  */\n   if (GET_CODE (insn) == PARALLEL)\n     insn = XVECEXP (insn, 0, 0);\n-  assert (GET_CODE (insn) == SET);\n+  if (GET_CODE (insn) != SET)\n+    abort ();\n \n   src = SET_SRC (insn);\n   dest = SET_DEST (insn);\n@@ -1133,10 +1141,12 @@ dwarf2out_frame_debug (insn)\n \t{\n \t  /* Setting FP from SP.  */\n \tcase REG:\n-\t  assert (cfa_reg == REGNO (src));\n-\t  assert (REGNO (dest) == STACK_POINTER_REGNUM\n-\t\t  || (frame_pointer_needed\n-\t\t      && REGNO (dest) == HARD_FRAME_POINTER_REGNUM));\n+\t  if (cfa_reg != REGNO (src))\n+\t    abort ();\n+\t  if (REGNO (dest) != STACK_POINTER_REGNUM\n+\t      && !(frame_pointer_needed\n+\t\t   && REGNO (dest) == HARD_FRAME_POINTER_REGNUM))\n+\t    abort ();\n \t  cfa_reg = REGNO (dest);\n \t  break;\n \n@@ -1151,7 +1161,8 @@ dwarf2out_frame_debug (insn)\n \t\t  offset = INTVAL (XEXP (src, 1));\n \t\t  break;\n \t\tcase REG:\n-\t\t  assert (REGNO (XEXP (src, 1)) == cfa_temp_reg);\n+\t\t  if (REGNO (XEXP (src, 1)) != cfa_temp_reg)\n+\t\t    abort ();\n \t\t  offset = cfa_temp_value;\n \t\t  break;\n \t\tdefault:\n@@ -1161,11 +1172,12 @@ dwarf2out_frame_debug (insn)\n \t      if (XEXP (src, 0) == hard_frame_pointer_rtx)\n \t\t{\n \t\t  /* Restoring SP from FP in the epilogue.  */\n-\t\t  assert (cfa_reg == HARD_FRAME_POINTER_REGNUM);\n+\t\t  if (cfa_reg != HARD_FRAME_POINTER_REGNUM)\n+\t\t    abort ();\n \t\t  cfa_reg = STACK_POINTER_REGNUM;\n \t\t}\n-\t      else\n-\t\tassert (XEXP (src, 0) == stack_pointer_rtx);\n+\t      else if (XEXP (src, 0) != stack_pointer_rtx)\n+\t\tabort ();\n \n \t      if (GET_CODE (src) == PLUS)\n \t\toffset = -offset;\n@@ -1176,11 +1188,12 @@ dwarf2out_frame_debug (insn)\n \t    }\n \t  else\n \t    {\n-\t      /* Initializing the store base register.  */\n-\t      assert (GET_CODE (src) == PLUS);\n-\t      assert (XEXP (src, 1) == stack_pointer_rtx);\n-\t      assert (GET_CODE (XEXP (src, 0)) == REG\n-\t\t      && REGNO (XEXP (src, 0)) == cfa_temp_reg);\n+\t      if (GET_CODE (src) != PLUS\n+\t\t  || XEXP (src, 1) != stack_pointer_rtx\n+\t\tabort ();\n+\t      if (GET_CODE (XEXP (src, 0)) != REG\n+\t\t  || REGNO (XEXP (src, 0)) != cfa_temp_reg)\n+\t\tabort ();\n \t      cfa_store_reg = REGNO (dest);\n \t      cfa_store_offset -= cfa_temp_value;\n \t    }\n@@ -1192,10 +1205,11 @@ dwarf2out_frame_debug (insn)\n \t  break;\n \n \tcase IOR:\n-\t  assert (GET_CODE (XEXP (src, 0)) == REG\n-\t\t  && REGNO (XEXP (src, 0)) == cfa_temp_reg);\n-\t  assert (REGNO (dest) == cfa_temp_reg);\n-\t  assert (GET_CODE (XEXP (src, 1)) == CONST_INT);\n+\t  if (GET_CODE (XEXP (src, 0)) != REG\n+\t      || REGNO (XEXP (src, 0)) != cfa_temp_reg\n+\t      || REGNO (dest) != cfa_temp_reg\n+\t      || GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\t    abort ();\n \t  cfa_temp_value |= INTVAL (XEXP (src, 1));\n \t  break;\n \n@@ -1208,7 +1222,8 @@ dwarf2out_frame_debug (insn)\n     case MEM:\n       /* Saving a register to the stack.  Make sure dest is relative to the\n          CFA register.  */\n-      assert (GET_CODE (src) == REG);\n+      if (GET_CODE (src) != REG)\n+\tabort ();\n       switch (GET_CODE (XEXP (dest, 0)))\n \t{\n \t  /* With a push.  */\n@@ -1218,8 +1233,9 @@ dwarf2out_frame_debug (insn)\n \t  if (GET_CODE (XEXP (dest, 0)) == PRE_INC)\n \t    offset = -offset;\n \n-\t  assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM);\n-\t  assert (cfa_store_reg == STACK_POINTER_REGNUM);\n+\t  if (REGNO (XEXP (XEXP (dest, 0), 0)) != STACK_POINTER_REGNUM\n+\t      || cfa_store_reg != STACK_POINTER_REGNUM)\n+\t    abort ();\n \t  cfa_store_offset += offset;\n \t  if (cfa_reg == STACK_POINTER_REGNUM)\n \t    cfa_offset = cfa_store_offset;\n@@ -1234,7 +1250,8 @@ dwarf2out_frame_debug (insn)\n \t  if (GET_CODE (src) == MINUS)\n \t    offset = -offset;\n \n-\t  assert (cfa_store_reg == REGNO (XEXP (XEXP (dest, 0), 0)));\n+\t  if (cfa_store_reg != REGNO (XEXP (XEXP (dest, 0), 0)))\n+\t    abort ();\n \t  offset -= cfa_store_offset;\n \t  break;\n \n@@ -3862,7 +3879,8 @@ add_child_die (die, child_die)\n {\n   if (die != NULL && child_die != NULL)\n     {\n-      assert (die != child_die);\n+      if (die == child_die)\n+\tabort ();\n       child_die->die_parent = die;\n       child_die->die_sib = NULL;\n \n@@ -6156,7 +6174,8 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t     that copy might have a different TYPE_UID from the original\n \t     ..._TYPE node.  */\n \t  mod_type_die = lookup_type_die (type_main_variant (type));\n-\t  assert (mod_type_die != NULL);\n+\t  if (mod_type_die == NULL)\n+\t    abort ();\n \t}\n     }\n \n@@ -7152,8 +7171,10 @@ add_bit_offset_attribute (die, decl)\n   register unsigned highest_order_field_bit_offset;\n   register unsigned bit_offset;\n \n-  assert (TREE_CODE (decl) == FIELD_DECL);\t/* Must be a field.  */\n-  assert (type);\t\t\t\t/* Must be a bit field.  */\n+  /* Must be a field and a bit field.  */\n+  if (!type\n+      || TREE_CODE (decl) != FIELD_DECL)\n+    abort ();\n \n   /* We can't yet handle bit-fields whose offsets are variable, so if we\n      encounter such things, just return without generating any attribute\n@@ -7195,8 +7216,10 @@ add_bit_size_attribute (die, decl)\n      register dw_die_ref die;\n      register tree decl;\n {\n-  assert (TREE_CODE (decl) == FIELD_DECL);\t/* Must be a field.  */\n-  assert (DECL_BIT_FIELD_TYPE (decl));\t\t/* Must be a bit field.  */\n+  /* Must be a field and a bit field.  */\n+  if (TREE_CODE (decl) != FIELD_DECL\n+      || ! DECL_BIT_FIELD_TYPE (decl))\n+    abort ();\n   add_AT_unsigned (die, DW_AT_bit_size,\n \t\t   (unsigned) TREE_INT_CST_LOW (DECL_SIZE (decl)));\n }\n@@ -7345,10 +7368,12 @@ scope_die_for (t, context_die)\n \n       if (i == 0)\n \t{\n-\t  assert (scope_die == comp_unit_die);\n-\t  assert (TREE_CODE_CLASS (TREE_CODE (containing_scope)) == 't');\n-\t  if (debug_info_level > DINFO_LEVEL_TERSE)\n-\t    assert (TREE_ASM_WRITTEN (containing_scope));\n+\t  if (scope_die != comp_unit_die\n+\t      || TREE_CODE_CLASS (TREE_CODE (containing_scope)) != 't')\n+\t    abort ();\n+\t  if (debug_info_level > DINFO_LEVEL_TERSE\n+\t      && !TREE_ASM_WRITTEN (containing_scope))\n+\t    abort ();\n \t}\n     }\n \n@@ -7359,7 +7384,8 @@ scope_die_for (t, context_die)\n static inline void\n pop_decl_scope ()\n {\n-  assert (decl_scope_depth > 0);\n+  if (decl_scope_depth <= 0)\n+    abort ();\n   --decl_scope_depth;\n }\n \n@@ -7598,7 +7624,8 @@ output_pending_types_for_scope (context_die)\n       --pending_types;\n       type = pending_types_list[pending_types];\n       gen_type_die (type, context_die);\n-      assert (TREE_ASM_WRITTEN (type));\n+      if (!TREE_ASM_WRITTEN (type))\n+\tabort ();\n     }\n }\n \n@@ -7612,7 +7639,8 @@ gen_inlined_enumeration_type_die (type, context_die)\n   register dw_die_ref type_die = new_die (DW_TAG_enumeration_type,\n \t\t\t\t\t  scope_die_for (type, context_die));\n \n-  assert (TREE_ASM_WRITTEN (type));\n+  if (!TREE_ASM_WRITTEN (type))\n+    abort ();\n   add_abstract_origin_attribute (type_die, type);\n }\n \n@@ -7626,7 +7654,8 @@ gen_inlined_structure_type_die (type, context_die)\n   register dw_die_ref type_die = new_die (DW_TAG_structure_type,\n \t\t\t\t\t  scope_die_for (type, context_die));\n \n-  assert (TREE_ASM_WRITTEN (type));\n+  if (!TREE_ASM_WRITTEN (type))\n+    abort ();\n   add_abstract_origin_attribute (type_die, type);\n }\n \n@@ -7640,7 +7669,8 @@ gen_inlined_union_type_die (type, context_die)\n   register dw_die_ref type_die = new_die (DW_TAG_union_type,\n \t\t\t\t\t  scope_die_for (type, context_die));\n \n-  assert (TREE_ASM_WRITTEN (type));\n+  if (!TREE_ASM_WRITTEN (type))\n+    abort ();\n   add_abstract_origin_attribute (type_die, type);\n }\n \n@@ -7881,7 +7911,8 @@ gen_subprogram_die (decl, context_die)\n       register unsigned file_index\n \t= lookup_filename (DECL_SOURCE_FILE (decl));\n \n-      assert (get_AT_flag (old_die, DW_AT_declaration) == 1);\n+      if (get_AT_flag (old_die, DW_AT_declaration) != 1)\n+\tabort ();\n \n       /* If the definition comes from the same place as the declaration,\n \t maybe use the old DIE.  We always want the DIE for this function\n@@ -8784,8 +8815,9 @@ gen_tagged_type_instantiation_die (type, context_die)\n      this type (i.e. without any const or volatile qualifiers) so make sure\n      that we have the main variant (i.e. the unqualified version) of this\n      type now.  */\n-  assert (type == type_main_variant (type));\n-  assert (TREE_ASM_WRITTEN (type));\n+  if (type != type_main_variant (type)\n+      || !TREE_ASM_WRITTEN (type))\n+    abort ();\n \n   switch (TREE_CODE (type))\n     {"}, {"sha": "2e108dc0410a5dc83a457d5bc8db8eac0999090e", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a88cbd1064a982e90863182d99e0a48f6973d73/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a88cbd1064a982e90863182d99e0a48f6973d73/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=3a88cbd1064a982e90863182d99e0a48f6973d73", "patch": "@@ -33,9 +33,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"defaults.h\"\n \n-/* #define NDEBUG 1 */\n-#include \"assert.h\"\n-\n #if defined(DWARF_TIMESTAMPS)\n #if defined(POSIX)\n #include <time.h>\n@@ -2698,8 +2695,10 @@ bit_offset_attribute (decl)\n   register unsigned highest_order_field_bit_offset;\n   register unsigned bit_offset;\n \n-  assert (TREE_CODE (decl) == FIELD_DECL);\t/* Must be a field.  */\n-  assert (type);\t\t\t\t/* Must be a bit field.\t */\n+  /* Must be a bit field.  */\n+  if (!type\n+      || TREE_CODE (decl) != FIELD_DECL)\n+    abort ();\n \n   /* We can't yet handle bit-fields whose offsets are variable, so if we\n      encounter such things, just return without generating any attribute\n@@ -2742,8 +2741,10 @@ static inline void\n bit_size_attribute (decl)\n     register tree decl;\n {\n-  assert (TREE_CODE (decl) == FIELD_DECL);\t/* Must be a field.  */\n-  assert (DECL_BIT_FIELD_TYPE (decl));\t\t/* Must be a bit field.\t */\n+  /* Must be a field and a bit field.  */\n+  if (TREE_CODE (decl) != FIELD_DECL\n+      || ! DECL_BIT_FIELD_TYPE (decl))\n+    abort ();\n \n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_bit_size);\n   ASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n@@ -3272,7 +3273,8 @@ output_inlined_enumeration_type_die (arg)\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_enumeration_type);\n   sibling_attribute ();\n-  assert (TREE_ASM_WRITTEN (type));\n+  if (!TREE_ASM_WRITTEN (type))\n+    abort ();\n   abstract_origin_attribute (type);\n }\n \n@@ -3286,7 +3288,8 @@ output_inlined_structure_type_die (arg)\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_structure_type);\n   sibling_attribute ();\n-  assert (TREE_ASM_WRITTEN (type));\n+  if (!TREE_ASM_WRITTEN (type))\n+    abort ();\n   abstract_origin_attribute (type);\n }\n \n@@ -3300,7 +3303,8 @@ output_inlined_union_type_die (arg)\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_union_type);\n   sibling_attribute ();\n-  assert (TREE_ASM_WRITTEN (type));\n+  if (!TREE_ASM_WRITTEN (type))\n+    abort ();\n   abstract_origin_attribute (type);\n }\n \n@@ -4436,9 +4440,11 @@ output_tagged_type_instantiation (type)\n      sure that we have the main variant (i.e. the unqualified version) of\n      this type now.  */\n \n-  assert (type == type_main_variant (type));\n+  if (type != type_main_variant (type))\n+    abort ();\n \n-  assert (TREE_ASM_WRITTEN (type));\n+  if (!TREE_ASM_WRITTEN (type))\n+    abort ();\n \n   switch (TREE_CODE (type))\n     {\n@@ -5179,7 +5185,8 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n \n   /* The above call should have totally emptied the pending_types_list.  */\n \n-  assert (pending_types == 0);\n+  if (pending_types != 0)\n+    abort ();\n \n   ASM_OUTPUT_POP_SECTION (asm_out_file);\n "}, {"sha": "e98130e0300410c03e0738dbfe882ad486fdf9af", "filename": "gcc/except.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a88cbd1064a982e90863182d99e0a48f6973d73/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a88cbd1064a982e90863182d99e0a48f6973d73/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=3a88cbd1064a982e90863182d99e0a48f6973d73", "patch": "@@ -404,7 +404,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"output.h\"\n-#include \"assert.h\"\n \n /* One to use setjmp/longjmp method of generating code for exception\n    handling.  */\n@@ -1959,7 +1958,8 @@ void\n save_eh_status (p)\n      struct function *p;\n {\n-  assert (p != NULL);\n+  if (p == NULL)\n+    abort ();\n \n   p->ehstack = ehstack;\n   p->ehqueue = ehqueue;\n@@ -1981,7 +1981,8 @@ void\n restore_eh_status (p)\n      struct function *p;\n {\n-  assert (p != NULL);\n+  if (p == NULL)\n+    abort ();\n \n   protect_list = p->protect_list;\n   caught_return_label_stack = p->caught_return_label_stack;\n@@ -2046,11 +2047,12 @@ scan_region (insn, n, delete_outer)\n   /* Assume we can delete the region.  */\n   int delete = 1;\n \n-  assert (insn != NULL_RTX\n-\t  && GET_CODE (insn) == NOTE\n-\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG\n-\t  && NOTE_BLOCK_NUMBER (insn) == n\n-\t  && delete_outer != NULL);\n+  if (insn == NULL_RTX\n+      || GET_CODE (insn) != NOTE\n+      || NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_BEG\n+      || NOTE_BLOCK_NUMBER (insn) != n\n+      || delete_outer == NULL)\n+    abort ();\n \n   insn = NEXT_INSN (insn);\n "}]}