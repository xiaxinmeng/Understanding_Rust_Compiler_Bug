{"sha": "a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdmNmJjOGM3NDg4NjIyNTdiOWI2ZTIyMDM0ZmQ0YWUwZmZkNGMzOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2007-09-23T02:36:34Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2007-09-23T02:36:34Z"}, "message": "re PR c++/19407 (vector keyword in typedef inside template struct ignored)\n\n        PR c++/19407\n        * cp/cp-tree.h (ATTR_IS_DEPENDENT): New macro.\n        (MAYBE_TAGGED_TYPE_P): Remove.\n        * cp/pt.c (apply_late_template_attributes): Check ATTR_IS_DEPENDENT\n        instead of calling is_late_template_attribute again.\n        (tsubst_decl) [TYPE_DECL]: Just check if the name is the tag.\n        (tsubst): A typedef is a TYPE_NAME != TYPE_MAIN_DECL.\n        Don't crash on typedefs from non-template classes.\n        * cp/decl2.c (grokfield): Don't sorry about attrs on template parms.\n        (is_late_template_attribute): All attributes applied to template\n        parms or typename types are dependent.  Static, take decl.\n        (splice_template_attributes): Pass decl through.\n        (save_template_attributes): Likewise.\n        * attribs.c (lookup_attribute_spec): Split out...\n        (decl_attributes): From here.\n        * tree.h: Declare it.\n\nFrom-SVN: r128681", "tree": {"sha": "17a3573bc82b532229f930f45caf02beb84bdead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17a3573bc82b532229f930f45caf02beb84bdead"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e74fb44cdb05432d3eb116dc80e1b0d4f86889d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e74fb44cdb05432d3eb116dc80e1b0d4f86889d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e74fb44cdb05432d3eb116dc80e1b0d4f86889d"}], "stats": {"total": 192, "additions": 136, "deletions": 56}, "files": [{"sha": "2de9c65b9ad4c7530459395b01b3c03b6733b0cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "patch": "@@ -1,3 +1,10 @@\n+2007-09-22  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/19407\n+\t* attribs.c (lookup_attribute_spec): Split out...\n+\t(decl_attributes): From here.\n+\t* tree.h: Declare it.\n+\n 2007-09-22  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* doc/sourcebuild.texi: Document dg-add-options mips16_attribute."}, {"sha": "31b92cad508bff2c875fa3b9e7e6c2a7aec5d49f", "filename": "gcc/attribs.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "patch": "@@ -195,6 +195,20 @@ init_attributes (void)\n       }\n   attributes_initialized = true;\n }\n+\n+/* Return the spec for the attribute named NAME.  */\n+\n+const struct attribute_spec *\n+lookup_attribute_spec (tree name)\n+{\n+  struct substring attr;\n+\n+  attr.str = IDENTIFIER_POINTER (name);\n+  attr.length = IDENTIFIER_LENGTH (name);\n+  extract_attribute_substring (&attr);\n+  return htab_find_with_hash (attribute_hash, &attr,\n+\t\t\t      substring_hash (attr.str, attr.length));\n+}\n \f\n /* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n    which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n@@ -221,16 +235,9 @@ decl_attributes (tree *node, tree attributes, int flags)\n       tree name = TREE_PURPOSE (a);\n       tree args = TREE_VALUE (a);\n       tree *anode = node;\n-      const struct attribute_spec *spec = NULL;\n+      const struct attribute_spec *spec = lookup_attribute_spec (name);\n       bool no_add_attrs = 0;\n       tree fn_ptr_tmp = NULL_TREE;\n-      struct substring attr;\n-\n-      attr.str = IDENTIFIER_POINTER (name);\n-      attr.length = IDENTIFIER_LENGTH (name);\n-      extract_attribute_substring (&attr);\n-      spec = htab_find_with_hash (attribute_hash, &attr,\n-\t\t\t\t  substring_hash (attr.str, attr.length));\n \n       if (spec == NULL)\n \t{"}, {"sha": "4c4e5847d3a7476435893dba6ef5abc5f9d717e5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "patch": "@@ -1,3 +1,19 @@\n+2007-09-22  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/19407\n+\t* cp-tree.h (ATTR_IS_DEPENDENT): New macro.\n+\t(MAYBE_TAGGED_TYPE_P): Remove.\n+\t* pt.c (apply_late_template_attributes): Check ATTR_IS_DEPENDENT\n+\tinstead of calling is_late_template_attribute again.\n+\t(tsubst_decl) [TYPE_DECL]: Just check if the name is the tag.\n+\t(tsubst): A typedef is a TYPE_NAME != TYPE_MAIN_DECL.\n+\tDon't crash on typedefs from non-template classes.\n+\t* decl2.c (grokfield): Don't sorry about attrs on template parms.\n+\t(is_late_template_attribute): All attributes applied to template\n+\tparms or typename types are dependent.  Static.\n+\t(splice_template_attributes): Pass decl through.\n+\t(save_template_attributes): Likewise.\n+\n 2007-09-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/33496"}, {"sha": "fbe1bcc01706b908c673fc5391b3cf96c97f915e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "patch": "@@ -58,6 +58,7 @@ struct diagnostic_context;\n       TARGET_EXPR_IMPLICIT_P (in TARGET_EXPR)\n       TEMPLATE_PARM_PARAMETER_PACK (in TEMPLATE_PARM_INDEX)\n       TYPE_REF_IS_RVALUE (in REFERENCE_TYPE)\n+      ATTR_IS_DEPENDENT (in the TREE_LIST for an attribute)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -988,10 +989,6 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n   ((T) == RECORD_TYPE || (T) == UNION_TYPE)\n #define TAGGED_TYPE_P(T) \\\n   (CLASS_TYPE_P (T) || TREE_CODE (T) == ENUMERAL_TYPE)\n-/* A tagged type or a dependent type that might be a tagged type when\n-   instantiated.  Like IS_AGGR_TYPE, but include enums as well.  */\n-#define MAYBE_TAGGED_TYPE_P(T) \\\n-  (IS_AGGR_TYPE(T) || TREE_CODE (T) == ENUMERAL_TYPE)\n #define IS_OVERLOAD_TYPE(T) TAGGED_TYPE_P (T)\n \n /* True if this a \"Java\" type, defined in 'extern \"Java\"'.  */\n@@ -2134,6 +2131,10 @@ struct lang_decl GTY(())\n    directives  */\n #define TREE_INDIRECT_USING(NODE) (TREE_LIST_CHECK (NODE)->base.lang_flag_0)\n \n+/* In a TREE_LIST in an attribute list, indicates that the attribute\n+   must be applied at instantiation time.  */\n+#define ATTR_IS_DEPENDENT(NODE) (TREE_LIST_CHECK (NODE)->base.lang_flag_0)\n+\n extern tree decl_shadowed_for_var_lookup (tree);\n extern void decl_shadowed_for_var_insert (tree, tree);\n \n@@ -4280,7 +4281,6 @@ extern tree grokfield (const cp_declarator *, cp_decl_specifier_seq *,\n \t\t       tree, bool, tree, tree);\n extern tree grokbitfield (const cp_declarator *, cp_decl_specifier_seq *,\n \t\t\t  tree);\n-extern bool is_late_template_attribute\t\t(tree);\n extern void cplus_decl_attributes\t\t(tree *, tree, int);\n extern void finish_anon_union\t\t\t(tree);\n extern void cp_write_global_declarations\t(void);"}, {"sha": "d58194265dbb3fdab67a8c4d74df62684011304f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "patch": "@@ -800,16 +800,7 @@ grokfield (const cp_declarator *declarator,\n \tvalue = push_template_decl (value);\n \n       if (attrlist)\n-\t{\n-\t  /* Avoid storing attributes in template parameters:\n-\t     tsubst is not ready to handle them.  */\n-\t  tree type = TREE_TYPE (value);\n-\t  if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n-\t      || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n-\t    sorry (\"applying attributes to template parameters is not implemented\");\n-\t  else\n-\t    cplus_decl_attributes (&value, attrlist, 0);\n-\t}\n+\tcplus_decl_attributes (&value, attrlist, 0);\n \n       return value;\n     }\n@@ -988,24 +979,43 @@ grokbitfield (const cp_declarator *declarator,\n /* Returns true iff ATTR is an attribute which needs to be applied at\n    instantiation time rather than template definition time.  */\n \n-bool\n-is_late_template_attribute (tree attr)\n+static bool\n+is_late_template_attribute (tree attr, tree decl)\n {\n   tree name = TREE_PURPOSE (attr);\n   tree args = TREE_VALUE (attr);\n+  const struct attribute_spec *spec = lookup_attribute_spec (name);\n+\n   if (is_attribute_p (\"aligned\", name)\n       && args\n       && value_dependent_expression_p (TREE_VALUE (args)))\n+    /* Can't apply this until we know the desired alignment.  */\n     return true;\n+  else if (TREE_CODE (decl) == TYPE_DECL || spec->type_required)\n+    {\n+      tree type = TYPE_P (decl) ? decl : TREE_TYPE (decl);\n+\n+      /* We can't apply any attributes to a completely unknown type until\n+\t instantiation time.  */\n+      enum tree_code code = TREE_CODE (type);\n+      if (code == TEMPLATE_TYPE_PARM\n+\t  || code == BOUND_TEMPLATE_TEMPLATE_PARM\n+\t  || code == TYPENAME_TYPE)\n+\treturn true;\n+      else\n+\treturn false;\n+    }\n   else\n     return false;\n }\n \n /* ATTR_P is a list of attributes.  Remove any attributes which need to be\n-   applied at instantiation time and return them.  */\n+   applied at instantiation time and return them.  If IS_DEPENDENT is true,\n+   the declaration itself is dependent, so all attributes should be applied\n+   at instantiation time.  */\n \n static tree\n-splice_template_attributes (tree *attr_p)\n+splice_template_attributes (tree *attr_p, tree decl)\n {\n   tree *p = attr_p;\n   tree late_attrs = NULL_TREE;\n@@ -1016,8 +1026,9 @@ splice_template_attributes (tree *attr_p)\n \n   for (; *p; )\n     {\n-      if (is_late_template_attribute (*p))\n+      if (is_late_template_attribute (*p, decl))\n \t{\n+\t  ATTR_IS_DEPENDENT (*p) = 1;\n \t  *q = *p;\n \t  *p = TREE_CHAIN (*p);\n \t  q = &TREE_CHAIN (*q);\n@@ -1036,7 +1047,7 @@ splice_template_attributes (tree *attr_p)\n static void\n save_template_attributes (tree *attr_p, tree *decl_p)\n {\n-  tree late_attrs = splice_template_attributes (attr_p);\n+  tree late_attrs = splice_template_attributes (attr_p, *decl_p);\n   tree *q;\n \n   if (!late_attrs)"}, {"sha": "c9ec37034a58c1681c5c38e303b9ced0ebca3aa5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "patch": "@@ -6494,20 +6494,14 @@ apply_late_template_attributes (tree *decl_p, tree attributes, int attr_flags,\n   else\n     TYPE_ATTRIBUTES (*decl_p) = attributes;\n \n-  /* Set processing_template_decl so we can check for dependent\n-     expressions.  */\n-  ++processing_template_decl;\n-\n   for (t = attributes; t; t = TREE_CHAIN (t))\n-    if (is_late_template_attribute (t))\n+    if (ATTR_IS_DEPENDENT (t))\n       late_attrs = tree_cons\n \t(TREE_PURPOSE (t),\n \t tsubst_expr (TREE_VALUE (t), args, complain, in_decl,\n \t\t      /*integral_constant_expression_p=*/false),\n \t late_attrs);\n \n-  --processing_template_decl;\n-\n   cplus_decl_attributes (decl_p, late_attrs, attr_flags);\n }\n \n@@ -8085,20 +8079,16 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tbool local_p;\n \n \tif (TREE_CODE (t) == TYPE_DECL\n-\t    && MAYBE_TAGGED_TYPE_P (TREE_TYPE (t)))\n+\t    && t == TYPE_MAIN_DECL (TREE_TYPE (t)))\n \t  {\n+\t    /* If this is the canonical decl, we don't have to\n+\t       mess with instantiations, and often we can't (for\n+\t       typename, template type parms and such).  Note that\n+\t       TYPE_NAME is not correct for the above test if\n+\t       we've copied the type for a typedef.  */\n \t    type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n-\t    if (TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM\n-\t\t|| t == TYPE_MAIN_DECL (TREE_TYPE (t)))\n-\t      {\n-\t\t/* If this is the canonical decl, we don't have to\n-\t\t   mess with instantiations, and often we can't (for\n-\t\t   typename, template type parms and such).  Note that\n-\t\t   TYPE_NAME is not correct for the above test if\n-\t\t   we've copied the type for a typedef.  */\n-\t\tr = TYPE_NAME (type);\n-\t\tbreak;\n-\t      }\n+\t    r = TYPE_NAME (type);\n+\t    break;\n \t  }\n \n \t/* Check to see if we already have the specialization we\n@@ -8555,16 +8545,15 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   gcc_assert (type != unknown_type_node);\n \n   /* Reuse typedefs.  We need to do this to handle dependent attributes,\n-     specifically attribute aligned.  */\n+     such as attribute aligned.  */\n   if (TYPE_P (t)\n       && TYPE_NAME (t)\n-      && !MAYBE_TAGGED_TYPE_P (t)\n-      && TREE_CODE (t) != TEMPLATE_TEMPLATE_PARM\n-      && TREE_CODE (t) != UNBOUND_CLASS_TEMPLATE)\n+      && TYPE_NAME (t) != TYPE_MAIN_DECL (t))\n     {\n       tree decl = TYPE_NAME (t);\n       \n-      if (DECL_CLASS_SCOPE_P (decl))\n+      if (DECL_CLASS_SCOPE_P (decl)\n+\t  && CLASSTYPE_TEMPLATE_INFO (DECL_CONTEXT (decl)))\n \t{\n \t  tree tmpl = most_general_template (DECL_TI_TEMPLATE (decl));\n \t  tree gen_args = tsubst (DECL_TI_ARGS (decl), args, complain, in_decl);"}, {"sha": "25b27f307b5c12c9209aa178f91b468928111d85", "filename": "gcc/testsuite/g++.dg/ext/attrib20.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattrib20.C?ref=a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "patch": "@@ -7,16 +7,16 @@ template <typename T>\n struct BVector\n {\n   typedef T T2;\n-  typedef T value_type __attribute__ ((aligned(8)));    // { dg-bogus \"attribute\" \"attribute\" { xfail *-*-* } }\n-  typedef T2 value_type2 __attribute__ ((aligned(8)));  // { dg-bogus \"attribute\" \"attribute\" { xfail *-*-* } }\n+  typedef T value_type __attribute__ ((aligned(8)));    // { dg-bogus \"attribute\" \"attribute\" }\n+  typedef T2 value_type2 __attribute__ ((aligned(8)));  // { dg-bogus \"attribute\" \"attribute\" }\n   value_type v;\n };\n BVector<int> m;\n \n template <template <class> class T>\n struct BV2\n {\n-  typedef T<float> value_type __attribute__((aligned(8))); // { dg-bogus \"attribute\" \"attribute\" { xfail *-*-* } }\n+  typedef T<float> value_type __attribute__((aligned(8))); // { dg-bogus \"attribute\" \"attribute\" }\n   value_type v;\n };\n BV2<BVector> m2;"}, {"sha": "30138d44aab284730d51060e88cf7a9a8750990c", "filename": "gcc/testsuite/g++.dg/ext/tmplattr5.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftmplattr5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftmplattr5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftmplattr5.C?ref=a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "patch": "@@ -0,0 +1,33 @@\n+// PR c++/19407\n+// { dg-do run }\n+\n+typedef float global_vector_type __attribute__((vector_size(16)));\n+\n+template <class T> struct A\n+{\n+  typedef T type;\n+};\n+\n+template < typename Val > struct S\n+{\n+  typedef typename A<Val>::type vector_type __attribute__((vector_size(16)));\n+  typedef Val vector_type2 __attribute__((vector_size(16)));\n+  int pr_size() { return sizeof(vector_type); }\n+  int pr_size2() { return sizeof(vector_type2); }\n+};\n+\n+int main()\n+{\n+  if (sizeof (S<float>::vector_type) != sizeof (global_vector_type))\n+    return 1;\n+  if (sizeof (S<float>::vector_type2) != sizeof (global_vector_type))\n+    return 2;\n+\n+  S<float> x;\n+  if (x.pr_size() != sizeof (global_vector_type))\n+    return 3;\n+  if (x.pr_size2() != sizeof (global_vector_type))\n+    return 4;\n+  \n+  return 0;\n+}"}, {"sha": "2d39c90b9ee2221af94905c4b025cd43f0237a3a", "filename": "gcc/testsuite/g++.dg/template/typedef7.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypedef7.C?ref=a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "patch": "@@ -0,0 +1,15 @@\n+// An intermediate version of the fix for c++/19407 broke this example.\n+\n+struct A\n+{\n+  typedef struct { int i; } S;\n+};\n+\n+template <class T>\n+struct B: public A\n+{\n+  template <class U>\n+  static S f ();\n+};\n+\n+template struct B<int>;"}, {"sha": "e893dea098aad723e8dfea6be4f8cb6728c3c270", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a7f6bc8c748862257b9b6e22034fd4ae0ffd4c38", "patch": "@@ -5002,6 +5002,8 @@ extern bool must_pass_in_stack_var_size_or_pad (enum machine_mode, const_tree);\n \n /* In attribs.c.  */\n \n+extern const struct attribute_spec *lookup_attribute_spec (tree);\n+\n /* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n    which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n    it should be modified in place; if a TYPE, a copy should be created"}]}