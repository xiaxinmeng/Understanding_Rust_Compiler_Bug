{"sha": "c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzliYWNmZGI4NGVkZDRjYThiYjI5ZThhOWNlODAxY2I3ODAzNTBjZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-11T12:45:05Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-11T12:45:05Z"}, "message": "* flow.c: Fix formatting.\n\nFrom-SVN: r35631", "tree": {"sha": "1559b0446c77cc25323a429f7ff09ca5caaed2d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1559b0446c77cc25323a429f7ff09ca5caaed2d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce/comments", "author": null, "committer": null, "parents": [{"sha": "b333f246e4178158a05af6ff3079a1ab4abdc8f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b333f246e4178158a05af6ff3079a1ab4abdc8f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b333f246e4178158a05af6ff3079a1ab4abdc8f4"}], "stats": {"total": 752, "additions": 382, "deletions": 370}, "files": [{"sha": "42d7dba182761a0386b7e524bc36cafc88e094d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce", "patch": "@@ -1,3 +1,7 @@\n+2000-08-11  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* flow.c: Fix formatting.\n+\n 2000-08-11  Richard Henderson  <rth@cygnus.com>\n \n \t* reload.c (push_secondary_reload): When invoking a reload_{in,out}"}, {"sha": "6c3b18d61a4d856f777f61742b8b7c25c7e9ddb4", "filename": "gcc/flow.c", "status": "modified", "additions": 378, "deletions": 370, "changes": 748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=c9bacfdb84edd4ca8bb29e8a9ce801cb780350ce", "patch": "@@ -1,5 +1,5 @@\n /* Data flow analysis for GNU compiler.\n-   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, \n+   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n    1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* This file contains the data flow analysis pass of the compiler.  It\n    computes data flow information which tells combine_instructions\n    which insns to consider combining and controls register allocation.\n@@ -57,7 +56,7 @@ Boston, MA 02111-1307, USA.  */\n    pseudo register.  The bit is 1 if the register is live at the\n    beginning of the basic block.\n \n-   Two types of elements can be added to an insn's REG_NOTES.  \n+   Two types of elements can be added to an insn's REG_NOTES.\n    A REG_DEAD note is added to an insn's REG_NOTES for any register\n    that meets both of two conditions:  The value in the register is not\n    needed in subsequent insns and the insn does not replace the value in\n@@ -110,7 +109,7 @@ Boston, MA 02111-1307, USA.  */\n    life_analysis sets current_function_sp_is_unchanging if the function\n    doesn't modify the stack pointer.  */\n \n-/* TODO: \n+/* TODO:\n \n    Split out from life_analysis:\n \t- local property discovery (bb->local_live, bb->local_set)\n@@ -144,7 +143,6 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n@@ -259,7 +257,7 @@ static HARD_REG_SET elim_reg_set;\n varray_type basic_block_for_insn;\n \n /* The labels mentioned in non-jump rtl.  Valid during find_basic_blocks.  */\n-/* ??? Should probably be using LABEL_NUSES instead.  It would take a \n+/* ??? Should probably be using LABEL_NUSES instead.  It would take a\n    bit of surgery to be able to use or co-opt the routines in jump.  */\n \n static rtx label_value_list;\n@@ -316,13 +314,13 @@ struct propagate_block_info\n   int flags;\n };\n \n-/* Store the data structures necessary for depth-first search. */\n+/* Store the data structures necessary for depth-first search.  */\n struct depth_first_search_dsS {\n   /* stack for backtracking during the algorithm */\n   basic_block *stack;\n \n   /* number of edges in the stack.  That is, positions 0, ..., sp-1\n-     have edges. */\n+     have edges.  */\n   unsigned int sp;\n \n   /* record of basic blocks already seen by depth-first search */\n@@ -453,7 +451,7 @@ find_basic_blocks (f, nregs, file)\n \n       clear_edges ();\n \n-      /* Clear bb->aux on all extant basic blocks.  We'll use this as a \n+      /* Clear bb->aux on all extant basic blocks.  We'll use this as a\n \t tag for reuse during create_basic_block, just in case some pass\n \t copies around basic block notes improperly.  */\n       for (i = 0; i < n_basic_blocks; ++i)\n@@ -468,14 +466,14 @@ find_basic_blocks (f, nregs, file)\n      by find_basic_blocks_1, since we want to keep the structure pointers\n      stable across calls to find_basic_blocks.  */\n   /* ??? This whole issue would be much simpler if we called find_basic_blocks\n-     exactly once, and thereafter we don't have a single long chain of \n+     exactly once, and thereafter we don't have a single long chain of\n      instructions at all until close to the end of compilation when we\n      actually lay them out.  */\n \n   VARRAY_BB_INIT (basic_block_info, n_basic_blocks, \"basic_block_info\");\n \n   find_basic_blocks_1 (f);\n-  \n+\n   /* Record the block to which an insn belongs.  */\n   /* ??? This should be done another way, by which (perhaps) a label is\n      tagged directly with the basic block that it starts.  It is used for\n@@ -507,7 +505,7 @@ find_basic_blocks (f, nregs, file)\n \n /* Count the basic blocks of the function.  */\n \n-static int \n+static int\n count_basic_blocks (f)\n      rtx f;\n {\n@@ -582,14 +580,14 @@ find_label_refs (f, lvl)\n \trtx note;\n \n \t/* Make a list of all labels referred to other than by jumps\n-\t   (which just don't have the REG_LABEL notes). \n+\t   (which just don't have the REG_LABEL notes).\n \n \t   Make a special exception for labels followed by an ADDR*VEC,\n-\t   as this would be a part of the tablejump setup code. \n+\t   as this would be a part of the tablejump setup code.\n \n \t   Make a special exception for the eh_return_stub_label, which\n \t   we know isn't part of any otherwise visible control flow.  */\n-\t     \n+\n \tfor (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t  if (REG_NOTE_KIND (note) == REG_LABEL)\n \t    {\n@@ -629,7 +627,7 @@ find_basic_blocks_1 (f)\n   rtx trll = NULL_RTX;\n   rtx head = NULL_RTX;\n   rtx end = NULL_RTX;\n-  \n+\n   /* We process the instructions in a slightly different way than we did\n      previously.  This is so that we see a NOTE_BASIC_BLOCK after we have\n      closed out the previous block, so that it gets attached at the proper\n@@ -659,7 +657,7 @@ find_basic_blocks_1 (f)\n \t\tfree_INSN_LIST_node (t);\n \t      }\n \n-\t    /* Look for basic block notes with which to keep the \n+\t    /* Look for basic block notes with which to keep the\n \t       basic_block_info pointers stable.  Unthread the note now;\n \t       we'll put it back at the right place in create_basic_block.\n \t       Or not at all if we've already found a note in this block.  */\n@@ -674,7 +672,7 @@ find_basic_blocks_1 (f)\n \t  }\n \n \tcase CODE_LABEL:\n-\t  /* A basic block starts at a label.  If we've closed one off due \n+\t  /* A basic block starts at a label.  If we've closed one off due\n \t     to a barrier or some such, no need to do it again.  */\n \t  if (head != NULL_RTX)\n \t    {\n@@ -702,14 +700,14 @@ find_basic_blocks_1 (f)\n \t    head = insn;\n \t  else\n \t    {\n-\t      /* ??? Make a special check for table jumps.  The way this \n+\t      /* ??? Make a special check for table jumps.  The way this\n \t\t happens is truly and amazingly gross.  We are about to\n \t\t create a basic block that contains just a code label and\n \t\t an addr*vec jump insn.  Worse, an addr_diff_vec creates\n \t\t its own natural loop.\n \n \t\t Prevent this bit of brain damage, pasting things together\n-\t\t correctly in make_edges.  \n+\t\t correctly in make_edges.\n \n \t\t The correct solution involves emitting the table directly\n \t\t on the tablejump instruction as a note, or JUMP_LABEL.  */\n@@ -786,8 +784,8 @@ find_basic_blocks_1 (f)\n \t\tbb_note = NULL_RTX;\n \t\tbreak;\n \t      }\n-\t    }\n-\t  /* FALLTHRU */\n+\t  }\n+\t  /* Fall through.  */\n \n \tdefault:\n \t  if (GET_RTX_CLASS (code) == 'i')\n@@ -804,14 +802,14 @@ find_basic_blocks_1 (f)\n \t  rtx note;\n \n \t  /* Make a list of all labels referred to other than by jumps\n-\t     (which just don't have the REG_LABEL notes). \n+\t     (which just don't have the REG_LABEL notes).\n \n \t     Make a special exception for labels followed by an ADDR*VEC,\n-\t     as this would be a part of the tablejump setup code. \n+\t     as this would be a part of the tablejump setup code.\n \n \t     Make a special exception for the eh_return_stub_label, which\n \t     we know isn't part of any otherwise visible control flow.  */\n-\t     \n+\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_LABEL)\n \t      {\n@@ -970,7 +968,7 @@ clear_edges ()\n     {\n       basic_block bb = BASIC_BLOCK (i);\n \n-      for (e = bb->succ; e ; e = n)\n+      for (e = bb->succ; e; e = n)\n \t{\n \t  n = e->succ_next;\n \t  free (e);\n@@ -980,7 +978,7 @@ clear_edges ()\n       bb->pred = 0;\n     }\n \n-  for (e = ENTRY_BLOCK_PTR->succ; e ; e = n)\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = n)\n     {\n       n = e->succ_next;\n       free (e);\n@@ -997,7 +995,7 @@ clear_edges ()\n    NONLOCAL_LABEL_LIST is a list of non-local labels in the function.  Blocks\n    that are otherwise unreachable may be reachable with a non-local goto.\n \n-   BB_EH_END is an array indexed by basic block number in which we record \n+   BB_EH_END is an array indexed by basic block number in which we record\n    the list of exception regions active at the end of the basic block.  */\n \n static void\n@@ -1085,7 +1083,7 @@ make_edges (label_value_list)\n \n \t      for (x = label_value_list; x; x = XEXP (x, 1))\n \t\tmake_label_edge (edge_cache, bb, XEXP (x, 0), EDGE_ABNORMAL);\n-\t      \n+\n \t      for (x = forced_labels; x; x = XEXP (x, 1))\n \t\tmake_label_edge (edge_cache, bb, XEXP (x, 0), EDGE_ABNORMAL);\n \t    }\n@@ -1103,7 +1101,7 @@ make_edges (label_value_list)\n \t    }\n \t}\n \n-      /* If this is a sibling call insn, then this is in effect a \n+      /* If this is a sibling call insn, then this is in effect a\n \t combined call and return, and so we need an edge to the\n \t exit block.  No need to worry about EH edges, since we\n \t wouldn't have created the sibling call in the first place.  */\n@@ -1159,7 +1157,7 @@ make_edges (label_value_list)\n \t\t than 0 is guaranteed not to perform a non-local goto.  */\n \t      rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n \t      if (!note || INTVAL (XEXP (note, 0)) >=  0)\n-\t\tfor (x = nonlocal_goto_handler_labels; x ; x = XEXP (x, 1))\n+\t\tfor (x = nonlocal_goto_handler_labels; x; x = XEXP (x, 1))\n \t\t  make_label_edge (edge_cache, bb, XEXP (x, 0),\n \t\t\t\t   EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n \t    }\n@@ -1212,7 +1210,7 @@ make_edge (edge_cache, src, dst, flags)\n \n   /* Make sure we don't add duplicate edges.  */\n   if (! use_edge_cache || TEST_BIT (edge_cache[src->index], dst->index))\n-    for (e = src->succ; e ; e = e->succ_next)\n+    for (e = src->succ; e; e = e->succ_next)\n       if (e->dest == dst)\n \t{\n \t  e->flags |= flags;\n@@ -1343,7 +1341,7 @@ record_active_eh_regions (f)\n   int i = 0;\n   basic_block bb = BASIC_BLOCK (0);\n \n-  for (insn = f; insn ; insn = NEXT_INSN (insn))\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n       if (bb->head == insn)\n \tbb->eh_beg = (eh_list ? NOTE_EH_HANDLER (XEXP (eh_list, 0)) : -1);\n@@ -1393,7 +1391,7 @@ mark_critical_edges ()\n       /* (1) Critical edges must have a source with multiple successors.  */\n       if (bb->succ && bb->succ->succ_next)\n \t{\n-\t  for (e = bb->succ; e ; e = e->succ_next)\n+\t  for (e = bb->succ; e; e = e->succ_next)\n \t    {\n \t      /* (2) Critical edges must have a destination with multiple\n \t\t predecessors.  Note that we know there is at least one\n@@ -1406,7 +1404,7 @@ mark_critical_edges ()\n \t}\n       else\n \t{\n-\t  for (e = bb->succ; e ; e = e->succ_next)\n+\t  for (e = bb->succ; e; e = e->succ_next)\n \t    e->flags &= ~EDGE_CRITICAL;\n \t}\n \n@@ -1417,10 +1415,10 @@ mark_critical_edges ()\n }\n \f\n /* Split a (typically critical) edge.  Return the new block.\n-   Abort on abnormal edges. \n+   Abort on abnormal edges.\n \n    ??? The code generally expects to be called on critical edges.\n-   The case of a block ending in an unconditional jump to a \n+   The case of a block ending in an unconditional jump to a\n    block with multiple predecessors is not handled optimally.  */\n \n basic_block\n@@ -1431,7 +1429,7 @@ split_edge (edge_in)\n   edge edge_out;\n   rtx bb_note;\n   int i, j;\n- \n+\n   /* Abnormal edges cannot be split.  */\n   if ((edge_in->flags & EDGE_ABNORMAL) != 0)\n     abort ();\n@@ -1484,7 +1482,7 @@ split_edge (edge_in)\n \n   /* Tricky case -- if there existed a fallthru into the successor\n      (and we're not it) we must add a new unconditional jump around\n-     the new block we're actually interested in. \n+     the new block we're actually interested in.\n \n      Further, if that edge is critical, this means a second new basic\n      block must be created to hold it.  In order to simplify correct\n@@ -1493,7 +1491,7 @@ split_edge (edge_in)\n   if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n     {\n       edge e;\n-      for (e = edge_out->pred_next; e ; e = e->pred_next)\n+      for (e = edge_out->pred_next; e; e = e->pred_next)\n \tif (e->flags & EDGE_FALLTHRU)\n \t  break;\n \n@@ -1529,7 +1527,7 @@ split_edge (edge_in)\n \t  /* ... let jump know that label is in use, ...  */\n \t  JUMP_LABEL (pos) = old_succ->head;\n \t  ++LABEL_NUSES (old_succ->head);\n-\t  \n+\n \t  /* ... and clear fallthru on the outgoing edge.  */\n \t  e->flags &= ~EDGE_FALLTHRU;\n \n@@ -1552,11 +1550,10 @@ split_edge (edge_in)\n   BASIC_BLOCK (i) = bb;\n   bb->index = i;\n \n-  /* Create the basic block note. \n+  /* Create the basic block note.\n \n      Where we place the note can have a noticable impact on the generated\n-     code.  Consider this cfg: \n-\t\n+     code.  Consider this cfg:\n \n \t\t        E\n \t\t\t|\n@@ -1612,7 +1609,7 @@ split_edge (edge_in)\n \t  for (j = GET_NUM_ELEM (vec) - 1; j >= 0; --j)\n \t    if (XEXP (RTVEC_ELT (vec, j), 0) == old_label)\n \t      {\n-\t        RTVEC_ELT (vec, j) = gen_rtx_LABEL_REF (VOIDmode, new_label);\n+\t\tRTVEC_ELT (vec, j) = gen_rtx_LABEL_REF (VOIDmode, new_label);\n \t\t--LABEL_NUSES (old_label);\n \t\t++LABEL_NUSES (new_label);\n \t      }\n@@ -1624,7 +1621,7 @@ split_edge (edge_in)\n \t      && GET_CODE (XEXP (SET_SRC (tmp), 2)) == LABEL_REF\n \t      && XEXP (XEXP (SET_SRC (tmp), 2), 0) == old_label)\n \t    {\n-\t      XEXP (SET_SRC (tmp), 2) = gen_rtx_LABEL_REF (VOIDmode, \n+\t      XEXP (SET_SRC (tmp), 2) = gen_rtx_LABEL_REF (VOIDmode,\n \t\t\t\t\t\t\t   new_label);\n \t      --LABEL_NUSES (old_label);\n \t      ++LABEL_NUSES (new_label);\n@@ -1677,7 +1674,7 @@ insert_insn_on_edge (pattern, e)\n   emit_insn (pattern);\n \n   e->insns = get_insns ();\n-  end_sequence();\n+  end_sequence ();\n }\n \n /* Update the CFG for the instructions queued on edge E.  */\n@@ -1712,7 +1709,7 @@ commit_one_edge_insertion (e)\n       else\n \tafter = PREV_INSN (tmp);\n     }\n-  \n+\n   /* If the source has one successor and the edge is not abnormal,\n      insert there.  Except for the entry block.  */\n   else if ((e->flags & EDGE_ABNORMAL) == 0\n@@ -1722,7 +1719,7 @@ commit_one_edge_insertion (e)\n       bb = e->src;\n       /* It is possible to have a non-simple jump here.  Consider a target\n \t where some forms of unconditional jumps clobber a register.  This\n-\t happens on the fr30 for example. \n+\t happens on the fr30 for example.\n \n \t We know this block has a single successor, so we can just emit\n \t the queued insns before the jump.  */\n@@ -1774,7 +1771,7 @@ commit_one_edge_insertion (e)\n \n   if (returnjump_p (last))\n     {\n-      /* ??? Remove all outgoing edges from BB and add one for EXIT. \n+      /* ??? Remove all outgoing edges from BB and add one for EXIT.\n          This is not currently a problem because this only happens\n \t for the (single) epilogue, which already has a fallthru edge\n \t to EXIT.  */\n@@ -1807,14 +1804,14 @@ commit_edge_insertions ()\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n- \n+\n   i = -1;\n   bb = ENTRY_BLOCK_PTR;\n   while (1)\n     {\n       edge e, next;\n \n-      for (e = bb->succ; e ; e = next)\n+      for (e = bb->succ; e; e = next)\n \t{\n \t  next = e->succ_next;\n \t  if (e->insns)\n@@ -1849,21 +1846,21 @@ delete_unreachable_blocks ()\n      be only one.  It isn't inconcievable that we might one day directly\n      support Fortran alternate entry points.  */\n \n-  for (e = ENTRY_BLOCK_PTR->succ; e ; e = e->succ_next)\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n     {\n       *tos++ = e->dest;\n \n       /* Mark the block with a handy non-null value.  */\n       e->dest->aux = e;\n     }\n-      \n+\n   /* Iterate: find everything reachable from what we've already seen.  */\n \n   while (tos != worklist)\n     {\n       basic_block b = *--tos;\n \n-      for (e = b->succ; e ; e = e->succ_next)\n+      for (e = b->succ; e; e = e->succ_next)\n \tif (!e->dest->aux)\n \t  {\n \t    *tos++ = e->dest;\n@@ -1872,7 +1869,7 @@ delete_unreachable_blocks ()\n     }\n \n   /* Delete all unreachable basic blocks.  Count down so that we don't\n-     interfere with the block renumbering that happens in flow_delete_block. */\n+     interfere with the block renumbering that happens in flow_delete_block.  */\n \n   deleted_handler = 0;\n \n@@ -1890,7 +1887,7 @@ delete_unreachable_blocks ()\n   tidy_fallthru_edges ();\n \n   /* If we deleted an exception handler, we may have EH region begin/end\n-     blocks to remove as well. */\n+     blocks to remove as well.  */\n   if (deleted_handler)\n     delete_eh_regions ();\n \n@@ -1909,8 +1906,8 @@ delete_eh_regions ()\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (GET_CODE (insn) == NOTE)\n       {\n-\tif ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG) ||\n-\t    (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)) \n+\tif ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n+\t    || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END))\n \t  {\n \t    int num = NOTE_EH_HANDLER (insn);\n \t    /* A NULL handler indicates a region is no longer needed,\n@@ -1993,7 +1990,7 @@ flow_delete_block (b)\n      NOTE_INSN_EH_REGION_END notes.  */\n \n   insn = b->head;\n-  \n+\n   never_reached_warning (insn);\n \n   if (GET_CODE (insn) == CODE_LABEL)\n@@ -2036,12 +2033,12 @@ flow_delete_block (b)\n   /* Selectively delete the entire chain.  */\n   flow_delete_insn_chain (insn, end);\n \n-  /* Remove the edges into and out of this block.  Note that there may \n+  /* Remove the edges into and out of this block.  Note that there may\n      indeed be edges in, if we are removing an unreachable loop.  */\n   {\n     edge e, next, *q;\n \n-    for (e = b->pred; e ; e = next)\n+    for (e = b->pred; e; e = next)\n       {\n \tfor (q = &e->src->succ; *q != e; q = &(*q)->succ_next)\n \t  continue;\n@@ -2050,7 +2047,7 @@ flow_delete_block (b)\n \tn_edges--;\n \tfree (e);\n       }\n-    for (e = b->succ; e ; e = next)\n+    for (e = b->succ; e; e = next)\n       {\n \tfor (q = &e->dest->pred; *q != e; q = &(*q)->pred_next)\n \t  continue;\n@@ -2102,7 +2099,7 @@ flow_delete_insn (insn)\n   PREV_INSN (insn) = NULL_RTX;\n   NEXT_INSN (insn) = NULL_RTX;\n   INSN_DELETED_P (insn) = 1;\n-  \n+\n   if (prev)\n     NEXT_INSN (prev) = next;\n   if (next)\n@@ -2130,7 +2127,7 @@ flow_delete_insn (insn)\n \n /* True if a given label can be deleted.  */\n \n-static int \n+static int\n can_delete_label_p (label)\n      rtx label;\n {\n@@ -2139,20 +2136,20 @@ can_delete_label_p (label)\n   if (LABEL_PRESERVE_P (label))\n     return 0;\n \n-  for (x = forced_labels; x ; x = XEXP (x, 1))\n+  for (x = forced_labels; x; x = XEXP (x, 1))\n     if (label == XEXP (x, 0))\n       return 0;\n-  for (x = label_value_list; x ; x = XEXP (x, 1))\n+  for (x = label_value_list; x; x = XEXP (x, 1))\n     if (label == XEXP (x, 0))\n       return 0;\n-  for (x = exception_handler_labels; x ; x = XEXP (x, 1))\n+  for (x = exception_handler_labels; x; x = XEXP (x, 1))\n     if (label == XEXP (x, 0))\n       return 0;\n \n   /* User declared labels must be preserved.  */\n   if (LABEL_NAME (label) != 0)\n     return 0;\n-  \n+\n   return 1;\n }\n \n@@ -2162,7 +2159,7 @@ tail_recursion_label_p (label)\n {\n   rtx x;\n \n-  for (x = tail_recursion_label_list; x ; x = XEXP (x, 1))\n+  for (x = tail_recursion_label_list; x; x = XEXP (x, 1))\n     if (label == XEXP (x, 0))\n       return 1;\n \n@@ -2222,7 +2219,7 @@ merge_blocks_nomove (a, b)\n \t the insn that set cc0.  */\n       if (prev && sets_cc0_p (prev))\n \t{\n-          rtx tmp = prev;\n+\t  rtx tmp = prev;\n \t  prev = prev_nonnote_insn (prev);\n \t  if (!prev)\n \t    prev = a->head;\n@@ -2247,7 +2244,7 @@ merge_blocks_nomove (a, b)\n     remove_edge (a->succ);\n \n   /* Adjust the edges out of B for the new owner.  */\n-  for (e = b->succ; e ; e = e->succ_next)\n+  for (e = b->succ; e; e = e->succ_next)\n     e->src = a;\n   a->succ = b->succ;\n \n@@ -2314,12 +2311,12 @@ merge_blocks_move_predecessor_nojumps (a, b)\n   /* Swap the records for the two blocks around.  Although we are deleting B,\n      A is now where B was and we want to compact the BB array from where\n      A used to be.  */\n-  BASIC_BLOCK(a->index) = b;\n-  BASIC_BLOCK(b->index) = a;\n+  BASIC_BLOCK (a->index) = b;\n+  BASIC_BLOCK (b->index) = a;\n   index = a->index;\n   a->index = b->index;\n   b->index = index;\n-  \n+\n   /* Now blocks A and B are contiguous.  Merge them.  */\n   merge_blocks_nomove (a, b);\n \n@@ -2380,7 +2377,7 @@ merge_blocks_move_successor_nojumps (a, b)\n   return 1;\n }\n \n-/* Attempt to merge basic blocks that are potentially non-adjacent.  \n+/* Attempt to merge basic blocks that are potentially non-adjacent.\n    Return true iff the attempt succeeded.  */\n \n static int\n@@ -2418,24 +2415,24 @@ merge_blocks (e, b, c)\n \n       /* We must make sure to not munge nesting of exception regions,\n \t lexical blocks, and loop notes.\n-  \n+\n \t The first is taken care of by requiring that the active eh\n \t region at the end of one block always matches the active eh\n \t region at the beginning of the next block.\n-  \n+\n \t The later two are taken care of by squeezing out all the notes.  */\n-  \n+\n       /* ???  A throw/catch edge (or any abnormal edge) should be rarely\n \t executed and we may want to treat blocks which have two out\n \t edges, one normal, one abnormal as only having one edge for\n \t block merging purposes.  */\n \n-      for (tmp_edge = c->succ; tmp_edge ; tmp_edge = tmp_edge->succ_next)\n+      for (tmp_edge = c->succ; tmp_edge; tmp_edge = tmp_edge->succ_next)\n \tif (tmp_edge->flags & EDGE_FALLTHRU)\n \t  break;\n       c_has_outgoing_fallthru = (tmp_edge != NULL);\n \n-      for (tmp_edge = b->pred; tmp_edge ; tmp_edge = tmp_edge->pred_next)\n+      for (tmp_edge = b->pred; tmp_edge; tmp_edge = tmp_edge->pred_next)\n \tif (tmp_edge->flags & EDGE_FALLTHRU)\n \t  break;\n       b_has_incoming_fallthru = (tmp_edge != NULL);\n@@ -2484,10 +2481,10 @@ try_merge_blocks ()\n   int i;\n \n   /* Attempt to merge blocks as made possible by edge removal.  If a block\n-     has only one successor, and the successor has only one predecessor, \n+     has only one successor, and the successor has only one predecessor,\n      they may be combined.  */\n \n-  for (i = 0; i < n_basic_blocks; )\n+  for (i = 0; i < n_basic_blocks;)\n     {\n       basic_block c, b = BASIC_BLOCK (i);\n       edge s;\n@@ -2637,7 +2634,7 @@ life_analysis (f, file, flags)\n      Otherwise offsets and such may be incorrect.\n \n      Reload will make some registers as live even though they do not\n-     appear in the rtl.  \n+     appear in the rtl.\n \n      We don't want to create new auto-incs after reload, since they\n      are unlikely to be useful and can cause problems with shared\n@@ -2658,7 +2655,7 @@ life_analysis (f, file, flags)\n      we've already emitted the epilogue so there's no sense searching.  */\n   if (! reload_completed)\n     notice_stack_pointer_modification (f);\n-    \n+\n   /* Allocate and zero out data structures that will record the\n      data from lifetime analysis.  */\n   allocate_reg_life_data ();\n@@ -2672,7 +2669,7 @@ life_analysis (f, file, flags)\n      is not immediately handy.  */\n \n   if (flags & PROP_REG_INFO)\n-    memset (regs_ever_live, 0, sizeof(regs_ever_live));\n+    memset (regs_ever_live, 0, sizeof (regs_ever_live));\n   update_life_info (NULL, UPDATE_LIFE_GLOBAL, flags);\n \n   /* Clean up.  */\n@@ -2762,7 +2759,7 @@ verify_local_live_at_start (new_live_at_start, bb)\n \n /* Updates life information starting with the basic blocks set in BLOCKS.\n    If BLOCKS is null, consider it to be the universal set.\n-   \n+\n    If EXTENT is UPDATE_LIFE_LOCAL, such as after splitting or peepholeing,\n    we are only expecting local modifications to basic blocks.  If we find\n    extra registers live at the beginning of a block, then we either killed\n@@ -2839,7 +2836,7 @@ update_life_info (blocks, extent, prop_flags)\n \t\t\t\t FIRST_PSEUDO_REGISTER, i,\n \t\t\t\t { REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; });\n \n-      /* We have a problem with any pseudoreg that lives across the setjmp. \n+      /* We have a problem with any pseudoreg that lives across the setjmp.\n \t ANSI says that if a user variable does not change in value between\n \t the setjmp and the longjmp, then the longjmp preserves it.  This\n \t includes longjmp from a place where the pseudo appears dead.\n@@ -2887,6 +2884,7 @@ free_basic_block_vars (keep_head_end_p)\n }\n \n /* Return nonzero if the destination of SET equals the source.  */\n+\n static int\n set_noop_p (set)\n      rtx set;\n@@ -2908,6 +2906,7 @@ set_noop_p (set)\n \n /* Return nonzero if an insn consists only of SETs, each of which only sets a\n    value to itself.  */\n+\n static int\n noop_move_p (insn)\n      rtx insn;\n@@ -3010,6 +3009,7 @@ notice_stack_pointer_modification (f)\n \n /* Mark a register in SET.  Hard registers in large modes get all\n    of their component registers set as well.  */\n+\n static void\n mark_reg (reg, xset)\n      rtx reg;\n@@ -3032,6 +3032,7 @@ mark_reg (reg, xset)\n \n /* Mark those regs which are needed at the end of the function as live\n    at the end of the last basic block.  */\n+\n static void\n mark_regs_live_at_end (set)\n      regset set;\n@@ -3061,7 +3062,7 @@ mark_regs_live_at_end (set)\n       /* If they are different, also mark the hard frame pointer as live.  */\n       if (! LOCAL_REGNO (HARD_FRAME_POINTER_REGNUM))\n         SET_REGNO_REG_SET (set, HARD_FRAME_POINTER_REGNUM);\n-#endif      \n+#endif\n     }\n \n #ifdef PIC_OFFSET_TABLE_REGNUM\n@@ -3110,7 +3111,7 @@ set_phi_alternative_reg (insn, dest_regno, src_regno, data)\n }\n \n /* Propagate global life info around the graph of basic blocks.  Begin\n-   considering blocks with their corresponding bit set in BLOCKS_IN. \n+   considering blocks with their corresponding bit set in BLOCKS_IN.\n    If BLOCKS_IN is null, consider it the universal set.\n \n    BLOCKS_OUT is set for every block that was changed.  */\n@@ -3130,7 +3131,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n   new_live_at_end = INITIALIZE_REG_SET (new_live_at_end_head);\n \n   /* Create a worklist.  Allocate an extra slot for ENTRY_BLOCK, and one\n-     because the `head == tail' style test for an empty queue doesn't \n+     because the `head == tail' style test for an empty queue doesn't\n      work with a full queue.  */\n   queue = (basic_block *) xmalloc ((n_basic_blocks + 2) * sizeof (*queue));\n   qtail = queue;\n@@ -3141,7 +3142,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n     BASIC_BLOCK (i)->aux = NULL;\n \n   /* Queue the blocks set in the initial mask.  Do this in reverse block\n-     number order so that we are more likely for the first round to do \n+     number order so that we are more likely for the first round to do\n      useful work.  We use AUX non-null to flag that the block is queued.  */\n   if (blocks_in)\n     {\n@@ -3178,13 +3179,13 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \n       /* Begin by propogating live_at_start from the successor blocks.  */\n       CLEAR_REG_SET (new_live_at_end);\n-      for (e = bb->succ; e ; e = e->succ_next)\n+      for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  basic_block sb = e->dest;\n \t  IOR_REG_SET (new_live_at_end, sb->global_live_at_start);\n \t}\n \n-      /* Force the stack pointer to be live -- which might not already be \n+      /* Force the stack pointer to be live -- which might not already be\n \t the case for blocks within infinite loops.  */\n       SET_REGNO_REG_SET (new_live_at_end, STACK_POINTER_REGNUM);\n \n@@ -3193,7 +3194,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \t particular edge.  Set those regs that are live because of a\n \t phi node alternative corresponding to this particular block.  */\n       if (in_ssa_form)\n-\tfor_each_successor_phi (bb, &set_phi_alternative_reg, \n+\tfor_each_successor_phi (bb, &set_phi_alternative_reg,\n \t\t\t\tnew_live_at_end);\n \n       if (bb == ENTRY_BLOCK_PTR)\n@@ -3202,7 +3203,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \t  continue;\n \t}\n \n-      /* On our first pass through this block, we'll go ahead and continue. \n+      /* On our first pass through this block, we'll go ahead and continue.\n \t Recognize first pass by local_set NULL.  On subsequent passes, we\n \t get to skip out early if live_at_end wouldn't have changed.  */\n \n@@ -3276,7 +3277,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \n       /* Queue all predecessors of BB so that we may re-examine\n \t their live_at_end.  */\n-      for (e = bb->pred; e ; e = e->pred_next)\n+      for (e = bb->pred; e; e = e->pred_next)\n \t{\n \t  basic_block pb = e->src;\n \t  if (pb->aux == NULL)\n@@ -3349,7 +3350,7 @@ allocate_reg_life_data ()\n      vector oriented regsets would set regset_{size,bytes} here also.  */\n   allocate_reg_info (max_regno, FALSE, FALSE);\n \n-  /* Reset all the data we'll collect in propagate_block and its \n+  /* Reset all the data we'll collect in propagate_block and its\n      subroutines.  */\n   for (i = 0; i < max_regno; i++)\n     {\n@@ -3417,7 +3418,7 @@ propagate_block_delete_libcall (bb, insn, note)\n \n   if (insn == bb->end)\n     bb->end = before;\n-  \n+\n   flow_delete_insn_chain (first, insn);\n   return before;\n }\n@@ -3459,7 +3460,7 @@ propagate_one_insn (pbi, insn)\n       && find_reg_note (insn, REG_MAYBE_DEAD, NULL_RTX) == 0)\n     {\n       if (flags & PROP_KILL_DEAD_CODE)\n-\t{ \n+\t{\n \t  warning (\"ICE: would have deleted prologue/epilogue insn\");\n \t  if (!inhibit_warnings)\n \t    debug_rtx (insn);\n@@ -3648,7 +3649,7 @@ init_propagate_block_info (bb, live, local_set, flags)\n      regset local_set;\n      int flags;\n {\n-  struct propagate_block_info *pbi = xmalloc (sizeof(*pbi));\n+  struct propagate_block_info *pbi = xmalloc (sizeof (*pbi));\n \n   pbi->bb = bb;\n   pbi->reg_live = live;\n@@ -3686,7 +3687,7 @@ init_propagate_block_info (bb, live, local_set, flags)\n       bb_true = bb->succ->dest;\n       if (bb->succ->succ_next != NULL)\n \t{\n-          bb_false = bb->succ->succ_next->dest;\n+\t  bb_false = bb->succ->succ_next->dest;\n \n \t  if (bb->succ->flags & EDGE_FALLTHRU)\n \t    {\n@@ -3706,7 +3707,7 @@ init_propagate_block_info (bb, live, local_set, flags)\n \t  /* Simplest way to do nothing.  */\n \t  bb_false = bb_true;\n \t}\n-     \n+\n       /* Extract the condition from the branch.  */\n       set_src = SET_SRC (pc_set (bb->end));\n       cond_true = XEXP (set_src, 0);\n@@ -3759,7 +3760,7 @@ init_propagate_block_info (bb, live, local_set, flags)\n   if (optimize\n       && (flags & PROP_SCAN_DEAD_CODE)\n       && (bb->succ == NULL\n-          || (bb->succ->succ_next == NULL\n+\t  || (bb->succ->succ_next == NULL\n \t      && bb->succ->dest == EXIT_BLOCK_PTR)))\n     {\n       rtx insn;\n@@ -3769,7 +3770,7 @@ init_propagate_block_info (bb, live, local_set, flags)\n \t    && GET_CODE (SET_DEST (PATTERN (insn))) == MEM)\n \t  {\n \t    rtx mem = SET_DEST (PATTERN (insn));\n-\t    \n+\n \t    if (XEXP (mem, 0) == frame_pointer_rtx\n \t\t|| (GET_CODE (XEXP (mem, 0)) == PLUS\n \t\t    && XEXP (XEXP (mem, 0), 0) == frame_pointer_rtx\n@@ -3808,7 +3809,7 @@ free_propagate_block_info (pbi)\n    When called, REG_LIVE contains those live at the end.  On return, it\n    contains those live at the beginning.\n \n-   LOCAL_SET, if non-null, will be set with all registers killed by \n+   LOCAL_SET, if non-null, will be set with all registers killed by\n    this basic block.  */\n \n void\n@@ -3820,22 +3821,22 @@ propagate_block (bb, live, local_set, flags)\n {\n   struct propagate_block_info *pbi;\n   rtx insn, prev;\n-  \n+\n   pbi = init_propagate_block_info (bb, live, local_set, flags);\n \n   if (flags & PROP_REG_INFO)\n     {\n       register int i;\n \n       /* Process the regs live at the end of the block.\n-\t Mark them as not local to any one basic block. */\n+\t Mark them as not local to any one basic block.  */\n       EXECUTE_IF_SET_IN_REG_SET (live, 0, i,\n \t\t\t\t { REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; });\n     }\n \n   /* Scan the block an insn at a time from end to beginning.  */\n \n-  for (insn = bb->end; ; insn = prev)\n+  for (insn = bb->end;; insn = prev)\n     {\n       /* If this is a call to `setjmp' et al, warn if any\n \t non-volatile datum is live.  */\n@@ -3876,7 +3877,7 @@ insn_dead_p (pbi, x, call_ok, notes)\n      expresions into account.  */\n   if (reload_completed)\n     {\n-      for ( ; notes; notes = XEXP (notes, 1))\n+      for (; notes; notes = XEXP (notes, 1))\n \t{\n \t  if (REG_NOTE_KIND (notes) == REG_INC)\n \t    {\n@@ -3902,7 +3903,7 @@ insn_dead_p (pbi, x, call_ok, notes)\n       if (GET_CODE (r) == CC0)\n \treturn ! pbi->cc0_live;\n #endif\n-      \n+\n       /* A SET that is a subroutine call cannot be dead.  */\n       if (GET_CODE (SET_SRC (x)) == CALL)\n \t{\n@@ -4144,26 +4145,26 @@ invalidate_mems_from_autoinc (pbi, insn)\n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n     {\n       if (REG_NOTE_KIND (note) == REG_INC)\n-        {\n-          rtx temp = pbi->mem_set_list;\n-          rtx prev = NULL_RTX;\n+\t{\n+\t  rtx temp = pbi->mem_set_list;\n+\t  rtx prev = NULL_RTX;\n \t  rtx next;\n \n-          while (temp)\n+\t  while (temp)\n \t    {\n \t      next = XEXP (temp, 1);\n \t      if (reg_overlap_mentioned_p (XEXP (note, 0), XEXP (temp, 0)))\n-\t        {\n-\t          /* Splice temp out of list.  */\n-\t          if (prev)\n-\t            XEXP (prev, 1) = next;\n-\t          else\n-\t            pbi->mem_set_list = next;\n+\t\t{\n+\t\t  /* Splice temp out of list.  */\n+\t\t  if (prev)\n+\t\t    XEXP (prev, 1) = next;\n+\t\t  else\n+\t\t    pbi->mem_set_list = next;\n \t\t  free_EXPR_LIST_node (temp);\n-\t        }\n+\t\t}\n \t      else\n-\t        prev = temp;\n-              temp = next;\n+\t\tprev = temp;\n+\t      temp = next;\n \t    }\n \t}\n     }\n@@ -4223,7 +4224,7 @@ mark_set_regs (pbi, x, insn)\n \t\tsub = COND_EXEC_CODE (sub);\n \t\tif (GET_CODE (sub) != SET && GET_CODE (sub) != CLOBBER)\n \t\t  break;\n-\t\t/* FALLTHRU */\n+\t\t/* Fall through.  */\n \n \t      case SET:\n \t      case CLOBBER:\n@@ -4285,7 +4286,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n       if (GET_CODE (reg) == MEM)\n \tbreak;\n       not_dead = REGNO_REG_SET_P (pbi->reg_live, REGNO (reg));\n-      /* FALLTHRU */\n+      /* Fall through.  */\n \n     case REG:\n       regno_last = regno_first = REGNO (reg);\n@@ -4345,7 +4346,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n       break;\n     }\n \n-  /* If this set is a MEM, then it kills any aliased writes. \n+  /* If this set is a MEM, then it kills any aliased writes.\n      If this set is a REG, then it kills any MEMs which use the reg.  */\n   if (optimize && (flags & PROP_SCAN_DEAD_CODE))\n     {\n@@ -4388,7 +4389,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t  /* We do not know the size of a BLKmode store, so we do not track\n \t     them for redundant store elimination.  */\n \t  && GET_MODE (reg) != BLKmode\n-\t  /* There are no REG_INC notes for SP, so we can't assume we'll see \n+\t  /* There are no REG_INC notes for SP, so we can't assume we'll see\n \t     everything that invalidates it.  To be safe, don't eliminate any\n \t     stores though SP; none of them should be redundant anyway.  */\n \t  && ! reg_mentioned_p (stack_pointer_rtx, reg))\n@@ -4468,7 +4469,7 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n \t\t     elsewhere, but we want the count to include the insn\n \t\t     where the reg is set, and the normal counting mechanism\n \t\t     would not count it.  */\n-\t          REG_LIVE_LENGTH (i) += 1;\n+\t\t  REG_LIVE_LENGTH (i) += 1;\n \t\t}\n \n \t      /* If this is a hard reg, record this function uses the reg.  */\n@@ -4574,8 +4575,8 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n }\n \f\n #ifdef HAVE_conditional_execution\n-/* Mark REGNO conditionally dead.  Return true if the register is\n-   now unconditionally dead.  */\n+/* Mark REGNO conditionally dead.\n+   Return true if the register is now unconditionally dead.  */\n \n static int\n mark_regno_cond_dead (pbi, regno, cond)\n@@ -4611,8 +4612,7 @@ mark_regno_cond_dead (pbi, regno, cond)\n \t  /* The register was unconditionally live previously.\n \t     Record the current condition as the condition under\n \t     which it is dead.  */\n-\t  rcli = (struct reg_cond_life_info *)\n-\t    xmalloc (sizeof (*rcli));\n+\t  rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n \t  rcli->condition = alloc_EXPR_LIST (0, cond, NULL_RTX);\n \t  splay_tree_insert (pbi->reg_cond_dead, regno,\n \t\t\t     (splay_tree_value) rcli);\n@@ -4625,7 +4625,7 @@ mark_regno_cond_dead (pbi, regno, cond)\n \t}\n       else\n \t{\n-\t  /* The register was conditionally live previously. \n+\t  /* The register was conditionally live previously.\n \t     Add the new condition to the old.  */\n \t  rcli = (struct reg_cond_life_info *) node->value;\n \t  ncond = rcli->condition;\n@@ -4724,9 +4724,9 @@ flush_reg_cond_reg (pbi, regno)\n \n /* Logical arithmetic on predicate conditions.  IOR, NOT and NAND.\n    We actually use EXPR_LIST to chain the sub-expressions together\n-   instead of IOR because it's easier to manipulate and we have \n+   instead of IOR because it's easier to manipulate and we have\n    the lists.c functions to reuse nodes.\n-   \n+\n    Return a new rtl expression as appropriate.  */\n \n static rtx\n@@ -4745,7 +4745,7 @@ ior_reg_cond (old, x)\n     abort ();\n \n   /* Search the expression for an existing sub-expression of X_REG.  */\n-  for (c = old; c ; c = XEXP (c, 1))\n+  for (c = old; c; c = XEXP (c, 1))\n     {\n       rtx y = XEXP (c, 0);\n       if (REGNO (XEXP (y, 0)) == REGNO (x_reg))\n@@ -4754,7 +4754,7 @@ ior_reg_cond (old, x)\n \t  if (GET_CODE (y) == x_code)\n \t    return old;\n \n-\t  /* If we find X being a compliment of a condition in OLD, \n+\t  /* If we find X being a compliment of a condition in OLD,\n \t     then the entire condition is true.  */\n \t  if (GET_CODE (y) == reverse_condition (x_code))\n \t    return const1_rtx;\n@@ -4801,12 +4801,12 @@ nand_reg_cond (old, x)\n \n   /* Search the expression for an existing sub-expression of X_REG.  */\n \n-  for (c = *(prev = &old); c ; c = *(prev = &XEXP (c, 1)))\n+  for (c = *(prev = &old); c; c = *(prev = &XEXP (c, 1)))\n     {\n       rtx y = XEXP (c, 0);\n       if (REGNO (XEXP (y, 0)) == REGNO (x_reg))\n \t{\n-\t  /* If we find X already present in OLD, then we need to \n+\t  /* If we find X already present in OLD, then we need to\n \t     splice it out.  */\n \t  if (GET_CODE (y) == x_code)\n \t    {\n@@ -4815,7 +4815,7 @@ nand_reg_cond (old, x)\n \t      return old ? old : const0_rtx;\n \t    }\n \n-\t  /* If we find X being a compliment of a condition in OLD, \n+\t  /* If we find X being a compliment of a condition in OLD,\n \t     then we need do nothing.  */\n \t  if (GET_CODE (y) == reverse_condition (x_code))\n \t    return old;\n@@ -4910,7 +4910,7 @@ attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n \n       /* INCR will become a NOTE and INSN won't contain a\n \t use of INCR_REG.  If a use of INCR_REG was just placed in\n-\t the insn before INSN, make that the next use. \n+\t the insn before INSN, make that the next use.\n \t Otherwise, invalidate it.  */\n       if (GET_CODE (PREV_INSN (insn)) == INSN\n \t  && GET_CODE (PATTERN (PREV_INSN (insn))) == SET\n@@ -4941,8 +4941,7 @@ attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n      auto-inc, so update the status.  First, record that this insn\n      has an implicit side effect.  */\n \n-  REG_NOTES (insn)\n-    = alloc_EXPR_LIST (REG_INC, incr_reg, REG_NOTES (insn));\n+  REG_NOTES (insn) = alloc_EXPR_LIST (REG_INC, incr_reg, REG_NOTES (insn));\n \n   /* Modify the old increment-insn to simply copy\n      the already-incremented value of our register.  */\n@@ -4956,7 +4955,7 @@ attempt_auto_inc (pbi, inc, insn, mem, incr, incr_reg)\n     {\n       /* If the original source was dead, it's dead now.  */\n       rtx note;\n-      \n+\n       while (note = find_reg_note (incr, REG_DEAD, NULL_RTX))\n \t{\n \t  remove_note (incr, note);\n@@ -5037,15 +5036,15 @@ find_auto_inc (pbi, x, insn)\n \tattempt_auto_inc (pbi, gen_rtx_POST_INC (Pmode, addr), insn, x,\n \t\t\t  incr, addr);\n       else if (HAVE_POST_DECREMENT\n-\t       && (INTVAL (inc_val) == - size && offset == 0))\n+\t       && (INTVAL (inc_val) == -size && offset == 0))\n \tattempt_auto_inc (pbi, gen_rtx_POST_DEC (Pmode, addr), insn, x,\n \t\t\t  incr, addr);\n       else if (HAVE_PRE_INCREMENT\n \t       && (INTVAL (inc_val) == size && offset == size))\n \tattempt_auto_inc (pbi, gen_rtx_PRE_INC (Pmode, addr), insn, x,\n \t\t\t  incr, addr);\n       else if (HAVE_PRE_DECREMENT\n-\t       && (INTVAL (inc_val) == - size && offset == - size))\n+\t       && (INTVAL (inc_val) == -size && offset == -size))\n \tattempt_auto_inc (pbi, gen_rtx_PRE_DEC (Pmode, addr), insn, x,\n \t\t\t  incr, addr);\n       else if (HAVE_POST_MODIFY_DISP && offset == 0)\n@@ -5228,7 +5227,7 @@ mark_used_reg (pbi, reg, cond, insn)\n \t    }\n \t  else\n \t    {\n-\t      /* The register was conditionally live previously. \n+\t      /* The register was conditionally live previously.\n \t\t Subtract the new life cond from the old death cond.  */\n \t      rcli = (struct reg_cond_life_info *) node->value;\n \t      ncond = rcli->condition;\n@@ -5320,16 +5319,17 @@ mark_used_regs (pbi, x, cond, insn)\n       return;\n \n     case MEM:\n-      /* Don't bother watching stores to mems if this is not the \n+      /* Don't bother watching stores to mems if this is not the\n \t final pass.  We'll not be deleting dead stores this round.  */\n       if (optimize && (flags & PROP_SCAN_DEAD_CODE))\n \t{\n-          /* Invalidate the data for the last MEM stored, but only if MEM is\n+\t  /* Invalidate the data for the last MEM stored, but only if MEM is\n \t     something that can be stored into.  */\n-          if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t  if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n \t      && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n-\t    ; /* needn't clear the memory set list */\n-          else\n+\t    /* Needn't clear the memory set list.  */\n+\t    ;\n+\t  else\n \t    {\n \t      rtx temp = pbi->mem_set_list;\n \t      rtx prev = NULL_RTX;\n@@ -5379,7 +5379,7 @@ mark_used_regs (pbi, x, cond, insn)\n       x = SUBREG_REG (x);\n       if (GET_CODE (x) != REG)\n \tgoto retry;\n-      /* FALLTHRU */\n+      /* Fall through.  */\n \n     case REG:\n       /* See a register other than being set => mark it as needed.  */\n@@ -5403,7 +5403,7 @@ mark_used_regs (pbi, x, cond, insn)\n \t    mark_used_regs (pbi, SET_SRC (x), cond, insn);\n \t    return;\n \t  }\n-\t    \n+\n \t/* Storing in STRICT_LOW_PART is like storing in a reg\n \t   in that this SET might be dead, so ignore it in TESTREG.\n \t   but in some other ways it is like using the reg.\n@@ -5474,7 +5474,7 @@ mark_used_regs (pbi, x, cond, insn)\n \n \t   Consider for instance a volatile asm that changes the fpu rounding\n \t   mode.  An insn should not be moved across this even if it only uses\n-\t   pseudo-regs because it might give an incorrectly rounded result. \n+\t   pseudo-regs because it might give an incorrectly rounded result.\n \n \t   ?!? Unfortunately, marking all hard registers as live causes massive\n \t   problems for the register allocator and marking all pseudos as live\n@@ -5485,7 +5485,7 @@ mark_used_regs (pbi, x, cond, insn)\n \tif (code != ASM_OPERANDS || MEM_VOLATILE_P (x))\n \t  free_EXPR_LIST_list (&pbi->mem_set_list);\n \n-        /* For all ASM_OPERANDS, we must traverse the vector of input operands.\n+\t/* For all ASM_OPERANDS, we must traverse the vector of input operands.\n \t   We can not just fall through here since then we would be confused\n \t   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate\n \t   traditional asms unlike their normal usage.  */\n@@ -5526,7 +5526,7 @@ mark_used_regs (pbi, x, cond, insn)\n   {\n     register const char *fmt = GET_RTX_FORMAT (code);\n     register int i;\n-    \n+\n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n \tif (fmt[i] == 'e')\n@@ -5560,7 +5560,7 @@ try_pre_increment_1 (pbi, insn)\n      make it do pre-increment or pre-decrement if appropriate.  */\n   rtx x = single_set (insn);\n   HOST_WIDE_INT amount = ((GET_CODE (SET_SRC (x)) == PLUS ? 1 : -1)\n-\t\t* INTVAL (XEXP (SET_SRC (x), 1)));\n+\t\t\t  * INTVAL (XEXP (SET_SRC (x), 1)));\n   int regno = REGNO (SET_DEST (x));\n   rtx y = pbi->reg_next_use[regno];\n   if (y != 0\n@@ -5785,10 +5785,10 @@ dump_flow_info (file)\n \tif (REG_BASIC_BLOCK (i) >= 0)\n \t  fprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n \tif (REG_N_SETS (i))\n-  \t  fprintf (file, \"; set %d time%s\", REG_N_SETS (i),\n-   \t\t   (REG_N_SETS (i) == 1) ? \"\" : \"s\");\n+\t  fprintf (file, \"; set %d time%s\", REG_N_SETS (i),\n+\t\t   (REG_N_SETS (i) == 1) ? \"\" : \"s\");\n \tif (REG_USERVAR_P (regno_reg_rtx[i]))\n-  \t  fprintf (file, \"; user var\");\n+\t  fprintf (file, \"; user var\");\n \tif (REG_N_DEATHS (i) != 1)\n \t  fprintf (file, \"; dies in %d places\", REG_N_DEATHS (i));\n \tif (REG_N_CALLS_CROSSED (i) == 1)\n@@ -5825,11 +5825,11 @@ dump_flow_info (file)\n \t       i, INSN_UID (bb->head), INSN_UID (bb->end), bb->loop_depth, bb->count);\n \n       fprintf (file, \"Predecessors: \");\n-      for (e = bb->pred; e ; e = e->pred_next)\n+      for (e = bb->pred; e; e = e->pred_next)\n \tdump_edge_info (file, e, 0);\n \n       fprintf (file, \"\\nSuccessors: \");\n-      for (e = bb->succ; e ; e = e->succ_next)\n+      for (e = bb->succ; e; e = e->succ_next)\n \tdump_edge_info (file, e, 1);\n \n       fprintf (file, \"\\nRegisters live at start:\");\n@@ -5838,10 +5838,10 @@ dump_flow_info (file)\n       fprintf (file, \"\\nRegisters live at end:\");\n       dump_regset (bb->global_live_at_end, file);\n \n-      putc('\\n', file);\n+      putc ('\\n', file);\n     }\n \n-  putc('\\n', file);\n+  putc ('\\n', file);\n }\n \n void\n@@ -5885,7 +5885,7 @@ dump_edge_info (file, e, do_succ)\n \n \t    if (comma)\n \t      fputc (',', file);\n-\t    if (i < (int)(sizeof (bitnames) / sizeof (*bitnames)))\n+\t    if (i < (int) (sizeof (bitnames) / sizeof (*bitnames)))\n \t      fputs (bitnames[i], file);\n \t    else\n \t      fprintf (file, \"%d\", i);\n@@ -5894,9 +5894,9 @@ dump_edge_info (file, e, do_succ)\n       fputc (')', file);\n     }\n }\n-\n \f\n /* Print out one basic block with live information at start and end.  */\n+\n void\n dump_bb (bb, outf)\n      basic_block bb;\n@@ -5913,7 +5913,7 @@ dump_bb (bb, outf)\n   putc ('\\n', outf);\n \n   fputs (\";; Predecessors: \", outf);\n-  for (e = bb->pred; e ; e = e->pred_next)\n+  for (e = bb->pred; e; e = e->pred_next)\n     dump_edge_info (outf, e, 0);\n   putc ('\\n', outf);\n \n@@ -5947,7 +5947,7 @@ void\n debug_bb_n (n)\n      int n;\n {\n-  dump_bb (BASIC_BLOCK(n), stderr);\n+  dump_bb (BASIC_BLOCK (n), stderr);\n }\n \n /* Like print_rtl, but also print out live information for the start of each\n@@ -5984,9 +5984,9 @@ print_rtl_with_bb (outf, rtx_first)\n \t  for (x = bb->head; x != NULL_RTX; x = NEXT_INSN (x))\n \t    {\n \t      enum bb_state state = IN_MULTIPLE_BB;\n-\t      if (in_bb_p[INSN_UID(x)] == NOT_IN_BB)\n+\t      if (in_bb_p[INSN_UID (x)] == NOT_IN_BB)\n \t\tstate = IN_ONE_BB;\n-\t      in_bb_p[INSN_UID(x)] = state;\n+\t      in_bb_p[INSN_UID (x)] = state;\n \n \t      if (x == bb->end)\n \t\tbreak;\n@@ -6006,11 +6006,11 @@ print_rtl_with_bb (outf, rtx_first)\n \t      putc ('\\n', outf);\n \t    }\n \n-\t  if (in_bb_p[INSN_UID(tmp_rtx)] == NOT_IN_BB\n+\t  if (in_bb_p[INSN_UID (tmp_rtx)] == NOT_IN_BB\n \t      && GET_CODE (tmp_rtx) != NOTE\n \t      && GET_CODE (tmp_rtx) != BARRIER)\n \t    fprintf (outf, \";; Insn is not within a basic block\\n\");\n-\t  else if (in_bb_p[INSN_UID(tmp_rtx)] == IN_MULTIPLE_BB)\n+\t  else if (in_bb_p[INSN_UID (tmp_rtx)] == IN_MULTIPLE_BB)\n \t    fprintf (outf, \";; Insn is in multiple basic blocks\\n\");\n \n \t  did_output = print_rtl_single (outf, tmp_rtx);\n@@ -6042,6 +6042,7 @@ print_rtl_with_bb (outf, rtx_first)\n }\n \n /* Compute dominator relationships using new flow graph structures.  */\n+\n void\n compute_flow_dominators (dominators, post_dominators)\n      sbitmap *dominators;\n@@ -6245,25 +6246,25 @@ compute_immediate_dominators (idom, dominators)\n   tmp = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n \n   /* Begin with tmp(n) = dom(n) - { n }.  */\n-  for (b = n_basic_blocks; --b >= 0; )\n+  for (b = n_basic_blocks; --b >= 0;)\n     {\n       sbitmap_copy (tmp[b], dominators[b]);\n       RESET_BIT (tmp[b], b);\n     }\n \n   /* Subtract out all of our dominator's dominators.  */\n-  for (b = n_basic_blocks; --b >= 0; )\n+  for (b = n_basic_blocks; --b >= 0;)\n     {\n       sbitmap tmp_b = tmp[b];\n       int s;\n \n-      for (s = n_basic_blocks; --s >= 0; )\n+      for (s = n_basic_blocks; --s >= 0;)\n \tif (TEST_BIT (tmp_b, s))\n \t  sbitmap_difference (tmp_b, tmp_b, tmp[s]);\n     }\n \n   /* Find the one bit set in the bitmap and put it in the output array.  */\n-  for (b = n_basic_blocks; --b >= 0; )\n+  for (b = n_basic_blocks; --b >= 0;)\n     {\n       int t;\n       EXECUTE_IF_SET_IN_SBITMAP (tmp[b], 0, t, { idom[b] = t; });\n@@ -6318,8 +6319,8 @@ recompute_reg_usage (f, loop_step)\n \n int\n count_or_remove_death_notes (blocks, kill)\n-    sbitmap blocks;\n-    int kill;\n+     sbitmap blocks;\n+     int kill;\n {\n   int i, count = 0;\n \n@@ -6333,7 +6334,7 @@ count_or_remove_death_notes (blocks, kill)\n \n       bb = BASIC_BLOCK (i);\n \n-      for (insn = bb->head; ; insn = NEXT_INSN (insn))\n+      for (insn = bb->head;; insn = NEXT_INSN (insn))\n \t{\n \t  if (INSN_P (insn))\n \t    {\n@@ -6356,17 +6357,17 @@ count_or_remove_death_notes (blocks, kill)\n \t\t\t    n = HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg));\n \t\t\t  count += n;\n \t\t\t}\n-\t\t      /* FALLTHRU */\n+\t\t      /* Fall through.  */\n \n \t\t    case REG_UNUSED:\n \t\t      if (kill)\n \t\t\t{\n \t\t\t  rtx next = XEXP (link, 1);\n \t\t\t  free_EXPR_LIST_node (link);\n-\t\t          *pprev = link = next;\n-\t\t          break;\n+\t\t\t  *pprev = link = next;\n+\t\t\t  break;\n \t\t\t}\n-\t\t      /* FALLTHRU */\n+\t\t      /* Fall through.  */\n \n \t\t    default:\n \t\t      pprev = &XEXP (link, 1);\n@@ -6395,7 +6396,7 @@ set_block_for_insn (insn, bb)\n   if (uid >= basic_block_for_insn->num_elements)\n     {\n       int new_size;\n-      \n+\n       /* Add one-eighth the size so we don't keep calling xrealloc.  */\n       new_size = uid + (uid + 7) / 8;\n \n@@ -6419,7 +6420,7 @@ set_block_num (insn, bb)\n    aborts when something is wrong.  Hope that this function will help to\n    convert many optimization passes to preserve CFG consistent.\n \n-   Currently it does following checks: \n+   Currently it does following checks:\n \n    - test head/end pointers\n    - overlapping of basic blocks\n@@ -6428,7 +6429,7 @@ set_block_num (insn, bb)\n    - tails of basic blocks (ensure that boundary is necesary)\n    - scans body of the basic block for JUMP_INSN, CODE_LABEL\n      and NOTE_INSN_BASIC_BLOCK\n-   - check that all insns are in the basic blocks \n+   - check that all insns are in the basic blocks\n    (except the switch handling code, barriers and notes)\n    - check that all returns are followed by barriers\n \n@@ -6466,7 +6467,7 @@ verify_flow_info ()\n \n       /* Work backwards from the end to the head of the basic block\n \t to verify the head is in the RTL chain.  */\n-      for ( ; x != NULL_RTX; x = PREV_INSN (x))\n+      for (; x != NULL_RTX; x = PREV_INSN (x))\n \t{\n \t  /* While walking over the insn chain, verify insns appear\n \t     in only one basic block and initialize the BB_INFO array\n@@ -6504,7 +6505,8 @@ verify_flow_info ()\n \t{\n \t  if (e->src != bb)\n \t    {\n-\t      fprintf (stderr, \"verify_flow_info: Basic block %d succ edge is corrupted\\n\",\n+\t      fprintf (stderr,\n+\t\t       \"verify_flow_info: Basic block %d succ edge is corrupted\\n\",\n \t\t       bb->index);\n \t      fprintf (stderr, \"Predecessor: \");\n \t      dump_edge_info (stderr, e, 0);\n@@ -6668,17 +6670,18 @@ verify_flow_info ()\n }\n \f\n /* Functions to access an edge list with a vector representation.\n-   Enough data is kept such that given an index number, the \n+   Enough data is kept such that given an index number, the\n    pred and succ that edge represents can be determined, or\n    given a pred and a succ, its index number can be returned.\n-   This allows algorithms which consume a lot of memory to \n+   This allows algorithms which consume a lot of memory to\n    represent the normally full matrix of edge (pred,succ) with a\n    single indexed vector,  edge (EDGE_INDEX (pred, succ)), with no\n    wasted space in the client code due to sparse flow graphs.  */\n \n-/* This functions initializes the edge list. Basically the entire \n+/* This functions initializes the edge list. Basically the entire\n    flowgraph is processed, and all edges are assigned a number,\n    and the data structure is filled in.  */\n+\n struct edge_list *\n create_edge_list ()\n {\n@@ -6718,7 +6721,7 @@ create_edge_list ()\n       elist->index_to_edge[num_edges] = e;\n       num_edges++;\n     }\n-  \n+\n   for (x = 0; x < n_basic_blocks; x++)\n     {\n       basic_block bb = BASIC_BLOCK (x);\n@@ -6734,6 +6737,7 @@ create_edge_list ()\n }\n \n /* This function free's memory associated with an edge list.  */\n+\n void\n free_edge_list (elist)\n      struct edge_list *elist;\n@@ -6746,33 +6750,35 @@ free_edge_list (elist)\n }\n \n /* This function provides debug output showing an edge list.  */\n-void \n+\n+void\n print_edge_list (f, elist)\n      FILE *f;\n      struct edge_list *elist;\n {\n   int x;\n-  fprintf(f, \"Compressed edge list, %d BBs + entry & exit, and %d edges\\n\",\n-\t  elist->num_blocks - 2, elist->num_edges);\n+  fprintf (f, \"Compressed edge list, %d BBs + entry & exit, and %d edges\\n\",\n+\t   elist->num_blocks - 2, elist->num_edges);\n \n   for (x = 0; x < elist->num_edges; x++)\n     {\n       fprintf (f, \" %-4d - edge(\", x);\n       if (INDEX_EDGE_PRED_BB (elist, x) == ENTRY_BLOCK_PTR)\n-        fprintf (f,\"entry,\");\n+\tfprintf (f, \"entry,\");\n       else\n-        fprintf (f,\"%d,\", INDEX_EDGE_PRED_BB (elist, x)->index);\n+\tfprintf (f, \"%d,\", INDEX_EDGE_PRED_BB (elist, x)->index);\n \n       if (INDEX_EDGE_SUCC_BB (elist, x) == EXIT_BLOCK_PTR)\n-        fprintf (f,\"exit)\\n\");\n+\tfprintf (f, \"exit)\\n\");\n       else\n-        fprintf (f,\"%d)\\n\", INDEX_EDGE_SUCC_BB (elist, x)->index);\n+\tfprintf (f, \"%d)\\n\", INDEX_EDGE_SUCC_BB (elist, x)->index);\n     }\n }\n \n /* This function provides an internal consistency check of an edge list,\n-   verifying that all edges are present, and that there are no \n+   verifying that all edges are present, and that there are no\n    extra edges.  */\n+\n void\n verify_edge_list (f, elist)\n      FILE *f;\n@@ -6792,7 +6798,7 @@ verify_edge_list (f, elist)\n \t  index = EDGE_INDEX (elist, e->src, e->dest);\n \t  if (index == EDGE_INDEX_NO_EDGE)\n \t    {\n-\t      fprintf (f, \"*p* No index for edge from %d to %d\\n\",pred, succ);\n+\t      fprintf (f, \"*p* No index for edge from %d to %d\\n\", pred, succ);\n \t      continue;\n \t    }\n \t  if (INDEX_EDGE_PRED_BB (elist, index)->index != pred)\n@@ -6810,7 +6816,7 @@ verify_edge_list (f, elist)\n       index = EDGE_INDEX (elist, e->src, e->dest);\n       if (index == EDGE_INDEX_NO_EDGE)\n \t{\n-\t  fprintf (f, \"*p* No index for edge from %d to %d\\n\",pred, succ);\n+\t  fprintf (f, \"*p* No index for edge from %d to %d\\n\", pred, succ);\n \t  continue;\n \t}\n       if (INDEX_EDGE_PRED_BB (elist, index)->index != pred)\n@@ -6822,99 +6828,100 @@ verify_edge_list (f, elist)\n     }\n   /* We've verified that all the edges are in the list, no lets make sure\n      there are no spurious edges in the list.  */\n-  \n-  for (pred = 0 ; pred < n_basic_blocks; pred++)\n-    for (succ = 0 ; succ < n_basic_blocks; succ++)\n+\n+  for (pred = 0; pred < n_basic_blocks; pred++)\n+    for (succ = 0; succ < n_basic_blocks; succ++)\n       {\n-        basic_block p = BASIC_BLOCK (pred);\n-        basic_block s = BASIC_BLOCK (succ);\n+\tbasic_block p = BASIC_BLOCK (pred);\n+\tbasic_block s = BASIC_BLOCK (succ);\n \n-        int found_edge = 0;\n+\tint found_edge = 0;\n \n-        for (e = p->succ; e; e = e->succ_next)\n-          if (e->dest == s)\n+\tfor (e = p->succ; e; e = e->succ_next)\n+\t  if (e->dest == s)\n \t    {\n \t      found_edge = 1;\n \t      break;\n \t    }\n-        for (e = s->pred; e; e = e->pred_next)\n-          if (e->src == p)\n+\tfor (e = s->pred; e; e = e->pred_next)\n+\t  if (e->src == p)\n \t    {\n \t      found_edge = 1;\n \t      break;\n \t    }\n-        if (EDGE_INDEX (elist, BASIC_BLOCK (pred), BASIC_BLOCK (succ)) \n+\tif (EDGE_INDEX (elist, BASIC_BLOCK (pred), BASIC_BLOCK (succ))\n \t    == EDGE_INDEX_NO_EDGE && found_edge != 0)\n \t  fprintf (f, \"*** Edge (%d, %d) appears to not have an index\\n\",\n-\t  \t   pred, succ);\n-        if (EDGE_INDEX (elist, BASIC_BLOCK (pred), BASIC_BLOCK (succ)) \n+\t\t   pred, succ);\n+\tif (EDGE_INDEX (elist, BASIC_BLOCK (pred), BASIC_BLOCK (succ))\n \t    != EDGE_INDEX_NO_EDGE && found_edge == 0)\n \t  fprintf (f, \"*** Edge (%d, %d) has index %d, but there is no edge\\n\",\n-\t  \t   pred, succ, EDGE_INDEX (elist, BASIC_BLOCK (pred), \n+\t  \t   pred, succ, EDGE_INDEX (elist, BASIC_BLOCK (pred),\n \t\t\t\t\t   BASIC_BLOCK (succ)));\n       }\n-    for (succ = 0 ; succ < n_basic_blocks; succ++)\n-      {\n-        basic_block p = ENTRY_BLOCK_PTR;\n-        basic_block s = BASIC_BLOCK (succ);\n+  for (succ = 0; succ < n_basic_blocks; succ++)\n+    {\n+      basic_block p = ENTRY_BLOCK_PTR;\n+      basic_block s = BASIC_BLOCK (succ);\n \n-        int found_edge = 0;\n+      int found_edge = 0;\n \n-        for (e = p->succ; e; e = e->succ_next)\n-          if (e->dest == s)\n-\t    {\n-\t      found_edge = 1;\n-\t      break;\n-\t    }\n-        for (e = s->pred; e; e = e->pred_next)\n-          if (e->src == p)\n-\t    {\n-\t      found_edge = 1;\n-\t      break;\n-\t    }\n-        if (EDGE_INDEX (elist, ENTRY_BLOCK_PTR, BASIC_BLOCK (succ)) \n-\t    == EDGE_INDEX_NO_EDGE && found_edge != 0)\n-\t  fprintf (f, \"*** Edge (entry, %d) appears to not have an index\\n\",\n-\t  \t   succ);\n-        if (EDGE_INDEX (elist, ENTRY_BLOCK_PTR, BASIC_BLOCK (succ)) \n-\t    != EDGE_INDEX_NO_EDGE && found_edge == 0)\n-\t  fprintf (f, \"*** Edge (entry, %d) has index %d, but no edge exists\\n\",\n-\t  \t   succ, EDGE_INDEX (elist, ENTRY_BLOCK_PTR, \n-\t\t\t\t     BASIC_BLOCK (succ)));\n-      }\n-    for (pred = 0 ; pred < n_basic_blocks; pred++)\n-      {\n-        basic_block p = BASIC_BLOCK (pred);\n-        basic_block s = EXIT_BLOCK_PTR;\n+      for (e = p->succ; e; e = e->succ_next)\n+\tif (e->dest == s)\n+\t  {\n+\t    found_edge = 1;\n+\t    break;\n+\t  }\n+      for (e = s->pred; e; e = e->pred_next)\n+\tif (e->src == p)\n+\t  {\n+\t    found_edge = 1;\n+\t    break;\n+\t  }\n+      if (EDGE_INDEX (elist, ENTRY_BLOCK_PTR, BASIC_BLOCK (succ))\n+\t  == EDGE_INDEX_NO_EDGE && found_edge != 0)\n+\tfprintf (f, \"*** Edge (entry, %d) appears to not have an index\\n\",\n+\t\t succ);\n+      if (EDGE_INDEX (elist, ENTRY_BLOCK_PTR, BASIC_BLOCK (succ))\n+\t  != EDGE_INDEX_NO_EDGE && found_edge == 0)\n+\tfprintf (f, \"*** Edge (entry, %d) has index %d, but no edge exists\\n\",\n+\t\t succ, EDGE_INDEX (elist, ENTRY_BLOCK_PTR,\n+\t\t\t\t   BASIC_BLOCK (succ)));\n+    }\n+  for (pred = 0; pred < n_basic_blocks; pred++)\n+    {\n+      basic_block p = BASIC_BLOCK (pred);\n+      basic_block s = EXIT_BLOCK_PTR;\n \n-        int found_edge = 0;\n+      int found_edge = 0;\n \n-        for (e = p->succ; e; e = e->succ_next)\n-          if (e->dest == s)\n-\t    {\n-\t      found_edge = 1;\n-\t      break;\n-\t    }\n-        for (e = s->pred; e; e = e->pred_next)\n-          if (e->src == p)\n-\t    {\n-\t      found_edge = 1;\n-\t      break;\n-\t    }\n-        if (EDGE_INDEX (elist, BASIC_BLOCK (pred), EXIT_BLOCK_PTR) \n-\t    == EDGE_INDEX_NO_EDGE && found_edge != 0)\n-\t  fprintf (f, \"*** Edge (%d, exit) appears to not have an index\\n\",\n-\t  \t   pred);\n-        if (EDGE_INDEX (elist, BASIC_BLOCK (pred), EXIT_BLOCK_PTR) \n-\t    != EDGE_INDEX_NO_EDGE && found_edge == 0)\n-\t  fprintf (f, \"*** Edge (%d, exit) has index %d, but no edge exists\\n\",\n-\t  \t   pred, EDGE_INDEX (elist, BASIC_BLOCK (pred), \n-\t\t\t\t     EXIT_BLOCK_PTR));\n-      }\n+      for (e = p->succ; e; e = e->succ_next)\n+\tif (e->dest == s)\n+\t  {\n+\t    found_edge = 1;\n+\t    break;\n+\t  }\n+      for (e = s->pred; e; e = e->pred_next)\n+\tif (e->src == p)\n+\t  {\n+\t    found_edge = 1;\n+\t    break;\n+\t  }\n+      if (EDGE_INDEX (elist, BASIC_BLOCK (pred), EXIT_BLOCK_PTR)\n+\t  == EDGE_INDEX_NO_EDGE && found_edge != 0)\n+\tfprintf (f, \"*** Edge (%d, exit) appears to not have an index\\n\",\n+\t\t pred);\n+      if (EDGE_INDEX (elist, BASIC_BLOCK (pred), EXIT_BLOCK_PTR)\n+\t  != EDGE_INDEX_NO_EDGE && found_edge == 0)\n+\tfprintf (f, \"*** Edge (%d, exit) has index %d, but no edge exists\\n\",\n+\t\t pred, EDGE_INDEX (elist, BASIC_BLOCK (pred),\n+\t\t\t\t   EXIT_BLOCK_PTR));\n+    }\n }\n \n /* This routine will determine what, if any, edge there is between\n    a specified predecessor and successor.  */\n+\n int\n find_edge_index (edge_list, pred, succ)\n      struct edge_list *edge_list;\n@@ -6931,6 +6938,7 @@ find_edge_index (edge_list, pred, succ)\n }\n \n /* This function will remove an edge from the flow graph.  */\n+\n void\n remove_edge (e)\n      edge e;\n@@ -6968,12 +6976,13 @@ remove_edge (e)\n /* This routine will remove any fake successor edges for a basic block.\n    When the edge is removed, it is also removed from whatever predecessor\n    list it is in.  */\n+\n static void\n remove_fake_successors (bb)\n      basic_block bb;\n {\n   edge e;\n-  for (e = bb->succ; e ; )\n+  for (e = bb->succ; e;)\n     {\n       edge tmp = e;\n       e = e->succ_next;\n@@ -6985,6 +6994,7 @@ remove_fake_successors (bb)\n /* This routine will remove all fake edges from the flow graph.  If\n    we remove all fake successors, it will automatically remove all\n    fake predecessors.  */\n+\n void\n remove_fake_edges ()\n {\n@@ -7000,6 +7010,7 @@ remove_fake_edges ()\n /* This function will add a fake edge between any block which has no\n    successors, and the exit block. Some data flow equations require these\n    edges to exist.  */\n+\n void\n add_noreturn_fake_exit_edges ()\n {\n@@ -7019,20 +7030,21 @@ add_noreturn_fake_exit_edges ()\n    The current implementation is ugly, not attempting to minimize the\n    number of inserted fake edges.  To reduce the number of fake edges\n    to insert, add fake edges from _innermost_ loops containing only\n-   nodes not reachable from the exit block. */\n+   nodes not reachable from the exit block.  */\n+\n void\n connect_infinite_loops_to_exit ()\n {\n   basic_block unvisited_block;\n \n   /* Perform depth-first search in the reverse graph to find nodes\n-     reachable from the exit block. */\n+     reachable from the exit block.  */\n   struct depth_first_search_dsS dfs_ds;\n \n   flow_dfs_compute_reverse_init (&dfs_ds);\n   flow_dfs_compute_reverse_add_bb (&dfs_ds, EXIT_BLOCK_PTR);\n-  \n-  /* Repeatedly add fake edges, updating the unreachable nodes. */\n+\n+  /* Repeatedly add fake edges, updating the unreachable nodes.  */\n   while (1)\n     {\n       unvisited_block = flow_dfs_compute_reverse_execute (&dfs_ds);\n@@ -7048,6 +7060,7 @@ connect_infinite_loops_to_exit ()\n }\n \n /* Redirect an edge's successor from one block to another.  */\n+\n void\n redirect_edge_succ (e, new_succ)\n      edge e;\n@@ -7056,7 +7069,7 @@ redirect_edge_succ (e, new_succ)\n   edge *pe;\n \n   /* Disconnect the edge from the old successor block.  */\n-  for (pe = &e->dest->pred; *pe != e ; pe = &(*pe)->pred_next)\n+  for (pe = &e->dest->pred; *pe != e; pe = &(*pe)->pred_next)\n     continue;\n   *pe = (*pe)->pred_next;\n \n@@ -7067,6 +7080,7 @@ redirect_edge_succ (e, new_succ)\n }\n \n /* Redirect an edge's predecessor from one block to another.  */\n+\n void\n redirect_edge_pred (e, new_pred)\n      edge e;\n@@ -7075,7 +7089,7 @@ redirect_edge_pred (e, new_pred)\n   edge *pe;\n \n   /* Disconnect the edge from the old predecessor block.  */\n-  for (pe = &e->src->succ; *pe != e ; pe = &(*pe)->succ_next)\n+  for (pe = &e->src->succ; *pe != e; pe = &(*pe)->succ_next)\n     continue;\n   *pe = (*pe)->succ_next;\n \n@@ -7086,7 +7100,8 @@ redirect_edge_pred (e, new_pred)\n }\n \f\n /* Dump the list of basic blocks in the bitmap NODES.  */\n-static void \n+\n+static void\n flow_nodes_print (str, nodes, file)\n      const char *str;\n      const sbitmap nodes;\n@@ -7099,9 +7114,9 @@ flow_nodes_print (str, nodes, file)\n   fputs (\"}\\n\", file);\n }\n \n-\n /* Dump the list of exiting edges in the array EDGES.  */\n-static void \n+\n+static void\n flow_exits_print (str, edges, num_edges, file)\n      const char *str;\n      const edge *edges;\n@@ -7116,8 +7131,8 @@ flow_exits_print (str, edges, num_edges, file)\n   fputs (\"}\\n\", file);\n }\n \n-\n /* Dump loop related CFG information.  */\n+\n static void\n flow_loops_cfg_dump (loops, file)\n      const struct loops *loops;\n@@ -7135,10 +7150,9 @@ flow_loops_cfg_dump (loops, file)\n       fprintf (file, \";; %d succs { \", i);\n       for (succ = BASIC_BLOCK (i)->succ; succ; succ = succ->succ_next)\n \tfprintf (file, \"%d \", succ->dest->index);\n-      flow_nodes_print (\"} dom\", loops->cfg.dom[i], file);\t\n+      flow_nodes_print (\"} dom\", loops->cfg.dom[i], file);\n     }\n \n-\n   /* Dump the DFS node order.  */\n   if (loops->cfg.dfs_order)\n     {\n@@ -7157,8 +7171,8 @@ flow_loops_cfg_dump (loops, file)\n     }\n }\n \n-\n /* Return non-zero if the nodes of LOOP are a subset of OUTER.  */\n+\n static int\n flow_loop_nested_p (outer, loop)\n      struct loop *outer;\n@@ -7167,9 +7181,9 @@ flow_loop_nested_p (outer, loop)\n   return sbitmap_a_subset_b_p (loop->nodes, outer->nodes);\n }\n \n-\n /* Dump the loop information specified by LOOPS to the stream FILE.  */\n-void \n+\n+void\n flow_loops_dump (loops, file, verbose)\n      const struct loops *loops;\n      FILE *file;\n@@ -7182,7 +7196,7 @@ flow_loops_dump (loops, file, verbose)\n   if (! num_loops || ! file)\n     return;\n \n-  fprintf (file, \";; %d loops found, %d levels\\n\", \n+  fprintf (file, \";; %d loops found, %d levels\\n\",\n \t   num_loops, loops->levels);\n \n   for (i = 0; i < num_loops; i++)\n@@ -7192,7 +7206,7 @@ flow_loops_dump (loops, file, verbose)\n       fprintf (file, \";; loop %d (%d to %d):\\n;;   header %d, latch %d, pre-header %d, depth %d, level %d, outer %ld\\n\",\n \t       i, INSN_UID (loop->header->head), INSN_UID (loop->latch->end),\n \t       loop->header->index, loop->latch->index,\n-\t       loop->pre_header ? loop->pre_header->index : -1, \n+\t       loop->pre_header ? loop->pre_header->index : -1,\n \t       loop->depth, loop->level,\n \t       (long) (loop->outer ? (loop->outer - loops->array) : -1));\n       fprintf (file, \";;   %d\", loop->num_nodes);\n@@ -7220,7 +7234,7 @@ flow_loops_dump (loops, file, verbose)\n \t\t     must be disjoint.  */\n \t\t  disjoint = ! flow_loop_nested_p (smaller ? loop : oloop,\n \t\t\t\t\t\t   smaller ? oloop : loop);\n-\t\t  fprintf (file, \n+\t\t  fprintf (file,\n \t\t\t   \";; loop header %d shared by loops %d, %d %s\\n\",\n \t\t\t   loop->header->index, i, j,\n \t\t\t   disjoint ? \"disjoint\" : \"nested\");\n@@ -7235,7 +7249,7 @@ flow_loops_dump (loops, file, verbose)\n \t  if (GET_CODE (PREV_INSN (loop->first->head)) != NOTE\n \t      || NOTE_LINE_NUMBER (PREV_INSN (loop->first->head))\n \t      != NOTE_INSN_LOOP_BEG)\n-\t    fprintf (file, \";; No NOTE_INSN_LOOP_BEG at %d\\n\", \n+\t    fprintf (file, \";; No NOTE_INSN_LOOP_BEG at %d\\n\",\n \t\t     INSN_UID (PREV_INSN (loop->first->head)));\n \t  if (GET_CODE (NEXT_INSN (loop->last->end)) != NOTE\n \t      || NOTE_LINE_NUMBER (NEXT_INSN (loop->last->end))\n@@ -7249,11 +7263,11 @@ flow_loops_dump (loops, file, verbose)\n     flow_loops_cfg_dump (loops, file);\n }\n \n-\n /* Free all the memory allocated for LOOPS.  */\n-void \n+\n+void\n flow_loops_free (loops)\n-       struct loops *loops;\n+     struct loops *loops;\n {\n   if (loops->array)\n     {\n@@ -7266,15 +7280,15 @@ flow_loops_free (loops)\n       for (i = 0; i < loops->num; i++)\n \t{\n \t  struct loop *loop = &loops->array[i];\n-\t  \n+\n \t  if (loop->nodes)\n \t    sbitmap_free (loop->nodes);\n \t  if (loop->exits)\n \t    free (loop->exits);\n \t}\n       free (loops->array);\n       loops->array = NULL;\n-      \n+\n       if (loops->cfg.dom)\n \tsbitmap_vector_free (loops->cfg.dom);\n       if (loops->cfg.dfs_order)\n@@ -7284,10 +7298,10 @@ flow_loops_free (loops)\n     }\n }\n \n-\n /* Find the exits from the loop using the bitmap of loop nodes NODES\n    and store in EXITS array.  Return the number of exits from the\n    loop.  */\n+\n static int\n flow_loop_exits_find (nodes, exits)\n      const sbitmap nodes;\n@@ -7306,7 +7320,7 @@ flow_loop_exits_find (nodes, exits)\n   EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, node, {\n     for (e = BASIC_BLOCK (node)->succ; e; e = e->succ_next)\n       {\n-\tbasic_block dest = e->dest;\t  \n+\tbasic_block dest = e->dest;\n \n \tif (dest == EXIT_BLOCK_PTR || ! TEST_BIT (nodes, dest->index))\n \t    num_exits++;\n@@ -7323,7 +7337,7 @@ flow_loop_exits_find (nodes, exits)\n   EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, node, {\n     for (e = BASIC_BLOCK (node)->succ; e; e = e->succ_next)\n       {\n-\tbasic_block dest = e->dest;\t  \n+\tbasic_block dest = e->dest;\n \n \tif (dest == EXIT_BLOCK_PTR || ! TEST_BIT (nodes, dest->index))\n \t  (*exits)[num_exits++] = e;\n@@ -7333,11 +7347,11 @@ flow_loop_exits_find (nodes, exits)\n   return num_exits;\n }\n \n-\n /* Find the nodes contained within the loop with header HEADER and\n    latch LATCH and store in NODES.  Return the number of nodes within\n    the loop.  */\n-static int \n+\n+static int\n flow_loop_nodes_find (header, latch, nodes)\n      basic_block header;\n      basic_block latch;\n@@ -7374,7 +7388,7 @@ flow_loop_nodes_find (header, latch, nodes)\n       for (e = node->pred; e; e = e->pred_next)\n \t{\n \t  basic_block ancestor = e->src;\n-\t  \n+\n \t  /* If each ancestor not marked as part of loop, add to set of\n \t     loop nodes and push on to stack.  */\n \t  if (ancestor != ENTRY_BLOCK_PTR\n@@ -7391,13 +7405,13 @@ flow_loop_nodes_find (header, latch, nodes)\n   return num_nodes;\n }\n \n-\n /* Compute the depth first search order and store in the array\n   DFS_ORDER if non-zero, marking the nodes visited in VISITED.  If\n   RC_ORDER is non-zero, return the reverse completion number for each\n   node.  Returns the number of nodes visited.  A depth first search\n   tries to get as far away from the starting point as quickly as\n   possible.  */\n+\n static int\n flow_depth_first_order_compute (dfs_order, rc_order)\n      int *dfs_order;\n@@ -7418,7 +7432,7 @@ flow_depth_first_order_compute (dfs_order, rc_order)\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   sbitmap_zero (visited);\n-  \n+\n   /* Push the first edge on to the stack.  */\n   stack[sp++] = ENTRY_BLOCK_PTR->succ;\n \n@@ -7432,40 +7446,40 @@ flow_depth_first_order_compute (dfs_order, rc_order)\n       e = stack[sp - 1];\n       src = e->src;\n       dest = e->dest;\n-      \n+\n       /* Check if the edge destination has been visited yet.  */\n       if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n \t{\n \t  /* Mark that we have visited the destination.  */\n \t  SET_BIT (visited, dest->index);\n-\t  \n+\n \t  if (dfs_order)\n \t    dfs_order[dfsnum++] = dest->index;\n \n- \t  if (dest->succ)\n- \t    {\n- \t      /* Since the DEST node has been visited for the first\n- \t\t time, check its successors.  */\n- \t      stack[sp++] = dest->succ;\n- \t    }\n- \t  else\n- \t    {\n- \t      /* There are no successors for the DEST node so assign\n- \t\t its reverse completion number.  */\n+\t  if (dest->succ)\n+\t    {\n+\t      /* Since the DEST node has been visited for the first\n+\t\t time, check its successors.  */\n+\t      stack[sp++] = dest->succ;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* There are no successors for the DEST node so assign\n+\t\t its reverse completion number.  */\n \t      if (rc_order)\n \t\trc_order[rcnum--] = dest->index;\n- \t    }\n+\t    }\n \t}\n       else\n \t{\n \t  if (! e->succ_next && src != ENTRY_BLOCK_PTR)\n-  \t    {\n- \t      /* There are no more successors for the SRC node\n- \t\t so assign its reverse completion number.  */\n+\t    {\n+\t      /* There are no more successors for the SRC node\n+\t\t so assign its reverse completion number.  */\n \t      if (rc_order)\n \t\trc_order[rcnum--] = src->index;\n-  \t    }\n-\t  \n+\t    }\n+\n \t  if (e->succ_next)\n \t    stack[sp - 1] = e->succ_next;\n \t  else\n@@ -7487,7 +7501,6 @@ flow_depth_first_order_compute (dfs_order, rc_order)\n   return dfsnum;\n }\n \n-\n /* Compute the depth first search order on the _reverse_ graph and\n    store in the array DFS_ORDER, marking the nodes visited in VISITED.\n    Returns the number of nodes visited.\n@@ -7510,7 +7523,7 @@ flow_depth_first_order_compute (dfs_order, rc_order)\n    Thus, the user will probably call ..._init(), call ..._add_bb() to\n    add a beginning basic block to the stack, call ..._execute(),\n    possibly add another bb to the stack and again call ..._execute(),\n-   ..., and finally call _finish(). */\n+   ..., and finally call _finish().  */\n \n /* Initialize the data structures used for depth-first search on the\n    reverse graph.  If INITIALIZE_STACK is nonzero, the exit block is\n@@ -7524,13 +7537,12 @@ flow_dfs_compute_reverse_init (data)\n {\n   /* Allocate stack for back-tracking up CFG.  */\n   data->stack =\n-    (basic_block *) xmalloc ((n_basic_blocks - (INVALID_BLOCK+1)) \n+    (basic_block *) xmalloc ((n_basic_blocks - (INVALID_BLOCK + 1))\n \t\t\t     * sizeof (basic_block));\n   data->sp = 0;\n \n   /* Allocate bitmap to track nodes that have been visited.  */\n-  data->visited_blocks \n-    = sbitmap_alloc (n_basic_blocks - (INVALID_BLOCK + 1));\n+  data->visited_blocks = sbitmap_alloc (n_basic_blocks - (INVALID_BLOCK + 1));\n \n   /* None of the nodes in the CFG have been visited yet.  */\n   sbitmap_zero (data->visited_blocks);\n@@ -7540,7 +7552,7 @@ flow_dfs_compute_reverse_init (data)\n \n /* Add the specified basic block to the top of the dfs data\n    structures.  When the search continues, it will start at the\n-   block. */\n+   block.  */\n \n static void\n flow_dfs_compute_reverse_add_bb (data, bb)\n@@ -7555,6 +7567,7 @@ flow_dfs_compute_reverse_add_bb (data, bb)\n    with the block at the stack's top and ending when the stack is\n    empty.  Visited nodes are marked.  Returns an unvisited basic\n    block, or NULL if there is none available.  */\n+\n static basic_block\n flow_dfs_compute_reverse_execute (data)\n      depth_first_search_ds data;\n@@ -7567,26 +7580,26 @@ flow_dfs_compute_reverse_execute (data)\n     {\n       bb = data->stack[--data->sp];\n \n-      /* Mark that we have visited this node. */\n-      if (!TEST_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK+1)))\n+      /* Mark that we have visited this node.  */\n+      if (!TEST_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK + 1)))\n \t{\n-\t  SET_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK+1));\n+\t  SET_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK + 1));\n \n-\t  /* Perform depth-first search on adjacent vertices. */\n+\t  /* Perform depth-first search on adjacent vertices.  */\n \t  for (e = bb->pred; e; e = e->pred_next)\n \t    flow_dfs_compute_reverse_add_bb (data, e->src);\n \t}\n     }\n \n-  /* Determine if there are unvisited basic blocks. */\n-  for (i = n_basic_blocks - (INVALID_BLOCK+1); --i >= 0; )\n+  /* Determine if there are unvisited basic blocks.  */\n+  for (i = n_basic_blocks - (INVALID_BLOCK + 1); --i >= 0;)\n     if (!TEST_BIT (data->visited_blocks, i))\n-      return BASIC_BLOCK (i + (INVALID_BLOCK+1));\n+      return BASIC_BLOCK (i + (INVALID_BLOCK + 1));\n   return NULL;\n }\n \n /* Destroy the data structures needed for depth-first search on the\n-   reverse graph. */\n+   reverse graph.  */\n \n static void\n flow_dfs_compute_reverse_finish (data)\n@@ -7600,10 +7613,11 @@ flow_dfs_compute_reverse_finish (data)\n /* Return the block for the pre-header of the loop with header\n    HEADER where DOM specifies the dominator information.  Return NULL if\n    there is no pre-header.  */\n+\n static basic_block\n flow_loop_pre_header_find (header, dom)\n      basic_block header;\n-     const sbitmap *dom;     \n+     const sbitmap *dom;\n {\n   basic_block pre_header;\n   edge e;\n@@ -7614,15 +7628,15 @@ flow_loop_pre_header_find (header, dom)\n   for (e = header->pred; e; e = e->pred_next)\n     {\n       basic_block node = e->src;\n-      \n+\n       if (node != ENTRY_BLOCK_PTR\n \t  && ! TEST_BIT (dom[node->index], header->index))\n \t{\n \t  if (pre_header == NULL)\n \t    pre_header = node;\n \t  else\n \t    {\n-\t      /* There are multiple edges into the header from outside \n+\t      /* There are multiple edges into the header from outside\n \t\t the loop so there is no pre-header block.  */\n \t      pre_header = NULL;\n \t      break;\n@@ -7632,10 +7646,10 @@ flow_loop_pre_header_find (header, dom)\n   return pre_header;\n }\n \n-\n /* Add LOOP to the loop hierarchy tree where PREVLOOP was the loop\n    previously added.  The insertion algorithm assumes that the loops\n    are added in the order found by a depth first search of the CFG.  */\n+\n static void\n flow_loop_tree_node_add (prevloop, loop)\n      struct loop *prevloop;\n@@ -7659,16 +7673,16 @@ flow_loop_tree_node_add (prevloop, loop)\n \t}\n       prevloop = prevloop->outer;\n     }\n-  \n+\n   prevloop->next = loop;\n   loop->outer = NULL;\n }\n \n-\n /* Build the loop hierarchy tree for LOOPS.  */\n+\n static void\n flow_loops_tree_build (loops)\n-       struct loops *loops;\n+     struct loops *loops;\n {\n   int i;\n   int num_loops;\n@@ -7678,7 +7692,7 @@ flow_loops_tree_build (loops)\n     return;\n \n   /* Root the loop hierarchy tree with the first loop found.\n-     Since we used a depth first search this should be the \n+     Since we used a depth first search this should be the\n      outermost loop.  */\n   loops->tree = &loops->array[0];\n   loops->tree->outer = loops->tree->inner = loops->tree->next = NULL;\n@@ -7688,10 +7702,10 @@ flow_loops_tree_build (loops)\n     flow_loop_tree_node_add (&loops->array[i - 1], &loops->array[i]);\n }\n \n-\n /* Helper function to compute loop nesting depth and enclosed loop level\n-   for the natural loop specified by LOOP at the loop depth DEPTH.   \n+   for the natural loop specified by LOOP at the loop depth DEPTH.\n    Returns the loop level.  */\n+\n static int\n flow_loop_level_compute (loop, depth)\n      struct loop *loop;\n@@ -7722,7 +7736,6 @@ flow_loop_level_compute (loop, depth)\n   return level;\n }\n \n-\n /* Compute the loop nesting depth and enclosed loop level for the loop\n    hierarchy tree specfied by LOOPS.  Return the maximum enclosed loop\n    level.  */\n@@ -7745,14 +7758,13 @@ flow_loops_level_compute (loops)\n   return levels;\n }\n \n-\n /* Find all the natural loops in the function and save in LOOPS structure\n    and recalculate loop_depth information in basic block structures.\n    Return the number of natural loops found.  */\n \n-int \n+int\n flow_loops_find (loops)\n-       struct loops *loops;\n+     struct loops *loops;\n {\n   int i;\n   int b;\n@@ -7762,7 +7774,7 @@ flow_loops_find (loops)\n   sbitmap *dom;\n   int *dfs_order;\n   int *rc_order;\n-  \n+\n   loops->num = 0;\n   loops->array = NULL;\n   loops->tree = NULL;\n@@ -7791,7 +7803,7 @@ flow_loops_find (loops)\n       for (e = BASIC_BLOCK (b)->pred; e; e = e->pred_next)\n \t{\n \t  basic_block latch = e->src;\n-\t  \n+\n \t  /* Look for back edges where a predecessor is dominated\n \t     by this block.  A natural loop has a single entry\n \t     node (header) that dominates all the nodes in the\n@@ -7802,7 +7814,7 @@ flow_loops_find (loops)\n \t    num_loops++;\n \t}\n     }\n-  \n+\n   if (num_loops)\n     {\n       /* Compute depth first search order of the CFG so that outer\n@@ -7814,7 +7826,7 @@ flow_loops_find (loops)\n       /* Allocate loop structures.  */\n       loops->array\n \t= (struct loop *) xcalloc (num_loops, sizeof (struct loop));\n-      \n+\n       headers = sbitmap_alloc (n_basic_blocks);\n       sbitmap_zero (headers);\n \n@@ -7831,12 +7843,12 @@ flow_loops_find (loops)\n \t  /* Search the nodes of the CFG in DFS order that we can find\n \t     outer loops first.  */\n \t  header = BASIC_BLOCK (rc_order[b]);\n-\t  \n+\n \t  /* Look for all the possible latch blocks for this header.  */\n \t  for (e = header->pred; e; e = e->pred_next)\n \t    {\n \t      basic_block latch = e->src;\n-\t      \n+\n \t      /* Look for back edges where a predecessor is dominated\n \t\t by this block.  A natural loop has a single entry\n \t\t node (header) that dominates all the nodes in the\n@@ -7847,19 +7859,19 @@ flow_loops_find (loops)\n \t\t  && TEST_BIT (dom[latch->index], header->index))\n \t\t{\n \t\t  struct loop *loop;\n-\t\t  \n+\n \t\t  loop = loops->array + num_loops;\n-\t\t  \n+\n \t\t  loop->header = header;\n \t\t  loop->latch = latch;\n \t\t  loop->num = num_loops;\n-\t\t  \n+\n \t\t  /* Keep track of blocks that are loop headers so\n \t\t     that we can tell which loops should be merged.  */\n \t\t  if (TEST_BIT (headers, header->index))\n \t\t    SET_BIT (loops->shared_headers, header->index);\n \t\t  SET_BIT (headers, header->index);\n-\t\t  \n+\n \t\t  /* Find nodes contained within the loop.  */\n \t\t  loop->nodes = sbitmap_alloc (n_basic_blocks);\n \t\t  loop->num_nodes\n@@ -7872,22 +7884,21 @@ flow_loops_find (loops)\n \t\t  loop->first\n \t\t    = BASIC_BLOCK (sbitmap_first_set_bit (loop->nodes));\n \t\t  loop->last\n-\t\t    = BASIC_BLOCK (sbitmap_last_set_bit (loop->nodes));\t\n-\t  \n+\t\t    = BASIC_BLOCK (sbitmap_last_set_bit (loop->nodes));\n+\n \t\t  /* Find edges which exit the loop.  Note that a node\n \t\t     may have several exit edges.  */\n \t\t  loop->num_exits\n \t\t    = flow_loop_exits_find (loop->nodes, &loop->exits);\n \n \t\t  /* Look to see if the loop has a pre-header node.  */\n-\t\t  loop->pre_header \n-\t\t    = flow_loop_pre_header_find (header, dom);\n+\t\t  loop->pre_header = flow_loop_pre_header_find (header, dom);\n \n \t\t  num_loops++;\n \t\t}\n \t    }\n \t}\n-      \n+\n       /* Natural loops with shared headers may either be disjoint or\n \t nested.  Disjoint loops with shared headers cannot be inner\n \t loops and should be merged.  For now just mark loops that share\n@@ -7916,7 +7927,6 @@ flow_loops_find (loops)\n   return num_loops;\n }\n \n-\n /* Return non-zero if edge E enters header of LOOP from outside of LOOP.  */\n \n int\n@@ -7930,8 +7940,7 @@ flow_loop_outside_edge_p (loop, e)\n     || ! TEST_BIT (loop->nodes, e->src->index);\n }\n \n-\n-/* Clear LOG_LINKS fields of insns in a chain.  \n+/* Clear LOG_LINKS fields of insns in a chain.\n    Also clear the global_live_at_{start,end} fields of the basic block\n    structures.  */\n \n@@ -7978,4 +7987,3 @@ reg_set_to_hard_reg_set (to, from)\n        SET_HARD_REG_BIT (*to, i);\n      });\n }\n-"}]}