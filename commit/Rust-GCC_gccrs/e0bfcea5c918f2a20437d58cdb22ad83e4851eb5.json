{"sha": "e0bfcea5c918f2a20437d58cdb22ad83e4851eb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBiZmNlYTVjOTE4ZjJhMjA0MzdkNThjZGIyMmFkODNlNDg1MWViNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1994-04-08T15:23:06Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1994-04-08T15:23:06Z"}, "message": "Add support for -membedded-pic\n\nFrom-SVN: r6997", "tree": {"sha": "ee8ea3867eb51777f4b5396bd9367b9a0619dce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee8ea3867eb51777f4b5396bd9367b9a0619dce9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0bfcea5c918f2a20437d58cdb22ad83e4851eb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0bfcea5c918f2a20437d58cdb22ad83e4851eb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0bfcea5c918f2a20437d58cdb22ad83e4851eb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0bfcea5c918f2a20437d58cdb22ad83e4851eb5/comments", "author": null, "committer": null, "parents": [{"sha": "8926095fe7324b246adcf31dc78297d8963ed38a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8926095fe7324b246adcf31dc78297d8963ed38a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8926095fe7324b246adcf31dc78297d8963ed38a"}], "stats": {"total": 168, "additions": 156, "deletions": 12}, "files": [{"sha": "19a00cc3ed3140e780cd4cf88b168083ca9e8a77", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bfcea5c918f2a20437d58cdb22ad83e4851eb5/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bfcea5c918f2a20437d58cdb22ad83e4851eb5/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e0bfcea5c918f2a20437d58cdb22ad83e4851eb5", "patch": "@@ -3191,6 +3191,28 @@ override_options ()\n   else\n     mips_abicalls = MIPS_ABICALLS_NO;\n \n+  /* -membedded-pic is a form of PIC code suitable for embedded\n+     systems.  All calls are made using PC relative addressing, and\n+     all data is addressed using the $gp register.  This requires gas,\n+     which does most of the work, and GNU ld, which automatically\n+     expands PC relative calls which are out of range into a longer\n+     instruction sequence.  All gcc really does differently is\n+     generate a different sequence for a switch.  */\n+  if (TARGET_EMBEDDED_PIC)\n+    {\n+      flag_pic = 1;\n+      if (TARGET_ABICALLS)\n+\twarning (\"-membedded-pic and -mabicalls are incompatible\");\n+      if (g_switch_set)\n+\twarning (\"-G and -membedded-pic are incompatible\");\n+      /* Setting mips_section_threshold is not required, because gas\n+\t will force everything to be GP addressable anyhow, but\n+\t setting it will cause gcc to make better estimates of the\n+\t number of instructions required to access a particular data\n+\t item.  */\n+      mips_section_threshold = 0x7fffffff;\n+    }\n+\n   /* -mrnames says to use the MIPS software convention for register\n      names instead of the hardware names (ie, $a0 instead of $4).\n      We do this by switching the names in mips_reg_names, which the\n@@ -3387,6 +3409,7 @@ mips_debugger_offset (addr, offset)\n    'M'  print high-order register of double-word register operand.\n    'C'  print part of opcode for a branch condition.\n    'N'  print part of opcode for a branch condition, inverted.\n+   'S'  X is CODE_LABEL, print with prefix of \"LS\" (for embedded switch).\n    '('\tTurn on .set noreorder\n    ')'\tTurn on .set reorder\n    '['\tTurn on .set noat\n@@ -3569,6 +3592,14 @@ print_operand (file, op, letter)\n \tabort_with_insn (op, \"PRINT_OPERAND, illegal insn for %%N\");\n       }\n \n+  else if (letter == 'S')\n+    {\n+      char buffer[100];\n+\n+      ASM_GENERATE_INTERNAL_LABEL (buffer, \"LS\", CODE_LABEL_NUMBER (op));\n+      assemble_name (file, buffer);\n+    }\n+\n   else if (code == REG)\n     {\n       register int regnum = REGNO (op);"}, {"sha": "175649b6d39bc520bea7fc5080fd2561deebbe4b", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bfcea5c918f2a20437d58cdb22ad83e4851eb5/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bfcea5c918f2a20437d58cdb22ad83e4851eb5/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=e0bfcea5c918f2a20437d58cdb22ad83e4851eb5", "patch": "@@ -254,12 +254,12 @@ extern char\t       *mktemp ();\n #define MASK_HALF_PIC\t0x00000800\t/* Emit OSF-style pic refs to externs*/\n #define MASK_LONG_CALLS\t0x00001000\t/* Always call through a register */\n #define MASK_64BIT\t0x00002000\t/* Use 64 bit GP registers and insns */\n-#define MASK_UNUSED1\t0x00004000\n-#define MASK_UNUSED2\t0x00008000\n-#define MASK_UNUSED3\t0x00010000\n-#define MASK_UNUSED4\t0x00020000\n-#define MASK_UNUSED5\t0x00040000\n-#define MASK_UNUSED6\t0x00080000\n+#define MASK_EMBEDDED_PIC 0x00004000\t/* Generate embedded PIC code */\n+#define MASK_UNUSED1\t0x00008000\n+#define MASK_UNUSED2\t0x00010000\n+#define MASK_UNUSED3\t0x00020000\n+#define MASK_UNUSED4\t0x00040000\n+#define MASK_UNUSED5\t0x00080000\n \n \t\t\t\t\t/* Dummy switches used only in spec's*/\n #define MASK_MIPS_TFILE\t0x00000000\t/* flag for mips-tfile usage */\n@@ -327,6 +327,10 @@ extern char\t       *mktemp ();\n \t\t\t\t\t/* always call through a register */\n #define TARGET_LONG_CALLS\t(target_flags & MASK_LONG_CALLS)\n \n+\t\t\t\t\t/* generate embedded PIC code;\n+\t\t\t\t\t   requires gas.  */\n+#define TARGET_EMBEDDED_PIC\t(target_flags & MASK_EMBEDDED_PIC)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -364,6 +368,8 @@ extern char\t       *mktemp ();\n   {\"no-half-pic\",\t -MASK_HALF_PIC},\t\t\t\t\\\n   {\"long-calls\",\t  MASK_LONG_CALLS},\t\t\t\t\\\n   {\"no-long-calls\",\t -MASK_LONG_CALLS},\t\t\t\t\\\n+  {\"embedded-pic\",\t  MASK_EMBEDDED_PIC},\t\t\t\t\\\n+  {\"no-embedded-pic\",\t -MASK_EMBEDDED_PIC},\t\t\t\t\\\n   {\"debug\",\t\t  MASK_DEBUG},\t\t\t\t\t\\\n   {\"debuga\",\t\t  MASK_DEBUG_A},\t\t\t\t\\\n   {\"debugb\",\t\t  MASK_DEBUG_B},\t\t\t\t\\\n@@ -552,7 +558,8 @@ while (0)\n %{ggdb:-g} %{ggdb0:-g0} %{ggdb1:-g1} %{ggdb2:-g2} %{ggdb3:-g3} \\\n %{gstabs:-g} %{gstabs0:-g0} %{gstabs1:-g1} %{gstabs2:-g2} %{gstabs3:-g3} \\\n %{gstabs+:-g} %{gstabs+0:-g0} %{gstabs+1:-g1} %{gstabs+2:-g2} %{gstabs+3:-g3} \\\n-%{gcoff:-g} %{gcoff0:-g0} %{gcoff1:-g1} %{gcoff2:-g2} %{gcoff3:-g3}\"\n+%{gcoff:-g} %{gcoff0:-g0} %{gcoff1:-g1} %{gcoff2:-g2} %{gcoff3:-g3} \\\n+%{membedded-pic}\"\n \n #else\n /* not GAS */\n@@ -568,7 +575,8 @@ while (0)\n %{ggdb:-g} %{ggdb0:-g0} %{ggdb1:-g1} %{ggdb2:-g2} %{ggdb3:-g3} \\\n %{gstabs:-g} %{gstabs0:-g0} %{gstabs1:-g1} %{gstabs2:-g2} %{gstabs3:-g3} \\\n %{gstabs+:-g} %{gstabs+0:-g0} %{gstabs+1:-g1} %{gstabs+2:-g2} %{gstabs+3:-g3} \\\n-%{gcoff:-g} %{gcoff0:-g0} %{gcoff1:-g1} %{gcoff2:-g2} %{gcoff3:-g3}\"\n+%{gcoff:-g} %{gcoff0:-g0} %{gcoff1:-g1} %{gcoff2:-g2} %{gcoff3:-g3} \\\n+%{membedded-pic}\"\n \n #endif\n #endif\t/* ASM_SPEC */\n@@ -3375,12 +3383,33 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t   VALUE)\n \n /* This is how to output an element of a case-vector that is relative.\n-   This is used for pc-relative code (e.g. when TARGET_ABICALLS).  */\n+   This is used for pc-relative code (e.g. when TARGET_ABICALLS or\n+   TARGET_EMBEDDED_PIC).  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, VALUE, REL)\t\t\t\\\n-  fprintf (STREAM, \"\\t%s\\t$L%d\\n\",\t\t\t\t\t\\\n-\t   TARGET_LONG64 ? \".gpdword\" : \".gpword\",\t\t\t\\\n-\t   VALUE)\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_EMBEDDED_PIC)\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t%s\\t$L%d-$LS%d\\n\",\t\t\t\t\\\n+\t     TARGET_LONG64 ? \".dword\" : \".word\",\t\t\t\\\n+\t     VALUE, REL);\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t%s\\t$L%d\\n\",\t\t\t\t\t\\\n+\t     TARGET_LONG64 ? \".gpdword\" : \".gpword\",\t\t\t\\\n+\t     VALUE);\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* When generating embedded PIC code we want to put the jump table in\n+   the .text section.  In all other cases, we want to put the jump\n+   table in the .rdata section.  Unfortunately, we can't use\n+   JUMP_TABLES_IN_TEXT_SECTION, because it is not conditional.\n+   Instead, we use ASM_OUTPUT_CASE_LABEL to switch back to the .text\n+   section if appropriate.  */\n+#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, INSN)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_EMBEDDED_PIC)\t\t\t\t\t\t\\\n+    text_section ();\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM);\t\t\t\\\n+} while (0)\n \n /* This is how to output an assembler line\n    that says to advance the location counter"}, {"sha": "be9e1512a06b6d7f2b078d68748dfd35908a7e42", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0bfcea5c918f2a20437d58cdb22ad83e4851eb5/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0bfcea5c918f2a20437d58cdb22ad83e4851eb5/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=e0bfcea5c918f2a20437d58cdb22ad83e4851eb5", "patch": "@@ -5410,6 +5410,90 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"1\")])\n \n+;; Implement a switch statement when generating embedded PIC code.\n+;; Switches are implemented by `tablejump' when not using -membedded-pic.\n+\n+(define_expand \"casesi\"\n+  [(set (match_dup 5)\n+\t(minus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t  (match_operand:SI 1 \"arith_operand\" \"dI\")))\n+   (set (cc0)\n+\t(compare:CC (match_dup 5)\n+\t\t    (match_operand:SI 2 \"arith_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 4 \"\" \"\"))\n+\t\t      (pc)))\n+   (parallel\n+    [(set (pc)\n+\t  (mem:SI (plus:SI (mult:SI (match_dup 5)\n+\t\t\t\t    (const_int 4))\n+\t\t\t   (label_ref (match_operand 3 \"\" \"\")))))\n+     (clobber (match_scratch:SI 6 \"\"))\n+     (clobber (reg:SI 31))])]\n+  \"TARGET_EMBEDDED_PIC\"\n+  \"\n+{\n+  /* We need slightly different code for eight byte table entries.  */\n+  if (TARGET_LONG64)\n+    abort ();\n+\n+  if (operands[0])\n+    {\n+      rtx reg = gen_reg_rtx (SImode);\n+\n+      /* The constraints should handle this, but they don't.  */\n+      operands[0] = force_reg (SImode, operands[0]);\n+      if (! arith_operand (operands[1]))\n+\toperands[1] = force_reg (SImode, operands[1]);\n+      if (! arith_operand (operands[2]))\n+\toperands[2] = force_reg (SImode, operands[2]);\n+\n+      /* If the index is too large, go to the default label.  */\n+      emit_insn (gen_subsi3 (reg, operands[0], operands[1]));\n+      emit_insn (gen_cmpsi (reg, operands[2]));\n+      emit_insn (gen_bgtu (operands[4]));\n+\n+      /* Do the PIC jump.  */\n+      emit_insn (gen_casesi_internal (reg, operands[3], gen_reg_rtx (SImode)));\n+\n+      DONE;\n+    }\n+}\")\n+\n+;; An embedded PIC switch statement looks like this:\n+;;\tbal\t$LS1\n+;;\tsll\t$reg,$index,2\n+;; $LS1:\n+;;\taddu\t$reg,$reg,$31\n+;;\tlw\t$reg,$L1-$LS1($reg)\n+;;\taddu\t$reg,$reg,$31\n+;;\tj\t$reg\n+;; $L1:\n+;;\t.word\tcase1-$LS1\n+;;\t.word\tcase2-$LS1\n+;;\t...\n+\n+(define_insn \"casesi_internal\"\n+  [(set (pc)\n+\t(mem:SI (plus:SI (mult:SI (match_operand:SI 0 \"register_operand\" \"d\")\n+\t\t\t\t  (const_int 4))\n+\t\t\t (label_ref (match_operand 1 \"\" \"\")))))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"d\"))\n+   (clobber (reg:SI 31))]\n+  \"TARGET_EMBEDDED_PIC\"\n+  \"*\n+{\n+  output_asm_insn (\\\"%(bal\\\\t%S1\\;sll\\\\t%0,2\\\\n%S1:\\\", operands);\n+  output_asm_insn (\\\"addu\\\\t%0,%0,$31%)\\\", operands);\n+  output_asm_insn (\\\"lw\\\\t%0,%1-%S1(%0)\\;addu\\\\t%0,%0,$31\\\", operands);\n+  return \\\"j\\\\t%0\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"6\")])\n+\n \f\n ;;\n ;;  ...................."}]}