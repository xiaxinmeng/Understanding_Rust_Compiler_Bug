{"sha": "0ea39696e441675fa9c8d2e7dafd5ff6782e241d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVhMzk2OTZlNDQxNjc1ZmE5YzhkMmU3ZGFmZDVmZjY3ODJlMjQxZA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-10-08T17:52:06Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-10-08T17:52:06Z"}, "message": "In libobjc/: 2011-10-08 Richard Frith-Macdonald <rfm@gnu.org> Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2011-10-08  Richard Frith-Macdonald <rfm@gnu.org>\n            Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tPR libobjc/50428\n\t* sendmsg.c (__objc_send_initialize): If a class does not have an\n\t+initialize method, search for an +initialize method in the\n\tsuperclass and in the ancestor classes and execute the first one\n\tthat is found.  This makes the GNU runtime behave in the same way\n\tas the Apple/NeXT runtime with respect to +initialize methods and\n\tsubclassing.\n\nIn gcc/:\n2011-10-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tPR libobjc/50428\n\t* doc/objc.texi (Garbage Collection): Updated example to protect\n\t+initialize against execution in subclasses.\n\nIn gcc/testsuite/:\n2011-10-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\tPR libobjc/50428\t\n\t* objc/execute/initialize-1.m: New test.\n\nFrom-SVN: r179711", "tree": {"sha": "c87aa33515b54b89054895be5d96b1b5bee58c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c87aa33515b54b89054895be5d96b1b5bee58c6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ea39696e441675fa9c8d2e7dafd5ff6782e241d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ea39696e441675fa9c8d2e7dafd5ff6782e241d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ea39696e441675fa9c8d2e7dafd5ff6782e241d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/comments", "author": null, "committer": null, "parents": [{"sha": "30a390c8104f9530cd8721e699deecd823fc4e9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30a390c8104f9530cd8721e699deecd823fc4e9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30a390c8104f9530cd8721e699deecd823fc4e9c"}], "stats": {"total": 103, "additions": 76, "deletions": 27}, "files": [{"sha": "edf17165872dbff7e345b3bc326fd271036538f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ea39696e441675fa9c8d2e7dafd5ff6782e241d", "patch": "@@ -1,3 +1,9 @@\n+2011-10-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR libobjc/50428\n+\t* doc/objc.texi (Garbage Collection): Updated example to protect\n+\t+initialize against execution in subclasses.\n+\n 2011-10-07  Richard Henderson  <rth@redhat.com>\n \n \t* doc/extend.texi (__builtin_shuffle): Improve the description to"}, {"sha": "a36b0e70530472f369d8f081a6a603bda4e630db", "filename": "gcc/doc/objc.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/gcc%2Fdoc%2Fobjc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/gcc%2Fdoc%2Fobjc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fobjc.texi?ref=0ea39696e441675fa9c8d2e7dafd5ff6782e241d", "patch": "@@ -635,7 +635,8 @@ following class does this:\n \n + (void)initialize\n @{\n-  class_ivar_set_gcinvisible (self, \"weakPointer\", YES);\n+  if (self == objc_lookUpClass (\"WeakPointer\"))\n+    class_ivar_set_gcinvisible (self, \"weakPointer\", YES);\n @}\n \n - initWithPointer:(const void*)p"}, {"sha": "74ab91220f5082c642ddf42c4472d0796fcea4fe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ea39696e441675fa9c8d2e7dafd5ff6782e241d", "patch": "@@ -1,3 +1,8 @@\n+2011-10-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR libobjc/50428\t\n+\t* objc/execute/initialize-1.m: New test.\n+\n 2011-10-08  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/47844"}, {"sha": "9ca4aebbe697ea66cd6837f0468195c05159db5c", "filename": "gcc/testsuite/objc/execute/initialize-1.m", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Finitialize-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Finitialize-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc%2Fexecute%2Finitialize-1.m?ref=0ea39696e441675fa9c8d2e7dafd5ff6782e241d", "patch": "@@ -0,0 +1,47 @@\n+/* Contributed by Nicola Pero - Sat  8 Oct 2011 16:47:48 BST */\n+#include <objc/objc.h>\n+\n+/* Test that if a class has no +initialize method, the superclass\n+   implementation is called.  */\n+\n+static int class_variable = 0;\n+\n+@interface TestClass\n+{\n+  Class isa;\n+}\n++ (void) initialize;\n++ (int) classVariable;\n+@end\n+\n+@implementation TestClass\n++ (void) initialize\n+{\n+  class_variable++;\n+}\n++ (int) classVariable\n+{\n+  return class_variable;\n+}\n+@end\n+\n+@interface TestSubClass : TestClass\n+@end\n+\n+@implementation TestSubClass\n+@end\n+\n+int main (void)\n+{\n+  if ([TestClass classVariable] != 1)\n+    {\n+      abort ();\n+    }\n+\n+  if ([TestSubClass classVariable] != 2)\n+    {\n+      abort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "f88f2f45cdf682aeb4c99dc38a2fc40be5986434", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=0ea39696e441675fa9c8d2e7dafd5ff6782e241d", "patch": "@@ -1,3 +1,14 @@\n+2011-10-08  Richard Frith-Macdonald <rfm@gnu.org>\n+            Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR libobjc/50428\n+\t* sendmsg.c (__objc_send_initialize): If a class does not have an\n+\t+initialize method, search for an +initialize method in the\n+\tsuperclass and in the ancestor classes and execute the first one\n+\tthat is found.  This makes the GNU runtime behave in the same way\n+\tas the Apple/NeXT runtime with respect to +initialize methods and\n+\tsubclassing.\n+\n 2011-08-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR libobjc/50002"}, {"sha": "ea8ea9702628460e947356df0ef34a284d8e86c4", "filename": "libobjc/sendmsg.c", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ea39696e441675fa9c8d2e7dafd5ff6782e241d/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=0ea39696e441675fa9c8d2e7dafd5ff6782e241d", "patch": "@@ -516,34 +516,13 @@ __objc_send_initialize (Class class)\n \n       {\n \tSEL op = sel_registerName (\"initialize\");\n-\tIMP imp = 0;\n-        struct objc_method_list * method_list = class->class_pointer->methods;\n-\t\n-        while (method_list)\n-\t  {\n-\t    int i;\n-\t    struct objc_method * method;\n-\t    \n-\t    for (i = 0; i < method_list->method_count; i++)\n-\t      {\n-\t\tmethod = &(method_list->method_list[i]);\n-\t\tif (method->method_name\n-\t\t    && method->method_name->sel_id == op->sel_id)\n-\t\t  {\n-\t\t    imp = method->method_imp;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    \n-\t    if (imp)\n-\t      break;\n-\t    \n-\t    method_list = method_list->method_next;\n-\t  }\n-\tif (imp)\n+        struct objc_method *method = search_for_method_in_hierarchy (class->class_pointer, \n+\t\t\t\t\t\t\t\t     op);\n+\n+\tif (method)\n \t  {\n \t    DEBUG_PRINTF (\" begin of [%s +initialize]\\n\", class->name);\n-\t    (*imp) ((id) class, op);\n+\t    (*method->method_imp) ((id)class, op);\n \t    DEBUG_PRINTF (\" end of [%s +initialize]\\n\", class->name);\n \t  }\n #ifdef DEBUG"}]}