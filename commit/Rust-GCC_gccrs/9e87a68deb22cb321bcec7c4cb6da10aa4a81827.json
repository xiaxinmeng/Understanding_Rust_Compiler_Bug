{"sha": "9e87a68deb22cb321bcec7c4cb6da10aa4a81827", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU4N2E2OGRlYjIyY2IzMjFiY2VjN2M0Y2I2ZGExMGFhNGE4MTgyNw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-04-06T09:27:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:27:31Z"}, "message": "sem_util.ads, [...] (Object_Access_Level): If the object is a dereference of a local object R created as a reference to...\n\n2007-04-06  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_util.ads, sem_util.adb (Object_Access_Level): If the object is a\n\tdereference of a local object R created as a reference to another\n\tobject O, use the access level of O.\n\t(Matches_Prefixed_View_Profile): Use common predicate Conforming_Types,\n\trather than local Same_Formal_Type, to check whether protected operation\n\toverrides an inherited one.\n\t(Same_Formal_Type): New predicate, used when matching signatures of\n\toverriding synchronized operations, to handle the case when a formal\n\thas a type that is a generic actual.\n\t(Is_Aliased_View): Replace check on E_Task_Type and E_Protected_Type by\n\tpredicate Is_Concurrent_Type. This ensures supportin case of subtypes.\n\t(Needs_One_Actual): New predicate, for Ada 2005 use, to resolve\n\tsyntactic ambiguities involving indexing of function calls that return\n\tarrays.\n\t(Abstract_Interface_List): New subprogram that returns the list of\n\tabstract interfaces associated with a concurrent type or a\n\tconcurrent record type.\n\t(Interface_Present_In_Parent): New subprogram used to check if a\n\tgiven type or some of its parents implement a given interface.\n\t(Collect_Abstract_Interfaces): Add support for concurrent types\n\twith interface types.\n\t(Has_Abstract_Interfaces): Add support for concurrent types with\n\tinterface types.\n\t(Is_Parent): New subprogram that determines whether E1 is a parent\n\tof E2. For a concurrent type its parent is the first element of its\n\tlist of interface types; for other types this function provides the\n\tsame result than Is_Ancestor.\n\t(Enclosing_Subprogram): Add test for N_Extended_Return_Statement.\n\t(Collect_Synchronized_Interfaces): Removed because the subprogram\n\tCollect_Abstract_Interfaces provides this functionality.\n\t(Collect_Abstract_Interfaces): Minor update to give support to\n\tconcurrent types and thus avoid undesired code duplication.\n\t(Get_Subprogram_Entity): Handle entry calls.\n\t(May_Be_Lvalue): Include actuals that appear as in-out parameters in\n\tentry calls.\n\t(Enter_Name): Do not give -gnatwh hiding warning for record component\n\tentities, they never result in hiding.\n\nFrom-SVN: r123599", "tree": {"sha": "eb9c40cea3470f325e78592e175019e723d1e012", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb9c40cea3470f325e78592e175019e723d1e012"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e87a68deb22cb321bcec7c4cb6da10aa4a81827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e87a68deb22cb321bcec7c4cb6da10aa4a81827", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e87a68deb22cb321bcec7c4cb6da10aa4a81827", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e87a68deb22cb321bcec7c4cb6da10aa4a81827/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3aba5ed58e7dec4dd58f9a324cee4ad85fa73dd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aba5ed58e7dec4dd58f9a324cee4ad85fa73dd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aba5ed58e7dec4dd58f9a324cee4ad85fa73dd8"}], "stats": {"total": 448, "additions": 287, "deletions": 161}, "files": [{"sha": "f623f16fc6b56bb415aa916d531833734206c622", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 267, "deletions": 152, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e87a68deb22cb321bcec7c4cb6da10aa4a81827/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e87a68deb22cb321bcec7c4cb6da10aa4a81827/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9e87a68deb22cb321bcec7c4cb6da10aa4a81827", "patch": "@@ -45,6 +45,7 @@ with Rtsfind;  use Rtsfind;\n with Scans;    use Scans;\n with Scn;      use Scn;\n with Sem;      use Sem;\n+with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -84,6 +85,58 @@ package body Sem_Util is\n    --  T is a derived tagged type. Check whether the type extension is null.\n    --  If the parent type is fully initialized, T can be treated as such.\n \n+   ------------------------------\n+   --  Abstract_Interface_List --\n+   ------------------------------\n+\n+   function Abstract_Interface_List (Typ : Entity_Id) return List_Id is\n+      Nod : Node_Id;\n+\n+   begin\n+      if Is_Concurrent_Type (Typ) then\n+         Nod := Parent (Typ);\n+\n+      elsif Ekind (Typ) = E_Record_Type_With_Private then\n+         if Nkind (Parent (Typ)) = N_Full_Type_Declaration then\n+            Nod := Type_Definition (Parent (Typ));\n+\n+         elsif Nkind (Parent (Typ)) = N_Private_Type_Declaration then\n+            if Present (Full_View (Typ)) then\n+               Nod := Type_Definition (Parent (Full_View (Typ)));\n+\n+            --  If the full-view is not available we cannot do anything\n+            --  else here (the source has errors)\n+\n+            else\n+               return Empty_List;\n+            end if;\n+\n+         --  The support for generic formals with interfaces is still\n+         --  missing???\n+\n+         elsif Nkind (Parent (Typ)) = N_Formal_Type_Declaration then\n+            return Empty_List;\n+\n+         else\n+            pragma Assert\n+              (Nkind (Parent (Typ)) = N_Private_Extension_Declaration);\n+            Nod := Parent (Typ);\n+         end if;\n+\n+      elsif Ekind (Typ) = E_Record_Subtype then\n+         Nod := Type_Definition (Parent (Etype (Typ)));\n+\n+      else pragma Assert ((Ekind (Typ)) = E_Record_Type);\n+         if Nkind (Parent (Typ)) = N_Formal_Type_Declaration then\n+            Nod := Formal_Type_Definition (Parent (Typ));\n+         else\n+            Nod := Type_Definition (Parent (Typ));\n+         end if;\n+      end if;\n+\n+      return Interface_List (Nod);\n+   end Abstract_Interface_List;\n+\n    --------------------------------\n    -- Add_Access_Type_To_Process --\n    --------------------------------\n@@ -971,6 +1024,13 @@ package body Sem_Util is\n       --  Subsidiary subprogram used to traverse the whole list\n       --  of directly and indirectly implemented interfaces\n \n+      function Interface_Present_In_Parent\n+         (Typ   : Entity_Id;\n+          Iface : Entity_Id) return Boolean;\n+      --  Typ must be a tagged record type/subtype and Iface must be an\n+      --  abstract interface type. This function is used to check if Typ\n+      --  or some parent of Typ implements Iface.\n+\n       -------------------\n       -- Add_Interface --\n       -------------------\n@@ -994,54 +1054,31 @@ package body Sem_Util is\n       -------------\n \n       procedure Collect (Typ : Entity_Id) is\n-         Ancestor : Entity_Id;\n-         Id       : Node_Id;\n-         Iface    : Entity_Id;\n-         Nod      : Node_Id;\n+         Iface_List : constant List_Id := Abstract_Interface_List (Typ);\n+         Ancestor   : Entity_Id;\n+         Id         : Node_Id;\n+         Iface      : Entity_Id;\n \n       begin\n-         if Ekind (Typ) = E_Record_Type_With_Private then\n-            if Nkind (Parent (Typ)) = N_Full_Type_Declaration then\n-               Nod := Type_Definition (Parent (Typ));\n+         --  Include the ancestor if we are generating the whole list of\n+         --  abstract interfaces.\n \n-            elsif Nkind (Parent (Typ)) = N_Private_Type_Declaration then\n-               if Present (Full_View (Typ)) then\n-                  Nod := Type_Definition (Parent (Full_View (Typ)));\n+         --  In concurrent types the ancestor interface (if any) is the\n+         --  first element of the list of interface types.\n \n-               --  If the full-view is not available we cannot do anything\n-               --  else here (the source has errors)\n+         if Is_Concurrent_Type (Typ)\n+           or else Is_Concurrent_Record_Type (Typ)\n+         then\n+            if Is_Non_Empty_List (Iface_List) then\n+               Ancestor := Etype (First (Iface_List));\n+               Collect (Ancestor);\n \n-               else\n-                  return;\n+               if not Exclude_Parent_Interfaces then\n+                  Add_Interface (Ancestor);\n                end if;\n-\n-            --  The support for generic formals with interfaces is still\n-            --  missing???\n-\n-            elsif Nkind (Parent (Typ)) = N_Formal_Type_Declaration then\n-               return;\n-\n-            else\n-               pragma Assert\n-                 (Nkind (Parent (Typ)) = N_Private_Extension_Declaration);\n-               Nod := Parent (Typ);\n             end if;\n \n-         elsif Ekind (Typ) = E_Record_Subtype then\n-            Nod := Type_Definition (Parent (Etype (Typ)));\n-\n-         else pragma Assert ((Ekind (Typ)) = E_Record_Type);\n-            if Nkind (Parent (Typ)) = N_Formal_Type_Declaration then\n-               Nod := Formal_Type_Definition (Parent (Typ));\n-            else\n-               Nod := Type_Definition (Parent (Typ));\n-            end if;\n-         end if;\n-\n-         --  Include the ancestor if we are generating the whole list of\n-         --  abstract interfaces.\n-\n-         if Etype (Typ) /= Typ\n+         elsif Etype (Typ) /= Typ\n \n             --  Protect the frontend against wrong sources. For example:\n \n@@ -1068,8 +1105,19 @@ package body Sem_Util is\n \n          --  Traverse the graph of ancestor interfaces\n \n-         if Is_Non_Empty_List (Interface_List (Nod)) then\n-            Id := First (Interface_List (Nod));\n+         if Is_Non_Empty_List (Iface_List) then\n+            Id := First (Iface_List);\n+\n+            --  In concurrent types the ancestor interface (if any) is the\n+            --  first element of the list of interface types and we have\n+            --  already processed them while climbing to the root type.\n+\n+            if Is_Concurrent_Type (Typ)\n+              or else Is_Concurrent_Record_Type (Typ)\n+            then\n+               Next (Id);\n+            end if;\n+\n             while Present (Id) loop\n                Iface := Etype (Id);\n \n@@ -1080,7 +1128,7 @@ package body Sem_Util is\n \n                if Is_Interface (Iface) then\n                   if Exclude_Parent_Interfaces\n-                    and then Interface_Present_In_Ancestor (T, Iface)\n+                    and then Interface_Present_In_Parent (T, Iface)\n                   then\n                      null;\n                   else\n@@ -1094,10 +1142,37 @@ package body Sem_Util is\n          end if;\n       end Collect;\n \n+      ---------------------------------\n+      -- Interface_Present_In_Parent --\n+      ---------------------------------\n+\n+      function Interface_Present_In_Parent\n+         (Typ   : Entity_Id;\n+          Iface : Entity_Id) return Boolean\n+      is\n+         Aux        : Entity_Id := Typ;\n+         Iface_List : List_Id;\n+\n+      begin\n+         if Is_Concurrent_Type (Typ)\n+           or else Is_Concurrent_Record_Type (Typ)\n+         then\n+            Iface_List := Abstract_Interface_List (Typ);\n+\n+            if Is_Non_Empty_List (Iface_List) then\n+               Aux := Etype (First (Iface_List));\n+            else\n+               return False;\n+            end if;\n+         end if;\n+\n+         return Interface_Present_In_Ancestor (Aux, Iface);\n+      end Interface_Present_In_Parent;\n+\n    --  Start of processing for Collect_Abstract_Interfaces\n \n    begin\n-      pragma Assert (Is_Tagged_Type (T));\n+      pragma Assert (Is_Tagged_Type (T) or else Is_Concurrent_Type (T));\n       Ifaces_List := New_Elmt_List;\n       Collect (T);\n    end Collect_Abstract_Interfaces;\n@@ -1236,92 +1311,6 @@ package body Sem_Util is\n       return Op_List;\n    end Collect_Primitive_Operations;\n \n-   -------------------------------------\n-   -- Collect_Synchronized_Interfaces --\n-   -------------------------------------\n-\n-   procedure Collect_Synchronized_Interfaces\n-     (Typ         : Entity_Id;\n-      Ifaces_List : out Elist_Id)\n-   is\n-      Iface : Entity_Id;\n-\n-      procedure Collect (Typ : Entity_Id);\n-      --  Gather any parent or progenitor interfaces of type Typ\n-\n-      -------------\n-      -- Collect --\n-      -------------\n-\n-      procedure Collect (Typ : Entity_Id) is\n-         Iface_Elmt : Elmt_Id;\n-\n-         procedure Add (Iface : Entity_Id);\n-         --  Add a single interface to list Ifaces if the interface is\n-         --  not already in the list.\n-\n-         ---------\n-         -- Add --\n-         ---------\n-\n-         procedure Add (Iface : Entity_Id) is\n-            Iface_Elmt : Elmt_Id;\n-\n-         begin\n-            Iface_Elmt := First_Elmt (Ifaces_List);\n-            while Present (Iface_Elmt)\n-              and then Node (Iface_Elmt) /= Iface\n-            loop\n-               Next_Elmt (Iface_Elmt);\n-            end loop;\n-\n-            if No (Iface_Elmt) then\n-               Append_Elmt (Iface, Ifaces_List);\n-            end if;\n-         end Add;\n-\n-      --  Start of processing for Collect\n-\n-      begin\n-         if Is_Interface (Typ) then\n-\n-            --  Potential parent interface\n-\n-            if Etype (Typ) /= Typ then\n-               Collect (Etype (Typ));\n-            end if;\n-\n-            --  Progenitors\n-\n-            if Present (Abstract_Interfaces (Typ)) then\n-               Iface_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n-               while Present (Iface_Elmt) loop\n-                  Collect (Node (Iface_Elmt));\n-                  Next_Elmt (Iface_Elmt);\n-               end loop;\n-            end if;\n-\n-            Add (Typ);\n-         end if;\n-      end Collect;\n-\n-   --  Start of processing for Collect_Synchronized_Interfaces\n-\n-   begin\n-      pragma Assert (Is_Concurrent_Type (Typ));\n-\n-      Ifaces_List := New_Elmt_List;\n-\n-      if Present (Interface_List (Parent (Typ))) then\n-         Iface := First (Interface_List (Parent (Typ)));\n-         while Present (Iface) loop\n-            Collect (Etype (Iface));\n-\n-            Next (Iface);\n-         end loop;\n-      end if;\n-   end Collect_Synchronized_Interfaces;\n-\n    -----------------------------------\n    -- Compile_Time_Constraint_Error --\n    -----------------------------------\n@@ -1945,7 +1934,9 @@ package body Sem_Util is\n       elsif Ekind (Dynamic_Scope) = E_Subprogram_Body then\n          return Corresponding_Spec (Parent (Parent (Dynamic_Scope)));\n \n-      elsif Ekind (Dynamic_Scope) = E_Block then\n+      elsif Ekind (Dynamic_Scope) = E_Block\n+        or else Ekind (Dynamic_Scope) = E_Return_Statement\n+      then\n          return Enclosing_Subprogram (Dynamic_Scope);\n \n       elsif Ekind (Dynamic_Scope) = E_Task_Type then\n@@ -2286,6 +2277,17 @@ package body Sem_Util is\n \n       if Warn_On_Hiding and then Present (C)\n \n+         --  Don't warn for record components since they always have a well\n+         --  defined scope which does not confuse other uses. Note that in\n+         --  some cases, Ekind has not been set yet.\n+\n+         and then Ekind (C) /= E_Component\n+         and then Ekind (C) /= E_Discriminant\n+         and then Nkind (Parent (C)) /= N_Component_Declaration\n+         and then Ekind (Def_Id) /= E_Component\n+         and then Ekind (Def_Id) /= E_Discriminant\n+         and then Nkind (Parent (Def_Id)) /= N_Component_Declaration\n+\n          --  Don't warn for one character variables. It is too common to use\n          --  such variables as locals and will just cause too many false hits.\n \n@@ -3062,6 +3064,17 @@ package body Sem_Util is\n    begin\n       if Nkind (Nod) = N_Accept_Statement then\n          Nam := Entry_Direct_Name (Nod);\n+\n+      --  For an entry call, the prefix of the call is a selected component.\n+      --  Need additional code for internal calls ???\n+\n+      elsif Nkind (Nod) = N_Entry_Call_Statement then\n+         if Nkind (Name (Nod)) = N_Selected_Component then\n+            Nam := Entity (Selector_Name (Name (Nod)));\n+         else\n+            Nam := Empty;\n+         end if;\n+\n       else\n          Nam := Name (Nod);\n       end if;\n@@ -3167,6 +3180,14 @@ package body Sem_Util is\n       pragma Assert (Is_Record_Type (Tagged_Type)\n          and then Is_Tagged_Type (Tagged_Type));\n \n+      --  Handle concurrent record types\n+\n+      if Is_Concurrent_Record_Type (Tagged_Type)\n+        and then Is_Non_Empty_List (Abstract_Interface_List (Tagged_Type))\n+      then\n+         return True;\n+      end if;\n+\n       --  Handle private types\n \n       if Present (Full_View (Tagged_Type)) then\n@@ -3236,17 +3257,13 @@ package body Sem_Util is\n             Comp : Entity_Id;\n \n          begin\n-            Comp := First_Entity (Typ);\n+            Comp := First_Component_Or_Discriminant (Typ);\n             while Present (Comp) loop\n-               if (Ekind (Comp) = E_Component\n-                     or else\n-                   Ekind (Comp) = E_Discriminant)\n-                 and then Has_Access_Values (Etype (Comp))\n-               then\n+               if Has_Access_Values (Etype (Comp)) then\n                   return True;\n                end if;\n \n-               Next_Entity (Comp);\n+               Next_Component_Or_Discriminant (Comp);\n             end loop;\n          end;\n \n@@ -3776,8 +3793,8 @@ package body Sem_Util is\n             --  We are interested only in components and discriminants\n \n             if Ekind (Ent) = E_Component\n-              or else\n-                Ekind (Ent) = E_Discriminant\n+                or else\n+               Ekind (Ent) = E_Discriminant\n             then\n                --  Get default expression if any. If there is no declaration\n                --  node, it means we have an internal entity. The parent and\n@@ -4382,9 +4399,8 @@ package body Sem_Util is\n                       or else Ekind (E) = E_Generic_In_Parameter)\n                     and then Is_Tagged_Type (Etype (E)))\n \n-           or else ((Ekind (E) = E_Task_Type\n-                      or else Ekind (E) = E_Protected_Type)\n-                    and then In_Open_Scopes (E))\n+           or else (Is_Concurrent_Type (E)\n+                     and then In_Open_Scopes (E))\n \n             --  Current instance of type, either directly or as rewritten\n             --  reference to the current object.\n@@ -4394,6 +4410,7 @@ package body Sem_Util is\n                      and then Is_Type (Entity (Original_Node (Obj))))\n \n            or else (Is_Type (E) and then E = Current_Scope)\n+\n            or else (Is_Incomplete_Or_Private_Type (E)\n                      and then Full_View (E) = Current_Scope);\n \n@@ -5259,6 +5276,33 @@ package body Sem_Util is\n       end if;\n    end Is_OK_Variable_For_Out_Formal;\n \n+   ---------------\n+   -- Is_Parent --\n+   ---------------\n+\n+   function Is_Parent\n+     (E1 : Entity_Id;\n+      E2 : Entity_Id) return Boolean\n+   is\n+      Iface_List : List_Id;\n+      T          : Entity_Id := E2;\n+\n+   begin\n+      if Is_Concurrent_Type (T)\n+        or else Is_Concurrent_Record_Type (T)\n+      then\n+         Iface_List := Abstract_Interface_List (E2);\n+\n+         if Is_Empty_List (Iface_List) then\n+            return False;\n+         end if;\n+\n+         T := Etype (First (Iface_List));\n+      end if;\n+\n+      return Is_Ancestor (E1, T);\n+   end Is_Parent;\n+\n    -----------------------------------\n    -- Is_Partially_Initialized_Type --\n    -----------------------------------\n@@ -6241,9 +6285,10 @@ package body Sem_Util is\n          when N_Function_Call =>\n             return False;\n \n-         --  Positional parameter for procedure or accept call\n+         --  Positional parameter for procedure, entry,  or accept call\n \n          when N_Procedure_Call_Statement |\n+              N_Entry_Call_Statement |\n               N_Accept_Statement\n           =>\n             declare\n@@ -6340,6 +6385,33 @@ package body Sem_Util is\n       end case;\n    end May_Be_Lvalue;\n \n+   ----------------------\n+   -- Needs_One_Actual --\n+   ----------------------\n+\n+   function Needs_One_Actual (E : Entity_Id) return Boolean is\n+      Formal : Entity_Id;\n+\n+   begin\n+      if Ada_Version >= Ada_05\n+        and then Present (First_Formal (E))\n+      then\n+         Formal := Next_Formal (First_Formal (E));\n+         while Present (Formal) loop\n+            if No (Default_Value (Formal)) then\n+               return False;\n+            end if;\n+\n+            Next_Formal (Formal);\n+         end loop;\n+\n+         return True;\n+\n+      else\n+         return False;\n+      end if;\n+   end Needs_One_Actual;\n+\n    -------------------------\n    -- New_External_Entity --\n    -------------------------\n@@ -6853,6 +6925,34 @@ package body Sem_Util is\n    --  is not always one is immaterial (invariant: if level(E2) is\n    --  deeper than level(E1), then Scope_Depth(E1) < Scope_Depth(E2)).\n \n+      function Reference_To (Obj : Node_Id) return Node_Id;\n+      --  An explicit dereference is created when removing side-effects\n+      --  from expressions for constraint checking purposes. In this case\n+      --  a local access type is created for it. The correct access level\n+      --  is that of the original source node. We detect this case by\n+      --  noting that the prefix of the dereference is created by an object\n+      --  declaration whose initial expression is a reference.\n+\n+      ------------------\n+      -- Reference_To --\n+      ------------------\n+\n+      function Reference_To (Obj : Node_Id) return Node_Id is\n+         Pref : constant Node_Id := Prefix (Obj);\n+      begin\n+         if Is_Entity_Name (Pref)\n+           and then Nkind (Parent (Entity (Pref))) = N_Object_Declaration\n+           and then Present (Expression (Parent (Entity (Pref))))\n+           and then Nkind (Expression (Parent (Entity (Pref)))) = N_Reference\n+         then\n+            return (Prefix (Expression (Parent (Entity (Pref)))));\n+         else\n+            return Empty;\n+         end if;\n+      end Reference_To;\n+\n+   --  Start of processing for Object_Access_Level\n+\n    begin\n       if Is_Entity_Name (Obj) then\n          E := Entity (Obj);\n@@ -6912,6 +7012,18 @@ package body Sem_Util is\n              Ekind (Entity (Selector_Name (Prefix (Obj)))) = E_Discriminant\n          then\n             return Object_Access_Level (Prefix (Obj));\n+\n+         elsif not (Comes_From_Source (Obj)) then\n+            declare\n+               Ref : constant Node_Id := Reference_To (Obj);\n+            begin\n+               if Present (Ref) then\n+                  return Object_Access_Level (Ref);\n+               else\n+                  return Type_Access_Level (Etype (Prefix (Obj)));\n+               end if;\n+            end;\n+\n          else\n             return Type_Access_Level (Etype (Prefix (Obj)));\n          end if;\n@@ -7044,8 +7156,10 @@ package body Sem_Util is\n             if Ekind (Defining_Identifier (Subp_Param)) /=\n                  Ekind (Defining_Identifier (Over_Param))\n               or else\n-                Etype (Parameter_Type (Subp_Param)) /=\n-                  Etype (Parameter_Type (Over_Param))\n+                not Conforming_Types\n+                  (Etype (Parameter_Type (Subp_Param)),\n+                   Etype (Parameter_Type (Over_Param)),\n+                   Subtype_Conformant)\n             then\n                return False;\n             end if;\n@@ -7083,7 +7197,7 @@ package body Sem_Util is\n          if Ekind (Def_Id) = E_Entry\n            and then Ekind (Candidate) = E_Procedure\n            and then Nkind (Parent (Candidate)) = N_Procedure_Specification\n-           and then (Is_Abstract (Candidate)\n+           and then (Is_Abstract_Subprogram (Candidate)\n                        or else Null_Present (Parent (Candidate)))\n          then\n             while Present (Alias (Candidate)) loop\n@@ -7102,7 +7216,7 @@ package body Sem_Util is\n          elsif Ekind (Def_Id) = E_Procedure\n            and then Ekind (Candidate) = E_Procedure\n            and then Nkind (Parent (Candidate)) = N_Procedure_Specification\n-           and then (Is_Abstract (Candidate)\n+           and then (Is_Abstract_Subprogram (Candidate)\n                        or else Null_Present (Parent (Candidate)))\n            and then Matches_Prefixed_View_Profile\n                       (Parameter_Specifications (Parent (Def_Id)),\n@@ -7115,7 +7229,7 @@ package body Sem_Util is\n          elsif Ekind (Def_Id) = E_Function\n            and then Ekind (Candidate) = E_Function\n            and then Nkind (Parent (Candidate)) = N_Function_Specification\n-           and then Is_Abstract (Candidate)\n+           and then Is_Abstract_Subprogram (Candidate)\n            and then Matches_Prefixed_View_Profile\n                       (Parameter_Specifications (Parent (Def_Id)),\n                        Parameter_Specifications (Parent (Candidate)))\n@@ -7995,6 +8109,7 @@ package body Sem_Util is\n       then\n          Set_Is_Unsigned_Type       (T1, Is_Unsigned_Type          (T2));\n       end if;\n+\n       Set_Alignment                 (T1, Alignment                 (T2));\n    end Set_Size_Info;\n \n@@ -8461,9 +8576,9 @@ package body Sem_Util is\n          else\n             if From_With_Type (Found_Type) then\n                Error_Msg_NE (\"\\\\found incomplete}!\", Expr, Found_Type);\n-               Error_Msg_NE\n-                 (\"\\possibly missing with_clause on&\", Expr,\n-                   Scope (Found_Type));\n+               Error_Msg_Qual_Level := 99;\n+               Error_Msg_NE (\"\\\\missing `WITH &;\", Expr, Scope (Found_Type));\n+               Error_Msg_Qual_Level := 0;\n             else\n                Error_Msg_NE (\"found}!\", Expr, Found_Type);\n             end if;"}, {"sha": "8b6ee893107ad456b8ac92dd716589fae6e3fdea", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e87a68deb22cb321bcec7c4cb6da10aa4a81827/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e87a68deb22cb321bcec7c4cb6da10aa4a81827/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=9e87a68deb22cb321bcec7c4cb6da10aa4a81827", "patch": "@@ -33,6 +33,10 @@ with Urealp; use Urealp;\n \n package Sem_Util is\n \n+   function Abstract_Interface_List (Typ : Entity_Id) return List_Id;\n+   --  Given a type that implements interfaces look for its associated\n+   --  definition node and return its list of interfaces.\n+\n    procedure Add_Access_Type_To_Process (E : Entity_Id; A : Entity_Id);\n    --  Add A to the list of access types to process when expanding the\n    --  freeze node of E.\n@@ -140,12 +144,6 @@ package Sem_Util is\n    --  one subsidiary subtype of the type. These subprograms can only\n    --  appear after the type itself.\n \n-   procedure Collect_Synchronized_Interfaces\n-     (Typ         : Entity_Id;\n-      Ifaces_List : out Elist_Id);\n-   --  Similar to Collect_Abstract_Interfaces, but tailored to task and\n-   --  protected types.\n-\n    function Compile_Time_Constraint_Error\n      (N    : Node_Id;\n       Msg  : String;\n@@ -598,12 +596,20 @@ package Sem_Util is\n    --  is a variable (in the Is_Variable sense) with a non-tagged type\n    --  target are considered view conversions and hence variables.\n \n+   function Is_Parent\n+     (E1 : Entity_Id;\n+      E2 : Entity_Id) return Boolean;\n+   --  Determine whether E1 is a parent of E2. For a concurrent type, the\n+   --  parent is the first element of its list of interface types; for other\n+   --  types, this function provides the same result as Is_Ancestor.\n+\n    function Is_Partially_Initialized_Type (Typ : Entity_Id) return Boolean;\n    --  Typ is a type entity. This function returns true if this type is\n    --  partly initialized, meaning that an object of the type is at least\n    --  partly initialized (in particular in the record case, that at least\n-   --  one field has an initialization expression). Note that initialization\n-   --  resulting from the use of pragma Normalized_Scalars does not count.\n+   --  one component has an initialization expression). Note that\n+   --  initialization resulting from the use of pragma Normalized_Scalars does\n+   --  not count.\n \n    function Is_Potentially_Persistent_Type (T : Entity_Id) return Boolean;\n    --  Determines if type T is a potentially persistent type. A potentially\n@@ -618,7 +624,7 @@ package Sem_Util is\n    --  body of a remote call interface package.\n \n    function Is_Remote_Access_To_Class_Wide_Type (E : Entity_Id) return Boolean;\n-   --  Return True if E is a remote access-to-class-wide-limited_private type\n+   --  Return True if E is a remote access-to-class-wide type\n \n    function Is_Remote_Access_To_Subprogram_Type (E : Entity_Id) return Boolean;\n    --  Return True if E is a remote access to subprogram type\n@@ -710,6 +716,11 @@ package Sem_Util is\n    --  to guarantee this in all cases. Note that it is more possible to give\n    --  correct answer if the tree is fully analyzed.\n \n+   function Needs_One_Actual (E : Entity_Id) return Boolean;\n+   --  Returns True if a function has defaults for all but its first\n+   --  formal. Used in Ada 2005 mode to solve the syntactic ambiguity that\n+   --  results from an indexing of a function call written in prefix form.\n+\n    function New_External_Entity\n      (Kind         : Entity_Kind;\n       Scope_Id     : Entity_Id;"}]}