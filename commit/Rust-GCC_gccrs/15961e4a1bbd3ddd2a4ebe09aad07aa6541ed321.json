{"sha": "15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU5NjFlNGExYmJkM2RkZDJhNGViZTA5YWFkMDdhYTY1NDFlZDMyMQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2017-01-26T17:08:12Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2017-01-26T17:08:12Z"}, "message": "re PR target/79131 (ICE: in extract_constrain_insn, at recog.c:2213, big-endian ARM)\n\n2017-01-26  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/79131\n\t* lra-assigns.c (setup_live_pseudos_and_spill_after_risky): Take\n\tendianess for subregs into account.\n\t* lra-constraints.c (lra_constraints): Do risky transformations\n\talways on the first iteration.\n\t* lra-lives.c (check_pseudos_live_through_calls): Add arg\n\tlast_call_used_reg_set.\n\t(process_bb_lives): Define and use last_call_used_reg_set.\n\t* lra.c (lra): Always continue after lra_constraints on the first\n\titeration.\n\n2017-01-26  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR target/79131\n\t* gcc.target/arm/pr79131.c: New.\n\nFrom-SVN: r244942", "tree": {"sha": "3ba1dafb844c589e276e71d31cb9c17653dce0c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ba1dafb844c589e276e71d31cb9c17653dce0c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b63144aa0fce12fb94e3655bc04017e619f1dfa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b63144aa0fce12fb94e3655bc04017e619f1dfa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b63144aa0fce12fb94e3655bc04017e619f1dfa6"}], "stats": {"total": 106, "additions": 85, "deletions": 21}, "files": [{"sha": "d09061e724e3906c0a7309e09a3bb9d27489f500", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "patch": "@@ -1,3 +1,16 @@\n+2017-01-26  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/79131\n+\t* lra-assigns.c (setup_live_pseudos_and_spill_after_risky): Take\n+\tendianess for subregs into account.\n+\t* lra-constraints.c (lra_constraints): Do risky transformations\n+\talways on the first iteration.\n+\t* lra-lives.c (check_pseudos_live_through_calls): Add arg\n+\tlast_call_used_reg_set.\n+\t(process_bb_lives): Define and use last_call_used_reg_set.\n+\t* lra.c (lra): Always continue after lra_constraints on the first\n+\titeration.\n+\n 2017-01-26  Kirill Yukhin  <kirill.yukhin@gmail.com>\n \n \t* gcc.target/i386/avx512bw-kshiftlq-2.c: Use unsigned long long"}, {"sha": "74a3195c4db2a8d18a58fd717e5e742b4daec0f9", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "patch": "@@ -1179,9 +1179,19 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n \t    /* If it is multi-register pseudos they should start on\n \t       the same hard register.\t*/\n \t    || hard_regno != reg_renumber[conflict_regno])\n-\t  add_to_hard_reg_set (&conflict_set,\n-\t\t\t       lra_reg_info[conflict_regno].biggest_mode,\n-\t\t\t       reg_renumber[conflict_regno]);\n+\t  {\n+\t    int conflict_hard_regno = reg_renumber[conflict_regno];\n+\t    machine_mode biggest_mode = lra_reg_info[conflict_regno].biggest_mode;\n+\t    int biggest_nregs = hard_regno_nregs[conflict_hard_regno][biggest_mode];\n+\t    int nregs_diff = (biggest_nregs\n+\t\t\t      - (hard_regno_nregs\n+\t\t\t\t [conflict_hard_regno]\n+\t\t\t\t [PSEUDO_REGNO_MODE (conflict_regno)]));\n+\t    add_to_hard_reg_set (&conflict_set,\n+\t\t\t\t biggest_mode,\n+\t\t\t\t conflict_hard_regno\n+\t\t\t\t - (WORDS_BIG_ENDIAN ? nregs_diff : 0));\n+\t  }\n       if (! overlaps_hard_reg_set_p (conflict_set, mode, hard_regno))\n \t{\n \t  update_lives (regno, false);"}, {"sha": "25869134bd0d1fe5d16078888b303f8928324759", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "patch": "@@ -4511,7 +4511,10 @@ lra_constraints (bool first_p)\n       && REGNO (pic_offset_table_rtx) >= FIRST_PSEUDO_REGISTER)\n     lra_risky_transformations_p = true;\n   else\n-    lra_risky_transformations_p = false;\n+    /* On the first iteration we should check IRA assignment\n+       correctness.  In rare cases, the assignments can be wrong as\n+       early clobbers operands are ignored in IRA.  */\n+    lra_risky_transformations_p = first_p;\n   new_insn_uid_start = get_max_uid ();\n   new_regno_start = first_p ? lra_constraint_new_regno_start : max_reg_num ();\n   /* Mark used hard regs for target stack size calulations.  */"}, {"sha": "f0194387c6319f60617285d96bba2eeeaaf56810", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "patch": "@@ -560,18 +560,19 @@ lra_setup_reload_pseudo_preferenced_hard_reg (int regno,\n }\n \n /* Check that REGNO living through calls and setjumps, set up conflict\n-   regs, and clear corresponding bits in PSEUDOS_LIVE_THROUGH_CALLS and\n-   PSEUDOS_LIVE_THROUGH_SETJUMPS.  */\n+   regs using LAST_CALL_USED_REG_SET, and clear corresponding bits in\n+   PSEUDOS_LIVE_THROUGH_CALLS and PSEUDOS_LIVE_THROUGH_SETJUMPS.  */\n static inline void\n-check_pseudos_live_through_calls (int regno)\n+check_pseudos_live_through_calls (int regno,\n+\t\t\t\t  HARD_REG_SET last_call_used_reg_set)\n {\n   int hr;\n \n   if (! sparseset_bit_p (pseudos_live_through_calls, regno))\n     return;\n   sparseset_clear_bit (pseudos_live_through_calls, regno);\n   IOR_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs,\n-\t\t    call_used_reg_set);\n+\t\t    last_call_used_reg_set);\n \n   for (hr = 0; hr < FIRST_PSEUDO_REGISTER; hr++)\n     if (HARD_REGNO_CALL_PART_CLOBBERED (hr, PSEUDO_REGNO_MODE (regno)))\n@@ -604,11 +605,13 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n   rtx_insn *next;\n   rtx link, *link_loc;\n   bool need_curr_point_incr;\n-\n+  HARD_REG_SET last_call_used_reg_set;\n+  \n   reg_live_out = df_get_live_out (bb);\n   sparseset_clear (pseudos_live);\n   sparseset_clear (pseudos_live_through_calls);\n   sparseset_clear (pseudos_live_through_setjumps);\n+  CLEAR_HARD_REG_SET (last_call_used_reg_set);\n   REG_SET_TO_HARD_REG_SET (hard_regs_live, reg_live_out);\n   AND_COMPL_HARD_REG_SET (hard_regs_live, eliminable_regset);\n   EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n@@ -795,7 +798,8 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t    need_curr_point_incr\n \t      |= mark_regno_live (reg->regno, reg->biggest_mode,\n \t\t\t\t  curr_point);\n-\t    check_pseudos_live_through_calls (reg->regno);\n+\t    check_pseudos_live_through_calls (reg->regno,\n+\t\t\t\t\t      last_call_used_reg_set);\n \t  }\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n@@ -831,15 +835,27 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       if (call_p)\n \t{\n-\t  if (flag_ipa_ra)\n+\t  if (! flag_ipa_ra)\n+\t    COPY_HARD_REG_SET(last_call_used_reg_set, call_used_reg_set);\n+\t  else\n \t    {\n \t      HARD_REG_SET this_call_used_reg_set;\n \t      get_call_reg_set_usage (curr_insn, &this_call_used_reg_set,\n \t\t\t\t      call_used_reg_set);\n \n+\t      bool flush = (! hard_reg_set_empty_p (last_call_used_reg_set)\n+\t\t\t    && ! hard_reg_set_equal_p (last_call_used_reg_set,\n+\t\t\t\t\t\t       this_call_used_reg_set));\n+\n \t      EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, j)\n-\t\tIOR_HARD_REG_SET (lra_reg_info[j].actual_call_used_reg_set,\n-\t\t\t\t  this_call_used_reg_set);\n+\t\t{\n+\t\t  IOR_HARD_REG_SET (lra_reg_info[j].actual_call_used_reg_set,\n+\t\t\t\t    this_call_used_reg_set);\n+\t\t  if (flush)\n+\t\t    check_pseudos_live_through_calls\n+\t\t      (j, last_call_used_reg_set);\n+\t\t}\n+\t      COPY_HARD_REG_SET(last_call_used_reg_set, this_call_used_reg_set);\n \t    }\n \n \t  sparseset_ior (pseudos_live_through_calls,\n@@ -866,7 +882,8 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t    need_curr_point_incr\n \t      |= mark_regno_live (reg->regno, reg->biggest_mode,\n \t\t\t\t  curr_point);\n-\t    check_pseudos_live_through_calls (reg->regno);\n+\t    check_pseudos_live_through_calls (reg->regno,\n+\t\t\t\t\t      last_call_used_reg_set);\n \t  }\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n@@ -1009,7 +1026,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       if (sparseset_cardinality (pseudos_live_through_calls) == 0)\n \tbreak;\n       if (sparseset_bit_p (pseudos_live_through_calls, j))\n-\tcheck_pseudos_live_through_calls (j);\n+\tcheck_pseudos_live_through_calls (j, last_call_used_reg_set);\n     }\n \n   if (need_curr_point_incr)"}, {"sha": "9be0053f54369e16ce3722977bfd3f9c742afe19", "filename": "gcc/lra.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "patch": "@@ -2295,7 +2295,7 @@ void\n lra (FILE *f)\n {\n   int i;\n-  bool live_p, scratch_p, inserted_p;\n+  bool live_p, inserted_p;\n \n   lra_dump_file = f;\n \n@@ -2332,7 +2332,6 @@ lra (FILE *f)\n   lra_constraint_new_regno_start = lra_new_regno_start = max_reg_num ();\n   lra_bad_spill_regno_start = INT_MAX;\n   remove_scratches ();\n-  scratch_p = lra_constraint_new_regno_start != max_reg_num ();\n \n   /* A function that has a non-local label that can reach the exit\n      block via non-exceptional paths must save all call-saved\n@@ -2372,11 +2371,12 @@ lra (FILE *f)\n       for (;;)\n \t{\n \t  /* We should try to assign hard registers to scratches even\n-\t     if there were no RTL transformations in\n-\t     lra_constraints.  */\n+\t     if there were no RTL transformations in lra_constraints.\n+\t     Also we should check IRA assignments on the first\n+\t     iteration as they can be wrong because of early clobbers\n+\t     operands which are ignored in IRA.  */\n \t  if (! lra_constraints (lra_constraint_iter == 0)\n-\t      && (lra_constraint_iter > 1\n-\t\t  || (! scratch_p && ! caller_save_needed)))\n+\t      && lra_constraint_iter > 1)\n \t    break;\n \t  /* Constraint transformations may result in that eliminable\n \t     hard regs become uneliminable and pseudos which use them"}, {"sha": "8796bb59c869ca6ee221f56e2d150ff1b5d9008e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "patch": "@@ -1,3 +1,8 @@\n+2017-01-26  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR target/79131\n+\t* gcc.target/arm/pr79131.c: New.\n+\n 2017-01-26  Bin Cheng  <bin.cheng@arm.com>\n \n \t* gcc.target/aarch64/ldp_vec_64_1.c: Xfail."}, {"sha": "3bd9e0fd935366dd60646c7d44c21f209e957200", "filename": "gcc/testsuite/gcc.target/arm/pr79131.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr79131.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr79131.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr79131.c?ref=15961e4a1bbd3ddd2a4ebe09aad07aa6541ed321", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mbig-endian\" } */\n+\n+long long a;\n+enum { NILFS_SEGMENT_USAGE_ACTIVE, NILFS_SEGMENT_USAGE_DIRTY } b;\n+void nilfs_sufile_mod_counter(long long p1) {\n+  long c = p1;\n+  unsigned d = __builtin_bswap64(a);\n+  a = __builtin_bswap64(d + c);\n+}\n+void nilfs_sufile_do_free() {\n+  int e, f;\n+  e = __builtin_bswap32(b) & 1 << NILFS_SEGMENT_USAGE_DIRTY;\n+  f = e;\n+  nilfs_sufile_mod_counter(f ? -1 : 0);\n+}"}]}