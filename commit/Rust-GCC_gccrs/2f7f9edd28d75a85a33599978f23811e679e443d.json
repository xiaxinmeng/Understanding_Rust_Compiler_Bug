{"sha": "2f7f9edd28d75a85a33599978f23811e679e443d", "node_id": "C_kwDOANBUbNoAKDJmN2Y5ZWRkMjhkNzVhODVhMzM1OTk5NzhmMjM4MTFlNjc5ZTQ0M2Q", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-12T08:33:01Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-12T08:33:01Z"}, "message": "range-op: Implement floating point multiplication fold_range [PR107569]\n\nThe following patch implements frange multiplication, including the\nspecial case of x * x.  The callers don't tell us that it is x * x,\njust that it is either z = x * x or if (x == y) z = x * y;\nFor irange that makes no difference, but for frange it can mean\nx is -0.0 and y is 0.0 if they have the same range that includes both\nsigned and unsigned zeros, so we need to assume result could be -0.0.\n\nThe patch causes one regression:\n+FAIL: gcc.dg/fold-overflow-1.c scan-assembler-times 2139095040 2\nbut that is already tracked in PR107608 and affects not just the newly\nadded multiplication, but addition and other floating point operations\n(and doesn't seem like a ranger bug but dce or whatever else).\n\n2022-11-12  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/107569\n\tPR tree-optimization/107591\n\t* range-op.h (range_operator_float::rv_fold): Add relation_kind\n\targument.\n\t* range-op-float.cc (range_operator_float::fold_range): Name\n\tlast argument trio and pass trio.op1_op2 () as last argument to\n\trv_fold.\n\t(range_operator_float::rv_fold): Add relation_kind argument.\n\t(foperator_plus::rv_fold, foperator_minus::rv_fold): Likewise.\n\t(foperator_mult): New class.\n\t(floating_op_table::floating_op_table): Use foperator_mult for\n\tMULT_EXPR.", "tree": {"sha": "efd57b30bd4fcaf4ec89b61be9c3910ca51f1513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efd57b30bd4fcaf4ec89b61be9c3910ca51f1513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f7f9edd28d75a85a33599978f23811e679e443d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7f9edd28d75a85a33599978f23811e679e443d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f7f9edd28d75a85a33599978f23811e679e443d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f7f9edd28d75a85a33599978f23811e679e443d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5225dbf5cf2a57ed5a2073b1a90a854093d063e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5225dbf5cf2a57ed5a2073b1a90a854093d063e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5225dbf5cf2a57ed5a2073b1a90a854093d063e"}], "stats": {"total": 194, "additions": 187, "deletions": 7}, "files": [{"sha": "8f411b83ad16a645e770905184fc5920f0cf583c", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 185, "deletions": 6, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7f9edd28d75a85a33599978f23811e679e443d/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7f9edd28d75a85a33599978f23811e679e443d/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=2f7f9edd28d75a85a33599978f23811e679e443d", "patch": "@@ -51,7 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n bool\n range_operator_float::fold_range (frange &r, tree type,\n \t\t\t\t  const frange &op1, const frange &op2,\n-\t\t\t\t  relation_trio) const\n+\t\t\t\t  relation_trio trio) const\n {\n   if (empty_range_varying (r, type, op1, op2))\n     return true;\n@@ -65,7 +65,7 @@ range_operator_float::fold_range (frange &r, tree type,\n   bool maybe_nan;\n   rv_fold (lb, ub, maybe_nan, type,\n \t   op1.lower_bound (), op1.upper_bound (),\n-\t   op2.lower_bound (), op2.upper_bound ());\n+\t   op2.lower_bound (), op2.upper_bound (), trio.op1_op2 ());\n \n   // Handle possible NANs by saturating to the appropriate INF if only\n   // one end is a NAN.  If both ends are a NAN, just return a NAN.\n@@ -103,8 +103,8 @@ range_operator_float::rv_fold (REAL_VALUE_TYPE &lb,\n \t\t\t       const REAL_VALUE_TYPE &lh_lb ATTRIBUTE_UNUSED,\n \t\t\t       const REAL_VALUE_TYPE &lh_ub ATTRIBUTE_UNUSED,\n \t\t\t       const REAL_VALUE_TYPE &rh_lb ATTRIBUTE_UNUSED,\n-\t\t\t       const REAL_VALUE_TYPE &rh_ub ATTRIBUTE_UNUSED)\n-  const\n+\t\t\t       const REAL_VALUE_TYPE &rh_ub ATTRIBUTE_UNUSED,\n+\t\t\t       relation_kind) const\n {\n   lb = dconstninf;\n   ub = dconstinf;\n@@ -1868,7 +1868,8 @@ class foperator_plus : public range_operator_float\n \t\tconst REAL_VALUE_TYPE &lh_lb,\n \t\tconst REAL_VALUE_TYPE &lh_ub,\n \t\tconst REAL_VALUE_TYPE &rh_lb,\n-\t\tconst REAL_VALUE_TYPE &rh_ub) const final override\n+\t\tconst REAL_VALUE_TYPE &rh_ub,\n+\t\trelation_kind) const final override\n   {\n     frange_arithmetic (PLUS_EXPR, type, lb, lh_lb, rh_lb, dconstninf);\n     frange_arithmetic (PLUS_EXPR, type, ub, lh_ub, rh_ub, dconstinf);\n@@ -1892,7 +1893,8 @@ class foperator_minus : public range_operator_float\n \t\tconst REAL_VALUE_TYPE &lh_lb,\n \t\tconst REAL_VALUE_TYPE &lh_ub,\n \t\tconst REAL_VALUE_TYPE &rh_lb,\n-\t\tconst REAL_VALUE_TYPE &rh_ub) const final override\n+\t\tconst REAL_VALUE_TYPE &rh_ub,\n+\t\trelation_kind) const final override\n   {\n     frange_arithmetic (MINUS_EXPR, type, lb, lh_lb, rh_ub, dconstninf);\n     frange_arithmetic (MINUS_EXPR, type, ub, lh_ub, rh_lb, dconstinf);\n@@ -1908,6 +1910,182 @@ class foperator_minus : public range_operator_float\n   }\n } fop_minus;\n \n+\n+class foperator_mult : public range_operator_float\n+{\n+  void rv_fold (REAL_VALUE_TYPE &lb, REAL_VALUE_TYPE &ub, bool &maybe_nan,\n+\t\ttree type,\n+\t\tconst REAL_VALUE_TYPE &lh_lb,\n+\t\tconst REAL_VALUE_TYPE &lh_ub,\n+\t\tconst REAL_VALUE_TYPE &rh_lb,\n+\t\tconst REAL_VALUE_TYPE &rh_ub,\n+\t\trelation_kind kind) const final override\n+  {\n+    bool is_square\n+      = (kind == VREL_EQ\n+\t && real_equal (&lh_lb, &rh_lb)\n+\t && real_equal (&lh_ub, &rh_ub)\n+\t && real_isneg (&lh_lb) == real_isneg (&rh_lb)\n+\t && real_isneg (&lh_ub) == real_isneg (&rh_ub));\n+\n+    maybe_nan = false;\n+    // x * x never produces a new NAN and we only multiply the same\n+    // values, so the 0 * INF problematic cases never appear there.\n+    if (!is_square)\n+      {\n+\t// [+-0, +-0] * [+INF,+INF] (or [-INF,-INF] or swapped is a known NAN.\n+\tif ((real_iszero (&lh_lb)\n+\t     && real_iszero (&lh_ub)\n+\t     && real_isinf (&rh_lb)\n+\t     && real_isinf (&rh_ub, real_isneg (&rh_lb)))\n+\t    || (real_iszero (&rh_lb)\n+\t\t&& real_iszero (&rh_ub)\n+\t\t&& real_isinf (&lh_lb)\n+\t\t&& real_isinf (&lh_ub, real_isneg (&lh_lb))))\n+\t  {\n+\t    real_nan (&lb, \"\", 0, TYPE_MODE (type));\n+\t    ub = lb;\n+\t    maybe_nan = true;\n+\t    return;\n+\t  }\n+\n+\t// Otherwise, if one range includes zero and the other ends with +-INF,\n+\t// it is a maybe NAN.\n+\tif ((real_compare (LE_EXPR, &lh_lb, &dconst0)\n+\t     && real_compare (GE_EXPR, &lh_ub, &dconst0)\n+\t     && (real_isinf (&rh_lb) || real_isinf (&rh_ub)))\n+\t    || (real_compare (LE_EXPR, &rh_lb, &dconst0)\n+\t\t&& real_compare (GE_EXPR, &rh_ub, &dconst0)\n+\t\t&& (real_isinf (&lh_lb) || real_isinf (&lh_ub))))\n+\t  {\n+\t    maybe_nan = true;\n+\n+\t    bool must_have_signbit_zero = false;\n+\t    bool must_have_signbit_nonzero = false;\n+\t    if (real_isneg (&lh_lb) == real_isneg (&lh_ub)\n+\t\t&& real_isneg (&rh_lb) == real_isneg (&rh_ub))\n+\t      {\n+\t\tif (real_isneg (&lh_lb) == real_isneg (&rh_ub))\n+\t\t  must_have_signbit_zero = true;\n+\t\telse\n+\t\t  must_have_signbit_nonzero = true;\n+\t      }\n+\n+\t    // If one of the ranges that includes INF is singleton\n+\t    // and the other range includes zero, the resulting\n+\t    // range is INF and NAN, because the 0 * INF boundary\n+\t    // case will be NAN, but already nextafter (0, 1) * INF\n+\t    // is INF.\n+\t    if ((real_isinf (&lh_lb)\n+\t\t && real_isinf (&lh_ub, real_isneg (&lh_lb)))\n+\t\t|| (real_isinf (&rh_lb)\n+\t\t    && real_isinf (&rh_ub, real_isneg (&rh_lb))))\n+\t      {\n+\t\t// If all the boundary signs are the same, [+INF, +INF].\n+\t\tif (must_have_signbit_zero)\n+\t\t  ub = lb = dconstinf;\n+\t\t// If the two multiplicands have always different sign,\n+\t\t// [-INF, -INF].\n+\t\telse if (must_have_signbit_nonzero)\n+\t\t  ub = lb = dconstninf;\n+\t\t// Otherwise -> [-INF, +INF] (-INF or +INF).\n+\t\telse\n+\t\t  {\n+\t\t    lb = dconstninf;\n+\t\t    ub = dconstinf;\n+\t\t  }\n+\t\treturn;\n+\t      }\n+\n+\t    // If one of the multiplicands must be zero, the resulting\n+\t    // range is +-0 and NAN.\n+\t    if ((real_iszero (&lh_lb) && real_iszero (&lh_ub))\n+\t\t|| (real_iszero (&rh_lb) && real_iszero (&rh_ub)))\n+\t      {\n+\t\tub = lb = dconst0;\n+\t\t// If all the boundary signs are the same, [+0.0, +0.0].\n+\t\tif (must_have_signbit_zero)\n+\t\t  ;\n+\t\t// If divisor and dividend must have different signs,\n+\t\t// [-0.0, -0.0].\n+\t\telse if (must_have_signbit_nonzero)\n+\t\t  ub = lb = real_value_negate (&dconst0);\n+\t\t// Otherwise -> [-0.0, +0.0].\n+\t\telse\n+\t\t  lb = real_value_negate (&dconst0);\n+\t\treturn;\n+\t      }\n+\n+\t    // Otherwise one of the multiplicands could be\n+\t    // [0.0, nextafter (0.0, 1.0)] and the [DBL_MAX, INF]\n+\t    // or similarly with different signs.  0.0 * DBL_MAX\n+\t    // is still 0.0, nextafter (0.0, 1.0) * INF is still INF,\n+\t    // so if the signs are always the same or always different,\n+\t    // result is [+0.0, +INF] or [-INF, -0.0], otherwise VARYING.\n+\t    if (must_have_signbit_zero)\n+\t      {\n+\t\tlb = dconst0;\n+\t\tub = dconstinf;\n+\t      }\n+\t    else if (must_have_signbit_nonzero)\n+\t      {\n+\t\tlb = dconstninf;\n+\t\tub = real_value_negate (&dconst0);\n+\t      }\n+\t    else\n+\t      {\n+\t\tlb = dconstninf;\n+\t\tub = dconstinf;\n+\t      }\n+\t    return;\n+\t  }\n+      }\n+\n+    REAL_VALUE_TYPE cp[8];\n+    // Do a cross-product.\n+    frange_arithmetic (MULT_EXPR, type, cp[0], lh_lb, rh_lb, dconstninf);\n+    frange_arithmetic (MULT_EXPR, type, cp[4], lh_lb, rh_lb, dconstinf);\n+    if (is_square)\n+      {\n+\t// For x * x we can just do max (lh_lb * lh_lb, lh_ub * lh_ub)\n+\t// as maximum and -0.0 as minimum if 0.0 is in the range,\n+\t// otherwise min (lh_lb * lh_lb, lh_ub * lh_ub).\n+\t// -0.0 rather than 0.0 because VREL_EQ doesn't prove that\n+\t// x and y are bitwise equal, just that they compare equal.\n+\tif (real_compare (LE_EXPR, &lh_lb, &dconst0)\n+\t    && real_compare (GE_EXPR, &lh_ub, &dconst0))\n+\t  cp[1] = real_value_negate (&dconst0);\n+\telse\n+\t  cp[1] = cp[0];\n+\tcp[2] = cp[0];\n+\tcp[5] = cp[4];\n+\tcp[6] = cp[4];\n+      }\n+    else\n+      {\n+\tfrange_arithmetic (MULT_EXPR, type, cp[1], lh_lb, rh_ub, dconstninf);\n+\tfrange_arithmetic (MULT_EXPR, type, cp[5], lh_lb, rh_ub, dconstinf);\n+\tfrange_arithmetic (MULT_EXPR, type, cp[2], lh_ub, rh_lb, dconstninf);\n+\tfrange_arithmetic (MULT_EXPR, type, cp[6], lh_ub, rh_lb, dconstinf);\n+      }\n+    frange_arithmetic (MULT_EXPR, type, cp[3], lh_ub, rh_ub, dconstninf);\n+    frange_arithmetic (MULT_EXPR, type, cp[7], lh_ub, rh_ub, dconstinf);\n+\n+    for (int i = 1; i < 4; ++i)\n+      {\n+\tif (real_less (&cp[i], &cp[0])\n+\t    || (real_iszero (&cp[0]) && real_isnegzero (&cp[i])))\n+\t  std::swap (cp[i], cp[0]);\n+\tif (real_less (&cp[4], &cp[i + 4])\n+\t    || (real_isnegzero (&cp[4]) && real_iszero (&cp[i + 4])))\n+\t  std::swap (cp[i + 4], cp[4]);\n+      }\n+    lb = cp[0];\n+    ub = cp[4];\n+\n+  }\n+} fop_mult;\n+\n // Instantiate a range_op_table for floating point operations.\n static floating_op_table global_floating_table;\n \n@@ -1942,6 +2120,7 @@ floating_op_table::floating_op_table ()\n   set (NEGATE_EXPR, fop_negate);\n   set (PLUS_EXPR, fop_plus);\n   set (MINUS_EXPR, fop_minus);\n+  set (MULT_EXPR, fop_mult);\n }\n \n // Return a pointer to the range_operator_float instance, if there is"}, {"sha": "da85b5b8e43766b4978551ada0058eea30c19c15", "filename": "gcc/range-op.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f7f9edd28d75a85a33599978f23811e679e443d/gcc%2Frange-op.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f7f9edd28d75a85a33599978f23811e679e443d/gcc%2Frange-op.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.h?ref=2f7f9edd28d75a85a33599978f23811e679e443d", "patch": "@@ -128,7 +128,8 @@ class range_operator_float\n \t\t\tconst REAL_VALUE_TYPE &lh_lb,\n \t\t\tconst REAL_VALUE_TYPE &lh_ub,\n \t\t\tconst REAL_VALUE_TYPE &rh_lb,\n-\t\t\tconst REAL_VALUE_TYPE &rh_ub) const;\n+\t\t\tconst REAL_VALUE_TYPE &rh_ub,\n+\t\t\trelation_kind) const;\n   // Unary operations have the range of the LHS as op2.\n   virtual bool fold_range (irange &r, tree type,\n \t\t\t   const frange &lh,"}]}