{"sha": "537cff9c871369177f5c01fe02d3a9dd85492750", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM3Y2ZmOWM4NzEzNjkxNzdmNWMwMWZlMDJkM2E5ZGQ4NTQ5Mjc1MA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:41Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:41Z"}, "message": "Initial revision\n\nFrom-SVN: r26256", "tree": {"sha": "45ba50dd3a2bba6e0300e1a1cc36470d3c87316e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45ba50dd3a2bba6e0300e1a1cc36470d3c87316e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/537cff9c871369177f5c01fe02d3a9dd85492750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/537cff9c871369177f5c01fe02d3a9dd85492750", "html_url": "https://github.com/Rust-GCC/gccrs/commit/537cff9c871369177f5c01fe02d3a9dd85492750", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/537cff9c871369177f5c01fe02d3a9dd85492750/comments", "author": null, "committer": null, "parents": [{"sha": "090aab56506db9f5185932085972aec7513cc1de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/090aab56506db9f5185932085972aec7513cc1de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/090aab56506db9f5185932085972aec7513cc1de"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "c28a052a80d26df959d9504e0134b06e8d181584", "filename": "boehm-gc/solaris_pthreads.c", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/537cff9c871369177f5c01fe02d3a9dd85492750/boehm-gc%2Fsolaris_pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/537cff9c871369177f5c01fe02d3a9dd85492750/boehm-gc%2Fsolaris_pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_pthreads.c?ref=537cff9c871369177f5c01fe02d3a9dd85492750", "patch": "@@ -0,0 +1,172 @@\n+/* \n+ * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ */\n+/*\n+ * Support code for Solaris threads.  Provides functionality we wish Sun\n+ * had provided.  Relies on some information we probably shouldn't rely on.\n+ * Modified Peter C. for Solaris Posix Threads.\n+ */\n+/* Boehm, September 14, 1994 4:44 pm PDT */\n+/* $Id: solaris_pthreads.c,v 1.1 1999/04/07 14:56:06 tromey Exp $ */\n+\n+# if defined(_SOLARIS_PTHREADS)\n+# include \"gc_priv.h\"\n+# include <pthread.h>\n+# include <thread.h>\n+# include <signal.h>\n+# include <fcntl.h>\n+# include <sys/types.h>\n+# include <sys/mman.h>\n+# include <sys/time.h>\n+# include <sys/resource.h>\n+# include <sys/stat.h>\n+# include <sys/syscall.h>\n+# include <sys/procfs.h>\n+# include <sys/lwp.h>\n+# include <sys/reg.h>\n+# define _CLASSIC_XOPEN_TYPES\n+# include <unistd.h>\n+# include <errno.h>\n+# include \"solaris_threads.h\"\n+# include <stdio.h>\n+\n+#undef pthread_join\n+#undef pthread_create\n+\n+pthread_cond_t GC_prom_join_cv;\t\t/* Broadcast when any thread terminates\t*/\n+pthread_cond_t GC_create_cv;\t\t/* Signalled when a new undetached\t*/\n+\t\t\t\t/* thread starts.\t\t\t*/\n+\t\t\t\t\n+extern bool GC_multithreaded;\n+\n+/* We use the allocation lock to protect thread-related data structures. */\n+\n+/* We stop the world using /proc primitives.  This makes some\t*/\n+/* minimal assumptions about the threads implementation.\t*/\n+/* We don't play by the rules, since the rules make this\t*/\n+/* impossible (as of Solaris 2.3).  Also note that as of\t*/\n+/* Solaris 2.3 the various thread and lwp suspension\t\t*/\n+/* primitives failed to stop threads by the time the request\t*/\n+/* is completed.\t\t\t\t\t\t*/\n+\n+\n+\n+int GC_pthread_join(pthread_t wait_for, void **status)\n+{\n+\treturn GC_thr_join((thread_t)wait_for, NULL, status);\n+}\n+\n+\n+int\n+GC_pthread_create(pthread_t *new_thread,\n+          const pthread_attr_t *attr_in,\n+          void * (*thread_execp)(void *), void *arg)\n+{\n+    int result;\n+    GC_thread t;\n+    pthread_t my_new_thread;\n+    pthread_attr_t  attr;\n+    word my_flags = 0;\n+    int  flag;\n+    void * stack;\n+    size_t stack_size;\n+    int    n;\n+    struct sched_param schedparam;\n+   \n+    (void)pthread_attr_getstacksize(attr_in, &stack_size);\n+    (void)pthread_attr_getstackaddr(attr_in, &stack);\n+    (void)pthread_attr_init(&attr);\n+\n+    LOCK();\n+    if (!GC_thr_initialized) {\n+\t    GC_thr_init();\n+    }\n+    GC_multithreaded++;\n+\t    \n+    if (stack == 0) {\n+     \tif (stack_size == 0)\n+\t\tstack_size = GC_min_stack_sz;\n+\telse\n+\t\tstack_size += thr_min_stack();\n+\n+     \tstack = (void *)GC_stack_alloc(&stack_size);\n+     \tif (stack == 0) {\n+\t    GC_multithreaded--;\n+     \t    UNLOCK();\n+\t    errno = ENOMEM;\n+     \t    return -1;\n+     \t}\n+    } else {\n+    \tmy_flags |= CLIENT_OWNS_STACK;\n+    }\n+    (void)pthread_attr_setstacksize(&attr, stack_size);\n+    (void)pthread_attr_setstackaddr(&attr, stack);\n+    (void)pthread_attr_getscope(attr_in, &n);\n+    (void)pthread_attr_setscope(&attr, n);\n+    (void)pthread_attr_getschedparam(attr_in, &schedparam);\n+    (void)pthread_attr_setschedparam(&attr, &schedparam);\n+    (void)pthread_attr_getschedpolicy(attr_in, &n);\n+    (void)pthread_attr_setschedpolicy(&attr, n);\n+    (void)pthread_attr_getinheritsched(attr_in, &n);\n+    (void)pthread_attr_setinheritsched(&attr, n);\n+\n+    (void)pthread_attr_getdetachstate(attr_in, &flag);\n+    if (flag == PTHREAD_CREATE_DETACHED) {\n+\t    my_flags |= DETACHED;\n+    }\n+    (void)pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n+    /*\n+     * thr_create can call malloc(), which if redirected will\n+     * attempt to acquire the allocation lock.\n+     * Unlock here to prevent deadlock.\n+     */\n+\n+\n+#if 0\n+#ifdef I386\n+    UNLOCK();\n+#endif\n+#endif\n+    result = \n+\t    pthread_create(&my_new_thread, &attr, thread_execp, arg);\n+#if 0\n+#ifdef I386\n+    LOCK();\n+#endif\n+#endif\n+    if (result == 0) {\n+        t = GC_new_thread(my_new_thread);\n+        t -> flags = my_flags;\n+        if (!(my_flags & DETACHED)) cond_init(&(t->join_cv), USYNC_THREAD, 0);\n+        t -> stack = stack;\n+        t -> stack_size = stack_size;\n+        if (new_thread != 0) *new_thread = my_new_thread;\n+        pthread_cond_signal(&GC_create_cv);\n+    } else {\n+\t    if (!(my_flags & CLIENT_OWNS_STACK)) {\n+\t\t    GC_stack_free(stack, stack_size);\n+\t    }        \n+\t    GC_multithreaded--;\n+    }\n+    UNLOCK();\n+    pthread_attr_destroy(&attr);\n+    return(result);\n+}\n+\n+# else\n+\n+#ifndef LINT\n+  int GC_no_sunOS_pthreads;\n+#endif\n+\n+# endif /* SOLARIS_THREADS */\n+"}]}