{"sha": "d30846a02eb9ea43b61311e74fbf05692ffefba2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMwODQ2YTAyZWI5ZWE0M2I2MTMxMWU3NGZiZjA1NjkyZmZlZmJhMg==", "commit": {"author": {"name": "Fei Yang", "email": "felix.yang@huawei.com", "date": "2020-06-12T10:37:00Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-06-12T10:37:00Z"}, "message": "vect: Fix an ICE in vect_loop_versioning [PR95570]\n\nIn the test case for PR95570, the only data reference in the loop is a\ngather-statter access.  Scalar evolution analysis for this data reference\nfailed, so DR_STEP is NULL_TREE.  This leads to the segmentation fault.\nWe should filter out scatter-gather access in vect_enhance_data_refs_alignment.\n\n2020-06-12  Felix Yang  <felix.yang@huawei.com>\n\ngcc/\n\tPR tree-optimization/95570\n\t* tree-vect-data-refs.c (vect_relevant_for_alignment_p): New function.\n\t(vect_verify_datarefs_alignment): Call it to filter out data references\n\tin the loop whose alignment is irrelevant.\n\t(vect_get_peeling_costs_all_drs): Likewise.\n\t(vect_peeling_supportable): Likewise.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\ngcc/testsuite/\n\n\tPR tree-optimization/95570\n\t* gcc.dg/vect/pr95570.c: New test.", "tree": {"sha": "ff2094dc7651fb89194c9657397bd7e474fd1f96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff2094dc7651fb89194c9657397bd7e474fd1f96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d30846a02eb9ea43b61311e74fbf05692ffefba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d30846a02eb9ea43b61311e74fbf05692ffefba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d30846a02eb9ea43b61311e74fbf05692ffefba2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d30846a02eb9ea43b61311e74fbf05692ffefba2/comments", "author": null, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "135a8ad3a59972ea64b1244b0e221cdded9a6ec6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/135a8ad3a59972ea64b1244b0e221cdded9a6ec6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/135a8ad3a59972ea64b1244b0e221cdded9a6ec6"}], "stats": {"total": 94, "additions": 45, "deletions": 49}, "files": [{"sha": "b93626140048b1a88718fe1d3ee4693a1226249b", "filename": "gcc/testsuite/gcc.dg/vect/pr95570.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30846a02eb9ea43b61311e74fbf05692ffefba2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr95570.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30846a02eb9ea43b61311e74fbf05692ffefba2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr95570.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr95570.c?ref=d30846a02eb9ea43b61311e74fbf05692ffefba2", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-march=armv8.2-a+sve -msve-vector-bits=256 -mstrict-align -fwrapv\" { target aarch64*-*-* } } */\n+\n+int x[8][32];\n+\n+void\n+foo (int start)\n+{\n+  for (int i = start; i < start + 16; i++)\n+    x[start][i] = i;\n+}"}, {"sha": "3e86980172ee267893d7fcead2414d311d7ec55e", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 34, "deletions": 49, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d30846a02eb9ea43b61311e74fbf05692ffefba2/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d30846a02eb9ea43b61311e74fbf05692ffefba2/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=d30846a02eb9ea43b61311e74fbf05692ffefba2", "patch": "@@ -1129,6 +1129,35 @@ vect_update_misalignment_for_peel (dr_vec_info *dr_info,\n   SET_DR_MISALIGNMENT (dr_info, DR_MISALIGNMENT_UNKNOWN);\n }\n \n+/* Return true if alignment is relevant for DR_INFO.  */\n+\n+static bool\n+vect_relevant_for_alignment_p (dr_vec_info *dr_info)\n+{\n+  stmt_vec_info stmt_info = dr_info->stmt;\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  /* For interleaving, only the alignment of the first access matters.  */\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+      && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt_info)\n+    return false;\n+\n+  /* Scatter-gather and invariant accesses continue to address individual\n+     scalars, so vector-level alignment is irrelevant.  */\n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info)\n+      || integer_zerop (DR_STEP (dr_info->dr)))\n+    return false;\n+\n+  /* Strided accesses perform only component accesses, alignment is\n+     irrelevant for them.  */\n+  if (STMT_VINFO_STRIDED_P (stmt_info)\n+      && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    return false;\n+\n+  return true;\n+}\n \n /* Function verify_data_ref_alignment\n \n@@ -1169,20 +1198,7 @@ vect_verify_datarefs_alignment (loop_vec_info vinfo)\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n       dr_vec_info *dr_info = vinfo->lookup_dr (dr);\n-      stmt_vec_info stmt_info = dr_info->stmt;\n-\n-      if (!STMT_VINFO_RELEVANT_P (stmt_info))\n-\tcontinue;\n-\n-      /* For interleaving, only the alignment of the first access matters.   */\n-      if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-\t  && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt_info)\n-\tcontinue;\n-\n-      /* Strided accesses perform only component accesses, alignment is\n-\t irrelevant for them.  */\n-      if (STMT_VINFO_STRIDED_P (stmt_info)\n-\t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+      if (!vect_relevant_for_alignment_p (dr_info))\n \tcontinue;\n \n       opt_result res = verify_data_ref_alignment (vinfo, dr_info);\n@@ -1415,20 +1431,7 @@ vect_get_peeling_costs_all_drs (loop_vec_info loop_vinfo,\n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     {\n       dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n-      stmt_vec_info stmt_info = dr_info->stmt;\n-      if (!STMT_VINFO_RELEVANT_P (stmt_info))\n-\tcontinue;\n-\n-      /* For interleaving, only the alignment of the first access\n-         matters.  */\n-      if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-\t  && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt_info)\n-\tcontinue;\n-\n-      /* Strided accesses perform only component accesses, alignment is\n-         irrelevant for them.  */\n-      if (STMT_VINFO_STRIDED_P (stmt_info)\n-\t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+      if (!vect_relevant_for_alignment_p (dr_info))\n \tcontinue;\n \n       int save_misalignment;\n@@ -1548,17 +1551,7 @@ vect_peeling_supportable (loop_vec_info loop_vinfo, dr_vec_info *dr0_info,\n \tcontinue;\n \n       dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n-      stmt_vec_info stmt_info = dr_info->stmt;\n-      /* For interleaving, only the alignment of the first access\n-\t matters.  */\n-      if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-\t  && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt_info)\n-\tcontinue;\n-\n-      /* Strided accesses perform only component accesses, alignment is\n-\t irrelevant for them.  */\n-      if (STMT_VINFO_STRIDED_P (stmt_info)\n-\t  && !STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+      if (!vect_relevant_for_alignment_p (dr_info))\n \tcontinue;\n \n       save_misalignment = DR_MISALIGNMENT (dr_info);\n@@ -2197,21 +2190,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       FOR_EACH_VEC_ELT (datarefs, i, dr)\n         {\n \t  dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n-\t  stmt_vec_info stmt_info = dr_info->stmt;\n-\n-\t  /* For interleaving, only the alignment of the first access\n-\t     matters.  */\n \t  if (aligned_access_p (dr_info)\n-\t      || (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-\t\t  && DR_GROUP_FIRST_ELEMENT (stmt_info) != stmt_info))\n+\t      || !vect_relevant_for_alignment_p (dr_info))\n \t    continue;\n \n+\t  stmt_vec_info stmt_info = dr_info->stmt;\n \t  if (STMT_VINFO_STRIDED_P (stmt_info))\n \t    {\n-\t      /* Strided loads perform only component accesses, alignment is\n-\t\t irrelevant for them.  */\n-\t      if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-\t\tcontinue;\n \t      do_versioning = false;\n \t      break;\n \t    }"}]}