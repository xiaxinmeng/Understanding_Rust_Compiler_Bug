{"sha": "77b0791e3dd1c8f8115499725357d0791334ce85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdiMDc5MWUzZGQxYzhmODExNTQ5OTcyNTM1N2QwNzkxMzM0Y2U4NQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2011-03-15T02:19:28Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2011-03-15T02:19:28Z"}, "message": "re PR target/48032 (PowerPC64 -mcmodel=medium invalid ld offset)\n\n\tPR target/48032\n\t* config/rs6000/rs6000.c (offsettable_ok_by_alignment): Do not\n\tpresume symbol_refs without a symbol_ref_decl are suitably\n\taligned, nor other trees we may see here.  Handle anchor symbols.\n\t(legitimate_constant_pool_address_p): Comment.  Add mode param.\n\tCheck cmodel=medium addresses.  Adjust all calls.\n\t(rs6000_emit_move): Don't call offsettable_ok_by_alignment on\n\tcreating cmodel=medium optimized access to locals.\n\t* config/rs6000/constraints.md (R): Pass QImode to\n\tlegitimate_constant_pool_address_p.\n\t* config/rs6000/predicates.md (input_operand): Pass mode to\n\tlegitimate_constant_pool_address_p.\n\t* config/rs6000/rs6000-protos.h (legitimate_constant_pool_address_p):\n\tUpdate prototype.\n\nFrom-SVN: r170976", "tree": {"sha": "b27ed5b1bbd9fb5fa033c1c1714e2076ee51296e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b27ed5b1bbd9fb5fa033c1c1714e2076ee51296e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77b0791e3dd1c8f8115499725357d0791334ce85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77b0791e3dd1c8f8115499725357d0791334ce85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77b0791e3dd1c8f8115499725357d0791334ce85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77b0791e3dd1c8f8115499725357d0791334ce85/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95992339f9c10fce65d2eea8c95fe9e5a84d43c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95992339f9c10fce65d2eea8c95fe9e5a84d43c"}], "stats": {"total": 180, "additions": 132, "deletions": 48}, "files": [{"sha": "a4bcde02f7525bb370a0d837a64cca1292a95a8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77b0791e3dd1c8f8115499725357d0791334ce85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77b0791e3dd1c8f8115499725357d0791334ce85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77b0791e3dd1c8f8115499725357d0791334ce85", "patch": "@@ -1,3 +1,20 @@\n+2011-03-15  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/48032\n+\t* config/rs6000/rs6000.c (offsettable_ok_by_alignment): Do not\n+\tpresume symbol_refs without a symbol_ref_decl are suitably\n+\taligned, nor other trees we may see here.  Handle anchor symbols.\n+\t(legitimate_constant_pool_address_p): Comment.  Add mode param.\n+\tCheck cmodel=medium addresses.  Adjust all calls.\n+\t(rs6000_emit_move): Don't call offsettable_ok_by_alignment on\n+\tcreating cmodel=medium optimized access to locals.\n+\t* config/rs6000/constraints.md (R): Pass QImode to\n+\tlegitimate_constant_pool_address_p.\n+\t* config/rs6000/predicates.md (input_operand): Pass mode to\n+\tlegitimate_constant_pool_address_p.\n+\t* config/rs6000/rs6000-protos.h (legitimate_constant_pool_address_p):\n+\tUpdate prototype.\n+\n 2011-03-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/48053"}, {"sha": "71b3b207ef8724370ce437a41938744119c1b5a2", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77b0791e3dd1c8f8115499725357d0791334ce85/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77b0791e3dd1c8f8115499725357d0791334ce85/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=77b0791e3dd1c8f8115499725357d0791334ce85", "patch": "@@ -166,7 +166,7 @@ usually better to use @samp{m} or @samp{es} in @code{asm} statements)\"\n \n (define_constraint \"R\"\n   \"AIX TOC entry\"\n-  (match_test \"legitimate_constant_pool_address_p (op, false)\"))\n+  (match_test \"legitimate_constant_pool_address_p (op, QImode, false)\"))\n \n ;; General constraints\n "}, {"sha": "90947452b65cb00ef59dfbb4b8725a7c7633109a", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77b0791e3dd1c8f8115499725357d0791334ce85/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77b0791e3dd1c8f8115499725357d0791334ce85/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=77b0791e3dd1c8f8115499725357d0791334ce85", "patch": "@@ -854,7 +854,7 @@\n     return 1;\n \n   /* A SYMBOL_REF referring to the TOC is valid.  */\n-  if (legitimate_constant_pool_address_p (op, false))\n+  if (legitimate_constant_pool_address_p (op, mode, false))\n     return 1;\n \n   /* A constant pool expression (relative to the TOC) is valid */"}, {"sha": "d79af36ce04d3dd1b024ee57532703622ea553a3", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77b0791e3dd1c8f8115499725357d0791334ce85/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77b0791e3dd1c8f8115499725357d0791334ce85/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=77b0791e3dd1c8f8115499725357d0791334ce85", "patch": "@@ -41,7 +41,8 @@ extern int small_data_operand (rtx, enum machine_mode);\n extern bool toc_relative_expr_p (rtx);\n extern bool invalid_e500_subreg (rtx, enum machine_mode);\n extern void validate_condition_mode (enum rtx_code, enum machine_mode);\n-extern bool legitimate_constant_pool_address_p (const_rtx, bool);\n+extern bool legitimate_constant_pool_address_p (const_rtx, enum machine_mode,\n+\t\t\t\t\t\tbool);\n extern bool legitimate_indirect_address_p (rtx, int);\n extern bool legitimate_indexed_address_p (rtx, int);\n extern bool avoiding_indexed_address_p (enum machine_mode);"}, {"sha": "0ff174519d3b8abe961bdccfbe1180ca8b2cf8e6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 111, "deletions": 45, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77b0791e3dd1c8f8115499725357d0791334ce85/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77b0791e3dd1c8f8115499725357d0791334ce85/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=77b0791e3dd1c8f8115499725357d0791334ce85", "patch": "@@ -5791,6 +5791,94 @@ virtual_stack_registers_memory_p (rtx op)\n \t  && regnum <= LAST_VIRTUAL_POINTER_REGISTER);\n }\n \n+/* Return true if memory accesses to OP are known to never straddle\n+   a 32k boundary.  */\n+\n+static bool\n+offsettable_ok_by_alignment (rtx op, HOST_WIDE_INT offset,\n+\t\t\t     enum machine_mode mode)\n+{\n+  tree decl, type;\n+  unsigned HOST_WIDE_INT dsize, dalign;\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return false;\n+\n+  decl = SYMBOL_REF_DECL (op);\n+  if (!decl)\n+    {\n+      if (GET_MODE_SIZE (mode) == 0)\n+\treturn false;\n+\n+      /* -fsection-anchors loses the original SYMBOL_REF_DECL when\n+\t replacing memory addresses with an anchor plus offset.  We\n+\t could find the decl by rummaging around in the block->objects\n+\t VEC for the given offset but that seems like too much work.  */\n+      dalign = 1;\n+      if (SYMBOL_REF_HAS_BLOCK_INFO_P (op)\n+\t  && SYMBOL_REF_ANCHOR_P (op)\n+\t  && SYMBOL_REF_BLOCK (op) != NULL)\n+\t{\n+\t  struct object_block *block = SYMBOL_REF_BLOCK (op);\n+\t  HOST_WIDE_INT lsb, mask;\n+\n+\t  /* Given the alignment of the block..  */\n+\t  dalign = block->alignment;\n+\t  mask = dalign / BITS_PER_UNIT - 1;\n+\n+\t  /* ..and the combined offset of the anchor and any offset\n+\t     to this block object..  */\n+\t  offset += SYMBOL_REF_BLOCK_OFFSET (op);\n+\t  lsb = offset & -offset;\n+\n+\t  /* ..find how many bits of the alignment we know for the\n+\t     object.  */\n+\t  mask &= lsb - 1;\n+\t  dalign = mask + 1;\n+\t}\n+      return dalign >= GET_MODE_SIZE (mode);\n+    }\n+\n+  if (DECL_P (decl))\n+    {\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\treturn true;\n+\n+      if (!DECL_SIZE_UNIT (decl))\n+\treturn false;\n+\n+      if (!host_integerp (DECL_SIZE_UNIT (decl), 1))\n+\treturn false;\n+\n+      dsize = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n+      if (dsize > 32768)\n+\treturn false;\n+\n+      dalign = DECL_ALIGN_UNIT (decl);\n+      return dalign >= dsize;\n+    }\n+\n+  type = TREE_TYPE (decl);\n+\n+  if (TREE_CODE (decl) == STRING_CST)\n+    dsize = TREE_STRING_LENGTH (decl);\n+  else if (TYPE_SIZE_UNIT (type)\n+\t   && host_integerp (TYPE_SIZE_UNIT (type), 1))\n+    dsize = tree_low_cst (TYPE_SIZE_UNIT (type), 1);\n+  else\n+    return false;\n+  if (dsize > 32768)\n+    return false;\n+\n+  dalign = TYPE_ALIGN (type);\n+  if (CONSTANT_CLASS_P (decl))\n+    dalign = CONSTANT_ALIGNMENT (decl, dalign);\n+  else\n+    dalign = DATA_ALIGNMENT (decl, dalign);\n+  dalign /= BITS_PER_UNIT;\n+  return dalign >= dsize;\n+}\n+\n static bool\n constant_pool_expr_p (rtx op)\n {\n@@ -5815,8 +5903,12 @@ toc_relative_expr_p (rtx op)\n \t  && XINT (tocrel_base, 1) == UNSPEC_TOCREL);\n }\n \n+/* Return true if X is a constant pool address, and also for cmodel=medium\n+   if X is a toc-relative address known to be offsettable within MODE.  */\n+\n bool\n-legitimate_constant_pool_address_p (const_rtx x, bool strict)\n+legitimate_constant_pool_address_p (const_rtx x, enum machine_mode mode,\n+\t\t\t\t    bool strict)\n {\n   return (TARGET_TOC\n \t  && (GET_CODE (x) == PLUS || GET_CODE (x) == LO_SUM)\n@@ -5825,7 +5917,12 @@ legitimate_constant_pool_address_p (const_rtx x, bool strict)\n \t      || ((TARGET_MINIMAL_TOC\n \t\t   || TARGET_CMODEL != CMODEL_SMALL)\n \t\t  && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict)))\n-\t  && toc_relative_expr_p (XEXP (x, 1)));\n+\t  && toc_relative_expr_p (XEXP (x, 1))\n+\t  && (TARGET_CMODEL != CMODEL_MEDIUM\n+\t      || constant_pool_expr_p (XVECEXP (tocrel_base, 0, 0))\n+\t      || mode == QImode\n+\t      || offsettable_ok_by_alignment (XVECEXP (tocrel_base, 0, 0),\n+\t\t\t\t\t      INTVAL (tocrel_offset), mode)));\n }\n \n static bool\n@@ -5853,7 +5950,7 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n     return false;\n   if (!reg_offset_addressing_ok_p (mode))\n     return virtual_stack_registers_memory_p (x);\n-  if (legitimate_constant_pool_address_p (x, strict))\n+  if (legitimate_constant_pool_address_p (x, mode, strict))\n     return true;\n   if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n     return false;\n@@ -6853,7 +6950,8 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n     return 1;\n   if (reg_offset_p && legitimate_small_data_p (mode, x))\n     return 1;\n-  if (reg_offset_p && legitimate_constant_pool_address_p (x, reg_ok_strict))\n+  if (reg_offset_p\n+      && legitimate_constant_pool_address_p (x, mode, reg_ok_strict))\n     return 1;\n   /* If not REG_OK_STRICT (before reload) let pass any stack offset.  */\n   if (! reg_ok_strict\n@@ -6963,7 +7061,7 @@ rs6000_mode_dependent_address (const_rtx addr)\n     case LO_SUM:\n       /* Anything in the constant pool is sufficiently aligned that\n \t all bytes have the same high part address.  */\n-      return !legitimate_constant_pool_address_p (addr, false);\n+      return !legitimate_constant_pool_address_p (addr, QImode, false);\n \n     /* Auto-increment cases are now treated generically in recog.c.  */\n     case PRE_MODIFY:\n@@ -7327,53 +7425,21 @@ rs6000_eliminate_indexed_memrefs (rtx operands[2])\n \n   if (GET_CODE (operands[0]) == MEM\n       && GET_CODE (XEXP (operands[0], 0)) != REG\n-      && ! legitimate_constant_pool_address_p (XEXP (operands[0], 0), false))\n+      && ! legitimate_constant_pool_address_p (XEXP (operands[0], 0),\n+\t\t\t\t\t       GET_MODE (operands[0]), false))\n     operands[0]\n       = replace_equiv_address (operands[0],\n \t\t\t       copy_addr_to_reg (XEXP (operands[0], 0)));\n \n   if (GET_CODE (operands[1]) == MEM\n       && GET_CODE (XEXP (operands[1], 0)) != REG\n-      && ! legitimate_constant_pool_address_p (XEXP (operands[1], 0), false))\n+      && ! legitimate_constant_pool_address_p (XEXP (operands[1], 0),\n+\t\t\t\t\t       GET_MODE (operands[1]), false))\n     operands[1]\n       = replace_equiv_address (operands[1],\n \t\t\t       copy_addr_to_reg (XEXP (operands[1], 0)));\n }\n \n-/* Return true if memory accesses to DECL are known to never straddle\n-   a 32k boundary.  */\n-\n-static bool\n-offsettable_ok_by_alignment (tree decl)\n-{\n-  unsigned HOST_WIDE_INT dsize, dalign;\n-\n-  /* Presume any compiler generated symbol_ref is suitably aligned.  */\n-  if (!decl)\n-    return true;\n-\n-  if (TREE_CODE (decl) != VAR_DECL\n-      && TREE_CODE (decl) != PARM_DECL\n-      && TREE_CODE (decl) != RESULT_DECL\n-      && TREE_CODE (decl) != FIELD_DECL)\n-    return true;\n-\n-  if (!DECL_SIZE_UNIT (decl))\n-    return false;\n-\n-  if (!host_integerp (DECL_SIZE_UNIT (decl), 1))\n-    return false;\n-\n-  dsize = tree_low_cst (DECL_SIZE_UNIT (decl), 1);\n-  if (dsize <= 1)\n-    return true;\n-  if (dsize > 32768)\n-    return false;\n-\n-  dalign = DECL_ALIGN_UNIT (decl);\n-  return dalign >= dsize;\n-}\n-\n /* Emit a move from SOURCE to DEST in mode MODE.  */\n void\n rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n@@ -7695,8 +7761,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t  || (TARGET_CMODEL == CMODEL_MEDIUM\n \t      && GET_CODE (operands[1]) == SYMBOL_REF\n \t      && !CONSTANT_POOL_ADDRESS_P (operands[1])\n-\t      && SYMBOL_REF_LOCAL_P (operands[1])\n-\t      && offsettable_ok_by_alignment (SYMBOL_REF_DECL (operands[1]))))\n+\t      && SYMBOL_REF_LOCAL_P (operands[1])))\n \t{\n \t  rtx reg = NULL_RTX;\n \t  if (TARGET_CMODEL != CMODEL_SMALL)\n@@ -7718,7 +7783,8 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t\t   || (GET_CODE (operands[0]) == REG\n \t\t       && FP_REGNO_P (REGNO (operands[0]))))\n \t       && GET_CODE (operands[1]) != HIGH\n-\t       && ! legitimate_constant_pool_address_p (operands[1], false)\n+\t       && ! legitimate_constant_pool_address_p (operands[1], mode,\n+\t\t\t\t\t\t\tfalse)\n \t       && ! toc_relative_expr_p (operands[1])\n \t       && (TARGET_CMODEL == CMODEL_SMALL\n \t\t   || can_create_pseudo_p ()\n@@ -16444,7 +16510,7 @@ print_operand_address (FILE *file, rtx x)\n       fprintf (file, \")(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n     }\n #endif\n-  else if (legitimate_constant_pool_address_p (x, true))\n+  else if (legitimate_constant_pool_address_p (x, QImode, true))\n     {\n       /* This hack along with a corresponding hack in\n \t rs6000_output_addr_const_extra arranges to output addends"}]}