{"sha": "1628e36bcf93a88d29885dd4e47e44ba80f909c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYyOGUzNmJjZjkzYTg4ZDI5ODg1ZGQ0ZTQ3ZTQ0YmE4MGY5MDljNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-06-22T07:12:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-06-22T07:12:22Z"}, "message": "re PR ipa/65908 (ICE: in expand_thunk, at cgraphunit.c:1700)\n\n\n\tPR ipa/65908\n\t* ipa-icf.c (sem_item::target_supports_symbol_aliases): Remove\n\tconstruction of arg_types.\n\t(sem_function::sem_function): Likewise.\n\t(sem_function::~sem_function): Remove destruction of arg_types.\n\t(sem_function::compatible_parm_types_p): New function.\n\t(sem_function::equals_wpa): Reorg matching of return values\n\tand parameter types.\n\t(sem_function::equals_private): Reorg mathcing of argument types.\n\t(sem_function::parse_tree_args): Remove.\n\t* ipa-icf.h (init_wpa): Do not call it.\n\t(parse_tree_args): Remove.\n\t(compatible_parm_types_p): Declare.\n\t(result_type): Remove.\n\t(arg_types): Remove.\n\t* testsuite/g++.dg/ipa/pr65908.C: New testcase.\n\nCo-Authored-By: Martin Liska <mliska@suse.cz>\n\nFrom-SVN: r224720", "tree": {"sha": "181883c54c895a0afe9404a8d38108c40f3e86c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/181883c54c895a0afe9404a8d38108c40f3e86c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1628e36bcf93a88d29885dd4e47e44ba80f909c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1628e36bcf93a88d29885dd4e47e44ba80f909c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1628e36bcf93a88d29885dd4e47e44ba80f909c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1628e36bcf93a88d29885dd4e47e44ba80f909c6/comments", "author": null, "committer": null, "parents": [{"sha": "7083621fad0baad1dfcbb6ab42bea360879c2081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7083621fad0baad1dfcbb6ab42bea360879c2081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7083621fad0baad1dfcbb6ab42bea360879c2081"}], "stats": {"total": 193, "additions": 119, "deletions": 74}, "files": [{"sha": "a0bcee81d69e972b0d15daec04efcc37ed9fa675", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1628e36bcf93a88d29885dd4e47e44ba80f909c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1628e36bcf93a88d29885dd4e47e44ba80f909c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1628e36bcf93a88d29885dd4e47e44ba80f909c6", "patch": "@@ -1,3 +1,22 @@\n+2015-06-22  Jan Hubicka  <hubicka@ucw.cz>\n+\t    Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/65908\n+\t* ipa-icf.c (sem_item::target_supports_symbol_aliases): Remove\n+\tconstruction of arg_types.\n+\t(sem_function::sem_function): Likewise.\n+\t(sem_function::~sem_function): Remove destruction of arg_types.\n+\t(sem_function::compatible_parm_types_p): New function.\n+\t(sem_function::equals_wpa): Reorg matching of return values\n+\tand parameter types.\n+\t(sem_function::equals_private): Reorg mathcing of argument types.\n+\t(sem_function::parse_tree_args): Remove.\n+\t* ipa-icf.h (init_wpa): Do not call it.\n+\t(parse_tree_args): Remove.\n+\t(compatible_parm_types_p): Declare.\n+\t(result_type): Remove.\n+\t(arg_types): Remove.\n+\n 2015-06-22  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/66351"}, {"sha": "9a8133faa2c4620acf27e54fd6c2f02951d97a56", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 63, "deletions": 64, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1628e36bcf93a88d29885dd4e47e44ba80f909c6/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1628e36bcf93a88d29885dd4e47e44ba80f909c6/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=1628e36bcf93a88d29885dd4e47e44ba80f909c6", "patch": "@@ -259,7 +259,6 @@ sem_item::target_supports_symbol_aliases_p (void)\n sem_function::sem_function (bitmap_obstack *stack): sem_item (FUNC, stack),\n   m_checker (NULL), m_compared_func (NULL)\n {\n-  arg_types.create (0);\n   bb_sizes.create (0);\n   bb_sorted.create (0);\n }\n@@ -271,7 +270,6 @@ sem_function::sem_function (cgraph_node *node, hashval_t hash,\n   sem_item (FUNC, node, hash, stack),\n   m_checker (NULL), m_compared_func (NULL)\n {\n-  arg_types.create (0);\n   bb_sizes.create (0);\n   bb_sorted.create (0);\n }\n@@ -281,7 +279,6 @@ sem_function::~sem_function ()\n   for (unsigned i = 0; i < bb_sorted.length (); i++)\n     delete (bb_sorted[i]);\n \n-  arg_types.release ();\n   bb_sizes.release ();\n   bb_sorted.release ();\n }\n@@ -581,6 +578,30 @@ sem_function::param_used_p (unsigned int i)\n   return ipa_is_param_used (IPA_NODE_REF (get_node ()), i);\n }\n \n+/* Perform additional check needed to match types function parameters that are\n+   used.  Unlike for normal decls it matters if type is TYPE_RESTRICT and we\n+   make an assumption that REFERENCE_TYPE parameters are always non-NULL.  */\n+\n+bool\n+sem_function::compatible_parm_types_p (tree parm1, tree parm2)\n+{\n+  /* Be sure that parameters are TBAA compatible.  */\n+  if (!func_checker::compatible_types_p (parm1, parm2))\n+    return return_false_with_msg (\"parameter type is not compatible\");\n+\n+  if (POINTER_TYPE_P (parm1)\n+      && (TYPE_RESTRICT (parm1) != TYPE_RESTRICT (parm2)))\n+    return return_false_with_msg (\"argument restrict flag mismatch\");\n+\n+  /* nonnull_arg_p implies non-zero range to REFERENCE types.  */\n+  if (POINTER_TYPE_P (parm1)\n+      && TREE_CODE (parm1) != TREE_CODE (parm2)\n+      && opt_for_fn (decl, flag_delete_null_pointer_checks))\n+    return return_false_with_msg (\"pointer wrt reference mismatch\");\n+\n+  return true;\n+}\n+\n /* Fast equality function based on knowledge known in WPA.  */\n \n bool\n@@ -593,9 +614,6 @@ sem_function::equals_wpa (sem_item *item,\n \n   m_compared_func = static_cast<sem_function *> (item);\n \n-  if (arg_types.length () != m_compared_func->arg_types.length ())\n-    return return_false_with_msg (\"different number of arguments\");\n-\n   if (cnode->thunk.thunk_p != cnode2->thunk.thunk_p)\n     return return_false_with_msg (\"thunk_p mismatch\");\n \n@@ -684,38 +702,40 @@ sem_function::equals_wpa (sem_item *item,\n     }\n \n   /* Result type checking.  */\n-  if (!func_checker::compatible_types_p (result_type,\n-\t\t\t\t\t m_compared_func->result_type))\n+  if (!func_checker::compatible_types_p\n+\t (TREE_TYPE (TREE_TYPE (decl)),\n+\t  TREE_TYPE (TREE_TYPE (m_compared_func->decl))))\n     return return_false_with_msg (\"result types are different\");\n \n   /* Checking types of arguments.  */\n-  for (unsigned i = 0; i < arg_types.length (); i++)\n+  tree list1 = TYPE_ARG_TYPES (TREE_TYPE (decl)),\n+       list2 = TYPE_ARG_TYPES (TREE_TYPE (m_compared_func->decl));\n+  for (unsigned i = 0; list1 && list2;\n+       list1 = TREE_CHAIN (list1), list2 = TREE_CHAIN (list2), i++)\n     {\n+      tree parm1 = TREE_VALUE (list1);\n+      tree parm2 = TREE_VALUE (list2);\n+\n       /* This guard is here for function pointer with attributes (pr59927.c).  */\n-      if (!arg_types[i] || !m_compared_func->arg_types[i])\n+      if (!parm1 || !parm2)\n \treturn return_false_with_msg (\"NULL argument type\");\n \n-      /* We always need to match types so we are sure the callin conventions\n-\t are compatible.  */\n-      if (!func_checker::compatible_types_p (arg_types[i],\n-\t\t\t\t\t     m_compared_func->arg_types[i]))\n-\treturn return_false_with_msg (\"argument type is different\");\n+      /* Verify that types are compatible to ensure that both functions\n+\t have same calling conventions.  */\n+      if (!types_compatible_p (parm1, parm2))\n+\treturn return_false_with_msg (\"parameter types are not compatible\");\n \n-      /* On used arguments we need to do a bit more of work.  */\n       if (!param_used_p (i))\n \tcontinue;\n-      if (POINTER_TYPE_P (arg_types[i])\n-\t  && (TYPE_RESTRICT (arg_types[i])\n-\t      != TYPE_RESTRICT (m_compared_func->arg_types[i])))\n-\treturn return_false_with_msg (\"argument restrict flag mismatch\");\n-      /* nonnull_arg_p implies non-zero range to REFERENCE types.  */\n-      if (POINTER_TYPE_P (arg_types[i])\n-\t  && TREE_CODE (arg_types[i])\n-\t     != TREE_CODE (m_compared_func->arg_types[i])\n-\t  && opt_for_fn (decl, flag_delete_null_pointer_checks))\n-\treturn return_false_with_msg (\"pointer wrt reference mismatch\");\n+\n+      /* Perform additional checks for used parameters.  */\n+      if (!compatible_parm_types_p (parm1, parm2))\n+\treturn false;\n     }\n \n+  if (list1 || list2)\n+    return return_false_with_msg (\"Mismatched number of parameters\");\n+\n   if (node->num_references () != item->node->num_references ())\n     return return_false_with_msg (\"different number of references\");\n \n@@ -922,11 +942,23 @@ sem_function::equals_private (sem_item *item)\n \t\t\t\tfalse,\n \t\t\t\t&refs_set,\n \t\t\t\t&m_compared_func->refs_set);\n-  for (arg1 = DECL_ARGUMENTS (decl),\n-       arg2 = DECL_ARGUMENTS (m_compared_func->decl);\n-       arg1; arg1 = DECL_CHAIN (arg1), arg2 = DECL_CHAIN (arg2))\n-    if (!m_checker->compare_decl (arg1, arg2))\n-      return return_false ();\n+  arg1 = DECL_ARGUMENTS (decl);\n+  arg2 = DECL_ARGUMENTS (m_compared_func->decl);\n+  for (unsigned i = 0;\n+       arg1 && arg2; arg1 = DECL_CHAIN (arg1), arg2 = DECL_CHAIN (arg2), i++)\n+    {\n+      if (!types_compatible_p (TREE_TYPE (arg1), TREE_TYPE (arg2)))\n+\treturn return_false_with_msg (\"argument types are not compatible\");\n+      if (!param_used_p (i))\n+\tcontinue;\n+      /* Perform additional checks for used parameters.  */\n+      if (!compatible_parm_types_p (TREE_TYPE (arg1), TREE_TYPE (arg2)))\n+\treturn false;\n+      if (!m_checker->compare_decl (arg1, arg2))\n+        return return_false ();\n+    }\n+  if (arg1 || arg2)\n+    return return_false_with_msg (\"Mismatched number of arguments\");\n \n   if (!dyn_cast <cgraph_node *> (node)->has_gimple_body_p ())\n     return true;\n@@ -1439,8 +1471,6 @@ sem_function::init (void)\n       hstate.add_flag (cnode->thunk.add_pointer_bounds_args);\n       gcode_hash = hstate.end ();\n     }\n-\n-  parse_tree_args ();\n }\n \n /* Accumulate to HSTATE a hash of expression EXP.\n@@ -1691,37 +1721,6 @@ sem_function::parse (cgraph_node *node, bitmap_obstack *stack)\n   return f;\n }\n \n-/* Parses function arguments and result type.  */\n-\n-void\n-sem_function::parse_tree_args (void)\n-{\n-  tree result;\n-\n-  if (arg_types.exists ())\n-    arg_types.release ();\n-\n-  arg_types.create (4);\n-  tree fnargs = DECL_ARGUMENTS (decl);\n-\n-  for (tree parm = fnargs; parm; parm = DECL_CHAIN (parm))\n-    arg_types.safe_push (DECL_ARG_TYPE (parm));\n-\n-  /* Function result type.  */\n-  result = DECL_RESULT (decl);\n-  result_type = result ? TREE_TYPE (result) : NULL;\n-\n-  /* During WPA, we can get arguments by following method.  */\n-  if (!fnargs)\n-    {\n-      tree type = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-      for (tree parm = type; parm; parm = TREE_CHAIN (parm))\n-\targ_types.safe_push (TYPE_CANONICAL (TREE_VALUE (parm)));\n-\n-      result_type = TREE_TYPE (TREE_TYPE (decl));\n-    }\n-}\n-\n /* For given basic blocks BB1 and BB2 (from functions FUNC1 and FUNC),\n    return true if phi nodes are semantically equivalent in these blocks .  */\n "}, {"sha": "ee35ee27ac26090a8e55b29ea26f93f9479c8a75", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1628e36bcf93a88d29885dd4e47e44ba80f909c6/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1628e36bcf93a88d29885dd4e47e44ba80f909c6/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=1628e36bcf93a88d29885dd4e47e44ba80f909c6", "patch": "@@ -292,7 +292,6 @@ class sem_function: public sem_item\n \n   inline virtual void init_wpa (void)\n   {\n-    parse_tree_args ();\n   }\n \n   virtual void init (void);\n@@ -310,9 +309,6 @@ class sem_function: public sem_item\n     dump_function_to_file (decl, file, TDF_DETAILS);\n   }\n \n-  /* Parses function arguments and result type.  */\n-  void parse_tree_args (void);\n-\n   /* Returns cgraph_node.  */\n   inline cgraph_node *get_node (void)\n   {\n@@ -329,15 +325,13 @@ class sem_function: public sem_item\n      semantic function item.  */\n   static sem_function *parse (cgraph_node *node, bitmap_obstack *stack);\n \n+  /* Perform additional checks needed to match types of used function\n+     paramters.  */\n+  bool compatible_parm_types_p (tree, tree);\n+\n   /* Exception handling region tree.  */\n   eh_region region_tree;\n \n-  /* Result type tree node.  */\n-  tree result_type;\n-\n-  /* Array of argument tree types.  */\n-  vec <tree> arg_types;\n-\n   /* Number of function arguments.  */\n   unsigned int arg_count;\n "}, {"sha": "0e33302ea5956f06c733a0160978caff8105bc48", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1628e36bcf93a88d29885dd4e47e44ba80f909c6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1628e36bcf93a88d29885dd4e47e44ba80f909c6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1628e36bcf93a88d29885dd4e47e44ba80f909c6", "patch": "@@ -1,3 +1,9 @@\n+2015-06-22  Jan Hubicka  <hubicka@ucw.cz>\n+\t    Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/65908\n+\t* g++.dg/ipa/pr65908.C: New testcase.\n+\n 2015-06-20  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \tPR c++/65882"}, {"sha": "38730bd0b2db187a531428e4e703250852d5faf9", "filename": "gcc/testsuite/g++.dg/ipa/pr65908.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1628e36bcf93a88d29885dd4e47e44ba80f909c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr65908.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1628e36bcf93a88d29885dd4e47e44ba80f909c6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr65908.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr65908.C?ref=1628e36bcf93a88d29885dd4e47e44ba80f909c6", "patch": "@@ -0,0 +1,27 @@\n+// PR ipa/65908\n+// { dg-do compile }\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-fPIC\" { target fpic } }\n+\n+class A\n+{\n+  A (A &);\n+};\n+class B\n+{\n+  const A &m_fn1 () const;\n+};\n+class C\n+{\n+  A m_fn2 () const;\n+};\n+A\n+C::m_fn2 () const\n+{\n+  throw 0;\n+}\n+const A &\n+B::m_fn1 () const\n+{\n+  throw 0;\n+}"}]}