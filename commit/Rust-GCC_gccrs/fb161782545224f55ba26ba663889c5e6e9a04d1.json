{"sha": "fb161782545224f55ba26ba663889c5e6e9a04d1", "node_id": "C_kwDOANBUbNoAKGZiMTYxNzgyNTQ1MjI0ZjU1YmEyNmJhNjYzODg5YzVlNmU5YTA0ZDE", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-10-25T05:59:51Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-11-10T09:16:42Z"}, "message": "Improve integer bit test on __atomic_fetch_[or|and]_* returns\n\ncommit adedd5c173388ae505470df152b9cb3947339566\nAuthor: Jakub Jelinek <jakub@redhat.com>\nDate:   Tue May 3 13:37:25 2016 +0200\n\n    re PR target/49244 (__sync or __atomic builtins will not emit 'lock bts/btr/btc')\n\noptimized bit test on __atomic_fetch_or_* and __atomic_fetch_and_* returns\nwith lock bts/btr/btc by turning\n\n  mask_2 = 1 << cnt_1;\n  _4 = __atomic_fetch_or_* (ptr_6, mask_2, _3);\n  _5 = _4 & mask_2;\n\ninto\n\n  _4 = ATOMIC_BIT_TEST_AND_SET (ptr_6, cnt_1, 0, _3);\n  _5 = _4;\n\nand\n\n  mask_6 = 1 << bit_5(D);\n  _1 = ~mask_6;\n  _2 = __atomic_fetch_and_4 (v_8(D), _1, 0);\n  _3 = _2 & mask_6;\n  _4 = _3 != 0;\n\ninto\n\n  mask_6 = 1 << bit_5(D);\n  _1 = ~mask_6;\n  _11 = .ATOMIC_BIT_TEST_AND_RESET (v_8(D), bit_5(D), 1, 0);\n  _4 = _11 != 0;\n\nBut it failed to optimize many equivalent, but slighly different cases:\n\n1.\n  _1 = __atomic_fetch_or_4 (ptr_6, 1, _3);\n  _4 = (_Bool) _1;\n2.\n  _1 = __atomic_fetch_and_4 (ptr_6, ~1, _3);\n  _4 = (_Bool) _1;\n3.\n  _1 = __atomic_fetch_or_4 (ptr_6, 1, _3);\n  _7 = ~_1;\n  _5 = (_Bool) _7;\n4.\n  _1 = __atomic_fetch_and_4 (ptr_6, ~1, _3);\n  _7 = ~_1;\n  _5 = (_Bool) _7;\n5.\n  _1 = __atomic_fetch_or_4 (ptr_6, 1, _3);\n  _2 = (int) _1;\n  _7 = ~_2;\n  _5 = (_Bool) _7;\n6.\n  _1 = __atomic_fetch_and_4 (ptr_6, ~1, _3);\n  _2 = (int) _1;\n  _7 = ~_2;\n  _5 = (_Bool) _7;\n7.\n  _1 = __atomic_fetch_or_4 (ptr_6, 0x80000000, _3);\n  _5 = (signed int) _1;\n  _4 = _5 < 0;\n8.\n  _1 = __atomic_fetch_and_4 (ptr_6, 0x7fffffff, _3);\n  _5 = (signed int) _1;\n  _4 = _5 < 0;\n9.\n  _1 = 1 << bit_4(D);\n  mask_5 = (unsigned int) _1;\n  _2 = __atomic_fetch_or_4 (v_7(D), mask_5, 0);\n  _3 = _2 & mask_5;\n10.\n  mask_7 = 1 << bit_6(D);\n  _1 = ~mask_7;\n  _2 = (unsigned int) _1;\n  _3 = __atomic_fetch_and_4 (v_9(D), _2, 0);\n  _4 = (int) _3;\n  _5 = _4 & mask_7;\n\nWe make\n\n  mask_2 = 1 << cnt_1;\n  _4 = __atomic_fetch_or_* (ptr_6, mask_2, _3);\n  _5 = _4 & mask_2;\n\nand\n\n  mask_6 = 1 << bit_5(D);\n  _1 = ~mask_6;\n  _2 = __atomic_fetch_and_4 (v_8(D), _1, 0);\n  _3 = _2 & mask_6;\n  _4 = _3 != 0;\n\nthe canonical forms for this optimization and transform cases 1-9 to the\nequivalent canonical form.  For cases 10 and 11, we simply remove the cast\nbefore __atomic_fetch_or_4/__atomic_fetch_and_4 with\n\n  _1 = 1 << bit_4(D);\n  _2 = __atomic_fetch_or_4 (v_7(D), _1, 0);\n  _3 = _2 & _1;\n\nand\n\n  mask_7 = 1 << bit_6(D);\n  _1 = ~mask_7;\n  _3 = __atomic_fetch_and_4 (v_9(D), _1, 0);\n  _6 = _3 & mask_7;\n  _5 = (int) _6;\n\n2021-11-04  H.J. Lu  <hongjiu.lu@intel.com>\n\t    Hongtao Liu  <hongtao.liu@intel.com>\ngcc/\n\n\tPR middle-end/102566\n\t* match.pd (nop_atomic_bit_test_and_p): New match.\n\t* tree-ssa-ccp.c (convert_atomic_bit_not): New function.\n\t(gimple_nop_atomic_bit_test_and_p): New prototype.\n\t(optimize_atomic_bit_test_and): Transform equivalent, but slighly\n\tdifferent cases to their canonical forms.\n\ngcc/testsuite/\n\n\tPR middle-end/102566\n\t* g++.target/i386/pr102566-1.C: New test.\n\t* g++.target/i386/pr102566-2.C: Likewise.\n\t* g++.target/i386/pr102566-3.C: Likewise.\n\t* g++.target/i386/pr102566-4.C: Likewise.\n\t* g++.target/i386/pr102566-5a.C: Likewise.\n\t* g++.target/i386/pr102566-5b.C: Likewise.\n\t* g++.target/i386/pr102566-6a.C: Likewise.\n\t* g++.target/i386/pr102566-6b.C: Likewise.\n\t* gcc.target/i386/pr102566-1a.c: Likewise.\n\t* gcc.target/i386/pr102566-1b.c: Likewise.\n\t* gcc.target/i386/pr102566-2.c: Likewise.\n\t* gcc.target/i386/pr102566-3a.c: Likewise.\n\t* gcc.target/i386/pr102566-3b.c: Likewise.\n\t* gcc.target/i386/pr102566-4.c: Likewise.\n\t* gcc.target/i386/pr102566-5.c: Likewise.\n\t* gcc.target/i386/pr102566-6.c: Likewise.\n\t* gcc.target/i386/pr102566-7.c: Likewise.\n\t* gcc.target/i386/pr102566-8a.c: Likewise.\n\t* gcc.target/i386/pr102566-8b.c: Likewise.\n\t* gcc.target/i386/pr102566-9a.c: Likewise.\n\t* gcc.target/i386/pr102566-9b.c: Likewise.\n\t* gcc.target/i386/pr102566-10a.c: Likewise.\n\t* gcc.target/i386/pr102566-10b.c: Likewise.\n\t* gcc.target/i386/pr102566-11.c: Likewise.\n\t* gcc.target/i386/pr102566-12.c: Likewise.\n\t* gcc.target/i386/pr102566-13.c: New test.\n\t* gcc.target/i386/pr102566-14.c: New test.", "tree": {"sha": "0e1df016da34d448c1147993b1cf8859eb7d8fa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e1df016da34d448c1147993b1cf8859eb7d8fa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb161782545224f55ba26ba663889c5e6e9a04d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb161782545224f55ba26ba663889c5e6e9a04d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb161782545224f55ba26ba663889c5e6e9a04d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb161782545224f55ba26ba663889c5e6e9a04d1/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc"}], "stats": {"total": 1599, "additions": 1557, "deletions": 42}, "files": [{"sha": "a319aefa8081ac177981ad425c461f8a771128f4", "filename": "gcc/match.pd", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -105,6 +105,39 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n (define_operator_list COND_TERNARY\n   IFN_COND_FMA IFN_COND_FMS IFN_COND_FNMA IFN_COND_FNMS)\n \n+/* __atomic_fetch_or_*, __atomic_fetch_xor_*, __atomic_xor_fetch_*  */\n+(define_operator_list ATOMIC_FETCH_OR_XOR_N\n+  BUILT_IN_ATOMIC_FETCH_OR_1 BUILT_IN_ATOMIC_FETCH_OR_2\n+  BUILT_IN_ATOMIC_FETCH_OR_4 BUILT_IN_ATOMIC_FETCH_OR_8\n+  BUILT_IN_ATOMIC_FETCH_OR_16\n+  BUILT_IN_ATOMIC_FETCH_XOR_1 BUILT_IN_ATOMIC_FETCH_XOR_2\n+  BUILT_IN_ATOMIC_FETCH_XOR_4 BUILT_IN_ATOMIC_FETCH_XOR_8\n+  BUILT_IN_ATOMIC_FETCH_XOR_16\n+  BUILT_IN_ATOMIC_XOR_FETCH_1 BUILT_IN_ATOMIC_XOR_FETCH_2\n+  BUILT_IN_ATOMIC_XOR_FETCH_4 BUILT_IN_ATOMIC_XOR_FETCH_8\n+  BUILT_IN_ATOMIC_XOR_FETCH_16)\n+/* __sync_fetch_and_or_*, __sync_fetch_and_xor_*, __sync_xor_and_fetch_*  */\n+(define_operator_list SYNC_FETCH_OR_XOR_N\n+  BUILT_IN_SYNC_FETCH_AND_OR_1 BUILT_IN_SYNC_FETCH_AND_OR_2\n+  BUILT_IN_SYNC_FETCH_AND_OR_4 BUILT_IN_SYNC_FETCH_AND_OR_8\n+  BUILT_IN_SYNC_FETCH_AND_OR_16\n+  BUILT_IN_SYNC_FETCH_AND_XOR_1 BUILT_IN_SYNC_FETCH_AND_XOR_2\n+  BUILT_IN_SYNC_FETCH_AND_XOR_4 BUILT_IN_SYNC_FETCH_AND_XOR_8\n+  BUILT_IN_SYNC_FETCH_AND_XOR_16\n+  BUILT_IN_SYNC_XOR_AND_FETCH_1 BUILT_IN_SYNC_XOR_AND_FETCH_2\n+  BUILT_IN_SYNC_XOR_AND_FETCH_4 BUILT_IN_SYNC_XOR_AND_FETCH_8\n+  BUILT_IN_SYNC_XOR_AND_FETCH_16)\n+/* __atomic_fetch_and_*.  */\n+(define_operator_list ATOMIC_FETCH_AND_N\n+  BUILT_IN_ATOMIC_FETCH_AND_1 BUILT_IN_ATOMIC_FETCH_AND_2\n+  BUILT_IN_ATOMIC_FETCH_AND_4 BUILT_IN_ATOMIC_FETCH_AND_8\n+  BUILT_IN_ATOMIC_FETCH_AND_16)\n+/* __sync_fetch_and_and_*.  */\n+(define_operator_list SYNC_FETCH_AND_AND_N\n+  BUILT_IN_SYNC_FETCH_AND_AND_1 BUILT_IN_SYNC_FETCH_AND_AND_2\n+  BUILT_IN_SYNC_FETCH_AND_AND_4 BUILT_IN_SYNC_FETCH_AND_AND_8\n+  BUILT_IN_SYNC_FETCH_AND_AND_16)\n+\n /* With nop_convert? combine convert? and view_convert? in one pattern\n    plus conditionalize on tree_nop_conversion_p conversions.  */\n (match (nop_convert @0)\n@@ -3976,6 +4009,76 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (vec_cond @0 (op! @3 @1) (op! @3 @2))))\n #endif\n \n+#if GIMPLE\n+(match (nop_atomic_bit_test_and_p @0 @1 @4)\n+ (bit_and (nop_convert?@4 (ATOMIC_FETCH_OR_XOR_N @2 INTEGER_CST@0 @3))\n+\t   INTEGER_CST@1)\n+ (with {\n+\t int ibit = tree_log2 (@0);\n+\t int ibit2 = tree_log2 (@1);\n+       }\n+  (if (ibit == ibit2\n+      && ibit >= 0))))\n+\n+(match (nop_atomic_bit_test_and_p @0 @1 @3)\n+ (bit_and (nop_convert?@3 (SYNC_FETCH_OR_XOR_N @2 INTEGER_CST@0))\n+\t  INTEGER_CST@1)\n+ (with {\n+\t int ibit = tree_log2 (@0);\n+\t int ibit2 = tree_log2 (@1);\n+       }\n+  (if (ibit == ibit2\n+      && ibit >= 0))))\n+\n+(match (nop_atomic_bit_test_and_p @0 @0 @4)\n+ (bit_and:c\n+  (nop_convert?@4\n+   (ATOMIC_FETCH_OR_XOR_N @2 (nop_convert? (lshift@0 integer_onep@5 @6)) @3))\n+  @0))\n+\n+(match (nop_atomic_bit_test_and_p @0 @0 @4)\n+ (bit_and:c\n+  (nop_convert?@4\n+   (SYNC_FETCH_OR_XOR_N @2 (nop_convert? (lshift@0 integer_onep@3 @5))))\n+  @0))\n+\n+(match (nop_atomic_bit_test_and_p @0 @1 @3)\n+ (bit_and@4 (nop_convert?@3 (ATOMIC_FETCH_AND_N @2 INTEGER_CST@0 @5))\n+\t    INTEGER_CST@1)\n+ (with {\n+\t int ibit = wi::exact_log2 (wi::zext (wi::bit_not (wi::to_wide (@0)),\n+\t\t\t\t\t      TYPE_PRECISION(type)));\n+\t int ibit2 = tree_log2 (@1);\n+       }\n+  (if (ibit == ibit2\n+      && ibit >= 0))))\n+\n+(match (nop_atomic_bit_test_and_p @0 @1 @3)\n+ (bit_and@4\n+  (nop_convert?@3 (SYNC_FETCH_AND_AND_N @2 INTEGER_CST@0))\n+  INTEGER_CST@1)\n+ (with {\n+\t int ibit = wi::exact_log2 (wi::zext (wi::bit_not (wi::to_wide (@0)),\n+\t\t\t\t\t      TYPE_PRECISION(type)));\n+\t int ibit2 = tree_log2 (@1);\n+       }\n+  (if (ibit == ibit2\n+      && ibit >= 0))))\n+\n+(match (nop_atomic_bit_test_and_p @0 @0 @3)\n+ (bit_and:c\n+  (nop_convert?@3\n+   (ATOMIC_FETCH_AND_N @2 (nop_convert? (bit_not (lshift@0 integer_onep@6 @7))) @5))\n+   @0))\n+\n+(match (nop_atomic_bit_test_and_p @0 @0 @3)\n+ (bit_and:c\n+  (nop_convert?@3\n+   (SYNC_FETCH_AND_AND_N @2 (nop_convert? (bit_not (lshift@0 integer_onep@6 @7)))))\n+   @0))\n+\n+#endif\n+\n /* (v ? w : 0) ? a : b is just (v & w) ? a : b\n    Currently disabled after pass lvec because ARM understands\n    VEC_COND_EXPR<v==w,-1,0> but not a plain v==w fed to BIT_IOR_EXPR.  */"}, {"sha": "94a66d717ccc731147572bdba7c5ca4516f16bd6", "filename": "gcc/testsuite/g++.target/i386/pr102566-1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-1.C?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <atomic>\n+\n+bool\n+tbit0 (std::atomic<int> &i)\n+{\n+#define BIT (1 << 0)\n+  return i.fetch_or(BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+bool\n+tbit30 (std::atomic<int> &i)\n+{\n+#define BIT (1 << 30)\n+  return i.fetch_or(BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+bool\n+tbit31 (std::atomic<int> &i)\n+{\n+#define BIT (1 << 31)\n+  return i.fetch_or(BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btsl\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "4f2aea961c2c0d4a35edb9a46adbda8eb07925b0", "filename": "gcc/testsuite/g++.target/i386/pr102566-2.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-2.C?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <atomic>\n+\n+bool\n+tbit0 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 0)\n+  return i.fetch_or(BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+bool\n+tbit30 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 30)\n+  return i.fetch_or(BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+bool\n+tbit31 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 31)\n+  return i.fetch_or(BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btsl\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "e88921dd155f15760453c9e8eeca8c38a51d874e", "filename": "gcc/testsuite/g++.target/i386/pr102566-3.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-3.C?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <atomic>\n+\n+bool\n+tbit0 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 0)\n+  return !(i.fetch_or(BIT, std::memory_order_relaxed) & BIT);\n+#undef BIT \n+}\n+\n+bool\n+tbit30 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 30)\n+  return !(i.fetch_or(BIT, std::memory_order_relaxed) & BIT);\n+#undef BIT \n+}\n+\n+bool\n+tbit31 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 31)\n+  return !(i.fetch_or(BIT, std::memory_order_relaxed) & BIT);\n+#undef BIT \n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btsl\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "44d1362ac2e46c56eaf3aa73ee2d313bc63febad", "filename": "gcc/testsuite/g++.target/i386/pr102566-4.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-4.C?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <atomic>\n+\n+typedef int __attribute__ ((mode (__word__))) int_type;\n+\n+#define BIT (1 << 0)\n+\n+bool\n+tbit0 (std::atomic<int_type> &i)\n+{\n+  return i.fetch_or(BIT, std::memory_order_relaxed) & ~1;\n+}\n+\n+bool\n+tbit30 (std::atomic<int_type> &i)\n+{\n+  return i.fetch_or(BIT, std::memory_order_relaxed) & ~2;\n+}\n+\n+bool\n+tbit31 (std::atomic<int_type> &i)\n+{\n+  return i.fetch_or(BIT, std::memory_order_relaxed) & ~4;\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*cmpxchg\" 3 } } */\n+/* { dg-final { scan-assembler-not \"bts\" } } */"}, {"sha": "f9595bee2aba40500b33f6e9a003f0e57c08d08a", "filename": "gcc/testsuite/g++.target/i386/pr102566-5a.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-5a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-5a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-5a.C?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <atomic>\n+\n+bool\n+tbit0 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 0)\n+  return i.fetch_and(~BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+bool\n+tbit30 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 30)\n+  return i.fetch_and(~BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+bool\n+tbit31 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 31)\n+  return i.fetch_and(~BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btrl\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "d917b27a91846fc13d2843b5959414b9b571d263", "filename": "gcc/testsuite/g++.target/i386/pr102566-5b.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-5b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-5b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-5b.C?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target { c++11 && { ! ia32 } } } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <atomic>\n+\n+bool\n+tbit0 (std::atomic<unsigned long long> &i)\n+{\n+#define BIT (1ll << 0)\n+  return i.fetch_and(~BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+bool\n+tbit30 (std::atomic<unsigned long long> &i)\n+{\n+#define BIT (1ll << 30)\n+  return i.fetch_and(~BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+bool\n+tbit31 (std::atomic<unsigned long long> &i)\n+{\n+#define BIT (1ll << 63)\n+  return i.fetch_and(~BIT, std::memory_order_relaxed) & BIT;\n+#undef BIT \n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btrq\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "01d495eda23464bcc71094b22ba62cff23d1cb18", "filename": "gcc/testsuite/g++.target/i386/pr102566-6a.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-6a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-6a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-6a.C?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target c++11 } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <atomic>\n+\n+bool\n+tbit0 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 0)\n+  return !(i.fetch_and(~BIT, std::memory_order_relaxed) & BIT);\n+#undef BIT \n+}\n+\n+bool\n+tbit30 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 30)\n+  return !(i.fetch_and(~BIT, std::memory_order_relaxed) & BIT);\n+#undef BIT \n+}\n+\n+bool\n+tbit31 (std::atomic<unsigned int> &i)\n+{\n+#define BIT (1 << 31)\n+  return !(i.fetch_and(~BIT, std::memory_order_relaxed) & BIT);\n+#undef BIT \n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btrl\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "adc11fcbf2d1278a0a771668603112539166ebba", "filename": "gcc/testsuite/g++.target/i386/pr102566-6b.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-6b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-6b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Fi386%2Fpr102566-6b.C?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile { target { c++11 && { ! ia32 } } } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <atomic>\n+\n+bool\n+tbit0 (std::atomic<unsigned long long> &i)\n+{\n+#define BIT (1ll << 0)\n+  return !(i.fetch_and(~BIT, std::memory_order_relaxed) & BIT);\n+#undef BIT \n+}\n+\n+bool\n+tbit30 (std::atomic<unsigned long long> &i)\n+{\n+#define BIT (1ll << 30)\n+  return !(i.fetch_and(~BIT, std::memory_order_relaxed) & BIT);\n+#undef BIT \n+}\n+\n+bool\n+tbit31 (std::atomic<unsigned long long> &i)\n+{\n+#define BIT (1ll << 63)\n+  return !(i.fetch_and(~BIT, std::memory_order_relaxed) & BIT);\n+#undef BIT \n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btrq\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "1c1f86a965928099f004ff6b463216f94efa796d", "filename": "gcc/testsuite/gcc.target/i386/pr102566-10a.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-10a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-10a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-10a.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo (_Atomic int *v, int bit)\n+{\n+  int mask = 1 << bit;\n+  return atomic_fetch_and_explicit (v, ~mask, memory_order_relaxed) & mask;\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btrl\" 1 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "0bf39824ea6b74dabf0b4d105ba4215314cb6250", "filename": "gcc/testsuite/gcc.target/i386/pr102566-10b.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-10b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-10b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-10b.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo (_Atomic long long int *v, int bit)\n+{\n+  long long int mask = 1ll << bit;\n+  return atomic_fetch_and_explicit (v, ~mask, memory_order_relaxed) & mask;\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btrq\" 1 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "2c8f8c4e59a580c7f61b1e9c584af3e6442e7c5d", "filename": "gcc/testsuite/gcc.target/i386/pr102566-11.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-11.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+#define MASK 0x1234\n+\n+bool\n+foo1 (_Atomic int *v)\n+{\n+  return atomic_fetch_or_explicit (v, MASK, memory_order_relaxed) & MASK;\n+}\n+\n+bool\n+foo2 (_Atomic unsigned int *v, int mask)\n+{\n+  return atomic_fetch_or_explicit (v, mask, memory_order_relaxed) & mask;\n+}\n+\n+bool\n+foo3 (_Atomic unsigned int *v, int mask)\n+{\n+  return !(atomic_fetch_or_explicit (v, mask, memory_order_relaxed) & mask);\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*cmpxchg\" 3 } } */\n+/* { dg-final { scan-assembler-not \"bts\" } } */"}, {"sha": "4603a77612c516285f73991f1a5d12ff4834d499", "filename": "gcc/testsuite/gcc.target/i386/pr102566-12.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-12.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+#define MASK 0x1234\n+\n+bool\n+foo1 (_Atomic long *v)\n+{\n+  return atomic_fetch_and_explicit (v, ~MASK, memory_order_relaxed) & MASK;\n+}\n+\n+bool\n+foo2 (_Atomic long *v, long mask)\n+{\n+  return atomic_fetch_and_explicit (v, ~mask, memory_order_relaxed) & mask;\n+}\n+\n+bool\n+foo3 (_Atomic long *v, long mask)\n+{\n+  return !(atomic_fetch_and_explicit (v, ~mask, memory_order_relaxed) & mask);\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*cmpxchg\" 3 } } */\n+/* { dg-final { scan-assembler-not \"btr\" } } */"}, {"sha": "2657a2f62ae561e2a09c66a8811cf7461ddf726c", "filename": "gcc/testsuite/gcc.target/i386/pr102566-13.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-13.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+#define FOO(TYPE,MASK)\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  atomic_fetch_or_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1 << MASK;\t\t\t\t\t\t\\\n+    return __atomic_fetch_or (a, mask, __ATOMIC_RELAXED) & mask;\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  atomic_fetch_xor_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1 << MASK;\t\t\t\t\t\t\\\n+    return __atomic_fetch_xor (a, mask, __ATOMIC_RELAXED) & mask;\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  atomic_xor_fetch_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1 << MASK;\t\t\t\t\t\t\\\n+    return __atomic_xor_fetch (a, mask, __ATOMIC_RELAXED) & mask;\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  atomic_fetch_and_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1 << MASK;\t\t\t\t\t\t\\\n+    return __atomic_fetch_and (a, ~mask, __ATOMIC_RELAXED) & mask;\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  sync_fetch_and_or_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1 << MASK;\t\t\t\t\t\t\\\n+    return __sync_fetch_and_or (a, mask) & mask;\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  sync_fetch_and_xor_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1 << MASK;\t\t\t\t\t\t\\\n+    return __sync_fetch_and_xor (a, mask) & mask;\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  sync_xor_and_fetch_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1 << MASK;\t\t\t\t\t\t\\\n+    return __sync_xor_and_fetch (a, mask) & mask;\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  sync_fetch_and_and_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1 << MASK;\t\t\t\t\t\t\\\n+    return __sync_fetch_and_and (a, ~mask) & mask;\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+FOO(short, 0);\n+FOO(short, 7);\n+FOO(short, 15);\n+FOO(int, 0);\n+FOO(int, 15);\n+FOO(int, 31);\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*bts\" 12 } } */\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btc\" 24 } } */\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btr\" 12 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "24681c1da18645cb5b979553211c0fa2868432e8", "filename": "gcc/testsuite/gcc.target/i386/pr102566-14.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-14.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2\" } */\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+typedef long long int64;\n+\n+#define FOO(TYPE,MASK)\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  atomic_fetch_or_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1ll << MASK;\t\t\t\t\t\t\\\n+    return __atomic_fetch_or (a, mask, __ATOMIC_RELAXED) & mask;\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  atomic_fetch_xor_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1ll << MASK;\t\t\t\t\t\t\\\n+    return __atomic_fetch_xor (a, mask, __ATOMIC_RELAXED) & mask;\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  atomic_xor_fetch_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1ll << MASK;\t\t\t\t\t\t\\\n+    return __atomic_xor_fetch (a, mask, __ATOMIC_RELAXED) & mask;\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  atomic_fetch_and_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1ll << MASK;\t\t\t\t\t\t\\\n+    return __atomic_fetch_and (a, ~mask, __ATOMIC_RELAXED) & mask;\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  sync_fetch_and_or_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1ll << MASK;\t\t\t\t\t\t\\\n+    return __sync_fetch_and_or (a, mask) & mask;\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  sync_fetch_and_xor_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1ll << MASK;\t\t\t\t\t\t\\\n+    return __sync_fetch_and_xor (a, mask) & mask;\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  sync_xor_and_fetch_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1ll << MASK;\t\t\t\t\t\t\\\n+    return __sync_xor_and_fetch (a, mask) & mask;\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+  __attribute__((noinline,noclone)) TYPE\t\t\t\t\\\n+  sync_fetch_and_and_##TYPE##_##MASK (_Atomic TYPE* a)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    TYPE mask = 1ll << MASK;\t\t\t\t\t\t\\\n+    return __sync_fetch_and_and (a, ~mask) & mask;\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+\n+\n+FOO(int64, 0);\n+FOO(int64, 32);\n+FOO(int64, 63);\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*bts\" 6 } } */\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btc\" 12 } } */\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btr\" 6 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "a915de354e56c94cd9b75108ac2ec36702abbc7c", "filename": "gcc/testsuite/gcc.target/i386/pr102566-1a.c", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-1a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-1a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-1a.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,188 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+void bar (void);\n+\n+__attribute__((noinline, noclone)) int\n+f1 (int *a, int bit)\n+{\n+  int mask = 1 << bit;\n+  return (__sync_fetch_and_or (a, mask) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f2 (int *a, int bit)\n+{\n+  int mask = 1 << bit;\n+  int t1 = __atomic_fetch_or (a, mask, __ATOMIC_RELAXED);\n+  int t2 = t1 & mask;\n+  return t2 != 0;\n+}\n+\n+__attribute__((noinline, noclone)) long int\n+f3 (long int *a, int bit)\n+{\n+  long int mask = 1l << bit;\n+  return (__atomic_fetch_or (a, mask, __ATOMIC_SEQ_CST) & mask) == 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f4 (int *a)\n+{\n+  int mask = 1 << 7;\n+  return (__sync_fetch_and_or (a, mask) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f5 (int *a)\n+{\n+  int mask = 1 << 13;\n+  return (__atomic_fetch_or (a, mask, __ATOMIC_RELAXED) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f6 (int *a)\n+{\n+  int mask = 1 << 0;\n+  return (__atomic_fetch_or (a, mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f7 (int *a, int bit)\n+{\n+  int mask = 1 << bit;\n+  if ((__sync_fetch_and_xor (a, mask) & mask) != 0)\n+    bar ();\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f8 (int *a, int bit)\n+{\n+  int mask = 1 << bit;\n+  if ((__atomic_fetch_xor (a, mask, __ATOMIC_RELAXED) & mask) == 0)\n+    bar ();\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f9 (int *a, int bit)\n+{\n+  int mask = 1 << bit;\n+  return (__atomic_fetch_xor (a, mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f10 (int *a)\n+{\n+  int mask = 1 << 7;\n+  return (__sync_fetch_and_xor (a, mask) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f11 (int *a)\n+{\n+  int mask = 1 << 13;\n+  return (__atomic_fetch_xor (a, mask, __ATOMIC_RELAXED) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f12 (int *a)\n+{\n+  int mask = 1 << 0;\n+  return (__atomic_fetch_xor (a, mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f13 (int *a, int bit)\n+{\n+  int mask = 1 << bit;\n+  return (__sync_fetch_and_and (a, ~mask) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f14 (int *a, int bit)\n+{\n+  int mask = 1 << bit;\n+  return (__atomic_fetch_and (a, ~mask, __ATOMIC_RELAXED) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f15 (int *a, int bit)\n+{\n+  int mask = 1 << bit;\n+  return (__atomic_fetch_and (a, ~mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f16 (int *a)\n+{\n+  int mask = 1 << 7;\n+  return (__sync_fetch_and_and (a, ~mask) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f17 (int *a)\n+{\n+  int mask = 1 << 13;\n+  return (__atomic_fetch_and (a, ~mask, __ATOMIC_RELAXED) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f18 (int *a)\n+{\n+  int mask = 1 << 0;\n+  return (__atomic_fetch_and (a, ~mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) long int\n+f19 (long int *a, int bit)\n+{\n+  long int mask = 1l << bit;\n+  return (__atomic_xor_fetch (a, mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) long int\n+f20 (long int *a)\n+{\n+  long int mask = 1l << 7;\n+  return (__atomic_xor_fetch (a, mask, __ATOMIC_SEQ_CST) & mask) == 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+f21 (int *a, int bit)\n+{\n+  int mask = 1 << bit;\n+  return (__sync_fetch_and_or (a, mask) & mask);\n+}\n+\n+__attribute__((noinline, noclone)) long int\n+f22 (long int *a)\n+{\n+  long int mask = 1l << 7;\n+  return (__atomic_xor_fetch (a, mask, __ATOMIC_SEQ_CST) & mask);\n+}\n+\n+__attribute__((noinline, noclone)) long int\n+f23 (long int *a)\n+{\n+  long int mask = 1l << 7;\n+  return (__atomic_fetch_xor (a, mask, __ATOMIC_SEQ_CST) & mask);\n+}\n+\n+__attribute__((noinline, noclone)) short int\n+f24 (short int *a)\n+{\n+  short int mask = 1 << 7;\n+  return (__sync_fetch_and_or (a, mask) & mask) != 0;\n+}\n+\n+__attribute__((noinline, noclone)) short int\n+f25 (short int *a)\n+{\n+  short int mask = 1 << 7;\n+  return (__atomic_fetch_or (a, mask, __ATOMIC_SEQ_CST) & mask) != 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*bts\" 9 } } */\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btc\" 10 } } */\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btr\" 6 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "c4dab8135c72aaa7e2ab7641fe3a94caf54cc739", "filename": "gcc/testsuite/gcc.target/i386/pr102566-1b.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-1b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-1b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-1b.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,107 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -g\" } */\n+\n+int cnt;\n+\n+__attribute__((noinline, noclone)) void\n+bar (void)\n+{\n+  cnt++;\n+}\n+\n+#include \"pr102566-1a.c\"\n+\n+int a;\n+long int b;\n+unsigned long int c;\n+unsigned short int d;\n+\n+int\n+main ()\n+{\n+  __atomic_store_n (&a, 15, __ATOMIC_RELAXED);\n+  if (f1 (&a, 2) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 15\n+      || f1 (&a, 4) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 31)\n+    __builtin_abort ();\n+  if (f2 (&a, 1) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 31\n+      || f2 (&a, 5) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 63)\n+    __builtin_abort ();\n+  __atomic_store_n (&b, 24, __ATOMIC_RELAXED);\n+  if (f3 (&b, 2) != 1 || __atomic_load_n (&b, __ATOMIC_RELAXED) != 28\n+      || f3 (&b, 3) != 0 || __atomic_load_n (&b, __ATOMIC_RELAXED) != 28)\n+    __builtin_abort ();\n+  __atomic_store_n (&a, 0, __ATOMIC_RELAXED);\n+  if (f4 (&a) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 128\n+      || f4 (&a) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 128)\n+    __builtin_abort ();\n+  if (f5 (&a) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8320\n+      || f5 (&a) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8320)\n+    __builtin_abort ();\n+  if (f6 (&a) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8321\n+      || f6 (&a) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8321)\n+    __builtin_abort ();\n+  if (cnt != 0\n+      || (f7 (&a, 7), cnt) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8193\n+      || (f7 (&a, 7), cnt) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8321)\n+    __builtin_abort ();\n+  if ((f8 (&a, 7), cnt) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8193\n+      || (f8 (&a, 7), cnt) != 2 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8321)\n+    __builtin_abort ();\n+  if (f9 (&a, 13) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 129\n+      || f9 (&a, 13) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8321)\n+    __builtin_abort ();\n+  if (f10 (&a) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8193\n+      || f10 (&a) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8321)\n+    __builtin_abort ();\n+  if (f11 (&a) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 129\n+      || f11 (&a) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8321)\n+    __builtin_abort ();\n+  if (f12 (&a) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8320\n+      || f12 (&a) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8321)\n+    __builtin_abort ();\n+  if (f13 (&a, 7) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8193\n+      || f13 (&a, 7) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8193)\n+    __builtin_abort ();\n+  if (f14 (&a, 13) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 1\n+      || f14 (&a, 13) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 1)\n+    __builtin_abort ();\n+  if (f15 (&a, 0) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 0\n+      || f15 (&a, 0) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 0)\n+    __builtin_abort ();\n+  __atomic_store_n (&a, 8321, __ATOMIC_RELAXED);\n+  if (f16 (&a) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8193\n+      || f16 (&a) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 8193)\n+    __builtin_abort ();\n+  if (f17 (&a) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 1\n+      || f17 (&a) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 1)\n+    __builtin_abort ();\n+  if (f18 (&a) != 1 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 0\n+      || f18 (&a) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 0)\n+    __builtin_abort ();\n+  if (f19 (&c, 7) != 1 || __atomic_load_n (&c, __ATOMIC_RELAXED) != 128\n+      || f19 (&c, 7) != 0 || __atomic_load_n (&c, __ATOMIC_RELAXED) != 0)\n+    __builtin_abort ();\n+  if (f20 (&c) != 0 || __atomic_load_n (&c, __ATOMIC_RELAXED) != 128\n+      || f20 (&c) != 1 || __atomic_load_n (&c, __ATOMIC_RELAXED) != 0)\n+    __builtin_abort ();\n+  __atomic_store_n (&a, 128, __ATOMIC_RELAXED);\n+  if (f21 (&a, 4) != 0 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 144\n+      || f21 (&a, 4) != 16 || __atomic_load_n (&a, __ATOMIC_RELAXED) != 144)\n+    __builtin_abort ();\n+  __atomic_store_n (&c, 1, __ATOMIC_RELAXED);\n+  if (f22 (&c) != 128 || __atomic_load_n (&c, __ATOMIC_RELAXED) != 129\n+      || f22 (&c) != 0 || __atomic_load_n (&c, __ATOMIC_RELAXED) != 1)\n+    __builtin_abort ();\n+  if (f23 (&c) != 0 || __atomic_load_n (&c, __ATOMIC_RELAXED) != 129\n+      || f23 (&c) != 128 || __atomic_load_n (&c, __ATOMIC_RELAXED) != 1)\n+    __builtin_abort ();\n+  if (f24 (&d) != 0 || __atomic_load_n (&d, __ATOMIC_RELAXED) != 128\n+      || f24 (&d) != 1 || __atomic_load_n (&d, __ATOMIC_RELAXED) != 128)\n+    __builtin_abort ();\n+  __atomic_store_n (&d, 1, __ATOMIC_RELAXED);\n+  if (f25 (&d) != 0 || __atomic_load_n (&d, __ATOMIC_RELAXED) != 129\n+      || f25 (&d) != 1 || __atomic_load_n (&d, __ATOMIC_RELAXED) != 129\n+      || cnt != 2)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "00a7c349f2adff9ad03dc45d956eb2b434b60e2f", "filename": "gcc/testsuite/gcc.target/i386/pr102566-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-2.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo0 (_Atomic int *v)\n+{\n+#define BIT (1 << 0)\n+  return atomic_fetch_or_explicit (v, BIT, memory_order_relaxed) & BIT;\n+#undef BIT\n+}\n+\n+bool\n+foo30 (_Atomic int *v)\n+{\n+#define BIT (1 << 30)\n+  return atomic_fetch_or_explicit (v, BIT, memory_order_relaxed) & BIT;\n+#undef BIT\n+}\n+\n+bool\n+foo31 (_Atomic int *v)\n+{\n+#define BIT (1 << 31)\n+  return atomic_fetch_or_explicit (v, BIT, memory_order_relaxed) & BIT;\n+#undef BIT\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btsl\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "8bf1cd6e1bdef8a552fd805e5f03ede66a67983c", "filename": "gcc/testsuite/gcc.target/i386/pr102566-3a.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-3a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-3a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-3a.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo (_Atomic int *v, int bit)\n+{\n+  int mask = 1 << bit;\n+  return atomic_fetch_or_explicit (v, mask, memory_order_relaxed) & mask;\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btsl\" 1 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "d155ed367a16b25ed0d599567c8e6c167e611eb1", "filename": "gcc/testsuite/gcc.target/i386/pr102566-3b.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-3b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-3b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-3b.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo (_Atomic long long int *v, int bit)\n+{\n+  long long int mask = 1ll << bit;\n+  return atomic_fetch_or_explicit (v, mask, memory_order_relaxed) & mask;\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btsq\" 1 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "2668ccf827c03e79d969ed882017e1b1e3305177", "filename": "gcc/testsuite/gcc.target/i386/pr102566-4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-4.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo (_Atomic int *v, int bit)\n+{\n+  unsigned int mask = 1 << bit;\n+  return atomic_fetch_or_explicit (v, mask, memory_order_relaxed) & mask;\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btsl\" 1 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "8bf1cd6e1bdef8a552fd805e5f03ede66a67983c", "filename": "gcc/testsuite/gcc.target/i386/pr102566-5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-5.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo (_Atomic int *v, int bit)\n+{\n+  int mask = 1 << bit;\n+  return atomic_fetch_or_explicit (v, mask, memory_order_relaxed) & mask;\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btsl\" 1 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "3dfe55ac6830fbf13e7e75de73605e02c8bc5ea2", "filename": "gcc/testsuite/gcc.target/i386/pr102566-6.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-6.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo0 (_Atomic int *v)\n+{\n+#define BIT (1 << 0)\n+  return !(atomic_fetch_or_explicit (v, BIT, memory_order_relaxed) & BIT);\n+#undef BIT\n+}\n+\n+bool\n+foo30 (_Atomic int *v)\n+{\n+#define BIT (1 << 30)\n+  return !(atomic_fetch_or_explicit (v, BIT, memory_order_relaxed) & BIT);\n+#undef BIT\n+}\n+\n+bool\n+foo31 (_Atomic int *v)\n+{\n+#define BIT (1 << 31)\n+  return !(atomic_fetch_or_explicit (v, BIT, memory_order_relaxed) & BIT);\n+#undef BIT\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btsl\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "6bc0ae0f3208cbc0c725f1f4306b3c0bb1f0b268", "filename": "gcc/testsuite/gcc.target/i386/pr102566-7.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-7.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+typedef int __attribute__ ((mode (__word__))) int_type;\n+\n+#define BIT (1 << 0)\n+\n+bool\n+foo0 (_Atomic int_type *v)\n+{\n+  return atomic_fetch_or_explicit (v, BIT, memory_order_relaxed) & ~1;\n+}\n+\n+bool\n+foo1 (_Atomic int_type *v)\n+{\n+  return atomic_fetch_or_explicit (v, BIT, memory_order_relaxed) & ~2;\n+}\n+\n+bool\n+foo2 (_Atomic int_type *v)\n+{\n+  return atomic_fetch_or_explicit (v, BIT, memory_order_relaxed) & ~3;\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*cmpxchg\" 3 } } */\n+/* { dg-final { scan-assembler-not \"bts\" } } */"}, {"sha": "168e3db78c9e4022aaf6becfe3c8dd0393f0ea72", "filename": "gcc/testsuite/gcc.target/i386/pr102566-8a.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-8a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-8a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-8a.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo0 (_Atomic int *v)\n+{\n+#define BIT (1 << 0)\n+  return atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT;\n+#undef BIT\n+}\n+\n+bool\n+foo30 (_Atomic int *v)\n+{\n+#define BIT (1 << 30)\n+  return atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT;\n+#undef BIT\n+}\n+\n+bool\n+foo31 (_Atomic int *v)\n+{\n+#define BIT (1 << 31)\n+  return atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT;\n+#undef BIT\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btrl\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "392da3098e0c91e0ad73e42ccda2676fac0f01a4", "filename": "gcc/testsuite/gcc.target/i386/pr102566-8b.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-8b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-8b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-8b.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo0 (_Atomic long long *v)\n+{\n+#define BIT (1ll << 0)\n+  return atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT;\n+#undef BIT\n+}\n+\n+bool\n+foo30 (_Atomic long long *v)\n+{\n+#define BIT (1ll << 62)\n+  return atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT;\n+#undef BIT\n+}\n+\n+bool\n+foo31 (_Atomic long long *v)\n+{\n+#define BIT (1ll << 63)\n+  return atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT;\n+#undef BIT\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btrq\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "3fa2a3ef04372189144c64fb819a88372373d285", "filename": "gcc/testsuite/gcc.target/i386/pr102566-9a.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-9a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-9a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-9a.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo0 (_Atomic int *v)\n+{\n+#define BIT (1 << 0)\n+  return !(atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT);\n+#undef BIT\n+}\n+\n+bool\n+foo30 (_Atomic int *v)\n+{\n+#define BIT (1 << 30)\n+  return !(atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT);\n+#undef BIT\n+}\n+\n+bool\n+foo31 (_Atomic int *v)\n+{\n+#define BIT (1 << 31)\n+  return !(atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT);\n+#undef BIT\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btrl\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "38ddbdc630fdbd9323535fceb10f3ee0d0d3671a", "filename": "gcc/testsuite/gcc.target/i386/pr102566-9b.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-9b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-9b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr102566-9b.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+\n+bool\n+foo0 (_Atomic long long *v)\n+{\n+#define BIT (1ll << 0)\n+  return !(atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT);\n+#undef BIT\n+}\n+\n+bool\n+foo30 (_Atomic long long *v)\n+{\n+#define BIT (1ll << 62)\n+  return !(atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT);\n+#undef BIT\n+}\n+\n+bool\n+foo31 (_Atomic long long *v)\n+{\n+#define BIT (1ll << 63)\n+  return !(atomic_fetch_and_explicit (v, ~BIT, memory_order_relaxed) & BIT);\n+#undef BIT\n+}\n+\n+/* { dg-final { scan-assembler-times \"lock;?\\[ \\t\\]*btrq\" 3 } } */\n+/* { dg-final { scan-assembler-not \"cmpxchg\" } } */"}, {"sha": "0f79e9f05bdd5b5847445628723c4a212ed72340", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 414, "deletions": 42, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb161782545224f55ba26ba663889c5e6e9a04d1/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=fb161782545224f55ba26ba663889c5e6e9a04d1", "patch": "@@ -3243,6 +3243,90 @@ optimize_unreachable (gimple_stmt_iterator i)\n   return ret;\n }\n \n+/* Convert\n+   _1 = __atomic_fetch_or_* (ptr_6, 1, _3);\n+   _7 = ~_1;\n+   _5 = (_Bool) _7;\n+   to\n+   _1 = __atomic_fetch_or_* (ptr_6, 1, _3);\n+   _8 = _1 & 1;\n+   _5 = _8 == 0;\n+   and convert\n+   _1 = __atomic_fetch_and_* (ptr_6, ~1, _3);\n+   _7 = ~_1;\n+   _4 = (_Bool) _7;\n+   to\n+   _1 = __atomic_fetch_and_* (ptr_6, ~1, _3);\n+   _8 = _1 & 1;\n+   _4 = (_Bool) _8;\n+\n+   USE_STMT is the gimplt statement which uses the return value of\n+   __atomic_fetch_or_*.  LHS is the return value of __atomic_fetch_or_*.\n+   MASK is the mask passed to __atomic_fetch_or_*.\n+ */\n+\n+static gimple *\n+convert_atomic_bit_not (enum internal_fn fn, gimple *use_stmt,\n+\t\t\ttree lhs, tree mask)\n+{\n+  tree and_mask;\n+  if (fn == IFN_ATOMIC_BIT_TEST_AND_RESET)\n+    {\n+      /* MASK must be ~1.  */\n+      if (!operand_equal_p (build_int_cst (TREE_TYPE (lhs),\n+\t\t\t\t\t   ~HOST_WIDE_INT_1), mask, 0))\n+\treturn nullptr;\n+      and_mask = build_int_cst (TREE_TYPE (lhs), 1);\n+    }\n+  else\n+    {\n+      /* MASK must be 1.  */\n+      if (!operand_equal_p (build_int_cst (TREE_TYPE (lhs), 1), mask, 0))\n+\treturn nullptr;\n+      and_mask = mask;\n+    }\n+\n+  tree use_lhs = gimple_assign_lhs (use_stmt);\n+\n+  use_operand_p use_p;\n+  gimple *use_not_stmt;\n+\n+  if (!single_imm_use (use_lhs, &use_p, &use_not_stmt)\n+      || !is_gimple_assign (use_not_stmt))\n+    return nullptr;\n+\n+  if (!CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_not_stmt)))\n+    return nullptr;\n+\n+  tree use_not_lhs = gimple_assign_lhs (use_not_stmt);\n+  if (TREE_CODE (TREE_TYPE (use_not_lhs)) != BOOLEAN_TYPE)\n+    return nullptr;\n+\n+  gimple_stmt_iterator gsi;\n+  gsi = gsi_for_stmt (use_stmt);\n+  gsi_remove (&gsi, true);\n+  tree var = make_ssa_name (TREE_TYPE (lhs));\n+  use_stmt = gimple_build_assign (var, BIT_AND_EXPR, lhs, and_mask);\n+  gsi = gsi_for_stmt (use_not_stmt);\n+  gsi_insert_before (&gsi, use_stmt, GSI_NEW_STMT);\n+  lhs = gimple_assign_lhs (use_not_stmt);\n+  gimple *g = gimple_build_assign (lhs, EQ_EXPR, var,\n+\t\t\t\t   build_zero_cst (TREE_TYPE (mask)));\n+  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+  gsi = gsi_for_stmt (use_not_stmt);\n+  gsi_remove (&gsi, true);\n+  return use_stmt;\n+}\n+\n+/* match.pd function to match atomic_bit_test_and pattern which\n+   has nop_convert:\n+     _1 = __atomic_fetch_or_4 (&v, 1, 0);\n+     _2 = (int) _1;\n+     _5 = _2 & 1;\n+ */\n+extern bool gimple_nop_atomic_bit_test_and_p (tree, tree *,\n+\t\t\t\t\t      tree (*) (tree));\n+\n /* Optimize\n      mask_2 = 1 << cnt_1;\n      _4 = __atomic_fetch_or_* (ptr_6, mask_2, _3);\n@@ -3269,7 +3353,7 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n   tree lhs = gimple_call_lhs (call);\n   use_operand_p use_p;\n   gimple *use_stmt;\n-  tree mask, bit;\n+  tree mask;\n   optab optab;\n \n   if (!flag_inline_atomics\n@@ -3279,10 +3363,271 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n       || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs)\n       || !single_imm_use (lhs, &use_p, &use_stmt)\n       || !is_gimple_assign (use_stmt)\n-      || gimple_assign_rhs_code (use_stmt) != BIT_AND_EXPR\n       || !gimple_vdef (call))\n     return;\n \n+  tree bit = nullptr;\n+\n+  mask = gimple_call_arg (call, 1);\n+  tree_code rhs_code = gimple_assign_rhs_code (use_stmt);\n+  if (rhs_code != BIT_AND_EXPR)\n+    {\n+      if (rhs_code != NOP_EXPR && rhs_code != BIT_NOT_EXPR)\n+\treturn;\n+\n+      tree use_lhs = gimple_assign_lhs (use_stmt);\n+      if (TREE_CODE (use_lhs) == SSA_NAME\n+\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (use_lhs))\n+\treturn;\n+\n+      tree use_rhs = gimple_assign_rhs1 (use_stmt);\n+      if (lhs != use_rhs)\n+\treturn;\n+\n+      gimple *g;\n+      gimple_stmt_iterator gsi;\n+      tree var;\n+      int ibit = -1;\n+\n+      if (rhs_code == BIT_NOT_EXPR)\n+\t{\n+\t  g = convert_atomic_bit_not (fn, use_stmt, lhs, mask);\n+\t  if (!g)\n+\t    return;\n+\t  use_stmt = g;\n+\t  ibit = 0;\n+\t}\n+      else if (TREE_CODE (TREE_TYPE (use_lhs)) == BOOLEAN_TYPE)\n+\t{\n+\t  tree and_mask;\n+\t  if (fn == IFN_ATOMIC_BIT_TEST_AND_RESET)\n+\t    {\n+\t      /* MASK must be ~1.  */\n+\t      if (!operand_equal_p (build_int_cst (TREE_TYPE (lhs),\n+\t\t\t\t\t\t   ~HOST_WIDE_INT_1),\n+\t\t\t\t    mask, 0))\n+\t\treturn;\n+\n+\t      /* Convert\n+\t\t _1 = __atomic_fetch_and_* (ptr_6, ~1, _3);\n+\t\t _4 = (_Bool) _1;\n+\t\t to\n+\t\t _1 = __atomic_fetch_and_* (ptr_6, ~1, _3);\n+\t\t _5 = _1 & 1;\n+\t\t _4 = (_Bool) _5;\n+\t       */\n+\t      and_mask = build_int_cst (TREE_TYPE (lhs), 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      and_mask = build_int_cst (TREE_TYPE (lhs), 1);\n+\t      if (!operand_equal_p (and_mask, mask, 0))\n+\t\treturn;\n+\n+\t      /* Convert\n+\t\t _1 = __atomic_fetch_or_* (ptr_6, 1, _3);\n+\t\t _4 = (_Bool) _1;\n+\t\t to\n+\t\t _1 = __atomic_fetch_or_* (ptr_6, 1, _3);\n+\t\t _5 = _1 & 1;\n+\t\t _4 = (_Bool) _5;\n+\t       */\n+\t    }\n+\t  var = make_ssa_name (TREE_TYPE (use_rhs));\n+\t  replace_uses_by (use_rhs, var);\n+\t  g = gimple_build_assign (var, BIT_AND_EXPR, use_rhs,\n+\t\t\t\t   and_mask);\n+\t  gsi = gsi_for_stmt (use_stmt);\n+\t  gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t  use_stmt = g;\n+\t  ibit = 0;\n+\t}\n+      else if (TYPE_PRECISION (TREE_TYPE (use_lhs))\n+\t       == TYPE_PRECISION (TREE_TYPE (use_rhs)))\n+\t{\n+\t  gimple *use_nop_stmt;\n+\t  if (!single_imm_use (use_lhs, &use_p, &use_nop_stmt)\n+\t      || !is_gimple_assign (use_nop_stmt))\n+\t    return;\n+\t  rhs_code = gimple_assign_rhs_code (use_nop_stmt);\n+\t  if (rhs_code != BIT_AND_EXPR)\n+\t    {\n+\t      tree use_nop_lhs = gimple_assign_lhs (use_nop_stmt);\n+\t      if (TREE_CODE (use_nop_lhs) == SSA_NAME\n+\t\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (use_nop_lhs))\n+\t\treturn;\n+\t      if (rhs_code == BIT_NOT_EXPR)\n+\t\t{\n+\t\t  g = convert_atomic_bit_not (fn, use_nop_stmt, lhs,\n+\t\t\t\t\t      mask);\n+\t\t  if (!g)\n+\t\t    return;\n+\t\t  /* Convert\n+\t\t     _1 = __atomic_fetch_or_4 (ptr_6, 1, _3);\n+\t\t     _2 = (int) _1;\n+\t\t     _7 = ~_2;\n+\t\t     _5 = (_Bool) _7;\n+\t\t     to\n+\t\t     _1 = __atomic_fetch_or_4 (ptr_6, ~1, _3);\n+\t\t     _8 = _1 & 1;\n+\t\t     _5 = _8 == 0;\n+\t\t     and convert\n+\t\t     _1 = __atomic_fetch_and_4 (ptr_6, ~1, _3);\n+\t\t     _2 = (int) _1;\n+\t\t     _7 = ~_2;\n+\t\t     _5 = (_Bool) _7;\n+\t\t     to\n+\t\t     _1 = __atomic_fetch_and_4 (ptr_6, 1, _3);\n+\t\t     _8 = _1 & 1;\n+\t\t     _5 = _8 == 0;\n+\t\t   */\n+\t\t  gsi = gsi_for_stmt (use_stmt);\n+\t\t  gsi_remove (&gsi, true);\n+\t\t  use_stmt = g;\n+\t\t  ibit = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (TREE_CODE (TREE_TYPE (use_nop_lhs)) != BOOLEAN_TYPE)\n+\t\t    return;\n+\t\t  if (rhs_code != GE_EXPR && rhs_code != LT_EXPR)\n+\t\t    return;\n+\t\t  tree cmp_rhs1 = gimple_assign_rhs1 (use_nop_stmt);\n+\t\t  if (use_lhs != cmp_rhs1)\n+\t\t    return;\n+\t\t  tree cmp_rhs2 = gimple_assign_rhs2 (use_nop_stmt);\n+\t\t  if (!integer_zerop (cmp_rhs2))\n+\t\t    return;\n+\n+\t\t  tree and_mask;\n+\n+\t\t  unsigned HOST_WIDE_INT bytes\n+\t\t    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (use_rhs)));\n+\t\t  ibit = bytes * BITS_PER_UNIT - 1;\n+\t\t  unsigned HOST_WIDE_INT highest\n+\t\t    = HOST_WIDE_INT_1U << ibit;\n+\n+\t\t  if (fn == IFN_ATOMIC_BIT_TEST_AND_RESET)\n+\t\t    {\n+\t\t      /* Get the signed maximum of the USE_RHS type.  */\n+\t\t      and_mask = build_int_cst (TREE_TYPE (use_rhs),\n+\t\t\t\t\t\thighest - 1);\n+\t\t      if (!operand_equal_p (and_mask, mask, 0))\n+\t\t\treturn;\n+\n+\t\t      /* Convert\n+\t\t\t _1 = __atomic_fetch_and_4 (ptr_6, 0x7fffffff, _3);\n+\t\t\t _5 = (signed int) _1;\n+\t\t\t _4 = _5 < 0 or _5 >= 0;\n+\t\t\t to\n+\t\t\t _1 = __atomic_fetch_and_4 (ptr_6, 0x7fffffff, _3);\n+\t\t\t _6 = _1 & 0x80000000;\n+\t\t\t _4 = _6 != 0 or _6 == 0;\n+\t\t       */\n+\t\t      and_mask = build_int_cst (TREE_TYPE (use_rhs),\n+\t\t\t\t\t\thighest);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* Get the signed minimum of the USE_RHS type.  */\n+\t\t      and_mask = build_int_cst (TREE_TYPE (use_rhs),\n+\t\t\t\t\t\thighest);\n+\t\t      if (!operand_equal_p (and_mask, mask, 0))\n+\t\t\treturn;\n+\n+\t\t      /* Convert\n+\t\t\t _1 = __atomic_fetch_or_4 (ptr_6, 0x80000000, _3);\n+\t\t\t _5 = (signed int) _1;\n+\t\t\t _4 = _5 < 0 or _5 >= 0;\n+\t\t\t to\n+\t\t\t _1 = __atomic_fetch_or_4 (ptr_6, 0x80000000, _3);\n+\t\t\t _6 = _1 & 0x80000000;\n+\t\t\t _4 = _6 != 0 or _6 == 0;\n+\t\t       */\n+\t\t    }\n+\t\t  var = make_ssa_name (TREE_TYPE (use_rhs));\n+\t\t  gsi = gsi_for_stmt (use_stmt);\n+\t\t  gsi_remove (&gsi, true);\n+\t\t  g = gimple_build_assign (var, BIT_AND_EXPR, use_rhs,\n+\t\t\t\t\t   and_mask);\n+\t\t  gsi = gsi_for_stmt (use_nop_stmt);\n+\t\t  gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t\t  use_stmt = g;\n+\t\t  g = gimple_build_assign (use_nop_lhs,\n+\t\t\t\t\t   (rhs_code == GE_EXPR\n+\t\t\t\t\t    ? EQ_EXPR : NE_EXPR),\n+\t\t\t\t\t   var,\n+\t\t\t\t\t   build_zero_cst (TREE_TYPE (use_rhs)));\n+\t\t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\t\t  gsi = gsi_for_stmt (use_nop_stmt);\n+\t\t  gsi_remove (&gsi, true);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      tree and_expr = gimple_assign_lhs (use_nop_stmt);\n+\t      tree match_op[3];\n+\t      gimple *g;\n+\t      if (!gimple_nop_atomic_bit_test_and_p (and_expr,\n+\t\t\t\t\t\t     &match_op[0], NULL)\n+\t\t  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (match_op[2])\n+\t\t  || !single_imm_use (match_op[2], &use_p, &g)\n+\t\t  || !is_gimple_assign (g))\n+\t\treturn;\n+\t      mask = match_op[1];\n+\t      if (TREE_CODE (mask) == INTEGER_CST)\n+\t\t{\n+\t\t  ibit = tree_log2 (mask);\n+\t\t  gcc_assert (ibit >= 0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  g = SSA_NAME_DEF_STMT (mask);\n+\t\t  gcc_assert (is_gimple_assign (g));\n+\t\t  bit = gimple_assign_rhs2 (g);\n+\t\t}\n+\t      /* Convert\n+\t\t _1 = __atomic_fetch_or_4 (ptr_6, mask, _3);\n+\t\t _2 = (int) _1;\n+\t\t _5 = _2 & mask;\n+\t\t to\n+\t\t _1 = __atomic_fetch_or_4 (ptr_6, mask, _3);\n+\t\t _6 = _1 & mask;\n+\t\t _5 = (int) _6;\n+\t\t and convert\n+\t\t _1 = ~mask_7;\n+\t\t _2 = (unsigned int) _1;\n+\t\t _3 = __atomic_fetch_and_4 (ptr_6, _2, 0);\n+\t\t _4 = (int) _3;\n+\t\t _5 = _4 & mask_7;\n+\t\t to\n+\t\t _1 = __atomic_fetch_and_* (ptr_6, ~mask_7, _3);\n+\t\t _12 = _3 & mask_7;\n+\t\t _5 = (int) _12;\n+\t       */\n+\t      replace_uses_by (use_lhs, lhs);\n+\t      tree use_nop_lhs = gimple_assign_lhs (use_nop_stmt);\n+\t      var = make_ssa_name (TREE_TYPE (use_nop_lhs));\n+\t      gimple_assign_set_lhs (use_nop_stmt, var);\n+\t      gsi = gsi_for_stmt (use_stmt);\n+\t      gsi_remove (&gsi, true);\n+\t      release_defs (use_stmt);\n+\t      gsi_remove (gsip, true);\n+\t      g = gimple_build_assign (use_nop_lhs, NOP_EXPR, var);\n+\t      gsi = gsi_for_stmt (use_nop_stmt);\n+\t      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\t      use_stmt = use_nop_stmt;\n+\t    }\n+\t}\n+\n+      if (!bit)\n+\t{\n+\t  if (ibit < 0)\n+\t    gcc_unreachable ();\n+\t  bit = build_int_cst (TREE_TYPE (lhs), ibit);\n+\t}\n+    }\n+\n   switch (fn)\n     {\n     case IFN_ATOMIC_BIT_TEST_AND_SET:\n@@ -3301,51 +3646,76 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n   if (optab_handler (optab, TYPE_MODE (TREE_TYPE (lhs))) == CODE_FOR_nothing)\n     return;\n \n-  mask = gimple_call_arg (call, 1);\n   tree use_lhs = gimple_assign_lhs (use_stmt);\n   if (!use_lhs)\n     return;\n \n-  if (TREE_CODE (mask) == INTEGER_CST)\n-    {\n-      if (fn == IFN_ATOMIC_BIT_TEST_AND_RESET)\n-\tmask = const_unop (BIT_NOT_EXPR, TREE_TYPE (mask), mask);\n-      mask = fold_convert (TREE_TYPE (lhs), mask);\n-      int ibit = tree_log2 (mask);\n-      if (ibit < 0)\n-\treturn;\n-      bit = build_int_cst (TREE_TYPE (lhs), ibit);\n-    }\n-  else if (TREE_CODE (mask) == SSA_NAME)\n+  if (!bit)\n     {\n-      gimple *g = SSA_NAME_DEF_STMT (mask);\n-      if (fn == IFN_ATOMIC_BIT_TEST_AND_RESET)\n+      if (TREE_CODE (mask) == INTEGER_CST)\n \t{\n-\t  if (!is_gimple_assign (g)\n-\t      || gimple_assign_rhs_code (g) != BIT_NOT_EXPR)\n+\t  if (fn == IFN_ATOMIC_BIT_TEST_AND_RESET)\n+\t    mask = const_unop (BIT_NOT_EXPR, TREE_TYPE (mask), mask);\n+\t  mask = fold_convert (TREE_TYPE (lhs), mask);\n+\t  int ibit = tree_log2 (mask);\n+\t  if (ibit < 0)\n \t    return;\n-\t  mask = gimple_assign_rhs1 (g);\n-\t  if (TREE_CODE (mask) != SSA_NAME)\n+\t  bit = build_int_cst (TREE_TYPE (lhs), ibit);\n+\t}\n+      else if (TREE_CODE (mask) == SSA_NAME)\n+\t{\n+\t  gimple *g = SSA_NAME_DEF_STMT (mask);\n+\t  if (fn == IFN_ATOMIC_BIT_TEST_AND_RESET)\n+\t    {\n+\t      if (!is_gimple_assign (g)\n+\t\t  || gimple_assign_rhs_code (g) != BIT_NOT_EXPR)\n+\t\treturn;\n+\t      mask = gimple_assign_rhs1 (g);\n+\t      if (TREE_CODE (mask) != SSA_NAME)\n+\t\treturn;\n+\t      g = SSA_NAME_DEF_STMT (mask);\n+\t    }\n+\t  if (!is_gimple_assign (g))\n \t    return;\n-\t  g = SSA_NAME_DEF_STMT (mask);\n+\t  rhs_code = gimple_assign_rhs_code (g);\n+\t  if (rhs_code != LSHIFT_EXPR)\n+\t    {\n+\t      if (rhs_code != NOP_EXPR)\n+\t\treturn;\n+\n+\t      /* Handle\n+\t\t _1 = 1 << bit_4(D);\n+\t\t mask_5 = (unsigned int) _1;\n+\t\t _2 = __atomic_fetch_or_4 (v_7(D), mask_5, 0);\n+\t\t _3 = _2 & mask_5;\n+\t\t */\n+\t      tree nop_lhs = gimple_assign_lhs (g);\n+\t      tree nop_rhs = gimple_assign_rhs1 (g);\n+\t      if (TYPE_PRECISION (TREE_TYPE (nop_lhs))\n+\t\t  != TYPE_PRECISION (TREE_TYPE (nop_rhs)))\n+\t\treturn;\n+\t      g = SSA_NAME_DEF_STMT (nop_rhs);\n+\t      if (!is_gimple_assign (g)\n+\t\t  || gimple_assign_rhs_code (g) != LSHIFT_EXPR)\n+\t\treturn;\n+\t    }\n+\t  if (!integer_onep (gimple_assign_rhs1 (g)))\n+\t    return;\n+\t  bit = gimple_assign_rhs2 (g);\n \t}\n-      if (!is_gimple_assign (g)\n-\t  || gimple_assign_rhs_code (g) != LSHIFT_EXPR\n-\t  || !integer_onep (gimple_assign_rhs1 (g)))\n+      else\n \treturn;\n-      bit = gimple_assign_rhs2 (g);\n-    }\n-  else\n-    return;\n \n-  if (gimple_assign_rhs1 (use_stmt) == lhs)\n-    {\n-      if (!operand_equal_p (gimple_assign_rhs2 (use_stmt), mask, 0))\n+      if (gimple_assign_rhs1 (use_stmt) == lhs)\n+\t{\n+\t  if (!operand_equal_p (gimple_assign_rhs2 (use_stmt), mask, 0))\n+\t    return;\n+\t}\n+      else if (gimple_assign_rhs2 (use_stmt) != lhs\n+\t       || !operand_equal_p (gimple_assign_rhs1 (use_stmt),\n+\t\t\t\t    mask, 0))\n \treturn;\n     }\n-  else if (gimple_assign_rhs2 (use_stmt) != lhs\n-\t   || !operand_equal_p (gimple_assign_rhs1 (use_stmt), mask, 0))\n-    return;\n \n   bool use_bool = true;\n   bool has_debug_uses = false;\n@@ -3434,18 +3804,20 @@ optimize_atomic_bit_test_and (gimple_stmt_iterator *gsip,\n \t of the specified bit after the atomic operation (makes only sense\n \t for xor, otherwise the bit content is compile time known),\n \t we need to invert the bit.  */\n-      g = gimple_build_assign (make_ssa_name (TREE_TYPE (lhs)),\n-\t\t\t       BIT_XOR_EXPR, new_lhs,\n-\t\t\t       use_bool ? build_int_cst (TREE_TYPE (lhs), 1)\n-\t\t\t\t\t: mask);\n-      new_lhs = gimple_assign_lhs (g);\n+      tree mask_convert = mask;\n+      gimple_seq stmts = NULL;\n+      if (!use_bool)\n+\tmask_convert = gimple_convert (&stmts, TREE_TYPE (lhs), mask);\n+      new_lhs = gimple_build (&stmts, BIT_XOR_EXPR, TREE_TYPE (lhs), new_lhs,\n+\t\t\t      use_bool ? build_int_cst (TREE_TYPE (lhs), 1)\n+\t\t\t\t       : mask_convert);\n       if (throws)\n \t{\n-\t  gsi_insert_on_edge_immediate (e, g);\n-\t  gsi = gsi_for_stmt (g);\n+\t  gsi_insert_seq_on_edge_immediate (e, stmts);\n+\t  gsi = gsi_for_stmt (gimple_seq_last (stmts));\n \t}\n       else\n-\tgsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\tgsi_insert_seq_after (&gsi, stmts, GSI_NEW_STMT);\n     }\n   if (use_bool && has_debug_uses)\n     {"}]}