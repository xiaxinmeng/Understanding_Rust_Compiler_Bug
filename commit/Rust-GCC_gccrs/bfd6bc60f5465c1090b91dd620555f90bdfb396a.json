{"sha": "bfd6bc60f5465c1090b91dd620555f90bdfb396a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZkNmJjNjBmNTQ2NWMxMDkwYjkxZGQ2MjA1NTVmOTBiZGZiMzk2YQ==", "commit": {"author": {"name": "John Carr", "email": "jfc@mit.edu", "date": "1998-01-30T23:34:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-01-30T23:34:15Z"}, "message": "sparc.c (sparc_override_options): Make v8plus and ultrasparc set MASK_V8PLUS.\n\nFri Jan 30 22:30:39 1998  John Carr  <jfc@mit.edu>\n        * sparc.c (sparc_override_options): Make v8plus and ultrasparc set\n        MASK_V8PLUS.\n        (output_function_epilogue): Omit epilogue if nothing drops through.\n        (output_move_double): Supress int ldd usage on ultrasparc and v9.\n        (registers_ok_for_ldd_peep): Likewise.\n        (print_operand): Supress b,a on ultrasparc.  Let Y accept a constant.\n        (ultrasparc_adjust_cost): New function.\n        (sparc_issue_rate): New function.\n        * sparc.h (MASK_VIS, TARGET_VIS): New\n        (MASK_V8PLUS, TARGET_V8PLUS): New.\n        (TARGET_HARD_MUL32, TARGET_HARD_MUL): New.\n        (TARGET_SWITCHES): Add vis and v8plus.\n        (REG_CLASS_FROM_LETTER): Accept d and b for VIS.\n        (REGISTER_MOVE_COST): FP<->INT move cost 12 for ultrasparc.\n        (RTX_COSTS): Use TARGET_HARD_MUL\n        (ADJUST_COST): Call ultrasparc_adjust_cost.\n        (ISSUE_RATE): New.\n        * sparc.md (attr type): Add sload, fpmove, fpcmove.  Adjust users\n        of load & fp appropritely.\n        (supersparc function units): Adjust for Haifa.\n        (ultrasparc function units): Likewise.\n        (get_pc_via_rdpc): All v9, not just arch64.\n        (movdi_v8plus, movdi_v8plus+1): New.\n        (adddi3_sp32+1): New.\n        (subdi3_sp32+1): New.\n        (movsi_insn, movsf_const_insn, movdf_const_insn): Know VIS.\n        (addsi3, subsi3, anddi3_sp32, andsi3, and_not_di_sp32): Likewise.\n        (and_not_si, iordi3_sp32, iorsi3, or_not_di_sp32, or_not_si): Likewise.\n        (xorsi3_sp32, xorsi3, xor_not_di_sp32, xor_not_si): Likewise.\n        (one_cmpldi2_sp32, one_cmplsi2): Likewise.\n        (ldd peepholes): Suppress for v9.\n        (return_adddi): Kill redundant test.  Arg1 may be arith_operand.\n        (return_subsi): Revmove.\n\nFrom-SVN: r17560", "tree": {"sha": "4c8f591fec668cf405dc1ae764a949d736a2e4e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c8f591fec668cf405dc1ae764a949d736a2e4e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfd6bc60f5465c1090b91dd620555f90bdfb396a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfd6bc60f5465c1090b91dd620555f90bdfb396a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfd6bc60f5465c1090b91dd620555f90bdfb396a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfd6bc60f5465c1090b91dd620555f90bdfb396a/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b526a9a94031f39cf5304423828c7a0b08ee5c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b526a9a94031f39cf5304423828c7a0b08ee5c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b526a9a94031f39cf5304423828c7a0b08ee5c4"}], "stats": {"total": 942, "additions": 703, "deletions": 239}, "files": [{"sha": "f87310c94d24bf64a62b6dba6bbcc30b40a664db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd6bc60f5465c1090b91dd620555f90bdfb396a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd6bc60f5465c1090b91dd620555f90bdfb396a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfd6bc60f5465c1090b91dd620555f90bdfb396a", "patch": "@@ -1,3 +1,40 @@\n+Fri Jan 30 22:30:39 1998  John Carr  <jfc@mit.edu>\n+\n+\t* sparc.c (sparc_override_options): Make v8plus and ultrasparc set\n+\tMASK_V8PLUS.\n+\t(output_function_epilogue): Omit epilogue if nothing drops through.\n+\t(output_move_double): Supress int ldd usage on ultrasparc and v9.\n+\t(registers_ok_for_ldd_peep): Likewise.\n+\t(print_operand): Supress b,a on ultrasparc.  Let Y accept a constant.\n+\t(ultrasparc_adjust_cost): New function.\n+\t(sparc_issue_rate): New function.\n+\t* sparc.h (MASK_VIS, TARGET_VIS): New\n+\t(MASK_V8PLUS, TARGET_V8PLUS): New.\n+\t(TARGET_HARD_MUL32, TARGET_HARD_MUL): New.\n+\t(TARGET_SWITCHES): Add vis and v8plus.\n+\t(REG_CLASS_FROM_LETTER): Accept d and b for VIS.\n+\t(REGISTER_MOVE_COST): FP<->INT move cost 12 for ultrasparc.\n+\t(RTX_COSTS): Use TARGET_HARD_MUL\n+\t(ADJUST_COST): Call ultrasparc_adjust_cost.\n+\t(ISSUE_RATE): New.\n+\t* sparc.md (attr type): Add sload, fpmove, fpcmove.  Adjust users\n+\tof load & fp appropritely.\n+\t(supersparc function units): Adjust for Haifa.\n+\t(ultrasparc function units): Likewise.\n+\t(get_pc_via_rdpc): All v9, not just arch64.\n+\t(movdi_v8plus, movdi_v8plus+1): New.\n+\t(adddi3_sp32+1): New.\n+\t(subdi3_sp32+1): New.\n+\t(movsi_insn, movsf_const_insn, movdf_const_insn): Know VIS.\n+\t(addsi3, subsi3, anddi3_sp32, andsi3, and_not_di_sp32): Likewise.\n+\t(and_not_si, iordi3_sp32, iorsi3, or_not_di_sp32, or_not_si): Likewise.\n+\t(xorsi3_sp32, xorsi3, xor_not_di_sp32, xor_not_si): Likewise.\n+\t(one_cmpldi2_sp32, one_cmplsi2): Likewise.\n+\t(ldd peepholes): Suppress for v9.\n+\t(return_adddi): Kill redundant test.  Arg1 may be arith_operand.\n+\t(return_subsi): Revmove.\n+\n+\n Fri Jan 30 18:30:03 1998  John F Carr  <jfc@mit.edu>\n \n \t* mips.c (save_restore_insns): Set RTX_UNCHANGING_P in register"}, {"sha": "4d4d84ba773bafc7af9a7626e93edd5d846f470f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 191, "deletions": 11, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd6bc60f5465c1090b91dd620555f90bdfb396a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd6bc60f5465c1090b91dd620555f90bdfb396a/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bfd6bc60f5465c1090b91dd620555f90bdfb396a", "patch": "@@ -209,10 +209,10 @@ sparc_override_options ()\n     /* TEMIC sparclet */\n     { \"tsc701\",     PROCESSOR_TSC701, MASK_ISA, MASK_SPARCLET },\n     /* \"v8plus\" is what Sun calls Solaris2.5 running on UltraSPARC's.  */\n-    { \"v8plus\",     PROCESSOR_V8PLUS, MASK_ISA, MASK_V9 },\n+    { \"v8plus\",     PROCESSOR_V8PLUS, MASK_ISA, MASK_V8PLUS },\n     { \"v9\",         PROCESSOR_V9, MASK_ISA, MASK_V9 },\n     /* TI ultrasparc */\n-    { \"ultrasparc\", PROCESSOR_ULTRASPARC, MASK_ISA, MASK_V9 },\n+    { \"ultrasparc\", PROCESSOR_ULTRASPARC, MASK_ISA, MASK_V8PLUS },\n     { 0 }\n   };\n   struct cpu_table *cpu;\n@@ -379,6 +379,7 @@ v9_regcmp_p (code)\n   return (code == EQ || code == NE || code == GE || code == LT\n \t  || code == LE || code == GT);\n }\n+\n \f\n /* Operand constraints.  */\n \n@@ -1257,7 +1258,7 @@ eligible_for_epilogue_delay (trial, slot)\n \n   src = SET_SRC (pat);\n \n-  /* This matches \"*return_[qhs]\".  */\n+  /* This matches \"*return_[qhs]i\".  */\n   if (arith_operand (src, GET_MODE (src)))\n     return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (SImode);\n     \n@@ -2009,13 +2010,26 @@ output_move_double (operands)\n \n       /* In v9, ldd can be used for word aligned addresses, so technically\n \t some of this logic is unneeded.  We still avoid ldd if the address\n-\t is obviously unaligned though.  */\n+\t is obviously unaligned though.\n \n-      if (mem_aligned_8 (mem)\n+\t Integer ldd/std are deprecated in V9 and are slow on UltraSPARC.\n+\t Use them only if the access is volatile or not offsettable.  */\n+\n+      if ((mem_aligned_8 (mem)\n+\t   && (REGNO (reg) >= 32\n+\t       || MEM_VOLATILE_P (mem)\n+\t       || ! ((optype0 == OFFSOP || optype1 == OFFSOP)\n+\t\t     && (sparc_cpu == PROCESSOR_ULTRASPARC\n+\t\t\t || sparc_cpu == PROCESSOR_V9))))\n \t  /* If this is a floating point register higher than %f31,\n \t     then we *must* use an aligned load, since `ld' will not accept\n \t     the register number.  */\n-\t  || (TARGET_V9 && REGNO (reg) >= 64))\n+\t  || (TARGET_V9 && REGNO (reg) >= 64)\n+\t  /* Even if two instructions would otherwise be better than ldd/std,\n+\t     if this insn was put in a delay slot because reorg thought it\n+\t     was only one machine instruction, make sure it is only one\n+\t     instruction.  */\n+\t  || dbr_sequence_length () != 0)\n \t{\n \t  if (FP_REG_P (reg) || ! TARGET_ARCH64)\n \t    return (mem == op1 ? \"ldd %1,%0\" : \"std %1,%0\");\n@@ -3504,6 +3518,16 @@ output_function_epilogue (file, size, leaf_function)\n     }\n #endif\n \n+  else if (current_function_epilogue_delay_list == 0)\n+    {                                                \n+      /* If code does not drop into the epilogue, do nothing.  */\n+      rtx insn = get_last_insn ();                               \n+      if (GET_CODE (insn) == NOTE)                               \n+      insn = prev_nonnote_insn (insn);                           \n+      if (insn && GET_CODE (insn) == BARRIER)                    \n+      return;                                                    \n+    }\n+\n   /* Restore any call saved registers.  */\n   if (num_gfregs)\n     {\n@@ -4631,8 +4655,7 @@ order_regs_for_local_alloc ()\n /* Return 1 if REGNO (reg1) is even and REGNO (reg1) == REGNO (reg2) - 1.\n    This makes them candidates for using ldd and std insns. \n \n-   Note reg1 and reg2 *must* be hard registers.  To be sure we will\n-   abort if we are passed pseudo registers.  */\n+   Note reg1 and reg2 *must* be hard registers.  */\n \n int\n registers_ok_for_ldd_peep (reg1, reg2)\n@@ -4645,6 +4668,10 @@ registers_ok_for_ldd_peep (reg1, reg2)\n   if (REGNO (reg1) % 2 != 0)\n     return 0;\n \n+  /* Integer ldd is deprecated in SPARC V9 */ \n+  if (TARGET_V9 && REGNO (reg1) < 32)                  \n+    return 0;                             \n+\n   return (REGNO (reg1) == REGNO (reg2) - 1);\n }\n \n@@ -4762,13 +4789,17 @@ print_operand (file, x, code)\n \t are optimizing.  This is always used with '(' below.  */\n       /* Sun OS 4.1.1 dbx can't handle an annulled unconditional branch;\n \t this is a dbx bug.  So, we only do this when optimizing.  */\n-      if (dbr_sequence_length () == 0 && optimize)\n+      /* On UltraSPARC, a branch in a delay slot causes a pipeline flush.\n+\t Always emit a nop in case the next instruction is a branch.  */\n+      if (dbr_sequence_length () == 0\n+\t  && (optimize && (int)sparc_cpu < PROCESSOR_V8PLUS))\n \tfputs (\",a\", file);\n       return;\n     case '(':\n       /* Output a 'nop' if there's nothing for the delay slot and we are\n \t not optimizing.  This is always used with '*' above.  */\n-      if (dbr_sequence_length () == 0 && ! optimize)\n+      if (dbr_sequence_length () == 0\n+\t  && ! (optimize && (int)sparc_cpu < PROCESSOR_V8PLUS))\n \tfputs (\"\\n\\tnop\", file);\n       return;\n     case '_':\n@@ -4783,7 +4814,9 @@ print_operand (file, x, code)\n       return;\n     case 'Y':\n       /* Adjust the operand to take into account a RESTORE operation.  */\n-      if (GET_CODE (x) != REG)\n+      if (GET_CODE (x) == CONST_INT)\n+\tbreak;\n+      else if (GET_CODE (x) != REG)\n \toutput_operand_lossage (\"Invalid %%Y operand\");\n       else if (REGNO (x) < 8)\n \tfputs (reg_names[REGNO (x)], file);\n@@ -6022,3 +6055,150 @@ supersparc_adjust_cost (insn, link, dep_insn, cost)\n \t\n   return cost;\n }\n+\n+int\n+ultrasparc_adjust_cost (insn, link, dep_insn, cost)\n+     rtx insn;                                     \n+     rtx link;                                     \n+     rtx dep_insn;                                     \n+     int cost;                                     \n+{\n+  enum attr_type insn_type, dep_type;\n+  rtx pat = PATTERN(insn);                                                    \n+  rtx dep_pat = PATTERN (dep_insn);                                           \n+\n+  if (recog_memoized (insn) < 0 || recog_memoized (dep_insn) < 0)        \n+    return cost;                                     \n+\n+  insn_type = get_attr_type (insn);                     \n+  dep_type = get_attr_type (dep_insn);                  \n+\n+#define SLOW_FP(dep_type) \\\n+(dep_type == TYPE_FPSQRT || dep_type == TYPE_FPDIVS || dep_type == TYPE_FPDIVD)   \n+  switch (REG_NOTE_KIND (link))\n+    {                                              \n+    case 0:                                        \n+      /* Data dependency; DEP_INSN writes a register that INSN reads some\n+\t cycles later.  */                               \n+\n+      switch (insn_type)\n+\t{                              \n+\t  /* UltraSPARC can dual issue a store and an instruction setting       \n+\t     the value stored, except for divide and square root.  */           \n+\tcase TYPE_FPSTORE:\n+\t  if (! SLOW_FP (dep_type))        \n+\t    return 0;                                     \n+\t  break;\n+\n+\tcase TYPE_STORE:                                  \n+\t  if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET)\n+\t    return cost;     \n+\n+\t  /* The dependency between the two instructions is on the data\n+\t     that is being stored.  Assume that the address of the store\n+\t     is not also dependent.  */\n+\t  if (rtx_equal_p (SET_DEST (dep_pat), SET_SRC (pat)))\n+\t    return 0;                                \n+\t  return cost;                                   \n+\n+\tcase TYPE_LOAD:   \n+\tcase TYPE_SLOAD:               \n+\tcase TYPE_FPLOAD:                                                       \n+\t  /* A load does not return data until at least 11 cycles after         \n+\t     a store to the same location.  3 cycles are accounted for\n+\t     in the load latency; add the other 8 here.  */\n+\t  if (dep_type == TYPE_STORE || dep_type == TYPE_FPSTORE)\n+\t    {   \n+\t      /* If the addresses are not equal this may be a false\n+\t\t dependency because pointer aliasing could not be\n+\t\t determined.  Add only 2 cycles in that case.  2 is\n+\t\t an arbitrary compromise between 8, which would cause\n+\t\t the scheduler to generate worse code elsewhere to\n+\t\t compensate for a dependency which might not really    \n+\t\t exist, and 0.  */                                      \n+\t      if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET\n+\t\t  || GET_CODE (SET_DEST (pat)) != MEM         \n+\t\t  || GET_CODE (SET_SRC (dep_pat)) != MEM\n+\t\t  || ! rtx_equal_p (XEXP (SET_DEST (pat), 0),\n+\t\t\t\t    XEXP (SET_SRC (dep_pat), 0)))\n+\t\treturn cost + 2;\n+\n+\t      return cost + 8;         \n+\t    }                                                                   \n+\t  break;                                                                \n+\n+\tcase TYPE_BRANCH:                                  \n+\t  /* Compare to branch latency is 0.  There is no benefit from\n+\t     separating compare and branch.  */\n+\t  if (dep_type == TYPE_COMPARE)                            \n+\t    return 0;                                            \n+\t  /* Floating point compare to branch latency is less than \n+\t     compare to conditional move.  */                        \n+\t  if (dep_type == TYPE_FPCMP)                             \n+\t    return cost - 1;                                           \n+\t  break;                                                        \n+\n+\tcase TYPE_FPCMOVE:                                    \n+\t  /* FMOVR class instructions can not issue in the same cycle\n+\t     or the cycle after an instruction which writes any\n+\t     integer register.  Model this as cost 2 for dependent\n+\t     instructions.  */  \n+\t  if (GET_CODE (PATTERN (insn)) == SET\n+\t      && (GET_MODE (SET_DEST (PATTERN (insn))) == SFmode\n+\t          || GET_MODE (SET_DEST (PATTERN (insn))) == DFmode)            \n+\t      && cost < 2)                                                      \n+\t    return 2;\n+\t  /* Otherwise check as for integer conditional moves. */\n+\n+\tcase TYPE_CMOVE:                       \n+\t  /* Conditional moves involving integer registers wait until\n+\t     3 cycles after loads return data.  The interlock applies\n+\t     to all loads, not just dependent loads, but that is hard\n+\t     to model.  */                        \n+\t  if (dep_type == TYPE_LOAD || dep_type == TYPE_SLOAD)                  \n+\t    return cost + 3;                                           \n+\t  break;                                                        \n+\t}\n+\tbreak;                                                \n+\n+    case REG_DEP_ANTI:                                       \n+      /* Divide and square root lock destination registers for full latency. */\n+      if (! SLOW_FP (dep_type))             \n+\treturn 0;                                               \n+      break;                                                                  \n+    }\n+\n+  /* Other costs not accounted for:                            \n+     - Multiply should be modeled as having no latency because there is\n+       nothing the scheduler can do about it.  \n+     - Single precision floating point loads lock the other half of  \n+       the even/odd register pair.                                   \n+     - Several hazards associated with ldd/std are ignored because these\n+       instructions are rarely generated for V9.  \n+     - A shift following an integer instruction which does not set the\n+       condition codes can not issue in the same cycle.\n+     - The floating point pipeline can not have both a single and double\n+       precision operation active at the same time.  Format conversions\n+       and graphics instructions are given honorary double precision status.\n+     - call and jmpl are always the first instruction in a group.  */\n+\n+  return cost;                                                              \n+}  \n+\n+int                                                           \n+sparc_issue_rate ()\n+{\n+  switch (sparc_cpu)\n+    {\n+    default:                                 \n+      return 1;                                                    \n+    case PROCESSOR_V8PLUS:                                         \n+    case PROCESSOR_V9:                                                \n+      /* Assume these generic V9 types are capable of at least dual-issue.  */\n+      return 2;\n+    case PROCESSOR_SUPERSPARC:                                        \n+      return 3;                                                      \n+    case PROCESSOR_ULTRASPARC:                                            \n+      return 4;                                                    \n+    }\n+}"}, {"sha": "94636294c58de0627703740a573b68a30aaa95e1", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd6bc60f5465c1090b91dd620555f90bdfb396a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd6bc60f5465c1090b91dd620555f90bdfb396a/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=bfd6bc60f5465c1090b91dd620555f90bdfb396a", "patch": "@@ -449,6 +449,27 @@ extern int target_flags;\n #define MASK_FPU_SET 0x400000\n #define TARGET_FPU_SET (target_flags & MASK_FPU_SET)\n \n+/* Use the UltraSPARC Visual Instruction Set extensions.  */\n+#define MASK_VIS 0x1000000          \n+#define TARGET_VIS (target_flags & MASK_VIS)\n+\n+/* Compile for Solaris V8+.  64 bit instructions are available but the\n+   high 32 bits of all registers except the globals and current outs may\n+   be cleared at any time.  */                 \n+#define MASK_V8PLUS 0x2000000                 \n+#define TARGET_V8PLUS (target_flags & MASK_V8PLUS)                            \n+\n+/* See sparc.md */\n+#define TARGET_HARD_MUL32\t\t\t\t\\\n+  ((TARGET_V8 || TARGET_SPARCLITE\t\t\t\\\n+    || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS)\t\\\n+   && ! TARGET_V8PLUS)\n+\n+#define TARGET_HARD_MUL\t\t\t\t\t\\\n+  (TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET\t\\\n+   || TARGET_DEPRECATED_V8_INSNS || TARGET_V8PLUS)                        \n+\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -474,12 +495,14 @@ extern int target_flags;\n     {\"no-app-regs\", -MASK_APP_REGS},\t\\\n     {\"hard-quad-float\", MASK_HARD_QUAD}, \\\n     {\"soft-quad-float\", -MASK_HARD_QUAD}, \\\n+    {\"vis\", MASK_VIS},\t\t\t\\\n     /* ??? These are deprecated, coerced to -mcpu=.  Delete in 2.9.  */ \\\n     {\"cypress\", 0},\t\t\t\\\n     {\"sparclite\", 0},\t\t\t\\\n     {\"f930\", 0},\t\t\t\\\n     {\"f934\", 0},\t\t\t\\\n     {\"v8\", 0},\t\t\t\t\\\n+    {\"v8plus\", 0},\t\t\t\\\n     {\"supersparc\", 0},\t\t\t\\\n     /* End of deprecated options.  */\t\\\n     /* -mptrNN exists for *experimental* purposes.  */ \\\n@@ -1242,17 +1265,20 @@ extern char leaf_reg_remap[];\n \n /* Get reg_class from a letter such as appears in the machine description.\n    In the not-v9 case, coerce v9's 'e' class to 'f', so we can use 'e' in the\n-   .md file for v8 and v9.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-(TARGET_V9\t\t\t\\\n- ? ((C) == 'f' ? FP_REGS\t\\\n-    : (C) == 'e' ? EXTRA_FP_REGS \\\n-    : (C) == 'c' ? FPCC_REGS\t\\\n-    : NO_REGS)\t\t\t\\\n- : ((C) == 'f' ? FP_REGS\t\\\n-    : (C) == 'e' ? FP_REGS\t\\\n-    : (C) == 'c' ? FPCC_REGS\t\\\n+   .md file for v8 and v9.\n+   Use 'd' and 'b' for single precision VIS operations if TARGET_VIS.  */\n+\n+#define REG_CLASS_FROM_LETTER(C)\t\t\\\n+(TARGET_V9\t\t\t\t\t\\\n+ ? ((C) == 'f' ? FP_REGS\t\t\t\\\n+    : (C) == 'e' ? EXTRA_FP_REGS \t\t\\\n+    : (C) == 'c' ? FPCC_REGS\t\t\t\\\n+    : ((C) == 'd' && TARGET_VIS) ? FP_REGS\t\\\n+    : ((C) == 'b' && TARGET_VIS) ? FP_REGS\t\\\n+    : NO_REGS)\t\t\t\t\t\\\n+ : ((C) == 'f' ? FP_REGS\t\t\t\\\n+    : (C) == 'e' ? FP_REGS\t\t\t\\\n+    : (C) == 'c' ? FPCC_REGS\t\t\t\\\n     : NO_REGS))\n \n /* The letters I, J, K, L and M in a register constraint string\n@@ -2683,11 +2709,13 @@ extern struct rtx_def *legitimize_pic_address ();\n #define ADDRESS_COST(RTX)  1\n \n /* Compute extra cost of moving data between one register class\n-   and another.\n-   ??? v9: We ignore FPCC_REGS on the assumption they'll never be seen.  */\n-#define REGISTER_MOVE_COST(CLASS1, CLASS2) \\\n-  (((FP_REG_CLASS_P (CLASS1) && (CLASS2) == GENERAL_REGS) \\\n-    || ((CLASS1) == GENERAL_REGS && FP_REG_CLASS_P (CLASS2))) ? 6 : 2)\n+   and another.  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\t\\\n+  (((FP_REG_CLASS_P (CLASS1) && (CLASS2) == GENERAL_REGS)\t\\\n+    || ((CLASS1) == GENERAL_REGS && FP_REG_CLASS_P (CLASS2))\t\\\n+    || (CLASS1) == FPCC_REGS || (CLASS2) == FPCC_REGS)\t\t\\\n+   ? (sparc_cpu == PROCESSOR_ULTRASPARC ? 12 : 6)\t\t\\\n+   : 2)\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n    switch on CODE.  The purpose for the cost of MULT is to encourage\n@@ -2698,8 +2726,7 @@ extern struct rtx_def *legitimize_pic_address ();\n \n #define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n-    return (TARGET_V8 || TARGET_SPARCLITE)              \\\n-\t? COSTS_N_INSNS (5) : COSTS_N_INSNS (25);\t\\\n+    return TARGET_HARD_MUL ? COSTS_N_INSNS (5) : COSTS_N_INSNS (25); \\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\\\n@@ -2711,16 +2738,24 @@ extern struct rtx_def *legitimize_pic_address ();\n   case FIX:\t\t\t\t\t\t\\\n     return 19;\n \n+#define ISSUE_RATE  sparc_issue_rate()\n+\n /* Adjust the cost of dependencies.  */\n-#define ADJUST_COST(INSN,LINK,DEP,COST) \\\n-  if (sparc_cpu == PROCESSOR_SUPERSPARC) \\\n-    (COST) = supersparc_adjust_cost (INSN, LINK, DEP, COST)\n+#define ADJUST_COST(INSN,LINK,DEP,COST)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if (sparc_cpu == PROCESSOR_SUPERSPARC)\t\t\t\\\n+    (COST) = supersparc_adjust_cost (INSN, LINK, DEP, COST);\t\\\n+  else if (sparc_cpu == PROCESSOR_ULTRASPARC)\t\t\t\\\n+    (COST) = ultrasparc_adjust_cost (INSN, LINK, DEP, COST);\t\\\n+} while (0)\n \n /* Conditional branches with empty delay slots have a length of two.  */\n-#define ADJUST_INSN_LENGTH(INSN, LENGTH)\t\\\n+#define ADJUST_INSN_LENGTH(INSN, LENGTH)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (INSN) == CALL_INSN\t\t\t\t\t\\\n       || (GET_CODE (INSN) == JUMP_INSN && ! simplejump_p (insn)))\t\\\n-    LENGTH += 1;\n+    LENGTH += 1;\t\t\t\t\t\t\t\\\n+} while (0)\n \f\n /* Control the assembler format that we output.  */\n "}, {"sha": "0cd564baa347ac040a4f01ea6d7200a7c6fa9f04", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 417, "deletions": 205, "changes": 622, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfd6bc60f5465c1090b91dd620555f90bdfb396a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfd6bc60f5465c1090b91dd620555f90bdfb396a/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=bfd6bc60f5465c1090b91dd620555f90bdfb396a", "patch": "@@ -67,7 +67,7 @@\n ;; type \"call_no_delay_slot\" is a call followed by an unimp instruction.\n \n (define_attr \"type\"\n-  \"move,unary,binary,compare,load,store,ialu,shift,uncond_branch,branch,call,call_no_delay_slot,address,imul,fpload,fpstore,fp,fpcmp,fpmul,fpdivs,fpdivd,fpsqrt,cmove,multi,misc\"\n+  \"move,unary,binary,compare,load,sload,store,ialu,shift,uncond_branch,branch,call,call_no_delay_slot,address,imul,fpload,fpstore,fp,fpmove,fpcmove,fpcmp,fpmul,fpdivs,fpdivd,fpsqrt,cmove,multi,misc\"\n   (const_string \"binary\"))\n \n ;; Set true if insn uses call-clobbered intermediate register.\n@@ -79,7 +79,7 @@\n \n ;; Length (in # of insns).\n (define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"load,fpload\")\n+  (cond [(eq_attr \"type\" \"load,sload,fpload\")\n \t (if_then_else (match_operand 1 \"symbolic_memory_operand\" \"\")\n \t\t       (const_int 2) (const_int 1))\n \n@@ -182,8 +182,11 @@\n \n ;; ---- cypress CY7C602 scheduling:\n ;; Memory with load-delay of 1 (i.e., 2 cycle load).\n+\n (define_function_unit \"memory\" 1 0 \n-  (and (eq_attr \"type\" \"load,fpload\") (eq_attr \"cpu\" \"cypress\")) 2 2)\n+  (and (eq_attr \"cpu\" \"cypress\")\n+    (eq_attr \"type\" \"load,sload,fpload\"))\n+  2 2)\n \n ;; SPARC has two floating-point units: the FP ALU,\n ;; and the FP MUL/DIV/SQRT unit.\n@@ -205,34 +208,57 @@\n ;; More insns cause the chip to stall.\n \n (define_function_unit \"fp_alu\" 1 0\n-  (and (eq_attr \"type\" \"fp\")            (eq_attr \"cpu\" \"cypress\")) 5 5)\n+  (and (eq_attr \"cpu\" \"cypress\")\n+    (eq_attr \"type\" \"fp,fpmove\"))\n+  5 5)\n+\n (define_function_unit \"fp_mds\" 1 0\n-  (and (eq_attr \"type\" \"fpmul\")         (eq_attr \"cpu\" \"cypress\")) 7 7)\n+  (and (eq_attr \"cpu\" \"cypress\")\n+    (eq_attr \"type\" \"fpmul\"))\n+  7 7)\n+\n (define_function_unit \"fp_mds\" 1 0\n-  (and (eq_attr \"type\" \"fpdivs,fpdivd\") (eq_attr \"cpu\" \"cypress\")) 37 37)\n+  (and (eq_attr \"cpu\" \"cypress\")\n+    (eq_attr \"type\" \"fpdivs,fpdivd\"))\n+  37 37)\n+\n (define_function_unit \"fp_mds\" 1 0\n-  (and (eq_attr \"type\" \"fpsqrt\")        (eq_attr \"cpu\" \"cypress\")) 63 63)\n+  (and (eq_attr \"cpu\" \"cypress\")\n+    (eq_attr \"type\" \"fpsqrt\"))\n+  63 63)\n \n ;; ----- The TMS390Z55 scheduling\n-;; The Supersparc can issue 1 - 3 insns per cycle; here we assume\n-;; three insns/cycle, and hence multiply all costs by three.\n-;; Combinations up to two integer, one ld/st, one fp.\n+;; The Supersparc can issue 1 - 3 insns per cycle: up to two integer,\n+;; one ld/st, one fp.\n ;; Memory delivers its result in one cycle to IU, zero cycles to FP\n+\n (define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"load\")          (eq_attr \"cpu\" \"supersparc\")) 3 3)\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"load,sload\"))\n+  1 1)\n+\n (define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"fpload\")        (eq_attr \"cpu\" \"supersparc\")) 1 3)\n-;; at least one in three instructions can be a mem opt.\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fpload\"))\n+  0 1)\n+\n (define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"store,fpstore\") (eq_attr \"cpu\" \"supersparc\")) 1 3)\n-;; at least one in three instructions can be a shift op.\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"store,fpstore\"))\n+  1 1)\n+\n (define_function_unit \"shift\" 1 0\n-  (and (eq_attr \"type\" \"shift\")         (eq_attr \"cpu\" \"supersparc\")) 1 3)\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"shift\"))\n+  1 1)\n \n ;; There are only two write ports to the integer register file\n ;; A store also uses a write port\n+\n (define_function_unit \"iwport\" 2 0\n-  (and (eq_attr \"type\" \"load,store,shift,ialu\") (eq_attr \"cpu\" \"supersparc\")) 1 3)\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"load,sload,store,shift,ialu\"))\n+  1 1)\n \n ;; Timings; throughput/latency\n ;; FADD     1/3    add/sub, format conv, compar, abs, neg\n@@ -244,50 +270,104 @@\n ;; IMUL     4/4\n \n (define_function_unit \"fp_alu\" 1 0\n-  (and (eq_attr \"type\" \"fp,fpcmp\") (eq_attr \"cpu\" \"supersparc\")) 9 3)\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fp,fpmove,fpcmp\"))\n+  3 1)\n+\n (define_function_unit \"fp_mds\" 1 0\n-  (and (eq_attr \"type\" \"fpmul\")    (eq_attr \"cpu\" \"supersparc\")) 9 3)\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fpmul\"))\n+  3 1)\n+\n (define_function_unit \"fp_mds\" 1 0\n-  (and (eq_attr \"type\" \"fpdivs\")   (eq_attr \"cpu\" \"supersparc\")) 18 12)\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fpdivs\"))\n+  6 4)\n+\n (define_function_unit \"fp_mds\" 1 0\n-  (and (eq_attr \"type\" \"fpdivd\")   (eq_attr \"cpu\" \"supersparc\")) 27 21)\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fpdivd\"))\n+  9 7)\n+\n (define_function_unit \"fp_mds\" 1 0\n-  (and (eq_attr \"type\" \"fpsqrt\")   (eq_attr \"cpu\" \"supersparc\")) 36 30)\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"fpsqrt\"))\n+  12 10)\n+\n (define_function_unit \"fp_mds\" 1 0\n-  (and (eq_attr \"type\" \"imul\")     (eq_attr \"cpu\" \"supersparc\")) 12 12)\n+  (and (eq_attr \"cpu\" \"supersparc\")\n+    (eq_attr \"type\" \"imul\"))\n+  4 4)\n \n ;; ----- sparclet tsc701 scheduling\n ;; The tsc701 issues 1 insn per cycle.\n ;; Results may be written back out of order.\n \n ;; Loads take 2 extra cycles to complete and 4 can be buffered at a time.\n+\n (define_function_unit \"tsc701_load\" 4 1\n-  (and (eq_attr \"type\" \"load\")          (eq_attr \"cpu\" \"tsc701\")) 3 1)\n+  (and (eq_attr \"cpu\" \"tsc701\")\n+    (eq_attr \"type\" \"load,sload\"))\n+  3 1)\n+\n ;; Stores take 2(?) extra cycles to complete.\n ;; It is desirable to not have any memory operation in the following 2 cycles.\n ;; (??? or 2 memory ops in the case of std).\n+\n (define_function_unit \"tsc701_store\" 1 0\n-  (and (eq_attr \"type\" \"store\")\t\t(eq_attr \"cpu\" \"tsc701\")) 3 3\n-  [(eq_attr \"type\" \"load,store\")])\n+  (and (eq_attr \"cpu\" \"tsc701\")\n+    (eq_attr \"type\" \"store\"))\n+  3 3\n+  [(eq_attr \"type\" \"load,sload,store\")])\n+\n ;; The multiply unit has a latency of 5.\n (define_function_unit \"tsc701_mul\" 1 0\n-  (and (eq_attr \"type\" \"imul\")\t\t(eq_attr \"cpu\" \"tsc701\")) 5 5)\n+  (and (eq_attr \"cpu\" \"tsc701\")\n+    (eq_attr \"type\" \"imul\"))\n+  5 5)\n \n ;; ----- The UltraSPARC-1 scheduling\n-;; The Ultrasparc can issue 1 - 4 insns per cycle; here we assume\n-;; four insns/cycle, and hence multiply all costs by four.\n+;; UltraSPARC has two integer units.  Shift instructions can only execute\n+;; on IE0.  Condition code setting instructions, call, and jmpl (including\n+;; the ret and retl pseudo-instructions) can only execute on IE1.\n+;; Branch on register uses IE1, but branch on condition code does not.\n+;; Conditional moves take 2 cycles.  No other instruction can issue in the\n+;; same cycle as a conditional move.\n+;; Multiply and divide take many cycles during which no other instructions\n+;; can issue.\n+;; Memory delivers its result in two cycles (except for signed loads,\n+;; which take one cycle more).  One memory instruction can be issued per\n+;; cycle.\n \n-;; Memory delivers its result in three cycles to IU, three cycles to FP\n (define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"load,fpload\")   (eq_attr \"cpu\" \"ultrasparc\")) 12 4)\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"load,fpload\"))\n+  2 1)\n+\n (define_function_unit \"memory\" 1 0\n-  (and (eq_attr \"type\" \"store,fpstore\") (eq_attr \"cpu\" \"ultrasparc\"))  4 4)\n-(define_function_unit \"ieu\" 1 0\n-  (and (eq_attr \"type\" \"ialu\")          (eq_attr \"cpu\" \"ultrasparc\"))  1 2)\n-(define_function_unit \"ieu\" 1 0\n-  (and (eq_attr \"type\" \"shift\")         (eq_attr \"cpu\" \"ultrasparc\"))  1 4)\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"sload\"))\n+  3 1)\n+\n+(define_function_unit \"memory\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"store,fpstore\"))\n+  1 1)\n+\n (define_function_unit \"ieu\" 1 0\n-  (and (eq_attr \"type\" \"cmove\")         (eq_attr \"cpu\" \"ultrasparc\"))  8 4)\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"ialu,shift,compare,cmove,call\"))\n+  1 1)\n+\n+(define_function_unit \"ieu_shift\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"shift\"))\n+  1 1)\n+\n+(define_function_unit \"ieu_shift\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"cmove\"))\n+  2 1)\n \n ;; Timings; throughput/latency\n ;; ?? FADD     1/3    add/sub, format conv, compar, abs, neg\n@@ -297,18 +377,50 @@\n ;; ?? FSQRTs   1/12\n ;; ?? FSQRTd   1/22\n \n-(define_function_unit \"fp\" 1 0\n-  (and (eq_attr \"type\" \"fp\")       (eq_attr \"cpu\" \"ultrasparc\")) 12 2)\n-(define_function_unit \"fp\" 1 0\n-  (and (eq_attr \"type\" \"fpcmp\")    (eq_attr \"cpu\" \"ultrasparc\"))  8 2)\n-(define_function_unit \"fp\" 1 0\n-  (and (eq_attr \"type\" \"fpmul\")    (eq_attr \"cpu\" \"ultrasparc\")) 12 2)\n-(define_function_unit \"fp\" 1 0\n-  (and (eq_attr \"type\" \"fpdivs\")   (eq_attr \"cpu\" \"ultrasparc\")) 48 2)\n-(define_function_unit \"fp\" 1 0\n-  (and (eq_attr \"type\" \"fpdivd\")   (eq_attr \"cpu\" \"ultrasparc\")) 88 2)\n-(define_function_unit \"fp\" 1 0\n-  (and (eq_attr \"type\" \"fpsqrt\")   (eq_attr \"cpu\" \"ultrasparc\")) 48 2)\n+(define_function_unit \"fadd\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpmove\"))\n+  1 1)\n+\n+(define_function_unit \"fadd\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpcmove\"))\n+  2 1)\n+\n+(define_function_unit \"fadd\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fp\"))\n+  4 1)\n+\n+(define_function_unit \"fadd\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpcmp\"))\n+  2 1)\n+\n+(define_function_unit \"fmul\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpmul\"))\n+  4 1)\n+\n+(define_function_unit \"fadd\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpcmove\"))\n+  2 1)\n+\n+(define_function_unit \"fadd\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpdivs\"))\n+  12 12)\n+\n+(define_function_unit \"fadd\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpdivd\"))\n+  22 22)\n+\n+(define_function_unit \"fadd\" 1 0\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+    (eq_attr \"type\" \"fpsqrt\"))\n+  12 12)\n \f\n ;; Compare instructions.\n ;; This controls RTL generation and register allocation.\n@@ -1542,7 +1654,7 @@\n \n (define_insn \"get_pc_via_rdpc\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\") (pc))]\n-  \"TARGET_PTR64\"\n+  \"TARGET_V9\"\n   \"rd %%pc,%0\"\n   [(set_attr \"type\" \"move\")])\n \n@@ -1972,8 +2084,8 @@\n ;; in an fp register, or an fp number is an integer register.\n \n (define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\" \"=r,f,r,r,f,Q,Q\")\n-\t(match_operand:SI 1 \"move_operand\" \"rI,!f,K,Q,!Q,rJ,!f\"))]\n+  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\" \"=r,f,r,r,f,Q,Q,d\")\n+\t(match_operand:SI 1 \"move_operand\" \"rI,!f,K,Q,!Q,rJ,!f,J\"))]\n   \"! TARGET_LIVE_G0\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n@@ -1985,8 +2097,9 @@\n    ld %1,%0\n    ld %1,%0\n    st %r1,%0\n-   st %1,%0\"\n-  [(set_attr \"type\" \"move,fp,move,load,fpload,store,fpstore\")\n+   st %1,%0\n+   fzeros %0\"\n+  [(set_attr \"type\" \"move,fp,move,load,fpload,store,fpstore,fpmove\")\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*movsi_insn_liveg0\"\n@@ -2005,7 +2118,7 @@\n    ld %1,%0\n    st %1,%0\n    st %1,%0\"\n-  [(set_attr \"type\" \"move,move,move,fp,move,load,fpload,store,fpstore\")\n+  [(set_attr \"type\" \"move,move,move,fpmove,move,load,fpload,store,fpstore\")\n    (set_attr \"length\" \"1,1,2,1,1,1,1,1,1\")])\n \n (define_insn \"*store_si\"\n@@ -2028,6 +2141,47 @@\n     DONE;\n }\")\n \n+;; V8+ movdi is like regular 32 bit except that a 64 bit zero can be stored\n+;; to aligned memory with a single instruction and the ldd/std instructions\n+;; are not used.\n+(define_insn \"*movdi_v8plus\"\n+  [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,T,Q,r,r,f,f,Q,b\")\n+      (match_operand:DI 1 \"general_operand\" \"r,J,r,Q,i,?f,?Q,?f,?J\"))]\n+  \"TARGET_V8PLUS\n+   && (register_operand (operands[0], DImode)\n+       || register_operand (operands[1], DImode)\n+       || operands[1] == const0_rtx)\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"stx %%g0,%0\\\";\n+  if (which_alternative == 7)\n+    return \\\"fzero %0\\\";\n+  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n+    return output_fp_move_double (operands);\n+  return output_move_double (operands);\n+}\"\n+  [(set_attr \"type\" \"move,store,store,load,multi,fp,fpload,fpstore,fpmove\")\n+   (set_attr \"length\" \"2,1,3,3,3,2,3,3,1\")])\n+\n+;; ??? The Haifa scheduler does not split instructions after reload if\n+;; it also ran before reload.\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n+      (match_operand:DI 1 \"register_operand\" \"r\"))]\n+  \"TARGET_V8PLUS && !TARGET_ARCH64 && reload_completed\n+   && REGNO (operands[1]) < 32 && ! MEM_VOLATILE_P (operands[0])\n+   && offsettable_memref_p (operands[0])\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"operands[3] = gen_highpart (SImode, operands[1]);\n+   operands[5] = gen_lowpart (SImode, operands[1]);\n+   operands[4] = adj_offsettable_operand (operands[0], 4);\n+   PUT_MODE (operands[4], SImode);\n+   operands[2] = copy_rtx (operands[0]);\n+   PUT_MODE (operands[2], SImode);\")\n+\n (define_insn \"*movdi_sp32_insn\"\n   [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,T,U,Q,r,r,?f,?f,?Q\")\n \t(match_operand:DI 1 \"general_operand\" \"r,U,T,r,Q,i,f,Q,f\"))]\n@@ -2155,8 +2309,8 @@\n ;; to be reloaded by putting the constant into memory.\n ;; It must come before the more general movsf pattern.\n (define_insn \"*movsf_const_insn\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=?r,f,m\")\n-\t(match_operand:SF 1 \"\" \"?F,m,G\"))]\n+  [(set (match_operand:SF 0 \"general_operand\" \"=?r,f,m,d\")\n+\t(match_operand:SF 1 \"\" \"?F,m,G,G\"))]\n   \"TARGET_FPU\n    && GET_CODE (operands[1]) == CONST_DOUBLE\n    && (GET_CODE (operands[0]) == REG\n@@ -2171,10 +2325,12 @@\n       return \\\"ld %1,%0\\\";\n     case 2:\n       return \\\"st %%g0,%0\\\";\n+    case 3:\n+      return \\\"fzeros %0\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"load,fpload,store\")\n-   (set_attr \"length\" \"2,1,1\")])\n+  [(set_attr \"type\" \"load,fpload,store,fpmove\")\n+   (set_attr \"length\" \"2,1,1,1\")])\n \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"general_operand\" \"\")\n@@ -2199,7 +2355,7 @@\n    ld %1,%0\n    st %1,%0\n    st %1,%0\"\n-  [(set_attr \"type\" \"fp,move,fpload,load,fpstore,store\")])\n+  [(set_attr \"type\" \"fpmove,move,fpload,load,fpstore,store\")])\n \n ;; Exactly the same as above, except that all `f' cases are deleted.\n ;; This is necessary to prevent reload from ever trying to use a `f' reg\n@@ -2232,8 +2388,8 @@\n ;; It must come before the more general movdf pattern.\n \n (define_insn \"*movdf_const_insn\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=?r,e,o\")\n-\t(match_operand:DF 1 \"\" \"?F,m,G\"))]\n+  [(set (match_operand:DF 0 \"general_operand\" \"=?r,e,o,d\")\n+\t(match_operand:DF 1 \"\" \"?F,m,G,G\"))]\n   \"TARGET_FPU\n    && GET_CODE (operands[1]) == CONST_DOUBLE\n    && (GET_CODE (operands[0]) == REG\n@@ -2247,7 +2403,7 @@\n     case 1:\n       return output_fp_move_double (operands);\n     case 2:\n-      if (TARGET_ARCH64)\n+      if (TARGET_ARCH64 || (TARGET_V9 && mem_aligned_8 (operands[0])))\n \t{\n \t  return \\\"stx %%g0,%0\\\";\n \t}\n@@ -2256,10 +2412,12 @@\n \t  operands[1] = adj_offsettable_operand (operands[0], 4);\n \t  return \\\"st %%g0,%0\\;st %%g0,%1\\\";\n \t}\n+    case 3:\n+      return \\\"fzero %0\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"load,fpload,store\")\n-   (set_attr \"length\" \"3,3,3\")])\n+  [(set_attr \"type\" \"load,fpload,store,fpmove\")\n+   (set_attr \"length\" \"3,3,3,1\")])\n \n (define_expand \"movdf\"\n   [(set (match_operand:DF 0 \"general_operand\" \"\")\n@@ -2368,7 +2526,7 @@\n     case 1:\n       return output_fp_move_quad (operands);\n     case 2:\n-      if (TARGET_ARCH64)\n+      if (TARGET_ARCH64 || (TARGET_V9 && mem_aligned_8 (operands[0])))\n \t{\n \t  operands[1] = adj_offsettable_operand (operands[0], 8);\n \t  return \\\"stx %%g0,%0\\;stx %%g0,%1\\\";\n@@ -2730,7 +2888,7 @@\n   \"@\n    fmovs%C1 %x2,%3,%0\n    fmovs%c1 %x2,%4,%0\"\n-  [(set_attr \"type\" \"cmove\")])\n+  [(set_attr \"type\" \"fpcmove\")])\n \n (define_insn \"*movdf_cc_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n@@ -2743,7 +2901,7 @@\n   \"@\n    fmovd%C1 %x2,%3,%0\n    fmovd%c1 %x2,%4,%0\"\n-  [(set_attr \"type\" \"cmove\")])\n+  [(set_attr \"type\" \"fpcmove\")])\n \n (define_insn \"*movtf_cc_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n@@ -2756,7 +2914,7 @@\n   \"@\n    fmovq%C1 %x2,%3,%0\n    fmovq%c1 %x2,%4,%0\"\n-  [(set_attr \"type\" \"cmove\")])\n+  [(set_attr \"type\" \"fpcmove\")])\n \n (define_insn \"*movqi_cc_reg_sp64\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n@@ -2822,7 +2980,7 @@\n   \"@\n    fmovrs%D1 %2,%3,%0\n    fmovrs%d1 %2,%4,%0\"\n-  [(set_attr \"type\" \"cmove\")])\n+  [(set_attr \"type\" \"fpcmove\")])\n \n (define_insn \"*movdf_cc_reg_sp64\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n@@ -2835,7 +2993,7 @@\n   \"@\n    fmovrd%D1 %2,%3,%0\n    fmovrd%d1 %2,%4,%0\"\n-  [(set_attr \"type\" \"cmove\")])\n+  [(set_attr \"type\" \"fpcmove\")])\n \n (define_insn \"*movtf_cc_reg_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n@@ -2848,7 +3006,7 @@\n   \"@\n    fmovrq%D1 %2,%3,%0\n    fmovrq%d1 %2,%4,%0\"\n-  [(set_attr \"type\" \"cmove\")])\n+  [(set_attr \"type\" \"fpcmove\")])\n \f\n ;;- zero extension instructions\n \n@@ -3056,7 +3214,7 @@\n \t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n   \"\"\n   \"ldsh %1,%0\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"sload\")])\n \n (define_expand \"extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n@@ -3093,7 +3251,7 @@\n \t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n   \"\"\n   \"ldsb %1,%0\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"sload\")])\n \n (define_expand \"extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -3123,7 +3281,7 @@\n \t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n   \"\"\n   \"ldsb %1,%0\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"sload\")])\n \n (define_expand \"extendqidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -3153,7 +3311,7 @@\n \t(sign_extend:DI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n   \"TARGET_ARCH64\"\n   \"ldsb %1,%0\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"sload\")])\n \n (define_expand \"extendhidi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -3198,7 +3356,7 @@\n   \"@\n   sra %1,0,%0\n   ldsw %1,%0\"\n-  [(set_attr \"type\" \"unary,load\")\n+  [(set_attr \"type\" \"unary,sload\")\n    (set_attr \"length\" \"1\")])\n \f\n ;; Special pattern for optimizing bit-field compares.  This is needed\n@@ -3619,6 +3777,15 @@\n }\"\n   [(set_attr \"length\" \"2\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+      (plus:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n+               (match_operand:DI 2 \"register_operand\" \"r\")))\n+   (clobber (reg:SI 100))]\n+  \"! TARGET_ARCH64\"\n+  \"addcc %L2,%1,%L0\\;addx %H2,0,%H0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n (define_insn \"*adddi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n@@ -3627,12 +3794,14 @@\n   \"add %1,%2,%0\")\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+\t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%r,d\")\n+\t\t (match_operand:SI 2 \"arith_operand\" \"rI,d\")))]\n   \"\"\n-  \"add %1,%2,%0\"\n-  [(set_attr \"type\" \"ialu\")])\n+  \"@\n+   add %1,%2,%0\n+   fpadd32s %1,%2,%0\"\n+  [(set_attr \"type\" \"ialu,fp\")])\n \n (define_insn \"*cmp_cc_plus\"\n   [(set (reg:CC_NOOV 100)\n@@ -3721,6 +3890,15 @@\n }\"\n   [(set_attr \"length\" \"2\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+      (minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+                (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))\n+   (clobber (reg:SI 100))]\n+  \"! TARGET_ARCH64\"\n+  \"subcc %L1,%2,%L0\\;addx %H1,0,%H0\"\n+  [(set_attr \"type\" \"multi\")])\n+\n (define_insn \"*subdi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n@@ -3729,12 +3907,14 @@\n   \"sub %1,%2,%0\")\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r,d\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"rI,d\")))]\n   \"\"\n-  \"sub %1,%2,%0\"\n-  [(set_attr \"type\" \"ialu\")])\n+  \"@\n+   sub %1,%2,%0\n+   fpsub32s %1,%2,%0\"\n+  [(set_attr \"type\" \"ialu,fp\")])\n \n (define_insn \"*cmp_minus_cc\"\n   [(set (reg:CC_NOOV 100)\n@@ -3784,7 +3964,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n \t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"smul %1,%2,%0\"\n   [(set_attr \"type\" \"imul\")])\n \n@@ -3812,7 +3992,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"arith_operand\" \"\"))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"\n {\n   if (CONSTANT_P (operands[2]))\n@@ -3826,7 +4006,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"*\n {\n   return TARGET_SPARCLET ? \\\"smuld %1,%2,%L0\\\" : \\\"smul %1,%2,%L0\\;rd %%y,%H0\\\";\n@@ -3841,7 +4021,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (match_operand:SI 2 \"small_int\" \"I\")))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"*\n {\n   return TARGET_SPARCLET ? \\\"smuld %1,%2,%L0\\\" : \\\"smul %1,%2,%L0\\;rd %%y,%H0\\\";\n@@ -3856,7 +4036,7 @@\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n \t\t\t       (sign_extend:DI (match_operand:SI 2 \"arith_operand\" \"\")))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"\n {\n   if (CONSTANT_P (operands[2]))\n@@ -3872,7 +4052,7 @@\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r\")))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"smul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3890,7 +4070,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"uns_arith_operand\" \"\"))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"\n {\n   if (CONSTANT_P (operands[2]))\n@@ -3904,7 +4084,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"*\n {\n   return TARGET_SPARCLET ? \\\"umuld %1,%2,%L0\\\" : \\\"umul %1,%2,%L0\\;rd %%y,%H0\\\";\n@@ -3919,7 +4099,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t (match_operand:SI 2 \"uns_small_int\" \"\")))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"*\n {\n   return TARGET_SPARCLET ? \\\"umuld %1,%2,%L0\\\" : \\\"umul %1,%2,%L0\\;rd %%y,%H0\\\";\n@@ -3934,7 +4114,7 @@\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n \t\t\t       (zero_extend:DI (match_operand:SI 2 \"uns_arith_operand\" \"\")))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"\n {\n   if (CONSTANT_P (operands[2]))\n@@ -3950,7 +4130,7 @@\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\")))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"umul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -3960,7 +4140,7 @@\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t\t       (match_operand:SI 2 \"uns_small_int\" \"\"))\n \t\t      (const_int 32))))]\n-  \"TARGET_V8 || TARGET_SPARCLITE || TARGET_SPARCLET || TARGET_DEPRECATED_V8_INSNS\"\n+  \"TARGET_HARD_MUL\"\n   \"umul %1,%2,%%g0\\;rd %%y,%0\"\n   [(set_attr \"length\" \"2\")])\n \n@@ -4102,14 +4282,17 @@\n   \"\")\n \n (define_insn \"*anddi3_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n+\t(and:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,b\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\")))]\n   \"! TARGET_ARCH64\"\n   \"*\n {\n   rtx op2 = operands[2];\n \n+  if (which_alternative == 1)\n+    return \\\"fand %1,%2,%0\\\";\n+\n   if (GET_CODE (op2) == CONST_INT\n       || GET_CODE (op2) == CONST_DOUBLE)\n     {\n@@ -4125,7 +4308,7 @@\n     }\n   return \\\"and %1,%2,%0\\;and %R1,%R2,%R0\\\";\n }\"\n-  [(set_attr \"length\" \"2\")])\n+  [(set_attr \"length\" \"2,1\")])\n \n (define_insn \"*anddi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4135,12 +4318,14 @@\n   \"and %1,%2,%0\")\n \n (define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+\t(and:SI (match_operand:SI 1 \"arith_operand\" \"%r,d\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI,d\")))]\n   \"\"\n-  \"and %1,%2,%0\"\n-  [(set_attr \"type\" \"ialu\")])\n+  \"@\n+   and %1,%2,%0\n+   fands %1,%2,%0\"\n+  [(set_attr \"type\" \"ialu,fp\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -4158,12 +4343,14 @@\n }\")\n \n (define_insn \"*and_not_di_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n-\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n+\t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r,b\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r,b\")))]\n   \"! TARGET_ARCH64\"\n-  \"andn %2,%1,%0\\;andn %R2,%R1,%R0\"\n-  [(set_attr \"length\" \"2\")])\n+  \"@\n+   andn %2,%1,%0\\;andn %R2,%R1,%R0\n+   fandnot1 %1,%2,%0\"\n+  [(set_attr \"length\" \"2,1\")])\n \n (define_insn \"*and_not_di_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4173,12 +4360,14 @@\n   \"andn %2,%1,%0\")\n \n (define_insn \"*and_not_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r,d\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r,d\")))]\n   \"\"\n-  \"andn %2,%1,%0\"\n-  [(set_attr \"type\" \"ialu\")])\n+  \"@\n+   andn %2,%1,%0\n+   fandnot1s %1,%2,%0\"\n+  [(set_attr \"type\" \"ialu,fp\")])\n \n (define_expand \"iordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4188,14 +4377,17 @@\n   \"\")\n \n (define_insn \"*iordi3_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n+\t(ior:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,b\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\")))]\n   \"! TARGET_ARCH64\"\n   \"*\n {\n   rtx op2 = operands[2];\n \n+  if (which_alternative == 1)\n+    return \\\"for %1,%2,%0\\\";\n+\n   if (GET_CODE (op2) == CONST_INT\n       || GET_CODE (op2) == CONST_DOUBLE)\n     {\n@@ -4211,7 +4403,7 @@\n     }\n   return \\\"or %1,%2,%0\\;or %R1,%R2,%R0\\\";\n }\"\n-  [(set_attr \"length\" \"2\")])\n+  [(set_attr \"length\" \"2,1\")])\n \n (define_insn \"*iordi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4221,12 +4413,14 @@\n   \"or %1,%2,%0\")\n \n (define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ior:SI (match_operand:SI 1 \"arith_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+\t(ior:SI (match_operand:SI 1 \"arith_operand\" \"%r,d\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI,d\")))]\n   \"\"\n-  \"or %1,%2,%0\"\n-  [(set_attr \"type\" \"ialu\")])\n+  \"@\n+   or %1,%2,%0\n+   fors %1,%2,%0\"\n+  [(set_attr \"type\" \"ialu,fp\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -4244,12 +4438,14 @@\n }\")\n \n (define_insn \"*or_not_di_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ior:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n-\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n+\t(ior:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r,b\"))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r,b\")))]\n   \"! TARGET_ARCH64\"\n-  \"orn %2,%1,%0\\;orn %R2,%R1,%R0\"\n-  [(set_attr \"length\" \"2\")])\n+  \"@\n+   orn %2,%1,%0\\;orn %R2,%R1,%R0\n+   fornot1 %1,%2,%0\"\n+  [(set_attr \"length\" \"2,1\")])\n \n (define_insn \"*or_not_di_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4259,12 +4455,14 @@\n   \"orn %2,%1,%0\")\n \n (define_insn \"*or_not_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+\t(ior:SI (not:SI (match_operand:SI 1 \"register_operand\" \"r,d\"))\n+\t\t(match_operand:SI 2 \"register_operand\" \"r,d\")))]\n   \"\"\n-  \"orn %2,%1,%0\"\n-  [(set_attr \"type\" \"ialu\")])\n+  \"@\n+   orn %2,%1,%0\n+   fornot1s %1,%2,%0\"\n+  [(set_attr \"type\" \"ialu,fp\")])\n \n (define_expand \"xordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4274,14 +4472,17 @@\n   \"\")\n \n (define_insn \"*xorsi3_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n-\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n+\t(xor:DI (match_operand:DI 1 \"arith_double_operand\" \"%r,b\")\n+\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI,b\")))]\n   \"! TARGET_ARCH64\"\n   \"*\n {\n   rtx op2 = operands[2];\n \n+  if (which_alternative == 1)\n+    return \\\"fxor %1,%2,%0\\\";\n+\n   if (GET_CODE (op2) == CONST_INT\n       || GET_CODE (op2) == CONST_DOUBLE)\n     {\n@@ -4297,7 +4498,7 @@\n     }\n   return \\\"xor %1,%2,%0\\;xor %R1,%R2,%R0\\\";\n }\"\n-  [(set_attr \"length\" \"2\")])\n+  [(set_attr \"length\" \"2,1\")])\n \n (define_insn \"*xordi3_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4307,12 +4508,14 @@\n   \"xor %r1,%2,%0\")\n \n (define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(xor:SI (match_operand:SI 1 \"arith_operand\" \"%rJ\")\n-\t\t(match_operand:SI 2 \"arith_operand\" \"rI\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+\t(xor:SI (match_operand:SI 1 \"arith_operand\" \"%rJ,d\")\n+\t\t(match_operand:SI 2 \"arith_operand\" \"rI,d\")))]\n   \"\"\n-  \"xor %r1,%2,%0\"\n-  [(set_attr \"type\" \"ialu\")])\n+  \"@\n+   xor %r1,%2,%0\n+   fxors %1,%2,%0\"\n+  [(set_attr \"type\" \"ialu,fp\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -4347,27 +4550,33 @@\n ;; xnor patterns.  Note that (a ^ ~b) == (~a ^ b) == ~(a ^ b).\n ;; Combine now canonicalizes to the rightmost expression.\n (define_insn \"*xor_not_di_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(not:DI (xor:DI (match_operand:DI 1 \"register_operand\" \"r\")\n-\t\t\t(match_operand:DI 2 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n+\t(not:DI (xor:DI (match_operand:DI 1 \"register_operand\" \"r,b\")\n+\t\t\t(match_operand:DI 2 \"register_operand\" \"r,b\"))))]\n   \"! TARGET_ARCH64\"\n-  \"xnor %1,%2,%0\\;xnor %R1,%R2,%R0\"\n-  [(set_attr \"length\" \"2\")])\n+  \"@\n+   xnor %1,%2,%0\\;xnor %R1,%R2,%R0\n+   fxnor %1,%2,%0\"\n+  [(set_attr \"length\" \"2,1\")\n+   (set_attr \"type\" \"ialu,fp\")])\n \n (define_insn \"*xor_not_di_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(not:DI (xor:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n \t\t\t(match_operand:DI 2 \"arith_double_operand\" \"rHI\"))))]\n   \"TARGET_ARCH64\"\n-  \"xnor %r1,%2,%0\")\n+  \"xnor %r1,%2,%0\"\n+  [(set_attr \"type\" \"ialu\")])\n \n (define_insn \"*xor_not_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (xor:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t(match_operand:SI 2 \"arith_operand\" \"rI\"))))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,d\")\n+\t(not:SI (xor:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ,d\")\n+\t\t\t(match_operand:SI 2 \"arith_operand\" \"rI,d\"))))]\n   \"\"\n-  \"xnor %r1,%2,%0\"\n-  [(set_attr \"type\" \"ialu\")])\n+  \"@\n+   xnor %r1,%2,%0\n+   fxnors %1,%2,%0\"\n+  [(set_attr \"type\" \"ialu,fp\")])\n \n ;; These correspond to the above in the case where we also (or only)\n ;; want to set the condition code.  \n@@ -4608,12 +4817,14 @@\n   \"\")\n \n (define_insn \"*one_cmpldi2_sp32\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(not:DI (match_operand:DI 1 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n+\t(not:DI (match_operand:DI 1 \"register_operand\" \"r,b\")))]\n   \"! TARGET_ARCH64\"\n-  \"xnor %1,0,%0\\;xnor %R1,0,%R0\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"length\" \"2\")])\n+  \"@\n+   xnor %1,0,%0\\;xnor %R1,0,%R0\n+   fnot1 %1,%0\"\n+  [(set_attr \"type\" \"unary,fp\")\n+   (set_attr \"length\" \"2,1\")])\n \n (define_insn \"*one_cmpldi2_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -4623,21 +4834,24 @@\n   [(set_attr \"type\" \"unary\")])\n \n (define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(not:SI (match_operand:SI 1 \"arith_operand\" \"r,I\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,d\")\n+\t(not:SI (match_operand:SI 1 \"arith_operand\" \"r,I,d\")))]\n   \"\"\n   \"*\n {\n   if (which_alternative == 0)\n     return \\\"xnor %1,0,%0\\\";\n+  if (which_alternative == 1)\n+    return \\\"fnot1s %1,%0\\\";\n   if (TARGET_LIVE_G0)\n     output_asm_insn (\\\"and %%g0,0,%%g0\\\", operands);\n   return \\\"xnor %%g0,%1,%0\\\";\n }\"\n-  [(set_attr \"type\" \"unary\")\n+  [(set_attr \"type\" \"unary,unary,fp\")\n    (set_attr_alternative \"length\"\n      [(const_int 1)\n-      (if_then_else (eq_attr \"live_g0\" \"yes\") (const_int 2) (const_int 1))])])\n+      (if_then_else (eq_attr \"live_g0\" \"yes\") (const_int 2) (const_int 1))\n+      (const_int 1)])])\n \n (define_insn \"*cmp_cc_not\"\n   [(set (reg:CC 100)\n@@ -4804,7 +5018,7 @@\n    return TARGET_V9 ? \\\"fnegd %1,%0\\;fmovd %S1,%S0\\\"\n      : \\\"fnegs %1,%0\\;fmovs %R1,%R0\\;fmovs %S1,%S0\\;fmovs %T1,%T0\\\";\n }\"\n-  [(set_attr \"type\" \"fp\")\n+  [(set_attr \"type\" \"fpmove\")\n    (set_attr_alternative \"length\"\n      [(const_int 1)\n       (if_then_else (eq_attr \"isa\" \"v9\") (const_int 2) (const_int 4))])])\n@@ -4822,7 +5036,7 @@\n   else\n    return \\\"fnegs %1,%0\\;fmovs %R1,%R0\\\";\n }\"\n-  [(set_attr \"type\" \"fp\")\n+  [(set_attr \"type\" \"fpmove\")\n    (set_attr_alternative \"length\"\n      [(const_int 1)\n       (if_then_else (eq_attr \"isa\" \"v9\") (const_int 1) (const_int 2))])])\n@@ -4832,7 +5046,7 @@\n \t(neg:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_FPU\"\n   \"fnegs %1,%0\"\n-  [(set_attr \"type\" \"fp\")])\n+  [(set_attr \"type\" \"fpmove\")])\n \n (define_insn \"abstf2\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n@@ -4848,7 +5062,7 @@\n     return TARGET_V9 ? \\\"fabsd %1,%0\\;fmovd %S1,%S0\\\"\n       : \\\"fabss %1,%0\\;fmovs %R1,%R0\\;fmovs %S1,%S0\\;fmovs %T1,%T0\\\";\n }\"\n-  [(set_attr \"type\" \"fp\")\n+  [(set_attr \"type\" \"fpmove\")\n    (set_attr_alternative \"length\"\n      [(const_int 1)\n       (if_then_else (eq_attr \"isa\" \"v9\") (const_int 2) (const_int 4))])])\n@@ -4866,7 +5080,7 @@\n   else\n     return \\\"fabss %1,%0\\;fmovs %R1,%R0\\\";\n }\"\n-  [(set_attr \"type\" \"fp\")\n+  [(set_attr \"type\" \"fpmove\")\n    (set_attr_alternative \"length\"\n      [(const_int 1)\n       (if_then_else (eq_attr \"isa\" \"v9\") (const_int 1) (const_int 2))])])\n@@ -4876,7 +5090,7 @@\n \t(abs:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_FPU\"\n   \"fabss %1,%0\"\n-  [(set_attr \"type\" \"fp\")])\n+  [(set_attr \"type\" \"fpmove\")])\n \n (define_insn \"sqrttf2\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e\")\n@@ -5791,13 +6005,32 @@\n ;; The conditions in which we do this are very restricted and are \n ;; explained in the code for {registers,memory}_ok_for_ldd functions.\n \n+(define_peephole\n+  [(set (match_operand:SI 0 \"memory_operand\" \"\")\n+      (const_int 0))\n+   (set (match_operand:SI 1 \"memory_operand\" \"\")\n+      (const_int 0))]\n+  \"TARGET_V9\n+   && ! MEM_VOLATILE_P (operands[0]) && ! MEM_VOLATILE_P (operands[1])\n+   && addrs_ok_for_ldd_peep (XEXP (operands[0], 0), XEXP (operands[1], 0))\"\n+  \"stx %%g0,%0\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"memory_operand\" \"\")\n+      (const_int 0))\n+   (set (match_operand:SI 1 \"memory_operand\" \"\")\n+      (const_int 0))]\n+  \"TARGET_V9\n+   && ! MEM_VOLATILE_P (operands[0]) && ! MEM_VOLATILE_P (operands[1])\n+   && addrs_ok_for_ldd_peep (XEXP (operands[1], 0), XEXP (operands[0], 0))\"\n+  \"stx %%g0,%1\")\n+\n (define_peephole\n   [(set (match_operand:SI 0 \"register_operand\" \"=rf\")\n         (match_operand:SI 1 \"memory_operand\" \"\"))\n    (set (match_operand:SI 2 \"register_operand\" \"=rf\")\n         (match_operand:SI 3 \"memory_operand\" \"\"))]\n-  \"! TARGET_ARCH64\n-   && registers_ok_for_ldd_peep (operands[0], operands[2]) \n+   \"registers_ok_for_ldd_peep (operands[0], operands[2]) \n    && ! MEM_VOLATILE_P (operands[1]) && ! MEM_VOLATILE_P (operands[3])\n    && addrs_ok_for_ldd_peep (XEXP (operands[1], 0), XEXP (operands[3], 0))\" \n   \"ldd %1,%0\")\n@@ -5807,8 +6040,7 @@\n         (match_operand:SI 1 \"register_operand\" \"rf\"))\n    (set (match_operand:SI 2 \"memory_operand\" \"\")\n         (match_operand:SI 3 \"register_operand\" \"rf\"))]\n-  \"! TARGET_ARCH64\n-   && registers_ok_for_ldd_peep (operands[1], operands[3]) \n+   \"registers_ok_for_ldd_peep (operands[1], operands[3]) \n    && ! MEM_VOLATILE_P (operands[0]) && ! MEM_VOLATILE_P (operands[2])\n    && addrs_ok_for_ldd_peep (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n   \"std %1,%0\")\n@@ -5818,8 +6050,7 @@\n         (match_operand:SF 1 \"memory_operand\" \"\"))\n    (set (match_operand:SF 2 \"register_operand\" \"=fr\")\n         (match_operand:SF 3 \"memory_operand\" \"\"))]\n-  \"! TARGET_ARCH64\n-   && registers_ok_for_ldd_peep (operands[0], operands[2]) \n+   \"registers_ok_for_ldd_peep (operands[0], operands[2]) \n    && ! MEM_VOLATILE_P (operands[1]) && ! MEM_VOLATILE_P (operands[3])\n    && addrs_ok_for_ldd_peep (XEXP (operands[1], 0), XEXP (operands[3], 0))\"\n   \"ldd %1,%0\")\n@@ -5829,8 +6060,7 @@\n         (match_operand:SF 1 \"register_operand\" \"fr\"))\n    (set (match_operand:SF 2 \"memory_operand\" \"\")\n         (match_operand:SF 3 \"register_operand\" \"fr\"))]\n-  \"! TARGET_ARCH64\n-   && registers_ok_for_ldd_peep (operands[1], operands[3]) \n+   \"registers_ok_for_ldd_peep (operands[1], operands[3]) \n    && ! MEM_VOLATILE_P (operands[0]) && ! MEM_VOLATILE_P (operands[2])\n    && addrs_ok_for_ldd_peep (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n   \"std %1,%0\")\n@@ -5840,8 +6070,7 @@\n         (match_operand:SI 1 \"memory_operand\" \"\"))\n    (set (match_operand:SI 2 \"register_operand\" \"=rf\")\n         (match_operand:SI 3 \"memory_operand\" \"\"))]\n-  \"! TARGET_ARCH64\n-   && registers_ok_for_ldd_peep (operands[2], operands[0]) \n+   \"registers_ok_for_ldd_peep (operands[2], operands[0]) \n    && ! MEM_VOLATILE_P (operands[3]) && ! MEM_VOLATILE_P (operands[1])\n    && addrs_ok_for_ldd_peep (XEXP (operands[3], 0), XEXP (operands[1], 0))\"\n   \"ldd %3,%2\")\n@@ -5851,8 +6080,7 @@\n         (match_operand:SI 1 \"register_operand\" \"rf\"))\n    (set (match_operand:SI 2 \"memory_operand\" \"\")\n         (match_operand:SI 3 \"register_operand\" \"rf\"))]\n-  \"! TARGET_ARCH64\n-   && registers_ok_for_ldd_peep (operands[3], operands[1]) \n+   \"registers_ok_for_ldd_peep (operands[3], operands[1]) \n    && ! MEM_VOLATILE_P (operands[2]) && ! MEM_VOLATILE_P (operands[0])\n    && addrs_ok_for_ldd_peep (XEXP (operands[2], 0), XEXP (operands[0], 0))\" \n   \"std %3,%2\")\n@@ -5862,8 +6090,7 @@\n         (match_operand:SF 1 \"memory_operand\" \"\"))\n    (set (match_operand:SF 2 \"register_operand\" \"=fr\")\n         (match_operand:SF 3 \"memory_operand\" \"\"))]\n-  \"! TARGET_ARCH64\n-   && registers_ok_for_ldd_peep (operands[2], operands[0]) \n+   \"registers_ok_for_ldd_peep (operands[2], operands[0]) \n    && ! MEM_VOLATILE_P (operands[3]) && ! MEM_VOLATILE_P (operands[1])\n    && addrs_ok_for_ldd_peep (XEXP (operands[3], 0), XEXP (operands[1], 0))\"\n   \"ldd %3,%2\")\n@@ -5873,8 +6100,7 @@\n         (match_operand:SF 1 \"register_operand\" \"fr\"))\n    (set (match_operand:SF 2 \"memory_operand\" \"\")\n         (match_operand:SF 3 \"register_operand\" \"fr\"))]\n-  \"! TARGET_ARCH64\n-   && registers_ok_for_ldd_peep (operands[3], operands[1]) \n+   \"registers_ok_for_ldd_peep (operands[3], operands[1]) \n    && ! MEM_VOLATILE_P (operands[2]) && ! MEM_VOLATILE_P (operands[0])\n    && addrs_ok_for_ldd_peep (XEXP (operands[2], 0), XEXP (operands[0], 0))\"\n   \"std %3,%2\")\n@@ -6072,24 +6298,13 @@\n \n (define_insn \"*return_adddi\"\n   [(set (match_operand:DI 0 \"restore_operand\" \"\")\n-\t(plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n+\t(plus:DI (match_operand:DI 1 \"arith_operand\" \"%r\")\n \t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n    (return)]\n-  \"TARGET_ARCH64 && ! TARGET_EPILOGUE\n-   && (register_operand (operands[1], DImode)\n-       || register_operand (operands[2], DImode))\"\n+  \"TARGET_ARCH64 && ! TARGET_EPILOGUE\"\n   \"ret\\;restore %r1,%2,%Y0\"\n   [(set_attr \"type\" \"multi\")])\n \n-(define_insn \"*return_subsi\"\n-  [(set (match_operand:SI 0 \"restore_operand\" \"\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (match_operand:SI 2 \"small_int\" \"I\")))\n-   (return)]\n-  \"! TARGET_EPILOGUE && INTVAL (operands[2]) != -4096\"\n-  \"ret\\;restore %1,%n2,%Y0\"\n-  [(set_attr \"type\" \"multi\")])\n-\n ;; The following pattern is only generated by delayed-branch scheduling,\n ;; when the insn winds up in the epilogue.\n (define_insn \"*return_sf\"\n@@ -6117,10 +6332,7 @@\n \t      (clobber (reg:SI 15))])\n    (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n   \"short_branch (INSN_UID (insn), INSN_UID (operands[2]))\"\n-  \"*\n-{\n-  return \\\"call %a0,%1\\;add %%o7,(%l2-.-4),%%o7\\\";\n-}\")\n+  \"call %a0,%1\\;add %%o7,(%l2-.-4),%%o7\")\n \n (define_peephole\n   [(parallel [(set (match_operand 0 \"\" \"\")"}]}