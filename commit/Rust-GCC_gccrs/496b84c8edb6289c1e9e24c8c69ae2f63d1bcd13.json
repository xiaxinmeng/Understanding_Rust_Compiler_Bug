{"sha": "496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk2Yjg0YzhlZGI2Mjg5YzFlOWUyNGM4YzY5YWUyZjYzZDFiY2QxMw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-08-30T15:55:18Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-08-30T15:55:18Z"}, "message": "lib1funcs.asm (RETCOND): Delete.\n\n2003-08-30  Richard Earnshaw  <rearnsha@arm.com>\n\tNicolas Pitre <nico@cam.org>\n\n* arm/lib1funcs.asm (RETCOND): Delete.\n(RETLDM): New assembler macro.  Use it for returning with ldm/ldr.\n(ARM_LDIV0, THUMB_LDIV0): Collapse multiple definitions.\n(__ARM_ARCH__): Move here from ieee754-?f.S.\n(RET, RETc): Clean up definitions.\n(DIV_FUNC_END): Renamed from FUNC_END.  All uses changed.\n(FUNC_END): New macro that marks the end of any function.\n(ARM_FUNC_START): New macro that allows an assembler routine to be\nimplemented in ARM code even if a Thumb-only build.\nUnconditionally include ieee754-?f.S.\n* arm/ieee754-df.S: Delete macros moved to lib1funcs.asm.\nMark ends of functions.\nSplit into separate conditionally-compiled units.\nUse RETLDM to return from routines.\n* arm/ieee754-sf.S: Similarly.\n* t-arm-elf (LIB1ASMFUNCS): Remove _ieee754_dp and _ieee754_sp.\nAdd _negdf2 _addsubdf3 _muldivdf3 _cmpdf2 _unorddf2 _fixdfsi\n_truncdfsf2 _negsf2 _addsubsf3 _muldivsf3 _cmpsf2 _unordsf2\n_fixsfsi and _fixunssfsi.\n\n* arm/ieee754-df.S (__muldf3): Fix bug when result of a\nmultiplication underflows to zero.\n(__adddf3): Fix bug when using VFP ordering on little-endian\nprocessors.\n(__fixdfsi): Use rrx to extract the carry into a register instead of\nMRS instruction.  Optimize later use of result.\n* arm/ieee754-sf.S (__fixsfsi): Likewise.\n(__fixunssfsi): Use a better sequence for handling negative-or-zero.\n\nCo-Authored-By: Nicolas Pitre <nico@cam.org>\n\nFrom-SVN: r70949", "tree": {"sha": "349af1b7d66c6e55be23a479deec8f89cb9d734b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/349af1b7d66c6e55be23a479deec8f89cb9d734b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/comments", "author": null, "committer": null, "parents": [{"sha": "88d032eb1ef92c51e155131e30ce8411673bdec6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88d032eb1ef92c51e155131e30ce8411673bdec6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88d032eb1ef92c51e155131e30ce8411673bdec6"}], "stats": {"total": 612, "additions": 288, "deletions": 324}, "files": [{"sha": "59f43896bf5e154fd93b9703c012f58c540e71c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "patch": "@@ -1,3 +1,35 @@\n+2003-08-30  Richard Earnshaw  <rearnsha@arm.com>\n+\tNicolas Pitre <nico@cam.org>\n+\n+\t* arm/lib1funcs.asm (RETCOND): Delete.\n+\t(RETLDM): New assembler macro.  Use it for returning with ldm/ldr.\n+\t(ARM_LDIV0, THUMB_LDIV0): Collapse multiple definitions.\n+\t(__ARM_ARCH__): Move here from ieee754-?f.S.\n+\t(RET, RETc): Clean up definitions.\n+\t(DIV_FUNC_END): Renamed from FUNC_END.  All uses changed.\n+\t(FUNC_END): New macro that marks the end of any function.\n+\t(ARM_FUNC_START): New macro that allows an assembler routine to be\n+\timplemented in ARM code even if a Thumb-only build.\n+\tUnconditionally include ieee754-?f.S.\n+\t* arm/ieee754-df.S: Delete macros moved to lib1funcs.asm.\n+\tMark ends of functions.\n+\tSplit into separate conditionally-compiled units.\n+\tUse RETLDM to return from routines.\n+\t* arm/ieee754-sf.S: Similarly.\n+\t* t-arm-elf (LIB1ASMFUNCS): Remove _ieee754_dp and _ieee754_sp. \n+\tAdd _negdf2 _addsubdf3 _muldivdf3 _cmpdf2 _unorddf2 _fixdfsi\n+\t_truncdfsf2 _negsf2 _addsubsf3 _muldivsf3 _cmpsf2 _unordsf2\n+\t_fixsfsi and _fixunssfsi.\n+\n+\t* arm/ieee754-df.S (__muldf3): Fix bug when result of a \n+\tmultiplication underflows to zero.\n+\t(__adddf3): Fix bug when using VFP ordering on little-endian \n+\tprocessors.\n+\t(__fixdfsi): Use rrx to extract the carry into a register instead of\n+\tMRS instruction.  Optimize later use of result.\n+\t* arm/ieee754-sf.S (__fixsfsi): Likewise.\n+\t(__fixunssfsi): Use a better sequence for handling negative-or-zero.\n+\t\n 2003-08-29  Richard Henderson  <rth@redhat.com>\n \n \t* tree-optimize.c: New file."}, {"sha": "2d5f487ff6015a350da5f9433c7ee6e7aedf900a", "filename": "gcc/config/arm/ieee754-df.S", "status": "modified", "additions": 84, "deletions": 201, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/gcc%2Fconfig%2Farm%2Fieee754-df.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/gcc%2Fconfig%2Farm%2Fieee754-df.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fieee754-df.S?ref=496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "patch": "@@ -40,33 +40,6 @@\n  * if necessary without impacting performances.\n  */\n \n-@ This selects the minimum architecture level required.\n-#undef __ARM_ARCH__\n-#define __ARM_ARCH__ 3\n-\n-#if defined(__ARM_ARCH_3M__) || defined(__ARM_ARCH_4__) \\\n-\t|| defined(__ARM_ARCH_4T__)\n-#undef __ARM_ARCH__\n-/* We use __ARM_ARCH__ set to 4 here, but in reality it's any processor with\n-   long multiply instructions.  That includes v3M.  */\n-#define __ARM_ARCH__ 4\n-#endif\n-\t\n-#if defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) \\\n-\t|| defined(__ARM_ARCH_5TE__)\n-#undef __ARM_ARCH__\n-#define __ARM_ARCH__ 5\n-#endif\n-\n-#if (__ARM_ARCH__ > 4) || defined(__ARM_ARCH_4T__)\n-#undef RET\n-#undef RETc\n-#define RET\tbx\tlr\n-#define RETc(x) bx##x\tlr\n-#if (__ARM_ARCH__ == 4) && (defined(__thumb__) || defined(__THUMB_INTERWORK__))\n-#define __FP_INTERWORKING__\n-#endif\n-#endif\n \n @ For FPA, float words are always big-endian.\n @ For VFP, floats words follow the memory system mode.\n@@ -83,24 +56,19 @@\n #endif\n \n \n-#if defined(__thumb__) && !defined(__THUMB_INTERWORK__)\n-.macro\tARM_FUNC_START name\n-\tFUNC_START \\name\n-\tbx\tpc\n-\tnop\n-\t.arm\n-.endm\n-#else\n-.macro\tARM_FUNC_START name\n-\tFUNC_START \\name\n-.endm\n-#endif\n+#ifdef L_negdf2\n \n ARM_FUNC_START negdf2\n \t@ flip sign bit\n \teor\txh, xh, #0x80000000\n \tRET\n \n+\tFUNC_END negdf2\n+\n+#endif\n+\n+#ifdef L_addsubdf3\n+\n ARM_FUNC_START subdf3\n \t@ flip sign bit of second arg\n \teor\tyh, yh, #0x80000000\n@@ -155,12 +123,7 @@ ARM_FUNC_START adddf3\n \t@ already in xh-xl.  We need up to 54 bit to handle proper rounding\n \t@ of 0x1p54 - 1.1.\n \tcmp\tr5, #(54 << 20)\n-#ifdef __FP_INTERWORKING__\n-\tldmhifd\tsp!, {r4, r5, lr}\n-\tbxhi\tlr\n-#else\n-\tldmhifd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\" hi\n \n \t@ Convert mantissa to signed integer.\n \ttst\txh, #0x80000000\n@@ -227,9 +190,9 @@ LSYM(Lad_x):\n LSYM(Lad_p):\n \tcmp\txh, #0x00100000\n \tbcc\tLSYM(Lad_l)\n-\tcmp\tr0, #0x00200000\n+\tcmp\txh, #0x00200000\n \tbcc\tLSYM(Lad_r0)\n-\tcmp\tr0, #0x00400000\n+\tcmp\txh, #0x00400000\n \tbcc\tLSYM(Lad_r1)\n \n \t@ Result needs to be shifted right.\n@@ -268,14 +231,10 @@ LSYM(Lad_e):\n \tbic\txh, xh, #0x00300000\n \torr\txh, xh, r4\n \torr\txh, xh, r5\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\"\n \n-LSYM(Lad_l):\t@ Result must be shifted left and exponent adjusted.\n+LSYM(Lad_l):\n+\t@ Result must be shifted left and exponent adjusted.\n \t@ No rounding necessary since ip will always be 0.\n #if __ARM_ARCH__ < 5\n \n@@ -351,12 +310,7 @@ LSYM(Lad_l):\t@ Result must be shifted left and exponent adjusted.\n \tmov\txl, xl, lsr r4\n \torr\txl, xl, xh, lsl r2\n \torr\txh, r5, xh, lsr r4\n-#ifdef __FP_INTERWORKING\n-\tldmfd\tsp!, {r4, r5, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\"\n \n \t@ shift result right of 21 to 31 bits, or left 11 to 1 bits after\n \t@ a register switch from xh to xl.\n@@ -365,23 +319,13 @@ LSYM(Lad_l):\t@ Result must be shifted left and exponent adjusted.\n \tmov\txl, xl, lsr r2\n \torr\txl, xl, xh, lsl r4\n \tmov\txh, r5\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\"\n \n \t@ Shift value right of 32 to 64 bits, or 0 to 32 bits after a switch\n \t@ from xh to xl.\n 2:\tmov\txl, xh, lsr r4\n \tmov\txh, r5\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\"\n \n \t@ Adjust exponents for denormalized arguments.\n LSYM(Lad_d):\n@@ -407,12 +351,7 @@ LSYM(Lad_o):\n \torr\txh, r5, #0x7f000000\n \torr\txh, xh, #0x00f00000\n \tmov\txl, #0\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\"\n \n \t@ At least one of x or y is INF/NAN.\n \t@   if xh-xl != INF/NAN: return yh-yl (which is INF/NAN)\n@@ -425,24 +364,17 @@ LSYM(Lad_i):\n \tmovne\txh, yh\n \tmovne\txl, yl\n \tteqeq\tr5, ip\n-#ifdef __FP_INTERWORKING__\n-\tldmnefd\tsp!, {r4, r5, lr}\n-\tbxne\tlr\n-#else\n-\tldmnefd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\" ne\n+\n \torrs\tr4, xl, xh, lsl #12\n \torreqs\tr4, yl, yh, lsl #12\n \tteqeq\txh, yh\n \torrne\txh, r5, #0x00080000\n \tmovne\txl, #0\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\"\n \n+\tFUNC_END subdf3\n+\tFUNC_END adddf3\n \n ARM_FUNC_START floatunsidf\n \tteq\tr0, #0\n@@ -456,6 +388,7 @@ ARM_FUNC_START floatunsidf\n \tmov\txh, #0\n \tb\tLSYM(Lad_l)\n \n+\tFUNC_END floatunsidf\n \n ARM_FUNC_START floatsidf\n \tteq\tr0, #0\n@@ -470,6 +403,7 @@ ARM_FUNC_START floatsidf\n \tmov\txh, #0\n \tb\tLSYM(Lad_l)\n \n+\tFUNC_END floatsidf\n \n ARM_FUNC_START extendsfdf2\n \tmovs\tr2, r0, lsl #1\n@@ -495,6 +429,11 @@ ARM_FUNC_START extendsfdf2\n \tbic\txh, xh, #0x80000000\n \tb\tLSYM(Lad_l)\n \n+\tFUNC_END extendsfdf2\n+\n+#endif /* L_addsubdf3 */\n+\n+#ifdef L_muldivdf3\n \n ARM_FUNC_START muldf3\n \n@@ -656,36 +595,22 @@ LSYM(Lml_x):\n \t@ Add final exponent.\n \tbic\txh, xh, #0x00300000\n \torr\txh, xh, r4, lsl #1\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, r6, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, r6, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5, r6\"\n \n \t@ Result is 0, but determine sign anyway.\n LSYM(Lml_z):\n \teor\txh, xh, yh\n LSYM(Ldv_z):\n \tbic\txh, xh, #0x7fffffff\n \tmov\txl, #0\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, r6, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, r6, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5, r6\"\n \n \t@ Check if denormalized result is possible, otherwise return signed 0.\n LSYM(Lml_u):\n \tcmn\tr4, #(53 << 19)\n \tmovle\txl, #0\n-#ifdef __FP_INTERWORKING__\n-\tldmlefd\tsp!, {r4, r5, r6, lr}\n-\tbxle\tlr\n-#else\n-\tldmlefd\tsp!, {r4, r5, r6, pc}RETCOND\n-#endif\n+\tbicle\txh, xh, #0x7fffffff\n+\tRETLDM\t\"r4, r5, r6\" le\n \n \t@ Find out proper shift value.\n LSYM(Lml_r):\n@@ -709,12 +634,7 @@ LSYM(Lml_r):\n \tteq\tlr, #0\n \tteqeq\tr3, #0x80000000\n \tbiceq\txl, xl, #1\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, r6, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, r6, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5, r6\"\n \n \t@ shift result right of 21 to 31 bits, or left 11 to 1 bits after\n \t@ a register switch from xh to xl. Then round.\n@@ -729,12 +649,7 @@ LSYM(Lml_r):\n \tteq\tlr, #0\n \tteqeq\tr3, #0x80000000\n \tbiceq\txl, xl, #1\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, r6, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, r6, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5, r6\"\n \n \t@ Shift value right of 32 to 64 bits, or 0 to 32 bits after a switch\n \t@ from xh to xl.  Leftover bits are in r3-r6-lr for rounding.\n@@ -749,12 +664,7 @@ LSYM(Lml_r):\n \torrs\tr6, r6, lr\n \tteqeq\tr3, #0x80000000\n \tbiceq\txl, xl, #1\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, r6, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, r6, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5, r6\"\n \n \t@ One or both arguments are denormalized.\n \t@ Scale them leftwards and preserve sign bit.\n@@ -804,24 +714,15 @@ LSYM(Lml_o):\n \torr\txh, xh, #0x7f000000\n \torr\txh, xh, #0x00f00000\n \tmov\txl, #0\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, r6, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, r6, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5, r6\"\n \n \t@ Return NAN.\n LSYM(Lml_n):\n \tmov\txh, #0x7f000000\n \torr\txh, xh, #0x00f80000\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, r6, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, r6, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5, r6\"\n \n+\tFUNC_END muldf3\n \n ARM_FUNC_START divdf3\n \n@@ -961,12 +862,7 @@ LSYM(Ldv_x):\n \t@ Add exponent to result.\n \tbic\txh, xh, #0x00100000\n \torr\txh, xh, r4, lsl #1\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, r6, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, r6, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5, r6\"\n \n \t@ Division by 0x1p*: shortcut a lot of code.\n LSYM(Ldv_1):\n@@ -978,12 +874,8 @@ LSYM(Ldv_1):\n \tbge\tLSYM(Lml_o)\n \tcmp\tr4, #0\n \torrgt\txh, xh, r4, lsl #1\n-#ifdef __FP_INTERWORKING__\n-\tldmgtfd\tsp!, {r4, r5, r6, lr}\n-\tbxgt\tlr\n-#else\n-\tldmgtfd\tsp!, {r4, r5, r6, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5, r6\" gt\n+\n \tcmn\tr4, #(53 << 19)\n \tble\tLSYM(Ldv_z)\n \torr\txh, xh, #0x00100000\n@@ -1042,6 +934,11 @@ LSYM(Ldv_s):\n \tbne\tLSYM(Lml_z)\t\t@ 0 / <non_zero> -> 0\n \tb\tLSYM(Lml_n)\t\t@ 0 / 0 -> NAN\n \n+\tFUNC_END divdf3\n+\n+#endif /* L_muldivdf3 */\n+\n+#ifdef L_cmpdf2\n \n FUNC_START gedf2\n ARM_FUNC_START gtdf2\n@@ -1076,23 +973,13 @@ ARM_FUNC_START cmpdf2\n \tteqne\txh, yh\t\t\t@ or xh == yh\n \tteqeq\txl, yl\t\t\t@ and xl == yl\n \tmoveq\tr0, #0\t\t\t@ then equal.\n-#ifdef __FP_INTERWORKING__\n-\tldmeqfd\tsp!, {r4, r5, lr}\n-\tbxeq\tlr\n-#else\n-\tldmeqfd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\" eq\n \n \t@ Check for sign difference.\n \tteq\txh, yh\n \tmovmi\tr0, xh, asr #31\n \torrmi\tr0, r0, #1\n-#ifdef __FP_INTERWORKING__\n-\tldmmifd\tsp!, {r4, r5, lr}\n-\tbxmi\tlr\n-#else\n-\tldmmifd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\" mi\n \n \t@ Compare exponents.\n \tcmp\tr4, r5\n@@ -1104,12 +991,7 @@ ARM_FUNC_START cmpdf2\n \tmovcs\tr0, yh, asr #31\n \tmvncc\tr0, yh, asr #31\n \torr\tr0, r0, #1\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\"\n \n \t@ Look for a NAN.\n 3:\tteq\tr4, lr\n@@ -1121,13 +1003,19 @@ ARM_FUNC_START cmpdf2\n \torrs\tyl, yl, yh, lsl #12\n \tbeq\t2b\t\t\t@ y is not NAN\n 5:\tmov\tr0, ip\t\t\t@ return unordered code from ip\n-#ifdef __FP_INTERWORKING__\n-\tldmfd\tsp!, {r4, r5, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r4, r5, pc}RETCOND\n-#endif\n+\tRETLDM\t\"r4, r5\"\n \n+\tFUNC_END gedf2\n+\tFUNC_END gtdf2\n+\tFUNC_END ledf2\n+\tFUNC_END ltdf2\n+\tFUNC_END nedf2\n+\tFUNC_END eqdf2\n+\tFUNC_END cmpdf2\n+\n+#endif /* L_cmpdf2 */\n+\n+#ifdef L_unorddf2\n \n ARM_FUNC_START unorddf2\n \tstr\tlr, [sp, #-4]!\n@@ -1144,35 +1032,22 @@ ARM_FUNC_START unorddf2\n \torrs\tyl, yl, yh, lsl #12\n \tbne\t3f\t\t\t@ y is NAN\n 2:\tmov\tr0, #0\t\t\t@ arguments are ordered.\n-#ifdef __FP_INTERWORKING__\n-\tldr\tlr, [sp], #4\n-\tbx\tlr\n-#elif defined (__APCS_26__)\n-\tldmia\tsp!, {pc}^\n-#else\n-\tldr\tpc, [sp], #4\n-#endif\n+\tRETLDM\n+\n 3:\tmov\tr0, #1\t\t\t@ arguments are unordered.\n-#ifdef __FP_INTERWORKING__\n-\tldr\tlr, [sp], #4\n-\tbx\tlr\n-#elif defined (__APCS_26__)\n-\tldmia\tsp!, {pc}^\n-#else\n-\tldr\tpc, [sp], #4\n-#endif\n+\tRETLDM\n+\n+\tFUNC_END unorddf2\n \n+#endif /* L_unorddf2 */\n+\n+#ifdef L_fixdfsi\n \n ARM_FUNC_START fixdfsi\n \torrs\tip, xl, xh, lsl #1\n \tbeq\t1f\t\t\t@ value is 0.\n \n-\t@ preserve C flag (the actual sign)\n-#ifdef __APCS_26__\n-\tmov\tr3, pc\n-#else\n-\tmrs\tr3, cpsr\n-#endif\n+\tmov\tr3, r3, rrx\t\t@ preserve C flag (the actual sign)\n \n \t@ check exponent range.\n \tmov\tip, #0x7f000000\n@@ -1192,8 +1067,8 @@ ARM_FUNC_START fixdfsi\n \torr\tip, ip, #0x80000000\n \torr\tip, ip, xl, lsr #21\n \tmov\tr2, r2, lsr #20\n+\ttst\tr3, #0x80000000\t\t@ the sign bit\n \tmov\tr0, ip, lsr r2\n-\ttst\tr3, #0x20000000\t\t@ the sign bit\n \trsbne\tr0, r0, #0\n \tRET\n \n@@ -1202,18 +1077,19 @@ ARM_FUNC_START fixdfsi\n \n 2:\torrs\txl, xl, xh, lsl #12\n \tbne\t4f\t\t\t@ r0 is NAN.\n-3:\ttst\tr3, #0x20000000\t\t@ the sign bit\n+3:\tands\tr0, r3, #0x80000000\t@ the sign bit\n \tmoveq\tr0, #0x7fffffff\t\t@ maximum signed positive si\n-\tmovne\tr0, #0x80000000\t\t@ maximum signed negative si\n \tRET\n \n 4:\tmov\tr0, #0\t\t\t@ How should we convert NAN?\n \tRET\n \n+\tFUNC_END fixdfsi\n+\n ARM_FUNC_START fixunsdfsi\n \torrs\tip, xl, xh, lsl #1\n-\tbeq\t1b\t\t\t@ value is 0\n-\tbcs\t1b\t\t\t@ value is negative\n+\tmovcss\tr0, #0\t\t\t@ value is negative\n+\tRETc(eq)\t\t\t@ or 0 (xl, xh overlap r0)\n \n \t@ check exponent range.\n \tmov\tip, #0x7f000000\n@@ -1241,6 +1117,11 @@ ARM_FUNC_START fixunsdfsi\n 2:\tmov\tr0, #0xffffffff\t\t@ maximum unsigned si\n \tRET\n \n+\tFUNC_END fixunsdfsi\n+\n+#endif /* L_fixunsdfdi */\n+\n+#ifdef L_truncdfsf2\n \n ARM_FUNC_START truncdfsf2\n \torrs\tr2, xl, xh, lsl #1\n@@ -1328,4 +1209,6 @@ ARM_FUNC_START truncdfsf2\n \tand\txh, xh, #0x80000000\n \tb\t5b\n \n+\tFUNC_END truncdfsf2\n \n+#endif /* L_truncdfsf2 */"}, {"sha": "904b536f2ffb7307c26469f0f024d5ebc523f43e", "filename": "gcc/config/arm/ieee754-sf.S", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/gcc%2Fconfig%2Farm%2Fieee754-sf.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/gcc%2Fconfig%2Farm%2Fieee754-sf.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fieee754-sf.S?ref=496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "patch": "@@ -38,50 +38,17 @@\n  * if necessary without impacting performances.\n  */\n \n-@ This selects the minimum architecture level required.\n-#undef __ARM_ARCH__\n-#define __ARM_ARCH__ 3\n-\n-#if defined(__ARM_ARCH_3M__) || defined(__ARM_ARCH_4__) \\\n-\t|| defined(__ARM_ARCH_4T__)\n-#undef __ARM_ARCH__\n-/* We use __ARM_ARCH__ set to 4 here, but in reality it's any processor with\n-   long multiply instructions.  That includes v3M.  */\n-#define __ARM_ARCH__ 4\n-#endif\n+#ifdef L_negsf2\n \t\n-#if defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) \\\n-\t|| defined(__ARM_ARCH_5TE__)\n-#undef __ARM_ARCH__\n-#define __ARM_ARCH__ 5\n-#endif\n+ARM_FUNC_START negsf2\n+\teor\tr0, r0, #0x80000000\t@ flip sign bit\n+\tRET\n \n-#if (__ARM_ARCH__ > 4) || defined(__ARM_ARCH_4T__)\n-#undef RET\n-#undef RETc\n-#define RET\tbx\tlr\n-#define RETc(x) bx##x\tlr\n-#if (__ARM_ARCH__ == 4) && (defined(__thumb__) || defined(__THUMB_INTERWORK__))\n-#define __FP_INTERWORKING__\n-#endif\n-#endif\n+\tFUNC_END negsf2\n \n-#if defined(__thumb__) && !defined(__THUMB_INTERWORK__)\n-.macro\tARM_FUNC_START name\n-\tFUNC_START \\name\n-\tbx\tpc\n-\tnop\n-\t.arm\n-.endm\n-#else\n-.macro\tARM_FUNC_START name\n-\tFUNC_START \\name\n-.endm\n #endif\n \n-ARM_FUNC_START negsf2\n-\teor\tr0, r0, #0x80000000\t@ flip sign bit\n-\tRET\n+#ifdef L_addsubsf3\n \n ARM_FUNC_START subsf3\n \teor\tr1, r1, #0x80000000\t@ flip sign bit of second arg\n@@ -291,6 +258,8 @@ LSYM(Lad_i):\n \torrne\tr0, r3, #0x00400000\t@ NAN\n \tRET\n \n+\tFUNC_END addsf3\n+\tFUNC_END subsf3\n \n ARM_FUNC_START floatunsisf\n \tmov\tr3, #0\n@@ -321,6 +290,12 @@ ARM_FUNC_START floatsisf\n \tadd\tr2, r2, #(2 << 23)\n \tb\tLSYM(Lad_p)\n \n+\tFUNC_END floatsisf\n+\tFUNC_END floatunsisf\n+\n+#endif /* L_addsubsf3 */\n+\n+#ifdef L_muldivsf3\n \n ARM_FUNC_START mulsf3\n \n@@ -509,6 +484,7 @@ LSYM(Lml_n):\n \torr\tr0, r0, #0x00c00000\n \tRET\n \n+\tFUNC_END mulsf3\n \n ARM_FUNC_START divsf3\n \n@@ -659,6 +635,11 @@ LSYM(Ldv_s):\n \tbne\tLSYM(Lml_z)\t\t@ 0 / <non_zero> -> 0\n \tb\tLSYM(Lml_n)\t\t@ 0 / 0 -> NAN\n \n+\tFUNC_END divsf3\n+\n+#endif /* L_muldivsf3 */\n+\n+#ifdef L_cmpsf2\n \n FUNC_START gesf2\n ARM_FUNC_START gtsf2\n@@ -723,6 +704,17 @@ ARM_FUNC_START cmpsf2\n 5:\tmov\tr0, r3\t\t\t@ return unordered code from r3.\n \tRET\n \n+\tFUNC_END gesf2\n+\tFUNC_END gtsf2\n+\tFUNC_END lesf2\n+\tFUNC_END ltsf2\n+\tFUNC_END nesf2\n+\tFUNC_END eqsf2\n+\tFUNC_END cmpsf2\n+\n+#endif /* L_cmpsf2 */\n+\n+#ifdef L_unordsf2\n \n ARM_FUNC_START unordsf2\n \tmov\tip, #0xff000000\n@@ -741,16 +733,17 @@ ARM_FUNC_START unordsf2\n 3:\tmov\tr0, #1\t\t\t@ arguments are unordered.\n \tRET\n \n+\tFUNC_END unordsf2\n+\n+#endif /* L_unordsf2 */\n+\n+#ifdef L_fixsfsi\n \n ARM_FUNC_START fixsfsi\n \tmovs\tr0, r0, lsl #1\n \tRETc(eq)\t\t\t@ value is 0.\n-\t@ preserve C flag (the actual sign)\n-#ifdef __APCS_26__\n-\tmov\tr1, pc\n-#else\n-\tmrs\tr1, cpsr\n-#endif\n+\n+\tmov\tr1, r1, rrx\t\t@ preserve C flag (the actual sign)\n \n \t@ check exponent range.\n \tand\tr2, r0, #0xff000000\n@@ -764,29 +757,33 @@ ARM_FUNC_START fixsfsi\n \torr\tr0, r0, #0x80000000\n \tmov\tr2, r2, lsr #24\n \trsb\tr2, r2, #(127 + 31)\n+\ttst\tr1, #0x80000000\t\t@ the sign bit\n \tmov\tr0, r0, lsr r2\n-\ttst\tr1, #0x20000000\t\t@ the sign bit\n \trsbne\tr0, r0, #0\n \tRET\n \n 1:\tteq\tr2, #0xff000000\n \tbne\t2f\n \tmovs\tr0, r0, lsl #8\n \tbne\t3f\t\t\t@ r0 is NAN.\n-2:\ttst\tr1, #0x20000000\t\t@ the sign bit\n+2:\tands\tr0, r1, #0x80000000\t@ the sign bit\n \tmoveq\tr0, #0x7fffffff\t\t@ the maximum signed positive si\n-\tmovne\tr0, #0x80000000\t\t@ the maximum signed negative si\n \tRET\n \n 3:\tmov\tr0, #0\t\t\t@ What should we convert NAN to?\n \tRET\n \n+\tFUNC_END fixsfsi\n+\n+#endif /* L_fixsfsi */\n+\n+#ifdef L_fixunssfsi\n \n ARM_FUNC_START fixunssfsi\n \tmovs\tr0, r0, lsl #1\n-\tRETc(eq)\t\t\t@ value is 0.\n-\tmovcs\tr0, #0\n-\tRETc(cs)\t\t\t@ value is negative.\n+\tmovcss\tr0, #0\t\t\t@ value is negative...\n+\tRETc(eq)\t\t\t@ ... or 0.\n+\n \n \t@ check exponent range.\n \tand\tr2, r0, #0xff000000\n@@ -806,8 +803,13 @@ ARM_FUNC_START fixunssfsi\n 1:\tteq\tr2, #0xff000000\n \tbne\t2f\n \tmovs\tr0, r0, lsl #8\n-\tbne\t3b\t\t\t@ r0 is NAN.\n+\tbne\t3f\t\t\t@ r0 is NAN.\n 2:\tmov\tr0, #0xffffffff\t\t@ maximum unsigned si\n \tRET\n \n+3:\tmov\tr0, #0\t\t\t@ What should we convert NAN to?\n+\tRET\n+\n+\tFUNC_END fixunssfsi\n \n+#endif /* L_fixunssfsi */"}, {"sha": "34cf986d03e8275aa9414ce64d681739d0f580db", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 113, "deletions": 70, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "patch": "@@ -61,66 +61,107 @@ Boston, MA 02111-1307, USA.  */\n \n /* Function end macros.  Variants for 26 bit APCS and interworking.  */\n \n+@ This selects the minimum architecture level required.\n+#define __ARM_ARCH__ 3\n+\n+#if defined(__ARM_ARCH_3M__) || defined(__ARM_ARCH_4__) \\\n+\t|| defined(__ARM_ARCH_4T__)\n+/* We use __ARM_ARCH__ set to 4 here, but in reality it's any processor with\n+   long multiply instructions.  That includes v3M.  */\n+# undef __ARM_ARCH__\n+# define __ARM_ARCH__ 4\n+#endif\n+\t\n+#if defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) \\\n+\t|| defined(__ARM_ARCH_5TE__)\n+# undef __ARM_ARCH__\n+# define __ARM_ARCH__ 5\n+#endif\n+\n+/* How to return from a function call depends on the architecture variant.  */\n+\n #ifdef __APCS_26__\n+\n # define RET\t\tmovs\tpc, lr\n # define RETc(x)\tmov##x##s\tpc, lr\n-# define RETCOND \t^\n+\n+#elif (__ARM_ARCH__ > 4) || defined(__ARM_ARCH_4T__)\n+\n+# define RET\t\tbx\tlr\n+# define RETc(x)\tbx##x\tlr\n+\n+# if (__ARM_ARCH__ == 4) \\\n+\t&& (defined(__thumb__) || defined(__THUMB_INTERWORK__))\n+#  define __INTERWORKING__\n+# endif\n+\n+#else\n+\n+# define RET\t\tmov\tpc, lr\n+# define RETc(x)\tmov##x\tpc, lr\n+\n+#endif\n+\n+/* Don't pass dirn, it's there just to get token pasting right.  */\n+\n+.macro\tRETLDM\tregs=, cond=, dirn=ia\n+#ifdef __APCS_26__\n+\t.ifc \"\\regs\",\"\"\n+\tldm\\cond\\dirn\tsp!, {pc}^\n+\t.else\n+\tldm\\cond\\dirn\tsp!, {\\regs, pc}^\n+\t.endif\n+#elif defined (__INTERWORKING__)\n+\t.ifc \"\\regs\",\"\"\n+\tldr\\cond\tlr, [sp], #4\n+\t.else\n+\tldm\\cond\\dirn\tsp!, {\\regs, lr}\n+\t.endif\n+\tbx\\cond\tlr\n+#else\n+\t.ifc \"\\regs\",\"\"\n+\tldr\\cond\tpc, [sp], #4\n+\t.else\n+\tldm\\cond\\dirn\tsp!, {\\regs, pc}\n+\t.endif\n+#endif\n+.endm\n+\n+\n .macro ARM_LDIV0\n LSYM(Ldiv0):\n \tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0) __PLT__\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n-\tldmia\tsp!, {pc}^\n+\tRETLDM\n .endm\n-#else\n-# ifdef __THUMB_INTERWORK__\n-#  define RET\t\tbx\tlr\n-#  define RETc(x)\tbx##x\tlr\n+\n+\n .macro THUMB_LDIV0\n LSYM(Ldiv0):\n \tpush\t{ lr }\n \tbl\tSYM (__div0)\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n+#if defined (__INTERWORKING__)\n \tpop\t{ r1 }\n \tbx\tr1\n-.endm\n-.macro ARM_LDIV0\n-LSYM(Ldiv0):\n-\tstr\tlr, [sp, #-4]!\n-\tbl\tSYM (__div0) __PLT__\n-\tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n-\tldr\tlr, [sp], #4\n-\tbx\tlr\n-.endm\t\n-# else\n-#  define RET\t\tmov\tpc, lr\n-#  define RETc(x)\tmov##x\tpc, lr\n-.macro THUMB_LDIV0\n-LSYM(Ldiv0):\n-\tpush\t{ lr }\n-\tbl\tSYM (__div0)\n-\tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n+#else\n \tpop\t{ pc }\n-.endm\n-.macro ARM_LDIV0\n-LSYM(Ldiv0):\n-\tstr\tlr, [sp, #-4]!\n-\tbl\tSYM (__div0) __PLT__\n-\tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n-\tldmia\tsp!, {pc}\n-.endm\t\n-# endif\n-# define RETCOND\n #endif\n+.endm\n \n .macro FUNC_END name\n+\tSIZE (__\\name)\n+.endm\n+\n+.macro DIV_FUNC_END name\n LSYM(Ldiv0):\n #ifdef __thumb__\n \tTHUMB_LDIV0\n #else\n \tARM_LDIV0\n #endif\n-\tSIZE (__\\name)\t\n+\tFUNC_END \\name\n .endm\n \n .macro THUMB_FUNC_START name\n@@ -149,7 +190,24 @@ SYM (\\name):\n \tTHUMB_FUNC\n SYM (__\\name):\n .endm\n-\t\t\n+\n+/* Special function that will always be coded in ARM assembly, even if\n+   in Thumb-only compilation.  */\n+\n+#if defined(__thumb__) && !defined(__THUMB_INTERWORK__)\n+.macro\tARM_FUNC_START name\n+\tFUNC_START \\name\n+\tbx\tpc\n+\tnop\n+\t.arm\n+_L__\\name:\t\t/* A hook to tell gdb that we've switched to ARM */\n+.endm\n+#else\n+.macro\tARM_FUNC_START name\n+\tFUNC_START \\name\n+.endm\n+#endif\n+\n /* Register aliases.  */\n \n work\t\t.req\tr4\t@ XXXX is this safe ?\n@@ -452,7 +510,7 @@ LSYM(Lgot_result):\n \n #endif /* ARM version */\n \n-\tFUNC_END udivsi3\n+\tDIV_FUNC_END udivsi3\n \n #endif /* L_udivsi3 */\n /* ------------------------------------------------------------------------ */\n@@ -493,7 +551,7 @@ LSYM(Lover10):\n \n #endif /* ARM version.  */\n \t\n-\tFUNC_END umodsi3\n+\tDIV_FUNC_END umodsi3\n \n #endif /* L_umodsi3 */\n /* ------------------------------------------------------------------------ */\n@@ -555,7 +613,7 @@ LSYM(Lover12):\n \n #endif /* ARM version */\n \t\n-\tFUNC_END divsi3\n+\tDIV_FUNC_END divsi3\n \n #endif /* L_divsi3 */\n /* ------------------------------------------------------------------------ */\n@@ -616,7 +674,7 @@ LSYM(Lover12):\n \n #endif /* ARM version */\n \t\n-\tFUNC_END modsi3\n+\tDIV_FUNC_END modsi3\n \n #endif /* L_modsi3 */\n /* ------------------------------------------------------------------------ */\n@@ -626,7 +684,7 @@ LSYM(Lover12):\n \n \tRET\n \n-\tSIZE\t(__div0)\n+\tFUNC_END div0\n \t\n #endif /* L_divmodsi_tools */\n /* ------------------------------------------------------------------------ */\n@@ -639,22 +697,18 @@ LSYM(Lover12):\n #define __NR_getpid\t\t\t(__NR_SYSCALL_BASE+ 20)\n #define __NR_kill\t\t\t(__NR_SYSCALL_BASE+ 37)\n \n+\t.code\t32\n \tFUNC_START div0\n \n \tstmfd\tsp!, {r1, lr}\n \tswi\t__NR_getpid\n \tcmn\tr0, #1000\n-\tldmhsfd\tsp!, {r1, pc}RETCOND\t@ not much we can do\n+\tRETLDM\tr1 hs\n \tmov\tr1, #SIGFPE\n \tswi\t__NR_kill\n-#ifdef __THUMB_INTERWORK__\n-\tldmfd\tsp!, {r1, lr}\n-\tbx\tlr\n-#else\n-\tldmfd\tsp!, {r1, pc}RETCOND\n-#endif\n+\tRETLDM\tr1\n \n-\tSIZE \t(__div0)\n+\tFUNC_END div0\n \t\n #endif /* L_dvmd_lnx */\n /* ------------------------------------------------------------------------ */\n@@ -723,24 +777,23 @@ LSYM(Lover12):\n \n \t.code   32\n \t.globl _arm_return\n-_arm_return:\t\t\n-\tldmia \tr13!, {r12}\n-\tbx \tr12\n+_arm_return:\n+\tRETLDM\n \t.code   16\n \n-.macro interwork register\t\t\t\t\t\n-\t.code   16\n+.macro interwork register\n+\t.code\t16\n \n \tTHUMB_FUNC_START _interwork_call_via_\\register\n \n-\tbx \tpc\n+\tbx\tpc\n \tnop\n-\t\n-\t.code   32\n-\t.globl .Lchange_\\register\n-.Lchange_\\register:\n+\n+\t.code\t32\n+\t.globl LSYM(Lchange_\\register)\n+LSYM(Lchange_\\register):\n \ttst\t\\register, #1\n-\tstmeqdb\tr13!, {lr}\n+\tstreq\tlr, [sp, #-4]!\n \tadreq\tlr, _arm_return\n \tbx\t\\register\n \n@@ -783,16 +836,6 @@ _arm_return:\n \t\n #endif /* L_interwork_call_via_rX */\n \n-#ifdef L_ieee754_dp\n-\t/* These functions are coded in ARM state, even when called from\n-\t   Thumb.  */\n-\t.arm\n #include \"ieee754-df.S\"\n-#endif\n-\n-#ifdef L_ieee754_sp\n-\t/* These functions are coded in ARM state, even when called from\n-\t   Thumb.  */\n-\t.arm\n #include \"ieee754-sf.S\"\n-#endif\n+"}, {"sha": "1b8f719b94948df4a2b1083e74389a863d8c909b", "filename": "gcc/config/arm/t-arm-elf", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/gcc%2Fconfig%2Farm%2Ft-arm-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13/gcc%2Fconfig%2Farm%2Ft-arm-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-elf?ref=496b84c8edb6289c1e9e24c8c69ae2f63d1bcd13", "patch": "@@ -1,5 +1,9 @@\n LIB1ASMSRC = arm/lib1funcs.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func _call_via_rX _interwork_call_via_rX _ieee754_dp _ieee754_sp\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func \\\n+\t_call_via_rX _interwork_call_via_rX \\\n+\t_negdf2 _addsubdf3 _muldivdf3 _cmpdf2 _unorddf2 _fixdfsi \\\n+\t_truncdfsf2 _negsf2 _addsubsf3 _muldivsf3 _cmpsf2 _unordsf2 \\\n+\t_fixsfsi _fixunssfsi\n \n MULTILIB_OPTIONS     = marm/mthumb\n MULTILIB_DIRNAMES    = arm thumb"}]}