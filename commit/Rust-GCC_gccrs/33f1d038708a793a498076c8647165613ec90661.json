{"sha": "33f1d038708a793a498076c8647165613ec90661", "node_id": "C_kwDOANBUbNoAKDMzZjFkMDM4NzA4YTc5M2E0OTgwNzZjODY0NzE2NTYxM2VjOTA2NjE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-27T11:14:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-05T08:03:11Z"}, "message": "First refactor of vect_analyze_loop\n\nThis refactors the main loop analysis part in vect_analyze_loop,\nre-purposing the existing vect_reanalyze_as_main_loop for this\nto reduce code duplication.  Failure flow is a bit tricky since\nwe want to extract info from the analyzed loop but I wanted to\nshare the destruction part.  Thus I add some std::function and\nlambda to funnel post-analysis for the case we want that\n(when analyzing from the main iteration but not when re-analyzing\nan epilogue as main).\n\nIn addition I split vect_analyze_loop_form into analysis and\nvinfo creation so we can do the analysis only once, simplifying\nthe new vect_analyze_loop_1.\n\nAs discussed we probably want to change the loop over vector\nmodes to first only analyze things as the main loop, picking\nthe best (or simd VF) mode for the main loop and then analyze\nfor a vectorized epilogue.  The unroll would then integrate\nwith the main loop vectorization.  I think that currently\nwe may fail to analyze the epilogue with the same mode as\nthe main loop when using partial vectors since we increment\nmode_i before doing that.\n\n2021-11-04  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (struct vect_loop_form_info): New.\n\t(vect_analyze_loop_form): Adjust.\n\t(vect_create_loop_vinfo): New.\n\t* tree-parloops.c (gather_scalar_reductions): Adjust for\n\tvect_analyze_loop_form API change.\n\t* tree-vect-loop.c: Include <functional>.\n\t(vect_analyze_loop_form_1): Rename to vect_analyze_loop_form,\n\ttake struct vect_loop_form_info as output parameter and adjust.\n\t(vect_analyze_loop_form): Rename to vect_create_loop_vinfo and\n\tsplit out call to the original vect_analyze_loop_form_1.\n\t(vect_reanalyze_as_main_loop): Rename to...\n\t(vect_analyze_loop_1): ... this, factor out the call to\n\tvect_analyze_loop_form and generalize to be able to use it twice ...\n\t(vect_analyze_loop): ... here.  Perform vect_analyze_loop_form\n\tonce only and here.", "tree": {"sha": "c6936eac2ebbcf5ab579621361d4aa61be8b6dee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6936eac2ebbcf5ab579621361d4aa61be8b6dee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33f1d038708a793a498076c8647165613ec90661", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f1d038708a793a498076c8647165613ec90661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33f1d038708a793a498076c8647165613ec90661", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f1d038708a793a498076c8647165613ec90661/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "614b39757b8b61f70ac1c666edb7a01a5fc19cd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/614b39757b8b61f70ac1c666edb7a01a5fc19cd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/614b39757b8b61f70ac1c666edb7a01a5fc19cd4"}], "stats": {"total": 314, "additions": 160, "deletions": 154}, "files": [{"sha": "96932c70336ddb912b7192c4e9f262c9cad5c386", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f1d038708a793a498076c8647165613ec90661/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f1d038708a793a498076c8647165613ec90661/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=33f1d038708a793a498076c8647165613ec90661", "patch": "@@ -3298,10 +3298,11 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n   auto_vec<gimple *, 4> double_reduc_stmts;\n \n   vec_info_shared shared;\n-  simple_loop_info = vect_analyze_loop_form (loop, &shared);\n-  if (simple_loop_info == NULL)\n+  vect_loop_form_info info;\n+  if (!vect_analyze_loop_form (loop, &info))\n     goto gather_done;\n \n+  simple_loop_info = vect_create_loop_vinfo (loop, &shared, &info);\n   for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gphi *phi = gsi.phi ();\n@@ -3339,9 +3340,11 @@ gather_scalar_reductions (loop_p loop, reduction_info_table_type *reduction_list\n   if (!double_reduc_phis.is_empty ())\n     {\n       vec_info_shared shared;\n-      simple_loop_info = vect_analyze_loop_form (loop->inner, &shared);\n-      if (simple_loop_info)\n+      vect_loop_form_info info;\n+      if (vect_analyze_loop_form (loop->inner, &info))\n \t{\n+\t  simple_loop_info\n+\t    = vect_create_loop_vinfo (loop->inner, &shared, &info);\n \t  gphi *phi;\n \t  unsigned int i;\n "}, {"sha": "13a53436729a46c401fc5d04b1ace6f9bf5119a4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 142, "deletions": 148, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f1d038708a793a498076c8647165613ec90661/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f1d038708a793a498076c8647165613ec90661/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=33f1d038708a793a498076c8647165613ec90661", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #define INCLUDE_ALGORITHM\n+#define INCLUDE_FUNCTIONAL\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -1309,7 +1310,7 @@ vect_compute_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n }\n \n \n-/* Function vect_analyze_loop_form_1.\n+/* Function vect_analyze_loop_form.\n \n    Verify that certain CFG restrictions hold, including:\n    - the loop has a pre-header\n@@ -1319,16 +1320,15 @@ vect_compute_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n      niter could be analyzed under some assumptions.  */\n \n opt_result\n-vect_analyze_loop_form_1 (class loop *loop, gcond **loop_cond,\n-\t\t\t  tree *assumptions, tree *number_of_iterationsm1,\n-\t\t\t  tree *number_of_iterations, gcond **inner_loop_cond)\n+vect_analyze_loop_form (class loop *loop, vect_loop_form_info *info)\n {\n   DUMP_VECT_SCOPE (\"vect_analyze_loop_form\");\n \n   /* Different restrictions apply when we are considering an inner-most loop,\n      vs. an outer (nested) loop.\n      (FORNOW. May want to relax some of these restrictions in the future).  */\n \n+  info->inner_loop_cond = NULL;\n   if (!loop->inner)\n     {\n       /* Inner-most loop.  We currently require that the number of BBs is\n@@ -1393,11 +1393,8 @@ vect_analyze_loop_form_1 (class loop *loop, gcond **loop_cond,\n \t\t\t\t       \" unsupported outerloop form.\\n\");\n \n       /* Analyze the inner-loop.  */\n-      tree inner_niterm1, inner_niter, inner_assumptions;\n-      opt_result res\n-\t= vect_analyze_loop_form_1 (loop->inner, inner_loop_cond,\n-\t\t\t\t    &inner_assumptions, &inner_niterm1,\n-\t\t\t\t    &inner_niter, NULL);\n+      vect_loop_form_info inner;\n+      opt_result res = vect_analyze_loop_form (loop->inner, &inner);\n       if (!res)\n \t{\n \t  if (dump_enabled_p ())\n@@ -1408,18 +1405,19 @@ vect_analyze_loop_form_1 (class loop *loop, gcond **loop_cond,\n \n       /* Don't support analyzing niter under assumptions for inner\n \t loop.  */\n-      if (!integer_onep (inner_assumptions))\n+      if (!integer_onep (inner.assumptions))\n \treturn opt_result::failure_at (vect_location,\n \t\t\t\t       \"not vectorized: Bad inner loop.\\n\");\n \n-      if (!expr_invariant_in_loop_p (loop, inner_niter))\n+      if (!expr_invariant_in_loop_p (loop, inner.number_of_iterations))\n \treturn opt_result::failure_at (vect_location,\n \t\t\t\t       \"not vectorized: inner-loop count not\"\n \t\t\t\t       \" invariant.\\n\");\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"Considering outer-loop vectorization.\\n\");\n+      info->inner_loop_cond = inner.loop_cond;\n     }\n \n   if (!single_exit (loop))\n@@ -1446,48 +1444,42 @@ vect_analyze_loop_form_1 (class loop *loop, gcond **loop_cond,\n \t\t\t\t   \"not vectorized:\"\n \t\t\t\t   \" abnormal loop exit edge.\\n\");\n \n-  *loop_cond = vect_get_loop_niters (loop, assumptions, number_of_iterations,\n-\t\t\t\t     number_of_iterationsm1);\n-  if (!*loop_cond)\n+  info->loop_cond\n+    = vect_get_loop_niters (loop, &info->assumptions,\n+\t\t\t    &info->number_of_iterations,\n+\t\t\t    &info->number_of_iterationsm1);\n+  if (!info->loop_cond)\n     return opt_result::failure_at\n       (vect_location,\n        \"not vectorized: complicated exit condition.\\n\");\n \n-  if (integer_zerop (*assumptions)\n-      || !*number_of_iterations\n-      || chrec_contains_undetermined (*number_of_iterations))\n+  if (integer_zerop (info->assumptions)\n+      || !info->number_of_iterations\n+      || chrec_contains_undetermined (info->number_of_iterations))\n     return opt_result::failure_at\n-      (*loop_cond,\n+      (info->loop_cond,\n        \"not vectorized: number of iterations cannot be computed.\\n\");\n \n-  if (integer_zerop (*number_of_iterations))\n+  if (integer_zerop (info->number_of_iterations))\n     return opt_result::failure_at\n-      (*loop_cond,\n+      (info->loop_cond,\n        \"not vectorized: number of iterations = 0.\\n\");\n \n   return opt_result::success ();\n }\n \n-/* Analyze LOOP form and return a loop_vec_info if it is of suitable form.  */\n+/* Create a loop_vec_info for LOOP with SHARED and the\n+   vect_analyze_loop_form result.  */\n \n-opt_loop_vec_info\n-vect_analyze_loop_form (class loop *loop, vec_info_shared *shared)\n+loop_vec_info\n+vect_create_loop_vinfo (class loop *loop, vec_info_shared *shared,\n+\t\t\tconst vect_loop_form_info *info)\n {\n-  tree assumptions, number_of_iterations, number_of_iterationsm1;\n-  gcond *loop_cond, *inner_loop_cond = NULL;\n-\n-  opt_result res\n-    = vect_analyze_loop_form_1 (loop, &loop_cond,\n-\t\t\t\t&assumptions, &number_of_iterationsm1,\n-\t\t\t\t&number_of_iterations, &inner_loop_cond);\n-  if (!res)\n-    return opt_loop_vec_info::propagate_failure (res);\n-\n   loop_vec_info loop_vinfo = new _loop_vec_info (loop, shared);\n-  LOOP_VINFO_NITERSM1 (loop_vinfo) = number_of_iterationsm1;\n-  LOOP_VINFO_NITERS (loop_vinfo) = number_of_iterations;\n-  LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = number_of_iterations;\n-  if (!integer_onep (assumptions))\n+  LOOP_VINFO_NITERSM1 (loop_vinfo) = info->number_of_iterationsm1;\n+  LOOP_VINFO_NITERS (loop_vinfo) = info->number_of_iterations;\n+  LOOP_VINFO_NITERS_UNCHANGED (loop_vinfo) = info->number_of_iterations;\n+  if (!integer_onep (info->assumptions))\n     {\n       /* We consider to vectorize this loop by versioning it under\n \t some assumptions.  In order to do this, we need to clear\n@@ -1498,7 +1490,7 @@ vect_analyze_loop_form (class loop *loop, vec_info_shared *shared)\n \t analysis are done under the assumptions.  */\n       loop_constraint_set (loop, LOOP_C_FINITE);\n       /* Also record the assumptions for versioning.  */\n-      LOOP_VINFO_NITERS_ASSUMPTIONS (loop_vinfo) = assumptions;\n+      LOOP_VINFO_NITERS_ASSUMPTIONS (loop_vinfo) = info->assumptions;\n     }\n \n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n@@ -1507,17 +1499,17 @@ vect_analyze_loop_form (class loop *loop, vec_info_shared *shared)\n         {\n           dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"Symbolic number of iterations is \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_DETAILS, number_of_iterations);\n+\t  dump_generic_expr (MSG_NOTE, TDF_DETAILS, info->number_of_iterations);\n           dump_printf (MSG_NOTE, \"\\n\");\n         }\n     }\n \n-  stmt_vec_info loop_cond_info = loop_vinfo->lookup_stmt (loop_cond);\n+  stmt_vec_info loop_cond_info = loop_vinfo->lookup_stmt (info->loop_cond);\n   STMT_VINFO_TYPE (loop_cond_info) = loop_exit_ctrl_vec_info_type;\n-  if (inner_loop_cond)\n+  if (info->inner_loop_cond)\n     {\n       stmt_vec_info inner_loop_cond_info\n-\t= loop_vinfo->lookup_stmt (inner_loop_cond);\n+\t= loop_vinfo->lookup_stmt (info->inner_loop_cond);\n       STMT_VINFO_TYPE (inner_loop_cond_info) = loop_exit_ctrl_vec_info_type;\n       /* If we have an estimate on the number of iterations of the inner\n \t loop use that to limit the scale for costing, otherwise use\n@@ -1530,7 +1522,7 @@ vect_analyze_loop_form (class loop *loop, vec_info_shared *shared)\n \n   gcc_assert (!loop->aux);\n   loop->aux = loop_vinfo;\n-  return opt_loop_vec_info::success (loop_vinfo);\n+  return loop_vinfo;\n }\n \n \n@@ -2899,43 +2891,57 @@ vect_joust_loop_vinfos (loop_vec_info new_loop_vinfo,\n   return true;\n }\n \n-/* If LOOP_VINFO is already a main loop, return it unmodified.  Otherwise\n-   try to reanalyze it as a main loop.  Return the loop_vinfo on success\n-   and null on failure.  */\n-\n-static loop_vec_info\n-vect_reanalyze_as_main_loop (loop_vec_info loop_vinfo, unsigned int *n_stmts)\n+/* Analyze LOOP with VECTOR_MODE and as epilogue if MAIN_LOOP_VINFO is\n+   not NULL.  Process the analyzed loop with PROCESS even if analysis\n+   failed.  Sets *N_STMTS and FATAL according to the analysis.\n+   Return the loop_vinfo on success and wrapped null on failure.  */\n+\n+static opt_loop_vec_info\n+vect_analyze_loop_1 (class loop *loop, vec_info_shared *shared,\n+\t\t     const vect_loop_form_info *loop_form_info,\n+\t\t     machine_mode vector_mode, loop_vec_info main_loop_vinfo,\n+\t\t     unsigned int *n_stmts, bool &fatal,\n+\t\t     std::function<void(loop_vec_info)> process = nullptr)\n {\n-  if (!LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n-    return loop_vinfo;\n+  loop_vec_info loop_vinfo\n+    = vect_create_loop_vinfo (loop, shared, loop_form_info);\n+  loop_vinfo->vector_mode = vector_mode;\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"***** Reanalyzing as a main loop with vector mode %s\\n\",\n-\t\t     GET_MODE_NAME (loop_vinfo->vector_mode));\n+  if (main_loop_vinfo)\n+    LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = main_loop_vinfo;\n \n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  vec_info_shared *shared = loop_vinfo->shared;\n-  opt_loop_vec_info main_loop_vinfo = vect_analyze_loop_form (loop, shared);\n-  gcc_assert (main_loop_vinfo);\n+  /* Run the main analysis.  */\n+  fatal = false;\n+  opt_result res = vect_analyze_loop_2 (loop_vinfo, fatal, n_stmts);\n+  loop->aux = NULL;\n \n-  main_loop_vinfo->vector_mode = loop_vinfo->vector_mode;\n+  /* Process info before we destroy loop_vinfo upon analysis failure\n+     when there was no fatal failure.  */\n+  if (!fatal && process)\n+    process (loop_vinfo);\n \n-  bool fatal = false;\n-  bool res = vect_analyze_loop_2 (main_loop_vinfo, fatal, n_stmts);\n-  loop->aux = NULL;\n-  if (!res)\n+  if (dump_enabled_p ())\n     {\n-      if (dump_enabled_p ())\n+      if (res)\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"***** Failed to analyze main loop with vector\"\n-\t\t\t \" mode %s\\n\",\n+\t\t\t \"***** Analysis succeeded with vector mode %s\\n\",\n+\t\t\t GET_MODE_NAME (loop_vinfo->vector_mode));\n+      else\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"***** Analysis failed with vector mode %s\\n\",\n \t\t\t GET_MODE_NAME (loop_vinfo->vector_mode));\n-      delete main_loop_vinfo;\n-      return NULL;\n     }\n-  LOOP_VINFO_VECTORIZABLE_P (main_loop_vinfo) = 1;\n-  return main_loop_vinfo;\n+\n+  if (!res)\n+    {\n+      delete loop_vinfo;\n+      if (fatal)\n+\tgcc_checking_assert (main_loop_vinfo == NULL);\n+      return opt_loop_vec_info::propagate_failure (res);\n+    }\n+\n+  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n+  return opt_loop_vec_info::success (loop_vinfo);\n }\n \n /* Function vect_analyze_loop.\n@@ -2968,34 +2974,29 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n        \"not vectorized: loop nest containing two or more consecutive inner\"\n        \" loops cannot be vectorized\\n\");\n \n+  /* Analyze the loop form.  */\n+  vect_loop_form_info loop_form_info;\n+  opt_result res = vect_analyze_loop_form (loop, &loop_form_info);\n+  if (!res)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"bad loop form.\\n\");\n+      return opt_loop_vec_info::propagate_failure (res);\n+    }\n+\n   unsigned n_stmts = 0;\n   machine_mode autodetected_vector_mode = VOIDmode;\n   opt_loop_vec_info first_loop_vinfo = opt_loop_vec_info::success (NULL);\n   machine_mode next_vector_mode = VOIDmode;\n   poly_uint64 lowest_th = 0;\n-  unsigned vectorized_loops = 0;\n   bool pick_lowest_cost_p = ((autovec_flags & VECT_COMPARE_COSTS)\n \t\t\t     && !unlimited_cost_model (loop));\n \n   bool vect_epilogues = false;\n-  opt_result res = opt_result::success ();\n   unsigned HOST_WIDE_INT simdlen = loop->simdlen;\n   while (1)\n     {\n-      /* Check the CFG characteristics of the loop (nesting, entry/exit).  */\n-      opt_loop_vec_info loop_vinfo = vect_analyze_loop_form (loop, shared);\n-      if (!loop_vinfo)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"bad loop form.\\n\");\n-\t  gcc_checking_assert (first_loop_vinfo == NULL);\n-\t  return loop_vinfo;\n-\t}\n-      loop_vinfo->vector_mode = next_vector_mode;\n-\n-      bool fatal = false;\n-\n       /* When pick_lowest_cost_p is true, we should in principle iterate\n \t over all the loop_vec_infos that LOOP_VINFO could replace and\n \t try to vectorize LOOP_VINFO under the same conditions.\n@@ -3024,43 +3025,35 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t LOOP_VINFO fails when treated as an epilogue loop, succeeds when\n \t treated as a standalone loop, and ends up being genuinely cheaper\n \t than FIRST_LOOP_VINFO.  */\n-      if (vect_epilogues)\n-\tLOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo) = first_loop_vinfo;\n \n-      res = vect_analyze_loop_2 (loop_vinfo, fatal, &n_stmts);\n-      if (mode_i == 0)\n-\tautodetected_vector_mode = loop_vinfo->vector_mode;\n-      if (dump_enabled_p ())\n+      bool fatal;\n+      auto cb = [&] (loop_vec_info loop_vinfo)\n \t{\n-\t  if (res)\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"***** Analysis succeeded with vector mode %s\\n\",\n-\t\t\t     GET_MODE_NAME (loop_vinfo->vector_mode));\n-\t  else\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"***** Analysis failed with vector mode %s\\n\",\n-\t\t\t     GET_MODE_NAME (loop_vinfo->vector_mode));\n-\t}\n-\n-      loop->aux = NULL;\n-\n-      if (!fatal)\n-\twhile (mode_i < vector_modes.length ()\n-\t       && vect_chooses_same_modes_p (loop_vinfo, vector_modes[mode_i]))\n-\t  {\n-\t    if (dump_enabled_p ())\n-\t      dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t       \"***** The result for vector mode %s would\"\n-\t\t\t       \" be the same\\n\",\n-\t\t\t       GET_MODE_NAME (vector_modes[mode_i]));\n-\t    mode_i += 1;\n-\t  }\n+\t  if (mode_i == 0)\n+\t    autodetected_vector_mode = loop_vinfo->vector_mode;\n+\t  while (mode_i < vector_modes.length ()\n+\t\t && vect_chooses_same_modes_p (loop_vinfo,\n+\t\t\t\t\t       vector_modes[mode_i]))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t \"***** The result for vector mode %s would\"\n+\t\t\t\t \" be the same\\n\",\n+\t\t\t\t GET_MODE_NAME (vector_modes[mode_i]));\n+\t      mode_i += 1;\n+\t    }\n+\t};\n+      opt_loop_vec_info loop_vinfo\n+\t= vect_analyze_loop_1 (loop, shared, &loop_form_info,\n+\t\t\t       next_vector_mode,\n+\t\t\t       vect_epilogues\n+\t\t\t       ? (loop_vec_info)first_loop_vinfo : NULL,\n+\t\t\t       &n_stmts, fatal, cb);\n+      if (fatal)\n+\tbreak;\n \n-      if (res)\n+      if (loop_vinfo)\n \t{\n-\t  LOOP_VINFO_VECTORIZABLE_P (loop_vinfo) = 1;\n-\t  vectorized_loops++;\n-\n \t  /* Once we hit the desired simdlen for the first time,\n \t     discard any previous attempts.  */\n \t  if (simdlen\n@@ -3085,33 +3078,44 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t      if (vinfos.is_empty ()\n \t\t  && vect_joust_loop_vinfos (loop_vinfo, first_loop_vinfo))\n \t\t{\n-\t\t  loop_vec_info main_loop_vinfo\n-\t\t    = vect_reanalyze_as_main_loop (loop_vinfo, &n_stmts);\n-\t\t  if (main_loop_vinfo == loop_vinfo)\n+\t\t  if (!LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n \t\t    {\n \t\t      delete first_loop_vinfo;\n \t\t      first_loop_vinfo = opt_loop_vec_info::success (NULL);\n \t\t    }\n-\t\t  else if (main_loop_vinfo\n-\t\t\t   && vect_joust_loop_vinfos (main_loop_vinfo,\n-\t\t\t\t\t\t      first_loop_vinfo))\n-\t\t    {\n-\t\t      delete first_loop_vinfo;\n-\t\t      first_loop_vinfo = opt_loop_vec_info::success (NULL);\n-\t\t      delete loop_vinfo;\n-\t\t      loop_vinfo\n-\t\t\t= opt_loop_vec_info::success (main_loop_vinfo);\n-\t\t    }\n \t\t  else\n \t\t    {\n \t\t      if (dump_enabled_p ())\n \t\t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t\t \"***** No longer preferring vector\"\n-\t\t\t\t\t \" mode %s after reanalyzing the loop\"\n-\t\t\t\t\t \" as a main loop\\n\",\n+\t\t\t\t\t \"***** Reanalyzing as a main loop \"\n+\t\t\t\t\t \"with vector mode %s\\n\",\n \t\t\t\t\t GET_MODE_NAME\n-\t\t\t\t\t   (main_loop_vinfo->vector_mode));\n-\t\t      delete main_loop_vinfo;\n+\t\t\t\t\t   (loop_vinfo->vector_mode));\n+\t\t      opt_loop_vec_info main_loop_vinfo\n+\t\t\t= vect_analyze_loop_1 (loop, shared, &loop_form_info,\n+\t\t\t\t\t       loop_vinfo->vector_mode,\n+\t\t\t\t\t       NULL, &n_stmts, fatal);\n+\t\t      if (main_loop_vinfo\n+\t\t\t  && vect_joust_loop_vinfos (main_loop_vinfo,\n+\t\t\t\t\t\t     first_loop_vinfo))\n+\t\t\t{\n+\t\t\t  delete first_loop_vinfo;\n+\t\t\t  first_loop_vinfo = opt_loop_vec_info::success (NULL);\n+\t\t\t  delete loop_vinfo;\n+\t\t\t  loop_vinfo\n+\t\t\t    = opt_loop_vec_info::success (main_loop_vinfo);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  if (dump_enabled_p ())\n+\t\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t\t\t     \"***** No longer preferring vector\"\n+\t\t\t\t\t     \" mode %s after reanalyzing the \"\n+\t\t\t\t\t     \" loop as a main loop\\n\",\n+\t\t\t\t\t     GET_MODE_NAME\n+\t\t\t\t\t       (loop_vinfo->vector_mode));\n+\t\t\t  delete main_loop_vinfo;\n+\t\t\t}\n \t\t    }\n \t\t}\n \t    }\n@@ -3160,16 +3164,6 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t  if (!simdlen && !vect_epilogues && !pick_lowest_cost_p)\n \t    break;\n \t}\n-      else\n-\t{\n-\t  delete loop_vinfo;\n-\t  loop_vinfo = opt_loop_vec_info::success (NULL);\n-\t  if (fatal)\n-\t    {\n-\t      gcc_checking_assert (first_loop_vinfo == NULL);\n-\t      break;\n-\t    }\n-\t}\n \n       /* Handle the case that the original loop can use partial\n \t vectorization, but want to only adopt it for the epilogue."}, {"sha": "3f069e712963e34a9aa8db15fca2ceb868641f30", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33f1d038708a793a498076c8647165613ec90661/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33f1d038708a793a498076c8647165613ec90661/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=33f1d038708a793a498076c8647165613ec90661", "patch": "@@ -2152,8 +2152,17 @@ extern bool reduction_fn_for_scalar_code (enum tree_code, internal_fn *);\n \n /* Drive for loop transformation stage.  */\n extern class loop *vect_transform_loop (loop_vec_info, gimple *);\n-extern opt_loop_vec_info vect_analyze_loop_form (class loop *,\n-\t\t\t\t\t\t vec_info_shared *);\n+struct vect_loop_form_info\n+{\n+  tree number_of_iterations;\n+  tree number_of_iterationsm1;\n+  tree assumptions;\n+  gcond *loop_cond;\n+  gcond *inner_loop_cond;\n+};\n+extern opt_result vect_analyze_loop_form (class loop *, vect_loop_form_info *);\n+extern loop_vec_info vect_create_loop_vinfo (class loop *, vec_info_shared *,\n+\t\t\t\t\t     const vect_loop_form_info *);\n extern bool vectorizable_live_operation (vec_info *,\n \t\t\t\t\t stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t\t slp_tree, slp_instance, int,"}]}