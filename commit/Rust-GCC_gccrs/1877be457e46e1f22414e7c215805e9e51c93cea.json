{"sha": "1877be457e46e1f22414e7c215805e9e51c93cea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg3N2JlNDU3ZTQ2ZTFmMjI0MTRlN2MyMTU4MDVlOWU1MWM5M2NlYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-10-15T08:24:36Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-10-15T08:24:36Z"}, "message": "re PR c/7344 (performance regression on huge case statements)\n\n\t* i386.md (movv2di_internal): New pattern.\n\t(movv2df_internal, movv8hi_internal, movv16qi_internal): Fix predicate.\n\t(movv2di): New expander.\n\t* i386.c (ix86_preferred_reload_class): Return NO_REGS for vector operands.\n\n\t* i386.c (ix86_expand_timode_binop_builtin): Delete.\n\t(builtin_description): Add SSE1 logicals; rename SSE2 logicals.\n\t(ix86_init_mmx_sse_builtins): Kill SSE1 logicals.\n\t(ix86_expand_builtin): Likewise.\n\t* i386.h (sse_andti4_df_1, sse_andti3_df_2, sse_andti3_sf_1, sse_andti3_sf_2,\n        sse_andti3,\n\tsse_andnti4_df_1, sse_andti3_df_2, sse_andti3_sf_1, sse_andti3_sf_2,\n        sse_andnti3,\n\tsse_orti4_df_1, sse_orti3_df_2, sse_orti3_sf_1, sse_orti3_sf_2,\n        sse_orti3,\n\tsse_xorti4_df_1, sse_xorti3_df_2, sse_xorti3_sf_1, sse_xorti3_sf_2,\n        sse_xorti3): Kill.\n\t(sse_andv4sf3, sse_andnv4sf3, sse_orv2df3, sse_xorv2df3, sse_andv2df3,\n\t sse_andnv2df3, sse_orv2df3, sse_xorv2df3): New expanders.\n\t(*sse_andv4sf3, *sse_andnv2df3, *sse_orv4sf3, *sse_xorv4sf3, *sse_andv2df3,\n\t *sse_andnv2df3, *sse_orv2df3, *sse_xorv2df3): New patterns.\n\t(*sse_andsf3, *sse_andndf3, *sse_ordf3, *sse_xordf3, *sse_anddf3,\n\t *sse_andndf3, *sse_orv2df3, *sse_xorv2df3): New patterns.\n\n\t* xmmintrin.h (__m128i): Define as __v2di.\n\n\tPR c/7344\n\t* predict.c (can_predict_insn_p): New function.\n\t(estimate_probability): Avoid unnecesary work.\n\t(process_note_prediction): Likewise.\n\t* toplev.c (rest_of_compilation): Account early branch prediction pass\n\tas TV_BRANCH_PROB.\n\n\tPR c++/6419\n\t(expand_expr): Use DECL_RTL_SET_P.\n\nFrom-SVN: r58156", "tree": {"sha": "2926a21bf98ecf1245514d8ae40ece750b02bc54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2926a21bf98ecf1245514d8ae40ece750b02bc54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1877be457e46e1f22414e7c215805e9e51c93cea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1877be457e46e1f22414e7c215805e9e51c93cea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1877be457e46e1f22414e7c215805e9e51c93cea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1877be457e46e1f22414e7c215805e9e51c93cea/comments", "author": null, "committer": null, "parents": [{"sha": "0aab899b147fdb4d232e55bb9307777d07f7ebe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aab899b147fdb4d232e55bb9307777d07f7ebe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aab899b147fdb4d232e55bb9307777d07f7ebe4"}], "stats": {"total": 724, "additions": 475, "deletions": 249}, "files": [{"sha": "d0450180844549c2fd0c6494587f62edbb7943be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -1,3 +1,41 @@\n+Mon Oct 14 20:33:12 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (movv2di_internal): New pattern.\n+\t(movv2df_internal, movv8hi_internal, movv16qi_internal): Fix predicate.\n+\t(movv2di): New expander.\n+\t* i386.c (ix86_preferred_reload_class): Return NO_REGS for vector operands.\n+\n+\t* i386.c (ix86_expand_timode_binop_builtin): Delete.\n+\t(builtin_description): Add SSE1 logicals; rename SSE2 logicals.\n+\t(ix86_init_mmx_sse_builtins): Kill SSE1 logicals.\n+\t(ix86_expand_builtin): Likewise.\n+\t* i386.h (sse_andti4_df_1, sse_andti3_df_2, sse_andti3_sf_1, sse_andti3_sf_2,\n+        sse_andti3,\n+\tsse_andnti4_df_1, sse_andti3_df_2, sse_andti3_sf_1, sse_andti3_sf_2,\n+        sse_andnti3,\n+\tsse_orti4_df_1, sse_orti3_df_2, sse_orti3_sf_1, sse_orti3_sf_2,\n+        sse_orti3,\n+\tsse_xorti4_df_1, sse_xorti3_df_2, sse_xorti3_sf_1, sse_xorti3_sf_2,\n+        sse_xorti3): Kill.\n+\t(sse_andv4sf3, sse_andnv4sf3, sse_orv2df3, sse_xorv2df3, sse_andv2df3,\n+\t sse_andnv2df3, sse_orv2df3, sse_xorv2df3): New expanders.\n+\t(*sse_andv4sf3, *sse_andnv2df3, *sse_orv4sf3, *sse_xorv4sf3, *sse_andv2df3,\n+\t *sse_andnv2df3, *sse_orv2df3, *sse_xorv2df3): New patterns.\n+\t(*sse_andsf3, *sse_andndf3, *sse_ordf3, *sse_xordf3, *sse_anddf3,\n+\t *sse_andndf3, *sse_orv2df3, *sse_xorv2df3): New patterns.\n+\n+\t* xmmintrin.h (__m128i): Define as __v2di.\n+\n+\tPR c/7344\n+\t* predict.c (can_predict_insn_p): New function.\n+\t(estimate_probability): Avoid unnecesary work.\n+\t(process_note_prediction): Likewise.\n+\t* toplev.c (rest_of_compilation): Account early branch prediction pass\n+\tas TV_BRANCH_PROB.\n+\n+\tPR c++/6419\n+\t(expand_expr): Use DECL_RTL_SET_P.\n+\n 2002-10-14  Roger Sayle  <roger@eyesopen.com>\n \n \t* combine.c (simplify_set):  Treat MODE_CC registers like cc0.\n@@ -136,7 +174,7 @@ Fri Oct 11 22:22:38 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \tPR c/7344\n \t* cfgbuild.c (make_edges): Create edge cache when we do have\n \tlarge jumptable.\n-\t(do_tablejump): Note size of maximal jumptable.\n+\t* expr.c (do_tablejump): Note size of maximal jumptable.\n \t* function.c (prepare_function_start): Zero out size.\n \t* function.h (function): Add max_jumptable_ents.\n "}, {"sha": "82b22dc90aafe2a716396568012ab334c4900cbc", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 63, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -771,8 +771,6 @@ static rtx ix86_expand_sse_compare PARAMS ((const struct builtin_description *,\n static rtx ix86_expand_unop1_builtin PARAMS ((enum insn_code, tree, rtx));\n static rtx ix86_expand_unop_builtin PARAMS ((enum insn_code, tree, rtx, int));\n static rtx ix86_expand_binop_builtin PARAMS ((enum insn_code, tree, rtx));\n-static rtx ix86_expand_timode_binop_builtin PARAMS ((enum insn_code,\n-\t\t\t\t\t\t     tree, rtx));\n static rtx ix86_expand_store_builtin PARAMS ((enum insn_code, tree));\n static rtx safe_vector_operand PARAMS ((rtx, enum machine_mode));\n static enum rtx_code ix86_fp_compare_code_to_integer PARAMS ((enum rtx_code));\n@@ -11811,6 +11809,11 @@ static const struct builtin_description bdesc_2arg[] =\n   { MASK_SSE1, CODE_FOR_vmsminv4sf3, \"__builtin_ia32_minss\", IX86_BUILTIN_MINSS, 0, 0 },\n   { MASK_SSE1, CODE_FOR_vmsmaxv4sf3, \"__builtin_ia32_maxss\", IX86_BUILTIN_MAXSS, 0, 0 },\n \n+  { MASK_SSE1, CODE_FOR_sse_andv4sf3, \"__builtin_ia32_andps\", IX86_BUILTIN_ANDPS, 0, 0 },\n+  { MASK_SSE1, CODE_FOR_sse_nandv4sf3,  \"__builtin_ia32_andnps\", IX86_BUILTIN_ANDNPS, 0, 0 },\n+  { MASK_SSE1, CODE_FOR_sse_iorv4sf3, \"__builtin_ia32_orps\", IX86_BUILTIN_ORPS, 0, 0 },\n+  { MASK_SSE1, CODE_FOR_sse_xorv4sf3,  \"__builtin_ia32_xorps\", IX86_BUILTIN_XORPS, 0, 0 },\n+\n   { MASK_SSE1, CODE_FOR_sse_movss,  \"__builtin_ia32_movss\", IX86_BUILTIN_MOVSS, 0, 0 },\n   { MASK_SSE1, CODE_FOR_sse_movhlps,  \"__builtin_ia32_movhlps\", IX86_BUILTIN_MOVHLPS, 0, 0 },\n   { MASK_SSE1, CODE_FOR_sse_movlhps,  \"__builtin_ia32_movlhps\", IX86_BUILTIN_MOVLHPS, 0, 0 },\n@@ -11935,10 +11938,10 @@ static const struct builtin_description bdesc_2arg[] =\n   { MASK_SSE2, CODE_FOR_vmsminv2df3, \"__builtin_ia32_minsd\", IX86_BUILTIN_MINSD, 0, 0 },\n   { MASK_SSE2, CODE_FOR_vmsmaxv2df3, \"__builtin_ia32_maxsd\", IX86_BUILTIN_MAXSD, 0, 0 },\n \n-  { MASK_SSE2, CODE_FOR_sse2_anddf3, \"__builtin_ia32_andpd\", IX86_BUILTIN_ANDPD, 0, 0 },\n-  { MASK_SSE2, CODE_FOR_sse2_nanddf3,  \"__builtin_ia32_andnpd\", IX86_BUILTIN_ANDNPD, 0, 0 },\n-  { MASK_SSE2, CODE_FOR_sse2_iordf3, \"__builtin_ia32_orpd\", IX86_BUILTIN_ORPD, 0, 0 },\n-  { MASK_SSE2, CODE_FOR_sse2_xordf3,  \"__builtin_ia32_xorpd\", IX86_BUILTIN_XORPD, 0, 0 },\n+  { MASK_SSE2, CODE_FOR_sse2_andv2df3, \"__builtin_ia32_andpd\", IX86_BUILTIN_ANDPD, 0, 0 },\n+  { MASK_SSE2, CODE_FOR_sse2_nandv2df3,  \"__builtin_ia32_andnpd\", IX86_BUILTIN_ANDNPD, 0, 0 },\n+  { MASK_SSE2, CODE_FOR_sse2_iorv2df3, \"__builtin_ia32_orpd\", IX86_BUILTIN_ORPD, 0, 0 },\n+  { MASK_SSE2, CODE_FOR_sse2_xorv2df3,  \"__builtin_ia32_xorpd\", IX86_BUILTIN_XORPD, 0, 0 },\n \n   { MASK_SSE2, CODE_FOR_sse2_movsd,  \"__builtin_ia32_movsd\", IX86_BUILTIN_MOVSD, 0, 0 },\n   { MASK_SSE2, CODE_FOR_sse2_unpckhpd, \"__builtin_ia32_unpckhpd\", IX86_BUILTIN_UNPCKHPD, 0, 0 },\n@@ -12443,11 +12446,6 @@ ix86_init_mmx_sse_builtins ()\n   def_builtin (MASK_SSE1, \"__builtin_ia32_cvttps2pi\", v2si_ftype_v4sf, IX86_BUILTIN_CVTTPS2PI);\n   def_builtin (MASK_SSE1, \"__builtin_ia32_cvttss2si\", int_ftype_v4sf, IX86_BUILTIN_CVTTSS2SI);\n \n-  def_builtin (MASK_SSE1, \"__builtin_ia32_andps\", v4sf_ftype_v4sf_v4sf, IX86_BUILTIN_ANDPS);\n-  def_builtin (MASK_SSE1, \"__builtin_ia32_andnps\", v4sf_ftype_v4sf_v4sf, IX86_BUILTIN_ANDNPS);\n-  def_builtin (MASK_SSE1, \"__builtin_ia32_orps\", v4sf_ftype_v4sf_v4sf, IX86_BUILTIN_ORPS);\n-  def_builtin (MASK_SSE1, \"__builtin_ia32_xorps\", v4sf_ftype_v4sf_v4sf, IX86_BUILTIN_XORPS);\n-\n   def_builtin (MASK_SSE1 | MASK_3DNOW_A, \"__builtin_ia32_pextrw\", int_ftype_v4hi_int, IX86_BUILTIN_PEXTRW);\n   def_builtin (MASK_SSE1 | MASK_3DNOW_A, \"__builtin_ia32_pinsrw\", v4hi_ftype_v4hi_int_int, IX86_BUILTIN_PINSRW);\n \n@@ -12680,45 +12678,6 @@ ix86_expand_binop_builtin (icode, arglist, target)\n   return target;\n }\n \n-/* In type_for_mode we restrict the ability to create TImode types\n-   to hosts with 64-bit H_W_I.  So we've defined the SSE logicals\n-   to have a V4SFmode signature.  Convert them in-place to TImode.  */\n-\n-static rtx\n-ix86_expand_timode_binop_builtin (icode, arglist, target)\n-     enum insn_code icode;\n-     tree arglist;\n-     rtx target;\n-{\n-  rtx pat;\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n-  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n-\n-  op0 = gen_lowpart (TImode, op0);\n-  op1 = gen_lowpart (TImode, op1);\n-  target = gen_reg_rtx (TImode);\n-\n-  if (! (*insn_data[icode].operand[1].predicate) (op0, TImode))\n-    op0 = copy_to_mode_reg (TImode, op0);\n-  if (! (*insn_data[icode].operand[2].predicate) (op1, TImode))\n-    op1 = copy_to_mode_reg (TImode, op1);\n-\n-  /* In the commutative cases, both op0 and op1 are nonimmediate_operand,\n-     yet one of the two must not be a memory.  This is normally enforced\n-     by expanders, but we didn't bother to create one here.  */\n-  if (GET_CODE (op0) == MEM && GET_CODE (op1) == MEM)\n-    op0 = copy_to_mode_reg (TImode, op0);\n-\n-  pat = GEN_FCN (icode) (target, op0, op1);\n-  if (! pat)\n-    return 0;\n-  emit_insn (pat);\n-\n-  return gen_lowpart (V4SFmode, target);\n-}\n-\n /* Subroutine of ix86_expand_builtin to take care of stores.  */\n \n static rtx\n@@ -13064,19 +13023,6 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n     case IX86_BUILTIN_RCPSS:\n       return ix86_expand_unop1_builtin (CODE_FOR_vmrcpv4sf2, arglist, target);\n \n-    case IX86_BUILTIN_ANDPS:\n-      return ix86_expand_timode_binop_builtin (CODE_FOR_sse_andti3,\n-\t\t\t\t\t       arglist, target);\n-    case IX86_BUILTIN_ANDNPS:\n-      return ix86_expand_timode_binop_builtin (CODE_FOR_sse_nandti3,\n-\t\t\t\t\t       arglist, target);\n-    case IX86_BUILTIN_ORPS:\n-      return ix86_expand_timode_binop_builtin (CODE_FOR_sse_iorti3,\n-\t\t\t\t\t       arglist, target);\n-    case IX86_BUILTIN_XORPS:\n-      return ix86_expand_timode_binop_builtin (CODE_FOR_sse_xorti3,\n-\t\t\t\t\t       arglist, target);\n-\n     case IX86_BUILTIN_LOADAPS:\n       return ix86_expand_unop_builtin (CODE_FOR_sse_movaps, arglist, target, 1);\n \n@@ -13553,6 +13499,8 @@ ix86_preferred_reload_class (x, class)\n      rtx x;\n      enum reg_class class;\n {\n+  if (GET_CODE (x) == CONST_VECTOR && x != CONST0_RTX (GET_MODE (x)))\n+    return NO_REGS;\n   if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != VOIDmode)\n     {\n       /* SSE can't load any constant directly yet.  */"}, {"sha": "efa84c9515cef5187ccc745f4cf6199ba776ddc7", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 240, "deletions": 182, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -17823,6 +17823,15 @@\n   [(set_attr \"type\" \"ssemov\")\n    (set_attr \"mode\" \"V4SF\")])\n \n+(define_insn \"movv2di_internal\"\n+  [(set (match_operand:V2DI 0 \"nonimmediate_operand\" \"=x,m\")\n+\t(match_operand:V2DI 1 \"nonimmediate_operand\" \"xm,x\"))]\n+  \"TARGET_SSE\"\n+  ;; @@@ let's try to use movaps here.\n+  \"movdga\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n (define_insn \"movv8qi_internal\"\n   [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"=y,m\")\n \t(match_operand:V8QI 1 \"nonimmediate_operand\" \"ym,y\"))]\n@@ -17869,7 +17878,7 @@\n \n (define_insn \"movv2df_internal\"\n   [(set (match_operand:V2DF 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(match_operand:V2DF 1 \"general_operand\" \"xm,x\"))]\n+\t(match_operand:V2DF 1 \"nonimmediate_operand\" \"xm,x\"))]\n   \"TARGET_SSE2\"\n   ;; @@@ let's try to use movaps here.\n   \"movapd\\t{%1, %0|%0, %1}\"\n@@ -17878,7 +17887,7 @@\n \n (define_insn \"movv8hi_internal\"\n   [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(match_operand:V8HI 1 \"general_operand\" \"xm,x\"))]\n+\t(match_operand:V8HI 1 \"nonimmediate_operand\" \"xm,x\"))]\n   \"TARGET_SSE2\"\n   ;; @@@ let's try to use movaps here.\n   \"movaps\\t{%1, %0|%0, %1}\"\n@@ -17887,7 +17896,7 @@\n \n (define_insn \"movv16qi_internal\"\n   [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"=x,m\")\n-\t(match_operand:V16QI 1 \"general_operand\" \"xm,x\"))]\n+\t(match_operand:V16QI 1 \"nonimmediate_operand\" \"xm,x\"))]\n   \"TARGET_SSE2\"\n   ;; @@@ let's try to use movaps here.\n   \"movaps\\t{%1, %0|%0, %1}\"\n@@ -17933,12 +17942,21 @@\n (define_expand \"movv4si\"\n   [(set (match_operand:V4SI 0 \"general_operand\" \"\")\n \t(match_operand:V4SI 1 \"general_operand\" \"\"))]\n-  \"TARGET_MMX\"\n+  \"TARGET_SSE\"\n {\n   ix86_expand_vector_move (V4SImode, operands);\n   DONE;\n })\n \n+(define_expand \"movv2di\"\n+  [(set (match_operand:V2DI 0 \"general_operand\" \"\")\n+\t(match_operand:V2DI 1 \"general_operand\" \"\"))]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_move (V2DImode, operands);\n+  DONE;\n+})\n+\n (define_expand \"movv2si\"\n   [(set (match_operand:V2SI 0 \"general_operand\" \"\")\n \t(match_operand:V2SI 1 \"general_operand\" \"\"))]\n@@ -18455,236 +18473,313 @@\n \n ;; SSE logical operations.\n \n+;; SSE defines logical operations on floating point values.  This brings\n+;; interesting challenge to RTL representation where logicals are only valid\n+;; on integral types.  We deal with this by representing the floating point\n+;; logical as logical on arguments casted to TImode as this is what hardware\n+;; really does.  Unfortunately hardware requires the type information to be\n+;; present and thus we must avoid subregs from being simplified and elliminated\n+;; in later compilation phases.\n+;;\n+;; We have following variants from each instruction:\n+;; sse_andsf3 - the operation taking V4SF vector operands\n+;;              and doing TImode cast on them\n+;; *sse_andsf3_memory - the operation taking one memory operand casted to\n+;;                      TImode, since backend insist on elliminating casts\n+;;                      on memory operands\n+;; sse_andti3_sf_1 - the operation taking SF scalar operands.\n+;;                   We can not accept memory operand here as instruction reads\n+;;\t\t     whole scalar.  This is generated only post reload by GCC\n+;;\t\t     scalar float operations that expands to logicals (fabs)\n+;; sse_andti3_sf_2 - the operation taking SF scalar input and TImode\n+;;\t\t     memory operand.  Eventually combine can be able\n+;;\t\t     to synthetize these using splitter.\n+;; sse2_anddf3, *sse2_anddf3_memory\n+;;              \n+;; \n ;; These are not called andti3 etc. because we really really don't want\n ;; the compiler to widen DImode ands to TImode ands and then try to move\n ;; into DImode subregs of SSE registers, and them together, and move out\n ;; of DImode subregs again!\n+;; SSE1 single precision floating point logical operation\n+(define_expand \"sse_andv4sf3\"\n+  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"\") 0)\n+        (and:TI (subreg:TI (match_operand:V4SF 1 \"register_operand\" \"\") 0)\n+\t\t(subreg:TI (match_operand:V4SF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  \"TARGET_SSE\"\n+  \"\")\n \n-(define_insn \"*sse_andti3_df_1\"\n-  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n-        (and:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"%0\") 0)\n-\t\t(subreg:TI (match_operand:DF 2 \"register_operand\" \"Y\") 0)))]\n-  \"TARGET_SSE2\"\n-  \"andpd\\t{%2, %0|%0, %2}\"\n+(define_insn \"*sse_andv4sf3\"\n+  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"=x\") 0)\n+        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"andps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n+   (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"*sse_andti3_df_2\"\n-  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n-        (and:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"0\") 0)\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"Ym\")))]\n-  \"TARGET_SSE2\"\n-  \"andpd\\t{%2, %0|%0, %2}\"\n+(define_insn \"*sse_andsf3\"\n+  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n+        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"andps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n+   (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"*sse_andti3_sf_1\"\n-  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (and:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"%0\") 0)\n-\t\t(subreg:TI (match_operand:SF 2 \"register_operand\" \"x\") 0)))]\n+(define_expand \"sse_nandv4sf3\"\n+  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"\") 0)\n+        (and:TI (not:TI (subreg:TI (match_operand:V4SF 1 \"register_operand\" \"\") 0))\n+\t        (subreg:TI (match_operand:V4SF 2 \"nonimmediate_operand\" \"\") 0)))]\n   \"TARGET_SSE\"\n-  \"andps\\t{%2, %0|%0, %2}\"\n+  \"\")\n+\n+(define_insn \"*sse_nandv4sf3\"\n+  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"=x\") 0)\n+        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n+\t        (match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE\"\n+  \"andnps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"*sse_andti3_sf_2\"\n+(define_insn \"*sse_nandsf3\"\n   [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (and:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"0\") 0)\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n+\t        (match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE\"\n-  \"andps\\t{%2, %0|%0, %2}\"\n+  \"andnps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"sse_andti3\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n-        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n+(define_expand \"sse_iorv4sf3\"\n+  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"\") 0)\n+        (ior:TI (subreg:TI (match_operand:V4SF 1 \"register_operand\" \"\") 0)\n+\t\t(subreg:TI (match_operand:V4SF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  \"TARGET_SSE\"\n+  \"\")\n+\n+(define_insn \"*sse_iorv4sf3\"\n+  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"=x\") 0)\n+        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE && !TARGET_SSE2\n+  \"TARGET_SSE\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"andps\\t{%2, %0|%0, %2}\"\n+  \"orps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"sse2_andti3\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n-        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n+(define_insn \"*sse_iorsf3\"\n+  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n+        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE2\n+  \"TARGET_SSE\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"pand\\t{%2, %0|%0, %2}\"\n+  \"orps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"TI\")])\n+   (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"sse2_andv2di3\"\n-  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n-        (and:V2DI (match_operand:V2DI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t  (match_operand:V2DI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE2\n+(define_expand \"sse_xorv4sf3\"\n+  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"\") 0)\n+        (xor:TI (subreg:TI (match_operand:V4SF 1 \"register_operand\" \"\") 0)\n+\t\t(subreg:TI (match_operand:V4SF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  \"TARGET_SSE\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"pand\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"TI\")])\n-\n-(define_insn \"*sse_nandti3_df\"\n-  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n-        (and:TI (not:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"0\") 0))\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"Ym\")))]\n-  \"TARGET_SSE2\"\n-  \"andnpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n+  \"\")\n \n-(define_insn \"*sse_nandti3_sf\"\n-  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (and:TI (not:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"0\") 0))\n+(define_insn \"*sse_xorv4sf3\"\n+  [(set (subreg:TI (match_operand:V4SF 0 \"register_operand\" \"=x\") 0)\n+        (xor:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\"\n-  \"andnps\\t{%2, %0|%0, %2}\"\n+  \"TARGET_SSE\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"xorps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"sse_nandti3\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n-        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n+(define_insn \"*sse_xorsf3\"\n+  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n+        (xor:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE && !TARGET_SSE2\"\n-  \"andnps\\t{%2, %0|%0, %2}\"\n+  \"TARGET_SSE\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"xorps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"sse2_nandti3\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n-        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+;; SSE2 double precision floating point logical operation\n+\n+(define_expand \"sse2_andv2df3\"\n+  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"\") 0)\n+        (and:TI (subreg:TI (match_operand:V2DF 1 \"register_operand\" \"\") 0)\n+\t        (subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"\") 0)))]\n   \"TARGET_SSE2\"\n-  \"pandn\\t{%2, %0|%0, %2}\"\n+  \"\")\n+\n+(define_insn \"*sse2_andv2df3\"\n+  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"=x\") 0)\n+        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"andpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"TI\")])\n+   (set_attr \"mode\" \"V2DF\")])\n \n-(define_insn \"sse2_nandv2di3\"\n-  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n-        (and:V2DI (not:V2DI (match_operand:V2DI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t  (match_operand:V2DI 2 \"nonimmediate_operand\" \"xm\")))]\n+(define_insn \"*sse2_andv2df3\"\n+  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=x\") 0)\n+        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"pandn\\t{%2, %0|%0, %2}\"\n+  \"andpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"TI\")])\n+   (set_attr \"mode\" \"V2DF\")])\n \n-(define_insn \"*sse_iorti3_df_1\"\n-  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n-        (ior:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"%0\") 0)\n-\t\t(subreg:TI (match_operand:DF 2 \"register_operand\" \"Y\") 0)))]\n+(define_expand \"sse2_nandv2df3\"\n+  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"\") 0)\n+        (and:TI (not:TI (subreg:TI (match_operand:V2DF 1 \"register_operand\" \"\") 0))\n+\t        (subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"\") 0)))]\n   \"TARGET_SSE2\"\n-  \"orpd\\t{%2, %0|%0, %2}\"\n+  \"\")\n+\n+(define_insn \"*sse2_nandv2df3\"\n+  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"=x\") 0)\n+        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n+\t        (match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2\"\n+  \"andnpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V2DF\")])\n \n-(define_insn \"*sse_iorti3_df_2\"\n+(define_insn \"*sse_nandti3_df\"\n   [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n-        (ior:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"0\") 0)\n+        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"Ym\")))]\n   \"TARGET_SSE2\"\n+  \"andnpd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_expand \"sse2_iorv2df3\"\n+  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"\") 0)\n+        (ior:TI (subreg:TI (match_operand:V2DF 1 \"register_operand\" \"\") 0)\n+\t\t(subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  \"TARGET_SSE2\"\n+  \"\")\n+\n+(define_insn \"*sse2_iorv2df3\"\n+  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"=x\") 0)\n+        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n   \"orpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V2DF\")])\n \n-(define_insn \"*sse_iorti3_sf_1\"\n-  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (ior:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"%0\") 0)\n-\t\t(subreg:TI (match_operand:SF 2 \"register_operand\" \"x\") 0)))]\n-  \"TARGET_SSE\"\n-  \"orps\\t{%2, %0|%0, %2}\"\n+(define_insn \"*sse2_iordf3\"\n+  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=x\") 0)\n+        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"orpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V4SF\")])\n+   (set_attr \"mode\" \"V2DF\")])\n \n-(define_insn \"*sse_iorti3_sf_2\"\n-  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (ior:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"0\") 0)\n+(define_expand \"sse2_xorv2df3\"\n+  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"\") 0)\n+        (xor:TI (subreg:TI (match_operand:V2DF 1 \"nonimmediate_operand\" \"\") 0)\n+\t\t(subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"\") 0)))]\n+  \"TARGET_SSE2\"\n+  \"\")\n+\n+(define_insn \"*sse2_xorv2df3\"\n+  [(set (subreg:TI (match_operand:V2DF 0 \"register_operand\" \"=x\") 0)\n+        (xor:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\"\n-  \"orps\\t{%2, %0|%0, %2}\"\n+  \"TARGET_SSE2\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"xorpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V4SF\")])\n+   (set_attr \"mode\" \"V2DF\")])\n \n-(define_insn \"sse_iorti3\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n-        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n+(define_insn \"*sse2_xordf3\"\n+  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=x\") 0)\n+        (xor:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE && !TARGET_SSE2\n+  \"TARGET_SSE2\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"orps\\t{%2, %0|%0, %2}\"\n+  \"xorpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V4SF\")])\n+   (set_attr \"mode\" \"V2DF\")])\n \n-(define_insn \"sse2_iorti3\"\n+;; SSE2 integral logicals.  These patterns must always come after floating\n+;; point ones since we don't want compiler to use integer opcodes on floating\n+;; point SSE values to avoid matching of subregs in the match_operand.\n+(define_insn \"*sse2_andti3\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n-        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n+        (and:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"por\\t{%2, %0|%0, %2}\"\n+  \"pand\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"sse2_iorv2di3\"\n+(define_insn \"sse2_andv2di3\"\n   [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n-        (ior:V2DI (match_operand:V2DI 1 \"nonimmediate_operand\" \"%0\")\n+        (and:V2DI (match_operand:V2DI 1 \"nonimmediate_operand\" \"%0\")\n \t\t  (match_operand:V2DI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"por\\t{%2, %0|%0, %2}\"\n+  \"pand\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"*sse_xorti3_df_1\"\n-  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n-        (xor:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"%0\") 0)\n-\t\t(subreg:TI (match_operand:DF 2 \"register_operand\" \"Y\") 0)))]\n-  \"TARGET_SSE2\"\n-  \"xorpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n-(define_insn \"*sse_xorti3_df_2\"\n-  [(set (subreg:TI (match_operand:DF 0 \"register_operand\" \"=Y\") 0)\n-        (xor:TI (subreg:TI (match_operand:DF 1 \"register_operand\" \"0\") 0)\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"Ym\")))]\n+(define_insn \"*sse2_nandti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (and:TI (not:TI (match_operand:TI 1 \"register_operand\" \"0\"))\n+\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2\"\n-  \"xorpd\\t{%2, %0|%0, %2}\"\n+  \"pandn\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n+   (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"*sse_xorti3_sf_1\"\n-  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (xor:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"%0\") 0)\n-\t\t(subreg:TI (match_operand:SF 2 \"register_operand\" \"x\") 0)))]\n-  \"TARGET_SSE\"\n-  \"xorps\\t{%2, %0|%0, %2}\"\n+(define_insn \"sse2_nandv2di3\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+        (and:V2DI (not:V2DI (match_operand:V2DI 1 \"nonimmediate_operand\" \"%0\"))\n+\t\t  (match_operand:V2DI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"pandn\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V4SF\")])\n+   (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"*sse_xorti3_sf_2\"\n-  [(set (subreg:TI (match_operand:SF 0 \"register_operand\" \"=x\") 0)\n-        (xor:TI (subreg:TI (match_operand:SF 1 \"register_operand\" \"0\") 0)\n+(define_insn \"*sse2_iorti3\"\n+  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n+        (ior:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\"\n-  \"xorps\\t{%2, %0|%0, %2}\"\n+  \"TARGET_SSE2\n+   && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n+  \"por\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V4SF\")])\n+   (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"sse_xorti3\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n-        (xor:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE && !TARGET_SSE2\n+(define_insn \"sse2_iorv2di3\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n+        (ior:V2DI (match_operand:V2DI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t  (match_operand:V2DI 2 \"nonimmediate_operand\" \"xm\")))]\n+  \"TARGET_SSE2\n    && (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != MEM)\"\n-  \"xorps\\t{%2, %0|%0, %2}\"\n+  \"por\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V4SF\")])\n+   (set_attr \"mode\" \"TI\")])\n \n-(define_insn \"sse2_xorti3\"\n+(define_insn \"*sse2_xorti3\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=x\")\n         (xor:TI (match_operand:TI 1 \"nonimmediate_operand\" \"%0\")\n \t\t(match_operand:TI 2 \"nonimmediate_operand\" \"xm\")))]\n@@ -18889,7 +18984,6 @@\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"mode\" \"SF\")])\n \n-\n ;; SSE <-> integer/MMX conversions\n \n (define_insn \"cvtpi2ps\"\n@@ -20264,42 +20358,6 @@\n   \"minsd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sseadd\")\n    (set_attr \"mode\" \"DF\")])\n-\n-(define_insn \"sse2_anddf3\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n-        (subreg:V2DF (and:TI (subreg:TI (match_operand:V2DF 1 \"register_operand\" \"%0\") 0)\n-\t\t\t     (subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\") 0)) 0))]\n-  \"TARGET_SSE2\"\n-  \"andpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n-(define_insn \"sse2_nanddf3\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n-        (subreg:V2DF (and:TI (not:TI (subreg:TI (match_operand:V2DF 1 \"register_operand\" \"0\") 0))\n-\t\t\t     (subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\") 0)) 0))]\n-  \"TARGET_SSE2\"\n-  \"andnpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n-(define_insn \"sse2_iordf3\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n-        (subreg:V2DF (ior:TI (subreg:TI (match_operand:V2DF 1 \"register_operand\" \"%0\") 0)\n-\t\t\t     (subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\") 0)) 0))]\n-  \"TARGET_SSE2\"\n-  \"orpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n-(define_insn \"sse2_xordf3\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n-        (subreg:V2DF (xor:TI (subreg:TI (match_operand:V2DF 1 \"register_operand\" \"%0\") 0)\n-\t\t\t     (subreg:TI (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\") 0)) 0))]\n-  \"TARGET_SSE2\"\n-  \"xorpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sselog\")\n-   (set_attr \"mode\" \"V2DF\")])\n ;; SSE2 square root.  There doesn't appear to be an extension for the\n ;; reciprocal/rsqrt instructions if the Intel manual is to be believed.\n "}, {"sha": "fcf73ca796e34031667d36eadc367898b4303999", "filename": "gcc/config/i386/xmmintrin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxmmintrin.h?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -1066,7 +1066,7 @@ typedef int __v4si __attribute__ ((mode (V4SI)));\n typedef int __v8hi __attribute__ ((mode (V8HI)));\n typedef int __v16qi __attribute__ ((mode (V16QI)));\n \n-#define __m128i __m128\n+#define __m128i __v2di\n #define __m128d __v2df\n \n static __inline __m128d"}, {"sha": "c736ebc73e7ff1cb95f731c97053c35dc3759884", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -6532,7 +6532,7 @@ expand_expr (exp, target, tmode, modifier)\n       }\n \n     case PARM_DECL:\n-      if (DECL_RTL (exp) == 0)\n+      if (!DECL_RTL_SET_P (exp))\n \t{\n \t  error_with_decl (exp, \"prior parameter's size depends on `%s'\");\n \t  return CONST0_RTX (mode);\n@@ -10942,6 +10942,9 @@ do_tablejump (index, mode, range, table_label, default_label)\n {\n   rtx temp, vector;\n \n+  if (range > cfun->max_jumptable_ents)\n+    cfun->max_jumptable_ents = range;\n+\n   /* Do an unsigned comparison (in the proper mode) between the index\n      expression and the value which represents the length of the range.\n      Since we just finished subtracting the lower bound of the range"}, {"sha": "5b11665ef857b5be84bcd9ec8fda99427b0f8aa0", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -997,7 +997,7 @@ compute_alignments ()\n \t align it.  It is most likely an first block of loop.  */\n       if (has_fallthru\n \t  && branch_frequency + fallthru_frequency > BB_FREQ_MAX / 10\n-\t  && branch_frequency > fallthru_frequency * 5)\n+\t  && branch_frequency > fallthru_frequency * 2)\n \t{\n \t  log = LOOP_ALIGN (label);\n \t  if (max_log < log)"}, {"sha": "c857013f56a6a20569901b103d54046df047bf1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -1,3 +1,7 @@\n+Mon Oct 14 20:37:51 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/i386-ssetype-[1-5].c: New tests.\n+\n 2002-10-14  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.dg/20020219-1.c: Disable for 16-bit targets."}, {"sha": "e8411ff0a5307910977fdeda8eadbcba005a7652", "filename": "gcc/testsuite/gcc.dg/i386-ssetype-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-1.c?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -msse2 -march=athlon\" } */\n+/* { dg-final { scan-assembler \"andpd.*\\[bs\\]p\" } } */\n+/* { dg-final { scan-assembler \"andnpd.*\\[bs\\]p\" } } */\n+/* { dg-final { scan-assembler \"xorpd.*\\[bs\\]p\" } } */\n+/* { dg-final { scan-assembler \"iorpd.*\\[bs\\]p\" } } */\n+/* { dg-final { scan-assembler-not \"movdqa\" } } */\n+/* { dg-final { scan-assembler \"movapd.*\\[bs\\]p\" } } */\n+\n+/* Verify that we generate proper instruction with memory operand.  */\n+\n+#include <xmmintrin.h>\n+__m128d\n+t1(__m128d a, __m128d b)\n+{\n+return _mm_and_pd (a,b);\n+}\n+__m128d\n+t2(__m128d a, __m128d b)\n+{\n+return _mm_andnot_pd (a,b);\n+}\n+__m128d\n+t3(__m128d a, __m128d b)\n+{\n+return _mm_or_pd (a,b);\n+}\n+__m128d\n+t4(__m128d a, __m128d b)\n+{\n+return _mm_xor_pd (a,b);\n+}"}, {"sha": "377e1732cb44dce392e890e4131f0cea5bd6b1b0", "filename": "gcc/testsuite/gcc.dg/i386-ssetype-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-2.c?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -msse2 -march=athlon\" } */\n+/* { dg-final { scan-assembler \"andpd\" } } */\n+/* { dg-final { scan-assembler \"andnpd\" } } */\n+/* { dg-final { scan-assembler \"xorpd\" } } */\n+/* { dg-final { scan-assembler \"iorpd\" } } */\n+/* { dg-final { scan-assembler-not \"movdqa\" } } */\n+/* { dg-final { scan-assembler \"movapd\" } } */\n+\n+/* Verify that we generate proper instruction without memory operand.  */\n+\n+#include <xmmintrin.h>\n+__m128d\n+t1(__m128d a, __m128d b)\n+{\n+a=_mm_sqrt_pd(a);\n+b=_mm_sqrt_pd(b);\n+return _mm_and_pd (a,b);\n+}\n+__m128d\n+t2(__m128d a, __m128d b)\n+{\n+a=_mm_sqrt_pd(a);\n+b=_mm_sqrt_pd(b);\n+return _mm_andnot_pd (a,b);\n+}\n+__m128d\n+t3(__m128d a, __m128d b)\n+{\n+a=_mm_sqrt_pd(a);\n+b=_mm_sqrt_pd(b);\n+return _mm_or_pd (a,b);\n+}\n+__m128d\n+t4(__m128d a, __m128d b)\n+{\n+a=_mm_sqrt_pd(a);\n+b=_mm_sqrt_pd(b);\n+return _mm_xor_pd (a,b);\n+}"}, {"sha": "1d1d7b073ae1db638e7615d11af156aeaaae712a", "filename": "gcc/testsuite/gcc.dg/i386-ssetype-3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-3.c?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -msse2 -march=athlon\" } */\n+/* { dg-final { scan-assembler \"andps.*\\[bs]p\" } } */\n+/* { dg-final { scan-assembler \"andnps.*\\[bs]p\" } } */\n+/* { dg-final { scan-assembler \"xorps.*\\[bs]p\" } } */\n+/* { dg-final { scan-assembler \"orps.\\[b*s]p\" } } */\n+/* { dg-final { scan-assembler-not \"movdqa\" } } */\n+/* { dg-final { scan-assembler \"movaps.*\\[bs]p\" } } */\n+\n+/* Verify that we generate proper instruction with memory operand.  */\n+\n+#include <xmmintrin.h>\n+__m128\n+t1(__m128 a, __m128 b)\n+{\n+return _mm_and_ps (a,b);\n+}\n+__m128\n+t2(__m128 a, __m128 b)\n+{\n+return _mm_andnot_ps (a,b);\n+}\n+__m128\n+t3(__m128 a, __m128 b)\n+{\n+return _mm_or_ps (a,b);\n+}\n+__m128\n+t4(__m128 a, __m128 b)\n+{\n+return _mm_xor_ps (a,b);\n+}"}, {"sha": "ef6a93f6c16951b0df33e2c4751f3b3e90a4ee95", "filename": "gcc/testsuite/gcc.dg/i386-ssetype-4.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-4.c?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -msse2 -march=athlon\" } */\n+/* { dg-final { scan-assembler \"andps\" } } */\n+/* { dg-final { scan-assembler \"andnps\" } } */\n+/* { dg-final { scan-assembler \"xorps\" } } */\n+/* { dg-final { scan-assembler \"orps\" } } */\n+\n+/* Verify that we generate proper instruction without memory operand.  */\n+\n+#include <xmmintrin.h>\n+__m128\n+t1(__m128 a, __m128 b)\n+{\n+a=_mm_sqrt_ps(a);\n+b=_mm_sqrt_ps(b);\n+return _mm_and_ps (a,b);\n+}\n+__m128\n+t2(__m128 a, __m128 b)\n+{\n+a=_mm_sqrt_ps(a);\n+b=_mm_sqrt_ps(b);\n+return _mm_andnot_ps (a,b);\n+}\n+__m128\n+t3(__m128 a, __m128 b)\n+{\n+a=_mm_sqrt_ps(a);\n+b=_mm_sqrt_ps(b);\n+return _mm_or_ps (a,b);\n+}\n+__m128\n+t4(__m128 a, __m128 b)\n+{\n+a=_mm_sqrt_ps(a);\n+b=_mm_sqrt_ps(b);\n+return _mm_xor_ps (a,b);\n+}"}, {"sha": "97cc22fd3a811ab1bde2000427d69382ac1c4c50", "filename": "gcc/testsuite/gcc.dg/i386-ssetype-5.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1877be457e46e1f22414e7c215805e9e51c93cea/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-ssetype-5.c?ref=1877be457e46e1f22414e7c215805e9e51c93cea", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -msse2 -march=athlon\" } */\n+/* { dg-final { scan-assembler \"pand.*\\[bs\\]p\" } } */\n+/* { dg-final { scan-assembler \"pandn.*\\[bs\\]p\" } } */\n+/* { dg-final { scan-assembler \"pxor.*\\[bs\\]p\" } } */\n+/* { dg-final { scan-assembler \"por.*\\[bs\\]p\" } } */\n+/* { dg-final { scan-assembler \"movdqa\" } } */\n+/* { dg-final { scan-assembler-not \"movaps.*\\[bs\\]p\" } } */\n+\n+/* Verify that we generate proper instruction with memory operand.  */\n+\n+#include <xmmintrin.h>\n+__m128i\n+t1(__m128i a, __m128i b)\n+{\n+return _mm_and_si128 (a,b);\n+}\n+__m128i\n+t2(__m128i a, __m128i b)\n+{\n+return _mm_andnot_si128 (a,b);\n+}\n+__m128i\n+t3(__m128i a, __m128i b)\n+{\n+return _mm_or_si128 (a,b);\n+}\n+__m128i\n+t4(__m128i a, __m128i b)\n+{\n+return _mm_xor_si128 (a,b);\n+}\n+"}]}