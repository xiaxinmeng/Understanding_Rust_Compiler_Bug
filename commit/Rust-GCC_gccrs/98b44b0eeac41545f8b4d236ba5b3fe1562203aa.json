{"sha": "98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThiNDRiMGVlYWM0MTU0NWY4YjRkMjM2YmE1YjNmZTE1NjIyMDNhYQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2006-11-22T08:46:03Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2006-11-22T08:46:03Z"}, "message": "c-tree.texi: Document new tree codes.\n\n        * doc/c-tree.texi: Document new tree codes.\n        * doc/md.texi: Document new optabs.\n        * tree-pretty-print.c (dump_generic_node): Handle print of new tree\n        codes.\n        * optabs.c (optab_for_tree_code, init_optabs): Handle new optabs.\n        * optabs.h (optab_index): Add new.\n        (vec_extract_even_optab, vec_extract_odd_optab,\n        vec_interleave_high_optab, vec_interleave_low_optab): New optabs.\n        * genopinit.c (vec_extract_even_optab, vec_extract_odd_optab,\n        vec_interleave_high_optab, vec_interleave_low_optab): Initialize\n        new optabs.\n        * expr.c (expand_expr_real_1): Add implementation for new tree codes.\n        * tree-vectorizer.c (new_stmt_vec_info): Initialize new fields.\n        * tree-vectorizer.h (stmt_vec_info): Add new fields for interleaving\n        along with macros for their access.\n        * tree-data-ref.h (first_location_in_loop, data_reference): Update\n        comment.\n        * tree-vect-analyze.c (toplev.h): Include.\n        (vect_determine_vectorization_factor): Fix indentation.\n        (vect_insert_into_interleaving_chain,\n        vect_update_interleaving_chain, vect_equal_offsets): New functions.\n        (vect_analyze_data_ref_dependence): Add argument for interleaving\n        check. Check for interleaving if it's true.\n        (vect_check_dependences): New function.\n        (vect_analyze_data_ref_dependences): Call vect_check_dependences for\n        every ddr. Call vect_analyze_data_ref_dependence with new argument.\n        (vect_update_misalignment_for_peel): Update for interleaving.\n        (vect_verify_datarefs_alignment): Check only first data-ref for\n        interleaving.\n        (vect_enhance_data_refs_alignment): Update for interleaving. Check\n        only first data-ref for interleaving.\n        (vect_analyze_data_ref_access): Check interleaving, update\n        interleaving data.\n        (vect_analyze_data_refs): Call compute_data_dependences_for_loop\n        with different parameters.\n        * tree.def (VEC_EXTRACT_EVEN_EXPR, VEC_EXTRACT_ODD_EXPR,\n        VEC_INTERLEAVE_HIGH_EXPR, VEC_INTERLEAVE_LOW_EXPR): New tree codes.\n        * tree-inline.c (estimate_num_insns_1): Add cases for new codes.\n        * tree-vect-transform.c (vect_create_addr_base_for_vector_ref):\n        Update step in case of interleaving.\n        (vect_strided_store_supported, vect_permute_store_chain): New\n        functions.\n        (vectorizable_store): Handle strided stores.\n        (vect_strided_load_supported, vect_permute_load_chain,\n        vect_transform_strided_load): New functions.\n        (vectorizable_load): Handle strided loads.\n        (vect_transform_stmt): Add argument. Handle strided stores. Check\n        that vectorized stmt exists for patterns.\n        (vect_gen_niters_for_prolog_loop): Update calculation for\n        interleaving.\n        (vect_transform_loop): Remove stmt_vec_info for strided stores after\n        whole chain vectorization.\n        * config/rs6000/altivec.md (UNSPEC_EXTEVEN, UNSPEC_EXTODD,\n        UNSPEC_INTERHI, UNSPEC_INTERLO): New constants.\n        (vpkuhum_nomode, vpkuwum_nomode, vec_extract_even<mode>,\n        vec_extract_odd<mode>, altivec_vmrghsf, altivec_vmrglsf,\n        vec_interleave_high<mode>, vec_interleave_low<mode>): Implement.\n\nFrom-SVN: r119088", "tree": {"sha": "4b2ea3085ae0c7d9acece7d444f408bf4d827a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b2ea3085ae0c7d9acece7d444f408bf4d827a97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b0c6db58adfcdd39c80ea0b1895d1b7d255fe633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c6db58adfcdd39c80ea0b1895d1b7d255fe633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0c6db58adfcdd39c80ea0b1895d1b7d255fe633"}], "stats": {"total": 3964, "additions": 3766, "deletions": 198}, "files": [{"sha": "665fe81fe28ac0bb1525d949a295093d5788812b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -1,3 +1,63 @@\n+2006-11-22  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* doc/c-tree.texi: Document new tree codes.\n+\t* doc/md.texi: Document new optabs.\n+\t* tree-pretty-print.c (dump_generic_node): Handle print of new tree\n+\tcodes.\n+\t* optabs.c (optab_for_tree_code, init_optabs): Handle new optabs.\n+\t* optabs.h (optab_index): Add new.\n+\t(vec_extract_even_optab, vec_extract_odd_optab,\n+\tvec_interleave_high_optab, vec_interleave_low_optab): New optabs.\n+\t* genopinit.c (vec_extract_even_optab, vec_extract_odd_optab,\n+\tvec_interleave_high_optab, vec_interleave_low_optab): Initialize\n+\tnew optabs.\n+\t* expr.c (expand_expr_real_1): Add implementation for new tree codes.\n+\t* tree-vectorizer.c (new_stmt_vec_info): Initialize new fields.\n+\t* tree-vectorizer.h (stmt_vec_info): Add new fields for interleaving\n+\talong with macros for their access.\n+\t* tree-data-ref.h (first_location_in_loop, data_reference): Update\n+\tcomment.\n+\t* tree-vect-analyze.c (toplev.h): Include.\n+\t(vect_determine_vectorization_factor): Fix indentation.\n+\t(vect_insert_into_interleaving_chain,\n+\tvect_update_interleaving_chain, vect_equal_offsets): New functions.\n+\t(vect_analyze_data_ref_dependence): Add argument for interleaving\n+\tcheck. Check for interleaving if it's true.\n+\t(vect_check_dependences): New function.\n+\t(vect_analyze_data_ref_dependences): Call vect_check_dependences for\n+\tevery ddr. Call vect_analyze_data_ref_dependence with new argument.\n+\t(vect_update_misalignment_for_peel): Update for interleaving.\n+\t(vect_verify_datarefs_alignment): Check only first data-ref for\n+\tinterleaving.\n+\t(vect_enhance_data_refs_alignment): Update for interleaving. Check\n+\tonly first data-ref for interleaving.\n+\t(vect_analyze_data_ref_access): Check interleaving, update\n+\tinterleaving data.\n+\t(vect_analyze_data_refs): Call compute_data_dependences_for_loop\n+\twith different parameters.\n+\t* tree.def (VEC_EXTRACT_EVEN_EXPR, VEC_EXTRACT_ODD_EXPR,\n+\tVEC_INTERLEAVE_HIGH_EXPR, VEC_INTERLEAVE_LOW_EXPR): New tree codes.\n+\t* tree-inline.c (estimate_num_insns_1): Add cases for new codes.\n+\t* tree-vect-transform.c (vect_create_addr_base_for_vector_ref):\n+\tUpdate step in case of interleaving.\n+\t(vect_strided_store_supported, vect_permute_store_chain): New\n+\tfunctions.\n+\t(vectorizable_store): Handle strided stores.\n+\t(vect_strided_load_supported, vect_permute_load_chain,\n+\tvect_transform_strided_load): New functions.\n+\t(vectorizable_load): Handle strided loads.\n+\t(vect_transform_stmt): Add argument. Handle strided stores. Check\n+\tthat vectorized stmt exists for patterns.\n+\t(vect_gen_niters_for_prolog_loop): Update calculation for\n+\tinterleaving.\n+\t(vect_transform_loop): Remove stmt_vec_info for strided stores after\n+\twhole chain vectorization.\n+\t* config/rs6000/altivec.md (UNSPEC_EXTEVEN, UNSPEC_EXTODD,\n+\tUNSPEC_INTERHI, UNSPEC_INTERLO): New constants.\n+\t(vpkuhum_nomode, vpkuwum_nomode, vec_extract_even<mode>,\n+\tvec_extract_odd<mode>, altivec_vmrghsf, altivec_vmrglsf,\n+\tvec_interleave_high<mode>, vec_interleave_low<mode>): Implement.\n+\n 2006-11-22  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cse.c (enum taken): Remove PATH_AROUND."}, {"sha": "c10615e7315e9265e4020a5e8077c7ea38988944", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 340, "deletions": 1, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -115,6 +115,22 @@\n    (UNSPEC_REALIGN_LOAD 215)\n    (UNSPEC_REDUC_PLUS   217)\n    (UNSPEC_VECSH        219)\n+   (UNSPEC_EXTEVEN_V4SI 220)\n+   (UNSPEC_EXTEVEN_V8HI 221)\n+   (UNSPEC_EXTEVEN_V16QI 222)\n+   (UNSPEC_EXTEVEN_V4SF 223)\n+   (UNSPEC_EXTODD_V4SI  224)\n+   (UNSPEC_EXTODD_V8HI  225)\n+   (UNSPEC_EXTODD_V16QI 226)\n+   (UNSPEC_EXTODD_V4SF  227)\n+   (UNSPEC_INTERHI_V4SI 228)\n+   (UNSPEC_INTERHI_V8HI 229)\n+   (UNSPEC_INTERHI_V16QI 230)\n+   (UNSPEC_INTERHI_V4SF 231)\n+   (UNSPEC_INTERLO_V4SI 232)\n+   (UNSPEC_INTERLO_V8HI 233)\n+   (UNSPEC_INTERLO_V16QI 234)\n+   (UNSPEC_INTERLO_V4SF 235)\n    (UNSPEC_VCOND_V4SI   301)\n    (UNSPEC_VCOND_V4SF   302)\n    (UNSPEC_VCOND_V8HI   303)\n@@ -136,7 +152,9 @@\n    (UNSPEC_VUPKLUH      319)\n    (UNSPEC_VPERMSI\t320)\n    (UNSPEC_VPERMHI\t321)\n-   ])\n+   (UNSPEC_INTERHI      322)\n+   (UNSPEC_INTERLO      323)\n+])\n \n (define_constants\n   [(UNSPECV_SET_VRSAVE   30)\n@@ -855,6 +873,23 @@\n   \"vmrghw %0,%1,%2\"\n   [(set_attr \"type\" \"vecperm\")])\n \n+(define_insn \"altivec_vmrghsf\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+        (vec_merge:V4SF (vec_select:V4SF (match_operand:V4SF 1 \"register_operand\" \"v\")\n+                                         (parallel [(const_int 0)\n+                                                    (const_int 2)\n+                                                    (const_int 1)\n+                                                    (const_int 3)]))\n+                        (vec_select:V4SF (match_operand:V4SF 2 \"register_operand\" \"v\")\n+                                         (parallel [(const_int 2)\n+                                                    (const_int 0)\n+                                                    (const_int 3)\n+                                                    (const_int 1)]))\n+                      (const_int 5)))]\n+  \"TARGET_ALTIVEC\"\n+  \"vmrghw %0,%1,%2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n (define_insn \"altivec_vmrglb\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n         (vec_merge:V16QI (vec_select:V16QI (match_operand:V16QI 1 \"register_operand\" \"v\")\n@@ -938,6 +973,23 @@\n   \"vmrglw %0,%1,%2\"\n   [(set_attr \"type\" \"vecperm\")])\n \n+(define_insn \"altivec_vmrglsf\"\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=v\")\n+        (vec_merge:V4SF (vec_select:V4SF (match_operand:V4SF 1 \"register_operand\" \"v\")\n+                                         (parallel [(const_int 2)\n+                                                    (const_int 0)\n+                                                    (const_int 3)\n+                                                    (const_int 1)]))\n+                        (vec_select:V4SF (match_operand:V4SF 2 \"register_operand\" \"v\")\n+                                         (parallel [(const_int 0)\n+                                                    (const_int 2)\n+                                                    (const_int 1)\n+                                                    (const_int 3)]))\n+                      (const_int 5)))]\n+  \"TARGET_ALTIVEC\"\n+  \"vmrglw %0,%1,%2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n (define_insn \"altivec_vmuleub\"\n   [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n         (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n@@ -2601,3 +2653,290 @@\n     \n   DONE;\n }\")\n+\n+(define_expand \"vec_extract_evenv4si\"\n+ [(set (match_operand:V4SI 0 \"register_operand\" \"\")\n+        (unspec:V8HI [(match_operand:V4SI 1 \"register_operand\" \"\")\n+                      (match_operand:V4SI 2 \"register_operand\" \"\")]\n+\t\t      UNSPEC_EXTEVEN_V4SI))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx mask = gen_reg_rtx (V16QImode);\n+  rtvec v = rtvec_alloc (16);\n+\n+  RTVEC_ELT (v, 0) = gen_rtx_CONST_INT (QImode, 0);\n+  RTVEC_ELT (v, 1) = gen_rtx_CONST_INT (QImode, 1);\n+  RTVEC_ELT (v, 2) = gen_rtx_CONST_INT (QImode, 2);\n+  RTVEC_ELT (v, 3) = gen_rtx_CONST_INT (QImode, 3);\n+  RTVEC_ELT (v, 4) = gen_rtx_CONST_INT (QImode, 8);\n+  RTVEC_ELT (v, 5) = gen_rtx_CONST_INT (QImode, 9);\n+  RTVEC_ELT (v, 6) = gen_rtx_CONST_INT (QImode, 10);\n+  RTVEC_ELT (v, 7) = gen_rtx_CONST_INT (QImode, 11);\n+  RTVEC_ELT (v, 8) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 9) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 10) = gen_rtx_CONST_INT (QImode, 18);\n+  RTVEC_ELT (v, 11) = gen_rtx_CONST_INT (QImode, 19);\n+  RTVEC_ELT (v, 12) = gen_rtx_CONST_INT (QImode, 24);\n+  RTVEC_ELT (v, 13) = gen_rtx_CONST_INT (QImode, 25);\n+  RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, 26);\n+  RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, 27);\n+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_altivec_vperm_v4si (operands[0], operands[1], operands[2], mask));\n+  \n+  DONE;\n+}\")\n+\n+(define_expand \"vec_extract_evenv4sf\"\n+ [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n+        (unspec:V8HI [(match_operand:V4SF 1 \"register_operand\" \"\")\n+                      (match_operand:V4SF 2 \"register_operand\" \"\")]\n+                      UNSPEC_EXTEVEN_V4SF))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx mask = gen_reg_rtx (V16QImode);\n+  rtvec v = rtvec_alloc (16);\n+  \n+  RTVEC_ELT (v, 0) = gen_rtx_CONST_INT (QImode, 0);\n+  RTVEC_ELT (v, 1) = gen_rtx_CONST_INT (QImode, 1);\n+  RTVEC_ELT (v, 2) = gen_rtx_CONST_INT (QImode, 2);\n+  RTVEC_ELT (v, 3) = gen_rtx_CONST_INT (QImode, 3);\n+  RTVEC_ELT (v, 4) = gen_rtx_CONST_INT (QImode, 8);\n+  RTVEC_ELT (v, 5) = gen_rtx_CONST_INT (QImode, 9);\n+  RTVEC_ELT (v, 6) = gen_rtx_CONST_INT (QImode, 10);\n+  RTVEC_ELT (v, 7) = gen_rtx_CONST_INT (QImode, 11);\n+  RTVEC_ELT (v, 8) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 9) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 10) = gen_rtx_CONST_INT (QImode, 18);\n+  RTVEC_ELT (v, 11) = gen_rtx_CONST_INT (QImode, 19);\n+  RTVEC_ELT (v, 12) = gen_rtx_CONST_INT (QImode, 24);\n+  RTVEC_ELT (v, 13) = gen_rtx_CONST_INT (QImode, 25);\n+  RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, 26);\n+  RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, 27);\n+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_altivec_vperm_v4sf (operands[0], operands[1], operands[2], mask));\n+  \n+  DONE;\n+}\")\n+\n+(define_expand \"vec_extract_evenv8hi\"\n+ [(set (match_operand:V4SI 0 \"register_operand\" \"\")\n+        (unspec:V8HI [(match_operand:V8HI 1 \"register_operand\" \"\")\n+                      (match_operand:V8HI 2 \"register_operand\" \"\")]\n+                      UNSPEC_EXTEVEN_V8HI))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx mask = gen_reg_rtx (V16QImode);\n+  rtvec v = rtvec_alloc (16);\n+  \n+  RTVEC_ELT (v, 0) = gen_rtx_CONST_INT (QImode, 0);\n+  RTVEC_ELT (v, 1) = gen_rtx_CONST_INT (QImode, 1);\n+  RTVEC_ELT (v, 2) = gen_rtx_CONST_INT (QImode, 4);\n+  RTVEC_ELT (v, 3) = gen_rtx_CONST_INT (QImode, 5);\n+  RTVEC_ELT (v, 4) = gen_rtx_CONST_INT (QImode, 8);\n+  RTVEC_ELT (v, 5) = gen_rtx_CONST_INT (QImode, 9);\n+  RTVEC_ELT (v, 6) = gen_rtx_CONST_INT (QImode, 12);\n+  RTVEC_ELT (v, 7) = gen_rtx_CONST_INT (QImode, 13);\n+  RTVEC_ELT (v, 8) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 9) = gen_rtx_CONST_INT (QImode, 17);\n+  RTVEC_ELT (v, 10) = gen_rtx_CONST_INT (QImode, 20);\n+  RTVEC_ELT (v, 11) = gen_rtx_CONST_INT (QImode, 21);\n+  RTVEC_ELT (v, 12) = gen_rtx_CONST_INT (QImode, 24);\n+  RTVEC_ELT (v, 13) = gen_rtx_CONST_INT (QImode, 25);\n+  RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, 28);\n+  RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, 29);\n+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_altivec_vperm_v8hi (operands[0], operands[1], operands[2], mask));\n+  \n+  DONE;\n+}\")\n+\n+(define_expand \"vec_extract_evenv16qi\"\n+ [(set (match_operand:V4SI 0 \"register_operand\" \"\")\n+        (unspec:V8HI [(match_operand:V16QI 1 \"register_operand\" \"\")\n+                      (match_operand:V16QI 2 \"register_operand\" \"\")]\n+                      UNSPEC_EXTEVEN_V16QI))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  rtx mask = gen_reg_rtx (V16QImode);\n+  rtvec v = rtvec_alloc (16);\n+  \n+  RTVEC_ELT (v, 0) = gen_rtx_CONST_INT (QImode, 0);\n+  RTVEC_ELT (v, 1) = gen_rtx_CONST_INT (QImode, 2);\n+  RTVEC_ELT (v, 2) = gen_rtx_CONST_INT (QImode, 4);\n+  RTVEC_ELT (v, 3) = gen_rtx_CONST_INT (QImode, 6);\n+  RTVEC_ELT (v, 4) = gen_rtx_CONST_INT (QImode, 8);\n+  RTVEC_ELT (v, 5) = gen_rtx_CONST_INT (QImode, 10);\n+  RTVEC_ELT (v, 6) = gen_rtx_CONST_INT (QImode, 12);\n+  RTVEC_ELT (v, 7) = gen_rtx_CONST_INT (QImode, 14);\n+  RTVEC_ELT (v, 8) = gen_rtx_CONST_INT (QImode, 16);\n+  RTVEC_ELT (v, 9) = gen_rtx_CONST_INT (QImode, 18);\n+  RTVEC_ELT (v, 10) = gen_rtx_CONST_INT (QImode, 20);\n+  RTVEC_ELT (v, 11) = gen_rtx_CONST_INT (QImode, 22);\n+  RTVEC_ELT (v, 12) = gen_rtx_CONST_INT (QImode, 24);\n+  RTVEC_ELT (v, 13) = gen_rtx_CONST_INT (QImode, 26);\n+  RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, 28);\n+  RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, 30);\n+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_altivec_vperm_v16qi (operands[0], operands[1], operands[2], mask));\n+  \n+  DONE;\n+}\")\n+\n+(define_expand \"vec_extract_oddv4si\"\n+ [(set (match_operand:V4SI 0 \"register_operand\" \"\")\n+        (unspec:V8HI [(match_operand:V4SI 1 \"register_operand\" \"\")\n+                      (match_operand:V4SI 2 \"register_operand\" \"\")]\n+                      UNSPEC_EXTODD_V4SI))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx mask = gen_reg_rtx (V16QImode);\n+  rtvec v = rtvec_alloc (16);\n+\n+  RTVEC_ELT (v, 0) = gen_rtx_CONST_INT (QImode, 4);\n+  RTVEC_ELT (v, 1) = gen_rtx_CONST_INT (QImode, 5);\n+  RTVEC_ELT (v, 2) = gen_rtx_CONST_INT (QImode, 6);\n+  RTVEC_ELT (v, 3) = gen_rtx_CONST_INT (QImode, 7);\n+  RTVEC_ELT (v, 4) = gen_rtx_CONST_INT (QImode, 12);\n+  RTVEC_ELT (v, 5) = gen_rtx_CONST_INT (QImode, 13);\n+  RTVEC_ELT (v, 6) = gen_rtx_CONST_INT (QImode, 14);\n+  RTVEC_ELT (v, 7) = gen_rtx_CONST_INT (QImode, 15);\n+  RTVEC_ELT (v, 8) = gen_rtx_CONST_INT (QImode, 20);\n+  RTVEC_ELT (v, 9) = gen_rtx_CONST_INT (QImode, 21);\n+  RTVEC_ELT (v, 10) = gen_rtx_CONST_INT (QImode, 22);\n+  RTVEC_ELT (v, 11) = gen_rtx_CONST_INT (QImode, 23);\n+  RTVEC_ELT (v, 12) = gen_rtx_CONST_INT (QImode, 28);\n+  RTVEC_ELT (v, 13) = gen_rtx_CONST_INT (QImode, 29);\n+  RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, 30);\n+  RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, 31);\n+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_altivec_vperm_v4si (operands[0], operands[1], operands[2], mask));\n+  \n+  DONE;\n+}\")\n+\n+(define_expand \"vec_extract_oddv4sf\"\n+ [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n+        (unspec:V8HI [(match_operand:V4SF 1 \"register_operand\" \"\")\n+                      (match_operand:V4SF 2 \"register_operand\" \"\")]\n+                      UNSPEC_EXTODD_V4SF))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  rtx mask = gen_reg_rtx (V16QImode);\n+  rtvec v = rtvec_alloc (16);\n+\n+  RTVEC_ELT (v, 0) = gen_rtx_CONST_INT (QImode, 4);\n+  RTVEC_ELT (v, 1) = gen_rtx_CONST_INT (QImode, 5);\n+  RTVEC_ELT (v, 2) = gen_rtx_CONST_INT (QImode, 6);\n+  RTVEC_ELT (v, 3) = gen_rtx_CONST_INT (QImode, 7);\n+  RTVEC_ELT (v, 4) = gen_rtx_CONST_INT (QImode, 12);\n+  RTVEC_ELT (v, 5) = gen_rtx_CONST_INT (QImode, 13);\n+  RTVEC_ELT (v, 6) = gen_rtx_CONST_INT (QImode, 14);\n+  RTVEC_ELT (v, 7) = gen_rtx_CONST_INT (QImode, 15);\n+  RTVEC_ELT (v, 8) = gen_rtx_CONST_INT (QImode, 20);\n+  RTVEC_ELT (v, 9) = gen_rtx_CONST_INT (QImode, 21);\n+  RTVEC_ELT (v, 10) = gen_rtx_CONST_INT (QImode, 22);\n+  RTVEC_ELT (v, 11) = gen_rtx_CONST_INT (QImode, 23);\n+  RTVEC_ELT (v, 12) = gen_rtx_CONST_INT (QImode, 28);\n+  RTVEC_ELT (v, 13) = gen_rtx_CONST_INT (QImode, 29);\n+  RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, 30);\n+  RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, 31);\n+  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_altivec_vperm_v4sf (operands[0], operands[1], operands[2], mask));\n+\n+  DONE;\n+}\")\n+\n+(define_insn \"vpkuhum_nomode\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n+        (unspec:V16QI [(match_operand 1 \"register_operand\" \"v\")\n+                       (match_operand 2 \"register_operand\" \"v\")]\n+                      UNSPEC_VPKUHUM))] \n+  \"TARGET_ALTIVEC\"\n+  \"vpkuhum %0,%1,%2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"vpkuwum_nomode\"\n+  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+        (unspec:V8HI [(match_operand 1 \"register_operand\" \"v\")\n+                      (match_operand 2 \"register_operand\" \"v\")]\n+                     UNSPEC_VPKUWUM))]\n+  \"TARGET_ALTIVEC\"\n+  \"vpkuwum %0,%1,%2\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_expand \"vec_extract_oddv8hi\"\n+ [(set (match_operand:V8HI 0 \"register_operand\" \"\")\n+        (unspec:V8HI [(match_operand:V8HI 1 \"register_operand\" \"\")\n+                      (match_operand:V8HI 2 \"register_operand\" \"\")]\n+                      UNSPEC_EXTODD_V8HI))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_vpkuwum_nomode (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_extract_oddv16qi\"\n+ [(set (match_operand:V16QI 0 \"register_operand\" \"\")\n+        (unspec:V16QI [(match_operand:V16QI 1 \"register_operand\" \"\")\n+                      (match_operand:V16QI 2 \"register_operand\" \"\")]\n+                      UNSPEC_EXTODD_V16QI))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_vpkuhum_nomode (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+(define_expand \"vec_interleave_highv4sf\"\n+ [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n+        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"\")\n+                      (match_operand:V4SF 2 \"register_operand\" \"\")]\n+                      UNSPEC_INTERHI_V4SF))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{ \n+  emit_insn (gen_altivec_vmrghsf (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_interleave_lowv4sf\"\n+ [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n+        (unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"\")\n+                      (match_operand:V4SF 2 \"register_operand\" \"\")]\n+                      UNSPEC_INTERLO_V4SF))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_altivec_vmrglsf (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_interleave_high<mode>\"\n+ [(set (match_operand:VI 0 \"register_operand\" \"\")\n+        (unspec:VI [(match_operand:VI 1 \"register_operand\" \"\")\n+                    (match_operand:VI 2 \"register_operand\" \"\")]\n+                     UNSPEC_INTERHI))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_altivec_vmrgh<VI_char> (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"vec_interleave_low<mode>\"\n+ [(set (match_operand:VI 0 \"register_operand\" \"\")\n+        (unspec:VI [(match_operand:VI 1 \"register_operand\" \"\")\n+                    (match_operand:VI 2 \"register_operand\" \"\")]\n+                     UNSPEC_INTERLO))]\n+  \"TARGET_ALTIVEC\"\n+  \"\n+{\n+  emit_insn (gen_altivec_vmrgl<VI_char> (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")"}, {"sha": "b8a4faf0548f901f9559333cd51aaaad108b8adb", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -1936,6 +1936,10 @@ This macro returns the attributes on the type @var{type}.\n @tindex VEC_UNPACK_LO_EXPR\n @tindex VEC_PACK_MOD_EXPR\n @tindex VEC_PACK_SAT_EXPR\n+@tindex VEC_EXTRACT_EVEN_EXPR \n+@tindex VEC_EXTRACT_ODD_EXPR\n+@tindex VEC_INTERLEAVE_HIGH_EXPR\n+@tindex VEC_INTERLEAVE_LOW_EXPR\n \n The internal representation for expressions is for the most part quite\n straightforward.  However, there are a few facts that one must bear in\n@@ -2783,4 +2787,21 @@ elements, of an integral type whose size is half as wide.  In both cases\n the elements of the two vectors are demoted and merged (concatenated) to form\n the output vector.\n \n+@item VEC_EXTRACT_EVEN_EXPR\n+@item VEC_EXTRACT_ODD_EXPR\n+These nodes represent extracting of the even/odd elements of the two input \n+vectors, respectively. Their operands and result are vectors that contain the \n+same number of elements of the same type.\n+\n+@item VEC_INTERLEAVE_HIGH_EXPR\n+@item VEC_INTERLEAVE_LOW_EXPR\n+These nodes represent merging and interleaving of the high/low elements of the\n+two input vectors, respectively. The operands and the result are vectors that \n+contain the same number of elements (@code{N}) of the same type.\n+In the case of @code{VEC_INTERLEAVE_HIGH_EXPR}, the high @code{N/2} elements of \n+the first input vector are interleaved with the high @code{N/2} elements of the\n+second input vector. In the case of @code{VEC_INTERLEAVE_LOW_EXPR}, the low\n+@code{N/2} elements of the first input vector are interleaved with the low \n+@code{N/2} elements of the second input vector.\n+\n @end table"}, {"sha": "9f840b00d1dec3ba42c90a3fd72aac14e06b495c", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -3465,6 +3465,34 @@ operand 1 is new value of field and operand 2 specify the field index.\n Extract given field from the vector value.  Operand 1 is the vector, operand 2\n specify field index and operand 0 place to store value into.\n \n+@cindex @code{vec_extract_even@var{m}} instruction pattern\n+@item @samp{vec_extract_even@var{m}}\n+Extract even elements from the input vectors (operand 1 and operand 2). \n+The even elements of operand 2 are concatenated to the even elements of operand\n+1 in their original order. The result is stored in operand 0. \n+The output and input vectors should have the same modes. \n+\n+@cindex @code{vec_extract_odd@var{m}} instruction pattern\n+@item @samp{vec_extract_odd@var{m}}\n+Extract odd elements from the input vectors (operand 1 and operand 2). \n+The odd elements of operand 2 are concatenated to the odd elements of operand \n+1 in their original order. The result is stored in operand 0.\n+The output and input vectors should have the same modes.\n+\n+@cindex @code{vec_interleave_high@var{m}} instruction pattern\n+@item @samp{vec_interleave_high@var{m}}\n+Merge high elements of the two input vectors into the output vector. The output\n+and input vectors should have the same modes (@code{N} elements). The high\n+@code{N/2} elements of the first input vector are interleaved with the high\n+@code{N/2} elements of the second input vector.\n+\n+@cindex @code{vec_interleave_low@var{m}} instruction pattern\n+@item @samp{vec_interleave_low@var{m}}\n+Merge low elements of the two input vectors into the output vector. The output\n+and input vectors should have the same modes (@code{N} elements). The low\n+@code{N/2} elements of the first input vector are interleaved with the low \n+@code{N/2} elements of the second input vector.\n+\n @cindex @code{vec_init@var{m}} instruction pattern\n @item @samp{vec_init@var{m}}\n Initialize the vector to given values.  Operand 0 is the vector to initialize"}, {"sha": "f3372333cf0ec1e71aeebdb097d9c7102d391be7", "filename": "gcc/expr.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -8745,6 +8745,30 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n         return temp;\n       }\n \n+    case VEC_EXTRACT_EVEN_EXPR:\n+    case VEC_EXTRACT_ODD_EXPR:\n+      {\n+        expand_operands (TREE_OPERAND (exp, 0),  TREE_OPERAND (exp, 1),\n+                         NULL_RTX, &op0, &op1, 0);\n+        this_optab = optab_for_tree_code (code, type);\n+        temp = expand_binop (mode, this_optab, op0, op1, target, unsignedp,\n+                             OPTAB_WIDEN);\n+        gcc_assert (temp);\n+        return temp;\n+      }\n+\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+    case VEC_INTERLEAVE_LOW_EXPR:\n+      {\n+        expand_operands (TREE_OPERAND (exp, 0),  TREE_OPERAND (exp, 1),\n+                         NULL_RTX, &op0, &op1, 0);\n+        this_optab = optab_for_tree_code (code, type);\n+        temp = expand_binop (mode, this_optab, op0, op1, target, unsignedp,\n+                             OPTAB_WIDEN);\n+        gcc_assert (temp);\n+        return temp;\n+      }\n+\n     case VEC_LSHIFT_EXPR:\n     case VEC_RSHIFT_EXPR:\n       {"}, {"sha": "ad72637b90213efb96ab9a9a8ce79c435f9cadfa", "filename": "gcc/genopinit.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -199,6 +199,10 @@ static const char * const optabs[] =\n   \"sync_lock_release[$A] = CODE_FOR_$(sync_lock_release$I$a$)\",\n   \"vec_set_optab->handlers[$A].insn_code = CODE_FOR_$(vec_set$a$)\",\n   \"vec_extract_optab->handlers[$A].insn_code = CODE_FOR_$(vec_extract$a$)\",\n+  \"vec_extract_even_optab->handlers[$A].insn_code = CODE_FOR_$(vec_extract_even$a$)\",\n+  \"vec_extract_odd_optab->handlers[$A].insn_code = CODE_FOR_$(vec_extract_odd$a$)\",\n+  \"vec_interleave_high_optab->handlers[$A].insn_code = CODE_FOR_$(vec_interleave_high$a$)\",\n+  \"vec_interleave_low_optab->handlers[$A].insn_code = CODE_FOR_$(vec_interleave_low$a$)\",\n   \"vec_init_optab->handlers[$A].insn_code = CODE_FOR_$(vec_init$a$)\",\n   \"vec_shl_optab->handlers[$A].insn_code = CODE_FOR_$(vec_shl_$a$)\",\n   \"vec_shr_optab->handlers[$A].insn_code = CODE_FOR_$(vec_shr_$a$)\","}, {"sha": "9a7731d221434b76dc62bc511b929368a92e8900", "filename": "gcc/optabs.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -359,6 +359,18 @@ optab_for_tree_code (enum tree_code code, tree type)\n     case ABS_EXPR:\n       return trapv ? absv_optab : abs_optab;\n \n+    case VEC_EXTRACT_EVEN_EXPR:\n+      return vec_extract_even_optab;\n+\n+    case VEC_EXTRACT_ODD_EXPR:\n+      return vec_extract_odd_optab;\n+\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+      return vec_interleave_high_optab;\n+\n+    case VEC_INTERLEAVE_LOW_EXPR:\n+      return vec_interleave_low_optab;\n+\n     default:\n       return NULL;\n     }\n@@ -5384,6 +5396,10 @@ init_optabs (void)\n   udot_prod_optab = init_optab (UNKNOWN);\n \n   vec_extract_optab = init_optab (UNKNOWN);\n+  vec_extract_even_optab = init_optab (UNKNOWN);\n+  vec_extract_odd_optab = init_optab (UNKNOWN);\n+  vec_interleave_high_optab = init_optab (UNKNOWN);\n+  vec_interleave_low_optab = init_optab (UNKNOWN);\n   vec_set_optab = init_optab (UNKNOWN);\n   vec_init_optab = init_optab (UNKNOWN);\n   vec_shl_optab = init_optab (UNKNOWN);"}, {"sha": "85d9ca7f32f555245c89cedf8dd4a3681c0780a7", "filename": "gcc/optabs.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -27,6 +27,7 @@ Boston, MA 02110-1301, USA.  */\n /* Optabs are tables saying how to generate insn bodies\n    for various machine modes and numbers of operands.\n    Each optab applies to one operation.\n+\n    For example, add_optab applies to addition.\n \n    The insn_code slot is the enum insn_code that says how to\n@@ -253,6 +254,12 @@ enum optab_index\n   OTI_vec_set,\n   /* Extract specified field of vector operand.  */\n   OTI_vec_extract,\n+  /* Extract even/odd fields of vector operands.  */\n+  OTI_vec_extract_even,\n+  OTI_vec_extract_odd,\n+  /* Interleave fields of vector operands.  */\n+  OTI_vec_interleave_high,\n+  OTI_vec_interleave_low,\n   /* Initialize vector operand.  */\n   OTI_vec_init,\n   /* Whole vector shift. The shift amount is in bits.  */\n@@ -397,6 +404,10 @@ extern GTY(()) optab optab_table[OTI_MAX];\n \n #define vec_set_optab (optab_table[OTI_vec_set])\n #define vec_extract_optab (optab_table[OTI_vec_extract])\n+#define vec_extract_even_optab (optab_table[OTI_vec_extract_even])\n+#define vec_extract_odd_optab (optab_table[OTI_vec_extract_odd])\n+#define vec_interleave_high_optab (optab_table[OTI_vec_interleave_high])\n+#define vec_interleave_low_optab (optab_table[OTI_vec_interleave_low])\n #define vec_init_optab (optab_table[OTI_vec_init])\n #define vec_shl_optab (optab_table[OTI_vec_shl])\n #define vec_shr_optab (optab_table[OTI_vec_shr])"}, {"sha": "2e65881667cc0eb90f0f25c8a908566fa0271733", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -1,3 +1,29 @@\n+2006-11-22  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect-1.c: Additional loop is now vectorizable on \n+\tplatforms that have interleaving support.\n+\t* gcc.dg/vect/vect-107.c, gcc.dg/vect/vect-98.c: Likewise.\n+\t* gcc.dg/vect/vect-strided-a-u16-i2.c,\n+\tgcc.dg/vect/vect-strided-a-u16-i4.c, gcc.dg/vect/vect-strided-u16-i2.c,\n+\tgcc.dg/vect/vect-strided-u16-i4.c, gcc.dg/vect/vect-strided-u32-i4.c,\n+\tgcc.dg/vect/vect-strided-u32-i8.c, gcc.dg/vect/vect-strided-u8-i2.c,\n+\tgcc.dg/vect/vect-strided-u8-i2-gap.c,\n+\tgcc.dg/vect/vect-strided-u8-i8.c,\n+\tgcc.dg/vect/vect-strided-u8-i8-gap2.c,\n+\tgcc.dg/vect/vect-strided-u8-i8-gap4.c,\n+\tgcc.dg/vect/vect-strided-u8-i8-gap7.c,\n+\tgcc.dg/vect/vect-strided-float.c,\n+\tgcc.dg/vect/vect-strided-a-mult.c,\n+\tgcc.dg/vect/vect-strided-mult-char-ls.c,\n+\tgcc.dg/vect/vect-strided-a-u16-mult.c,\n+\tgcc.dg/vect/vect-strided-a-u32-mult.c,\n+\tgcc.dg/vect/vect-strided-a-u8-i2-gap.c,\n+\tgcc.dg/vect/vect-strided-a-u8-i8-gap2.c,\n+\tgcc.dg/vect/vect-strided-a-u8-i8-gap7.c,\n+\tgcc.dg/vect/vect-strided-mult.c,\n+\tgcc.dg/vect/vect-strided-u32-mult.c: New testcases.\n+\t* lib/target-supports.exp (vect_extract_even_odd, vect_interleave): New.\n+\n 2006-11-22 Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25087"}, {"sha": "1ec195c5352bd5ef2fc17df0ef1453bcfddd55de", "filename": "gcc/testsuite/gcc.dg/vect/vect-1.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-1.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -59,7 +59,8 @@ foo (int n)\n   fbar (a);\n \n \n-  /* Not vectorizable yet (access pattern).  */\n+  /* Strided access. Vectorizable on platforms that support load of strided \n+     accesses (extract of even/odd vector elements).  */\n   for (i = 0; i < N/2; i++){\n     a[i] = b[2*i+1] * c[2*i+1] - b[2*i] * c[2*i];\n     d[i] = b[2*i] * c[2*i+1] + b[2*i+1] * c[2*i];\n@@ -85,6 +86,6 @@ foo (int n)\n   fbar (a);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" { target vect_extract_even_odd } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail vect_extract_even_odd } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e4f823f310d22055ad4a8125b895a0b618058924", "filename": "gcc/testsuite/gcc.dg/vect/vect-107.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-107.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-107.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-107.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -14,7 +14,8 @@ main1 (void)\n   float c[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n   float d[N] = {0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30};\n \n-  /* Strided access pattern.  */\n+  /* Strided access. Vectorizable on platforms that support load of strided \n+     accesses (extract of even/odd vector elements).  */\n   for (i = 0; i < N/2; i++)\n     {\n       a[i] = b[2*i+1] * c[2*i+1] - b[2*i] * c[2*i];\n@@ -38,5 +39,6 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_extract_even_odd } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { xfail vect_extract_even_odd } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "56437e26d82027a342561425a718ee2fbf922a4c", "filename": "gcc/testsuite/gcc.dg/vect/vect-98.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-98.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-98.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-98.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -36,6 +36,7 @@ int main (void)\n   return main1 (ia);\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"not vectorized: complicated access pattern\" 1 \"vect\" } } */\n+/* Needs interleaving support.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { xfail  { vect_interleave && vect_extract_even_odd } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f269c9d80759248dcefef04ffc502cb01c5d3525", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-a-mult.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-mult.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-mult.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-mult.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+typedef struct {\n+   unsigned short a;\n+   unsigned short b;\n+} s;\n+\n+typedef struct {\n+   unsigned int a;\n+   unsigned int b;\n+} ii;\n+\n+int\n+main1 ()\n+{\n+  s arr[N];\n+  s *ptr = arr;\n+  ii iarr[N];\n+  ii *iptr = iarr;\n+  s res[N];\n+  ii ires[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      iarr[i].a = i;\n+      iarr[i].b = i * 3;\n+      if (arr[i].a == 178)\n+         abort();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ires[i].a = iptr->b - iptr->a;\n+      ires[i].b = iptr->b + iptr->a;\n+      res[i].b = ptr->b - ptr->a;\n+      res[i].a = ptr->b + ptr->a;\n+      iptr++;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].b != arr[i].b - arr[i].a\n+          || ires[i].a != iarr[i].b - iarr[i].a\n+          || res[i].a != arr[i].b + arr[i].a\n+          || ires[i].b != iarr[i].b +  iarr[i].a\n+)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}   \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "6cc62b47f34b1c4a154e815b1e91215c272dba3c", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-a-u16-i2.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-i2.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   unsigned short a;\n+   unsigned short b;\n+} s;\n+\n+int\n+main1 ()\n+{\n+  s arr[N];\n+  s *ptr = arr;\n+  s res[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      if (arr[i].a == 178)\n+         abort();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].a = ptr->b - ptr->a;\n+      res[i].b = ptr->b + ptr->a;\n+      ptr++;\n+    }\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].a != arr[i].b - arr[i].a\n+          || res[i].b != arr[i].a + arr[i].b)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  \n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "140f963e2ab6769b2acf299cbab346d106e42dc5", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-a-u16-i4.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-i4.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   unsigned short a;\n+   unsigned short b;\n+   unsigned short c;\n+   unsigned short d;\n+} s;\n+\n+int\n+main1 ()\n+{\n+  s arr[N];\n+  s *ptr = arr;\n+  s res[N];\n+  int i;\n+  unsigned short x, y, z, w;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      if (arr[i].a == 178)\n+         abort();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      x = ptr->b - ptr->a;\n+      y = ptr->d - ptr->c;\n+      res[i].c = x + y;\n+      z =  ptr->a + ptr->c;\n+      w = ptr->b + ptr->d;\n+      res[i].a = z + w;\n+      res[i].d = x + y;\n+      res[i].b = x + y;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].c != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].a != arr[i].a + arr[i].c + arr[i].b + arr[i].d\n+          || res[i].d != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].b != arr[i].b - arr[i].a + arr[i].d - arr[i].c)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  \n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "5d45bf84c9de7ea0ba310879e81366eae68cdcda", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-a-u16-mult.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-mult.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-mult.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-mult.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+typedef struct {\n+   unsigned short a;\n+   unsigned short b;\n+} s;\n+\n+int\n+main1 ()\n+{\n+  s arr[N];\n+  s *ptr = arr;\n+  unsigned int iarr[N];\n+  unsigned int *iptr = iarr;\n+  s res[N];\n+  unsigned int ires[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      iarr[i] = i * 3;\n+      if (arr[i].a == 178)\n+         abort();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ires[i] = *iptr;\n+      res[i].b = ptr->b - ptr->a;\n+      res[i].a = ptr->b + ptr->a;\n+      iptr++;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].b != arr[i].b - arr[i].a\n+          || ires[i] != iarr[i]\n+          || res[i].a != arr[i].b + arr[i].a)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "0fd0fdbd5bc8b1fe2488592ac6f8c01413a32a6a", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-a-u32-mult.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u32-mult.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u32-mult.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u32-mult.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+typedef struct {\n+   unsigned int a;\n+   unsigned int b;\n+} ii;\n+\n+int\n+main1 ()\n+{\n+  unsigned short arr[N];\n+  unsigned short *ptr = arr;\n+  ii iarr[N];\n+  ii *iptr = iarr;\n+  unsigned short res[N];\n+  ii ires[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i] = i;\n+      iarr[i].a = i;\n+      iarr[i].b = i * 3;\n+      if (arr[i] == 178)\n+         abort();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ires[i].a = iptr->b - iptr->a;\n+      ires[i].b = iptr->b + iptr->a;\n+      res[i] = *ptr;\n+      iptr++;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i] != arr[i]\n+          || ires[i].a != iarr[i].b - iarr[i].a\n+          || ires[i].b != iarr[i].b +  iarr[i].a)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "671b7d2b6db804cac73a63265905dfb5c5350985", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i2-gap.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u8-i2-gap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u8-i2-gap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u8-i2-gap.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+} s;\n+\n+int\n+main1 ()\n+{\n+  s arr[N];\n+  s *ptr = arr;\n+  s res[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      if (arr[i].a == 178)\n+         abort();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].a = ptr->a;\n+      res[i].b = ptr->a;\n+      ptr++;\n+    }\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].a != arr[i].a\n+          || res[i].b != arr[i].a)\n+\tabort ();\n+    }\n+\n+  ptr = arr;\n+  /* Not vectorizable: gap in store.  */ \n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].a = ptr->b;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].a != arr[i].b)\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "ce567955ae56a3f9c4a56047f7e3f5804601a1fa", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i8-gap2.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u8-i8-gap2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u8-i8-gap2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u8-i8-gap2.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+   unsigned char c;\n+   unsigned char d;\n+   unsigned char e;\n+   unsigned char f;\n+   unsigned char g;\n+   unsigned char h;\n+} s;\n+\n+int\n+main1 ()\n+{\n+  int i;\n+  s arr[N];\n+  s *ptr = arr;\n+  s res[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      arr[i].e = i + 5;\n+      arr[i].f = i * 2 + 2;\n+      arr[i].g = i - 3;\n+      arr[i].h = 56;\n+      if (arr[i].a == 178)\n+         abort();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].c = ptr->a;\n+      res[i].a = ptr->f + ptr->a;\n+      res[i].d = ptr->f - ptr->a;\n+      res[i].b = ptr->f;\n+      res[i].f = ptr->a;\n+      res[i].e = ptr->f - ptr->a; \n+      res[i].h = ptr->f;   \n+      res[i].g = ptr->f - ptr->a;\n+      ptr++; \n+    } \n+   \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (res[i].c != arr[i].a\n+          || res[i].a != arr[i].f + arr[i].a\n+          || res[i].d != arr[i].f - arr[i].a\n+          || res[i].b != arr[i].f\n+          || res[i].f != arr[i].a\n+          || res[i].e != arr[i].f - arr[i].a\n+          || res[i].h != arr[i].f\n+          || res[i].g != arr[i].f - arr[i].a)\n+          abort();\n+   }\n+}\n+\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "740d0568dce19c1670584786de26caf0f0a2cfac", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-a-u8-i8-gap7.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u8-i8-gap7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u8-i8-gap7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u8-i8-gap7.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+   unsigned char c;\n+   unsigned char d;\n+   unsigned char e;\n+   unsigned char f;\n+   unsigned char g;\n+   unsigned char h;\n+} s;\n+\n+int\n+main1 ()\n+{\n+  int i;\n+  s arr[N];\n+  s *ptr = arr;\n+  s res[N];\n+  unsigned char u, t, s, x, y, z, w;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      arr[i].e = i * 3 + 5;\n+      arr[i].f = i * 5;\n+      arr[i].g = i - 3;\n+      arr[i].h = 67;\n+      if (arr[i].a == 178)\n+         abort();\n+    }\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      u = ptr->b - ptr->a;\n+      t = ptr->d - ptr->c;\n+      res[i].c = u + t;\n+      x = ptr->b + ptr->d;\n+      res[i].a = ptr->a + x;\n+      res[i].d = u + t;\n+      s = ptr->h - ptr->a;\n+      res[i].b = s + t;\n+      res[i].f = ptr->f + ptr->h;\n+      res[i].e = ptr->b + ptr->e;\n+      res[i].h = ptr->d;\n+      res[i].g = u + t;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (res[i].c != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].a != arr[i].a + arr[i].b + arr[i].d\n+          || res[i].d != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].b != arr[i].h - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].f != arr[i].f + arr[i].h\n+          || res[i].e != arr[i].b + arr[i].e\n+          || res[i].h != arr[i].d\n+          || res[i].g != arr[i].b - arr[i].a + arr[i].d - arr[i].c)\n+         abort();\n+   }\n+}\n+\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "f2e4484563b38ef886b9a3299c95ff1bad38668b", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-float.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-float.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+int\n+main1 (void)\n+{\n+  int i;\n+  float a[N*2];\n+  float b[N*2] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93};\n+  float c[N*2] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};\n+\n+  /* Strided access pattern.  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      a[i*2] = b[2*i+1] * c[2*i+1] - b[2*i] * c[2*i];\n+      a[i*2+1] = b[2*i+8] * c[2*i+9] + b[2*i+9] * c[2*i+8];\n+    }\n+\n+  /* Check results.  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (a[i*2] != b[2*i+1] * c[2*i+1] - b[2*i] * c[2*i]\n+\t  || a[i*2+1] != b[2*i+8] * c[2*i+9] + b[2*i+9] * c[2*i+8])\n+\tabort();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+  return main1 ();\n+}\n+\n+/* Needs interleaving support.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { xfail { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "29d752d3c550fd58c2fefb4fbebcbf66abaebaa7", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-mult-char-ls.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-mult-char-ls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-mult-char-ls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-mult-char-ls.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+} s;\n+\n+typedef struct {\n+   unsigned int a;\n+   unsigned int b;\n+} ii;\n+\n+int\n+main1 (s *arr, ii *iarr)\n+{\n+  s *ptr = arr;\n+  ii *iptr = iarr;\n+  s res[N];\n+  ii ires[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ires[i].a = iptr->b;\n+      ires[i].b = iptr->a;\n+      res[i].b = ptr->b - ptr->a;\n+      res[i].a = ptr->b + ptr->a;\n+      iptr++;\n+      ptr++;\n+    }\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].b != arr[i].b - arr[i].a \n+          || ires[i].a != iarr[i].b\n+          || res[i].a != arr[i].b + arr[i].a\n+          || ires[i].b != iarr[i].a\n+)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  ii iarr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      iarr[i].a = i;\n+      iarr[i].b = i * 3;\n+      if (arr[i].a == 178)\n+         abort();\n+    }\n+\n+  main1 (arr, iarr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "823444ebeb471e8be39dca614c916b11ab5beb98", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-mult.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-mult.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-mult.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-mult.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+typedef struct {\n+   unsigned short a;\n+   unsigned short b;\n+} s;\n+\n+typedef struct {\n+   unsigned int a;\n+   unsigned int b;\n+} ii;\n+\n+int\n+main1 (s *arr, ii *iarr)\n+{\n+  s *ptr = arr;\n+  ii *iptr = iarr;\n+  s res[N];\n+  ii ires[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ires[i].a = iptr->b - iptr->a;\n+      ires[i].b = iptr->b + iptr->a;\n+      res[i].b = ptr->b - ptr->a;\n+      res[i].a = ptr->b + ptr->a;\n+      iptr++;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].b != arr[i].b - arr[i].a\n+          || ires[i].a != iarr[i].b - iarr[i].a\n+          || res[i].a != arr[i].b + arr[i].a\n+          || ires[i].b != iarr[i].b +  iarr[i].a\n+)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  ii iarr[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      iarr[i].a = i;\n+      iarr[i].b = i * 3;\n+      if (arr[i].a == 178)\n+         abort();\n+    }\n+\n+  main1 (arr, iarr); \n+  \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "3c76410f3e0b7177521ecb3649e37d3c6ec7add2", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u16-i2.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u16-i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u16-i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u16-i2.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   unsigned short a;\n+   unsigned short b;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  s *ptr = arr;\n+  s res[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].a = ptr->b - ptr->a;\n+      res[i].b = ptr->b + ptr->a;\n+      ptr++;\n+    }\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].a != arr[i].b - arr[i].a\n+          || res[i].b != arr[i].a + arr[i].b)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "199e3633c7721858962aa950341ad1fb9ac7f427", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u16-i4.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u16-i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u16-i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u16-i4.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   unsigned short a;\n+   unsigned short b;\n+   unsigned short c;\n+   unsigned short d;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+  unsigned short x, y, z, w;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      x = ptr->b - ptr->a;\n+      y = ptr->d - ptr->c;\n+      res[i].c = x + y;\n+      z =  ptr->a + ptr->c;\n+      w = ptr->b + ptr->d;\n+      res[i].a = z + w;\n+      res[i].d = x + y;\n+      res[i].b = x + y;\n+      ptr++;\n+    }\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].c != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].a != arr[i].a + arr[i].c + arr[i].b + arr[i].d\n+          || res[i].d != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].b != arr[i].b - arr[i].a + arr[i].d - arr[i].c)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "e872b97571a056d368cc7d088bfcee985200ef3c", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u32-i4.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u32-i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u32-i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u32-i4.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   int a;\n+   int b;\n+   int c;\n+   int d;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].c = ptr->b - ptr->a + ptr->d - ptr->c;\n+      res[i].a = ptr->a + ptr->c + ptr->b + ptr->d;\n+      res[i].d = ptr->b - ptr->a + ptr->d - ptr->c;\n+      res[i].b = ptr->b - ptr->a + ptr->d - ptr->c;\n+      ptr++;\n+    }\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].c != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].a != arr[i].a + arr[i].c + arr[i].b + arr[i].d\n+          || res[i].d != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].b != arr[i].b - arr[i].a + arr[i].d - arr[i].c)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "7e8888f128c3a8bab625debd1f3e307d091fec5b", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u32-i8.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u32-i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u32-i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u32-i8.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   int a;\n+   int b;\n+   int c;\n+   int d;\n+   int e;\n+   int f;\n+   int g;\n+   int h;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].c = ptr->b - ptr->a + ptr->d - ptr->c;\n+      res[i].a = ptr->a + ptr->g + ptr->b + ptr->d;\n+      res[i].d = ptr->b - ptr->a + ptr->d - ptr->c;\n+      res[i].b = ptr->h - ptr->a + ptr->d - ptr->c;\n+      res[i].f = ptr->f + ptr->h;\n+      res[i].e = ptr->b - ptr->e; \n+      res[i].h = ptr->d - ptr->g;   \n+      res[i].g = ptr->b - ptr->a + ptr->d - ptr->c;\n+      ptr++; \n+    } \n+   \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (res[i].c != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].a != arr[i].a + arr[i].g + arr[i].b + arr[i].d\n+          || res[i].d != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].b != arr[i].h - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].f != arr[i].f + arr[i].h\n+          || res[i].e != arr[i].b - arr[i].e\n+          || res[i].h != arr[i].d - arr[i].g\n+          || res[i].g != arr[i].b - arr[i].a + arr[i].d - arr[i].c)\n+         abort();\n+    }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      arr[i].e = i * 3 + 5;\n+      arr[i].f = i * 5;\n+      arr[i].g = i - 3;\n+      arr[i].h = 56;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "188bef86f98e919fd673dc11e2bad0c375c1d481", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u32-mult.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u32-mult.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u32-mult.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u32-mult.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+typedef struct {\n+   unsigned int a;\n+   unsigned int b;\n+} ii;\n+\n+int\n+main1 (unsigned short *arr, ii *iarr)\n+{\n+  unsigned short *ptr = arr;\n+  ii *iptr = iarr;\n+  unsigned short res[N];\n+  ii ires[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      ires[i].a = iptr->b - iptr->a;\n+      ires[i].b = iptr->b + iptr->a;\n+      res[i] = *ptr;\n+      iptr++;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i] != arr[i]\n+          || ires[i].a != iarr[i].b - iarr[i].a\n+          || ires[i].b != iarr[i].b +  iarr[i].a)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  unsigned short arr[N];\n+  ii iarr[N];\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      arr[i] = i;\n+      iarr[i].a = i;\n+      iarr[i].b = i * 3;\n+      if (arr[i] == 178)\n+         abort();\n+    }\n+  main1 (arr, iarr); \n+    \n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "86e86158e0cf3d0490015055e3a0ce7efbde53eb", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u8-i2-gap.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i2-gap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i2-gap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i2-gap.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  s *ptr = arr;\n+  s res[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].a = ptr->b;\n+      res[i].b = ptr->b;\n+      ptr++;\n+    }\n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].a != arr[i].b\n+          || res[i].b != arr[i].b)\n+\tabort ();\n+    }\n+\n+  ptr = arr;\n+  /* Not vectorizable: gap in store.  */ \n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].a = ptr->b;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].a != arr[i].b)\n+        abort ();\n+    }\n+\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "b9dcbba6b6b93c1b2a0c03a05bd532c9a7df7d21", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u8-i2.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i2.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 64\n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  s *ptr = arr;\n+  s res[N];\n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].a = ptr->b - ptr->a;\n+      res[i].b = ptr->b + ptr->a;\n+      ptr++;\n+    }\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (res[i].a != arr[i].b - arr[i].a\n+          || res[i].b != arr[i].a + arr[i].b)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+   "}, {"sha": "8827ee101789cd1f7415081c8184e8284fc03d4c", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap2.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap2.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+   unsigned char c;\n+   unsigned char d;\n+   unsigned char e;\n+   unsigned char f;\n+   unsigned char g;\n+   unsigned char h;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].c = ptr->b;\n+      res[i].a = ptr->f + ptr->b;\n+      res[i].d = ptr->f - ptr->b;\n+      res[i].b = ptr->f;\n+      res[i].f = ptr->b;\n+      res[i].e = ptr->f - ptr->b; \n+      res[i].h = ptr->f;   \n+      res[i].g = ptr->f - ptr->b;\n+      ptr++; \n+    } \n+   \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (res[i].c != arr[i].b\n+          || res[i].a != arr[i].f + arr[i].b\n+          || res[i].d != arr[i].f - arr[i].b\n+          || res[i].b != arr[i].f\n+          || res[i].f != arr[i].b\n+          || res[i].e != arr[i].f - arr[i].b\n+          || res[i].h != arr[i].f\n+          || res[i].g != arr[i].f - arr[i].b)\n+          abort();\n+   }\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      arr[i].e = i + 5;\n+      arr[i].f = i * 2 + 2;\n+      arr[i].g = i - 3;\n+      arr[i].h = 56;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "c176b3264f4c3d7289f2cc863155947b9bac6d1e", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap4.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,85 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+   unsigned char c;\n+   unsigned char d;\n+   unsigned char e;\n+   unsigned char f;\n+   unsigned char g;\n+   unsigned char h;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+  unsigned char x;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      res[i].c = ptr->b + ptr->c;\n+      x = ptr->c + ptr->f;\n+      res[i].a = x + ptr->b;\n+      res[i].d = ptr->b + ptr->c;\n+      res[i].b = ptr->c;\n+      res[i].f = ptr->f + ptr->e;\n+      res[i].e = ptr->b + ptr->e; \n+      res[i].h = ptr->c;   \n+      res[i].g = ptr->b + ptr->c;\n+      ptr++; \n+    } \n+   \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (res[i].c != arr[i].b + arr[i].c\n+          || res[i].a != arr[i].c + arr[i].f + arr[i].b\n+          || res[i].d != arr[i].b + arr[i].c\n+          || res[i].b != arr[i].c\n+          || res[i].f != arr[i].f + arr[i].e\n+          || res[i].e != arr[i].b + arr[i].e\n+          || res[i].h != arr[i].c\n+          || res[i].g != arr[i].b + arr[i].c)\n+          abort();\n+   }\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      arr[i].e = i * 3 + 5;\n+      arr[i].f = i * 5;\n+      arr[i].g = i - 3;\n+      arr[i].h = 56;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "317fe039f6c9160be2ae31f941a80b233e40e6fa", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap7.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap7.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+   unsigned char c;\n+   unsigned char d;\n+   unsigned char e;\n+   unsigned char f;\n+   unsigned char g;\n+   unsigned char h;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+  unsigned char u, t, s, x, y, z, w;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      u = ptr->b - ptr->a;\n+      t = ptr->d - ptr->c;\n+      res[i].c = u + t;\n+      x = ptr->b + ptr->d;\n+      res[i].a = ptr->a + x;\n+      res[i].d = u + t;\n+      s = ptr->h - ptr->a;\n+      res[i].b = s + t;\n+      res[i].f = ptr->f + ptr->h;\n+      res[i].e = ptr->b + ptr->e;\n+      res[i].h = ptr->d;\n+      res[i].g = u + t;\n+      ptr++;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (res[i].c != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].a != arr[i].a + arr[i].b + arr[i].d\n+          || res[i].d != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].b != arr[i].h - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].f != arr[i].f + arr[i].h\n+          || res[i].e != arr[i].b + arr[i].e\n+          || res[i].h != arr[i].d\n+          || res[i].g != arr[i].b - arr[i].a + arr[i].d - arr[i].c)\n+         abort();\n+   }\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      arr[i].e = i * 3 + 5;\n+      arr[i].f = i * 5;\n+      arr[i].g = i - 3;\n+      arr[i].h = 67;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "77a67e0dcfc76d2e05132d9db92c23c36dabeb49", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 32 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+   unsigned char c;\n+   unsigned char d;\n+   unsigned char e;\n+   unsigned char f;\n+   unsigned char g;\n+   unsigned char h;\n+} s;\n+\n+int\n+main1 (s *arr)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+  unsigned char u, t, s, x, y, z, w;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      u = ptr->b - ptr->a;\n+      t = ptr->d - ptr->c;\n+      res[i].c = u + t;\n+      s =  ptr->a + ptr->g;\n+      x = ptr->b + ptr->d;\n+      res[i].a = s + x;\n+      res[i].d = u + t;\n+      s = ptr->h - ptr->a;\n+      x = ptr->d - ptr->c;\n+      res[i].b = s + x;\n+      res[i].f = ptr->f + ptr->h;\n+      res[i].e = ptr->b + ptr->e; \n+      res[i].h = ptr->d - ptr->g;   \n+      res[i].g = u + t;\n+      ptr++; \n+    } \n+   \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    { \n+      if (res[i].c != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].a != arr[i].a + arr[i].g + arr[i].b + arr[i].d\n+          || res[i].d != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].b != arr[i].h - arr[i].a + arr[i].d - arr[i].c\n+          || res[i].f != arr[i].f + arr[i].h\n+          || res[i].e != arr[i].b + arr[i].e\n+          || res[i].h != arr[i].d - arr[i].g\n+          || res[i].g != arr[i].b - arr[i].a + arr[i].d - arr[i].c\n+       )\n+          abort();\n+   }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = i;\n+      arr[i].b = i * 2;\n+      arr[i].c = 17;\n+      arr[i].d = i+34;\n+      arr[i].e = i;\n+      arr[i].f = i + 5;\n+      arr[i].g = i + 3;\n+      arr[i].h = 67;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "e52139db9f969392113d1caae2777d04bdc8164a", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -1841,6 +1841,44 @@ proc check_effective_target_vect_int_mult { } {\n     return $et_vect_int_mult_saved\n }\n \n+# Return 1 if the target supports vector even/odd elements extraction, 0 otherwise.\n+\n+proc check_effective_target_vect_extract_even_odd { } {\n+    global et_vect_extract_even_odd_saved\n+    \n+    if [info exists et_vect_extract_even_odd_saved] {\n+        verbose \"check_effective_target_vect_extract_even_odd: using cached result\" 2\n+    } else {\n+        set et_vect_extract_even_odd_saved 0 \n+        if { [istarget powerpc*-*-*] } {\n+           set et_vect_extract_even_odd_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_vect_extract_even_odd: returning $et_vect_extract_even_odd_saved\" 2\n+    return $et_vect_extract_even_odd_saved\n+}\n+\n+# Return 1 if the target supports vector interleaving, 0 otherwise.\n+\n+proc check_effective_target_vect_interleave { } {\n+    global et_vect_interleave_saved\n+    \n+    if [info exists et_vect_interleave_saved] {\n+        verbose \"check_effective_target_vect_interleave: using cached result\" 2\n+    } else {\n+        set et_vect_interleave_saved 0\n+        if { [istarget powerpc*-*-*]\n+             || [istarget i?86-*-*]\n+             || [istarget x86_64-*-*] } {\n+           set et_vect_interleave_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_vect_interleave: returning $et_vect_interleave_saved\" 2\n+    return $et_vect_interleave_saved\n+}\n+\n # Return 1 if the target supports section-anchors\n \n proc check_effective_target_section_anchors { } {"}, {"sha": "d80be31e3d0610a26ae5a65baa47981b45cfb486", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -24,25 +24,27 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"lambda.h\"\n \n-/** {base_address + offset + init} is the first location accessed by data-ref \n-      in the loop, and step is the stride of data-ref in the loop in bytes;\n-      e.g.:\n-    \n+/*\n+  The first location accessed by data-ref in the loop is the address of data-ref's \n+  base (BASE_ADDRESS) plus the initial offset from the base. We divide the initial offset \n+  into two parts: loop invariant offset (OFFSET) and constant offset (INIT). \n+  STEP is the stride of data-ref in the loop in bytes.\n+\n                        Example 1                      Example 2\n       data-ref         a[j].b[i][j]                   a + x + 16B (a is int*)\n       \n-First location info:\n+  First location info:\n       base_address     &a                             a\n-      offset           j_0*D_j + i_0*D_i + C_a        x\n-      init             C_b                            16\n+      offset           j_0*D_j + i_0*D_i              x\n+      init             C_b + C_a                      16\n       step             D_j                            4\n       access_fn        NULL                           {16, +, 1}\n \n-Base object info:\n+  Base object info:\n       base_object      a                              NULL\n       access_fn        <access_fns of indexes of b>   NULL\n \n-  **/\n+  */\n struct first_location_in_loop\n {\n   tree base_address;\n@@ -51,7 +53,6 @@ struct first_location_in_loop\n   tree step;\n   /* Access function related to first location in the loop.  */\n   VEC(tree,heap) *access_fns;\n-\n };\n \n struct base_object_info\n@@ -97,10 +98,39 @@ struct data_reference\n   struct ptr_info_def *ptr_info;\n   subvar_t subvars;\n \n-  /* Alignment information.  */ \n-  /* The offset of the data-reference from its base in bytes.  */\n+  /* Alignment information.  \n+     MISALIGNMENT is the offset of the data-reference from its base in bytes.\n+     ALIGNED_TO is the maximum data-ref's alignment.  \n+\n+     Example 1, \n+       for i\n+          for (j = 3; j < N; j++)\n+            a[j].b[i][j] = 0;\n+\t \n+     For a[j].b[i][j], the offset from base (calculated in get_inner_reference() \n+     will be 'i * C_i + j * C_j + C'. \n+     We try to substitute the variables of the offset expression\n+     with initial_condition of the corresponding access_fn in the loop.\n+     'i' cannot be substituted, since its access_fn in the inner loop is i. 'j' \n+     will be substituted with 3. \n+\n+     Example 2\n+        for (j = 3; j < N; j++)\n+          a[j].b[5][j] = 0; \n+\n+     Here the offset expression (j * C_j + C) will not contain variables after\n+     subsitution of j=3 (3*C_j + C).\n+\n+     Misalignment can be calculated only if all the variables can be \n+     substituted with constants, otherwise, we record maximum possible alignment\n+     in ALIGNED_TO. In Example 1, since 'i' cannot be substituted, \n+     MISALIGNMENT will be NULL_TREE, and the biggest divider of C_i (a power of \n+     2) will be recorded in ALIGNED_TO.\n+\n+     In Example 2, MISALIGNMENT will be the value of 3*C_j + C in bytes, and \n+     ALIGNED_TO will be NULL_TREE.\n+  */\n   tree misalignment;\n-  /* The maximum data-ref's alignment.  */\n   tree aligned_to;\n \n   /* The type of the data-ref.  */"}, {"sha": "ad8a8bc6301c2b7c69326cd4d0077eaef3fd7e2e", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -1771,6 +1771,11 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n \n     case WIDEN_MULT_EXPR:\n \n+    case VEC_EXTRACT_EVEN_EXPR:\n+    case VEC_EXTRACT_ODD_EXPR:\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+    case VEC_INTERLEAVE_LOW_EXPR:\n+\n     case RESX_EXPR:\n       *count += 1;\n       break;"}, {"sha": "d33d8315adae0130c48def3129903279ae80e839", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -1957,6 +1957,38 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       }\n     break;\n \n+    case VEC_EXTRACT_EVEN_EXPR:\n+      pp_string (buffer, \" VEC_EXTRACT_EVEN_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+  \n+    case VEC_EXTRACT_ODD_EXPR:\n+      pp_string (buffer, \" VEC_EXTRACT_ODD_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+      pp_string (buffer, \" VEC_INTERLEAVE_HIGH_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case VEC_INTERLEAVE_LOW_EXPR:\n+      pp_string (buffer, \" VEC_INTERLEAVE_LOW_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n     default:\n       NIY;\n     }"}, {"sha": "4ea7b15dde588e340471ee4720c8b030c81e7889", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 585, "deletions": 24, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -38,6 +38,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-vectorizer.h\"\n+#include \"toplev.h\"\n \n /* Main analysis functions.  */\n static loop_vec_info vect_analyze_loop_form (struct loop *);\n@@ -56,13 +57,12 @@ static bool vect_determine_vectorization_factor (loop_vec_info);\n static bool exist_non_indexing_operands_for_use_p (tree, tree);\n static tree vect_get_loop_niters (struct loop *, tree *);\n static bool vect_analyze_data_ref_dependence\n-  (struct data_dependence_relation *, loop_vec_info);\n+  (struct data_dependence_relation *, loop_vec_info, bool);\n static bool vect_compute_data_ref_alignment (struct data_reference *); \n static bool vect_analyze_data_ref_access (struct data_reference *);\n static bool vect_can_advance_ivs_p (loop_vec_info);\n static void vect_update_misalignment_for_peel\n   (struct data_reference *, struct data_reference *, int npeel);\n- \n \n /* Function vect_determine_vectorization_factor\n \n@@ -185,9 +185,10 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"nunits = %d\", nunits);\n \n-\t  if (!vectorization_factor\n-              || (nunits > vectorization_factor))\n-            vectorization_factor = nunits;\n+          if (!vectorization_factor\n+\t      || (nunits > vectorization_factor))\n+\t    vectorization_factor = nunits;\n+\n         }\n     }\n \n@@ -559,14 +560,304 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n }\n \n \n+/* Function vect_insert_into_interleaving_chain.\n+\n+   Insert DRA into the interleaving chain of DRB according to DRA's INIT.  */\n+\n+static void\n+vect_insert_into_interleaving_chain (struct data_reference *dra,\n+\t\t\t\t     struct data_reference *drb)\n+{\n+  tree prev, next, next_init;\n+  stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra)); \n+  stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n+\n+  prev = DR_GROUP_FIRST_DR (stmtinfo_b);\n+  next = DR_GROUP_NEXT_DR (vinfo_for_stmt (prev));\t\t  \n+  while (next)\n+    {\n+      next_init = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n+      if (tree_int_cst_compare (next_init, DR_INIT (dra)) > 0)\n+\t{\n+\t  /* Insert here.  */\n+\t  DR_GROUP_NEXT_DR (vinfo_for_stmt (prev)) = DR_STMT (dra);\n+\t  DR_GROUP_NEXT_DR (stmtinfo_a) = next;\n+\t  return;\n+\t}\n+      prev = next;\n+      next = DR_GROUP_NEXT_DR (vinfo_for_stmt (prev));\n+    }\n+\n+  /* We got to the end of the list. Insert here.  */\n+  DR_GROUP_NEXT_DR (vinfo_for_stmt (prev)) = DR_STMT (dra);\n+  DR_GROUP_NEXT_DR (stmtinfo_a) = NULL_TREE;\n+}\n+\n+\n+/* Function vect_update_interleaving_chain.\n+   \n+   For two data-refs DRA and DRB that are a part of a chain interleaved data \n+   accesses, update the interleaving chain. DRB's INIT is smaller than DRA's.\n+\n+   There are four possible cases:\n+   1. New stmts - both DRA and DRB are not a part of any chain:\n+      FIRST_DR = DRB\n+      NEXT_DR (DRB) = DRA\n+   2. DRB is a part of a chain and DRA is not:\n+      no need to update FIRST_DR\n+      no need to insert DRB\n+      insert DRA according to init\n+   3. DRA is a part of a chain and DRB is not:\n+      if (init of FIRST_DR > init of DRB)\n+          FIRST_DR = DRB\n+\t  NEXT(FIRST_DR) = previous FIRST_DR\n+      else\n+          insert DRB according to its init\n+   4. both DRA and DRB are in some interleaving chains:\n+      choose the chain with the smallest init of FIRST_DR\n+      insert the nodes of the second chain into the first one.  */\n+\n+static void\n+vect_update_interleaving_chain (struct data_reference *drb,\n+\t\t\t\tstruct data_reference *dra)\n+{\n+  stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra)); \n+  stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n+  tree next_init, init_dra_chain, init_drb_chain, first_a, first_b;\n+  tree node, prev, next, node_init, first_stmt;\n+\n+  /* 1. New stmts - both DRA and DRB are not a part of any chain.   */\n+  if (!DR_GROUP_FIRST_DR (stmtinfo_a) && !DR_GROUP_FIRST_DR (stmtinfo_b))\n+    {\n+      DR_GROUP_FIRST_DR (stmtinfo_a) = DR_STMT (drb);\n+      DR_GROUP_FIRST_DR (stmtinfo_b) = DR_STMT (drb);\n+      DR_GROUP_NEXT_DR (stmtinfo_b) = DR_STMT (dra);\n+      return;\n+    }\n+\n+  /* 2. DRB is a part of a chain and DRA is not.  */\n+  if (!DR_GROUP_FIRST_DR (stmtinfo_a) && DR_GROUP_FIRST_DR (stmtinfo_b))\n+    {\n+      DR_GROUP_FIRST_DR (stmtinfo_a) = DR_GROUP_FIRST_DR (stmtinfo_b);\n+      /* Insert DRA into the chain of DRB.  */\n+      vect_insert_into_interleaving_chain (dra, drb);\n+      return;\n+    }\n+\n+  /* 3. DRA is a part of a chain and DRB is not.  */  \n+  if (DR_GROUP_FIRST_DR (stmtinfo_a) && !DR_GROUP_FIRST_DR (stmtinfo_b))\n+    {\n+      tree old_first_stmt = DR_GROUP_FIRST_DR (stmtinfo_a);\n+      tree init_old = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (\n+\t\t\t\t\t\t\t      old_first_stmt)));\n+      tree tmp;\n+\n+      if (tree_int_cst_compare (init_old, DR_INIT (drb)) > 0)\n+\t{\n+\t  /* DRB's init is smaller than the init of the stmt previously marked \n+\t     as the first stmt of the interleaving chain of DRA. Therefore, we \n+\t     update FIRST_STMT and put DRB in the head of the list.  */\n+\t  DR_GROUP_FIRST_DR (stmtinfo_b) = DR_STMT (drb);\n+\t  DR_GROUP_NEXT_DR (stmtinfo_b) = old_first_stmt;\n+\t\t\n+\t  /* Update all the stmts in the list to point to the new FIRST_STMT.  */\n+\t  tmp = old_first_stmt;\n+\t  while (tmp)\n+\t    {\n+\t      DR_GROUP_FIRST_DR (vinfo_for_stmt (tmp)) = DR_STMT (drb);\n+\t      tmp = DR_GROUP_NEXT_DR (vinfo_for_stmt (tmp));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Insert DRB in the list of DRA.  */\n+\t  vect_insert_into_interleaving_chain (drb, dra);\n+\t  DR_GROUP_FIRST_DR (stmtinfo_b) = DR_GROUP_FIRST_DR (stmtinfo_a);\t      \n+\t}\n+      return;\n+    }\n+  \n+  /* 4. both DRA and DRB are in some interleaving chains.  */\n+  first_a = DR_GROUP_FIRST_DR (stmtinfo_a);\n+  first_b = DR_GROUP_FIRST_DR (stmtinfo_b);\n+  if (first_a == first_b)\n+    return;\n+  init_dra_chain = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_a)));\n+  init_drb_chain = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_b)));\n+\n+  if (tree_int_cst_compare (init_dra_chain, init_drb_chain) > 0)\n+    {\n+      /* Insert the nodes of DRA chain into the DRB chain.  \n+\t After inserting a node, continue from this node of the DRB chain (don't\n+         start from the beginning.  */\n+      node = DR_GROUP_FIRST_DR (stmtinfo_a);\n+      prev = DR_GROUP_FIRST_DR (stmtinfo_b);      \n+      first_stmt = first_b;\n+    }\n+  else\n+    {\n+      /* Insert the nodes of DRB chain into the DRA chain.  \n+\t After inserting a node, continue from this node of the DRA chain (don't\n+         start from the beginning.  */\n+      node = DR_GROUP_FIRST_DR (stmtinfo_b);\n+      prev = DR_GROUP_FIRST_DR (stmtinfo_a);      \n+      first_stmt = first_a;\n+    }\n+  \n+  while (node)\n+    {\n+      node_init = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (node)));\n+      next = DR_GROUP_NEXT_DR (vinfo_for_stmt (prev));\t\t  \n+      while (next)\n+\t{\t  \n+\t  next_init = DR_INIT (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n+\t  if (tree_int_cst_compare (next_init, node_init) > 0)\n+\t    {\n+\t      /* Insert here.  */\n+\t      DR_GROUP_NEXT_DR (vinfo_for_stmt (prev)) = node;\n+\t      DR_GROUP_NEXT_DR (vinfo_for_stmt (node)) = next;\n+\t      prev = node;\n+\t      break;\n+\t    }\n+\t  prev = next;\n+\t  next = DR_GROUP_NEXT_DR (vinfo_for_stmt (prev));\n+\t}\n+      if (!next)\n+\t{\n+\t  /* We got to the end of the list. Insert here.  */\n+\t  DR_GROUP_NEXT_DR (vinfo_for_stmt (prev)) = node;\n+\t  DR_GROUP_NEXT_DR (vinfo_for_stmt (node)) = NULL_TREE;\n+\t  prev = node;\n+\t}\t\t\t\n+      DR_GROUP_FIRST_DR (vinfo_for_stmt (node)) = first_stmt;\n+      node = DR_GROUP_NEXT_DR (vinfo_for_stmt (node));\t       \n+    }\n+}\n+\n+\n+/* Function vect_equal_offsets.\n+\n+   Check if OFFSET1 and OFFSET2 are identical expressions.  */\n+\n+static bool\n+vect_equal_offsets (tree offset1, tree offset2)\n+{\n+  bool res0, res1;\n+\n+  STRIP_NOPS (offset1);\n+  STRIP_NOPS (offset2);\n+\n+  if (offset1 == offset2)\n+    return true;\n+\n+  if (TREE_CODE (offset1) != TREE_CODE (offset2)\n+      || !BINARY_CLASS_P (offset1)\n+      || !BINARY_CLASS_P (offset2))    \n+    return false;\n+  \n+  res0 = vect_equal_offsets (TREE_OPERAND (offset1, 0), \n+\t\t\t     TREE_OPERAND (offset2, 0));\n+  res1 = vect_equal_offsets (TREE_OPERAND (offset1, 1), \n+\t\t\t     TREE_OPERAND (offset2, 1));\n+\n+  return (res0 && res1);\n+}\n+\n+\n+/* Function vect_check_interleaving.\n+\n+   Check if DRA and DRB are a part of interleaving. In case they are, insert\n+   DRA and DRB in an interleaving chain.  */\n+\n+static void\n+vect_check_interleaving (struct data_reference *dra,\n+\t\t\t struct data_reference *drb)\n+{\n+  HOST_WIDE_INT type_size_a, type_size_b, diff_mod_size, step, init_a, init_b;\n+\n+  /* Check that the data-refs have same first location (except init) and they\n+     are both either store or load (not load and store).  */\n+  if ((DR_BASE_ADDRESS (dra) != DR_BASE_ADDRESS (drb)\n+       && (TREE_CODE (DR_BASE_ADDRESS (dra)) != ADDR_EXPR \n+\t   || TREE_CODE (DR_BASE_ADDRESS (drb)) != ADDR_EXPR\n+\t   || TREE_OPERAND (DR_BASE_ADDRESS (dra), 0) \n+\t   != TREE_OPERAND (DR_BASE_ADDRESS (drb),0)))\n+      || !vect_equal_offsets (DR_OFFSET (dra), DR_OFFSET (drb))\n+      || !tree_int_cst_compare (DR_INIT (dra), DR_INIT (drb)) \n+      || DR_IS_READ (dra) != DR_IS_READ (drb))\n+    return;\n+\n+  /* Check:\n+     1. data-refs are of the same type\n+     2. their steps are equal\n+     3. the step is greater than the difference between data-refs' inits  */\n+  type_size_a = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dra))));\n+  type_size_b = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (drb))));\n+\n+  if (type_size_a != type_size_b\n+      || tree_int_cst_compare (DR_STEP (dra), DR_STEP (drb)))\n+    return;\n+\n+  init_a = TREE_INT_CST_LOW (DR_INIT (dra));\n+  init_b = TREE_INT_CST_LOW (DR_INIT (drb));\n+  step = TREE_INT_CST_LOW (DR_STEP (dra));\n+\n+  if (init_a > init_b)\n+    {\n+      /* If init_a == init_b + the size of the type * k, we have an interleaving, \n+\t and DRB is accessed before DRA.  */\n+      diff_mod_size = (init_a - init_b) % type_size_a;\n+\n+      if ((init_a - init_b) > step)\n+         return; \n+\n+      if (diff_mod_size == 0)\n+\t{\n+\t  vect_update_interleaving_chain (drb, dra);\t  \n+\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"Detected interleaving \");\n+\t      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+\t      fprintf (vect_dump, \" and \");\n+\t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\t    }\n+\t  return;\n+\t} \n+    }\n+  else \n+    {\n+      /* If init_b == init_a + the size of the type * k, we have an \n+\t interleaving, and DRA is accessed before DRB.  */\n+      diff_mod_size = (init_b - init_a) % type_size_a;\n+\n+      if ((init_b - init_a) > step)\n+         return;\n+\n+      if (diff_mod_size == 0)\n+\t{\n+\t  vect_update_interleaving_chain (dra, drb);\t  \n+\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"Detected interleaving \");\n+\t      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+\t      fprintf (vect_dump, \" and \");\n+\t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+\t    }\n+\t  return;\n+\t} \n+    }\n+}\n+\n+\n /* Function vect_analyze_data_ref_dependence.\n \n    Return TRUE if there (might) exist a dependence between a memory-reference\n    DRA and a memory-reference DRB.  */\n       \n static bool\n vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n-                                  loop_vec_info loop_vinfo)\n+                                  loop_vec_info loop_vinfo,\n+\t\t\t\t  bool check_interleaving)\n {\n   unsigned int i;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -581,6 +872,14 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   unsigned int loop_depth;\n          \n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+    {\n+      /* Independent data accesses.  */\n+      if (check_interleaving)\n+\tvect_check_interleaving (dra, drb);\n+      return false;\n+    }\n+\n+  if ((DR_IS_READ (dra) && DR_IS_READ (drb)) || dra == drb)\n     return false;\n   \n   if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n@@ -659,6 +958,36 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n }\n \n \n+/* Function vect_check_dependences.\n+\n+    Return TRUE if there is a store-store or load-store dependence between\n+    data-refs in DDR, otherwise return FALSE.  */\n+\n+static bool\n+vect_check_dependences (struct data_dependence_relation *ddr)\n+{\n+  struct data_reference *dra = DDR_A (ddr);\n+  struct data_reference *drb = DDR_B (ddr);\n+\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_known || dra == drb)\n+    /* Independent or same data accesses.  */\n+    return false;\n+\n+  if (DR_IS_READ (dra) == DR_IS_READ (drb) && DR_IS_READ (dra))\n+    /* Two loads.  */\n+    return false;\n+\n+  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+    {\n+      fprintf (vect_dump, \"possible store or store/load dependence between \");\n+      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+      fprintf (vect_dump, \" and \");\n+      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+    }\n+  return true;\n+}\n+\n+\n /* Function vect_analyze_data_ref_dependences.\n           \n    Examine all the data references in the loop, and make sure there do not\n@@ -670,12 +999,24 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n   unsigned int i;\n   VEC (ddr_p, heap) *ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n   struct data_dependence_relation *ddr;\n+  bool check_interleaving = true;\n \n   if (vect_print_dump_info (REPORT_DETAILS)) \n     fprintf (vect_dump, \"=== vect_analyze_dependences ===\");\n      \n+  /* We allow interleaving only if there are no store-store and load-store\n+      dependencies in the loop.  */\n   for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n-    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo))\n+    {\n+      if (vect_check_dependences (ddr))\n+\t{\n+\t  check_interleaving = false;\n+\t  break;\n+\t}\n+    }\n+\n+  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n+    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, check_interleaving))\n       return false;\n \n   return true;\n@@ -830,11 +1171,20 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n   struct data_reference *current_dr;\n   int dr_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n   int dr_peel_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr_peel))));\n+  stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n+  stmt_vec_info peel_stmt_info = vinfo_for_stmt (DR_STMT (dr_peel));\n+\n+ /* For interleaved data accesses the step in the loop must be multiplied by\n+     the size of the interleaving group.  */\n+  if (DR_GROUP_FIRST_DR (stmt_info))\n+    dr_size *= DR_GROUP_SIZE (vinfo_for_stmt (DR_GROUP_FIRST_DR (stmt_info)));\n+  if (DR_GROUP_FIRST_DR (peel_stmt_info))\n+    dr_peel_size *= DR_GROUP_SIZE (peel_stmt_info);\n \n   if (known_alignment_for_access_p (dr)\n       && known_alignment_for_access_p (dr_peel)\n-      && (DR_MISALIGNMENT (dr)/dr_size == \n-\t  DR_MISALIGNMENT (dr_peel)/dr_peel_size))\n+      && (DR_MISALIGNMENT (dr) / dr_size ==\n+          DR_MISALIGNMENT (dr_peel) / dr_peel_size))\n     {\n       DR_MISALIGNMENT (dr) = 0;\n       return;\n@@ -848,15 +1198,15 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n     {\n       if (current_dr != dr)\n         continue;\n-      gcc_assert (DR_MISALIGNMENT (dr)/dr_size == \n-\t\t  DR_MISALIGNMENT (dr_peel)/dr_peel_size);\n+      gcc_assert (DR_MISALIGNMENT (dr) / dr_size ==\n+                  DR_MISALIGNMENT (dr_peel) / dr_peel_size);\n       DR_MISALIGNMENT (dr) = 0;\n       return;\n     }\n \n   if (known_alignment_for_access_p (dr)\n       && known_alignment_for_access_p (dr_peel))\n-    {  \n+    {\n       DR_MISALIGNMENT (dr) += npeel * dr_size;\n       DR_MISALIGNMENT (dr) %= UNITS_PER_SIMD_WORD;\n       return;\n@@ -883,6 +1233,14 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo)\n \n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n+      tree stmt = DR_STMT (dr);\n+      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\n+      /* For interleaving, only the alignment of the first access matters.  */\n+      if (DR_GROUP_FIRST_DR (stmt_info)\n+          && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n+        continue;\n+\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n       if (!supportable_dr_alignment)\n         {\n@@ -1007,6 +1365,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   bool do_peeling = false;\n   bool do_versioning = false;\n   bool stat;\n+  tree stmt;\n+  stmt_vec_info stmt_info;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_enhance_data_refs_alignment ===\");\n@@ -1051,12 +1411,47 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n      TODO: Use a cost model.  */\n \n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n-    if (!DR_IS_READ (dr) && !aligned_access_p (dr))\n-      {\n-\tdr0 = dr;\n-\tdo_peeling = true;\n-\tbreak;\n-      }\n+    {\n+      stmt = DR_STMT (dr);\n+      stmt_info = vinfo_for_stmt (stmt);\n+\n+      /* For interleaving, only the alignment of the first access\n+         matters.  */\n+      if (DR_GROUP_FIRST_DR (stmt_info)\n+          && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n+        continue;\n+\n+      if (!DR_IS_READ (dr) && !aligned_access_p (dr))\n+        {\n+\t  if (DR_GROUP_FIRST_DR (stmt_info))\n+\t    {\n+\t      /* For interleaved access we peel only if number of iterations in\n+\t\t the prolog loop ({VF - misalignment}), is a multiple of the\n+\t\t number of the interelaved accesses.  */\n+\t      int elem_size, mis_in_elements;\n+\t      int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\n+\t      /* FORNOW: handle only known alignment.  */\n+\t      if (!known_alignment_for_access_p (dr))\n+\t\t{\n+\t\t  do_peeling = false;\n+\t\t  break;\n+\t\t}\n+\n+\t      elem_size = UNITS_PER_SIMD_WORD / vf;\n+\t      mis_in_elements = DR_MISALIGNMENT (dr) / elem_size;\n+\n+\t      if ((vf - mis_in_elements) % DR_GROUP_SIZE (stmt_info))\n+\t\t{\n+\t\t  do_peeling = false;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  dr0 = dr;\n+\t  do_peeling = true;\n+\t  break;\n+\t}\n+    }\n \n   /* Often peeling for alignment will require peeling for loop-bound, which in \n      turn requires that we know how to adjust the loop ivs after the loop.  */\n@@ -1077,8 +1472,16 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           mis = DR_MISALIGNMENT (dr0);\n           mis /= GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr0))));\n           npeel = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - mis;\n+\n+\t  /* For interleaved data access every iteration accesses all the \n+\t     members of the group, therefore we divide the number of iterations\n+\t     by the group size.  */\n+\t  stmt_info = vinfo_for_stmt (DR_STMT (dr0));\t  \n+\t  if (DR_GROUP_FIRST_DR (stmt_info))\n+\t    npeel /= DR_GROUP_SIZE (stmt_info);\n+\n           if (vect_print_dump_info (REPORT_DETAILS))\n-            fprintf (vect_dump, \"Try peeling by %d\",npeel);\n+            fprintf (vect_dump, \"Try peeling by %d\", npeel);\n         }\n \n       /* Ensure that all data refs can be vectorized after the peel.  */\n@@ -1089,6 +1492,14 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  if (dr == dr0)\n \t    continue;\n \n+\t  stmt = DR_STMT (dr);\n+\t  stmt_info = vinfo_for_stmt (stmt);\n+\t  /* For interleaving, only the alignment of the first access\n+            matters.  */\n+\t  if (DR_GROUP_FIRST_DR (stmt_info)\n+\t      && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n+\t    continue;\n+\n \t  save_misalignment = DR_MISALIGNMENT (dr);\n \t  vect_update_misalignment_for_peel (dr, dr0, npeel);\n \t  supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n@@ -1146,10 +1557,17 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n     {\n       for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n         {\n-          if (aligned_access_p (dr))\n-            continue;\n+\t  stmt = DR_STMT (dr);\n+\t  stmt_info = vinfo_for_stmt (stmt);\n+\n+\t  /* For interleaving, only the alignment of the first access\n+\t     matters.  */\n+\t  if (aligned_access_p (dr)\n+\t      || (DR_GROUP_FIRST_DR (stmt_info)\n+\t\t  && DR_GROUP_FIRST_DR (stmt_info) != stmt))\n+\t    continue;\n \n-          supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n+\t  supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n \n           if (!supportable_dr_alignment)\n             {\n@@ -1266,14 +1684,157 @@ static bool\n vect_analyze_data_ref_access (struct data_reference *dr)\n {\n   tree step = DR_STEP (dr);\n+  HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n   tree scalar_type = TREE_TYPE (DR_REF (dr));\n+  HOST_WIDE_INT type_size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (scalar_type));\n+  tree stmt = DR_STMT (dr);\n+  /* For interleaving, STRIDE is STEP counted in elements, i.e., the size of the \n+     interleaving group (including gaps).  */\n+  HOST_WIDE_INT stride = dr_step / type_size;\n+\n+  if (!step)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"bad data-ref access\");\n+      return false;\n+    }\n \n-  if (!step || tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type)))\n+  /* Consecutive?  */\n+  if (!tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type)))\n     {\n+      /* Mark that it is not interleaving.  */\n+      DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) = NULL_TREE;\n+      return true;\n+    }\n+\n+  /* Not consecutive access is possible only if it is a part of interleaving.  */\n+  if (!DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)))\n+    {\n+      /* Check if it this DR is a part of interleaving, and is a single\n+\t element of the group that is accessed in the loop.  */\n+      \n+      /* Gaps are supported only for loads. STEP must be a multiple of the type\n+\t size.  The size of the group must be a power of 2.  */\n+      if (DR_IS_READ (dr)\n+\t  && (dr_step % type_size) == 0\n+\t  && stride > 0\n+\t  && exact_log2 (stride) != -1)\n+\t{\n+\t  DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) = stmt;\n+\t  DR_GROUP_SIZE (vinfo_for_stmt (stmt)) = stride;\n+\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"Detected single element interleaving %d \",\n+\t\t       DR_GROUP_SIZE (vinfo_for_stmt (stmt)));\n+\t      print_generic_expr (vect_dump, DR_REF (dr), TDF_SLIM);\n+\t      fprintf (vect_dump, \" step \");\n+\t      print_generic_expr (vect_dump, step, TDF_SLIM);\n+\t    }\n+\t  return true;\n+\t}\n       if (vect_print_dump_info (REPORT_DETAILS))\n \tfprintf (vect_dump, \"not consecutive access\");\n       return false;\n     }\n+\n+  if (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt)) == stmt)\n+    {\n+      /* First stmt in the interleaving chain. Check the chain.  */\n+      tree next = DR_GROUP_NEXT_DR (vinfo_for_stmt (stmt));\n+      struct data_reference *data_ref = dr;\n+      unsigned int count = 1;\n+      tree next_step;\n+      tree prev_init = DR_INIT (data_ref);\n+      tree prev = stmt;\n+      HOST_WIDE_INT diff, count_in_bytes;\n+\n+      while (next)\n+\t{\n+\t  /* Skip same data-refs. In case that two or more stmts share data-ref\n+\t     (supported only for loads), we vectorize only the first stmt, and\n+\t     the rest get their vectorized loads from the the first one.  */\n+\t  if (!tree_int_cst_compare (DR_INIT (data_ref),\n+\t\t\t\t     DR_INIT (STMT_VINFO_DATA_REF (\n+\t\t\t\t\t\t      vinfo_for_stmt (next)))))\n+\t    {\n+\t      /* For load use the same data-ref load. (We check in\n+\t\t vect_check_dependences() that there are no two stores to the\n+\t\t same location).  */\n+\t      DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next)) = prev;\n+\n+\t      prev = next;\n+\t      next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n+\t      continue;\n+\t    }\n+\t  prev = next;\n+\n+\t  /* Check that all the accesses have the same STEP.  */\n+\t  next_step = DR_STEP (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n+\t  if (tree_int_cst_compare (step, next_step))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\tfprintf (vect_dump, \"not consecutive access in interleaving\");\n+\t      return false;\n+\t    }\n+\n+\t  data_ref = STMT_VINFO_DATA_REF (vinfo_for_stmt (next));\n+\t  /* Check that the distance between two accesses is equal to the type\n+\t     size. Otherwise, we have gaps.  */\n+\t  diff = (TREE_INT_CST_LOW (DR_INIT (data_ref)) \n+\t\t  - TREE_INT_CST_LOW (prev_init)) / type_size;\n+\t  if (!DR_IS_READ (data_ref) && diff != 1)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\tfprintf (vect_dump, \"interleaved store with gaps\");\n+\t      return false;\n+\t    }\n+\t  /* Store the gap from the previous member of the group. If there is no\n+             gap in the access, DR_GROUP_GAP is always 1.  */\n+\t  DR_GROUP_GAP (vinfo_for_stmt (next)) = diff;\n+\n+\t  prev_init = DR_INIT (data_ref);\n+\t  next = DR_GROUP_NEXT_DR (vinfo_for_stmt (next));\n+\t  /* Count the number of data-refs in the chain.  */\n+\t  count++;\n+\t}\n+\n+      /* COUNT is the number of accesses found, we multiply it by the size of \n+\t the type to get COUNT_IN_BYTES.  */\n+      count_in_bytes = type_size * count;\n+      /* Check the size of the interleaving is not greater than STEP.  */\n+      if (dr_step < count_in_bytes) \n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"interleaving size is greater than step for \");\n+\t      print_generic_expr (vect_dump, DR_REF (dr), TDF_SLIM); \n+\t    }\n+\t  return false;\n+\t}\n+\n+      /* Check that STEP is a multiple of type size.  */\n+      if ((dr_step % type_size) != 0)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS)) \n+            {\n+              fprintf (vect_dump, \"step is not a multiple of type size: step \");\n+              print_generic_expr (vect_dump, step, TDF_SLIM);\n+              fprintf (vect_dump, \" size \");\n+              print_generic_expr (vect_dump, TYPE_SIZE_UNIT (scalar_type),\n+                                  TDF_SLIM);\n+            }\n+\t  return false;\n+\t}\n+\n+      /* FORNOW: we handle only interleaving that is a power of 2.  */\n+      if (exact_log2 (stride) == -1)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"interleaving is not a power of 2\");\n+\t  return false;\n+\t}\n+      DR_GROUP_SIZE (vinfo_for_stmt (stmt)) = stride;\n+    }\n   return true;\n }\n \n@@ -1335,7 +1896,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs ===\");\n \n-  compute_data_dependences_for_loop (loop, false,\n+  compute_data_dependences_for_loop (loop, true,\n                                      &LOOP_VINFO_DATAREFS (loop_vinfo),\n                                      &LOOP_VINFO_DDRS (loop_vinfo));\n "}, {"sha": "43a55f98ecf9456cc9c630b441a7cd3eb7d11ed9", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 854, "deletions": 141, "changes": 995, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -46,7 +46,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"real.h\"\n \n /* Utility functions for the code transformation.  */\n-static bool vect_transform_stmt (tree, block_stmt_iterator *);\n+static bool vect_transform_stmt (tree, block_stmt_iterator *, bool *);\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref_ptr \n   (tree, block_stmt_iterator *, tree, tree *, tree *, bool); \n@@ -160,9 +160,19 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   if (offset)\n     {\n       tree tmp = create_tmp_var (TREE_TYPE (base_offset), \"offset\");\n+      tree step; \n+\n+      /* For interleaved access step we divide STEP by the size of the\n+        interleaving group.  */\n+      if (DR_GROUP_SIZE (stmt_info))\n+\tstep = fold_build2 (TRUNC_DIV_EXPR, TREE_TYPE (offset), DR_STEP (dr),\n+\t\t\t    build_int_cst (TREE_TYPE (offset),\n+\t\t\t\t\t   DR_GROUP_SIZE (stmt_info)));\n+      else\n+\tstep = DR_STEP (dr);\n+\n       add_referenced_var (tmp);\n-      offset = fold_build2 (MULT_EXPR, TREE_TYPE (offset), offset,\n-\t\t\t    DR_STEP (dr));\n+      offset = fold_build2 (MULT_EXPR, TREE_TYPE (offset), offset, step);\n       base_offset = fold_build2 (PLUS_EXPR, TREE_TYPE (base_offset),\n \t\t\t\t base_offset, offset);\n       base_offset = force_gimple_operand (base_offset, &new_stmt, false, tmp);  \n@@ -2294,6 +2304,164 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n }\n \n \n+/* Function vect_strided_store_supported.\n+\n+   Returns TRUE is INTERLEAVE_HIGH and INTERLEAVE_LOW operations are supported,\n+   and FALSE otherwise.  */\n+\n+static bool\n+vect_strided_store_supported (tree vectype)\n+{\n+  optab interleave_high_optab, interleave_low_optab;\n+  int mode;\n+\n+  mode = (int) TYPE_MODE (vectype);\n+      \n+  /* Check that the operation is supported.  */\n+  interleave_high_optab = optab_for_tree_code (VEC_INTERLEAVE_HIGH_EXPR, \n+\t\t\t\t\t       vectype);\n+  interleave_low_optab = optab_for_tree_code (VEC_INTERLEAVE_LOW_EXPR, \n+\t\t\t\t\t      vectype);\n+  if (!interleave_high_optab || !interleave_low_optab)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"no optab for interleave.\");\n+      return false;\n+    }\n+\n+  if (interleave_high_optab->handlers[(int) mode].insn_code \n+      == CODE_FOR_nothing\n+      || interleave_low_optab->handlers[(int) mode].insn_code \n+      == CODE_FOR_nothing)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"interleave op not supported by target.\");\n+      return false;\n+    }\n+  return true;\n+}\n+\n+\n+/* Function vect_permute_store_chain.\n+\n+   Given a chain of interleaved strores in DR_CHAIN of LENGTH that must be\n+   a power of 2, generate interleave_high/low stmts to reorder the data \n+   correctly for the stores. Return the final references for stores in\n+   RESULT_CHAIN.\n+\n+   E.g., LENGTH is 4 and the scalar type is short, i.e., VF is 8.\n+   The input is 4 vectors each containg 8 elements. We assign a number to each \n+   element, the input sequence is:\n+\n+   1st vec:   0  1  2  3  4  5  6  7\n+   2nd vec:   8  9 10 11 12 13 14 15\n+   3rd vec:  16 17 18 19 20 21 22 23 \n+   4th vec:  24 25 26 27 28 29 30 31\n+\n+   The output sequence should be:\n+\n+   1st vec:  0  8 16 24  1  9 17 25\n+   2nd vec:  2 10 18 26  3 11 19 27\n+   3rd vec:  4 12 20 28  5 13 21 30\n+   4th vec:  6 14 22 30  7 15 23 31\n+\n+   i.e., we interleave the contents of the four vectors in their order.\n+\n+   We use interleave_high/low instructions to create such output. The input of \n+   each interleave_high/low operation is two vectors:\n+   1st vec    2nd vec \n+   0 1 2 3    4 5 6 7 \n+   the even elements of the result vector are obtained left-to-right from the \n+   high/low elements of the first vector. The odd elements of the result are \n+   obtained left-to-right from the high/low elements of the second vector.\n+   The output of interleave_high will be:   0 4 1 5\n+   and of interleave_low:                   2 6 3 7\n+\n+   \n+   The permutaion is done in log LENGTH stages. In each stage interleave_high \n+   and interleave_low stmts are created for each pair of vectors in DR_CHAIN, \n+   where the first argument is taken from the first half of DR_CHAIN and the \n+   second argument from it's second half. \n+   In our example, \n+\n+   I1: interleave_high (1st vec, 3rd vec)\n+   I2: interleave_low (1st vec, 3rd vec)\n+   I3: interleave_high (2nd vec, 4th vec)\n+   I4: interleave_low (2nd vec, 4th vec)\n+\n+   The output for the first stage is:\n+\n+   I1:  0 16  1 17  2 18  3 19\n+   I2:  4 20  5 21  6 22  7 23\n+   I3:  8 24  9 25 10 26 11 27\n+   I4: 12 28 13 29 14 30 15 31\n+\n+   The output of the second stage, i.e. the final result is:\n+\n+   I1:  0  8 16 24  1  9 17 25\n+   I2:  2 10 18 26  3 11 19 27\n+   I3:  4 12 20 28  5 13 21 30\n+   I4:  6 14 22 30  7 15 23 31.  */\n+ \n+static bool\n+vect_permute_store_chain (VEC(tree,heap) *dr_chain, \n+\t\t\t  unsigned int length, \n+\t\t\t  tree stmt, \n+\t\t\t  block_stmt_iterator *bsi,\n+\t\t\t  VEC(tree,heap) **result_chain)\n+{\n+  tree perm_dest, perm_stmt, vect1, vect2, high, low;\n+  tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+  tree scalar_dest;\n+  int i;\n+  unsigned int j;\n+  VEC(tree,heap) *first, *second;\n+  \n+  scalar_dest = TREE_OPERAND (stmt, 0);\n+  first = VEC_alloc (tree, heap, length/2);\n+  second = VEC_alloc (tree, heap, length/2);\n+\n+  /* Check that the operation is supported.  */\n+  if (!vect_strided_store_supported (vectype))\n+    return false;\n+\n+  *result_chain = VEC_copy (tree, heap, dr_chain);\n+\n+  for (i = 0; i < exact_log2 (length); i++)\n+    {\n+      for (j = 0; j < length/2; j++)\n+\t{\n+\t  vect1 = VEC_index (tree, dr_chain, j);\n+\t  vect2 = VEC_index (tree, dr_chain, j+length/2);\n+\n+\t  /* high = interleave_high (vect1, vect2);  */\n+\t  perm_dest = create_tmp_var (vectype, \"vect_inter_high\");\n+\t  add_referenced_var (perm_dest);\n+\t  perm_stmt = build2 (MODIFY_EXPR, vectype, perm_dest,\n+\t\t\t      build2 (VEC_INTERLEAVE_HIGH_EXPR, vectype, vect1, \n+\t\t\t\t      vect2));\n+\t  high = make_ssa_name (perm_dest, perm_stmt);\n+\t  TREE_OPERAND (perm_stmt, 0) = high;\n+\t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n+\t  VEC_replace (tree, *result_chain, 2*j, high);\n+\n+\t  /* low = interleave_low (vect1, vect2);  */\n+\t  perm_dest = create_tmp_var (vectype, \"vect_inter_low\");\n+\t  add_referenced_var (perm_dest);\n+\t  perm_stmt = build2 (MODIFY_EXPR, vectype, perm_dest,\n+\t\t\t      build2 (VEC_INTERLEAVE_LOW_EXPR, vectype, vect1, \n+\t\t\t\t      vect2));\n+\t  low = make_ssa_name (perm_dest, perm_stmt);\n+\t  TREE_OPERAND (perm_stmt, 0) = low;\n+\t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n+\t  VEC_replace (tree, *result_chain, 2*j+1, low);\n+\t}\n+      dr_chain = VEC_copy (tree, heap, *result_chain);\n+    }\n+  return true;\n+}\n+\n+\n /* Function vectorizable_store.\n \n    Check if STMT defines a non scalar data-ref (array/pointer/structure) that \n@@ -2310,7 +2478,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   tree op;\n   tree vec_oprnd = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr = NULL;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum machine_mode vec_mode;\n@@ -2320,12 +2488,15 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   def_operand_p def_p;\n   tree def, def_stmt;\n   enum vect_def_type dt;\n-  stmt_vec_info prev_stmt_info;\n+  stmt_vec_info prev_stmt_info = NULL;\n   tree dataref_ptr = NULL_TREE;\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n   int j;\n-\n+  tree next_stmt, first_stmt;\n+  bool strided_store = false;\n+  unsigned int group_size, i;\n+  VEC(tree,heap) *dr_chain = NULL, *oprnds = NULL, *result_chain = NULL;\n   gcc_assert (ncopies >= 1);\n \n   /* Is vectorizable store? */\n@@ -2335,7 +2506,8 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   scalar_dest = TREE_OPERAND (stmt, 0);\n   if (TREE_CODE (scalar_dest) != ARRAY_REF\n-      && TREE_CODE (scalar_dest) != INDIRECT_REF)\n+      && TREE_CODE (scalar_dest) != INDIRECT_REF\n+      && !DR_GROUP_FIRST_DR (stmt_info))\n     return false;\n \n   op = TREE_OPERAND (stmt, 1);\n@@ -2355,6 +2527,12 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n+  if (DR_GROUP_FIRST_DR (stmt_info))\n+    {\n+      strided_store = true;\n+      if (!vect_strided_store_supported (vectype))\n+\treturn false;      \n+    }\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n@@ -2367,7 +2545,34 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform store. ncopies = %d\",ncopies);\n \n-  alignment_support_cheme = vect_supportable_dr_alignment (dr);\n+  if (strided_store)\n+    {\n+      first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+      first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+      group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+\n+      DR_GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))++;\n+\n+      /* We vectorize all the stmts of the interleaving group when we\n+\t reach the last stmt in the group.  */\n+      if (DR_GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt)) \n+\t  < DR_GROUP_SIZE (vinfo_for_stmt (first_stmt)))\n+\t{\n+\t  *vec_stmt = NULL_TREE;\n+\t  return true;\n+\t}\n+    }\n+  else \n+    {\n+      first_stmt = stmt;\n+      first_dr = dr;\n+      group_size = 1;\n+    }\n+  \n+  dr_chain = VEC_alloc (tree, heap, group_size);\n+  oprnds = VEC_alloc (tree, heap, group_size);\n+\n+  alignment_support_cheme = vect_supportable_dr_alignment (first_dr);\n   gcc_assert (alignment_support_cheme);\n   gcc_assert (alignment_support_cheme == dr_aligned);  /* FORNOW */\n \n@@ -2377,6 +2582,39 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n      vector stmt by a factor VF/nunits.  For more details see documentation in \n      vect_get_vec_def_for_copy_stmt.  */\n \n+  /* In case of interleaving (non-unit strided access):\n+\n+        S1:  &base + 2 = x2\n+        S2:  &base = x0\n+        S3:  &base + 1 = x1\n+        S4:  &base + 3 = x3\n+\n+     We create vectorized storess starting from base address (the access of the\n+     first stmt in the chain (S2 in the above example), when the last store stmt\n+     of the chain (S4) is reached:\n+\n+        VS1: &base = vx2\n+\tVS2: &base + vec_size*1 = vx0\n+\tVS3: &base + vec_size*2 = vx1\n+\tVS4: &base + vec_size*3 = vx3\n+\n+     Then permutation statements are generated:\n+\n+        VS5: vx5 = VEC_INTERLEAVE_HIGH_EXPR < vx0, vx3 >\n+        VS6: vx6 = VEC_INTERLEAVE_LOW_EXPR < vx0, vx3 >\n+\t...\n+\t\n+     And they are put in STMT_VINFO_VEC_STMT of the corresponding scalar stmts\n+     (the order of the data-refs in the output of vect_permute_store_chain\n+     corresponds to the order of scalar stmts in the interleaving chain - see\n+     the documentaion of vect_permute_store_chain()).\n+\n+     In case of both multiple types and interleaving, above vector stores and\n+     permutation stmts are created for every copy. The result vector stmts are\n+     put in STMT_VINFO_VEC_STMT for the first copy and in the corresponding\n+     STMT_VINFO_RELATED_STMT for the next copies.     \n+  */\n+\n   prev_stmt_info = NULL;\n   for (j = 0; j < ncopies; j++)\n     {\n@@ -2385,52 +2623,111 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n       if (j == 0)\n \t{\n-\t  vec_oprnd = vect_get_vec_def_for_operand (op, stmt, NULL);\n-\t  dataref_ptr = vect_create_data_ref_ptr (stmt, bsi, NULL_TREE, &dummy, \n-\t\t\t\t\t\t  &ptr_incr, false);\n+\t  /* For interleaved stores we collect vectorized defs for all the \n+\t     stores in the group in DR_CHAIN and OPRNDS. DR_CHAIN is then used\n+\t     as an input to vect_permute_store_chain(), and OPRNDS as an input\n+\t     to vect_get_vec_def_for_stmt_copy() for the next copy.\n+\t     If the store is not strided, GROUP_SIZE is 1, and DR_CHAIN and\n+\t     OPRNDS are of size 1.\n+\t  */\n+\t  next_stmt = first_stmt;\t  \n+\t  for (i = 0; i < group_size; i++)\n+\t    {\n+\t      /* Since gaps are not supported for interleaved stores, GROUP_SIZE\n+\t\t is the exact number of stmts in the chain. Therefore, NEXT_STMT\n+\t\t can't be NULL_TREE.  In case that there is no interleaving, \n+\t\t GROUP_SIZE is 1, and only one iteration of the loop will be \n+\t\t executed.\n+\t      */\n+\t      gcc_assert (next_stmt);\n+\t      op = TREE_OPERAND (next_stmt, 1);\n+\t      vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt, NULL);\n+\t      VEC_quick_push(tree, dr_chain, vec_oprnd); \n+\t      VEC_quick_push(tree, oprnds, vec_oprnd); \n+\t      next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+\t    }\n+\t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, bsi, NULL_TREE, \n+\t\t\t\t\t\t  &dummy, &ptr_incr, false);\n \t}\n       else \n \t{\n-\t  vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, vec_oprnd);\n+\t  /* For interleaved stores we created vectorized defs for all the \n+\t     defs stored in OPRNDS in the previous iteration (previous copy). \n+\t     DR_CHAIN is then used as an input to vect_permute_store_chain(), \n+\t     and OPRNDS as an input to vect_get_vec_def_for_stmt_copy() for the \n+\t     next copy.\n+\t     If the store is not strided, GROUP_SIZE is 1, and DR_CHAIN and\n+\t     OPRNDS are of size 1.\n+\t  */\n+\t  for (i = 0; i < group_size; i++)\n+\t    {\n+\t      vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, \n+\t\t\t\t\t\t   VEC_index (tree, oprnds, i));\n+\t      VEC_replace(tree, dr_chain, i, vec_oprnd);\n+\t      VEC_replace(tree, oprnds, i, vec_oprnd);\n+\t    }\n \t  dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\n \t}\n \n-      /* Arguments are ready. create the new vector stmt.  */\n-      data_ref = build_fold_indirect_ref (dataref_ptr);\n-      new_stmt = build2 (MODIFY_EXPR, vectype, data_ref, vec_oprnd);\n-      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+      if (strided_store)\n+\t{\n+\t  result_chain = VEC_alloc (tree, heap, group_size);     \n+\t  /* Permute.  */\n+\t  if (!vect_permute_store_chain (dr_chain, group_size, stmt, bsi, \n+\t\t\t\t\t &result_chain))\n+\t    return false;\n+\t}\n \n-     /* Set the V_MAY_DEFS for the vector pointer. If this virtual def has a \n-\tuse outside the loop and a loop peel is performed then the def may be \n-\trenamed by the peel.  Mark it for renaming so the later use will also \n-\tbe renamed.  */\n-      copy_virtual_operands (new_stmt, stmt);\n-      if (j == 0)\n+      next_stmt = first_stmt;\n+      for (i = 0; i < group_size; i++)\n \t{\n-\t  /* The original store is deleted so the same SSA_NAMEs can be used.  \n-\t   */\n-\t  FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_VMAYDEF)\n+\t  /* For strided stores vectorized defs are interleaved in \n+\t     vect_permute_store_chain().  */\n+\t  if (strided_store)\n+\t    vec_oprnd = VEC_index(tree, result_chain, i);\n+\n+\t  data_ref = build_fold_indirect_ref (dataref_ptr);\n+\t  /* Arguments are ready. Create the new vector stmt.  */\n+\t  new_stmt = build2 (MODIFY_EXPR, vectype, data_ref, vec_oprnd);\n+\t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\n+\t  /* Set the V_MAY_DEFS for the vector pointer. If this virtual def has a \n+\t     use outside the loop and a loop peel is performed then the def may be \n+\t     renamed by the peel.  Mark it for renaming so the later use will also \n+\t     be renamed.  */\n+\t  copy_virtual_operands (new_stmt, next_stmt);\n+\t  if (j == 0)\n \t    {\n-\t      SSA_NAME_DEF_STMT (def) = new_stmt;\n-\t      mark_sym_for_renaming (SSA_NAME_VAR (def));\n+\t      /* The original store is deleted so the same SSA_NAMEs can be used.  \n+\t       */\n+\t      FOR_EACH_SSA_TREE_OPERAND (def, next_stmt, iter, SSA_OP_VMAYDEF)\n+\t\t{\n+\t\t  SSA_NAME_DEF_STMT (def) = new_stmt;\n+\t\t  mark_sym_for_renaming (SSA_NAME_VAR (def));\n+\t\t}\n+\t      \n+\t      STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt =  new_stmt;\n \t    }\n-\n-\t  STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt =  new_stmt;\n-\t}\n-      else\n-\t{\n-\t  /* Create new names for all the definitions created by COPY and\n-\t     add replacement mappings for each new name.  */\n-          FOR_EACH_SSA_DEF_OPERAND (def_p, new_stmt, iter, SSA_OP_VMAYDEF)\n+\t  else\n \t    {\n-\t      create_new_def_for (DEF_FROM_PTR (def_p), new_stmt, def_p);\n-\t      mark_sym_for_renaming (SSA_NAME_VAR (DEF_FROM_PTR (def_p)));\n+\t      /* Create new names for all the definitions created by COPY and\n+\t\t add replacement mappings for each new name.  */\n+\t      FOR_EACH_SSA_DEF_OPERAND (def_p, new_stmt, iter, SSA_OP_VMAYDEF)\n+\t\t{\n+\t\t  create_new_def_for (DEF_FROM_PTR (def_p), new_stmt, def_p);\n+\t\t  mark_sym_for_renaming (SSA_NAME_VAR (DEF_FROM_PTR (def_p)));\n+\t\t}\n+\t      \n+\t      STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n \t    }\n \n-\t  STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t  \t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+\t  if (!next_stmt)\n+\t    break;\n+\t  /* Bump the vector pointer.  */\n+\t  dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\n \t}\n-\n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n     }\n \n   return true;\n@@ -2473,8 +2770,7 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n    Output:\n    REALIGNMENT_TOKEN - the result of a call to the builtin_mask_for_load\n                        target hook, if defined.\n-   Return value - the result of the loop-header phi node.\n-*/\n+   Return value - the result of the loop-header phi node.  */\n \n static tree\n vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n@@ -2547,6 +2843,268 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n }\n \n \n+/* Function vect_strided_load_supported.\n+\n+   Returns TRUE is EXTRACT_EVEN and EXTRACT_ODD operations are supported,\n+   and FALSE otherwise.  */\n+\n+static bool\n+vect_strided_load_supported (tree vectype)\n+{\n+  optab perm_even_optab, perm_odd_optab;\n+  int mode;\n+\n+  mode = (int) TYPE_MODE (vectype);\n+\n+  perm_even_optab = optab_for_tree_code (VEC_EXTRACT_EVEN_EXPR, vectype);\n+  if (!perm_even_optab)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"no optab for perm_even.\");\n+      return false;\n+    }\n+\n+  if (perm_even_optab->handlers[mode].insn_code == CODE_FOR_nothing)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"perm_even op not supported by target.\");\n+      return false;\n+    }\n+\n+  perm_odd_optab = optab_for_tree_code (VEC_EXTRACT_ODD_EXPR, vectype);\n+  if (!perm_odd_optab)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"no optab for perm_odd.\");\n+      return false;\n+    }\n+\n+  if (perm_odd_optab->handlers[mode].insn_code == CODE_FOR_nothing)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"perm_odd op not supported by target.\");\n+      return false;\n+    }\n+  return true;\n+}\n+\n+\n+/* Function vect_permute_load_chain.\n+\n+   Given a chain of interleaved loads in DR_CHAIN of LENGTH that must be\n+   a power of 2, generate extract_even/odd stmts to reorder the input data \n+   correctly. Return the final references for loads in RESULT_CHAIN.\n+\n+   E.g., LENGTH is 4 and the scalar type is short, i.e., VF is 8.\n+   The input is 4 vectors each containg 8 elements. We assign a number to each \n+   element, the input sequence is:\n+\n+   1st vec:   0  1  2  3  4  5  6  7\n+   2nd vec:   8  9 10 11 12 13 14 15\n+   3rd vec:  16 17 18 19 20 21 22 23 \n+   4th vec:  24 25 26 27 28 29 30 31\n+\n+   The output sequence should be:\n+\n+   1st vec:  0 4  8 12 16 20 24 28\n+   2nd vec:  1 5  9 13 17 21 25 29\n+   3rd vec:  2 6 10 14 18 22 26 30 \n+   4th vec:  3 7 11 15 19 23 27 31\n+\n+   i.e., the first output vector should contain the first elements of each\n+   interleaving group, etc.\n+\n+   We use extract_even/odd instructions to create such output. The input of each\n+   extract_even/odd operation is two vectors\n+   1st vec    2nd vec \n+   0 1 2 3    4 5 6 7 \n+\n+   and the output is the vector of extracted even/odd elements. The output of \n+   extract_even will be:   0 2 4 6\n+   and of extract_odd:     1 3 5 7\n+\n+   \n+   The permutaion is done in log LENGTH stages. In each stage extract_even and \n+   extract_odd stmts are created for each pair of vectors in DR_CHAIN in their \n+   order. In our example, \n+\n+   E1: extract_even (1st vec, 2nd vec)\n+   E2: extract_odd (1st vec, 2nd vec)\n+   E3: extract_even (3rd vec, 4th vec)\n+   E4: extract_odd (3rd vec, 4th vec)\n+\n+   The output for the first stage will be:\n+\n+   E1:  0  2  4  6  8 10 12 14\n+   E2:  1  3  5  7  9 11 13 15\n+   E3: 16 18 20 22 24 26 28 30 \n+   E4: 17 19 21 23 25 27 29 31\n+\n+   In order to proceed and create the correct sequence for the next stage (or\n+   for the correct output, if the second stage is the last one, as in our \n+   example), we first put the output of extract_even operation and then the \n+   output of extract_odd in RESULT_CHAIN (which is then copied to DR_CHAIN).\n+   The input for the second stage is:\n+\n+   1st vec (E1):  0  2  4  6  8 10 12 14\n+   2nd vec (E3): 16 18 20 22 24 26 28 30  \n+   3rd vec (E2):  1  3  5  7  9 11 13 15    \n+   4th vec (E4): 17 19 21 23 25 27 29 31\n+\n+   The output of the second stage:\n+\n+   E1: 0 4  8 12 16 20 24 28\n+   E2: 2 6 10 14 18 22 26 30\n+   E3: 1 5  9 13 17 21 25 29\n+   E4: 3 7 11 15 19 23 27 31\n+\n+   And RESULT_CHAIN after reordering:\n+\n+   1st vec (E1):  0 4  8 12 16 20 24 28\n+   2nd vec (E3):  1 5  9 13 17 21 25 29\n+   3rd vec (E2):  2 6 10 14 18 22 26 30 \n+   4th vec (E4):  3 7 11 15 19 23 27 31.  */\n+\n+static bool\n+vect_permute_load_chain (VEC(tree,heap) *dr_chain, \n+\t\t\t unsigned int length, \n+\t\t\t tree stmt, \n+\t\t\t block_stmt_iterator *bsi,\n+\t\t\t VEC(tree,heap) **result_chain)\n+{\n+  tree perm_dest, perm_stmt, data_ref, first_vect, second_vect;\n+  tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+  int i;\n+  unsigned int j;\n+\n+  /* Check that the operation is supported.  */\n+  if (!vect_strided_load_supported (vectype))\n+    return false;\n+\n+  *result_chain = VEC_copy (tree, heap, dr_chain);\n+  for (i = 0; i < exact_log2 (length); i++)\n+    {\n+      for (j = 0; j < length; j +=2)\n+\t{\n+\t  first_vect = VEC_index (tree, dr_chain, j);\n+\t  second_vect = VEC_index (tree, dr_chain, j+1);\n+\n+\t  /* data_ref = permute_even (first_data_ref, second_data_ref);  */\n+\t  perm_dest = create_tmp_var (vectype, \"vect_perm_even\");\n+\t  add_referenced_var (perm_dest);\n+\t \n+\t  perm_stmt = build2 (MODIFY_EXPR, vectype, perm_dest,\n+\t\t\t      build2 (VEC_EXTRACT_EVEN_EXPR, vectype, \n+\t\t\t\t      first_vect, second_vect));\n+\n+\t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n+\t  TREE_OPERAND (perm_stmt, 0) = data_ref;\n+\t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n+\t  mark_new_vars_to_rename (perm_stmt);\n+\n+\t  VEC_replace (tree, *result_chain, j/2, data_ref);\t      \n+\t      \n+\t  /* data_ref = permute_odd (first_data_ref, second_data_ref);  */\n+\t  perm_dest = create_tmp_var (vectype, \"vect_perm_odd\");\n+\t  add_referenced_var (perm_dest);\n+\n+\t  perm_stmt = build2 (MODIFY_EXPR, vectype, perm_dest,\n+\t\t\t      build2 (VEC_EXTRACT_ODD_EXPR, vectype, \n+\t\t\t\t      first_vect, second_vect));\n+\t  data_ref = make_ssa_name (perm_dest, perm_stmt);\n+\t  TREE_OPERAND (perm_stmt, 0) = data_ref;\n+\t  vect_finish_stmt_generation (stmt, perm_stmt, bsi);\n+\t  mark_new_vars_to_rename (perm_stmt);\n+\n+\t  VEC_replace (tree, *result_chain, j/2+length/2, data_ref);\n+\t}\n+      dr_chain = VEC_copy (tree, heap, *result_chain);\n+    }\n+  return true;\n+}\n+\n+\n+/* Function vect_transform_strided_load.\n+\n+   Given a chain of input interleaved data-refs (in DR_CHAIN), build statements\n+   to perform their permutation and ascribe the result vectorized statements to\n+   the scalar statements.\n+*/\n+\n+static bool\n+vect_transform_strided_load (tree stmt, VEC(tree,heap) *dr_chain, int size,\n+\t\t\t     block_stmt_iterator *bsi)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+  tree next_stmt, new_stmt;\n+  VEC(tree,heap) *result_chain = NULL;\n+  unsigned int i, gap_count;\n+  tree tmp_data_ref;\n+\n+  /* DR_CHAIN contains input data-refs that are a part of the interleaving. \n+     RESULT_CHAIN is the output of vect_permute_load_chain, it contains permuted \n+     vectors, that are ready for vector computation.  */\n+  result_chain = VEC_alloc (tree, heap, size);\n+  /* Permute.  */\n+  if (!vect_permute_load_chain (dr_chain, size, stmt, bsi, &result_chain))\n+    return false;\n+\n+  /* Put a permuted data-ref in the VECTORIZED_STMT field.  \n+     Since we scan the chain starting from it's first node, their order \n+     corresponds the order of data-refs in RESULT_CHAIN.  */\n+  next_stmt = first_stmt;\n+  gap_count = 1;\n+  for (i = 0; VEC_iterate(tree, result_chain, i, tmp_data_ref); i++)\n+    {\n+      if (!next_stmt)\n+\tbreak;\n+\n+      /* Skip the gaps. Loads created for the gaps will be removed by dead\n+       code elimination pass later.\n+       DR_GROUP_GAP is the number of steps in elements from the previous\n+       access (if there is no gap DR_GROUP_GAP is 1). We skip loads that\n+       correspond to the gaps.\n+      */\n+      if (gap_count < DR_GROUP_GAP (vinfo_for_stmt (next_stmt)))\n+      {\n+        gap_count++;\n+        continue;\n+      }\n+\n+      while (next_stmt)\n+        {\n+\t  new_stmt = SSA_NAME_DEF_STMT (tmp_data_ref);\n+\t  /* We assume that if VEC_STMT is not NULL, this is a case of multiple\n+\t     copies, and we put the new vector statement in the first available\n+\t     RELATED_STMT.  */\n+\t  if (!STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt)))\n+\t    STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt)) = new_stmt;\n+\t  else\n+            {\n+\t      tree prev_stmt = STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt));\n+\t      tree rel_stmt = STMT_VINFO_RELATED_STMT (\n+\t\t\t\t\t\t       vinfo_for_stmt (prev_stmt));\n+\t      while (rel_stmt)\n+\t\t{\n+\t\t  prev_stmt = rel_stmt;\n+\t\t  rel_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (rel_stmt));\n+\t\t}\n+\t      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (prev_stmt)) = new_stmt;\n+            }\n+\t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n+\t  gap_count = 1;\n+\t  /* If NEXT_STMT accesses the same DR as the previous statement,\n+\t     put the same TMP_DATA_REF as its vectorized statement; otherwise\n+\t     get the next data-ref from RESULT_CHAIN.  */\n+\t  if (!next_stmt || !DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n+\t    break;\n+        }\n+    }\n+  return true;\n+}\n+\n+\n /* vectorizable_load.\n \n    Check if STMT reads a non scalar data-ref (array/pointer/structure) that \n@@ -2566,22 +3124,25 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   stmt_vec_info prev_stmt_info; \n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree new_temp;\n   int mode;\n-  tree new_stmt;\n+  tree new_stmt = NULL_TREE;\n   tree dummy;\n   enum dr_alignment_support alignment_support_cheme;\n   tree dataref_ptr = NULL_TREE;\n   tree ptr_incr;\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n-  int j;\n+  int i, j, group_size;\n   tree msq = NULL_TREE, lsq;\n   tree offset = NULL_TREE;\n   tree realignment_token = NULL_TREE;\n   tree phi_stmt = NULL_TREE;\n+  VEC(tree,heap) *dr_chain = NULL;\n+  bool strided_load = false;\n+  tree first_stmt;\n \n   /* Is vectorizable load? */\n   if (!STMT_VINFO_RELEVANT_P (stmt_info))\n@@ -2605,7 +3166,9 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     return false;\n \n   op = TREE_OPERAND (stmt, 1);\n-  if (TREE_CODE (op) != ARRAY_REF && TREE_CODE (op) != INDIRECT_REF)\n+  if (TREE_CODE (op) != ARRAY_REF \n+      && TREE_CODE (op) != INDIRECT_REF\n+      && !DR_GROUP_FIRST_DR (stmt_info))\n     return false;\n \n   if (!STMT_VINFO_DATA_REF (stmt_info))\n@@ -2622,6 +3185,16 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       return false;\n     }\n \n+  /* Check if the load is a part of an interleaving chain.  */\n+  if (DR_GROUP_FIRST_DR (stmt_info))\n+    {\n+      strided_load = true;\n+\n+      /* Check if interleaving is supported.  */\n+      if (!vect_strided_load_supported (vectype))\n+\treturn false;\n+    }\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n@@ -2633,9 +3206,30 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform load.\");\n \n-  alignment_support_cheme = vect_supportable_dr_alignment (dr);\n+  if (strided_load)\n+    {\n+      first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+      /* Check if the chain of loads is already vectorized.  */\n+      if (STMT_VINFO_VEC_STMT (vinfo_for_stmt (first_stmt)))\n+\t{\n+\t  *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n+\t  return true;\n+\t}\n+      first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+      group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      dr_chain = VEC_alloc (tree, heap, group_size);\n+    }\n+  else\n+    {\n+      first_stmt = stmt;\n+      first_dr = dr;\n+      group_size = 1;\n+    }\n+\n+  alignment_support_cheme = vect_supportable_dr_alignment (first_dr);\n   gcc_assert (alignment_support_cheme);\n \n+\n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n      more than one vector stmt - i.e - we need to \"unroll\" the\n@@ -2671,6 +3265,39 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n      information we recorded in RELATED_STMT field is used to vectorize \n      stmt S2.  */\n \n+  /* In case of interleaving (non-unit strided access):\n+\n+     S1:  x2 = &base + 2\n+     S2:  x0 = &base\n+     S3:  x1 = &base + 1\n+     S4:  x3 = &base + 3\n+\n+     Vectorized loads are created in the order of memory accesses \n+     starting from the access of the first stmt of the chain:\n+\n+     VS1: vx0 = &base\n+     VS2: vx1 = &base + vec_size*1\n+     VS3: vx3 = &base + vec_size*2\n+     VS4: vx4 = &base + vec_size*3\n+\n+     Then permutation statements are generated:\n+\n+     VS5: vx5 = VEC_EXTRACT_EVEN_EXPR < vx0, vx1 >\n+     VS6: vx6 = VEC_EXTRACT_ODD_EXPR < vx0, vx1 >\n+       ...\n+\n+     And they are put in STMT_VINFO_VEC_STMT of the corresponding scalar stmts\n+     (the order of the data-refs in the output of vect_permute_load_chain\n+     corresponds to the order of scalar stmts in the interleaving chain - see\n+     the documentaion of vect_permute_load_chain()).\n+     The generation of permutation stmts and recording them in\n+     STMT_VINFO_VEC_STMT is done in vect_transform_strided_load().\n+\n+     In case of both multiple types and interleaving, the vector loads and \n+     permutation stmts above are created for every copy. The result vector stmts\n+     are put in STMT_VINFO_VEC_STMT for the first copy and in the corresponding\n+     STMT_VINFO_RELATED_STMT for the next copies.  */\n+\n   /* If the data reference is aligned (dr_aligned) or potentially unaligned\n      on a target that supports unaligned accesses (dr_unaligned_supported)\n      we generate the following code:\n@@ -2698,12 +3325,11 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n            vec_dest = realign_load (msq, lsq, realignment_token)\n            indx = indx + 1;\n            msq = lsq;\n-         }\n-  */\n+         }   */\n \n   if (alignment_support_cheme == dr_unaligned_software_pipeline)\n     {\n-      msq = vect_setup_realignment (stmt, bsi, &realignment_token);\n+      msq = vect_setup_realignment (first_stmt, bsi, &realignment_token);\n       phi_stmt = SSA_NAME_DEF_STMT (msq);\n       offset = size_int (TYPE_VECTOR_SUBPARTS (vectype) - 1);\n     }\n@@ -2713,69 +3339,86 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     { \n       /* 1. Create the vector pointer update chain.  */\n       if (j == 0)\n-        dataref_ptr = vect_create_data_ref_ptr (stmt, bsi, offset,\n+        dataref_ptr = vect_create_data_ref_ptr (first_stmt, bsi, offset,\n                                                 &dummy, &ptr_incr, false);\n       else\n         dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\n \n-      /* 2. Create the vector-load in the loop.  */\n-      switch (alignment_support_cheme)\n-      {\n-      case dr_aligned:\n-        gcc_assert (aligned_access_p (dr));\n-        data_ref = build_fold_indirect_ref (dataref_ptr);\n-        break;\n-      case dr_unaligned_supported:\n-        {\n-          int mis = DR_MISALIGNMENT (dr);\n-          tree tmis = (mis == -1 ? size_zero_node : size_int (mis));\n-\n-          gcc_assert (!aligned_access_p (dr));\n-          tmis = size_binop (MULT_EXPR, tmis, size_int(BITS_PER_UNIT));\n-          data_ref =\n-                build2 (MISALIGNED_INDIRECT_REF, vectype, dataref_ptr, tmis);\n-          break;\n-        }\n-      case dr_unaligned_software_pipeline:\n-        gcc_assert (!aligned_access_p (dr));\n-        data_ref = build1 (ALIGN_INDIRECT_REF, vectype, dataref_ptr);\n-        break;\n-      default:\n-        gcc_unreachable ();\n-      }\n-      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n-      new_temp = make_ssa_name (vec_dest, new_stmt);\n-      TREE_OPERAND (new_stmt, 0) = new_temp;\n-      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-      copy_virtual_operands (new_stmt, stmt);\n-      mark_new_vars_to_rename (new_stmt);\n-\n-      /* 3. Handle explicit realignment if necessary/supported.  */\n-      if (alignment_support_cheme == dr_unaligned_software_pipeline)\n-        {\n-          /* Create in loop: \n-             <vec_dest = realign_load (msq, lsq, realignment_token)>  */\n-          lsq = TREE_OPERAND (new_stmt, 0);\n-          if (!realignment_token)\n-            realignment_token = dataref_ptr;\n-          vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-          new_stmt =\n-            build3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, realignment_token);\n-          new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, new_stmt);\n-          new_temp = make_ssa_name (vec_dest, new_stmt);\n-          TREE_OPERAND (new_stmt, 0) = new_temp;\n-          vect_finish_stmt_generation (stmt, new_stmt, bsi);\n-          if (j == ncopies - 1)\n-            add_phi_arg (phi_stmt, lsq, loop_latch_edge (loop));\n-          msq = lsq;\n-        }\n+      for (i = 0; i < group_size; i++)\n+\t{\n+\t  /* 2. Create the vector-load in the loop.  */\n+\t  switch (alignment_support_cheme)\n+\t    {\n+\t    case dr_aligned:\n+\t      gcc_assert (aligned_access_p (first_dr));\n+\t      data_ref = build_fold_indirect_ref (dataref_ptr);\n+\t      break;\n+\t    case dr_unaligned_supported:\n+\t      {\n+\t\tint mis = DR_MISALIGNMENT (first_dr);\n+\t\ttree tmis = (mis == -1 ? size_zero_node : size_int (mis));\n+\n+\t\tgcc_assert (!aligned_access_p (first_dr));\n+\t\ttmis = size_binop (MULT_EXPR, tmis, size_int(BITS_PER_UNIT));\n+\t\tdata_ref =\n+\t\t  build2 (MISALIGNED_INDIRECT_REF, vectype, dataref_ptr, tmis);\n+\t\tbreak;\n+\t      }\n+\t    case dr_unaligned_software_pipeline:\n+\t      gcc_assert (!aligned_access_p (first_dr));\n+\t      data_ref = build1 (ALIGN_INDIRECT_REF, vectype, dataref_ptr);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\t  new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, data_ref);\n+\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t  TREE_OPERAND (new_stmt, 0) = new_temp;\n+\t  vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\t  copy_virtual_operands (new_stmt, stmt);\n+\t  mark_new_vars_to_rename (new_stmt);\n+\n+\t  /* 3. Handle explicit realignment if necessary/supported.  */\n+\t  if (alignment_support_cheme == dr_unaligned_software_pipeline)\n+\t    {\n+\t      /* Create in loop: \n+\t\t <vec_dest = realign_load (msq, lsq, realignment_token)>  */\n+\t      lsq = TREE_OPERAND (new_stmt, 0);\n+\t      if (!realignment_token)\n+\t\trealignment_token = dataref_ptr;\n+\t      vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\t      new_stmt =\n+\t\tbuild3 (REALIGN_LOAD_EXPR, vectype, msq, lsq, realignment_token);\n+\t      new_stmt = build2 (MODIFY_EXPR, vectype, vec_dest, new_stmt);\n+\t      new_temp = make_ssa_name (vec_dest, new_stmt);\n+\t      TREE_OPERAND (new_stmt, 0) = new_temp;\n+\t      vect_finish_stmt_generation (stmt, new_stmt, bsi);\n+\t      if (i == group_size - 1 && j == ncopies - 1)\n+\t\tadd_phi_arg (phi_stmt, lsq, loop_latch_edge (loop));\n+\t      msq = lsq;\n+\t    }\n+\t  if (strided_load)\n+\t    VEC_quick_push (tree, dr_chain, new_temp);\n+\t  if (i < group_size - 1)\n+\t    dataref_ptr = bump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt);\t  \n+\t}\n \n-      if (j == 0)\n-        STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+      if (strided_load)\n+\t{\n+\t  if (!vect_transform_strided_load (stmt, dr_chain, group_size, bsi))\n+\t    return false;\t  \n+\t  *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n+\t  dr_chain = VEC_alloc (tree, heap, group_size);\n+\t}\n       else\n-        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t{\n+\t  if (j == 0)\n+\t    STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+\t  else\n+\t    STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\t  prev_stmt_info = vinfo_for_stmt (new_stmt);\n+\t}\n     }\n \n   return true;\n@@ -3011,7 +3654,7 @@ vectorizable_condition (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n    Create a vectorized stmt to replace STMT, and insert it at BSI.  */\n \n bool\n-vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n+vect_transform_stmt (tree stmt, block_stmt_iterator *bsi, bool *strided_store)\n {\n   bool is_store = false;\n   tree vec_stmt = NULL_TREE;\n@@ -3051,7 +3694,18 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n       case store_vec_info_type:\n \tdone = vectorizable_store (stmt, bsi, &vec_stmt);\n \tgcc_assert (done);\n-\tis_store = true;\n+\tif (DR_GROUP_FIRST_DR (stmt_info))\n+\t  {\n+\t    /* In case of interleaving, the whole chain is vectorized when the\n+\t       last store in the chain is reached. Store stmts before the last\n+\t       one are skipped, and there vec_stmt_info shoudn't be freed\n+\t       meanwhile.  */\n+\t    *strided_store = true;\n+\t    if (STMT_VINFO_VEC_STMT (stmt_info))\n+\t      is_store = true;\n+\t  }\n+\telse\n+\t  is_store = true;\n \tbreak;\n \n       case condition_vec_info_type:\n@@ -3065,25 +3719,29 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi)\n \tgcc_unreachable ();\n       }\n \n-      gcc_assert (vec_stmt);\n-      STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n-      orig_stmt_in_pattern = STMT_VINFO_RELATED_STMT (stmt_info);\n-      if (orig_stmt_in_pattern)\n-        {\n-          stmt_vec_info stmt_vinfo = vinfo_for_stmt (orig_stmt_in_pattern);\n-          if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n-            {\n-              gcc_assert (STMT_VINFO_RELATED_STMT (stmt_vinfo) == stmt);\n-\n-              /* STMT was inserted by the vectorizer to replace a computation \n-                 idiom.  ORIG_STMT_IN_PATTERN is a stmt in the original\n-                 sequence that computed this idiom.  We need to record a pointer\n-                 to VEC_STMT in the stmt_info of ORIG_STMT_IN_PATTERN.  See more\n-                 detail in the documentation of vect_pattern_recog.  */\n-\n-              STMT_VINFO_VEC_STMT (stmt_vinfo) = vec_stmt;\n-            }\n-        }\n+      gcc_assert (vec_stmt || *strided_store);\n+      if (vec_stmt)\n+\t{\n+\t  STMT_VINFO_VEC_STMT (stmt_info) = vec_stmt;\n+\t  orig_stmt_in_pattern = STMT_VINFO_RELATED_STMT (stmt_info);\n+\t  if (orig_stmt_in_pattern)\n+\t    {\n+\t      stmt_vec_info stmt_vinfo = vinfo_for_stmt (orig_stmt_in_pattern);\n+\t      if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n+\t\t{\n+\t\t  gcc_assert (STMT_VINFO_RELATED_STMT (stmt_vinfo) == stmt);\n+\t\t  \n+\t\t  /* STMT was inserted by the vectorizer to replace a \n+\t\t     computation idiom.  ORIG_STMT_IN_PATTERN is a stmt in the \n+\t\t     original sequence that computed this idiom.  We need to \n+\t\t     record a pointer to VEC_STMT in the stmt_info of \n+\t\t     ORIG_STMT_IN_PATTERN.  See more details in the \n+\t\t     documentation of vect_pattern_recog.  */\n+\n+\t\t  STMT_VINFO_VEC_STMT (stmt_vinfo) = vec_stmt;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n   if (STMT_VINFO_LIVE_P (stmt_info))\n@@ -3485,7 +4143,14 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n    prolog_niters = min ( LOOP_NITERS , (VF - addr_mis/elem_size)&(VF-1) )\n    \n    (elem_size = element type size; an element is the scalar element \n-\twhose type is the inner type of the vectype)  */\n+\twhose type is the inner type of the vectype)  \n+\n+   For interleaving,\n+\n+   prolog_niters = min ( LOOP_NITERS , \n+                        (VF/group_size - addr_mis/elem_size)&(VF/group_size-1) )\n+\t where group_size is the size of the interleaved group.\n+*/\n \n static tree \n vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n@@ -3502,18 +4167,29 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int vectype_align = TYPE_ALIGN (vectype) / BITS_PER_UNIT;\n   tree niters_type = TREE_TYPE (loop_niters);\n+  int group_size = 1;\n+  int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n+\n+  if (DR_GROUP_FIRST_DR (stmt_info))\n+    {\n+      /* For interleaved access element size must be multipled by the size of\n+\t the interleaved group.  */\n+      group_size = DR_GROUP_SIZE (vinfo_for_stmt (\n+\t\t\t\t\t       DR_GROUP_FIRST_DR (stmt_info)));\n+      element_size *= group_size;\n+    }\n \n   pe = loop_preheader_edge (loop); \n \n   if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n     {\n       int byte_misalign = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-      int element_size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (DR_REF (dr))));\n       int elem_misalign = byte_misalign / element_size;\n \n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"known alignment = %d.\", byte_misalign);\n-      iters = build_int_cst (niters_type, (vf - elem_misalign)&(vf-1));\n+      iters = build_int_cst (niters_type, \n+\t\t\t     (vf - elem_misalign)&(vf/group_size-1));\n     }\n   else\n     {\n@@ -3806,6 +4482,7 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   bitmap_iterator bi;\n   unsigned int j;\n+  bool strided_store;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n@@ -3936,17 +4613,53 @@ vect_transform_loop (loop_vec_info loop_vinfo,\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"transform statement.\");\n \n-\t  is_store = vect_transform_stmt (stmt, &si);\n-\t  if (is_store)\n-\t    {\n-\t      /* Free the attached stmt_vec_info and remove the stmt.  */\n-\t      stmt_ann_t ann = stmt_ann (stmt);\n-\t      free (stmt_info);\n-\t      set_stmt_info (ann, NULL);\n-\t      bsi_remove (&si, true);\n-\t      continue;\n+\t  strided_store = false;\n+\t  is_store = vect_transform_stmt (stmt, &si, &strided_store);\n+          if (is_store)\n+            {\n+\t      stmt_ann_t ann;\n+\t      if (DR_GROUP_FIRST_DR (stmt_info))\n+\t\t{\n+\t\t  /* Interleaving. If IS_STORE is TRUE, the vectorization of the\n+\t\t     interleaving chain was completed - free all the stores in\n+\t\t     the chain.  */\n+\t\t  tree next = DR_GROUP_FIRST_DR (stmt_info);\n+\t\t  tree tmp;\n+\t\t  stmt_vec_info next_stmt_info;\n+\n+\t\t  while (next)\n+\t\t    {\n+\t\t      next_stmt_info = vinfo_for_stmt (next);\n+\t\t      /* Free the attached stmt_vec_info and remove the stmt.  */\n+\t\t      ann = stmt_ann (next);\n+\t\t      tmp = DR_GROUP_NEXT_DR (next_stmt_info);\n+\t\t      free (next_stmt_info);\n+\t\t      set_stmt_info (ann, NULL);\n+\t\t      next = tmp;\n+\t\t    }\n+\t\t  bsi_remove (&si, true);\n+\t\t  continue;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Free the attached stmt_vec_info and remove the stmt.  */\n+\t\t  ann = stmt_ann (stmt);\n+\t\t  free (stmt_info);\n+\t\t  set_stmt_info (ann, NULL);\n+\t\t  bsi_remove (&si, true);\n+\t\t  continue;\n+\t\t}\n \t    }\n-\n+\t  else\n+\t    {\n+\t      if (strided_store)\n+\t\t{\n+\t\t  /* This is case of skipped interleaved store. We don't free\n+\t\t     its stmt_vec_info.  */\n+\t\t  bsi_remove (&si, true);\n+\t\t  continue;\n+\t\t}\n+            }\n \t  bsi_next (&si);\n \t}\t\t        /* stmts in BB */\n     }\t\t\t\t/* BBs in loop */"}, {"sha": "b349c89cb7e54bc230f5f122c80091cbbabe0d4a", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -1370,6 +1370,12 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   else\n     STMT_VINFO_DEF_TYPE (res) = vect_loop_def;\n   STMT_VINFO_SAME_ALIGN_REFS (res) = VEC_alloc (dr_p, heap, 5);\n+  DR_GROUP_FIRST_DR (res) = NULL_TREE;\n+  DR_GROUP_NEXT_DR (res) = NULL_TREE;\n+  DR_GROUP_SIZE (res) = 0;\n+  DR_GROUP_STORE_COUNT (res) = 0;\n+  DR_GROUP_GAP (res) = 0;\n+  DR_GROUP_SAME_DR_STMT (res) = NULL_TREE;\n \n   return res;\n }"}, {"sha": "9d75133443f6912a997d05f2c465704d867c965e", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -235,21 +235,50 @@ typedef struct _stmt_vec_info {\n   /* Classify the def of this stmt.  */\n   enum vect_def_type def_type;\n \n+  /* Interleaving info.  */\n+  /* First data-ref in the interleaving group.  */\n+  tree first_dr;\n+  /* Pointer to the next data-ref in the group.  */\n+  tree next_dr;\n+  /* The size of the interleaving group.  */\n+  unsigned int size;\n+  /* For stores, number of stores from this group seen. We vectorize the last\n+     one.  */\n+  unsigned int store_count;\n+  /* For loads only, the gap from the previous load. For consecutive loads, GAP\n+     is 1.  */\n+  unsigned int gap;\n+  /* In case that two or more stmts share data-ref, this is the pointer to the\n+     previously detected stmt with the same dr.  */\n+  tree same_dr_stmt;\n } *stmt_vec_info;\n \n /* Access Functions.  */\n-#define STMT_VINFO_TYPE(S)                (S)->type\n-#define STMT_VINFO_STMT(S)                (S)->stmt\n-#define STMT_VINFO_LOOP_VINFO(S)          (S)->loop_vinfo\n-#define STMT_VINFO_RELEVANT(S)            (S)->relevant\n-#define STMT_VINFO_LIVE_P(S)              (S)->live\n-#define STMT_VINFO_VECTYPE(S)             (S)->vectype\n-#define STMT_VINFO_VEC_STMT(S)            (S)->vectorized_stmt\n-#define STMT_VINFO_DATA_REF(S)            (S)->data_ref_info\n-#define STMT_VINFO_IN_PATTERN_P(S)        (S)->in_pattern_p\n-#define STMT_VINFO_RELATED_STMT(S)        (S)->related_stmt\n-#define STMT_VINFO_SAME_ALIGN_REFS(S)     (S)->same_align_refs\n-#define STMT_VINFO_DEF_TYPE(S)            (S)->def_type\n+#define STMT_VINFO_TYPE(S)                 (S)->type\n+#define STMT_VINFO_STMT(S)                 (S)->stmt\n+#define STMT_VINFO_LOOP_VINFO(S)           (S)->loop_vinfo\n+#define STMT_VINFO_RELEVANT(S)             (S)->relevant\n+#define STMT_VINFO_LIVE_P(S)               (S)->live\n+#define STMT_VINFO_VECTYPE(S)              (S)->vectype\n+#define STMT_VINFO_VEC_STMT(S)             (S)->vectorized_stmt\n+#define STMT_VINFO_DATA_REF(S)             (S)->data_ref_info\n+#define STMT_VINFO_IN_PATTERN_P(S)         (S)->in_pattern_p\n+#define STMT_VINFO_RELATED_STMT(S)         (S)->related_stmt\n+#define STMT_VINFO_SAME_ALIGN_REFS(S)      (S)->same_align_refs\n+#define STMT_VINFO_DEF_TYPE(S)             (S)->def_type\n+#define STMT_VINFO_DR_GROUP_FIRST_DR(S)    (S)->first_dr\n+#define STMT_VINFO_DR_GROUP_NEXT_DR(S)     (S)->next_dr\n+#define STMT_VINFO_DR_GROUP_SIZE(S)        (S)->size\n+#define STMT_VINFO_DR_GROUP_STORE_COUNT(S) (S)->store_count\n+#define STMT_VINFO_DR_GROUP_GAP(S)         (S)->gap\n+#define STMT_VINFO_DR_GROUP_SAME_DR_STMT(S)(S)->same_dr_stmt\n+\n+#define DR_GROUP_FIRST_DR(S)               (S)->first_dr\n+#define DR_GROUP_NEXT_DR(S)                (S)->next_dr\n+#define DR_GROUP_SIZE(S)                   (S)->size\n+#define DR_GROUP_STORE_COUNT(S)            (S)->store_count\n+#define DR_GROUP_GAP(S)                    (S)->gap\n+#define DR_GROUP_SAME_DR_STMT(S)           (S)->same_dr_stmt\n \n #define STMT_VINFO_RELEVANT_P(S)          ((S)->relevant != vect_unused_in_loop)\n "}, {"sha": "d5df9f26125bf0ae4b93cfa5ce9452953eda3ac0", "filename": "gcc/tree.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98b44b0eeac41545f8b4d236ba5b3fe1562203aa/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=98b44b0eeac41545f8b4d236ba5b3fe1562203aa", "patch": "@@ -1088,6 +1088,14 @@ DEFTREECODE (VEC_UNPACK_LO_EXPR, \"vec_unpack_lo_expr\", tcc_unary, 1)\n DEFTREECODE (VEC_PACK_MOD_EXPR, \"vec_pack_mod_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_PACK_SAT_EXPR, \"vec_pack_sat_expr\", tcc_binary, 2)\n                                                                                 \n+/* Extract even/odd fields from vectors.  */\n+DEFTREECODE (VEC_EXTRACT_EVEN_EXPR, \"vec_extracteven_expr\", tcc_binary, 2)\n+DEFTREECODE (VEC_EXTRACT_ODD_EXPR, \"vec_extractodd_expr\", tcc_binary, 2)\n+\n+/* Merge input vectors interleaving their fields.  */\n+DEFTREECODE (VEC_INTERLEAVE_HIGH_EXPR, \"vec_interleavehigh_expr\", tcc_binary, 2)\n+DEFTREECODE (VEC_INTERLEAVE_LOW_EXPR, \"vec_interleavelow_expr\", tcc_binary, 2)\n+\n /*\n Local variables:\n mode:c"}]}