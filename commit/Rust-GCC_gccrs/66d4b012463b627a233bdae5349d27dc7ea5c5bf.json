{"sha": "66d4b012463b627a233bdae5349d27dc7ea5c5bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZkNGIwMTI0NjNiNjI3YTIzM2JkYWU1MzQ5ZDI3ZGM3ZWE1YzViZg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2014-12-01T18:26:20Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2014-12-01T18:26:20Z"}, "message": "combine.c (struct insn_link): New field `regno'.\n\n\t* combine.c (struct insn_link): New field `regno'.\n\t(alloc_insn_link): New parameter `regno'.  Use it.\n\t(find_single_use): Check the new field.\n\t(can_combine_def_p, can_combine_use_p): New functions.  Split\n\toff from ...\n\t(create_log_links): ... here.  Correct data type of `regno'.\n\tAdjust call to alloc_insn_link.\n\t(adjust_for_new_dest): Find regno, use it in call to\n\talloc_insn_link.\n\t(try_combine): Check reg_used_between_p when combining a PARALLEL\n\tas earlier insn.  Adjust call to alloc_insn_link.\n\t(distribute_links): Check the new field.\n\nFrom-SVN: r218241", "tree": {"sha": "614235e83afd25d65afa5ee8cffb6491b5c709cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/614235e83afd25d65afa5ee8cffb6491b5c709cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66d4b012463b627a233bdae5349d27dc7ea5c5bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66d4b012463b627a233bdae5349d27dc7ea5c5bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66d4b012463b627a233bdae5349d27dc7ea5c5bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66d4b012463b627a233bdae5349d27dc7ea5c5bf/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeafb31957a4382a941e98a79d3e3ff1b5ca97a1"}], "stats": {"total": 159, "additions": 104, "deletions": 55}, "files": [{"sha": "bd31731cac5f67bdb593693d7eea72744dd75483", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d4b012463b627a233bdae5349d27dc7ea5c5bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d4b012463b627a233bdae5349d27dc7ea5c5bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66d4b012463b627a233bdae5349d27dc7ea5c5bf", "patch": "@@ -1,3 +1,18 @@\n+2014-12-01  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* combine.c (struct insn_link): New field `regno'.\n+\t(alloc_insn_link): New parameter `regno'.  Use it.\n+\t(find_single_use): Check the new field.\n+\t(can_combine_def_p, can_combine_use_p): New functions.  Split\n+\toff from ...\n+\t(create_log_links): ... here.  Correct data type of `regno'.\n+\tAdjust call to alloc_insn_link.\n+\t(adjust_for_new_dest): Find regno, use it in call to\n+\talloc_insn_link.\n+\t(try_combine): Check reg_used_between_p when combining a PARALLEL\n+\tas earlier insn.  Adjust call to alloc_insn_link.\n+\t(distribute_links): Check the new field.\n+\n 2014-12-01  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR jit/63854"}, {"sha": "f94d8770a347aaa099bc1763dbfba153088671fb", "filename": "gcc/combine.c", "status": "modified", "additions": 89, "deletions": 55, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66d4b012463b627a233bdae5349d27dc7ea5c5bf/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66d4b012463b627a233bdae5349d27dc7ea5c5bf/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=66d4b012463b627a233bdae5349d27dc7ea5c5bf", "patch": "@@ -328,6 +328,7 @@ static int *uid_insn_cost;\n \n struct insn_link {\n   rtx_insn *insn;\n+  unsigned int regno;\n   struct insn_link *next;\n };\n \n@@ -346,12 +347,13 @@ static struct obstack insn_link_obstack;\n /* Allocate a link.  */\n \n static inline struct insn_link *\n-alloc_insn_link (rtx_insn *insn, struct insn_link *next)\n+alloc_insn_link (rtx_insn *insn, unsigned int regno, struct insn_link *next)\n {\n   struct insn_link *l\n     = (struct insn_link *) obstack_alloc (&insn_link_obstack,\n \t\t\t\t\t  sizeof (struct insn_link));\n   l->insn = insn;\n+  l->regno = regno;\n   l->next = next;\n   return l;\n }\n@@ -686,7 +688,7 @@ find_single_use (rtx dest, rtx_insn *insn, rtx_insn **ploc)\n     if (INSN_P (next) && dead_or_set_p (next, dest))\n       {\n \tFOR_EACH_LOG_LINK (link, next)\n-\t  if (link->insn == insn)\n+\t  if (link->insn == insn && link->regno == REGNO (dest))\n \t    break;\n \n \tif (link)\n@@ -982,6 +984,43 @@ delete_noop_moves (void)\n }\n \n \f\n+/* Return false if we do not want to (or cannot) combine DEF.  */\n+static bool\n+can_combine_def_p (df_ref def)\n+{\n+  /* Do not consider if it is pre/post modification in MEM.  */\n+  if (DF_REF_FLAGS (def) & DF_REF_PRE_POST_MODIFY)\n+    return false;\n+\n+  unsigned int regno = DF_REF_REGNO (def);\n+\n+  /* Do not combine frame pointer adjustments.  */\n+  if ((regno == FRAME_POINTER_REGNUM\n+       && (!reload_completed || frame_pointer_needed))\n+#if !HARD_FRAME_POINTER_IS_FRAME_POINTER\n+      || (regno == HARD_FRAME_POINTER_REGNUM\n+\t  && (!reload_completed || frame_pointer_needed))\n+#endif\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+      || (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+#endif\n+      )\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return false if we do not want to (or cannot) combine USE.  */\n+static bool\n+can_combine_use_p (df_ref use)\n+{\n+  /* Do not consider the usage of the stack pointer by function call.  */\n+  if (DF_REF_FLAGS (use) & DF_REF_CALL_STACK_USAGE)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Fill in log links field for all insns.  */\n \n static void\n@@ -1015,67 +1054,46 @@ create_log_links (void)\n \n \t  FOR_EACH_INSN_DEF (def, insn)\n             {\n-              int regno = DF_REF_REGNO (def);\n+              unsigned int regno = DF_REF_REGNO (def);\n               rtx_insn *use_insn;\n \n               if (!next_use[regno])\n                 continue;\n \n-              /* Do not consider if it is pre/post modification in MEM.  */\n-              if (DF_REF_FLAGS (def) & DF_REF_PRE_POST_MODIFY)\n-                continue;\n+\t      if (!can_combine_def_p (def))\n+\t\tcontinue;\n \n-              /* Do not make the log link for frame pointer.  */\n-              if ((regno == FRAME_POINTER_REGNUM\n-                   && (! reload_completed || frame_pointer_needed))\n-#if !HARD_FRAME_POINTER_IS_FRAME_POINTER\n-                  || (regno == HARD_FRAME_POINTER_REGNUM\n-                      && (! reload_completed || frame_pointer_needed))\n-#endif\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-                  || (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n-#endif\n-                  )\n-                continue;\n+\t      use_insn = next_use[regno];\n+\t      next_use[regno] = NULL;\n \n-              use_insn = next_use[regno];\n-              if (BLOCK_FOR_INSN (use_insn) == bb)\n-                {\n-                  /* flow.c claimed:\n-\n-                     We don't build a LOG_LINK for hard registers contained\n-                     in ASM_OPERANDs.  If these registers get replaced,\n-                     we might wind up changing the semantics of the insn,\n-                     even if reload can make what appear to be valid\n-                     assignments later.  */\n-                  if (regno >= FIRST_PSEUDO_REGISTER\n-                      || asm_noperands (PATTERN (use_insn)) < 0)\n-\t\t    {\n-\t\t      /* Don't add duplicate links between instructions.  */\n-\t\t      struct insn_link *links;\n-\t\t      FOR_EACH_LOG_LINK (links, use_insn)\n-\t\t        if (insn == links->insn)\n-\t\t\t  break;\n+\t      if (BLOCK_FOR_INSN (use_insn) != bb)\n+\t\tcontinue;\n \n-\t\t      if (!links)\n-\t\t\tLOG_LINKS (use_insn)\n-\t\t\t  = alloc_insn_link (insn, LOG_LINKS (use_insn));\n-\t\t    }\n-                }\n-              next_use[regno] = NULL;\n-            }\n+\t      /* flow.c claimed:\n \n-\t  FOR_EACH_INSN_USE (use, insn)\n-            {\n-\t      int regno = DF_REF_REGNO (use);\n+\t\t We don't build a LOG_LINK for hard registers contained\n+\t\t in ASM_OPERANDs.  If these registers get replaced,\n+\t\t we might wind up changing the semantics of the insn,\n+\t\t even if reload can make what appear to be valid\n+\t\t assignments later.  */\n+\t      if (regno < FIRST_PSEUDO_REGISTER\n+\t\t  && asm_noperands (PATTERN (use_insn)) >= 0)\n+\t\tcontinue;\n \n-              /* Do not consider the usage of the stack pointer\n-\t\t by function call.  */\n-              if (DF_REF_FLAGS (use) & DF_REF_CALL_STACK_USAGE)\n-                continue;\n+\t      /* Don't add duplicate links between instructions.  */\n+\t      struct insn_link *links;\n+\t      FOR_EACH_LOG_LINK (links, use_insn)\n+\t        if (insn == links->insn && regno == links->regno)\n+\t\t  break;\n \n-              next_use[regno] = insn;\n+\t      if (!links)\n+\t\tLOG_LINKS (use_insn)\n+\t\t  = alloc_insn_link (insn, regno, LOG_LINKS (use_insn));\n             }\n+\n+\t  FOR_EACH_INSN_USE (use, insn)\n+\t    if (can_combine_use_p (use))\n+\t      next_use[DF_REF_REGNO (use)] = insn;\n         }\n     }\n \n@@ -2347,7 +2365,19 @@ adjust_for_new_dest (rtx_insn *insn)\n   /* The new insn will have a destination that was previously the destination\n      of an insn just above it.  Call distribute_links to make a LOG_LINK from\n      the next use of that destination.  */\n-  distribute_links (alloc_insn_link (insn, NULL));\n+\n+  rtx set = single_set (insn);\n+  gcc_assert (set);\n+\n+  rtx reg = SET_DEST (set);\n+\n+  while (GET_CODE (reg) == ZERO_EXTRACT\n+\t || GET_CODE (reg) == STRICT_LOW_PART\n+\t || GET_CODE (reg) == SUBREG)\n+    reg = XEXP (reg, 0);\n+  gcc_assert (REG_P (reg));\n+\n+  distribute_links (alloc_insn_link (insn, REGNO (reg), NULL));\n \n   df_insn_rescan (insn);\n }\n@@ -2759,7 +2789,9 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n       && GET_CODE (XVECEXP (PATTERN (i2), 0, 1)) == SET\n       && REG_P (SET_DEST (XVECEXP (PATTERN (i2), 0, 1)))\n       && rtx_equal_p (XEXP (SET_SRC (XVECEXP (PATTERN (i2), 0, 0)), 0),\n-\t\t      SET_SRC (XVECEXP (PATTERN (i2), 0, 1))))\n+\t\t      SET_SRC (XVECEXP (PATTERN (i2), 0, 1)))\n+      && !reg_used_between_p (SET_DEST (XVECEXP (PATTERN (i2), 0, 0)), i2, i3)\n+      && !reg_used_between_p (SET_DEST (XVECEXP (PATTERN (i2), 0, 1)), i2, i3))\n     {\n       for (i = XVECLEN (PATTERN (i2), 0) - 1; i >= 2; i--)\n \tif (GET_CODE (XVECEXP (PATTERN (i2), 0, i)) != CLOBBER)\n@@ -2780,7 +2812,9 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t  SUBST (PATTERN (i2), XVECEXP (PATTERN (i2), 0, 0));\n \t  SUBST (XEXP (SET_SRC (PATTERN (i2)), 0),\n \t\t SET_DEST (PATTERN (i1)));\n-\t  SUBST_LINK (LOG_LINKS (i2), alloc_insn_link (i1, LOG_LINKS (i2)));\n+\t  unsigned int regno = REGNO (SET_DEST (PATTERN (i1)));\n+\t  SUBST_LINK (LOG_LINKS (i2),\n+\t\t      alloc_insn_link (i1, regno, LOG_LINKS (i2)));\n \t}\n     }\n #endif\n@@ -13841,7 +13875,7 @@ distribute_links (struct insn_link *links)\n \t  struct insn_link *link2;\n \n \t  FOR_EACH_LOG_LINK (link2, place)\n-\t    if (link2->insn == link->insn)\n+\t    if (link2->insn == link->insn && link2->regno == link->regno)\n \t      break;\n \n \t  if (link2 == NULL)"}]}