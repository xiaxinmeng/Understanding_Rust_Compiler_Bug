{"sha": "3342b6fdab13e428d1f609c4c4b8af19d3d1cc26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM0MmI2ZmRhYjEzZTQyOGQxZjYwOWM0YzRiOGFmMTlkM2QxY2MyNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-05-18T20:43:43Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-05-18T20:43:43Z"}, "message": "/tmp/pl\n\nFrom-SVN: r42283", "tree": {"sha": "2cdc3e2a7faf6f393e5afd2bd8ea0177801d9341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cdc3e2a7faf6f393e5afd2bd8ea0177801d9341"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3342b6fdab13e428d1f609c4c4b8af19d3d1cc26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3342b6fdab13e428d1f609c4c4b8af19d3d1cc26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3342b6fdab13e428d1f609c4c4b8af19d3d1cc26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3342b6fdab13e428d1f609c4c4b8af19d3d1cc26/comments", "author": null, "committer": null, "parents": [{"sha": "63f36be6e7929a36a0c37ce9808ee31763d2d152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63f36be6e7929a36a0c37ce9808ee31763d2d152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63f36be6e7929a36a0c37ce9808ee31763d2d152"}], "stats": {"total": 29, "additions": 20, "deletions": 9}, "files": [{"sha": "7c150e1ce758bf1be5484617ddaedf4c6b91ed17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3342b6fdab13e428d1f609c4c4b8af19d3d1cc26/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3342b6fdab13e428d1f609c4c4b8af19d3d1cc26/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3342b6fdab13e428d1f609c4c4b8af19d3d1cc26", "patch": "@@ -1,3 +1,9 @@\n+Fri May 18 07:26:34 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* dbxout.c (dbxout_type): Use host_integerp.\n+\t(dbxout_symbol, case TYPE_DECL): Don't generate tag for records of\n+\tvariable size.\n+\n 2001-05-18  Stan Shebs  <shebs@apple.com>\n \n \t* configure.in (gcc_cv_as_eh_frame): Cope with old assemblers."}, {"sha": "1cc495b9c21232de3c9b6071b9f246ca556d8163", "filename": "gcc/dbxout.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3342b6fdab13e428d1f609c4c4b8af19d3d1cc26/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3342b6fdab13e428d1f609c4c4b8af19d3d1cc26/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=3342b6fdab13e428d1f609c4c4b8af19d3d1cc26", "patch": "@@ -1069,7 +1069,7 @@ dbxout_type (type, full, show_arg_types)\n \t Sun dbx crashes if we do.  */\n       if (! full || !COMPLETE_TYPE_P (type)\n \t  /* No way in DBX fmt to describe a variable size.  */\n-\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\t  || ! host_integerp (TYPE_SIZE (type), 1))\n \treturn;\n       break;\n     case TYPE_DEFINED:\n@@ -1094,7 +1094,7 @@ dbxout_type (type, full, show_arg_types)\n \t && !full)\n \t|| !COMPLETE_TYPE_P (type)\n \t/* No way in DBX fmt to describe a variable size.  */\n-\t|| TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\t|| ! host_integerp (TYPE_SIZE (type), 1))\n       {\n \ttypevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;\n \treturn;\n@@ -1146,7 +1146,7 @@ dbxout_type (type, full, show_arg_types)\n       /* If this is a subtype of another integer type, always prefer to\n \t write it as a subtype.  */\n       else if (TREE_TYPE (type) != 0\n-\t       && TREE_CODE (TREE_TYPE (type)) == INTEGER_CST)\n+\t       && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE)\n \tdbxout_range_type (type);\n \n       else\n@@ -1176,7 +1176,8 @@ dbxout_type (type, full, show_arg_types)\n \t      && TYPE_MAX_VALUE (type) != 0\n \t      && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n \t      && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)\n-\t\t  || (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)\n+\t\t  || ((TYPE_PRECISION (type)\n+\t\t       == TYPE_PRECISION (integer_type_node))\n \t\t      && TREE_UNSIGNED (type))\n \t\t  || TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT\n \t\t  || (TYPE_PRECISION (type) == HOST_BITS_PER_WIDE_INT\n@@ -1363,7 +1364,7 @@ dbxout_type (type, full, show_arg_types)\n \t     && !full)\n \t    || !COMPLETE_TYPE_P (type)\n \t    /* No way in DBX fmt to describe a variable size.  */\n-\t    || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\t    || ! host_integerp (TYPE_SIZE (type), 1))\n \t  {\n \t    /* If the type is just a cross reference, output one\n \t       and mark the type as partially described.\n@@ -1810,7 +1811,11 @@ dbxout_symbol (decl, local)\n \t\t&& !TREE_ASM_WRITTEN (TYPE_NAME (type))\n \t\t/* Distinguish the implicit typedefs of C++\n \t\t   from explicit ones that might be found in C.  */\n-                && DECL_ARTIFICIAL (decl))\n+                && DECL_ARTIFICIAL (decl)\n+\t\t/* Do not generate a tag for records of variable size,\n+\t\t   since this type can not be properly described in the\n+\t\t   DBX format, and it confuses some tools such as objdump.  */\n+\t\t&& ! host_integerp (TYPE_SIZE (type), 1))\n \t      {\n \t\ttree name = TYPE_NAME (type);\n \t\tif (TREE_CODE (name) == TYPE_DECL)\n@@ -1859,9 +1864,9 @@ dbxout_symbol (decl, local)\n \t    did_output = 1;\n \t  }\n \n-\t/* Don't output a tag if this is an incomplete type (TYPE_SIZE is\n-\t   zero).  This prevents the sun4 Sun OS 4.x dbx from crashing.  */ \n-\n+\t/* Don't output a tag if this is an incomplete type.  This prevents\n+\t   the sun4 Sun OS 4.x dbx from crashing.  */\n+\t\n \tif (tag_needed && TYPE_NAME (type) != 0\n \t    && (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE\n \t\t|| (DECL_NAME (TYPE_NAME (type)) != 0))"}]}