{"sha": "6382ae03d836e2a1ad66021c08fb3a32583f77d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM4MmFlMDNkODM2ZTJhMWFkNjYwMjFjMDhmYjNhMzI1ODNmNzdkOA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-05-25T01:41:18Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-05-25T01:41:18Z"}, "message": "(reemit_notes): New function.\n\n(schedule_block): Call reemit_notes twice.  Reorganize code for\nhandling SCHED_GROUP_P insns, so that reemit_notes works.\n\nFrom-SVN: r9814", "tree": {"sha": "5967f2c12217e696c181d95961d026f3158cf485", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5967f2c12217e696c181d95961d026f3158cf485"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6382ae03d836e2a1ad66021c08fb3a32583f77d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6382ae03d836e2a1ad66021c08fb3a32583f77d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6382ae03d836e2a1ad66021c08fb3a32583f77d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6382ae03d836e2a1ad66021c08fb3a32583f77d8/comments", "author": null, "committer": null, "parents": [{"sha": "20b04867c8c19136b4e97acd0eb170bcd3fdf57e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20b04867c8c19136b4e97acd0eb170bcd3fdf57e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20b04867c8c19136b4e97acd0eb170bcd3fdf57e"}], "stats": {"total": 58, "additions": 38, "deletions": 20}, "files": [{"sha": "97332280f40cd2b5b7005cc4b7313b49be819e52", "filename": "gcc/sched.c", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6382ae03d836e2a1ad66021c08fb3a32583f77d8/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6382ae03d836e2a1ad66021c08fb3a32583f77d8/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=6382ae03d836e2a1ad66021c08fb3a32583f77d8", "patch": "@@ -3103,6 +3103,33 @@ finish_sometimes_live (regs_sometimes_live, sometimes_max)\n     }\n }\n \n+/* Search INSN for fake REG_DEAD notes for NOTE_INSN_SETJMP,\n+   NOTE_INSN_LOOP_BEG, and NOTE_INSN_LOOP_END; and convert them back\n+   into NOTEs.  LAST is the last instruction output by the instruction\n+   scheduler.  Return the new value of LAST.  */\n+\n+static rtx\n+reemit_notes (insn, last)\n+     rtx insn;\n+     rtx last;\n+{\n+  rtx note;\n+\n+  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+    {\n+      if (REG_NOTE_KIND (note) == REG_DEAD\n+\t  && GET_CODE (XEXP (note, 0)) == CONST_INT)\n+\t{\n+\t  if (INTVAL (XEXP (note, 0)) == NOTE_INSN_SETJMP)\n+\t    emit_note_after (INTVAL (XEXP (note, 0)), insn);\n+\t  else\n+\t    last = emit_note_before (INTVAL (XEXP (note, 0)), last);\n+\t  remove_note (insn, note);\n+\t}\n+    }\n+  return last;\n+}\n+\n /* Use modified list scheduling to rearrange insns in basic block\n    B.  FILE, if nonzero, is where we dump interesting output about\n    this pass.  */\n@@ -3858,22 +3885,7 @@ schedule_block (b, file)\n       last = insn;\n \n       /* Check to see if we need to re-emit any notes here.  */\n-      {\n-\trtx note;\n-\n-\tfor (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t  {\n-\t    if (REG_NOTE_KIND (note) == REG_DEAD\n-\t\t&& GET_CODE (XEXP (note, 0)) == CONST_INT)\n-\t      {\n-\t\tif (INTVAL (XEXP (note, 0)) == NOTE_INSN_SETJMP)\n-\t\t  emit_note_after (INTVAL (XEXP (note, 0)), insn);\n-\t\telse\n-\t\t  last = emit_note_before (INTVAL (XEXP (note, 0)), last);\n-\t\tremove_note (insn, note);\n-\t      }\n-\t  }\n-      }\n+      last = reemit_notes (insn, last);\n \n       /* Everything that precedes INSN now either becomes \"ready\", if\n \t it can execute immediately before INSN, or \"pending\", if\n@@ -3888,7 +3900,8 @@ schedule_block (b, file)\n       /* Schedule all prior insns that must not be moved.  */\n       if (SCHED_GROUP_P (insn))\n \t{\n-\t  /* Disable these insns from being launched.  */\n+\t  /* Disable these insns from being launched, in case one of the\n+\t     insns in the group has a dependency on an earlier one.  */\n \t  link = insn;\n \t  while (SCHED_GROUP_P (link))\n \t    {\n@@ -3897,17 +3910,22 @@ schedule_block (b, file)\n \t      INSN_REF_COUNT (link) = 0;\n \t    }\n \n-\t  /* None of these insns can move forward into delay slots.  */\n+\t  /* Now handle each group insn like the main insn was handled\n+\t     above.  */\n \t  while (SCHED_GROUP_P (insn))\n \t    {\n \t      insn = PREV_INSN (insn);\n-\t      new_ready = schedule_insn (insn, ready, new_ready, clock);\n-\t      INSN_PRIORITY (insn) = DONE_PRIORITY;\n \n \t      sched_n_insns += 1;\n \t      NEXT_INSN (insn) = last;\n \t      PREV_INSN (last) = insn;\n \t      last = insn;\n+\n+\t      last = reemit_notes (insn, last);\n+\n+\t      /* ??? Why don't we set LAUNCH_PRIORITY here?  */\n+\t      new_ready = schedule_insn (insn, ready, new_ready, clock);\n+\t      INSN_PRIORITY (insn) = DONE_PRIORITY;\n \t    }\n \t}\n     }"}]}