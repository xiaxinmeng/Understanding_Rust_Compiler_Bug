{"sha": "9f313342b197d94012bd235b727564c1368eaad1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYzMTMzNDJiMTk3ZDk0MDEyYmQyMzViNzI3NTY0YzEzNjhlYWFkMQ==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2002-06-07T02:15:39Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2002-06-07T02:15:39Z"}, "message": "* gengtype.c: Add comments before all the routines.\n\nFrom-SVN: r54329", "tree": {"sha": "1482a68cc927fea9eb84a917a2a5cde6501f3795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1482a68cc927fea9eb84a917a2a5cde6501f3795"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f313342b197d94012bd235b727564c1368eaad1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f313342b197d94012bd235b727564c1368eaad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f313342b197d94012bd235b727564c1368eaad1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f313342b197d94012bd235b727564c1368eaad1/comments", "author": null, "committer": null, "parents": [{"sha": "3fa1b44830bc4c003392e2ff2c7cced5eb78f553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fa1b44830bc4c003392e2ff2c7cced5eb78f553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fa1b44830bc4c003392e2ff2c7cced5eb78f553"}], "stats": {"total": 112, "additions": 111, "deletions": 1}, "files": [{"sha": "7d319347c2d5d049aba55598a70fbfcc2965b8cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f313342b197d94012bd235b727564c1368eaad1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f313342b197d94012bd235b727564c1368eaad1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f313342b197d94012bd235b727564c1368eaad1", "patch": "@@ -1,3 +1,7 @@\n+2002-06-06  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* gengtype.c: Add comments before all the routines.\n+\n 2002-06-07  Jason Thorpe  <thorpej@wasabisystems.com>\n \n \t* config.gcc (sh5*-*-netbsd*): Remove sh/t-netbsd-sh5-32"}, {"sha": "eac1605a1eca1f2e7690b2e7ed9527a2bd996624", "filename": "gcc/gengtype.c", "status": "modified", "additions": 107, "deletions": 1, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f313342b197d94012bd235b727564c1368eaad1/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f313342b197d94012bd235b727564c1368eaad1/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=9f313342b197d94012bd235b727564c1368eaad1", "patch": "@@ -23,7 +23,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include <ctype.h>\n #include \"gengtype.h\"\n \n+/* Nonzero iff an error has occurred.  */\n static int hit_error = 0;\n+\n+/* Report an error at POS, printing MSG.  */\n+\n void\n error_at_line VPARAMS ((struct fileloc *pos, const char *msg, ...))\n {\n@@ -39,16 +43,22 @@ error_at_line VPARAMS ((struct fileloc *pos, const char *msg, ...))\n   VA_CLOSE (ap);\n }\n \n+/* The one and only TYPE_STRING.  */\n+\n struct type string_type = {\n   TYPE_STRING, NULL, NULL, GC_USED\n   UNION_INIT_ZERO\n }; \n \n+/* Lists of various things.  */\n+\n static pair_p typedefs;\n static type_p structures;\n static type_p param_structs;\n static pair_p variables;\n \n+/* Define S as a typedef to T at POS.  */\n+\n void\n do_typedef (s, t, pos)\n      const char *s;\n@@ -76,6 +86,8 @@ do_typedef (s, t, pos)\n   typedefs = p;\n }\n \n+/* Return the type previously defined for S.  Use POS to report errors.   */\n+\n type_p\n resolve_typedef (s, pos)\n      const char *s;\n@@ -89,6 +101,9 @@ resolve_typedef (s, pos)\n   return create_scalar_type (\"char\", 4);\n }\n \n+/* Create a new structure with tag NAME (or a union iff ISUNION is nonzero),\n+   at POS with fields FIELDS and options O.  */\n+\n void\n new_structure (name, isunion, pos, fields, o)\n      const char *name;\n@@ -163,6 +178,10 @@ new_structure (name, isunion, pos, fields, o)\n     s->u.s.lang_struct->u.s.bitmap |= bitmap;\n }\n \n+/* Return the previously-defined structure with tag NAME (or a union\n+   iff ISUNION is nonzero), or a new empty structure or union if none\n+   was defined previously.  */\n+\n type_p\n find_structure (name, isunion)\n      const char *name;\n@@ -184,6 +203,8 @@ find_structure (name, isunion)\n   return s;\n }\n \n+/* Return a scalar type with name NAME.  */\n+\n type_p\n create_scalar_type (name, name_len)\n      const char *name;\n@@ -195,6 +216,8 @@ create_scalar_type (name, name_len)\n   return r;\n }\n \n+/* Return a pointer to T.  */\n+\n type_p\n create_pointer (t)\n      type_p t;\n@@ -209,6 +232,8 @@ create_pointer (t)\n   return t->pointer_to;\n }\n \n+/* Return an array of length LEN.  */\n+\n type_p\n create_array (t, len)\n      type_p t;\n@@ -223,6 +248,15 @@ create_array (t, len)\n   return v;\n }\n \n+/* Perform any special processing on a type T, about to become the type\n+   of a field.  Return the appropriate type for the field.\n+   At present:\n+   - Converts pointer-to-char, with no length parameter, to TYPE_STRING;\n+   - Similarly for arrays of pointer-to-char;\n+   - Converts structures for which a parameter is provided to\n+   TYPE_PARAM_STRUCT.\n+*/   \n+\n type_p\n adjust_field_type (t, opt)\n      type_p t;\n@@ -269,6 +303,9 @@ adjust_field_type (t, opt)\n   return t;\n }\n \n+/* Add a variable named S of type T with options O defined at POS,\n+   to `variables'.  */\n+\n void\n note_variable (s, t, o, pos)\n      const char *s;\n@@ -286,6 +323,10 @@ note_variable (s, t, o, pos)\n   variables = n;\n }\n \n+/* Create a union for YYSTYPE, as yacc would do it, given a fieldlist FIELDS\n+   and information about the correspondance between token types and fields\n+   in TYPEINFO.  POS is used for error messages.  */\n+\n void\n note_yacc_type (o, fields, typeinfo, pos)\n      options_p o;\n@@ -350,6 +391,8 @@ static void process_gc_options PARAMS ((options_p, enum gc_used_enum, int *));\n static void set_gc_used_type PARAMS ((type_p, enum gc_used_enum));\n static void set_gc_used PARAMS ((pair_p));\n \n+/* Handle OPT for set_gc_used_type.  */\n+\n static void\n process_gc_options (opt, level, maybe_undef)\n      options_p opt;\n@@ -364,6 +407,8 @@ process_gc_options (opt, level, maybe_undef)\n       *maybe_undef = 1;\n }\n \n+/* Set the gc_used field of T to LEVEL, and handle the types it references.  */\n+\n static void\n set_gc_used_type (t, level)\n      type_p t;\n@@ -420,6 +465,8 @@ set_gc_used_type (t, level)\n     }\n }\n \n+/* Set the gc_used fileds of all the types pointed to by VARIABLES.  */\n+\n static void\n set_gc_used (variables)\n      pair_p variables;\n@@ -442,7 +489,13 @@ struct filemap {\n   FILE *output;\n };\n \n+/* The list of output files.  */\n+\n static filemap_p files;\n+\n+/* The output header file that is included into pretty much every\n+   source file.  */\n+\n FILE * header_file;\n \n enum {\n@@ -459,6 +512,8 @@ FILE *base_files[NUM_BASE_FILES];\n static FILE * create_file PARAMS ((const char *));\n static const char * get_file_basename PARAMS ((const char *));\n \n+/* Create and return a FILE* for a new header file to be called NAME.  */\n+\n static FILE *\n create_file (name)\n      const char *name;\n@@ -500,6 +555,8 @@ create_file (name)\n   return f;\n }\n \n+/* Open the global header file and the language-specific header files.  */\n+\n static void\n open_base_files (void)\n {\n@@ -526,6 +583,8 @@ open_base_files (void)\n #define startswith(len, c, s)  \\\n   ((size_t)(len) >= strlen (s) && memcmp (c, s, strlen (s)) == 0)\n \n+/* Determine the pathname to F relative to $(srcdir).  */\n+\n static const char *\n get_file_basename (f)\n      const char *f;\n@@ -554,6 +613,14 @@ get_file_basename (f)\n   return basename;\n }\n \n+/* Return a bitmap which has bit `1 << BASE_FILE_<lang>' set iff\n+   INPUT_FILE is used by <lang>.  \n+\n+   This function should be written to assume that a file _is_ used\n+   if the situation is unclear.  If it wrongly assumes a file _is_ used,\n+   a linker error will result.  If it wrongly assumes a file _is not_ used,\n+   some GC roots may be missed, which is a much harder-to-debug problem.  */\n+\n unsigned\n get_base_file_bitmap (input_file)\n      const char *input_file;\n@@ -584,6 +651,10 @@ get_base_file_bitmap (input_file)\n   abort ();\n }\n \n+/* An output file, suitable for definitions, that can see declarations\n+   made in INPUT_FILE and is linked into every language that uses\n+   INPUT_FILE.  */\n+\n FILE *\n get_output_file_with_visibility (input_file)\n      const char *input_file;\n@@ -681,6 +752,10 @@ get_output_file_with_visibility (input_file)\n   return fm->output;\n }\n \n+/* The name of an output file, suitable for definitions, that can see\n+   declarations made in INPUT_FILE and is linked into every language\n+   that uses INPUT_FILE.  */\n+\n const char *\n get_output_file_name (input_file)\n      const char *input_file;\n@@ -694,6 +769,9 @@ get_output_file_name (input_file)\n   return get_output_file_name (input_file);\n }\n \n+/* Close all output files and copy them to their final destinations,\n+   but don't unnecessarily change modification times.  */\n+\n static void\n close_output_files PARAMS ((void))\n {\n@@ -786,6 +864,10 @@ static void write_gc_roots PARAMS ((pair_p));\n \n static int gc_counter;\n \n+/* Print PARAM to OF processing escapes.  VAL references the current object,\n+   PREV_VAL the object containing the current object, ONAME is the name\n+   of the option and LINE is used to print error messages.  */\n+\n static void\n output_escaped_param (of, param, val, prev_val, oname, line)\n      FILE *of;\n@@ -811,6 +893,13 @@ output_escaped_param (of, param, val, prev_val, oname, line)\n \t\t     oname, '%', *p);\n }\n \n+/* Write out code to OF which marks the fields of S.  VAL references\n+   the current object, PREV_VAL the object containing the current\n+   object, OPTS is a list of options to apply, INDENT is the current\n+   indentation level, LINE is used to print error messages, BITMAP\n+   indicates which languages to print the structure for, and PARAM is\n+   the current parameter (from an enclosing param_is option).  */\n+\n static void\n write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n \t\t\t   param)\n@@ -1195,6 +1284,9 @@ write_gc_structure_fields (of, s, val, prev_val, opts, indent, line, bitmap,\n     }\n }\n \n+/* Write out a marker routine for S.  PARAM is the parameter from an\n+   enclosing PARAM_IS option.  */\n+\n static void\n write_gc_marker_routine_for_structure (s, param)\n      type_p s;\n@@ -1228,7 +1320,8 @@ write_gc_marker_routine_for_structure (s, param)\n   \n   fputs (\"}\\n\", f);\n }\n-     \n+\n+/* Write out marker routines for STRUCTURES and PARAM_STRUCTS.  */\n \n static void\n write_gc_types (structures, param_structs)\n@@ -1333,6 +1426,8 @@ write_gc_types (structures, param_structs)\n       }\n }\n \n+/* Mangle FN and print it to F.  */\n+\n static void\n put_mangled_filename (f, fn)\n      FILE *f;\n@@ -1346,6 +1441,10 @@ put_mangled_filename (f, fn)\n       fputc ('_', f);\n }\n \n+/* Finish off the currently-created root tables in FLP.  PFX, TNAME,\n+   LASTNAME, and NAME are all strings to insert in various places in\n+   the resulting code.  */\n+\n static void\n finish_root_table (flp, pfx, lastname, tname, name)\n      struct flist *flp;\n@@ -1418,6 +1517,11 @@ finish_root_table (flp, pfx, lastname, tname, name)\n   }\n }\n \n+/* Write out to F the table entry and any marker routines needed to\n+   mark NAME as TYPE.  The original variable is V, at LINE.\n+   HAS_LENGTH is nonzero iff V was a variable-length array.  IF_MARKED\n+   is nonzero iff we are building the root table for hash table caches.  */\n+\n static void\n write_gc_root (f, v, type, name, has_length, line, if_marked)\n      FILE *f;\n@@ -1573,6 +1677,8 @@ write_gc_root (f, v, type, name, has_length, line, if_marked)\n     }\n }\n \n+/* Output a table describing the locations and types of VARIABLES.  */\n+\n static void\n write_gc_roots (variables)\n      pair_p variables;"}]}