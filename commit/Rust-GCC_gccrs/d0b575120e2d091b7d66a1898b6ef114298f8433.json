{"sha": "d0b575120e2d091b7d66a1898b6ef114298f8433", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBiNTc1MTIwZTJkMDkxYjdkNjZhMTg5OGI2ZWYxMTQyOThmODQzMw==", "commit": {"author": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-04-27T07:41:50Z"}, "committer": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-04-27T07:41:50Z"}, "message": "Definition of (Meta)Class_t eliminated, using Class*\n\nFrom-SVN: r4244", "tree": {"sha": "53e7b4be054d1350f4e451f9c64009c35cc361eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53e7b4be054d1350f4e451f9c64009c35cc361eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0b575120e2d091b7d66a1898b6ef114298f8433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b575120e2d091b7d66a1898b6ef114298f8433", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0b575120e2d091b7d66a1898b6ef114298f8433", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b575120e2d091b7d66a1898b6ef114298f8433/comments", "author": null, "committer": null, "parents": [{"sha": "b8a914304da6ad15c03f90850858f97969809e95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8a914304da6ad15c03f90850858f97969809e95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8a914304da6ad15c03f90850858f97969809e95"}], "stats": {"total": 339, "additions": 182, "deletions": 157}, "files": [{"sha": "c763f13e926bb8ac9c43b6622233664b1637cc29", "filename": "gcc/objc/Makefile.in", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMakefile.in?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -29,7 +29,6 @@\n .SUFFIXES: .m\n \n OPTIMIZE= -O\n-CFLAGS = $(GCC_CFLAGS) \n \n VPATH = $(srcdir)/objc\n \n@@ -41,11 +40,11 @@ SUBDIR_INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/config\n \n .c.o:\n \t$(GCC_FOR_TARGET) $(OPTIMIZE) \\\n-\t\t-c $(CFLAGS) $(SUBDIR_INCLUDES) $<\n+\t\t-c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $<\n \n .m.o:\n \t$(GCC_FOR_TARGET) $(OPTIMIZE)  -fgnu-runtime \\\n-\t\t-c $(CFLAGS) $(SUBDIR_INCLUDES) $<\n+\t\t-c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $<\n \n # If we were not invoked from the parent dir,\n # invoke make in the parent dir and have reinvoke this makefile.\n@@ -76,11 +75,11 @@ copy-headers: $(OBJC_H)\n \tdone\n \n sendmsg.o: sendmsg.c fflags\n-\t$(GCC_FOR_TARGET) `cat fflags` -c $(CFLAGS) $(SUBDIR_INCLUDES) $(srcdir)/objc/sendmsg.c\n+\t$(GCC_FOR_TARGET) `cat fflags` -c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $(srcdir)/objc/sendmsg.c\n \n ## Next to are for heuristics on forwarding mechanism... \n _forward: _forward.c\n-\t-$(GCC_FOR_TARGET) -c $(CFLAGS) $(SUBDIR_INCLUDES) $(srcdir)/objc/_forward.c\n+\t-$(GCC_FOR_TARGET) -c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $(srcdir)/objc/_forward.c\n \t-$(GCC_FOR_TARGET) ./_forward.o -o _forward\n \tif [ \\! -f ./_forward ]; then touch ./_forward; fi\t\n "}, {"sha": "6ef6e879fa4ca4de616057519a07f1e0d09f62d2", "filename": "gcc/objc/Object.h", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2FObject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2FObject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FObject.h?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -26,15 +26,43 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #ifndef __object_INCLUDE_GNU\n #define __object_INCLUDE_GNU\n \n-#include \"objc/objc.h\"\n+#ifndef __objc_INCLUDE_GNU\n+\n+/* This is the minimal set of definitions, which may be sufficient \n+   for simple programs not interacting heavily with the runtime */\n+\n+typedef char  BOOL;\n+#define YES   (BOOL)1\n+#define NO    (BOOL)0\n+\n+typedef void* SEL;\n+\n+typedef struct objc_object {\n+  struct objc_class*  class_pointer;\n+} *id;\n+\n+typedef id (*IMP)(id, SEL, ...); \n+\n+typedef struct objc_class Class;\n+typedef struct objc_class MetaClass;\n+\n+#define nil (id)0                               /* id of Nil instance */\n+#define Nil (Class*)0                          /* id of Nil class */\n+typedef char *STR;                              /* String alias */\n+\n+@class Protocol;\n+typedef struct objc_typed_stream TypedStream;\n+typedef void* arglist_t;\n+\n+#endif /* not __objc_INCLUDE_GNU */\n \n /*\n  * All classes are derived from Object.  As such,\n  * this is the overhead tacked onto those objects.\n  */\n @interface Object\n {\n-    Class_t\tisa;\t/* A pointer to the instance's class structure */\n+    Class*\tisa;\t/* A pointer to the instance's class structure */\n }\n \n         /* Initializing classes and instances */\n@@ -51,9 +79,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n - deepCopy;\n \n         /* Identifying classes */\n-- (Class_t)class;\n-- (Class_t)superClass;\n-- (MetaClass_t)metaClass;\n+- (Class*)class;\n+- (Class*)superClass;\n+- (MetaClass*)metaClass;\n - (const char *)name;\n \n         /* Identifying and comparing objects */\n@@ -67,8 +95,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n - (BOOL)isInstance;\n \n         /* Testing inheritance relationships */\n-- (BOOL)isKindOf:(Class_t)aClassObject;\n-- (BOOL)isMemberOf:(Class_t)aClassObject;\n+- (BOOL)isKindOf:(Class*)aClassObject;\n+- (BOOL)isMemberOf:(Class*)aClassObject;\n - (BOOL)isKindOfClassNamed:(const char *)aClassName;\n - (BOOL)isMemberOfClassNamed:(const char *)aClassName;\n \n@@ -95,8 +123,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n - performv:(SEL)aSel :(arglist_t)argFrame;\n \n         /* Posing */\n-+ poseAs:(Class_t)aClassObject;\n-- (Class_t)transmuteClassTo:(Class_t)aClassObject;\n++ poseAs:(Class*)aClassObject;\n+- (Class*)transmuteClassTo:(Class*)aClassObject;\n \n         /* Enforcing intentions */\n - subclassResponsibility:(SEL)aSel;"}, {"sha": "5f35bd39df975b08e4c15f8e96589e8f13279028", "filename": "gcc/objc/Object.m", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2FObject.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2FObject.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FObject.m?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -27,6 +27,9 @@\n #include \"objc/Protocol.h\"\n #include \"objc/objc-api.h\"\n \n+#include \"gstdarg.h\"\n+extern void (*_objc_error)(id object, const char *format, va_list);\n+\n extern int errno;\n \n #define MAX_CLASS_NAME_LEN 256\n@@ -78,17 +81,17 @@ @implementation Object\n   return [self copy];\n }\n \n-- (Class_t)class\n+- (Class*)class\n {\n   return object_get_class(self);\n }\n \n-- (Class_t)superClass\n+- (Class*)superClass\n {\n   return object_get_super_class(self);\n }\n \n-- (MetaClass_t)metaClass\n+- (MetaClass*)metaClass\n {\n   return object_get_meta_class(self);\n }\n@@ -128,24 +131,24 @@ - (BOOL)isInstance\n   return object_is_instance(self);\n }\n \n-- (BOOL)isKindOf:(Class_t)aClassObject\n+- (BOOL)isKindOf:(Class*)aClassObject\n {\n-  Class_t class;\n+  Class* class;\n \n   for (class = self->isa; class!=Nil; class = class_get_super_class(class))\n     if (class==aClassObject)\n       return YES;\n   return NO;\n }\n \n-- (BOOL)isMemberOf:(Class_t)aClassObject\n+- (BOOL)isMemberOf:(Class*)aClassObject\n {\n   return self->isa==aClassObject;\n }\n \n - (BOOL)isKindOfClassNamed:(const char *)aClassName\n {\n-  Class_t class;\n+  Class* class;\n \n   if (aClassName!=NULL)\n     for (class = self->isa; class!=Nil; class = class_get_super_class(class))\n@@ -252,19 +255,19 @@ - (struct objc_method_description *)descriptionForMethod:(SEL)aSel\n   return objc_msg_sendv(self, aSel, method_get_argsize(0), argFrame);\n }\n \n-+ poseAs:(Class_t)aClassObject\n++ poseAs:(Class*)aClassObject\n {\n   return class_pose_as(self, aClassObject);\n }\n \n-- (Class_t)transmuteClassTo:(Class_t)aClassObject\n+- (Class*)transmuteClassTo:(Class*)aClassObject\n {\n   if (object_is_instance(self))\n     if (class_is_class(aClassObject))\n       if (class_get_instance_size(aClassObject)==class_get_instance_size(isa))\n         if ([self isKindOf:aClassObject])\n           {\n-            Class_t old_isa = isa;\n+            Class* old_isa = isa;\n             isa = aClassObject;\n             return old_isa;\n           }"}, {"sha": "26f4c4f44fdd89a9d852395df55b3732b0a23d22", "filename": "gcc/objc/class.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fclass.c?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -33,7 +33,7 @@ static cache_ptr __objc_class_hash = 0;\n /* This is a hook which is called by objc_get_class and \n    objc_lookup_class if the runtime is not able to find the class.\n    This may e.g. try to load in the class using dynamic loading */\n-Class_t (*_objc_lookup_class)(const char* name) = 0;\n+Class* (*_objc_lookup_class)(const char* name) = 0;\n \n \n /* True when class links has been resolved */     \n@@ -59,9 +59,9 @@ void __objc_init_class_tables()\n /* This function adds a class to the class hash table, and assigns the \n    class a number, unless it's already known */\n void\n-__objc_add_class_to_hash(Class_t class)\n+__objc_add_class_to_hash(Class* class)\n {\n-  Class_t h_class;\n+  Class* h_class;\n \n   /* make sure the table is there */\n   assert(__objc_class_hash);\n@@ -88,9 +88,9 @@ __objc_add_class_to_hash(Class_t class)\n /* Get the class object for the class named NAME.  If NAME does not\n    identify a known class, the hook _objc_lookup_class is called.  If\n    this fails, nil is returned */\n-Class_t objc_lookup_class (const char* name)\n+Class* objc_lookup_class (const char* name)\n {\n-  Class_t class;\n+  Class* class;\n \n   /* Make sure the class hash table exists.  */\n   assert (__objc_class_hash);\n@@ -109,10 +109,10 @@ Class_t objc_lookup_class (const char* name)\n /* Get the class object for the class named NAME.  If NAME does not\n    identify a known class, the hook _objc_lookup_class is called.  If\n    this fails,  an error message is issued and the system aborts */\n-Class_t\n+Class*\n objc_get_class (const char *name)\n {\n-  Class_t class;\n+  Class* class;\n \n   /* Make sure the class hash table exists.  */\n   assert (__objc_class_hash);\n@@ -139,15 +139,15 @@ objc_get_class (const char *name)\n void __objc_resolve_class_links()\n {\n   node_ptr node;\n-  Class_t object_class = objc_get_class (\"Object\");\n+  Class* object_class = objc_get_class (\"Object\");\n \n   assert(object_class);\n \n   /* Assign subclass links */\n   for (node = hash_next (__objc_class_hash, NULL); node;\n        node = hash_next (__objc_class_hash, node))\n     {\n-      Class_t class1 = node->value;\n+      Class* class1 = node->value;\n \n       /* Make sure we have what we think we have.  */\n       assert (CLS_ISCLASS(class1));\n@@ -163,7 +163,7 @@ void __objc_resolve_class_links()\n               \n           if(class1->super_class)\n             {   \n-              Class_t a_super_class \n+              Class* a_super_class \n                 = objc_get_class ((char *) class1->super_class);\n               \n               assert (a_super_class);\n@@ -198,8 +198,8 @@ void __objc_resolve_class_links()\n   for (node = hash_next (__objc_class_hash, NULL); node;\n        node = hash_next (__objc_class_hash, node))\n     {\n-      Class_t class1 = node->value;\n-      Class_t sub_class;\n+      Class* class1 = node->value;\n+      Class* sub_class;\n       for (sub_class = class1->subclass_list; sub_class;\n            sub_class = sub_class->sibling_class)\n         {\n@@ -223,12 +223,12 @@ I implement posing by hiding SUPER_CLASS, creating new class and meta class\n    structures -- except the impostor itself. The only dramatic effect on the\n    application is that subclasses of SUPER_CLASS cannot do a [ ....\n    super_class ] and expect their real super class. */\n-Class_t\n-class_pose_as (Class_t impostor, Class_t super_class)\n+Class*\n+class_pose_as (Class* impostor, Class* super_class)\n {\n-  Class_t new_class = (Class_t) calloc (1, sizeof (Class));\n-  MetaClass_t new_meta_class =\n-    (MetaClass_t) __objc_xmalloc(sizeof (MetaClass));\n+  Class* new_class = (Class*) calloc (1, sizeof (Class));\n+  MetaClass* new_meta_class =\n+    (MetaClass*) __objc_xmalloc(sizeof (MetaClass));\n   char *new_name = (char *)__objc_xmalloc ((size_t)strlen ((char*)super_class->name) + 12);\n \n   /* We must know the state of the hierachy.  Do initial setup if needed */\n@@ -278,8 +278,8 @@ class_pose_as (Class_t impostor, Class_t super_class)\n      complex, since we have both super_class link, and subclass_list for the\n      involved classes. */\n   {\n-    Class_t *classpp;\n-    MetaClass_t *metaclasspp;\n+    Class* *classpp;\n+    MetaClass* *metaclasspp;\n \n     /* Remove impostor from subclass list of super_class */\n     for (classpp = &(super_class->subclass_list);\n@@ -350,7 +350,7 @@ class_pose_as (Class_t impostor, Class_t super_class)\n   __objc_add_class_to_hash (new_class);\n \n   /* Now update dispatch tables for new_class and it's subclasses */\n-  __objc_update_dispatch_table_for_class ((Class_t) new_meta_class);\n+  __objc_update_dispatch_table_for_class ((Class*) new_meta_class);\n   __objc_update_dispatch_table_for_class (new_class);\n \n   return new_class;\n@@ -360,13 +360,13 @@ class_pose_as (Class_t impostor, Class_t super_class)\n __objc_class_hash_tables_size ()\n {\n   node_ptr node;\n-  Class_t class1;\n+  Class* class1;\n   int total = 0;\n \n   for (node = hash_next (__objc_class_hash, NULL); node;\n        node = hash_next (__objc_class_hash, node))\n     {\n-      Class_t class1 = node->value;\n+      Class* class1 = node->value;\n       total += (class1->cache->mask)*sizeof(struct objc_bucket);\n       total += sizeof(struct objc_cache);\n     }"}, {"sha": "17a650c00ce779a9bb73aef338d6ce7b1d63268c", "filename": "gcc/objc/init.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Finit.c?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -44,7 +44,7 @@ static void init_check_module_version(Module_t);\n static void __objc_init_protocols (struct objc_protocol_list* protos);\n \n /* Add protocol to class */\n-static void __objc_class_add_protocols (Class_t, struct objc_protocol_list*);\n+static void __objc_class_add_protocols (Class*, struct objc_protocol_list*);\n \n /* Is all categories/classes resolved? */\n BOOL __objc_dangling_categories = NO;\n@@ -95,7 +95,7 @@ __objc_exec_class (Module_t module)\n   DEBUG_PRINTF (\"gathering selectors from module: %s\\n\", module->name);\n   for (i = 0; i < symtab->cls_def_cnt; ++i)\n     {\n-      Class_t class = (Class_t) symtab->defs[i];\n+      Class* class = (Class*) symtab->defs[i];\n \n       /* Make sure we have what we think.  */\n       assert (CLS_ISCLASS(class));\n@@ -107,7 +107,7 @@ __objc_exec_class (Module_t module)\n \n       /* Register all of the selectors in the class and meta class.  */\n       __objc_register_selectors_from_class (class);\n-      __objc_register_selectors_from_class ((Class_t) class->class_pointer);\n+      __objc_register_selectors_from_class ((Class*) class->class_pointer);\n \n       /* Install the fake dispatch tables */\n       __objc_install_premature_dtable(class);\n@@ -125,7 +125,7 @@ __objc_exec_class (Module_t module)\n   for (i = 0; i < symtab->cat_def_cnt; ++i)\n     {\n       Category_t category = symtab->defs[i + symtab->cls_def_cnt];\n-      Class_t class = objc_lookup_class (category->class_name);\n+      Class* class = objc_lookup_class (category->class_name);\n       \n       /* If the class for the category exists then append its methods.  */\n       if (class)\n@@ -141,7 +141,7 @@ __objc_exec_class (Module_t module)\n \n \t  /* Do class methods.  */\n \t  if (category->class_methods)\n-\t    class_add_method_list ((Class_t) class->class_pointer, \n+\t    class_add_method_list ((Class*) class->class_pointer, \n \t\t\t\t   category->class_methods);\n \n \t  if (category->protocols)\n@@ -166,7 +166,7 @@ __objc_exec_class (Module_t module)\n        *cell && ((cell = &(*cell)->tail)))\n     {\n       Category_t category = (*cell)->head;\n-      Class_t class = objc_lookup_class (category->class_name);\n+      Class* class = objc_lookup_class (category->class_name);\n       \n       if (class)\n \t{\n@@ -179,7 +179,7 @@ __objc_exec_class (Module_t module)\n \t    class_add_method_list (class, category->instance_methods);\n \t  \n \t  if (category->class_methods)\n-\t    class_add_method_list ((Class_t) class->class_pointer,\n+\t    class_add_method_list ((Class*) class->class_pointer,\n \t\t\t\t   category->class_methods);\n \t  \n \t  if (category->protocols)\n@@ -221,7 +221,7 @@ static void\n __objc_init_protocols (struct objc_protocol_list* protos)\n {\n   int i;\n-  Class_t proto_class;\n+  Class* proto_class;\n \n   if (! protos)\n     return;\n@@ -251,7 +251,7 @@ __objc_init_protocols (struct objc_protocol_list* protos)\n     }\n }\n \n-static void __objc_class_add_protocols (Class_t class,\n+static void __objc_class_add_protocols (Class* class,\n \t\t\t\t\tstruct objc_protocol_list* protos)\n {\n   /* Well... */"}, {"sha": "b9b64ac273c4f6608abaac4f976840c3e52ad8ba", "filename": "gcc/objc/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fmisc.c?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -29,7 +29,7 @@ You should have received a copy of the GNU General Public License along with\n void objc_error(id object, const char* fmt, va_list);\n \n void (*_objc_error)(id, const char*, va_list) = objc_error;\n-/* id (*_objc_object_alloc)(Class_t) = 0; */\n+/* id (*_objc_object_alloc)(Class*) = 0; */\n /* id (*_objc_object_dispose)(id)    = 0; */\n /* id (*_objc_object_copy)(id)       = 0; */\n "}, {"sha": "2cbe9338dc5f54617682663677e610e5ee6edbf6", "filename": "gcc/objc/objc-api.h", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fobjc-api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fobjc-api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-api.h?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -28,35 +28,33 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include \"objc/objc.h\"\n #include \"objc/hash.h\"\n-#include <memory.h>\n+#include <stdio.h>\n \n static const ARGSIZE = 96;\t\t/* for `method_get_argsize()' */\n \n-extern void (*_objc_error)(id object, const char *format, va_list args);\n-\n /*\n ** This is a hook which is called by objc_lookup_class and\n ** objc_get_class if the runtime is not able to find the class.\n ** This may e.g. try to load in the class using dynamic loading.\n ** The function is guaranteed to be passed a non-NULL name string.\n */\n-extern Class_t (*_objc_lookup_class)(const char *name);\n+extern Class* (*_objc_lookup_class)(const char *name);\n \n-extern id (*_objc_object_alloc)(Class_t class);\n+extern id (*_objc_object_alloc)(Class* class);\n \n extern id (*_objc_object_copy)(id object);\n \n extern id (*_objc_object_dispose)(id object);\n \n-Method_t class_get_class_method(MetaClass_t class, SEL aSel);\n+Method_t class_get_class_method(MetaClass* class, SEL aSel);\n \n-Method_t class_get_instance_method(Class_t class, SEL aSel);\n+Method_t class_get_instance_method(Class* class, SEL aSel);\n \n-Class_t class_pose_as(Class_t impostor, Class_t superclass);\n+Class* class_pose_as(Class* impostor, Class* superclass);\n \n-Class_t objc_get_class(const char *name);\n+Class* objc_get_class(const char *name);\n \n-Class_t objc_lookup_class(const char *name);\n+Class* objc_lookup_class(const char *name);\n \n const char *sel_get_name(SEL selector);\n \n@@ -67,7 +65,7 @@ SEL sel_register_name(const char *name);\n BOOL sel_is_mapped (SEL aSel);\n \n extern inline id\n-class_create_instance(Class_t class)\n+class_create_instance(Class* class)\n {\n   id new = nil;\n   if (CLS_ISCLASS(class))\n@@ -80,50 +78,50 @@ class_create_instance(Class_t class)\n }\n \n static inline const char *\n-class_get_class_name(Class_t class)\n+class_get_class_name(Class* class)\n {\n   return CLS_ISCLASS(class)?class->name:((class==Nil)?\"Nil\":0);\n }\n \n static inline long\n-class_get_instance_size(Class_t class)\n+class_get_instance_size(Class* class)\n {\n   return CLS_ISCLASS(class)?class->instance_size:0;\n }\n \n-static inline MetaClass_t\n-class_get_meta_class(Class_t class)\n+static inline MetaClass*\n+class_get_meta_class(Class* class)\n {\n   return CLS_ISCLASS(class)?class->class_pointer:Nil;\n }\n \n-static inline Class_t\n-class_get_super_class(Class_t class)\n+static inline Class*\n+class_get_super_class(Class* class)\n {\n   return CLS_ISCLASS(class)?class->super_class:Nil;\n }\n \n static inline int\n-class_get_version(Class_t class)\n+class_get_version(Class* class)\n {\n   return CLS_ISCLASS(class)?class->version:-1;\n }\n \n static inline BOOL\n-class_is_class(Class_t class)\n+class_is_class(Class* class)\n {\n   return CLS_ISCLASS(class);\n }\n \n static inline BOOL\n-class_is_meta_class(Class_t class)\n+class_is_meta_class(Class* class)\n {\n   return CLS_ISMETA(class);\n }\n \n \n static inline void\n-class_set_version(Class_t class, long version)\n+class_set_version(Class* class, long version)\n {\n   if (CLS_ISCLASS(class))\n     class->version = version;\n@@ -141,7 +139,7 @@ method_get_imp(Method_t method)\n   return (method!=METHOD_NULL)?method->method_imp:(IMP)0;\n }\n \n-IMP get_imp (Class_t class, SEL sel);\n+IMP get_imp (Class* class, SEL sel);\n \n extern inline id\n object_copy(id object)\n@@ -174,14 +172,14 @@ object_dispose(id object)\n   return nil;\n }\n \n-static inline Class_t\n+static inline Class*\n object_get_class(id object)\n {\n   return ((object!=nil)\n \t  ? (CLS_ISCLASS(object->class_pointer)\n \t     ? object->class_pointer\n \t     : (CLS_ISMETA(object->class_pointer)\n-\t\t? (Class_t)object\n+\t\t? (Class*)object\n \t\t: Nil))\n \t  : Nil);\n }\n@@ -191,11 +189,11 @@ object_get_class_name(id object)\n {\n   return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n                          ?object->class_pointer->name\n-                         :((Class_t)object)->name)\n+                         :((Class*)object)->name)\n                        :\"Nil\");\n }\n \n-static inline MetaClass_t\n+static inline MetaClass*\n object_get_meta_class(id object)\n {\n   return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n@@ -206,22 +204,22 @@ object_get_meta_class(id object)\n                        :Nil);\n }\n \n-static inline Class_t\n+static inline Class*\n object_get_super_class\n (id object)\n {\n   return ((object!=nil)?(CLS_ISCLASS(object->class_pointer)\n                          ?object->class_pointer->super_class\n                          :(CLS_ISMETA(object->class_pointer)\n-                           ?((Class_t)object)->super_class\n+                           ?((Class*)object)->super_class\n                            :Nil))\n                        :Nil);\n }\n \n static inline BOOL\n object_is_class(id object)\n {\n-  return CLS_ISCLASS((Class_t)object);\n+  return CLS_ISCLASS((Class*)object);\n }\n \n static inline BOOL\n@@ -233,7 +231,7 @@ object_is_instance(id object)\n static inline BOOL\n object_is_meta_class(id object)\n {\n-  return CLS_ISMETA((Class_t)object);\n+  return CLS_ISMETA((Class*)object);\n }\n \n "}, {"sha": "d5eace390cb160e9d6d8972feca86b9bb74f97e3", "filename": "gcc/objc/objc.h", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc.h?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -53,29 +53,12 @@ extern const char* __objc_sparse_lookup_id;\n extern const char* __objc_hash_lookup_id;\n #endif\n \n+#ifndef __object_INCLUDE_GNU\n \n-#include <stdio.h>\n-#ifdef IN_GCC\n-#include <gstdarg.h>\n-#else\n-#include <stdarg.h>\n-#endif\n-\n-#define nil (id)0                               /* id of Nil instance */\n-#define Nil (Class_t)0                          /* id of Nil class */\n-typedef char *STR;                              /* String alias */\n-\n-                                                /* Boolean typedefs */\n typedef char  BOOL;\n #define YES   (BOOL)1\n #define NO    (BOOL)0\n \n-\n-/* For functions which return Method_t */\n-#define METHOD_NULL\t(Method_t)0\n-\n-\n-\n /*\n ** Definition of a selector.  Selectors are really of type unsigned int.\n ** The runtime does this mapping from SEL's to names internally in the\n@@ -93,6 +76,30 @@ typedef struct objc_object {\n \n typedef id (*IMP)(id, SEL, ...); \n \n+/*\n+** The compiler generates one of these structures for each class.  \n+**\n+** This structure is the definition for meta classes. By definition a meta\n+** class is the class's class.  Its most relevant contribution is that its\n+** method list contain the class's factory methods. \n+**\n+** This structure is generated by the compiler in the executable and used by\n+** the run-time during normal messaging operations.  Therefore some members\n+** change type. The compiler generates \"char* const\" and places a string in\n+** the following member variables:  class_pointer and super_class. \n+*/\n+typedef struct objc_class MetaClass;\n+typedef struct objc_class Class;\n+\n+#define nil (id)0                               /* id of Nil instance */\n+#define Nil (Class*)0                          /* id of Nil class */\n+typedef char *STR;                              /* String alias */\n+\n+#endif /* __object_INCLUDE_GNU */\n+\n+/* For functions which return Method_t */\n+#define METHOD_NULL\t(Method_t)0\n+                                                /* Boolean typedefs */\n /*\n ** Method descriptor returned by introspective Object methods.\n ** This is really just the first part of the more complete objc_method\n@@ -159,7 +166,7 @@ typedef struct objc_symtab {\n                                                   compiled (defined) in the \n                                                   module. */\n   void      *defs[1];                           /* Variable array of pointers.\n-                                                  cls_def_cnt of type Class_t \n+                                                  cls_def_cnt of type Class* \n                                                   followed by cat_def_cnt of\n                                                   type Category_t. */\n } Symtab,   *Symtab_t;\n@@ -270,20 +277,6 @@ struct objc_cache {\n \n #endif\n \n-/*\n-** The compiler generates one of these structures for each class.  \n-**\n-** This structure is the definition for meta classes. By definition a meta\n-** class is the class's class.  Its most relevant contribution is that its\n-** method list contain the class's factory methods. \n-**\n-** This structure is generated by the compiler in the executable and used by\n-** the run-time during normal messaging operations.  Therefore some members\n-** change type. The compiler generates \"char* const\" and places a string in\n-** the following member variables:  class_pointer and super_class. \n-*/\n-typedef struct objc_class *MetaClass_t;\n-\n /*\n ** The compiler generates one of these structures for each class.  \n ** \n@@ -295,7 +288,7 @@ typedef struct objc_class *MetaClass_t;\n ** the following member variables:  super_class. \n */\n struct objc_class {     \n-  MetaClass_t         class_pointer;          /* Pointer to the class's\n+  MetaClass*         class_pointer;          /* Pointer to the class's\n                                                 meta class. */\n   struct objc_class*  super_class;            /* Pointer to the super \n                                                 class. NULL for class \n@@ -331,10 +324,8 @@ struct objc_class {\n   struct objc_protocol_list *protocols;\t      /* Protocols conformed to */\n \n };\n-#define Class struct objc_class\n-#define Class_t Class*\n-typedef struct objc_class MetaClass;\n \n+#ifndef __object_INCLUDE_GNU\n /* Protocol support */\n \n #ifndef __OBJC__\n@@ -349,13 +340,14 @@ typedef struct objc_protocol {\n @class Protocol;\n #endif \n \n+#endif\n+\n struct objc_protocol_list {\n   struct objc_protocol_list *next;\n   int count;\n   Protocol *list[1];\n };\n \n-\n /*\n ** This is used to assure consistent access to the info field of \n ** classes\n@@ -368,12 +360,12 @@ struct objc_protocol_list {\n #define __CLS_ISINFO(cls, mask) ((__CLS_INFO(cls)&mask)==mask)\n #define __CLS_SETINFO(cls, mask) (__CLS_INFO(cls) |= mask)\n \n-/* The structure is of type MetaClass_t */\n+/* The structure is of type MetaClass* */\n #define _CLS_META 0x2L\n #define CLS_ISMETA(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_META))\n \n \n-/* The structure is of type Class_t */\n+/* The structure is of type Class* */\n #define _CLS_CLASS 0x1L\n #define CLS_ISCLASS(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_CLASS))\n \n@@ -428,7 +420,9 @@ typedef struct objc_category {\n ** Well...\n */\n \n+#ifndef __object_INCLUDE_GNU\n typedef struct objc_typed_stream TypedStream;\n+#endif\n \n /*\n ** Structure used when a message is send to a class's super class.  The\n@@ -438,15 +432,17 @@ typedef struct objc_typed_stream TypedStream;\n typedef struct objc_super {\n   id      self;                           /* Id of the object sending\n                                                 the message. */\n-  Class_t class;                              /* Object's super class. */\n+  Class* class;                              /* Object's super class. */\n } Super, *Super_t;\n \n IMP objc_msg_lookup_super(Super_t super, SEL sel);\n \n typedef void* retval_t;\t\t/* return value */\n typedef void(*apply_t)(void);\t/* function pointer */\n \n-#if defined(REG_ARGS) || defined(STACK_ARGS)\n+#ifndef __object_INCLUDE_GNU\n+\n+#if defined(REG_ARGS) || defined(STACK_ARGS) \n \n typedef struct {\n   char* arg_pointer;\n@@ -471,6 +467,7 @@ typedef struct {\n typedef void* arglist_t;\n \n #endif\n+#endif /* not __object_INCLUDE_GNU */\n \n retval_t objc_msg_sendv(id, SEL, size_t, arglist_t);\n "}, {"sha": "8bc922bfb94b66db9d8f377670566ff70224dd67", "filename": "gcc/objc/objects.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fobjects.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fobjects.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjects.c?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -26,16 +26,16 @@ You should have received a copy of the GNU General Public License along with\n \n #include \"runtime.h\"\t\t/* the kitchen sink */\n \n-id __objc_object_alloc(Class_t);\n+id __objc_object_alloc(Class*);\n id __objc_object_dispose(id);\n id __objc_object_copy(id);\n \n-id (*_objc_object_alloc)(Class_t) = __objc_object_alloc;\n+id (*_objc_object_alloc)(Class*) = __objc_object_alloc;\n id (*_objc_object_dispose)(id)    = __objc_object_dispose;\n id (*_objc_object_copy)(id)       = __objc_object_copy;\n \n id\n-class_create_instance(Class_t class)\n+class_create_instance(Class* class)\n {\n   id res = (*_objc_object_alloc)(class);\n   res->class_pointer = class;\n@@ -54,7 +54,7 @@ object_dispose(id object)\n   return (*_objc_object_dispose)(object);\n }\n \n-id __objc_object_alloc(Class_t class)\n+id __objc_object_alloc(Class* class)\n {\n   return (id)__objc_xmalloc(class->instance_size);\n }"}, {"sha": "ef6e572048dccbf94689c19ca3a36a16584c7df5", "filename": "gcc/objc/runtime.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fruntime.h?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -41,15 +41,15 @@ You should have received a copy of the GNU General Public License along with\n #include \"objc/hash.h\"\t\t/* hash structures */\n #include \"objc/list.h\"\t\t/* linear lists */\n \n-extern void __objc_add_class_to_hash(Class_t); /* (objc-class.c) */\n+extern void __objc_add_class_to_hash(Class*); /* (objc-class.c) */\n extern void __objc_init_selector_tables();     /* (objc-sel.c) */\n extern void __objc_init_class_tables();     /* (objc-class.c) */\n extern void __objc_init_dispatch_tables();     /* (objc-dispatch.c) */\n-extern void __objc_install_premature_dtable(Class_t); /* (objc-dispatch.c) */\n+extern void __objc_install_premature_dtable(Class*); /* (objc-dispatch.c) */\n extern void __objc_resolve_class_links(); /* (objc-class.c) */\n-extern void __objc_register_selectors_from_class(Class_t); /* (objc-sel.c) */\n-extern void __objc_update_dispatch_table_for_class (Class_t);/* (objc-msg.c) */\n-extern void class_add_method_list(Class_t, MethodList_t);\n+extern void __objc_register_selectors_from_class(Class*); /* (objc-sel.c) */\n+extern void __objc_update_dispatch_table_for_class (Class*);/* (objc-msg.c) */\n+extern void class_add_method_list(Class*, MethodList_t);\n \n /* True when class links has been resolved */     \n extern BOOL __objc_class_links_resolved;"}, {"sha": "dfb8ba9b2fa7998ef74cb5269ab114fd5568b287", "filename": "gcc/objc/selector.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fselector.c?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -51,7 +51,7 @@ void __objc_init_selector_tables()\n /* This routine is given a class and records all of the methods in its class\n    structure in the record table.  */\n void\n-__objc_register_selectors_from_class (Class_t class)\n+__objc_register_selectors_from_class (Class* class)\n {\n   MethodList_t method_list;\n "}, {"sha": "b8ffed626d57354c59604ea0a5a2eadb9437bbf8", "filename": "gcc/objc/sendmsg.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b575120e2d091b7d66a1898b6ef114298f8433/gcc%2Fobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsendmsg.c?ref=d0b575120e2d091b7d66a1898b6ef114298f8433", "patch": "@@ -44,16 +44,16 @@ struct sarray* __objc_uninstalled_dtable = 0;\n #endif\n \n /* Send +initialize to class */\n-static void __objc_send_initialize(Class_t);\n+static void __objc_send_initialize(Class*);\n \n-static void __objc_install_dispatch_table_for_class (Class_t);\n+static void __objc_install_dispatch_table_for_class (Class*);\n \n /* Forward declare some functions */\n #ifdef OBJC_SPARSE_LOOKUP\n static void __objc_init_install_dtable(id, SEL);\n #endif\n static id __objc_missing_method(id, SEL, ...);\n-static Method_t search_for_method_in_hierarchy (Class_t class, SEL sel);\n+static Method_t search_for_method_in_hierarchy (Class* class, SEL sel);\n static Method_t search_for_method_in_list(MethodList_t list, SEL op);\n id nil_method(id, SEL, ...);\n \n@@ -65,7 +65,7 @@ nil_method(id receiver, SEL op, ...)\n \n /* Given a class and selector, return the selector's implementation.  */\n __inline__ IMP\n-get_imp (Class_t class, SEL sel)\n+get_imp (Class* class, SEL sel)\n {\n #ifdef OBJC_SPARSE_LOOKUP\n   void* res = sarray_get (class->dtable, (size_t) sel);\n@@ -165,16 +165,16 @@ static void __objc_init_install_dtable(id receiver, SEL op)\n   else\n     {\n       /* receiver is a class object */\n-      assert(CLS_ISCLASS((Class_t)receiver));\n+      assert(CLS_ISCLASS((Class*)receiver));\n       assert(CLS_ISMETA(receiver->class_pointer));\n \n       /* Install real dtable for factory methods */\n       __objc_install_dispatch_table_for_class (receiver->class_pointer);\n       \n       if(op != sel_get_uid (\"initialize\"))\n-\t__objc_send_initialize((Class_t)receiver);\n+\t__objc_send_initialize((Class*)receiver);\n       else\n-\tCLS_SETINITIALIZED((Class_t)receiver);\n+\tCLS_SETINITIALIZED((Class*)receiver);\n     }\n \n allready_initialized:\n@@ -191,7 +191,7 @@ static void __objc_init_install_dtable(id receiver, SEL op)\n \n /* Install dummy table for class which causes the first message to\n    that class (or instances hereof) to be initialized properly */\n-void __objc_install_premature_dtable(Class_t class)\n+void __objc_install_premature_dtable(Class* class)\n {\n #ifdef OBJC_SPARSE_LOOKUP\n   assert(__objc_uninstalled_dtable);\n@@ -202,7 +202,7 @@ void __objc_install_premature_dtable(Class_t class)\n }   \n \n /* Send +initialize to class if not already done */\n-static void __objc_send_initialize(Class_t class)\n+static void __objc_send_initialize(Class* class)\n {\n   Method_t m;\n \n@@ -229,10 +229,10 @@ static void __objc_send_initialize(Class_t class)\n }  \n \n static void\n-__objc_install_dispatch_table_for_class (Class_t class)\n+__objc_install_dispatch_table_for_class (Class* class)\n {\n #ifdef OBJC_SPARSE_LOOKUP\n-  Class_t super;\n+  Class* super;\n   MethodList_t mlist;\n   int counter;\n \n@@ -270,9 +270,9 @@ __objc_install_dispatch_table_for_class (Class_t class)\n #endif\n }\n \n-void __objc_update_dispatch_table_for_class (Class_t class)\n+void __objc_update_dispatch_table_for_class (Class* class)\n {\n-  Class_t next;\n+  Class* next;\n #ifdef OBJC_SPARSE_LOOKUP\n   struct sarray* save;\n #else\n@@ -313,7 +313,7 @@ void __objc_update_dispatch_table_for_class (Class_t class)\n    methods installed rightaway, and their selectors are made into\n    SEL's by the function __objc_register_selectors_from_class. */ \n void\n-class_add_method_list (Class_t class, MethodList_t list)\n+class_add_method_list (Class* class, MethodList_t list)\n {\n   int i;\n \n@@ -348,13 +348,13 @@ class_add_method_list (Class_t class, MethodList_t list)\n \n \n Method_t\n-class_get_instance_method(Class_t class, SEL op)\n+class_get_instance_method(Class* class, SEL op)\n {\n   return search_for_method_in_hierarchy(class, op);\n }\n \n Method_t\n-class_get_class_method(MetaClass_t class, SEL op)\n+class_get_class_method(MetaClass* class, SEL op)\n {\n   return search_for_method_in_hierarchy(class, op);\n }\n@@ -365,10 +365,10 @@ class_get_class_method(MetaClass_t class, SEL op)\n    otherwise. */   \n \n static Method_t\n-search_for_method_in_hierarchy (Class_t cls, SEL sel)\n+search_for_method_in_hierarchy (Class* cls, SEL sel)\n {\n   Method_t method = NULL;\n-  Class_t class;\n+  Class* class;\n \n   if (! sel_is_mapped (sel))\n     return NULL;\n@@ -550,7 +550,7 @@ __objc_cache_insert(Cache_t cache, SEL op, IMP imp)\n }\n \n void* \n-__objc_cache_miss(Class_t class, SEL op) \n+__objc_cache_miss(Class* class, SEL op) \n {\n   Method_t m;\n   Cache_t cache = class->cache;"}]}