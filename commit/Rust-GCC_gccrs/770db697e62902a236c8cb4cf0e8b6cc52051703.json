{"sha": "770db697e62902a236c8cb4cf0e8b6cc52051703", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcwZGI2OTdlNjI5MDJhMjM2YzhjYjRjZjBlOGI2Y2M1MjA1MTcwMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-04-08T06:43:15Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:43:15Z"}, "message": "s-osinte-linux-alpha.ads, [...]: Removed.\n\n2008-04-08  Eric Botcazou  <ebotcazou@adacore.com>\n\t    Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-osinte-linux-alpha.ads, s-osinte-linux-hppa.ads: Removed.\n\n\ts-taspri-posix-noaltstack.ads, s-linux.ads, s-linux-alpha.ads,\n\ts-linux-hppa.ads: New files. Disable alternate stack on ia64-hpux.\n\n\t* s-osinte-lynxos-3.ads,\n\t(Alternate_Stack): Remove when not needed. Simplify declaration\n\totherwise.\n\t(Alternate_Stack_Size): New constant.\n\n\ts-osinte-mingw.ads, s-taprop-mingw.adb: Code clean up: avoid use of\n\t'Unrestricted_Access.\n\n\t* s-osinte-hpux.ads, s-osinte-solaris-posix.ads, s-osinte-aix.ads,\n\ts-osinte-lynxos.ads, s-osinte-freebsd.ads s-osinte-darwin.ads,\n\ts-osinte-tru64.ads, s-osinte-irix.ads, s-osinte-linux.ads,\n\ts-osinte-solaris.ads, s-osinte-vms.ads\n\t(SA_ONSTACK): New constant.\n\t(stack_t): New record type.\n\t(sigaltstack): New imported function.\n\t(Alternate_Stack): New imported variable.\n\t(Alternate_Stack_Size): New constant.\n\n\t* system-linux-x86_64.ads: (Stack_Check_Probes): Set to True.\n\n\t* s-taspri-lynxos.ads, s-taspri-solaris.ads, s-taspri-tru64.ads,\n\ts-taspri-hpux-dce.ads (Task_Address): New subtype of System.Address\n\t(Task_Address_Size): New constant size of System.Address\n\t(Alternate_Stack_Size): New constant.\n\n\t* s-taprop-posix.adb, s-taprop-linux.adb (Get_Stack_Attributes): Delete.\n\t(Enter_Task): Do not notify stack to System.Stack_Checking.Operations.\n\tEstablish the alternate stack if the platform makes use of n alternate\n\tsignal stack for stack overflows.\n\t(Create_Task): Take into account the alternate stack in the stack size.\n\t(Initialize): Save the address of the alternate stack into the ATCB for\n\tthe environment task.\n\t(Create_Task): Fix assertions for NPTL library (vs old LinuxThreads).\n\n\t* s-parame.adb (Minimum_Stack_Size): Increase value to 16K to\n\n\t* system-linux-x86.ads: (Stack_Check_Probes): Set to True.\n\n\t* s-intman-posix.adb: \n\t(Initialize): Set SA_ONSTACK for SIGSEGV if the platform makes use of an\n\talternate signal stack for stack overflows.\n\n\t* init.c (__gnat_adjust_context_for_raise, Linux version): On i386 and\n\tx86-64, adjust the saved value of the stack pointer if the signal was\n\traised by a stack checking probe.\n\t(HP-UX section): Use global __gnat_alternate_stack as signal handler\n\tstack and only for SIGSEGV.\n\t(Linux section): Likewise on x86 and x86-64.\n\t[VxWorks section]\n\t(__gnat_map_signal): Now static.\n\t(__gnat_error_handler): Not static any more.\n\t(__gnat_adjust_context_for_raise): New function. Signal context\n\tadjustment for PPC && !VTHREADS && !RTP, as required by the zcx\n\tpropagation circuitry.\n\t(__gnat_error_handler): Second argument of a sigaction handler is a\n\tpointer, not an int, and is unused.\n\tAdjust signal context before mapping to exception.\n\tInstall signal handlers for LynxOS case.\n\n\t* s-taskin.ads (Common_ATCB): New field Task_Alternate_Stack.\n\t(Task_Id): Set size to Task_Address_Size\n\t(To_Task_id): Unchecked convert from Task_Address vice System.Address\n\t(To_Address): Unchecked convert to Task_Address vice System.Address\n\n\t* s-tassta.adb (Task_Wrapper): Define the alternate stack and save its\n\taddress into the ATCB if the platform makes use of an alternate signal\n\tstack for stack overflows.\n\t(Free_Task): Add call to Finalize_Attributes_Link.\n\tAdd argument Relative_Deadline to pass the value specified for\n\tthe task. This is not yet used for any target.\n\n\t* s-tassta.ads (Create_Task): Add argument Relative_Deadline to pass\n\tthe value specified for the task.\n\nFrom-SVN: r134004", "tree": {"sha": "0e9bcf675dab91b0449162ce9f89d2a5215ca347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e9bcf675dab91b0449162ce9f89d2a5215ca347"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/770db697e62902a236c8cb4cf0e8b6cc52051703", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770db697e62902a236c8cb4cf0e8b6cc52051703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/770db697e62902a236c8cb4cf0e8b6cc52051703", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770db697e62902a236c8cb4cf0e8b6cc52051703/comments", "author": null, "committer": null, "parents": [{"sha": "42c3898c1d9a5351eaac6ffd792a5d1aaa268435", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42c3898c1d9a5351eaac6ffd792a5d1aaa268435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42c3898c1d9a5351eaac6ffd792a5d1aaa268435"}], "stats": {"total": 2982, "additions": 1308, "deletions": 1674}, "files": [{"sha": "5dd781556882f4cbe3bd83c9b9087295ca4b91c8", "filename": "gcc/ada/init.c", "status": "modified", "additions": 261, "deletions": 123, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -30,21 +30,21 @@\n  *                                                                          *\n  ****************************************************************************/\n \n-/*  This unit contains initialization circuits that are system dependent. A\n-    major part of the functionality involved involves stack overflow checking.\n+/*  This unit contains initialization circuits that are system dependent.\n+    A major part of the functionality involves stack overflow checking.\n     The GCC backend generates probe instructions to test for stack overflow.\n     For details on the exact approach used to generate these probes, see the\n     \"Using and Porting GCC\" manual, in particular the \"Stack Checking\" section\n-    and the subsection \"Specifying How Stack Checking is Done\". The handlers\n-    installed by this file are used to handle resulting signals that come\n-    from these probes failing (i.e. touching protected pages) */\n+    and the subsection \"Specifying How Stack Checking is Done\".  The handlers\n+    installed by this file are used to catch the resulting signals that come\n+    from these probes failing (i.e. touching protected pages).  */\n \n /* This file should be kept synchronized with 2sinit.ads, 2sinit.adb,\n-   s-init-ae653-cert.adb and s-init-xi-sparc.adb. All these files implement\n-   the required functionality for different targets. */\n+   s-init-ae653-cert.adb and s-init-xi-sparc.adb.  All these files implement\n+   the required functionality for different targets.  */\n \n /* The following include is here to meet the published VxWorks requirement\n-   that the __vxworks header appear before any other include. */\n+   that the __vxworks header appear before any other include.  */\n #ifdef __vxworks\n #include \"vxWorks.h\"\n #endif\n@@ -66,15 +66,15 @@\n \n extern void __gnat_raise_program_error (const char *, int);\n \n-/* Addresses of exception data blocks for predefined exceptions. Tasking_Error\n-   is not used in this unit, and the abort signal is only used on IRIX. */\n+/* Addresses of exception data blocks for predefined exceptions.  Tasking_Error\n+   is not used in this unit, and the abort signal is only used on IRIX.  */\n extern struct Exception_Data constraint_error;\n extern struct Exception_Data numeric_error;\n extern struct Exception_Data program_error;\n extern struct Exception_Data storage_error;\n \n /* For the Cert run time we use the regular raise exception routine because\n-   Raise_From_Signal_Handler is not available. */\n+   Raise_From_Signal_Handler is not available.  */\n #ifdef CERT\n #define Raise_From_Signal_Handler \\\n                       __gnat_raise_exception\n@@ -85,7 +85,7 @@ extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n #endif\n \n-/* Global values computed by the binder */\n+/* Global values computed by the binder.  */\n int   __gl_main_priority                 = -1;\n int   __gl_time_slice_val                = -1;\n char  __gl_wc_encoding                   = 'n';\n@@ -104,18 +104,18 @@ int   __gl_default_stack_size            = -1;\n int   __gl_leap_seconds_support          = 0;\n \n /* Indication of whether synchronous signal handler has already been\n-   installed by a previous call to adainit */\n+   installed by a previous call to adainit.  */\n int  __gnat_handler_installed      = 0;\n \n #ifndef IN_RTS\n int __gnat_inside_elab_final_code = 0;\n /* ??? This variable is obsolete since 2001-08-29 but is kept to allow\n-   bootstrap from old GNAT versions (< 3.15). */\n+   bootstrap from old GNAT versions (< 3.15).  */\n #endif\n \n /* HAVE_GNAT_INIT_FLOAT must be set on every targets where a __gnat_init_float\n-   is defined. If this is not set them a void implementation will be defined\n-   at the end of this unit. */\n+   is defined.  If this is not set then a void implementation will be defined\n+   at the end of this unit.  */\n #undef HAVE_GNAT_INIT_FLOAT\n \n /******************************/\n@@ -126,13 +126,13 @@ char __gnat_get_interrupt_state (int);\n \n /* This routine is called from the runtime as needed to determine the state\n    of an interrupt, as set by an Interrupt_State pragma appearing anywhere\n-   in the current partition. The input argument is the interrupt number,\n+   in the current partition.  The input argument is the interrupt number,\n    and the result is one of the following:\n \n        'n'   this interrupt not set by any Interrupt_State pragma\n        'u'   Interrupt_State pragma set state to User\n        'r'   Interrupt_State pragma set state to Runtime\n-       's'   Interrupt_State pragma set state to System */\n+       's'   Interrupt_State pragma set state to System  */\n \n char\n __gnat_get_interrupt_state (int intrup)\n@@ -149,13 +149,13 @@ __gnat_get_interrupt_state (int intrup)\n \n char __gnat_get_specific_dispatching (int);\n \n-/* This routine is called from the run time as needed to determine the\n+/* This routine is called from the runtime as needed to determine the\n    priority specific dispatching policy, as set by a\n    Priority_Specific_Dispatching pragma appearing anywhere in the current\n-   partition. The input argument is the priority number, and the result is\n-   the upper case first character of the policy name, e.g. 'F' for\n+   partition.  The input argument is the priority number, and the result\n+   is the upper case first character of the policy name, e.g. 'F' for\n    FIFO_Within_Priorities. A space ' ' is returned if no\n-   Priority_Specific_Dispatching pragma is used in the partition. */\n+   Priority_Specific_Dispatching pragma is used in the partition.  */\n \n char\n __gnat_get_specific_dispatching (int priority)\n@@ -175,7 +175,7 @@ __gnat_get_specific_dispatching (int priority)\n /**********************/\n \n /* This routine is kept for bootstrapping purposes, since the binder generated\n-   file now sets the __gl_* variables directly. */\n+   file now sets the __gl_* variables directly.  */\n \n void\n __gnat_set_globals ()\n@@ -193,14 +193,14 @@ __gnat_set_globals ()\n #include <signal.h>\n #include <sys/time.h>\n \n-/* Some versions of AIX don't define SA_NODEFER. */\n+/* Some versions of AIX don't define SA_NODEFER.  */\n \n #ifndef SA_NODEFER\n #define SA_NODEFER 0\n #endif /* SA_NODEFER */\n \n /* Versions of AIX before 4.3 don't have nanosleep but provide\n-   nsleep instead. */\n+   nsleep instead.  */\n \n #ifndef _AIXVERSION_430\n \n@@ -241,7 +241,7 @@ __gnat_error_handler (int sig, siginfo_t * si, void * uc)\n   switch (sig)\n     {\n     case SIGSEGV:\n-      /* FIXME: we need to detect the case of a *real* SIGSEGV */\n+      /* FIXME: we need to detect the case of a *real* SIGSEGV.  */\n       exception = &storage_error;\n       msg = \"stack overflow or erroneous memory access\";\n       break;\n@@ -272,13 +272,13 @@ __gnat_install_handler (void)\n \n   /* Set up signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n-     signal that might cause a scheduling event! */\n+     signal that might cause a scheduling event!  */\n \n   act.sa_flags = SA_NODEFER | SA_RESTART | SA_SIGINFO;\n   act.sa_sigaction = __gnat_error_handler;\n   sigemptyset (&act.sa_mask);\n \n-  /* Do not install handlers if interrupt state is \"System\" */\n+  /* Do not install handlers if interrupt state is \"System\".  */\n   if (__gnat_get_interrupt_state (SIGABRT) != 's')\n     sigaction (SIGABRT, &act, NULL);\n   if (__gnat_get_interrupt_state (SIGFPE) != 's')\n@@ -408,13 +408,13 @@ __gnat_install_handler (void)\n \n   /* Setup signal handler to map synchronous signals to appropriate\n      exceptions. Make sure that the handler isn't interrupted by another\n-     signal that might cause a scheduling event! */\n+     signal that might cause a scheduling event!  */\n \n   act.sa_handler = (void (*) (int)) __gnat_error_handler;\n   act.sa_flags = SA_RESTART | SA_NODEFER | SA_SIGINFO;\n   sigemptyset (&act.sa_mask);\n \n-  /* Do not install handlers if interrupt state is \"System\" */\n+  /* Do not install handlers if interrupt state is \"System\".  */\n   if (__gnat_get_interrupt_state (SIGABRT) != 's')\n     sigaction (SIGABRT, &act, NULL);\n   if (__gnat_get_interrupt_state (SIGFPE) != 's')\n@@ -493,7 +493,7 @@ __gnat_error_handler\n   switch (sig)\n     {\n     case SIGSEGV:\n-      /* FIXME: we need to detect the case of a *real* SIGSEGV */\n+      /* FIXME: we need to detect the case of a *real* SIGSEGV.  */\n       exception = &storage_error;\n       msg = \"stack overflow or erroneous memory access\";\n       break;\n@@ -518,45 +518,47 @@ __gnat_error_handler\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n+/* This must be in keeping with System.OS_Interface.Alternate_Stack_Size.  */\n+#if defined (__hppa__)\n+char __gnat_alternate_stack[16 * 1024]; /* 2 * SIGSTKSZ */\n+#else\n+char __gnat_alternate_stack[128 * 1024]; /* MINSIGSTKSZ */\n+#endif\n+\n void\n __gnat_install_handler (void)\n {\n   struct sigaction act;\n \n   /* Set up signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n-     signal that might cause a scheduling event! Also setup an alternate\n+     signal that might cause a scheduling event!  Also setup an alternate\n      stack region for the handler execution so that stack overflows can be\n      handled properly, avoiding a SEGV generation from stack usage by the\n-     handler itself. */\n-\n-  static char handler_stack[SIGSTKSZ*2];\n-  /* SIGSTKSZ appeared to be \"short\" for the needs in some contexts\n-     (e.g. experiments with GCC ZCX exceptions).  */\n+     handler itself.  */\n \n   stack_t stack;\n-\n-  stack.ss_sp    = handler_stack;\n-  stack.ss_size  = sizeof (handler_stack);\n+  stack.ss_sp = __gnat_alternate_stack;\n+  stack.ss_size = sizeof (__gnat_alternate_stack);\n   stack.ss_flags = 0;\n-\n   sigaltstack (&stack, NULL);\n \n   act.sa_sigaction = __gnat_error_handler;\n-  act.sa_flags = SA_NODEFER | SA_RESTART | SA_ONSTACK | SA_SIGINFO;\n+  act.sa_flags = SA_NODEFER | SA_RESTART | SA_SIGINFO;\n   sigemptyset (&act.sa_mask);\n \n-  /* Do not install handlers if interrupt state is \"System\" */\n+  /* Do not install handlers if interrupt state is \"System\".  */\n   if (__gnat_get_interrupt_state (SIGABRT) != 's')\n     sigaction (SIGABRT, &act, NULL);\n   if (__gnat_get_interrupt_state (SIGFPE) != 's')\n     sigaction (SIGFPE,  &act, NULL);\n   if (__gnat_get_interrupt_state (SIGILL) != 's')\n     sigaction (SIGILL,  &act, NULL);\n-  if (__gnat_get_interrupt_state (SIGSEGV) != 's')\n-    sigaction (SIGSEGV, &act, NULL);\n   if (__gnat_get_interrupt_state (SIGBUS) != 's')\n     sigaction (SIGBUS,  &act, NULL);\n+  act.sa_flags |= SA_ONSTACK;\n+  if (__gnat_get_interrupt_state (SIGSEGV) != 's')\n+    sigaction (SIGSEGV, &act, NULL);\n \n   __gnat_handler_installed = 1;\n }\n@@ -574,7 +576,7 @@ __gnat_install_handler (void)\n #include <sys/ucontext.h>\n \n /* GNU/Linux, which uses glibc, does not define NULL in included\n-   header files */\n+   header files.  */\n \n #if !defined (NULL)\n #define NULL ((void *) 0)\n@@ -583,13 +585,13 @@ __gnat_install_handler (void)\n #if defined (MaRTE)\n \n /* MaRTE OS provides its own version of sigaction, sigfillset, and\n-   sigemptyset (overriding these symbol names). We want to make sure that\n+   sigemptyset (overriding these symbol names).  We want to make sure that\n    the versions provided by the underlying C library are used here (these\n    versions are renamed by MaRTE to linux_sigaction, fake_linux_sigfillset,\n-   and fake_linux_sigemptyset, respectively). The MaRTE library will not\n+   and fake_linux_sigemptyset, respectively).  The MaRTE library will not\n    always be present (it will not be linked if no tasking constructs are\n    used), so we use the weak symbol mechanism to point always to the symbols\n-   defined within the C library. */\n+   defined within the C library.  */\n \n #pragma weak linux_sigaction\n int linux_sigaction (int signum, const struct sigaction *act,\n@@ -624,9 +626,34 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *ucontext)\n {\n   mcontext_t *mcontext = &((ucontext_t *) ucontext)->uc_mcontext;\n \n+  /* On the i386 and x86-64 architectures, stack checking is performed by\n+     means of probes with moving stack pointer, that is to say the probed\n+     address is always the value of the stack pointer.  Upon hitting the\n+     guard page, the stack pointer therefore points to an inaccessible\n+     address and an alternate signal stack is needed to run the handler.\n+     But there is an additional twist: on these architectures, the EH\n+     return code writes the address of the handler at the target CFA's\n+     value on the stack before doing the jump.  As a consequence, if\n+     there is an active handler in the frame whose stack has overflowed,\n+     the stack pointer must nevertheless point to an accessible address\n+     by the time the EH return is executed.\n+\n+     We therefore adjust the saved value of the stack pointer by the size\n+     of one page, in order to make sure that it points to an accessible\n+     address in case it's used as the target CFA.  The stack checking code\n+     guarantees that this page is unused by the time this happens.  */\n+\n #if defined (i386)\n+  unsigned long pattern = *(unsigned long *)mcontext->gregs[REG_EIP];\n+  /* The pattern is \"orl $0x0,(%esp)\" for a probe in 32-bit mode.  */\n+  if (signo == SIGSEGV && pattern == 0x00240c83)\n+    mcontext->gregs[REG_ESP] += 4096;\n   mcontext->gregs[REG_EIP]++;\n #elif defined (__x86_64__)\n+  unsigned long pattern = *(unsigned long *)mcontext->gregs[REG_RIP];\n+  /* The pattern is \"orq $0x0,(%rsp)\" for a probe in 64-bit mode.  */\n+  if (signo == SIGSEGV && (pattern & 0xffffffffff) == 0x00240c8348)\n+    mcontext->gregs[REG_RSP] += 4096;\n   mcontext->gregs[REG_RIP]++;\n #elif defined (__ia64__)\n   mcontext->sc_ip++;\n@@ -676,7 +703,7 @@ __gnat_error_handler (int sig,\n \n            For now we simply do not attempt any discrimination at all. Note\n            that this is quite acceptable, since a \"real\" SIGSEGV can only\n-           occur as the result of an erroneous program */\n+           occur as the result of an erroneous program.  */\n \n         msg = \"stack overflow (or erroneous memory access)\";\n         exception = &storage_error;\n@@ -701,38 +728,57 @@ __gnat_error_handler (int sig,\n \n   /* We adjust the interrupted context here (and not in the\n      MD_FALLBACK_FRAME_STATE_FOR macro) because recent versions of the Native\n-     POSIX Thread Library (NPTL) are compiled with DWARF 2 unwind information,\n-     and hence the later macro is never executed for signal frames. */\n+     POSIX Thread Library (NPTL) are compiled with DWARF-2 unwind information,\n+     and hence the later macro is never executed for signal frames.  */\n \n   __gnat_adjust_context_for_raise (sig, ucontext);\n \n   Raise_From_Signal_Handler (exception, msg);\n }\n \n+#if defined (i386) || defined (__x86_64__)\n+/* This must be in keeping with System.OS_Interface.Alternate_Stack_Size.  */\n+char __gnat_alternate_stack[16 * 1024]; /* 2 * SIGSTKSZ */\n+#endif\n+\n void\n __gnat_install_handler (void)\n {\n   struct sigaction act;\n \n   /* Set up signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n-     signal that might cause a scheduling event! */\n+     signal that might cause a scheduling event!  Also setup an alternate\n+     stack region for the handler execution so that stack overflows can be\n+     handled properly, avoiding a SEGV generation from stack usage by the\n+     handler itself.  */\n+\n+#if defined (i386) || defined (__x86_64__)\n+  stack_t stack;\n+  stack.ss_sp = __gnat_alternate_stack;\n+  stack.ss_size = sizeof (__gnat_alternate_stack);\n+  stack.ss_flags = 0;\n+  sigaltstack (&stack, NULL);\n+#endif\n \n   act.sa_sigaction = __gnat_error_handler;\n   act.sa_flags = SA_NODEFER | SA_RESTART | SA_SIGINFO;\n   sigemptyset (&act.sa_mask);\n \n-  /* Do not install handlers if interrupt state is \"System\" */\n+  /* Do not install handlers if interrupt state is \"System\".  */\n   if (__gnat_get_interrupt_state (SIGABRT) != 's')\n     sigaction (SIGABRT, &act, NULL);\n   if (__gnat_get_interrupt_state (SIGFPE) != 's')\n     sigaction (SIGFPE,  &act, NULL);\n   if (__gnat_get_interrupt_state (SIGILL) != 's')\n     sigaction (SIGILL,  &act, NULL);\n-  if (__gnat_get_interrupt_state (SIGSEGV) != 's')\n-    sigaction (SIGSEGV, &act, NULL);\n   if (__gnat_get_interrupt_state (SIGBUS) != 's')\n     sigaction (SIGBUS,  &act, NULL);\n+#if defined (i386) || defined (__x86_64__)\n+  act.sa_flags |= SA_ONSTACK;\n+#endif\n+  if (__gnat_get_interrupt_state (SIGSEGV) != 's')\n+    sigaction (SIGSEGV, &act, NULL);\n \n   __gnat_handler_installed = 1;\n }\n@@ -771,8 +817,7 @@ static void __gnat_error_handler (int, int, sigcontext_t *);\n           also the signal number but the second argument is the signal\n           code identifying the cause of the signal. The third argument\n           points to a sigcontext_t structure containing the receiving\n-\t  process's context when the signal was delivered.\n-*/\n+          process's context when the signal was delivered.  */\n \n static void\n __gnat_error_handler (int sig, int code, sigcontext_t *sc ATTRIBUTE_UNUSED)\n@@ -807,7 +852,7 @@ __gnat_error_handler (int sig, int code, sigcontext_t *sc ATTRIBUTE_UNUSED)\n \n \t  /* ??? Re-add smarts to further verify that we launched\n \t\t the stack into a guard page, not an attempt to\n-\t\t write to .text or something */\n+\t\t write to .text or something.  */\n \t  exception = &storage_error;\n \t  msg = \"SIGSEGV: (stack overflow or erroneous memory access)\";\n \t}\n@@ -816,7 +861,7 @@ __gnat_error_handler (int sig, int code, sigcontext_t *sc ATTRIBUTE_UNUSED)\n \t  /* Just in case the OS guys did it to us again.  Sometimes\n \t     they fail to document all of the valid codes that are\n \t     passed to signal handlers, just in case someone depends\n-\t     on knowing all the codes */\n+\t     on knowing all the codes.  */\n \t  exception = &program_error;\n \t  msg = \"SIGSEGV: (Undocumented reason)\";\n \t}\n@@ -846,7 +891,7 @@ __gnat_error_handler (int sig, int code, sigcontext_t *sc ATTRIBUTE_UNUSED)\n       break;\n \n     default:\n-      /* Everything else is a Program_Error. */\n+      /* Everything else is a Program_Error.  */\n       exception = &program_error;\n       msg = \"unhandled signal\";\n     }\n@@ -861,14 +906,14 @@ __gnat_install_handler (void)\n \n   /* Setup signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n-     signal that might cause a scheduling event! */\n+     signal that might cause a scheduling event!  */\n \n   act.sa_handler = __gnat_error_handler;\n   act.sa_flags = SA_NODEFER + SA_RESTART;\n   sigfillset (&act.sa_mask);\n   sigemptyset (&act.sa_mask);\n \n-  /* Do not install handlers if interrupt state is \"System\" */\n+  /* Do not install handlers if interrupt state is \"System\".  */\n   if (__gnat_get_interrupt_state (SIGABRT) != 's')\n     sigaction (SIGABRT, &act, NULL);\n   if (__gnat_get_interrupt_state (SIGFPE) != 's')\n@@ -885,6 +930,69 @@ __gnat_install_handler (void)\n   __gnat_handler_installed = 1;\n }\n \n+/*******************/\n+/* LynxOS Section */\n+/*******************/\n+\n+#elif defined (__Lynx__)\n+\n+#include <signal.h>\n+#include <unistd.h>\n+\n+static void\n+__gnat_error_handler (int sig)\n+{\n+  struct Exception_Data *exception;\n+  const char *msg;\n+\n+  switch(sig)\n+  {\n+    case SIGFPE:\n+      exception = &constraint_error;\n+      msg = \"SIGFPE\";\n+      break;\n+    case SIGILL:\n+      exception = &constraint_error;\n+      msg = \"SIGILL\";\n+      break;\n+    case SIGSEGV:\n+      exception = &storage_error;\n+      msg = \"stack overflow or erroneous memory access\";\n+      break;\n+    case SIGBUS:\n+      exception = &constraint_error;\n+      msg = \"SIGBUS\";\n+      break;\n+    default:\n+      exception = &program_error;\n+      msg = \"unhandled signal\";\n+    }\n+\n+    Raise_From_Signal_Handler(exception, msg);\n+}\n+\n+void\n+__gnat_install_handler(void)\n+{\n+  struct sigaction act;\n+\n+  act.sa_handler = __gnat_error_handler;\n+  act.sa_flags = 0x0;\n+  sigemptyset (&act.sa_mask);\n+\n+  /* Do not install handlers if interrupt state is \"System\".  */\n+  if (__gnat_get_interrupt_state (SIGFPE) != 's')\n+    sigaction (SIGFPE,  &act, NULL);\n+  if (__gnat_get_interrupt_state (SIGILL) != 's')\n+    sigaction (SIGILL,  &act, NULL);\n+  if (__gnat_get_interrupt_state (SIGSEGV) != 's')\n+    sigaction (SIGSEGV, &act, NULL);\n+  if (__gnat_get_interrupt_state (SIGBUS) != 's')\n+    sigaction (SIGBUS,  &act, NULL);\n+\n+  __gnat_handler_installed = 1;\n+}\n+\n /*******************/\n /* Solaris Section */\n /*******************/\n@@ -896,7 +1004,7 @@ __gnat_install_handler (void)\n #include <sys/ucontext.h>\n #include <sys/regset.h>\n \n-/* The code below is common to sparc and x86.  Beware of the delay slot\n+/* The code below is common to SPARC and x86.  Beware of the delay slot\n    differences for signal context adjustments.  */\n \n #if defined (__sparc)\n@@ -907,7 +1015,7 @@ __gnat_install_handler (void)\n \n /* Likewise regarding how the \"instruction pointer\" register slot can\n    be identified in signal machine contexts.  We have either \"REG_PC\"\n-   or \"PC\" at hand, depending on the target CPU and solaris version.  */\n+   or \"PC\" at hand, depending on the target CPU and Solaris version.  */\n \n #if !defined (REG_PC)\n #define REG_PC PC\n@@ -1005,13 +1113,13 @@ __gnat_install_handler (void)\n \n   /* Set up signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n-     signal that might cause a scheduling event! */\n+     signal that might cause a scheduling event!  */\n \n   act.sa_handler = __gnat_error_handler;\n   act.sa_flags = SA_NODEFER | SA_RESTART | SA_SIGINFO;\n   sigemptyset (&act.sa_mask);\n \n-  /* Do not install handlers if interrupt state is \"System\" */\n+  /* Do not install handlers if interrupt state is \"System\".  */\n   if (__gnat_get_interrupt_state (SIGABRT) != 's')\n     sigaction (SIGABRT, &act, NULL);\n   if (__gnat_get_interrupt_state (SIGFPE) != 's')\n@@ -1044,25 +1152,25 @@ long __gnat_error_handler (int *, void *);\n \n #if defined (IN_RTS) && !defined (__IA64)\n \n-/* The prehandler actually gets control first on a condition. It swaps the\n-   stack pointer and calls the handler (__gnat_error_handler). */\n+/* The prehandler actually gets control first on a condition.  It swaps the\n+   stack pointer and calls the handler (__gnat_error_handler).  */\n extern long __gnat_error_prehandler (void);\n \n extern char *__gnat_error_prehandler_stack;   /* Alternate signal stack */\n #endif\n \n /* Define macro symbols for the VMS conditions that become Ada exceptions.\n    Most of these are also defined in the header file ssdef.h which has not\n-   yet been converted to be recognized by Gnu C. */\n+   yet been converted to be recognized by GNU C.  */\n \n /* Defining these as macros, as opposed to external addresses, allows\n-   them to be used in a case statement (below */\n+   them to be used in a case statement below.  */\n #define SS$_ACCVIO            12\n #define SS$_HPARITH         1284\n #define SS$_STKOVF          1364\n #define SS$_RESIGNAL        2328\n \n-/* These codes are in standard message libraries */\n+/* These codes are in standard message libraries.  */\n extern int CMA$_EXIT_THREAD;\n extern int SS$_DEBUG;\n extern int SS$_INTDIV;\n@@ -1072,7 +1180,7 @@ extern int MTH$_FLOOVEMAT;       /* Some ACVC_21 CXA tests */\n \n /* These codes are non standard, which is to say the author is\n    not sure if they are defined in the standard message libraries\n-   so keep them as macros for now. */\n+   so keep them as macros for now.  */\n #define RDB$_STREAM_EOF 20480426\n #define FDL$_UNPRIKW 11829410\n \n@@ -1085,8 +1193,8 @@ struct descriptor_s {unsigned short len, mbz; __char_ptr32 adr; };\n \n /* Conditions that don't have an Ada exception counterpart must raise\n    Non_Ada_Error.  Since this is defined in s-auxdec, it should only be\n-   referenced by user programs, not the compiler or tools. Hence the\n-   #ifdef IN_RTS. */\n+   referenced by user programs, not the compiler or tools.  Hence the\n+   #ifdef IN_RTS.  */\n \n #ifdef IN_RTS\n \n@@ -1124,7 +1232,7 @@ extern struct Exception_Data *Coded_Exception (Exception_Code);\n extern Exception_Code Base_Code_In (Exception_Code);\n \n /* DEC Ada exceptions are not defined in a header file, so they\n-   must be declared as external addresses */\n+   must be declared as external addresses.  */\n \n extern int ADA$_PROGRAM_ERROR;\n extern int ADA$_LOCK_ERROR;\n@@ -1156,7 +1264,7 @@ extern int ADA$_KEY_MISMATCH;\n extern int ADA$_MAXLINEXC;\n extern int ADA$_LINEXCMRS;\n \n-/* DEC Ada specific conditions */\n+/* DEC Ada specific conditions.  */\n static const struct cond_except dec_ada_cond_except_table [] = {\n   {&ADA$_PROGRAM_ERROR,   &program_error},\n   {&ADA$_USE_ERROR,       &Use_Error},\n@@ -1198,8 +1306,8 @@ static const struct cond_except dec_ada_cond_except_table [] = {\n \n #endif /* IN_RTS */\n \n-/* Non DEC Ada specific conditions. We could probably also put\n-   SS$_HPARITH here and possibly SS$_ACCVIO, SS$_STKOVF. */\n+/* Non-DEC Ada specific conditions.  We could probably also put\n+   SS$_HPARITH here and possibly SS$_ACCVIO, SS$_STKOVF.  */\n static const struct cond_except cond_except_table [] = {\n   {&MTH$_FLOOVEMAT, &constraint_error},\n   {&SS$_INTDIV,     &constraint_error},\n@@ -1212,7 +1320,7 @@ static const struct cond_except cond_except_table [] = {\n    still need to be handled by such handlers, however, in which case\n    __gnat_error_handler needs to return SS$_RESIGNAL.  Consider for\n    instance the use of a third party library compiled with DECAda and\n-   performing it's own exception handling internally.\n+   performing its own exception handling internally.\n \n    To allow some user-level flexibility, which conditions should be\n    resignaled is controlled by a predicate function, provided with the\n@@ -1290,12 +1398,12 @@ __gnat_set_resignal_predicate (resignal_predicate * predicate)\n     __gnat_resignal_p = predicate;\n }\n \n-/* Should match System.Parameters.Default_Exception_Msg_Max_Length */\n+/* Should match System.Parameters.Default_Exception_Msg_Max_Length.  */\n #define Default_Exception_Msg_Max_Length 512\n \n-/* Action routine for SYS$PUTMSG. There may be\n-   multiple conditions, each with text to be appended to\n-   MESSAGE and separated by line termination. */\n+/* Action routine for SYS$PUTMSG. There may be multiple\n+   conditions, each with text to be appended to MESSAGE\n+   and separated by line termination.  */\n \n static int\n copy_msg (msgdesc, message)\n@@ -1305,14 +1413,14 @@ copy_msg (msgdesc, message)\n   int len = strlen (message);\n   int copy_len;\n \n-  /* Check for buffer overflow and skip */\n+  /* Check for buffer overflow and skip.  */\n   if (len > 0 && len <= Default_Exception_Msg_Max_Length - 3)\n     {\n       strcat (message, \"\\r\\n\");\n       len += 2;\n     }\n \n-  /* Check for buffer overflow and truncate if necessary */\n+  /* Check for buffer overflow and truncate if necessary.  */\n   copy_len = (len + msgdesc->len <= Default_Exception_Msg_Max_Length - 1 ?\n \t      msgdesc->len :\n \t      Default_Exception_Msg_Max_Length - 1 - len);\n@@ -1338,7 +1446,7 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n     return SS$_RESIGNAL;\n \n #ifdef IN_RTS\n-  /* See if it's an imported exception. Beware that registered exceptions\n+  /* See if it's an imported exception.  Beware that registered exceptions\n      are bound to their base code, with the severity bits masked off.  */\n   base_code = Base_Code_In ((Exception_Code) sigargs [1]);\n   exception = Coded_Exception (base_code);\n@@ -1347,14 +1455,14 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n     {\n       message [0] = 0;\n \n-      /* Subtract PC & PSL fields which messes with PUTMSG */\n+      /* Subtract PC & PSL fields which messes with PUTMSG.  */\n       sigargs [0] -= 2;\n       SYS$PUTMSG (sigargs, copy_msg, &gnat_facility, message);\n       sigargs [0] += 2;\n       msg = message;\n \n       exception->Name_Length = 19;\n-      /* The full name really should be get sys$getmsg returns. ??? */\n+      /* ??? The full name really should be get sys$getmsg returns.  */\n       exception->Full_Name = \"IMPORTED_EXCEPTION\";\n       exception->Import_Code = base_code;\n \n@@ -1396,7 +1504,7 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n \texception = &constraint_error;\n \tmsg = \"arithmetic error\";\n #ifndef __alpha__\n-\t/* No need to adjust pc on alpha: the pc is already on the instruction\n+\t/* No need to adjust pc on Alpha: the pc is already on the instruction\n \t   after the trapping one.  */\n \t__gnat_adjust_context_for_raise (0, (void *)mechargs);\n #endif\n@@ -1409,7 +1517,7 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n \t  int i;\n \n \t  /* Scan the DEC Ada exception condition table for a match and fetch\n-\t     the associated GNAT exception pointer */\n+\t     the associated GNAT exception pointer.  */\n \t  for (i = 0;\n \t       dec_ada_cond_except_table [i].cond &&\n \t       !LIB$MATCH_COND (&sigargs [1],\n@@ -1421,7 +1529,7 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n \t  if (!exception)\n \t    {\n \t      /* Scan the VMS standard condition table for a match and fetch\n-\t\t the associated GNAT exception pointer */\n+\t\t the associated GNAT exception pointer.  */\n \t      for (i = 0;\n \t\t   cond_except_table [i].cond &&\n \t\t   !LIB$MATCH_COND (&sigargs [1], &cond_except_table [i].cond);\n@@ -1431,15 +1539,15 @@ __gnat_handle_vms_condition (int *sigargs, void *mechargs)\n \n \t      if (!exception)\n \t\t/* User programs expect Non_Ada_Error to be raised, reference\n-\t\t   DEC Ada test CXCONDHAN. */\n+\t\t   DEC Ada test CXCONDHAN.  */\n \t\texception = &Non_Ada_Error;\n \t    }\n \t}\n #else\n \texception = &program_error;\n #endif\n \tmessage [0] = 0;\n-\t/* Subtract PC & PSL fields which messes with PUTMSG */\n+\t/* Subtract PC & PSL fields which messes with PUTMSG.  */\n \tsigargs [0] -= 2;\n \tSYS$PUTMSG (sigargs, copy_msg, &gnat_facility, message);\n \tsigargs [0] += 2;\n@@ -1483,7 +1591,7 @@ __gnat_install_handler (void)\n   __gnat_handler_installed = 1;\n }\n \n-/* __gnat_adjust_context_for_raise for alpha - see comments along with the\n+/* __gnat_adjust_context_for_raise for Alpha - see comments along with the\n    default version later in this file.  */\n \n #if defined (IN_RTS) && defined (__alpha__)\n@@ -1613,7 +1721,7 @@ __gnat_install_handler ()\n \n   /* Set up signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n-     signal that might cause a scheduling event! */\n+     signal that might cause a scheduling event!  */\n \n   act.sa_sigaction\n     = (void (*)(int, struct __siginfo *, void*)) __gnat_error_handler;\n@@ -1646,16 +1754,15 @@ __gnat_install_handler ()\n #include \"private/vThreadsP.h\"\n #endif\n \n-static void __gnat_error_handler (int, int, struct sigcontext *);\n-void __gnat_map_signal (int);\n+void __gnat_error_handler (int, void *, struct sigcontext *);\n \n #ifndef __RTP__\n \n-/* Directly vectored Interrupt routines are not supported when using RTPs */\n+/* Directly vectored Interrupt routines are not supported when using RTPs.  */\n \n extern int __gnat_inum_to_ivec (int);\n \n-/* This is needed by the GNAT run time to handle Vxworks interrupts */\n+/* This is needed by the GNAT run time to handle Vxworks interrupts.  */\n int\n __gnat_inum_to_ivec (int num)\n {\n@@ -1666,7 +1773,7 @@ __gnat_inum_to_ivec (int num)\n #if !defined(__alpha_vxworks) && (_WRS_VXWORKS_MAJOR != 6) && !defined(__RTP__)\n \n /* getpid is used by s-parint.adb, but is not defined by VxWorks, except\n-   on Alpha VxWorks and VxWorks 6.x (including RTPs). */\n+   on Alpha VxWorks and VxWorks 6.x (including RTPs).  */\n \n extern long getpid (void);\n \n@@ -1678,7 +1785,7 @@ getpid (void)\n #endif\n \n /* VxWorks expects the field excCnt to be zeroed when a signal is handled.\n-   The VxWorks version of longjmp does this; gcc's builtin_longjmp does not */\n+   The VxWorks version of longjmp does this; GCC's builtin_longjmp doesn't.  */\n void\n __gnat_clear_exception_count (void)\n {\n@@ -1689,9 +1796,37 @@ __gnat_clear_exception_count (void)\n #endif\n }\n \n-/* Exported to s-intman-vxworks.adb in order to handle different signal\n-   to exception mappings in different VxWorks versions */\n+\n+/* VxWorks context adjustment for targets that need/support it.  */\n+\n+void __gnat_adjust_context_for_raise (int, void*);\n+\n+#if defined (_ARCH_PPC) && !defined (VTHREADS) && !defined (__RTP__)\n+\n+#define HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n+\n+/* We need the constant and structure definitions describing the machine\n+   state.  Part of this is normally retrieved from the VxWorks \"regs.h\" but\n+   #including it here gets the GCC internals instance of this file instead.\n+   We need to #include the version we need directly here, and prevent the\n+   possibly indirect inclusion of the GCC one, as its contents is useless to\n+   us and it depends on several other headers that we don't have at hand.  */\n+#include <arch/ppc/regsPpc.h>\n+#define GCC_REGS_H\n+#include <sigLib.h>\n+\n void\n+__gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED, void *sigcontext)\n+{\n+  REG_SET * mcontext = ((struct sigcontext *) sigcontext)->sc_pregs;\n+  mcontext->pc++;\n+}\n+\n+#endif\n+\n+/* Handle different SIGnal to exception mappings in different VxWorks\n+   versions.   */\n+static void\n __gnat_map_signal (int sig)\n {\n   struct Exception_Data *exception;\n@@ -1754,22 +1889,25 @@ __gnat_map_signal (int sig)\n   Raise_From_Signal_Handler (exception, msg);\n }\n \n-static void\n-__gnat_error_handler (int sig, int code, struct sigcontext *sc)\n+/* Tasking and Non-tasking signal handler.  Map SIGnal to Ada exception\n+   propagation after the required low level adjustments.  */\n+\n+void\n+__gnat_error_handler (int sig, void * si ATTRIBUTE_UNUSED,\n+\t\t      struct sigcontext * sc)\n {\n   sigset_t mask;\n-  int result;\n \n   /* VxWorks will always mask out the signal during the signal handler and\n      will reenable it on a longjmp.  GNAT does not generate a longjmp to\n      return from a signal handler so the signal will still be masked unless\n-     we unmask it. */\n+     we unmask it.  */\n   sigprocmask (SIG_SETMASK, NULL, &mask);\n   sigdelset (&mask, sig);\n   sigprocmask (SIG_SETMASK, &mask, NULL);\n \n+  __gnat_adjust_context_for_raise (sig, (void *)sc);\n   __gnat_map_signal (sig);\n-\n }\n \n void\n@@ -1779,14 +1917,14 @@ __gnat_install_handler (void)\n \n   /* Setup signal handler to map synchronous signals to appropriate\n      exceptions.  Make sure that the handler isn't interrupted by another\n-     signal that might cause a scheduling event! */\n+     signal that might cause a scheduling event!  */\n \n   act.sa_handler = __gnat_error_handler;\n   act.sa_flags = SA_SIGINFO | SA_ONSTACK;\n   sigemptyset (&act.sa_mask);\n \n   /* For VxWorks, install all signal handlers, since pragma Interrupt_State\n-     applies to vectored hardware interrupts, not signals */\n+     applies to vectored hardware interrupts, not signals.  */\n   sigaction (SIGFPE,  &act, NULL);\n   sigaction (SIGILL,  &act, NULL);\n   sigaction (SIGSEGV, &act, NULL);\n@@ -1800,22 +1938,22 @@ __gnat_install_handler (void)\n void\n __gnat_init_float (void)\n {\n-  /* Disable overflow/underflow exceptions on the PPC processor, this is needed\n+  /* Disable overflow/underflow exceptions on the PPC processor, needed\n      to get correct Ada semantics.  Note that for AE653 vThreads, the HW\n      overflow settings are an OS configuration issue.  The instructions\n-     below have no effect */\n+     below have no effect.  */\n #if defined (_ARCH_PPC) && !defined (_SOFT_FLOAT) && !defined (VTHREADS)\n   asm (\"mtfsb0 25\");\n   asm (\"mtfsb0 26\");\n #endif\n \n #if (defined (__i386__) || defined (i386)) && !defined (VTHREADS)\n   /* This is used to properly initialize the FPU on an x86 for each\n-     process thread. */\n+     process thread.  */\n   asm (\"finit\");\n #endif\n \n-  /* Similarly for sparc64. Achieved by masking bits in the Trap Enable Mask\n+  /* Similarly for SPARC64.  Achieved by masking bits in the Trap Enable Mask\n      field of the Floating-point Status Register (see the SPARC Architecture\n      Manual Version 9, p 48).  */\n #if defined (sparc64)\n@@ -1893,7 +2031,7 @@ __gnat_install_handler(void)\n   act.sa_flags = SA_NODEFER | SA_RESTART;\n   sigemptyset (&act.sa_mask);\n \n-  /* Do not install handlers if interrupt state is \"System\" */\n+  /* Do not install handlers if interrupt state is \"System\".  */\n   if (__gnat_get_interrupt_state (SIGFPE) != 's')\n     sigaction (SIGFPE,  &act, NULL);\n   if (__gnat_get_interrupt_state (SIGILL) != 's')\n@@ -1971,7 +2109,7 @@ __gnat_install_handler(void)\n \n #else\n \n-/* For all other versions of GNAT, the handler does nothing */\n+/* For all other versions of GNAT, the handler does nothing.  */\n \n /*******************/\n /* Default Section */\n@@ -1990,8 +2128,8 @@ __gnat_install_handler (void)\n /*********************/\n \n /* This routine is called as each process thread is created, for possible\n-   initialization of the FP processor. This version is used under INTERIX,\n-   WIN32 and could be used under OS/2 */\n+   initialization of the FP processor.  This version is used under INTERIX,\n+   WIN32 and could be used under OS/2.  */\n \n #if defined (_WIN32) || defined (__INTERIX) || defined (__EMX__) \\\n   || defined (__Lynx__) || defined(__NetBSD__) || defined(__FreeBSD__) \\\n@@ -2005,7 +2143,7 @@ __gnat_init_float (void)\n #if defined (__i386__) || defined (i386)\n \n   /* This is used to properly initialize the FPU on an x86 for each\n-     process thread. */\n+     process thread.  */\n \n   asm (\"finit\");\n \n@@ -2015,7 +2153,7 @@ __gnat_init_float (void)\n \n #ifndef HAVE_GNAT_INIT_FLOAT\n \n-/* All targets without a specific __gnat_init_float will use an empty one */\n+/* All targets without a specific __gnat_init_float will use an empty one.  */\n void\n __gnat_init_float (void)\n {\n@@ -2028,7 +2166,7 @@ __gnat_init_float (void)\n \n #ifndef HAVE_GNAT_ADJUST_CONTEXT_FOR_RAISE\n \n-/* All targets without a specific version will use an empty one */\n+/* All targets without a specific version will use an empty one.  */\n \n /* Given UCONTEXT a pointer to a context structure received by a signal\n    handler for SIGNO, perform the necessary adjustments to let the handler"}, {"sha": "06a7b4500297e4be154df813a17242bfc42d883e", "filename": "gcc/ada/s-intman-posix.adb", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-intman-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-intman-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-posix.adb?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,6 +59,8 @@\n --                default\n --      Reserved: the OS specific set of signals that are reserved.\n \n+with System.Task_Primitives;\n+\n package body System.Interrupt_Management is\n \n    use Interfaces.C;\n@@ -117,7 +119,7 @@ package body System.Interrupt_Management is\n \n    begin\n       --  With the __builtin_longjmp, the signal mask is not restored, so we\n-      --  need to restore it explicitely.\n+      --  need to restore it explicitly.\n \n       Result := pthread_sigmask (SIG_UNBLOCK, Signal_Mask'Access, null);\n       pragma Assert (Result = 0);\n@@ -155,6 +157,10 @@ package body System.Interrupt_Management is\n       old_act : aliased struct_sigaction;\n       Result  : System.OS_Interface.int;\n \n+      Use_Alternate_Stack : constant Boolean :=\n+                              System.Task_Primitives.Alternate_Stack_Size /= 0;\n+      --  Whether to use an alternate signal stack for stack overflows\n+\n    begin\n       if Initialized then\n          return;\n@@ -171,8 +177,6 @@ package body System.Interrupt_Management is\n \n       act.sa_handler := Notify_Exception'Address;\n \n-      act.sa_flags := SA_SIGINFO;\n-\n       --  Setting SA_SIGINFO asks the kernel to pass more than just the signal\n       --  number argument to the handler when it is called. The set of extra\n       --  parameters includes a pointer to the interrupted context, which the\n@@ -191,7 +195,7 @@ package body System.Interrupt_Management is\n       --  fix should be made in sigsetjmp so that we save the Signal_Set and\n       --  restore it after a longjmp.\n \n-      --  Since SA_NODEFER is obsolete, instead we reset explicitely the mask\n+      --  Since SA_NODEFER is obsolete, instead we reset explicitly the mask\n       --  in the exception handler.\n \n       Result := sigemptyset (Signal_Mask'Access);\n@@ -220,10 +224,18 @@ package body System.Interrupt_Management is\n             Reserve (Exception_Interrupts (J)) := True;\n \n             if State (Exception_Interrupts (J)) /= Default then\n+               act.sa_flags := SA_SIGINFO;\n+\n+               if Use_Alternate_Stack\n+                 and then Exception_Interrupts (J) = SIGSEGV\n+               then\n+                  act.sa_flags := act.sa_flags + SA_ONSTACK;\n+               end if;\n+\n                Result :=\n                  sigaction\n-                 (Signal (Exception_Interrupts (J)), act'Unchecked_Access,\n-                  old_act'Unchecked_Access);\n+                   (Signal (Exception_Interrupts (J)), act'Unchecked_Access,\n+                    old_act'Unchecked_Access);\n                pragma Assert (Result = 0);\n             end if;\n          end if;\n@@ -235,15 +247,15 @@ package body System.Interrupt_Management is\n       end if;\n \n       --  Set SIGINT to unmasked state as long as it is not in \"User\" state.\n-      --  Check for Unreserve_All_Interrupts last\n+      --  Check for Unreserve_All_Interrupts last.\n \n       if State (SIGINT) /= User then\n          Keep_Unmasked (SIGINT) := True;\n          Reserve (SIGINT) := True;\n       end if;\n \n       --  Check all signals for state that requires keeping them unmasked and\n-      --  reserved\n+      --  reserved.\n \n       for J in Interrupt_ID'Range loop\n          if State (J) = Default or else State (J) = Runtime then"}, {"sha": "b2fd28f5672f67ed9baf3e30bb6a4b8496cc8ea3", "filename": "gcc/ada/s-linux-alpha.ads", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-linux-alpha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-linux-alpha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-linux-alpha.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -0,0 +1,119 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                          S Y S T E M .  L I N U X                        --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--             Copyright (C) 2008, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the alpha version of this package\n+\n+--  This package encapsulates cpu specific differences between implementations\n+--  of GNU/Linux, in order to share s-osinte-linux.ads.\n+\n+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+\n+package System.Linux is\n+   pragma Preelaborate;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   EAGAIN    : constant := 35;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   EPERM     : constant := 1;\n+   ETIMEDOUT : constant := 60;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGIOT     : constant := 6; --  IOT instruction\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS     : constant := 10; --  bus error\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGURG     : constant := 16; --  urgent condition on IO channel\n+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 18; --  user stop requested from tty\n+   SIGCONT    : constant := 19; --  stopped process has been continued\n+   SIGCLD     : constant := 20; --  alias for SIGCHLD\n+   SIGCHLD    : constant := 20; --  child status change\n+   SIGTTIN    : constant := 21; --  background tty read attempted\n+   SIGTTOU    : constant := 22; --  background tty write attempted\n+   SIGIO      : constant := 23; --  I/O now possible (4.2 BSD)\n+   SIGPOLL    : constant := 23; --  pollable event occurred\n+   SIGXCPU    : constant := 24; --  CPU time limit exceeded\n+   SIGXFSZ    : constant := 25; --  filesize limit exceeded\n+   SIGVTALRM  : constant := 26; --  virtual timer expired\n+   SIGPROF    : constant := 27; --  profiling timer expired\n+   SIGWINCH   : constant := 28; --  window size change\n+   SIGPWR     : constant := 29; --  power-fail restart\n+   SIGUSR1    : constant := 30; --  user defined signal 1\n+   SIGUSR2    : constant := 31; --  user defined signal 2\n+\n+   SIGLTHRRES : constant := 32; --  GNU/LinuxThreads restart signal\n+   SIGLTHRCAN : constant := 33; --  GNU/LinuxThreads cancel signal\n+   SIGLTHRDBG : constant := 34; --  GNU/LinuxThreads debugger signal\n+\n+   SIGADAABORT : constant := SIGABRT;\n+   --  Change this if you want to use another signal for task abort.\n+   --  SIGTERM might be a good one.\n+\n+   SIGUNUSED  : constant := 0;\n+   SIGSTKFLT  : constant := 0;\n+   SIGLOST    : constant := 0;\n+   --  These don't exist for Linux/Alpha.  The constants are present\n+   --  so that we can continue to use a-intnam-linux.ads.\n+\n+   --  struct_sigaction offsets\n+\n+   sa_mask_pos  : constant := Standard'Address_Size / 8;\n+   sa_flags_pos : constant := 128 + sa_mask_pos;\n+\n+   SA_SIGINFO  : constant := 16#40#;\n+   SA_ONSTACK  : constant := 16#01#;\n+\n+   type pthread_mutex_t is record\n+      dum0, dum1, dum2, dum3, dum4 : Interfaces.C.unsigned_long;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+end System.Linux;"}, {"sha": "841ff78c17e0a8e97f2e8014f093116806c583a2", "filename": "gcc/ada/s-linux-hppa.ads", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-linux-hppa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-linux-hppa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-linux-hppa.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -0,0 +1,131 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                          S Y S T E M .  L I N U X                        --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--             Copyright (C) 2008, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the hppa version of this package\n+\n+--  This package encapsulates cpu specific differences between implementations\n+--  of GNU/Linux, in order to share s-osinte-linux.ads.\n+\n+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n+\n+package System.Linux is\n+   pragma Preelaborate;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   EPERM     : constant := 1;\n+   ETIMEDOUT : constant := 238;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGIOT     : constant := 6; --  IOT instruction\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n+   SIGEMT     : constant := 7; --  EMT\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS     : constant := 10; --  bus error\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGSYS     : constant := 12; --  bad system call\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGUSR1    : constant := 16; --  user defined signal 1\n+   SIGUSR2    : constant := 17; --  user defined signal 2\n+   SIGCLD     : constant := 18; --  alias for SIGCHLD\n+   SIGCHLD    : constant := 18; --  child status change\n+   SIGPWR     : constant := 19; --  power-fail restart\n+   SIGVTALRM  : constant := 20; --  virtual timer expired\n+   SIGPROF    : constant := 21; --  profiling timer expired\n+   SIGPOLL    : constant := 22; --  pollable event occurred\n+   SIGIO      : constant := 22; --  I/O now possible (4.2 BSD)\n+   SIGWINCH   : constant := 23; --  window size change\n+   SIGSTOP    : constant := 24; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 25; --  user stop requested from tty\n+   SIGCONT    : constant := 26; --  stopped process has been continued\n+   SIGTTIN    : constant := 27; --  background tty read attempted\n+   SIGTTOU    : constant := 28; --  background tty write attempted\n+   SIGURG     : constant := 29; --  urgent condition on IO channel\n+   SIGLOST    : constant := 30; --  File lock lost\n+   SIGUNUSED  : constant := 31; --  unused signal (GNU/Linux)\n+   SIGXCPU    : constant := 33; --  CPU time limit exceeded\n+   SIGXFSZ    : constant := 34; --  filesize limit exceeded\n+   SIGSTKFLT  : constant := 36; --  coprocessor stack fault (Linux)\n+   SIGLTHRRES : constant := 37; --  GNU/LinuxThreads restart signal\n+   SIGLTHRCAN : constant := 38; --  GNU/LinuxThreads cancel signal\n+   SIGLTHRDBG : constant := 39; --  GNU/LinuxThreads debugger signal\n+\n+   --  struct_sigaction offsets\n+\n+   sa_flags_pos  : constant := Standard'Address_Size / 8;\n+   sa_mask_pos   : constant := sa_flags_pos * 2;\n+\n+   SA_SIGINFO  : constant := 16#10#;\n+   SA_ONSTACK  : constant := 16#01#;\n+\n+   type lock_array is array (1 .. 4) of int;\n+   type atomic_lock_t is record\n+      lock : lock_array;\n+   end record;\n+   pragma Convention (C, atomic_lock_t);\n+   --  ??? Alignment should be 16 but this is larger than BIGGEST_ALIGNMENT.\n+   --  This causes an erroneous pointer value to sometimes be passed to free\n+   --  during deallocation.  See PR ada/24533 for more details.\n+   for atomic_lock_t'Alignment use 8;\n+\n+   type struct_pthread_fast_lock is record\n+      spinlock : atomic_lock_t;\n+      status   : Long_Integer;\n+   end record;\n+   pragma Convention (C, struct_pthread_fast_lock);\n+\n+   type pthread_mutex_t is record\n+      m_reserved : Integer;\n+      m_count    : Integer;\n+      m_owner    : System.Address;\n+      m_kind     : Integer;\n+      m_lock     : struct_pthread_fast_lock;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+end System.Linux;"}, {"sha": "cb9ad42b018484e5eeefa7ab805a85cdeb400f81", "filename": "gcc/ada/s-linux.ads", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-linux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-linux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-linux.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -0,0 +1,119 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                          S Y S T E M .  L I N U X                        --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--             Copyright (C) 2008, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the default version of this package\n+\n+--  This package encapsulates cpu specific differences between implementations\n+--  of GNU/Linux, in order to share s-osinte-linux.ads.\n+\n+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n+--  Preelaborate. This package is designed to be a bottom-level (leaf) package\n+\n+package System.Linux is\n+   pragma Preelaborate;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   EPERM     : constant := 1;\n+   ETIMEDOUT : constant := 110;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGIOT     : constant := 6; --  IOT instruction\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS     : constant := 7; --  bus error\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGUSR1    : constant := 10; --  user defined signal 1\n+   SIGUSR2    : constant := 12; --  user defined signal 2\n+   SIGCLD     : constant := 17; --  alias for SIGCHLD\n+   SIGCHLD    : constant := 17; --  child status change\n+   SIGPWR     : constant := 30; --  power-fail restart\n+   SIGWINCH   : constant := 28; --  window size change\n+   SIGURG     : constant := 23; --  urgent condition on IO channel\n+   SIGPOLL    : constant := 29; --  pollable event occurred\n+   SIGIO      : constant := 29; --  I/O now possible (4.2 BSD)\n+   SIGLOST    : constant := 29; --  File lock lost\n+   SIGSTOP    : constant := 19; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 20; --  user stop requested from tty\n+   SIGCONT    : constant := 18; --  stopped process has been continued\n+   SIGTTIN    : constant := 21; --  background tty read attempted\n+   SIGTTOU    : constant := 22; --  background tty write attempted\n+   SIGVTALRM  : constant := 26; --  virtual timer expired\n+   SIGPROF    : constant := 27; --  profiling timer expired\n+   SIGXCPU    : constant := 24; --  CPU time limit exceeded\n+   SIGXFSZ    : constant := 25; --  filesize limit exceeded\n+   SIGUNUSED  : constant := 31; --  unused signal (GNU/Linux)\n+   SIGSTKFLT  : constant := 16; --  coprocessor stack fault (Linux)\n+   SIGLTHRRES : constant := 32; --  GNU/LinuxThreads restart signal\n+   SIGLTHRCAN : constant := 33; --  GNU/LinuxThreads cancel signal\n+   SIGLTHRDBG : constant := 34; --  GNU/LinuxThreads debugger signal\n+\n+   --  struct_sigaction offsets\n+\n+   sa_mask_pos  : constant := Standard'Address_Size / 8;\n+   sa_flags_pos : constant := 128 + sa_mask_pos;\n+\n+   SA_SIGINFO  : constant := 16#04#;\n+   SA_ONSTACK  : constant := 16#08000000#;\n+\n+   type struct_pthread_fast_lock is record\n+      status   : Long_Integer;\n+      spinlock : Integer;\n+   end record;\n+   pragma Convention (C, struct_pthread_fast_lock);\n+\n+   type pthread_mutex_t is record\n+      m_reserved : Integer;\n+      m_count    : Integer;\n+      m_owner    : System.Address;\n+      m_kind     : Integer;\n+      m_lock     : struct_pthread_fast_lock;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+end System.Linux;"}, {"sha": "6985915869d8b4f906bb3d244fd01690b83ff0bc", "filename": "gcc/ada/s-osinte-aix.ads", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-aix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-aix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-aix.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -174,7 +174,8 @@ package System.OS_Interface is\n    pragma Convention (C, struct_sigaction);\n    type struct_sigaction_ptr is access all struct_sigaction;\n \n-   SA_SIGINFO  : constant := 16#0100#;\n+   SA_SIGINFO : constant := 16#0100#;\n+   SA_ONSTACK : constant := 16#0001#;\n \n    SIG_BLOCK   : constant := 0;\n    SIG_UNBLOCK : constant := 1;\n@@ -291,6 +292,24 @@ package System.OS_Interface is\n    -- Stack --\n    -----------\n \n+   type stack_t is record\n+      ss_sp    : System.Address;\n+      ss_size  : size_t;\n+      ss_flags : int;\n+   end record;\n+   pragma Convention (C, stack_t);\n+\n+   function sigaltstack\n+     (ss  : not null access stack_t;\n+      oss : access stack_t) return int;\n+   pragma Import (C, sigaltstack, \"sigaltstack\");\n+\n+   Alternate_Stack : aliased System.Address;\n+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n    Stack_Base_Available : constant Boolean := False;\n    --  Indicates wether the stack base is available on this target\n \n@@ -309,7 +328,6 @@ package System.OS_Interface is\n    PROT_WRITE : constant := 2;\n    PROT_EXEC  : constant := 4;\n    PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n-\n    PROT_ON    : constant := PROT_READ;\n    PROT_OFF   : constant := PROT_ALL;\n "}, {"sha": "8dd28dbd0e571ac2c2651771faaf9672fb501994", "filename": "gcc/ada/s-osinte-darwin.ads", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-darwin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-darwin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-darwin.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -162,6 +162,7 @@ package System.OS_Interface is\n    SIG_IGN : constant := 1;\n \n    SA_SIGINFO : constant := 16#0040#;\n+   SA_ONSTACK : constant := 16#0001#;\n \n    function sigaction\n      (sig  : Signal;\n@@ -229,10 +230,10 @@ package System.OS_Interface is\n    ---------\n \n    function lwp_self return System.Address;\n+   pragma Import (C, lwp_self, \"pthread_self\");\n    --  lwp_self does not exist on this thread library, revert to pthread_self\n    --  which is the closest approximation (with getpid). This function is\n    --  needed to share 7staprop.adb across POSIX-like targets.\n-   pragma Import (C, lwp_self, \"pthread_self\");\n \n    -------------\n    -- Threads --\n@@ -264,22 +265,39 @@ package System.OS_Interface is\n    -- Stack --\n    -----------\n \n+   type stack_t is record\n+      ss_sp    : System.Address;\n+      ss_size  : size_t;\n+      ss_flags : int;\n+   end record;\n+   pragma Convention (C, stack_t);\n+\n+   function sigaltstack\n+     (ss  : not null access stack_t;\n+      oss : access stack_t) return int;\n+   pragma Import (C, sigaltstack, \"sigaltstack\");\n+\n+   Alternate_Stack : aliased System.Address;\n+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n    Stack_Base_Available : constant Boolean := False;\n-   --  Indicates wether the stack base is available on this target.\n-   --  This allows us to share s-osinte.adb between all the FSU run time.\n-   --  Note that this value can only be true if pthread_t has a complete\n-   --  definition that corresponds exactly to the C header files.\n+   --  Indicates wether the stack base is available on this target. This allows\n+   --  us to share s-osinte.adb between all the FSU run time. Note that this\n+   --  value can only be true if pthread_t has a complete definition that\n+   --  corresponds exactly to the C header files.\n \n    function Get_Stack_Base (thread : pthread_t) return System.Address;\n    pragma Inline (Get_Stack_Base);\n-   --  returns the stack base of the specified thread.\n-   --  Only call this function when Stack_Base_Available is True.\n+   --  returns the stack base of the specified thread. Only call this function\n+   --  when Stack_Base_Available is True.\n \n    function Get_Page_Size return size_t;\n    function Get_Page_Size return System.Address;\n    pragma Import (C, Get_Page_Size, \"getpagesize\");\n-   --  returns the size of a page, or 0 if this is not relevant on this\n-   --  target\n+   --  Returns the size of a page, or 0 if this is not relevant on this target\n \n    PROT_NONE  : constant := 0;\n    PROT_READ  : constant := 1;\n@@ -290,9 +308,10 @@ package System.OS_Interface is\n    PROT_ON    : constant := PROT_NONE;\n    PROT_OFF   : constant := PROT_ALL;\n \n-   function mprotect (addr : System.Address;\n-                      len : size_t;\n-                      prot : int) return int;\n+   function mprotect\n+     (addr : System.Address;\n+      len  : size_t;\n+      prot : int) return int;\n    pragma Import (C, mprotect);\n \n    ---------------------------------------\n@@ -528,13 +547,6 @@ private\n    end record;\n    pragma Convention (C, siginfo_t);\n \n-   type stack_t is record\n-      ss_sp    : System.Address;\n-      ss_size  : int;\n-      ss_flags : int;\n-   end record;\n-   pragma Convention (C, stack_t);\n-\n    type mcontext_t is new System.Address;\n \n    type ucontext_t is record"}, {"sha": "e0453ca90b4fe4b5a63dcad2ebaf47ac5e1047ae", "filename": "gcc/ada/s-osinte-freebsd.ads", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-freebsd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-freebsd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-freebsd.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -182,6 +182,7 @@ package System.OS_Interface is\n    SIG_IGN : constant := 1;\n \n    SA_SIGINFO : constant := 16#0040#;\n+   SA_ONSTACK : constant := 16#0001#;\n \n    function sigaction\n      (sig  : Signal;\n@@ -293,42 +294,57 @@ package System.OS_Interface is\n    -- Stack --\n    -----------\n \n+   type stack_t is record\n+      ss_sp    : System.Address;\n+      ss_size  : size_t;\n+      ss_flags : int;\n+   end record;\n+   pragma Convention (C, stack_t);\n+\n+   function sigaltstack\n+     (ss  : not null access stack_t;\n+      oss : access stack_t) return int;\n+   pragma Import (C, sigaltstack, \"sigaltstack\");\n+\n+   Alternate_Stack : aliased System.Address;\n+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n    Stack_Base_Available : constant Boolean := False;\n-   --  Indicates wether the stack base is available on this target.\n-   --  This allows us to share s-osinte.adb between all the FSU run time.\n-   --  Note that this value can only be true if pthread_t has a complete\n-   --  definition that corresponds exactly to the C header files.\n+   --  Indicates wether the stack base is available on this target. This allows\n+   --  us to share s-osinte.adb between all the FSU run time. Note that this\n+   --  value can only be true if pthread_t has a complete definition that\n+   --  corresponds exactly to the C header files.\n \n    function Get_Stack_Base (thread : pthread_t) return Address;\n    pragma Inline (Get_Stack_Base);\n-   --  returns the stack base of the specified thread.\n-   --  Only call this function when Stack_Base_Available is True.\n+   --  returns the stack base of the specified thread. Only call this function\n+   --  when Stack_Base_Available is True.\n \n    function Get_Page_Size return size_t;\n    function Get_Page_Size return Address;\n    pragma Import (C, Get_Page_Size, \"getpagesize\");\n-   --  returns the size of a page, or 0 if this is not relevant on this\n-   --  target\n+   --  returns the size of a page, or 0 if this is not relevant on this target\n \n    PROT_NONE  : constant := 0;\n    PROT_READ  : constant := 1;\n    PROT_WRITE : constant := 2;\n    PROT_EXEC  : constant := 4;\n    PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n-\n    PROT_ON    : constant := PROT_NONE;\n    PROT_OFF   : constant := PROT_ALL;\n \n-   function mprotect\n-     (addr : Address; len : size_t; prot : int) return int;\n+   function mprotect (addr : Address; len : size_t; prot : int) return int;\n    pragma Import (C, mprotect);\n \n    ---------------------------------------\n    -- Nonstandard Thread Initialization --\n    ---------------------------------------\n \n-   --  FSU_THREADS requires pthread_init, which is nonstandard and\n-   --  this should be invoked during the elaboration of s-taprop.adb\n+   --  FSU_THREADS requires pthread_init, which is nonstandard and this should\n+   --  be invoked during the elaboration of s-taprop.adb.\n \n    --  FreeBSD does not require this so we provide an empty Ada body\n "}, {"sha": "b22e20d81cf06349c1e5f5537c75b0be81d7e840", "filename": "gcc/ada/s-osinte-hpux.ads", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-hpux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-hpux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-hpux.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -156,7 +156,8 @@ package System.OS_Interface is\n    pragma Convention (C, struct_sigaction);\n    type struct_sigaction_ptr is access all struct_sigaction;\n \n-   SA_SIGINFO  : constant := 16#10#;\n+   SA_SIGINFO : constant := 16#10#;\n+   SA_ONSTACK : constant := 16#01#;\n \n    SIG_BLOCK   : constant := 0;\n    SIG_UNBLOCK : constant := 1;\n@@ -278,26 +279,43 @@ package System.OS_Interface is\n    -- Stack --\n    -----------\n \n+   type stack_t is record\n+      ss_sp    : System.Address;\n+      ss_flags : int;\n+      ss_size  : size_t;\n+   end record;\n+   pragma Convention (C, stack_t);\n+\n+   function sigaltstack\n+     (ss  : not null access stack_t;\n+      oss : access stack_t) return int;\n+   pragma Import (C, sigaltstack, \"sigaltstack\");\n+\n+   Alternate_Stack : aliased System.Address;\n+   pragma Import (C, Alternate_Stack, \"__gnat_alternate_stack\");\n+   --  The alternate signal stack for stack overflows\n+\n+   Alternate_Stack_Size : constant := 16 * 1024;\n+   --  This must be in keeping with init.c:__gnat_alternate_stack\n+\n    Stack_Base_Available : constant Boolean := False;\n    --  Indicates wether the stack base is available on this target\n \n    function Get_Stack_Base (thread : pthread_t) return Address;\n    pragma Inline (Get_Stack_Base);\n-   --  returns the stack base of the specified thread.\n-   --  Only call this function when Stack_Base_Available is True.\n+   --  Returns the stack base of the specified thread. Only call this function\n+   --  when Stack_Base_Available is True.\n \n    function Get_Page_Size return size_t;\n    function Get_Page_Size return Address;\n    pragma Import (C, Get_Page_Size, \"getpagesize\");\n-   --  returns the size of a page, or 0 if this is not relevant on this\n-   --  target\n+   --  Returns the size of a page, or 0 if this is not relevant on this target\n \n    PROT_NONE  : constant := 0;\n    PROT_READ  : constant := 1;\n    PROT_WRITE : constant := 2;\n    PROT_EXEC  : constant := 4;\n    PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n-\n    PROT_ON    : constant := PROT_READ;\n    PROT_OFF   : constant := PROT_ALL;\n "}, {"sha": "7925a5e055872042fd90d7482e8e52c884bab620", "filename": "gcc/ada/s-osinte-linux-alpha.ads", "status": "removed", "additions": 0, "deletions": 508, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c3898c1d9a5351eaac6ffd792a5d1aaa268435/gcc%2Fada%2Fs-osinte-linux-alpha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c3898c1d9a5351eaac6ffd792a5d1aaa268435/gcc%2Fada%2Fs-osinte-linux-alpha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-linux-alpha.ads?ref=42c3898c1d9a5351eaac6ffd792a5d1aaa268435", "patch": "@@ -1,508 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2006, Free Software Foundation, Inc.      --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a GNU/Linux (GNU/LinuxThreads) version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by children of System.\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Interfaces.C;\n-with Unchecked_Conversion;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-\n-   pragma Linker_Options (\"-lpthread\");\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype char           is Interfaces.C.char;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EAGAIN    : constant := 35;\n-   EINTR     : constant := 4;\n-   EINVAL    : constant := 22;\n-   ENOMEM    : constant := 12;\n-   EPERM     : constant := 1;\n-   ETIMEDOUT : constant := 60;\n-\n-   -------------\n-   -- Signals --\n-   -------------\n-\n-   Max_Interrupt : constant := 63;\n-   type Signal is new int range 0 .. Max_Interrupt;\n-   for Signal'Size use int'Size;\n-\n-   SIGHUP     : constant := 1; --  hangup\n-   SIGINT     : constant := 2; --  interrupt (rubout)\n-   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n-   SIGILL     : constant := 4; --  illegal instruction (not reset)\n-   SIGTRAP    : constant := 5; --  trace trap (not reset)\n-   SIGIOT     : constant := 6; --  IOT instruction\n-   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n-   SIGFPE     : constant := 8; --  floating point exception\n-   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n-   SIGBUS     : constant := 10; --  bus error\n-   SIGSEGV    : constant := 11; --  segmentation violation\n-   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM    : constant := 14; --  alarm clock\n-   SIGTERM    : constant := 15; --  software termination signal from kill\n-   SIGURG     : constant := 16; --  urgent condition on IO channel\n-   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)\n-   SIGTSTP    : constant := 18; --  user stop requested from tty\n-   SIGCONT    : constant := 19; --  stopped process has been continued\n-   SIGCLD     : constant := 20; --  alias for SIGCHLD\n-   SIGCHLD    : constant := 20; --  child status change\n-   SIGTTIN    : constant := 21; --  background tty read attempted\n-   SIGTTOU    : constant := 22; --  background tty write attempted\n-   SIGIO      : constant := 23; --  I/O now possible (4.2 BSD)\n-   SIGPOLL    : constant := 23; --  pollable event occurred\n-   SIGXCPU    : constant := 24; --  CPU time limit exceeded\n-   SIGXFSZ    : constant := 25; --  filesize limit exceeded\n-   SIGVTALRM  : constant := 26; --  virtual timer expired\n-   SIGPROF    : constant := 27; --  profiling timer expired\n-   SIGWINCH   : constant := 28; --  window size change\n-   SIGPWR     : constant := 29; --  power-fail restart\n-   SIGUSR1    : constant := 30; --  user defined signal 1\n-   SIGUSR2    : constant := 31; --  user defined signal 2\n-\n-   SIGLTHRRES : constant := 32; --  GNU/LinuxThreads restart signal\n-   SIGLTHRCAN : constant := 33; --  GNU/LinuxThreads cancel signal\n-   SIGLTHRDBG : constant := 34; --  GNU/LinuxThreads debugger signal\n-\n-   SIGADAABORT : constant := SIGABRT;\n-   --  Change this if you want to use another signal for task abort.\n-   --  SIGTERM might be a good one.\n-\n-   SIGUNUSED  : constant := 0;\n-   SIGSTKFLT  : constant := 0;\n-   SIGLOST    : constant := 0;\n-   --  These don't exist for Linux/Alpha.  The constants are present\n-   --  so that we can continue to use a-intnam-linux.ads.\n-\n-   type Signal_Set is array (Natural range <>) of Signal;\n-\n-   Unmasked    : constant Signal_Set := (\n-      SIGTRAP,\n-      --  To enable debugging on multithreaded applications, mark SIGTRAP to\n-      --  be kept unmasked.\n-\n-      SIGBUS,\n-\n-      SIGTTIN, SIGTTOU, SIGTSTP,\n-      --  Keep these three signals unmasked so that background processes\n-      --  and IO behaves as normal \"C\" applications\n-\n-      SIGPROF,\n-      --  To avoid confusing the profiler\n-\n-      SIGKILL, SIGSTOP,\n-      --  These two signals actually cannot be masked;\n-      --  POSIX simply won't allow it.\n-\n-      SIGLTHRRES, SIGLTHRCAN, SIGLTHRDBG);\n-      --  These three signals are used by GNU/LinuxThreads starting from\n-      --  glibc 2.1 (future 2.2).\n-\n-   Reserved    : constant Signal_Set := (SIGKILL, SIGSTOP);\n-\n-   type sigset_t is private;\n-\n-   function sigaddset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigaddset, \"sigaddset\");\n-\n-   function sigdelset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigdelset, \"sigdelset\");\n-\n-   function sigfillset (set : access sigset_t) return int;\n-   pragma Import (C, sigfillset, \"sigfillset\");\n-\n-   function sigismember (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigismember, \"sigismember\");\n-\n-   function sigemptyset (set : access sigset_t) return int;\n-   pragma Import (C, sigemptyset, \"sigemptyset\");\n-\n-   type union_type_3 is new String (1 .. 116);\n-   type siginfo_t is record\n-      si_signo : int;\n-      si_code  : int;\n-      si_errno : int;\n-      X_data   : union_type_3;\n-   end record;\n-   pragma Convention (C, siginfo_t);\n-\n-   type struct_sigaction is record\n-      sa_handler   : System.Address;\n-      sa_mask      : sigset_t;\n-      sa_flags     : unsigned_long;\n-   end record;\n-   pragma Convention (C, struct_sigaction);\n-   type struct_sigaction_ptr is access all struct_sigaction;\n-\n-   type Machine_State is record\n-     dummy : unsigned_long;\n-   end record;\n-   type Machine_State_Ptr is access all Machine_State;\n-\n-   SA_SIGINFO  : constant := 16#40#;\n-\n-   SIG_BLOCK   : constant := 0;\n-   SIG_UNBLOCK : constant := 1;\n-   SIG_SETMASK : constant := 2;\n-\n-   SIG_DFL : constant := 0;\n-   SIG_IGN : constant := 1;\n-\n-   function sigaction\n-     (sig  : Signal;\n-      act  : struct_sigaction_ptr;\n-      oact : struct_sigaction_ptr) return int;\n-   pragma Import (C, sigaction, \"sigaction\");\n-\n-   ----------\n-   -- Time --\n-   ----------\n-\n-   type timespec is private;\n-\n-   function To_Duration (TS : timespec) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timespec (D : Duration) return timespec;\n-   pragma Inline (To_Timespec);\n-\n-   type struct_timeval is private;\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n-\n-   function gettimeofday\n-     (tv : access struct_timeval;\n-      tz : System.Address := System.Null_Address) return int;\n-   pragma Import (C, gettimeofday, \"gettimeofday\");\n-\n-   function sysconf (name : int) return long;\n-   pragma Import (C, sysconf);\n-\n-   SC_CLK_TCK : constant := 2;\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_OTHER : constant := 0;\n-   SCHED_FIFO  : constant := 1;\n-   SCHED_RR    : constant := 2;\n-\n-   function To_Target_Priority\n-     (Prio : System.Any_Priority) return Interfaces.C.int;\n-   --  Maps System.Any_Priority to a POSIX priority.\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill, \"kill\");\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid, \"getpid\");\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-\n-   function Thread_Body_Access is new\n-     Unchecked_Conversion (System.Address, Thread_Body);\n-\n-   type pthread_t is new unsigned_long;\n-   subtype Thread_Id        is pthread_t;\n-\n-   function To_pthread_t is new Unchecked_Conversion\n-     (unsigned_long, pthread_t);\n-\n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_DETACHED : constant := 1;\n-\n-   -----------\n-   -- Stack --\n-   -----------\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address;\n-   pragma Inline (Get_Stack_Base);\n-   --  This is a dummy procedure to share some GNULLI files\n-\n-   ---------------------------------------\n-   -- Nonstandard Thread Initialization --\n-   ---------------------------------------\n-\n-   procedure pthread_init;\n-   pragma Inline (pthread_init);\n-   --  This is a dummy procedure to share some GNULLI files\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function sigwait (set : access sigset_t; sig : access Signal) return int;\n-   pragma Import (C, sigwait, \"sigwait\");\n-\n-   function pthread_kill (thread : pthread_t; sig : Signal) return int;\n-   pragma Import (C, pthread_kill, \"pthread_kill\");\n-\n-   function pthread_sigmask\n-     (how  : int;\n-      set  : access sigset_t;\n-      oset : access sigset_t) return int;\n-   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n-\n-   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n-\n-   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access timespec) return int;\n-   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   type struct_sched_param is record\n-      sched_priority : int;  --  scheduling priority\n-   end record;\n-   pragma Convention (C, struct_sched_param);\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n-\n-   function pthread_attr_setschedpolicy\n-     (attr   : access pthread_attr_t;\n-      policy : int) return int;\n-   pragma Import\n-     (C, pthread_attr_setschedpolicy, \"pthread_attr_setschedpolicy\");\n-\n-   function sched_yield return int;\n-   pragma Import (C, sched_yield, \"sched_yield\");\n-\n-   ---------------------------\n-   -- P1003.1c - Section 16 --\n-   ---------------------------\n-\n-   function pthread_attr_init\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n-\n-   function pthread_attr_destroy\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   pragma Import\n-     (C, pthread_attr_setdetachstate, \"pthread_attr_setdetachstate\");\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Import (C, pthread_create, \"pthread_create\");\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Import (C, pthread_exit, \"pthread_exit\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"pthread_self\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return int;\n-   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address;\n-   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int;\n-   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n-\n-private\n-\n-   type sigset_t is record\n-      dum0, dum1, dum2, dum3, dum4, dum5, dum6, dum7 : unsigned_long;\n-      dum8, dum9, dum10, dum11, dum12, dum13, dum14, dum15 : unsigned_long;\n-   end record;\n-   pragma Convention (C, sigset_t);\n-\n-   type pid_t is new int;\n-\n-   type time_t is new long;\n-\n-   type timespec is record\n-      tv_sec  : time_t;\n-      tv_nsec : long;\n-   end record;\n-   pragma Convention (C, timespec);\n-\n-   type struct_timeval is record\n-      tv_sec  : time_t;\n-      tv_usec : time_t;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n-   type pthread_attr_t is record\n-      dum0, dum1, dum2, dum3, dum4, dum5, dum6 : unsigned_long;\n-   end record;\n-   pragma Convention (C, pthread_attr_t);\n-\n-   type pthread_condattr_t is record\n-      dummy : int;\n-   end record;\n-   pragma Convention (C, pthread_condattr_t);\n-\n-   type pthread_mutexattr_t is record\n-      mutexkind : int;\n-   end record;\n-   pragma Convention (C, pthread_mutexattr_t);\n-\n-   type pthread_mutex_t is record\n-      dum0, dum1, dum2, dum3, dum4 : unsigned_long;\n-   end record;\n-   pragma Convention (C, pthread_mutex_t);\n-\n-   type pthread_cond_t is record\n-      dum0, dum1, dum2, dum3, dum4, dum5 : unsigned_long;\n-   end record;\n-   pragma Convention (C, pthread_cond_t);\n-\n-   type pthread_key_t is new unsigned;\n-\n-end System.OS_Interface;"}, {"sha": "2467f09cf5b5db267e06a2a083a838d53733836f", "filename": "gcc/ada/s-osinte-linux-hppa.ads", "status": "removed", "additions": 0, "deletions": 560, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c3898c1d9a5351eaac6ffd792a5d1aaa268435/gcc%2Fada%2Fs-osinte-linux-hppa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c3898c1d9a5351eaac6ffd792a5d1aaa268435/gcc%2Fada%2Fs-osinte-linux-hppa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-linux-hppa.ads?ref=42c3898c1d9a5351eaac6ffd792a5d1aaa268435", "patch": "@@ -1,560 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                          (GNU/Linux-HPPA Version)                        --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2008, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n--- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNARL; see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n---                                                                          --\n--- As a special exception,  if other files  instantiate  generics from this --\n--- unit, or you link  this unit with other files  to produce an executable, --\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\n--- covered  by the  GNU  General  Public  License.  This exception does not --\n--- however invalidate  any other reasons why  the executable file  might be --\n--- covered by the  GNU Public License.                                      --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a GNU/Linux (GNU/LinuxThreads) version of this package\n-\n---  This package encapsulates all direct interfaces to OS services that are\n---  needed by the tasking run-time (libgnarl).\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Ada.Unchecked_Conversion;\n-\n-with Interfaces.C;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-\n-   pragma Linker_Options (\"-lpthread\");\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype char           is Interfaces.C.char;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EAGAIN    : constant := 11;\n-   EINTR     : constant := 4;\n-   EINVAL    : constant := 22;\n-   ENOMEM    : constant := 12;\n-   EPERM     : constant := 1;\n-   ETIMEDOUT : constant := 238;\n-\n-   -------------\n-   -- Signals --\n-   -------------\n-\n-   Max_Interrupt : constant := 63;\n-   type Signal is new int range 0 .. Max_Interrupt;\n-   for Signal'Size use int'Size;\n-\n-   SIGHUP     : constant := 1; --  hangup\n-   SIGINT     : constant := 2; --  interrupt (rubout)\n-   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n-   SIGILL     : constant := 4; --  illegal instruction (not reset)\n-   SIGTRAP    : constant := 5; --  trace trap (not reset)\n-   SIGIOT     : constant := 6; --  IOT instruction\n-   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n-   SIGEMT     : constant := 7; --  EMT\n-   SIGFPE     : constant := 8; --  floating point exception\n-   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n-   SIGBUS     : constant := 10; --  bus error\n-   SIGSEGV    : constant := 11; --  segmentation violation\n-   SIGSYS     : constant := 12; --  bad system call\n-   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM    : constant := 14; --  alarm clock\n-   SIGTERM    : constant := 15; --  software termination signal from kill\n-   SIGUSR1    : constant := 16; --  user defined signal 1\n-   SIGUSR2    : constant := 17; --  user defined signal 2\n-   SIGCLD     : constant := 18; --  alias for SIGCHLD\n-   SIGCHLD    : constant := 18; --  child status change\n-   SIGPWR     : constant := 19; --  power-fail restart\n-   SIGVTALRM  : constant := 20; --  virtual timer expired\n-   SIGPROF    : constant := 21; --  profiling timer expired\n-   SIGPOLL    : constant := 22; --  pollable event occurred\n-   SIGIO      : constant := 22; --  I/O now possible (4.2 BSD)\n-   SIGWINCH   : constant := 23; --  window size change\n-   SIGSTOP    : constant := 24; --  stop (cannot be caught or ignored)\n-   SIGTSTP    : constant := 25; --  user stop requested from tty\n-   SIGCONT    : constant := 26; --  stopped process has been continued\n-   SIGTTIN    : constant := 27; --  background tty read attempted\n-   SIGTTOU    : constant := 28; --  background tty write attempted\n-   SIGURG     : constant := 29; --  urgent condition on IO channel\n-   SIGLOST    : constant := 30; --  File lock lost\n-   SIGUNUSED  : constant := 31; --  unused signal (GNU/Linux)\n-   SIGXCPU    : constant := 33; --  CPU time limit exceeded\n-   SIGXFSZ    : constant := 34; --  filesize limit exceeded\n-   SIGSTKFLT  : constant := 36; --  coprocessor stack fault (Linux)\n-   SIGLTHRRES : constant := 37; --  GNU/LinuxThreads restart signal\n-   SIGLTHRCAN : constant := 38; --  GNU/LinuxThreads cancel signal\n-   SIGLTHRDBG : constant := 39; --  GNU/LinuxThreads debugger signal\n-\n-   SIGADAABORT : constant := SIGABRT;\n-   --  Change this if you want to use another signal for task abort.\n-   --  SIGTERM might be a good one.\n-\n-   type Signal_Set is array (Natural range <>) of Signal;\n-\n-   Unmasked    : constant Signal_Set := (\n-      SIGTRAP,\n-      --  To enable debugging on multithreaded applications, mark SIGTRAP to\n-      --  be kept unmasked.\n-\n-      SIGBUS,\n-\n-      SIGTTIN, SIGTTOU, SIGTSTP,\n-      --  Keep these three signals unmasked so that background processes\n-      --  and IO behaves as normal \"C\" applications\n-\n-      SIGPROF,\n-      --  To avoid confusing the profiler\n-\n-      SIGKILL, SIGSTOP,\n-      --  These two signals actually cannot be masked;\n-      --  POSIX simply won't allow it.\n-\n-      SIGLTHRRES, SIGLTHRCAN, SIGLTHRDBG);\n-      --  These three signals are used by GNU/LinuxThreads starting from\n-      --  glibc 2.1 (future 2.2).\n-\n-   Reserved    : constant Signal_Set :=\n-   --  I am not sure why the following two signals are reserved.\n-   --  I guess they are not supported by this version of GNU/Linux.\n-     (SIGVTALRM, SIGUNUSED);\n-\n-   type sigset_t is private;\n-\n-   function sigaddset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigaddset, \"sigaddset\");\n-\n-   function sigdelset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigdelset, \"sigdelset\");\n-\n-   function sigfillset (set : access sigset_t) return int;\n-   pragma Import (C, sigfillset, \"sigfillset\");\n-\n-   function sigismember (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigismember, \"sigismember\");\n-\n-   function sigemptyset (set : access sigset_t) return int;\n-   pragma Import (C, sigemptyset, \"sigemptyset\");\n-\n-   type union_type_3 is new String (1 .. 116);\n-   type siginfo_t is record\n-      si_signo : int;\n-      si_code  : int;\n-      si_errno : int;\n-      X_data   : union_type_3;\n-   end record;\n-   pragma Convention (C, siginfo_t);\n-\n-   type struct_sigaction is record\n-      sa_handler   : System.Address;\n-      sa_flags     : unsigned_long;\n-      sa_mask      : sigset_t;\n-   end record;\n-   pragma Convention (C, struct_sigaction);\n-   type struct_sigaction_ptr is access all struct_sigaction;\n-\n-   type Machine_State is record\n-      eip : unsigned_long;\n-      ebx : unsigned_long;\n-      esp : unsigned_long;\n-      ebp : unsigned_long;\n-      esi : unsigned_long;\n-      edi : unsigned_long;\n-   end record;\n-   type Machine_State_Ptr is access all Machine_State;\n-\n-   SA_SIGINFO  : constant := 16;\n-\n-   SIG_BLOCK   : constant := 0;\n-   SIG_UNBLOCK : constant := 1;\n-   SIG_SETMASK : constant := 2;\n-\n-   SIG_DFL : constant := 0;\n-   SIG_IGN : constant := 1;\n-\n-   function sigaction\n-     (sig  : Signal;\n-      act  : struct_sigaction_ptr;\n-      oact : struct_sigaction_ptr) return int;\n-   pragma Import (C, sigaction, \"sigaction\");\n-\n-   ----------\n-   -- Time --\n-   ----------\n-\n-   type timespec is private;\n-\n-   function To_Duration (TS : timespec) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timespec (D : Duration) return timespec;\n-   pragma Inline (To_Timespec);\n-\n-   type struct_timeval is private;\n-\n-   function To_Duration (TV : struct_timeval) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timeval (D : Duration) return struct_timeval;\n-   pragma Inline (To_Timeval);\n-\n-   function gettimeofday\n-     (tv : access struct_timeval;\n-      tz : System.Address := System.Null_Address) return int;\n-   pragma Import (C, gettimeofday, \"gettimeofday\");\n-\n-   function sysconf (name : int) return long;\n-   pragma Import (C, sysconf);\n-\n-   SC_CLK_TCK : constant := 2;\n-   SC_NPROCESSORS_ONLN : constant := 84;\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_OTHER : constant := 0;\n-   SCHED_FIFO  : constant := 1;\n-   SCHED_RR    : constant := 2;\n-\n-   function To_Target_Priority\n-     (Prio : System.Any_Priority) return Interfaces.C.int;\n-   --  Maps System.Any_Priority to a POSIX priority\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill, \"kill\");\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid, \"getpid\");\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-   pragma Convention (C, Thread_Body);\n-\n-   function Thread_Body_Access is new\n-     Ada.Unchecked_Conversion (System.Address, Thread_Body);\n-\n-   type pthread_t is new unsigned_long;\n-   subtype Thread_Id        is pthread_t;\n-\n-   function To_pthread_t is new Ada.Unchecked_Conversion\n-     (unsigned_long, pthread_t);\n-\n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_DETACHED : constant := 1;\n-\n-   -----------\n-   -- Stack --\n-   -----------\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address;\n-   pragma Inline (Get_Stack_Base);\n-   --  This is a dummy procedure to share some GNULLI files\n-\n-   ---------------------------------------\n-   -- Nonstandard Thread Initialization --\n-   ---------------------------------------\n-\n-   procedure pthread_init;\n-   pragma Inline (pthread_init);\n-   --  This is a dummy procedure to share some GNULLI files\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function sigwait (set : access sigset_t; sig : access Signal) return int;\n-   pragma Import (C, sigwait, \"sigwait\");\n-\n-   function pthread_kill (thread : pthread_t; sig : Signal) return int;\n-   pragma Import (C, pthread_kill, \"pthread_kill\");\n-\n-   function pthread_sigmask\n-     (how  : int;\n-      set  : access sigset_t;\n-      oset : access sigset_t) return int;\n-   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n-\n-   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n-\n-   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access timespec) return int;\n-   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   type struct_sched_param is record\n-      sched_priority : int;  --  scheduling priority\n-   end record;\n-   pragma Convention (C, struct_sched_param);\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n-\n-   function pthread_attr_setschedpolicy\n-     (attr   : access pthread_attr_t;\n-      policy : int) return int;\n-   pragma Import\n-     (C, pthread_attr_setschedpolicy, \"pthread_attr_setschedpolicy\");\n-\n-   function sched_yield return int;\n-   pragma Import (C, sched_yield, \"sched_yield\");\n-\n-   ---------------------------\n-   -- P1003.1c - Section 16 --\n-   ---------------------------\n-\n-   function pthread_attr_init\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n-\n-   function pthread_attr_destroy\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   pragma Import\n-     (C, pthread_attr_setdetachstate, \"pthread_attr_setdetachstate\");\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Import (C, pthread_create, \"pthread_create\");\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Import (C, pthread_exit, \"pthread_exit\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"pthread_self\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return int;\n-   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address;\n-   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-   pragma Convention (C, destructor_pointer);\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int;\n-   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n-\n-   CPU_SETSIZE : constant := 1_024;\n-\n-   type bit_field is array (1 .. CPU_SETSIZE) of Boolean;\n-   for bit_field'Size use CPU_SETSIZE;\n-   pragma Pack (bit_field);\n-   pragma Convention (C, bit_field);\n-\n-   type cpu_set_t is record\n-      bits : bit_field;\n-   end record;\n-   pragma Convention (C, cpu_set_t);\n-\n-   function pthread_setaffinity_np\n-     (thread     : pthread_t;\n-      cpusetsize : size_t;\n-      cpuset     : access cpu_set_t) return int;\n-   pragma Import (C, pthread_setaffinity_np, \"__gnat_pthread_setaffinity_np\");\n-\n-private\n-\n-   type sigset_t is array (0 .. 31) of unsigned_long;\n-   pragma Convention (C, sigset_t);\n-\n-   type pid_t is new int;\n-\n-   type time_t is new long;\n-\n-   type timespec is record\n-      tv_sec  : time_t;\n-      tv_nsec : long;\n-   end record;\n-   pragma Convention (C, timespec);\n-\n-   type struct_timeval is record\n-      tv_sec  : time_t;\n-      tv_usec : time_t;\n-   end record;\n-   pragma Convention (C, struct_timeval);\n-\n-   type pthread_attr_t is record\n-      detachstate   : int;\n-      schedpolicy   : int;\n-      schedparam    : struct_sched_param;\n-      inheritsched  : int;\n-      scope         : int;\n-      guardsize     : size_t;\n-      stackaddr_set : int;\n-      stackaddr     : System.Address;\n-      stacksize     : size_t;\n-   end record;\n-   pragma Convention (C, pthread_attr_t);\n-\n-   type pthread_condattr_t is record\n-      dummy : int;\n-   end record;\n-   pragma Convention (C, pthread_condattr_t);\n-\n-   type pthread_mutexattr_t is record\n-      mutexkind : int;\n-   end record;\n-   pragma Convention (C, pthread_mutexattr_t);\n-\n-   type lock_array is array (1 .. 4) of int;\n-   type atomic_lock_t is record\n-      lock : lock_array;\n-   end record;\n-   pragma Convention (C, atomic_lock_t);\n-   --  ??? Alignment should be 16 but this is larger than BIGGEST_ALIGNMENT.\n-   --  This causes an erroneous pointer value to sometimes be passed to free\n-   --  during deallocation.  See PR ada/24533 for more details.\n-   for atomic_lock_t'Alignment use 8;\n-\n-   type struct_pthread_fast_lock is record\n-      spinlock : atomic_lock_t;\n-      status   : long;\n-   end record;\n-   pragma Convention (C, struct_pthread_fast_lock);\n-\n-   type pthread_mutex_t is record\n-      m_reserved : int;\n-      m_count    : int;\n-      m_owner    : System.Address;\n-      m_kind     : int;\n-      m_lock     : struct_pthread_fast_lock;\n-   end record;\n-   pragma Convention (C, pthread_mutex_t);\n-\n-   type pthread_cond_t is array (0 .. 47) of unsigned_char;\n-   pragma Convention (C, pthread_cond_t);\n-\n-   type pthread_key_t is new unsigned;\n-\n-end System.OS_Interface;"}, {"sha": "bbaa0b4282e772b2469694144fd70a23fcd9615e", "filename": "gcc/ada/s-osinte-linux.ads", "status": "modified", "additions": 84, "deletions": 66, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-linux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-linux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-linux.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -41,8 +41,8 @@\n --  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n \n with Ada.Unchecked_Conversion;\n-\n with Interfaces.C;\n+with System.Linux;\n \n package System.OS_Interface is\n    pragma Preelaborate;\n@@ -67,12 +67,12 @@ package System.OS_Interface is\n    function errno return int;\n    pragma Import (C, errno, \"__get_errno\");\n \n-   EAGAIN    : constant := 11;\n-   EINTR     : constant := 4;\n-   EINVAL    : constant := 22;\n-   ENOMEM    : constant := 12;\n-   EPERM     : constant := 1;\n-   ETIMEDOUT : constant := 110;\n+   EAGAIN    : constant := System.Linux.EAGAIN;\n+   EINTR     : constant := System.Linux.EINTR;\n+   EINVAL    : constant := System.Linux.EINVAL;\n+   ENOMEM    : constant := System.Linux.ENOMEM;\n+   EPERM     : constant := System.Linux.EPERM;\n+   ETIMEDOUT : constant := System.Linux.ETIMEDOUT;\n \n    -------------\n    -- Signals --\n@@ -82,44 +82,44 @@ package System.OS_Interface is\n    type Signal is new int range 0 .. Max_Interrupt;\n    for Signal'Size use int'Size;\n \n-   SIGHUP     : constant := 1; --  hangup\n-   SIGINT     : constant := 2; --  interrupt (rubout)\n-   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n-   SIGILL     : constant := 4; --  illegal instruction (not reset)\n-   SIGTRAP    : constant := 5; --  trace trap (not reset)\n-   SIGIOT     : constant := 6; --  IOT instruction\n-   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n-   SIGFPE     : constant := 8; --  floating point exception\n-   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n-   SIGBUS     : constant := 7; --  bus error\n-   SIGSEGV    : constant := 11; --  segmentation violation\n-   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM    : constant := 14; --  alarm clock\n-   SIGTERM    : constant := 15; --  software termination signal from kill\n-   SIGUSR1    : constant := 10; --  user defined signal 1\n-   SIGUSR2    : constant := 12; --  user defined signal 2\n-   SIGCLD     : constant := 17; --  alias for SIGCHLD\n-   SIGCHLD    : constant := 17; --  child status change\n-   SIGPWR     : constant := 30; --  power-fail restart\n-   SIGWINCH   : constant := 28; --  window size change\n-   SIGURG     : constant := 23; --  urgent condition on IO channel\n-   SIGPOLL    : constant := 29; --  pollable event occurred\n-   SIGIO      : constant := 29; --  I/O now possible (4.2 BSD)\n-   SIGLOST    : constant := 29; --  File lock lost\n-   SIGSTOP    : constant := 19; --  stop (cannot be caught or ignored)\n-   SIGTSTP    : constant := 20; --  user stop requested from tty\n-   SIGCONT    : constant := 18; --  stopped process has been continued\n-   SIGTTIN    : constant := 21; --  background tty read attempted\n-   SIGTTOU    : constant := 22; --  background tty write attempted\n-   SIGVTALRM  : constant := 26; --  virtual timer expired\n-   SIGPROF    : constant := 27; --  profiling timer expired\n-   SIGXCPU    : constant := 24; --  CPU time limit exceeded\n-   SIGXFSZ    : constant := 25; --  filesize limit exceeded\n-   SIGUNUSED  : constant := 31; --  unused signal (GNU/Linux)\n-   SIGSTKFLT  : constant := 16; --  coprocessor stack fault (Linux)\n-   SIGLTHRRES : constant := 32; --  GNU/LinuxThreads restart signal\n-   SIGLTHRCAN : constant := 33; --  GNU/LinuxThreads cancel signal\n-   SIGLTHRDBG : constant := 34; --  GNU/LinuxThreads debugger signal\n+   SIGHUP     : constant := System.Linux.SIGHUP;\n+   SIGINT     : constant := System.Linux.SIGINT;\n+   SIGQUIT    : constant := System.Linux.SIGQUIT;\n+   SIGILL     : constant := System.Linux.SIGILL;\n+   SIGTRAP    : constant := System.Linux.SIGTRAP;\n+   SIGIOT     : constant := System.Linux.SIGIOT;\n+   SIGABRT    : constant := System.Linux.SIGABRT;\n+   SIGFPE     : constant := System.Linux.SIGFPE;\n+   SIGKILL    : constant := System.Linux.SIGKILL;\n+   SIGBUS     : constant := System.Linux.SIGBUS;\n+   SIGSEGV    : constant := System.Linux.SIGSEGV;\n+   SIGPIPE    : constant := System.Linux.SIGPIPE;\n+   SIGALRM    : constant := System.Linux.SIGALRM;\n+   SIGTERM    : constant := System.Linux.SIGTERM;\n+   SIGUSR1    : constant := System.Linux.SIGUSR1;\n+   SIGUSR2    : constant := System.Linux.SIGUSR2;\n+   SIGCLD     : constant := System.Linux.SIGCLD;\n+   SIGCHLD    : constant := System.Linux.SIGCHLD;\n+   SIGPWR     : constant := System.Linux.SIGPWR;\n+   SIGWINCH   : constant := System.Linux.SIGWINCH;\n+   SIGURG     : constant := System.Linux.SIGURG;\n+   SIGPOLL    : constant := System.Linux.SIGPOLL;\n+   SIGIO      : constant := System.Linux.SIGIO;\n+   SIGLOST    : constant := System.Linux.SIGLOST;\n+   SIGSTOP    : constant := System.Linux.SIGSTOP;\n+   SIGTSTP    : constant := System.Linux.SIGTSTP;\n+   SIGCONT    : constant := System.Linux.SIGCONT;\n+   SIGTTIN    : constant := System.Linux.SIGTTIN;\n+   SIGTTOU    : constant := System.Linux.SIGTTOU;\n+   SIGVTALRM  : constant := System.Linux.SIGVTALRM;\n+   SIGPROF    : constant := System.Linux.SIGPROF;\n+   SIGXCPU    : constant := System.Linux.SIGXCPU;\n+   SIGXFSZ    : constant := System.Linux.SIGXFSZ;\n+   SIGUNUSED  : constant := System.Linux.SIGUNUSED;\n+   SIGSTKFLT  : constant := System.Linux.SIGSTKFLT;\n+   SIGLTHRRES : constant := System.Linux.SIGLTHRRES;\n+   SIGLTHRCAN : constant := System.Linux.SIGLTHRCAN;\n+   SIGLTHRDBG : constant := System.Linux.SIGLTHRDBG;\n \n    SIGADAABORT : constant := SIGABRT;\n    --  Change this if you want to use another signal for task abort.\n@@ -181,12 +181,13 @@ package System.OS_Interface is\n    pragma Convention (C, siginfo_t);\n \n    type struct_sigaction is record\n-      sa_handler   : System.Address;\n-      sa_mask      : sigset_t;\n-      sa_flags     : unsigned_long;\n-      sa_restorer  : System.Address;\n+      sa_handler  : System.Address;\n+      sa_mask     : sigset_t;\n+      sa_flags    : Interfaces.C.unsigned_long;\n+      sa_restorer : System.Address;\n    end record;\n    pragma Convention (C, struct_sigaction);\n+\n    type struct_sigaction_ptr is access all struct_sigaction;\n \n    type Machine_State is record\n@@ -199,7 +200,8 @@ package System.OS_Interface is\n    end record;\n    type Machine_State_Ptr is access all Machine_State;\n \n-   SA_SIGINFO  : constant := 16#04#;\n+   SA_SIGINFO : constant := System.Linux.SA_SIGINFO;\n+   SA_ONSTACK : constant := System.Linux.SA_ONSTACK;\n \n    SIG_BLOCK   : constant := 0;\n    SIG_UNBLOCK : constant := 1;\n@@ -299,6 +301,25 @@ package System.OS_Interface is\n    -- Stack --\n    -----------\n \n+   type stack_t is record\n+      ss_sp    : System.Address;\n+      ss_flags : int;\n+      ss_size  : size_t;\n+   end record;\n+   pragma Convention (C, stack_t);\n+\n+   function sigaltstack\n+     (ss  : not null access stack_t;\n+      oss : access stack_t) return int;\n+   pragma Import (C, sigaltstack, \"sigaltstack\");\n+\n+   Alternate_Stack : aliased System.Address;\n+   pragma Import (C, Alternate_Stack, \"__gnat_alternate_stack\");\n+   --  The alternate signal stack for stack overflows\n+\n+   Alternate_Stack_Size : constant := 16 * 1024;\n+   --  This must be in keeping with init.c:__gnat_alternate_stack\n+\n    function Get_Stack_Base (thread : pthread_t) return Address;\n    pragma Inline (Get_Stack_Base);\n    --  This is a dummy procedure to share some GNULLI files\n@@ -483,9 +504,19 @@ package System.OS_Interface is\n \n private\n \n-   type sigset_t is array (0 .. 127) of unsigned_char;\n+   type sigset_t is array (0 .. 127) of Interfaces.C.unsigned_char;\n    pragma Convention (C, sigset_t);\n-   for sigset_t'Alignment use unsigned_long'Alignment;\n+   for sigset_t'Alignment use Interfaces.C.unsigned_long'Alignment;\n+\n+   pragma Warnings (Off);\n+   for struct_sigaction use record\n+      sa_handler at                  0 range 0 .. Standard'Address_Size - 1;\n+      sa_mask    at Linux.sa_mask_pos  range 0 .. 1023;\n+      sa_flags   at Linux.sa_flags_pos range 0 .. Standard'Address_Size - 1;\n+   end record;\n+   --  We intentionally leave sa_restorer unspecified and let the compiler\n+   --  append it after the last field, so disable corresponding warning.\n+   pragma Warnings (On);\n \n    type pid_t is new int;\n \n@@ -526,20 +557,7 @@ private\n    end record;\n    pragma Convention (C, pthread_mutexattr_t);\n \n-   type struct_pthread_fast_lock is record\n-      status   : long;\n-      spinlock : int;\n-   end record;\n-   pragma Convention (C, struct_pthread_fast_lock);\n-\n-   type pthread_mutex_t is record\n-      m_reserved : int;\n-      m_count    : int;\n-      m_owner    : System.Address;\n-      m_kind     : int;\n-      m_lock     : struct_pthread_fast_lock;\n-   end record;\n-   pragma Convention (C, pthread_mutex_t);\n+   type pthread_mutex_t is new System.Linux.pthread_mutex_t;\n \n    type pthread_cond_t is array (0 .. 47) of unsigned_char;\n    pragma Convention (C, pthread_cond_t);"}, {"sha": "37c183b1f69d9c07b8d464a754de34fc44c11552", "filename": "gcc/ada/s-osinte-lynxos-3.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-lynxos-3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-lynxos-3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos-3.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -267,6 +267,9 @@ package System.OS_Interface is\n    -- Stack --\n    -----------\n \n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n    Stack_Base_Available : constant Boolean := False;\n    --  Indicates wether the stack base is available on this target\n "}, {"sha": "13c2b88fcdb9dbcdb2f71fb2473f3650b4c248dc", "filename": "gcc/ada/s-osinte-lynxos.ads", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-lynxos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-lynxos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -170,7 +170,12 @@ package System.OS_Interface is\n    pragma Convention (C, struct_sigaction);\n    type struct_sigaction_ptr is access all struct_sigaction;\n \n-   SA_SIGINFO  : constant := 16#80#;\n+   SA_SIGINFO : constant := 16#80#;\n+\n+   SA_ONSTACK : constant := 16#00#;\n+   --  SA_ONSTACK is not defined on LynxOS, but it is refered to in the POSIX\n+   --  implementation of System.Interrupt_Management. Therefore we define a\n+   --  dummy value of zero here so that setting this flag is a nop.\n \n    SIG_BLOCK   : constant := 0;\n    SIG_UNBLOCK : constant := 1;\n@@ -276,6 +281,9 @@ package System.OS_Interface is\n    -- Stack --\n    -----------\n \n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n    Stack_Base_Available : constant Boolean := False;\n    --  Indicates whether the stack base is available on this target\n "}, {"sha": "f526c77df8c09e1a6e11a7bf3f5fb7138f79ae4f", "filename": "gcc/ada/s-osinte-mingw.ads", "status": "modified", "additions": 82, "deletions": 218, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-mingw.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -35,16 +35,17 @@\n --  This is a NT (native) version of this package\n \n --  This package encapsulates all direct interfaces to OS services\n---  that are needed by the tasking run-time (libgnarl).\n+--  that are needed by the tasking run-time (libgnarl). For non tasking\n+--  oriented services consider declaring them into system-win32.\n \n --  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n --  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n \n-with Interfaces.C;\n+with Ada.Unchecked_Conversion;\n \n+with Interfaces.C;\n with Interfaces.C.Strings;\n-\n-with Ada.Unchecked_Conversion;\n+with System.Win32;\n \n package System.OS_Interface is\n    pragma Preelaborate;\n@@ -58,39 +59,15 @@ package System.OS_Interface is\n    -- General Types --\n    -------------------\n \n-   type DWORD is new Interfaces.C.unsigned_long;\n-   type WORD  is new Interfaces.C.unsigned_short;\n-\n-   --  The LARGE_INTEGER type is actually a fixed point type\n-   --  that only can represent integers. The reason for this is\n-   --  easier conversion to Duration or other fixed point types.\n-   --  (See Operations.Clock)\n-\n-   type LARGE_INTEGER is delta 1.0 range -2.0**63 .. 2.0**63 - 1.0;\n-\n    subtype PSZ   is Interfaces.C.Strings.chars_ptr;\n-   subtype PCHAR is Interfaces.C.Strings.chars_ptr;\n-\n-   subtype PVOID is System.Address;\n-\n-   Null_Void : constant PVOID := System.Null_Address;\n \n-   type PLONG  is access all Interfaces.C.long;\n-   type PDWORD is access all DWORD;\n-   type BYTE is new Interfaces.C.unsigned_char;\n-   subtype CHAR is Interfaces.C.char;\n-\n-   type BOOL is new Boolean;\n-   for BOOL'Size use Interfaces.C.unsigned_long'Size;\n+   Null_Void : constant Win32.PVOID := System.Null_Address;\n \n    -------------------------\n    -- Handles for objects --\n    -------------------------\n \n-   type HANDLE is new Interfaces.C.long;\n-   type PHANDLE is access all HANDLE;\n-\n-   subtype Thread_Id is HANDLE;\n+   subtype Thread_Id is Win32.HANDLE;\n \n    -----------\n    -- Errno --\n@@ -99,38 +76,6 @@ package System.OS_Interface is\n    NO_ERROR : constant := 0;\n    FUNC_ERR : constant := -1;\n \n-   -----------\n-   -- Files --\n-   -----------\n-\n-   type SECURITY_ATTRIBUTES is record\n-      nLength             : DWORD;\n-      pSecurityDescriptor : PVOID;\n-      bInheritHandle      : BOOL;\n-   end record;\n-\n-   function CloseHandle (hObject : HANDLE) return BOOL;\n-   pragma Import (Stdcall, CloseHandle, \"CloseHandle\");\n-\n-   ------------------------\n-   -- System Information --\n-   ------------------------\n-\n-   type SYSTEM_INFO is record\n-      dwOemId                     : DWORD;\n-      dwPageSize                  : DWORD;\n-      lpMinimumApplicationAddress : PVOID;\n-      lpMaximumApplicationAddress : PVOID;\n-      dwActiveProcessorMask       : DWORD;\n-      dwNumberOfProcessors        : DWORD;\n-      dwProcessorType             : DWORD;\n-      dwAllocationGranularity     : DWORD;\n-      dwReserved                  : DWORD;\n-   end record;\n-\n-   procedure GetSystemInfo (SI : access SYSTEM_INFO);\n-   pragma Import (Stdcall, GetSystemInfo, \"GetSystemInfo\");\n-\n    -------------\n    -- Signals --\n    -------------\n@@ -161,63 +106,6 @@ package System.OS_Interface is\n    procedure kill (sig : Signal);\n    pragma Import (C, kill, \"raise\");\n \n-   ---------------------\n-   -- Time Management --\n-   ---------------------\n-\n-   procedure Sleep (dwMilliseconds : DWORD);\n-   pragma Import (Stdcall, Sleep, External_Name => \"Sleep\");\n-\n-   type SYSTEMTIME is record\n-      wYear         : WORD;\n-      wMonth        : WORD;\n-      wDayOfWeek    : WORD;\n-      wDay          : WORD;\n-      wHour         : WORD;\n-      wMinute       : WORD;\n-      wSecond       : WORD;\n-      wMilliseconds : WORD;\n-   end record;\n-\n-   procedure GetSystemTime (pSystemTime : access SYSTEMTIME);\n-   pragma Import (Stdcall, GetSystemTime, \"GetSystemTime\");\n-\n-   procedure GetSystemTimeAsFileTime (lpFileTime : access Long_Long_Integer);\n-   pragma Import (Stdcall, GetSystemTimeAsFileTime, \"GetSystemTimeAsFileTime\");\n-\n-   function SetSystemTime (pSystemTime : access SYSTEMTIME) return BOOL;\n-   pragma Import (Stdcall, SetSystemTime, \"SetSystemTime\");\n-\n-   function FileTimeToSystemTime\n-     (lpFileTime   : access Long_Long_Integer;\n-      lpSystemTime : access SYSTEMTIME) return BOOL;\n-   pragma Import (Stdcall, FileTimeToSystemTime, \"FileTimeToSystemTime\");\n-\n-   function SystemTimeToFileTime\n-     (lpSystemTime : access SYSTEMTIME;\n-      lpFileTime   : access Long_Long_Integer) return BOOL;\n-   pragma Import (Stdcall, SystemTimeToFileTime, \"SystemTimeToFileTime\");\n-\n-   function FileTimeToLocalFileTime\n-     (lpFileTime      : access Long_Long_Integer;\n-      lpLocalFileTime : access Long_Long_Integer) return BOOL;\n-   pragma Import (Stdcall, FileTimeToLocalFileTime, \"FileTimeToLocalFileTime\");\n-\n-   function LocalFileTimeToFileTime\n-     (lpFileTime      : access Long_Long_Integer;\n-      lpLocalFileTime : access Long_Long_Integer) return BOOL;\n-   pragma Import (Stdcall, LocalFileTimeToFileTime, \"LocalFileTimeToFileTime\");\n-\n-   function QueryPerformanceCounter\n-     (lpPerformanceCount : access LARGE_INTEGER) return BOOL;\n-   pragma Import\n-     (Stdcall, QueryPerformanceCounter, \"QueryPerformanceCounter\");\n-\n-   function QueryPerformanceFrequency\n-     (lpFrequency : access LARGE_INTEGER) return BOOL;\n-   pragma Import\n-     (Stdcall, QueryPerformanceFrequency, \"QueryPerformanceFrequency\");\n-\n    -------------\n    -- Threads --\n    -------------\n@@ -233,11 +121,11 @@ package System.OS_Interface is\n    pragma Import (Stdcall, SwitchToThread, \"SwitchToThread\");\n \n    function GetThreadTimes\n-     (hThread        : HANDLE;\n+     (hThread        : Win32.HANDLE;\n       lpCreationTime : access Long_Long_Integer;\n       lpExitTime     : access Long_Long_Integer;\n       lpKernelTime   : access Long_Long_Integer;\n-      lpUserTime     : access Long_Long_Integer) return BOOL;\n+      lpUserTime     : access Long_Long_Integer) return Win32.BOOL;\n    pragma Import (Stdcall, GetThreadTimes, \"GetThreadTimes\");\n \n    -----------------------\n@@ -246,52 +134,33 @@ package System.OS_Interface is\n \n    type CRITICAL_SECTION is private;\n \n-   procedure InitializeCriticalSection\n-     (pCriticalSection : access CRITICAL_SECTION);\n-   pragma Import\n-     (Stdcall, InitializeCriticalSection, \"InitializeCriticalSection\");\n-\n-   procedure EnterCriticalSection\n-     (pCriticalSection : access CRITICAL_SECTION);\n-   pragma Import (Stdcall, EnterCriticalSection, \"EnterCriticalSection\");\n-\n-   procedure LeaveCriticalSection\n-     (pCriticalSection : access CRITICAL_SECTION);\n-   pragma Import (Stdcall, LeaveCriticalSection, \"LeaveCriticalSection\");\n-\n-   procedure DeleteCriticalSection\n-     (pCriticalSection : access CRITICAL_SECTION);\n-   pragma Import (Stdcall, DeleteCriticalSection, \"DeleteCriticalSection\");\n-\n    -------------------------------------------------------------\n    -- Thread Creation, Activation, Suspension And Termination --\n    -------------------------------------------------------------\n \n-   subtype ProcessorId is DWORD;\n-\n    type PTHREAD_START_ROUTINE is access function\n-     (pThreadParameter : PVOID) return DWORD;\n+     (pThreadParameter : Win32.PVOID) return Win32.DWORD;\n    pragma Convention (Stdcall, PTHREAD_START_ROUTINE);\n \n    function To_PTHREAD_START_ROUTINE is new\n      Ada.Unchecked_Conversion (System.Address, PTHREAD_START_ROUTINE);\n \n    function CreateThread\n-     (pThreadAttributes : access SECURITY_ATTRIBUTES;\n-      dwStackSize       : DWORD;\n+     (pThreadAttributes : access Win32.SECURITY_ATTRIBUTES;\n+      dwStackSize       : Win32.DWORD;\n       pStartAddress     : PTHREAD_START_ROUTINE;\n-      pParameter        : PVOID;\n-      dwCreationFlags   : DWORD;\n-      pThreadId         : PDWORD) return HANDLE;\n+      pParameter        : Win32.PVOID;\n+      dwCreationFlags   : Win32.DWORD;\n+      pThreadId         : access Win32.DWORD) return Win32.HANDLE;\n    pragma Import (Stdcall, CreateThread, \"CreateThread\");\n \n    function BeginThreadEx\n-     (pThreadAttributes : access SECURITY_ATTRIBUTES;\n-      dwStackSize       : DWORD;\n+     (pThreadAttributes : access Win32.SECURITY_ATTRIBUTES;\n+      dwStackSize       : Win32.DWORD;\n       pStartAddress     : PTHREAD_START_ROUTINE;\n-      pParameter        : PVOID;\n-      dwCreationFlags   : DWORD;\n-      pThreadId         : PDWORD) return HANDLE;\n+      pParameter        : Win32.PVOID;\n+      dwCreationFlags   : Win32.DWORD;\n+      pThreadId         : not null access Win32.DWORD) return Win32.HANDLE;\n    pragma Import (C, BeginThreadEx, \"_beginthreadex\");\n \n    Debug_Process                     : constant := 16#00000001#;\n@@ -311,70 +180,66 @@ package System.OS_Interface is\n    Stack_Size_Param_Is_A_Reservation : constant := 16#00010000#;\n \n    function GetExitCodeThread\n-     (hThread   : HANDLE;\n-      pExitCode : PDWORD) return BOOL;\n+     (hThread   : Win32.HANDLE;\n+      pExitCode : not null access Win32.DWORD) return Win32.BOOL;\n    pragma Import (Stdcall, GetExitCodeThread, \"GetExitCodeThread\");\n \n-   function ResumeThread (hThread : HANDLE) return DWORD;\n+   function ResumeThread (hThread : Win32.HANDLE) return Win32.DWORD;\n    pragma Import (Stdcall, ResumeThread, \"ResumeThread\");\n \n-   function SuspendThread (hThread : HANDLE) return DWORD;\n+   function SuspendThread (hThread : Win32.HANDLE) return Win32.DWORD;\n    pragma Import (Stdcall, SuspendThread, \"SuspendThread\");\n \n-   procedure ExitThread (dwExitCode : DWORD);\n+   procedure ExitThread (dwExitCode : Win32.DWORD);\n    pragma Import (Stdcall, ExitThread, \"ExitThread\");\n \n-   procedure EndThreadEx (dwExitCode : DWORD);\n+   procedure EndThreadEx (dwExitCode : Win32.DWORD);\n    pragma Import (C, EndThreadEx, \"_endthreadex\");\n \n    function TerminateThread\n-     (hThread    : HANDLE;\n-      dwExitCode : DWORD) return BOOL;\n+     (hThread    : Win32.HANDLE;\n+      dwExitCode : Win32.DWORD) return Win32.BOOL;\n    pragma Import (Stdcall, TerminateThread, \"TerminateThread\");\n \n-   function GetCurrentThread return HANDLE;\n+   function GetCurrentThread return Win32.HANDLE;\n    pragma Import (Stdcall, GetCurrentThread, \"GetCurrentThread\");\n \n-   function GetCurrentProcess return HANDLE;\n+   function GetCurrentProcess return Win32.HANDLE;\n    pragma Import (Stdcall, GetCurrentProcess, \"GetCurrentProcess\");\n \n-   function GetCurrentThreadId return DWORD;\n+   function GetCurrentThreadId return Win32.DWORD;\n    pragma Import (Stdcall, GetCurrentThreadId, \"GetCurrentThreadId\");\n \n-   function TlsAlloc return DWORD;\n+   function TlsAlloc return Win32.DWORD;\n    pragma Import (Stdcall, TlsAlloc, \"TlsAlloc\");\n \n-   function TlsGetValue (dwTlsIndex : DWORD) return PVOID;\n+   function TlsGetValue (dwTlsIndex : Win32.DWORD) return Win32.PVOID;\n    pragma Import (Stdcall, TlsGetValue, \"TlsGetValue\");\n \n-   function TlsSetValue (dwTlsIndex : DWORD; pTlsValue : PVOID) return BOOL;\n+   function TlsSetValue\n+     (dwTlsIndex : Win32.DWORD; pTlsValue : Win32.PVOID) return Win32.BOOL;\n    pragma Import (Stdcall, TlsSetValue, \"TlsSetValue\");\n \n-   function TlsFree (dwTlsIndex : DWORD) return BOOL;\n+   function TlsFree (dwTlsIndex : Win32.DWORD) return Win32.BOOL;\n    pragma Import (Stdcall, TlsFree, \"TlsFree\");\n \n-   TLS_Nothing : constant := DWORD'Last;\n+   TLS_Nothing : constant := Win32.DWORD'Last;\n \n    procedure ExitProcess (uExitCode : Interfaces.C.unsigned);\n    pragma Import (Stdcall, ExitProcess, \"ExitProcess\");\n \n    function WaitForSingleObject\n-     (hHandle        : HANDLE;\n-      dwMilliseconds : DWORD) return DWORD;\n+     (hHandle        : Win32.HANDLE;\n+      dwMilliseconds : Win32.DWORD) return Win32.DWORD;\n    pragma Import (Stdcall, WaitForSingleObject, \"WaitForSingleObject\");\n \n    function WaitForSingleObjectEx\n-     (hHandle        : HANDLE;\n-      dwMilliseconds : DWORD;\n-      fAlertable     : BOOL) return DWORD;\n+     (hHandle        : Win32.HANDLE;\n+      dwMilliseconds : Win32.DWORD;\n+      fAlertable     : Win32.BOOL) return Win32.DWORD;\n    pragma Import (Stdcall, WaitForSingleObjectEx, \"WaitForSingleObjectEx\");\n \n-   function SetThreadIdealProcessor\n-     (hThread          : HANDLE;\n-      dwIdealProcessor : ProcessorId) return DWORD;\n-   pragma Import (Stdcall, SetThreadIdealProcessor, \"SetThreadIdealProcessor\");\n-\n-   Wait_Infinite : constant := DWORD'Last;\n+   Wait_Infinite : constant := Win32.DWORD'Last;\n    WAIT_TIMEOUT  : constant := 16#0000_0102#;\n    WAIT_FAILED   : constant := 16#FFFF_FFFF#;\n \n@@ -383,59 +248,59 @@ package System.OS_Interface is\n    ------------------------------------\n \n    function CreateSemaphore\n-     (pSemaphoreAttributes : access SECURITY_ATTRIBUTES;\n+     (pSemaphoreAttributes : access Win32.SECURITY_ATTRIBUTES;\n       lInitialCount        : Interfaces.C.long;\n       lMaximumCount        : Interfaces.C.long;\n-      pName                : PSZ) return HANDLE;\n+      pName                : PSZ) return Win32.HANDLE;\n    pragma Import (Stdcall, CreateSemaphore, \"CreateSemaphoreA\");\n \n    function OpenSemaphore\n-     (dwDesiredAccess : DWORD;\n-      bInheritHandle  : BOOL;\n-      pName           : PSZ) return HANDLE;\n+     (dwDesiredAccess : Win32.DWORD;\n+      bInheritHandle  : Win32.BOOL;\n+      pName           : PSZ) return Win32.HANDLE;\n    pragma Import (Stdcall, OpenSemaphore, \"OpenSemaphoreA\");\n \n    function ReleaseSemaphore\n-     (hSemaphore     : HANDLE;\n+     (hSemaphore     : Win32.HANDLE;\n       lReleaseCount  : Interfaces.C.long;\n-      pPreviousCount : PLONG) return BOOL;\n+      pPreviousCount : access Win32.LONG) return Win32.BOOL;\n    pragma Import (Stdcall, ReleaseSemaphore, \"ReleaseSemaphore\");\n \n    function CreateEvent\n-     (pEventAttributes : access SECURITY_ATTRIBUTES;\n-      bManualReset     : BOOL;\n-      bInitialState    : BOOL;\n-      pName            : PSZ) return HANDLE;\n+     (pEventAttributes : access Win32.SECURITY_ATTRIBUTES;\n+      bManualReset     : Win32.BOOL;\n+      bInitialState    : Win32.BOOL;\n+      pName            : PSZ) return Win32.HANDLE;\n    pragma Import (Stdcall, CreateEvent, \"CreateEventA\");\n \n    function OpenEvent\n-     (dwDesiredAccess : DWORD;\n-      bInheritHandle  : BOOL;\n-      pName           : PSZ) return HANDLE;\n+     (dwDesiredAccess : Win32.DWORD;\n+      bInheritHandle  : Win32.BOOL;\n+      pName           : PSZ) return Win32.HANDLE;\n    pragma Import (Stdcall, OpenEvent, \"OpenEventA\");\n \n-   function SetEvent (hEvent : HANDLE) return BOOL;\n+   function SetEvent (hEvent : Win32.HANDLE) return Win32.BOOL;\n    pragma Import (Stdcall, SetEvent, \"SetEvent\");\n \n-   function ResetEvent (hEvent : HANDLE) return BOOL;\n+   function ResetEvent (hEvent : Win32.HANDLE) return Win32.BOOL;\n    pragma Import (Stdcall, ResetEvent, \"ResetEvent\");\n \n-   function PulseEvent (hEvent : HANDLE) return BOOL;\n+   function PulseEvent (hEvent : Win32.HANDLE) return Win32.BOOL;\n    pragma Import (Stdcall, PulseEvent, \"PulseEvent\");\n \n    function CreateMutex\n-     (pMutexAttributes : access SECURITY_ATTRIBUTES;\n-      bInitialOwner    : BOOL;\n-      pName            : PSZ) return HANDLE;\n+     (pMutexAttributes : access Win32.SECURITY_ATTRIBUTES;\n+      bInitialOwner    : Win32.BOOL;\n+      pName            : PSZ) return Win32.HANDLE;\n    pragma Import (Stdcall, CreateMutex, \"CreateMutexA\");\n \n    function OpenMutex\n-     (dwDesiredAccess : DWORD;\n-      bInheritHandle  : BOOL;\n-      pName           : PSZ) return HANDLE;\n+     (dwDesiredAccess : Win32.DWORD;\n+      bInheritHandle  : Win32.BOOL;\n+      pName           : PSZ) return Win32.HANDLE;\n    pragma Import (Stdcall, OpenMutex, \"OpenMutexA\");\n \n-   function ReleaseMutex (hMutex : HANDLE) return BOOL;\n+   function ReleaseMutex (hMutex : Win32.HANDLE) return Win32.BOOL;\n    pragma Import (Stdcall, ReleaseMutex, \"ReleaseMutex\");\n \n    ---------------------------------------------------\n@@ -447,21 +312,21 @@ package System.OS_Interface is\n    -----------------\n \n    function SetThreadPriority\n-     (hThread   : HANDLE;\n-      nPriority : Interfaces.C.int) return BOOL;\n+     (hThread   : Win32.HANDLE;\n+      nPriority : Interfaces.C.int) return Win32.BOOL;\n    pragma Import (Stdcall, SetThreadPriority, \"SetThreadPriority\");\n \n-   function GetThreadPriority (hThread : HANDLE) return Interfaces.C.int;\n+   function GetThreadPriority (hThread : Win32.HANDLE) return Interfaces.C.int;\n    pragma Import (Stdcall, GetThreadPriority, \"GetThreadPriority\");\n \n    function SetPriorityClass\n-     (hProcess        : HANDLE;\n-      dwPriorityClass : DWORD) return BOOL;\n+     (hProcess        : Win32.HANDLE;\n+      dwPriorityClass : Win32.DWORD) return Win32.BOOL;\n    pragma Import (Stdcall, SetPriorityClass, \"SetPriorityClass\");\n \n    procedure SetThreadPriorityBoost\n-     (hThread              : HANDLE;\n-      DisablePriorityBoost : BOOL);\n+     (hThread              : Win32.HANDLE;\n+      DisablePriorityBoost : Win32.BOOL);\n    pragma Import (Stdcall, SetThreadPriorityBoost, \"SetThreadPriorityBoost\");\n \n    Normal_Priority_Class   : constant := 16#00000020#;\n@@ -478,22 +343,21 @@ package System.OS_Interface is\n    Thread_Priority_Time_Critical : constant := 15;\n    Thread_Priority_Error_Return  : constant := Interfaces.C.long'Last;\n \n-   function GetLastError return DWORD;\n-   pragma Import (Stdcall, GetLastError, \"GetLastError\");\n-\n private\n \n    type sigset_t is new Interfaces.C.unsigned_long;\n \n    type CRITICAL_SECTION is record\n-      DebugInfo      : System.Address;\n-      --  The following three fields control entering and\n-      --  exiting the critical section for the resource\n+      DebugInfo : System.Address;\n+\n       LockCount      : Long_Integer;\n       RecursionCount : Long_Integer;\n-      OwningThread   : HANDLE;\n-      LockSemaphore  : HANDLE;\n-      Reserved       : DWORD;\n+      OwningThread   : Win32.HANDLE;\n+      --  The above three fields control entering and exiting the critical\n+      --  section for the resource.\n+\n+      LockSemaphore : Win32.HANDLE;\n+      Reserved      : Win32.DWORD;\n    end record;\n \n end System.OS_Interface;"}, {"sha": "05b328df26ad6481c7f8f73a6bd7d48601d34f47", "filename": "gcc/ada/s-osinte-solaris-posix.ads", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-solaris-posix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-solaris-posix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-solaris-posix.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -165,6 +165,7 @@ package System.OS_Interface is\n    type struct_sigaction_ptr is access all struct_sigaction;\n \n    SA_SIGINFO : constant := 16#0008#;\n+   SA_ONSTACK : constant := 16#0001#;\n \n    SIG_BLOCK   : constant := 1;\n    SIG_UNBLOCK : constant := 2;\n@@ -272,26 +273,42 @@ package System.OS_Interface is\n    -- Stack --\n    -----------\n \n+   type stack_t is record\n+      ss_sp    : System.Address;\n+      ss_size  : size_t;\n+      ss_flags : int;\n+   end record;\n+   pragma Convention (C, stack_t);\n+\n+   function sigaltstack\n+     (ss  : not null access stack_t;\n+      oss : access stack_t) return int;\n+   pragma Import (C, sigaltstack, \"sigaltstack\");\n+\n+   Alternate_Stack : aliased System.Address;\n+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n    Stack_Base_Available : constant Boolean := False;\n    --  Indicates whether the stack base is available on this target\n \n    function Get_Stack_Base (thread : pthread_t) return Address;\n    pragma Inline (Get_Stack_Base);\n-   --  returns the stack base of the specified thread.\n-   --  Only call this function when Stack_Base_Available is True.\n+   --  Returns the stack base of the specified thread. Only call this function\n+   --  when Stack_Base_Available is True.\n \n    function Get_Page_Size return size_t;\n    function Get_Page_Size return Address;\n    pragma Import (C, Get_Page_Size, \"getpagesize\");\n-   --  returns the size of a page, or 0 if this is not relevant on this\n-   --  target\n+   --  Returns the size of a page, or 0 if this is not relevant on this target\n \n    PROT_NONE  : constant := 0;\n    PROT_READ  : constant := 1;\n    PROT_WRITE : constant := 2;\n    PROT_EXEC  : constant := 4;\n    PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n-\n    PROT_ON    : constant := PROT_READ;\n    PROT_OFF   : constant := PROT_ALL;\n "}, {"sha": "efb739f8f5085038952e0d1d3324d6e1ea0b87a9", "filename": "gcc/ada/s-osinte-tru64.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-tru64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-osinte-tru64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-tru64.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -176,6 +176,7 @@ package System.OS_Interface is\n \n    SA_NODEFER : constant := 8;\n    SA_SIGINFO : constant := 16#40#;\n+   SA_ONSTACK : constant := 16#01#;\n \n    function sigaction\n      (sig  : Signal;"}, {"sha": "a4bc9495719eb5cc516ed28010fe1d154e17dc5b", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 32, "deletions": 72, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -49,7 +49,6 @@ with System.Task_Info;\n with System.Tasking.Debug;\n with System.Interrupt_Management;\n with System.OS_Primitives;\n-with System.Storage_Elements;\n with System.Stack_Checking.Operations;\n \n with System.Soft_Links;\n@@ -69,9 +68,11 @@ package body System.Task_Primitives.Operations is\n    use System.OS_Interface;\n    use System.Parameters;\n    use System.OS_Primitives;\n-   use System.Storage_Elements;\n    use System.Task_Info;\n \n+   Use_Alternate_Stack : constant Boolean := Alternate_Stack_Size /= 0;\n+   --  Whether to use an alternate signal stack for stack overflows\n+\n    ----------------\n    -- Local Data --\n    ----------------\n@@ -161,13 +162,6 @@ package body System.Task_Primitives.Operations is\n    function To_pthread_t is new Ada.Unchecked_Conversion\n      (unsigned_long, System.OS_Interface.pthread_t);\n \n-   procedure Get_Stack_Attributes\n-     (T    : Task_Id;\n-      ISP  : out System.Address;\n-      Size : out Storage_Offset);\n-   --  Fill ISP and Size with the Initial Stack Pointer value and the\n-   --  thread stack size for task T.\n-\n    -------------------\n    -- Abort_Handler --\n    -------------------\n@@ -696,59 +690,14 @@ package body System.Task_Primitives.Operations is\n       return T.Common.Current_Priority;\n    end Get_Priority;\n \n-   --------------------------\n-   -- Get_Stack_Attributes --\n-   --------------------------\n-\n-   procedure Get_Stack_Attributes\n-     (T    : Task_Id;\n-      ISP  : out System.Address;\n-      Size : out Storage_Offset)\n-   is\n-      function pthread_getattr_np\n-        (thread : pthread_t;\n-         attr   : System.Address) return Interfaces.C.int;\n-      pragma Import (C, pthread_getattr_np, \"pthread_getattr_np\");\n-\n-      function pthread_attr_getstack\n-        (attr : System.Address;\n-         base : System.Address;\n-         size : System.Address) return Interfaces.C.int;\n-      pragma Import (C, pthread_attr_getstack, \"pthread_attr_getstack\");\n-\n-      Result : Interfaces.C.int;\n-\n-      Attributes : aliased pthread_attr_t;\n-      Stack_Base : aliased System.Address;\n-      Stack_Size : aliased Storage_Offset;\n-\n-   begin\n-      Result :=\n-        pthread_getattr_np\n-          (T.Common.LL.Thread, Attributes'Address);\n-      pragma Assert (Result = 0);\n-\n-      Result :=\n-        pthread_attr_getstack\n-          (Attributes'Address, Stack_Base'Address, Stack_Size'Address);\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_attr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n-\n-      ISP  := Stack_Base + Stack_Size;\n-      Size := Stack_Size;\n-   end Get_Stack_Attributes;\n-\n    ----------------\n    -- Enter_Task --\n    ----------------\n \n    procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n       if Self_ID.Common.Task_Info /= null\n-        and then\n-          Self_ID.Common.Task_Info.CPU_Affinity = No_CPU\n+        and then Self_ID.Common.Task_Info.CPU_Affinity = No_CPU\n       then\n          raise Invalid_CPU_Number;\n       end if;\n@@ -769,17 +718,18 @@ package body System.Task_Primitives.Operations is\n \n       Unlock_RTS;\n \n-      --  Determine where the task stack starts, how large it is, and let the\n-      --  stack checking engine know about it.\n-\n-      declare\n-         Initial_SP : System.Address;\n-         Stack_Size : Storage_Offset;\n-      begin\n-         Get_Stack_Attributes (Self_ID, Initial_SP, Stack_Size);\n-         System.Stack_Checking.Operations.Notify_Stack_Attributes\n-           (Initial_SP, Stack_Size);\n-      end;\n+      if Use_Alternate_Stack then\n+         declare\n+            Stack  : aliased stack_t;\n+            Result : Interfaces.C.int;\n+         begin\n+            Stack.ss_sp    := Self_ID.Common.Task_Alternate_Stack;\n+            Stack.ss_size  := Alternate_Stack_Size;\n+            Stack.ss_flags := 0;\n+            Result := sigaltstack (Stack'Access, null);\n+            pragma Assert (Result = 0);\n+         end;\n+      end if;\n    end Enter_Task;\n \n    --------------\n@@ -864,10 +814,14 @@ package body System.Task_Primitives.Operations is\n       Priority   : System.Any_Priority;\n       Succeeded  : out Boolean)\n    is\n-      Attributes : aliased pthread_attr_t;\n-      Result     : Interfaces.C.int;\n+      Attributes          : aliased pthread_attr_t;\n+      Adjusted_Stack_Size : Interfaces.C.size_t;\n+      Result              : Interfaces.C.int;\n \n    begin\n+      Adjusted_Stack_Size :=\n+         Interfaces.C.size_t (Stack_Size + Alternate_Stack_Size);\n+\n       Result := pthread_attr_init (Attributes'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n@@ -878,7 +832,7 @@ package body System.Task_Primitives.Operations is\n \n       Result :=\n         pthread_attr_setstacksize\n-          (Attributes'Access, Interfaces.C.size_t (Stack_Size));\n+          (Attributes'Access, Adjusted_Stack_Size);\n       pragma Assert (Result = 0);\n \n       Result :=\n@@ -896,7 +850,8 @@ package body System.Task_Primitives.Operations is\n          Attributes'Access,\n          Thread_Body_Access (Wrapper),\n          To_Address (T));\n-      pragma Assert (Result = 0 or else Result = EAGAIN);\n+      pragma Assert\n+        (Result = 0 or else Result = EAGAIN or else Result = ENOMEM);\n \n       if Result /= 0 then\n          Succeeded := False;\n@@ -1148,8 +1103,7 @@ package body System.Task_Primitives.Operations is\n          pragma Assert (Result = 0);\n \n          SSL.Abort_Undefer.all;\n-      end\n-      if;\n+      end if;\n    end Suspend_Until_True;\n \n    ----------------\n@@ -1253,6 +1207,7 @@ package body System.Task_Primitives.Operations is\n       old_act : aliased struct_sigaction;\n       Tmp_Set : aliased sigset_t;\n       Result  : Interfaces.C.int;\n+      --  Whether to use an alternate signal stack for stack overflows\n \n       function State\n         (Int : System.Interrupt_Management.Interrupt_ID) return Character;\n@@ -1297,6 +1252,11 @@ package body System.Task_Primitives.Operations is\n \n       Specific.Initialize (Environment_Task);\n \n+      if Use_Alternate_Stack then\n+         Environment_Task.Common.Task_Alternate_Stack :=\n+           Alternate_Stack'Address;\n+      end if;\n+\n       Enter_Task (Environment_Task);\n \n       --  Install the abort-signal handler"}, {"sha": "898b75e21738ab4b5e0d59d97d1fadeb7c164f6c", "filename": "gcc/ada/s-taprop-mingw.adb", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taprop-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taprop-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-mingw.adb?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -49,6 +49,7 @@ with System.Tasking.Debug;\n with System.OS_Primitives;\n with System.Task_Info;\n with System.Interrupt_Management;\n+with System.Win32.Ext;\n \n with System.Soft_Links;\n --  We use System.Soft_Links instead of System.Tasking.Initialization because\n@@ -68,6 +69,8 @@ package body System.Task_Primitives.Operations is\n    use System.Parameters;\n    use System.OS_Primitives;\n    use System.Task_Info;\n+   use System.Win32;\n+   use System.Win32.Ext;\n \n    pragma Link_With (\"-Xlinker --stack=0x200000,0x1000\");\n    --  Change the default stack size (2 MB) for tasking programs on Windows.\n@@ -76,6 +79,30 @@ package body System.Task_Primitives.Operations is\n    --  Also note that under Windows XP, we use a Windows XP extension to\n    --  specify the stack size on a per task basis, as done under other OSes.\n \n+   ---------------------\n+   -- Local Functions --\n+   ---------------------\n+\n+   procedure InitializeCriticalSection (pCriticalSection : access RTS_Lock);\n+   procedure InitializeCriticalSection\n+     (pCriticalSection : access CRITICAL_SECTION);\n+   pragma Import\n+     (Stdcall, InitializeCriticalSection, \"InitializeCriticalSection\");\n+\n+   procedure EnterCriticalSection (pCriticalSection : access RTS_Lock);\n+   procedure EnterCriticalSection\n+     (pCriticalSection : access CRITICAL_SECTION);\n+   pragma Import (Stdcall, EnterCriticalSection, \"EnterCriticalSection\");\n+\n+   procedure LeaveCriticalSection (pCriticalSection : access RTS_Lock);\n+   procedure LeaveCriticalSection (pCriticalSection : access CRITICAL_SECTION);\n+   pragma Import (Stdcall, LeaveCriticalSection, \"LeaveCriticalSection\");\n+\n+   procedure DeleteCriticalSection (pCriticalSection : access RTS_Lock);\n+   procedure DeleteCriticalSection\n+     (pCriticalSection : access CRITICAL_SECTION);\n+   pragma Import (Stdcall, DeleteCriticalSection, \"DeleteCriticalSection\");\n+\n    ----------------\n    -- Local Data --\n    ----------------\n@@ -140,7 +167,7 @@ package body System.Task_Primitives.Operations is\n          Succeeded : BOOL;\n       begin\n          Succeeded := TlsSetValue (TlsIndex, To_Address (Self_Id));\n-         pragma Assert (Succeeded = True);\n+         pragma Assert (Succeeded = Win32.TRUE);\n       end Set;\n \n    end Specific;\n@@ -192,7 +219,7 @@ package body System.Task_Primitives.Operations is\n    procedure Initialize_Cond (Cond : not null access Condition_Variable) is\n       hEvent : HANDLE;\n    begin\n-      hEvent := CreateEvent (null, True, False, Null_Ptr);\n+      hEvent := CreateEvent (null, Win32.TRUE, Win32.FALSE, Null_Ptr);\n       pragma Assert (hEvent /= 0);\n       Cond.all := Condition_Variable (hEvent);\n    end Initialize_Cond;\n@@ -208,7 +235,7 @@ package body System.Task_Primitives.Operations is\n       Result : BOOL;\n    begin\n       Result := CloseHandle (HANDLE (Cond.all));\n-      pragma Assert (Result = True);\n+      pragma Assert (Result = Win32.TRUE);\n    end Finalize_Cond;\n \n    -----------------\n@@ -219,7 +246,7 @@ package body System.Task_Primitives.Operations is\n       Result : BOOL;\n    begin\n       Result := SetEvent (HANDLE (Cond.all));\n-      pragma Assert (Result = True);\n+      pragma Assert (Result = Win32.TRUE);\n    end Cond_Signal;\n \n    ---------------\n@@ -243,7 +270,7 @@ package body System.Task_Primitives.Operations is\n       --  Must reset Cond BEFORE L is unlocked\n \n       Result_Bool := ResetEvent (HANDLE (Cond.all));\n-      pragma Assert (Result_Bool = True);\n+      pragma Assert (Result_Bool = Win32.TRUE);\n       Unlock (L, Global_Lock => True);\n \n       --  No problem if we are interrupted here: if the condition is signaled,\n@@ -283,7 +310,7 @@ package body System.Task_Primitives.Operations is\n       --  Must reset Cond BEFORE L is unlocked\n \n       Result := ResetEvent (HANDLE (Cond.all));\n-      pragma Assert (Result = True);\n+      pragma Assert (Result = Win32.TRUE);\n       Unlock (L, Global_Lock => True);\n \n       --  No problem if we are interrupted here: if the condition is signaled,\n@@ -316,7 +343,7 @@ package body System.Task_Primitives.Operations is\n \n       if Timed_Out then\n          Result := SetEvent (HANDLE (Cond.all));\n-         pragma Assert (Result = True);\n+         pragma Assert (Result = Win32.TRUE);\n       end if;\n \n       Status := Integer (Wait_Result);\n@@ -384,7 +411,7 @@ package body System.Task_Primitives.Operations is\n    is\n       pragma Unreferenced (Level);\n    begin\n-      InitializeCriticalSection (CRITICAL_SECTION (L.all)'Unrestricted_Access);\n+      InitializeCriticalSection (L);\n    end Initialize_Lock;\n \n    -------------------\n@@ -398,7 +425,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Finalize_Lock (L : not null access RTS_Lock) is\n    begin\n-      DeleteCriticalSection (CRITICAL_SECTION (L.all)'Unrestricted_Access);\n+      DeleteCriticalSection (L);\n    end Finalize_Lock;\n \n    ----------------\n@@ -426,15 +453,14 @@ package body System.Task_Primitives.Operations is\n    is\n    begin\n       if not Single_Lock or else Global_Lock then\n-         EnterCriticalSection (CRITICAL_SECTION (L.all)'Unrestricted_Access);\n+         EnterCriticalSection (L);\n       end if;\n    end Write_Lock;\n \n    procedure Write_Lock (T : Task_Id) is\n    begin\n       if not Single_Lock then\n-         EnterCriticalSection\n-           (CRITICAL_SECTION (T.Common.LL.L)'Unrestricted_Access);\n+         EnterCriticalSection (T.Common.LL.L'Access);\n       end if;\n    end Write_Lock;\n \n@@ -461,15 +487,14 @@ package body System.Task_Primitives.Operations is\n      (L : not null access RTS_Lock; Global_Lock : Boolean := False) is\n    begin\n       if not Single_Lock or else Global_Lock then\n-         LeaveCriticalSection (CRITICAL_SECTION (L.all)'Unrestricted_Access);\n+         LeaveCriticalSection (L);\n       end if;\n    end Unlock;\n \n    procedure Unlock (T : Task_Id) is\n    begin\n       if not Single_Lock then\n-         LeaveCriticalSection\n-           (CRITICAL_SECTION (T.Common.LL.L)'Unrestricted_Access);\n+         LeaveCriticalSection (T.Common.LL.L'Access);\n       end if;\n    end Unlock;\n \n@@ -708,7 +733,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       Res := SetThreadPriority\n         (T.Common.LL.Thread, Interfaces.C.int (Underlying_Priorities (Prio)));\n-      pragma Assert (Res = True);\n+      pragma Assert (Res = Win32.TRUE);\n \n       if Dispatching_Policy = 'F' or else Get_Policy (Prio) = 'F' then\n \n@@ -869,7 +894,7 @@ package body System.Task_Primitives.Operations is\n \n       hTask          : HANDLE;\n       TaskId         : aliased DWORD;\n-      pTaskParameter : System.OS_Interface.PVOID;\n+      pTaskParameter : Win32.PVOID;\n       Result         : DWORD;\n       Entry_Point    : PTHREAD_START_ROUTINE;\n \n@@ -920,7 +945,7 @@ package body System.Task_Primitives.Operations is\n          --  boost. A priority boost is temporarily given by the system to a\n          --  thread when it is taken out of a wait state.\n \n-         SetThreadPriorityBoost (hTask, DisablePriorityBoost => True);\n+         SetThreadPriorityBoost (hTask, DisablePriorityBoost => Win32.TRUE);\n       end if;\n \n       --  Step 4: Handle Task_Info\n@@ -972,7 +997,7 @@ package body System.Task_Primitives.Operations is\n          Result := WaitForSingleObject (T.Common.LL.Thread, Wait_Infinite);\n          pragma Assert (Result /= WAIT_FAILED);\n          Succeeded := CloseHandle (T.Common.LL.Thread);\n-         pragma Assert (Succeeded = True);\n+         pragma Assert (Succeeded = Win32.TRUE);\n       end if;\n \n       Free (Self_ID);\n@@ -1095,7 +1120,7 @@ package body System.Task_Primitives.Operations is\n \n       --  Initialize internal condition variable\n \n-      S.CV := CreateEvent (null, True, False, Null_Ptr);\n+      S.CV := CreateEvent (null, Win32.TRUE, Win32.FALSE, Null_Ptr);\n       pragma Assert (S.CV /= 0);\n    end Initialize;\n \n@@ -1113,7 +1138,7 @@ package body System.Task_Primitives.Operations is\n       --  Destroy internal condition variable\n \n       Result := CloseHandle (S.CV);\n-      pragma Assert (Result = True);\n+      pragma Assert (Result = Win32.TRUE);\n    end Finalize;\n \n    -------------------\n@@ -1166,7 +1191,7 @@ package body System.Task_Primitives.Operations is\n          S.State := False;\n \n          Result := SetEvent (S.CV);\n-         pragma Assert (Result = True);\n+         pragma Assert (Result = Win32.TRUE);\n       else\n          S.State := True;\n       end if;\n@@ -1215,7 +1240,7 @@ package body System.Task_Primitives.Operations is\n             --  Must reset CV BEFORE L is unlocked\n \n             Result_Bool := ResetEvent (S.CV);\n-            pragma Assert (Result_Bool = True);\n+            pragma Assert (Result_Bool = Win32.TRUE);\n \n             LeaveCriticalSection (S.L'Access);\n "}, {"sha": "5b677bf539fa234e6702f7be9a8640d21895acf8", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -73,6 +73,9 @@ package body System.Task_Primitives.Operations is\n    use System.Parameters;\n    use System.OS_Primitives;\n \n+   Use_Alternate_Stack : constant Boolean := Alternate_Stack_Size /= 0;\n+   --  Whether to use an alternate signal stack for stack overflows\n+\n    ----------------\n    -- Local Data --\n    ----------------\n@@ -798,6 +801,19 @@ package body System.Task_Primitives.Operations is\n       end loop;\n \n       Unlock_RTS;\n+\n+      if Use_Alternate_Stack then\n+         declare\n+            Stack  : aliased stack_t;\n+            Result : Interfaces.C.int;\n+         begin\n+            Stack.ss_sp    := Self_ID.Common.Task_Alternate_Stack;\n+            Stack.ss_size  := Alternate_Stack_Size;\n+            Stack.ss_flags := 0;\n+            Result := sigaltstack (Stack'Access, null);\n+            pragma Assert (Result = 0);\n+         end;\n+      end if;\n    end Enter_Task;\n \n    --------------\n@@ -932,7 +948,8 @@ package body System.Task_Primitives.Operations is\n       use System.Task_Info;\n \n    begin\n-      Adjusted_Stack_Size := Interfaces.C.size_t (Stack_Size);\n+      Adjusted_Stack_Size :=\n+         Interfaces.C.size_t (Stack_Size + Alternate_Stack_Size);\n \n       if Stack_Base_Available then\n \n@@ -1415,6 +1432,11 @@ package body System.Task_Primitives.Operations is\n \n       Specific.Initialize (Environment_Task);\n \n+      if Use_Alternate_Stack then\n+         Environment_Task.Common.Task_Alternate_Stack :=\n+           Alternate_Stack'Address;\n+      end if;\n+\n       Enter_Task (Environment_Task);\n \n       --  Install the abort-signal handler"}, {"sha": "85f8dfc6af797ee4168cbc13bfa61de4d947e4be", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -106,6 +106,7 @@ package System.Tasking is\n    type Ada_Task_Control_Block;\n \n    type Task_Id is access all Ada_Task_Control_Block;\n+   for Task_Id'Size use System.Task_Primitives.Task_Address_Size;\n \n    Null_Task : constant Task_Id;\n \n@@ -117,9 +118,11 @@ package System.Tasking is\n    --  from the run-time system.\n \n    function To_Task_Id is\n-     new Ada.Unchecked_Conversion (System.Address, Task_Id);\n+     new Ada.Unchecked_Conversion\n+       (System.Task_Primitives.Task_Address, Task_Id);\n    function To_Address is\n-     new Ada.Unchecked_Conversion (Task_Id, System.Address);\n+     new Ada.Unchecked_Conversion\n+       (Task_Id, System.Task_Primitives.Task_Address);\n \n    -----------------------\n    -- Enumeration types --\n@@ -340,7 +343,7 @@ package System.Tasking is\n    --    Abnormal means that the task terminates because it is being aborted\n \n    --    handled_Exception means that the task terminates because of exception\n-   --    raised by by the execution of its task_body.\n+   --    raised by the execution of its task_body.\n \n    type Termination_Handler is access protected procedure\n      (Cause : Cause_Of_Termination;\n@@ -492,6 +495,11 @@ package System.Tasking is\n       --  Activator writes it, once, before Self starts executing. Thereafter,\n       --  Self only reads it.\n \n+      Task_Alternate_Stack : System.Address;\n+      --  The address of the alternate signal stack for this task, if any\n+      --\n+      --  Protection: Only accessed by Self\n+\n       Task_Entry_Point : Task_Procedure_Access;\n       --  Information needed to call the procedure containing the code for\n       --  the body of this task.\n@@ -801,7 +809,8 @@ package System.Tasking is\n    ------------------------------------\n \n    type Access_Address is access all System.Address;\n-   --  Comment on what this is used for ???\n+   --  Anonymous pointer used to implement task attributes (see s-tataat.adb\n+   --  and a-tasatt.adb)\n \n    pragma No_Strict_Aliasing (Access_Address);\n    --  This type is used in contexts where aliasing may be an issue (see"}, {"sha": "822b1b76ba15e7ced662da6d8497cfd81d2bfdff", "filename": "gcc/ada/s-taspri-hpux-dce.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taspri-hpux-dce.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taspri-hpux-dce.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-hpux-dce.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -64,6 +64,18 @@ package System.Task_Primitives is\n    --  A component of this type is guaranteed to be included in the\n    --  Ada_Task_Control_Block.\n \n+   subtype Task_Address is System.Address;\n+   --  In some versions of Task_Primitives, notably for VMS, Task_Address is\n+   --  the short version of address defined in System.Aux_DEC. To avoid\n+   --  dragging Aux_DEC into tasking packages a tasking specific subtype is\n+   --  defined here.\n+\n+   Task_Address_Size : constant := Standard'Address_Size;\n+   --  The size of Task_Address\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n private\n    type Lock is record\n       L              : aliased System.OS_Interface.pthread_mutex_t;"}, {"sha": "4e08865d8315ad1cb784a3132a4948a2dacc29a5", "filename": "gcc/ada/s-taspri-lynxos.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taspri-lynxos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taspri-lynxos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-lynxos.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -63,6 +63,18 @@ package System.Task_Primitives is\n    --  A component of this type is guaranteed to be included in the\n    --  Ada_Task_Control_Block.\n \n+   subtype Task_Address is System.Address;\n+   --  In some versions of Task_Primitives, notably for VMS, Task_Address is\n+   --  the short version of address defined in System.Aux_DEC. To avoid\n+   --  dragging Aux_DEC into tasking packages a tasking specific subtype is\n+   --  defined here.\n+\n+   Task_Address_Size : constant := Standard'Address_Size;\n+   --  The size of Task_Address\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n private\n \n    type Lock is record"}, {"sha": "2fb8655eb83e908d3d3dac5c7529ae3a74f9c849", "filename": "gcc/ada/s-taspri-posix-noaltstack.ads", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taspri-posix-noaltstack.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taspri-posix-noaltstack.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-posix-noaltstack.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -0,0 +1,124 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                                                                          --\n+--                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--             Copyright (C) 1991-1994, Florida State University            --\n+--                     Copyright (C) 1995-2008, AdaCore                     --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a POSIX-like version of this package where no alternate stack\n+--  is needed for stack checking.\n+\n+--  Note: this file can only be used for POSIX compliant systems\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during tasking\n+--  operations. It causes infinite loops and other problems.\n+\n+with System.OS_Interface;\n+\n+package System.Task_Primitives is\n+   pragma Preelaborate;\n+\n+   type Lock is limited private;\n+   --  Should be used for implementation of protected objects\n+\n+   type RTS_Lock is limited private;\n+   --  Should be used inside the runtime system. The difference between Lock\n+   --  and the RTS_Lock is that the later one serves only as a semaphore so\n+   --  that do not check for ceiling violations.\n+\n+   type Suspension_Object is limited private;\n+   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n+\n+   type Task_Body_Access is access procedure;\n+   --  Pointer to the task body's entry point (or possibly a wrapper declared\n+   --  local to the GNARL).\n+\n+   type Private_Data is limited private;\n+   --  Any information that the GNULLI needs maintained on a per-task basis.\n+   --  A component of this type is guaranteed to be included in the\n+   --  Ada_Task_Control_Block.\n+\n+   subtype Task_Address is System.Address;\n+   --  In some versions of Task_Primitives, notably for VMS, Task_Address is\n+   --  the short version of address defined in System.Aux_DEC. To avoid\n+   --  dragging Aux_DEC into tasking packages a tasking specific subtype is\n+   --  defined here.\n+\n+   Task_Address_Size : constant := Standard'Address_Size;\n+   --  The size of Task_Address\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n+private\n+\n+   type Lock is new System.OS_Interface.pthread_mutex_t;\n+   type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n+\n+   type Suspension_Object is record\n+      State : Boolean;\n+      pragma Atomic (State);\n+      --  Boolean that indicates whether the object is open. This field is\n+      --  marked Atomic to ensure that we can read its value without locking\n+      --  the access to the Suspension_Object.\n+\n+      Waiting : Boolean;\n+      --  Flag showing if there is a task already suspended on this object\n+\n+      L : aliased System.OS_Interface.pthread_mutex_t;\n+      --  Protection for ensuring mutual exclusion on the Suspension_Object\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Condition variable used to queue threads until condition is signaled\n+   end record;\n+\n+   type Private_Data is record\n+      Thread : aliased System.OS_Interface.pthread_t;\n+      pragma Atomic (Thread);\n+      --  Thread field may be updated by two different threads of control.\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the same\n+      --  value (thr_self value). We do not want to use lock on those\n+      --  operations and the only thing we have to make sure is that they are\n+      --  updated in atomic fashion.\n+\n+      LWP : aliased System.Address;\n+      --  The purpose of this field is to provide a better tasking support on\n+      --  gdb. The order of the two first fields (Thread and LWP) is important.\n+      --  On targets where lwp is not relevant, this is equivalent to Thread.\n+\n+      CV : aliased System.OS_Interface.pthread_cond_t;\n+      --  Should be commented ??? (in all versions of taspri)\n+\n+      L : aliased RTS_Lock;\n+      --  Protection for all components is lock L\n+   end record;\n+\n+end System.Task_Primitives;"}, {"sha": "0bf5139ef1540faaf11a9a13cecf26fed1560eb3", "filename": "gcc/ada/s-taspri-solaris.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taspri-solaris.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taspri-solaris.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-solaris.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -71,6 +71,18 @@ package System.Task_Primitives is\n    --  A component of this type is guaranteed to be included in the\n    --  Ada_Task_Control_Block.\n \n+   subtype Task_Address is System.Address;\n+   --  In some versions of Task_Primitives, notably for VMS, Task_Address is\n+   --  the short version of address defined in System.Aux_DEC. To avoid\n+   --  dragging Aux_DEC into tasking packages a tasking specific subtype is\n+   --  defined here.\n+\n+   Task_Address_Size : constant := Standard'Address_Size;\n+   --  The size of Task_Address\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n private\n \n    type Private_Task_Serial_Number is mod 2 ** 64;"}, {"sha": "50760c5d6514aba53343ac2f14226dfa1e1d55c6", "filename": "gcc/ada/s-taspri-tru64.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taspri-tru64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-taspri-tru64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-tru64.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -65,6 +65,18 @@ package System.Task_Primitives is\n    --  Any information that the GNULLI needs maintained on a per-task basis.\n    --  A component of this type is guaranteed to be included\n \n+   subtype Task_Address is System.Address;\n+   --  In some versions of Task_Primitives, notably for VMS, Task_Address is\n+   --  the short version of address defined in System.Aux_DEC. To avoid\n+   --  dragging Aux_DEC into tasking packages a tasking specific subtype is\n+   --  defined here.\n+\n+   Task_Address_Size : constant := Standard'Address_Size;\n+   --  The size of Task_Address\n+\n+   Alternate_Stack_Size : constant := 0;\n+   --  No alternate signal stack is used on this platform\n+\n private\n \n    type Lock is record"}, {"sha": "f0af3e06c3afdd34509421f8e3fd21bf669dc947", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -40,6 +40,7 @@ with Ada.Unchecked_Deallocation;\n \n with System.Tasking.Debug;\n with System.Address_Image;\n+with System.Task_Primitives;\n with System.Task_Primitives.Operations;\n with System.Tasking.Utilities;\n with System.Tasking.Queuing;\n@@ -135,9 +136,6 @@ package body System.Tasking.Stages is\n    --  For tasks created by an allocator that fails, due to an exception, it is\n    --  called from Expunge_Unactivated_Tasks.\n    --\n-   --  It is also called from Ada.Unchecked_Deallocation, for objects that are\n-   --  or contain tasks.\n-   --\n    --  Different code is used at master completion, in Terminate_Dependents,\n    --  due to a need for tighter synchronization with the master.\n \n@@ -408,8 +406,7 @@ package body System.Tasking.Stages is\n \n       Initialization.Undefer_Abort_Nestable (Self_ID);\n \n-      --  ???\n-      --  Why do we need to allow for nested deferral here?\n+      --  ??? Why do we need to allow for nested deferral here?\n \n       if Runtime_Traces then\n          Send_Trace_Info (T_Activate);\n@@ -457,24 +454,29 @@ package body System.Tasking.Stages is\n    --  called to create a new task.\n \n    procedure Create_Task\n-     (Priority      : Integer;\n-      Size          : System.Parameters.Size_Type;\n-      Task_Info     : System.Task_Info.Task_Info_Type;\n-      Num_Entries   : Task_Entry_Index;\n-      Master        : Master_Level;\n-      State         : Task_Procedure_Access;\n-      Discriminants : System.Address;\n-      Elaborated    : Access_Boolean;\n-      Chain         : in out Activation_Chain;\n-      Task_Image    : String;\n-      Created_Task  : out Task_Id)\n+     (Priority          : Integer;\n+      Size              : System.Parameters.Size_Type;\n+      Task_Info         : System.Task_Info.Task_Info_Type;\n+      Relative_Deadline : Ada.Real_Time.Time_Span;\n+      Num_Entries       : Task_Entry_Index;\n+      Master            : Master_Level;\n+      State             : Task_Procedure_Access;\n+      Discriminants     : System.Address;\n+      Elaborated        : Access_Boolean;\n+      Chain             : in out Activation_Chain;\n+      Task_Image        : String;\n+      Created_Task      : out Task_Id)\n    is\n       T, P          : Task_Id;\n       Self_ID       : constant Task_Id := STPO.Self;\n       Success       : Boolean;\n       Base_Priority : System.Any_Priority;\n       Len           : Natural;\n \n+      pragma Unreferenced (Relative_Deadline);\n+      --  EDF scheduling is not supported by any of the target platforms so\n+      --  this parameter is not passed any further.\n+\n    begin\n       --  If Master is greater than the current master, it means that Master\n       --  has already awaited its dependent tasks. This raises Program_Error,\n@@ -749,7 +751,7 @@ package body System.Tasking.Stages is\n          Unlock_RTS;\n       end if;\n \n-      --  We need to explicitely wait for the task to be terminated here\n+      --  We need to explicitly wait for the task to be terminated here\n       --  because on true concurrent system, we may end this procedure before\n       --  the tasks are really terminated.\n \n@@ -829,6 +831,7 @@ package body System.Tasking.Stages is\n          Initialization.Task_Lock (Self_Id);\n \n          Lock_RTS;\n+         Initialization.Finalize_Attributes_Link.all (T);\n          Initialization.Remove_From_All_Tasks_List (T);\n          Unlock_RTS;\n \n@@ -896,12 +899,12 @@ package body System.Tasking.Stages is\n    -- Task_Wrapper --\n    ------------------\n \n-   --  The task wrapper is a procedure that is called first for each task\n-   --  task body, and which in turn calls the compiler-generated task body\n-   --  procedure. The wrapper's main job is to do initialization for the task.\n-   --  It also has some locally declared objects that server as per-task local\n-   --  data. Task finalization is done by Complete_Task, which is called from\n-   --  an at-end handler that the compiler generates.\n+   --  The task wrapper is a procedure that is called first for each task body\n+   --  and which in turn calls the compiler-generated task body procedure.\n+   --  The wrapper's main job is to do initialization for the task. It also\n+   --  has some locally declared objects that serve as per-task local data.\n+   --  Task finalization is done by Complete_Task, which is called from an\n+   --  at-end handler that the compiler generates.\n \n    procedure Task_Wrapper (Self_ID : Task_Id) is\n       use type SSE.Storage_Offset;\n@@ -910,6 +913,13 @@ package body System.Tasking.Stages is\n \n       Bottom_Of_Stack : aliased Integer;\n \n+      Task_Alternate_Stack :\n+        aliased SSE.Storage_Array (1 .. Alternate_Stack_Size);\n+      --  The alternate signal stack for this task, if any\n+\n+      Use_Alternate_Stack : constant Boolean := Alternate_Stack_Size /= 0;\n+      --  Whether to use above alternate signal stack for stack overflows\n+\n       Secondary_Stack_Size :\n         constant SSE.Storage_Offset :=\n           Self_ID.Common.Compiler_Data.Pri_Stack_Info.Size *\n@@ -921,6 +931,9 @@ package body System.Tasking.Stages is\n       --  Why are warnings being turned off here???\n \n       Secondary_Stack_Address : System.Address := Secondary_Stack'Address;\n+      --  Address of secondary stack. In the fixed secondary stack case, this\n+      --  value is not modified, causing a warning, hence the bracketing with\n+      --  Warnings (Off/On). But why is so much *more* bracketed???\n \n       Small_Overflow_Guard : constant := 12 * 1024;\n       --  Note: this used to be 4K, but was changed to 12K, since smaller\n@@ -939,9 +952,6 @@ package body System.Tasking.Stages is\n       --  Size of the overflow guard, used by dynamic stack usage analysis\n \n       pragma Warnings (On);\n-      --  Address of secondary stack. In the fixed secondary stack case, this\n-      --  value is not modified, causing a warning, hence the bracketing with\n-      --  Warnings (Off/On). But why is so much *more* bracketed ???\n \n       SEH_Table : aliased SSE.Storage_Array (1 .. 8);\n       --  Structured Exception Registration table (2 words)\n@@ -1017,6 +1027,10 @@ package body System.Tasking.Stages is\n          Size := Size - Natural (Secondary_Stack_Size);\n       end if;\n \n+      if Use_Alternate_Stack then\n+         Self_ID.Common.Task_Alternate_Stack := Task_Alternate_Stack'Address;\n+      end if;\n+\n       if System.Stack_Usage.Is_Enabled then\n          STPO.Lock_RTS;\n          Initialize_Analyzer (Self_ID.Common.Analyzer,\n@@ -1309,7 +1323,8 @@ package body System.Tasking.Stages is\n       use System.Standard_Library;\n \n       function To_Address is new\n-        Ada.Unchecked_Conversion (Task_Id, System.Address);\n+        Ada.Unchecked_Conversion\n+         (Task_Id, System.Task_Primitives.Task_Address);\n \n       function Tailored_Exception_Information\n         (E : Exception_Occurrence) return String;"}, {"sha": "e535a53be540a15155c71f2bd8e005dbcd816ee3", "filename": "gcc/ada/s-tassta.ads", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-tassta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fs-tassta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -44,6 +44,8 @@\n with System.Task_Info;\n with System.Parameters;\n \n+with Ada.Real_Time;\n+\n package System.Tasking.Stages is\n    pragma Elaborate_Body;\n \n@@ -81,8 +83,8 @@ package System.Tasking.Stages is\n    --         _init.discr := discr;\n    --         _init._task_id := null;\n    --         create_task (unspecified_priority, tZ,\n-   --           unspecified_task_info, 0, _master,\n-   --           task_procedure_access!(tB'address),\n+   --           unspecified_task_info, ada__real_time__time_span_zero, 0,\n+   --           _master, task_procedure_access!(tB'address),\n    --           _init'address, tE'unchecked_access, _chain, _task_id, _init.\n    --           _task_id);\n    --         return;\n@@ -167,17 +169,18 @@ package System.Tasking.Stages is\n    --  now in order to wake up the activator (the environment task).\n \n    procedure Create_Task\n-     (Priority      : Integer;\n-      Size          : System.Parameters.Size_Type;\n-      Task_Info     : System.Task_Info.Task_Info_Type;\n-      Num_Entries   : Task_Entry_Index;\n-      Master        : Master_Level;\n-      State         : Task_Procedure_Access;\n-      Discriminants : System.Address;\n-      Elaborated    : Access_Boolean;\n-      Chain         : in out Activation_Chain;\n-      Task_Image    : String;\n-      Created_Task  : out Task_Id);\n+     (Priority          : Integer;\n+      Size              : System.Parameters.Size_Type;\n+      Task_Info         : System.Task_Info.Task_Info_Type;\n+      Relative_Deadline : Ada.Real_Time.Time_Span;\n+      Num_Entries       : Task_Entry_Index;\n+      Master            : Master_Level;\n+      State             : Task_Procedure_Access;\n+      Discriminants     : System.Address;\n+      Elaborated        : Access_Boolean;\n+      Chain             : in out Activation_Chain;\n+      Task_Image        : String;\n+      Created_Task      : out Task_Id);\n    --  Compiler interface only. Do not call from within the RTS.\n    --  This must be called to create a new task.\n    --\n@@ -186,6 +189,8 @@ package System.Tasking.Stages is\n    --  Size is the stack size of the task to create\n    --  Task_Info is the task info associated with the created task, or\n    --   Unspecified_Task_Info if none.\n+   --  Relative_Deadline is the relative deadline associated with the created\n+   --  task by means of a pragma Relative_Deadline, or 0.0 if none.\n    --  State is the compiler generated task's procedure body\n    --  Discriminants is a pointer to a limited record whose discriminants\n    --   are those of the task to create. This parameter should be passed as"}, {"sha": "f46da46fdaf6e170bbc1234287cb9c74e74a33a3", "filename": "gcc/ada/system-linux-x86.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fsystem-linux-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fsystem-linux-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-linux-x86.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                         (GNU-Linux/x86 Version)                          --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -139,7 +139,7 @@ private\n    Preallocated_Stacks       : constant Boolean := False;\n    Signed_Zeros              : constant Boolean := True;\n    Stack_Check_Default       : constant Boolean := False;\n-   Stack_Check_Probes        : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := True;\n    Stack_Check_Limits        : constant Boolean := False;\n    Support_64_Bit_Divides    : constant Boolean := True;\n    Support_Aggregates        : constant Boolean := True;"}, {"sha": "7ee4180334053e3423c0b6c226f82f85e493f4bc", "filename": "gcc/ada/system-linux-x86_64.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fsystem-linux-x86_64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770db697e62902a236c8cb4cf0e8b6cc52051703/gcc%2Fada%2Fsystem-linux-x86_64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-linux-x86_64.ads?ref=770db697e62902a236c8cb4cf0e8b6cc52051703", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                       (GNU-Linux/x86-64 Version)                         --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -139,7 +139,7 @@ private\n    Preallocated_Stacks       : constant Boolean := False;\n    Signed_Zeros              : constant Boolean := True;\n    Stack_Check_Default       : constant Boolean := False;\n-   Stack_Check_Probes        : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := True;\n    Stack_Check_Limits        : constant Boolean := False;\n    Support_64_Bit_Divides    : constant Boolean := True;\n    Support_Aggregates        : constant Boolean := True;"}]}