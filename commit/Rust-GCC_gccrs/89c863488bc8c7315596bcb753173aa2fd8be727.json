{"sha": "89c863488bc8c7315596bcb753173aa2fd8be727", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODljODYzNDg4YmM4YzczMTU1OTZiY2I3NTMxNzNhYTJmZDhiZTcyNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-04-14T21:27:19Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-04-16T05:16:03Z"}, "message": "c++: C++20 class NTTP trailing zero-init [PR100079]\n\nThe new testcase was breaking because constexpr evaluation was simplifying\nBar{Baz<42>{}} to Bar{empty}, but then we weren't treating them as\nequivalent.  Poking at this revealed that the code for eliding trailing\nzero-initialization in class non-type template argument mangling was pretty\nbroken, including the test, mangle71.\n\nI dealt with the FIXME to support RANGE_EXPR, and fixed the confusion\nbetween a list-initialized temporary mangled as written (i.e. in the\nsignature of a function template) and a template parameter object mangled as\nthe value representation of the object.  I'm distinguishing between these\nusing COMPOUND_LITERAL_P.  A later patch will adjust the use of\nCOMPOUND_LITERAL_P to be more useful for this distinction, but it works now\nfor distinguishing these cases in mangling.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/100079\n\t* cp-tree.h (first_field): Declare.\n\t* mangle.c (range_expr_nelts): New.\n\t(write_expression): Improve class NTTP mangling.\n\t* pt.c (get_template_parm_object): Clear TREE_HAS_CONSTRUCTOR.\n\t* tree.c (zero_init_expr_p): Improve class NTTP handling.\n\t* decl.c: Adjust comment.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/100079\n\t* g++.dg/abi/mangle71.C: Fix expected mangling.\n\t* g++.dg/abi/mangle77.C: New test.\n\t* g++.dg/cpp2a/nontype-class-union1.C: Likewise.\n\t* g++.dg/cpp2a/nontype-class-equiv1.C: Removed.\n\t* g++.dg/cpp2a/nontype-class44.C: New test.", "tree": {"sha": "23f643de494414e8cbb18cf5d22fc3007daac151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23f643de494414e8cbb18cf5d22fc3007daac151"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89c863488bc8c7315596bcb753173aa2fd8be727", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c863488bc8c7315596bcb753173aa2fd8be727", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89c863488bc8c7315596bcb753173aa2fd8be727", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89c863488bc8c7315596bcb753173aa2fd8be727/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee351f7fdbd82f8947fe9a0e74cea65d216a8549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee351f7fdbd82f8947fe9a0e74cea65d216a8549", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee351f7fdbd82f8947fe9a0e74cea65d216a8549"}], "stats": {"total": 169, "additions": 117, "deletions": 52}, "files": [{"sha": "23a77a2b2e0722c2e2f5b96a6f3ad9587b011c84", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=89c863488bc8c7315596bcb753173aa2fd8be727", "patch": "@@ -6695,6 +6695,7 @@ extern void initialize_artificial_var\t\t(tree, vec<constructor_elt, va_gc> *);\n extern tree check_var_type\t\t\t(tree, tree, location_t);\n extern tree reshape_init                        (tree, tree, tsubst_flags_t);\n extern tree next_initializable_field (tree);\n+extern tree first_field\t\t\t\t(const_tree);\n extern tree fndecl_declared_return_type\t\t(tree);\n extern bool undeduced_auto_decl\t\t\t(tree);\n extern bool require_deduced_type\t\t(tree, tsubst_flags_t = tf_warning_or_error);"}, {"sha": "d40b7a7da5f3bacf514476f09bc36cba4ad85d2a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=89c863488bc8c7315596bcb753173aa2fd8be727", "patch": "@@ -6152,7 +6152,7 @@ struct reshape_iter\n \n static tree reshape_init_r (tree, reshape_iter *, tree, tsubst_flags_t);\n \n-/* FIELD is a FIELD_DECL or NULL.  In the former case, the value\n+/* FIELD is an element of TYPE_FIELDS or NULL.  In the former case, the value\n    returned is the next FIELD_DECL (possibly FIELD itself) that can be\n    initialized.  If there are no more such fields, the return value\n    will be NULL.  */"}, {"sha": "49f1266bef366f6f4f771d1180e07c152fc8462d", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=89c863488bc8c7315596bcb753173aa2fd8be727", "patch": "@@ -2940,6 +2940,16 @@ write_base_ref (tree expr, tree base = NULL_TREE)\n   return true;\n }\n \n+/* The number of elements spanned by a RANGE_EXPR.  */\n+\n+unsigned HOST_WIDE_INT\n+range_expr_nelts (tree expr)\n+{\n+  tree lo = TREE_OPERAND (expr, 0);\n+  tree hi = TREE_OPERAND (expr, 1);\n+  return tree_to_uhwi (hi) - tree_to_uhwi (lo) + 1;\n+}\n+\n /* <expression> ::= <unary operator-name> <expression>\n \t\t::= <binary operator-name> <expression> <expression>\n \t\t::= <expr-primary>\n@@ -3284,8 +3294,14 @@ write_expression (tree expr)\n \t  write_type (etype);\n \t}\n \n-      bool nontriv = !trivial_type_p (etype);\n-      if (nontriv || !zero_init_expr_p (expr))\n+      /* If this is an undigested initializer, mangle it as written.\n+\t COMPOUND_LITERAL_P doesn't actually distinguish between digested and\n+\t undigested braced casts, but it should work to use it to distinguish\n+\t between braced casts in a template signature (undigested) and template\n+\t parm object values (digested), and all CONSTRUCTORS that get here\n+\t should be one of those two cases.  */\n+      bool undigested = braced_init || COMPOUND_LITERAL_P (expr);\n+      if (undigested || !zero_init_expr_p (expr))\n \t{\n \t  /* Convert braced initializer lists to STRING_CSTs so that\n \t     A<\"Foo\"> mangles the same as A<{'F', 'o', 'o', 0}> while\n@@ -3296,28 +3312,32 @@ write_expression (tree expr)\n \t  if (TREE_CODE (expr) == CONSTRUCTOR)\n \t    {\n \t      vec<constructor_elt, va_gc> *elts = CONSTRUCTOR_ELTS (expr);\n-\t      unsigned last_nonzero = UINT_MAX, i;\n+\t      unsigned last_nonzero = UINT_MAX;\n \t      constructor_elt *ce;\n-\t      tree val;\n \n-\t      if (!nontriv)\n-\t\tFOR_EACH_CONSTRUCTOR_VALUE (elts, i, val)\n-\t\t  if (!zero_init_expr_p (val))\n+\t      if (!undigested)\n+\t\tfor (HOST_WIDE_INT i = 0; vec_safe_iterate (elts, i, &ce); ++i)\n+\t\t  if ((TREE_CODE (etype) == UNION_TYPE\n+\t\t       && ce->index != first_field (etype))\n+\t\t      || !zero_init_expr_p (ce->value))\n \t\t    last_nonzero = i;\n \n-\t      if (nontriv || last_nonzero != UINT_MAX)\n+\t      if (undigested || last_nonzero != UINT_MAX)\n \t\tfor (HOST_WIDE_INT i = 0; vec_safe_iterate (elts, i, &ce); ++i)\n \t\t  {\n \t\t    if (i > last_nonzero)\n \t\t      break;\n-\t\t    /* FIXME handle RANGE_EXPR */\n \t\t    if (TREE_CODE (etype) == UNION_TYPE)\n \t\t      {\n \t\t\t/* Express the active member as a designator.  */\n \t\t\twrite_string (\"di\");\n \t\t\twrite_unqualified_name (ce->index);\n \t\t      }\n-\t\t    write_expression (ce->value);\n+\t\t    unsigned reps = 1;\n+\t\t    if (ce->index && TREE_CODE (ce->index) == RANGE_EXPR)\n+\t\t      reps = range_expr_nelts (ce->index);\n+\t\t    for (unsigned j = 0; j < reps; ++j)\n+\t\t      write_expression (ce->value);\n \t\t  }\n \t    }\n \t  else"}, {"sha": "a0ca65cfa0de45127b289f436b4e72d7951af2f1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=89c863488bc8c7315596bcb753173aa2fd8be727", "patch": "@@ -7150,6 +7150,9 @@ get_template_parm_object (tree expr, tsubst_flags_t complain)\n   if (invalid_tparm_referent_p (TREE_TYPE (expr), expr, complain))\n     return error_mark_node;\n \n+  /* This is no longer a compound literal.  */\n+  TREE_HAS_CONSTRUCTOR (expr) = 0;\n+\n   tree name = mangle_template_parm_object (expr);\n   tree decl = get_global_binding (name);\n   if (decl)"}, {"sha": "a8bfd5fc05319ae2c8cb65d5445b359d0f0df90d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=89c863488bc8c7315596bcb753173aa2fd8be727", "patch": "@@ -4680,20 +4680,30 @@ zero_init_expr_p (tree t)\n   tree type = TREE_TYPE (t);\n   if (!type || uses_template_parms (type))\n     return false;\n-  if (zero_init_p (type))\n-    return initializer_zerop (t);\n   if (TYPE_PTRMEM_P (type))\n     return null_member_pointer_value_p (t);\n-  if (TREE_CODE (t) == CONSTRUCTOR\n-      && CP_AGGREGATE_TYPE_P (type))\n+  if (TREE_CODE (t) == CONSTRUCTOR)\n     {\n-      tree elt_init;\n-      unsigned HOST_WIDE_INT i;\n-      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (t), i, elt_init)\n-\tif (!zero_init_expr_p (elt_init))\n-\t  return false;\n+      if (CONSTRUCTOR_IS_DEPENDENT (t)\n+\t  || BRACE_ENCLOSED_INITIALIZER_P (t))\n+\t/* Undigested, conversions might change the zeroness.\n+\n+\t   Other COMPOUND_LITERAL_P in template context are also undigested,\n+\t   but there isn't currently a way to distinguish between them and\n+\t   COMPOUND_LITERAL_P from non-template context that are digested.  */\n+\treturn false;\n+      for (constructor_elt &elt : CONSTRUCTOR_ELTS (t))\n+\t{\n+\t  if (TREE_CODE (type) == UNION_TYPE\n+\t      && elt.index != first_field (type))\n+\t    return false;\n+\t  if (!zero_init_expr_p (elt.value))\n+\t    return false;\n+\t}\n       return true;\n     }\n+  if (zero_init_p (type))\n+    return initializer_zerop (t);\n   return false;\n }\n "}, {"sha": "038befa8f7dbca24e9f5e77de998b95d2b01e985", "filename": "gcc/testsuite/g++.dg/abi/mangle71.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle71.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle71.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle71.C?ref=89c863488bc8c7315596bcb753173aa2fd8be727", "patch": "@@ -1,4 +1,4 @@\n-// Verify manglinng of class literals of types with ctors.\n+// Verify mangling of class literals of types with ctors.\n // { dg-do compile { target c++2a } }\n \n struct A\n@@ -13,16 +13,16 @@ struct B { A a[3]; };\n template <B> struct X { };\n \n void f___ (X<B{{ }}>) { }\n-// { dg-final { scan-assembler \"_Z4f___1XIXtl1BtlA3_1AtlS1_Lc1EEEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4f0001XIXtl1BEEE\" } }\n \n void f0__ (X<B{{ 0 }}>) { }\n-// { dg-final { scan-assembler \"_Z4f0__1XIXtl1BtlA3_1AtlS1_Lc0EEtlS1_Lc1EEEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4f0__1XIXtl1BtlA3_1AtlS1_EtlS1_Lc1EEtlS1_Lc1EEEEEE\" } }\n \n void f00_ (X<B{{ 0, 0 }}>) { }\n-// { dg-final { scan-assembler \"_Z4f00_1XIXtl1BtlA3_1AtlS1_Lc0EEtlS1_Lc0EEtlS1_Lc1EEEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4f00_1XIXtl1BtlA3_1AtlS1_EtlS1_EtlS1_Lc1EEEEEE\" } }\n \n void f000 (X<B{{ 0, 0, 0 }}>) { }\n-// { dg-final { scan-assembler \"_Z4f0001XIXtl1BtlA3_1AtlS1_Lc0EEtlS1_Lc0EEtlS1_Lc0EEEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4f0001XIXtl1BEEE\" } }\n \n void f1__ (X<B{{ 1 }}>) { }\n-// { dg-final { scan-assembler \"_Z4f1__1XIXtl1BtlA3_1AtlS1_Lc1EEtlS1_Lc1EEEEEE\" } }\n+// { dg-final { scan-assembler \"_Z4f1__1XIXtl1BtlA3_1AtlS1_Lc1EEtlS1_Lc1EEtlS1_Lc1EEEEEE\" } }"}, {"sha": "1181dc82f565e8e3e1cb4bf1470c1c06f1b8cebd", "filename": "gcc/testsuite/g++.dg/abi/mangle77.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle77.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle77.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle77.C?ref=89c863488bc8c7315596bcb753173aa2fd8be727", "patch": "@@ -0,0 +1,31 @@\n+// Test that we handle T{} differently between class non-type template\n+// arguments and other expressions in the signature.\n+\n+// { dg-do compile { target c++20 } }\n+\n+struct B\n+{\n+  int i;\n+  constexpr B(int i): i(i+1) {}\n+};\n+\n+struct A\n+{\n+  B b;\n+};\n+\n+template <class T, class... Ts> T sink(T&&, Ts&&...);\n+\n+// Here A{1} is mangled as A{1}, the source representation, because expressions\n+// involving template parameters are compared by ODR (token-based) equivalence\n+// [temp.over.link].\n+// { dg-final { scan-assembler \"_Z1fIiEDTcl4sinktl1ALi1EEcvT__EEES1_\" } }\n+template <class T>\n+decltype(sink(A{1},T())) f(T) { return A{1}; }\n+int main() { f(42); }\n+\n+template <auto> struct C { };\n+// Here A{1} is mangled as A{B{2}}, the value representation, because template\n+// arguments are compared by value.\n+// { dg-final { scan-assembler \"_Z1g1CIXtl1Atl1BLi2EEEEE\" } }\n+void g(C<A{1}>) { }"}, {"sha": "038d46fdac877dbbbba8bf471c730a505222b389", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class-equiv1.C", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee351f7fdbd82f8947fe9a0e74cea65d216a8549/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class-equiv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee351f7fdbd82f8947fe9a0e74cea65d216a8549/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class-equiv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class-equiv1.C?ref=ee351f7fdbd82f8947fe9a0e74cea65d216a8549", "patch": "@@ -1,25 +0,0 @@\n-// { dg-do compile { target c++20 } }\n-\n-template <auto N> struct A {};\n-template <class,class> struct assert_same;\n-template <class T> struct assert_same<T,T> {};\n-\n-#define TEQ(X,Y) static_assert(__is_same(A<(X)>,A<(Y)>))\n-#define TNEQ(X,Y) static_assert(!__is_same(A<(X)>,A<(Y)>))\n-\n-union U {\n-  int i; int j;\n-  constexpr U(int i): i(i) {}\n-  constexpr U(unsigned u): j(u) {}\n-};\n-\n-TEQ(U(0),U(0));\n-\n-// Calling the other constructor initializes a different member with the same\n-// value.  We need to distinguish these.\n-TNEQ(U(0),U(0u));\n-\n-// { dg-final { scan-assembler \"_Z1f1AIXtl1Udi1iLi0EEEE\" } }\n-void f(A<U(0)>) { }\n-// { dg-final { scan-assembler \"_Z1g1AIXtl1Udi1jLi0EEEE\" } }\n-void g(A<U(0u)>) { }"}, {"sha": "df913256a790e66fc53c8bd1829ff6509d1c11ae", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class-union1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class-union1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class-union1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class-union1.C?ref=89c863488bc8c7315596bcb753173aa2fd8be727", "patch": "@@ -19,7 +19,7 @@ TEQ(U(0),U(0));\n // value.  We need to distinguish these.\n TNEQ(U(0),U(0u));\n \n-// { dg-final { scan-assembler \"_Z1f1AIXtl1Udi1iLi0EEEE\" } }\n+// { dg-final { scan-assembler \"_Z1f1AIXtl1UEEE\" } }\n void f(A<U(0)>) { }\n // { dg-final { scan-assembler \"_Z1g1AIXtl1Udi1jLi0EEEE\" } }\n void g(A<U(0u)>) { }"}, {"sha": "0316f79d212b354331e9ab87fed7ee12789b75d7", "filename": "gcc/testsuite/g++.dg/cpp2a/nontype-class44.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class44.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89c863488bc8c7315596bcb753173aa2fd8be727/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class44.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fnontype-class44.C?ref=89c863488bc8c7315596bcb753173aa2fd8be727", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/100079\n+// { dg-do compile { target c++20 } }\n+\n+template <auto value>\n+struct Foo {\n+    using SomeTypeAlias = int;\n+\n+    Foo() {}\n+};\n+\n+template <class T>\n+struct Bar {\n+    T value;\n+\n+    constexpr Bar(const T& value)\n+        : value{value}\n+    {}\n+};\n+\n+template <int N>\n+struct Baz {};\n+\n+constexpr auto baz = Baz<42>{};\n+\n+const Foo<Bar<Baz<42>>{baz}> test{};"}]}