{"sha": "9cbd2d979c5e7095530a6fc290615847d31b549d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNiZDJkOTc5YzVlNzA5NTUzMGE2ZmMyOTA2MTU4NDdkMzFiNTQ5ZA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-31T09:03:27Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-31T09:03:27Z"}, "message": "* tree-vect-loop-manip.c (create_intersect_range_checks_index)\n\t(create_intersect_range_checks): Move from ...\n\t* tree-data-ref.c (create_intersect_range_checks_index)\n\t(create_intersect_range_checks): ... to here.\n\t(create_runtime_alias_checks): New function factored from ...\n\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks): ...\n\there.  Call above function.\n\t* tree-data-ref.h (create_runtime_alias_checks): New function.\n\nFrom-SVN: r248726", "tree": {"sha": "aed776864467f3e672fded8bcc2d363b45ef4866", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aed776864467f3e672fded8bcc2d363b45ef4866"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cbd2d979c5e7095530a6fc290615847d31b549d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cbd2d979c5e7095530a6fc290615847d31b549d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cbd2d979c5e7095530a6fc290615847d31b549d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cbd2d979c5e7095530a6fc290615847d31b549d/comments", "author": null, "committer": null, "parents": [{"sha": "c7d7e2227f72d54ce3ec725693a0fac35455c555", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7d7e2227f72d54ce3ec725693a0fac35455c555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7d7e2227f72d54ce3ec725693a0fac35455c555"}], "stats": {"total": 454, "additions": 240, "deletions": 214}, "files": [{"sha": "4901b38c264571d8cd09c601324f6029b7cbf3ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cbd2d979c5e7095530a6fc290615847d31b549d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cbd2d979c5e7095530a6fc290615847d31b549d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cbd2d979c5e7095530a6fc290615847d31b549d", "patch": "@@ -1,3 +1,14 @@\n+2017-05-31  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vect-loop-manip.c (create_intersect_range_checks_index)\n+\t(create_intersect_range_checks): Move from ...\n+\t* tree-data-ref.c (create_intersect_range_checks_index)\n+\t(create_intersect_range_checks): ... to here.\n+\t(create_runtime_alias_checks): New function factored from ...\n+\t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks): ...\n+\there.  Call above function.\n+\t* tree-data-ref.h (create_runtime_alias_checks): New function.\n+\n 2017-05-31  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-data-ref.c (prune_runtime_alias_test_list): Relax minimal"}, {"sha": "d16bc361d09bc65cd1b1af835d6077a587492ca3", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cbd2d979c5e7095530a6fc290615847d31b549d/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cbd2d979c5e7095530a6fc290615847d31b549d/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=9cbd2d979c5e7095530a6fc290615847d31b549d", "patch": "@@ -1470,6 +1470,231 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n     }\n }\n \n+/* Given LOOP's two data references and segment lengths described by DR_A\n+   and DR_B, create expression checking if the two addresses ranges intersect\n+   with each other based on index of the two addresses.  This can only be\n+   done if DR_A and DR_B referring to the same (array) object and the index\n+   is the only difference.  For example:\n+\n+                       DR_A                           DR_B\n+      data-ref         arr[i]                         arr[j]\n+      base_object      arr                            arr\n+      index            {i_0, +, 1}_loop               {j_0, +, 1}_loop\n+\n+   The addresses and their index are like:\n+\n+        |<- ADDR_A    ->|          |<- ADDR_B    ->|\n+     ------------------------------------------------------->\n+        |   |   |   |   |          |   |   |   |   |\n+     ------------------------------------------------------->\n+        i_0 ...         i_0+4      j_0 ...         j_0+4\n+\n+   We can create expression based on index rather than address:\n+\n+     (i_0 + 4 < j_0 || j_0 + 4 < i_0)\n+\n+   Note evolution step of index needs to be considered in comparison.  */\n+\n+static bool\n+create_intersect_range_checks_index (struct loop *loop, tree *cond_expr,\n+\t\t\t\t     const dr_with_seg_len& dr_a,\n+\t\t\t\t     const dr_with_seg_len& dr_b)\n+{\n+  if (integer_zerop (DR_STEP (dr_a.dr))\n+      || integer_zerop (DR_STEP (dr_b.dr))\n+      || DR_NUM_DIMENSIONS (dr_a.dr) != DR_NUM_DIMENSIONS (dr_b.dr))\n+    return false;\n+\n+  if (!tree_fits_uhwi_p (dr_a.seg_len) || !tree_fits_uhwi_p (dr_b.seg_len))\n+    return false;\n+\n+  if (!tree_fits_shwi_p (DR_STEP (dr_a.dr)))\n+    return false;\n+\n+  if (!operand_equal_p (DR_BASE_OBJECT (dr_a.dr), DR_BASE_OBJECT (dr_b.dr), 0))\n+    return false;\n+\n+  if (!operand_equal_p (DR_STEP (dr_a.dr), DR_STEP (dr_b.dr), 0))\n+    return false;\n+\n+  gcc_assert (TREE_CODE (DR_STEP (dr_a.dr)) == INTEGER_CST);\n+\n+  bool neg_step = tree_int_cst_compare (DR_STEP (dr_a.dr), size_zero_node) < 0;\n+  unsigned HOST_WIDE_INT abs_step\n+    = absu_hwi (tree_to_shwi (DR_STEP (dr_a.dr)));\n+\n+  unsigned HOST_WIDE_INT seg_len1 = tree_to_uhwi (dr_a.seg_len);\n+  unsigned HOST_WIDE_INT seg_len2 = tree_to_uhwi (dr_b.seg_len);\n+  /* Infer the number of iterations with which the memory segment is accessed\n+     by DR.  In other words, alias is checked if memory segment accessed by\n+     DR_A in some iterations intersect with memory segment accessed by DR_B\n+     in the same amount iterations.\n+     Note segnment length is a linear function of number of iterations with\n+     DR_STEP as the coefficient.  */\n+  unsigned HOST_WIDE_INT niter_len1 = (seg_len1 + abs_step - 1) / abs_step;\n+  unsigned HOST_WIDE_INT niter_len2 = (seg_len2 + abs_step - 1) / abs_step;\n+\n+  unsigned int i;\n+  for (i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)\n+    {\n+      tree access1 = DR_ACCESS_FN (dr_a.dr, i);\n+      tree access2 = DR_ACCESS_FN (dr_b.dr, i);\n+      /* Two indices must be the same if they are not scev, or not scev wrto\n+\t current loop being vecorized.  */\n+      if (TREE_CODE (access1) != POLYNOMIAL_CHREC\n+\t  || TREE_CODE (access2) != POLYNOMIAL_CHREC\n+\t  || CHREC_VARIABLE (access1) != (unsigned)loop->num\n+\t  || CHREC_VARIABLE (access2) != (unsigned)loop->num)\n+\t{\n+\t  if (operand_equal_p (access1, access2, 0))\n+\t    continue;\n+\n+\t  return false;\n+\t}\n+      /* The two indices must have the same step.  */\n+      if (!operand_equal_p (CHREC_RIGHT (access1), CHREC_RIGHT (access2), 0))\n+\treturn false;\n+\n+      tree idx_step = CHREC_RIGHT (access1);\n+      /* Index must have const step, otherwise DR_STEP won't be constant.  */\n+      gcc_assert (TREE_CODE (idx_step) == INTEGER_CST);\n+      /* Index must evaluate in the same direction as DR.  */\n+      gcc_assert (!neg_step || tree_int_cst_sign_bit (idx_step) == 1);\n+\n+      tree min1 = CHREC_LEFT (access1);\n+      tree min2 = CHREC_LEFT (access2);\n+      if (!types_compatible_p (TREE_TYPE (min1), TREE_TYPE (min2)))\n+\treturn false;\n+\n+      /* Ideally, alias can be checked against loop's control IV, but we\n+\t need to prove linear mapping between control IV and reference\n+\t index.  Although that should be true, we check against (array)\n+\t index of data reference.  Like segment length, index length is\n+\t linear function of the number of iterations with index_step as\n+\t the coefficient, i.e, niter_len * idx_step.  */\n+      tree idx_len1 = fold_build2 (MULT_EXPR, TREE_TYPE (min1), idx_step,\n+\t\t\t\t   build_int_cst (TREE_TYPE (min1),\n+\t\t\t\t\t\t  niter_len1));\n+      tree idx_len2 = fold_build2 (MULT_EXPR, TREE_TYPE (min2), idx_step,\n+\t\t\t\t   build_int_cst (TREE_TYPE (min2),\n+\t\t\t\t\t\t  niter_len2));\n+      tree max1 = fold_build2 (PLUS_EXPR, TREE_TYPE (min1), min1, idx_len1);\n+      tree max2 = fold_build2 (PLUS_EXPR, TREE_TYPE (min2), min2, idx_len2);\n+      /* Adjust ranges for negative step.  */\n+      if (neg_step)\n+\t{\n+\t  min1 = fold_build2 (MINUS_EXPR, TREE_TYPE (min1), max1, idx_step);\n+\t  max1 = fold_build2 (MINUS_EXPR, TREE_TYPE (min1),\n+\t\t\t      CHREC_LEFT (access1), idx_step);\n+\t  min2 = fold_build2 (MINUS_EXPR, TREE_TYPE (min2), max2, idx_step);\n+\t  max2 = fold_build2 (MINUS_EXPR, TREE_TYPE (min2),\n+\t\t\t      CHREC_LEFT (access2), idx_step);\n+\t}\n+      tree part_cond_expr\n+\t= fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t    fold_build2 (LE_EXPR, boolean_type_node, max1, min2),\n+\t    fold_build2 (LE_EXPR, boolean_type_node, max2, min1));\n+      if (*cond_expr)\n+\t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t  *cond_expr, part_cond_expr);\n+      else\n+\t*cond_expr = part_cond_expr;\n+    }\n+  return true;\n+}\n+\n+/* Given two data references and segment lengths described by DR_A and DR_B,\n+   create expression checking if the two addresses ranges intersect with\n+   each other:\n+\n+     ((DR_A_addr_0 + DR_A_segment_length_0) <= DR_B_addr_0)\n+     || (DR_B_addr_0 + DER_B_segment_length_0) <= DR_A_addr_0))  */\n+\n+static void\n+create_intersect_range_checks (struct loop *loop, tree *cond_expr,\n+\t\t\t       const dr_with_seg_len& dr_a,\n+\t\t\t       const dr_with_seg_len& dr_b)\n+{\n+  *cond_expr = NULL_TREE;\n+  if (create_intersect_range_checks_index (loop, cond_expr, dr_a, dr_b))\n+    return;\n+\n+  tree segment_length_a = dr_a.seg_len;\n+  tree segment_length_b = dr_b.seg_len;\n+  tree addr_base_a = DR_BASE_ADDRESS (dr_a.dr);\n+  tree addr_base_b = DR_BASE_ADDRESS (dr_b.dr);\n+  tree offset_a = DR_OFFSET (dr_a.dr), offset_b = DR_OFFSET (dr_b.dr);\n+\n+  offset_a = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_a),\n+\t\t\t  offset_a, DR_INIT (dr_a.dr));\n+  offset_b = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_b),\n+\t\t\t  offset_b, DR_INIT (dr_b.dr));\n+  addr_base_a = fold_build_pointer_plus (addr_base_a, offset_a);\n+  addr_base_b = fold_build_pointer_plus (addr_base_b, offset_b);\n+\n+  tree seg_a_min = addr_base_a;\n+  tree seg_a_max = fold_build_pointer_plus (addr_base_a, segment_length_a);\n+  /* For negative step, we need to adjust address range by TYPE_SIZE_UNIT\n+     bytes, e.g., int a[3] -> a[1] range is [a+4, a+16) instead of\n+     [a, a+12) */\n+  if (tree_int_cst_compare (DR_STEP (dr_a.dr), size_zero_node) < 0)\n+    {\n+      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a.dr)));\n+      seg_a_min = fold_build_pointer_plus (seg_a_max, unit_size);\n+      seg_a_max = fold_build_pointer_plus (addr_base_a, unit_size);\n+    }\n+\n+  tree seg_b_min = addr_base_b;\n+  tree seg_b_max = fold_build_pointer_plus (addr_base_b, segment_length_b);\n+  if (tree_int_cst_compare (DR_STEP (dr_b.dr), size_zero_node) < 0)\n+    {\n+      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_b.dr)));\n+      seg_b_min = fold_build_pointer_plus (seg_b_max, unit_size);\n+      seg_b_max = fold_build_pointer_plus (addr_base_b, unit_size);\n+    }\n+  *cond_expr\n+    = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\tfold_build2 (LE_EXPR, boolean_type_node, seg_a_max, seg_b_min),\n+\tfold_build2 (LE_EXPR, boolean_type_node, seg_b_max, seg_a_min));\n+}\n+\n+/* Create a conditional expression that represents the run-time checks for\n+   overlapping of address ranges represented by a list of data references\n+   pairs passed in ALIAS_PAIRS.  Data references are in LOOP.  The returned\n+   COND_EXPR is the conditional expression to be used in the if statement\n+   that controls which version of the loop gets executed at runtime.  */\n+\n+void\n+create_runtime_alias_checks (struct loop *loop,\n+\t\t\t     vec<dr_with_seg_len_pair_t> *alias_pairs,\n+\t\t\t     tree * cond_expr)\n+{\n+  tree part_cond_expr;\n+\n+  for (size_t i = 0, s = alias_pairs->length (); i < s; ++i)\n+    {\n+      const dr_with_seg_len& dr_a = (*alias_pairs)[i].first;\n+      const dr_with_seg_len& dr_b = (*alias_pairs)[i].second;\n+\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf (MSG_NOTE, \"create runtime check for data references \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a.dr));\n+\t  dump_printf (MSG_NOTE, \" and \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b.dr));\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t}\n+\n+      /* Create condition expression for each pair data references.  */\n+      create_intersect_range_checks (loop, &part_cond_expr, dr_a, dr_b);\n+      if (*cond_expr)\n+\t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t  *cond_expr, part_cond_expr);\n+      else\n+\t*cond_expr = part_cond_expr;\n+    }\n+}\n+\n /* Check if OFFSET1 and OFFSET2 (DR_OFFSETs of some data-refs) are identical\n    expressions.  */\n static bool"}, {"sha": "1d8e01dd7fe885758ef5cedfe2035ea13873e817", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cbd2d979c5e7095530a6fc290615847d31b549d/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cbd2d979c5e7095530a6fc290615847d31b549d/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=9cbd2d979c5e7095530a6fc290615847d31b549d", "patch": "@@ -371,6 +371,8 @@ extern bool dr_equal_offsets_p (struct data_reference *,\n extern int data_ref_compare_tree (tree, tree);\n extern void prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *,\n \t\t\t\t\t   unsigned HOST_WIDE_INT);\n+extern void create_runtime_alias_checks (struct loop *,\n+\t\t\t\t\t vec<dr_with_seg_len_pair_t> *, tree*);\n /* Return true when the base objects of data references A and B are\n    the same memory object.  */\n "}, {"sha": "42b9f48dbf4145ea273f2119820f858333bddf8a", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 2, "deletions": 214, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cbd2d979c5e7095530a6fc290615847d31b549d/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cbd2d979c5e7095530a6fc290615847d31b549d/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=9cbd2d979c5e7095530a6fc290615847d31b549d", "patch": "@@ -2044,194 +2044,6 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n     *cond_expr = part_cond_expr;\n }\n \n-/* Given LOOP's two data references and segment lengths described by DR_A\n-   and DR_B, create expression checking if the two addresses ranges intersect\n-   with each other based on index of the two addresses.  This can only be\n-   done if DR_A and DR_B referring to the same (array) object and the index\n-   is the only difference.  For example:\n-\n-                       DR_A                           DR_B\n-      data-ref         arr[i]                         arr[j]\n-      base_object      arr                            arr\n-      index            {i_0, +, 1}_loop               {j_0, +, 1}_loop\n-\n-   The addresses and their index are like:\n-\n-        |<- ADDR_A    ->|          |<- ADDR_B    ->|\n-     ------------------------------------------------------->\n-        |   |   |   |   |          |   |   |   |   |\n-     ------------------------------------------------------->\n-        i_0 ...         i_0+4      j_0 ...         j_0+4\n-\n-   We can create expression based on index rather than address:\n-\n-     (i_0 + 4 < j_0 || j_0 + 4 < i_0)\n-\n-   Note evolution step of index needs to be considered in comparison.  */\n-\n-static bool\n-create_intersect_range_checks_index (struct loop *loop, tree *cond_expr,\n-\t\t\t\t     const dr_with_seg_len& dr_a,\n-\t\t\t\t     const dr_with_seg_len& dr_b)\n-{\n-  if (integer_zerop (DR_STEP (dr_a.dr))\n-      || integer_zerop (DR_STEP (dr_b.dr))\n-      || DR_NUM_DIMENSIONS (dr_a.dr) != DR_NUM_DIMENSIONS (dr_b.dr))\n-    return false;\n-\n-  if (!tree_fits_uhwi_p (dr_a.seg_len) || !tree_fits_uhwi_p (dr_b.seg_len))\n-    return false;\n-\n-  if (!tree_fits_shwi_p (DR_STEP (dr_a.dr)))\n-    return false;\n-\n-  if (!operand_equal_p (DR_BASE_OBJECT (dr_a.dr), DR_BASE_OBJECT (dr_b.dr), 0))\n-    return false;\n-\n-  if (!operand_equal_p (DR_STEP (dr_a.dr), DR_STEP (dr_b.dr), 0))\n-    return false;\n-\n-  gcc_assert (TREE_CODE (DR_STEP (dr_a.dr)) == INTEGER_CST);\n-\n-  bool neg_step = tree_int_cst_compare (DR_STEP (dr_a.dr), size_zero_node) < 0;\n-  unsigned HOST_WIDE_INT abs_step\n-    = absu_hwi (tree_to_shwi (DR_STEP (dr_a.dr)));\n-\n-  unsigned HOST_WIDE_INT seg_len1 = tree_to_uhwi (dr_a.seg_len);\n-  unsigned HOST_WIDE_INT seg_len2 = tree_to_uhwi (dr_b.seg_len);\n-  /* Infer the number of iterations with which the memory segment is accessed\n-     by DR.  In other words, alias is checked if memory segment accessed by\n-     DR_A in some iterations intersect with memory segment accessed by DR_B\n-     in the same amount iterations.\n-     Note segnment length is a linear function of number of iterations with\n-     DR_STEP as the coefficient.  */\n-  unsigned HOST_WIDE_INT niter_len1 = (seg_len1 + abs_step - 1) / abs_step;\n-  unsigned HOST_WIDE_INT niter_len2 = (seg_len2 + abs_step - 1) / abs_step;\n-\n-  unsigned int i;\n-  for (i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)\n-    {\n-      tree access1 = DR_ACCESS_FN (dr_a.dr, i);\n-      tree access2 = DR_ACCESS_FN (dr_b.dr, i);\n-      /* Two indices must be the same if they are not scev, or not scev wrto\n-\t current loop being vecorized.  */\n-      if (TREE_CODE (access1) != POLYNOMIAL_CHREC\n-\t  || TREE_CODE (access2) != POLYNOMIAL_CHREC\n-\t  || CHREC_VARIABLE (access1) != (unsigned)loop->num\n-\t  || CHREC_VARIABLE (access2) != (unsigned)loop->num)\n-\t{\n-\t  if (operand_equal_p (access1, access2, 0))\n-\t    continue;\n-\n-\t  return false;\n-\t}\n-      /* The two indices must have the same step.  */\n-      if (!operand_equal_p (CHREC_RIGHT (access1), CHREC_RIGHT (access2), 0))\n-\treturn false;\n-\n-      tree idx_step = CHREC_RIGHT (access1);\n-      /* Index must have const step, otherwise DR_STEP won't be constant.  */\n-      gcc_assert (TREE_CODE (idx_step) == INTEGER_CST);\n-      /* Index must evaluate in the same direction as DR.  */\n-      gcc_assert (!neg_step || tree_int_cst_sign_bit (idx_step) == 1);\n-\n-      tree min1 = CHREC_LEFT (access1);\n-      tree min2 = CHREC_LEFT (access2);\n-      if (!types_compatible_p (TREE_TYPE (min1), TREE_TYPE (min2)))\n-\treturn false;\n-\n-      /* Ideally, alias can be checked against loop's control IV, but we\n-\t need to prove linear mapping between control IV and reference\n-\t index.  Although that should be true, we check against (array)\n-\t index of data reference.  Like segment length, index length is\n-\t linear function of the number of iterations with index_step as\n-\t the coefficient, i.e, niter_len * idx_step.  */\n-      tree idx_len1 = fold_build2 (MULT_EXPR, TREE_TYPE (min1), idx_step,\n-\t\t\t\t   build_int_cst (TREE_TYPE (min1),\n-\t\t\t\t\t\t  niter_len1));\n-      tree idx_len2 = fold_build2 (MULT_EXPR, TREE_TYPE (min2), idx_step,\n-\t\t\t\t   build_int_cst (TREE_TYPE (min2),\n-\t\t\t\t\t\t  niter_len2));\n-      tree max1 = fold_build2 (PLUS_EXPR, TREE_TYPE (min1), min1, idx_len1);\n-      tree max2 = fold_build2 (PLUS_EXPR, TREE_TYPE (min2), min2, idx_len2);\n-      /* Adjust ranges for negative step.  */\n-      if (neg_step)\n-\t{\n-\t  min1 = fold_build2 (MINUS_EXPR, TREE_TYPE (min1), max1, idx_step);\n-\t  max1 = fold_build2 (MINUS_EXPR, TREE_TYPE (min1),\n-\t\t\t      CHREC_LEFT (access1), idx_step);\n-\t  min2 = fold_build2 (MINUS_EXPR, TREE_TYPE (min2), max2, idx_step);\n-\t  max2 = fold_build2 (MINUS_EXPR, TREE_TYPE (min2),\n-\t\t\t      CHREC_LEFT (access2), idx_step);\n-\t}\n-      tree part_cond_expr\n-\t= fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t    fold_build2 (LE_EXPR, boolean_type_node, max1, min2),\n-\t    fold_build2 (LE_EXPR, boolean_type_node, max2, min1));\n-      if (*cond_expr)\n-\t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t  *cond_expr, part_cond_expr);\n-      else\n-\t*cond_expr = part_cond_expr;\n-    }\n-  return true;\n-}\n-\n-/* Given two data references and segment lengths described by DR_A and DR_B,\n-   create expression checking if the two addresses ranges intersect with\n-   each other:\n-\n-     ((DR_A_addr_0 + DR_A_segment_length_0) <= DR_B_addr_0)\n-     || (DR_B_addr_0 + DER_B_segment_length_0) <= DR_A_addr_0))  */\n-\n-static void\n-create_intersect_range_checks (struct loop *loop, tree *cond_expr,\n-\t\t\t       const dr_with_seg_len& dr_a,\n-\t\t\t       const dr_with_seg_len& dr_b)\n-{\n-  *cond_expr = NULL_TREE;\n-  if (create_intersect_range_checks_index (loop, cond_expr, dr_a, dr_b))\n-    return;\n-\n-  tree segment_length_a = dr_a.seg_len;\n-  tree segment_length_b = dr_b.seg_len;\n-  tree addr_base_a = DR_BASE_ADDRESS (dr_a.dr);\n-  tree addr_base_b = DR_BASE_ADDRESS (dr_b.dr);\n-  tree offset_a = DR_OFFSET (dr_a.dr), offset_b = DR_OFFSET (dr_b.dr);\n-\n-  offset_a = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_a),\n-\t\t\t  offset_a, DR_INIT (dr_a.dr));\n-  offset_b = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_b),\n-\t\t\t  offset_b, DR_INIT (dr_b.dr));\n-  addr_base_a = fold_build_pointer_plus (addr_base_a, offset_a);\n-  addr_base_b = fold_build_pointer_plus (addr_base_b, offset_b);\n-\n-  tree seg_a_min = addr_base_a;\n-  tree seg_a_max = fold_build_pointer_plus (addr_base_a, segment_length_a);\n-  /* For negative step, we need to adjust address range by TYPE_SIZE_UNIT\n-     bytes, e.g., int a[3] -> a[1] range is [a+4, a+16) instead of\n-     [a, a+12) */\n-  if (tree_int_cst_compare (DR_STEP (dr_a.dr), size_zero_node) < 0)\n-    {\n-      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a.dr)));\n-      seg_a_min = fold_build_pointer_plus (seg_a_max, unit_size);\n-      seg_a_max = fold_build_pointer_plus (addr_base_a, unit_size);\n-    }\n-\n-  tree seg_b_min = addr_base_b;\n-  tree seg_b_max = fold_build_pointer_plus (addr_base_b, segment_length_b);\n-  if (tree_int_cst_compare (DR_STEP (dr_b.dr), size_zero_node) < 0)\n-    {\n-      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_b.dr)));\n-      seg_b_min = fold_build_pointer_plus (seg_b_max, unit_size);\n-      seg_b_max = fold_build_pointer_plus (addr_base_b, unit_size);\n-    }\n-  *cond_expr\n-    = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\tfold_build2 (LE_EXPR, boolean_type_node, seg_a_max, seg_b_min),\n-\tfold_build2 (LE_EXPR, boolean_type_node, seg_b_max, seg_a_min));\n-}\n-\n /* Function vect_create_cond_for_alias_checks.\n \n    Create a conditional expression that represents the run-time checks for\n@@ -2257,36 +2069,12 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n {\n   vec<dr_with_seg_len_pair_t> comp_alias_ddrs =\n     LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo);\n-  tree part_cond_expr;\n \n   if (comp_alias_ddrs.is_empty ())\n     return;\n \n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  for (size_t i = 0, s = comp_alias_ddrs.length (); i < s; ++i)\n-    {\n-      const dr_with_seg_len& dr_a = comp_alias_ddrs[i].first;\n-      const dr_with_seg_len& dr_b = comp_alias_ddrs[i].second;\n-\n-      if (dump_enabled_p ())\n-\t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t   \"create runtime check for data references \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a.dr));\n-\t  dump_printf (MSG_NOTE, \" and \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b.dr));\n-\t  dump_printf (MSG_NOTE, \"\\n\");\n-\t}\n-\n-      /* Create condition expression for each pair data references.  */\n-      create_intersect_range_checks (loop, &part_cond_expr, dr_a, dr_b);\n-      if (*cond_expr)\n-\t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t  *cond_expr, part_cond_expr);\n-      else\n-\t*cond_expr = part_cond_expr;\n-    }\n-\n+  create_runtime_alias_checks (LOOP_VINFO_LOOP (loop_vinfo),\n+\t\t\t       &comp_alias_ddrs, cond_expr);\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"created %u versioning for alias checks.\\n\","}]}