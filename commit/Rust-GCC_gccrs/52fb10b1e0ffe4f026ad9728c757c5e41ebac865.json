{"sha": "52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJmYjEwYjFlMGZmZTRmMDI2YWQ5NzI4Yzc1N2M1ZTQxZWJhYzg2NQ==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-08T12:23:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-08T12:23:49Z"}, "message": "Merge #656\n\n656: Add mangling switch r=philberty a=CohenArthur\n\nAdd option to choose mangling scheme.\r\n\r\nCloses #429 \r\n\r\nThis PR splits the `Mangler` class in its own set of header and source and adds the base for v0 name mangling.\r\n\r\nYou are now able to specify the mangling scheme to use using `-frust-mangling=<value>`.\r\n\r\nWhen inputting an invalid value, the compiler errors out using `unrecognized command-line option `-frust-mangling=<not_valid>`. Is there a better way to do this? Is there also a way to test this behaviour using dejagnu?\n\nCo-authored-by: CohenArthur <arthur.cohen@epita.fr>", "tree": {"sha": "70e1e0d3107c9307da1cda36f69f9b6a68ad2c02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70e1e0d3107c9307da1cda36f69f9b6a68ad2c02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhOKtVCRBK7hj4Ov3rIwAAQJcIAG4sH1GUCRHYOfGz665HpBbp\nKHh6dw8DZa539wOgX0qr4qCNiRZiEArdYYd9yd/k/jrxFlByGMMgqoyNZPdiQovD\n1NESkoeieu2K+JxwOaaTCn7wEs2lLPrL8RE8V/tbx3q+b5GYfm/DyGS/Y1edsYr/\nMchc2lX3ajspTav0JRWlmcTyBkuhutiK92MjgND1NKgSJnDr3DDk/L3hiNQP0k7u\nWEqsOOcbW+5+ix0eUx9bvScwOxprXsx4VAh/edvs+613+Jv7TYD4jRr0NP6jCMYh\nvmB2WCRHflF3YekVDn0eHpXWU9aZPOO1hlTNJG3NLjX/XyE4TuRSk2YFFRwffNk=\n=bWnL\n-----END PGP SIGNATURE-----\n", "payload": "tree 70e1e0d3107c9307da1cda36f69f9b6a68ad2c02\nparent 8a9271e1921d0eac46bda889da6508cf94d32682\nparent 37f3b02bf8edbf707e6156feec593b9b0d7da027\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631103829 +0000\ncommitter GitHub <noreply@github.com> 1631103829 +0000\n\nMerge #656\n\n656: Add mangling switch r=philberty a=CohenArthur\n\nAdd option to choose mangling scheme.\r\n\r\nCloses #429 \r\n\r\nThis PR splits the `Mangler` class in its own set of header and source and adds the base for v0 name mangling.\r\n\r\nYou are now able to specify the mangling scheme to use using `-frust-mangling=<value>`.\r\n\r\nWhen inputting an invalid value, the compiler errors out using `unrecognized command-line option `-frust-mangling=<not_valid>`. Is there a better way to do this? Is there also a way to test this behaviour using dejagnu?\n\nCo-authored-by: CohenArthur <arthur.cohen@epita.fr>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a9271e1921d0eac46bda889da6508cf94d32682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9271e1921d0eac46bda889da6508cf94d32682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a9271e1921d0eac46bda889da6508cf94d32682"}, {"sha": "37f3b02bf8edbf707e6156feec593b9b0d7da027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37f3b02bf8edbf707e6156feec593b9b0d7da027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37f3b02bf8edbf707e6156feec593b9b0d7da027"}], "stats": {"total": 341, "additions": 234, "deletions": 107}, "files": [{"sha": "14294f3fc3e1d63b9ff53b7cccb289c76bb675de", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "patch": "@@ -70,6 +70,7 @@ GRS_OBJS = \\\n     rust/rust-ast-full-test.o \\\n     rust/rust-session-manager.o \\\n     rust/rust-compile.o \\\n+    rust/rust-mangle.o \\\n     rust/rust-compile-resolve-path.o \\\n     rust/rust-macro-expand.o \\\n     rust/rust-hir-full-test.o \\"}, {"sha": "05c15e3c7ea50d6052a5f16f3a6af827739e9fa9", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "patch": "@@ -28,6 +28,7 @@\n #include \"rust-ast-full.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-hir-const-fold-ctx.h\"\n+#include \"rust-mangle.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -45,7 +46,7 @@ class Context\n     : backend (backend), resolver (Resolver::Resolver::get ()),\n       tyctx (Resolver::TypeCheckContext::get ()),\n       mappings (Analysis::Mappings::get ()),\n-      const_ctx (ConstFold::Context::get ())\n+      const_ctx (ConstFold::Context::get ()), mangler (Mangler ())\n   {\n     // insert the builtins\n     auto builtins = resolver->get_builtin_types ();\n@@ -285,13 +286,19 @@ class Context\n     return pop;\n   }\n \n-  // this needs to support Legacy and V0 see github #429 or #305\n   std::string mangle_item (const TyTy::BaseType *ty,\n-\t\t\t   const Resolver::CanonicalPath &path) const;\n+\t\t\t   const Resolver::CanonicalPath &path) const\n+  {\n+    return mangler.mangle_item (ty, path, mappings->get_current_crate_name ());\n+  }\n \n   std::string mangle_impl_item (const TyTy::BaseType *self,\n \t\t\t\tconst TyTy::BaseType *ty,\n-\t\t\t\tconst std::string &name) const;\n+\t\t\t\tconst std::string &name) const\n+  {\n+    return mangler.mangle_impl_item (self, ty, name,\n+\t\t\t\t     mappings->get_current_crate_name ());\n+  }\n \n private:\n   ::Backend *backend;\n@@ -300,6 +307,7 @@ class Context\n   Analysis::Mappings *mappings;\n   ConstFold::Context *const_ctx;\n   std::set<HirId> builtin_range;\n+  Mangler mangler;\n \n   // state\n   std::vector<fncontext> fn_stack;"}, {"sha": "ef2c16a1ed5a97785261b2fe7cd81e1f371c17fa", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "patch": "@@ -22,7 +22,6 @@\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n-#include \"fnv-hash.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -538,107 +537,5 @@ HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n \n   return true;\n }\n-\n-// Mr Mangle time\n-\n-static const std::string kMangledSymbolPrefix = \"_ZN\";\n-static const std::string kMangledSymbolDelim = \"E\";\n-static const std::string kMangledGenericDelim = \"$C$\";\n-static const std::string kMangledSubstBegin = \"$LT$\";\n-static const std::string kMangledSubstEnd = \"$GT$\";\n-\n-static std::string\n-mangle_name (const std::string &name)\n-{\n-  return std::to_string (name.size ()) + name;\n-}\n-\n-static std::string\n-mangle_canonical_path (const Resolver::CanonicalPath &path)\n-{\n-  std::string buffer;\n-  path.iterate_segs ([&] (const Resolver::CanonicalPath &p) -> bool {\n-    buffer += mangle_name (p.get ());\n-    return true;\n-  });\n-  return buffer;\n-}\n-\n-// rustc uses a sip128 hash for legacy mangling, but an fnv 128 was quicker to\n-// implement for now\n-static std::string\n-legacy_hash (const std::string &fingerprint)\n-{\n-  Hash::FNV128 hasher;\n-  hasher.write ((const unsigned char *) fingerprint.c_str (),\n-\t\tfingerprint.size ());\n-\n-  uint64_t hi, lo;\n-  hasher.sum (&hi, &lo);\n-\n-  char hex[16 + 1];\n-  memset (hex, 0, sizeof hex);\n-  snprintf (hex, sizeof hex, \"%08\" PRIx64 \"%08\" PRIx64, lo, hi);\n-\n-  return \"h\" + std::string (hex, sizeof (hex) - 1);\n-}\n-\n-static std::string\n-mangle_self (const TyTy::BaseType *self)\n-{\n-  if (self->get_kind () != TyTy::TypeKind::ADT)\n-    return mangle_name (self->get_name ());\n-\n-  const TyTy::ADTType *s = static_cast<const TyTy::ADTType *> (self);\n-  std::string buf = s->get_identifier ();\n-\n-  if (s->has_subsititions_defined ())\n-    {\n-      buf += kMangledSubstBegin;\n-\n-      const std::vector<TyTy::SubstitutionParamMapping> &params\n-\t= s->get_substs ();\n-      for (size_t i = 0; i < params.size (); i++)\n-\t{\n-\t  const TyTy::SubstitutionParamMapping &sub = params.at (i);\n-\t  buf += sub.as_string ();\n-\n-\t  if ((i + 1) < params.size ())\n-\t    buf += kMangledGenericDelim;\n-\t}\n-\n-      buf += kMangledSubstEnd;\n-    }\n-\n-  return mangle_name (buf);\n-}\n-\n-std::string\n-Context::mangle_item (const TyTy::BaseType *ty,\n-\t\t      const Resolver::CanonicalPath &path) const\n-{\n-  const std::string &crate_name = mappings->get_current_crate_name ();\n-\n-  const std::string hash = legacy_hash (ty->as_string ());\n-  const std::string hash_sig = mangle_name (hash);\n-\n-  return kMangledSymbolPrefix + mangle_name (crate_name)\n-\t + mangle_canonical_path (path) + hash_sig + kMangledSymbolDelim;\n-}\n-\n-// FIXME this is a wee bit broken\n-std::string\n-Context::mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n-\t\t\t   const std::string &name) const\n-{\n-  const std::string &crate_name = mappings->get_current_crate_name ();\n-\n-  const std::string hash = legacy_hash (ty->as_string ());\n-  const std::string hash_sig = mangle_name (hash);\n-\n-  return kMangledSymbolPrefix + mangle_name (crate_name) + mangle_self (self)\n-\t + mangle_name (name) + hash_sig + kMangledSymbolDelim;\n-}\n-\n } // namespace Compile\n } // namespace Rust"}, {"sha": "40822b4be7b1681a7878d02d1c3d87b279a88593", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "patch": "@@ -0,0 +1,152 @@\n+#include \"rust-mangle.h\"\n+#include \"fnv-hash.h\"\n+\n+// FIXME: Rename those to legacy_*\n+static const std::string kMangledSymbolPrefix = \"_ZN\";\n+static const std::string kMangledSymbolDelim = \"E\";\n+static const std::string kMangledGenericDelim = \"$C$\";\n+static const std::string kMangledSubstBegin = \"$LT$\";\n+static const std::string kMangledSubstEnd = \"$GT$\";\n+\n+namespace Rust {\n+namespace Compile {\n+\n+Mangler::MangleVersion Mangler::version = MangleVersion::LEGACY;\n+\n+static std::string\n+legacy_mangle_name (const std::string &name)\n+{\n+  return std::to_string (name.size ()) + name;\n+}\n+\n+static std::string\n+legacy_mangle_canonical_path (const Resolver::CanonicalPath &path)\n+{\n+  std::string buffer;\n+  path.iterate_segs ([&] (const Resolver::CanonicalPath &p) -> bool {\n+    buffer += legacy_mangle_name (p.get ());\n+    return true;\n+  });\n+  return buffer;\n+}\n+\n+// rustc uses a sip128 hash for legacy mangling, but an fnv 128 was quicker to\n+// implement for now\n+static std::string\n+legacy_hash (const std::string &fingerprint)\n+{\n+  Hash::FNV128 hasher;\n+  hasher.write ((const unsigned char *) fingerprint.c_str (),\n+\t\tfingerprint.size ());\n+\n+  uint64_t hi, lo;\n+  hasher.sum (&hi, &lo);\n+\n+  char hex[16 + 1];\n+  memset (hex, 0, sizeof hex);\n+  snprintf (hex, sizeof hex, \"%08\" PRIx64 \"%08\" PRIx64, lo, hi);\n+\n+  return \"h\" + std::string (hex, sizeof (hex) - 1);\n+}\n+\n+static std::string\n+legacy_mangle_self (const TyTy::BaseType *self)\n+{\n+  if (self->get_kind () != TyTy::TypeKind::ADT)\n+    return legacy_mangle_name (self->get_name ());\n+\n+  const TyTy::ADTType *s = static_cast<const TyTy::ADTType *> (self);\n+  std::string buf = s->get_identifier ();\n+\n+  if (s->has_subsititions_defined ())\n+    {\n+      buf += kMangledSubstBegin;\n+\n+      const std::vector<TyTy::SubstitutionParamMapping> &params\n+\t= s->get_substs ();\n+      for (size_t i = 0; i < params.size (); i++)\n+\t{\n+\t  const TyTy::SubstitutionParamMapping &sub = params.at (i);\n+\t  buf += sub.as_string ();\n+\n+\t  if ((i + 1) < params.size ())\n+\t    buf += kMangledGenericDelim;\n+\t}\n+\n+      buf += kMangledSubstEnd;\n+    }\n+\n+  return legacy_mangle_name (buf);\n+}\n+\n+static std::string\n+legacy_mangle_item (const TyTy::BaseType *ty,\n+\t\t    const Resolver::CanonicalPath &path,\n+\t\t    const std::string &crate_name)\n+{\n+  const std::string hash = legacy_hash (ty->as_string ());\n+  const std::string hash_sig = legacy_mangle_name (hash);\n+\n+  return kMangledSymbolPrefix + legacy_mangle_name (crate_name)\n+\t + legacy_mangle_canonical_path (path) + hash_sig + kMangledSymbolDelim;\n+}\n+\n+// FIXME this is a wee bit broken\n+static std::string\n+legacy_mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n+\t\t\t const std::string &name, const std::string &crate_name)\n+{\n+  const std::string hash = legacy_hash (ty->as_string ());\n+  const std::string hash_sig = legacy_mangle_name (hash);\n+\n+  return kMangledSymbolPrefix + legacy_mangle_name (crate_name)\n+\t + legacy_mangle_self (self) + legacy_mangle_name (name) + hash_sig\n+\t + kMangledSymbolDelim;\n+}\n+\n+// FIXME: Uncomment once v0 mangling is implemented\n+// static std::string\n+// Mangler::v0_mangle_item (const TyTy::BaseType *ty,\n+// \t\t\t const std::string &name)\n+// {}\n+//\n+// static std::string\n+// Mangler::v0_mangle_impl_item (const TyTy::BaseType *self,\n+// \t\t\t      const TyTy::BaseType *ty,\n+// \t\t\t      const std::string &name)\n+// {}\n+\n+std::string\n+Mangler::mangle_item (const TyTy::BaseType *ty,\n+\t\t      const Resolver::CanonicalPath &path,\n+\t\t      const std::string &crate_name) const\n+{\n+  switch (version)\n+    {\n+    case Mangler::MangleVersion::LEGACY:\n+      return legacy_mangle_item (ty, path, crate_name);\n+    case Mangler::MangleVersion::V0:\n+      gcc_unreachable ();\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+std::string\n+Mangler::mangle_impl_item (const TyTy::BaseType *self, const TyTy::BaseType *ty,\n+\t\t\t   const std::string &name,\n+\t\t\t   const std::string &crate_name) const\n+{\n+  switch (version)\n+    {\n+    case Mangler::MangleVersion::LEGACY:\n+      return legacy_mangle_impl_item (self, ty, name, crate_name);\n+    case Mangler::MangleVersion::V0:\n+      gcc_unreachable ();\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "9e77c54423189bfdff9e41292273099c1bf6d7dd", "filename": "gcc/rust/backend/rust-mangle.h", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Fbackend%2Frust-mangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Fbackend%2Frust-mangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.h?ref=52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "patch": "@@ -0,0 +1,54 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_MANGLE_H\n+#define RUST_MANGLE_H\n+\n+#include \"rust-compile-tyty.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+class Mangler\n+{\n+public:\n+  enum MangleVersion\n+  {\n+    // Values defined in rust/lang.opt\n+    LEGACY = 0,\n+    V0 = 1,\n+  };\n+\n+  // this needs to support Legacy and V0 see github #429 or #305\n+  std::string mangle_item (const TyTy::BaseType *ty,\n+\t\t\t   const Resolver::CanonicalPath &path,\n+\t\t\t   const std::string &crate_name) const;\n+\n+  std::string mangle_impl_item (const TyTy::BaseType *self,\n+\t\t\t\tconst TyTy::BaseType *ty,\n+\t\t\t\tconst std::string &name,\n+\t\t\t\tconst std::string &crate_name) const;\n+\n+  static void set_mangling (int frust_mangling_value)\n+  {\n+    version = static_cast<MangleVersion> (frust_mangling_value);\n+  }\n+\n+private:\n+  static enum MangleVersion version;\n+};\n+} // namespace Compile\n+} // namespace Rust\n+#endif // RUST_MANGLE_H"}, {"sha": "27e3c443b386ffd99d8d21893f6366813771ba43", "filename": "gcc/rust/lang.opt", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang.opt?ref=52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "patch": "@@ -43,6 +43,19 @@ frust-dump-\n Rust Joined RejectNegative\n -frust-dump-<type>\tDump Rust frontend internal information.\n \n+frust-mangling=\n+Rust Joined RejectNegative Enum(frust_mangling) Var(flag_rust_mangling)\n+-frust-mangling=[legacy|v0]     Choose which version to use for name mangling\n+\n+Enum\n+Name(frust_mangling) Type(int) UnknownError(unknown rust mangling option %qs)\n+\n+EnumValue\n+Enum(frust_mangling) String(legacy) Value(0)\n+\n+EnumValue\n+Enum(frust_mangling) String(v0) Value(1)\n+\n o\n Rust Joined Separate\n ; Documented in common.opt"}, {"sha": "a924c4b9581c26106472215e2eed551f3d8ecdc2", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52fb10b1e0ffe4f026ad9728c757c5e41ebac865/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=52fb10b1e0ffe4f026ad9728c757c5e41ebac865", "patch": "@@ -370,6 +370,8 @@ Session::handle_option (\n \t  ret = false;\n \t}\n       break;\n+    case OPT_frust_mangling_:\n+      Compile::Mangler::set_mangling (flag_rust_mangling);\n     // no option handling for -o\n     default:\n       // return 1 to indicate option is valid"}]}